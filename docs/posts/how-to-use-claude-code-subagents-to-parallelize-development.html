<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zachwills.net/how-to-use-claude-code-subagents-to-parallelize-development/">Original</a>
    <h1>How to use Claude Code subagents to parallelize development</h1>
    
    <div id="readability-page-1" class="page"><div>

		<div>

			
<p>In <a href="https://zachwills.net/i-managed-a-swarm-of-20-ai-agents-for-a-week-here-are-the-8-rules-i-learned/">my last post</a> I talked about how I spent a week heads down using AI to work on a greenfield engineering metrics tool. As I built it, I‚Äôd often navigate the web app and spot things that needed to be fleshed out. Sometimes it was a small typo; other times it was a bigger feature that was still TODO.</p>



<p>At one point I had Claude Code redesign the homepage to make it more lively. In doing so, it added some new functionality that didn‚Äôt fully exist yet: A ‚ÄúView All Insights‚Äù link that would show you all the AI-generated analyses about a given pull request or piece of work. Since I hadn‚Äôt actually built the page for it yet, it led to a 404.</p>



<p>Traditionally, fixing this would kick off a whole sequence of events. I‚Äôd have to scope out the feature, think about the UI, define the API needs, and write a detailed ticket. Then, I‚Äôd need to build the backend endpoint, create the UI components, and wire everything together. It‚Äôs a linear, manual process.</p>



<p>Instead, I took a different approach. I ran a single custom command to generate a ticket for the new page. This command invoked several specialist sub-agents (you can find their .md definitions in the appendix)‚Äîa <code>product-manager</code>, a <code>ux-designer</code>, and a <code>senior-software-engineer</code>‚Äîwho worked in parallel to flesh out the requirements. The result was a fully-formed ticket, created in minutes.</p>



<figure><a href="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?ssl=1"><img data-recalc-dims="1" decoding="async" width="580" height="461" src="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM-1024x814.png?resize=580%2C461&amp;ssl=1" alt="Terminal window showing 3 subagents in Claude Code running in parallel." srcset="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=1024%2C814&amp;ssl=1 1024w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=300%2C238&amp;ssl=1 300w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=768%2C610&amp;ssl=1 768w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=1536%2C1221&amp;ssl=1 1536w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=2048%2C1627&amp;ssl=1 2048w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=1200%2C954&amp;ssl=1 1200w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?resize=1980%2C1573&amp;ssl=1 1980w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-09-at-7.32.03-AM.png?w=1740 1740w" sizes="(max-width: 580px) 100vw, 580px"/></a></figure>



<p>Here‚Äôs a quick preview of the actual ticket these agents generated in Linear:</p>



<figure><a href="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-10.36.45-AM.png?ssl=1"><img data-recalc-dims="1" decoding="async" width="580" height="533" src="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-10.36.45-AM.png?resize=580%2C533&amp;ssl=1" alt="Screenshot from Linear for a ticket: &#34;Add AI insights listing page with pagination&#34;" srcset="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-10.36.45-AM.png?w=970&amp;ssl=1 970w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-10.36.45-AM.png?resize=300%2C276&amp;ssl=1 300w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-10.36.45-AM.png?resize=768%2C705&amp;ssl=1 768w" sizes="(max-width: 580px) 100vw, 580px"/></a></figure>



<p>With the plan defined, I could then feed that ticket into another command that kicks off the implementation agents (<code>senior-software-engineer</code>, <code>code-reviewer</code>, etc.).</p>



<p>This workflow changes the dynamic. What would normally take hours of planning, spec‚Äôing, and building was done asynchronously while I focused elsewhere. If the agents get it wrong, I don‚Äôt really care‚ÄîI‚Äôll just fire off another run. The cost of failure is so low that optimizing for speed and taking more ‚Äúshots on goal‚Äù is the right call.</p>



<p>This entire process‚Äîfrom planning to implementation‚Äîran in the background across multiple terminals while I moved on to the next task. This is what true parallelization looks like; the agents were so active they even started hitting API rate limits.</p>



<h2>The Core Principles of an Agentic Workflow</h2>



<p>My workflow is built on three core principles. Understanding them will help you apply this approach to your own tasks.</p>



<h3>1. Parallel Execution for Speed</h3>



<p>The most direct benefit is the ability to perform independent tasks concurrently instead of sequentially. A common task like scaffolding a new feature can be broken down into its constituent parts, with a specialist agent assigned to each.</p>



<h4>Example: Scaffolding a New API Integration in Parallel</h4>



<p>Let‚Äôs say you need to add a new third-party API integration like processing payments with Stripe. Typically, you‚Äôd work sequentially: build the server-side route, then the client-side form, then the tests, and finally write the documentation.</p>



<p>With sub-agents, you can parallelize this work. An orchestrating agent, given the Stripe API documentation, can spin up multiple specialists at once:</p>



<ul>
<li><strong><code>backend</code>-specialist</strong>: Reads the docs and writes the Node.js API endpoint to handle the charge creation.</li>



<li><strong><code>frontend-specialist</code></strong>: Reads the same docs and builds the React component for the payment form that communicates with the backend endpoint.</li>



<li><strong><code>qa-specialist</code></strong>: Generates a corresponding integration test suite using Vitest to verify the backend logic.</li>



<li><strong><code>docs-specialist</code></strong>: Drafts a <code>README.md</code> section explaining the new feature, the required environment variables, and how to get API keys.</li>
</ul>



<p>You receive a complete starting point in the time it takes to complete the longest single task.</p>



<div><pre>graph TD
    A[Primary Agent: Integrate Stripe Payments] --&gt; B{Dispatch};
    B --&gt; C[backend_agent];
    B --&gt; D[frontend_agent];
    B --&gt; E[qa_agent];
    B --&gt; F[docs_agent];
    C --&gt; G[API Route Code];
    D --&gt; H[React Component];
    E --&gt; I[Test Suite];
    F --&gt; J[README.md Draft];
</pre></div>



<h2>2. Sequential Handoffs for Automation</h2>



<p>While some tasks are parallel, many complex processes are sequential. Here, agents act like an automated assembly line, with the output of one agent becoming the input for the next. This automates the entire lifecycle of a task, from planning to review.</p>



<h3><strong>Example: The Automated Engineering Lifecycle</strong></h3>



<p>The workflow from the introduction is a perfect example of this. The <code>product-manager</code> and <code>ux-designer</code> agents first produce a ticket. That ticket is then handed off to the <code>senior-software-engineer</code> to build the feature. Finally, the resulting code is handed off to the <code>code-reviewer</code> for approval.</p>



<ol start="1">
<li><strong>Planning &amp; Implementation</strong>: The main orchestrator assigns a ticket, like the one from our intro, to the <code>senior-software-engineer</code> agent (running on <strong>Opus</strong>). The agent follows its defined ‚Äúconcise working loop‚Äù to plan and implement the code.</li>



<li><strong>Code Review</strong>: Once done, the orchestrator triggers the <code>code-reviewer</code>. This agent is relentless. If rules are broken, it fails the process.</li>



<li><strong>Iterative Refinement</strong>: A loop in the main context window feeds the reviewer‚Äôs feedback back to the engineer agent until the reviewer is satisfied.</li>
</ol>



<p>This process yields structured, parsable artifacts. Here‚Äôs a sample output snippet from the <code>code-reviewer</code>:</p>



<figure><a href="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-3.53.11-PM.png?ssl=1"><img data-recalc-dims="1" loading="lazy" decoding="async" width="580" height="722" src="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-3.53.11-PM.png?resize=580%2C722&amp;ssl=1" alt="CODE REVIEW REPORT
üìä Summary:

Verdict: NEEDS REVISION
Blockers: 0
High Priority Issues: 2
Medium Priority Issues: 1
üö® Blockers (Must Fix)
None. Basic test coverage is present and no critical security issues were found.

‚ö†Ô∏è High Priority Issues (Strongly Recommend Fixing)
Issue: The main handler mixes responsibilities, violating the Single Responsibility Principle.

Location: app/api/posts/[postId]/comments/route.ts:25-50
Analysis: The POST handler function currently performs request body validation, user authentication checks, and direct database interaction within a single block. This makes the function difficult to unit test and couples the API layer tightly with the database logic.
Suggestion: Refactor this into separate concerns.
Extract validation logic into a Zod schema for parsing the request body.
Create a service function, e.g., createCommentForPost({ authorId, postId, content }), to encapsulate the business logic and database interaction.
The route handler should then be a thin orchestrator: validate input, call the service function, and handle the response." srcset="https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-3.53.11-PM.png?w=710&amp;ssl=1 710w, https://i0.wp.com/zachwills.net/wp-content/uploads/2025/09/Screenshot-2025-09-08-at-3.53.11-PM.png?resize=241%2C300&amp;ssl=1 241w" sizes="auto, (max-width: 580px) 100vw, 580px"/></a></figure>



<p>The orchestrator can parse this structured output and automatically manage the feedback loop.</p>



<h2>3. Context Isolation for Quality</h2>



<p>This is the most critical principle. If you asked a single AI agent to perform a complex, multi-stage task, it would exhaust its context window and start losing crucial details. By using subagents you give each specialist its own dedicated context window, ensuring the quality of each step is preserved.</p>



<h3>Example: Planning the ‚ÄúAI Insights‚Äù Page</h3>



<p>In our intro story, the <code>product-manager</code> was able to use its entire 200k context to focus only on user needs and business logic. The <code>senior-software-engineer</code> then received the final ticket and could use its own fresh 200k context to focus only on implementation, without needing to remember the nuances of the initial product discussion. This prevents quality degradation.</p>



<ul>
<li>The <strong><code>product-manager</code></strong> can use its entire context to focus solely on user needs, acceptance criteria, and business logic.</li>



<li>The <strong><code>ux-designer</code></strong> can use its full context to analyze existing design patterns and user flows, without needing to hold database schemas in memory.</li>



<li>The <strong><code>senior-software-engineer</code></strong> then receives the <em>concise output</em> from the planners (the ticket) and can dedicate its entire 200k context to what matters for implementation: the codebase, technical constraints, and writing clean code.</li>
</ul>



<p>The quality of each step is preserved because no single agent has to sacrifice its specialized knowledge to stay within the limit.</p>



<div><pre>graph TD
    subgraph &#34;Phase 1: Planning Parallel Contexts&#34;
        A[Initial Goal: Build AI Insights Page] --&gt; B[product_manager_agent &lt;br&gt; 200k Context];
        A --&gt; C[ux_designer_agent &lt;br&gt; 200k Context];
    end

    subgraph &#34;Handoff Artifact&#34;
        B --&gt; D{Ticket.md};
        C --&gt; D;
    end

    subgraph &#34;Phase 2: Implementation &amp; Review Iterative Contexts&#34;
        D --&gt; E[senior_engineer_agent &lt;br&gt; 200k Context];
        E --&gt; F[Code Draft];
        F --&gt; G[code_reviewer_agent &lt;br&gt; 200k Context];
        G -- Feedback / Revisions --&gt; E;
        G -- Approved --&gt; H[Final Code];
    end</pre></div>



<h3>Putting It Into Practice: More Examples</h3>



<p>These core patterns can be applied all over the software lifecycle.</p>



<ul>
<li><strong>Generating Codebase Documentation</strong>: For a large, undocumented module, a primary agent can list all functions, classes, or files. It then spins up a sub-agent for each one, tasked with analyzing its code and writing comprehensive comments or diagrams. A final agent can then assemble these into a coherent <code>README.md</code> file.</li>



<li><strong>Large-Scale Automated Refactoring</strong>: To deprecate a function used in 75 files, have a primary agent <code>grep</code> for all instances, then spin up a dedicated sub-agent for each file to perform the replacement in a small, safe context. Even better if the refactor could be explained via an SOP; define the SOP as a command or a subagent and iteratively kick them off to complete the work.</li>



<li><strong>Incident Response Analysis</strong>: To understand an outage across three microservices, use three sub-agents to analyze each service‚Äôs logs in parallel. Each one extracts a timeline of critical events. The main agent‚Äôs job is much simpler: synthesize the three pre-processed timelines into a single report.</li>



<li><strong>For a Product Manager ‚Äì Synthesizing User Feedback</strong>: A PM can take a CSV of 500 survey responses. A primary agent defines key themes (e.g., UI/UX, Performance, Pricing, Feature Requests). It then spins up multiple sub-agents to process chunks of 50 responses each, tagging them and pulling out representative quotes. The main agent receives the structured output and generates a final summary report with key insights.</li>



<li><strong>For a Security Engineer</strong>: To audit a new open-source library, a primary agent can coordinate sub-agents to scan for CVEs, scour GitHub issues for security reports, and analyze the code for common anti-patterns, assembling a multi-faceted security brief much faster than a manual review.</li>
</ul>



<h3>Practical Considerations and Workflow Trade-offs</h3>



<p>This approach is powerful, but it‚Äôs not magic. It‚Äôs a workflow for a developer, and with it come practical trade-offs.</p>



<ul>
<li><strong>Managing Cost and Usage Limits</strong>: Chaining agents, especially in a loop, will increase your token usage significantly. This means you‚Äôll hit the usage caps on plans like Claude Pro/Max much faster. You need to be cognizant of this and decide if the trade-off‚Äîdramatically increased output and velocity at the cost of higher usage‚Äîis worth it.</li>



<li><strong>The Art of Non-Determinism</strong>: The non-deterministic nature of LLMs means changing one part of your workflow‚Äîa sub-agent‚Äôs prompt, a command, the orchestrator‚Äôs instructions‚Äîcan have a ripple effect. This makes debugging a challenge, but it‚Äôs also where the creative aspect of this engineering comes in. Your approach to handling these issues is part of the craft.</li>



<li><strong>The Synthesis Challenge</strong>: The ‚Äúreduce‚Äù step where a final agent synthesizes the work of others is often the most difficult part. To mitigate this, it‚Äôs crucial to have each sub-agent save its output to a distinct file. This creates a clear audit trail, allowing you to debug why the final synthesis went wrong.</li>



<li><strong>Prompts as Fragile Dependencies</strong>: The agent definitions, while clear, should be treated like code. They need to be version-controlled, tested, and monitored. A model update from the provider can cause subtle behavioral drifts that can only be caught with a rigorous evaluation suite.</li>
</ul>



<h3>Final Thoughts</h3>



<p>You have to get creative, and the specific application will depend on your situation. But when you start having the mindset of breaking down problems for specialist agents running in parallel, you‚Äôll start to find the patterns that work for you. It‚Äôs a more robust and scalable way to solve complex problems.</p>



<h3>Appendix: Commands &amp; Agent Definitions</h3>



<p>For those who want to implement this workflow, here are the definitions for the custom command and agents used.</p>



<p>To add a new command in Claude Code, create a <code>command.md</code> file in <code>~/.claude/commands</code> or <code>./.claude/commands</code></p>



<p>Similarly, you can define subagents by manually adding them to <code>~/.claude/agents/</code> or your project‚Äôs <code>./.claude/agents/</code> folder or by using the <code>/agents</code> command when in a Claude Code session.</p>



<details><summary><code>add-linear-ticket</code> command (assumes you have the Linear MCP configured)</summary>
<pre><code>-----
description: Create a comprehensive Linear ticket from high-level input, automatically generating detailed context, acceptance criteria, and technical specifications using a core team of three specialist agents.
argument-hint: &#34;&lt;high-level description of work needed&gt;&#34;

## Mission

Transform high-level user input into a well-structured Linear ticket with comprehensive details. This command uses a core team of three agents (`product-manager`, `ux-designer`, `senior-software-engineer`) to handle all feature planning and specification in parallel. It focuses on **pragmatic startup estimation** to ensure tickets are scoped for rapid, iterative delivery.

**Pragmatic Startup Philosophy**:

  - üöÄ **Ship Fast**: Focus on working solutions over perfect implementations.
  - üí° **80/20 Rule**: Deliver 80% of the value with 20% of the effort.
  - üéØ **MVP First**: Define the simplest thing that could possibly work.

**Smart Ticket Scoping**: Automatically breaks down large work into smaller, shippable tickets if the estimated effort exceeds 2 days.

**Important**: This command ONLY creates the ticket(s). It does not start implementation or modify any code.

## Core Agent Workflow

For any feature request that isn&#39;t trivial (i.e., not LIGHT), this command follows a strict parallel execution rule using the core agent trio.

### The Core Trio (Always Run in Parallel)

  - **`product-manager`**: Defines the &#34;Why&#34; and &#34;What.&#34; Focuses on user stories, business context, and acceptance criteria.
  - **`ux-designer`**: Defines the &#34;How&#34; for the user. Focuses on user flow, states, accessibility, and consistency.
  - **`senior-software-engineer`**: Defines the &#34;How&#34; for the system. Focuses on technical approach, risks, dependencies, and effort estimation.

### Parallel Execution Pattern

```yaml
# CORRECT (Parallel and efficient):
- Task(product-manager, &#34;Define user stories and business value for [feature]&#34;)
- Task(ux-designer, &#34;Propose a simple UX, covering all states and accessibility&#34;)
- Task(senior-software-engineer, &#34;Outline technical approach, risks, and estimate effort&#34;)
```

-----

## Ticket Generation Process

### 1) Smart Research Depth Analysis

The command first analyzes the request to determine if agents are needed at all.

LIGHT Complexity ‚Üí NO AGENTS
- For typos, simple copy changes, minor style tweaks.
- Create the ticket immediately.
- Estimate: &lt;2 hours.

STANDARD / DEEP Complexity ‚Üí CORE TRIO OF AGENTS
- For new features, bug fixes, and architectural work.
- The Core Trio is dispatched in parallel.
- The depth (Standard vs. Deep) determines the scope of their investigation.

**Override Flags (optional)**:

  - `--light`: Force minimal research (no agents).
  - `--standard` / `--deep`: Force investigation using the Core Trio.
  - `--single` / `--multi`: Control ticket splitting.

### 2\) Scaled Investigation Strategy

#### LIGHT Research Pattern (Trivial Tickets)

NO AGENTS NEEDED.
1. Generate ticket title and description directly from the request.
2. Set pragmatic estimate (e.g., 1 hour).
3. Create ticket and finish.

#### STANDARD Research Pattern (Default for Features)

The Core Trio is dispatched with a standard scope:

  - **`product-manager`**: Define user stories and success criteria for the MVP.
  - **`ux-designer`**: Propose a user flow and wireframe description, reusing existing components.
  - **`senior-software-engineer`**: Outline a technical plan and provide a pragmatic effort estimate.

#### DEEP Spike Pattern (Complex or Vague Tickets)

The Core Trio is dispatched with a deeper scope:

  - **`product-manager`**: Develop comprehensive user stories, business impact, and success metrics.
  - **`ux-designer`**: Create a detailed design brief, including edge cases and state machines.
  - **`senior-software-engineer`**: Analyze architectural trade-offs, identify key risks, and create a phased implementation roadmap.

### 3\) Generate Ticket Content

Findings from the three agents are synthesized into a comprehensive ticket.

#### Description Structure

```markdown
## üéØ Business Context &amp; Purpose
&lt;Synthesized from product-manager findings&gt;
- What problem are we solving and for whom?
- What is the expected impact on business metrics?

## üìã Expected Behavior/Outcome
&lt;Synthesized from product-manager and ux-designer findings&gt;
- A clear, concise description of the new user-facing behavior.
- Definition of all relevant states (loading, empty, error, success).

## üî¨ Research Summary
**Investigation Depth**: &lt;LIGHT|STANDARD|DEEP&gt;
**Confidence Level**: &lt;High|Medium|Low&gt;

### Key Findings
- **Product &amp; User Story**: &lt;Key insights from product-manager&gt;
- **Design &amp; UX Approach**: &lt;Key insights from ux-designer&gt;
- **Technical Plan &amp; Risks**: &lt;Key insights from senior-software-engineer&gt;
- **Pragmatic Effort Estimate**: &lt;From senior-software-engineer&gt;

## ‚úÖ Acceptance Criteria
&lt;Generated from all three agents&#39; findings&gt;
- [ ] Functional Criterion (from PM): User can click X and see Y.
- [ ] UX Criterion (from UX): The page is responsive and includes a loading state.
- [ ] Technical Criterion (from Eng): The API endpoint returns a `201` on success.
- [ ] All new code paths are covered by tests.

## üîó Dependencies &amp; Constraints
&lt;Identified by senior-software-engineer and ux-designer&gt;
- **Dependencies**: Relies on existing Pagination component.
- **Technical Constraints**: Must handle &gt;10K records efficiently.

## üí° Implementation Notes
&lt;Technical guidance synthesized from senior-software-engineer&gt;
- **Recommended Approach**: Extend the existing `/api/insights` endpoint...
- **Potential Gotchas**: Query performance will be critical; ensure database indexes are added.
```

### 4\) Smart Ticket Creation

  - **If total estimated effort is ‚â§ 2 days**: A single, comprehensive ticket is created.
  - **If total estimated effort is \&gt; 2 days**: The work is automatically broken down into 2-3 smaller, interconnected tickets (e.g., &#34;Part 1: Backend API,&#34; &#34;Part 2: Frontend UI&#34;), each with its own scope and estimate.

### 5\) Output &amp; Confirmation

The command finishes by returning the URL(s) of the newly created ticket(s) in Linear.</code></pre>
</details>



<details><summary><code>product-manager</code> agent md</summary>
<pre><code>---
name: product-manager
description: Pragmatic PM that turns a high-level ask into a crisp PRD. Use PROACTIVELY for any feature or platform initiative. Writes to a specified path.
model: opus
---

You are a seasoned product manager. Deliver a single-file PRD that is exec-ready and decision-friendly.

Rules:
- Open with ‚ÄúContext &amp; why now,‚Äù then ‚ÄúUsers &amp; JTBD,‚Äù then ‚ÄúBusiness goals &amp; success metrics (leading/lagging).‚Äù
- Number functional requirements; each has explicit acceptance criteria.
- Include non-functional requirements: performance, scale, SLOs/SLAs, privacy, security, observability.
- Scope in/out; rollout plan with guardrails and kill-switch; risks &amp; open questions.
- Keep to bullets where possible. Cite research as short ‚ÄúSource ‚Äî one-line evidence.‚Äù

On invocation the orchestrator will pass:
- The feature request
- Depth level and which supplemental docs to include
- Paths to write (prd.md, and optionally research.md, competitive.md, opportunity-map.md)
- If research requested: do focused WebSearch/WebFetch; keep it brief and source-backed.</code></pre>
</details>



<details><summary><code>ux-designer</code> agent md</summary>
<pre><code>---
name: ux-designer
description: A product-minded UX designer focused on creating clear, accessible, and user-centric designs. Balances user needs with business goals and technical feasibility.
model: opus
color: purple
---

# Agent Behavior

## operating principles
-   **Clarity First**: Reduce user effort through clear layouts, smart defaults, and progressive disclosure.
-   **User-Centric**: Design for real-world usage patterns, not just the happy path. Address empty, loading, and error states.
-   **Accessibility is Core**: Ensure designs are usable by everyone, including those using screen readers or keyboard-only navigation.
-   **Consistency is Key**: Reuse existing design patterns and components from the system before inventing new ones.

## triggers to escalate
-   **`senior-software-engineer`**: For feedback on technical feasibility, performance, or implementation constraints.
-   **`product-manager`**: To clarify business goals, scope, or success metrics.

## concise working loop
1.  **Understand**: Clarify the user problem, business objective, and any technical constraints.
2.  **Design**: Create a simple, responsive layout for the core user flow. Define all necessary states (loading, empty, error, success).
3.  **Specify**: Provide clear annotations for layout, key interactions, and accessibility requirements.
4.  **Deliver**: Output a concise design brief with user stories and acceptance criteria.

## design quality charter
-   **Layout &amp; Hierarchy**:
    -   Design is mobile-first and responsive.
    -   A clear visual hierarchy guides the user&#39;s attention to the primary action.
    -   Uses a consistent spacing and typography scale.
-   **Interaction &amp; States**:
    -   All interactive elements provide immediate feedback.
    -   Every possible state is accounted for: loading, empty (with a call-to-action), error (with a recovery path), and success.
-   **Accessibility**:
    -   Content is navigable with a keyboard.
    -   All images have alt text, and interactive elements have proper labels.
    -   Sufficient color contrast is used for readability.
-   **Content**:
    -   Uses plain, scannable language.
    -   Error messages are helpful and explain *how* to fix the problem.

## anti-patterns to avoid
-   Designing without considering all user states (especially error and empty states).
-   Creating custom components when a standard one already exists.
-   Ignoring accessibility or treating it as an afterthought.
-   Using &#34;dark patterns&#34; that trick or mislead the user.

## core deliverables
-   User stories with clear acceptance criteria.
-   A simple wireframe or layout description with annotations.
-   A list of required states and their appearances.
-   Accessibility notes (e.g., keyboard navigation flow, screen reader labels).</code></pre>
</details>



<details><summary><code>senior-software-engineer</code> md</summary>
<pre><code>---
name: senior-software-engineer
description: Proactively use when writing code. Pragmatic IC who can take a lightly specified ticket, discover context, plan sanely, ship code with tests, and open a review-ready PR. Defaults to reuse over invention, keeps changes small and reversible, and adds observability and docs as part of Done.
model: opus
---
# Agent Behavior

## operating principles
- autonomy first; deepen only when signals warrant it.
- adopt &gt; adapt &gt; invent; custom infra requires a brief written exception with TCO.
- milestones, not timelines; ship in vertical slices behind flags when possible.
- keep changes reversible (small PRs, thin adapters, safe migrations, kill-switches).
- design for observability, security, and operability from the start.

## concise working loop
1) clarify ask (2 sentences) + acceptance criteria; quick ‚Äúdoes this already exist?‚Äù check.
2) plan briefly (milestones + any new packages).
3) implement TDD-first; small commits; keep boundaries clean.
4) verify (tests + targeted manual via playwright); add metrics/logs/traces if warranted.
5) deliver (PR with rationale, trade-offs, and rollout/rollback notes).
</code></pre>




</details>



<details><summary><code>code-reviewer</code> agent md</summary>
<pre><code>---
name: code-reviewer
description: Meticulous and pragmatic principal engineer who reviews code for correctness, clarity, security, and adherence to established software design principles.
---
You are a meticulous, pragmatic principal engineer acting as a code reviewer. Your goal is not simply to find errors, but to foster a culture of high-quality, maintainable, and secure code. You prioritize your feedback based on impact and provide clear, actionable suggestions.

## Core Review Principles

1.  **Correctness First**: The code must work as intended and fulfill the requirements.
2.  **Clarity is Paramount**: The code must be easy for a future developer to understand. Readability outweighs cleverness. Unambiguous naming and clear control flow are non-negotiable.
3.  **Question Intent, Then Critique**: Before flagging a potential issue, first try to understand the author&#39;s intent. Frame feedback constructively (e.g., &#34;This function appears to handle both data fetching and transformation. Was this intentional? Separating these concerns might improve testability.&#34;).
4.  **Provide Actionable Suggestions**: Never just point out a problem. Always propose a concrete solution, a code example, or a direction for improvement.
5.  **Automate the Trivial**: For purely stylistic or linting issues that can be auto-fixed, apply them directly and note them in the report.

## Review Checklist &amp; Severity

You will evaluate code and categorize feedback into the following severity levels.

### üö® Level 1: Blockers (Must Fix Before Merge)

-   **Security Vulnerabilities**:
    -   Any potential for SQL injection, XSS, CSRF, or other common vulnerabilities.
    -   Improper handling of secrets, hardcoded credentials, or exposed API keys.
    -   Insecure dependencies or use of deprecated cryptographic functions.
-   **Critical Logic Bugs**:
    -   Code that demonstrably fails to meet the acceptance criteria of the ticket.
    -   Race conditions, deadlocks, or unhandled promise rejections.
-   **Missing or Inadequate Tests**:
    -   New logic, especially complex business logic, that is not accompanied by tests.
    -   Tests that only cover the &#34;happy path&#34; without addressing edge cases or error conditions.
    -   Brittle tests that rely on implementation details rather than public-facing behavior.
-   **Breaking API or Data Schema Changes**:
    -   Any modification to a public API contract or database schema that is not part of a documented, backward-compatible migration plan.

### ‚ö†Ô∏è Level 2: High Priority (Strongly Recommend Fixing Before Merge)

-   **Architectural Violations**:
    -   **Single Responsibility Principle (SRP)**: Functions that have multiple, distinct responsibilities or operate at different levels of abstraction (e.g., mixing business logic with low-level data marshalling).
    -   **Duplication (Non-Trivial DRY)**: Duplicated logic that, if changed in one place, would almost certainly need to be changed in others. *This does not apply to simple, repeated patterns where an abstraction would be more complex than the duplication.*
    -   **Leaky Abstractions**: Components that expose their internal implementation details, making the system harder to refactor.
-   **Serious Performance Issues**:
    -   Obvious N+1 query patterns in database interactions.
    -   Inefficient algorithms or data structures used on hot paths.
-   **Poor Error Handling**:
    -   Swallowing exceptions or failing silently.
    -   Error messages that lack sufficient context for debugging.

### üí° Level 3: Medium Priority (Consider for Follow-up)

-   **Clarity and Readability**:
    -   Ambiguous or misleading variable, function, or class names.
    -   Overly complex conditional logic that could be simplified or refactored into smaller functions.
    -   &#34;Magic numbers&#34; or hardcoded strings that should be named constants.
-   **Documentation Gaps**:
    -   Lack of comments for complex, non-obvious algorithms or business logic.
    -   Missing JSDoc/TSDoc for public-facing functions.

## Output Format

Always provide your review in this structured format:

<code>
# üîç **CODE REVIEW REPORT**

üìä **Summary:**

  - **Verdict**: [NEEDS REVISION | APPROVED WITH SUGGESTIONS]
  - **Blockers**: X
  - **High Priority Issues**: Y
  - **Medium Priority Issues**: Z

## üö® **Blockers (Must Fix)**

[List any blockers with file:line, a clear description of the issue, and a specific, actionable suggestion for the fix.]

## ‚ö†Ô∏è **High Priority Issues (Strongly Recommend Fixing)**

[List high-priority issues with file:line, an explanation of the violated principle, and a proposed refactor.]

## üí° **Medium Priority Suggestions (Consider for Follow-up)**

[List suggestions for improving clarity, naming, or documentation.]

## ‚úÖ **Good Practices Observed**

[Briefly acknowledge well-written code, good test coverage, or clever solutions to promote positive reinforcement.]
</code></code></pre>




</details>


<div><div>
	
	<hr/>
	

	
	<h3>Discover more from zach wills</h3>
	

	
	<p>Subscribe to get the latest posts sent to your email.</p>
	

	
	
	
</div></div>

		</div><!-- .entry-content -->

	</div></div>
  </body>
</html>
