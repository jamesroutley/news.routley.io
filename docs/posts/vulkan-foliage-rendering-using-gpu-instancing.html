<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thegeeko.me/blog/foliage-rendering">Original</a>
    <h1>Vulkan Foliage rendering using GPU Instancing</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
      <section>
        
        <time>Feb 24, 2024</time>
        <article><p>I was watching <a href="https://www.youtube.com/watch?v=jw00MbIJcrk">acerola&#39;s video</a> on foliage rendering and I liked the idea of rendering millions of grass blades, it was a good opportunity to play around with GPU instancing and indirect draw.</p><h3 id="what-i&#39;ll-be-using"><span>
      What I&#39;ll Be Using
    </span></h3><p>The features and extensions set used in this abroach are:</p><ul><li><p><code>VK_EXT_buffer_device_address</code> This extension allows for using pointers in GLSL and passing them in push constants or buffers, this extension along with <code>VK_EXT_descriptor_indexing</code> makes dealing with buffers and textures soo much easier and nicer IMHO.</p></li><li><p><code>multiDrawIndirect</code> This feature allows for multiple draw calls in indirect buffer make use of them to draw multiple LODs of the grass.</p></li></ul><h2 id="how-it-works"><span>
      How It Works
    </span></h2><p>Basically, there&#39;s a compute pass that generates info about the grass blades stores them in a buffer, and does frustum culling and LOD selection and fill indirect commands, then a graphics pass to draw the blades.</p><h3 id="compute-pass"><span>
      Compute Pass
    </span></h3><p>our grass blade is defined by the following</p><pre><code><span>struct</span> <span>GrassBlade</span> <span>{</span>
	
	
	<span>vec4</span> pos_bend<span>;</span>
	
	
	
	<span>vec4</span> size_anim_pitch<span>;</span>
<span>}</span><span>;</span>
</code></pre>

<p>we want to generate all of this data we start by</p><h4 id="position(displacement-from-the-center)"><span>
      Position(displacement from the center)
    </span></h4><p>It starts by generating random positions inside a rectangle area defined by center, width and height using the following formula</p><pre><code>

<span>vec3</span> <span>rand</span><span>(</span><span>uvec3</span> v<span>)</span> <span>{</span>
	v <span>=</span> v <span>*</span> <span>1664525u</span> <span>+</span> <span>1013904223u</span><span>;</span>
	v<span>.</span>x <span>+=</span> v<span>.</span>y <span>*</span> v<span>.</span>z<span>;</span>
	v<span>.</span>y <span>+=</span> v<span>.</span>z <span>*</span> v<span>.</span>x<span>;</span>
	v<span>.</span>z <span>+=</span> v<span>.</span>x <span>*</span> v<span>.</span>y<span>;</span>
	v <span>^=</span> v <span>&gt;&gt;</span> <span>16u</span><span>;</span>
	v<span>.</span>x <span>+=</span> v<span>.</span>y <span>*</span> v<span>.</span>z<span>;</span>
	v<span>.</span>y <span>+=</span> v<span>.</span>z <span>*</span> v<span>.</span>x<span>;</span>
	v<span>.</span>z <span>+=</span> v<span>.</span>x <span>*</span> v<span>.</span>y<span>;</span>
	<span>return</span> <span>vec3</span><span>(</span>v<span>)</span> <span>*</span> <span>(</span><span>1.0</span> <span>/</span> <span>float</span><span>(</span><span>0xffffffffu</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>uvec2</span> i <span>=</span> gl_GlobalInvocationID<span>.</span>xy<span>;</span>
<span>vec3</span> pos <span>=</span> pc<span>.</span>aria_center<span>.</span>xyz<span>;</span>

<span>vec3</span> rand_val <span>=</span> <span>rand</span><span>(</span><span>uvec3</span><span>(</span>i<span>,</span> <span>378294</span><span>)</span><span>)</span><span>;</span>
pos<span>.</span>x <span>+=</span> <span>(</span>pc<span>.</span>aria<span>.</span>x <span>/</span> <span>2</span><span>)</span> <span>-</span> rand_val<span>.</span>x <span>*</span> pc<span>.</span>aria<span>.</span>x<span>;</span>
pos<span>.</span>z <span>+=</span> <span>(</span>pc<span>.</span>aria<span>.</span>y <span>/</span> <span>2</span><span>)</span> <span>-</span> rand_val<span>.</span>y <span>*</span> pc<span>.</span>aria<span>.</span>y<span>;</span>
</code></pre>

<h4 id="height-and-width"><span>
      Height &amp; Width
    </span></h4><p>then it generates a uv coords for each grass blade to sample a texture by doing</p><pre><code><span>vec2</span> bottom_left_corner <span>=</span> pc<span>.</span>aria_center<span>.</span>xz <span>-</span> <span>(</span>pc<span>.</span>aria<span>.</span>xy <span>/</span> <span>2.0</span><span>)</span><span>;</span>
<span>vec2</span> upper_right_corner <span>=</span> pc<span>.</span>aria_center<span>.</span>xz <span>+</span> <span>(</span>pc<span>.</span>aria<span>.</span>xy <span>/</span> <span>2.0</span><span>)</span><span>;</span>
<span>vec2</span> uv <span>=</span> pos<span>.</span>xz <span>/</span> <span>(</span>upper_right_corner <span>-</span> bottom_left_corner<span>)</span><span>;</span>
</code></pre>

<p>after that using the uv coords, we can sample a simplex noise texture to have height multiplier or width multiplier we can also add some terms for user control using simplex noise for height makes sense as the tall grass tends to stick together in real life.</p><p><img src="https://www.bryanbraun.com/images/folliage-simplex.png" alt="simplex noise for hight"/></p><h4 id="bend-term"><span>
      Bend Term
    </span></h4><p>This is a term to define how bendable a grass blade is which will be used later as a multiplier in vertex shader to do the animation.</p><h4 id="animation-term"><span>
      Animation term
    </span></h4><p>This is a term used by the animation formula to animate the grass it&#39;s the same for all of the vertices so calculating it here saves us time and allows us to not pass uvs to vertex shader which is 2 floats but for millions of blads it will be 100s of megabytes. It&#39;s calculated by the following</p><pre><code><span>float</span> <span>wind</span><span>(</span><span>vec2</span> uv<span>,</span> <span>float</span> time<span>,</span> <span>float</span> base_freq<span>,</span> 
           <span>float</span> freq_scale<span>,</span> <span>float</span> strength<span>)</span> <span>{</span>
	<span>float</span> noise_factor <span>=</span> <span>length</span><span>(</span><span>pcg2d</span><span>(</span><span>uvec2</span><span>(</span>uv <span>*</span> <span>104234.f</span><span>)</span><span>)</span><span>)</span><span>;</span>
	
	
	<span>float</span> freq <span>=</span> base_freq <span>+</span> <span>sin</span><span>(</span>time<span>)</span> <span>*</span> freq_scale<span>;</span>
	
	<span>vec2</span> uv_displaced <span>=</span> uv <span>+</span> strength<span>;</span>
	<span>vec2</span> uv_scaled <span>=</span> uv_displaced <span>*</span> freq<span>;</span>
	
	<span>float</span> sin_term <span>=</span> uv_scaled<span>.</span>x <span>+</span> uv_scaled<span>.</span>y <span>+</span> noise_factor<span>;</span>
	<span>return</span> sin_term<span>;</span>
<span>}</span>
</code></pre>

<p>In the vertex shader this value will be used as a parameter for the sin function which will result in a kinda wind like wave, you can see for yourself here in <a href="https://www.shadertoy.com/view/MXXXWj">shader toy</a></p><p>It&#39;s called <code>sin_term</code> because I&#39;ll pass it to sin function later in the vertex shader.</p><h4 id="pitch"><span>
      Pitch
    </span></h4><p>defines the angle of rotation around the UP axis, which is always <code>{0, 1, 0}</code> in our case the grass will always point upwards, so all we need is just an angle to construct a rotation matrix in the vertex shader. You can make this random or always face the camera or be controlled by the user whatever suits your needs.</p><h4 id="frustum-culling"><span>
      Frustum culling
    </span></h4><p>For the frustum culling, we start by generating a sphere around each blade the radius of the circle is determined by the max of height and width then we transform the sphere to camera space, at this point the distance from the camera is just the length of the point as in camera space the camera is at <code>0, 0, 0</code> we use this to apply the cutoff distance and choose LOD.</p><pre><code><span>float</span> radius <span>=</span> blade_height <span>&gt;=</span> blade_width <span>?</span> blade_height <span>:</span> blade_width<span>;</span>
<span>vec4</span> center <span>=</span> <span>vec4</span><span>(</span>pos<span>,</span> <span>1.0</span><span>)</span><span>;</span>
center<span>.</span>x <span>+=</span> <span>(</span>blade_width <span>/</span> <span>2</span><span>)</span><span>;</span>
center<span>.</span>y <span>+=</span> <span>(</span>blade_height <span>/</span> <span>2</span><span>)</span><span>;</span>

center <span>=</span> pc<span>.</span>per_frame<span>.</span>view <span>*</span> center<span>;</span>



<span>float</span> dist_from_cam <span>=</span> <span>distance</span><span>(</span>center<span>.</span>xyz<span>)</span><span>;</span>
<span>const</span> <span>float</span> cutoff_dist <span>=</span> <span>800</span><span>;</span>
<span>const</span> <span>float</span> low_lod_dist <span>=</span> <span>200</span><span>;</span>

<span>bool</span> visible <span>=</span> <span>(</span>dist_from_cam <span>&lt;</span> cutoff_dist<span>)</span><span>;</span>
<span>bool</span> low_lod <span>=</span> <span>(</span>dist_from_cam <span>&gt;</span> low_lod_dist<span>)</span><span>;</span>
</code></pre>

<p>then the frustum culling we kinda doing the projection by hand and then check if the sphere is in range, I only do culling on the x and y axes as for the z axis we already have a cutoff but adding that is also trivial. I learned this way of culling on <a href="https://youtu.be/NGGzk4Fi2iU?t=6962">Arseny Kapoulkine&#39;s stream</a> they explain it much better but basically, we extract the left or right plane(we need just one of them) and the top or bottom plane then on the GPU we calculate the dot product between the sphere center and planes while taking the abs of the x component of the center of the sphere to do the culling on both sides at same time utilizing its symmetry.</p><pre><code>
visible <span>=</span> visible <span>&amp;&amp;</span> 
	center<span>.</span>z <span>*</span> frustum<span>[</span><span>1</span><span>]</span> <span>+</span> <span>abs</span><span>(</span>center<span>.</span>x<span>)</span> <span>*</span> frustum<span>[</span><span>0</span><span>]</span> <span>&lt;</span> radius<span>;</span>

visible <span>=</span> visible <span>&amp;&amp;</span> 
	center<span>.</span>z <span>*</span> frustum<span>[</span><span>3</span><span>]</span> <span>+</span> <span>abs</span><span>(</span>center<span>.</span>y<span>)</span> <span>*</span> frustum<span>[</span><span>2</span><span>]</span> <span>&lt;</span> radius<span>;</span>
</code></pre>

<p>After that, we fill the blade info in the respective index in the blades data buffer</p><pre><code><span>uint</span> buf_index <span>=</span> pc<span>.</span>blades_number<span>.</span>x <span>*</span> i<span>.</span>y <span>+</span> i<span>.</span>x<span>;</span>
pc<span>.</span>grass<span>.</span>data<span>[</span>buf_index<span>]</span><span>.</span>pos_bend<span>.</span>xyz <span>=</span> pos<span>;</span>
pc<span>.</span>grass<span>.</span>data<span>[</span>buf_index<span>]</span><span>.</span>pos_bend<span>.</span>w <span>=</span> bend_factor<span>;</span>
pc<span>.</span>grass<span>.</span>data<span>[</span>buf_index<span>]</span><span>.</span>anim_size<span>.</span>x <span>=</span> blade_width<span>;</span>
pc<span>.</span>grass<span>.</span>data<span>[</span>buf_index<span>]</span><span>.</span>anim_size<span>.</span>y <span>=</span> blade_height<span>;</span>
pc<span>.</span>grass<span>.</span>data<span>[</span>buf_index<span>]</span><span>.</span>anim_size<span>.</span>z <span>=</span> pitch<span>;</span>
pc<span>.</span>grass<span>.</span>data<span>[</span>buf_index<span>]</span><span>.</span>anim_size<span>.</span>w <span>=</span> sin_term<span>;</span>
</code></pre>

<h4 id="draw-command-buffers"><span>
      Draw Command Buffers
    </span></h4><p>After generating the data we can fill the command buffer, each thread will atomically increase the number of instances in the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkDrawIndirectCommand.html">commands buffer</a> this allows us to know to use the instance count as an index in another buffer to store the indices of the visible blades which allows us to access the values using <code>gl_InstaceIndex</code> we can also copy the buffer and sort using prefix sum scan just like Acerola in his video but this is better memory-wise and probably performance wise but I didn&#39;t measure performance. in summary, the vertex shader will use <code>gl_InstaceIndex</code> to index into a buffer that contains the indices of the visible grass blades.</p><p><img src="https://www.bryanbraun.com/images/foliage-buffers.png" alt="diagram showing the buffers layout"/></p><p>The compute shader makes use of 2 indirect draw commands one for high LOD and other for low LOD we can add as many LOD levels as we want, and we check if it&#39;s low LOD or high and then increase <code>gl_InstanceIndex</code> in the respective command buffer.</p><pre><code>

<span>bool</span> low_lod <span>=</span> dist_from_cam <span>&gt;</span> low_lod_dist<span>;</span>
<span>if</span> <span>(</span>visible<span>)</span> <span>{</span>
	<span>uint</span> cmd_index <span>=</span> <span>uint</span><span>(</span>low_lod<span>)</span><span>;</span>
	<span>uint</span> index_in_visible <span>=</span> <span>atomicAdd</span><span>(</span>
		pc<span>.</span>cmds<span>.</span>data<span>[</span>cmd_index<span>]</span><span>.</span>instance_count<span>,</span> 
		<span>1</span>
	<span>)</span><span>;</span>
<span>}</span>
</code></pre>

<p>after that, we use <code>index_in_visible</code> to index into the visible blades indices buffer and store the index of the current grass blade.</p><pre><code>

DrawIndices indices <span>=</span> low_lod <span>?</span> pc<span>.</span>visible_low_lod <span>:</span> pc<span>.</span>visible<span>;</span>
indices<span>.</span>i<span>[</span>index_in_visible<span>]</span> <span>=</span> buf_index<span>;</span>

</code></pre>

<p>Now we have our indices data in a continuous buffer to index into using <code>gl_InstanceIndex</code> and <code>gl_DrawID</code> to determine which indices buffer to read from. We are ready to draw the grass blades.</p><h3 id="rendering"><span>
      Rendering
    </span></h3><p>In the vertex shader we start by pulling the Blade data respective to the current instance.</p><pre><code>DrawIndices visible <span>=</span> gl_DrawID <span>==</span> <span>1</span> <span>?</span> pc<span>.</span>visible_low_lod <span>:</span> pc<span>.</span>visible<span>;</span>
<span>uint</span> i_visible <span>=</span> visible<span>.</span>i<span>[</span>gl_InstanceIndex<span>]</span><span>;</span>
GrassBlade blade <span>=</span> pc<span>.</span>grass<span>.</span>data<span>[</span>i_visible<span>]</span><span>;</span>
</code></pre>

<p>After that, we construct a rotation matrix and apply the height and width multiplier.</p><pre><code><span>float</span> sin_pitch <span>=</span> <span>sin</span><span>(</span>blade<span>.</span>anim_size<span>.</span>z<span>)</span><span>;</span>
<span>float</span> cos_pitch <span>=</span> <span>cos</span><span>(</span>blade<span>.</span>anim_size<span>.</span>z<span>)</span><span>;</span>
<span>float</span> height_multiplier <span>=</span> blade<span>.</span>anim_size<span>.</span>y<span>;</span>
<span>float</span> width_multiplier <span>=</span> blade<span>.</span>anim_size<span>.</span>x<span>;</span>
<span>mat3</span> rotation <span>=</span> <span>{</span>
	<span>{</span>cos_pitch<span>,</span> <span>0</span><span>,</span> <span>-</span>sin_pitch<span>}</span><span>,</span>
	<span>{</span><span>0</span><span>,</span> <span>1</span><span>,</span> <span>0</span><span>}</span><span>,</span>
	<span>{</span>sin_pitch<span>,</span> <span>0</span><span>,</span> cos_pitch<span>}</span><span>,</span>
<span>}</span><span>;</span>

<span>vec3</span> v_pos <span>=</span> rotation <span>*</span> 
	<span>vec3</span><span>(</span>v<span>.</span>x <span>*</span> width_multiplier<span>,</span> v<span>.</span>y <span>*</span> height_multiplier<span>,</span> v<span>.</span>z<span>)</span><span>;</span>
</code></pre>

<p>Then we use the sin term to animate the grass blade using a sin function we scroll with time and the height of the vertex because naturally the tip of of the grass blade skew more than the base.</p><pre><code><span>float</span> sin_term <span>=</span> blade<span>.</span>anim_size<span>.</span>w<span>;</span>
<span>float</span> bend <span>=</span> <span>sin</span><span>(</span>sin_term <span>+</span> pc<span>.</span>time <span>+</span> <span>(</span>blade<span>.</span>pos_bend<span>.</span>w <span>*</span> pos<span>.</span>y<span>)</span><span>)</span><span>;</span>
pos<span>.</span>z <span>+=</span> bend <span>*</span> pos<span>.</span>y<span>;</span>
</code></pre>

<p>here is how it looks</p><p>
  <iframe src="https://www.youtube.com/embed/mDakjkrvH-0" title="Grass Animation" frame-border="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="">
  </iframe>
</p><p>For the color, I opted for a simple gradient that goes brighter as it gets higher. I plan to improve this for example using normals for the grass also add some specular lighting as it could look really nice for example like Ghost of Tsushima&#39;s grass.</p><h3 id="optimization"><span>
      Optimization
    </span></h3><p>The simplest thing I thought of was just to reduce the amount of the work the vertex shader does since it will run millions of times a low hanging fruit was multiplying the projection and view matrix on the CPU and have it ready for the vertex shader, the next thing we can do is optimize the grass blade mesh I&#39;ve used <a href="https://github.com/zeux/meshoptimizer">Mesh Optimizer</a> by Arseny Kapoulkine I used it and did multiple optimizations and the one who had the most impact was converting the grass blade from a triangle list to a triangle strip that reduced the number of vertex shader invocations drastically and almost cut the vertex shader work in half and the shape of the grass blade can be represented nicely as a strip.</p><h4 id="very-rough-numbers"><span>
      very rough numbers
    </span></h4><p><strong>Note:</strong> <em>note I got the numbers using <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#queries">Vulkan&#39;s timestamp queries</a></em></p><p>On my RX5600XT using the <a href="https://docs.mesa3d.org/drivers/radv.html">open source drivers(RADV)</a> on Linux in 1080p resleoution my GPU can process about 6&#39;770&#39;688 grass blade with all of them visible the compute shader takes about <code>4.7ms</code> and drawing it takes around <code>8ms</code> that&#39;s about it more than that it drop blew 60fps. Increasing the area covered by the grass to 1000 by 1000 we can consider up to 19&#39;066&#39;880 grass blade with compute shader taking about <code>2.5ms</code> and drawing them takes about <code>6ms</code>. <img src="https://www.bryanbraun.com/images/folliage-stats.png" alt="performance data"/></p></article>
      </section>
    </div><div>
  <div><p>
    PS: I&#39;m actively looking for opportunities and internships in Graphics. </p></div>
</div></div>
  </body>
</html>
