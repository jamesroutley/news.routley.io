<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hirrolot.github.io/posts/sat-supercompilation.html">Original</a>
    <h1>Solving SAT via Positive Supercompilation</h1>
    
    <div id="readability-page-1" class="page"><div><a href="#supercompilation-by-example"><h2 id="supercompilation-by-example">Supercompilation by example</h2></a><p>Supercompilation is a deep program transformation technique due to <a href="https://en.wikipedia.org/wiki/Valentin_Turchin">V. F. Turchin</a>,
a prominent computer scientist, cybernetician, physicist, and <a href="https://en.wikipedia.org/wiki/Soviet_dissidents">Soviet
dissident</a>.</p><p>He described the concept as follows <a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>:</p><blockquote>
<p>A supercompiler is a program transformer of a certain type. The usual
way of thinking about program transformation is in terms of some set of
rules which preserve the functional meaning of the program, and a
step-by-step application of these rules to the initial program. … The
concept of a supercompiler is a product of cybernetic thinking. A
program is seen as a machine. To make sense of it, one must observe its
operation. So a supercompiler does not transform the program by steps;
it controls and observes (SUPERvises) the running of the machine that is
represented by the program; let us call this machine M<sub>1</sub>. In
observing the operation of M<sub>1</sub>, the supercompiler COMPILES a
program which describes the activities of M<sub>1</sub>, but it makes
shortcuts and whatever clever tricks it knows in order to produce the
same effect as M<sub>1</sub>, but faster. The goal of the supercompiler
is to make the definition of this program (machine) M<sub>2</sub>
self-sufficient. When this is acheived, it outputs M<sub>2</sub> in some
intermediate language L<sup>sup</sup> and simply throws away the
(unchanged) machine M<sub>1</sub>.</p>
</blockquote><p>A supercompiler is interesting not only as a program transformer but
also as a very general philosophical concept:</p><blockquote>
<p>The supercompiler concept comes close to the way humans think and
make science. We do not think in terms of rules of formal logic. We
create mental and linguistic models of the reality we observe. How do we
do that? We observe phenomena, generalize observations, and try to
construct a self-sufficient model in terms of these generalizations.
This is also what the supercompiler does. … A supercompiler would run
M<sub>1</sub>, in a general form, with unknown values of variables, and
create a graph of states and transitions between possible configurations
of the computing system. … To make it finite, the supercompiler performs
the operation of generalization on the system configurations in such a
manner that it finally comes to a set of generalized configurations,
called <em>basic</em>, in terms of which the behavior of the system can
be expressed. Thus the new program becomes a self-sufficient model of
the old one.</p>
</blockquote><p>Since the above explanations are hard to comprehend at first sight, I
will try to illustrate supercompilation <em>by example</em>.</p><p>Let the object language of supercompilation be a simple first-order
functional language called <em>SLL</em>, which stands for <em>Simple
Lazy Language</em>. It consists of:</p><ul>
<li><strong>Variables:</strong> just regular symbolic identifiers.
<ul>
<li>Examples: <code>a</code>, <code>b</code>, <code>c</code>.</li>
</ul></li>
<li><strong>Constructors:</strong> symbolic identifiers that wrap their
arguments of arbitrary structure.
<ul>
<li>Examples: <code>Foo(a, b, c)</code>,
<code>Bar(a, Foo(a), c)</code>.</li>
</ul></li>
<li><strong>F-functions:</strong> <em>indifferent</em> functions that
just transform their arguments.
<ul>
<li>Examples:
<ul>
<li><code>foo(a, b, c) = Foo(a, b, Bar(c));</code></li>
<li><code>bar(a, b, c) = foo(Bar(a), b, c);</code></li>
</ul></li>
</ul></li>
<li><strong>G-functions:</strong> <em>curious</em> functions that
pattern-match on their first argument.
<ul>
<li>Examples: see below.</li>
</ul></li>
</ul><p>Suppose that natural numbers are represented as <code>Z</code>,
<code>S(Z)</code>, <code>S(S(Z))</code>, and so on <a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>.
Then, we can define addition as the following g-function (from <a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>):</p><div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a>add(Z, y) = y;</span>
<span id="cb1-2"><a href="#cb1-2"></a>add(S(x), y) = S(add(x, y));</span></code></pre></div><p>A supercompiler’s input is a pair of an expression and program, the
latter being a set of definitions of f- and g-functions. This pair is
usually called a <em>task</em>.</p><p>Let the task for a hypothetic supercompiler be the expression
<code>add(S(Z), S(S(Z)))</code> together with the definition of
<code>add</code> above. In this case, the work of a supercompiler is as
simple as sequential reduction of the initial expression to the target
expression <code>S(S(S(Z)))</code>, according to the rules of
<code>add</code>:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/add-1-2.png" width="400px"/></p><p>However, to think of a supercompiler as of a mere expression
evaluator is a grave mistake. Let us consider what happens when it
encounters a <em>variable</em> that does not stand for some concrete
expression. For example, let the task be <code>add(S(S(Z)), b)</code>
with the same definition of <code>add</code>, where <code>b</code> is
understood as “any” expression:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/add-2-b.png" width="400px"/></p><p>It <em>just</em> works!</p><p>A supercompiler saw the variable <code>b</code> when trying to reduce
<code>S(S(add(Z, b)))</code>, and then it just substituted
<code>y</code> (from the rule <code>add(Z, y)</code>) for this
<code>b</code>. After that, supercompilation has stopped because the
actual expression for <code>b</code> is unknown at this point. As a
result, we got <code>S(S(b))</code>, which is equivalent to the initial
expression.</p><p>Now consider what happens if there is a need to
<em>pattern-match</em> on an unknown variable. In this case, we cannot
just proceed with “direct” computation since there are several
possibilities of the form the variable may take. Suppose that the task
is <code>add(a, 2)</code> <a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> with the same function
<code>add</code>. What a supercompiler does is that it <em>analyze</em>
the expression <code>add(a, 2)</code> according to all the possibilities
of <code>a</code>, which are either <code>Z</code> or
<code>S(v1)</code>, where <code>v1</code> is some fresh variable
identifier. The situation looks like this:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/add-a-2.png" width="600px"/></p><p>A supercompiler has built an (incomplete) <em>process tree</em> that
describes the execution of <code>add(a, 2)</code> in a general sense. In
the first branch, <code>a</code> is substituted for <code>Z</code>
according to the first rule of <code>add</code>; in the second branch,
<code>a</code> is substituted for <code>S(v1)</code> according to the
second rule of <code>add</code>. The resulting two nodes are labelled
with expressions that resulted in reducing a particular substitution of
the parent expression.</p><p>However, the supercompilation is not complete yet: there is still a
node labelled as <code>S(add(v1, 2))</code>. A supercompiler decides to
<em>decompose</em> it, meaning to move <code>add(v1, 2)</code> out of
<code>S(...)</code> in the following way:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/add-a-2-decompose.png" width="600px"/></p><p>After that, if we proceed with supercompiling
<code>add(v1, 2)</code>, we will eventually arrive at the initial
expression <code>add(a, 2)</code>. This is because the expressions
<code>add(v1, 2)</code> and <code>add(a, 2)</code> are <em>alpha
equivalent</em>, meaning that they only differ in the names of
variables. A supercompiler should be smart enough to detect this
situation of alpha equivalence and, instead of continuing infinite
supercompilation, just draw a back arrow from <code>add(v1, 2)</code> to
the initial node as depicted below:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/add-a-2-loop.png" width="600px"/></p><p>Hooray, the supercompilation of <code>add(a, 2)</code> is now
complete!</p><p>What is left is to perform <em>residualization</em> – the process of
converting a process tree to an SLL task, a <em>self-sufficient
model</em> of the initial program. Every node in the graph (except for
leaf nodes) is transformed into a function whose parameters are the set
of free variables from the node expression; each function is given a
unique name. For example, if we see the node <code>add(a, 2)</code>
pointing to <code>2</code> and <code>S(add(v1, 2))</code>, we must
generate a new g-function of the following form:</p><div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a>g1(Z) = ...;</span>
<span id="cb2-2"><a href="#cb2-2"></a>g1(S(v1)) = ...;</span></code></pre></div><p>We can complete the first branch by inserting <code>2</code> in place
of <code>...</code>:</p><div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1"></a>g1(Z) = 2;</span>
<span id="cb3-2"><a href="#cb3-2"></a>g1(S(v1)) = ...;</span></code></pre></div><p>Since the second branch leads to a node that decomposes a
constructor, we generate a new f-function and call it inside
<code>S</code>:</p><div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a>g1(Z) = 2;</span>
<span id="cb4-2"><a href="#cb4-2"></a>g1(S(v1)) = S(f1(v1));</span>
<span id="cb4-3"><a href="#cb4-3"></a>f1(v1) = ...;</span></code></pre></div><p>According to the graph, the body of <code>f1</code> should be
<code>add(v1, 2)</code>, but since now <code>add</code> stands for
<code>g1</code>, the body will be <code>g1(v1)</code>:</p><div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1"></a>g1(Z) = 2;</span>
<span id="cb5-2"><a href="#cb5-2"></a>g1(S(v1)) = S(f1(v1));</span>
<span id="cb5-3"><a href="#cb5-3"></a>f1(v1) = g1(v1);</span></code></pre></div><p>Since <code>f1</code> is redundant, we can inline it as follows:</p><div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1"></a>g1(Z) = 2;</span>
<span id="cb6-2"><a href="#cb6-2"></a>g1(S(v1)) = S(g1(v1));</span></code></pre></div><p>This is the final residual <em>program</em>; the residual
<em>expression</em> will be <code>g1(a)</code>, since <code>a</code> is
the only free variable from the initial expression. As you can see, the
definition of <code>g1</code> is simpler than the original function
<code>add</code> in the sense that it accepts only one argument; the
second argument has been specialized to <code>2</code> during
supercompilation.</p><p>Perhaps a more interesting example would be specializing an
interpreter to a concrete program, obtaining a compiled “executable”. In
the partial computation literature, this is called the <em>first
Futamura projection</em> <a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>.</p><p>Consider the following interpreter <code>eq</code> (also from <a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>):</p><div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1"></a>eq(Z, y) = eqZ(y);</span>
<span id="cb7-2"><a href="#cb7-2"></a>eq(S(x), y) = eqS(y, x);</span>
<span id="cb7-3"><a href="#cb7-3"></a>eqZ(Z) = True;</span>
<span id="cb7-4"><a href="#cb7-4"></a>eqZ(S(x)) = False;</span>
<span id="cb7-5"><a href="#cb7-5"></a>eqS(Z, x) = False;</span>
<span id="cb7-6"><a href="#cb7-6"></a>eqS(S(y), x) = eq(x, y);</span></code></pre></div><p>which compares two Peano numbers for equality, resulting in either
<code>True</code> or <code>False</code>.</p><p>Now consider the expression <code>eq(S(S(Z)), x)</code> with the
above definition of <code>eq</code>; supercompilation will produce the
following residual program:</p><div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1"></a>eqZ3(Z) = True;</span>
<span id="cb8-2"><a href="#cb8-2"></a>eqZ3(S(v)) = False;</span>
<span id="cb8-3"><a href="#cb8-3"></a>eqS2(Z) = False;</span>
<span id="cb8-4"><a href="#cb8-4"></a>eqS2(S(v)) = eqZ3(v);</span>
<span id="cb8-5"><a href="#cb8-5"></a>eqS1(Z) = False;</span>
<span id="cb8-6"><a href="#cb8-6"></a>eqS1(S(v)) = eqS2(v);</span></code></pre></div><p>together with the residual expression <code>eqS1(x)</code>. In a
sense, we have obtained a compiled version of <code>eq</code>
specialized to <code>S(S(Z))</code>, because <code>eqS1</code>
pattern-matches only on an unknown variable <code>x</code> instead of
the known “program” <code>S(S(Z))</code>.</p><p>However, supercompilation is inherently more powerful than classical
partial evaluation. In Turchin’s own words <a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>:</p><blockquote>
<p>Although supercompilation includes partial evaluation, it does not
reduce to it. Supercompilation can lead to a very deep structural
transformation of the original program; it can improve the program even
if all the actual parameters in the function calls are variable. The
supercompilation process aims at the reduction of redundancy in the
original program, but this redundancy does not necessarily come from
fixed values of variables; it can result from nested loops, repeated
variables, and so on.</p>
</blockquote><p>That being said, a <a href="https://twitter.com/hirrolot/status/1741049231656280289">sufficiently
smart supercompiler</a> can transform a two-pass list mapping into a
single-pass algorithm, essentially performing <em>list fusion</em>:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/list-fusion.jpeg"/></p><p>A similar example can be found in <em>“Rethinking
Supercompilation”</em> by Neil Mitchell <a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a> and
in <a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a> (section 6, <em>“Examples of
supercompilation”</em>).</p><hr/><p>Although I have deliberately skipped a few important aspects of
supercompilation, most notably termination checking (see homeomorphic
embedding <a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a> <a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a>
<a href="#fn12" id="fnref12" role="doc-noteref"><sup>12</sup></a>), the material presented in this
section should be enough to understand the rest of the text. An
interested reader may go through the references and also look into <a href="#fn13" id="fnref13" role="doc-noteref"><sup>13</sup></a> <a href="#fn14" id="fnref14" role="doc-noteref"><sup>14</sup></a>
<a href="#fn15" id="fnref15" role="doc-noteref"><sup>15</sup></a> for some insight into a more
general topic of <em>metacomputation</em>. A more thorough introduction
to supercompilation can be found in <a href="https://themonadreader.files.wordpress.com/2014/04/super-final.pdf"><em>“Supercompilation:
Ideas and Methods”</em></a> by Ilya Klyuchnikov and Dimitur Krustev.</p><a href="#sat-and-dead-code-elimination"><h2 id="sat-and-dead-code-elimination">SAT and dead code
elimination</h2></a><p>Not let us consider how SAT can be reduced to the problem of <a href="https://en.wikipedia.org/wiki/Dead-code_elimination">dead code
elimination</a>.</p><p>Consider a language whose expressions are:</p><ul>
<li><code>If (x, m, n)</code>, where <code>x</code> is a variable,
<code>m</code> and <code>n</code> are expressions.</li>
<li><code>T</code> and <code>F</code>, which are constants.</li>
</ul><p>This language is enough to encode any SAT problem. We can encode each
clause in the formula as follows (in pseudocode):</p><div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1"></a>OR(x, ...) = If (x, T, ...);</span>
<span id="cb9-2"><a href="#cb9-2"></a>OR(NOT x, ...) = If (x, ..., T);</span></code></pre></div><p>Then <code>OR(x, OR(y, OR(NOT z, F)))</code> would correspond to “x
OR y OR NOT z”:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/if-x-y-not-z.png" width="550px"/></p><p>Now consider the encoding of a conjunction of clauses <a href="#fn16" id="fnref16" role="doc-noteref"><sup>16</sup></a>:</p><div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1"></a>AND(If(x, m, n), ...) = If(x, AND(m, ...), AND(n, ...));</span>
<span id="cb10-2"><a href="#cb10-2"></a>AND(T, ...) = ...;</span>
<span id="cb10-3"><a href="#cb10-3"></a>AND(F, ...) = F;</span></code></pre></div><p>Then <code>AND(OR(x, F), AND(OR(NOT y, F), T))</code> would
correspond to “x AND NOT y”:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/x-and-not-y.png" width="550px"/></p><p>Is the formula satisfiable? Yes, because we can assign <code>x</code>
to <code>T</code> and <code>y</code> to <code>F</code>.</p><p>Now consider the formula
<code>AND(OR(x, F), AND(OR(NOT x, F), T))</code>, which is equivalent to
“x AND NOT x”:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/x-and-not-x.png" width="550px"/></p><p>Is the formula satisfiable? To figure out, let us remove <em>dead
paths</em> from the formula:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/if-x-f-f.png" width="550px"/></p><p>We have replaced the lower <code>if x</code> node with its first
child <code>F</code> because <code>x</code> was already assigned
<code>T</code> in this path. Since there are no <code>T</code> leafs in
the resulting tree, it is correct to say that the formula is
unsatisfiable: with any value of <code>x</code> we will arrive at
<code>F</code>.</p><p>One more example is
<code>AND(OR(x, F), AND(OR(x, OR(y, F)), AND(OR(NOT x, F), T)))</code>,
which is equivalent to “x AND (y OR z) AND NOT x”:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/if-last-example.png" width="600px"/></p><p>After removing dead paths:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/if-last-example-final.png" width="600px"/></p><p>The general observation is that, after encoding a CNF formula as an
if-tree and removing dead paths from it, if there is at least one
<code>T</code> leaf, the initial formula is satisfiable; otherwise, the
formula is unsatisfiable because there is no path from the root that
will take us to <code>T</code>. Think about it for a moment.</p><p>Having this technique at our disposal, we can proceed to the key
section.</p><a href="#supercompilation-of-sat"><h2 id="supercompilation-of-sat">Supercompilation of SAT</h2></a><p><em>Positive supercompilation</em> is a particular model of
supercompilation that propagates only <em>positive information</em> when
doing case analysis. For example, when supercompiling
<code>add(a, 2)</code>, a positive supercompiler will substitute (i.e.,
propagate) <code>a=Z</code> and <code>a=S(v1)</code> to the respective
children nodes. On the other hand, <em>negative information</em> means
that some variable is <em>not</em> equal to a particular value (or
values); a typical example is the “default” case in a pattern-matching
construction. A <em>perfect supercompiler</em> is a supercompiler that
is able to propagate both positive and negative information.</p><p>In this post, we only deal with positive supercompilation. Consider
the schematic representation of the CNF formula “x AND NOT x” again:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/x-and-not-x.png" width="550px"/></p><p>Imagine that <code>if</code>, <code>T</code>, and <code>F</code> are
SLL constructors, with <code>if</code> holding three arguments: two
branches and a variable, which is <code>T</code> in the first branch and
<code>F</code> in the second. If we analyze the uppermost
<code>if x</code>, we will get the following “process tree” <a href="#fn17" id="fnref17" role="doc-noteref"><sup>17</sup></a>:</p><p><img src="https://parse.rnksngh.com/rnksngh.github.io/2024/01/media/sat-supercompilation/if-x-f-f.png" width="550px"/></p><p>Supercompilation acted as a dead code eliminator! This is because
<code>x=T</code> was propagated to the first branch of the uppermost
<code>if x</code>, resulting in the elimination of the branch
<code>T</code> of the innermost <code>if x</code>. The second uppermost
branch remains unchanged.</p><p>What if we somehow launch analysis of the whole if-tree? If so, we
would essentially eliminate all dead paths from the corresponding
expression, which is equivalent to solving the SAT problem! As I have
mentioned in the previous section, if there is at least one
<code>T</code> leaf in the final tree, the formula is satisfiable
because this <code>T</code> is reachable from the root. Otherwise (if
there is no <code>T</code>), the formula is unsatisfiable <a href="#fn18" id="fnref18" role="doc-noteref"><sup>18</sup></a>.</p><p>Here is a complete SAT solver written in SLL:</p><div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1"></a>or(Var(x), rest) = If(x, T, rest);</span>
<span id="cb11-2"><a href="#cb11-2"></a>or(Not(x), rest) = If(x, rest, T);</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a>and(If(x, m, n), rest) = If(x, and(m, rest), and(n, rest));</span>
<span id="cb11-5"><a href="#cb11-5"></a>and(T, rest) = rest;</span>
<span id="cb11-6"><a href="#cb11-6"></a>and(F, rest) = F;</span>
<span id="cb11-7"><a href="#cb11-7"></a></span>
<span id="cb11-8"><a href="#cb11-8"></a>solve(If(x, m, n)) = analyze(x, solve(m), solve(n));</span>
<span id="cb11-9"><a href="#cb11-9"></a>solve(T) = T;</span>
<span id="cb11-10"><a href="#cb11-10"></a>solve(F) = F;</span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>analyze(T, m, n) = m;</span>
<span id="cb11-13"><a href="#cb11-13"></a>analyze(F, m, n) = n;</span></code></pre></div><p>Without blank lines, it is 10 lines of code! This is probably the
simplest (and the slowest!) SAT solver in the history of humanity.</p><p>The functions <code>or</code> and <code>and</code> are the encodings
of the logical OR and AND operations, respectively. The function
<code>solve</code> is the main entry point of the solver, and
<code>analyze</code> is a helper function that selects one of the two
branches of an <code>if</code>-expression according to the value of the
first argument. Since <code>solve</code> traverses the whole expression
and invokes <code>analyze</code> for each <code>If (x, m, n)</code>, all
<code>If</code>-nodes in the expression are case-analyzed when
<code>solve(formula)</code> is being supercompiled.</p><p>To test the solver, I will use my own <a href="https://gist.github.com/Hirrolot/35e3c40e49e01cfb11d67b6bcc67b23e">positive
supercompiler written in OCaml</a>. The definitions of <code>or</code>,
<code>and</code>, <code>solve</code>, and <code>analyze</code> will
be:</p><div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1"></a><span>let</span> g_rules =</span>
<span id="cb12-2"><a href="#cb12-2"></a>  [</span>
<span id="cb12-3"><a href="#cb12-3"></a>    ( <span>&#34;or&#34;</span>,</span>
<span id="cb12-4"><a href="#cb12-4"></a>      [</span>
<span id="cb12-5"><a href="#cb12-5"></a>        ( (<span>&#34;Var&#34;</span>, [ <span>&#34;x&#34;</span> ]),</span>
<span id="cb12-6"><a href="#cb12-6"></a>          [ <span>&#34;rest&#34;</span> ],</span>
<span id="cb12-7"><a href="#cb12-7"></a>          ctr_call (<span>&#34;If&#34;</span>, [ Var <span>&#34;x&#34;</span>; ctr_call (<span>&#34;T&#34;</span>, []); Var <span>&#34;rest&#34;</span> ]) );</span>
<span id="cb12-8"><a href="#cb12-8"></a>        ( (<span>&#34;Not&#34;</span>, [ <span>&#34;x&#34;</span> ]),</span>
<span id="cb12-9"><a href="#cb12-9"></a>          [ <span>&#34;rest&#34;</span> ],</span>
<span id="cb12-10"><a href="#cb12-10"></a>          ctr_call (<span>&#34;If&#34;</span>, [ Var <span>&#34;x&#34;</span>; Var <span>&#34;rest&#34;</span>; ctr_call (<span>&#34;T&#34;</span>, []) ]) );</span>
<span id="cb12-11"><a href="#cb12-11"></a>      ] );</span>
<span id="cb12-12"><a href="#cb12-12"></a>    ( <span>&#34;and&#34;</span>,</span>
<span id="cb12-13"><a href="#cb12-13"></a>      [</span>
<span id="cb12-14"><a href="#cb12-14"></a>        ( (<span>&#34;If&#34;</span>, [ <span>&#34;x&#34;</span>; <span>&#34;m&#34;</span>; <span>&#34;n&#34;</span> ]),</span>
<span id="cb12-15"><a href="#cb12-15"></a>          [ <span>&#34;rest&#34;</span> ],</span>
<span id="cb12-16"><a href="#cb12-16"></a>          ctr_call</span>
<span id="cb12-17"><a href="#cb12-17"></a>            ( <span>&#34;If&#34;</span>,</span>
<span id="cb12-18"><a href="#cb12-18"></a>              [</span>
<span id="cb12-19"><a href="#cb12-19"></a>                Var <span>&#34;x&#34;</span>;</span>
<span id="cb12-20"><a href="#cb12-20"></a>                g_call (<span>&#34;and&#34;</span>, Var <span>&#34;m&#34;</span>, [ Var <span>&#34;rest&#34;</span> ]);</span>
<span id="cb12-21"><a href="#cb12-21"></a>                g_call (<span>&#34;and&#34;</span>, Var <span>&#34;n&#34;</span>, [ Var <span>&#34;rest&#34;</span> ]);</span>
<span id="cb12-22"><a href="#cb12-22"></a>              ] ) );</span>
<span id="cb12-23"><a href="#cb12-23"></a>        ((<span>&#34;T&#34;</span>, []), [ <span>&#34;rest&#34;</span> ], Var <span>&#34;rest&#34;</span>);</span>
<span id="cb12-24"><a href="#cb12-24"></a>        ((<span>&#34;F&#34;</span>, []), [ <span>&#34;rest&#34;</span> ], ctr_call (<span>&#34;F&#34;</span>, []));</span>
<span id="cb12-25"><a href="#cb12-25"></a>      ] );</span>
<span id="cb12-26"><a href="#cb12-26"></a>    ( <span>&#34;solve&#34;</span>,</span>
<span id="cb12-27"><a href="#cb12-27"></a>      [</span>
<span id="cb12-28"><a href="#cb12-28"></a>        ( (<span>&#34;If&#34;</span>, [ <span>&#34;x&#34;</span>; <span>&#34;m&#34;</span>; <span>&#34;n&#34;</span> ]),</span>
<span id="cb12-29"><a href="#cb12-29"></a>          [],</span>
<span id="cb12-30"><a href="#cb12-30"></a>          g_call</span>
<span id="cb12-31"><a href="#cb12-31"></a>            ( <span>&#34;analyze&#34;</span>,</span>
<span id="cb12-32"><a href="#cb12-32"></a>              Var <span>&#34;x&#34;</span>,</span>
<span id="cb12-33"><a href="#cb12-33"></a>              [ g_call (<span>&#34;solve&#34;</span>, Var <span>&#34;m&#34;</span>, []); g_call (<span>&#34;solve&#34;</span>, Var <span>&#34;n&#34;</span>, []) ]</span>
<span id="cb12-34"><a href="#cb12-34"></a>            ) );</span>
<span id="cb12-35"><a href="#cb12-35"></a>        ((<span>&#34;T&#34;</span>, []), [], ctr_call (<span>&#34;T&#34;</span>, []));</span>
<span id="cb12-36"><a href="#cb12-36"></a>        ((<span>&#34;F&#34;</span>, []), [], ctr_call (<span>&#34;F&#34;</span>, []));</span>
<span id="cb12-37"><a href="#cb12-37"></a>      ] );</span>
<span id="cb12-38"><a href="#cb12-38"></a>    ( <span>&#34;analyze&#34;</span>,</span>
<span id="cb12-39"><a href="#cb12-39"></a>      [ ((<span>&#34;T&#34;</span>, []), [ <span>&#34;m&#34;</span>; <span>&#34;n&#34;</span> ], Var <span>&#34;m&#34;</span>); ((<span>&#34;F&#34;</span>, []), [ <span>&#34;m&#34;</span>; <span>&#34;n&#34;</span> ], Var <span>&#34;n&#34;</span>) ]</span>
<span id="cb12-40"><a href="#cb12-40"></a>    );</span>
<span id="cb12-41"><a href="#cb12-41"></a>  ]</span></code></pre></div><p>And some helper functions in OCaml to conveniently construct CNF
formulas:</p><div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1"></a><span>let</span> <span>rec</span> clause = <span>function</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>  | `Var x :: rest -&gt; g_call (<span>&#34;or&#34;</span>, ctr_call (<span>&#34;Var&#34;</span>, [ Var x ]), [ clause rest ])</span>
<span id="cb13-3"><a href="#cb13-3"></a>  | `Not x :: rest -&gt; g_call (<span>&#34;or&#34;</span>, ctr_call (<span>&#34;Not&#34;</span>, [ Var x ]), [ clause rest ])</span>
<span id="cb13-4"><a href="#cb13-4"></a>  | [] -&gt; ctr_call (<span>&#34;F&#34;</span>, [])</span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span>let</span> <span>rec</span> formula = <span>function</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  | hd :: rest -&gt; g_call (<span>&#34;and&#34;</span>, hd, [ formula rest ])</span>
<span id="cb13-8"><a href="#cb13-8"></a>  | [] -&gt; ctr_call (<span>&#34;T&#34;</span>, [])</span></code></pre></div><p>The function <code>check</code> calls <code>optimize</code>, which is
supercompilation + residualization, on a given <code>formula</code>, and
compares the resudual task with <code>expected</code>:</p><div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1"></a><span>let</span> check ~expected formula =</span>
<span id="cb14-2"><a href="#cb14-2"></a>  check ~equal:[%derive.eq: <span>string</span> * <span>string</span> <span>list</span>]</span>
<span id="cb14-3"><a href="#cb14-3"></a>    ~show:[%derive.show: <span>string</span> * <span>string</span> <span>list</span>] ~expected</span>
<span id="cb14-4"><a href="#cb14-4"></a>    ~actual:(optimize ~g_rules (g_call (<span>&#34;solve&#34;</span>, formula, [])))</span></code></pre></div><p>Testing “x AND y”:</p><div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1"></a><span>let</span> () =</span>
<span id="cb15-2"><a href="#cb15-2"></a>  check</span>
<span id="cb15-3"><a href="#cb15-3"></a>    ~expected:</span>
<span id="cb15-4"><a href="#cb15-4"></a>      ( <span>&#34;g0(x, y)&#34;</span>,</span>
<span id="cb15-5"><a href="#cb15-5"></a>        [</span>
<span id="cb15-6"><a href="#cb15-6"></a>          <span>&#34;g0(F(), y) = F()&#34;</span>;</span>
<span id="cb15-7"><a href="#cb15-7"></a>          <span>&#34;g0(T(), y) = g1(y)&#34;</span>;</span>
<span id="cb15-8"><a href="#cb15-8"></a>          <span>&#34;g1(F()) = F()&#34;</span>;</span>
<span id="cb15-9"><a href="#cb15-9"></a>          <span>&#34;g1(T()) = T()&#34;</span>;</span>
<span id="cb15-10"><a href="#cb15-10"></a>        ] )</span>
<span id="cb15-11"><a href="#cb15-11"></a>    (formula [ clause [ `Var <span>&#34;x&#34;</span> ]; clause [ `Var <span>&#34;y&#34;</span> ] ]);</span></code></pre></div><p>The residual function <code>g0</code> acts as the AND operation. The
formula is <strong>satisfiable</strong>.</p><p>Testing “(x OR y) AND NOT z”:</p><div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1"></a>  check</span>
<span id="cb16-2"><a href="#cb16-2"></a>    ~expected:</span>
<span id="cb16-3"><a href="#cb16-3"></a>      ( <span>&#34;g0(x, y, z)&#34;</span>,</span>
<span id="cb16-4"><a href="#cb16-4"></a>        [</span>
<span id="cb16-5"><a href="#cb16-5"></a>          <span>&#34;g0(F(), y, z) = g1(y, z)&#34;</span>;</span>
<span id="cb16-6"><a href="#cb16-6"></a>          <span>&#34;g0(T(), y, z) = g3(z)&#34;</span>;</span>
<span id="cb16-7"><a href="#cb16-7"></a>          <span>&#34;g1(F(), z) = F()&#34;</span>;</span>
<span id="cb16-8"><a href="#cb16-8"></a>          <span>&#34;g1(T(), z) = g2(z)&#34;</span>;</span>
<span id="cb16-9"><a href="#cb16-9"></a>          <span>&#34;g2(F()) = T()&#34;</span>;</span>
<span id="cb16-10"><a href="#cb16-10"></a>          <span>&#34;g2(T()) = F()&#34;</span>;</span>
<span id="cb16-11"><a href="#cb16-11"></a>          <span>&#34;g3(F()) = T()&#34;</span>;</span>
<span id="cb16-12"><a href="#cb16-12"></a>          <span>&#34;g3(T()) = F()&#34;</span>;</span>
<span id="cb16-13"><a href="#cb16-13"></a>        ] )</span>
<span id="cb16-14"><a href="#cb16-14"></a>    (formula [ clause [ `Var <span>&#34;x&#34;</span>; `Var <span>&#34;y&#34;</span> ]; clause [ `Not <span>&#34;z&#34;</span> ] ]);</span></code></pre></div><p>The formula is TRUE when either “x” or “y” are TRUE (or both), whilst
“z” must always be FALSE. The formula is
<strong>satisfiable</strong>.</p><p>Testing “(x OR NOT z) AND (y OR z OR NOT x)”:</p><div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1"></a>  check</span>
<span id="cb17-2"><a href="#cb17-2"></a>    ~expected:</span>
<span id="cb17-3"><a href="#cb17-3"></a>      ( <span>&#34;g0(x, y, z)&#34;</span>,</span>
<span id="cb17-4"><a href="#cb17-4"></a>        [</span>
<span id="cb17-5"><a href="#cb17-5"></a>          <span>&#34;g0(F(), y, z) = g1(z, y)&#34;</span>;</span>
<span id="cb17-6"><a href="#cb17-6"></a>          <span>&#34;g0(T(), y, z) = g3(y, z)&#34;</span>;</span>
<span id="cb17-7"><a href="#cb17-7"></a>          <span>&#34;g1(F(), y) = g2(y)&#34;</span>;</span>
<span id="cb17-8"><a href="#cb17-8"></a>          <span>&#34;g1(T(), y) = F()&#34;</span>;</span>
<span id="cb17-9"><a href="#cb17-9"></a>          <span>&#34;g2(F()) = T()&#34;</span>;</span>
<span id="cb17-10"><a href="#cb17-10"></a>          <span>&#34;g2(T()) = T()&#34;</span>;</span>
<span id="cb17-11"><a href="#cb17-11"></a>          <span>&#34;g3(F(), z) = g4(z)&#34;</span>;</span>
<span id="cb17-12"><a href="#cb17-12"></a>          <span>&#34;g3(T(), z) = T()&#34;</span>;</span>
<span id="cb17-13"><a href="#cb17-13"></a>          <span>&#34;g4(F()) = F()&#34;</span>;</span>
<span id="cb17-14"><a href="#cb17-14"></a>          <span>&#34;g4(T()) = T()&#34;</span>;</span>
<span id="cb17-15"><a href="#cb17-15"></a>        ] )</span>
<span id="cb17-16"><a href="#cb17-16"></a>    (formula</span>
<span id="cb17-17"><a href="#cb17-17"></a>       [</span>
<span id="cb17-18"><a href="#cb17-18"></a>         clause [ `Var <span>&#34;x&#34;</span>; `Not <span>&#34;z&#34;</span> ]; clause [ `Var <span>&#34;y&#34;</span>; `Var <span>&#34;z&#34;</span>; `Not <span>&#34;x&#34;</span> ];</span>
<span id="cb17-19"><a href="#cb17-19"></a>       ]);</span></code></pre></div><p>Ditto.</p><p>Testing “(a OR b) AND (NOT b OR NOT d) AND (c OR d) AND (NOT d OR NOT
e) AND (e OR NOT f) AND (f OR NOT g) AND (f OR g) AND (g OR NOT p) AND
(h OR NOT i) AND (NOT h OR NOT n) AND (i OR g) AND (i OR NOT g) AND (NOT
g OR NOT k) AND (g OR l) AND (k OR l) AND (m OR n) AND (n OR NOT o) AND
(o OR p)”:</p><details>
<summary>
Show the test case
</summary>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1"></a>  check</span>
<span id="cb18-2"><a href="#cb18-2"></a>    ~expected:</span>
<span id="cb18-3"><a href="#cb18-3"></a>      ( <span>&#34;g0(a, b, c, d, e, f, g, h, i, k, l, m, n, o, p)&#34;</span>,</span>
<span id="cb18-4"><a href="#cb18-4"></a>        [</span>
<span id="cb18-5"><a href="#cb18-5"></a>          <span>&#34;g0(F(), b, c, d, e, f, g, h, i, k, l, m, n, o, p) = g1(b, c, d, e, </span><span>\</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span>           f, g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-7"><a href="#cb18-7"></a>          <span>&#34;g0(T(), b, c, d, e, f, g, h, i, k, l, m, n, o, p) = g30(b, c, d, e, </span><span>\</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span>           f, g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-9"><a href="#cb18-9"></a>          <span>&#34;g1(F(), c, d, e, f, g, h, i, k, l, m, n, o, p) = F()&#34;</span>;</span>
<span id="cb18-10"><a href="#cb18-10"></a>          <span>&#34;g1(T(), c, d, e, f, g, h, i, k, l, m, n, o, p) = g2(d, c, e, f, g, </span><span>\</span></span>
<span id="cb18-11"><a href="#cb18-11"></a><span>           h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-12"><a href="#cb18-12"></a>          <span>&#34;g10(F(), h, i, k, l, m, n, o) = g11(h, i, k, l, m, n, o)&#34;</span>;</span>
<span id="cb18-13"><a href="#cb18-13"></a>          <span>&#34;g10(T(), h, i, k, l, m, n, o) = F()&#34;</span>;</span>
<span id="cb18-14"><a href="#cb18-14"></a>          <span>&#34;g11(F(), i, k, l, m, n, o) = g12(i)&#34;</span>;</span>
<span id="cb18-15"><a href="#cb18-15"></a>          <span>&#34;g11(T(), i, k, l, m, n, o) = g13(n, i, k, l, m, o)&#34;</span>;</span>
<span id="cb18-16"><a href="#cb18-16"></a>          <span>&#34;g12(F()) = F()&#34;</span>;</span>
<span id="cb18-17"><a href="#cb18-17"></a>          <span>&#34;g12(T()) = F()&#34;</span>;</span>
<span id="cb18-18"><a href="#cb18-18"></a>          <span>&#34;g13(F(), i, k, l, m, o) = g14(i, k, l, m, o)&#34;</span>;</span>
<span id="cb18-19"><a href="#cb18-19"></a>          <span>&#34;g13(T(), i, k, l, m, o) = F()&#34;</span>;</span>
<span id="cb18-20"><a href="#cb18-20"></a>          <span>&#34;g14(F(), k, l, m, o) = F()&#34;</span>;</span>
<span id="cb18-21"><a href="#cb18-21"></a>          <span>&#34;g14(T(), k, l, m, o) = g15(l, k, m, o)&#34;</span>;</span>
<span id="cb18-22"><a href="#cb18-22"></a>          <span>&#34;g15(F(), k, m, o) = F()&#34;</span>;</span>
<span id="cb18-23"><a href="#cb18-23"></a>          <span>&#34;g15(T(), k, m, o) = g16(k, m, o)&#34;</span>;</span>
<span id="cb18-24"><a href="#cb18-24"></a>          <span>&#34;g16(F(), m, o) = g17(m, o)&#34;</span>;</span>
<span id="cb18-25"><a href="#cb18-25"></a>          <span>&#34;g16(T(), m, o) = g19(m, o)&#34;</span>;</span>
<span id="cb18-26"><a href="#cb18-26"></a>          <span>&#34;g17(F(), o) = F()&#34;</span>;</span>
<span id="cb18-27"><a href="#cb18-27"></a>          <span>&#34;g17(T(), o) = g18(o)&#34;</span>;</span>
<span id="cb18-28"><a href="#cb18-28"></a>          <span>&#34;g18(F()) = F()&#34;</span>;</span>
<span id="cb18-29"><a href="#cb18-29"></a>          <span>&#34;g18(T()) = F()&#34;</span>;</span>
<span id="cb18-30"><a href="#cb18-30"></a>          <span>&#34;g19(F(), o) = F()&#34;</span>;</span>
<span id="cb18-31"><a href="#cb18-31"></a>          <span>&#34;g19(T(), o) = g20(o)&#34;</span>;</span>
<span id="cb18-32"><a href="#cb18-32"></a>          <span>&#34;g2(F(), c, e, f, g, h, i, k, l, m, n, o, p) = g3(c, e, f, g, h, i, </span><span>\</span></span>
<span id="cb18-33"><a href="#cb18-33"></a><span>           k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-34"><a href="#cb18-34"></a>          <span>&#34;g2(T(), c, e, f, g, h, i, k, l, m, n, o, p) = F()&#34;</span>;</span>
<span id="cb18-35"><a href="#cb18-35"></a>          <span>&#34;g20(F()) = F()&#34;</span>;</span>
<span id="cb18-36"><a href="#cb18-36"></a>          <span>&#34;g20(T()) = F()&#34;</span>;</span>
<span id="cb18-37"><a href="#cb18-37"></a>          <span>&#34;g21(F(), i, k, l, m, n, o, p) = g22(i)&#34;</span>;</span>
<span id="cb18-38"><a href="#cb18-38"></a>          <span>&#34;g21(T(), i, k, l, m, n, o, p) = g23(n, i, k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-39"><a href="#cb18-39"></a>          <span>&#34;g22(F()) = F()&#34;</span>;</span>
<span id="cb18-40"><a href="#cb18-40"></a>          <span>&#34;g22(T()) = F()&#34;</span>;</span>
<span id="cb18-41"><a href="#cb18-41"></a>          <span>&#34;g23(F(), i, k, l, m, o, p) = g24(i, k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-42"><a href="#cb18-42"></a>          <span>&#34;g23(T(), i, k, l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-43"><a href="#cb18-43"></a>          <span>&#34;g24(F(), k, l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-44"><a href="#cb18-44"></a>          <span>&#34;g24(T(), k, l, m, o, p) = g25(k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-45"><a href="#cb18-45"></a>          <span>&#34;g25(F(), l, m, o, p) = g26(l, m, o, p)&#34;</span>;</span>
<span id="cb18-46"><a href="#cb18-46"></a>          <span>&#34;g25(T(), l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-47"><a href="#cb18-47"></a>          <span>&#34;g26(F(), m, o, p) = F()&#34;</span>;</span>
<span id="cb18-48"><a href="#cb18-48"></a>          <span>&#34;g26(T(), m, o, p) = g27(m, o, p)&#34;</span>;</span>
<span id="cb18-49"><a href="#cb18-49"></a>          <span>&#34;g27(F(), o, p) = F()&#34;</span>;</span>
<span id="cb18-50"><a href="#cb18-50"></a>          <span>&#34;g27(T(), o, p) = g28(o, p)&#34;</span>;</span>
<span id="cb18-51"><a href="#cb18-51"></a>          <span>&#34;g28(F(), p) = g29(p)&#34;</span>;</span>
<span id="cb18-52"><a href="#cb18-52"></a>          <span>&#34;g28(T(), p) = F()&#34;</span>;</span>
<span id="cb18-53"><a href="#cb18-53"></a>          <span>&#34;g29(F()) = F()&#34;</span>;</span>
<span id="cb18-54"><a href="#cb18-54"></a>          <span>&#34;g29(T()) = T()&#34;</span>;</span>
<span id="cb18-55"><a href="#cb18-55"></a>          <span>&#34;g3(F(), e, f, g, h, i, k, l, m, n, o, p) = F()&#34;</span>;</span>
<span id="cb18-56"><a href="#cb18-56"></a>          <span>&#34;g3(T(), e, f, g, h, i, k, l, m, n, o, p) = g4(e, f, g, h, i, k, l, </span><span>\</span></span>
<span id="cb18-57"><a href="#cb18-57"></a><span>           m, n, o, p)&#34;</span>;</span>
<span id="cb18-58"><a href="#cb18-58"></a>          <span>&#34;g30(F(), c, d, e, f, g, h, i, k, l, m, n, o, p) = g31(c, d, e, f, </span><span>\</span></span>
<span id="cb18-59"><a href="#cb18-59"></a><span>           g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-60"><a href="#cb18-60"></a>          <span>&#34;g30(T(), c, d, e, f, g, h, i, k, l, m, n, o, p) = g66(d, c, e, f, </span><span>\</span></span>
<span id="cb18-61"><a href="#cb18-61"></a><span>           g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-62"><a href="#cb18-62"></a>          <span>&#34;g31(F(), d, e, f, g, h, i, k, l, m, n, o, p) = g32(d, e, f, g)&#34;</span>;</span>
<span id="cb18-63"><a href="#cb18-63"></a>          <span>&#34;g31(T(), d, e, f, g, h, i, k, l, m, n, o, p) = g36(d, e, f, g, h, </span><span>\</span></span>
<span id="cb18-64"><a href="#cb18-64"></a><span>           i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-65"><a href="#cb18-65"></a>          <span>&#34;g32(F(), e, f, g) = F()&#34;</span>;</span>
<span id="cb18-66"><a href="#cb18-66"></a>          <span>&#34;g32(T(), e, f, g) = g33(e, f, g)&#34;</span>;</span>
<span id="cb18-67"><a href="#cb18-67"></a>          <span>&#34;g33(F(), f, g) = g34(f, g)&#34;</span>;</span>
<span id="cb18-68"><a href="#cb18-68"></a>          <span>&#34;g33(T(), f, g) = F()&#34;</span>;</span>
<span id="cb18-69"><a href="#cb18-69"></a>          <span>&#34;g34(F(), g) = g35(g)&#34;</span>;</span>
<span id="cb18-70"><a href="#cb18-70"></a>          <span>&#34;g34(T(), g) = F()&#34;</span>;</span>
<span id="cb18-71"><a href="#cb18-71"></a>          <span>&#34;g35(F()) = F()&#34;</span>;</span>
<span id="cb18-72"><a href="#cb18-72"></a>          <span>&#34;g35(T()) = F()&#34;</span>;</span>
<span id="cb18-73"><a href="#cb18-73"></a>          <span>&#34;g36(F(), e, f, g, h, i, k, l, m, n, o, p) = g37(e, f, g, h, i, k, </span><span>\</span></span>
<span id="cb18-74"><a href="#cb18-74"></a><span>           l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-75"><a href="#cb18-75"></a>          <span>&#34;g36(T(), e, f, g, h, i, k, l, m, n, o, p) = g63(e, f, g)&#34;</span>;</span>
<span id="cb18-76"><a href="#cb18-76"></a>          <span>&#34;g37(F(), f, g, h, i, k, l, m, n, o, p) = g38(f, g)&#34;</span>;</span>
<span id="cb18-77"><a href="#cb18-77"></a>          <span>&#34;g37(T(), f, g, h, i, k, l, m, n, o, p) = g40(f, g, h, i, k, l, m, </span><span>\</span></span>
<span id="cb18-78"><a href="#cb18-78"></a><span>           n, o, p)&#34;</span>;</span>
<span id="cb18-79"><a href="#cb18-79"></a>          <span>&#34;g38(F(), g) = g39(g)&#34;</span>;</span>
<span id="cb18-80"><a href="#cb18-80"></a>          <span>&#34;g38(T(), g) = F()&#34;</span>;</span>
<span id="cb18-81"><a href="#cb18-81"></a>          <span>&#34;g39(F()) = F()&#34;</span>;</span>
<span id="cb18-82"><a href="#cb18-82"></a>          <span>&#34;g39(T()) = F()&#34;</span>;</span>
<span id="cb18-83"><a href="#cb18-83"></a>          <span>&#34;g4(F(), f, g, h, i, k, l, m, n, o, p) = g5(f, g)&#34;</span>;</span>
<span id="cb18-84"><a href="#cb18-84"></a>          <span>&#34;g4(T(), f, g, h, i, k, l, m, n, o, p) = g7(f, g, h, i, k, l, m, n, </span><span>\</span></span>
<span id="cb18-85"><a href="#cb18-85"></a><span>           o, p)&#34;</span>;</span>
<span id="cb18-86"><a href="#cb18-86"></a>          <span>&#34;g40(F(), g, h, i, k, l, m, n, o, p) = g41(g)&#34;</span>;</span>
<span id="cb18-87"><a href="#cb18-87"></a>          <span>&#34;g40(T(), g, h, i, k, l, m, n, o, p) = g42(g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-88"><a href="#cb18-88"></a>          <span>&#34;g41(F()) = F()&#34;</span>;</span>
<span id="cb18-89"><a href="#cb18-89"></a>          <span>&#34;g41(T()) = F()&#34;</span>;</span>
<span id="cb18-90"><a href="#cb18-90"></a>          <span>&#34;g42(F(), h, i, k, l, m, n, o, p) = g43(p, h, i, k, l, m, n, o)&#34;</span>;</span>
<span id="cb18-91"><a href="#cb18-91"></a>          <span>&#34;g42(T(), h, i, k, l, m, n, o, p) = g54(h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-92"><a href="#cb18-92"></a>          <span>&#34;g43(F(), h, i, k, l, m, n, o) = g44(h, i, k, l, m, n, o)&#34;</span>;</span>
<span id="cb18-93"><a href="#cb18-93"></a>          <span>&#34;g43(T(), h, i, k, l, m, n, o) = F()&#34;</span>;</span>
<span id="cb18-94"><a href="#cb18-94"></a>          <span>&#34;g44(F(), i, k, l, m, n, o) = g45(i)&#34;</span>;</span>
<span id="cb18-95"><a href="#cb18-95"></a>          <span>&#34;g44(T(), i, k, l, m, n, o) = g46(n, i, k, l, m, o)&#34;</span>;</span>
<span id="cb18-96"><a href="#cb18-96"></a>          <span>&#34;g45(F()) = F()&#34;</span>;</span>
<span id="cb18-97"><a href="#cb18-97"></a>          <span>&#34;g45(T()) = F()&#34;</span>;</span>
<span id="cb18-98"><a href="#cb18-98"></a>          <span>&#34;g46(F(), i, k, l, m, o) = g47(i, k, l, m, o)&#34;</span>;</span>
<span id="cb18-99"><a href="#cb18-99"></a>          <span>&#34;g46(T(), i, k, l, m, o) = F()&#34;</span>;</span>
<span id="cb18-100"><a href="#cb18-100"></a>          <span>&#34;g47(F(), k, l, m, o) = F()&#34;</span>;</span>
<span id="cb18-101"><a href="#cb18-101"></a>          <span>&#34;g47(T(), k, l, m, o) = g48(l, k, m, o)&#34;</span>;</span>
<span id="cb18-102"><a href="#cb18-102"></a>          <span>&#34;g48(F(), k, m, o) = F()&#34;</span>;</span>
<span id="cb18-103"><a href="#cb18-103"></a>          <span>&#34;g48(T(), k, m, o) = g49(k, m, o)&#34;</span>;</span>
<span id="cb18-104"><a href="#cb18-104"></a>          <span>&#34;g49(F(), m, o) = g50(m, o)&#34;</span>;</span>
<span id="cb18-105"><a href="#cb18-105"></a>          <span>&#34;g49(T(), m, o) = g52(m, o)&#34;</span>;</span>
<span id="cb18-106"><a href="#cb18-106"></a>          <span>&#34;g5(F(), g) = g6(g)&#34;</span>;</span>
<span id="cb18-107"><a href="#cb18-107"></a>          <span>&#34;g5(T(), g) = F()&#34;</span>;</span>
<span id="cb18-108"><a href="#cb18-108"></a>          <span>&#34;g50(F(), o) = F()&#34;</span>;</span>
<span id="cb18-109"><a href="#cb18-109"></a>          <span>&#34;g50(T(), o) = g51(o)&#34;</span>;</span>
<span id="cb18-110"><a href="#cb18-110"></a>          <span>&#34;g51(F()) = F()&#34;</span>;</span>
<span id="cb18-111"><a href="#cb18-111"></a>          <span>&#34;g51(T()) = F()&#34;</span>;</span>
<span id="cb18-112"><a href="#cb18-112"></a>          <span>&#34;g52(F(), o) = F()&#34;</span>;</span>
<span id="cb18-113"><a href="#cb18-113"></a>          <span>&#34;g52(T(), o) = g53(o)&#34;</span>;</span>
<span id="cb18-114"><a href="#cb18-114"></a>          <span>&#34;g53(F()) = F()&#34;</span>;</span>
<span id="cb18-115"><a href="#cb18-115"></a>          <span>&#34;g53(T()) = F()&#34;</span>;</span>
<span id="cb18-116"><a href="#cb18-116"></a>          <span>&#34;g54(F(), i, k, l, m, n, o, p) = g55(i)&#34;</span>;</span>
<span id="cb18-117"><a href="#cb18-117"></a>          <span>&#34;g54(T(), i, k, l, m, n, o, p) = g56(n, i, k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-118"><a href="#cb18-118"></a>          <span>&#34;g55(F()) = F()&#34;</span>;</span>
<span id="cb18-119"><a href="#cb18-119"></a>          <span>&#34;g55(T()) = F()&#34;</span>;</span>
<span id="cb18-120"><a href="#cb18-120"></a>          <span>&#34;g56(F(), i, k, l, m, o, p) = g57(i, k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-121"><a href="#cb18-121"></a>          <span>&#34;g56(T(), i, k, l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-122"><a href="#cb18-122"></a>          <span>&#34;g57(F(), k, l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-123"><a href="#cb18-123"></a>          <span>&#34;g57(T(), k, l, m, o, p) = g58(k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-124"><a href="#cb18-124"></a>          <span>&#34;g58(F(), l, m, o, p) = g59(l, m, o, p)&#34;</span>;</span>
<span id="cb18-125"><a href="#cb18-125"></a>          <span>&#34;g58(T(), l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-126"><a href="#cb18-126"></a>          <span>&#34;g59(F(), m, o, p) = F()&#34;</span>;</span>
<span id="cb18-127"><a href="#cb18-127"></a>          <span>&#34;g59(T(), m, o, p) = g60(m, o, p)&#34;</span>;</span>
<span id="cb18-128"><a href="#cb18-128"></a>          <span>&#34;g6(F()) = F()&#34;</span>;</span>
<span id="cb18-129"><a href="#cb18-129"></a>          <span>&#34;g6(T()) = F()&#34;</span>;</span>
<span id="cb18-130"><a href="#cb18-130"></a>          <span>&#34;g60(F(), o, p) = F()&#34;</span>;</span>
<span id="cb18-131"><a href="#cb18-131"></a>          <span>&#34;g60(T(), o, p) = g61(o, p)&#34;</span>;</span>
<span id="cb18-132"><a href="#cb18-132"></a>          <span>&#34;g61(F(), p) = g62(p)&#34;</span>;</span>
<span id="cb18-133"><a href="#cb18-133"></a>          <span>&#34;g61(T(), p) = F()&#34;</span>;</span>
<span id="cb18-134"><a href="#cb18-134"></a>          <span>&#34;g62(F()) = F()&#34;</span>;</span>
<span id="cb18-135"><a href="#cb18-135"></a>          <span>&#34;g62(T()) = T()&#34;</span>;</span>
<span id="cb18-136"><a href="#cb18-136"></a>          <span>&#34;g63(F(), f, g) = g64(f, g)&#34;</span>;</span>
<span id="cb18-137"><a href="#cb18-137"></a>          <span>&#34;g63(T(), f, g) = F()&#34;</span>;</span>
<span id="cb18-138"><a href="#cb18-138"></a>          <span>&#34;g64(F(), g) = g65(g)&#34;</span>;</span>
<span id="cb18-139"><a href="#cb18-139"></a>          <span>&#34;g64(T(), g) = F()&#34;</span>;</span>
<span id="cb18-140"><a href="#cb18-140"></a>          <span>&#34;g65(F()) = F()&#34;</span>;</span>
<span id="cb18-141"><a href="#cb18-141"></a>          <span>&#34;g65(T()) = F()&#34;</span>;</span>
<span id="cb18-142"><a href="#cb18-142"></a>          <span>&#34;g66(F(), c, e, f, g, h, i, k, l, m, n, o, p) = g67(c, e, f, g, h, </span><span>\</span></span>
<span id="cb18-143"><a href="#cb18-143"></a><span>           i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-144"><a href="#cb18-144"></a>          <span>&#34;g66(T(), c, e, f, g, h, i, k, l, m, n, o, p) = F()&#34;</span>;</span>
<span id="cb18-145"><a href="#cb18-145"></a>          <span>&#34;g67(F(), e, f, g, h, i, k, l, m, n, o, p) = F()&#34;</span>;</span>
<span id="cb18-146"><a href="#cb18-146"></a>          <span>&#34;g67(T(), e, f, g, h, i, k, l, m, n, o, p) = g68(e, f, g, h, i, k, </span><span>\</span></span>
<span id="cb18-147"><a href="#cb18-147"></a><span>           l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-148"><a href="#cb18-148"></a>          <span>&#34;g68(F(), f, g, h, i, k, l, m, n, o, p) = g69(f, g)&#34;</span>;</span>
<span id="cb18-149"><a href="#cb18-149"></a>          <span>&#34;g68(T(), f, g, h, i, k, l, m, n, o, p) = g71(f, g, h, i, k, l, m, </span><span>\</span></span>
<span id="cb18-150"><a href="#cb18-150"></a><span>           n, o, p)&#34;</span>;</span>
<span id="cb18-151"><a href="#cb18-151"></a>          <span>&#34;g69(F(), g) = g70(g)&#34;</span>;</span>
<span id="cb18-152"><a href="#cb18-152"></a>          <span>&#34;g69(T(), g) = F()&#34;</span>;</span>
<span id="cb18-153"><a href="#cb18-153"></a>          <span>&#34;g7(F(), g, h, i, k, l, m, n, o, p) = g8(g)&#34;</span>;</span>
<span id="cb18-154"><a href="#cb18-154"></a>          <span>&#34;g7(T(), g, h, i, k, l, m, n, o, p) = g9(g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-155"><a href="#cb18-155"></a>          <span>&#34;g70(F()) = F()&#34;</span>;</span>
<span id="cb18-156"><a href="#cb18-156"></a>          <span>&#34;g70(T()) = F()&#34;</span>;</span>
<span id="cb18-157"><a href="#cb18-157"></a>          <span>&#34;g71(F(), g, h, i, k, l, m, n, o, p) = g72(g)&#34;</span>;</span>
<span id="cb18-158"><a href="#cb18-158"></a>          <span>&#34;g71(T(), g, h, i, k, l, m, n, o, p) = g73(g, h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-159"><a href="#cb18-159"></a>          <span>&#34;g72(F()) = F()&#34;</span>;</span>
<span id="cb18-160"><a href="#cb18-160"></a>          <span>&#34;g72(T()) = F()&#34;</span>;</span>
<span id="cb18-161"><a href="#cb18-161"></a>          <span>&#34;g73(F(), h, i, k, l, m, n, o, p) = g74(p, h, i, k, l, m, n, o)&#34;</span>;</span>
<span id="cb18-162"><a href="#cb18-162"></a>          <span>&#34;g73(T(), h, i, k, l, m, n, o, p) = g85(h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-163"><a href="#cb18-163"></a>          <span>&#34;g74(F(), h, i, k, l, m, n, o) = g75(h, i, k, l, m, n, o)&#34;</span>;</span>
<span id="cb18-164"><a href="#cb18-164"></a>          <span>&#34;g74(T(), h, i, k, l, m, n, o) = F()&#34;</span>;</span>
<span id="cb18-165"><a href="#cb18-165"></a>          <span>&#34;g75(F(), i, k, l, m, n, o) = g76(i)&#34;</span>;</span>
<span id="cb18-166"><a href="#cb18-166"></a>          <span>&#34;g75(T(), i, k, l, m, n, o) = g77(n, i, k, l, m, o)&#34;</span>;</span>
<span id="cb18-167"><a href="#cb18-167"></a>          <span>&#34;g76(F()) = F()&#34;</span>;</span>
<span id="cb18-168"><a href="#cb18-168"></a>          <span>&#34;g76(T()) = F()&#34;</span>;</span>
<span id="cb18-169"><a href="#cb18-169"></a>          <span>&#34;g77(F(), i, k, l, m, o) = g78(i, k, l, m, o)&#34;</span>;</span>
<span id="cb18-170"><a href="#cb18-170"></a>          <span>&#34;g77(T(), i, k, l, m, o) = F()&#34;</span>;</span>
<span id="cb18-171"><a href="#cb18-171"></a>          <span>&#34;g78(F(), k, l, m, o) = F()&#34;</span>;</span>
<span id="cb18-172"><a href="#cb18-172"></a>          <span>&#34;g78(T(), k, l, m, o) = g79(l, k, m, o)&#34;</span>;</span>
<span id="cb18-173"><a href="#cb18-173"></a>          <span>&#34;g79(F(), k, m, o) = F()&#34;</span>;</span>
<span id="cb18-174"><a href="#cb18-174"></a>          <span>&#34;g79(T(), k, m, o) = g80(k, m, o)&#34;</span>;</span>
<span id="cb18-175"><a href="#cb18-175"></a>          <span>&#34;g8(F()) = F()&#34;</span>;</span>
<span id="cb18-176"><a href="#cb18-176"></a>          <span>&#34;g8(T()) = F()&#34;</span>;</span>
<span id="cb18-177"><a href="#cb18-177"></a>          <span>&#34;g80(F(), m, o) = g81(m, o)&#34;</span>;</span>
<span id="cb18-178"><a href="#cb18-178"></a>          <span>&#34;g80(T(), m, o) = g83(m, o)&#34;</span>;</span>
<span id="cb18-179"><a href="#cb18-179"></a>          <span>&#34;g81(F(), o) = F()&#34;</span>;</span>
<span id="cb18-180"><a href="#cb18-180"></a>          <span>&#34;g81(T(), o) = g82(o)&#34;</span>;</span>
<span id="cb18-181"><a href="#cb18-181"></a>          <span>&#34;g82(F()) = F()&#34;</span>;</span>
<span id="cb18-182"><a href="#cb18-182"></a>          <span>&#34;g82(T()) = F()&#34;</span>;</span>
<span id="cb18-183"><a href="#cb18-183"></a>          <span>&#34;g83(F(), o) = F()&#34;</span>;</span>
<span id="cb18-184"><a href="#cb18-184"></a>          <span>&#34;g83(T(), o) = g84(o)&#34;</span>;</span>
<span id="cb18-185"><a href="#cb18-185"></a>          <span>&#34;g84(F()) = F()&#34;</span>;</span>
<span id="cb18-186"><a href="#cb18-186"></a>          <span>&#34;g84(T()) = F()&#34;</span>;</span>
<span id="cb18-187"><a href="#cb18-187"></a>          <span>&#34;g85(F(), i, k, l, m, n, o, p) = g86(i)&#34;</span>;</span>
<span id="cb18-188"><a href="#cb18-188"></a>          <span>&#34;g85(T(), i, k, l, m, n, o, p) = g87(n, i, k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-189"><a href="#cb18-189"></a>          <span>&#34;g86(F()) = F()&#34;</span>;</span>
<span id="cb18-190"><a href="#cb18-190"></a>          <span>&#34;g86(T()) = F()&#34;</span>;</span>
<span id="cb18-191"><a href="#cb18-191"></a>          <span>&#34;g87(F(), i, k, l, m, o, p) = g88(i, k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-192"><a href="#cb18-192"></a>          <span>&#34;g87(T(), i, k, l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-193"><a href="#cb18-193"></a>          <span>&#34;g88(F(), k, l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-194"><a href="#cb18-194"></a>          <span>&#34;g88(T(), k, l, m, o, p) = g89(k, l, m, o, p)&#34;</span>;</span>
<span id="cb18-195"><a href="#cb18-195"></a>          <span>&#34;g89(F(), l, m, o, p) = g90(l, m, o, p)&#34;</span>;</span>
<span id="cb18-196"><a href="#cb18-196"></a>          <span>&#34;g89(T(), l, m, o, p) = F()&#34;</span>;</span>
<span id="cb18-197"><a href="#cb18-197"></a>          <span>&#34;g9(F(), h, i, k, l, m, n, o, p) = g10(p, h, i, k, l, m, n, o)&#34;</span>;</span>
<span id="cb18-198"><a href="#cb18-198"></a>          <span>&#34;g9(T(), h, i, k, l, m, n, o, p) = g21(h, i, k, l, m, n, o, p)&#34;</span>;</span>
<span id="cb18-199"><a href="#cb18-199"></a>          <span>&#34;g90(F(), m, o, p) = F()&#34;</span>;</span>
<span id="cb18-200"><a href="#cb18-200"></a>          <span>&#34;g90(T(), m, o, p) = g91(m, o, p)&#34;</span>;</span>
<span id="cb18-201"><a href="#cb18-201"></a>          <span>&#34;g91(F(), o, p) = F()&#34;</span>;</span>
<span id="cb18-202"><a href="#cb18-202"></a>          <span>&#34;g91(T(), o, p) = g92(o, p)&#34;</span>;</span>
<span id="cb18-203"><a href="#cb18-203"></a>          <span>&#34;g92(F(), p) = g93(p)&#34;</span>;</span>
<span id="cb18-204"><a href="#cb18-204"></a>          <span>&#34;g92(T(), p) = F()&#34;</span>;</span>
<span id="cb18-205"><a href="#cb18-205"></a>          <span>&#34;g93(F()) = F()&#34;</span>;</span>
<span id="cb18-206"><a href="#cb18-206"></a>          <span>&#34;g93(T()) = T()&#34;</span>;</span>
<span id="cb18-207"><a href="#cb18-207"></a>        ] )</span>
<span id="cb18-208"><a href="#cb18-208"></a>    (formula</span>
<span id="cb18-209"><a href="#cb18-209"></a>       [</span>
<span id="cb18-210"><a href="#cb18-210"></a>         clause [ `Var <span>&#34;a&#34;</span>; `Var <span>&#34;b&#34;</span> ];</span>
<span id="cb18-211"><a href="#cb18-211"></a>         clause [ `Not <span>&#34;b&#34;</span>; `Not <span>&#34;d&#34;</span> ];</span>
<span id="cb18-212"><a href="#cb18-212"></a>         clause [ `Var <span>&#34;c&#34;</span>; `Var <span>&#34;d&#34;</span> ];</span>
<span id="cb18-213"><a href="#cb18-213"></a>         clause [ `Not <span>&#34;d&#34;</span>; `Not <span>&#34;e&#34;</span> ];</span>
<span id="cb18-214"><a href="#cb18-214"></a>         clause [ `Var <span>&#34;e&#34;</span>; `Not <span>&#34;f&#34;</span> ];</span>
<span id="cb18-215"><a href="#cb18-215"></a>         clause [ `Var <span>&#34;f&#34;</span>; `Not <span>&#34;g&#34;</span> ];</span>
<span id="cb18-216"><a href="#cb18-216"></a>         clause [ `Var <span>&#34;f&#34;</span>; `Var <span>&#34;g&#34;</span> ];</span>
<span id="cb18-217"><a href="#cb18-217"></a>         clause [ `Var <span>&#34;g&#34;</span>; `Not <span>&#34;p&#34;</span> ];</span>
<span id="cb18-218"><a href="#cb18-218"></a>         clause [ `Var <span>&#34;h&#34;</span>; `Not <span>&#34;i&#34;</span> ];</span>
<span id="cb18-219"><a href="#cb18-219"></a>         clause [ `Not <span>&#34;h&#34;</span>; `Not <span>&#34;n&#34;</span> ];</span>
<span id="cb18-220"><a href="#cb18-220"></a>         clause [ `Var <span>&#34;i&#34;</span>; `Var <span>&#34;g&#34;</span> ];</span>
<span id="cb18-221"><a href="#cb18-221"></a>         clause [ `Var <span>&#34;i&#34;</span>; `Not <span>&#34;g&#34;</span> ];</span>
<span id="cb18-222"><a href="#cb18-222"></a>         clause [ `Not <span>&#34;g&#34;</span>; `Not <span>&#34;k&#34;</span> ];</span>
<span id="cb18-223"><a href="#cb18-223"></a>         clause [ `Var <span>&#34;g&#34;</span>; `Var <span>&#34;l&#34;</span> ];</span>
<span id="cb18-224"><a href="#cb18-224"></a>         clause [ `Var <span>&#34;k&#34;</span>; `Var <span>&#34;l&#34;</span> ];</span>
<span id="cb18-225"><a href="#cb18-225"></a>         clause [ `Var <span>&#34;m&#34;</span>; `Var <span>&#34;n&#34;</span> ];</span>
<span id="cb18-226"><a href="#cb18-226"></a>         clause [ `Var <span>&#34;n&#34;</span>; `Not <span>&#34;o&#34;</span> ];</span>
<span id="cb18-227"><a href="#cb18-227"></a>         clause [ `Var <span>&#34;o&#34;</span>; `Var <span>&#34;p&#34;</span> ];</span>
<span id="cb18-228"><a href="#cb18-228"></a>       ]);</span></code></pre></div>
</details><p>Ditto.</p><p>Testing “x AND NOT x”:</p><div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1"></a>  check</span>
<span id="cb19-2"><a href="#cb19-2"></a>    ~expected:(<span>&#34;g0(x)&#34;</span>, [ <span>&#34;g0(F()) = F()&#34;</span>; <span>&#34;g0(T()) = F()&#34;</span> ])</span>
<span id="cb19-3"><a href="#cb19-3"></a>    (formula [ clause [ `Var <span>&#34;x&#34;</span> ]; clause [ `Not <span>&#34;x&#34;</span> ] ]);</span></code></pre></div><p>Since there is no path in <code>g0</code> that leads to
<code>T</code>, the formula is <strong>unsatisfiable</strong>.</p><p>Testing “x AND (y OR z) AND NOT x”:</p><div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1"></a>  check</span>
<span id="cb20-2"><a href="#cb20-2"></a>    ~expected:</span>
<span id="cb20-3"><a href="#cb20-3"></a>      ( <span>&#34;g0(x, y, z)&#34;</span>,</span>
<span id="cb20-4"><a href="#cb20-4"></a>        [</span>
<span id="cb20-5"><a href="#cb20-5"></a>          <span>&#34;g0(F(), y, z) = F()&#34;</span>;</span>
<span id="cb20-6"><a href="#cb20-6"></a>          <span>&#34;g0(T(), y, z) = g1(y, z)&#34;</span>;</span>
<span id="cb20-7"><a href="#cb20-7"></a>          <span>&#34;g1(F(), z) = g2(z)&#34;</span>;</span>
<span id="cb20-8"><a href="#cb20-8"></a>          <span>&#34;g1(T(), z) = F()&#34;</span>;</span>
<span id="cb20-9"><a href="#cb20-9"></a>          <span>&#34;g2(F()) = F()&#34;</span>;</span>
<span id="cb20-10"><a href="#cb20-10"></a>          <span>&#34;g2(T()) = F()&#34;</span>;</span>
<span id="cb20-11"><a href="#cb20-11"></a>        ] )</span>
<span id="cb20-12"><a href="#cb20-12"></a>    (formula</span>
<span id="cb20-13"><a href="#cb20-13"></a>       [</span>
<span id="cb20-14"><a href="#cb20-14"></a>         clause [ `Var <span>&#34;x&#34;</span> ]; clause [ `Var <span>&#34;y&#34;</span>; `Var <span>&#34;z&#34;</span> ]; clause [ `Not <span>&#34;x&#34;</span> ];</span>
<span id="cb20-15"><a href="#cb20-15"></a>       ]);</span></code></pre></div><p>Ditto.</p><p>Testing “(x OR x OR x) AND (NOT x OR NOT x OR NOT x)”:</p><div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1"></a>  check</span>
<span id="cb21-2"><a href="#cb21-2"></a>    ~expected:(<span>&#34;g0(x)&#34;</span>, [ <span>&#34;g0(F()) = F()&#34;</span>; <span>&#34;g0(T()) = F()&#34;</span> ])</span>
<span id="cb21-3"><a href="#cb21-3"></a>    (formula</span>
<span id="cb21-4"><a href="#cb21-4"></a>       [</span>
<span id="cb21-5"><a href="#cb21-5"></a>         clause [ `Var <span>&#34;x&#34;</span>; `Var <span>&#34;x&#34;</span>; `Var <span>&#34;x&#34;</span> ];</span>
<span id="cb21-6"><a href="#cb21-6"></a>         clause [ `Not <span>&#34;x&#34;</span>; `Not <span>&#34;x&#34;</span>; `Not <span>&#34;x&#34;</span> ];</span>
<span id="cb21-7"><a href="#cb21-7"></a>       ]);</span></code></pre></div><p>Ditto.</p><p>Testing “(x OR y OR z) AND (x OR y OR NOT z) AND (x OR NOT y OR z)
AND (x OR NOT y OR NOT z) AND (NOT x OR y OR z) AND (NOT x OR y OR NOT
z) AND (NOT x OR NOT y OR z) AND (NOT x OR NOT y OR NOT z)”:</p><div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1"></a>  check</span>
<span id="cb22-2"><a href="#cb22-2"></a>    ~expected:</span>
<span id="cb22-3"><a href="#cb22-3"></a>      ( <span>&#34;g0(x, y, z)&#34;</span>,</span>
<span id="cb22-4"><a href="#cb22-4"></a>        [</span>
<span id="cb22-5"><a href="#cb22-5"></a>          <span>&#34;g0(F(), y, z) = g1(y, z)&#34;</span>;</span>
<span id="cb22-6"><a href="#cb22-6"></a>          <span>&#34;g0(T(), y, z) = g4(y, z)&#34;</span>;</span>
<span id="cb22-7"><a href="#cb22-7"></a>          <span>&#34;g1(F(), z) = g2(z)&#34;</span>;</span>
<span id="cb22-8"><a href="#cb22-8"></a>          <span>&#34;g1(T(), z) = g3(z)&#34;</span>;</span>
<span id="cb22-9"><a href="#cb22-9"></a>          <span>&#34;g2(F()) = F()&#34;</span>;</span>
<span id="cb22-10"><a href="#cb22-10"></a>          <span>&#34;g2(T()) = F()&#34;</span>;</span>
<span id="cb22-11"><a href="#cb22-11"></a>          <span>&#34;g3(F()) = F()&#34;</span>;</span>
<span id="cb22-12"><a href="#cb22-12"></a>          <span>&#34;g3(T()) = F()&#34;</span>;</span>
<span id="cb22-13"><a href="#cb22-13"></a>          <span>&#34;g4(F(), z) = g5(z)&#34;</span>;</span>
<span id="cb22-14"><a href="#cb22-14"></a>          <span>&#34;g4(T(), z) = g6(z)&#34;</span>;</span>
<span id="cb22-15"><a href="#cb22-15"></a>          <span>&#34;g5(F()) = F()&#34;</span>;</span>
<span id="cb22-16"><a href="#cb22-16"></a>          <span>&#34;g5(T()) = F()&#34;</span>;</span>
<span id="cb22-17"><a href="#cb22-17"></a>          <span>&#34;g6(F()) = F()&#34;</span>;</span>
<span id="cb22-18"><a href="#cb22-18"></a>          <span>&#34;g6(T()) = F()&#34;</span>;</span>
<span id="cb22-19"><a href="#cb22-19"></a>        ] )</span>
<span id="cb22-20"><a href="#cb22-20"></a>    (formula</span>
<span id="cb22-21"><a href="#cb22-21"></a>       [</span>
<span id="cb22-22"><a href="#cb22-22"></a>         clause [ `Var <span>&#34;x&#34;</span>; `Var <span>&#34;y&#34;</span>; `Var <span>&#34;z&#34;</span> ];</span>
<span id="cb22-23"><a href="#cb22-23"></a>         clause [ `Var <span>&#34;x&#34;</span>; `Var <span>&#34;y&#34;</span>; `Not <span>&#34;z&#34;</span> ];</span>
<span id="cb22-24"><a href="#cb22-24"></a>         clause [ `Var <span>&#34;x&#34;</span>; `Not <span>&#34;y&#34;</span>; `Var <span>&#34;z&#34;</span> ];</span>
<span id="cb22-25"><a href="#cb22-25"></a>         clause [ `Var <span>&#34;x&#34;</span>; `Not <span>&#34;y&#34;</span>; `Not <span>&#34;z&#34;</span> ];</span>
<span id="cb22-26"><a href="#cb22-26"></a>         clause [ `Not <span>&#34;x&#34;</span>; `Var <span>&#34;y&#34;</span>; `Var <span>&#34;z&#34;</span> ];</span>
<span id="cb22-27"><a href="#cb22-27"></a>         clause [ `Not <span>&#34;x&#34;</span>; `Var <span>&#34;y&#34;</span>; `Not <span>&#34;z&#34;</span> ];</span>
<span id="cb22-28"><a href="#cb22-28"></a>         clause [ `Not <span>&#34;x&#34;</span>; `Not <span>&#34;y&#34;</span>; `Var <span>&#34;z&#34;</span> ];</span>
<span id="cb22-29"><a href="#cb22-29"></a>         clause [ `Not <span>&#34;x&#34;</span>; `Not <span>&#34;y&#34;</span>; `Not <span>&#34;z&#34;</span> ];</span>
<span id="cb22-30"><a href="#cb22-30"></a>       ])</span></code></pre></div><p>Ditto.</p><a href="#final-words"><h2 id="final-words">Final words</h2></a><p>In this essay, I have demonstrated how supercompilation can solve any
SAT problem with only 10 lines of code in SLL.</p><p>There are several theoretical and practical consequences of this
discovery:</p><ul>
<li><strong>Theoretically,</strong> this means that a positive
supercompiler can solve SAT “automatically” – possibly mixed with a
number of other optimizations and code transformations. In other words,
it is possible that supercompilation can optimize your code based on the
knowledge of a solution to a particular SAT problem.
<ul>
<li>A direct consequence of this is that supercompiling a particular
task can have exponential time and space complexity. This is both good
and bad: the good part is that supercompilation is very smart, and the
bad part is that it can be <em>too smart</em> to serve as a predictable
code optimizer.</li>
<li>Since it is generally believed that there is <a href="https://en.wikipedia.org/wiki/P_versus_NP_problem">no
polynomial-time algorithm</a> to solve SAT, positive supercompilation is
also likely not to have it.</li>
<li>Since SAT is an <a href="https://en.wikipedia.org/wiki/NP-complete">NP-complete
problem</a>, meaning that it is at least as hard as any other problem in
NP, supercompilation is also at least as hard as any other problem in
NP. In other words, supercompilation has enough expressive power to
solve any NP problem <em>during the process</em>.</li>
</ul></li>
<li><strong>Practically,</strong> using naive supercompilation as an
optimization pass would not be a good idea. However, since
supercompilation is a general method rather than a particular algorithm,
it should always be possible to restrict the expressive power of a
<em>particular</em> supercompiler to make it more predictable – albeit
less smart. See the technique of <em>speculative supercompilation</em>
from <a href="#fn19" id="fnref19" role="doc-noteref"><sup>19</sup></a>.
<ul>
<li>The SLL solver demonstrated in the previous section can serve as a
good stress test for a practical supercompiler.</li>
</ul></li>
</ul><p>Although the idea of supercompilation dates back to the 1970’s,
developing an industrial supercompiler is still an open problem.</p><p>If you find the post interesting, please share your thoughts in the
comments.</p><a href="#references"><h2 id="references">References</h2></a></div></div>
  </body>
</html>
