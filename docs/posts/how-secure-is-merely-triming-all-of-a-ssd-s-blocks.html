<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/SSDBlockDiscardHowSecure">Original</a>
    <h1>How secure is merely TRIMing all of a SSD&#39;s blocks?</h1>
    
    <div id="readability-page-1" class="page"><div><h2>How secure is merely discarding (TRIMing) all of a SSD&#39;s blocks?</h2>

	<p><small>March  4, 2023</small></p>
</div><div><p>Suppose hypothetically that you have some SSDs to securely dispose
of, and that for one reason or another you can&#39;t use <a href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase">built-in SSD
secure erase</a>
on them, for example (apparently) because your BIOS automatically
locks out that option when it boots. You might wonder how well
protected you are if you simply tell the SSD to <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/SSDsAndBlockDiscardTrim">discard all of
its data</a>. Unsurprisingly, the answer is
that it depends.</p>

<p>First off, any SSD you want to use today will support what&#39;s called
&#39;Deterministic Read After TRIM (DRAT)&#39; (sort of <a href="https://en.wikipedia.org/wiki/Trim_(computing)#ATA">cf</a>), where the
SSD will always return a fixed result when you read data after a
TRIM operation. Some SSDs also promise to always return zeros in
this situation; this is &#39;Deterministic read ZEROs after TRIM&#39;,
variously abbreviated as &#39;DZAT&#39;, &#39;RZAT&#39;, or &#39;DRZAT&#39;. These are the
(S)ATA versions, but NVMe has a similar system. All of these mean
that once you TRIM the entire drive, the previous data on the drive
can&#39;t be read through normal means, so someone who gets your drive
and puts it in a computer will get garbage (or <a href="https://superuser.com/questions/1652827/how-to-tell-whether-zeros-originate-from-trim-or-from-actually-writing-zeros-on">possibly errors
on NVMe drives</a>).</p>

<p>(My impression is that vendors initially supported DZAT only on
higher end (or at least more expensive) SSDs they sold for use in
RAID arrays, although support for this seems to have trickled down
to at least some modern consumer SSDs. Supporting DRAT but not DZAT
strikes me as mostly a market segmentation thing; if you&#39;re going
to be deterministic, making it always zero seems as easy as anything
else.)</p>

<p>If the drive then goes on to actually erase all of the flash blocks with
any copies of what you&#39;ve TRIM&#39;d, then as far as I know the data is
completely unrecoverable. Flash storage, unlike traditional hard drives,
can really be completely and irrecoverably erased, with no lingering
magnetic ghosts that a sufficiently determined person could in theory
reconstruct. However, SSDs don&#39;t particularly promise to actually erase
all of your blocks after you&#39;ve TRIM&#39;d them. Erasing blocks is a time
and power consuming activity, so while a SSD probably wants to keep a
pool of already erased blocks for new writes, it might not keep going
on at full pace once it thinks it has a big enough pool. SSDs make no
promises here and as far as I know there is no reliable, normal way to
tell how many erased blocks they have or if they&#39;ve erased all your
blocks. Letting a TRIM&#39;d SSD sit powered on but idle for minutes or
hours likely increases your chances that everything gets TRIM&#39;d, but
doesn&#39;t guarantee it. There&#39;s also no certainty that a SSD will erase a
block that it&#39;s decided is too unreliable to reuse.</p>

<p>The lack of certainty on erasure matters because SSDs can be put
into a special <a href="https://blog.elcomsoft.com/2019/01/life-after-trim-using-factory-access-mode-for-imaging-ssd-drives/">factory mode</a>
that generally allows raw access to the flash storage and allows
you to stop the SSD from doing any further block erasure. If you
can put a drive into this state you can read out TRIM&#39;d but not yet
erased blocks, although you may not know what logical blocks they
were. Serious data recovery companies can probably put pretty much
any SSD from any mainline maker into this recovery mode, which means
that anyone who wants to spend enough money can probably pull out
any not yet erased data from a TRIM&#39;d drive. If they can&#39;t get the
pre-TRIM mapping of logical blocks to flash storage, making sense of
the result may take a lot of work but it&#39;s probably not impossible.</p>

<p>So on my taxonomy of <a href="https://utcc.utoronto.ca/~cks/space/blog/tech/DiskErasingWhoAreYouStopping">who you&#39;re trying to stop when securely
erasing disks</a>, simply TRIM&#39;ing your
SSDs definitely stops the basic threat of &#39;someone plugs it into
a computer and tries&#39;, but probably doesn&#39;t entirely stop the threat
of &#39;someone is willing to spend a bunch of money to send it to a
data recovery firm&#39;. Letting your drives sit so that they erase
as many blocks as possible will make the life of the second sort
of person harder, but not impossible.</p>

<p>(TRIM&#39;ing your SSD and then filling it up with new junk data will
probably help here, because it will push the drive to erase almost
everything. Randomly rewriting scattered bits afterward with more
junk will probably push the drive into erasing its overprovisioned
blocks too. But all of that is a speculative guess, because SSDs
are black boxes. If this matters a lot to you, you want to use
SSDs that have good implementations of secure erase. How you find
out what those SSDs are, I don&#39;t know.)</p>

<p>(Under Linux, you can use &#39;<code>hdparm -I</code>&#39; to see what SATA SSDs support
(or claim to), and <a href="https://unix.stackexchange.com/questions/472211/list-features-of-nvme-drive-like-hdparm-i-for-non-nvme">see this stackexchange question and answer for
how to do it on NVMe drives</a>.)</p>
</div></div>
  </body>
</html>
