<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.mastermind.dev/indexes-in-postgresql">Original</a>
    <h1>Understanding database indexes in PostgreSQL</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>There are three types of developers: those who know that indexes speed up database queries, those who know that indexes speed up database queries and take additional space and time to write, and those who have a more profound knowledge about indexes, their advantages, disadvantages, different types and much more. Unfortunately, the first and the second group is the most numerous.</p>
<p>This article will help you understand SQL indexes if you fall into the first two groups. If you know a lot about indexes, this article will help you organize your knowledge and remind you about good practices. <strong>SQL is a declarative language meaning it tells the database what we want to do but not how to achieve it</strong>. The database engine decides how to pull data. We can help the query planner by using indexes.</p>
<p>All information I provide in this article is specific to the PostgreSQL database engine, but at some point, they are also helpful for other popular database engines.</p>

<p>Imagine that you run a web application that is used by millions of users every day. The application uses a database where information about users is collected in a single database called <code>users</code>. Each time someone requests a user’s profile to be rendered, you have to first find the user record in the database and then render the information back to the visitor. An ordinary scenario:</p>
<pre><code><span>SELECT</span> * <span>FROM</span> <span>users</span> <span>WHERE</span> users.slug = <span>&#39;user411&#39;</span> <span>LIMIT</span> <span>1</span>;
</code></pre>
<p>The above query was executed against the table with one million records, where every slug is unique, but I didn’t put any index on it. It took 57.419 ms to get one record. Let’s add a unique index on the <code>slug</code> column:</p>
<pre><code><span>CREATE</span> <span>UNIQUE</span> <span>INDEX</span> slug_idx <span>ON</span> <span>users</span> (slug);
</code></pre>
<p>I ran the <code>select</code> query again, and it took 0.055 ms to get the matching record. That’s <strong>1043 times faster</strong> than before! Imagine using a more complicated query against a bigger set of data without proper indexes on the columns. Now, when we have analyzed simple yet meaningful example, we can do a deep dive into the world of indexes to learn how to design our database the right way.</p>

<p>I mentioned at the beginning that most of the developers know that the index speeds up the queries to the database, but if you would ask them to explain the index in detail, they wouldn’t know the answer.</p>
<p>I separated the definition of index into two pieces: a high-level explanation and a low-level definition. The first one is needed to get the right understanding of how indexes work in general, and the second one is for those who like to know how things are working under the hood.</p>
<h2 id="heading-high-level-definition">High-level definition</h2>
<p>Imagine you have a list of contacts on your iPhone, but this list is not sorted alphabetically. You want to call John. What would you do? You would go through every contact starting from the top and stop on the contact named John. Let’s say your list contains 100 contacts, and if you are lucky enough, you would need to go through 20 - 30 contacts before finding the right one. What if John is the last contact? It would take a lot of time to find the contact.</p>
<p>That’s the problem that is solved by indexes. Without the index on the column, when you do the filtering, the database is doing the full scan, which simply means that it goes through every record unless the matching record is found. It can take a lot of time, depending on the database size.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1684247880429/c97d276f-26f2-4ec2-a970-1eb6bf4662a9.jpeg?auto=compress,format&amp;format=webp" alt=""/></p>
<p>When you put the index on a column, in our case, the name of the contact, the database creates a special structure that sorts the contacts. So if you are looking for John, you would look for contact names starting with the letter J; it speeds up the searching process a few times.</p>
<h2 id="heading-low-level-definition">Low-level definition</h2>
<p>There are a few types of indexes; I will discuss them next. Let’s focus on the default one, which is B-tree, so I can demonstrate what it looks like on a low level inside the database.</p>
<p>B-tree stands for balanced search tree. It simplifies the binary search tree by allowing nodes with more than two children. Each node contains keys in ascending order. If we would consider the example with contact names, the B-tree structure would look similar to the following visualization:</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1684247918941/1a0363c6-d9ff-470e-bdf9-f52e7784f8dc.png?auto=compress,format&amp;format=webp" alt=""/></p>
<p>If you would form all of those names into an array and sort them alphabetically, John would be in the middle of an array. If the search is performed on the index, the engine checks if the given value is before or after the root node and repeats the check for every next node.</p>
<p>Nodes also contain a pointer to the record in the database, so <strong>when the matching node is found, the engine will use the pointer to get the record from the database</strong> and incorporate it into search results.</p>

<p>There are a few types of indexes, each one suitable for different use cases. You already learned about the B-tree index, which is a default one, and it will be applied unless you specify another one. Here is the full list, along with use cases for each of the index types:</p>
<ul>
<li><p><strong>B-tree</strong> - the default index, suitable for all kinds of data. The query planner would consider using the B-tree index when the following operators are used: <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>&gt;=</code>,<code>&gt;</code>, <code>BETWEEN</code>, <code>IN</code>, <code>IS NULL</code> or <code>IS NOT NULL</code>. Additionally, the query planner can also consider using this index for queries that include pattern-matching with operators <code>LIKE</code> and <code>~</code>. However, the pattern must be a constant, and the anchor must be at the begging of the pattern.</p>
</li>
<li><p><strong>Hash</strong> - index that can handle only simple equality comparisons with the <code>=</code> operator, and only when a such an operator is used, the query planner will consider using the hash index. In Postgres versions to 10, you shouldn’t be using this index as it’s not transaction safe and comes with some other disadvantages. Also, the advantage over b-tree is quite small so in most cases, b-tree is a better choice.</p>
</li>
<li><p><strong>GiST</strong> - the shortcut that stands for Generalized Search Tree. This type of index is good for geometric data types, network address data, and full-text search. The query planner would consider using it when the following operators are used: <code>&lt;&lt;</code>, <code>&amp;&lt;</code>, <code>&amp;&gt;</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;|</code>, <code>&amp;&lt;|</code>, <code>|&amp;&gt;</code>, <code>|&gt;&gt;</code>, <code>@&gt;</code>, <code>&lt;@</code>, <code>~=</code> or <code>&amp;&amp;</code>. This type of index is also good for optimizing queries that find the nearest neighbor.</p>
</li>
<li><p><strong>SP-GiST</strong> - the shortcut that stands for space-partitioned generalized search tree. This type of index is suitable for multimedia, phone routing, IP routing or GIS. The query planner would consider using this index when one of the following operators is used: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>~=</code>, <code>&lt;@</code>, <code>&lt;&lt;|</code> or <code>|&gt;&gt;</code>.</p>
</li>
<li><p><strong>GIN</strong> - the shortcut that stands for Generalized Inverted Index. While B-tree index is optimized for a case when row has a single key value, GIN is more suitable for a case when the index must map many values to one row. Think about GIN when you want to index arrays, hstore, jsonb and implement full-text search. The query planner would consider using this index when the following operators will be used: <code>&lt;@</code>, <code>@&gt;</code>, <code>=</code> or <code>&amp;&amp;</code>.</p>
</li>
<li><p><strong>BRIN</strong> - the shortcut that stands for Block Range Index. It is often used on a column that has a linear sort order, for example, the creation date on records used for reporting. Much smaller than B-tree index and less costly to maintain. The query planner would consider using this index when the following operators are used: <code>&lt;</code>, <code>&lt;=</code>, <code>=</code>, <code>&gt;=</code> or <code>&gt;</code>. The BRIN index is generally more suitable for large tables with time series data rather than small tables with randomly ordered data.</p>
</li>
</ul>
<p>The truth is that in most of the cases, you should be fine with the b-tree index that is created by the default unless you cope with a very specific information in your database.</p>

<p>Now, that it’s clear how indexes work in general and under the hood, it is much easier to understand how we can update the queries with the indexes to make them much faster.</p>
<h2 id="heading-detecting-when-to-add-an-index">Detecting when to add an index</h2>
<p>You know why and how. It is the time to find the answer when. You won’t benefit from putting indexes on the wrong columns; your database would only take more disk space. In general, the following practices are considered as good:</p>
<ul>
<li><p><strong>Index columns that you search on</strong> - after discovering how indexes work, this one should be obvious to you. If you filter your records by the <code>last_name</code> column, put an index there. There are countless examples of cases when you can use filtering to narrow search results.</p>
</li>
<li><p><strong>Index columns for database-level validation</strong> - it’s not enough to have validation on the backend or frontend (or both). It is considered to be a good practice to use indexes to validate the data presence and integrity.</p>
</li>
<li><p><strong>Index columns used for join operations</strong> - putting an index on a column that you use to join table can improve the performance.</p>
</li>
<li><p><strong>Index column that you often use for sorting</strong> - index organizes the data in a way that makes the sorting more efficient, reducing the need for expensive sort operations.</p>
</li>
</ul>
<p>You may find some special use cases for your data, but the above rules apply to most of the applications. Think about them each time you design the database, perform the audit of the legacy database, or look for a way to improve the performance of the queries.</p>
<h3 id="heading-using-explain-and-analyze-commands">Using explain and analyze commands</h3>
<p>This section won’t be complete without mentioning about the <code>explain</code> and <code>analyze</code> commands that help us to determine how the query planner sees our data.</p>
<p>The <code>EXPLAIN</code> command prints the execution plan of a query without executing it. The plan contains the order of the operations, join methods, index usage, and estimated costs:</p>
<pre><code><span>EXPLAIN</span> <span>SELECT</span> title <span>FROM</span> articles <span>WHERE</span> published = <span>true</span>;
</code></pre>
<p>The <code>ANALYZE</code> command collects statistics about the data in a table or index. In opposite to the <code>EXPLAIN</code> command, it provides actual runtime performance metrics:</p>
<pre><code><span>ANALYZE</span> <span>SELECT</span> title <span>FROM</span> articles <span>WHERE</span> published = <span>true</span>;
</code></pre>
<p>You can also combine both commands to get the complete insight into query optimization and fine-tuning in PostgreSQL:</p>
<pre><code><span>EXPLAIN</span> <span>ANALYZE</span> <span>SELECT</span> title <span>FROM</span> articles <span>WHERE</span> published = <span>true</span>;
</code></pre>
<h2 id="heading-basic-index-on-single-or-multiple-columns">Basic index on single or multiple columns</h2>
<p>When it comes to filtering, you can filter records based on single or multiple columns. If you plan to filter basic data types, the default index (b-tree) will be enough:</p>
<pre><code><span>CREATE</span> <span>INDEX</span> title_idx <span>ON</span> articles (title);
</code></pre>
<p>If you plan to add an index on multiple columns, just modify the last part of the command:</p>
<pre><code><span>CREATE</span> <span>INDEX</span> title_category_idx <span>ON</span> articles (title, <span>category</span>);
</code></pre>
<h2 id="heading-partial-indexes">Partial indexes</h2>
<p>When you create an index, by default, you index all records in the given table. If you want to avoid it, you can create a partial index. When you build a query, you use <code>WHERE</code> keyword to narrow search results, and the same is for the indexes creation:</p>
<pre><code><span>CREATE</span> <span>INDEX</span> title_idx <span>ON</span> articles (title) <span>WHERE</span> published = <span>true</span>;
</code></pre>
<p>That way, you will reduce the index size by indexing only the subset of all records.</p>
<h2 id="heading-expression-indexes">Expression indexes</h2>
<p>When simple values are not enough, you can create indexes based on the outcome of the function. A popular example would be indexing the lowercase version of the value in the given field:</p>
<pre><code><span>CREATE</span> <span>INDEX</span> title_idx <span>ON</span> articles (<span>lower</span>(title));
</code></pre>
<p>Keep in mind that such an index can take more space (depending on the outcome) and can have the impact of the performance of data modifications.</p>
<h2 id="heading-covering-indexes">Covering indexes</h2>
<p>As you may already know, after the index is scanned, the pointer is used to retrieve the data from the table. You can skip the second part and improve the query even more by using covering indexes.</p>
<p>A covering index is also known as index-only scan. It contains all of the columns required to satisfy the query so there is no need to perform the lookup query. The syntax for creating such indexes is the following:</p>
<pre><code><span>CREATE</span> <span>INDEX</span> idx_covering <span>ON</span> articles (title, <span>category</span>) <span>INCLUDE</span> (author, slug);
</code></pre>
<p>As always, such an index gives us a lot of benefits, but you also have to know that it is not a good idea to use such an index if you perform frequent updates on the included columns, as it requires updating both the index and the table.</p>
<h2 id="heading-other-types-of-indexes">Other types of indexes</h2>
<p>Besides mentioned simple queries, you can also improve the speed of queries that are more advanced. These include full-text search and geospatial data. Whenever you create the index, you can refer to the <a target="_blank" href="https://www.postgresql.org/docs/current/sql-createindex.html">official documentation</a> where the index creation command is well described along with all possible parameters.</p>

<p>It’s not enough to just add the right indexes to your database; you also need to maintain the existing indexes to make sure that the structure of your database is in the best shape possible. While when you start the application from the bottom, you don’t have much to maintain in term of indexes, in a legacy application, there is a lot of cases to handle.</p>
<p>You need to maintain indexes because one of the following situations might happen in the past:</p>
<ul>
<li><p>The developer indexed more columns than it was needed</p>
</li>
<li><p>The developer indexed a column before it was used, and it happened that it was never used</p>
</li>
<li><p>The query plan is not using the index and do the full scan instead; it can happen especially on small tables</p>
</li>
</ul>
<p>These are just some of many situations where invalid indexes can be created, and we need to maintain them to keep our database healthy and as performant as possible.</p>
<h2 id="heading-the-table-where-information-about-indexes-is-stored">The table where information about indexes is stored</h2>
<p>In PostgreSQL, the information about indexes is stored in the <code>pg_index</code> table. Since it’s a table, you can query it just like any other table in your database. I investigated the table columns (I used version 11.19), and the table contains the following columns among others:</p>
<ul>
<li><p><code>indnatts</code> - the total number of columns in the index</p>
</li>
<li><p><code>indnkeyatts</code> - the total number of key columns in the index</p>
</li>
<li><p><code>indisunique</code> - determines if index is unique</p>
</li>
<li><p><code>indisprimary</code> - determines if index represents primary key of the table</p>
</li>
<li><p><code>indisexclusion</code> - determines if the index supports exclusion constraint</p>
</li>
<li><p><code>indisclustered</code> - determines if table was last clustered on this index</p>
</li>
<li><p><code>indisvalid</code> - determines if index is valid for queries</p>
</li>
<li><p><code>indisready</code> - determines if index is ready for inserts</p>
</li>
<li><p><code>indislive</code> - determines if index is in process of being dropped</p>
</li>
<li><p><code>indisreplident</code> - determines if index has been chosen as replica identity</p>
</li>
<li><p><code>indkey</code> - an array of <code>indnatts</code> values to indicate which table columns the index indexes</p>
</li>
</ul>
<p>The other columns are <code>indexrelid</code>, <code>indrelid</code>, <code>indimmediate</code>, <code>indcheckxmin</code>, <code>indcollation</code>, <code>indclass</code>, <code>indoption</code>, <code>indexprs</code>, <code>indpred</code>. You can check the detailed explanation of each column in the <a target="_blank" href="https://www.postgresql.org/docs/current/catalog-pg-index.html">official documentation</a>.</p>
<h2 id="heading-detecting-unused-indexes">Detecting unused indexes</h2>
<p>To detect unused indexes in our database, we can use the <code>pg_stat_user_indexes</code> table which contains usage statistics. This table contains the following important columns:</p>
<ul>
<li><p><code>idx_scan</code> - number of scans performed on the index</p>
</li>
<li><p><code>relname</code> - name of the table</p>
</li>
<li><p><code>indexrelname</code> - name of the index</p>
</li>
<li><p><code>indexrelid</code> - identification of the relation that would help us to find corresponding record in <code>pg_index</code> table</p>
</li>
</ul>
<p>What you have to keep in mind is that we can’t just simply find records where <code>idx_scan</code> equals zero. We also have to keep in mind the following things:</p>
<ul>
<li><p>Sometimes index is not simple, and it’s an expression over one or more columns in the table or a partial index. In such case, we don’t want to consider it in our query for finding unused indexes. To take this situation into consideration, we can use the <code>indkey</code> column from the <code>pg_index</code> table - when the column contains 0, it means that the index is an expression.</p>
</li>
<li><p>For unique indexes, the <code>idx_scan</code> will contain 0 as such indexes behave differently from non-unique indexes. Unique index are used to enforce the unique constraint, and a full scan is not performed. To find unique indexes we can leverage the <code>indisunique</code> column from <code>pg_index</code> table.</p>
</li>
<li><p>Besides uniqueness, we also have other constraints. Those we also can’t take into account when searching for unused indexes. To improve our process, we can take a look into the <code>pg_constraint</code> table which contains all constraints. If our index is not included there, we can take it into consideration.</p>
</li>
</ul>
<p>Taking into account all of the above points, we can finally produce a SQL query that will show us which indexes are unused:</p>
<pre><code><span>SELECT</span> s.relname, s.indexrelname, pg_relation_size(s.indexrelid) <span>AS</span> index_size <span>FROM</span> pg_stat_user_indexes s <span>JOIN</span> pg_catalog.pg_index i <span>ON</span> s.indexrelid = i.indexrelid <span>WHERE</span> s.idx_scan = <span>0</span> <span>AND</span> <span>0</span> &lt;&gt;<span>ALL</span> (i.indkey) <span>AND</span> <span>NOT</span> i.indisunique <span>AND</span> <span>NOT</span> <span>EXISTS</span> (<span>SELECT</span> <span>1</span> <span>FROM</span> pg_catalog.pg_constraint c <span>WHERE</span> c.conindid = s.indexrelid) <span>ORDER</span> <span>BY</span> pg_relation_size(s.indexrelid) <span>DESC</span>;
</code></pre>
<p>The above query will produce a set of results where each result contains three attributes:</p>
<ul>
<li><p><code>relname</code> - the name of the table</p>
</li>
<li><p><code>indexrelname</code> - the name of the index</p>
</li>
<li><p><code>index_size</code> - the size of the index</p>
</li>
</ul>
<h2 id="heading-detecting-bloats">Detecting bloats</h2>
<p>Frequent update and delete operations can lead to a situation where there is a lot of unused space in a table or index relation files on the disk; it is called bloat. Such a situation can cause the performance degradation.</p>
<h3 id="heading-how-bloat-is-created">How bloat is created</h3>
<p>While it might be surprising for a lot of developers, when a record is deleted, it is not physically removed from the disk. PostgreSQL makes it invisible and marked for deletion. The same situation happens when the record is updated. A new version is created in the database, and the old one is marked as invisible.</p>
<p>During the VACUUM operation, PostgreSQL scans the table for dead rows and removes them from the table; just this situation physically deletes the data and frees up the space. However, the auto VACUUM operation is not enabled by default.</p>
<p>The bloat is created when auto VACUUM is not enabled or when it’s enabled but is not running frequently enough to keep up with the workload on the database. You can check if this feature is enabled by running the following query:</p>
<pre><code><span>SELECT</span> <span>name</span>, setting, unit <span>FROM</span> pg_settings <span>WHERE</span> <span>name</span> = <span>&#39;autovacuum&#39;</span>;
</code></pre>
<h3 id="heading-finding-the-size-of-the-bloat">Finding the size of the bloat</h3>
<p>The database itself provides an extension that provides information about the tuples in our database. For example, you can query the <code>tables</code> table, and for each table, trigger the <code>pgstattuple</code> function and read the percentage of dead tuples with the following query:</p>
<pre><code><span>SELECT</span> table_name, (pgstattuple(table_name)).dead_tuple_percent <span>AS</span> dead_tuple_percent <span>FROM</span> information_schema.tables <span>WHERE</span> table_schema=<span>&#39;public&#39;</span> <span>AND</span> table_type=<span>&#39;BASE TABLE&#39;</span> <span>ORDER</span> <span>BY</span> dead_tuple_percent <span>DESC</span>;
</code></pre>
<p>If you receive an error about the unknown extension, you have to enable it first:</p>
<pre><code><span>CREATE</span> EXTENSION pgstattuple;
</code></pre>
<p>It should work now. Since this article is about indexes, let’s find out how we can find the bloat size in indexes. We can use the following query:</p>
<pre><code><span>SELECT</span> cls.relname, am.amname, pg_total_relation_size(indexrelid) <span>AS</span> index_size_bytes, pg_total_relation_size(indexrelid) - pg_relation_size(indexrelid) <span>AS</span> index_bloat_bytes <span>FROM</span> pg_index idx <span>JOIN</span> pg_class cls <span>ON</span> cls.oid=idx.indexrelid <span>JOIN</span> pg_am am <span>ON</span> am.oid=cls.relam <span>WHERE</span> indrelid &gt; <span>16384</span>;
</code></pre>
<p>This query returns the name of the index, index type, and estimated bloat size.</p>
<h3 id="heading-removing-the-bloat-from-index">Removing the bloat from index</h3>
<p>To remove the bloat from the given index, you can rebuild the index:</p>
<pre><code>REINDEX INDEX index_name;
</code></pre>
<p>Above command will copy the data from the old index to the new index. Please keep in mind that this operation can take some time and affect the database performance.</p>
<h2 id="heading-detecting-duplicate-indexes">Detecting duplicate indexes</h2>
<p>There are some cases when two or more indexes exist; they have different names but the same combination of columns. As a result, one of them (or even more) is not used and just takes the space and makes the writing process more expensive.</p>
<p>To find duplications, we can query the <code>pg_index</code> table using the following query:</p>
<pre><code><span>SELECT</span> pg_size_pretty(<span>sum</span>(pg_relation_size(idx))::<span>bigint</span>) <span>as</span> <span>size</span>, (array_agg(idx))[<span>1</span>] <span>as</span> idx1, (array_agg(idx))[<span>2</span>] <span>as</span> idx2 <span>FROM</span> ( <span>SELECT</span> indexrelid::regclass <span>as</span> idx, (indrelid::<span>text</span> ||E<span>&#39;\n&#39;</span>|| indclass::<span>text</span> ||E<span>&#39;\n&#39;</span>|| indkey::<span>text</span> ||E<span>&#39;\n&#39;</span>|| <span>coalesce</span>(indexprs::<span>text</span>,<span>&#39;&#39;</span>)||E<span>&#39;\n&#39;</span> || <span>coalesce</span>(indpred::<span>text</span>,<span>&#39;&#39;</span>)) <span>as</span> <span>key</span> <span>FROM</span> pg_index) sub <span>GROUP</span> <span>BY</span> <span>key</span> <span>HAVING</span> <span>count</span>(*) &gt; <span>1</span> <span>ORDER</span> <span>BY</span> <span>sum</span>(pg_relation_size(idx)) <span>DESC</span>;
</code></pre>
<p>To better understand what is happening above, let’s break down the query into smaller pieces. We have the following subquery:</p>
<pre><code><span>SELECT</span> indexrelid::regclass <span>as</span> idx, (indrelid::<span>text</span> ||E<span>&#39;\n&#39;</span>|| indclass::<span>text</span> ||E<span>&#39;\n&#39;</span>|| indkey::<span>text</span> ||E<span>&#39;\n&#39;</span>|| <span>coalesce</span>(indexprs::<span>text</span>,<span>&#39;&#39;</span>)||E<span>&#39;\n&#39;</span> || <span>coalesce</span>(indpred::<span>text</span>,<span>&#39;&#39;</span>)) <span>as</span> <span>key</span> <span>FROM</span> pg_index
</code></pre>
<ul>
<li><p><code>indexrelid::regclass as idx</code> - to obtain the name of the index. Without the casting, we would just get the OID which is the object identifier of the index.</p>
</li>
<li><p><code>indrelid::text ||E&#39;\n&#39;|| indclass::text ||E&#39;\n&#39;|| indkey::text ||E&#39;\n&#39;|| coalesce(indexprs::text,&#39;&#39;)||E&#39;\n&#39; || coalesce(indpred::text,&#39;&#39;)</code> - the <code>||</code> character is a concatenation operator, and this part of the query formats a single string based on a few details about the index</p>
</li>
</ul>
<p>We also have the main query:</p>
<pre><code><span>SELECT</span> pg_size_pretty(<span>sum</span>(pg_relation_size(idx))::<span>bigint</span>) <span>as</span> <span>size</span>, <span>key</span>, (array_agg(idx))[<span>1</span>] <span>as</span> idx1, (array_agg(idx))[<span>2</span>] <span>as</span> idx2 <span>FROM</span> ( ... ) sub <span>GROUP</span> <span>BY</span> <span>key</span> <span>HAVING</span> <span>count</span>(*) &gt; <span>1</span> <span>ORDER</span> <span>BY</span> <span>sum</span>(pg_relation_size(idx)) <span>DESC</span>;
</code></pre>
<p>It filters the subquery to get keys that appear more than once, gets the size of the index, and provides the names of duplicated indexed. The above example finds only two indexes, but if you suspect that they can be more of them, simply add <code>(array_agg(idx))[n] as idxn</code> to get more of them as a result.</p>

<p>I bet you have often heard the term constraint, but what is it really? It’s a condition (or rule) that describes a valid state of the data in a table. Constraints are related to indexing because each time you create the constraint, you also create an index.</p>
<p>You have the following types of constraints at your disposal:</p>
<ul>
<li><p><strong>Primary key</strong> - a constraint that ensures that a column (or combination of columns) uniquely identifies each row in a given table.</p>
</li>
<li><p><strong>Unique</strong> - a constraint that ensures that a column (or combination of columns) is unique per given table. The difference between the primary key and the unique constraint is that the primary key does not allow null values.</p>
</li>
<li><p><strong>Not null</strong> - a constraint that ensures that a column does not contain a null value. On the backend you can call it presence validation for a given field in the form.</p>
</li>
<li><p><strong>Foreign key</strong> - a constraint that ensures that the relationship exists and help to avoid a case when you delete associated record in a second table and leave the “dead” reference in the base table.</p>
</li>
<li><p><strong>Check</strong> - a constraint that ensures that every row evaluates the given expression to true. For example, if you have a <code>salary</code> column, you can define the <code>salary &gt; 10000</code> expression, and each row in the table must evaluate it to true otherwise won’t be considered as valid.</p>
</li>
<li><p><strong>Exclusion</strong> - a constraint that ensures that two records does not have overlapping values on a given column. The most common case is an event table where we don’t want the <code>start_date</code> and <code>end_date</code> columns to overlap with another record.</p>
</li>
</ul>
<p>Having proper constraints help you to keep your data in the right format but also improves the performance as you avoid having invalid information inside the database so you simply have fewer data to process, scan, or query.</p>

<p>Last, but not least, it’s always good to know good practices regarding indexes. Not only because of technical interviews! It’s easier to memorize more general rules and go deeper each time it is needed instead of trying to memorize all of the information that is available.</p>
<p>Try to remember the following good practices to make the work with databases as efficient as possible:</p>
<ul>
<li><p><strong>Don’t index all columns</strong> - indexes increase the writing time and take space, so look for columns that you filter on or those that you need to validate.</p>
</li>
<li><p><strong>Don’t index columns if the table has little data</strong> - PostgreSQL won’t use indexes if there is just little data inside the table. The query planner would prefer to use a full scan in such cases.</p>
</li>
<li><p><strong>Select the proper index type</strong> - the b-tree index (which is a default one) is good for many cases but not for all. When you want to use full-text search, geospatial data, or more complex data types, the default index won’t be the right choice.</p>
</li>
<li><p><strong>Maintain your indexes</strong> - as time goes by, some of the indexes may no longer be needed, or the data needs to be reindexed. Remember to look after your indexes on a regular basis.</p>
</li>
<li><p><strong>Benchmark and test</strong> - always test indexes on production-like data before deploying them to ensure that you will benefit from the change.</p>
</li>
<li><p><strong>Use indexes</strong> - the query planner does a great job, but you can help him by using indexes; it will then more efficiently pull your data.</p>
</li>
</ul>
<p>When you make indexing the columns a habit, you will generate your own list of good practices with time. Also, understanding the way indexes work under the hood will help you to make more confident decisions regarding database architecture.</p>
</div></div></div>
  </body>
</html>
