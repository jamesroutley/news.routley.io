<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blat-blatnik.github.io/computerBear/making-accurate-sleep-function/">Original</a>
    <h1>Making an Accurate Sleep() Function</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>There are many cases in programming where I wish the system <code>Sleep()</code> function was more accurate. Real-time rendering immediately comes to mind, as do animated GUI’s. In both of these cases you want some piece of code to run on a fixed timer, executing <em>precisely</em> every 16.67 milliseconds for 60 FPS.</p>

<p>I haven’t really found any usefull posts or tutorials about how to do precise timing anywhere else, so I decided to make a short post about my own precise timing solution.</p>

<p><strong>Note</strong> this is only usefull if you can’t use <a href="https://en.wikipedia.org/wiki/Vsync_(computing)">vsync</a> for synchronization, or if you have no way to guarantee that vsync will be turned on on the user’s machine.</p>

<p><strong>Also note</strong> this is by no means a <em>perfect</em> solution, even though it seems to be pretty accurate, it isn’t very robust and might act differently on different systems.</p>

<h2 id="sleep">Sleep</h2>

<p>Before we move on, it’s important that you understand exactly what the problem with <code>Sleep()</code> is.</p>

<p>I should also clarify that by “sleep”, I mean the <a href="https://en.wikipedia.org/wiki/Sleep_(system_call)"><code>Sleep()</code></a> system call. It’s a function that makes the calling thread do nothing for a given period of time. In C++ we can use <a href="https://en.cppreference.com/w/cpp/thread/sleep_for"><code>this_thread::sleep_for()</code></a> from <a href="https://en.cppreference.com/w/cpp/header/thread"><code>&lt;thread&gt;</code></a> as a cross-platform way to sleep.</p>

<p>Let’s pretend like we’re making a simple game loop that needs to run <em>precisely</em> 60 times per second, so approximately once every 16.67 milliseconds. Let’s see what happens if we try to use <code>Sleep()</code> for our timing:</p>

<div><div><pre><code><span>#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;stdio.h&gt;
</span><span>using</span> <span>namespace</span> <span>std</span><span>;</span>
<span>using</span> <span>namespace</span> <span>std</span><span>::</span><span>chrono</span><span>;</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>auto</span> <span>prevClock</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>auto</span> <span>nextClock</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
        <span>double</span> <span>deltaTime</span> <span>=</span> <span>(</span><span>nextClock</span> <span>-</span> <span>prevClock</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
        <span>printf</span><span>(</span><span>&#34; frame time: %.2lf ms</span><span>\n</span><span>&#34;</span><span>,</span> <span>deltaTime</span> <span>*</span> <span>1e3</span><span>);</span>
        <span>// updateGame();</span>
        
        <span>// make sure each frame takes *at least* 1/60th of a second</span>
        <span>auto</span> <span>frameClock</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
        <span>double</span> <span>sleepSecs</span> <span>=</span> <span>1.0</span> <span>/</span> <span>60</span> <span>-</span> <span>(</span><span>frameClock</span> <span>-</span> <span>nextClock</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
        <span>if</span> <span>(</span><span>sleepSecs</span> <span>&gt;</span> <span>0</span><span>)</span>
            <span>this_thread</span><span>::</span><span>sleep_for</span><span>(</span><span>nanoseconds</span><span>((</span><span>int64_t</span><span>)(</span><span>sleepSecs</span> <span>*</span> <span>1e9</span><span>)));</span>

        <span>prevClock</span> <span>=</span> <span>nextClock</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>So far so good. This seems like it will do exactly what we want. But look at what happens when we run it:</p>

<div><div><pre><code> ...
 frame time: 17.99 ms
 frame time: 17.57 ms
 frame time: 17.53 ms
 frame time: 18.04 ms
 frame time: 17.53 ms
 frame time: 17.27 ms
 frame time: 17.76 ms
 frame time: 18.30 ms
 frame time: 17.35 ms
 frame time: 17.08 ms
 ...
</code></pre></div></div>

<p>Yikes. That doesn’t look precise at all. Remember that we were looking for steady 16.67ms, and not only are all frames taking longer than that, but the timings are completely inconsistent.</p>

<p>So why is the system sleep so imprecise? Well the answer is complicated. When you call <code>Sleep()</code>, your application releases it’s assigned CPU core to the OS’s scheduler, so that it’s free to do other tasks while your app waits. Ideally, the schedule will reschedule your application exactly at the time you requested, but things obviously don’t happen this way for 2 main reasons:</p>

<ol>
  <li>The scheduler wakes up approximately every 3ms. So if you tried to sleep for 1ms, you would instead sleep for <em>at least</em> 1ms, but up to 4ms. The exact time depends on how well you were synchronized with the scheduler’s own clock.</li>
  <li>When the time to reschedule comes, all threads might be in use by some higher-priority system services or apps, meaning you don’t get your thread back until <em>they</em> decide to sleep, or terminate.</li>
</ol>

<p>So, calling <code>Sleep()</code> only guarantees that your thread will wait for <em>at least</em> the given amount of time. Usually, this means 1-2ms more than you asked for. Also, this extra wait time is <em>random</em> for all intents and purposes. It depends on your exact system, what other programs are running, and the specific time you called <code>Sleep()</code>.</p>

<p>One very good thing about sleep in general is that it conserves the CPU. While your program is sleeping, other programs can utilize “your” CPU time to do usefull work, and if nothing else needs to run, the CPU can be put into low-power mode to save power and battery life.</p>

<h2 id="spin-lock">Spin-lock</h2>

<p>If you want to make your program wait for a precise amount of time without risking your thread to the OS’s scheduler, then spin-locking is pretty much the only thing you can do.</p>

<p>Spin-locking generally look like something like this: <code>while needToWaitMore(): doNothing()</code>. As you can see it’s pretty much the most precise method of waiting, as the CPU does absolutely nothing until the exact moment that it needs to stop waiting. We can incorporate this into our pretend-game loop like so:</p>

<div><div><pre><code><span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>auto</span> <span>nextClock</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>double</span> <span>deltaTime</span> <span>=</span> <span>(</span><span>nextClock</span> <span>-</span> <span>prevClock</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34; frame time: %.2lf ms</span><span>\n</span><span>&#34;</span><span>,</span> <span>deltaTime</span> <span>*</span> <span>1e3</span><span>);</span>
    <span>// updateGame();</span>
    
    <span>// make sure each frame takes *at least* 1/60th of a second</span>
    <span>auto</span> <span>frameClock</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>double</span> <span>sleepSecs</span> <span>=</span> <span>1.0</span> <span>/</span> <span>60</span> <span>-</span> <span>(</span><span>frameClock</span> <span>-</span> <span>nextClock</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
    <span>auto</span> <span>spinStart</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>while</span> <span>((</span><span>high_resolution_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>spinStart</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span> <span>&lt;</span> <span>seconds</span><span>);</span>

    <span>prevClock</span> <span>=</span> <span>nextClock</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, it’s very easy to set up. And this is what the timing’s look like when we run it:</p>

<div><div><pre><code> ...
 frame time: 16.67 ms
 frame time: 16.79 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.68 ms
 ...
</code></pre></div></div>

<p>Even this sadly isn’t fool proof though. You can clearly see that while <em>most</em> frames run for 16.67ms, one ran for 16.79ms and another ran for 16.68ms. I don’t really know exactly why this happens, but my guess is that the scheduler poked our thread at a bad time, right before the wait was supposed to end.</p>

<p>Still, this is <em>the most precision we can possibly get here</em>.</p>

<p>The problem with this is that spin-locking eats up CPU time and does absolutely nothing. This time could have been better used by other threads that actually have <em>usefull</em> work to do. Or if no other threads are running, the CPU core could have been switched into low-power mode in order to save power and battery life on mobile systems.</p>

<h2 id="combining-sleep-and-spin-lock">Combining sleep and spin-lock</h2>

<p>So far we’ve tried two options, each with their own pros and cons:</p>
<ol>
  <li><strong>Sleep</strong> conserves the CPU but is innacurate.</li>
  <li><strong>Spin-lock</strong> accurate but thrashes the CPU.</li>
</ol>

<p>These are pretty much on oposite ends of the spectrum. If we could somehow get the best of both worlds, we would have a perfect sleep function.</p>

<p>Without further ado, here is the <code>preciseSleep()</code> function that I came up with that combines these two:</p>

<div><div><pre><code><span>#include &lt;chrono&gt;
#include &lt;thread&gt;
#include &lt;math.h&gt;
</span>
<span>void</span> <span>preciseSleep</span><span>(</span><span>double</span> <span>seconds</span><span>)</span> <span>{</span>
    <span>using</span> <span>namespace</span> <span>std</span><span>;</span>
    <span>using</span> <span>namespace</span> <span>std</span><span>::</span><span>chrono</span><span>;</span>

    <span>static</span> <span>double</span> <span>estimate</span> <span>=</span> <span>5e-3</span><span>;</span>
    <span>static</span> <span>double</span> <span>mean</span> <span>=</span> <span>5e-3</span><span>;</span>
    <span>static</span> <span>double</span> <span>m2</span> <span>=</span> <span>0</span><span>;</span>
    <span>static</span> <span>int64_t</span> <span>count</span> <span>=</span> <span>1</span><span>;</span>

    <span>while</span> <span>(</span><span>seconds</span> <span>&gt;</span> <span>estimate</span><span>)</span> <span>{</span>
        <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
        <span>this_thread</span><span>::</span><span>sleep_for</span><span>(</span><span>milliseconds</span><span>(</span><span>1</span><span>));</span>
        <span>auto</span> <span>end</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>

        <span>double</span> <span>observed</span> <span>=</span> <span>(</span><span>end</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
        <span>seconds</span> <span>-=</span> <span>observed</span><span>;</span>

        <span>++</span><span>count</span><span>;</span>
        <span>double</span> <span>delta</span> <span>=</span> <span>observed</span> <span>-</span> <span>mean</span><span>;</span>
        <span>mean</span> <span>+=</span> <span>delta</span> <span>/</span> <span>count</span><span>;</span>
        <span>m2</span>   <span>+=</span> <span>delta</span> <span>*</span> <span>(</span><span>observed</span> <span>-</span> <span>mean</span><span>);</span>
        <span>double</span> <span>stddev</span> <span>=</span> <span>sqrt</span><span>(</span><span>m2</span> <span>/</span> <span>(</span><span>count</span> <span>-</span> <span>1</span><span>));</span>
        <span>estimate</span> <span>=</span> <span>mean</span> <span>+</span> <span>stddev</span><span>;</span>
    <span>}</span>

    <span>// spin lock</span>
    <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>while</span> <span>((</span><span>high_resolution_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span> <span>&lt;</span> <span>seconds</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>In short, <code>preciseSleep()</code> tries to sleep for 1ms only while it is sure (within reasonable doubt) that the <code>Sleep(1ms)</code> call won’t take longer than the amount of seconds left to wait for. Then it spin-locks for any remaining time.</p>

<p>This is what we get if we update our pretend-game loop from before to use this function:</p>

<div><div><pre><code> ...
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.69 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.67 ms
 frame time: 16.98 ms
 frame time: 16.67 ms
 ...
</code></pre></div></div>

<p>That’s looking very similar to the output for the spin-lock wait that we did before. Sometimes there are slight hiccups like that 16.98ms frame, but overall it’s pretty much as perfect as we can hope to get.</p>

<p>And the best part about it is that it uses way less CPU than a pure spin-lock. Mind you it still uses more CPU than a pure Sleep loop. On my laptop it measures somewhere around 5% core usage on average, but that’s way better than 100% with a pure spin-lock. We’ve basically cut down power usage by <strong>95%</strong> without a noticeable accuracy penalty.</p>

<h2 id="how-we-got-here">How we got here</h2>

<p>If you’re curious how I derived the <code>preciseSleep()</code> function above, then I’ll try to explain it now.</p>

<p>Let’s walk through a simple example that shows how we can combine Sleep with spin-locking. Let’s say that a perfect <code>preciseSleep()</code> function was called to sleep for exactly 3.4ms. Let’s also <em>assume</em> that our function somehow knows that calling <code>Sleep(1ms)</code> will sleep for <em>exactly</em> 1.1ms. The function would then obviously do something like this pseudo code:</p>

<div><div><pre><code><span>def</span> <span>preciseSleep</span><span>(</span><span>3.4</span><span>ms</span><span>)</span>
    <span>Sleep</span><span>(</span><span>1</span><span>ms</span><span>)</span>      <span># 1.1ms elapsed</span>
    <span>Sleep</span><span>(</span><span>1</span><span>ms</span><span>)</span>      <span># 2.2ms elapsed</span>
    <span>Sleep</span><span>(</span><span>1</span><span>ms</span><span>)</span>      <span># 3.3ms elapsed</span>
    <span>spinLock</span><span>(</span><span>0.1</span><span>ms</span><span>)</span> <span># 3.4ms elapsed</span>
<span>end</span>
</code></pre></div></div>

<p>This is perfect if we want to sleep for 3.4ms, but what about 2.4ms, or 10ms? Well we can deal with those in a loop like this:</p>

<div><div><pre><code><span>def</span> <span>preciseSleep</span><span>(</span><span>time</span><span>)</span>
    <span>while</span> <span>time</span> <span>&gt;</span> <span>1.1</span><span>ms</span>
        <span>Sleep</span><span>(</span><span>1</span><span>ms</span><span>)</span>     <span># we still assumes this takes precisely 1.1ms</span>
        <span>time</span> <span>-=</span> <span>1.1</span><span>ms</span>
    <span>end</span>
    <span>spinLock</span><span>(</span><span>time</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Great, and now to deal with the elephant in the room.. We don’t actually know how long <code>Sleep(1ms)</code> will take. But we can measure how long it takes to finish a bunch of times with our clock to get some estimate. And we can then keep updating this estimate while sleeping.</p>

<div><div><pre><code><span>estimate</span> <span>=</span> <span>??</span>

<span>def</span> <span>preciseSleep</span><span>(</span><span>time</span><span>)</span>
    <span>while</span> <span>time</span> <span>&gt;</span> <span>estimate</span>
        <span>start</span> <span>=</span> <span>clock</span><span>()</span>
        <span>Sleep</span><span>(</span><span>1</span><span>ms</span><span>)</span>
        <span>observed</span> <span>=</span> <span>clock</span><span>()</span> <span>-</span> <span>start</span>
        <span>time</span> <span>-=</span> <span>observed</span>
        <span>estimate</span> <span>=</span> <span>updateEstimate</span><span>(</span><span>observed</span><span>)</span>
    <span>end</span>
    <span>spinLock</span><span>(</span><span>time</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>This is looking promising, but what’s a good estimate here, and how do we find it? Well one thing we know for certain is that <code>Sleep(1ms)</code> will take <em>at least</em> 1ms. It might take more, upwards of 10ms even, who knows, but we can safely set our initial estimate to something higher, like 5ms and then decrease it once we actually have data.</p>

<p>Updating the estimate now might seem tricky, but the key realization here is that when we call <code>Sleep(1ms)</code>, we actually end up sleeping for 1ms + some random amount of noise time:</p>

<div><div><pre><code><span>duration</span> <span>of</span> <span>Sleep</span><span>(</span><span>1</span><span>ms</span><span>)</span> <span>=</span> <span>1</span><span>ms</span> <span>+</span> <span>random</span><span>()</span>
</code></pre></div></div>

<p>So really, we can treat the whole <code>Sleep(1ms)</code> call as having a random duration with some mean duration and some random spread. We can calculate the mean and standard deviation from our observed <code>Sleep(1ms)</code> durations to make reasonable updates to estimates. We can calculate these on-the-fly as we get new observations using <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford%27s_online_algorithm">Welford’s algorithm</a>. So our <code>updateEstimate()</code> can look something like this:</p>

<div><div><pre><code><span>mean</span>  <span>=</span> <span>5</span><span>ms</span>
<span>m2</span>    <span>=</span> <span>0</span>
<span>count</span> <span>=</span> <span>1</span>

<span>def</span> <span>updateEstimate</span><span>(</span><span>observed</span><span>)</span>
    <span>delta</span>  <span>=</span> <span>observed</span> <span>-</span> <span>mean</span>
    <span>count</span> <span>+=</span> <span>1</span>
    <span>mean</span>  <span>+=</span> <span>delta</span> <span>/</span> <span>count</span>
    <span>m2</span>    <span>+=</span> <span>delta</span> <span>*</span> <span>(</span><span>observed</span> <span>-</span> <span>mean</span><span>)</span>
    <span>stddev</span> <span>=</span> <span>sqrt</span><span>(</span><span>m2</span> <span>/</span> <span>(</span><span>count</span> <span>-</span> <span>1</span><span>))</span>
    <span>return</span> <span>estimate</span> <span>=</span> <span>mean</span> <span>+</span> <span>stddev</span>
<span>end</span>
</code></pre></div></div>

<p>Notice how we set the estimate to be one standard deviation above the mean. This is us being a bit pessimistic about how long <code>Sleep(1)</code> will take, because it can randomly take a lot longer than expected. If you want a higher precision at the cost of more wasted CPU cycles, you can change this to:</p>

<div><div><pre><code><span>return</span> <span>estimate</span> <span>=</span> <span>mean</span> <span>+</span> <span>X</span> <span>*</span> <span>stddev</span>
</code></pre></div></div>

<p>and then replace <code>X</code> with any constant you like. I have it set to 1 because it’s simple and seems to work reasonably well.</p>

<h2 id="timers-on-windows">Timers on Windows</h2>

<p>If you’re dead set on writting portable standard C++ code, than the above <code>preciseSleep()</code> function is probably as good as you’re gonna get. But if you’re willing to step down into the pits of Windows hell, you can try using <a href="https://docs.microsoft.com/en-us/windows/win32/sync/waitable-timer-objects">waitable timers</a> to drive your sleep function.</p>

<p>The upside of this is that it’s very CPU friendly. I got 0% reported CPU usage when using this in the pretend-game loop. The accuracy is significantly worse than <code>preciseSleep()</code>, but if an error of ~0.2ms is good enough for your needs then here you go:</p>

<div><div><pre><code><span>#include &lt;windows.h&gt;
#include &lt;chrono&gt;
#include &lt;math.h&gt;
</span>
<span>void</span> <span>timerSleep</span><span>(</span><span>double</span> <span>seconds</span><span>)</span> <span>{</span>
    <span>using</span> <span>namespace</span> <span>std</span><span>::</span><span>chrono</span><span>;</span>

    <span>static</span> <span>HANDLE</span> <span>timer</span> <span>=</span> <span>CreateWaitableTimer</span><span>(</span><span>NULL</span><span>,</span> <span>FALSE</span><span>,</span> <span>NULL</span><span>);</span>
    <span>static</span> <span>double</span> <span>estimate</span> <span>=</span> <span>5e-3</span><span>;</span>
    <span>static</span> <span>double</span> <span>mean</span> <span>=</span> <span>5e-3</span><span>;</span>
    <span>static</span> <span>double</span> <span>m2</span> <span>=</span> <span>0</span><span>;</span>
    <span>static</span> <span>int64_t</span> <span>count</span> <span>=</span> <span>1</span><span>;</span>
    
    <span>while</span> <span>(</span><span>seconds</span> <span>-</span> <span>estimate</span> <span>&gt;</span> <span>1e-7</span><span>)</span> <span>{</span>
        <span>double</span> <span>toWait</span> <span>=</span> <span>seconds</span> <span>-</span> <span>estimate</span><span>;</span>
        <span>LARGE_INTEGER</span> <span>due</span><span>;</span>
        <span>due</span><span>.</span><span>QuadPart</span> <span>=</span> <span>-</span><span>int64_t</span><span>(</span><span>toWait</span> <span>*</span> <span>1e7</span><span>);</span>
        <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
        <span>SetWaitableTimerEx</span><span>(</span><span>timer</span><span>,</span> <span>&amp;</span><span>due</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>,</span> <span>NULL</span><span>,</span> <span>0</span><span>);</span>
        <span>WaitForSingleObject</span><span>(</span><span>timer</span><span>,</span> <span>INFINITE</span><span>);</span>
        <span>auto</span> <span>end</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>

        <span>double</span> <span>observed</span> <span>=</span> <span>(</span><span>end</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
        <span>seconds</span> <span>-=</span> <span>observed</span><span>;</span>

        <span>++</span><span>count</span><span>;</span>
        <span>double</span> <span>error</span> <span>=</span> <span>observed</span> <span>-</span> <span>toWait</span><span>;</span>
        <span>double</span> <span>delta</span> <span>=</span> <span>error</span> <span>-</span> <span>mean</span><span>;</span>
        <span>mean</span> <span>+=</span> <span>delta</span> <span>/</span> <span>count</span><span>;</span>
        <span>m2</span>   <span>+=</span> <span>delta</span> <span>*</span> <span>(</span><span>error</span> <span>-</span> <span>mean</span><span>);</span>
        <span>double</span> <span>stddev</span> <span>=</span> <span>sqrt</span><span>(</span><span>m2</span> <span>/</span> <span>(</span><span>count</span> <span>-</span> <span>1</span><span>));</span>
        <span>estimate</span> <span>=</span> <span>mean</span> <span>+</span> <span>stddev</span><span>;</span>
    <span>}</span>

    <span>// spin lock</span>
    <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>while</span> <span>((</span><span>high_resolution_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span> <span>&lt;</span> <span>seconds</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<h2 id="data-accuracy">Data: accuracy</h2>

<p>How accurate is this precise sleeping function exactly? I’m not the sort of programmer that gets easily swayed without some numbers, so let’s get some.</p>

<p>First, I ran all 4 different sleep functions we’ve disscussed above for 1000 frames in our 60 FPS game loop test, and I measured the average, minimum, and maximum deviation from 16.67ms frame times when using each sleep function:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>1000</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
    <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>sleep</span><span>(</span><span>1</span> <span>/</span> <span>60.0</span><span>);</span>
    <span>auto</span> <span>end</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>double</span> <span>duration</span> <span>=</span> <span>(</span><span>end</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;%.2lf</span><span>\n</span><span>&#34;</span><span>,</span> <span>duration</span> <span>*</span> <span>1e3</span><span>);</span>
    <span>// data analysis was done later with a python script</span>
<span>}</span>
</code></pre></div></div>

<p>Here’s a graph comparing the errors for all 4 sleep functions:</p>

<p><img src="https://blat-blatnik.github.io/computerBear/assets/sleep/fig1.svg#center" alt="Figure 1"/></p>

<blockquote>
  <p><strong>Figure 1</strong> A graph comparing the absolute error of each sleep function in the 60 FPS game loop test. The bars represent the average error over 1000 runs, while the error lines represent the [minimum, maximum] error.</p>
</blockquote>

<p>You can clearly see how closely <code>preciseSleep()</code> matches spin-locking with a negligable error. <code>timerSleep()</code> does a bit worse with ~40μs of error on average.</p>

<p>Note that in the 60 FPS game loop test we were basically always sleeping for 16.67ms, but these functions are also very precise at higher/lower sleep intervals.</p>

<p>To show this, I ran each function 100 times in a loop with sleep intervals in 1ns, 10ns, 100ns, … 1 second.</p>

<div><div><pre><code><span>for</span> <span>(</span><span>int64_t</span> <span>ns</span> <span>=</span> <span>1</span><span>;</span> <span>ns</span> <span>&lt;=</span> <span>1&#39;000&#39;000&#39;000</span><span>;</span> <span>ns</span> <span>*=</span> <span>10</span><span>)</span> <span>{</span>
    <span>// note that I collected other data but this isn&#39;t shown for conciseness</span>
    <span>double</span> <span>mean</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>1</span><span>;</span> <span>i</span> <span>&lt;=</span> <span>100</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
        <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
        <span>sleep</span><span>(</span><span>sec</span><span>);</span>
        <span>auto</span> <span>end</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
        <span>double</span> <span>elapsed</span> <span>=</span> <span>(</span><span>end</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
        <span>mean</span> <span>+=</span> <span>(</span><span>elapsed</span> <span>-</span> <span>mean</span><span>)</span> <span>/</span> <span>i</span><span>;</span>
    <span>}</span>
    <span>printf</span><span>(</span><span>&#34;%.1lf</span><span>\n</span><span>&#34;</span><span>,</span> <span>mean</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>And here’s a graph showing the results.</p>

<p><img src="https://blat-blatnik.github.io/computerBear/assets/sleep/fig2.svg#center" alt="Figure 2"/></p>

<blockquote>
  <p><strong>Figure 2</strong> a log-log plot of the requested sleep time vs the actual measured sleep time when calling the different functions for various time intervals.</p>
</blockquote>

<p>Note how both <code>preciseSleep()</code> and <code>timerSleep()</code> match the requested sleeping time almost perfectly when it is higher than 10µs. Below 100ns not even spin locking can really match the requested time well, probably because calling <code>high_resolution_clock::now()</code> takes about 100ns on my system.</p>

<p>I have to admit it’s a bit difficult to tell how the different sleep function compare at higher times here because the errors are so miniscule. I can tell you that there <em>is</em> a small difference: spin-lock is obviously the most precise, followed by <code>preciseSleep()</code> and then followed by <code>timerSleep()</code>. If you want to see for yourself you can always look at the raw data.</p>

<h2 id="data-cpu-usage">Data: CPU usage</h2>

<p>There’s no way cross platform way to get CPU usage in C++ that I know of, so I resorted to using Windows’ <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getprocesstimes"><code>GetProcessTimes()</code></a> function.</p>

<div><div><pre><code><span>double</span> <span>getProcessTime</span><span>()</span> <span>{</span>
    <span>static</span> <span>DWORD</span> <span>pid</span> <span>=</span> <span>GetCurrentProcessId</span><span>();</span>
    <span>static</span> <span>HANDLE</span> <span>process</span> <span>=</span> <span>OpenProcess</span><span>(</span><span>PROCESS_QUERY_INFORMATION</span><span>,</span> <span>FALSE</span><span>,</span> <span>pid</span><span>);</span>

    <span>FILETIME</span> <span>creation</span><span>,</span> <span>exit</span><span>,</span> <span>kern</span><span>,</span> <span>user</span><span>;</span>
    <span>GetProcessTimes</span><span>(</span><span>process</span><span>,</span> <span>&amp;</span><span>creation</span><span>,</span> <span>&amp;</span><span>exit</span><span>,</span> <span>&amp;</span><span>kern</span><span>,</span> <span>&amp;</span><span>user</span><span>);</span>
    <span>uint64_t</span> <span>t1</span> <span>=</span> <span>(</span><span>uint64_t</span><span>(</span><span>kern</span><span>.</span><span>dwHighDateTime</span><span>)</span> <span>&lt;&lt;</span> <span>32</span><span>)</span> <span>|</span> <span>kern</span><span>.</span><span>dwLowDateTime</span><span>;</span>
    <span>uint64_t</span> <span>t2</span> <span>=</span> <span>(</span><span>uint64_t</span><span>(</span><span>user</span><span>.</span><span>dwHighDateTime</span><span>)</span> <span>&lt;&lt;</span> <span>32</span><span>)</span> <span>|</span> <span>user</span><span>.</span><span>dwLowDateTime</span><span>;</span>
    <span>return</span> <span>(</span><span>t1</span> <span>+</span> <span>t2</span><span>)</span> <span>/</span> <span>1e7</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>This returns the fractional number of seconds that our process was in use so far. If we divide this by the total number of seconds that elapsed since our program started, we can get a % CPU usage.</p>

<p>I then ran all of the different sleep functions for 1000 frames of the 60 FPS game loop and measured the total % CPU usage over the entire 1000 frames.</p>

<div><div><pre><code><span>double</span> <span>startProcess</span> <span>=</span> <span>getProcessTime</span><span>();</span>
<span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>

<span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>1000</span><span>;</span> <span>++</span><span>i</span><span>)</span>
    <span>sleep</span><span>(</span><span>1</span> <span>/</span> <span>60.0</span><span>);</span>

<span>double</span> <span>endProcess</span> <span>=</span> <span>getProcessTime</span><span>();</span>
<span>double</span> <span>duration</span> <span>=</span> <span>(</span><span>high_resolution_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
<span>double</span> <span>cpuUsage</span> <span>=</span> <span>100</span> <span>*</span> <span>(</span><span>getProcessTime</span><span>()</span> <span>-</span> <span>startProcess</span><span>)</span> <span>/</span> <span>duration</span><span>;</span>
<span>printf</span><span>(</span><span>&#34;cpu usage: %.1lf</span><span>\n</span><span>&#34;</span><span>,</span> <span>name</span><span>,</span> <span>cpuUsage</span><span>);</span>
</code></pre></div></div>

<p>I didn’t measure CPU usage for each individial sleep call as I’m not exactly sure how granular <code>GetProcessTimes()</code> is.</p>

<p>Anyway, here are the results:</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th><strong>CPU usage</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>system sleep</strong></td>
      <td>0.0%</td>
    </tr>
    <tr>
      <td><strong>spin-lock</strong></td>
      <td>99.8%</td>
    </tr>
    <tr>
      <td><strong>precise sleep</strong></td>
      <td>4.8%</td>
    </tr>
    <tr>
      <td><strong>timer sleep</strong></td>
      <td>0.4%</td>
    </tr>
  </tbody>
</table>

<p>So system sleep and spin-lock get 0 and ~100%, as expected. Precise sleep only uses 4.8%, that’s significantly lower than what I expected. And timer sleep also basically uses 0% of the CPU, which is great.</p>

<p>Now, it’s also interesting to look at how <code>preciseSleep()</code> and <code>timerSleep()</code> behave when they try to sleep for smaller time intervals, so I also wrote a little test for that.</p>

<p>I checked to CPU usage of both of them when they were waiting for 1ms .. 25ms in a loop for 10 seconds using something like this:</p>

<div><div><pre><code><span>for</span> <span>(</span><span>int64_t</span> <span>ms</span> <span>=</span> <span>1</span><span>;</span> <span>ms</span> <span>&lt;=</span> <span>10</span><span>;</span> <span>++</span><span>ms</span><span>)</span> <span>{</span>
    <span>double</span> <span>processStart</span> <span>=</span> <span>getProcessTime</span><span>();</span>
    <span>auto</span> <span>start</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>while</span> <span>((</span><span>high_resolution_clock</span><span>::</span><span>now</span><span>()</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span> <span>&lt;</span> <span>5</span><span>)</span>
        <span>sleep</span><span>(</span><span>ms</span> <span>/</span> <span>1e3</span><span>);</span>
    <span>auto</span> <span>end</span> <span>=</span> <span>high_resolution_clock</span><span>::</span><span>now</span><span>();</span>
    <span>double</span> <span>cpuTime</span> <span>=</span> <span>getProcessTime</span><span>()</span> <span>-</span> <span>processStart</span><span>;</span>
    <span>double</span> <span>allTime</span> <span>=</span> <span>(</span><span>end</span> <span>-</span> <span>start</span><span>).</span><span>count</span><span>()</span> <span>/</span> <span>1e9</span><span>;</span>
    <span>printf</span><span>(</span><span>&#34;CPU usage: %.1lf</span><span>\n</span><span>&#34;</span><span>,</span> <span>ms</span><span>,</span> <span>100</span> <span>*</span> <span>cpuTime</span> <span>/</span> <span>allTime</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Here are the results:</p>

<p><img src="https://blat-blatnik.github.io/computerBear/assets/sleep/fig3.svg#center" alt="Figure 3"/></p>

<blockquote>
  <p><strong>Figure 3</strong> The CPU usage of <code>preciseSleep()</code> and <code>timerSleep()</code> at different sleep intervals.</p>
</blockquote>

<p>So it seems like somewhere around 5ms-6ms is when both <code>preciseSleep()</code> and <code>timerSleep()</code> decide that actually sleeping instead of spin-locking is safe enough, on my system at least. <code>timerSleep()</code> then immediately falls down to 0% CPU usage at 6ms+, while the CPU usage of <code>preciseSleep()</code> slowly falls off from ~12% to ~3%.</p>

<h2 id="data-robustness">Data: robustness</h2>

<p>All of this data was obviously collected only from <em>my</em> computer, but OS scheduler granularity can vary a lot between different systems, and I wanted to make sure that the <code>preciseSleep()</code> routine performs well in general.</p>

<p>In order to test the behaviour on different scheduling periods, I made a little “fake” sleep routine that looks like this:</p>

<div><div><pre><code><span>void</span> <span>fakeSystemSleep</span><span>(</span><span>double</span> <span>seconds</span><span>)</span> <span>{</span>
    <span>// sleep for at least the requested time</span>
    <span>spinLock</span><span>(</span><span>seconds</span><span>);</span>

    <span>// align with the fake scheduler period</span>
    <span>double</span> <span>untilNextSchedule</span> <span>=</span> <span>SCHEDULER_PERIOD</span> <span>*</span> <span>(</span><span>rand</span><span>()</span> <span>/</span> <span>(</span><span>double</span><span>)</span><span>RAND_MAX</span><span>);</span>
    <span>spinLock</span><span>(</span><span>untilNextSchedule</span><span>);</span>
    
    <span>// emulate another process grabbing the CPU</span>
    <span>while</span> <span>((</span><span>rand</span><span>()</span> <span>/</span> <span>(</span><span>double</span><span>)</span><span>RAND_MAX</span><span>)</span> <span>&lt;</span> <span>0.05</span><span>)</span>
        <span>spinLock</span><span>(</span><span>SCHEDULER_PERIOD</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>It emulates the bahaviour of the system sleep function, although it spin locks instead of actually sleeping - but we don’t need to worry about that for this test.</p>

<p>We’ve already seen that the system sleep function behaves something like the above. But the nice part about <code>fakeSystemSleep()</code> is that we can control this <code>SCHEDULER_PERIOD</code> parameter which is supposed to emulate the period of an acual OS scheduler.</p>

<p>With this fake sleep function I measured the accuracy of <code>preciseSleep()</code> when <code>SCHEDULER_PERIOD</code> was set to 1ms .. 10ms. These are common periods for real OS schedulers so they should be representative. Either way, here are the results.</p>

<p><img src="https://blat-blatnik.github.io/computerBear/assets/sleep/fig4.svg#center" alt="Figure 4"/></p>

<blockquote>
  <p><strong>Figure 4</strong> A heatmap showing the relative error when sleeping with <code>preciseSleep()</code> for different time intervals and with different scheduler periods. The relative error is calculated as (t<sub>a</sub> - t<sub>r</sub> ) / t<sub>r</sub> where t<sub>r</sub> is the requested sleep time, and t<sub>a</sub> is the actual time spent sleeping.</p>
</blockquote>

<p>Ok so from the heatmap you can see how the error gradually increases as the scheduler period increases. This shows that <code>preciseSleep()</code> isn’t very robust against high scheduler periods when small intervals of sleep are requested.</p>

<p>We can also see that the error doesn’t increase as much when higher sleep intervals are requested (10+ ms). So <code>preciseSleep()</code> is pretty robust in those cases, but that doesn’t mean much.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Well, we’ve seen the problems with using the system’s <code>Sleep()</code> function for precise timing first-hand, and we’ve come up with 2 alternative sleeping functions to fix this. <code>preciseSleep()</code> is a cross platform solution with higher precision, while <code>timerSleep()</code> is a Windows-only solution with a lower precision but also lower CPU usage.</p>

<p>I think I’ve also demonstrated that both of these functions can be very precise with an average error less than 0.1ms. <em>But</em> the caveat is that they behave unpredictably if ran on an operating system whose scheduler operates on a period &gt; 5ms.</p>

<p>Luckily, modern operating systems have scheduler periods in the low range of 1-5ms, at least <a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/cc938613(v=technet.10)?redirectedfrom=MSDN">according to Microsoft</a>. On my machine it seems to be around 2ms based on the <code>Sleep()</code> timings I’m getting. <code>preciseSleep()</code> seems to be pretty stable in this range.</p>

<p>However, if you’re depending on this working on most computers, you’re probably not going to want to use <code>preciseSleep()</code> or anything based even remotely on the system <code>Sleep()</code> call. Use a spin-lock, it will eat up your CPU, but sometimes it’s a necessary evil.</p>

<p>I really wish OS API’s provided more accurate timing measures. I’m really not sure what the excuse is for how frankly pathetic the OS provided timing measures truly are. Even adding something like a <code>beginLowPowerCPUMode()</code> function would go a long way, because then we could at least conserve the CPU while we spin lock for more precise timings. But, who knows, maybe there are some security issues with there that I’m not considering.</p>

<p>Either way, see you next time.</p>

<h2 id="source-code">Source Code</h2>

<p>You can download all of the source code used in this post, as well as the script I used to process the data by clicking <a href="https://blat-blatnik.github.io/computerBear/assets/sleep/src.zip">here</a>.</p>

<p>You can download the raw data used for the figures by clicking here <a href="https://blat-blatnik.github.io/computerBear/assets/sleep/data.zip">here</a>.</p>

  </div>

  

  
</article>

      </div>
    </div></div>
  </body>
</html>
