<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/1006117/">Original</a>
    <h1>New horizons for Julia</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
<a href="https://julialang.org/">Julia</a>, a free, general-purpose
programming language aimed at science, engineering, and related arenas of
technical computing, has steadily improved and widened its scope of
application since its <a href="https://julialang.org/blog/2012/02/why-we-created-julia">initial public
release in 2012</a>. As part of its <a href="https://julialang.org/blog/2024/10/julia-1.11-highlights/">1.11 release</a> from late 2024, Julia made several inroads into areas
outside of its traditional focus, provided its users with advances in
tooling, and has seen several improvements in performance and programmer
convenience. 
These recent developments in and
around Julia go a long way to answer several longstanding complaints from
both new and experienced users. We last <a href="https://lwn.net/Articles/958337/">looked
in on the language</a> one year ago,
for its previous major release, Julia 1.10. 
</p>

<h4 id="static-binaries">Static binaries</h4>

<p>
It&#39;s simple to share Julia projects in environments where 
Julia is already installed: provide the text files containing the program and one
additional text file, called <tt>Project.toml</tt>, which lists the direct
dependencies of the code. This latter file is generated automatically by
Julia. The recipient need merely execute the single command <a href="https://pkgdocs.julialang.org/v1/environments/#Using-someone-else&#39;s-project"><tt>instantiate</tt></a>
to have Julia install any needed packages to exactly reproduce the
environment.
</p>

<!-- middle-ad -->

<p>
This works well with colleagues who happen to be Julia users; it is great
for collaborative development and for reproducibility in scientific
research. However, it&#39;s a dead end for colleagues who do not have Julia
installed. Distributing the program in the
form of an 
&#34;app&#34; would solve the problem, but a normal installation of Julia provides
no obvious way to do this. 
</p>

<p>
As Julia is a compiled language, one might wonder what the problem
is. After all, you can compile your Fortran or C program into a compact,
self-contained (perhaps, depending on shared libraries) binary, and even
target a variety of architectures with cross-compilation. Anyone can run
these binaries, without a compiler installed.
</p>

<p>
It has also been possible to compile a Julia program into a static binary
for some time, using the <a href="https://github.com/JuliaLang/PackageCompiler.jl">PackageCompiler
package</a>. Experienced Julia hands use this package to create &#34;system
images&#34; (or &#34;sysimages&#34;) that contain the Julia runtime along with frozen
versions of packages used in their projects. These sysimages load instantly
and save time when one is not currently using the Julia read-eval-print
loop (REPL).
</p>

<p>
The major improvements in precompilation and package-loading times that
came with 1.10 largely obsoleted the use of PackageCompiler to save
startup time. PackageCompiler might still be a solution to the problem of binary
distribution except for one serious issue: the binaries that it
generates are huge.
</p>

<p>
The sysimages created by PackageCompiler contain the Julia runtime, the
entire standard library, parts of the LLVM
compiler, and more. The result is that a &#34;hello, world&#34; program is burdened
with about 150MB of stuff that it does not use. (The compiled &#34;hello,
world&#34; program will, for example, contain the BLAS linear algebra routines,
because, in its current state of development, PackageCompiler does not
figure out that they are not needed.) This is a vast improvement over
earlier incarnations of PackageCompiler, which turned &#34;hello world&#34; into a
gargantuan 900MB, but does not compare well with, for example, the Fortran
equivalent. I just used the <a href="https://gcc.gnu.org/wiki/GFortran"><tt>gfortran</tt></a> compiler to
process a Fortran 90 &#34;hello world&#34; program and found that it resulted
in a
tiny 17KB binary.
</p>

<p>
Efforts toward reducing the size of binaries have also involved another package for static
compilation. This package is only useful for relatively small Julia
programs, however, and is confined to a severely limited set of language
features. Within these limitations, <a href="https://github.com/tshort/StaticCompiler.jl">StaticCompiler</a> can produce truly small binaries, similar
in size
to those produced by C and Fortran. Because of the limitations, however, interest
remained focused on the evolution of PackageCompiler.
</p>

<p>
Why can&#39;t PackageCompiler just strip out the unneeded stuff and create
binaries of a reasonable size? That&#39;s the obvious question, but finding a
way to eliminate the unneeded baggage turned out to be a difficult
problem. Julia&#39;s dynamic design and its focus on REPL-driven development
mean that its runtime and &#34;just-ahead-of-time&#34; compiler were envisioned to
be always available behind the scenes. They are used to compile new methods
for newly-encountered mixtures of argument types and to keep the whole
array of language features at the ready, including various types of
introspection. This is the essential reason that binaries created by
PackageCompiler are so large, and why so much work was required to allow
the programmer nearly full use of all language features while not dragging
the entire runtime along with each compilation target.
</p>

<p>
The goal of creating small binaries has occupied a handful of talented
developers over the past few years, and they have recently achieved a new
level of success. Development builds of Julia now include an experimental
method of invoking the compiler called <tt>juliac</tt>. This compiler
invocation script <a href="https://github.com/JuliaLang/julia/commit/97ecdb8595c4a1fbe68ba6f39b3244e8cdabc2c6">comes
with a <tt>--trim</tt> flag</a> that &#34;trims&#34; away whatever is not needed to
run the program, while still allowing the use of nearly all normal Julia
features. The idea is that the user will be able to type <tt>juliac</tt> at
the terminal, instead of <tt>julia</tt>, to compile a binary rather than
run a program or start the REPL. The result is an impressive 90% reduction
in final binary size compared with the current version of PackageCompiler.
The exact size of &#34;hello world&#34; is fluctuating some in the development
builds as of this writing, but it is around 900KB.
</p>

<p>
The next major Julia release, 1.12, is likely to appear in mid-2025. It will finally include the ability to generate static
binaries of a reasonable size, appropriate for distribution. This will be a
refinement of the <tt>juliac</tt> mechanism that is already merged into the
development branch.
</p>

<p>
Static compilation  will be the definitive answer to the complaints and
wishes of many 
Julia programmers who have wanted their favorite language to be able to do
what the traditional workhorses for scientific computing have done for decades.
</p>

<h4 id="juliaup"><tt>juliaup</tt></h4>

<p>
Julia has always been easy to install and upgrade on operating systems
such as Linux and BSD: simply download and expand the tarball
and place a link to the <tt>julia</tt> binary in your
<tt>path</tt>. Julia&#39;s <a href="https://lwn.net/Articles/871490/">package
system</a> also makes it easy to keep any number of Julia versions
installed on the same machine, with dependencies correctly resolved for
projects using different versions of the language.
However, it&#39;s clear from questions on forums that there are many users of
Julia who are less comfortable using command-line tools to navigate their
filesystems. Installing, upgrading, or switching among versions often leads
to confusion.
</p>

<p>
Now there is a utility called &#34;<a href="https://github.com/JuliaLang/juliaup"><tt>juliaup</tt></a>&#34; to make
their lives simpler. As <tt>juliaup</tt> has become the <a href="https://julialang.org/downloads/">recommended</a> way to
install and upgrade Julia, it&#39;s now widely used even by Linux adopters
(although I am set in my ways and don&#39;t bother with it).
<tt>juliaup</tt> does provide some useful abstractions. These are built
around its concept of &#34;channels&#34;. Some examples of <tt>juliaup</tt>
channels are <tt>release</tt>, referring to the latest stable version of
Julia; <tt>lts</tt>, referring to the &#34;long term support&#34; release;
<tt>beta</tt>, pointing to the most recent beta; and <tt>nightly</tt>,
pointing to, perhaps unsurprisingly, the nightly build. Thanks to this
channel abstraction, one need never refer to Julia&#39;s version numbers.
</p>

<p>
To get the latest nightly, a user simply types:
</p>

<pre>    $ juliaup update nightly
</pre>

<p>
<tt>juliaup</tt> also provides a new, flexible <tt>julia</tt> command for starting
the language.
To run the nightly build, the command is:
</p>

<pre>    $ julia +nightly
</pre>

<p>
After executing the command:
</p>

<pre>    $ juliaup default release
</pre>

<p>
the plain <tt>julia</tt> command will now use the stable release.
</p>

<p>
These are just a few examples of how <tt>juliaup</tt> works. It comes with
a collection of other commands to do such things as list available
channels, update all channels at once, or refer to specific Julia versions,
as well.
</p>

<h4 id="julia-in-web-browsers">Julia in web browsers</h4>

<p>
These days, fairly complex simulations written in Julia can run completely
within the web browser.
Alexander Barth has created a fun and addictive <a href="https://alexander-barth.github.io/FluidSimDemo-WebAssembly/">simulation
of fluid flow</a> that runs in the browser. The visitor can draw
boundaries with the mouse and watch the pressure field adapt. The same
author has also created a browser-based <a href="https://alexander-barth.github.io/FluidSimDemo-WebAssembly/ShallowWater/">simulation
of surface waves</a>. Those with an interest in <a href="https://en.wikipedia.org/wiki/Chaos_theory">chaos theory</a> can find an <a href="https://tshort.github.io/WebAssemblyCompiler.jl/stable/examples/lorenz/">in-browser
solution</a> of the famous Lorenz system of ordinary differential
equations. It&#39;s remarkably fast, and the demonstration comes with a
tutorial explaining how it was done.
</p>

<p>
These three examples were written not in JavaScript, but in Julia, and run
in the browser thanks to <a href="https://webassembly.org">WebAssembly</a>. <a href="https://lwn.net/Articles/648510/">Launched</a> in 2015, WebAssembly
(often abbreviated &#34;Wasm&#34;) is a binary instruction format that has become
widely deployed in modern web browsers. It potentially allows any language
to run in a browser, provided someone has written a WebAssembly compiler
for it.
</p>

<p>
The <a href="https://wasmlang.org">growing list</a> of source languages
with WebAssembly compilers in various stages of development is
encouraging. We can already use <a href="https://lwn.net/Articles/898452/">Python</a>, C, Go, Lua, Rust, and
many others as replacements for JavaScript. However, despite the impressive
examples above, Julia for WebAssembly is still in the early stages of
development. Only a restricted subset of the language is supported (for
example, no multidimensional arrays). However, the problems encountered in
creating small binaries have some overlap with the problems of targeting
WebAssembly, so recent progress in the former is likely to help speed along
the latter.
</p>

<p>
Readers interested in getting their Julia programs running in the browser
should start with the <a href="https://tshort.github.io/WebAssemblyCompiler.jl/stable">WebAssemblyCompiler</a>
package. The author warns that the code is experimental, but it comes with
guided examples.
</p>

<h4 id="features-of-1.11">Features of 1.11</h4>

<p>
The <a href="https://discourse.julialang.org/t/julia-v1-11-3-has-been-released/125056">latest
release</a> of Julia is 1.11.3, unveiled on January 21, 2025. The <a href="https://docs.julialang.org/en/v1/NEWS/#Julia-v1.11-Release-Notes">release notes</a> for the
1.11 major version, which appeared on October 8, provide detailed
information on the improvements to the language in that release. Here I&#39;ll
summarize some of the most important and interesting language developments since 1.10.
</p>

<p>
<tt>MemoryRef</tt> datatype: many array operations had been implemented in C
up to now, which <a href="https://hackmd.io/@vtjnash/GenericMemory">created some overhead</a>. These have now been moved to Julia
code thanks to a <a href="https://hackmd.io/@vtjnash/GenericMemory#New-Builtin-functions">new
datatype called <tt>MemoryRef</tt></a>. The performance improvements coming
from this change include a
doubling in speed of the <tt>push!()</tt> function that inserts items
onto the end of an array. The maintainer of the WebAssembly
package remarked that the <tt>MemoryRef</tt> datatype will finally allow
multidimensional arrays to be used in Julia programs destined for
WebAssembly.
</p>

<p>
<tt>public</tt> keyword: as pointed out in our article about Julia&#39;s
package system, names in a module can be explicitly exported, which allows
their use without namespacing. For example, Base is a library that is
automatically imported into every Julia environment. It provides hundreds
of functions, from basic mathematical workhorses such as <tt>sin()</tt> to
string manipulation routines such as <tt>split()</tt>.  Julia programmers
can use these functions by invoking their unadorned names because they are
exported by the modules in which they are defined.
</p>

<p>
However, Base also
contains functions useful in more unusual contexts that are not
exported. One example is <tt>Base.OneTo(n)</tt>, which returns something
like the interval <tt>1:n</tt>, but slightly different in the way that it&#39;s
treated by the type system. Those who know that they need this function
must namespace it by prefixing <tt>Base</tt>. Although not exported,
<tt>Base.OneTo()</tt> is &#34;safe&#34; to use; it&#39;s intended for public
consumption and will not break future code. This is <em>not</em> the case for
every unexported function defined in every module.  Up to now, there was no
standard way to tell the difference between a safe unexported function and
one that should be considered &#34;private&#34;, in the sense that it may not be
future-proof. Now <a href="https://julialang.org/blog/2024/10/julia-1.11-highlights/#new_public_keyword">Julia&#39;s
<tt>public</tt> keyword</a> fills this gap by marking names that are safe
to use even if they are not exported. Of course Julia will not stop programmers
from using names not so blessed, but now it will warn them.
</p>

<p>
<a href="https://julialang.org/blog/2024/10/julia-1.11-highlights/#stdlib_excision"><tt>stdlib</tt>
excision</a>: Julia 1.11 continues the process that has been underway for a
couple of years to remove modules from the standard library and turn them
into normal packages. This allows them to be developed independently from
releases of the language, which generally allows a faster pace of
improvements. It also allows Julia to be distributed with a smaller
sysimage, purged of unnecessary libraries, that can start faster and
consume less memory. In the latest release, modules from stdlib will all have
their own version numbers, formalizing their independent existence.
</p>

<p>
<tt>@main</tt>: Julia 1.11 <a href="https://julialang.org/blog/2024/10/julia-1.11-highlights/#new_main_entry_point">added
a <tt>@main</tt> macro</a> that marks which function in a Julia program
file will be the entry point when the program is run (rather than
imported). This lets programmers use the same file as a resource imported
into other programs and as a file to be executed. For example, a module
that consists of a list of function definitions can be imported into
another program without any side effects. But if one of those functions is
decorated with <tt>@main</tt>, then, if the same file is <em>executed</em>
(for instance by typing &#34;<tt>julia file.jl</tt>&#34;), in addition to the
functions being defined, the one so marked will be run. This is
semantically identical to inserting a line at the bottom of the file
invoking the name of the main function; thanks to <tt>@main</tt>, one
version of the file can now be used both ways.
</p>

<h4 id="conclusion">Conclusion</h4>

<p>
Due to the accumulation of improvements in the last several versions of
Julia, startup times have become fast enough that I have begun to use the
language for utility scripting, something that would have been impractical
a few years ago. This trend continues in the most recent version, and the
greater ease of compiling programs promised in the next version should make
Julia even more suited for building system utilities. It&#39;s already become a
serious contender to replace Bash and Python for my purposes.
If WebAssembly targeting continues to make progress, which the improvements
to compilation will also contribute to, then Julia will become a
welcome replacement for (or addition to) JavaScript as well, further
extending its scope of application.
</p>

<p>
A solution to the problem of small binaries, to be released as part of 1.12, should
allay the misgivings of those for whom the difficulty of sharing compiled
programs has kept them away from the language.
For Julia&#39;s core original audience, who were accustomed to amortizing large
compilation times over simulation times measured in days or weeks, the new
language&#39;s awkwardness in some interactive contexts was an acceptable
tradeoff to finally have a modern, expressive medium that did not entail
compromises in performance.
By successfully meeting the objections of Julia&#39;s critics in several key
areas, its developers have ensured that their language is poised to widen
its scope far beyond that original core user base.
</p></div></div>
  </body>
</html>
