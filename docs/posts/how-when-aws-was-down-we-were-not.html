<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://authress.io/knowledge-base/articles/2025/11/01/how-we-prevent-aws-downtime-impacts">Original</a>
    <h1>How when AWS was down, we were not</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content" itemprop="articleBody"><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>For help understanding this article or how you can implement auth and similar security architectures in your services, feel free to reach out to me via the <a href="https://authress.io/community" target="_blank" rel="noopener noreferrer">community server</a>.</p></div><h2 id="aws-is-down">üö® AWS us-east-1 is down!<a href="#aws-is-down" aria-label="Direct link to üö® AWS us-east-1 is down!" title="Direct link to üö® AWS us-east-1 is down!">‚Äã</a></h2><p>One of the most massive AWS incidents transpired on <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">October 20th</a>. The long story short is that the DNS for DynamoDB was impacted for <code>us-east-1</code>, which created a health event for the entire region. It&#39;s the worst incident we&#39;ve seen in a decade. <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">Disney+</a>, <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">Lyft</a>, <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">McDonald&#39;ss</a>, <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">New York Times</a>, <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">Reddit</a>, and the <a href="https://www.cnbc.com/2025/10/20/amazon-web-services-outage-takes-down-major-websites.html" target="_blank" rel="noopener noreferrer">list goes on</a> were lining up to claim their share too of the spotlight. And we&#39;ve been watching because our product is part of our customers critical infrastructure. This one graph of the event says it all:</p><p><img loading="lazy" alt="Route 53 Health Check result where us-east-1 is down" src="https://authress.io/knowledge-base/assets/images/route53healthcheck-175155e6db205fcb2ce60e342835f530.png" width="1319" height="695"/></p><p>The AWS <a href="https://aws.amazon.com/message/101925/" target="_blank" rel="noopener noreferrer">post-incident report</a> indicates that at 7:48 PM UTC DynamoDB had <em>&#34;increased error rates&#34;</em>. But this article isn&#39;t about AWS, and instead I want to share <strong>how exactly we were still up when when AWS was down.</strong></p><p>Now you might be thinking: <strong><em>why are you running infra in us-east-1?</em></strong></p><p>And it&#39;s true, almost no one should be using us-east-1, unless, well, of course, you are us. And that&#39;s because we end up running our infrastructure where our customers are. In theory, practice and theory are the same, but in practice they differ. And if our (or your) customers chose <code>us-east-1</code> in AWS, then realistically, that means you are also choosing us-east-1 üòÖ.</p><p>During this time, us-east-1 was offline, and while we only run a limited amount of infrastructure in the region, we have to run it there because we have customers who want it there. And even without a direct dependency on <code>us-east-1</code>, there are critical services in AWS ‚Äî CloudFront, Certificate Manager, Lambda@Edge, and IAM ‚Äî that all have their control planes in that region. Attempting to create distributions or roles at that time were also met with significant issues.</p><p>Since there are plenty of articles in the wild talking about <a href="https://newsletter.pragmaticengineer.com/p/what-caused-the-large-aws-outage" target="_blank" rel="noopener noreferrer">what actually happened</a>, <a href="https://www.crn.com/news/cloud/2025/aws-15-hour-outage-5-big-ai-dns-ec2-and-data-center-keys-to-know" target="_blank" rel="noopener noreferrer">why it happened</a>, and <a href="https://www.theregister.com/2025/10/20/aws_outage_amazon_brain_drain_corey_quinn/" target="_blank" rel="noopener noreferrer">why it will continue to happen</a>, I don&#39;t need to go into it here. Instead, I&#39;m going to share a dive about exactly what we&#39;ve built to avoid these exact issues, and what you can do for your applications and platforms as well. In this article, I&#39;ll review how we maintain a high SLI to match our SLA <strong>reliability</strong> commitment even when the infrastructure and services we use don&#39;t.</p><h2 id="reliability">üìñ What is reliability?<a href="#reliability" aria-label="Direct link to üìñ What is reliability?" title="Direct link to üìñ What is reliability?">‚Äã</a></h2><p>Before I get to the part where I share how we built one of the most reliable <a href="https://authress.io/knowledge-base/articles/auth-situation-report">auth solutions</a> available. I want to define reliability. And for us, that&#39;s an SLA of five nines. I think that&#39;s so extraordinary that the question I want you to keep in mind through this article is: <strong>is that actually possible?</strong> Is it really achievable to have a service with a five nines SLA? When I say five nines, I mean that 99.999% of the time, our service is up and running as expected by our customers. And to put this into perspective, the red, in the sea of blue, represents just how much time we can be down.</p><p><img loading="lazy" alt="What does 5 nines look like" src="https://authress.io/knowledge-base/assets/images/how-much-is-5-nines-c194bc4c40bc0b3cce3e6b43112048f0.png" width="1283" height="176"/></p><p>And if you can&#39;t see it, it&#39;s hiding inside this black dot. It amounts to just five minutes and 15 seconds per year. This pretty much means we have to be up all the time, providing responses and functionality exactly as our customers expect.</p><p><img loading="lazy" alt="5 nines on the timescale of a year" src="https://authress.io/knowledge-base/assets/images/how-much-is-5-nines-red-dot-1333ca56c8c7cd5d1ba066a244213394.png" width="1271" height="566"/></p><h2 id="but-why">ü§î But why?<a href="#but-why" aria-label="Direct link to ü§î But why?" title="Direct link to ü§î But why?">‚Äã</a></h2><p>To put it into perspective, it&#39;s important to share for a moment, the specific challenges that we face, why we built what we built, and of course why that&#39;s relevant. To do that, I need to include some details about what we&#39;re building ‚Äî what <a href="https://authress.io" target="_blank" rel="noopener noreferrer">Authress actually does</a>. Authress provides login and access control for the software applications that you write ‚Äî It generates JWTs for your applications. This means:</p><ul><li>User authentication and authorization</li><li>User identities</li><li>Granular role and resource-based authorization (ReBAC, ABAC, TBAC, RBAC, etc...)</li><li>API keys for your technical customers to interact with your own APIs</li><li>Machine to machine authentication, or services ‚Äî if you have a microservice architecture.</li><li>Audit trails to track the permission changes within your services or expose this to your customers.</li></ul><p>And there are of course many more components, that help complete full auth-platform, but they aren&#39;t totally relevant to this article, so I&#39;m going to skip over them.</p><p>With that, you may already start to be able to see why uptime is so critical for us. <strong>We&#39;re on the critical path for our customers</strong>. It&#39;s not inherently true for every single platform, but it is for us. So if our solution is down, then our customer applications are down as well.</p><p>If we put the reliability part in the back corner for one second and just think about the features, we can theorize about a potential initial architecture. That is, an architecture that just focuses on the features, how might you build this out as simple as possible? I want to do this, so I can help explain all the issues that we would face with the simple solution.</p><p>Maybe you&#39;ve got a single region, and in that region you have some sort of HTTP router that handles requests and they forward to some compute, serverless, container, or virtual machine, or, and I&#39;m very sorry for the scenario ‚Äî if you have to use bare metal. Lastly, you&#39;re interacting with some database, NoSQL, SQL, or something else, file storage, and maybe there&#39;s some async components.</p><p><img loading="lazy" alt="The simplest auth architecture" src="https://authress.io/knowledge-base/assets/images/initial-architecture-36b5d669429755d471abd1d58a1535ba.png" width="1204" height="555"/></p><p>If you take a look at this, it&#39;s probably obvious to you (and everyone else) that there is no way it is going to meet our reliability needs. But we have to ask, just exactly how often will there actually be a problem with this architecture? Just building out complexity doesn&#39;t directly increase reliability, we need to focus on why this architecture would fail. For us, we use AWS, so I look to the Amazon CTO for guidance, and he&#39;s famously quoted as saying, <em><strong>Everything fails all the time</strong></em>.</p><p>And AWS&#39;s own services are no exception to this. Over the last decade, we&#39;ve seen numerous incidents:</p><ul><li>2014 - Ireland (Partial) - Hardware - Transformer failed - EC2, EBS, and RDS</li><li>2016 - Sydney (Partial) - Severe Weather - Power Loss - All Services</li><li>2017 - All Regions - Human error - S3 critical servers deleted - S3</li><li>2018 - Seoul Region - Human error - DNS resolvers impacted - EC2</li><li>2021 - Virginia - Traffic Scaling - Network Control Plane outage - All Services</li><li>2021 - California - Traffic Scaling - Network Control Plane outage - All Services</li><li>2021 - Frankfurt (Partial) - Fire - Fire Suppression System issues - All Services</li><li>2023 - Virginia - Kinesis issues - Scheduling Lambda Invocations impact - Lambda</li><li>2023 - Virginia - Networking issues - Operational issue - Lambda, Fargate, API Gateway‚Ä¶</li><li>2023 - Oregon (Partial) - Error rates - Dynamodb + 48 services</li><li>2024 - Singapore (Partial) - EC2 Autoscaling - EC2</li><li>2024 - Virginia (Partial) - Describe API Failures ECS - ECS + 4 services</li><li>2024 - Brazil - ISP issues - CloudFront connectivity - CloudFront</li><li>2024 - Global - Network connectivity - STS Service</li><li>2024 - Virginia - Message size overflow - Kinesis down - Lambda, S3, ECS, CloudWatch, Redshift</li><li><strong>2025 - Virginia - Dynamo DB DNS - DynamoDB down - All Services</strong></li></ul><p>And any one of these would have caused major problems for us and therefore our customers. And the frequency of incident is actually increasing in time. This shouldn&#39;t be a surprise, right? Cloud adoption is increasing over time. The number of services AWS is offering is also increasing. But how impactful are these events? Would single one of them have been a problem for us to actually reach our SLA promise? What would happen if we just trusted AWS and used that to pass through our commitments? Would it be sufficient to achieve 99.999% SLA uptime? Well, let&#39;s take a look.</p><h2 id="aws">üï∞Ô∏è AWS SLA Commitments<a href="#aws" aria-label="Direct link to üï∞Ô∏è AWS SLA Commitments" title="Direct link to üï∞Ô∏è AWS SLA Commitments">‚Äã</a></h2><h4 id="the-aws-lambda-sla-is-below-5-nines">The AWS Lambda SLA is below 5 nines<a href="#the-aws-lambda-sla-is-below-5-nines" aria-label="Direct link to The AWS Lambda SLA is below 5 nines" title="Direct link to The AWS Lambda SLA is below 5 nines">‚Äã</a></h4><p><img loading="lazy" alt="Lambda SLA" src="https://authress.io/knowledge-base/assets/images/lambda-sla-a4d87b72819203815380229225a332f9.png" width="1307" height="475"/></p><h4 id="the-api-gateway-sla-is-below-5-nines">The API Gateway SLA is below 5 nines<a href="#the-api-gateway-sla-is-below-5-nines" aria-label="Direct link to The API Gateway SLA is below 5 nines" title="Direct link to The API Gateway SLA is below 5 nines">‚Äã</a></h4><p><img loading="lazy" alt="API Gateway SLA" src="https://authress.io/knowledge-base/assets/images/api-gateway-sla-f263c0452ec0d45283d0d7375b49d0ef.png" width="1299" height="407"/></p><h4 id="the-aws-sqs-sla-is-below-5-nines">The AWS SQS SLA is below 5 nines<a href="#the-aws-sqs-sla-is-below-5-nines" aria-label="Direct link to The AWS SQS SLA is below 5 nines" title="Direct link to The AWS SQS SLA is below 5 nines">‚Äã</a></h4><p><img loading="lazy" alt="SQS SLA" src="https://authress.io/knowledge-base/assets/images/sqs-sla-1055fc9668c15c2e53ea324f07db43df.png" width="1301" height="388"/></p><p>Okay, so when it comes to trusting AWS SLAs, it isn&#39;t sufficient. At. All.</p><p>We can&#39;t just use the components that are offered by AWS, and go from there. We fundamentally need to do something more than that. So the question becomes, what exactly must a dependency&#39;s reliability be in order for us to utilize it? To answer that question, it&#39;s time for a math lesson. Or more specifically, everyone&#39;s favorite topic, <strong>probabilities</strong>.</p><p>Let&#39;s quickly get through this <del>torture</del> exercise. Fundamentally, you have endpoints in your service, and you get in an HTTP request, and it interacts with some third-party component or API, and then you write the result to a database. For us, this could be an integration such as <strong>logging in with Google</strong> or with <strong>Okta</strong> for our customers&#39; enterprise customers.</p><p><img loading="lazy" alt="Third-party Failure Rate" src="https://authress.io/knowledge-base/assets/images/thirdparty-failure-rate-3efad846ceef7a4ad985f9a367333673.png" width="1503" height="413"/></p><h2 id="calculations">üíª Calculating the allowed failure rate<a href="#calculations" aria-label="Direct link to üíª Calculating the allowed failure rate" title="Direct link to üíª Calculating the allowed failure rate">‚Äã</a></h2><p>So if we want to meet a 5-nines reliability promise, how unreliable could this third-party component actually be? What happens if this component out of the box is only 90% reliable? We&#39;ll design a strategy for getting around that.</p><p>Uptime is a product of all of the individual probabilities:</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>=</mo><msub><mi mathvariant="normal">P</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚àó</mo><msub><mi mathvariant="normal">P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚àó</mo><mo>‚ãØ</mo><msub><mi mathvariant="normal">P</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚ãØ</mo><mo>‚àó</mo><msub><mi mathvariant="normal">P</mi><mrow><mi>C</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}_{total}(\text{Success}) = \mathrm{P}_{0}(\text{S}) * \mathrm{P}_{1}(\text{S}) * \cdots \mathrm{P}_{i}(\text{S}) \cdots *\mathrm{P}_{C - 1}(\text{S})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>0</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚àó</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>1</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚àó</span><span></span></span><span><span></span><span>‚ãØ</span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>i</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚ãØ</span><span></span><span>‚àó</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>C</span><span>‚àí</span><span>1</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span></span></span></span></span></p><p>For the sake of this example, we&#39;ll just assume that every other component in our architecture is 100% reliable ‚Äî That&#39;s every line of code, no bugs ever written in our library dependencies, or transitive library dependencies, or the dependencies&#39; dependencies&#39; dependencies, and everything always works exactly as we expect.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>‚àó</mo><mn>1</mn><mo>‚àó</mo><mo>‚ãØ</mo><msub><mi mathvariant="normal">P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>‚ãØ</mo><mo>‚àó</mo><mn>1</mn><mo>‚àó</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mathrm{P}_{total}(\text{Success}) = 1 * 1 * \cdots \mathrm{P}_{3rdParty}(\text{Success}) \cdots * 1 * 1</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span>‚àó</span><span></span></span><span><span></span><span>1</span><span></span><span>‚àó</span><span></span></span><span><span></span><span>‚ãØ</span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>‚ãØ</span><span></span><span>‚àó</span><span></span></span><span><span></span><span>1</span><span></span><span>‚àó</span><span></span></span><span><span></span><span>1</span></span></span></span></span></p><p>So we can actually rewrite our uptime promise as a result of the failure rate of that third-party component.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>‚àí</mo><msub><mi mathvariant="normal">P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Failure</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}_{total}(\text{Success}) = 1 - \mathrm{P}_{3rdParty}(\text{Failure})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span>‚àí</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Failure</span></span><span>)</span></span></span></span></span></p><p>And the only way that we can actually increase the success rate of the uptime based off of failures is to retry. And so we can multiply out the third-party failure rate and retry multiple times.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>‚àí</mo><msub><mi mathvariant="normal">P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Failure</mtext><msup><mo stretchy="false">)</mo><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\mathrm{P}_{total}(\text{Success}) = 1 - \mathrm{P}_{3rdParty}(\text{Failure})^{Retry Count}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>1</span><span></span><span>‚àí</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Failure</span></span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>R</span><span>e</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>Logically that makes a lot of sense. When a component fails, if you retry again, and again, the likelihood it will be down every single time approaches zero. And we can generate a really nasty equation from this to actually determine how many exact times do we need to retry.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><mo>‚â•</mo><mfrac><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi mathvariant="normal">P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>F</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>u</mi><mi>r</mi><mi>e</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><msub><mi mathvariant="normal">P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">{Retry Count} \ge \frac{ln(\mathrm{P}_{3rdParty}(Failure))}{ln(1 - \mathrm{P}_{total}(Success))}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>R</span><span>e</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span><span></span><span>‚â•</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>l</span><span>n</span><span>(</span><span>1</span><span></span><span>‚àí</span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>u</span><span>ccess</span><span>))</span></span></span><span><span></span><span></span></span><span><span></span><span><span>l</span><span>n</span><span>(</span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>F</span><span>ai</span><span>l</span><span>u</span><span>re</span><span>))</span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></p><p>How many exactly can it? Rather than guessing whether or not we should retry four times or five times, or put it in a <code>while(true)</code> loop, we can figure it out exactly. So we take this equation and extend it out a little bit. Plugging in our 90% reliable third-party component:</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><mo>‚â•</mo><mfrac><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mtext>10%</mtext><mo stretchy="false">)</mo></mrow><mrow><mi>l</mi><mi>n</mi><mo stretchy="false">(</mo><mn>1</mn><mo>‚àí</mo><mtext>99.999%</mtext><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">{Retry Count} \ge \frac{ln(\text{10\%})}{ln(1 - \text{99.999\%})}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>R</span><span>e</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span><span></span><span>‚â•</span><span></span></span><span><span></span><span><span></span><span><span><span><span><span><span></span><span><span>l</span><span>n</span><span>(</span><span>1</span><span></span><span>‚àí</span><span></span><span><span>99.999%</span></span><span>)</span></span></span><span><span></span><span></span></span><span><span></span><span><span>l</span><span>n</span><span>(</span><span><span>10%</span></span><span>)</span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span><span></span></span></span></span></span></span></p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><mo>‚â•</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">{Retry Count} \ge 5</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>R</span><span>e</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span><span></span><span>‚â•</span><span></span></span><span><span></span><span>5</span></span></span></span></span></p><p>We find that our retry count actually must be greater than or equal to five. We can see that this adds up to our uptime expectation:</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mtext>10%</mtext><mn>5</mn></msup><mo>=</mo><mn>0.00001</mn><mo>‚üπ</mo><mtext>99.999%</mtext></mrow><annotation encoding="application/x-tex">\text{10\%}^{5} = 0.00001 \Longrightarrow \text{99.999\%}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>10%</span></span><span><span><span><span><span><span></span><span><span><span>5</span></span></span></span></span></span></span></span></span><span></span><span>=</span><span></span></span><span><span></span><span>0.00001</span><span></span><span>‚üπ</span><span></span></span><span><span></span><span><span>99.999%</span></span></span></span></span></span></p><p>Is this the end of the story? Just retry a bunch of times and you&#39;re good? Well, not exactly. Remember this equation?</p><div><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="normal">P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>=</mo><msub><mi mathvariant="normal">P</mi><mn>0</mn></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚àó</mo><msub><mi mathvariant="normal">P</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚àó</mo><mo>‚ãØ</mo><msub><mi mathvariant="normal">P</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚ãØ</mo><mo>‚àó</mo><msub><mi mathvariant="normal">P</mi><mrow><mi>C</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{P}_{total}(\text{Success}) = \mathrm{P}_{0}(\text{S}) * \mathrm{P}_{1}(\text{S}) * \cdots \mathrm{P}_{i}(\text{S}) \cdots *\mathrm{P}_{C - 1}(\text{S})</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>0</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚àó</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>1</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚àó</span><span></span></span><span><span></span><span>‚ãØ</span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>i</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚ãØ</span><span></span><span>‚àó</span><span></span></span><span><span></span><span><span>P</span><span><span><span><span><span><span></span><span><span><span>C</span><span>‚àí</span><span>1</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span></span></span></span></span></p></div><p>We do really need to consider every single component that we utilize. And specifically when it comes to the third-party component, we had to execute it by utilizing a retry handler. So we need to consider the addition of the retry handler into our equation. Going back to the initial architecture, instead of what we had before, when there&#39;s a failure in that third-party component, now we will automatically execute some sort of asynchronous retries or in-process retries. And every time that third-party component fails, we execute the retry handler and retry again.</p><p>This means we need to consider the reliability of that retry handler.</p><p><img loading="lazy" alt="Retry handler failure rate consideration" src="https://authress.io/knowledge-base/assets/images/retry-handler-failure-rate-cb802d75c06552c63b81e7f4c0245f2b.png" width="1297" height="686"/></p><p>Let&#39;s assume we have a really reliable retry handler and that it&#39;s even more reliable than our service. I think that&#39;s reasonable, and actually required. A retry handler that is less reliable than our stated SLA by default is just as faulty as the third-party component.</p><p>Let&#39;s consider one with five and a half nines ‚Äî that&#39;s half a nine more reliable than our own SLA.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>E</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>99.9995%</mtext></mrow><annotation encoding="application/x-tex">{P}_{retryExecutor}(S) = \text{99.9995\%}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>re</span><span>t</span><span>ry</span><span>E</span><span>x</span><span>ec</span><span>u</span><span>t</span><span>or</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span>99.9995%</span></span></span></span></span></span></p><p>But how reliable does it really need to be? Well, we can pull in our original equation and realize that our total uptime is the unreliability or the reliability of the third-party component multiplied by the reliability of our retry handler.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo stretchy="false">(</mo><mtext>Success</mtext><mo stretchy="false">)</mo><mo>=</mo><msub><mi>P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mtext>S</mtext><mo stretchy="false">)</mo><mo>‚àó</mo><msub><mi>P</mi><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>E</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{P}_{total}(\text{Success}) = {P}_{3rdParty}(\text{S}) * {P}_{retryExecutor}(S)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>Success</span></span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span><span>S</span></span><span>)</span><span></span><span>‚àó</span><span></span></span><span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>re</span><span>t</span><span>ry</span><span>E</span><span>x</span><span>ec</span><span>u</span><span>t</span><span>or</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>)</span></span></span></span></span></p><p>From here, we add in the retries to figure out what the result should be:</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>W</mi><mi>i</mi><mi>t</mi><mi>h</mi><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>E</mi><mi>x</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>t</mi><mi>o</mi><mi>r</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mrow><mi>r</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">{P}_{totalWithRetries}(S) = ({P}_{retryExecutor}(S))^{retryCount}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>t</span><span>o</span><span>t</span><span>a</span><span>l</span><span>Wi</span><span>t</span><span>h</span><span>R</span><span>e</span><span>t</span><span>r</span><span>i</span><span>es</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>)</span><span></span><span>=</span><span></span></span><span><span></span><span>(</span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>re</span><span>t</span><span>ry</span><span>E</span><span>x</span><span>ec</span><span>u</span><span>t</span><span>or</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>)</span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>re</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>99.999%</mtext><mo>‚â§</mo><mo stretchy="false">(</mo><mtext>99.9995%</mtext><msup><mo stretchy="false">)</mo><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\text{99.999\%} \le (\text{99.9995\%})^{RetryCount}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>99.999%</span></span><span></span><span>‚â§</span><span></span></span><span><span></span><span>(</span><span><span>99.9995%</span></span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>R</span><span>e</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow><mo>‚â§</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">{RetryCount} \le 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>R</span><span>e</span><span>t</span><span>ry</span><span>C</span><span>o</span><span>u</span><span>n</span><span>t</span></span><span></span><span>‚â§</span><span></span></span><span><span></span><span>2</span></span></span></span></span></p><p>We have a reliable retry handler, but it&#39;s not perfect. And with a retry handler that has reliability of five and a half nines, we can retry <strong>a maximum two times</strong>. Because remember, it has to be reliable every single time we utilize it, as it is a component which can also fail. Which means left with this equation:</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>5</mn><mo>&gt;</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">5 \gt 2</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>5</span><span></span><span>&gt;</span><span></span></span><span><span></span><span>2</span></span></span></span></span></p><p>I don&#39;t think comes as a surprise to anyone that in fact five is greater than two. What is the implication here?</p><p>The number of retries required for that unreliable third-party component to be utilized by us exceeds the number of retries actually allowed by our retry handler.</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>d</mi></mrow><mo>&gt;</mo><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">{Retries Required} \gt Retries Allowed</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span>R</span><span>e</span><span>t</span><span>r</span><span>i</span><span>es</span><span>R</span><span>e</span><span>q</span><span>u</span><span>i</span><span>re</span><span>d</span></span><span></span><span>&gt;</span><span></span></span><span><span></span><span>R</span><span>e</span><span>t</span><span>r</span><span>i</span><span>es</span><span>A</span><span>ll</span><span>o</span><span>w</span><span>e</span><span>d</span></span></span></span></span></p><p>That&#39;s a failure, the retry handler can only retry twice before itself violates our SLA, but we need to retry five times in order to raise the third-party component reliably up. We can actually figure out what the minimum reliability of a third-party component is allowed to be, when using our retry handler:</p><p><span><span><span><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>y</mi><mi>H</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>l</mi><mi>e</mi><mi>r</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>1</mn><mo>‚àí</mo><msub><mi>P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>F</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>u</mi><mi>r</mi><mi>e</mi><msup><mo stretchy="false">)</mo><mrow><mi>R</mi><mi>e</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>s</mi><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>d</mi></mrow></msup></mrow></mstyle></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mtext>99.999%</mtext></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>‚â§</mo><mn>1</mn><mo>‚àí</mo><msub><mi>P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>F</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>u</mi><mi>r</mi><mi>e</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></mstyle></mtd><mtd></mtd><mtd></mtd></mtr><mtr><mtd></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>P</mi><mrow><mn>3</mn><mi>r</mi><mi>d</mi><mi>P</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>y</mi></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>&gt;</mo><mtext>99.7%</mtext></mrow></mstyle></mtd><mtd></mtd><mtd></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} Min({P}_{3rdParty}(Success)) &amp;= f(RetryHandler) \\ &amp;= 1 - {P}_{3rdParty}(Failure)^{Retries Allowed} \\ \text{99.999\%} &amp;\le 1 - {P}_{3rdParty}(Failure)^{2} \\ Min({P}_{3rdParty}(Success)) &amp;&gt; \text{99.7\%} \end{align}</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span><span><span><span><span><span><span></span><span><span>M</span><span>in</span><span>(</span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>u</span><span>ccess</span><span>))</span></span></span><span><span></span><span></span></span><span><span></span><span><span><span>99.999%</span></span></span></span><span><span></span><span><span>M</span><span>in</span><span>(</span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>S</span><span>u</span><span>ccess</span><span>))</span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span><span><span><span><span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>f</span><span>(</span><span>R</span><span>e</span><span>t</span><span>ryH</span><span>an</span><span>d</span><span>l</span><span>er</span><span>)</span></span></span><span><span></span><span><span></span><span></span><span>=</span><span></span><span>1</span><span></span><span>‚àí</span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>F</span><span>ai</span><span>l</span><span>u</span><span>re</span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>R</span><span>e</span><span>t</span><span>r</span><span>i</span><span>es</span><span>A</span><span>ll</span><span>o</span><span>w</span><span>e</span><span>d</span></span></span></span></span></span></span></span></span></span></span><span><span></span><span><span></span><span></span><span>‚â§</span><span></span><span>1</span><span></span><span>‚àí</span><span></span><span><span><span>P</span></span><span><span><span><span><span><span></span><span><span><span>3</span><span>r</span><span>d</span><span>P</span><span>a</span><span>r</span><span>t</span><span>y</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span><span>(</span><span>F</span><span>ai</span><span>l</span><span>u</span><span>re</span><span><span>)</span><span><span><span><span><span><span></span><span><span><span>2</span></span></span></span></span></span></span></span></span></span></span><span><span></span><span><span></span><span></span><span>&gt;</span><span></span><span><span>99.7%</span></span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span></span><span><span><span><span><span><span></span><span></span></span><span><span></span><span></span></span><span><span></span><span></span></span><span><span></span><span></span></span></span><span>‚Äã</span></span><span><span><span></span></span></span></span></span></span></span></span></p><p>Which in turn validates that it&#39;s actually impossible for us to utilize that component. <code>99.7%</code>. <code>99.7%</code> is the minimum allowed reliability for any third-party component in order for us to meet our required 5-nines SLA. This third-party component is so unreliable (<code>~90%</code>), that even using a highly reliable retry handler, we still can&#39;t make it reliable enough without the retry handler itself compromising our SLA. We fundamentally need to consider this constraint, when we&#39;re building out our architecture. </p><p>That means we drop this third-party component. Done.</p><p>And then, let&#39;s assume we get rid of every flaky component, everything that don&#39;t have a high enough reliability for us. At this point, it&#39;s good to think, is this sufficient to achieve our 5-nines SLA? Well, it isn&#39;t just third-party components we have to be concerned about. We also have to be worried about those AWs infrastructure failures.</p><h2 id="infrastructure">üå©Ô∏è Infrastructure Failures<a href="#infrastructure" aria-label="Direct link to üå©Ô∏è Infrastructure Failures" title="Direct link to üå©Ô∏è Infrastructure Failures">‚Äã</a></h2><p>So let&#39;s flashback to our initial architecture again:</p><p><img loading="lazy" alt="The simplest auth architecture" src="https://authress.io/knowledge-base/assets/images/initial-architecture-36b5d669429755d471abd1d58a1535ba.png" width="1204" height="555"/></p><p>We can have issues at the database layer, right? There could be any number of problems here. Maybe it&#39;s returning 500s, there are some slow queries, maybe things are timing out. Or there could be a problem with our compute. Maybe it&#39;s not scaling up fast enough. We&#39;re not getting new infrastructure resources. Sometimes, even AWS is out of bare metal machines when you don&#39;t reserve them, request them get them on demand, and the list go on.</p><p>Additionally, there could also be some sort of network issue, where requests aren&#39;t making it through to us or even throw a DNS resolution error on a request from our users.</p><p><img loading="lazy" alt="AWS Infrastructure Failure locations" src="https://authress.io/knowledge-base/assets/images/infra-failures-1cd729c359ce13d417b142d40ceb105b.png" width="1139" height="517"/></p><p>In many of these cases, I think the answer is obvious. We just have to declare the whole region as down. And you are probably thinking, well, this is where we failover to somewhere else. No surprise, yeah, this is exactly what we do:</p><p><img loading="lazy" alt="Region failover strategy in AWS" src="https://authress.io/knowledge-base/assets/images/region-failover-7a2b87080459460ea41d68a5d74419e2.png" width="1509" height="635"/></p><p>However, this means we have to have all the data and all the infrastructure components duplicated to another region in order to do this. And since <a href="https://authress.io" target="_blank" rel="noopener noreferrer">Authress</a> has <strong>six primary regions</strong> around the world, that also means we need multiple backup regions to be able to support the strategy. But this comes with significant wasted resources and wasted compute that we&#39;re not even getting to use. Costly! But I&#39;ll get to that later.</p><p>Knowing a redundant architecture is required is a great first step, but that leaves us having to solve for: <strong>how do we actually make the failover happen in practice?</strong></p><h2 id="strategy">üöß The Failover Routing Strategy<a href="#strategy" aria-label="Direct link to üöß The Failover Routing Strategy" title="Direct link to üöß The Failover Routing Strategy">‚Äã</a></h2><p>Simply put ‚Äî our strategy is to utilize DNS dynamic routing. This means requests come into our DNS and it automatically selects between one of two target regions, the primary region that we&#39;re utilizing or the failover region in case there&#39;s an issue. The critical component of the infrastructure is to switch regions during an incident:</p><p><img loading="lazy" alt="Utilizing Route 53 health checks" src="https://authress.io/knowledge-base/assets/images/route53-failover-9cf08debc464f1c92eb384207584810e.png" width="832" height="620"/></p><p>In our case, when using AWS, this means using the Route 53 health checks and the <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-policy-failover.html" target="_blank" rel="noopener noreferrer">Route 53 failover routing policy</a>.</p><p>We know how we&#39;re gonna do it, but the long pole in the tent is actually knowing that there is even a problem in the first place. A partial answer is to say <strong>Have a health check</strong>, so of course there is health check here. But the full answer is: have a health check that validates both of the regions, checking if the region is up, or is there an incident? And if it is, reports the results to the DNS router.</p><p>We could be utilizing the default provided handler from AWS Route 53 or a third-party component which pings our website, but that&#39;s not accurate enough from a standpoint of correctly and knowing for certain that our services are in fact down.</p><p>It would be devastating for us to fail over when a secondary region is having worse problems than our primary region. Or what if there&#39;s an issue with with network traffic. We wouldn&#39;t know if that&#39;s an issue of communication between AWS&#39;s infrastructure services, or an issue with the default Route 53 health check endpoint, or some entangled problem with how those specifically interact with our code that we&#39;re actually utilizing. So it became a requirement to built something ourselves, custom, to actually execute exactly what we need to check.</p><p>Here is a representation of what we&#39;re doing. It&#39;s not exactly what we are doing, but it&#39;s close enough to be useful. Health check request come in from the Route 53 Health Check. They call into our APIGW or Load Balancer as a router. The requests are passed to our compute which can interact and validate logic, code, access, and data in the database:</p><p><img loading="lazy" alt="The health check endpoint architecture" src="https://authress.io/knowledge-base/assets/images/dns-health-check-5aad726de934354da648cffb60004d10.png" width="892" height="473"/></p><p>The health check executes this code on request that allows us to validate if the region is in fact healthy:</p><div><p>Region HealthCheck validation</p><div><pre tabindex="0"><code><span><span>import</span><span> </span><span>Authorizer</span><span> </span><span>from</span><span> </span><span>&#39;./authorizer.js&#39;</span><span>;</span><span></span><br/></span><span><span></span><span>import</span><span> </span><span>ModelValidator</span><span> </span><span>from</span><span> </span><span>&#39;./modelValidator.js&#39;</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span></span><span>async</span><span> </span><span>healthCheck</span><span>(</span><span>request</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>    </span><span>await</span><span> profiler</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>const</span><span> dynamoDbCheck </span><span>=</span><span> accountDatabase</span><span>.</span><span>getDefaultAccount</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>const</span><span> indexerCheck </span><span>=</span><span> indexer</span><span>.</span><span>authorizationCheck</span><span>(</span><span>&#39;HealthCheck&#39;</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>const</span><span> sqsValidation </span><span>=</span><span> sqsClient</span><span>.</span><span>queue</span><span>(</span><span>&#39;LiveCheck&#39;</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>const</span><span> authorizer </span><span>=</span><span> </span><span>Authorizer</span><span>.</span><span>validate</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>const</span><span> modelValidation </span><span>=</span><span> </span><span>ModelValidator</span><span>.</span><span>validate</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>try</span><span> </span><span>{</span><span></span><br/></span><span><span>        </span><span>await</span><span> </span><span>Promise</span><span>.</span><span>all</span><span>(</span><span>[</span><span></span><br/></span><span><span>          dynamoDbCheck</span><span>,</span><span> indexerCheck</span><span>,</span><span> sqsValidation</span><span>,</span><span></span><br/></span><span><span>          authorizer</span><span>,</span><span> modelValidation </span><span>]</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>}</span><span> </span><span>catch</span><span> </span><span>(</span><span>error</span><span>)</span><span> </span><span>{</span><span></span><br/></span><span><span>        logger</span><span>.</span><span>log</span><span>(</span><span>&#39;HealthCheck Failed&#39;</span><span>,</span><span> error</span><span>)</span><span>;</span><span></span><br/></span><span><span>        </span><span>return</span><span> </span><span>{</span><span> </span><span>statusCode</span><span>:</span><span> </span><span>503</span><span> </span><span>}</span><span>;</span><span></span><br/></span><span><span>    </span><span>}</span><span></span><br/></span><span><span></span><br/></span><span><span>    </span><span>await</span><span> profiler</span><span>.</span><span>end</span><span>(</span><span>)</span><span>;</span><span></span><br/></span><span><span>    </span><span>return</span><span> </span><span>{</span><span> </span><span>statusCode</span><span>:</span><span> </span><span>200</span><span> </span><span>}</span><span>;</span><span></span><br/></span><span><span></span><span>}</span><br/></span></code></pre></div></div><ol><li>We start a profiler to know how long our requests are taking.</li><li>Then we interact with our databases, as well as validate some secondary components, such as SQS. While issues with secondary components may not always be a reason to failover, they can cause impacts to response time, and those indicators can be used to predict incoming incidents.</li><li>From there, we check whether or not the most critical business logic is working correctly. In our case, that&#39;s interactions with DynamoDB as well as core authorizer logic. Compared to a simple unit test, this accounts for corruption in a deployment package, as well instances where some subtle differences between regions interact with our code base. We can catch those sorts of problems here, and know that the primary region that we&#39;re utilizing, one of the six, is having a problem and automatically update the DNS based on this.</li><li>When we&#39;re done, we return success or failure so the health check can track changes.</li></ol><h2 id="improvement">üåø Improving the Failover Strategy<a href="#improvement" aria-label="Direct link to üåø Improving the Failover Strategy" title="Direct link to üåø Improving the Failover Strategy">‚Äã</a></h2><p>And we don&#39;t stop here with our infrastructure failover however. With the current strategy, it&#39;s good, in some cases, even sufficient. But it isn&#39;t that great. For starters, we have to completely failover. If there&#39;s just one component that&#39;s problematic, we can&#39;t just swap that one out easily, it&#39;s all or nothing with the Route 53 health check. So when possible, we push for an edge-optimized architecture. In AWS, this means utilizing <a href="https://aws.amazon.com/cloudfront/" target="_blank" rel="noopener noreferrer">AWS CloudFront</a> with AWS Lambda@Edge for compute. This not only helps reduce latency for our customers and their end users depending where they are around the world, as a secondary benefit, fundamentally, it is an improved failover strategy.</p><p>And that looks like this:</p><p><img loading="lazy" alt="CloudFront Edge Failover" src="https://authress.io/knowledge-base/assets/images/edge-failover-1c7bc4a076542e0b3b8f257cf031f523.gif" width="1393" height="531"/></p><p>Using CloudFront gives us a <a href="https://aws.amazon.com/blogs/networking-and-content-delivery/charting-the-life-of-an-amazon-cloudfront-request/" target="_blank" rel="noopener noreferrer">highly reliable CDN</a>, which routes requests to the locally available compute region. From there, we can interact with the local database. When our database in that region experiences a health incident, we automatically failover, and check the database in a second adjacent region. And when there&#39;s a problem there as well, we do it again to a third region. We can do that because when utilizing DynamoDB we have <a href="https://aws.amazon.com/dynamodb/global-tables/" target="_blank" rel="noopener noreferrer">Global Tables</a> configured for authorization configuration. In places where we don&#39;t need the data duplicated, we just interact with the table in a different region without replication.</p><p>After a third region with an issue, <strong>we stop.</strong></p><p>And maybe you&#39;re asking why three and not four or five or six? Aren&#39;t you glad we did the probabilities exercise earlier? Now you can actually figure out why it&#39;s three here. But, I&#39;ll leave that math as an exercise for you.</p><p>As a quick recap, this handles the problems with at the infrastructure level and with third-party components. And if we solve those, is that sufficient for us to achieve our goal the 5-nines SLA?</p><p>For us the answer is <strong>No</strong>, and you might have guessed, if you peaked at the scrollbar or table contents that there are still quite some additional components integrated into our solution. One of them is knowing that at some point, there&#39;s going to be a bug in our code, unfortunately.</p><h2 id="application">üíª Application level failures<a href="#application" aria-label="Direct link to üíª Application level failures" title="Direct link to üíª Application level failures">‚Äã</a></h2><p>And that bug will get committed to production, which means we&#39;re going to end up with an application failure. It should be obvious that it isn&#39;t achievable to write completely bug-free code. Maybe there is someone out there that thinks that, and maybe even that&#39;s you, and I believe you that you believe that. However, I know it&#39;s not me, and realistically, I don&#39;t want to sit around and pray that it&#39;s also my fellow team members. The risk is too high, because in the case something does get into production, that means it can impact some of our customers. So instead, let&#39;s assume that will happen and design a strategy around it.</p><p>So when it does happen, we of course have to trigger our incident response. For us, we send out an email, we post a message on our community and internal communication workspaces, and start an on-call alert. The technology here isn&#39;t so relevant, but tools like AWS SES, SQS, SNS, Discord, and emails are involved.</p><p>Incidents wake an engineer up, so someone can start to take look at the incident, and most likely the code.</p><p>But by the time they even respond to the alert, let alone actually investigate and fix the cause of the incident, we would long violated our SLA. So an alert is not sufficient for us. We need to also implement automation to automatically remediate any of these problems. Now, I&#39;m sure you&#39;re thinking, <em>yeah, okay, test automation</em>. You might even be thinking about an LLM agent that can automatically create PRs. (Side note: LLM code generation, doesn&#39;t actually work for us, and I&#39;ll get to that a little further down) Instead, we have to rely on having sufficient testing in place. And yes, of course we do. We test before deployment. There is no better time to test.</p><p>This seems simple and an obvious answer, and I hope that for anyone reading this article it is. Untested code never goes to production. Every line of code is completely tested before it is merged to production, even if it is enabled on some flag. Untested code is never released, it is far too dangerous. Untested code never makes it to production behind some magic flag. Abusing feature flags to make that happen could not be a worse decision for us. And that&#39;s because we can need to be as confident as possible before those changes actually get out in front of our customers. The result is ‚Äî we don&#39;t focus on test coverage percentage, but rather <strong>test value</strong>. That is, which areas provide most value, that are most risky, that we care about being the most reliable for our customers. Those are the ones we focus on testing.</p><h3 id="root-cause-analysis-rca">Root Cause Analysis (RCA)<a href="#root-cause-analysis-rca" aria-label="Direct link to Root Cause Analysis (RCA)" title="Direct link to Root Cause Analysis (RCA)">‚Äã</a></h3><p><strong>Every incident could have been prevented if we just had one more test.</strong> The trick though is actually having that right test, before the incident.</p><p>And in reality, that&#39;s not actually possible. Having every right test for a service that is constantly changing, while new features are being added, is just unmaintainable. Every additional test we write increases the maintenance burden of our service. Attempting to achieve 100% complete test coverage would require an infinite amount of time. This is known as the <a href="https://en.wikipedia.org/wiki/Pareto_principle" target="_blank" rel="noopener noreferrer">Pareto Principle</a>, more commonly the 80-20 rule. If it takes 20% of the time to deliver 80% of the tests, it takes an infinite amount of time to achieve all the tests, and that assumes that the source code isn&#39;t changing.</p><p>The result is we&#39;ll never be able to catch everything. <strong>So we can&#39;t just optimize for prevention. We also need to optimize for recovery.</strong> This conclusion for us means also implementing tests against our deployed production code. One example of this are validation tests.</p><h2 id="validation-tests">üìã Validation Tests<a href="#validation-tests" aria-label="Direct link to üìã Validation Tests" title="Direct link to üìã Validation Tests">‚Äã</a></h2><p>A validation test is where you have some data in one format and data in another format and you use those two different formats to ensure referential consistency. (Side note: There are many different kinds of tests, and I do a deep dive in <a href="https://authress.io/knowledge-base/academy/topics/user-impersonation-risks#solution-b-dom-recording">the different types of tests</a> and how they&#39;re relevant in building secure and reliable systems). One concrete example could be you have a request that comes in, you end up logging the request data and the response, then you can compare that logged data to what&#39;s actually saved in your database.</p><p>In our scenario, which focuses on the authorization and permissions enforcement checks, we have multiple databases with similar data. In one case, there&#39;s the storage of permissions as well as the storage of the expected checks and the audit trail tracking the creation of those permissions. So we actually have multiple opportunities to compare the data between our databases asynchronously outside of customer critical path usage.</p><h3 id="running-the-validation">Running the Validation<a href="#running-the-validation" aria-label="Direct link to Running the Validation" title="Direct link to Running the Validation">‚Äã</a></h3><p>On a schedule, via an AWS CloudWatch Scheduled Rule, we load the data from our different databases and we compare them against each other to make sure it is consistent. If there is a problem, then if this fires off an incident before any of our customers notice, so that we can actually go in and check what&#39;s going on.</p><p><img loading="lazy" alt="The architecture flow to trigger the validation tests" src="https://authress.io/knowledge-base/assets/images/validation-tests-798e04b9ad9c3f9ba86c40b645e162ed.png" width="899" height="638"/></p><p>This sounds bad on the surface that it could ever happen. But the reality of the situation is that a discrepancy can show up as a result of any number of mechanisms. For instance, the infrastructure from AWS could have corrupted one of the database shards and what is written to the databases is inconsistent. We know that this can happen as there is no 100% guarantee on database durability, even from AWS. <strong>AWS does not guarantee Database Durability</strong>, are you assuming they do, because we don&#39;t! So actually reading the data back and verifying its internal consistency is something that we must do.</p><p>While it might not seem that this could reduce the probability of there being an incident. Consider that a requested user permission check whose result doesn&#39;t match our customer&#39;s expectation is an incident. It might not always be one that anyone identifies or even becomes aware of, but it nonetheless a problem, just like a publicly exposed S3 is technically an issue, even if no one has exfiltrated the data yet, it doesn&#39;t mean the bucket isn&#39;is sufficiently secured.</p><h2 id="-incident-impact">üéØ Incident Impact<a href="#-incident-impact" aria-label="Direct link to üéØ Incident Impact" title="Direct link to üéØ Incident Impact">‚Äã</a></h2><p>There are two parts to the actual risk of an incident. The probability and the impact. Everything in this article I&#39;ve discuss until now talks about reducing the probability of an incident, that is ‚Äî the likelihood of it happening. But since we know that we can&#39;t avoid ever having an incident, we also have to reduce the impact when it happens.</p><p>One way we do that is by utilizing an <strong>incremental rollout</strong>. Hopefully everyone knows what incremental rollout is, so I&#39;ll instead jump straight into how we accomplish it utilizing AWS. And for that we focus again on our solution integrating with CloudFront and our edge architecture.</p><p>The solution for us is what I call <strong>Customer Deployment Buckets</strong>. We bucket individual customers into separate buckets and then deploy to each of the buckets sequentially. If the deployment rolls out without a problem, and it&#39;s all green, that is everything works correctly, then we go on to the second bucket and then deploy our code to there, and then the third bucket, and so on and so forth until every single customer has the new version.</p><p><img loading="lazy" alt="Rolling out to customer buckets one at a time" src="https://authress.io/knowledge-base/assets/images/bucket-roll-out-39ed3214efbaaf15ad96e8e1ca84df26.gif" width="1393" height="605"/></p><p>If there is an issue, we stop the rollout and we go and investigate what&#39;s actually going on. While we can&#39;t prevent the issue from happening to the earlier buckets, we are able to stop that issue from propagating to more customers, having an impact on everyone, and thus reduce the impact of the incident.</p><p>As I mentioned before the biggest recurring issue isn&#39;t executing an operations process during an incident, it&#39;s identifying there is a real incident in the first place. So, <strong>How do we actually know that there&#39;s an issue?</strong></p><p>If it was an easy problem to solve, you would have written a unit task or <a href="https://authress.io/knowledge-base/academy/topics/user-impersonation-risks#solution-b-dom-recording">integration test or service level test</a> and thus already discovered it, right? So adding tests can&#39;t, by design, help us. Maybe there&#39;s an issue with the deployment itself or during infrastructure creation, but likely that&#39;s not what&#39;s happening.</p><p>Now, I know you&#39;re thinking, <em><strong>When is he going to get to AI?</strong></em></p><p>Whether or not we&#39;ll ever truly have AI is a separate <code>&lt;rant /&gt;</code> that I won&#39;t get into here, so this is the only section on it, I promise. What we actually do is better called <strong>anomaly detection.</strong> Historically anomaly detection, was what AI always meant, true AI, rather than an LLM or agent in any way.</p><h2 id="-ai-anomaly-detection">üîé AI: Anomaly Detection<a href="#-ai-anomaly-detection" aria-label="Direct link to üîé AI: Anomaly Detection" title="Direct link to üîé AI: Anomaly Detection">‚Äã</a></h2><p>This is a graph of our detection analysis:</p><p><img loading="lazy" alt="namely detection graph" src="https://authress.io/knowledge-base/assets/images/anomaly-detection-bd49cd74a6c145c9470df317dd14f87c.png" width="2397" height="1289"/></p><p>You might notice that it&#39;s not tracking 400s or 500s, which are in reality relatively easy to detect. But in fact don&#39;t actually tell us meaningfully what&#39;s wrong with our service or whether or not there really is a problem. Impact is measured by business value, not technical protocol level analytics, so we need to have a business-focused metric.</p><p>And for us, at Authress, the business-focussed metric we use to identify meaningful incidents we call: <strong>The Authorization Ratio</strong>. That is the ratio of successful logins and authorizations to ones that are blocked, rejected, timeout or are never completed for some reason.</p><p>The above CloudWatch metric display contains this exact ratio, and here in this timeframe represents an instance not too long ago where we got really close to firing off our alert.</p><p><img loading="lazy" alt="Anomaly Detection allowance bands" src="https://authress.io/knowledge-base/assets/images/anomaly-detection-reveal-47ec9d2e0f410a6e8b4f12bc771c7fe4.png" width="2393" height="1283"/></p><p>Here, there was a slight elevation of errors soon after a deployment. The expected ratio was outside of our allowance span for a short period of time. However not long enough to trigger an incident. We still investigated, but it wasn&#39;t something that required immediate remediation. And it&#39;s a good reminder that identifying problems in any production software isn&#39;t so straightforward. To achieve high reliability, we&#39;ve needed an AI or in this case anomaly detection to actually identify additional problems. And realistically, even with this level of sophistication in place, we still can never know with 100% certainty that there is actually an incident at any moment. And that&#39;s because &#34;what is an incident&#34;, is actually a philosophical question...</p><h2 id="-does-it-smell-like-an-incident">üåπ Does it smell like an incident?<a href="#-does-it-smell-like-an-incident" aria-label="Direct link to üåπ Does it smell like an incident?" title="Direct link to üåπ Does it smell like an incident?">‚Äã</a></h2><p>Our anomaly detection said ‚Äì almost an incident, and we determined the result ‚Äì no incident. But does that mean there wasn&#39;t an incident? What makes an incident, how do I define an incident? And is that exact definition ubiquitous, for every system, every engineer, every customer?</p><p>Obviously not, and one look at the <a href="https://health.console.aws.amazon.com/health/home" target="_blank" rel="noopener noreferrer">AWS Health Status Dashboard</a> is all you need to determine that the identification of incidents is based on subjective perspective, rather than objective criteria. What&#39;s actually more important is the synthesis of our perspective on the situation and what our customers believe. To see what I mean, let&#39;s do a comparison:</p><p><img loading="lazy" alt="incident perspective comparison" src="https://authress.io/knowledge-base/assets/images/perspective-comparison-200862c120ae03c4498bb7a36cff5b0b.png" width="1325" height="854"/></p><p>I&#39;m going to use Authress as an example. So I&#39;ve got the product services perspective on one side and our customer&#39;s perspective on the other.</p><h3 id="incident-alignment">Incident Alignment<a href="#incident-alignment" aria-label="Direct link to Incident Alignment" title="Direct link to Incident Alignment">‚Äã</a></h3><p>In the top left corner we have alignment. If we believe that our system is up and working and our customers do, too, then success, all good. Everything&#39;s working as expected.</p><p><img loading="lazy" alt="incident perspective comparison alignment" src="https://authress.io/knowledge-base/assets/images/perspective-comparison-good-4ec1a8786538f8395523e06d741d1e49.png" width="1084" height="698"/></p><p>Inversely in the opposite corner, maybe there is a problem. We believe that one of our services is having an issue, and successfully, we&#39;re able to identify it. Most importantly, our customers say‚Äìyes, there is an issue for us.</p><p>It&#39;s not great that there&#39;s an incident, but as I&#39;ve identified incidents will absolutely happen, and the fact we&#39;ve correctly aligned with our customers on the problem&#39;s existence independently allows us to deploy automation to automatically remediate the issue. That&#39;s a success! If it&#39;s a new problem that we haven&#39;t seen before, we can even design new automation to fix this. Correctly identifying incidents is challenging, so doing that step correctly, leads itself very well to automation for remediation.</p><h3 id="perspective-mismatch">Perspective Mismatch<a href="#perspective-mismatch" aria-label="Direct link to Perspective Mismatch" title="Direct link to Perspective Mismatch">‚Äã</a></h3><p>One interesting corner is when our customers believe that there&#39;s nothing wrong, there have been no incidents reported, but all our alerts are saying ‚Äì <em>RED ALERT</em> ‚Äî someone has to go look at this!</p><p><img loading="lazy" alt="incident perspective mismatch" src="https://authress.io/knowledge-base/assets/images/perspective-comparison-mismatch-05c9e8f5abb0ca87192d36bf4ace33b2.png" width="1324" height="853"/></p><p>In this case, our alerts have identified a problem that no one cares about. This often happens in scenarios where our customers are in one region, Switzerland for example, with local region users, a health care, manufacturing, or e-commerce app, is a good example, rather than global, who are likely asleep at 2:00 AM. And that means an incident at the moment, could be an issue affecting some customers. But if they aren&#39;t around to experience it, is it actually happening?</p><p>You are probably wincing at that idea. There&#39;s a bug, it must be fixed! And sure that&#39;s a problem, it&#39;s happening and we should take note of what&#39;s going on. But we don&#39;t need to respond in real time. That&#39;s a waste of our resources where we could be investing in other things. Why wake up our engineers based on functionality that no one is using?</p><p>I think one of the most interesting categories is in the top right-hand corner where:</p><ul><li>our customers say, <em>&#34;hey, your service is down&#34;</em></li><li>But we say, &#34;Wait, really, is it?&#34;_</li></ul><p>This is known as a <strong>gray failure</strong>.</p><h3 id="gray-failures">Gray Failures<a href="#gray-failures" aria-label="Direct link to Gray Failures" title="Direct link to Gray Failures">‚Äã</a></h3><p><img loading="lazy" alt="Gray failures identified" src="https://authress.io/knowledge-base/assets/images/perspective-comparison-gray-1270ef7b4fe8e4235852527688a4e059.png" width="1082" height="695"/></p><p>And it can happen for any number of reasons. Maybe there is something in our knowledge base that tells our customers to do something one way and it&#39;s confusing and they&#39;ve interpreted it in a different way. So there&#39;s a different expectation here. That expectation can get codified into customer processes and product services.</p><p>Or maybe our customer is running different tests from us, ones that are of course, valuable for their business, but not ones that we consider. Or more likely they are just using a less resilient cloud provider.</p><p>Most fundamentally, there could really be an incident, something that we haven&#39;t detected yet, but they have. And if we don&#39;t respond to that, it could grow, and left unchecked, escalate, and eventually impact all our customers. This means we need to give our customers an easy way to report incidents to us, which we can immediately follow up with.</p><p>For us, every single incident, every single customer support ticket that comes into our platform, we immediately and directly send it to our engineering team. Now, I often get pushback on this from other leaders. I&#39;m sure, even you might be thinking something like ‚Äî <em>I don&#39;t want to be on call for customer support incidents.</em> But if you throw additional tiers in your organization between your engineering teams and your customers, that means you&#39;re increasing the time to actually start investigating and resolving those problems. If you have two tiers before your engineering team and each tier has its own SLA of 10 minutes to triage the issue, that means you&#39;ve already gone through 20 minutes before an engineer even knows about it and can go and look at it. That violates our SLA by fourfold before investigation and remediation can even begin.</p><p>Instead, in those scenarios, what I actually recommend thinking about is how might you reduce the number of support tickets you receive in aggregate? This is the much more appropriate way to look at the problem. If you are getting support tickets that don&#39;t make sense, then you&#39;ve got to investigate, <em>why did we get this ticket?</em> Do the root cause analysis on the ticket, not just the issue mentioned in it ‚Äî why the ticket was even created in the first place.</p><p>A ticket means: Something is broken. From there, we can figure out, OK, maybe we need to improve our documentation. Or we need to change what we&#39;re doing on one of our endpoints. Or we need to change the response error message we&#39;re sending. But you can always go deeper.</p><h3 id="the-customer-support-advantage">The customer support advantage<a href="#the-customer-support-advantage" aria-label="Direct link to The customer support advantage" title="Direct link to The customer support advantage">‚Äã</a></h3><p>And going deeper, means  customer support is critical for us. We consider customer support to be the lifeline of our service level agreement (SLA). If we didn&#39;t have that advantage, then we might not have been able to deliver our commitment at all. So much so that we report some of our own CloudWatch custom metrics to our customers so they can have an aggregate view of both what they know internally and what we believe. We do this through our own internal dashboard in our application management UIs.</p><p><img loading="lazy" alt="Authress metric dashboard" src="https://authress.io/knowledge-base/assets/images/authress-dashboard-3ccee084978cd39a3efb082eab304689.png" width="2103" height="1407"/></p><p><strong>Helping our users identify incidents benefits us; because we can&#39;t catch everything. It&#39;s just not possible.</strong></p><h2 id="-negligence-and-malice">üíÄ Negligence and Malice<a href="#-negligence-and-malice" aria-label="Direct link to üíÄ Negligence and Malice" title="Direct link to üíÄ Negligence and Malice">‚Äã</a></h2><p>To this point, we&#39;ve done the math on reliability of third-party components. We&#39;ve implemented an automatic region failover and added incremental rollout. And we have a core customer support focus. Is that sufficient to achieve 5-nines of reliability?</p><p>If you think yes, then you&#39;d expect the meme pictures now. And, I wish I could say it was enough, but it&#39;s not. That&#39;s because we also have to deal with negligence and malice.</p><p>We&#39;re in a privileged position to have numerous security researchers out there on the internet constantly trying to find vulnerabilities within our service. For transparency, I have some of those reports I want to share:</p><h3 id="real-vulnerability-reports">‚ÄúReal‚Äù Vulnerability Reports<a href="#real-vulnerability-reports" aria-label="Direct link to ‚ÄúReal‚Äù Vulnerability Reports" title="Direct link to ‚ÄúReal‚Äù Vulnerability Reports">‚Äã</a></h3><p><img loading="lazy" alt="fake vulnerability disclosure" src="https://authress.io/knowledge-base/assets/images/vulnerability-disclosure-1-27dc85ac57155d84fb110a716533bf96.png" width="2473" height="1219"/></p><blockquote><p>I am a web security researcher enthusiast. Do you give a monetary reward?</p></blockquote><p>Okay, this isn&#39;t starting out that great. What else have we received?</p><p><img loading="lazy" alt="appeal to ethical hacking rewards" src="https://authress.io/knowledge-base/assets/images/vulnerability-disclosure-2-c1ea2887c9c81e5d076d8a2c24cc6ed0.png" width="2472" height="1080"/></p><blockquote><p>I found some vulnerabilities in your website. Do you offer rewards for ethical hackers?</p></blockquote><p>Well, maybe, but I think you would actually need to answer for us, what the problem actually is. And you also might notice this went to our spam. It didn&#39;t even get to our inbox. So a lot of help they might be providing. Actually we ignore any <em>‚Äùsecurity‚Äù</em> email sent from a non-custom domain.</p><p><img loading="lazy" alt="Phishing attempt using our own credentials" src="https://authress.io/knowledge-base/assets/images/vulnerability-disclosure-3-809289836ba4c4b9e8a70b6fe091a21c.png" width="1801" height="1265"/></p><p>This one was really interesting. We had someone attempting to phish our engineering team by creating a support ticket and putting in some configuration trying to get us to provide them our own credentials to one of our third-party dependencies. Interestingly enough, our teams don&#39;t even have access to those credentials directly.</p><p>And, we know this was malicious because the credentials that they are referencing in the support request are from our honey pot, stuck in our UI to explicitly catch these sorts of things. The only way to get these credentials is if they hacked around our UI application and pulled out of the HTML. They aren&#39;t readily available any other way. So it was very easy for us to detect that this ‚Äúreport‚Äù was actually a social engineering attack.</p><p>And this is one of my favorites, and I can&#39;t make this up:</p><p><img loading="lazy" alt="Bugbounty vulnerability reporting" src="https://authress.io/knowledge-base/assets/images/vulnerability-disclosure-4-75fd0339199af159cacce860f1216779.png" width="2463" height="1215"/></p><blockquote><p>I have found many security loophole. How much will you pay if you want to working with me like project?</p></blockquote><p>That&#39;s the exact quote, I don&#39;t even know what that means. Unfortunately, LLMs will actually start to make all of these future &#34;vulnerability reports&#34; sound more appealing to read in the future, for better or worse. However, at the end of the day, the truth is that these are harmless. And we actually do have a <a href="https://authress.io/app/#/disclosure" target="_blank" rel="noopener noreferrer">security disclosure program</a> that anyone can go and submit problems for. I hope the message to white-hat hackers is please use that process, and the legitimate reports usually do go through it. Do not send us emails. Those are going to go into the abyss. Alternatively, you can follow our <a href="https://authress.io/.well-known/security.txt" target="_blank" rel="noopener noreferrer">security.txt</a> public page or go to the disclosure form, but with email, the wrong people are going to get that and we can&#39;t triage effectively.</p><p>Vulnerabilities in our services can result in production incidents for our customers. That means security is part of our SLA. Don&#39;t believe me, I&#39;ll show you how:</p><h3 id="multitenant-considerations">Multitenant considerations<a href="#multitenant-considerations" aria-label="Direct link to Multitenant considerations" title="Direct link to Multitenant considerations">‚Äã</a></h3><p>It&#39;s relevant for us, that Authress is a multitenant solution. So some of the resources within our service are in fact shared between customers.</p><p>Additionally, customers could have multiple services in a microservice architecture or multiple components. And one of these services could theoretically consume all of the resources that we&#39;ve allocated for that customer. In that scenario, that would cause an incident for that customer. So we need to protect against resource exhaustion <strong>Intra-Tenant</strong>. Likewise, we have multiple customers. One of those customers could be consuming more resources than we&#39;ve allocated to the entire tenant. And that could cause an incident across <strong>Inter-Tenant</strong> and cause an incident across our platform and impact other customers.</p><p>Lastly, we have to be worried about our customers, our customers&#39; customers, and our customers&#39; customers&#39; customers, because any one of those could be malicious and consume their resources and so on and so forth, thus causing a cascading failure. <strong>A failure due to lack of resources is an incident</strong>. The only solution that makes sense for this is, surprise, rate limiting.</p><h3 id="helpful-rate-limiting">Helpful Rate Limiting<a href="#helpful-rate-limiting" aria-label="Direct link to Helpful Rate Limiting" title="Direct link to Helpful Rate Limiting">‚Äã</a></h3><p>So we need to rate-limit these requests at different levels for different kinds of clients, different kinds of users, and we do that within our architecture, at different fundamental levels within our infrastructure.</p><p><img loading="lazy" alt="CloudFront and Region based rate limiting locations" src="https://authress.io/knowledge-base/assets/images/waf-architecture-9a4c494204c064580d7fa65b67b0e053.png" width="1790" height="1141"/></p><p>Primarily there are protections at our compute level, as well at the region level, and also place protections at a global level. In AWS, this of course means using a <a href="https://aws.amazon.com/waf/" target="_blank" rel="noopener noreferrer">web application firewall or WAF</a>. I think our WAF configuration is interesting and in some ways novel.</p><p>Fundamentally, one of the things that we love to use is the <a href="https://docs.aws.amazon.com/waf/latest/developerguide/aws-managed-rule-groups-ip-rep.html#aws-managed-rule-groups-ip-rep-amazon" target="_blank" rel="noopener noreferrer">AWS managed IP reputation list</a>.</p><p>The reputation list is list of IP addresses that have been associated with malicious activity outside of our service throughout other customers at AWS and other providers out there in the world where a problem has been detected. That means before those attacks even get to our service or to our customers&#39; instances of Authress, we can already know to block them, and the WAF does that. This is great, and most importantly, has a very low false positive rate.</p><p>However, the false positive rate is an important metric for consideration of counter measures against malicious attacks or negligent accidental abuse of resources, and something that prevents us from using any other managed rules from AWS or external providers. There&#39;s two problems with managed rules, fundamentally:</p><ol><li>Number one is the false positive rate. If that is even a little bit more than, it couldn&#39;t be sustainable, and would result in us blocking legitimate requests coming for a customer. This means it is a problem, and it&#39;s an incident for them if some of their users can&#39;t utilize their software because of something we did. False positives are customer incidents.</li><li>The second one is that managed rules are gratuitously expensive. Lots of companies are building these just to charge you lots of money, and the ROI just doesn&#39;t seem to be there. We don&#39;t see useful blocks from them.</li></ol><p>But the truth is, we need to do something more than just the reputation list rule.</p><h3 id="handling-requests-at-scale">Handling Requests at Scale<a href="#handling-requests-at-scale" aria-label="Direct link to Handling Requests at Scale" title="Direct link to Handling Requests at Scale">‚Äã</a></h3><p>And the thing that we&#39;ve decided to do is ‚Äî add blocking for sufficiently high requests. By default, any Authress account&#39;s service client that goes above 2,000 requests per second (RPS), we just immediately terminate. Now, this isn&#39;t every customer, as there are some out there for us that do require such a high load or even higher (as 2k isn&#39;t that high). But for the majority of them, if you get to this number and they haven&#39;t talked to us about their volume, then it is probably malicious in some way. You don&#39;t magically go from zero to 2,000 one day, unless it is an import job.</p><p>Likewise, we can actually learn about a problem long before it gets to that scale. We have milestones, and we start reporting loads from clients at 100, 200, 500, 1,000, et cetera. If we see clients hitting these load milestones, we can already start to respond and create an incident for us to investigate before they reach a point where they&#39;re consuming all of the resources in our services for that customer. And we do this by adding alerts on the COUNT of requests for WAF metrics.</p><p>However, we also get attacks at a smaller scale. Just because we aren&#39;t being DDoS-ed doesn&#39;t mean there isn&#39;t attack. And those requests will still get through because they don&#39;t meet our blocking limits. They could be malicious in nature, but only identifiable in aggregate. So while single request might seem fine, if you see the same request 10 times a second, 100 times a second, something is probably wrong. Or if you have request urls that end in <code>.php?admin</code>, when no one has run WordPress in decades, you also know that there&#39;s a problem. We catch these by logging all of the blocked requests.</p><p>We have automation in place to query those results and update our rules, but a picture is worth a thousand words:</p><p><img loading="lazy" alt="WAF COUNT metrics display" src="https://authress.io/knowledge-base/assets/images/waf-counts-display-1185348606e0db3f23326dd1f0bb3570.png" width="2185" height="1108"/></p><p>Here you can see a query based off of the IP addresses from the client that are being utilized and sorted by frequency. When we get these requests that look non-malicious individually, we execute a query such as this one and we check to see if the results match a pattern. You can use ip address matching or more intelligently, something called the JA3 or JA4 fingerprints of those requests There are actually lots of options available, I&#39;m not going to get into exactly what they are, there are some <a href="https://ramimac.me/waf-ddos" target="_blank" rel="noopener noreferrer">great articles on the topic</a>. And there are more mechanisms to actually track these used throughout the security industry, and utilizing them let&#39;s you instantly identify: <em>Hey, you know what? This request violates one of our patterns, maybe we should block all the requests from that client.</em></p><p>And so, rather than waiting for them to get to the point where an attacker is consuming 2,000 requests per second worth of resources, you can stop there right away. In the cases where we can&#39;t make a conclusive decision, this technology gives us another tool that we can utilize to improve our patterns for the future. Maybe it goes without saying, but of course because we&#39;ve running our technology to many regions around the world, we have to work on deploying this infrastructure in all these places and push it out to the edge where possible.</p><p><img loading="lazy" alt="Authress AWS Regional and Global locations" src="https://authress.io/knowledge-base/assets/images/authress-global-locations-03495d352c7ee9fe140f8e7f03a30241.png" width="2112" height="1285"/></p><h2 id="-the-conclusion">üéÅ The Conclusion<a href="#-the-conclusion" aria-label="Direct link to üéÅ The Conclusion" title="Direct link to üéÅ The Conclusion">‚Äã</a></h2><p>I said a lot of things, so I to quickly want to quickly summarize our architecture that we have in place:</p><ol><li><strong>Third-party component reliability reviews</strong>. I can&#39;t stress this enough. Don&#39;t just assume that you can utilize something. And sometimes in order to achieve 5-nines, you actually have to remove components from your infrastructure. Some things are just not able to be utilized no matter what. Now maybe you can put it in some sort of async background, but it can&#39;t be on the critical path for your endpoints.</li><li><strong>DNS failover and health checks.</strong> For places where you have an individual region or availability zone or cluster, having a full backup with a way to conclusively determine what&#39;s up and automatically failover is critical.</li><li><strong>Edge compute where possible</strong>. There&#39;s a whole network out there of services that are running on top of the cloud providers, which help guarantee your capability to run as close to as possible to where your users are and reduce latency.</li><li><strong>Incremental rollout</strong> for when you want to reduce the impact as much as possible.</li><li>The <strong>Web Application Firewall</strong> for handling those malicious requests.</li><li>Having a <strong>Customer Support Focus</strong> to enable escalating issues that outside your area of detection.</li></ol><p>And through seven years or so that we&#39;ve been doing this and building up this architecture, there&#39;s a couple of things that we&#39;ve learned:</p><p><img loading="lazy" alt="Unsolvable Problems at scale" src="https://authress.io/knowledge-base/assets/images/lessions-learned-b848a223205afe1959cce537c04d5465.png" width="1356" height="695"/></p><h3 id="murphys-law">Murphy&#39;s Law<a href="#murphys-law" aria-label="Direct link to Murphy&#39;s Law" title="Direct link to Murphy&#39;s Law">‚Äã</a></h3><p>Everything fails all the time. There absolutely will be failures everywhere. Every line of code, every component you pull in, every library, there&#39;s guaranteed to be a problem in each and everyone of those. And you will for sure have to deal with it, at some point. So being prepared to handle that situation, is something you have to be thinking through in your design.</p><h3 id="dns">DNS<a href="#dns" aria-label="Direct link to DNS" title="Direct link to DNS">‚Äã</a></h3><p>DNS, yeah, AWS will say it, everyone out there will say, and now we get to say it. The global DNS architecture is pretty good and reliable for a lot of scenarios, but I worry that it&#39;s still a single point of failure in a lot of ways.</p><h3 id="infrastructure-as-code-iac">Infrastructure as Code (IAC)<a href="#infrastructure-as-code-iac" aria-label="Direct link to Infrastructure as Code (IAC)" title="Direct link to Infrastructure as Code (IAC)">‚Äã</a></h3><p>The last thing is infrastructure as code challenges. We deploy primary regions, but then there&#39;s also the backup regions, which are slightly different from the primary regions, and then there are edge compute, which are, again, even more slightly different. And then sometimes, we do this ridiculous thing, where we deploy infrastructure dedicated to one customers. And in doing so, we&#39;re running some sort of IaC to deploy those resources.</p><p>It is almost exactly the same architecture. Almost! Because it isn&#39;t exactly the same there are quite the opportunities for challenges to sneak it. That&#39;s problematic with even Open Tofu or CloudFormation, and often these tools make it more difficult, not less. And good luck to you, if you&#39;re still using some else that hasn&#39;t been modernized. With those, it&#39;s even easier to run into problems and not get it exactly correct.</p><p>The last thing I want to leave you with is, well, <strong>With all of these, is that actually sufficient to achieve five nines?</strong></p><p>No. Our commitment is 5-nines, what we do is in defense of that, just because you do all these things doesn&#39;t automatically mean your promise of 5-nines in guaranteed. And you know what, you too can promise a 5-nines SLA without doing anything. You&#39;ll likely break your promise, but for us our promise is important, and so this is our defense.</p><div><p><span><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg></span>info</p><p>For help understanding this article or how you can implement auth and similar security architectures in your services, feel free to reach out to me via the <a href="https://authress.io/community" target="_blank" rel="noopener noreferrer">community server</a>.</p></div></div></div>
  </body>
</html>
