<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/fan-service">Original</a>
    <h1>Fan Service</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>ASUS laptops generally have a feature that lets the user toggle the fan speed. Fn-F5 on some models, Fn-F on others. The direct effect is to limit the fan speed, from whisper mode to megablast, and indirectly control performance. But it doesn’t work in OpenBSD, so I needed to write an ASUS ACPI WMI driver.</p><h3 id="acpi">acpi</h3><p>ACPI is a hardware abstraction layer that lets the computer tell the operating system how to do things. It provides functions in byte code which the OS interprets to perform certain tasks. So instead of having to write a driver for every CPU, you call the ACPI method _PSS and that tells you what to do.</p><p>Of course, vendors want to include functionality that isn’t defined in the standard, so they add some extra methods, and then you end up writing some custom drivers anyway, for the little buttons that turn the microphone on and off, etc. OpenBSD (and other OSs) have lots of little drivers for ThinkPads and whatnot.</p><p>ACPI method names are only four letters long, so what do we do if two vendors include a method called WMNB and how do we determine what it does? (Technically, the ACPI nodes are identified by seven letter names, and the methods live under them, so it’s not really a problem, but somebody got paid to make a solution anyway.)</p><h3 id="wmi">wmi</h3><p>The solution is an extension to ACPI called WMI, which stands for Windows Multiplies Irritations or something. You ask ACPI for a buffer called _WDG, and this contains a table mapping GUIDs (globally unique, says so right there in the name) to local method names. Looking through this table, we come across <span>DCBA-FE-10-23-456789</span>, which we recognize as a GUID of interest, and this tells us the method to call is WMNB, but now we know it’s the right one.</p><p>OpenBSD does not have a WMI driver, which is part of what I need to set the fan profile. There is a WMI driver in Linux, and it includes an ASUS support driver for a variety of functions I’m interested in.</p><h3 id="first-steps">first steps</h3><p>First, I wrote a little acpi driver that attaches to PNP0C14. Read the _WDG buffer and print out all the GUIDs. Didn’t recognize any of the values, then realized I got the byte order wrong. Fixed that, saw something very close, realized I still didn’t get the byte order quite right. GUIDs are not big endian, they are not little endian, they are Goldilocks endian.</p><p>With that sorted out, I was able to enable events and get a printf every time I pushed a hotkey.</p><h3 id="events">events</h3><p>After receiving an interrupt and landing in our callback, we need to identify which event just happened by calling _WED. I did this, but was only getting 1 in response every time, regardless of key. I was a little stuck here. Very close to getting what I wanted, but without much clue as to what went wrong.</p><p>Turns out you can just look at your system’s ACPI code. OpenBSD runs <i>acpidump</i> at boot and saves all the files. Copy them to a work directory, run <i>iasl -d</i>, and have a look. A quick grep for _WED reveals the source.</p><pre><code>            Method (_WED, 1, NotSerialized)
            {   
                If ((Arg0 == 0xFF))
                {
                    Return (GANQ ())
                }
     
                Return (One)
            }
            Method (GANQ, 0, Serialized)
            {
                P8XH (Zero, 0xF2)
                If (AQNO)
                {
                    AQNO--
                    Local0 = DerefOf (ATKQ [AQHI])
                    AQHI++ 
                    AQHI &amp;= 0x0F
                    Return (Local0)
                }

                Return (Ones)
            }</code></pre><p>Even without knowing anything at all about ASL, this looks like a function that dequeues an event, but only if called with an argument of 255. That was the bug! Once I called it with the correct argument, I started receiving different event codes for backlight toggle, fan toggle, AC attach, etc.</p><h3 id="devices">devices</h3><p>Wrote some more code to handle getting and setting device state. There’s a magic incantation to call an ACPI method and pass it a device id, which could be the keyboard backlight, or the wifi led, or the fan profile, etc. Started with the keyboard backlight, since this was pretty easy to observe.</p><p>After fixing a few simple bugs like reversing the device ids for fnlock and backlight, I was able to blink the keyboard light by pressing F7. It’s all coming together.</p><p>Toggling the fan profile didn’t seem to accomplish anything, though. Under Windows, there is an audible difference switching to whisper mode, but I didn’t observe any change.</p><p>The Linux driver includes code for at least three different fan and performance profile settings. The same driver is used for a wide range of laptops, from thin and lights to gaming fraggers. According to the Linux driver, you can detect which devices are present by reading their state, then checking for a high bit, and then getting the value by masking off some low bits. This seemed to indicate I had a fan boost device, but it wasn’t responding to my changes.</p><p>After printing out the raw values, I noticed they were all -2. That doesn’t seem very likely. But it definitely has a high bit set, and masking off the low bits made it look reasonable. I think I missed something in the Linux driver? There’s lots of shifts and masks in lots of places.</p><p>Back to the ACPI dump, the WMNB method is a giant switch statement that ends with  Return (0xFFFFFFFE). So sure enough, there’s the -2 for a missing device, but I still don’t know which device id I should be using.</p><p>Back to the Linux driver, there’s an epic norse define for  <span>ASUS_WMI_DEVID_THROTTLE_THERMAL_POLICY_VIVO</span> which I hadn’t yet integrated because I was testing on a Zenbook, not a Vivobook. Added a check anyway, rebooted, and that’s a bingo! The Linux define name is a lie. Confirmed by inspecting the ASL code.</p><pre><code>            If ((IIA0 == 0x00110019))
            {
                Return (FANL (IIA1))
            }</code></pre><p>Now I had all the pieces. After a bit of cleanup and refactoring, my driver is complete. Kinda. There’s still a bunch of sensors that would be interesting to read, but my immediate concern has been addressed.</p><h3 id="results">results</h3><p>Pressing Fn-F after boot drops the fan speed noticeably, from a medium whir to barely a whisper. This has only a moderate effect on ordinary performance. The processor’s power budget is reduced, but not its (single core) clock speeds, so everything still runs smoothly. Lengthy compiles are slower, but I can also switch back to megablast turbo mode with the tap of a button.</p><p>Battery life is also much better. The fan itself is obviously eating less power. I think the CPU also enters a somewhat lower power state in whisper mode, or it’s willing to sleep a little deeper. It’s not clear everything that changes, and it varies by machine, but that’s the beauty of it. I wrote the driver on an AMD Zenbook, but it works without changes on an Intel Vivobook. Very convenient.</p><h3 id="misc">misc</h3><p>I also looked at the FreeBSD driver. FreeBSD directly uses the <span>ACPICA</span> code interfaces, calling function like <code>AcpiEvaluateObject</code> which personally look kinda out of place in BSD driver code. Linux does too, but all the functions have been renamed to <code>acpi_evaluate_object</code>, so they resemble the local style. I’m not entirely sure of the history here, but I think the generic <span>ACPICA</span> was at some pointer extracted and generified from the Linux code. OpenBSD uses a custom AML interpreter, so we have functions like <code>aml_evalname</code>.</p><p>In OpenBSD, nearly all header files are kept with their C files. So both dsdt.c and dsdt.h live in dev/acpi. (Notable exception is core C files in kern and headers in sys.) As a first time acpi driver writer, it was very convenient that all the OpenBSD code I needed to reference, from sample drivers to data structures to helper functions, was all in one spot.</p><p>Linux separates things such that I was looking at C files in drivers/platform/x86 and header files in include/linux/platform_data/x86. And the ACPI code lives other places as well. It’s all very orderly, but at times it felt like navigating a grocery store that arranges products in alphabetical order. Logical, but not exactly cozy.
</p></div></div>
  </body>
</html>
