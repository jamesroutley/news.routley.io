<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakearchibald.com/2024/garbage-collection-and-closures/">Original</a>
    <h1>JavaScript garbage collection and closures</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p><time datetime="2024-07-30">Posted 30 July 2024 </time></p><div><p>Me, <a href="https://twitter.com/DasSurma">Surma</a>, and <a href="https://twitter.com/_developit">Jason</a> were hacking on a thing, and discovered that garbage collection within a function doesn&#39;t quite work like we expected.</p>
<div><pre><code><span>function</span> <span>demo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> bigArrayBuffer <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span><span>100_000_000</span><span>)</span><span>;</span>
  <span>const</span> id <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>bigArrayBuffer<span>.</span>byteLength<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearTimeout</span><span>(</span>id<span>)</span><span>;</span>
<span>}</span>

globalThis<span>.</span>cancelDemo <span>=</span> <span>demo</span><span>(</span><span>)</span><span>;</span></code></pre></div><p>With the above, <code>bigArrayBuffer</code> is leaked forever. I didn&#39;t expect that, because:</p>
<ul>
<li>After a second, the function referencing <code>bigArrayBuffer</code> is no longer callable.</li>
<li>The returned cancel function doesn&#39;t reference <code>bigArrayBuffer</code>.</li>
</ul>
<p>But that doesn&#39;t matter. Here&#39;s why:</p>
<h2 id="javascript-engines-are-reasonably-smart"><a href="#javascript-engines-are-reasonably-smart">JavaScript engines are reasonably smart</a></h2>
<p>This doesn&#39;t leak:</p>
<div><pre><code><span>function</span> <span>demo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> bigArrayBuffer <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span><span>100_000_000</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>bigArrayBuffer<span>.</span>byteLength<span>)</span><span>;</span>
<span>}</span>

<span>demo</span><span>(</span><span>)</span><span>;</span></code></pre></div><p>The function executes, <code>bigArrayBuffer</code> is no longer needed, so it&#39;s garbage collected.</p>
<p>This also doesn&#39;t leak:</p>
<div><pre><code><span>function</span> <span>demo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> bigArrayBuffer <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span><span>100_000_000</span><span>)</span><span>;</span>

  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>bigArrayBuffer<span>.</span>byteLength<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
<span>}</span>

<span>demo</span><span>(</span><span>)</span><span>;</span></code></pre></div><p>In this case:</p>
<ol>
<li>The engine knows it needs to retain <code>bigArrayBuffer</code> beyond the initial execution of the function, so it&#39;s kept around. It&#39;s associated with the scope that was created when <code>demo()</code> was called.</li>
<li>After a second, the function referencing <code>bigArrayBuffer</code> is no longer callable.</li>
<li>Since nothing within the scope is callable, the scope is garbage collected, along with <code>bigArrayBuffer</code>.</li>
</ol>
<p>This also doesn&#39;t leak:</p>
<div><pre><code><span>function</span> <span>demo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> bigArrayBuffer <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span><span>100_000_000</span><span>)</span><span>;</span>

  <span>const</span> id <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>&#39;hello&#39;</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearTimeout</span><span>(</span>id<span>)</span><span>;</span>
<span>}</span>

globalThis<span>.</span>cancelDemo <span>=</span> <span>demo</span><span>(</span><span>)</span><span>;</span></code></pre></div><p>In this case, the engine knows it doesn&#39;t need to retain <code>bigArrayBuffer</code> beyond the initial execution of the function, as none of the future-callables access it.</p>
<h2 id="the-problem-case"><a href="#the-problem-case">The problem case</a></h2>
<p>Here&#39;s where it gets messy:</p>
<div><pre><code><span>function</span> <span>demo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> bigArrayBuffer <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span><span>100_000_000</span><span>)</span><span>;</span>

  <span>const</span> id <span>=</span> <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>bigArrayBuffer<span>.</span>byteLength<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearTimeout</span><span>(</span>id<span>)</span><span>;</span>
<span>}</span>

globalThis<span>.</span>cancelDemo <span>=</span> <span>demo</span><span>(</span><span>)</span><span>;</span></code></pre></div><p>This leaks, because:</p>
<ol>
<li>The engine knows it needs to retain <code>bigArrayBuffer</code> beyond the initial execution of the function, so it&#39;s kept around. It&#39;s associated with the scope that was created when <code>demo()</code> was called.</li>
<li>After a second, the function referencing <code>bigArrayBuffer</code> is no longer callable.</li>
<li>But, the scope remains, because the cleanup function within is still callable.</li>
<li><code>bigArrayBuffer</code> is associated with the scope, so it remains in memory.</li>
</ol>
<p>I thought engines would be smarter, and GC <code>bigArrayBuffer</code> since it&#39;s no longer referenceable, but that isn&#39;t the case.</p>
<div><pre><code>globalThis<span>.</span>cancelDemo <span>=</span> <span>null</span><span>;</span></code></pre></div><p><em>Now</em> <code>bigArrayBuffer</code> is GC&#39;d, since nothing within the scope is callable.</p>
<p>This isn&#39;t specific to timers, it&#39;s just how I encountered the issue. For example:</p>
<div><pre><code><span>function</span> <span>demo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> bigArrayBuffer <span>=</span> <span>new</span> <span>ArrayBuffer</span><span>(</span><span>100_000_000</span><span>)</span><span>;</span>

  globalThis<span>.</span><span>innerFunc1</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>bigArrayBuffer<span>.</span>byteLength<span>)</span><span>;</span>
  <span>}</span><span>;</span>

  globalThis<span>.</span><span>innerFunc2</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>&#39;hello&#39;</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span>

<span>demo</span><span>(</span><span>)</span><span>;</span>


globalThis<span>.</span>innerFunc1 <span>=</span> <span>undefined</span><span>;</span>


globalThis<span>.</span>innerFunc2 <span>=</span> <span>undefined</span><span>;</span>
</code></pre></div><p>TIL!</p>
</div><p><small><a href="https://github.com/jakearchibald/jakearchibald.com/blob/main/static-build/posts/2024/07/garbage-collection-and-closures/index.md">View this page on GitHub</a></small></p></div></div><div><section><figure></figure><p>Hello, I&#39;m Jake and that&#39;s me there. The one that isn&#39;t a cat. I&#39;m a developer of sorts.</p><p>Feel free to <a href="mailto:jaffathecake@gmail.com">throw me an email</a>, unless you&#39;re a recruiter, or someone trying to offer me &#39;sponsored content&#39; for this site, in which case write your request on a piece of paper, and fling it out the window.</p></section></div></div></div></div>
  </body>
</html>
