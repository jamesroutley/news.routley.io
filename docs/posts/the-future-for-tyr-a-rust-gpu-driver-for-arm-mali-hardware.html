<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/1055590/">Original</a>
    <h1>The Future for Tyr, a Rust GPU Driver for Arm Mali Hardware</h1>
    
    <div id="readability-page-1" class="page"><div>

<p>
The
<a href="https://gitlab.freedesktop.org/panfrost/linux/-/project_members">
team</a> behind
<a href="https://rust-for-linux.com/tyr-gpu-driver">
Tyr</a> started 2025 with little to show in our quest to
produce a Rust GPU driver for Arm Mali hardware, and by the end of the
year, we were able to play <a href="https://supertuxkart.net">SuperTuxKart</a> (a 3D open-source racing
game) at the Linux Plumbers Conference (LPC). Our prototype was a joint
effort between Arm, Collabora, and Google; it ran well for the duration
of the event, and the performance was more than adequate for players.
Thankfully, we picked up steam at precisely the right moment: Dave
Airlie just
<a href="https://lwn.net/Articles/1050174/">
announced</a> in the Maintainers Summit that the DRM subsystem
is only &#34;<q>about a year away</q>&#34; from disallowing new drivers written in C
and requiring the use of Rust. Now it is time to lay out a
possible roadmap for 2026 in order to upstream all of this work.
</p>

<h4 id="eyes-on-the-prize">What are we trying to accomplish with Tyr?</h4>
<p>
Miguel Ojeda&#39;s
<a href="https://lpc.events/event/19/contributions/2068/">
talk at LPC</a> this year summarized where Rust is being used in the Linux
kernel, with drivers like the <a href="https://rust-for-linux.com/android-%60ashmem%60">anonymous shared memory
subsystem for Android</a> (ashmem)
quickly being rolled out to millions of users. Given Mali&#39;s extensive market
share in the phone market, supporting this segment is a natural aspiration for Tyr,
followed by other embedded platforms where Mali is also present. In
parallel, we must not lose track of upstream, as the objective is to
evolve together with the <a href="https://rust-for-linux.com/nova-gpu-driver">Nova</a> Rust GPU driver and ensure
that the ecosystem will be useful for any new drivers that might come in
the future. The prototype was meant to prove that a Rust driver for Arm
Mali could come to fruition with acceptable performance, but now we
should iterate on the code and refactor it as needed.
This will allow us to learn from our mistakes and settle on a design
that is appropriate for an upstream driver.
</p>

<h4 id="what-is-there-and-what-is-not">What is there, and what is
not</h4>
<p>
A version of the Tyr driver was
<a href="https://lwn.net/ml/rust-for-linux/20250910-tyr-v3-1-dba3bc2ae623@collabora.com/">
merged for the 6.18 kernel release</a>, but it is not capable of much,
as a few key Rust abstractions are missing. The
<a href="https://gitlab.freedesktop.org/panfrost/linux/-/tree/tyr-dev?ref_type=heads">
downstream branch</a> (the parts of Tyr not yet in the mainline kernel) is
where we house our latest prototype; it is working well enough to run
desktop environments and games, even if there are still
power-consumption and GPU-recovery problems that need to be fixed. The prototype
will serve the purpose of guiding our upstream efforts and let us
experiment with different designs.
</p>

<p>
A kernel-mode GPU driver such as Tyr is a small component
backing a much larger user-mode driver that implements a graphics
API like Vulkan or OpenGL. The user-mode driver translates hardware-independent API
calls into GPU-specific commands that can be used by the rasterization
process. The kernel&#39;s responsibility centers around sharing hardware
resources between applications, enforcing isolation and fairness, and
keeping the hardware operational. This includes providing the user-mode driver with
GPU memory, letting it know when submitted work finishes, and giving
user space a way to describe dependency chains between jobs. Our talk (<a href="https://www.youtube.com/watch?v=R5h6qu1vFvM">YouTube video</a>) at
LPC2025 goes over this in detail.
</p>

<p><a href="https://lwn.net/Articles/1056363">
<img src="https://static.lwn.net/images/2026/tyr-demo-small.png" alt="[SuperTuxKart running on Tyr at LPC]" title="SuperTuxKart running on Tyr at LPC"/>
</a></p><p>
Having a working prototype does not mean it&#39;s ready for real world
usage, however, and a walkthrough of what is missing reveals why. Mali
GPUs are usually found on mobile devices where power is at a premium.
Conserving energy and managing the thermal characteristics of the device is paramount to user
experience, and Tyr does not have any power-management or frequency-scaling
code at the moment. In fact, Rust abstractions to support these features are not
available at all.
</p>

<p>
Something else worth considering is what happens if the GPU hangs. It
is imperative that the system remains working to the extent possible, or
users might lose all of their work. Owing to our &#34;prototype&#34; state, there
is no GPU-recovery code right now.
These two things are a hard requirement for deployability. One simply
cannot deploy a driver that gobbles all of the battery in the system —
making it hot and unpleasant in the process — or crashes and takes the
user&#39;s work with it.
</p>


<p>
On top of that, Vulkan must be correctly implementable on top of Tyr,
or we may fail to achieve drop-in compatibility with our Vulkan driver
(PanVK). This requires passing the Vulkan Conformance Testing Suite when
using Tyr instead of the C driver. At that point, we would be confident
enough to add support for more GPU models beyond the currently supported
Mali-G610. Finally, we will turn our attention to benchmarking to ensure
that Tyr can match the C driver&#39;s performance while benefiting from
Rust&#39;s safety guarantees. We
have demonstrated running a complex game with acceptable performance,
so results are good so far.
</p>

<h4 id="what-rust-abstractions-are-missing">Which Rust abstractions are
missing</h4>
<p>
Some required Rust infrastructure is still work-in-progress. This
includes Lyude Paul&#39;s work on the <a href="https://www.kernel.org/doc/html/latest/gpu/drm-mm.html#the-graphics-execution-manager-gem">graphics
execution manager</a> (GEM)
<a href="https://www.kernel.org/doc/html/latest/gpu/drm-mm.html#c.drm_gem_shmem_object">shmem</a>
objects, needed to allocate memory for systems without discrete video RAM.
This is notably the case for Tyr, as the GPU is packaged in a larger
system-on-chip and must share system memory. Additionally, there are
still open questions, like how to share non-overlapping
regions of a GPU buffer without locks, preferably encoded in the type
system and checked at compile time.
</p>

<!-- middle-ad -->


<p>
On top of allocating GPU memory, modern kernel drivers must let the
user-mode driver manage its own view of the GPU address space. In the DRM
ecosystem, this is delegated to <a href="https://www.kernel.org/doc/html/latest/gpu/drm-mm.html#drm-gpuvm">GPUVM</a>,
which contains the common code to manage those address spaces on
hardware that offers memory-isolation capabilities similar to modern CPUs.
The GPU firmware also expects control over the placement of some
sections in memory, so it will not work until this capability is
available. Alice Ryhl is working on the Rust abstractions for
GPUVM as well as the <code>io-pgtable</code> abstractions
that are needed to manipulate the <code>IOMMU</code> page tables used to
enforce memory isolation. These are both based on the
<a href="https://lwn.net/Articles/995383/">
previous work</a> of
Asahi Lina, who pioneered the first Rust abstractions for the DRM
subsystem.
</p>

<p>
Another unsolved issue is DRM device initialization. The current code
requires an initializer for the driver&#39;s private data in order to return
a <a href="https://rust.docs.kernel.org/kernel/drm/device/struct.Device.html">drm::Device</a>
instance, but some drivers need the <code>drm::Device</code> to build
the private data in the first place, which leads to an impossible-to-satisfy
cycle of dependencies. This is also the
case for Tyr: allocating GPU memory through the GEM shmem API
requires a <code>drm::Device</code>, but some fields in Tyr&#39;s private
data need to store GEM objects — for example, to parse and boot the
firmware. <a href="https://lwn.net/ml/rust-for-linux/20251107193204.398657-1-lyude@redhat.com/">
Lyude
Paul is working on this</a> by introducing a <code>drm::DeviceCtx</code>
that encodes the device state in the type system.
</p>

<p>
The situation remains the same as when the first Tyr patches were
submitted: most of the roadmap is blocked on <code>GEM shmem</code>,
GPUVM, <code>io-pgtable</code> and the device
initialization issue. There is room to integrate some work by the Nova team, as
well: the <a href="https://lwn.net/ml/all/20260126-register-v3-0-2328a59d7312@nvidia.com/">register!</a>
macro and <a href="https://lwn.net/ml/rust-for-linux/20251108-bounded_ints-v4-0-c9342ac7ebd1@nvidia.com/">bounded</a>
integers. Once we can handle those items, we expect to quickly
become able to boot the GPU
firmware and then progress unhindered until it is time to discuss job
submission.
</p>

<p>
Another area needing consideration is the paths where the driver
makes forward progress on completing <a href="https://www.kernel.org/doc/html/latest/driver-api/dma-buf.html#dma-fences">fences</a>,
which are synchronization primitives that GPU drivers signal once jobs finish
executing. These paths must be carefully annotated or the system may
deadlock, and the driver must ensure that only safe locks are taken in the
signaling path. Additionally, DMA fences must
always signal in finite time, or someone elsewhere in the system may
block forever. Allocating memory using anything other than
<code>GFP_ATOMIC</code> must be disallowed, or the shrinker may kick in
under memory pressure and wait on the very job that triggered it. All of
this is covered in the <a href="https://docs.kernel.org/driver-api/dma-buf.html#dma-fence-cross-driver-contract">documentation</a>.
We conveniently ignore this in the prototype, meaning it can randomly
deadlock under memory pressure. Addressing this is straightforward: it
is just a matter of carefully vetting key parts of the driver. Doing so
elegantly, however, and perhaps in a way that takes advantage of Rust&#39;s type
system is something that remains to be discussed.
</p>

<h4 id="looking-into-the-future">Looking into the future</h4>
<p>
We have not touched upon what is next for Linux GPU drivers as a
whole: reworking the job-submission logic in Rust. The current design
assumes that <a href="https://docs.kernel.org/gpu/drm-mm.html#gpu-scheduler">drm_gpu_scheduler</a>
is used, but this has become a hindrance for some drivers in an age
where GPU firmware can schedule jobs itself, and it&#39;s been plagued by
hard-to-solve lifetime problems. Quite some time was spent
<a href="https://indico.freedesktop.org/event/10/contributions/450/">
at the X.Org
Developer&#39;s Conference</a> in 2025 discussing how to fix it.
</p>

<p>
The current consensus for Rust is to write a new component that
merely ensures that the dependencies for a given job are satisfied
before the job is eligible to be assigned in the GPU&#39;s ring buffer, at
which point the firmware scheduler takes over. This seems to be where
GPU hardware is going, as most vendors have switched to
firmware-assisted scheduling in recent years. As this component will not
schedule jobs, it will probably be called <code>JobQueue</code> instead.
This correctly conveys the meaning of a queue where new work is
deposited in and removed once the dependencies are met and a job is
ready to run. Philip Stanner has been spearheading this work.
</p>

<p>
The plan is to also
expose an API for C drivers using a <a href="https://lwn.net/Articles/970565/">technique I have described here
in the past</a>. This will possibly be the first Rust kernel component
usable from C drivers, another milestone for Rust in the kernel, and a
hallmark of seamless interoperability between C and Rust.
</p>

<p>
One way that Tyr can fit into this overall vision is by serving as a
testbed for the new design. If the old <code>drm_gpu_scheduler</code>
can be replaced with the <code>JobQueue</code> successfully in the
prototype, it will help attest its suitability for other, more complex
drivers like Nova. Expect this discussion to continue for a while.
</p>

<p>
In all, Tyr has made a lot of progress this past year. Hopefully, it will
continue to do so through 2026 and beyond.
</p></div></div>
  </body>
</html>
