<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://surfingcomplexity.blog/2024/03/26/the-problem-with-invariants-is-that-they-change-over-time/">Original</a>
    <h1>The problem with invariants is that they change over time</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3663">
			<!-- .entry-header -->		<!-- .entry-meta -->
	
	<div>
		
<p> Cliff L. Biffle blogged a great write-up of a debugging odyssey at <a href="https://oxide.computer/">Oxide</a> with the title <a href="https://cliffle.com/blog/who-killed-the-network-switch/">Who killed the network switch?</a> Here’s the bit that jumped out at me:</p>



<blockquote>
<p>At the time that code was written, it was correct, but it embodied the assumption that any loaned memory would fit into one region.</p>



<p>That assumption became obsolete the moment that Matt implemented task packing, but we didn’t notice. This code, which was still simple and easy to read, was now also wrong.</p>
</blockquote>



<p>This type of assumption is an example of an <em>invariant</em>, a property of the system that is supposed to be guaranteed to not change over time. Invariants play an important role in formal methods (for example, see the section <a href="https://www.learntla.com/core/invariants.html">Writing an invariant</a> in Hillel Wayne’s <a href="https://www.learntla.com/index.html">Learn TLA+</a> site). </p>



<p>Now, consider the following:</p>



<ul>
<li>Our systems change over time. In particular, we will always make modifications to support new functionality that we could not have foreseen earlier in the lifecycle of the system. </li>



<li>Our code often rests on a number of <em>invariants</em>, properties that are currently true of our system and that we assume will always be true. </li>



<li>These invariants are <em>implicit</em>: the assumptions themselves are not explicitly represented in the source code. That means there’s no easy way to, say, mechanically extract them via static analysis.</li>



<li>A change can happen that violates an assumed invariant can be arbitrary far away from code that depends on the invariant to function properly.</li>
</ul>



<p>What this means is that these kinds of failure modes are<em> inevitable</em>. If you’ve been in this business long enough, you’ve almost certainly run into an incident where one of the contributors was an implicit invariant that was violated by a new change. If you’re system lives long enough, it’s going to change. And one of those changes is eventually going to invalidate an assumption that somebody made long ago, which was a reasonable assumption to make at the time.</p>



<p>Implicit invariants are, by definition, impossible to enforce explicitly. They are time bombs. And they are everywhere.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->

	<div>
			<!-- .entry-auhtor -->
			<p><strong>Published</strong>
			<time datetime="2024-03-26T20:57:34-07:00">March 26, 2024</time><time datetime="2024-03-26T20:59:38-07:00">March 26, 2024</time>		</p><!-- .site-posted-on -->
	</div>
</article></div>
  </body>
</html>
