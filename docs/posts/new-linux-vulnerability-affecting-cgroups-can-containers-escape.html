<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unit42.paloaltonetworks.com/cve-2022-0492-cgroups/">Original</a>
    <h1>New Linux vulnerability affecting cgroups: can containers escape?</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>
                      <figure>
              <img width="600" height="300" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/Unit42-blog-2by1-characters-r4d1-2020_Container-v1.png" alt="A conceptual image representing container security issues, such as CVE-2022-0492, the Linux vulnerability discussed here." loading="lazy"/>            </figure>
                    <p>This post is also available in: 
    <span><a href="https://unit42.paloaltonetworks.jp/cve-2022-0492-cgroups/"><span lang="ja">日本語</span><span><span> (</span>Japanese<span>)</span></span></a></span></p><h2><a id="post-122166-_etb17eqk5vb5"></a><strong>Executive Summary</strong></h2>
<p>On Feb. 4, Linux announced <a href="https://access.redhat.com/security/cve/cve-2022-0492">CVE-2022-0492</a>, a new privilege escalation vulnerability in the kernel. CVE-2022-0492 marks a logical bug in control groups (<a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">cgroups</a>), a Linux feature that is a fundamental building block of containers. The issue stands out as one of the simplest Linux privilege escalations discovered in recent times: The Linux kernel mistakenly exposed a privileged operation to unprivileged users.</p>
<p>Fortunately, the default security hardenings in most container environments are enough to prevent container escape. Containers running with AppArmor or SELinux are protected. That being said, if you run containers without best practice hardenings, or with additional privileges, you may be at risk. The <a href="#Am-I-Affected">&#34;Am I Affected?&#34;</a> section lists vulnerable container configurations and provides instructions on how to test whether a container environment is vulnerable.</p>
<p>Aside from containers, the vulnerability can also allow root host processes with no capabilities, or non-root host processes with the <span>CAP_DAC_OVERRIDE</span> capability, to escalate privileges and attain all capabilities. This may allow attackers to circumvent a hardening measure used by certain services, which drop capabilities in an attempt to limit impact if a compromise occurs.</p>
<p>Unit 42 recommends users upgrade to a fixed kernel version. For those running containers, enable Seccomp and ensure AppArmor or SELinux are enabled. Prisma Cloud users can refer to the <a href="#Prisma-Cloud-Protections">&#34;Prisma Cloud Protections&#34;</a> section for the mitigations provided by Prisma Cloud.</p>
<p>CVE-2022-0492 is now the third <a href="https://www.paloaltonetworks.com/blog/prisma-cloud/linux-kernel-vulnerabilities/">kernel vulnerability in recent months</a> that allows malicious containers to escape. In all three vulnerabilities, securing containers with Seccomp and either AppArmor or SELinux was enough to prevent container escape.</p>

<h2><a id="post-122166-_en4cxg914ahb"></a><strong>Table of Contents</strong></h2>
<p><a href="#Background-on-Cgroups">Background on Cgroups</a></p>
<h2><a id="Background-on-Cgroups"></a><strong>Background on Cgroups </strong></h2>
<p>Control groups (cgroups) are a Linux feature that allows administrators to limit, account for and isolate the resource usage of a collection of processes. Linux supports two cgroup architectures called v1 and v2. The new vulnerability only affects cgroup v1, which is currently the more widely used architecture by far. The rest of this section will only refer to cgroup v1.</p>
<p>Cgroups are managed via cgroupfs, a management API exposed as a filesystem and normally mounted under <span>/sys/fs/cgroup</span>. By creating and writing to files and directories in a mounted cgroupfs, administrators can create cgroups, control the constraints imposed on a cgroup, add processes to a certain cgroup and so on.</p>
<p>Cgroups are divided into subsystems, each configuring access to a different resource. The memory cgroup for example, can limit the memory consumption of a collection of processes. The device cgroup defines which devices (e.g. the hard drive, or the mouse) can be accessed by processes in the cgroup. Other examples for subsystems include block IO, CPU and remote direct memory access (RDMA).</p>
<p>Each subsystem is typically mounted at <span>/sys/fs/cgroup/&lt;subsystem&gt;</span>, which is considered the root cgroup for the subsystem. Any subsequent directories under the root cgroup denote a new child cgroup. A Docker container, for example, would normally be a part of the <span>/docker/&lt;ctr-id&gt; <span>cgroup</span></span>, which could be found on the host at <span>/sys/fs/cgroup/&lt;subsystem&gt;/docker/&lt;ctr-id&gt;</span>. Figure 1 shows the cgroup membership of a Docker container, and Figure 2 shows the cgroup membership of a Kubernetes pod.</p>
<figure id="attachment_122169" aria-describedby="caption-attachment-122169"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image.png" alt="Cgroup membership of a process in a Docker container." width="900" height="296"/><figcaption id="caption-attachment-122169">Figure 1. Cgroup membership of a process in a Docker container.</figcaption></figure>
<figure id="attachment_122171" aria-describedby="caption-attachment-122171"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-1.png" alt="Cgroup membership of a process in a Kubernetes pod." width="900" height="197"/><figcaption id="caption-attachment-122171">Figure 2. Cgroup membership of a process in a Kubernetes pod.</figcaption></figure>
<p>As seen in the screenshots above, not all hosts are configured to support the same subsystems. Docker and Kubernetes also have a variety of cgroup configurations, so containers on your hosts or clusters may not have the same memberships as in the examples above.</p>
<h2><a id="Root-Cause-Analysis-CVE-2022-0492"></a><strong>Root Cause Analysis – CVE-2022-0492 </strong></h2>
<p>One of the features of cgroups v1 is the <span>release_agent</span> file. It allows administrators to configure a &#34;release agent&#34; program that would run upon the termination of a process in the cgroup. This is done by writing the desired release agent path to the <span>release_agent</span> file, as demonstrated below:</p>
<p><span>$ echo /bin/my-release-agent &gt; /sys/fs/cgroup/memory/release_agent</span></p>
<p>The <span>release_agent</span> file is only visible in the root cgroup directory and affects all its child cgroups. Each child group can be configured to either trigger or not trigger the release agent (upon the termination of one of its processes) by writing to the <span>notify_on_release</span> file. The following command enables the <span>notify_on_release</span> functionality for the <span>a_child_cgroup</span> cgroup:</p>
<p><span>$ echo 1 &gt; /sys/fs/cgroup/memory/a_child_cgroup/notify_on_release</span></p>
<p>When a process dies, the kernel checks whether its cgroups had <span>notify_on_release </span>enabled, and if so, spawns the configured <span>release_agent</span> binary. The release agent runs with the highest possible permissions: a root process with all capabilities in the initial namespaces. As such, configuring the release agent is considered a privileged operation, as it allows one to decide which binary will run with full root permissions.</p>
<p>CVE-2022-0492 stems from a missing verification. Linux simply didn&#39;t check that the process setting the <span>release_agent</span> file has administrative privileges (i.e. the <span>CAP_SYS_ADMIN</span> capability). The very short patch for CVE-2022-0492 (lines 2-8 below) best explains the vulnerability:</p><!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-6223005f7403b814014480" data-settings=" minimize scroll-mouseover wrap">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					
				</td>
						<td><div><p><span>@</span><span>@</span><span> </span><span>-</span><span>549</span><span>,</span><span>6</span><span> </span><span>+</span><span>549</span><span>,</span><span>14</span><span> </span><span>@</span><span>@</span><span> </span><span>static</span><span> </span><span>ssize_t </span><span>cgroup_release_agent_write</span><span>(</span><span>struct</span><span> </span><span>kernfs_open_file *</span><span>of</span><span>,</span></p><p><span>+</span><span>	</span><span>/*</span></p><p><span>+	 * Release agent gets called with all capabilities,</span></p><p><span>+	 * require capabilities to set release agent.</span></p><p><span>+	 */</span></p><p><span>+</span><span>	</span><span>if</span><span> </span><span>(</span><span>(</span><span>of</span><span>-&gt;</span><span>file</span><span>-&gt;</span><span>f_cred</span><span>-&gt;</span><span>user_ns</span><span> </span><span>!=</span><span> </span><span>&amp;</span><span>init_user_ns</span><span>)</span><span> </span><span>||</span></p><p><span>+</span><span>	    </span><span>!</span><span>capable</span><span>(</span><span>CAP_SYS_ADMIN</span><span>)</span><span>)</span></p><p><span>+</span><span>		</span><span>return</span><span> </span><span>-</span><span>EPERM</span><span>;</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0004 seconds] -->

<h2><a id="Exploitation-Prerequisites"></a><strong>Exploitation Prerequisites</strong></h2>
<p>As established, if you can write to the <span>release_agent</span> file, you can force the kernel into invoking a binary of your choosing with elevated privileges and take control of the entire machine. So who can write to the <span>release_agent</span> file on a vulnerable machine? Even though the kernel won&#39;t explicitly check the writing processes&#39; privileges, normal file ownership and permission semantics still apply.</p>
<p>Because Linux sets the owner of the <span>release_agent</span> file to root, only root can write to it (or processes that can bypass file permission checks via the <span>CAP_DAC_OVERRIDE</span> capability). As such, <strong>the vulnerability only allows root processes to escalate privileges</strong>.</p>
<p>At first glance, a privilege escalation vulnerability that can only be exploited by the root user may seem bizarre. In the past, this wouldn&#39;t be considered a security issue. But today, running as root doesn&#39;t necessarily mean full control over the machine: There&#39;s a gray area between the root user and full privileges that includes capabilities, namespaces and containers. In these scenarios where a root process doesn&#39;t have full control over the machine, CVE-2022-0492 becomes a serious vulnerability.</p>
<h2><a id="A-Win-for-Defense-in-Depth-Container-Escape-Prerequisites"></a><strong>A Win for Defense-In-Depth – Container Escape Prerequisites </strong></h2>
<p>Not every container can exploit CVE-2022-0492 to escape; only those with permissive security profiles can perform the necessary steps.</p>
<p>Cgroup mounts are mounted read-only inside containers, so the <span>release_agent</span> file they host cannot be written to. A malicious container that wants to exploit CVE-2022-0492 must mount another, writable cgroupfs.</p>
<figure id="attachment_122173" aria-describedby="caption-attachment-122173"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-2.png" alt="Cgroupfs mounts inside containers are read-only (&#34;ro&#34;). A malicious container that wants to exploit CVE-2022-0492 must mount another, writable cgroupfs." width="900" height="229"/><figcaption id="caption-attachment-122173">Figure 3. Cgroupfs mounts inside containers are read-only (&#34;ro&#34;).</figcaption></figure>
<p><strong>Both AppArmor and SELinux prevent mounting, meaning containers running with either are protected</strong>. Without both, a container can mount cgroupfs in one of two ways: abusing either user namespaces or the <span>CAP_SYS_ADMIN</span> capability.</p>
<h3><a id="post-122166-_vwwoa25yhpc3"></a>User namespace Escape</h3>
<p>Mounting a cgroupfs requires the <span>CAP_SYS_ADMIN</span> capability in the user namespace hosting the current cgroup namespace. By default, containers run without <span>CAP_SYS_ADMIM</span>, and thus cannot mount cgroupfs in the initial user namespace. But through the <span>unshare()</span> syscall, containers can create new user and cgroup namespaces where they possess the <span>CAP_SYS_ADMIN</span> capability and can mount a cgroupfs.</p>
<figure id="attachment_122175" aria-describedby="caption-attachment-122175"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-3.png" alt="A container creating a new user namespace where it&#39;ll have the CAP_SYS_ADMIN capability." width="900" height="166"/><figcaption id="caption-attachment-122175">Figure 4. A container creating a new user namespace where it&#39;ll have the CAP_SYS_ADMIN capability.</figcaption></figure>
<p>Not every container can create a new user namespace –<strong> the underlying host must have unprivileged user namespaces enabled</strong>. This is the default on recent Ubuntu releases, for example. Since Seccomp blocks the <span>unshare()</span> syscall, <strong>only containers running without Seccomp can create a new user namespace</strong>. The container shown in the attached screenshot runs without Seccomp, AppArmor or SELinux.</p>
<figure id="attachment_122177" aria-describedby="caption-attachment-122177"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-4.png" alt="The container mounts the memory cgroup in the new user and cgroup namespaces." width="900" height="231"/><figcaption id="caption-attachment-122177">Figure 5. The container mounts the memory cgroup in the new user and cgroup namespaces.</figcaption></figure>
<p>In the screenshot above, the container successfully mounted a memory cgroup, but you may notice that the <span>release_agent</span> file isn&#39;t included in the mounted directory!</p>
<p>As mentioned earlier, the <span>release_agent</span> file is only visible in the root cgroup. One caveat of mounting a cgroupfs in a cgroup namespace is that you mount the cgroup you belong to, not the root cgroup. If you scroll back up to Figure 1, you&#39;ll see that the container doesn&#39;t run in the root memory cgroup but in a child cgroup: <span>/docker/&lt;id&gt;</span>. <strong>For the release_agent file to be visible in the cgroup mount, the container must run in the root cgroup of a subsystem</strong>.</p>
<p>Also back in Figure 1, you&#39;ll see that Docker ran the container in the root RDMA cgroup. If we repeat the same commands for the RDMA cgroup, the <span>release_agent</span> file would be visible.</p>
<figure id="attachment_122179" aria-describedby="caption-attachment-122179"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-5.png" alt="The container mounting the root RDMA cgroup in the new user and cgroup namespaces." width="900" height="96"/><figcaption id="caption-attachment-122179">Figure 6. The container mounting the root RDMA cgroup in the new user and cgroup namespaces.</figcaption></figure>
<p>To exploit the issue, we need to write a malicious release agent to the <span>release_agent</span> file. As seen in Figure 6 above, that file is owned by root, so <strong>only root container processes may set the release agent</strong>. Figure 7 shows the container setting the release agent, while Figure 8 shows a non-root container failing to do so.</p>
<figure id="attachment_122181" aria-describedby="caption-attachment-122181"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-6.png" alt="A root container setting the release agent." width="900" height="106"/><figcaption id="caption-attachment-122181">Figure 7. A root container setting the release agent.</figcaption></figure>
<figure id="attachment_122183" aria-describedby="caption-attachment-122183"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-7.png" alt="Non-root container cannot set the release agent." width="900" height="106"/><figcaption id="caption-attachment-122183">Figure 8. Non-root container cannot set the release agent.</figcaption></figure>
<p>The final step of the escape is to invoke the configured <span>release_agent</span>, which doesn&#39;t require any privileges. Since this step is always doable, it has no implications on whether an environment is vulnerable to CVE-2022-0492, and so we decided to leave it out. You can still see how a full exploit looks in the screenshot below.</p>
<figure id="attachment_122185" aria-describedby="caption-attachment-122185"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-8.png" alt="Exploiting CVE-2022-0492 for container escape, via user namespaces." width="900" height="160"/><figcaption id="caption-attachment-122185">Figure 9. Exploiting CVE-2022-0492 for container escape, via user namespaces.</figcaption></figure>
<p>If you go over the <strong>bolded</strong> lines in this section, you&#39;ll find the requirements for exploiting CVE-2022-0492 for container escape via user namespaces.</p>
<h3><a id="post-122166-_vmuzywrfwb6q"></a>CAP_SYS_ADMIN Escape</h3>
<p>Rather than creating new user and cgroup namespaces, a simpler exploit is possible if the container is granted the <span>CAP_SYS_ADMIN</span> capability. A container running with the <span>CAP_SYS_ADMIN</span> capability is permitted to mount cgroupfs, no questions asked. As a bonus, most containers today run without cgroup namespaces, meaning the mounted cgroup would be the root cgroup hosting and the <span>release_agent</span> file.</p>
<figure id="attachment_122187" aria-describedby="caption-attachment-122187"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-9.png" alt="In the initial cgroup namespace, mounting cgroupfs will always mount the root cgroup, regardless of the container&#39;s cgroup." width="900" height="214"/><figcaption id="caption-attachment-122187">Figure 10. In the initial cgroup namespace, mounting cgroupfs will always mount the root cgroup, regardless of the container&#39;s cgroup.</figcaption></figure>
<p>Even with the <span>CAP_SYS_ADMIN</span> capability, AppArmor and SELinux still prevent mounting, so containers running with either cannot exploit CVE-2022-0492. Figure 11 shows a container running without AppArmor and SELinux, and with the <span>CAP_SYS_ADMIN</span> capability, exploiting CVE-2022-0492 to break out.</p>
<figure id="attachment_122189" aria-describedby="caption-attachment-122189"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-10.png" alt="Exploiting CVE-2022-0492 for container escape via the CAP_SYS_ADMIN capability." width="900" height="163"/><figcaption id="caption-attachment-122189">Figure 11. Exploiting CVE-2022-0492 for container escape via the CAP_SYS_ADMIN capability.</figcaption></figure>
<h2><a id="Am-I-Affected"></a><strong>Am I Affected?</strong></h2>
<p>In conclusion, a container can escape if it runs:</p>
<ol>
<li>As the root user, or without the <span><a href="https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation">no_new_privs</a> </span>flag; and</li>
<li>Without AppArmor or <a href="https://www.redhat.com/en/topics/linux/what-is-selinux#:~:text=Security%2DEnhanced%20Linux%20(SELinux),Linux%20Security%20Modules%20(LSM).">SELinux</a>; and</li>
<li>Without <a href="https://docs.docker.com/engine/security/seccomp/">Seccomp</a>; and</li>
<li>On a host that enables unprivileged user namespaces; and</li>
<li>In a root v1 cgroup.</li>
</ol>
<p>Or alternatively, if it runs:</p>
<ol>
<li>With the <span>CAP_SYS_ADMIN</span> capability; and</li>
<li>Without AppArmor or <a href="https://www.redhat.com/en/topics/linux/what-is-selinux#:~:text=Security%2DEnhanced%20Linux%20(SELinux),Linux%20Security%20Modules%20(LSM).">SELinux</a> ; and</li>
<li>Without cgroup namespaces, or in a root v1 cgroup.</li>
</ol>
<p>Unit 42 researchers created a <a href="https://github.com/PaloAltoNetworks/can-ctr-escape-cve-2022-0492">script</a> that can test whether a container environment is vulnerable to CVE-2022-0492. To test your environment, you can simply deploy a new container running our <span>us-central1-docker.pkg.dev/twistlock-secresearch/public/can-ctr-escape-cve-2022-0492</span> image, which is configured to run the script, print its output and exit. Alternatively, you can build and run your own image using the Dockerfile included in the tool&#39;s repository.</p>
<p>While possible, we don&#39;t advise running the script in an existing container. That&#39;s because the container may not have the utilities the script relies on, or their correct version, which may lead to inaccurate results.</p>
<figure id="attachment_122191" aria-describedby="caption-attachment-122191"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-11.png" alt="Using the script to test which container configurations can exploit CVE-2022-0492 to escape." width="900" height="274"/><figcaption id="caption-attachment-122191">Figure 12. Using the script to test which container configurations can exploit CVE-2022-0492 to escape.</figcaption></figure>
<h2><a id="Mitigations"></a><strong>Mitigations</strong></h2>
<p>CVE-2022-0492 is fixed on the latest Linux release; all users are encouraged to upgrade to the latest kernel version of their respective distribution.</p>
<p>To protect against malicious containers in scenarios where upgrading isn&#39;t possible, users can enable one of the following mitigations:</p>
<ol>
<li>Enable AppArmor or SELinux. See this <a href="https://kubernetes.io/docs/tutorials/security/apparmor/">Kubernetes guide</a> for more information.</li>
<li>Enable Seccomp. See this <a href="https://kubernetes.io/docs/tutorials/security/seccomp/">Kubernetes guide</a> for more information. Note that this won&#39;t defend against containers running with the <span>CAP_SYS_ADMIN</span> capability.</li>
</ol>
<p>To protect against malicious host processes escalating privileges, in scenarios where upgrading isn&#39;t possible, users may enable both mitigations below. Note that this solution is a best effort attempt at preventing trival exploits and doesn&#39;t persist during reboot.</p>
<ol>
<li>Disable unprivileged user namespaces using the following command: <span>sudo sysctl -w kernel.unprivileged_userns_clone=0</span>. Note that some services like <a href="https://podman.io/">Podman</a> rely on unprivileged user namespaces and may not work as intended.</li>
<li>Prevent processes from setting the <span>release_agent</span> in any cgroup mount using the script below. The script masks all <span>release_agent</span> files with a read-only bind mount. If your system mounts cgroups at a custom path (default is <span>/sys/fs/cgroup</span>), you can provide it as an argument to the script.</li>
</ol>
<!-- Crayon Syntax Highlighter v_2.7.2_beta -->

		<div id="crayon-6223005f74049688049702" data-settings=" minimize scroll-mouseover">
		
			
			
			
			<div>
				<table>
					<tbody><tr>
				<td data-settings="show">
					<div><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p></div>
				</td>
						<td><div><p><span>#!/bin/bash</span></p><p><span>set</span><span> </span><span>-</span><span>e</span></p><p><span>mask_dir</span><span>=</span><span>/</span><span>var</span><span>/</span><span>lib</span><span>/</span><span>cve_2022_0492_release_agent_mask</span></p><p><span>cgroup_dir</span><span>=</span><span>/</span><span>sys</span><span>/</span><span>fs</span><span>/</span><span>cgroup</span></p><p><span>if</span><span> </span><span>[</span><span> </span><span>!</span><span> </span><span>-</span><span>z</span><span> </span><span>&#34;$1&#34;</span><span> </span><span>]</span><span>;</span><span> </span><span>then</span><span> </span><span>cgroup_dir</span><span>=</span><span>$</span><span>1</span><span> </span><span>;</span><span> </span><span>fi</span></p><p><span>echo</span><span> </span><span>&#34;[+] Creating mask at $mask_dir/mask&#34;</span></p><p><span>sudo </span><span>mkdir</span><span> </span><span>-</span><span>p</span><span> </span><span>$</span><span>mask_dir</span></p><p><span>sudo </span><span>mount</span><span> </span><span>-</span><span>t</span><span> </span><span>tmpfs </span><span>release_agent</span><span>_</span>mask<span> </span><span>$</span><span>mask_dir</span></p><p><span>sudo </span><span>touch</span><span> </span><span>$</span><span>mask_dir</span><span>/</span><span>mask</span></p><p><span>sudo </span><span>mount</span><span> </span><span>-</span><span>o</span><span> </span><span>remount</span><span>,</span><span>ro</span><span> </span><span>$</span><span>mask_dir</span></p><p><span>for</span><span> </span><span>release_agent </span><span>in</span><span> </span><span>$</span><span>(</span><span>find</span><span> </span><span>$</span><span>cgroup_dir</span><span> </span><span>-</span><span>name</span><span> </span><span>&#39;release_agent&#39;</span><span>)</span><span> </span><span>;</span><span>do</span><span> </span></p><p><span>    </span><span>echo</span><span> </span><span>&#34;[+] Mounting read-only mask over $release_agent&#34;</span></p><p><span>    </span><span>sudo </span><span>mount</span><span> </span><span>--</span><span>bind</span><span> </span><span>$</span><span>mask_dir</span><span>/</span><span>mask</span><span> </span><span>$</span><span>release_agent</span></p><p><span>done</span></p></div></td>
					</tr>
				</tbody></table>
			</div>
		</div>
<!-- [Format Time: 0.0008 seconds] -->

<h2><a id="Prisma-Cloud-Protections"></a><strong>Prisma Cloud Protections</strong></h2>
<p>Prisma Cloud detects and alerts on hosts running a vulnerable kernel version. The platform also generates compliance alerts on containers that aren&#39;t protected by Seccomp, and on those running with neither AppArmor nor SELinux.</p>
<figure id="attachment_122193" aria-describedby="caption-attachment-122193"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-12.png" alt="Prisma Cloud alerting on a Linux host running the kernel version that is vulnerable to CVE-2022-0492." width="900" height="399"/><figcaption id="caption-attachment-122193">Figure 13. Prisma Cloud alerting on a Linux host running the vulnerable kernel version.</figcaption></figure>
<figure id="attachment_122195" aria-describedby="caption-attachment-122195"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-13.png" alt="Prisma Cloud generates a critical compliance alert for containers running without Seccomp." width="900" height="364"/><figcaption id="caption-attachment-122195">Figure 14. Prisma Cloud generates a critical compliance alert for containers running without Seccomp.</figcaption></figure>
<p>Under <span>Compute/Defend/Compliance</span>, you can further harden your environments by blocking containers that don&#39;t follow certain compliance rules, for example, and as shown in Figure 15, those running without Seccomp.</p>
<figure id="attachment_122197" aria-describedby="caption-attachment-122197"><img loading="lazy" src="https://unit42.paloaltonetworks.com/wp-content/uploads/2022/03/word-image-14.png" alt="" width="900" height="190"/><figcaption id="caption-attachment-122197">Figure 15. Configuring Prisma Cloud to block containers running without Seccomp.</figcaption></figure>
<h2><a id="Conclusion"></a><strong>Conclusion</strong></h2>
<p>CVE-2022-0492 marks another Linux vulnerability that can be exploited for container escape. Fortunately, environments that follow best practices are protected from this vulnerability. Environments with lax security controls hosting untrusted or publicly exposed containers are, unsurprisingly, at high risk. As always, it&#39;s best to upgrade your hosts to a fixed kernel version.</p>
<p>We strongly recommend running containers with Seccomp and either AppArmor or SELinux enabled, to protect against this vulnerability and against future Linux zero-day vulnerabilities. Many privilege escalation vulnerabilities in the Linux kernel can only be exploited for container escape when the container is allowed to create a new user namespace, or in other words, when the container runs without Seccomp.</p>
<p>Prisma Cloud users are encouraged to review <span>Compute/Monitor/Compliance</span> and determine whether any of their containers run without Seccomp. Users can also choose to block containers running without Seccomp, as shown in Figure 15.</p>
          <div>
  <h4>Get updates from </h4>
  <p>Sign up to receive the latest news, cyber threat intelligence and research from us</p>
  <!-- <form action="https://app-guse4001.marketo.com/index.php/leadCapture/save2" method="post" novalidate class="subscribe-form py-25" name="Unit42_Subscribe"> -->
  

  
</div>


        </div>
      </div>
    </div></div>
  </body>
</html>
