<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://morizbuesing.com/blog/greppability-code-metric/">Original</a>
    <h1>Greppability is an underrated code metric</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>When I’m working on maintaining an unfamiliar codebase, I will spend a lot of
time grepping the code base for strings. Even in projects exclusively written
by myself, I have to search a lot: function names, error messages,
class names, that kind of thing. If I can’t find what I’m looking for, it’ll
be frustrating in the best case, or in the worst case lead to dangerous
situations where I’ll assume a thing is not needed anymore, since I can’t find
any references to it in the code base. From these situations, I’ve derived some
rules you can apply to keep your code base greppable:</p>
<h2 id="dont-split-up-identifiers">Don’t split up identifiers</h2>
<p>It turns out that splitting up, or dynamically constructing identifiers is a
bad idea.</p>
<p>Suppose you have two database tables <code>shipping_addresses</code>, <code>billing_addresses</code>,
it might seem like a perfectly good solution to construct the table name
dynamically from the order type.</p>
<pre tabindex="0"><code><span><span>const</span><span> getTableName</span><span> =</span><span> (addressType</span><span>:</span><span> &#39;shipping&#39;</span><span> |</span><span> &#39;billing&#39;</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    return</span><span> `${</span><span>addressType</span><span>}_addresses`</span></span>
<span><span>}</span></span></code></pre>
<p>Though it looks nice and DRY, it’s not great for maintainenance: someone will
inevitably search the code base for the table name <code>shipping_addresses</code> and
miss this occurence.</p>
<p>Refactored for greppability:</p>
<pre tabindex="0"><code><span><span>const</span><span> getTableName</span><span> =</span><span> (addressType</span><span>:</span><span> &#39;shipping&#39;</span><span> |</span><span> &#39;billing&#39;</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    if</span><span> (</span><span>addressType</span><span> ===</span><span> &#39;shipping&#39;</span><span>) {</span></span>
<span><span>        return</span><span> &#39;shipping_addresses&#39;</span></span>
<span><span>    }</span></span>
<span><span>    if</span><span> (</span><span>addressType</span><span> ===</span><span> &#39;billing&#39;</span><span>) {</span></span>
<span><span>        return</span><span> &#39;billing_addresses&#39;</span></span>
<span><span>    }</span></span>
<span><span>    throw</span><span> new</span><span> TypeError</span><span>(</span><span>&#39;addressType must be billing or shipping&#39;</span><span>)</span></span>
<span><span>}</span></span></code></pre>
<p>The same goes for column names, object fields, and, god forbid, method/function
names (it’s easily possible to dynamically construct method names with javascript).</p>
<h2 id="use-the-same-names-for-things-across-the-stack">Use the same names for things across the stack</h2>
<p>Don’t rename fields at application boundaries to match naming schemes. An obvious
example is then importing postgres-style snake_case identifiers into
javascript, then converting them to camelCase. This makes it harder to
find—you now have to grep for two strings instead of one in order to find all
occurences!</p>
<pre tabindex="0"><code><span><span>const</span><span> getAddress</span><span> =</span><span> async</span><span> (id</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    const</span><span> address</span><span> =</span><span> await</span><span> getAddressById</span><span>(</span><span>id</span><span>)</span></span>
<span><span>    return</span><span> {</span></span>
<span><span>        streetName: </span><span>address</span><span>.</span><span>street_name</span><span>,</span></span>
<span><span>        zipCode: </span><span>address</span><span>.</span><span>zip_code</span><span>,</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>You’re better off biting the bullet and returning the object directly:</p>
<pre tabindex="0"><code><span><span>const</span><span> getAddress</span><span> =</span><span> async</span><span> (id</span><span>:</span><span> string</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    return</span><span> await</span><span> getAddressById</span><span>(</span><span>id</span><span>)</span></span>
<span><span>}</span></span></code></pre>
<h2 id="flat-is-better-than-nested">Flat is better than nested</h2>
<p>Taking inspiration from the <a href="https://peps.python.org/pep-0020/">Zen of Python</a>,
when dealing with namespaces, flattening your folders/object structures is mostly better
than nesting.</p>
<p>For example if you have two choices to set up your translation files:</p>
<pre tabindex="0"><code><span><span>{</span></span>
<span><span>    &#34;auth&#34;</span><span>: {</span></span>
<span><span>        &#34;login&#34;</span><span>: {</span></span>
<span><span>            &#34;title&#34;</span><span>: </span><span>&#34;Login&#34;</span><span>,</span></span>
<span><span>            &#34;emailLabel&#34;</span><span>: </span><span>&#34;Email&#34;</span><span>,</span></span>
<span><span>            &#34;passwordLabel&#34;</span><span>: </span><span>&#34;Password&#34;</span><span>,</span></span>
<span><span>        },</span></span>
<span><span>        &#34;register&#34;</span><span>:</span></span>
<span><span>            &#34;title&#34;</span><span>: </span><span>&#34;Register&#34;</span><span>,</span></span>
<span><span>            &#34;emailLabel&#34;</span><span>: </span><span>&#34;Email&#34;</span><span>,</span></span>
<span><span>            &#34;passwordLabel&#34;</span><span>: </span><span>&#34;Password&#34;</span><span>,</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>}</span></span></code></pre>
<p>and</p>
<pre tabindex="0"><code><span><span>{</span></span>
<span><span>    &#34;auth.login.title&#34;</span><span>: </span><span>&#34;Login&#34;</span><span>,</span></span>
<span><span>    &#34;auth.login.emailLabel&#34;</span><span>: </span><span>&#34;Email&#34;</span><span>,</span></span>
<span><span>    &#34;auth.login.passwordLabel&#34;</span><span>: </span><span>&#34;Password&#34;</span><span>,</span></span>
<span><span>    &#34;auth.register.title&#34;</span><span>: </span><span>&#34;Login&#34;</span><span>,</span></span>
<span><span>    &#34;auth.register.emailLabel&#34;</span><span>: </span><span>&#34;Email&#34;</span><span>,</span></span>
<span><span>    &#34;auth.register.passwordLabel&#34;</span><span>: </span><span>&#34;Password&#34;</span><span>,</span></span>
<span><span>}</span></span></code></pre>
<p>take the second option! You will be able to easily find your keys now, which
you are probably referring to as something like <code>t(&#39;auth.login.title&#39;)</code>.</p>
<p>Or consider React component structure: a component stucture like</p>
<pre tabindex="0"><code><span><span>./components/AttributeFilterCombobox.tsx</span></span>
<span><span>./components/AttributeFilterDialog.tsx</span></span>
<span><span>./components/AttributeFilterRating.tsx</span></span>
<span><span>./components/AttributeFilterSelect.tsx</span></span></code></pre>
<p>is preferable to</p>
<pre tabindex="0"><code><span><span>./components/attribute/filter/Combobox.tsx</span></span>
<span><span>./components/attribute/filter/Dialog.tsx</span></span>
<span><span>./components/attribute/filter/Rating.tsx</span></span>
<span><span>./components/attribute/filter/Select.tsx</span></span></code></pre>
<p>from a greppability perspective, since you’ll be able to grep for the
whole namespaced component <code>AttributeFilterCombobox</code> just from the usage, as
opposed to just <code>Dialog</code>, which you might have multiple of accross your
application.</p>  </div></div>
  </body>
</html>
