<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.thezdi.com/blog/2022/6/15/cve-2022-23088-exploiting-a-heap-overflow-in-the-freebsd-wi-fi-stack">Original</a>
    <h1>CVE-2022-23088: Exploiting a Heap Overflow in the FreeBSD Wi-Fi Stack</h1>
    
    <div id="readability-page-1" class="page"><div id="outerWrapper">

      

      <!--HEADER-->

      

      <!--SITE TITLE OR LOGO-->
      <div id="innerWrapper">

      <!--CONTENT INJECTION POINT-->
        <section id="content">
          <div data-content-field="main-content">
            <!-- CATEGORY NAV -->
            
            <div id="mainContent">
    

    <div>
        
        <div>
            <div>
                <div>
                    
                      <div>
                        <div data-layout-label="Post Body" data-type="item" data-updated-on="1655309078728" id="item-62aa028ed6cc4b6bc3635fac"><div><div><div data-block-type="2" id="block-0a9a23050eda1c49e92d"><p><em>In April of this year, FreeBSD patched a 13-year-old heap overflow in the Wi-Fi stack that could allow network-adjacent attackers to execute arbitrary code on affected installations of FreeBSD Kernel. This bug was originally reported to the ZDI program by a researcher known as m00nbsd and patched in April 2022 as  </em><a href="https://www.freebsd.org/security/advisories/FreeBSD-SA-22:07.wifi_meshid.asc" target="_blank"><em>FreeBSD-SA-22:07.wifi_meshid</em></a><em>. The researcher has graciously provided this detailed write-up of the vulnerability and a proof-of-concept exploit demonstrating the bug.</em></p></div><div data-block-type="2" id="block-yui_3_17_2_1_1654658670558_136169"><div><p>Our goal is to achieve kernel remote code execution on a target FreeBSD system using a heap overflow vulnerability in the Wi-Fi stack of the FreeBSD kernel. This vulnerability has been assigned CVE-2022-23088 and affects all FreeBSD versions since 2009, along with many FreeBSD derivatives such as <a href="https://www.pfsense.org/" target="_blank">pfSense</a> and <a href="https://opnsense.org/" target="_blank">OPNsense</a>. It was <a href="https://www.freebsd.org/security/advisories/FreeBSD-SA-22:07.wifi_meshid.asc" target="_blank">patched</a> by the FreeBSD project in April 2022.</p><p><strong>The Vulnerability</strong></p><p>When a system is scanning for available Wi-Fi networks, it listens for <em>management</em> frames that are emitted by Wi-Fi access points in its vicinity. There are several types of management frames, but we are interested in only one: the <em>beacon</em> management subtype. A beacon frame has the following format:</p>


</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_148921"><div><p>In FreeBSD, beacon frames are parsed in <code>ieee80211_parse_beacon()</code>. This function iterates over the sequence of options in the frame and keeps pointers to the options it will use later.</p>
<p>One option, <code>IEEE80211_ELEMID_MESHID</code>, is particularly interesting:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_169166"><p>There is no sanity check performed on the option length (<code>frm[1]</code>). Later, in  function <code>sta_add()</code>, there is a memcpy that takes this option length as size argument and a fixed-size buffer as destination:</p></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_170467"><div><p>Due to the lack of a sanity check on the option length, there is an ideal buffer overflow condition here: the attacker can control both the size of the overflow (<code>sp-&gt;meshid[1]</code>) as well as the contents that will be written (<code>sp-&gt;meshid</code>).</p>
<p>Therefore, when a FreeBSD system is scanning for available networks, an attacker can trigger a kernel heap overflow by sending a beacon frame that has an oversized <code>IEEE80211_ELEMID_MESHID</code> option.</p>
<p><b data-preserve-html-node="true">Building a “Write-What-Where” Primitive</b></p>
<p>Let’s look at <code>ise-&gt;se_meshid</code>, the buffer that is overflown during the memcpy. It is defined in the <code>ieee80211_scan_entry</code> structure:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_172319"><p>Here, the overflow of <code>se_meshid</code> allows us to overwrite the <code>se_ies</code> field that follows. The <code>se_ies</code> field is of type <code>struct ieee80211_ies</code>, defined as follows:</p></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_173562"><div><p>We will be interested in overwriting the last two fields: <code>data</code> and <code>len</code>.</p>
<p>Back in <code>sta_add()</code>, not long after the memcpy, there is a function call that uses the <code>se_ies</code> field:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_174785"><p>This <code>ieee80211_ies_init()</code> function is defined as:</p></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_175911"><p>The <code>data</code> parameter here points to the beginning of the beacon options in the frame, and <code>len</code> is the full length of all the beacon options. In other words, the (<code>data</code>,<code>len</code>) couple describes the <i data-preserve-html-node="true">options buffer</i> that is part of the frame that the attacker sent:</p></div><div data-block-type="5" id="block-yui_3_17_2_1_1654658670558_177070"><div>















  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          
        

        
          
          <figcaption>
            <p><em>Figure 1 - The Options Buffer</em></p>
          </figcaption>
        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_191538"><div><p>As noted in the code snippet, the <code>ies</code> structure is fully attacker-controlled thanks to the buffer overflow.</p>
<p>Therefore, at <code>$1</code>:</p>
<p>       -- We can control <code>len</code>, given that this is the full size of the <i data-preserve-html-node="true">options buffer</i>, and we can decide that size by just adding or removing options to our frame.</p>
<p>We thus have a near-perfect write-what-where primitive that allows us to write almost whatever data we want at whatever kernel memory address we want just by sending one beacon frame that has an oversized MeshId option.</p>
<p><b data-preserve-html-node="true">Constraints on the Primitive</b></p>
<p>A few constraints apply to the primitive:</p>
<ol>
<li><p>The FreeBSD kernel expects there to be <i data-preserve-html-node="true">SSID</i> and <i data-preserve-html-node="true">Rates</i> options in the frame. That means that there are 2x2=4 bytes of the <i data-preserve-html-node="true">options buffer</i> that we cannot control. In addition, our oversized MeshId option has a 2-byte header, so that makes 6 bytes we cannot control. For convenience and simplicity, we will place these bytes at the beginning of the options buffer.</p>
</li>
<li><p>Our oversized MeshId option must be large enough to overwrite up to the <code>ies-&gt;data</code> and <code>ies-&gt;len</code> fields, but not more. This equates to a length of 182 bytes for the MeshId option, plus its 2-byte header. To accommodate the MeshId option plus the two options mentioned above, we will use an <i data-preserve-html-node="true">options buffer</i> of size 188 bytes.</p>
</li>
<li><p>The <code>ies-&gt;data</code> and <code>ies-&gt;len</code> fields we overwrite are respectively the last 8 and 4 bytes within the options buffer, so they too are constrained.</p>
</li>
<li><p>The <code>ies-&gt;len</code> field must be equal to <code>len</code> for the branch at <code>$0</code> not to be taken.</p>
</li>
</ol>
<p>The big picture of what the frame looks like given the aforementioned constraints:</p>

</div></div><div data-block-type="5" id="block-yui_3_17_2_1_1654658670558_227519"><div>















  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          
        

        
          
          <figcaption>
            <p><em>Figure 2 - The Big Picture</em></p>
          </figcaption>
        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_228635"><div><p><b data-preserve-html-node="true">Maintaining stability of the target</b></p>
<p>Let’s say we send a beacon frame that uses the primitive to overwrite an area of kernel memory. There is going to be a problem at some point when the kernel subsequently tries to free <code>ies-&gt;data</code>. This is because <code>ies-&gt;data</code> is supposed to point to a malloc-allocated buffer, which may no longer be true after our overwrite.</p>
<p>To maintain stability and avoid crashing the target, we can send a second, corrective beacon frame that overflows <code>ies-&gt;data</code> to be NULL and <code>ies-&gt;len</code> to be 0. After that, when the kernel attempts to free <code>ies-&gt;data</code>, it will see that the pointer is NULL, and won’t do anything as a result. This allows us to maintain the stability of the target and ensure our primitive doesn’t crash it.</p>
<p><b data-preserve-html-node="true">Choosing what to write, and where to write it</b></p>
<p>Now we have a nice write-what-where primitive that we can invoke with just one beacon frame plus one corrective frame. What exactly can we do with it now?</p>
<p>A first thought might be to use the primitive to overwrite the instructions that the kernel executes in memory. (Un)fortunately, in FreeBSD, the kernel text segment is not writable, so we
cannot use our primitive to directly overwrite kernel instructions. Furthermore, the kernel implements W^X, so no writable pages are executable.</p>
<p>However, the page tables that map executable pages are writable. </p>
<p><b data-preserve-html-node="true">Injecting an implant</b></p>
<p>Here we are going to inject an implant into the target&#39;s kernel that will process &#34;commands&#34; that we send to it later on via subsequent Wi-Fi frames — a full kernel backdoor, if you will.</p>
<p>The process of injecting this implant will take four beacon frames.</p>
<p>This is a bit of a bumpy technical ride, so fasten your seatbelt.</p>
<p><b data-preserve-html-node="true">Frame 1: Injecting the payload</b></p>
<p><i data-preserve-html-node="true">Background: the direct map is a special kernel memory region that contiguously maps the entire physical memory of the system as writable pages, except for the physical pages of read-only text segments.</i></p>
<p>We use the primitive to write data at the physical address <code>0x1000</code> using the direct map:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_249108"><p><code>0x1000</code> was chosen as a convenient physical address because it is unused. The data we write is as follows:</p></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_250932"><div><p>The implant shellcode area contains the instructions of our implant. The rest of the fields are explained below.</p>
<p><b data-preserve-html-node="true">Frame 2: Overwriting an L3 PTE</b></p>
<p><i data-preserve-html-node="true">Quick Background: x64 CPUs use page tables to map virtual addresses to physical RAM pages, in a 4-level hierarchy that goes from L4 (root) to L0 (leaf). Refer to the official AMD and Intel specifications for more details.</i></p>
<p>In this step, we use the primitive to overwrite an L3 page table entry (PTE) and make it point to the L2 PTE that we wrote at physical address 0x1000 as part of Frame 1. We crafted that L2 PTE precisely to point to our three L1 PTEs, which themselves point to two different areas: (1) two physical pages of the kernel text segment, and (2) our implant shellcode.</p>
<p>In other words, by overwriting an L3 PTE, we create a branch in the page tables that maps two pages of kernel text as writable and our shellcode as executable:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_253464"><div><p>At this point, our shellcode is mapped into the target’s virtual memory space and is ready to be executed. We will see below why we&#39;re mapping the two pages of the kernel text segment.</p>
<p><i data-preserve-html-node="true">The attentive reader may be concerned about the constraints of the primitive here. Nothing to worry about: the L3 PTE space is mostly unpopulated. We just have to choose an unpopulated range where overwriting 188 bytes will not matter.</i></p>
<p><b data-preserve-html-node="true">Frame 3: Patching the text segment</b></p>
<p>In order to jump into our newly mapped shellcode, we will patch the beginning of the <code>sta_input()</code> function in the text segment. This function is part of the Wi-Fi stack and gets called each time the kernel receives a Wi-Fi frame, so it seems like the perfect place to invoke our implant.</p>
<p>How can we patch it, given that the kernel text segment is not writable? By mapping as writable the text pages that contain the function. This is what we did in frames 1 and 2, with the first two L1 PTEs, that now give us a <i data-preserve-html-node="true">writable view</i> of the instruction bytes of <code>sta_input()</code>:</p>

</div></div><div data-block-type="5" id="block-yui_3_17_2_1_1654658670558_255212"><div>















  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          
        

        
          
          <figcaption>
            <p><em>Figure 6 - Our writable view of sta_input()</em></p>
          </figcaption>
        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_256316"><p>Back on topic, we use the primitive to patch the first bytes of <code>sta_input()</code> via the writable view we created in frames 1 and 2, and replace these bytes with:</p></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_257443"><div><p>This simply calls our shellcode. However, the constraints of our primitive come into play:</p>
<ol>
<li>The first constraint of the primitive is that the first 6 bytes that we overwrite cannot be controlled. Overwriting memory at <code>sta_input</code> would not be great, as it would put 6 bytes of garbage at the beginning of the function, causing the target to crash.</li>
</ol>
<p>However, if we look at the instruction dump of <code>sta_input</code>, we can see that it actually has a convenient layout:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_258647"><div><p>What we can do here is overwrite memory at <code>sta_input-6</code>. The 6 bytes of garbage will just overwrite the unreachable <code>NOP</code>s of the previous <code>sta_newstate()</code> function, with no effect on execution.</p>
<p>With this trick, we don’t have to worry about these first 6 bytes, as they are effectively discarded.</p>
<ol start="2">
<li><p>The second constraint of the primitive is that we are forced to overwrite exactly 182 bytes, so we cannot overwrite the first few bytes only. This is not really a problem. We can just fill the rest of the bytes with the same instruction bytes that are there in memory already.</p>
</li>
<li><p>The third constraint of the primitive is that the last 12 bytes that we write are the <code>ies-&gt;data</code> and <code>ies-&gt;len</code> fields, and these don’t disassemble to valid instructions. That’s a problem because these bytes are within <code>sta_input()</code>. If the kernel tries to execute these bytes, it won’t be long before it crashes. To work around this, we must have corrective code in our implant. When called for the first time, our implant must correct the last 12 bytes of garbage that we wrote into <code>sta_input()</code>. Although slightly annoying, this is not complicated to implement.</p>
</li>
</ol>
<p>With all that established, we’re all set. Our implant will now execute each time <code>sta_input()</code> is called, meaning, each time a Wi-Fi frame is received by the target!</p>
<p><b data-preserve-html-node="true">Frame 4: Corrective frame</b></p>
<p>Finally, to maintain the stability of the target, we send a final beacon frame where we overflow <code>ies-&gt;data</code> to be NULL and <code>ies-&gt;len</code> to be 0.</p>
<p>This ensures that the target won’t crash.</p>
<p><b data-preserve-html-node="true">Subsequent communication channel</b></p>
<p>With the aforementioned four frames, we have a recipe to reliably inject an implant into the target’s kernel. The implant gets called in the same context as <code>sta_input()</code>:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_283157"><div><p>Notably, the second argument, <code>m</code>, is the memory region containing the buffer of the frame that the kernel is currently processing. The implant can therefore inspect that buffer (via <code>%rsi</code>) and act depending on its contents.</p>
<p>In other words, we have a communication channel with the implant. We can therefore code our implant as a <i data-preserve-html-node="true">server</i> backdoor and send <i data-preserve-html-node="true">commands</i> to it via this channel.</p>
<p><b data-preserve-html-node="true">Full steps</b></p>
<p>Let’s recap:</p>
<ol>
<li>A heap buffer overflow vulnerability exists in the FreeBSD kernel. An attacker can trigger this bug by sending a beacon frame with an oversized MeshId option.</li>
<li>Using that vulnerability, we can implement a write-what-where primitive that allows us to perform one kernel memory overwrite per beacon frame we send.</li>
<li>We can use that primitive three times to inject an implant into the target’s kernel.</li>
<li>A fourth beacon frame is used to clean up <code>ies-&gt;data</code> and <code>ies-&gt;len</code>, to prevent a crash.</li>
<li>Finally, our implant runs in the kernel of the target and acts as a full backdoor that can process subsequent Wi-Fi frames we send to it.</li>
</ol>
<p><b data-preserve-html-node="true">The Exploit</b></p>
<p>A full exploit can be found <a href="https://github.com/thezdi/PoC/tree/master/CVE-2022-23088">here</a>. It injects a simple implant that calls <code>printf()</code> with the strings that the attacker subsequently sends. To use this exploit from a Linux machine that has a Wi-Fi card called wifi0, switch the card to monitor mode with:</p>

</div></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_287334"><p>Then, build and run the exploit for the desired target. For example, if you wish to target a pfSense 2.5.2 system:</p></div><div data-block-type="44" id="block-yui_3_17_2_1_1654658670558_288446"><div><p><b data-preserve-html-node="true"><i data-preserve-html-node="true">Please exercise caution - this will exploit all vulnerable systems in your vicinity.</i></b></p>
<p>Once you have done this, look at the target’s tty0 console. You should see: “Hello there, I’m in the kernel”. </p>

</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1654658670558_289449"><p><em>Thanks again to m00nbsd for providing this thorough write-up. They have contributed multiple bugs to the ZDI program over the last few years, and we certainly hope to see more submissions from them in the future. Until then, follow the </em><a href="https://twitter.com/thezdi" target="_blank"><em>team</em></a><em> for the latest in exploit techniques and security patches.</em></p></div></div></div></div>
                      </div>

                       
                        <ul>
                          
                            <!--TAGS-->
                            
                              <li><a href="https://www.thezdi.com/blog?tag=FreeBSD">FreeBSD</a></li>
                            
                              <li><a href="https://www.thezdi.com/blog?tag=Kernel">Kernel</a></li>
                            
                              <li><a href="https://www.thezdi.com/blog?tag=Research">Research</a>
                          
                        </li></ul>
                      
                   
                    
                </div>
                
            </div><!-- /. contentBlock -->
        </div>

        
    </div><!-- /. blog-listing -->
</div>
          </div>
        </section>

        
        
        

        

        <!--FOOTER WITH OPEN BLOCK FIELD-->
        

        

    <!--INJECTION POINT FOR TRACKING SCRIPTS AND USER CONTENT FROM THE CODE INJECTION TAB-->

    
    </div> <!-- end #innerWrapper -->
    </div></div>
  </body>
</html>
