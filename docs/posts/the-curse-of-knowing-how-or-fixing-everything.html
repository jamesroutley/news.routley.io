<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notashelf.dev/posts/curse-of-knowing">Original</a>
    <h1>The curse of knowing how, or; fixing everything</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-gjtny2mx="">  <p>It starts innocently.</p>
<p>You rename a batch of files with a ten-line Python script, or you alias a common
<code>git</code> command to shave off two keystrokes. Maybe you build a small shell
function to format JSON from the clipboard.</p>
<p>You’re not even trying to be clever. You’re just solving tiny problems. Making
the machine do what it should have done in the first place. And then something
happens. You cross a <em>threshold</em>. You look at your tools, your environment, your
operating system—even your editor—and suddenly <strong>everything</strong> is fair game.</p>
<p>You <em>could</em> rebuild that (if you wanted to).</p>
<p>Then someone challenges you. As banter maybe, perhaps jokingly but also with a
dash of hope. Then the air in the room changes.</p>
<p>It suddenly becomes something else. It becomes:</p>
<p>You <em>should</em>.</p>
<p>And from that moment forward, the world is broken in new and specific ways that
only <em>you</em> can see.</p>
<h2 id="technical-capability-as-a-moral-weight">Technical Capability as a Moral Weight</h2>
<p>Before I could program, broken software was frustrating but ignorable. For years
I’ve simply “used” a computer, as a consumer. I was what companies were
concerned with tricking into buying their products, or subscribing to their
services. Not the technical geek that they prefer to avoid with their software
releases, or banning from their games based on an OS.</p>
<p>Now it has become <em>provocative</em>. I can see the patterns that I wish I couldn’t,
find oversights that I can attribute to a certain understanding (or the lack
thereof) of a certain concept and I can <em>hear</em> what has been echoing in the head
of the computer illiterate person who conjured the program I have to debug.</p>
<p>I notice flaws like a good surgeon notices a limp.</p>
<p>Those things are <em>not</em> just questions, they are <em>accusations</em>. And,
unfortunately, they do not stop.</p>
<p>Now that I’ve learned to notice, my perception of software has changed in its
entirety.</p>
<p>Every piece of software becomes a TODO list.</p>
<h2 id="one-must-imagine-sisyphus-happy">One Must Imagine Sisyphus Happy</h2>
<p>Like Camus’ Sisyphus, we are condemned to push the boulder of our own systems
uphill—one fix, one refactor, one script at a time. But unlike the story of
Sisyphus, the curse is not placed onto you by some god. We built the boulder
ourselves. And we keep polishing it on the way up.</p>
<p>I’ve lost count of how many projects I have started that began with some
variation of “Yeah, I could build this <em>but better</em>.”</p>
<ul>
<li>A static site generator because the existing ones had too many opinions.</li>
<li>A note-taking tool because I didn’t like the way others structured metadata.</li>
<li>A CLI task runner because Make is cryptic and Taskfile is YAML hell.</li>
<li>A personal wiki engine in Rust, then in Go, then in Nim, then back to
Markdown.</li>
<li>A homelab dashboard because I don’t like webslop.</li>
</ul>
<p>The list continues, and trust me it <em>does</em> continue. My dev directory, as it
stands, is nearing 30 gigabytes.</p>
<p>If you ask me, I was solving real, innocent problems. But in hindsight, I was
also feeding something else: a compulsion to assert control. Every new tool I
built was a sandbox I <em>owned</em>: No weird bugs. No legacy constraints. No
decisions I didn’t entirely agree with. Until, of course, I became the legacy.</p>
<p>Kafka once wrote that “<strong>a cage went in search of a bird</strong>.” <sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup> That is what
these projects can become. Empty systems we keep building, waiting for purpose,
for clarity, for… salvation? I’m not sure how else would you call this
pursuit.</p>
<h2 id="entropy-is-undefeated">Entropy Is Undefeated</h2>
<p>Now let’s go back. Back to when we didn’t know better.</p>
<p>Software doesn’t stay solved. Every solution you write starts to rot the moment
it exists. Not now, not later, but eventually. Libraries deprecate. APIs change.
Performance regressions creep in. Your once-perfect tool breaks silently because
<code>libfoo.so</code> is now <code>libfoo.so.2</code>. <sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref="" aria-describedby="footnote-label">2</a></sup></p>
<p>I <em>have</em> had scripts silently fail because a website changed its HTML layout.</p>
<p>In each case, the immediate emotional response was not just inconvenience but
something that moreso resembles <em>guilt</em>. I built this, and I do know better. How
could I not have foreseen this? Time to fix it.</p>
<p>If you replace every part of the system over time, is it still the same tool?
Does it still serve the same purpose? Do <em>you</em>?</p>
<h2 id="the-illusion-of-finality">The Illusion of Finality</h2>
<p>I think we lie to ourselves.</p>
<blockquote>
<p>“If I just get this setup right, I’ll never have to touch it again.&#34;</p>
</blockquote>
<p>It is, I admit, a seductive lie. It frames programming as a conquest of sorts. A
series of battles you win, or challenges you complete. But the imaginary war
never ends. You don’t build a castle. You dig trenches. And they flood every
time it rains. The trials are <em>never</em> complete.</p>
<h2 id="technical-work-as-emotional-regulation">Technical Work as Emotional Regulation</h2>
<p>On the theme of filling this post with literary references, let me quote the
Stoic Marcus Aurelius.</p>
<blockquote>
<p>You have power over your mind—not outside events. Realize this, and you will
find strength.</p>
</blockquote>
<p>But programming lures us into believing we <em>can</em> control the outside events.
That is where the suffering begins. There is something deeper happening here.
This is <em>not</em> just about software.</p>
<p>I believe sometimes building things is how we self-soothe. We write a new tool
or a script because we are in a desperate need for a small victory. We write a
new tool because we are overwhelmed. Refactor it, not because the code is messy,
but your life is. We chase the perfect system because it gives us something to
hold onto when everything else is spinning. This is the lesson I’ve taken from
using NixOS.</p>
<p>I have written entire applications just to avoid thinking about why I was
unhappy. Programming gives you instant feedback. You run the thing, and it
works. Or it <em>doesn’t</em>, and you fix it. Either way, you’re <em>doing something</em>.</p>
<p>That kind of agency is addictive. Especially when the rest of life doesn’t offer
it. We program because we <em>can</em>, even when we shouldn’t. Because at least it
gives us something to rebel against.</p>
<h2 id="the-burnout-you-dont-see-coming">The Burnout You Don’t See Coming</h2>
<p>Burnout does not just come from overwork. It comes from <em>overresponsibility</em>.</p>
<p>And programming, once internalized deeply enough, makes everything feel like
your responsibility. The bloated website. The inefficient script. The clunky
onboarding process at your job. You <em>could</em> fix it. So why aren’t you?</p>
<p>The truth you are very well aware of is that you can’t fix it all. You <em>know</em>
this, you always knew it regardless of your level of skill. But try telling that
to the part of your brain that sees every inefficiency as a moral failing.</p>
<p>Nietzsche warned of gazing too long into the abyss. But he didn <em>not</em> warn what
happens when the abyss is a <code>Makefile</code> or a 30k line of code Typescript project.</p>
<h2 id="learning-to-let-go">Learning to Let Go</h2>
<p>So where is the exit? Is this akin to Sartre’s depiction of hell, where hell
<em>is</em> other people and how they interact with your software? Or is it some weird
backwards hell where people create software that you have to interact with?</p>
<p>The first step is recognizing that <em>not everything broken is yours to fix</em>.</p>
<p>Sometimes, it’s OK to just <em>use</em> the thing. Sometimes it’s enough to know <em>why</em>
it’s broken—even if you don’t fix it. Sometimes the most disciplined thing you
can do is <em>walk away</em> from the problem you know how to solve. There’s a kind of
strength in that.</p>
<p>Not apathy, no. Nor laziness. Just… some restraint.</p>
<h2 id="a-new-kind-of-skill">A New Kind of Skill</h2>
<p>What if the real skill isn’t technical mastery? Or better yet what if it’s
emotional clarity?</p>
<ul>
<li>Knowing which problems are worth your energy.</li>
<li>Knowing which projects are worth maintaining.</li>
<li>Knowing when you’re building to help—and when you’re building to cope.</li>
<li>Knowing when to stop.</li>
</ul>
<p>This is what I’m trying to learn now. After the excitement. After the obsession.
After the burnout. I’m trying to let things stay a little broken. Because I’ve
realized I don’t want to <em>fix everything</em>. I just want to feel OK in a world
that often isn’t. I can fix something, but not everything.</p>
<hr/>
<p>You learn how to program. You learn how to fix things. But the hardest thing
you’ll ever learn is when to <em>leave them broken</em>.</p>
<p>And maybe that’s the most human skill of all.</p>
  </div></div>
  </body>
</html>
