<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flawless.dev/essays/when-letting-it-crash-is-not-enough/">Original</a>
    <h1>When &#34;letting it crash&#34; is not enough</h1>
    
    <div id="readability-page-1" class="page"><div>
        <header>
            <a href="https://flawless.dev/">
                <img src="https://flawless.dev/img/logo.png" alt="Flawless Logo, a beautiful woman with freckles head illustration."/>
                <span>flawless</span><span>.dev</span>
            </a>
        </header>

        
<section>
    
<!-- Dealing with failure in complex computer systems mostly comes down to following your
human intuition. If a website is unavailable, what do you usually do? Just wait a bit and
try again. Still can't open it? Wait a bit more, maybe try again tomorrow. This approach
somewhat describes a popular technique used by libraries to re-try failed HTTP requests,
called exponential backoff.

Humans are great at dealing with failure. We have been growing up in the real world where
everything can go wrong, and our brains will easily pattern match the most effective way
of recovery to a specific failure. -->
<p>When it comes to computer systems, The <a href="https://www.erlang.org">Erlang/OTP</a> programming platform has an
interesting approach to failure handling. It&#39;s also widely known under the name &#34;let it
crash&#34;. The core idea behind it has to do with the fact that modern applications have a
huge number of states that they can find themselves in. The more complex your application
is, the more variables you need to keep track of everything. Eventually it becomes
impossible for developers to predict all combinations of state that these variables will
form. Once your app gets into an undesirable state, the best thing you can do is to reset
it and start from a fresh, well known and correct state.</p>
<p>This works amazingly well together with Erlang&#39;s property that each process has a separate
memory space. Allowing us to selectively reset only parts of our application, while
keeping the system as a whole running. Then we can divide the application into a tree-like
structure and keep restarting parts of it until we reach the root and are forced to
restart the whole thing. This concept is also known as <a href="https://www.erlang.org/doc/design_principles/des_princ">supervision trees</a>.</p>
<p>If you take a closer look at Erlang&#39;s approach, this is exactly what a human would do. If
your phone gets stuck playing a video, you will try restarting the app, and if this
doesn&#39;t fix it, you might end up restarting your phone. Or even the router of your home
internet connection. You intuitively know that propagating the failure through your home
will eventually bring all devices into a state that resembles the one when you first set
everything up and everything was working.</p>
<span>
Even sometimes Erlang&#39;s claims around resilience and fault tolerance are a bit
<b><a href="https://stackoverflow.com/a/26447543" target="_blank">overblown</a></b>, I
still think that it&#39;s a very powerful way to deal with failure.</span> If my web app
breaks, the first thing I do is to restart the server. In the majority of cases this
immediately fixes the issue, while I dive deeper into the logs trying to figure out what
went wrong. Having this automatic restarting capability at every level of abstraction in
your app, will definitely help you sleep better.
<p>However, resetting the state is almost never enough. In the phone example, once the phone
starts up again, you still need to get back into the state where you stopped. This usually
means finding the video again and jumping back to the right point on the timeline. We are
partially reconstructing the state where we stopped, but ignoring all the other state
where things might have gone wrong, like our home internet connection being broken.</p>
<p>For humans, it&#39;s easy to approximately remember where we stopped watching a video, but for
an application it&#39;s impossible to reconstruct the state without the developer explicitly
keeping track of it. How to snapshot your state, where to store it and how often to do it,
are very difficult questions. Even with very frequent snapshots, with my luck, it would
probably fail in between snapshots and result in data loss. The only way of having total
confidence in such a system is if <strong>every</strong> state change is captured.</p>
<h3 id="durable-execution">Durable Execution</h3>
<p>This brings me to a recent discovery I made, another approach to dealing with failure that
completely blew my mind ðŸ¤¯. It&#39;s commonly known under the name durable execution, and it&#39;s
an elegant solution to the &#34;keeping track of state changes&#34; problem, and perfectly
complements Erlang&#39;s approach.</p>
<p>The simplest way of thinking of it is as <span>a database for compute
progression</span>. It stores the minimal amount of data to be able to reconstruct your
application&#39;s sate at any time. It makes your local variables indestructible, and for many
scenarios you will not even require a traditional database anymore.</p>
<p>Imagine if you could just start an arbitrary computation and the system guarantees that
it will run until completion and all the operations will be performed <strong>exactly once</strong>.
Even if your app needs to be restarted in the middle. Or even if you need to stop the
computation, move it to a different machine and continue. <span> Your
running code suddenly becomes this tangible thing, that you can look at, move and play
with.</span></p>
<p>Durable execution is more of a general purpose technology that can be used for different
use cases, like transactions across distributed services, or very long-running jobs
(months), but the underlying guarantees also make it the ultimate tool to create snapshots
for picking up where you stopped in case you need to partially restart your system.</p>
<p>I have been working on my own engine for durable execution called <strong><a href="https://flawless.dev">flawless</a></strong>. It
implicitly keeps a log of side effects, so that you always can reconstruct the latest
state and pick up where you left off. It&#39;s still in private alpha, but I hope to soon
open it up and share with everyone.</p>
<p>~ <a href="https://twitter.com/bkolobara">Bernard</a></p>

</section>

    </div></div>
  </body>
</html>
