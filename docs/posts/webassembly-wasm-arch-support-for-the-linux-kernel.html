<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/joelseverin/linux-wasm">Original</a>
    <h1>WebAssembly (WASM) arch support for the Linux kernel</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This project contains scripts to download, build and run a Linux system that can executed on the web, using native WebAssembly (Wasm).</p>
<p dir="auto">These scripts can be run in the following way:</p>
<ul dir="auto">
<li>Directly on a host machine.</li>
<li>In a generic docker container.</li>
<li>In a specific docker container (see Dockerfile).</li>
</ul>

<p dir="auto">The project is built and assembled from following pieces of software:</p>
<ul dir="auto">
<li>LLVM Project:
<ul dir="auto">
<li>Base version: 18.1.2</li>
<li>Patches:
<ul dir="auto">
<li>A hack patch that enables GNU ld-style linker scripts in wasm-ld.</li>
</ul>
</li>
<li>Artifacts: clang, wasm-ld (from lld), compiler-rt</li>
</ul>
</li>
<li>Linux kernel:
<ul dir="auto">
<li>Base version: 6.4.16</li>
<li>Patches:
<ul dir="auto">
<li>A patch for adding Wasm architecture support to the kernel.</li>
<li>A wasm binfmt feature patch, enabling .wasm files to run as executables.</li>
<li>A console driver for a Wasm &#34;web console&#34;.</li>
</ul>
</li>
<li>Artifacts: vmlinux, exported (unmodified) kernel headers</li>
<li>Dependencies: clang, wasm-ld with linker script support, (compiler-rt is <em>not</em> needed)</li>
</ul>
</li>
<li>musl:
<ul dir="auto">
<li>Base version: 1.2.5</li>
<li>Patches:
<ul dir="auto">
<li>A hack patch (minimal and incorrect) that:
<ul dir="auto">
<li>Adds Wasm as a target to musl (I guessed and cheated a lot on this one).</li>
<li>Allows musl to be built using clang and wasm-ld (linker script support may be needed).</li>
</ul>
</li>
</ul>
</li>
<li>Atifacts: musl libc</li>
<li>Dependencies: clang, wasm-ld, compiler-rt</li>
</ul>
</li>
<li>Linux kernel headers for BusyBox
<ul dir="auto">
<li>Base version: from the kernel</li>
<li>Patches:
<ul dir="auto">
<li>A series of patches, originally hosted by Sabotage Linux, but modified to suit a newer kernel. These patches allow BusyBox to include kernel headers (which is not really supported by Linux). This magically just &#34;works&#34; with glibc but needs modding for musl.</li>
</ul>
</li>
<li>Artifacts: modified kernel headers</li>
<li>Dependencies: exported Linux kernel headers</li>
</ul>
</li>
<li>BusyBox:
<ul dir="auto">
<li>Base version: 1.36.1</li>
<li>Patches:
<ul dir="auto">
<li>A hack patch (minimal and incomplete) that:
<ul dir="auto">
<li>Allows BuxyBox to be built using clang and wasm-ld (linker script support might be unnecessary).</li>
<li>Adds a Wasm defconfig.</li>
</ul>
</li>
</ul>
</li>
<li>Artifacts: BusyBox installation (base binary and symlinks for ls, cat, mv etc.)</li>
<li>Dependencies: musl libc, modified headers for BusyBox</li>
</ul>
</li>
<li>A minimal initramfs:
<ul dir="auto">
<li>Notes:
<ul dir="auto">
<li>Packages up the busybox installation into a compessed cpio archive.</li>
<li>It sets up a pty for you (for proper signal/session/job management) and drops you into a shell.</li>
</ul>
</li>
<li>Artifacts: initramfs.cpio.gz</li>
<li>Dependencies: BusyBox installation</li>
</ul>
</li>
<li>A runtime:
<ul dir="auto">
<li>Notes:
<ul dir="auto">
<li>Some example code of how a minimal JavaScript Wasm host could look like.</li>
<li>Error handling is not very graceful, more geared towards debugging than user experience.</li>
<li>This is the glue code that kicks everything off, spawns web workers, creates Wasm instances etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p dir="auto">Hint: Wasm lacks an MMU, meaning that Linux needs to be built in a NOMMU configuration. Wasm programs thus need to be built using -fPIC/-shared. Alternatively, existing Wasm programs can run together with a proxy that does syscalls towards the kernel. In such a case, each thread that wishes to independently execute syscalls should map to a thread in the proxy. The drawback of such an approach is that memory cannot be mapped and shared between processes. However, from a memory protection standpoint, this property could also be beneficial.</p>

<p dir="auto">Run ./linux-wasm.sh to see usage. Downloads happen first, building afterwards. You may partially select what to download or (re)-build.</p>
<p dir="auto">Due to a bug in LLVM&#39;s build system, building LLVM a second time fails when building runtimes (complaining that clang fails to build a simple test program). A workaround is to build it yet again (it works each other time, i.e. the 1st, 3rd, 5th etc. time).</p>
<p dir="auto">Due to limitations in the Linux kernel&#39;s build system, the absolute path of the cross compiler (install path of LLVM) cannot contain spaces. Since LLVM is built by linux-wasm.sh, it more or less means its workspace directory (or at least install directory) has to be in a space free path.</p>

<p dir="auto">The following commands should be executed in this repo root.</p>
<p dir="auto">There are two containers:</p>
<ul dir="auto">
<li><strong>linux-wasm-base</strong>: Contains an Ubuntu 20.04 environment with all tools installed for building (e.g. cmake, gcc etc.).</li>
<li><strong>linux-wasm-contained</strong>: Actually builds everything into the container. Meant as a dispoable way to build everything isolated.</li>
</ul>
<p dir="auto">Create the containers:</p>
<div data-snippet-clipboard-copy-content="docker build -t linux-wasm-base:dev ./docker/linux-wasm-base
docker build -t linux-wasm-contained:dev ./docker/linux-wasm-contained"><pre><code>docker build -t linux-wasm-base:dev ./docker/linux-wasm-base
docker build -t linux-wasm-contained:dev ./docker/linux-wasm-contained
</code></pre></div>
<p dir="auto">Note that the latter command will copy linux-wasm.sh, in its current state, into the container.</p>
<p dir="auto">To launch a simple docker container with a mapping to host (recommended for development):</p>
<div data-snippet-clipboard-copy-content="docker run -it --name my-linux-wasm --mount type=bind,src=&#34;$(pwd)&#34;,target=/linux-wasm linux-wasm-base:dev bash
(Inside the bash prompt, run for example:) /linux-wasm/linux-wasm.sh all"><pre><code>docker run -it --name my-linux-wasm --mount type=bind,src=&#34;$(pwd)&#34;,target=/linux-wasm linux-wasm-base:dev bash
(Inside the bash prompt, run for example:) /linux-wasm/linux-wasm.sh all
</code></pre></div>
<p dir="auto">To actually build everything inside the container (mostly useful for build servers):</p>
<div data-snippet-clipboard-copy-content="docker run -it -name full-linux-wasm linux-wasm-contained:dev /linux-wasm/linux-wasm.sh all"><pre><code>docker run -it -name full-linux-wasm linux-wasm-contained:dev /linux-wasm/linux-wasm.sh all
</code></pre></div>
<p dir="auto">To change workspace folder, docker run -e LW_WORKSPACE=/path/to/workspace ...blah... can be used. This may be useful together with docker volumes.</p>
</article></div></div>
  </body>
</html>
