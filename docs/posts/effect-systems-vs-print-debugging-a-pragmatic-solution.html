<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.flix.dev/blog/effect-systems-vs-print-debugging/">Original</a>
    <h1>Effect Systems vs. Print Debugging: A Pragmatic Solution</h1>
    
    <div id="readability-page-1" class="page"><section><blockquote>
<p><strong>&#34;Every lie we tell incurs a debt to the truth. Sooner or later, that debt is paid.&#34;</strong></p>
</blockquote>
<p>— Valery Legasov (<em>Jared Harris, Chernobyl 2019</em>)</p>
<p>Lying to a <strong>type system</strong> works the same way: the truth eventually comes out.
In memory-safe languages, that usually means as a runtime error (e.g. a
<code>ClassCastException</code>, a <code>TypeError: foo is not a function</code>, and so on). In
memory-unsafe languages, the consequences can be more dire: corrupted data,
segmentation faults, or arbitrary code execution. Nevertheless, if we are in a
memory-safe language, we might not feel too bad about lying to the type
system...</p>
<p>But what happens when you lie to the <strong>effect system</strong>? Nothing good.</p>
<p>To understand why, let us examine how the Flix compiler uses the effect system:</p>
<p><strong>Dead code elimination:</strong> Flix uses the effect system to identify expressions,
statements, and let-bindings that have no side effects and whose results are
unused. The compiler removes such code, improving performance and reducing
binary size.</p>
<p><strong>Inlining and value propagation:</strong> Flix also uses the effect system to
determine which let-bindings can be safely inlined without changing program
semantics. This enables constant folding and closure elimination.</p>
<p><strong>Automatic parallelization:</strong> The Flix compiler, in cooperation with the Flix
Standard Library, automatically parallelizes a selected set of higher-order
functions when their arguments are pure, and when parallel evaluation preserves
program semantics.</p>
<p><strong>Separating control-pure from control-impure code:</strong> Flix uses effect tracking
to distinguish code that may trigger effects and handlers from purely
computational code. Control-pure code is compiled without capturing the
delimited continuation, while control-impure code includes the machinery
required to reify the stack.</p>
<p>These are scary program transformations!</p>
<p>Hence, when a Flix programmer writes a function:</p>
<pre data-lang="flix"><code data-lang="flix">def add(x: Int32, y: Int32): Int32 \ { } = x + y
                                  // ^^^ empty effect set
</code></pre>
<p>We — the Flix language designers — are downright paranoid about ensuring that
the effects of the function are not a lie. <em>But surely one little white lie is
okay</em>, you suggest, as you carelessly add that <code>unchecked_cast</code> to your program,
while I look on with dark visions of unspeakable cosmic horror.</p>
<p>Interlude...</p>
<h2 id="print-debugging">Print Debugging</h2>
<p>One beautiful autumn afternoon, Jim was sitting in front of his computer.
Outside, the leaves were turning brilliant shades of orange, while inside, a
freshly brewed cup of coffee sat beside him. He had just finished reading a blog
post on HackerNews about a new programming language with a type and effect
system: Flix.</p>
<p>Intrigued, he downloaded the compiler and typed:</p>
<pre data-lang="flix"><code data-lang="flix">def main(): Int32 \ IO = 
    println(&#34;Hello World!&#34;);
    sum(123, 456)

def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    println(&#34;The sum of ${x} and ${y} is ${result}&#34;);
    result
</code></pre>
<p>Running the Flix compiler, Jim was confronted with:</p>
<pre data-lang="sh"><code data-lang="sh">❌ -- Type Error --

&gt;&gt; Unable to unify the effect formulas: &#39;IO&#39; and &#39;Pure&#39;.

6 |&gt; def sum(x: Int32, y: Int32): Int32 = ...
</code></pre>
<p>Dismayed, Jim poked around a bit but couldn’t get the program to work.
Frustrated, he returned to HackerNews and posted a comment:</p>
<blockquote>
<p>Ever tried adding a simple print statement for debugging purposes while coding
in effectful lang? compiler: &#34;NNNOOOO!!!! THIS IS AN ERROR; I WILL NEVER
COMPILE THIS NONSENSE YOU MUST SPECIFY THE <code>CONSOLE</code> EFFECT WAAARGH&#34;</p>
</blockquote>
<h2 id="being-a-programming-language-designer-is-hard">Being a Programming Language Designer is Hard</h2>
<p>The art of programming language design is to balance contradictory requirements:</p>
<ul>
<li>Programmers expect lightning-fast compilation, but also deep, aggressive
compiler optimizations. (&#34;The compiler is too slow!&#34; vs. &#34;Surely the compiler
will optimize that away!&#34;)</li>
<li>Programmers want expressive type systems, but also intuitive and helpful error
messages. (&#34;What do you mean a skolem variable escapes its scope???&#34;)</li>
<li>Programmers want type inference, but also simple type error messages (&#34;What do
you mean you can&#39;t unify these types?&#34;)</li>
<li>Programmers want escape hatches for everything, but nothing must ever break.
(&#34;What do you mean turning off the fuel for the engines crashes the plane? I
thought you said this was a safe airplane?!&#34;)</li>
</ul>
<p>Returning to earth: we may be academics, but <strong>we are trying to build a real
programming language. That means listening to our users and that means
we have to support print debugging.</strong> The question is <em>how</em>?</p>
<h2 id="print-debugging-attempt-1">Print-Debugging — Attempt #1</h2>
<p>Consider if we introduce a special function:</p>
<pre data-lang="flix"><code data-lang="flix">mod Debug {
    pub def dprintln(x: a): Unit with ToString[a] =
        unchecked_cast(println(x) as _ \ {}) 
}
</code></pre>
<p>Here we use an <code>unchecked_cast</code> to discard the <code>IO</code> effect of <code>println</code>. That
is, we <em>lie</em> to the effect system.</p>
<p>While our special <code>dprintln</code> function type and effect checks, it does not work
well.</p>
<p>If we attempt to use it as follows:</p>
<pre data-lang="flix"><code data-lang="flix">def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    Debug.dprintln(&#34;The sum of ${x} and ${y} is ${result}&#34;);
    result
</code></pre>
<p>The Flix compiler rejects our program with the error:</p>
<pre data-lang="sh"><code data-lang="sh">❌ -- Redundancy Error --

&gt;&gt; Useless expression: It has no side-effect(s) and its result is discarded.

11 |         Debug.dprintln(&#34;The sum of ${x} and ${y} is ${result}&#34;);
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             useless expression.
</code></pre>
<p>The compiler <em>correctly</em> reports that <code>dprintln</code> is a useless expression: it has
no observable effects and its result is ignored. This redundancy check is
normally helpful for catching bugs, but in this case it prevents our use of
<code>dprintln</code>.</p>
<p>We can try to work around this check with a small trick:</p>
<pre data-lang="flix"><code data-lang="flix">def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    let _ = Debug.dprintln(&#34;The sum of ${x} and ${y} is ${result}&#34;);
    result
</code></pre>
<p>By introducing a let binding with a wildcard name, the redundancy checker is
satisfied and the program now compiles.</p>
<p>However, when we run the program... nothing is printed!</p>
<p>Now, the optimizer detects that the let-bound expression has no side effects and
that its variable is unused, so it removes it. Normally this is desirable; we
want the optimizer to eliminate dead code, but here it gets in our way.</p>
<p>It seems we are stuck. There are two paths forward:</p>
<ul>
<li>
<p>We could try to equip the optimizer with knowledge of print debugging
statements. In that case, we would track these &#34;effects-that-are-not-effects&#34;
and avoid treating them as pure expressions. The problem with this approach is
that it would have to handle the entire language—e.g., lambda expressions,
higher-order functions, and polymorphism. In effect (no pun intended), we
would essentially be re-implementing an ad hoc effect system inside the
optimizer.</p>
</li>
<li>
<p>We could decide to <em>disable</em> the optimizer during development. The problem
with that is threefold: (a) it would cause a massive slowdown in runtime
performance, (b) somewhat surprisingly, it would also make the Flix compiler
itself run <em>slower</em>, since dead code elimination and other optimizations
actually speed up the backend, and (c) it would be fertile ground for compiler
bugs, because instead of one battle-tested compiler pipeline, there would be two
pipelines to develop and maintain.</p>
</li>
</ul>
<p>Neither option is really acceptable to us.</p>
<h2 id="print-debugging-attempt-2">Print-Debugging — Attempt #2</h2>
<p>What we need is a better lie: one with a different set of trade-offs.</p>
<p>We introduce a <code>Debug</code> effect and use it for <code>dprintln</code>:</p>
<pre data-lang="flix"><code data-lang="flix">eff Debug { /* empty -- marker effect */ }

mod Debug {
    pub def dprintln(x: a): Unit \ Debug with ToString[a] = ...
}
</code></pre>
<p>We no longer lie about <code>dprintln</code>. Calling it now has the <code>Debug</code> effect.</p>
<p>We can use it to debug our <code>sum</code> function from earlier:</p>
<pre data-lang="flix"><code data-lang="flix">def sum(x: Int32, y: Int32): Int32 =
    let result = x + y;
    Debug.dprintln(&#34;The sum of ${x} and ${y} is ${result}&#34;);
    result
</code></pre>
<p>The implementation of <code>sum</code> is a let-expression whose body is a
statement-expression. Because of the call to <code>dprintln</code>, the inferred effect of
both is <code>Debug</code>.</p>
<p>We are now back to the original problem: The <code>Debug</code> effect is incompatible with
the declared type and effect signature of <code>sum</code> (i.e., <code>sum</code> having the empty
effect set). However, instead of changing the signature of <code>dprintln</code> or <code>sum</code>,
<strong>we will change the <em>effect system</em> to allow the absence of the <code>Debug</code>
effect</strong>.</p>
<p>When a programmer writes a type and effect signature like:</p>
<pre data-lang="flix"><code data-lang="flix">def downloadUrl(x: Int32): Unit \ {FileWrite, Http} = exp
</code></pre>
<p>We first check if <code>exp</code> can be type-checked with the signature:</p>
<p><code>Int32 -&gt; Unit \ {FileWrite, Http}</code></p>
<p>If it cannot, we retry with the signature:</p>
<p><code>Int32 -&gt; Unit \ {FileWrite, Http, Debug}</code></p>
<p>If that works, we consider the function well-typed, but crucially, we do <em>not</em>
update the signature of <code>downloadUrl</code>. Consequently, everywhere <code>downloadUrl</code> is
used, it is still typed as if it only has the <code>FileWrite</code> and <code>Http</code> effects.</p>
<p>The advantages of this implementation are:</p>
<ul>
<li>We can use <code>dprintln</code> anywhere in a function and it just works.</li>
<li>We can add <code>dprintln</code> anywhere without having to change the signature of the
function nor the signatures of any callers.</li>
<li>We can be sure that the optimizer will leave our <code>dprintln</code> calls intact.</li>
</ul>
<p>There are two minor downsides. First, adding a <code>dprintln</code> marks an expression as
impure, effectively disabling the optimizer for that expression and its parent
expressions. Still, this is far less invasive than disabling the optimizer for
the entire program. Second, because the <code>Debug</code> effect is hidden from the
function’s signature, calls to that function inside other functions might be
moved or even eliminated. On the bright side, this ensures that a <code>dprintln</code>
only prints if the function is actually called!</p>
<p><strong>Development vs. Production Mode.</strong> We don’t want published packages to (a) lie
to the type and effect system, or (b) contain print debugging statements. Hence,
when the compiler is run in production mode, we disable the lie that allows the
implicit <code>Debug</code> effect. As a result, using <code>dprintln</code> in production mode causes
a compilation error.</p>
<h2 id="addendum-look-ma-no-macros">Addendum: Look Ma: No Macros!</h2>
<p>Rust has a beautiful <a href="https://doc.rust-lang.org/std/macro.dbg.html"><code>dbg!</code> macro</a> which works like this:</p>
<pre data-lang="rust"><code data-lang="rust">let a = 2;
let b = dbg!(a * 2) + 1;
//      ^-- prints: [src/main.rs:2:9] a * 2 = 4
assert_eq!(b, 5);
</code></pre>
<p>Since the macro has access to the syntax tree, it can print the file name, line,
column, and the original expression. Flix does not currently support macros (and
we would not introduce them solely for this purpose). However, we can achieve
part of this functionality using a <strong>debug string interpolator</strong>.</p>
<p>For example, we can write:</p>
<pre data-lang="flix"><code data-lang="flix">use Debug.dprintln

def main(): Unit \ IO = 
    let result = sum(123, 456);
    println(&#34;The sum is: ${result}&#34;)

def sum(x: Int32, y: Int32): Int32 = 
    dprintln(d&#34;x = ${x}, y = ${y}&#34;);
    x + y
</code></pre>
<p>Note the debug string interpolator <code>d&#34;x = ${x}, y = ${y}&#34;</code>.</p>
<p>Running the program prints:</p>
<pre data-lang="sh"><code data-lang="sh">[Main.flix:8] x = 123, y = 456                         
The sum is: 579
</code></pre>
<p>We get the file name and line number for the small cost of a single <code>d</code>.</p>
<p>That&#39;s all for now.</p>
<p>Until next time, happy hacking.</p>

        </section></div>
  </body>
</html>
