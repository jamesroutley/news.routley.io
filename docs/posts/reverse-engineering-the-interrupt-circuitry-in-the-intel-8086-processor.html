<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2023/02/8086-interrupt.html">Original</a>
    <h1>Reverse-engineering the interrupt circuitry in the Intel 8086 processor</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6015138995640807347" itemprop="description articleBody">


<p>Interrupts have been an important part of computers since the mid-1950s,<span id="fnref:history"><a href="#fn:history">1</a></span>
providing a mechanism to interrupt a program&#39;s execution.
Interrupts allows the computer to handle time-critical tasks such as I/O device operations.
In this blog post, I look at the interrupt features in the Intel 8086 (1978) and how they are implemented in
silicon, a combination of interesting circuitry and microcode.</p>
<p>I&#39;ve been reverse-engineering the 8086 starting with the silicon die.
The die photo below shows the chip under a microscope.
The metal layer on top of the chip is visible, with the silicon and polysilicon mostly hidden underneath.
Around the edges of the die, bond wires connect pads to the chip&#39;s 40 external pins;
relevant pins are marked in yellow.
I&#39;ve labeled the key functional blocks; the ones that are important to this discussion are darker and will be discussed in detail below.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top and an Execution Unit (EU) below.
The BIU handles bus activity, while the Execution Unit (EU) executes instructions and microcode.
Both parts are extensively involved in interrupt handling.</p>
<p><a href="https://static.righto.com/images/8086-interrupts/die-labeled.jpg"><img alt="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." height="624" src="https://static.righto.com/images/8086-interrupts/die-labeled-w600.jpg" title="The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8086 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.</p>
<h2>Interrupts in the 8086</h2>
<p>The idea behind an interrupt is to stop the current flow of execution, run an interrupt handler to perform
a task, and then continue execution where it left off.
An interrupt is like a subroutine call in some ways; it pushes the current segment register and program counter on
the stack and continues at a new address. However, there are a few important differences.
First, the address of the interrupt handler is obtained indirectly, through an interrupt vector table.
Interrupts are numbered 0 through 255, and each interrupt has an entry in the vector table that gives the address
of the code to handle the interrupt.
Second, an interrupt pushes the processor flags to the stack, so they can be restored after the interrupt.
Finally, an interrupt clears the interrupt and trap flags, blocking more interrupts while handling the
interrupt.</p>
<p>The 8086 provides several types of interrupts, some generated by hardware and some generated by software.
For hardware interrupts, the INTR pin on the chip generates a maskable interrupt when activated, while the NMI pin on the chip generates a higher-priority non-maskable interrupt.<span id="fnref:maskable"><a href="#fn:maskable">2</a></span>
Typically, most interrupts use the INTR pin, signaling things such as a timer, keyboard request, real-time clock,
or a disk needing service.
The NMI interrupt is designed for things such as parity error or an impending power failure, which are so critical they can&#39;t be delayed.
The 8086 also has a RESET pin that resets the CPU.
Although not technically an interrupt, the RESET action has many features in common with interrupts, so I&#39;ll discuss it here.</p>
<p>On the software side, the 8086 has multiple types of interrupts generated by different instructions.
The <code>INT n</code> instruction creates an interrupt of the specified type (0 to 255).
These software interrupts were used in the IBM PC to execute a function in the BIOS, the layer underneath the operating system.
These functions could be everything from a floppy disk operation to accessing the printer.
The one-byte <code>INT 3</code> instruction creates a breakpoint interrupt for debugging.
The divide instructions generate an interrupt if a divide-by-zero or overflow occurs.
The <code>INTO</code> instruction (Interrupt if Overflow) generates an interrupt
if the overflow flag is set.
To support single-step mode in debuggers, the Trap flag generate an interrupt on every instruction.</p>
<p>The diagram below shows how the vector table is implemented. Each of the 256 interrupt types has an entry holding
the address of the interrupt handler (the code segment value and the instruction pointer (program counter) value).
In the next section, I&#39;ll show below how the microcode loads the vector from the table and switches execution to that
interrupt handler.</p>
<p><a href="https://static.righto.com/images/8086-interrupts/vector-table.jpg"><img alt="This diagram shows where the interrupt vectors are stored in memory.  From iAPX 86/88 User&#39;s Manual, Figure 4-18." height="653" src="https://static.righto.com/images/8086-interrupts/vector-table-w450.jpg" title="This diagram shows where the interrupt vectors are stored in memory.  From iAPX 86/88 User&#39;s Manual, Figure 4-18." width="450"/></a></p><p>This diagram shows where the interrupt vectors are stored in memory.  From <a href="http://www.bitsavers.org/components/intel/_dataBooks/1981_iAPX_86_88_Users_Manual.pdf">iAPX 86/88 User&#39;s Manual</a>, Figure 4-18.</p>
<h2>Microcode</h2>
<p>Most of the operations in the 8086 are implemented in microcode,
a low-level layer of code that sits between the
machine code instructions and the chip&#39;s hardware.
I&#39;ll explain a few features of the 8086&#39;s microcode that are important for the interrupt code.
Each micro-instruction is 21 bits long, as shown below.
The first part of the micro-instruction specifies a move between a source register and a destination register;
these may be special-purpose internal registers, not just the registers visible to the programmer.
The meaning of the remaining bits depends on the type of micro-instruction, but includes
jumps within the microcode, ALU (Arithmetic/Logic Unit) operations, and memory operations.</p>
<p><a href="https://static.righto.com/images/8086-interrupts/microcode-format.jpg"><img alt="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" height="203" src="https://static.righto.com/images/8086-interrupts/microcode-format-w700.jpg" title="The encoding of a micro-instruction into 21 bits. Based on NEC v. Intel: Will Hardware Be Drawn into the Black Hole of Copyright?" width="700"/></a></p>
<p>For a memory access, microcode issues a memory read or write micro-instruction.
Memory accesses use two internal registers: the <code>IND</code> (Indirect) register holds the address in the segment,
while the <code>OPR</code> (Operand) register holds the word that is read or written.
A micro-instruction such as <code>W SS,P2</code> writes the <code>OPR</code> register to the memory address specified by the <code>IND</code> register
and the segment register (<code>SS</code> indicates the stack segment). The <code>IND</code> register can also be incremented or decremented
(<code>P2</code> indicates &#34;Plus 2&#34;).</p>
<p>The 8086&#39;s Bus Interface Unit (BIU) handles the memory request in hardware, while the microcode waits.
The BIU has an adder to combine the segment address and the offset to obtain the &#34;absolute&#34; address.
It also has a constant ROM to increment or decrement the <code>IND</code> register.
Memory accesses are complicated in the 8086 and take at least four clock cycles,<span id="fnref:cycles"><a href="#fn:cycles">3</a></span> called T1, T2,
T3, and T4.
An interrupt acknowledge is almost the same as a memory read, except the <code>IAK</code> bit is set in the microcode,
causing some behavior changes.</p>
<p>The interaction between microcode and the ALU (Arithmetic/Logic Unit) will also be important.
The ALU has three temporary registers that hold the arguments for operations, called temporary A, B, and C.
These registers are invisible to the programmer.
The first argument for, say, an addition can come from any of the three registers, while the second argument is
always from the temporary B register.
Performing an ALU operation takes at least two micro-instructions. First, the ALU is configured to perform
an operation, for example, ADD or DEC2 (decrement by 2).
The result is then read from the ALU, denoted as the <code>Σ</code> register.</p>
<h2>Software interrupts</h2>
<p>The main microcode for interrupt handling is shown below.<span id="fnref:jenner"><a href="#fn:jenner">4</a></span>
Each line specifies a move operation and an action, with my comments in green.
On entry to <code>INTR</code> interrupt handler, the <code>OPR</code> operand register holds the interrupt type.
This chunk of microcode looks up the interrupt handler in the vector table, pushes the status flags onto the stack,
and then branches to a routine <code>FARCALL2</code> to perform a subroutine call the interrupt handler.</p>


<pre>       move            action
19d  OPR → tmpBL     SUSP         <span>INTR: OPR to tmpB(low), suspend prefetch</span>
19e  0 → tmpbH       ADD tmpB      <span>0 to tmpB(high), add tmpB to tmpB</span>
19f  Σ → tmpB                      <span>ALU sum to tmpB, add tmpB to tmpB</span>
1a0  Σ → IND         R S0,P2       <span>ALU sum to IND, read from memory, IND+=2</span>
1a1  OPR → tmpB      DEC2 tmpC     <span>memory to tmpB, set up decrement tmpC</span>
1a2  SP → tmpC       R S0,P0       <span>SP to tmpC, read from memory</span>
1a3  OPR → tmpA                    <span>memory to tmpA</span>
1a4  F → OPR         CITF          <span>Flags to OPR, clear interrupt and trap flags</span>
1a5  Σ → IND         W SS,P0       <span>ALU dec to IND, Write to memory</span>
1a6  IND → tmpC      JMP FARCALL2  <span>IND to tmpC, branch to FARCALL2</span>
</pre>

<p>In more detail, the microcode routine starts at 19d by moving the interrupt number from the <code>OPR</code> register to the
low byte of the ALU&#39;s temporary B register.
The <code>SUSP</code> action suspends instruction prefetching since we&#39;ll start executing instructions from a new location.
Next, line 19e zeros out the top byte of the temporary B register and tells the ALU to add temporary B to itself.
The next micro-instruction puts the ALU result (indicated by Σ) into temporary B, doubling the value.</p>
<p>Line 1a0 calculates another sum (doubling) from the ALU and stores it in the <code>IND</code> register.
In other words, the interrupt number has been multiplied by 4, yielding an address into the vector table.
The interrupt handle address is read from the vector table: <code>R S0,P2</code> operation reads from memory, segment 0, and performs a &#34;Plus 2&#34; on the <code>IND</code> register.
Line 1a1
puts the result (<code>OPR</code>) into the temporary B register.</p>
<p>Line 1a2 stores the current stack pointer register into temporary C. It also performs a second read to get the
handler code segment from the vector table.
Line 1a3 stores this in the temporary A register.
Line 1a4 puts the flags (<code>F</code>) into the <code>OPR</code> register. It also clears the interrupt and trap flags (<code>CITF</code>), blocking further interrupts.</p>
<p>Line 1a5 puts the ALU result (the decremented stack pointer) into the <code>IND</code> register. (This ALU operation was set up back in line 1a1.)
To push the flags on the stack, <code>W SS,P0</code> writes <code>OPR</code> to the Stack segment and does a &#34;Plus 0&#34; on the <code>IND</code> register.
Finally, line 1a6 stores the <code>IND</code> register (the new top-of-stack) into the temporary C register and jumps to the <code>FARCALL2</code> micro-routine.<span id="fnref:jump"><a href="#fn:jump">5</a></span></p>
<p>Understanding microcode can be tricky, since it is even more low-level than machine instructions, but hopefully
this discussion gives you a feel for it.
Everything is broken down into very small steps, even more basic than machine instructions.
Microcode is a bit like a jigsaw puzzle, carefully fit together to ensure
everything is at the right place at the right time, as efficiently as possible.</p>
<h3>Subroutine call microcode: FARCALL2</h3>
<p>Next, I&#39;ll describe the <code>FARCALL2</code> microcode.
Because of its segment registers, the 8086 has two types of calls (and jumps):
a near call is a subroutine call within the same code segment, while a far call is a subroutine call
to a different code segment.
A far call target is specified with two words: the new code segment register and the new program counter.</p>
<p>The <code>FARCALL2</code> micro-routine performs a subroutine call to a particular segment and offset.
At entry to <code>FARCALL2</code>, the target code segment in temporary A, the offset is in temporary B, and the
decremented stack pointer will be provided by the ALU.
The microcode below pushes the code segment register to the stack, updates the code segment
register with the new value, and then jumps to <code>NEARCALL</code> to finish the subroutine call.</p>
<pre>06c  Σ → IND      CORR        <span>FARCALL2: ALU (IND-2) to IND, correct PC</span>
06d  CS → OPR     W SS,M2      <span>CS to OPR, write to memory, IND-=2</span>
06e  tmpA → CS    PASS tmpC    <span>tmpA to CS, ALU passthrough</span>
06f  PC → OPR     JMP NEARCALL <span>PC to OPR, branch to NEARCALL</span>
</pre>

<p>For a subroutine call, the program counter is saved so execution can resume where it left off.
But because of prefetching, the program counter in the 8086 points to the next instruction to <em>fetch</em>,
not the next instruction to <em>execute</em>.
To fix this, the 
<code>CORR</code> (Correction) micro-instruction corrects the program counter value 
by subtracting the length of the prefetch queue.
Line 06c also puts the decremented stack location into <code>IND</code> using the ALU decrement operation set up way back at line 1a1.</p>
<p>Line 06d puts the code segment value (<code>CS</code>) into the <code>OPR</code> register and then writes it to the stack segment,
performing a &#34;Minus 2&#34; on <code>IND</code>. In other words, the CS register is pushed onto the stack.
Line 06e stores the new value (from temporary A) into the CS register. It also sets up the ALU to pass the value
of the temporary C register as its result.
Finally, line 06f puts the (corrected) program counter into the <code>OPR</code> register and jumps to the <code>NEARCALL</code> routine.</p>
<h3>Subroutine call microcode: NEARCALL</h3>
<p>The <code>NEARCALL</code> micro-routine does a near subroutine call, updating the program counter but not the segment register.
At entry, the target address is in temporary B, the <code>IND</code> register indicates the top of the stack, and <code>OPR</code> holds the program counter.</p>
<pre>077  tmpB → PC    FLUSH      <span>NEARCALL: tmpB to PC, restart prefetch</span>
078  IND → tmpC               <span>IND to tmpC</span>
079  Σ → IND                  <span>ALU to IND</span>
07a  Σ → SP       W SS,P0 RNI <span>ALU to SP, write PC to memory, run next instruction</span>
</pre>

<p>Line 077 puts temporary B into the program counter. The <code>FLUSH</code> operation flushes the stale instructions from
the prefetch queue and starts prefetching from the new PC address.
Line 078 puts <code>IND</code> (i.e. the new stack pointer value) into temporary C.
Line 079 puts this value into the <code>IND</code> register and line 07a puts this value into the <code>SP</code> register.
(The ALU was configured at line 06e to pass the temporary C value unmodified.)</p>
<p>Line 07a pushes the PC to the stack by writing <code>OPR</code> (the old program counter) to the stack segment.
Finally, <code>RNI</code> (Run Next Instruction) ends this microcode sequence and causes the 8086 to
run the next machine instruction, the first instruction of the interrupt handler.</p>
<h3>Starting an interrupt</h3>
<p>The above microcode handles a generic interrupt. But there&#39;s one more piece: setting up the interrupt
type for the instruction.
For instance, the <code>INT ib</code> machine instruction has the interrupt type in the second byte of the opcode.
This machine instruction has the two micro-instructions below.
The microcode loads the type from the instruction prefetch queue (<code>Q</code>) and puts it into temporary B and then <code>OPR</code>.
Then it jumps to the <code>INTR</code> microcode discussed earlier.</p>
<pre>1a8  Q → tmpB             <span>INT ib: load a byte from the queue</span>
1a9  tmpB → OPR  JMP INTR  <span>Put the byte in OPR and jump to INTR</span>
</pre>

<p>Several instructions require specific interrupt numbers, and the microcode uses a tricky technique to obtain these numbers.
The numbers are obtained from a special pseudo-register called <code>CR</code>, which is all zeros except the three low bits
come from the microcode address.<span id="fnref:zero"><a href="#fn:zero">6</a></span>
The microcode is carefully arranged in memory so the micro-instruction is at the right address to generate the necessary value.
For instance, in the microcode below, entry point <code>INT1</code> will load the number 1 into <code>OPR</code>, entry point <code>INT2</code> will load the number 2 into <code>OPR</code>, and <code>INT0</code> will load 0 into <code>OPR</code>.
Each line then jumps to the main <code>INTR</code> interrupt microcode.</p>
<!--
For instance, the `INT 3` instruction is provided as a special case, a one-byte instruction that can be inserted into
code for a breakpoint and causes a type 3 interrupt. A trap creates a type 1 interrupt while an overflow creates
a type 4 interrupt.
-->

<pre>198  CR → OPR     JMP INTR      <span>INT1: num to OPR, branch to INTR</span>
199  CR → OPR     JMP INTR      <span>INT2: num to OPR, branch to INTR</span>
...
1a7  CR → OPR     JMP INTR      <span>INT0: num to OPR, branch to INTR</span>
</pre>

<p>The microcode for the <code>INT 3</code> and <code>INTO</code> (not to be confused with <code>INT0</code>) machine instructions has some wasted micro-instructions to ensure that the <code>CR → OPR</code> is at the right address.
This wastes a couple of cycles and a couple of micro-instructions.<span id="fnref:int3"><a href="#fn:int3">7</a></span></p>
<!--
Another case is the divide-by-0 interrupt. It is triggered in the division microcode,
which simply jumps to the `INT0` microcode if there is an overflow.
-->

<h3>Return from interrupt</h3>
<p>The <code>IRET</code> interrupt is used to return from interrupts.
It pops the program counter, code segment register, and flags from the stack, so execution can continue
at the point where the interrupt happened.
It calls the microcode subroutine <code>FARRET</code> to pop the code segment register and the PC from the stack.
(I won&#39;t go into <code>FARRET</code> in this post.)
Then it pops the flags from the stack, updates the Stack Pointer, and runs the next instruction.</p>
<pre>0c8               CALL FARRET <span>IRET: call Far Return</span>
0c9               R SS,P2      <span>read from stack, IND+=2</span>
0ca  OPR → F                   <span>mem to Flags</span>
0cb  IND → SP     RNI          <span>IND to stack pointer, run next instruction</span>
</pre>

<h2>External hardware interrupts</h2>
<p>As well as software interrupts, the 8086 has hardware interrupts.
The 8086 chip has pins for INTR and NMI; pulling the pin high causes a hardware interrupt.
This section discusses the hardware circuitry and the microcode that handles these interrupts.</p>
<h3>The interrupt pin circuit</h3>
<p>The schematic below shows the input circuitry for the INTR pin; the NMI, RESET, and TEST pins use the same circuit.
The function of this circuit is to clean up the input and ensure that it is synchronized with the clock.
The chip&#39;s INTR pin is connected to a protection diode to drain a negative voltage to ground.
Next, the signal goes through three inverters, probably to force a marginal voltage
to either 0 or 1.
Finally, the signal goes through an edge-triggered flip-flop to synchronize it with the clock.
The flip-flop is constructed from two set-reset latches, the first gated by clk&#39; and the second gated by clk.
At the output of each stage is a &#34;superbuffer&#34;, two transistors that produce a higher-current output than a regular
inverter.
This flip-flop circuit is unusual for the 8086; most flip-flops and latches are constructed from dynamic logic
with pass transistors, which is much more compact.
The more complicated circuitry on the INTR input probably protects against metastability and other problems that
could occur with poor-quality input signals.</p>
<p><a href="https://static.righto.com/images/8086-interrupts/pin-input.jpg"><img alt="Schematic of the input circuitry for the INTR pin." height="209" src="https://static.righto.com/images/8086-interrupts/pin-input-w700.jpg" title="Schematic of the input circuitry for the INTR pin." width="700"/></a></p><p>Schematic of the input circuitry for the INTR pin.</p>
<h3>The interrupt logic circuitry</h3>
<p>The chip has a block of interrupt logic to receive interrupts, handle interrupt priorities, and execute an
interrupt at the appropriate time.
This circuitry is in the top right part of the chip, on the opposite side of the chip from the interrupt pins.
The schematic below shows this circuitry.</p>
<p><a href="https://static.righto.com/images/8086-interrupts/interrupt-logic.jpg"><img alt="The interrupt logic circuitry activates the microcode interrupt code at the appropriate time." height="422" src="https://static.righto.com/images/8086-interrupts/interrupt-logic-w600.jpg" title="The interrupt logic circuitry activates the microcode interrupt code at the appropriate time." width="600"/></a></p><p>The interrupt logic circuitry activates the microcode interrupt code at the appropriate time.</p>
<p>The top chunk of logic latches an NMI (non-maskable interrupt) until it runs or it is cleared by a reset.<span id="fnref:nmi"><a href="#fn:nmi">8</a></span>
The first flip-flop helps convert an NMI input into a one-clock pulse.
The second flip-flop holds the NMI until it runs.</p>
<p>The middle chunk of logic handles traps. If the trap flag is high, the latch will hold the trap request until
it can take place.
The latch is loaded on First Clock (FC), which indicates the start of a new instruction.
The NOR gate blocks the trap if there is an interrupt or NMI, which has higher priority.<span id="fnref:simultaneous"><a href="#fn:simultaneous">9</a></span></p>
<p>The third chunk of logic schedules the interrupt.
Three things can delay an interrupt: an interrupt delay micro-instruction, an instruction that modifies a
segment register, or an instruction prefix.<span id="fnref:delay"><a href="#fn:delay">10</a></span>
If not delayed, the interrupt (NMI, trap, or INTR pin) will run at the start of the next instruction (i.e. <code>FC</code>).<span id="fnref:fc"><a href="#fn:fc">11</a></span>
The microcode interrupt code is run for these cases as well as a reset.
Note that the reset is not gated by First Clock, but can run at any time.</p>
<p>The interrupt signal from this circuitry loads a hardcoded interrupt
address into the microcode address latches, depending on the type of interrupt.<span id="fnref:mc-addr"><a href="#fn:mc-addr">12</a></span>
This happens for an interrupt at First Clock, while a reset can happen any time in the instruction cycle.
A trap goes to the <code>INT1</code> microcode routine described earlier, while an NMI interrupt goes to <code>INT2</code> microcode routine.
The microcode for the <code>INTR</code> interrupt will be discussed in the next section.</p>
<p>The interrupt signal also goes to the Group Decode ROM (via the instruction register), where it blocks regular
instruction decoding.
Finally, the interrupt signal goes to a circuit called the loader, where it prevents fetching of the next instruction from the prefetch
queue.</p>
<h2>The external INTR interrupt</h2>
<p>The INTR interrupt has some special behavior to communicate with the device that triggered the interrupt:
the 8086 performs two bus cycles to acknowledge the interrupt and to
obtain the interrupt number from the device.
This is implemented with a combination of microcode and the bus interface logic.
The bus cycles are similar to memory read cycles, but with some behavior specific to interrupts.</p>
<p>The INTR interrupt has its own microcode, shown below.
The first micro-instruction zeros the <code>IND</code> memory address register and then performs a special <code>IAK</code> bus cycle.<span id="fnref:iak"><a href="#fn:iak">13</a></span>
This is similar to a memory read but asserts the <code>INTA</code> interrupt acknowledge line so the device knows that
its interrupt has been received.
Next, prefetching is suspended.
The third line performs a second <code>IAK</code> bus cycle and the external device puts the interrupt
number onto the bus. The interrupt number is read into the <code>ORD</code> register, just like a memory read.
At this point, the code falls through into the interrupt microcode described previously.</p>
<pre>19a  0 → IND   IAK S0,P0  <span>IRQ: 0 to IND, run interrupt bus cycle</span>
19b            SUSP        <span>suspend prefetch</span>
19c            IAK S0,P0   <span>run interrupt bus cycle</span>
19d            ...        <span>The INTR routine discussed earlier</span>
</pre>

<h3>The bus cycle</h3>
<p>The diagram below provides timing details of the two interrupt acknowledge bus cycles. Each cycle is
similar to a memory read bus cycle, going through the T1 through T4 states, starting with an
<code>ALE</code> (Address Latch Enable) signal.
The main difference is the interrupt acknowledge bus cycle also raises the <code>INTA</code> (Interrupt Acknowledge) to
let the requesting device know that its interrupt has been acknowledged.<span id="fnref:minimum"><a href="#fn:minimum">14</a></span>
On the second cycle, the device provides an 8-bit type vector that provides the interrupt number.
The 8086 also issues a <code>LOCK</code> signal to lock the bus from other uses during this sequence.
The point of this is that the 8086 goes through a fairly complex bus sequence when handling a hardware interrupt.
The microcode triggers these two bus cycles with the <code>IAK</code> micro-operation, but the bus interface circuitry
goes through the various states of the bus cycle in hardware, without involving the microcode.</p>
<p><a href="https://static.righto.com/images/8086-interrupts/int-ack.jpg"><img alt="This diagram shows the interrupt acknowledge sequence. From Intel 8086 datasheet." height="308" src="https://static.righto.com/images/8086-interrupts/int-ack-w600.jpg" title="This diagram shows the interrupt acknowledge sequence. From Intel 8086 datasheet." width="600"/></a></p><p>This diagram shows the interrupt acknowledge sequence. From <a href="https://www.electro-tech-online.com/datasheets/8086_intel.pdf">Intel 8086 datasheet</a>.</p>
<p>The circuitry to control the bus cycle is complicated with many flip-flops and logic gates; the diagram below shows the flip-flops.
I plan to write about the bus cycle circuitry in detail later, but for now, I&#39;ll give an extremely simplified description.
Internally, there is a T0 state before T1 to provide a cycle to set up the bus operation.
The bus timing states are controlled by a chain of flip-flops configured like a shift register with additional logic: the output from the T0 flip-flop is connected to the input of the T1 flip-flop and likewise with T2 and T3, forming a chain.
A bus cycle is started by putting a 1 into the input of the T0 flip-flop.
When the CPU&#39;s clock transitions, the flip-flop latches this signal, indicating the (internal) T0 bus state.
On the next clock cycle, this 1 signal goes from the T0 flip-flop to the T1 flip-flop, creating the externally-visible T1 state.
Likewise, the signal passes to the T2 and T3 flip-flops in sequence, creating the bus cycle.
Some special-case logic changes the behavior for an interrupt versus a read.<span id="fnref:bus-logic"><a href="#fn:bus-logic">15</a></span></p>
<p><a href="https://static.righto.com/images/8086-interrupts/mem-ctrl.jpg"><img alt="The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon." height="509" src="https://static.righto.com/images/8086-interrupts/mem-ctrl-w600.jpg" title="The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon." width="600"/></a></p><p>The read/write control circuitry on the die with the flip-flops labeled. Metal and polysilicon were removed to show the underlying silicon.</p>
<h2>Reset</h2>
<p>The reset pin resets the CPU to an initial state.
This isn&#39;t an interrupt, but much of the circuitry is the same, so I&#39;ll describe it for completeness.
The reset microcode below initializes the segment registers, program counter, and flags to 0, except the
code segment is initialized to 0xffff.
Thus, after a reset, instruction execution will start at absolute address 0xffff0.
The reset line is also connected to numerous flip-flops and circuits in the 8086 to ensure that they are initialized to the proper state. These initializations happen outside of the microcode.</p>
<pre>1e4  0 → DS     SUSP   <span>RESET: 0 to DS, suspend prefetch</span>
1e5  ONES → CS          <span>FFFF to CS</span>
1e6  0 → PC     FLUSH   <span>0 to PC, start prefetch</span>
1e7  0 → F              <span>0 to Flags</span>
1e8  0 → ES             <span>0 to ES</span>
1e9  0 → SS     RNI     <span>0 to SS, run next instruction</span>
</pre>

<h2>A bit of history</h2>
<p>The 8086&#39;s interrupt system inherits a lot from the Intel 8008 processor.
Interrupts were a bit of an afterthought on the 8008 so the interrupt handling was primitive and designed to simplify implementation.<span id="fnref:8008"><a href="#fn:8008">17</a></span>
In particular, an interrupt response acts like an instruction fetch except the interrupting device &#34;jams&#34;
an instruction on the bus.
To support this, the 8008 provided one-byte <code>RST</code> (Restart) instructions that would call a fixed location.
The Intel 8080 improved the 8008, but kept this model of performing an instruction fetch cycle that received a &#34;jammed&#34; instruction for an interrupt.
With more pins available, the 8080 added the <code>INTA</code> Interrupt Acknowledge pin.</p>
<p>The approach of &#34;jamming&#34; an instruction onto the bus for an interrupt is rather unusual.
Other contemporary microprocessors such as the 6800, 6502, or Intel 8048 used an interrupt vector approach, which
is much more standard:
an interrupt vector table held pointers to the interrupt service routines.</p>
<p>The 8086 switched to an interrupt vector table, but retained some 8080 interrupt characteristics for backward compatibility.
In particular, the 8086 performs a memory cycle very much like an instruction fetch, but instead of an
instruction, it receives an interrupt number.
The 8086 performs two interrupt ack bus cycles but ignores the first one, which lets the same hardware work with
the 8080 and 8086.<span id="fnref:8259A"><a href="#fn:8259A">16</a></span></p>
<h2>Conclusions</h2>
<p>This is another blog post that I expected would be quick and easy, but there&#39;s a lot going on in the 8086&#39;s
interrupt system, both in hardware and microcode.
The 8086 has some strange characteristics, such as acknowledging interrupts twice, but these features make
more sense when looking at the 8086&#39;s history and what it inherited from the 8008 and 8080.</p>
<p>I&#39;ve written multiple <a href="https://www.righto.com/search/label/8086">posts on the 8086</a> so far and
plan to continue reverse-engineering the 8086 die so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="http://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;ve also started experimenting with Mastodon recently as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="95faf9f1f7ece1f0e6bbe6e5f4f6f0d5fef0fbe6fdfce7e7fcf3f3">[email protected]</span></a>.
Thanks to <a href="https://news.ycombinator.com/item?id=34495797">pwg</a> on HN for suggesting interrupts as a topic.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
