<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hezmatt.org/~mpalmer/blog/2024/01/16/pwned-certificates-on-the-fediverse.html">Original</a>
    <h1>Pwned Certificates on the Fediverse</h1>
    
    <div id="readability-page-1" class="page"><div id="body">
			
			<div id="content">

				
				<p>
					Posted: Tue, 16 January 2024
					| <a href="https://www.hezmatt.org/~mpalmer/blog/2024/01/16/pwned-certificates-on-the-fediverse.html">permalink</a>
					| <a href="https://www.hezmatt.org/~mpalmer/blog/2024/01/16/pwned-certificates-on-the-fediverse.html#comments">
						
							No comments
						
					</a>
				</p>
<p>As well as the collection and distribution of <a href="https://pwnedkeys.com">compromised keys</a>, the <a href="https://pwnedkeys.com">pwnedkeys</a> project also matches those pwned keys against issued SSL certificates.
I’m excited to announce that, as of the beginning of 2024, all matched certificates are now being published <a href="https://botsin.space/@pwnedcerts">on the Fediverse</a>, thanks to the <a href="https://botsin.space/">botsin.space</a> Mastodon server.</p>

<p>Want to know which sites are susceptible to interception and interference, in (near-)real time?
Do you have a burning desire to know who is issuing certificates to people that post their private keys in public?
Now you can.</p>



<p>The process for publishing pwned certs is, roughly, as follows:</p>

<ol>
  <li>
    <p>All the certificates in <a href="https://certificate.transparency.dev">Certificate Transparency</a> (CT) logs are hoovered up (using my <a href="https://github.com/mpalmer/scrape-ct-log">scrape-ct-log</a> tool, the fastest log scraper in the west!), and the fingerprint of the public key of each certificate is stored in an <a href="https://lmdb.tech/">LMDB</a> datafile.</p>
  </li>
  <li>
    <p>As new private keys are identified as having been compromised, the fingerprint of that key is checked against all the LMDB files, which map key fingerprints to certificates (actually to CT log entry IDs, from which the certificates themselves are retrieved).</p>
  </li>
  <li>
    <p>If one or more matches are found, then the certificates using the compromised key are forwarded to the “tooter”, which <a href="https://botsin.space/@pwnedcerts">publishes them for the world to marvel at</a>.</p>
  </li>
</ol>

<p>This makes it sound all very straightforward, and  it is… in theory.
The trick comes in optimising the pipeline so that the five million or so new certificates every day can get indexed on the one slightly middle-aged server I’ve got, without getting backlogged.</p>



<p>Funny story about that…</p>

<p>I used to notify CAs of certificates they’d issued using compromised keys, which had the effect of requiring them to revoke the associated certificates.
However, several CAs disliked having to revoke all those certificates, because it cost them staff time (and hence money) to do so.
They went so far as to change their procedures from the standard way of accepting problem reports (emailing a generic attestation of compromise), and instead required CA-specific hoop-jumping to notify them of compromised keys.</p>

<p>Since the effectiveness of revocation in the WebPKI is, shall we say, “homeopathic” at best, I decided I couldn’t be bothered to play whack-a-mole with CAs that just wanted to be difficult, and I stopped sending compromised key notifications to CAs.
Instead, now I’m publishing the details of compromised certificates to everyone, so that users can protect themselves directly should they choose to.</p>



<p>The astute amongst you may have noticed, in the above “How It Works” description, a bit of a gap in my scanning coverage.
CAs can (and do!) issue certificates for keys that are <em>already</em> compromised, including “weak” keys that have been known about for a decade or more (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1472052">1</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1620772">2</a>, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1789521">3</a>).
However, as currently implemented, the pwnedkeys certificate checker does not automatically find such certificates.</p>

<p>My plan is to augment the CT scraping / cert processing pipeline to check all incoming certificates against the existing (2M+) set of pwned keys.
Though, with over five million new certificates to check every day, it’s not necessarily as simple as “just hit the <a href="https://pwnedkeys.com/api/v1.html">pwnedkeys API</a> for every new cert”.
The poor old API server might not like that very much.</p>



<p>If you’d like to see this extra matching happen a bit quicker, I’ve setup a <a href="https://ko-fi.com/tobermorytech">ko-fi supporters page</a>, where you can support my work on <a href="https://pwnedkeys.com">pwnedkeys</a> and the other open source software and projects I work on by <a href="https://ko-fi.com/tobermorytech">buying me a refreshing beverage</a>.
I would be very appreciative, and your support lets me know I should do more interesting things with the giant database of compromised keys I’ve accumulated.</p>


<hr/>
			
			

			</div>
		</div></div>
  </body>
</html>
