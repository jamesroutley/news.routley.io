<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.andreinc.net/2021/11/08/a-tale-of-java-hash-tables">Original</a>
    
    <div id="readability-page-1" class="page"><div>
      
        <header>
          
          

  <p>
    
      
      <span>
        <i aria-hidden="true"></i>
        
        <time datetime="2021-11-08T00:00:00+00:00">November 8, 2021</time>
      </span>
    

    

    
  </p>


        </header>
      

      <section itemprop="text">
        
        <p><strong>Note(s)</strong></p>

<ul>
  <li>The intended audience for this article is undergrad students who already have a good grasp of Java, or seasoned Java developers who would like to explore an in-depth analysis of various <em>hash table</em> implementations that use <em>Open Addressing</em>.</li>
  <li>The reader should be familiar with Java generics, collections, basic data structures, hash functions, and bitwise operations.</li>
</ul>



<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#separate-chaining-or-how-hashmapkv-works-internally">Separate Chaining, or how <code>HashMap&lt;K,V&gt;</code> works internally</a></li>
  <li><a href="#open-addressing">Open Addressing</a>
    <ul>
      <li><a href="#lprobmapk-v"><code>LProbMap&lt;K, V&gt;</code></a>
        <ul>
          <li><a href="#inserting-an-entry">Inserting an entry</a></li>
          <li><a href="#retrieving-an-entry">Retrieving an entry</a></li>
          <li><a href="#deleting-an-entry">Deleting an entry</a></li>
          <li><a href="#resizing-and-rehashing">Resizing and rehashing</a></li>
        </ul>
      </li>
      <li><a href="#perturbmapk-v"><code>PerturbMap&lt;K, V&gt;</code></a></li>
      <li><a href="#lprobbinsmapkv"><code>LProbBinsMap&lt;K,V&gt;</code></a></li>
      <li><a href="#lprobradarmapk-v"><code>LProbRadarMap&lt;K, V&gt;</code></a></li>
      <li><a href="#robinhoodmapk-v"><code>RobinHoodMap&lt;K, V&gt;</code></a></li>
    </ul>
  </li>
  <li><a href="#benchmarks">Benchmarks</a>
    <ul>
      <li><a href="#randomstringsreads"><code>RandomStringsReads</code></a></li>
      <li><a href="#sequencedstringsreads"><code>SequencedStringsReads</code></a></li>
      <li><a href="#alphanumericcodesreads"><code>AlphaNumericCodesReads</code></a></li>
    </ul>
  </li>
  <li><a href="#the-results">The results</a></li>
  <li><a href="#wrapping-up">Wrapping up</a></li>
</ul>



<p>In Java, the main <em>hash table</em> implementation, <code>HashMap&lt;K,V&gt;</code>, uses the classical <em>Separate Chaining</em> technique (with critical optimizations that reduce read times in case of collisions).</p>

<p>But, as described <a href="https://rcoh.me/posts/hash-map-analysis/">here</a>, the decision to use <a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining"><em>Separate Chaining</em></a> vs. <a href="https://en.wikipedia.org/wiki/Hash_table#Open_addressing"><em>Open Addressing</em></a> is not unanimously accepted by programming languages designers. For example, in python, ruby, and rust, the standard hash tables are implemented using <em>Open Addressing</em>, while Java, go, C#, C++ are all more conservatory and use <em>Separate Chaining</em>.</p>

<table>
  <thead>
    <tr>
      <th>Programming Language</th>
      <th>Hash table algorithm</th>
      <th>Source(s)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Python</td>
      <td>Open Addressing</td>
      <td><a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c">dictobject.c</a></td>
    </tr>
    <tr>
      <td>Ruby</td>
      <td>Open Addressing</td>
      <td><a href="https://github.com/ruby/ruby/blob/master/st.c">st.c</a></td>
    </tr>
    <tr>
      <td>Rust</td>
      <td>Open Addressing</td>
      <td><a href="https://github.com/rust-lang/rust/blob/master/library/std/src/collections/hash/map.rs">map.rs</a></td>
    </tr>
    <tr>
      <td>Java</td>
      <td>Separate Chaining</td>
      <td><a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java">HashMap.java</a></td>
    </tr>
    <tr>
      <td>Go</td>
      <td>Separate Chaining</td>
      <td><a href="https://github.com/golang/go/blob/master/src/hash/maphash/maphash.go">maphash.go</a></td>
    </tr>
    <tr>
      <td>C#</td>
      <td>Separate Chaining</td>
      <td><a href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Collections/Generic/Dictionary.cs">Dictionary.cs</a></td>
    </tr>
    <tr>
      <td>C++</td>
      <td>Separate Chaining</td>
      <td><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/hashtable.h">hashtable.h</a></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>There are, of course, lovely <em>hash table</em> implementations that sit outside the standard libraries. So, if you are looking for a good read, check out the Facebook (or should I say Meta) <a href="https://engineering.fb.com/2019/04/25/developer-tools/f14/">Engineering Blog</a> discussing their super-fast &amp; efficient F14 implementation.</p>
</blockquote>

<p>In this article, we will discuss how to implement hash tables in Java, using <em>Open Addressing</em> and then benchmark them against the reference <code>HashMap&lt;K,V&gt;</code> implementation that uses <em>Separate Chaining</em>.</p>

<p>I’ve decided to stay away from <a href="https://en.wikipedia.org/wiki/Hopscotch_hashing">Hopscotch</a>, although I did get inspired by it. In regards to <a href="https://en.wikipedia.org/wiki/Cuckoo_hashing">Cuckoo Hashing</a>, you can find a “draft” implementation in the code repo.</p>

<p>I’ve also skipped Quadratic probing because I consider python’s approach <em>smarter</em>.</p>

<p>My implementations will be entirely academic, and I am sure a person with more experience optimizing Java code manually will do a better job than me.</p>

<p>Also, given the complex nature of benchmarking Java code, please feel free to comment on the results. I’ve used <a href="https://openjdk.java.net/projects/code-tools/jmh/"><code>jmh</code></a>, but I am more than happy to explore other alternatives.</p>

<p>For the moment, we are going to implement five <code>Map&lt;K,V&gt;</code> and benchmark their (<code>get()</code>) speed against <code>HashMap&lt;K,V&gt;</code>:</p>

<table>
  <thead>
    <tr>
      <th>Java Class</th>
      <th>Source</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#lprobmapk-v"><code>LProbMap&lt;K, V&gt;</code></a></td>
      <td><a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbMap.java">src</a></td>
      <td>A classic Open Addressing implementation that uses Linear Probing</td>
    </tr>
    <tr>
      <td><a href="#lprobbinsmapkv"><code>LProbBinsMap&lt;K,V&gt;</code></a></td>
      <td><a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbBinsMap.java">src</a></td>
      <td>An “almost” classic Open Addressing implementation inspired by ruby’s hash table.</td>
    </tr>
    <tr>
      <td><a href="#lprobradarmapk-v"><code>LProbRadarMap&lt;K, V&gt;</code></a></td>
      <td><a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbRadarMap.java">src</a></td>
      <td>An Open Addressing implementation that uses a separate vector (<code>radar</code>) to determine where to search for items. It uses the same idea as <em>Hopscotch Hashing</em></td>
    </tr>
    <tr>
      <td><a href="#perturbmapk-v"><code>PerturbMap&lt;K, V&gt;</code></a></td>
      <td><a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/PerturbMap.java">src</a></td>
      <td>An Open Addressing implementation that uses the python’s <em>perturbator</em> algorithm instead of linear probing</td>
    </tr>
    <tr>
      <td><a href="#robinhoodmapk-v"><code>RobinHoodMap&lt;K, V&gt;</code></a></td>
      <td><a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/RobinHoodMap.java">src</a></td>
      <td>An Open Addressing implementation that uses linear probing with <em>Robin Hood Hashing</em></td>
    </tr>
  </tbody>
</table>

<p>The code is available in the following repo:</p>

<div><div><pre><code>git clone git@github.com:nomemory/open-addressing-java-maps.git
</code></pre></div></div>

<p>Before jumping directly to the implementation, I recommend you to read <a href="https://www.andreinc.net/2021/10/02/implementing-hash-tables-in-c-part-1">my previous article</a> on the subject. Even if the code is in C, I recommend refreshing a few theoretical insights (e.g., hash functions).</p>



<p>As I’ve previously stated, <code>HashMap&lt;K,V&gt;</code> is implemented using a typical <em>Separate Chaining</em> technique. If you jump straight into <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java">reading the source code</a>, things can be a little confusing, especially if you don’t know what you are looking for. But once you understand the main concepts, everything becomes much clearer.</p>

<blockquote>
  <p>Even if this is not the purpose of this article, I believe it’s always a good idea to understand how <code>HashMap&lt;K,V&gt;</code> works. Many (Java) interviewers love to ask this question.</p>
</blockquote>

<p>If you already understand how <code>HashMap&lt;K,V&gt;</code> works, you can skip directly to the <a href="#open-addressing">next section</a>. If you don’t, and you are curious about it, please read the following paragraphs.</p>

<p>The <code>HashMap&lt;K,V&gt;</code> class contains an array of <code>Node&lt;K,V&gt;</code>. For simplicity and inertia, we are going to call this array <code>table</code>:</p>

<div><div><pre><code><span>// The table, initialized on first use, and resized as necessary. </span>
<span>// When allocated, length is always a power of two. </span>
<span>transient</span> <span>Node</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;[]</span> <span>table</span><span>;</span>
</code></pre></div></div>

<p>The <code>table</code> is the most <em>important</em> structure from the class; it’s the <em>place</em> where we store our data.</p>

<p><code>Node&lt;K,V&gt;</code> class has the following composition:</p>

<div><div><pre><code><span>static</span> <span>class</span> <span>Node</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>implements</span> <span>Map</span><span>.</span><span>Entry</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>{</span>
        <span>final</span> <span>int</span> <span>hash</span><span>;</span>
        <span>final</span> <span>K</span> <span>key</span><span>;</span>
        <span>V</span> <span>value</span><span>;</span>
        <span>Node</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>next</span><span>;</span>

        <span>// getters and setters + other goodies       </span>
<span>}</span>
</code></pre></div></div>

<p>As you rightfully observed, <code>Node&lt;K,V&gt;</code> is used to implement a “linked” (or <em>chained</em>) data structure. The <code>next</code> attribute references the next <code>Node</code> in the chain.</p>

<p>In this regard, think of the <code>Node&lt;K,V&gt;[] table</code> as an array of linked data structures. For simplicity, let’s suppose those chained structures are <em>linked lists</em>.</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/chained-structure.drawio.png" alt="png"/></p>

<p>To make things more transparent, let’s analyze the following example. We define a <code>HashMap&lt;String, String&gt;</code>, where keys <code>K</code> are European capital cities (<code>String</code>), while the values <code>V</code> are the corresponding country names (<code>String</code>).</p>

<p>Before doing any insert, there will be one empty <code>table</code> with the initial capacity set to: <code>DEFAULT_INITIAL_CAPACITY=1&lt;&lt;4</code> (by the magic of bitwise operators, <code>1&lt;&lt;4==16</code>). The choice of using a power of two is not <em>accidental</em>, we will see shortly why.</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/empty-hashmap.drawio.png" alt="png"/></p>

<p>Now let’s see what happens when we want to insert the first <code>&lt;String, String&gt;</code> entries: <code>&lt;&#34;Paris&#34;, &#34;France&#34;&gt;</code>, <code>&lt;&#34;Sofia&#34;, &#34;Bulgaria&#34;&gt;</code>, <code>&lt;&#34;Madrid&#34;, &#34;Spain&#34;&gt;</code> and <code>&lt;&#34;Bucharest&#34;, &#34;Romania&#34;&gt;</code>.</p>

<p>The <code>put(K key, V value)</code> method is called first, eventually <em>dispatching</em> the call to <code>putVal(...)</code>.</p>

<div><div><pre><code><span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span><span>key</span><span>),</span> <span>key</span><span>,</span> <span>value</span><span>,</span> <span>false</span><span>,</span> <span>true</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>But, before <code>putVal(...)</code> gets called, we need to compute <code>hash(key)</code>.</p>

<div><div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
    <span>int</span> <span>h</span><span>;</span>
    <span>return</span> <span>(</span><span>key</span> <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span><span>h</span> <span>=</span> <span>key</span><span>.</span><span>hashCode</span><span>())</span> <span>^</span> <span>(</span><span>h</span> <span>&gt;&gt;&gt;</span> <span>16</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p><code>HashMap&lt;K,V&gt;</code> accepts <code>null</code> keys, so by convention, <code>hash(null)</code> is always <code>0</code>.</p>

<p>If the key is not <code>null</code>, we <code>shift</code> and <code>xor</code> the <code>hashCode()</code> of the key and return the value.</p>

<p>The reason for doing that extra bit operation is to improve the diffusion of the <code>hashCode()</code> by considering the higher-order bits. If you want to understand more of this magic, please read my previous article: <a href="https://www.andreinc.net/2021/10/02/implementing-hash-tables-in-c-part-1#hash-functions">Implementing Hash Tables in C/Hash functions</a>.</p>

<p>If we were to apply the <code>hash</code> method to our input (<code>&#34;Paris&#34;</code>, <code>&#34;Sofia&#34;</code>, <code>&#34;Madrid&#34;</code>, <code>&#34;Bucharest&#34;</code>), we’d obtain the following values:</p>

<div><div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
    <span>int</span> <span>h</span><span>;</span>
    <span>return</span> <span>(</span><span>key</span> <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span><span>h</span> <span>=</span> <span>key</span><span>.</span><span>hashCode</span><span>())</span> <span>^</span> <span>(</span><span>h</span> <span>&gt;&gt;&gt;</span> <span>16</span><span>);</span>
<span>}</span>
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[]</span> <span>args</span><span>)</span> <span>{</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Paris&#34;</span><span>));</span>      <span>// 76885502</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Sofia&#34;</span><span>));</span>      <span>// 80061639</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Madrid&#34;</span><span>));</span>     <span>// -1997818570</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Bucharest&#34;</span><span>));</span>  <span>// -543452922</span>
<span>}</span>
</code></pre></div></div>

<p>The next step is to look at the <code>putVal(...)</code> method and see what it does:</p>

<div><div><pre><code><span>final</span> <span>V</span> <span>putVal</span><span>(</span><span>int</span> <span>hash</span><span>,</span> <span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>,</span> <span>boolean</span> <span>onlyIfAbsent</span><span>,</span>
                <span>boolean</span> <span>evict</span><span>)</span> <span>{</span>
    <span>Node</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;[]</span> <span>tab</span><span>;</span> 
    <span>Node</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>p</span><span>;</span> 
    <span>int</span> <span>n</span><span>,</span> <span>i</span><span>;</span>
    <span>// If the table is empty we simply allocate space for it</span>
    <span>if</span> <span>((</span><span>tab</span> <span>=</span> <span>table</span><span>)</span> <span>==</span> <span>null</span> <span>||</span> <span>(</span><span>n</span> <span>=</span> <span>tab</span><span>.</span><span>length</span><span>)</span> <span>==</span> <span>0</span><span>)</span>
        <span>n</span> <span>=</span> <span>(</span><span>tab</span> <span>=</span> <span>resize</span><span>()).</span><span>length</span><span>;</span>
    <span>// Based on the hash we identify an empty slot in the table</span>
    <span>if</span> <span>((</span><span>p</span> <span>=</span> <span>tab</span><span>[</span><span>i</span> <span>=</span> <span>(</span><span>n</span> <span>-</span> <span>1</span><span>)</span> <span>&amp;</span> <span>hash</span><span>])</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// The slot in the tab is empty so we introduce the &lt;key, value&gt; pair here</span>
        <span>tab</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>newNode</span><span>(</span><span>hash</span><span>,</span> <span>key</span><span>,</span> <span>value</span><span>,</span> <span>null</span><span>);</span>
    <span>}</span>
    <span>else</span> <span>{</span>
       <span>// The slot is not empty, a collision happened</span>
       <span>// We append the item to the tab</span>
    <span>}</span>
    <span>// More code here</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p><code>tab[i = (n - 1) &amp; hash])</code>, where <code>n=table.length</code>, looks like magic, but it’s not.</p>

<p>Because <code>n</code> is a power of two we can use <code>(n-1) &amp; hash</code> to “project” the values from the interval <code>[Integer.MIN_VALUE, Integer.MAX_VALUE]</code> to the <code>table</code> indices: <code>{0, 1, .., n-1}</code>.</p>

<p>It’s a <a href="https://stackoverflow.com/questions/6670715/mod-of-power-2-on-bitwise-operators">simple trick</a> that works on the power of twos, helping us avoid <code>%</code> (modulo), which is a slow operation.</p>

<p>For our values:</p>

<div><div><pre><code><span>int</span> <span>n</span> <span>=</span> <span>1</span><span>&lt;&lt;</span><span>4</span><span>;</span>

<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;Paris&#34;</span><span>);</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Paris&#34;</span><span>));</span>          <span>// hash = 76885502</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>((</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>&amp;</span> <span>hash</span><span>(</span><span>&#34;Paris&#34;</span><span>));</span>  <span>// index = 14</span>

<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;Sofia&#34;</span><span>);</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Sofia&#34;</span><span>));</span>          <span>// hash = 80061639</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>((</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>&amp;</span> <span>hash</span><span>(</span><span>&#34;Sofia&#34;</span><span>));</span>  <span>// index = 7</span>

<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;Madrid&#34;</span><span>);</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Madrid&#34;</span><span>));</span>         <span>// hash = -1997818570</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>((</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>&amp;</span> <span>hash</span><span>(</span><span>&#34;Madrid&#34;</span><span>));</span> <span>// index = 6</span>

<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>&#34;Bucharest&#34;</span><span>);</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>hash</span><span>(</span><span>&#34;Bucharest&#34;</span><span>));</span>          <span>// hash = -543452922</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>((</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>&amp;</span> <span>hash</span><span>(</span><span>&#34;Bucharest&#34;</span><span>));</span>  <span>// index = 6</span>
</code></pre></div></div>

<p>So now we can visualize what is happening when we try to insert the entries into the <code>HashMap&lt;K,V&gt;</code>:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/insert-hashmap.drawio.png" alt="png"/></p>

<ol>
  <li>The first entry to insert is <code>&lt;&#34;Paris&#34;, &#34;France&#34;&gt;</code>.
    <ul>
      <li>We compute <code>hash(&#34;Paris&#34;)=76885502</code>.</li>
      <li>We create a new <code>Node&lt;String, String&gt;</code> with <code>hash=76885502</code>, <code>key=Paris</code>, <code>value=France</code> and <code>next=null</code>.</li>
      <li>Based on the <code>hash</code> we identify the <em>bucket</em> from the <code>table</code> where we are going to insert the entry.</li>
      <li>Because <code>(16-1) &amp; 76885502 = 14</code>, we insert the newly created node at position <code>table[14]</code>.</li>
    </ul>
  </li>
  <li>The second entry to insert is <code>&lt;&#34;Sofia&#34;, &#34;Bulgaria&#34;&gt;</code>.
    <ul>
      <li>We compute <code>hash(&#34;Sofia&#34;)=80061639</code>.</li>
      <li>We create a new <code>Node&lt;String, String&gt;</code> with <code>hash=80061639</code>, <code>key=Sofia</code>, <code>value=Bulgaria</code> and <code>next=null</code>.</li>
      <li>Based on the <code>hash</code> we identify the <em>bucket</em> from the <code>table</code> where we are going to insert the entry.</li>
      <li>Because <code>(16-1) &amp; 80061639 = 7</code>, we insert the newly created node at position <code>table[7]</code>.</li>
    </ul>
  </li>
  <li>The third entry to insert is <code>&lt;Madrid, Spain&gt;</code>.
    <ul>
      <li>We compute the <code>hash(&#34;Madrid&#34;)=-1997818570</code>.</li>
      <li>We create a new <code>Node&lt;String, String&gt;</code> with <code>hash=-1997818570</code>, <code>key=Madrid</code>, <code>value=Spain</code> and <code>next=null</code>.</li>
      <li>Based on the <code>hash</code> we identify the <em>bucket</em> from the <code>table</code> where we are going to insert the entry.</li>
      <li>Because <code>(16-1) &amp; (-1997818570) = 6</code>, we insert the newly created node at position <code>table[6]</code>.</li>
    </ul>
  </li>
  <li>The fourth and last entry to insert is <code>&lt;Bucharest, Romania&gt;</code>.
    <ul>
      <li>We compute the <code>hash(&#34;Bucharest&#34;)=-543452922</code>.</li>
      <li>We create a new <code>Node&lt;String, String&gt;</code> with <code>hash=-543452922</code>, <code>key=Bucharest</code>, <code>value=Romania</code> and <code>next=null</code>.</li>
      <li>Based on the <code>hash</code> we identify the <em>bucket</em> from the <code>table</code> where we are going to insert the entry.</li>
      <li>Because <code>(16-1) &amp; (-543452922) = 6</code>, we want to insert our node to <code>table[6]</code>.
        <ul>
          <li>But the position <code>table[6]</code> is already occupied!! This is called a <em>hash collision</em>.</li>
          <li>The solution is to append our newly created node to the last node from the chain (we use <code>next</code> to point to our newly created node).</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p>Now retrieving an element by its key is simple; we have to follow the same <em>trail</em> as the insertions.</p>

<p>Let’s imagine for example we want to <code>get(&#34;Bucharest&#34;)</code>:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/read-hashmap.drawio.png" alt="png"/></p>

<p>First, we compute the <code>hash(&#34;Bucharest&#34;)=-543452922</code> and the possible index where we might find the item in the <code>table</code>, <code>6 = (16-1) &amp; (-543452922)</code>.</p>

<p>At position <code>table[6]</code>, there seems to be an item already. But we don’t know for sure if it’s the item we are looking for or another item we’ve collided with when we perform the insertions.</p>

<p>In this regard we compare <code>hash(&#34;Bucharest&#34;)</code> with <code>table[6].hash</code>. In our case, the hash values are not equal, so we jump to the next item in the chain: <code>table[6].next</code>.</p>

<p>We do the hash comparison again <code>hash(&#34;Bucharest)==table[6].next.hash</code>, and this time it’s <code>true</code>.</p>

<p>To be 100% sure we get (retrieving) the correct value we do a final comparison <code>&#34;Bucharest&#34;.equals(table[6].next.key)</code>. If the two keys are equal, we’ve found the correct value. If not, we continue the two comparisons until we reach the end of the chain <code>table[6].next ... .next</code>.</p>

<blockquote>
  <p>There’s a slight chance of having two distinct <code>Strings</code> with the same <code>hash(..)</code> value. That’s why we perform the additional comparison using <code>equals(...)</code> - to make sure we eliminate this possibility.</p>
</blockquote>

<p>To make things more efficient, the <code>HashMap&lt;K,V&gt;</code> performs two types of optimizations while we insert (lots of) elements into the <code>table</code>: <em>Capacity Adjustment</em> and <em>Bucket Adjustment</em>.</p>

<p>In the <code>HashMap&lt;K,V&gt;</code> constructor, you can pass a <code>loadFactor</code> parameter. If you don’t specify a value for it, a default will be used: <code>DEFAULT_LOAD_FACTOR = 0.75f</code>. The <code>loadFactor</code> is defined as the ratio between the number of items inserted in the <code>table</code>, and the actual <code>table.length</code> (which, as we know, is a power of two).</p>

<p>If the <code>loadFactor</code> exceeds the given threshold (by default <code>0.75f</code>), a new <code>table</code> will be allocated with an increased capacity. If the current size of the table is 2<sup>n</sup>, the new size will be 2<sup>n+1</sup> (basically the next power of two).</p>

<p>After the successful re-allocation, all of the existing elements will be inserted in the new <code>Node&lt;K,V&gt;[] table</code>. Even if this is a costly operation, <em>having more air to breathe</em> will increase reading performance (<code>get(K key)</code>). Plus, it shouldn’t happen very often. Most of the time <em>Hash Tables</em> are used for reads than for inserts.</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/adjust-capacity-hashmap.drawio.png" alt="png"/></p>

<p>Another smart optimization the <code>HashMap&lt;K,V&gt;</code> performs is the <em>Bucket Adjustment</em>. The idea is simple - if the number of elements colliding inside a <code>table</code> slot (bucket) reaches a certain threshold, <code>TREEIFY_THRESHOLD = 8</code>, the pairs are re-organized in a <a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">red-black tree</a>.</p>

<p>Searching in the tree is done in logarithmic time.</p>

<p>So let’s assume this optimization is ignored, and there are 64 elements in a bucket. Searching inside a <em>linked list</em> is <code>O(n)</code>, so we will have to go through 64 iterations in the worst-case scenario. In a tree, searching is <code>O(logn)</code>, so in the worst-case scenario, we will perform log<sub>2</sub>2<sup>5</sup>= 5 operations.</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/adjust-bucket.drawio.png" alt="png"/></p>



<p>Compared to <em>Separate Chaining</em>, <em>Open Addressing</em> hash tables store only entry per slot. So there are no real <em>buckets</em>, no <em>linked lists</em>, and no <em>red-black trees</em>. It’s only one extensive array that has everything it needs to operate.</p>

<p>If the <em>array</em> of pairs is sparse enough (operating on a low load factor <code>&lt; 0.77</code>), and the <em>hashing function</em> has decent diffusion, <em>hash collisions</em> should be rare. But even so, they can happen. In this case, we probe the array to find another empty slot for the entry to be inserted.</p>

<p>The most straightforward <em>probing</em> algorithm is called <strong>linear probing</strong>. In case of collision, we iterate over each bucket (starting with the first slot computed), until we find an empty index to make the insertion. If we reach the end of the array, we start again from index <code>0</code>.</p>

<p>The advantage of <em>Open Addressing</em> over <em>Separate Chaining</em> is that cache misses are less frequent because we operate on a single contiguous block of memory (the array itself).</p>

<p>The visual representation for how inserts are working for <em>Open Addressing</em> is the following:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/open-addressing-high-level.drawio.png" alt="png"/></p>

<p>The biggest shortcoming for <em>Open Addressing</em> hash tables is that they are susceptible to lousy hash functions. Let think of it for a moment. The absolute worst hash function is one that returns a constant value. If it does so, all elements are going to target a single slot. We will have as many collisions as the number of elements.</p>

<p>In this case, the performance of <code>HashMap&lt;K,V&gt;</code> will have a graceful degrade to <code>O(logn)</code>, while the performance of an <em>Linear Probing</em> hash table implementation will degrade to <code>O(n)</code>.</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/hashmap-vs-open-addressing.drawio.png" alt="png"/></p>

<p>The above example is rather extreme, in practice, nobody will use a <em>hash function</em> that returns a constant integer. But if the <em>hash function</em> is sub-optimal, an <em>Open Addressing</em> (+Linear Probing) implementation is subject to what we call <strong>clustering</strong>: a dense area of occupied slots in our entries array that needs to be traversed in case of inserts/reads and deletes.</p>

<p>And one more thing before jumping straight to the code.</p>

<p>Deleting an element from an <em>Open Addressing</em> table is a subtle task! For this reason, we need to introduce the concept of <a href="http://localhost:4000/2021/10/02/implementing-hash-tables-in-c-part-1#tombstones"><strong>tombstones</strong></a> (click on the link for an in-depth explanation).</p>

<p>Basically, whenever we delete an entry, we cannot empty the slot and make it <code>null</code>, because we might break an existing sequence. In this regard, we mark the slot as <em>tombstone</em>:</p>
<ul>
  <li>If we are doing insert operations (<code>put(Key k, V value)</code>), we consider the tombstone a potential candidate for the insertion.</li>
  <li>If we perform read or delete operations, we skip the tombstone, and we continue the traversal to find the right spot.</li>
</ul>

<p>Whenever we need to re-adjust the size of the entries array, we don’t rehash the tombstones. After all, they are “junk” elements introduced by delete operations.</p>

<p>Algorithms that avoid tombstones altogether exist, but they make the delete operation more complex, as they involve subsequent swaps of elements to fill up the space previously occupied by the deleted element. I’ve decided not to implement them. My logic was simple:</p>

<ul>
  <li>In most of the cases, deleting an element from a <code>Map&lt;K,V&gt;</code> is not a common activity;</li>
  <li>If deletes are rare, introducing a few tombstones down the road won’t affect the performance in a significant manner.</li>
</ul>

<h2 id="lprobmapk-v"><code>LProbMap&lt;K, V&gt;</code></h2>

<p><code>LProbMap&lt;K,V&gt;</code> was my first <em>academic</em> attempt to implement an <em>Open Addressing</em> <code>Map&lt;K,V&gt;</code> in Java. I haven’t tried any trick; I’ve just implemented the corresponding algorithms <em>by the book</em>.</p>

<blockquote>
  <p>For the source code, check this <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbMap.java">link</a>.</p>
</blockquote>

<p>The first thing was to <code>extend Map&lt;K,V&gt;</code> and, as per the interface contract, I had to write an implementation for all the abstract methods. I won’t copy-paste the entire code here, but I will focus on the most important methods: <code>put</code>, <code>get</code>, <code>remove</code>, and the underlying data structures.</p>

<div><div><pre><code><span>public</span> <span>class</span> <span>LProbMap</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;</span> <span>implements</span> <span>Map</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>{</span>

    <span>private</span> <span>static</span> <span>final</span> <span>double</span> <span>DEFAULT_MAX_LOAD_FACTOR</span> <span>=</span> <span>0.6</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>double</span> <span>DEFAULT_MIN_LOAD_FACTOR</span> <span>=</span> <span>DEFAULT_MAX_LOAD_FACTOR</span> <span>/</span> <span>4</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> <span>DEFAULT_MAP_CAPACITY_POW_2</span> <span>=</span> <span>6</span><span>;</span>

    <span>private</span> <span>int</span> <span>size</span> <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>int</span> <span>tombstones</span> <span>=</span> <span>0</span><span>;</span>
    <span>private</span> <span>int</span> <span>capPow2</span> <span>=</span> <span>DEFAULT_MAP_CAPACITY_POW_2</span><span>;</span>

    <span>public</span> <span>LProbMapEntry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;[]</span> <span>buckets</span> <span>=</span> 
                        <span>new</span> <span>LProbMapEntry</span><span>[</span><span>1</span><span>&lt;&lt;</span> <span>DEFAULT_MAP_CAPACITY_POW_2</span><span>];</span>

    <span>// More code here</span>
    
<span>}</span>
</code></pre></div></div>

<p><code>DEFAULT_MAX_LOAD_FACTOR</code> is the maximum load factor my <code>LProbMap&lt;K,V&gt;</code> accepts. After this threshold is reached, the number of buckets is increased to the next power of two.</p>

<p>I’ve tried a few values, and <code>0.6</code> seems to be a decent choice for when I’ve benchmarked the read operations. At the same time, I am wasting <code>40%</code> of my <code>buckets</code> array on <code>null</code> elements. <code>0.7</code> or <code>0.77</code> are also decent choices, so it’s up to you to try them out.</p>

<p>The <code>loadFactor</code> in for <code>LProbMap&lt;K,V&gt;</code> is computed by the following formula:</p>

<div><div><pre><code><span>final</span> <span>double</span> <span>lf</span> <span>=</span> <span>(</span><span>double</span><span>)(</span><span>size</span><span>+</span><span>tombstones</span><span>)</span> <span>/</span> <span>buckets</span><span>.</span><span>length</span><span>;</span>
</code></pre></div></div>

<p>So compared to <code>HashMap&lt;K,V&gt;</code>, tombstones have an influence on this metric.</p>

<p><code>DEFAULT_MIN_LOAD_FACTOR</code> is the minimum acceptable load factor before we reduce the size of <code>buckets</code> to the previous power of two.</p>

<p><code>DEFAULT_MAP_CAPACITY_POW_2</code> is the default power of two that we use to compute the capacity of the <code>buckets</code> (<code>buckets.length == 1&lt;&lt;6 == 64</code>).</p>

<p>An important aspect is to also define a static <code>hash(Object object)</code> function:</p>

<div><div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>hash</span><span>(</span><span>final</span> <span>Object</span> <span>obj</span><span>)</span> <span>{</span>
    <span>int</span> <span>h</span> <span>=</span> <span>obj</span><span>.</span><span>hashCode</span><span>();</span>
    <span>h</span> <span>^=</span> <span>h</span> <span>&gt;&gt;</span> <span>16</span><span>;</span>
    <span>h</span> <span>*=</span> <span>0x3243f6a9</span><span>;</span>
    <span>h</span> <span>^=</span> <span>h</span> <span>&gt;&gt;</span> <span>16</span><span>;</span>
    <span>return</span> <span>h</span> <span>&amp;</span> <span>0xfffffff</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>As you can see, we (re)use Java’s <code>obj.hashCode()</code> method. We also apply a <em>finalizer</em> to it, inspired by <a href="https://en.wikipedia.org/wiki/MurmurHash">Murmur Hash</a>. The reason to shift/xor/multiply/shift/xor is to make better use of the high order bits of the object key.</p>

<p>The last line <code>h &amp; 0xfffffff</code> ensures that the returned value is not a negative number. In Java, compared to C, for example, there is no <code>uint32_t</code> type, so we need to consider the sign. Doing this, we are invalidating (through others) the bit containing the sign.</p>

<p>In regards to the <code>Map&lt;K,V&gt;</code> contract, we need to use entries extending the <code>Map.Entry&lt;K,V&gt;</code> class.</p>

<div><div><pre><code><span>protected</span> <span>static</span> <span>class</span> <span>LProbMapEntry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;</span> <span>implements</span> <span>Map</span><span>.</span><span>Entry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;</span> <span>{</span>

    <span>public</span> <span>K</span> <span>key</span><span>;</span>
    <span>public</span> <span>V</span> <span>value</span><span>;</span>
    <span>public</span> <span>int</span> <span>hash</span><span>;</span>

    <span>public</span> <span>LProbMapEntry</span><span>(</span><span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>,</span> <span>int</span> <span>hash</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>key</span> <span>=</span> <span>key</span><span>;</span>
        <span>this</span><span>.</span><span>value</span> <span>=</span> <span>value</span><span>;</span>
        <span>this</span><span>.</span><span>hash</span> <span>=</span> <span>hash</span><span>;</span>
    <span>}</span>

    <span>// More code here</span>
<span>}</span>
</code></pre></div></div>

<h3 id="inserting-an-entry">Inserting an entry</h3>

<p>Inserting an entry in the <code>LProbMap&lt;K, V&gt;</code> is straightforward, and the algorithm is as follows:</p>
<ul>
  <li>We increase capacity if the <em>load factor</em> is bigger than what we’ve decided to be the threshold;</li>
  <li>We compute the base bucket (slot);
    <ul>
      <li>If the bucket is <code>null</code>, we insert the element and increment the size;</li>
      <li>Otherwise, we iterate forever (<code>while(true)</code>) using linear probing, until we either:
        <ul>
          <li>Find a tombstone to insert the entry, then we decrement the number of tombstones and increase the size. We return <code>null</code>;</li>
          <li>Find an empty bucket, we increase the size. We return <code>null</code>;</li>
          <li>Find the exact element, and we update the value. We return the <code>oldVal</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>The only difference to the <code>HashMap&lt;K,V&gt;</code> is that we don’t accept <code>null</code> keys. The reason is simple, we use entries with <code>null</code> keys as tombstones. This is our convention.</p>

<div><div><pre><code><span>@Override</span>
<span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>null</span><span>==</span><span>key</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>&#34;Map doesn&#39;t support null keys&#34;</span><span>);</span>
    <span>}</span>
    <span>return</span> <span>put</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>,</span> <span>hash</span><span>(</span><span>key</span><span>));</span>
<span>}</span>

<span>// This method is not called directly, so there&#39;s no need </span>
<span>// to check if key is null</span>
<span>protected</span> <span>V</span> <span>put</span><span>(</span><span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>,</span> <span>int</span> <span>hash</span><span>)</span> <span>{</span>
    <span>// We increase capacity if it&#39;s needed</span>
    <span>increaseCapacity</span><span>();</span>
    <span>// We calculate the base bucket for the entry</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>// If the slot is empty, we insert the new item</span>
        <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// It&#39;s a free spot</span>
            <span>buckets</span><span>[</span><span>idx</span><span>]</span> <span>=</span> <span>new</span> <span>LProbMapEntry</span><span>&lt;&gt;(</span><span>key</span><span>,</span> <span>value</span><span>,</span> <span>hash</span><span>);</span>
            <span>size</span><span>++;</span>
            <span>// No value was updated so we return null</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// It&#39;s a tombstone</span>
            <span>// We update the entry with the new values</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>=</span> <span>key</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span> <span>=</span> <span>value</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>=</span> <span>hash</span><span>;</span>
            <span>size</span><span>++;</span>
            <span>// No value was updated so we return null</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>==</span> <span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>))</span> <span>{</span>
            <span>// The element already existed in the map</span>
            <span>// We keep the old value to return it later</span>
            <span>// We update the element to new value</span>
            <span>V</span> <span>ret</span><span>;</span>
            <span>ret</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span> <span>=</span> <span>value</span><span>;</span>
            <span>// We return the value that was replaced</span>
            <span>return</span> <span>ret</span><span>;</span>
        <span>}</span>
        <span>// Linear probing algorithm</span>
        <span>// We jump to the next item</span>
        <span>// In case we&#39;ve reached the end of the list </span>
        <span>// we start again</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>==</span><span>idx</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>In code above, one line that can look awkward, if you are not familiar with bitwise operations, is <code>int idx = hash &amp; (buckets.length-1)</code>. This is used to calculate the <em>base</em> slot for the entry. We define the <em>base</em> slot as the <em>most natural</em> position an entry could have in our <code>buckets</code> array, if there are no collisions.</p>

<p><code>LProbMap&lt;K,V&gt;.hash(Object key)</code> will always return a positive integer in the interval <code>[0, Integer.MAX_VALUE]</code>. But we have only <code>buckets.length</code> slots available to insert the item. Typically, we could write <code>hash(key) % buckets.length</code> to return the base slot. But modulo <code>%</code> operation is kinda slow.</p>

<blockquote>
  <p>Multiplication and division take a longer time. Integer multiplication takes 11 clock cycles on Pentium 4 processors and 3 - 4 clock cycles on most other microprocessors. Integer division takes 40 - 80 clock cycles, depending on the microprocessor. Integer division is faster the smaller the integer size on AMD processors, but not on Intel processors. Details about instruction latencies are listed in manual 4: “Instruction tables”. Tips about how to speed up multiplications and divisions are given on pages 146 and 147, respectively. (<a href="https://www.agner.org/optimize/optimizing_cpp.pdf">source</a>).</p>
</blockquote>

<p>Honestly, I don’t know how the JVM is optimizing the code behind the scenes, so the best thing was to make sure optimizations were happening by using a simple bitwise trick.</p>

<p>Because <code>buckets.length</code> is a power of two, <code>hash(key) % buckets.length</code> is equivalent to writing <code>hash(key) &amp; (buckets.length -1)</code>. If you don’t believe me, just run the following code:</p>

<div><div><pre><code><span>int</span> <span>size</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span> <span>// 16</span>
<span>for</span><span>(</span><span>int</span> <span>i</span> <span>=</span> <span>100</span><span>;</span> <span>i</span> <span>&lt;</span> <span>1000</span><span>;</span> <span>i</span><span>++)</span> <span>{</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>printf</span><span>(</span><span>&#34;%d %% %d = %d --- AND ---- %d &amp; (%d -1) = %d\n&#34;</span><span>,</span> 
        <span>i</span><span>,</span> <span>size</span><span>,</span> <span>i</span> <span>%</span> <span>size</span><span>,</span> <span>i</span><span>,</span> <span>size</span><span>,</span> <span>i</span> <span>&amp;</span> <span>(</span><span>size</span><span>-</span><span>1</span><span>));</span>
<span>}</span>

<span>// Output</span>

<span>// 100 % 16 = 4 --- AND ---- 100 &amp; (16 -1) = 4</span>
<span>// 101 % 16 = 5 --- AND ---- 101 &amp; (16 -1) = 5</span>
<span>// 102 % 16 = 6 --- AND ---- 102 &amp; (16 -1) = 6</span>
<span>// 103 % 16 = 7 --- AND ---- 103 &amp; (16 -1) = 7</span>
<span>// 104 % 16 = 8 --- AND ---- 104 &amp; (16 -1) = 8</span>
<span>// 105 % 16 = 9 --- AND ---- 105 &amp; (16 -1) = 9</span>

<span>// and so on</span>
</code></pre></div></div>

<p><em>The trick</em> has an easy visual explanation. Let’s look at an example, <code>1001 &amp; (32-1)</code> and why it’s equivalent with <code>1001 % 32</code>:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/bitwise-modulo.drawio.png" alt="png"/></p>

<p>After the number is “cut”, the maximum value of 5 remaining bits is <code>31</code> (<code>0...00011111</code>).</p>

<h3 id="retrieving-an-entry">Retrieving an entry</h3>

<p>The algorithm for retrieving a <code>V value</code> by it’s <code>Object key</code> is the following:</p>
<ul>
  <li>We compute the <code>hash(key)</code>;</li>
  <li>We compute the base slot: <code>idx = hash &amp; (buckets.length-1)</code>;</li>
  <li>If the base slot is <code>null</code>, <code>bucket[idx]==null</code> , then we are 100% sure there’s no need to look further, and we return <code>null</code>;</li>
  <li>Otherwise, we check to see if the key’s <code>hash</code> matches the node’s <code>hash</code>
    <ul>
      <li>If they do, we do an additional check to see if the keys are equal. We do this extra step because there’s a small chance that two different elements have the same <code>hash</code>.
        <ul>
          <li>If not, we probe further;</li>
          <li>If they are <code>equals()</code>, we return the <code>V value</code>;</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>We repeat until we encounter a <code>null</code> slot, which means we’ve finished traversing the potential cluster of entries without finding what we were looking for.</li>
</ul>

<div><div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
    <span>int</span> <span>hash</span> <span>=</span> <span>hash</span><span>(</span><span>key</span><span>);</span>
    <span>// We determine the base bucket</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>LProbMapEntry</span><span>&lt;</span><span>K</span><span>,</span><span>V</span><span>&gt;</span> <span>bucket</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>];</span>
    <span>// If the base is null we return null</span>
    <span>if</span> <span>(</span><span>bucket</span><span>==</span><span>null</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>do</span> <span>{</span>
        <span>// If we found the element we return the value, </span>
        <span>// breaking the loop</span>
        <span>if</span> <span>(</span><span>bucket</span><span>.</span><span>hash</span> <span>==</span> <span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>bucket</span><span>.</span><span>key</span><span>))</span> <span>{</span>
            <span>return</span> <span>bucket</span><span>.</span><span>value</span><span>;</span>
        <span>}</span>
        <span>// We jump to the next element by using linear probing</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>idx</span><span>==</span><span>buckets</span><span>.</span><span>length</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
        <span>bucket</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>];</span>
    <span>}</span> <span>while</span><span>(</span><span>null</span><span>!=</span><span>bucket</span><span>);</span>
    <span>// We couldn&#39;t find any element,</span>
    <span>// We simply return null</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h3 id="deleting-an-entry">Deleting an entry</h3>

<p>The algorithm for deleting an entry is as follows:</p>

<ul>
  <li>We identify the base slot (the one bucket where we look first);</li>
  <li>If the base is <code>null</code>, there’s no reason to continue probing, we return <code>null</code>;</li>
  <li>Otherwise, we check to see if the slot’s <code>hash</code> matches the key’s <code>hash</code>. (If they do, we compare the keys using <code>equals()</code>).
    <ul>
      <li>If the element is present we remove it by inserting a tombstone;</li>
      <li>We return the old value;</li>
    </ul>
  </li>
  <li>We continue with the last step until the slot is <code>null</code>.</li>
  <li>We decrease the capacity if needed.</li>
</ul>

<div><div><pre><code><span>public</span> <span>V</span> <span>remove</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
     <span>// We determine the base bucket</span>
    <span>int</span> <span>hash</span> <span>=</span> <span>hash</span><span>(</span><span>key</span><span>);</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>// If the base is null, there&#39;s no reason to continue probing</span>
    <span>// We simply return null</span>
    <span>if</span> <span>(</span><span>null</span><span>==</span><span>buckets</span><span>[</span><span>idx</span><span>])</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>do</span> <span>{</span>
        <span>// If we found the bucket we insert a tombstone </span>
        <span>// Increment the number of tombstones</span>
        <span>// and reduce the real size</span>
        <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>==</span> <span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>))</span> <span>{</span>
            <span>V</span> <span>oldVal</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>=</span> <span>null</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span> <span>=</span> <span>null</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>=</span> <span>0</span><span>;</span>
            <span>tombstones</span><span>++;</span>
            <span>size</span><span>--;</span>
            <span>return</span> <span>oldVal</span><span>;</span>
        <span>}</span>
        <span>// Continue with linear probing</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>idx</span> <span>==</span> <span>buckets</span><span>.</span><span>length</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span> <span>while</span> <span>(</span><span>null</span> <span>!=</span> <span>buckets</span><span>[</span><span>idx</span><span>]);</span>
    <span>decreaseCapacity</span><span>();</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<h3 id="resizing-and-rehashing">Resizing and rehashing</h3>

<p>We will follow the same trick as <code>HashMap&lt;K,V&gt;</code> in regards to capacity re-adjustment. If the <em>load factor</em> reaches a certain max threshold, we increase the capacity of the <code>buckets</code> to the next power of two. Vice-versa, if the <em>load factor</em> reaches a min threshold, we decrease the capacity of the <code>buckets</code> to the previous power of two. A full-rehashing is also happening.</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/resize-rehash.drawio.png" alt="png"/></p>

<p>Capacity re-adjustment is performed to reduce the <em>clustering effect</em> and to remove the previously inserted junk elements (<em>tombstones</em>). After a capacity re-adjustment, there are simply more slots available to insert the entries so the <code>buckets</code> array will become more sparse.</p>

<p>The code:</p>

<div><div><pre><code><span>protected</span> <span>final</span> <span>void</span> <span>reHashElements</span><span>(</span><span>int</span> <span>capModifier</span><span>)</span> <span>{</span>
    <span>// We modify the next power of two either +1 or -1</span>
    <span>this</span><span>.</span><span>capPow2</span><span>+=</span><span>capModifier</span><span>;</span>
    <span>// We keep a reference to the old buckets</span>
    <span>LProbMapEntry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;[]</span> <span>oldBuckets</span> <span>=</span> <span>this</span><span>.</span><span>buckets</span><span>;</span>
    <span>// We allocate memory for new buckets</span>
    <span>this</span><span>.</span><span>buckets</span> <span>=</span> <span>new</span> <span>LProbMapEntry</span><span>[</span><span>1</span> <span>&lt;&lt;</span> <span>capPow2</span><span>];</span>
    <span>this</span><span>.</span><span>size</span> <span>=</span> <span>0</span><span>;</span>
    <span>this</span><span>.</span><span>tombstones</span> <span>=</span> <span>0</span><span>;</span>
    <span>// We perform a full-rehash by re-insert all elements</span>
    <span>// We don&#39;t re-compute the hash, because it was already computed </span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>oldBuckets</span><span>.</span><span>length</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>null</span> <span>!=</span> <span>oldBuckets</span><span>[</span><span>i</span><span>]</span> <span>&amp;&amp;</span> <span>oldBuckets</span><span>[</span><span>i</span><span>].</span><span>key</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span><span>put</span><span>(</span><span>oldBuckets</span><span>[</span><span>i</span><span>].</span><span>key</span><span>,</span> <span>oldBuckets</span><span>[</span><span>i</span><span>].</span><span>value</span><span>,</span> <span>oldBuckets</span><span>[</span><span>i</span><span>].</span><span>hash</span><span>);</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>protected</span> <span>final</span> <span>void</span> <span>increaseCapacity</span><span>()</span> <span>{</span>
    <span>final</span> <span>double</span> <span>lf</span> <span>=</span> <span>(</span><span>double</span><span>)(</span><span>size</span><span>+</span><span>tombstones</span><span>)</span> <span>/</span> <span>buckets</span><span>.</span><span>length</span><span>;</span>
    <span>if</span> <span>(</span><span>lf</span> <span>&gt;</span> <span>DEFAULT_MAX_LOAD_FACTOR</span><span>)</span> <span>{</span>
        <span>reHashElements</span><span>(</span><span>1</span><span>);</span>
    <span>}</span>
<span>}</span>

<span>protected</span> <span>final</span> <span>void</span> <span>decreaseCapacity</span><span>()</span> <span>{</span>
    <span>final</span> <span>double</span> <span>lf</span> <span>=</span> <span>(</span><span>double</span><span>)(</span><span>size</span><span>)</span> <span>/</span> <span>buckets</span><span>.</span><span>length</span><span>;</span>
    <span>if</span> <span>(</span><span>lf</span> <span>&lt;</span> <span>DEFAULT_MIN_LOAD_FACTOR</span> <span>&amp;&amp;</span> <span>this</span><span>.</span><span>capPow2</span> <span>&gt;</span> <span>DEFAULT_MAP_CAPACITY_POW_2</span><span>)</span> <span>{</span>
        <span>reHashElements</span><span>(-</span><span>1</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>This approach is a little <em>naive</em>, but it works. It can be improved by computing in advance the actual value when we are going to trigger the rehash, so we don’t have to do final <code>double lf = (double)(size) / buckets.length;</code> at each insert/remove.</p>

<p>Also, depending on how many tombstones were created, we can reduce the capacity to <code>reHashElements(-2)</code> or <code>reHashElements(-3)</code> directly.</p>

<h2 id="perturbmapk-v"><code>PerturbMap&lt;K, V&gt;</code></h2>

<p><a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/PerturbMap.java"><code>PerturbMap&lt;K,V&gt;</code></a> is my second approach of implementing an <em>Open Addressing</em> <code>Map&lt;K,V&gt;</code>, and it’s almost identical to <code>LProbMap&lt;K,V&gt;</code> with one significant change.</p>

<p>Reading the <a href="https://github.com/python/cpython/blob/main/Objects/dictobject.c">source code</a> for cpython’s <code>dict</code> implementation I’ve stumbled upon those lines:</p>

<div><div><pre><code>(...)

This is done by initializing a (unsigned) vrbl &#34;perturb&#34; to the

full hash code, and changing the recurrence to:

    perturb &gt;&gt;= PERTURB_SHIFT;
    j = (5*j) + 1 + perturb;
    use j % 2**i as the next table index;

(...)
</code></pre></div></div>

<p>To avoid clustering (that depends on how good our hash function is), a new strategy for probing is proposed, one that doesn’t use <em>linear probing</em>, but instead tries to <em>scramble</em> the entries positions by itself.</p>

<p>So instead of <em>cycling</em> through the array with:</p>

<div><div><pre><code><span>idx</span><span>++</span>
<span>if</span> <span>(</span><span>idx</span> <span>==</span> <span>buckets</span><span>.</span><span>length</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
</code></pre></div></div>

<p>We will do something like:</p>

<div><div><pre><code><span>idx</span> <span>=</span> <span>5</span> <span>*</span> <span>idx</span> <span>+</span> <span>1</span> <span>+</span> <span>perturb</span><span>;</span>
<span>perturb</span><span>&gt;&gt;=</span> <span>SHIFTER</span><span>;</span>
<span>idx</span> <span>=</span> <span>idx</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
</code></pre></div></div>

<p>Where <code>SHIFTER</code> is a constant, that equals to 5, and <code>peturb</code> is initialized to <code>peturb=hash</code>.</p>

<p>To make things clearer, let’s look at the following example. Let’s assume our initial <code>hash=32132932</code>, <code>shifter=5</code> and <code>bucketsLength=1&lt;&lt;4</code>. Let’s see how the probing goes if we use this algorithm:</p>

<div><div><pre><code><span>final</span> <span>int</span> <span>hash</span> <span>=</span> <span>32132932</span><span>;</span>
<span>final</span> <span>int</span> <span>shifter</span> <span>=</span> <span>5</span><span>;</span>
<span>final</span> <span>int</span> <span>bucketsLength</span> <span>=</span> <span>1</span> <span>&lt;&lt;</span> <span>4</span><span>;</span>

<span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>bucketsLength</span><span>-</span><span>1</span><span>);</span>
<span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>idx</span><span>);</span>

<span>int</span> <span>j</span> <span>=</span> <span>5</span><span>;</span>
<span>int</span> <span>perturb</span> <span>=</span> <span>hash</span><span>;</span>
<span>while</span><span>(</span><span>j</span><span>--&gt;</span><span>0</span><span>)</span> <span>{</span>
    <span>idx</span> <span>=</span> <span>5</span> <span>*</span> <span>idx</span> <span>+</span> <span>perturb</span><span>;</span>
    <span>perturb</span><span>&gt;&gt;=</span><span>shifter</span><span>;</span>
    <span>idx</span> <span>=</span> <span>idx</span> <span>&amp;</span> <span>(</span><span>bucketsLength</span><span>-</span><span>1</span><span>);</span>
    <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>idx</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The output is:</p>



<p>Visually, the probing algorithm looks like this:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/perturb.drawio.png" alt="png"/></p>

<p>You can access all the code here, but as an example, this is how the <code>get(Object key)</code> looks like:</p>

<div><div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>null</span><span>==</span><span>key</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>&#34;Map doesn&#39;t support null keys&#34;</span><span>);</span>
    <span>}</span>
    <span>int</span> <span>hash</span> <span>=</span> <span>hash32</span><span>(</span><span>key</span><span>);</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>if</span> <span>(</span><span>null</span> <span>==</span> <span>buckets</span><span>[</span><span>idx</span><span>])</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>int</span> <span>perturb</span> <span>=</span> <span>hash</span><span>;</span>
    <span>do</span> <span>{</span>
        <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>==</span> <span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>))</span> <span>{</span>
            <span>return</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span><span>;</span>
        <span>}</span>
        <span>// !! Different than LProbMap&lt;K,V&gt; !!</span>
        <span>idx</span> <span>=</span> <span>5</span> <span>*</span> <span>idx</span> <span>+</span> <span>1</span> <span>+</span> <span>perturb</span><span>;</span>
        <span>perturb</span><span>&gt;&gt;=</span> <span>SHIFTER</span><span>;</span>
        <span>idx</span> <span>=</span> <span>idx</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>}</span> <span>while</span> <span>(</span><span>null</span> <span>!=</span> <span>buckets</span><span>[</span><span>idx</span><span>]);</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Now, in terms of performance:</p>
<ul>
  <li>We combat clustering by augmenting the diffusion of the hashing function with this simple trick;</li>
  <li>We potentially increase the number of cache misses, because elements that were previously sharing the same locality are now spread across the <code>buckets</code>.</li>
</ul>

<h2 id="lprobbinsmapkv"><code>LProbBinsMap&lt;K,V&gt;</code></h2>

<p>This is another almost identical implementation to <code>LProbMap&lt;K,V&gt;</code>, but with an extra change inspired by <a href="https://github.com/ruby/ruby/blob/master/st.c">ruby’s hash table implementation</a>. For simplicity, I’ve opted to use <em>linear probing</em> as the probing algorithm.</p>

<blockquote>
  <p>For the full source code please check <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbBinsMap.java">this link</a></p>
</blockquote>

<p>The main idea is to avoid keeping everything inside the <code>buckets</code> array, so we split the information between two arrays:</p>

<ul>
  <li><code>int[] bins</code></li>
  <li><code>Map.Entry&lt;K,V&gt;[] entries</code></li>
</ul>

<p><code>bin</code> is (sparse) array of integer values that where we keep the indices of the entries.</p>

<p><code>entries</code> is an <code>ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;</code>-like structure, that is dense. Here is were we store the actual keys, values, hashes.</p>

<p>Visually <code>LProbBinsMAp&lt;K,V&gt;</code> looks like this:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/binsandentries.drawio.png" alt="png"/></p>

<p>To find the base bucket we do a look-up inside <code>bins</code>, where we keep the index of <code>entries</code>.</p>

<p>Code wise, this is only a re-interpretation of <code>LProbMap&lt;K,V</code>. As an example this is how the <code>get(Object key)</code> method looks like:</p>

<div><div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>null</span><span>==</span><span>key</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>&#34;Map doesn&#39;t support null keys&#34;</span><span>);</span>
    <span>}</span>
    <span>int</span> <span>hash</span> <span>=</span> <span>hash</span><span>(</span><span>key</span><span>);</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>bins</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>if</span> <span>(</span><span>bins</span><span>[</span><span>idx</span><span>]==</span><span>EMPTY_SLOT</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>do</span> <span>{</span>
        <span>if</span> <span>(</span><span>bins</span><span>[</span><span>idx</span><span>]!=</span><span>TOMBSTONE</span> <span>&amp;&amp;</span> <span>entries</span><span>[</span><span>bins</span><span>[</span><span>idx</span><span>]].</span><span>hash</span><span>==</span><span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>entries</span><span>[</span><span>bins</span><span>[</span><span>idx</span><span>]].</span><span>key</span><span>))</span> <span>{</span>
            <span>return</span> <span>entries</span><span>[</span><span>bins</span><span>[</span><span>idx</span><span>]].</span><span>value</span><span>;</span>
        <span>}</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>idx</span> <span>==</span> <span>bins</span><span>.</span><span>length</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span> <span>while</span><span>(</span><span>bins</span><span>[</span><span>idx</span><span>]!=</span><span>EMPTY_SLOT</span><span>);</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The advantage of this approach should be reduced memory consumption and increased memory locality.</p>

<h2 id="lprobradarmapk-v"><code>LProbRadarMap&lt;K, V&gt;</code></h2>

<p><code>LProbRadarMap&lt;K,V&gt;</code> is an original attempt to write an implementation for <code>Map&lt;K,V&gt;</code>, that fights clustering, by keeping a <code>radar</code> like structure that tracks the neighborhood of an element.</p>

<blockquote>
  <p>For the full source code please check <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbRadarMap.java">this link</a></p>
</blockquote>

<p>The <code>radar[i]</code> keeps track of all the elements of <code>buckets</code> that have the base in <code>i</code> and are spread in the next 32 positions.</p>

<p>To better understand, let’s look at the following diagram:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/radar.drawio.png" alt="png"/></p>

<p><code>buckets[2]</code> doesn’t have the base in <code>1</code>, so the second bit of <code>radar[1]</code> is 0.</p>

<p><code>bucket[3]</code>, <code>buckets[5]</code> and <code>buckets[6]</code> have the base in <code>1</code>, so we set to 1 the corresponding bits in <code>radar[1]</code>.</p>

<p>Inserting an element in the <code>LProbRadarMap&lt;K,V&gt;</code> looks like this:</p>

<div><div><pre><code><span>protected</span> <span>V</span> <span>put</span><span>(</span><span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>,</span> <span>int</span> <span>hash</span><span>)</span> <span>{</span>
    <span>// We increase the capacity if needed</span>
    <span>if</span> <span>(</span><span>shouldGrow</span><span>())</span> <span>{</span>
        <span>grow</span><span>();</span>
    <span>}</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>int</span> <span>base</span> <span>=</span> <span>idx</span><span>;</span>
    <span>int</span> <span>probing</span> <span>=</span> <span>0</span><span>;</span>
    <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>
        <span>// We increase the capacity if we exit the radar</span>
        <span>if</span> <span>(</span><span>probing</span><span>==</span><span>32</span><span>)</span> <span>{</span>
            <span>grow</span><span>();</span>
            <span>return</span> <span>put</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>,</span> <span>hash</span><span>);</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// It&#39;s a free spot</span>
            <span>buckets</span><span>[</span><span>idx</span><span>]</span> <span>=</span> <span>new</span> <span>LProbEntry</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>,</span> <span>hash</span><span>);</span>
            <span>// We mark the bit in the radar entry</span>
            <span>radar</span><span>[</span><span>base</span><span>]</span> <span>|=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>probing</span><span>);</span>
            <span>size</span><span>++;</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// It&#39;s a tombstone</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>=</span> <span>key</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>val</span> <span>=</span> <span>value</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>=</span> <span>hash</span><span>;</span>
            <span>radar</span><span>[</span><span>base</span><span>]</span> <span>|=</span> <span>(</span><span>1</span> <span>&lt;&lt;</span> <span>probing</span><span>);</span>
        <span>}</span>
        <span>else</span> <span>if</span> <span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>==</span> <span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>))</span> <span>{</span>
            <span>// We perform an update on the element</span>
            <span>V</span> <span>ret</span><span>;</span>
            <span>ret</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>val</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>=</span> <span>key</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>=</span> <span>hash</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>val</span> <span>=</span> <span>value</span><span>;</span>
            <span>return</span> <span>ret</span><span>;</span>
        <span>}</span>
        <span>probing</span><span>++;</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>==</span><span>idx</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The algorithm for retrieving an element from <code>LProbRadarMap&lt;K,V&gt;</code> is the following:</p>

<div><div><pre><code><span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> <span>key</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>null</span><span>==</span><span>key</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>&#34;Map doesn&#39;t support null keys&#34;</span><span>);</span>
    <span>}</span>
    <span>int</span> <span>hash</span> <span>=</span> <span>hash</span><span>(</span><span>key</span><span>);</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span><span>-</span><span>1</span><span>);</span>
    <span>int</span> <span>rd</span> <span>=</span> <span>radar</span><span>[</span><span>idx</span><span>];</span>
    <span>if</span> <span>(</span><span>rd</span><span>==</span><span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>for</span><span>(</span><span>int</span> <span>bit</span> <span>=</span> <span>0</span><span>;</span> <span>bit</span> <span>&lt;</span> <span>32</span><span>;</span> <span>bit</span><span>++)</span> <span>{</span>
        <span>if</span> <span>(((</span><span>rd</span><span>&gt;&gt;</span><span>bit</span><span>)&amp;</span><span>1</span><span>)==</span><span>1</span> <span>&amp;&amp;</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>==</span> <span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>))</span> <span>{</span>
            <span>return</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>val</span><span>;</span>
        <span>}</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>idx</span> <span>==</span> <span>buckets</span><span>.</span><span>length</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>To be honest, doing this doesn’t achieve much because doing the bit check <code>(rd&gt;&gt;bit)&amp;1)==1</code> is not necessarily more efficient than just verifying if the <code>bucket[idx]</code>is <code>null</code>.</p>

<p>Also, enforcing this:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>probing</span><span>==</span><span>32</span><span>)</span> <span>{</span>
    <span>grow</span><span>();</span>
    <span>return</span> <span>put</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>,</span> <span>hash</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>it’s <em>dangerous</em> approach. We have no control on how the inserted <code>Object key</code> implements its <code>hashCode()</code>, so a bad <code>hashCode()</code> function might form clusters bigger than <code>32</code> (which is the maximum <code>radar</code> size for each element). In this regard, our <code>buckets</code> array can grow indefinitely until eventually crashing with an OOM.</p>

<p>Nevertheless, it was a fun exercise.</p>

<h2 id="robinhoodmapk-v"><code>RobinHoodMap&lt;K, V&gt;</code></h2>

<p>This was my last attempt at implementing an <em>Open Addressing</em> hash table, using the <a href="https://en.wikipedia.org/wiki/Hash_table#Robin_Hood_hashing">Robin Hood</a> hashing technique.</p>

<blockquote>
  <p>For the full source code please check <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/RobinHoodMap.java">this link</a></p>
</blockquote>

<p><em>Robin Hood</em> works exactly as <em>Linear Probing</em>, with one more addition. When we insert a new entry, we also keep track of how it is from its base. In this regard, we add a new attribute to the inner <code>Map.Entry&lt;K,V&gt;</code>:</p>

<div><div><pre><code><span>public</span> <span>static</span> <span>class</span> <span>Entry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;</span> <span>implements</span> <span>Map</span><span>.</span><span>Entry</span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>&gt;</span> <span>{</span>

    <span>private</span> <span>K</span> <span>key</span><span>;</span>
    <span>private</span> <span>V</span> <span>value</span><span>;</span>
    <span>private</span> <span>int</span> <span>hash</span><span>;</span>
    <span>private</span> <span>int</span> <span>dist</span><span>;</span> <span>// &lt;--</span>

    <span>// (more code)</span>
<span>}</span>
</code></pre></div></div>

<p><code>dist</code> signifies the distance of the entry from its base.</p>

<p>Whenever a new entry is inserted, we try to put it as close as possible to its base slot, displacing <em>older</em> entries in the process and putting them closer to the clusters’ edge.</p>

<p>Let’s look at the following example:</p>

<p><img src="https://www.andreinc.net/assets/images/2021-11-08-a-tale-of-java-hash-tables/robinhood.drawio.png" alt="png"/></p>

<ul>
  <li>We want to insert <code>&#34;B&#34;</code>. The base slot for <code>&#34;B&#34;</code> is <code>3</code>.</li>
  <li>We try to insert <code>&#34;B&#34;</code> at index <code>3</code>. But <code>distance(B,3) == 0 &lt; distance(X,2) == 1</code> so we don’t do a swap;</li>
  <li>We try to insert <code>&#34;B&#34;</code> at index <code>4</code>. But <code>distance(B,3) == 1 &lt; distance(D,2) == 2</code> so we don’t do a swap;</li>
  <li>We try to insert <code>&#34;B&#34;</code> at index <code>5</code>. <code>distance(B,3) == 2 &gt; distance(F,4) == 1</code> so we swap <code>B</code> with <code>F</code> and we continue in the same manner to insert <code>F</code>.</li>
</ul>

<p>The <code>get</code> and <code>remove</code> operations are exactly as for <code>LProbMap&lt;K,V&gt;</code>, but what it differs is the <code>put</code> operation:</p>

<div><div><pre><code><span>protected</span> <span>V</span> <span>put</span><span>(</span><span>K</span> <span>key</span><span>,</span> <span>V</span> <span>value</span><span>,</span> <span>int</span> <span>hash</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>null</span><span>==</span><span>key</span><span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>&#34;Map doesn&#39;t support null keys&#34;</span><span>);</span>
    <span>}</span>
    <span>increaseCapacity</span><span>();</span>
    <span>K</span> <span>cKey</span> <span>=</span> <span>key</span><span>;</span>
    <span>V</span> <span>cVal</span> <span>=</span> <span>value</span><span>;</span>
    <span>int</span> <span>cHash</span> <span>=</span> <span>hash</span><span>;</span>
    <span>V</span> <span>old</span> <span>=</span> <span>null</span><span>;</span>
    <span>int</span> <span>probing</span> <span>=</span> <span>0</span><span>;</span>
    <span>// Identifying the base slot</span>
    <span>int</span> <span>idx</span> <span>=</span> <span>hash</span> <span>&amp;</span> <span>(</span><span>buckets</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>);</span>
    <span>while</span> <span>(</span><span>true</span><span>){</span>
        <span>// If the bucket is empty we simply insert the element and we break the loop</span>
        <span>if</span> <span>(</span><span>null</span> <span>==</span> <span>buckets</span><span>[</span><span>idx</span><span>])</span> <span>{</span>
            <span>buckets</span><span>[</span><span>idx</span><span>]</span> <span>=</span> <span>new</span> <span>Entry</span><span>&lt;&gt;(</span><span>cKey</span><span>,</span> <span>cVal</span><span>,</span> <span>cHash</span><span>,</span> <span>probing</span><span>);</span>
            <span>this</span><span>.</span><span>size</span><span>++;</span>
            <span>break</span><span>;</span>
        <span>}</span> 
        <span>// If we found the bucket, we just update the value</span>
        <span>else</span> <span>if</span> <span>(</span><span>hash</span> <span>==</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>&amp;&amp;</span> <span>key</span><span>.</span><span>equals</span><span>(</span><span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>))</span> <span>{</span>
            <span>old</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span> <span>=</span> <span>value</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>dist</span> <span>=</span> <span>probing</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span> 
        <span>// We probe &amp; swap until we find the right slot</span>
        <span>else</span> <span>if</span> <span>(</span><span>probing</span> <span>&gt;</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>dist</span><span>)</span> <span>{</span>
            <span>K</span> <span>tmpKey</span><span>;</span>
            <span>V</span> <span>tmpVal</span><span>;</span>
            <span>int</span> <span>tmpHash</span><span>;</span>
            <span>int</span> <span>tmpDist</span><span>;</span>
            <span>tmpHash</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span><span>;</span>
            <span>tmpVal</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span><span>;</span>
            <span>tmpDist</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>dist</span><span>;</span>
            <span>tmpKey</span> <span>=</span> <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>hash</span> <span>=</span> <span>cHash</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>value</span> <span>=</span> <span>cVal</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>key</span> <span>=</span> <span>cKey</span><span>;</span>
            <span>buckets</span><span>[</span><span>idx</span><span>].</span><span>dist</span> <span>=</span> <span>probing</span><span>;</span>
            <span>cHash</span> <span>=</span> <span>tmpHash</span><span>;</span>
            <span>cVal</span> <span>=</span> <span>tmpVal</span><span>;</span>
            <span>cKey</span> <span>=</span> <span>tmpKey</span><span>;</span>
            <span>probing</span> <span>=</span> <span>tmpDist</span><span>;</span>
        <span>}</span>
        <span>// Linear probing is used</span>
        <span>probing</span><span>++;</span>
        <span>idx</span><span>++;</span>
        <span>if</span> <span>(</span><span>idx</span> <span>==</span> <span>buckets</span><span>.</span><span>length</span><span>)</span> <span>idx</span> <span>=</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>old</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>One significant advantage of <em>Robin Hood</em> hashing is that it enforces minimal variances of entries compared to their base slot. There are no worst-case scenarios whenever we get an element because all elements will have almost the same distance for a given base slot.</p>



<p>After having implemented the five <em>Open Addressing</em> maps, (<a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbMap.java">LProbMap.java</a>, <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbBinsMap.java">LProbBinsMap.java</a>, <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/LProbRadarMap.java">LProbRadarMap.java</a>, <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/PerturbMap.java">PerturbMap.java</a>, <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/net/andreinc/neatmaps/RobinHoodMap.java">RobinHoodMap.java</a>), I wanted to check how good they perform vs. the <code>HashMap&lt;K,V&gt;</code> reference implementation.</p>

<p>(micro)Benchmarking in Java is hard, so in this regard, I’ve used <a href="https://openjdk.java.net/projects/code-tools/jmh/">jmh</a> + <a href="https://www.mockneat.com">mockneat</a> (to generate test data).</p>

<p>The benchmarks are included in the repo, so if you plan to check out the code:</p>

<div><div><pre><code>git clone git@github.com:nomemory/open-addressing-java-maps.git
</code></pre></div></div>

<p>they can be found in the <a href="https://github.com/nomemory/open-addressing-java-maps/tree/main/src/main/java/performance/jmh"><code>performance/jmh</code></a> folder.</p>

<p>If you want to run them yourself, see the <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/performance/jmh/Main.java">Main.class</a>.</p>

<div><div><pre><code><span>// Cleans the existing generated data from previous runs</span>
<span>InputDataUtils</span><span>.</span><span>cleanBenchDataFolder</span><span>();</span>

<span>Options</span> <span>options</span> <span>=</span> <span>new</span> <span>OptionsBuilder</span><span>()</span>
        <span>// Benchmarks to include</span>
        <span>.</span><span>include</span><span>(</span><span>RandomStringsReads</span><span>.</span><span>class</span><span>.</span><span>getName</span><span>())</span>
        <span>.</span><span>include</span><span>(</span><span>SequencedStringReads</span><span>.</span><span>class</span><span>.</span><span>getName</span><span>())</span>
        <span>.</span><span>include</span><span>(</span><span>AlphaNumericCodesReads</span><span>.</span><span>class</span><span>.</span><span>getName</span><span>())</span>
        <span>// Configuration</span>
        <span>.</span><span>timeUnit</span><span>(</span><span>TimeUnit</span><span>.</span><span>MICROSECONDS</span><span>)</span>
        <span>.</span><span>shouldDoGC</span><span>(</span><span>true</span><span>)</span>
        <span>.</span><span>resultFormat</span><span>(</span><span>ResultFormatType</span><span>.</span><span>JSON</span><span>)</span>
        <span>.</span><span>addProfiler</span><span>(</span><span>GCProfiler</span><span>.</span><span>class</span><span>)</span>
        <span>.</span><span>result</span><span>(</span><span>&#34;benchmarks_&#34;</span> <span>+</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>()</span> <span>+</span> <span>&#34;.json&#34;</span><span>)</span>
        <span>.</span><span>build</span><span>();</span>

<span>new</span> <span>Runner</span><span>(</span><span>options</span><span>).</span><span>run</span><span>();</span>
</code></pre></div></div>

<p>At the end of the program execution, a <code>benchmark_*.json</code> file will be generated (but be prepared; it will take some time).</p>

<p>You can visually analyze the results by using <a href="https://jmh.morethan.io/">this tool</a> or running this quick <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/reporting/benchmarks_reporting.py">python script</a>.</p>

<p>At the moment I am writing this article, there are three benchmark classes:</p>

<ul>
  <li><code>RandomStringsReads</code></li>
  <li><code>SequencedStringReads</code></li>
  <li><code>AlphaNumericCodesReads</code></li>
</ul>

<p>They are configured like this:</p>

<div><div><pre><code><span>@BenchmarkMode</span><span>(</span><span>Mode</span><span>.</span><span>AverageTime</span><span>)</span>
<span>@OutputTimeUnit</span><span>(</span><span>TimeUnit</span><span>.</span><span>MICROSECONDS</span><span>)</span>
<span>@State</span><span>(</span><span>Scope</span><span>.</span><span>Benchmark</span><span>)</span>
<span>@Fork</span><span>(</span><span>value</span> <span>=</span> <span>3</span><span>,</span> <span>jvmArgs</span> <span>=</span> <span>{</span><span>&#34;-Xms6G&#34;</span><span>,</span> <span>&#34;-Xmx16G&#34;</span><span>})</span>
<span>@Warmup</span><span>(</span><span>iterations</span> <span>=</span> <span>2</span><span>,</span> <span>time</span> <span>=</span> <span>5</span><span>)</span>
<span>@Measurement</span><span>(</span><span>iterations</span> <span>=</span> <span>4</span><span>,</span> <span>time</span> <span>=</span> <span>5</span><span>)</span>
</code></pre></div></div>

<p>We use <code>3</code> forks, <code>2</code> warmup iterations, and <code>4</code> measurements. I know I should’ve probably increased those values, but even like this, and given the high input params variance, the benchmark takes around 6 hours to complete on my machine.</p>

<p>To conclude, I believe this is enough to get a glimpse of the performance of the code.</p>

<p>Each benchmark class has two methods:</p>

<div><div><pre><code><span>@Benchmark</span>
<span>@CompilerControl</span><span>(</span><span>CompilerControl</span><span>.</span><span>Mode</span><span>.</span><span>INLINE</span><span>)</span>
<span>public</span> <span>void</span> <span>randomReads</span><span>(</span><span>Blackhole</span> <span>bh</span><span>)</span> <span>{</span>
    <span>bh</span><span>.</span><span>consume</span><span>(</span>
            <span>testedMap</span><span>.</span><span>get</span><span>(</span><span>fromStrings</span><span>(</span><span>keys</span><span>).</span><span>get</span><span>())</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<div><div><pre><code><span>@Benchmark</span>
<span>@CompilerControl</span><span>(</span><span>CompilerControl</span><span>.</span><span>Mode</span><span>.</span><span>INLINE</span><span>)</span>
<span>public</span> <span>void</span> <span>randomReadsWithMisses</span><span>(</span><span>Blackhole</span> <span>bh</span><span>)</span> <span>{</span>
    <span>bh</span><span>.</span><span>consume</span><span>(</span>
            <span>testedMap</span><span>.</span><span>get</span><span>(</span><span>fromStrings</span><span>(</span><span>keysWithMisses</span><span>).</span><span>get</span><span>())</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>randomReadsWithMisses()</code> method benchmarks <code>get()</code> operations where keys have a 50% chance of not being present in the <code>Map&lt;K,V&gt;</code>.</p>

<p>For <code>randomReads()</code>, it is guaranteed all the keys exist.</p>

<h2 id="randomstringsreads"><code>RandomStringsReads</code></h2>

<p>The full code of this benchmark can be found <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/performance/jmh/bechmarks/reads/RandomStringsReads.java">here</a>.</p>

<p>For this benchmark the keys are randomly generated by following this simple rule:</p>

<div><div><pre><code> <span>probabilities</span><span>(</span><span>String</span><span>.</span><span>class</span><span>)</span>
            <span>.</span><span>add</span><span>(</span><span>0.2</span><span>,</span> <span>names</span><span>().</span><span>full</span><span>())</span>
            <span>.</span><span>add</span><span>(</span><span>0.2</span><span>,</span> <span>addresses</span><span>())</span>
            <span>.</span><span>add</span><span>(</span><span>0.2</span><span>,</span> <span>words</span><span>())</span>
            <span>.</span><span>add</span><span>(</span><span>0.2</span><span>,</span> <span>cars</span><span>())</span>
            <span>.</span><span>add</span><span>(</span><span>0.2</span><span>,</span> <span>ints</span><span>().</span><span>mapToString</span><span>())</span>
</code></pre></div></div>

<p><a href="https://www.mockneat.com/docs/#probabilities"><code>probabilities()</code></a> is a <a href="https://www.mockneat.com">mockneat</a> method that generates random data based on given “chances”.</p>

<p>The keys are <code>String</code> values that:</p>
<ul>
  <li>Have a 20% chance of being full names (e.g., “Mike Smith”);</li>
  <li>Have a 20% chance of being a full address;</li>
  <li>Have a 20% chance of being a random word from the English dictionary;</li>
  <li>Have a 20% chance of being a “car” name and model;</li>
  <li>Have a 20% chance of being a numerical value (an <code>int</code>) converted to <code>String</code>.</li>
</ul>

<p>This benchmark will have the following input params:</p>

<div><div><pre><code><span>@Param</span><span>({</span><span>&#34;KEYS_STRING_1_000&#34;</span><span>,</span> <span>&#34;KEYS_STRING_10_000&#34;</span><span>,</span> <span>&#34;KEYS_STRING_100_000&#34;</span><span>,</span> <span>&#34;KEYS_STRING_1_000_000&#34;</span><span>,</span> <span>&#34;KEYS_STRING_10_000_000&#34;</span><span>})</span>
<span>private</span> <span>StringsSourceTypes</span> <span>input</span><span>;</span>

<span>@Param</span><span>({</span><span>&#34;LProbMap&#34;</span><span>,</span> <span>&#34;LProbBinsMap&#34;</span><span>,</span> <span>&#34;LProbRadarMap&#34;</span><span>,</span> <span>&#34;RobinHoodMap&#34;</span><span>,</span> <span>&#34;PerturbMap&#34;</span><span>,</span> <span>&#34;HashMap&#34;</span><span>})</span>
<span>private</span> <span>MapTypes</span> <span>mapClass</span><span>;</span>
</code></pre></div></div>

<p><code>KEYS_STRING_1_000</code> means that data will be read from a <code>MapType={LProbMap, LProbBinsMap, ...}</code> with <code>1000</code> entries, <code>KEYS_STRING_10_000</code> means that data will be read from a <code>MapType={LProbMap, LProbBinsMap, ...}</code> with <code>10_000</code> entries, and so on, up to <code>10_000_000</code> entries.</p>

<p><em>Note: I’ve created the benchmarks in such a way, the same data will be used for all the <code>MapTypes</code>.</em></p>

<h2 id="sequencedstringsreads"><code>SequencedStringsReads</code></h2>

<p>The full code of this benchmark can be found <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/performance/jmh/bechmarks/reads/SequencedStringsReads.java">here</a>.</p>

<p>For this benchmark, the keys are randomly generated by following this simple rule:</p>



<p><a href="https://www.mockneat.com/docs/#intseq"><code>intSeq()</code></a> is part of the <a href="https://www.mockneat.com/"><code>mockneat</code></a> API.</p>

<p>Basically the keys will be <code>String</code> values that are <code>int</code> values in a sequence: <code>&#34;0&#34;</code>, <code>&#34;1&#34;</code>, …, <code>&#34;1000&#34;</code>.</p>

<p>The reason I’ve introduced this benchmark was to see how my <code>Maps</code> are performing versus input that has a certain pattern.</p>

<h2 id="alphanumericcodesreads"><code>AlphaNumericCodesReads</code></h2>

<p>The full code of this benchmark can be found <a href="https://github.com/nomemory/open-addressing-java-maps/blob/main/src/main/java/performance/jmh/bechmarks/reads/AlphaNumericCodesReads.java">here</a>.</p>

<p>For this benchmark, the keys are randomly generated by following this simple rule:</p>

<div><div><pre><code><span>strings</span><span>().</span><span>size</span><span>(</span><span>6</span><span>).</span><span>type</span><span>(</span><span>StringType</span><span>.</span><span>ALPHA_NUMERIC</span><span>)</span>
</code></pre></div></div>

<p>Keys are alphanumeric characters of <code>length==6</code>.</p>

<p>I’ve introduced this benchmark (again) to see how my <code>Maps</code> are performing versus input with specific patterns.</p>



<p>After running all the three benchmarks for almost 6 hours, I’ve got the following results:</p>





<p>Firstly, the benchmarks are incomplete as we haven’t tested the performance for <code>put</code> or <code>remove</code> operations. More work can be done to improve both methods. The <code>tombstones</code> strategy is probably not the best; more thoughtful implementations prefer shifting elements instead.</p>

<p>Secondly, I was surprised to see that <code>LProbMap&lt;K,V&gt;</code> and <code>RobinHoodMap&lt;K,V&gt;</code> are performing relatively well vs. <code>HashMap&lt;K,V&gt;</code> for datasets &lt; <code>1_000_000</code>. After the number of elements increases, performance is degrading but not by huge margins. In terms of memory consumption, the results were also quite similar.</p>

<p>Implementing the 5 <em>Open Addressing</em> maps was a fun and frustrating exercise. In Java, you can only be <em>half-smart</em> when you are writing code. The other <em>half</em> is where the JIT comes into play. You cannot control even what function is getting inlined. So writing the code to make it as fast as possible was a trial and error endeavor. I am not even sure I’ve made the right decisions.</p>

<p>I had high hopes for <code>LProbBinsMap&lt;K,V&gt;</code>, but surprisingly it performed the worst. Maybe I’ve missed something and someone more experienced than me can find the reason why it works poorly.</p>

<p>Should you ever consider using an <em>Open Addressing</em> hash table in Java instead of <code>HashMap&lt;K,V&gt;</code>. Probably not. <code>HashMap&lt;K,V&gt;</code> is simple, performant and bullet-proof.</p>

<p>I am yet to find an <em>Open Addressing</em> implementation that outperforms <code>HashMap&lt;K,V&gt;</code> by a significant margin. If you have additional ideas, you can use the existing repo, as you already have some infrastructure at hand: unit tests, benchmarks, and a script to plot the results. I am accepting PRs, and I will update the article.</p>



<p>Related <a href="https://news.ycombinator.com/item?id=29319151#29319535">hacker news link</a>.</p>

<p>Related <a href="https://www.reddit.com/r/java/comments/r0b9o9/a_tale_of_java_hash_tables/">reddit link</a>.</p>

        
      </section>

      

      

      
    </div></div>
  </body>
</html>
