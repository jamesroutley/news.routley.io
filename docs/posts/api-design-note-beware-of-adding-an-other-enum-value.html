<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20250217-00/?p=110873">Original</a>
    <h1>API design note: Beware of adding an &#34;Other&#34; enum value</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-110873">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>Consider the following API:</p>
<pre>enum class WidgetFlavor
{
    Vanilla,
    Chocolate,
    Strawberry,
    <span>Other,</span>
};

WidgetFlavor GetWidgetFlavor(HWIDGET widget);
</pre>
<p>The idea here is that Widgets come in three flavors today, but we might add new flavors in the future, so we add an <code>Other</code> value to cover any future flavors.</p>
<p>This is a problem.</p>
<p>Suppose we do indeed add a new flavor <code>Mint</code> in the next version.</p>
<pre>enum class WidgetFlavor
{
    Vanilla,
    Chocolate,
    Strawberry,
    Other,
    <span>Mint,</span>
};
</pre>
<p>What flavor should you report if somebody calls <code>Get­Widget­Flavor</code> and the widget is mint?</p>
<p>If you return <code>WidgetFlavor::<wbr/>Mint</code>, then this will confuse code written with the Version 1 API, because they expected to get <code>Other</code> for anything that isn’t vanilla, chocolate, or strawberry. The word “other” means “not mentioned elsewhere”, so the presence of an <code>Other</code> logically implies that the enumeration is exhaustive.</p>
<p>On the other hand, you obviously should return <code>WidgetFlavor::<wbr/>Mint</code> because that’s why you added the value to the enum in the first place!</p>
<p>My recommendation is not to have an <code>Other</code> at all. Just document that the enumeration is open-ended, and programs should treat any unrecognized values as if they were “Other”. Any code that uses this enumeration will therefore put all unrecognized values into an app-defined “Other” category on their own. Now you can add <code>Mint</code>: New code will put minty widgets in a “Mint” category, and old code will continue to put them in the app=defined “Other” category.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
