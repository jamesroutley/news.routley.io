<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.twilio.com/blog/comparing-nextjs-nestjs-nuxt-gatsby">Original</a>
    <h1>Next, Nest, Nuxt Nust?</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <section>
        
          <ul>
        
          
          
    
      



<article>
  <header>
  
  
  </header>
  <section>
    
    <div>

<p>This blog post is for everyone looking for their new favorite JavaScript backend framework. A few months ago, I was precisely in this place and wanted to learn a new JavaScript backend framework for my side project.</p>
<p>To be honest, I was a bit overwhelmed with all the fancy options to choose from... <em>Next</em>, <em>Nest</em>, <em>Nuxt...</em> - when you hear these names, you probably think the JavaScript community finally ran out of names, and &#34;Nust&#34; will be the next big thing. So the first item on my To-Do list was finding the best framework for my side project.</p>
<p>If you also want to understand the Gatsby, Next.js, Nest, and Nust frameworks better, this post is for you. Iâ€™ll explain the similarities and differences between the frameworks, their performance characteristics, real-world popularity, and discuss how to choose the best one for you.</p>
<p>Letâ€™s get started!</p>
<h2>Express versus Next.js, Nest, Gatsby, and Nuxt</h2>
<p>All of these open-source frameworks are, according to the latest State of JavaScript survey, the <a href="https://2021.stateofjs.com/en-US/libraries/back-end-frameworks">most popular backend frameworks</a>. The State of JS survey reveals that Next.js, Gatsby, Nuxt, and Nest are  among the top five. They are behind the undefeated number one <a href="https://expressjs.com/">Express</a> and still growing. But what are they all about?</p>
<p><img alt="Screenshot of the state of js survey" height="583" sizes="800px" src="https://assets.cdn.prod.twilio.com/images/El4uRxW3DZ57Yo9C657m9EujzMt3IaEOksR7V7_4N6Wg5t.width-800.png" srcset="https://assets.cdn.prod.twilio.com/images/El4uRxW3DZ57Yo9C657m9EujzMt3IaEOksR7V7_4N6Wg5t.width-800.png 800w, https://assets.cdn.prod.twilio.com/images/El4uRxW3DZ57Yo9C657m9EujzMt3IaEOksR7V7_4N6Wg5.width-1600.png 1004w" width="800"/></p>
<p>Express has been around almost since the inception of Node.js and is the de-facto standard JavaScript framework. It is comparatively close to the HTTP protocol and offers a minimalist interface, which explains why itâ€™s often used as the basis for many other frameworks. The other frameworks in the top five follow a very different strategy and offer a lot of abstraction to their users. But these abstractions also require a more profound understanding of the frameworks themselves. This post will introduce you to the other contenders in the top 5 of the most used frameworks: Gatsby, Next.js, Nuxt.js, and Nest.</p>
</div>
<div>


<p>The following two sections cover <a href="https://web.dev/vitals/">Web Vitals</a>, such as LP and LCP, and <a href="https://web.dev/rendering-on-the-web/">rendering strategies</a>, such as CSR, SSR, and isomorphic apps. You are welcome to jump directly to the frameworks and <a href="https://docs.google.com/document/d/1cU_A7jwyqXcrkQnfgCfELzRuiInd-rJxei4awgdTTwo/edit?pli=1#heading=h.w9o1oczdpqam">skip these sections</a> if you already know what these abbreviations mean.</p>
</div>
<div>

<h2>Performance Metrics for Web Applications</h2>
<p>Before we dig into the frameworks, let&#39;s think about the requirements for a web application. Almost all projects share one common goal: to deliver relevant, high-quality content to your users. But we also know that even the best content alone doesn&#39;t do the job. It also needs to be delivered with acceptable <strong>performance </strong>and (when talking about public content) needs to be <strong>discoverable</strong>.</p>
<p>The latter point on discoverability is very straightforward. When you publish content on a public site, you want search engines to index the page, which will then be discoverable in search.</p>
<p>The performance aspect might be a bit harder to define: which performance metric tells you the content is presented timely? I would argue that there is no perfect answer to this question, but there certainly are multiple good metrics that can be combined for a holistic view:</p>
<ul>
<li><a href="https://web.dev/ttfb/">Time to First Byte</a> (TTFB)</li>
<li><a href="https://web.dev/rendering-on-the-web/#terminology">First Paint</a> (FB)</li>
<li><a href="https://web.dev/first-contentful-paint/">First Contentful Paint</a> (FCP)</li>
<li><a href="https://web.dev/lcp/">Largest Contentful Paint</a> (LCP)</li>
<li><a href="https://web.dev/interactive/">Time to Interactive</a> (TTI)</li>
</ul>
<p><img alt="Results of a Lighthouse performance measurement in Chrome" height="454" sizes="500px" src="https://assets.cdn.prod.twilio.com/images/NbgJVgLgVDGTgJwu71S1opqxKy2UNk8DCInusDoteUM4NW.width-500.png" srcset="https://assets.cdn.prod.twilio.com/images/NbgJVgLgVDGTgJwu71S1opqxKy2UNk8DCInusDoteUM4NW.width-500.png 500w, https://assets.cdn.prod.twilio.com/images/NbgJVgLgVDGTgJwu71S1opqxKy2UNk8DCInusDoteUM4N.width-1000.png 1000w" width="500"/></p>
</div>
<div>


<div>
  <p>These metrics were introduced by the Chrome team and are often also referred to as <a href="https://web.dev/vitals/">Web Vitals</a>. The good news is all <a href="https://en.wikipedia.org/wiki/Blink_(browser_engine)">Blink-based</a> browsers come with development tools to measure these metrics. The bad news is that these metrics are, as of now, <a href="https://blog.webpagetest.org/posts/why-first-contentful-paint-doesnt-work-as-a-cross-browser-metric/">not supported</a> by Safari. So you might need to use other browsers for performance tuning, use other metrics in these browsers, or sit in front of the screen with a stopwatch ðŸ™‚.</p>
<p>But don&#39;t worry. For this post, it doesn&#39;t matter which browser you use, as we&#39;ll use these metrics only to highlight the differences between various rendering options in the next section.</p>
</div>
</div>
<div>

<h2>Rendering Options</h2>
<p>On a very high level, all websites work the same. The client sends an initial request to the server that holds the desired information. The server responds with the requested file, which might or might not trigger a cascade of more requests. Eventually, the client has all the needed data and can render a page to display the information visually to the user.</p>
<p><img alt="Visualization of the client-server-flow" height="303" src="https://assets.cdn.prod.twilio.com/original_images/GoSa_TzgzdlAwuwnIwwJFkXPll76Ympraid1_CSiBnCL6a99TatCo_-S6eNbaE-kMh05Fnu1v5ntUP" width="800"/></p>
<p>For static content, i.e., content that looks the same for every user and doesn&#39;t require any computations, HTML and CSS files are stored on the server and delivered to the client upon request. The client, in most cases the browser, parses these files and builds the Document Object Model (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">DOM</a>) based on these instructions.</p>
<p>Unfortunately, large parts of the web consist of dynamic content that needs to differ for each user, possibly even depending on the time or state when the user accesses the web resource. And for these scenarios, computation needs to happen during the requesting process that is visualized above.</p>
<p>When I started programming, <a href="https://github.com/GRomR1/java-servlet-hello/blob/master/src/main/java/com/mycompany/hello/HelloServlet.java">Java Servlets</a> were a popular approach to adding dynamic content to websites. Whenever a request reached the server, it ran precompiled Java byte code which printed the HTML response of the request. With the rise of frameworks like <a href="https://en.wikipedia.org/wiki/AngularJS">AngularJS</a>, <a href="https://en.wikipedia.org/wiki/Backbone.js">Backbone.js</a>, and <a href="https://en.wikipedia.org/wiki/Knockout_(web_framework)">Knockout</a> in 2010, we saw a shift to Single Page Applications (<a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a>).</p>
<p>The SPA approach mainly transfers JS and JSON files between the client and server. When executed in the browser, these files render the DOM elements users see. Java Servlet and Single Page Apps commonly execute code to generate the website&#39;s markup. However, they differentiate on <strong>where</strong> and <strong>when</strong> this code is executed. We can also say they use a different <em>rendering strategy</em>.</p>
<p>Various rendering strategies have advantages and disadvantages based on your requirements. Some might be more relevant to your project than others. The following sections will cover the most common ones we see today.</p>
<h3>Client-side Rendering (CSR)</h3>
<p>Applications which render individual pages all in the clientâ€™s browser are also often referred to as Single Page Applications. This concept is known as <em>CSR</em>, or <em>Client-side Rendering</em>.</p>
<p>The server essentially serves minified JavaScript code executed on the client side to fetch additional information via HTTP requests and renders the DOM elements. For many web developers, this is now the de-facto standard for developing web applications. Popular SPA frameworks are <a href="https://reactjs.org/">React</a>, <a href="https://angular.io/">Angular</a>, <a href="https://vuejs.org/">Vue.js</a>, and <a href="https://svelte.dev/">Svelte</a>.</p>
<p>This approach has the advantage that it <strong>scales well</strong> as most of the computation happens on the clients, which leads to a fast Time To First Byte. Another advantage is that you can use <a href="https://developer.mozilla.org/en-US/docs/Web/API">Web APIs</a> supported by modern browsers such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API">Geolocation</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API">Clipboard</a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">Push</a>.</p>
<p>There are disadvantages, though. Since all the rendering happens on the client, this <strong>requires additional time</strong> once the JavaScript files have been loaded and could lead to a blocked user interface during that time. Hence, metrics like First Paint, First Contentful Paint, Largest Contentful Paint, and Time-to-Interactive require more time.</p>
<p>To compensate for this waiting time, front-end developers often create <a href="https://en.wikipedia.org/wiki/Splash_screen">splash screens </a>to reduce the perceived loading time. Another disadvantage is that most <strong>search engines don&#39;t execute JavaScript</strong>, which leads to problems when you&#39;re interested in SEO â€“ as crawlers can have a difficult time understanding page content, it can affect your pagesâ€™ discoverability. Of course, there might be projects, such as company-internal apps, where SEO isn&#39;t relevant and that aspect doesn&#39;t bother you.  </p>
<h3>Server-side Rendering (SSR)</h3>
<p>Another approach, <em>SSR</em> (or <em>Server-side Rendering</em>) computes the fully rendered HTML before responding to incoming requests, delivering a complete page. This rendering approach is, in many ways, the opposite of client-side rendering. Since search engine crawlers are parsing full web pages, this approach is <strong>SEO-friendly</strong> and still shows <strong>up-to-date content</strong> that varies from user to user. Interestingly, First Paint, First Contentful Paint, Largest Contentful Paint, and Time To Interactive are <strong>fast</strong> and usually very close to each other as the website usually renders all at once.</p>
<p>However, as you guessed, there is a disadvantage here as well. As servers must complete computations before serving the markup, <strong>Time To First Byte</strong> typically requires more <strong>time</strong>. This approach is comparably <strong>harder to scale</strong> as computational load grows with every additional user. Web Pages that look very similar for all users can suffer significantly from this approach, as the same computations with the same results are computed repeatedly.</p>
<h3>Static Site Generation (SSG)</h3>
<p><em>SSG</em>, or <em>Static Site Generation</em>, computes page markup during the build time of the web application instead of on-demand. This approach focuses on reducing repeated server-side computation by precomputing dynamic web pages up front.. This leads to a longer build time, but eventually saves computation time by serving these precomputed pages.</p>
<p><strong>All metrics</strong> (Time To First Byte, First Paint, First Contentful Paint, Largest Contentful Paint, and Time To Interactive) benefit from this approach as it is very similar to static serving. This naturally also leads to <strong>low server costs</strong> and excellent <strong>scalability</strong>.</p>
<p>The significant disadvantage is that all pages look the <strong>same for every user</strong>. This is only desired â€“ or even <em>possible</em> â€“with some kinds of web applications.</p>
<p>Can you imagine a webshop, especially a shopping cart, that looks the same to every user? For some pages, such as API documentation or small blogs, authors can fully leverage this rendering strategy.</p>
<p>But the example of a &#34;static webshop&#34; shows a second disadvantage â€“ every time you change a common element, you need to rebuild the site! You would need to rebuild the entire application to update a single product description â€“ otherwise, the shop would never display the latest information. So, with Static Site Generation it makes sense to modify the strategy a bit and let pages expire or not render them at build-time, and wait until they are requested the first time. These modifications are called <a href="https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration">Incremental Static Regeneration</a> and <a href="https://www.gatsbyjs.com/docs/how-to/rendering-options/using-deferred-static-generation/">Deferred Site Generation</a>, respectively.</p>
<h3>Hybrid rendering strategies â€“ universal/isomorphic apps, hydration, and client-side fetching</h3>
<p>Pure forms of the previously mentioned strategies move <strong>all</strong> the computational load to the client, the server, or the build server, respectively. And the side effects are the advantages and disadvantages listed, e.g., SEO-friendly vs. poor SEO support. But it doesn&#39;t have to be that way! <em>Why not do some of the computation on the client and some on the server? </em></p>
<p>For discoverability, it seems reasonable to minimize the amount of client-side rendered page elements. This means we only want to render <em>user-specific elements</em> in the browser. All other page elements â€“ headers, footers, sidebar, or even the full pages, like &#34;About us&#34; â€“ can be rendered and cached on the server to save time.</p>
<p>This approach has a few different names used in various frameworks. Some describe these kinds of apps as <a href="https://nuxtjs.org/docs/configuration-glossary/configuration-mode#the-mode-property">universal/isomorphic</a>. Other frameworks call this process <a href="https://beta.reactjs.org/apis/react-dom/hydrate">(re-)hydration</a> or <a href="https://nextjs.org/docs/basic-features/data-fetching/client-side">client-side fetching</a>. Sometimes you also come across the term <em>prerendering</em>, but I avoid it because it isn&#39;t clearly defined.</p>
</div>
<div>


<div>
  <p>A note about the term <em>prerendering</em>:</p>
<p>This is a term you will often encounter when you research rendering options. At first, the word seems like a great fit, but I try to avoid it because I have yet to find a clear definition.</p>
<p>In a <a href="https://web.dev/rendering-on-the-web/">blog post</a>, some Chrome and Shopify engineers mention a &#34;difference between static rendering and prerendering&#34;. The <a href="https://vuejs.org/guide/scaling-up/ssr.html#why-ssr">Vue.js documentation</a> says Static Site Generation (SSG) is &#34;also referred to as prerendering&#34;. Similarly, the <a href="https://nextjs.org/docs/basic-features/pages#server-side-rendering">Next.js documentation</a> says that Static Generation and Server-side Rendering are &#34;two forms of prerendering&#34;. The <a href="https://jamstack.org/what-is-jamstack/">Jamstack documentation</a> follows a similar idea, but calls anything &#34;which can be served directly from a CDN&#34; prerendering. This includes Static Site Generation, Server-side Rendering, and the hybrid approach.</p>
<p>I share this opinion, too: Pre-rendering is everything that is not exclusively rendered on the client side. But I don&#39;t want to contribute to the confusion and try to avoid the term (at least for now).</p>
</div>
</div>
<div>

<p>Independent of the name, this strategy has a <strong>fast</strong> Time To First Byte, First Paint, and First Contentful Paint that is also<strong> SEO-friendly</strong>. Only the Largest Contentful Paint and the Time To Interactive usually show a disadvantage. But overall, these metrics still perform better versus Single Page Apps solely rendered on the client.</p>
<p>There&#39;s not a real disadvantage concerning the Web Vital metrics of this approach, but there is a pragmatic one. It comes with <strong>additional complexity</strong> to define when to render which page elements where.</p>
<h3>Multiple rendering strategies</h3>
<p>You see, there are many rendering strategies to choose from. And truth be told, these classifications are more theoretical than anything else. In real life, one website can <strong>use multiple strategies </strong>for different subpages. To stick with the example of a webshop, the catalog and product pages must have a fast loading time and be SEO-optimized simultaneously. That sounds like a job for Static Site Generation. But there is also the need for some user-specific pages where discoverability isnâ€™t a factor, such as the shopping cart. It makes sense to leverage a hybrid rendering strategy for these subpages. The layout of the cart page, which is the same for all users, can be rendered on the server, and the items of the cart can be rendered via client-side fetching.</p>
<p>When you implement a web app partially rendered on the client and the server, how do you decide which code needs to run on which platform or how the code is minified and split into individual chunks? This can get very complicated fast. But thankfully, there are frameworks that can help you with this task.</p>
<h2>Frameworks</h2>
<h3>Gatsby</h3>
<p>Gatsby was initially conceptualized in 2015 as a framework for Static Site Generation of React web apps. Over time, it added a few other <a href="https://www.gatsbyjs.com/docs/conceptual/rendering-options/">rendering options</a>, such as Deferred Site Generation (on the first request), Server-Side Rendering (which you should only use in some cases), and <a href="https://www.gatsbyjs.com/docs/conceptual/data-fetching/#fetching-data-at-client-side-runtime">client-side fetching</a>.</p>
<p>You can <a href="https://www.gatsbyjs.com/docs/how-to/sourcing-data/sourcing-from-databases/">source data</a> from multiple systems, such as database management or headless content management systems, to build the React sites you need. But one of the technologies that Gatsby is most strongly related to is <a href="https://www.gatsbyjs.com/docs/conceptual/graphql-concepts/">GraphQL</a>. It includes its own GraphQL server to serve metadata about the server and from connected sources.</p>
<p>A special highlight of this framework is the size of its open-source community, which has built a large <a href="https://www.gatsbyjs.com/plugins">Plugin Library</a> that allows you to stand on the shoulders of giants.</p>
<p>This is how a Gatsby <code>404</code> page could look:</p>
</div>
<div>

<div>
    <div><pre><code>import * as React from &#34;react&#34;
import { Link } from &#34;gatsby&#34;
import { StaticImage } from &#34;gatsby-plugin-image&#34;;


const pageStyles = {
 color: &#34;#232129&#34;,
 padding: &#34;96px&#34;,
 fontFamily: &#34;-apple-system, Roboto, sans-serif, serif&#34;,
}
const headingStyles = {
 marginTop: 0,
 marginBottom: 64,
 maxWidth: 320,
}

const paragraphStyles = {
 marginBottom: 48,
}
const codeStyles = {
 color: &#34;#8A6534&#34;,
 padding: 4,
 backgroundColor: &#34;#FFF4DB&#34;,
 fontSize: &#34;1.25rem&#34;,
 borderRadius: 4,
}

const NotFoundPage = () =&gt; {
 return (
   &lt;main style={pageStyles}&gt;
     &lt;h1 style={headingStyles}&gt;Page not found&lt;/h1&gt;
     &lt;StaticImage alt=&#34;Clifford, a reddish-brown pitbull&#34;
       src=&#34;https://pbs.twimg.com/media/E1oMV3QVgAIr1NT?format=jpg&amp;name=large&#34;
     /&gt;

     &lt;p style={paragraphStyles}&gt;
       Sorry ðŸ˜”, we couldn&#39;t find what you were looking for.
       &lt;br /&gt;
       {process.env.NODE_ENV === &#34;development&#34; ? (
         &lt;&gt;
           &lt;br /&gt;
           Try creating a page in &lt;code style={codeStyles}&gt;src/pages/&lt;/code&gt;.
           &lt;br /&gt;
         &lt;/&gt;
       ) : null}
       &lt;br /&gt;
       &lt;Link to=&#34;/&#34;&gt;Go home&lt;/Link&gt;.
     &lt;/p&gt;
   &lt;/main&gt;
 )
}

export default NotFoundPage
</code></pre></div>
</div>
</div>
<div>

<p>With its supported rendering options, Gatsby is well-equipped to implement <a href="https://jamstack.org/">Jamstack Sites</a>. Here&#39;s a great <a href="https://jamstack.org/">resource on Jamstack </a>that explains the benefit of applications that decouple the web experience layer from data and business logic. Sites built with Gatsby are <a href="https://www.gatsbyjs.com/customers/">often used for</a> &#34;content consumption&#34; that offers a great user experience, such as the web presence of companies.</p>
<p>The framework doesn&#39;t support custom backend logic, so you should look for another framework, such as Next.js, if that&#39;s what you need.</p>
<h3>Next.js</h3>
<p>The Next.js framework, published initially in 2016, is in many ways similar to Gatsby, with the addition of a few <a href="https://vercel.com/docs/concepts/functions/edge-functions">edge computing</a> features. These features include <a href="https://vercel.com/docs/concepts/functions/edge-functions">Edge Functions</a>, the serverless execution of custom code, and <a href="https://nextjs.org/docs/advanced-features/middleware">Edge Middleware</a> that can be used to redirect certain requests to other domains.  This allows you to run your serverless Next.js app globally without worrying about server management. Next.js supports Static Site Generation, Server-side Rendering, Incremental Static Regeneration, and client-side data fetching.</p>
<p>A home page in Next.js</p>
</div>
<div>

<div>
    <div><pre><code>import Head from &#39;next/head&#39;
import Image from &#39;next/image&#39;
import styles from &#39;../styles/Home.module.css&#39;

export default function Home() {
 return (
   &lt;div className={styles.container}&gt;
     &lt;Head&gt;
       &lt;title&gt;Create Next App&lt;/title&gt;
       &lt;meta name=&#34;description&#34; content=&#34;Generated by create next app&#34; /&gt;
       &lt;link rel=&#34;icon&#34; href=&#34;/favicon.ico&#34; /&gt;
     &lt;/Head&gt;

     &lt;main className={styles.main}&gt;
       &lt;h1 className={styles.title}&gt;
         Welcome to &lt;a href=&#34;https://nextjs.org&#34;&gt;Next.js!&lt;/a&gt;
       &lt;/h1&gt;

       &lt;p className={styles.description}&gt;
         Get started by editing{&#39; &#39;}
         &lt;code className={styles.code}&gt;pages/index.js&lt;/code&gt;
       &lt;/p&gt;
     &lt;/main&gt;

     &lt;footer className={styles.footer}&gt;
       &lt;a
         href=&#34;https://vercel.com?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app&#34;
         target=&#34;_blank&#34;
         rel=&#34;noopener noreferrer&#34;
       &gt;
         Powered by{&#39; &#39;}
         &lt;span className={styles.logo}&gt;
           &lt;Image src=&#34;/vercel.svg&#34; alt=&#34;Vercel Logo&#34; width={72} height={16} /&gt;
         &lt;/span&gt;
       &lt;/a&gt;
     &lt;/footer&gt;
   &lt;/div&gt;
 )
}

</code></pre></div>
</div>
</div>
<p>An Edge function:</p>
<div>

<div>
    <div><pre><code>const twilio = require(&#34;twilio&#34;);

export default function handler(req, res) {
 const twiml = new twilio.twiml.MessagingResponse();
 twiml.message(&#34;Hi, I&#39;m a TwiML response&#34;);
 res.setHeader(&#34;Content-Type&#34;, &#34;text/xml&#34;);
 res.status(200).send(twiml.toString());
}
</code></pre></div>
</div>
</div>
<div>

<p>A <strong>unique feature</strong> of Next.js is its huge popularity, big community, and widespread<a href="https://nextjs.org/showcase"> usage</a>. The framework allows you to host it on your own infrastructure, but you can also deploy it to multiple edge networks to outsource server administration work.</p>
<p>On the other hand, this serverless nature can also be a downside. There is no notion of state in the framework; therefore, you cannot easily store state without manually adding a database.</p>
<h3>NuxtJS</h3>
<p>NuxtJS, published initially in 2016,  differs from the previous frameworks in multiple ways. The most obvious difference is that you donâ€™t build with React, but on another popular UI framework: <a href="https://vuejs.org/">Vue.js</a>. But that does not mean that Nuxt is a port of Next.js. Nuxt is conceptually very different and offers all rendering options - <a href="https://nuxtjs.org/docs/features/rendering-modes/">even Client-side Rendering</a>. So this framework can also be used for Progressive Web Apps.</p>
<p>On top of that, it comes with a rich wizard that asks questions for different configurations, testing frameworks, building frameworks, and component packages. So it can also be seen as a framework for frameworks. Nuxt also comes with state storage functionality: the <a href="https://nuxtjs.org/docs/directory-structure/store/">Vuex Store</a>.</p>
<p>A Nuxt page definition</p>
</div>
<div>

<div>
    <div><pre><code>&lt;template&gt;
 &lt;div&gt;
   &lt;h1&gt;Hello Nuxters! ðŸ‘‹&lt;/h1&gt;
   &lt;p&gt;
     This page is rendered on the &lt;strong&gt;{{ rendering }}&lt;/strong&gt;
   &lt;/p&gt;
   &lt;p v-if=&#34;rendering === &#39;server&#39;&#34;&gt;
     First load or hard refresh is done on server side.
   &lt;/p&gt;
   &lt;p v-if=&#34;rendering === &#39;client&#39;&#34;&gt;Navigation is done on client side.&lt;/p&gt;
   &lt;ul&gt;
     &lt;li&gt;Refresh the page for server side rendering.&lt;/li&gt;
     &lt;li&gt;Click the links to see client side rendering.&lt;/li&gt;
   &lt;/ul&gt;

   &lt;NuxtLink to=&#34;/about&#34;&gt;About Page&lt;/NuxtLink&gt;
 &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
 asyncData() {
   return {
     rendering: process.server ? &#39;server&#39; : &#39;client&#39;
   }
 }
}
&lt;/script&gt;
</code></pre></div>
</div>
</div>
<p>To avoid confusion, it&#39;s worth highlighting that Nuxt offers many options for developing <a href="https://nuxtjs.org/showcaseshttps://nuxtjs.org/showcases">websites</a>. But that doesn&#39;t mean that it&#39;s a framework for creating your own server applications that need to handle <a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">Object Relational Mappers</a> or protocols besides HTTP.</p>
<div>


<p>Thereâ€™s a great memory trick to distinguish these similar sounding frameworks: N<strong>e</strong>xt.js uses R<strong>e</strong>act and N<strong>u</strong>xt uses V<strong>u</strong>e.js.</p>
</div>
<div>

<h3>Nest</h3>
<p>Nest, the Angular-inspired framework from 2018, is the real outlier in this series. While all other frameworks implement various rendering strategies, Nest lives in a different sphere away from front-ends. This framework <strong>for server-side applications</strong> is more similar to the famous <a href="https://spring.io/">Spring framework</a> and can be used to implement microservices. It supports virtually <a href="https://docs.nestjs.com/techniques/database">all popular database management systems</a> via object-relational mappers and many additional protocols such as <a href="https://docs.nestjs.com/microservices/basics">WebSockets, GraphQL, and MQTT</a>.</p>
<p>Under the hood, Nest uses Express but also provides compatibility with a wide range of other libraries, like, e.g., <a href="https://www.npmjs.com/package/fastify">Fastify</a>, allowing for convenient use of third-party plugins. But my favorite feature is the neat code-reuse mechanism via <a href="https://docs.nestjs.com/cli/libraries">modules</a>. Modules allow you to externalize features that you can reuse in multiple parts of your application or share with the entire Nest community as libraries.</p>
<p>Module usage in a Nest application:</p>
</div>
<div>

<div>
    <div><pre><code hl_lines="[4, 7]">import { Module } from &#39;@nestjs/common&#39;;
import { AppController } from &#39;./app.controller&#39;;
import { AppService } from &#39;./app.service&#39;;
import { ConfigModule } from &#34;@nestjs/config&#34;;

@Module({
 imports: [ConfigModule.forRoot()],
 controllers: [AppController],
 providers: [AppService],
})
export class AppModule {}
</code></pre></div>
</div>
</div>
<div>

<p>It&#39;s essential to remember that this framework is not related to any front-end framework by default. That means you manually need to<strong> integrate the <code>dist</code> folder</strong> with your front-end project in this project directory (or better: automate this in the build script). These kinds of applications often need to handle more complex computations and therefore have a <strong>higher server load</strong> and can be harder to scale.</p>
<h2>Real-world Popularity</h2>
<p>The usage/awareness ranking of the State of JS survey comes with a <a href="https://en.wikipedia.org/wiki/Selection_bias">selection bias</a> and does not necessarily reflect the actual situation. Hence, I looked at some more quantitative data that indicate the developer experience of these frameworks.</p>
<p>I inspected the download numbers from npm and some community stats from GitHub and Stack Overflow. This data is accurate as of December 2022.</p>
</div>
<div>

<table>
    
    
        <thead>
        <tr>
            
            
                <th scope="col">
                    
                </th>
            
            
            
                <th scope="col">
                    
                        
                            Next.js
                        
                    
                </th>
            
            
            
                <th scope="col">
                    
                        
                            Gatsby
                        
                    
                </th>
            
            
            
                <th scope="col">
                    
                        
                            NuxtJS
                        
                    
                </th>
            
            
            
                <th scope="col">
                    
                        
                            Nest
                        
                    
                </th>
            
            
        </tr>
        </thead>
    
    <tbody>
    
    
        <tr>
            
            
                
                    <th scope="row">
                        
                            
                                Usage/Awareness
                            
                        
                    </th>
                 
            
            
            
                
                    <td>
                        
                            
                                #2
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                #3
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                #4
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                #5
                            
                        
                    </td>
                 
            
            
        </tr>
    
    
    
        <tr>
            
            
                
                    <th scope="row">
                        
                            
                                Weekly downloads
                            
                        
                    </th>
                 
            
            
            
                
                    <td>
                        
                            
                                3.5m
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                412k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                485k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                1.9m
                            
                        
                    </td>
                 
            
            
        </tr>
    
    
    
        <tr>
            
            
                
                    <th scope="row">
                        
                            
                                GH Stars
                            
                        
                    </th>
                 
            
            
            
                
                    <td>
                        
                            
                                97.7k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                53.9k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                10.9kÂ *
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                52.8k
                            
                        
                    </td>
                 
            
            
        </tr>
    
    
    
        <tr>
            
            
                
                    <th scope="row">
                        
                            
                                GH Forks
                            
                        
                    </th>
                 
            
            
            
                
                    <td>
                        
                            
                                21.6k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                10.5k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                1.1k *
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                6.3k
                            
                        
                    </td>
                 
            
            
        </tr>
    
    
    
        <tr>
            
            
                
                    <th scope="row">
                        
                            
                                GH Contributors
                            
                        
                    </th>
                 
            
            
            
                
                    <td>
                        
                            
                                2.4k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                3.9k
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                340 *
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                350
                            
                        
                    </td>
                 
            
            
        </tr>
    
    
    
        <tr>
            
            
                
                    <th scope="row">
                        
                            
                                SO Questions (answered)
                            
                        
                    </th>
                 
            
            
            
                
                    <td>
                        
                            
                                25k (12.3k)
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                5.6k (3.7k)
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                10.9k (5.7k)
                            
                        
                    </td>
                 
            
            
            
                
                    <td>
                        
                            
                                9.8k (5.1k)
                            
                        
                    </td>
                 
            
            
        </tr>
    
    
    </tbody>
</table>
</div>
<div>

<p>* Started a new repository for version 3</p>

<p>Across almost all these metrics, we see Next.jsâ€™s leadership. It has the most downloads, GitHub stars, and forks, and the most extensive knowledge base on Stack Overflow. Surprisingly, Gatsby has the most GitHub contributions, which shows how big its rich ecosystem is. At first, it also seems surprising that Nest has so many weekly downloads compared to Gatsby and Nuxt, even if the other stats are very similar. A possible explanation might be that Nest is the only listed framework that can be used to implement backend servers and is, therefore, without competition. Even though the other frameworks are not freely interchangeable, they all can be used for server-rendered HTML pages and might cannibalize themselves to some degree.</p>
<h2>How to Choose</h2>
<p>Let&#39;s revisit the start of this post now that we know more about these frameworks. Which framework would be best suited for a side project? To answer this question, you need to ask yourself the following questions:</p>
<ul>
<li>Do you want to build a full-stack app or not?</li>
<li>If so, do you want more freedom and flexibility or prefer out-of-the-box modules, if available in the first place, that you can plug in to get the desired result?</li>
<li>If the app doesn&#39;t require full-stack development, which rendering strategy do you prefer based on your needs for performance and SEO-friendliness?</li>
</ul>
<p>This decision tree includes these questions and will help you focus on the frameworks you might want to consider:</p>
<p><img alt="Decision tree for the frameworks" height="450" sizes="800px" src="https://assets.cdn.prod.twilio.com/images/NxT7z5CTH83aLdJa1qSl_4rWga1K7a8C1eixQKFCpj_Z2u.width-800.png" srcset="https://assets.cdn.prod.twilio.com/images/NxT7z5CTH83aLdJa1qSl_4rWga1K7a8C1eixQKFCpj_Z2u.width-800.png 800w, https://assets.cdn.prod.twilio.com/images/NxT7z5CTH83aLdJa1qSl_4rWga1K7a8C1eixQKFCpj_Z2.width-1600.png 960w" width="800"/></p>
<h2>My recommendations, and whatâ€™s next</h2>
<p>If youâ€™d like to learn something new, Iâ€™d recommend checking out <a href="https://nextjs.org/docs/getting-started">Next.js</a>. Itâ€™s great if you want to build a website that leverages React and has an informative character without a lot of interactivity, such as a company website, a blog, or a landing page for a product. If you want to build such a site but prefer Vue.js, then <a href="https://nuxtjs.org/docs/get-started/installation">Nuxt</a> will be your friend.</p>
<p>Itâ€™s also ok to build a SPA, without a backend framework, with React or Vue.js if this fits your needs. When you want to build a server application, on the other hand, it makes sense to evaluate whether you want to build with established modules that offer a plug-and-play mechanism (Nest) or whether you want to be able to build everything on your own with Express.</p>
<p>If you are planning to develop with any of these frameworks and you have open questions, feel free to contact me via any of the following channels.</p>
<ul>
<li>Email: mobert@twilio.com</li>
<li>Twitter: <a href="https://twitter.com/IObert_">@IObert_</a></li>
<li>Github:<a href="https://github.com/IObert">IObert</a></li>
</ul>

</div>
    
    
    

    

    

    
  </section>
</article>


    

        
          </ul>
        
      </section>
    </div></div>
  </body>
</html>
