<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rrampage.github.io/2025/06/13/strace-tips-for-better-debugging/">Original</a>
    <h1>strace tips for better debugging</h1>
    
    <div id="readability-page-1" class="page"><div><p>Recently, I have been building software without libc to better understand Linux syscalls and internals better. So far, I have built a <a href="https://gist.github.com/rrampage/5046b60ca2d040bcffb49ee38e86041f">minimal shell</a>, <a href="https://gist.github.com/rrampage/2a781662645dc2fcba45784eb584cbdc">terminal Snake game</a>, pure ARM64 assembly <a href="https://gist.github.com/rrampage/d31e75647a77badb3586ebae1e414cb6">HTTP server</a> and <a href="https://gist.github.com/rrampage/43c56d4a56f8f73320d17ff7b3a49be6">threads implementation</a>. I have been using <a href="https://man7.org/linux/man-pages/man1/strace.1.html"><code>strace</code></a> extensively while debugging.</p>
<h2 id="useful-options-and-flags">Useful options and flags</h2>
<p>I use a version of the following command:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>strace -fintrCDTYyy -o strace.log -v -s128 ./binary
</span></span></code></pre></div><p>This looks like an alphabet soup of options! Hereâ€™s what they do and how they are useful:</p>
<ul>
<li><code>-f</code>: Follow child processes/threads. This is especially useful when dealing with spawning processes or threads as otherwise, strace will only trace the parent process.</li>
<li><code>-v</code>: Print unabbreviated versions of environment, stat, termios and other structs in  syscalls. I found this invaluable in conjunction with <code>-s</code> when doing assembly programming to check if the structs were being initialized correctly and if certain arguments were being sent in little/big endian format</li>
<li><code>-s NUM</code>: Specify the maximum string size to print. Useful for large structs</li>
<li><code>-o</code>: Save strace output to a log file. It is always better to do this to investigate the output of the original process and strace separately without each cluttering the other</li>
<li><code>-yy</code>: Print all available information associated with file descriptors. This is great for expanding the file descriptor to either its full path in case of a file or TCP address in case of sockets</li>
<li><code>-Y</code>: Print command names for PIDs. I found this useful when building the shell to check if the correct program is being executed</li>
<li><code>-t</code>: Print current timestamp in log</li>
<li><code>-T</code>: Show time spent in syscalls. Useful for some basic profiling although strace heavily slows down the process.</li>
<li><code>-r</code>: Print a relative timestamp upon entry to each system call</li>
<li><code>-n</code>: Print syscall number. Great to quickly find out syscall numbers on new architectures.</li>
<li><code>-i</code>: Print instruction pointer at the time of syscall. Found this useful when debugging assembly code to check rough location of errors.</li>
<li><code>-C</code>: Print summary of syscall count, time, errors at the end of regular output</li>
</ul>
<h2 id="print-stack-traces">Print stack traces</h2>
<p>The <code>-k</code> or <code>--stack-trace</code> prints the stacktrace along with the syscall. This is useful if your program is compiled with with <code>-g</code>. <a href="https://shane.ai/posts/backtraces-with-strace/">This post</a> is a good read on using strace to show backtraces for a Golang program compiled with <code>GODEBUG</code>.</p>
<h2 id="selectively-tracing-syscalls">Selectively tracing syscalls</h2>
<p>By default, strace traces all syscalls. We can be very selective in tracing calls by using the <code>-e</code> option. It  allows us to trace families of syscalls e.g <code>-e t=%net</code> will trace all network related syscalls while <code>-e t=%mem</code> will trace memory related syscalls.</p>
<p>We can also trace only syscalls which succeed using <code>-z</code> option or fail using <code>-Z</code> option. Another useful option is <code>-P</code> which can be used to only trace syscalls which access a particular path e.g <code>strace -f -P /usr/bin/ls sh -c ls</code>.</p>
<h2 id="tampering-with-syscalls">Tampering with syscalls!</h2>
<p>strace is very powerful and can do stuff like inject faults for particular syscalls e.g <code>strace -e inject=%file:error=ENOENT:when=3+ ls</code> which fails the all file related syscalls after 2 successful invocations. We can also make syscalls return a particular value using <code>retval</code> or send signal using <code>signal</code> or delay at beginning or end of syscall using <code>delay_enter</code> and <code>delay_exit</code> with <code>-e inject</code>.</p>
<p>I found this useful when debugging failure cases in code for the syscalls. The strace output will have lines like <code>openat(AT_FDCWD, &#34;/lib/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory) (INJECTED)</code> which have <code>INJECTED</code> marked in them. This is useful to differentiate genuine syscall errors from the injected ones.</p>


  </div></div>
  </body>
</html>
