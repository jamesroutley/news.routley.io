<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://computerwebsite.net/writing/gjk">Original</a>
    <h1>The GJK Algorithm: A weird and beautiful way to do a simple thing</h1>
    
    <div id="readability-page-1" class="page">
    

    
    <hr/>
    <p>The GJK algorithm is a weird way to do a simple thing.
</p><p>We have shape A and shape B, and we&#39;d like to determine if they overlap.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609145754.png" width="500"/>
</p><p>A shape is a set of infinitely many points. If there exists any point that&#39;s a member of both sets, then the shapes overlap.
</p><p>Alternatively, if there exists point <em>a</em> in set A and a point <em>b</em> in set B such that:
</p><p><em>a</em> - <em>b</em> = <strong>0</strong>
</p><p>Then an intersection exists. Note that the <strong>0</strong> here represents a point itself: the origin.
</p><p>To see what this means intuitively, we can take a shift in perspective. Instead of dealing with specific points, let&#39;s try subtracting <em>every</em> point within one shape from <em>every</em> point within another, and plotting where they all end up:
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240604163159.png" width="500"/>
</p><p>We&#39;ve ended up with a new set that represents the &#34;difference&#34; between A and B. Since it contains the origin, we know that there must be at least one pair of points whose difference is <strong>0</strong>.
</p><p>That&#39;s exactly what the GJK algorithm takes advantage of. Instead of directly checking if the sets have an intersection, we subtract them and see if the new set contains the origin.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240604163335.png" width="500"/>
</p><p>Combining sets like this is known as taking the Minkowski difference. You may see this denoted &#39;⊖&#39; to separate it from the normal notion of a difference.
</p><p>More formally, it&#39;s defined as:
</p><p>A ⊖ B = {a - b | a ∊ A, b ∊ B}
</p><p>At first, it doesn&#39;t seem like we&#39;ve made any progress, only rephrased the problem. How are we supposed to subtract infinitely many points? Well, let&#39;s find the bare minimum that we <em>need to know</em> about the set A ⊖ B to see if it contains the origin.
</p><p>In 2 dimensions, if a convex set contains the origin, it means we&#39;re able to draw a triangle between 3 points on the boundary, which contains the origin. This makes the problem even easier. If we know that A ⊖ B is convex, we only need to deal with the boundary.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240604164614.png" width="500"/>
</p><p>Luckily, it&#39;s easy to ensure A ⊖ B will be convex.
</p><p>The Minkowski difference of any two convex sets is also convex. So, we just need to break down A and B into convex components, which we can work with individually. On a computer, most shapes are already constructed out of convex components, so this process is often extremely easy.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240604182725.png" width="500"/>
</p><p>By the way, even though I&#39;m explaining in 2D, our problem is fundamentally the same in any dimension. Here, we&#39;re looking for a bounding triangle on A ⊖ B. But, more generally, we&#39;re looking for a &#34;simplex&#34; in our dimension. An n-dimensional simplex is just the simplest polytope that can enclose an n-dimensional region. For example, a 3D simplex is a tetrahedron, as it has the fewest vertices needed to bound a volume.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240604175314.png" width="500"/>
</p><p><em></em>With these tools, let&#39;s restate the problem.
</p><ul><li>We want to determine if any simplex within A ⊖ B will enclose the origin.
</li></ul><ul><li>We don&#39;t want to have to compute the entire boundary of A ⊖ B. We only need to find some 3 points on A and some 3 points on B that will map to the vertices of our bounding simplex.
</li></ul><ul><li>There&#39;s no one solution, as infinitely many bounding simplexes might exist. We just need to find any 6 points on A and B that work, or prove that we can&#39;t find any.
</li></ul><p>So, from now on, whenever I say &#34;shape&#34;, I&#39;m speaking only about the boundary of a given set. We&#39;ve thrown away all the area, as it&#39;s no longer relevant to the problem.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240604192323.png" width="500"/>
</p><p>Things would be much easier if we had some system to identify points on our shape. The support function (denoted S here) does just that. It takes in a vector, and outputs the furthest point on the shape in that direction. On a convex shape, every boundary point is identifiable using the support function of some direction.
</p><p>In other words, if we rotate a vector <em>d</em> 360 degrees around the origin, S(<em>d</em>) will hit every point. So, finding N points on a shape corresponds to finding N directions.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609121840.png" width="500"/>
</p><p>The support function is easy to formally define. It&#39;s just the point that has the highest dot product of <em>d</em>. 
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609125706.png" width="500"/>
</p><p>Remember how I previously said we&#39;d need to find 3 points on A, and 3 points on B? Well, we really only need to find 3 points in total. That&#39;s because of the following useful property of the Minkowski difference:
</p><p>The support of direction <em>d</em> in A ⊖ B = the support of <em>d</em> in A minus the support of <em>-d</em> in B.
</p><p>Basically, if we sweep across the borders of A and B in opposite directions by rotating <em>d</em>, we&#39;ll hit every boundary point on A ⊖ B. This massively narrows down how many possible points we need to search, as our points on A and B will always be dependent on each other. I know the diagrams are getting a bit confusing now, so bear with me.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240603131831.png" width="500"/>
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240610135637.png" width="500"/>
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609122623.png" width="500"/>
</p><p>Put differently, most combinations of points on A and B don&#39;t matter, as they won&#39;t land us on the border of A ⊖ B. We only need to consider the case where they&#39;re in opposite directions. (There&#39;s some easy intuition for why this is the case: I&#39;ll leave that as an exercise)
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609123441.png" width="500"/>
</p><p>Alright, the stage has been set for GJK. The goal of the GJK algorithm is to find a simplex on A ⊖ B that contains the origin (or show that none exists), while doing as few operations as possible.
</p><p>Let&#39;s appreciate how incredible such an algorithm would be: given <em>any</em> convex shape, as long as it has some defined notion of support points, we can detect collisions. That&#39;s unbelievably powerful. 
</p><p>Here&#39;s how it works:
</p><p>1) First, find a point on A ⊖ B using a random direction <em>d</em>, which we&#39;ll call <em>p</em>. This is just S(<em>d</em>) - S(-<em>d</em>). It&#39;s the first point on our simplex.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240603135933.png" width="500"/>
</p><p>2) Then, let&#39;s take the dot product of <em>d</em> and <em>p</em>. If it&#39;s positive, we keep going on with the algorithm. If it&#39;s negative, that means <em>d</em> and <em>p</em> point in opposite directions. In that case, we terminate the algorithm, as there&#39;s no way for B and A to overlap.
</p><p>But why?
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240603151836.png" width="500"/>
</p><p>It&#39;s more clear when we rotate our view to be in line with <em>d</em>. Point <em>a</em> is S(<em>d</em>), and point <em>b</em> is S(-<em>d</em>). Now, point <em>a</em> is the &#34;top&#34; of shape A, and point <em>b</em> is the &#34;bottom&#34; of B. Remember that <em>p</em> = <em>a - b</em>. So, if we project <em>p</em> onto <em>d</em> by taking the dot product, and it&#39;s negative, a gap exists between A and B.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609131123.png" width="500"/>
</p><p>3) Ok, great. We&#39;ve got one point of our simplex. Now, we need another. From our point <em>p</em>, let&#39;s shoot in the direction of the origin. Take the support of that vector <em>-d</em>, and run our check from step 2 on it.
</p><p>If you think about it, we&#39;re just finding the point most in the direction of the origin from <em>p</em>. If our shape encloses the origin, then our new point will have to be on the opposite side of it.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240610080829.png" width="500"/>
</p><p>Remember how we just performed the check from step 2? Well, there&#39;s another way to think about it. We&#39;re just checking to see if we&#39;ve crossed the origin. If the origin is within our shape, we&#39;ll have to cross it when we take support points in opposite directions.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609152836.png" width="500"/>
</p><p>4) Now, we&#39;re ready to complete the simplex. Let&#39;s take the vector perpendicular to our first 2 points in the direction of the origin. The support of that vector is the 3rd point of our simplex.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609133818.png" width="500"/>
</p><p>I mean, think about it. We&#39;ve effectively divided the space in half with our first line. We know the origin can&#39;t be anywhere on one side of our line, so we continue our search in the opposite direction. That&#39;s the efficiency of GJK: we&#39;ll keep dividing the space in half, until we find the point.
</p><p>Oh, and as usual, we can run our check from step 2 to see if we&#39;ve proven that the shapes do not overlap.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609134721.png" width="500"/>
</p><p>5) Now, let&#39;s see if our simplex contains the origin. If it does, we return true. Otherwise, we continue on.
</p><p>To find if the origin is within our triangle, first, let&#39;s break down the area surrounding it into the three infinite regions depicted below.
</p><p>The overlapping red, green, and blue regions each divide the space in half: an inside region, and an outside region.
</p><p>We&#39;ve already eliminated the possibility of the origin being in the red region. So, we just have to check whether it&#39;s outside either of the remaining 2 lines.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240610140613.png" width="500"/>
</p><p>Luckily, we already know how to do this. Just take the dot product perpendicular to a given line to see if the origin is beyond it. If so, we know it must be in the white region.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240610140732.png" width="500"/>
</p><p>6) Now, it&#39;s time to iterate. We repeat from step 4, this time from the line on our simplex closest to the origin. We update our simplex using this new support point, and check if the new simplex contains the origin, as we did in step 5. This time, it does! Our algorithm returns <em>true</em>. If it doesn&#39;t, we keep doing this iterative process until it does, or one of our checks fails.
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609142721.png" width="500"/>
</p><p><img src="https://computerwebsite.net/writing/images/Pasted%20image%2020240609143010.png" width="500"/>
</p><p>And, that&#39;s it. That&#39;s the essence of the GJK algorithm. 
</p><p>I&#39;ve glossed over a few implementation details, but you now have all the intuition you need to develop an in-depth understanding.
</p><p>Personally, I find this algorithm pretty because it&#39;s such a tidy example of what makes mathematics so powerful. Through a bunch of subtle shifts in perspective, a complicated problem becomes obvious.
</p><p>There&#39;s probably a few things incorrect with what I said. So, take it with the appropriate amount of salt for a high school sophomore&#39;s explanation of anything math related.</p>


</div>
  </body>
</html>
