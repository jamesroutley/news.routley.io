<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://driftingin.space/posts/you-might-not-need-a-crdt">Original</a>
    <h1>You might not need a CRDT</h1>
    
    <div id="readability-page-1" class="page"><div id="__next" data-reactroot=""><div><div><article><p><time datetime="2022-12-05">December 5, 2022</time> • <!-- -->Paul Butler</p><p><em>Conflict-free replicated data types</em> (CRDTs) are a family of replicated data structures.</p>
<p>CRDTs differ from simple leader/follower replication in that they do not designate an authoritative source-of-truth that all writes must pass through. Instead, all replicas are treated as equal peers. Each replica may be modified locally, and changes to any replica are propagated to the others.</p>
<p>In developer discourse, the term <em>CRDT</em> sometimes gets thrown around as a synecdoche for a broader set of techniques to enable Figma-like collaborative features. But when we started talking to dozens of companies building <a href="https://browsertech.com/bt-index">ambitious browser-based apps</a>, we found it rare for apps to use true CRDTs to power multiplayer collaboration.</p>
<p>In this post, I’ll first give some high-level context on CRDTs, and then talk about why we often find other approaches used in practice.</p>
<h3>Synchronizing State</h3>
<p>The core problem that multiplayer apps need to solve is maintaining shared state. If you and I are both editing the same document, I should see your changes in real-time and vice versa.</p>
<p>At the code level, this means that there is some data structure (say, a tree or list) representing the document which exists in multiple locations: one for each user with the document open. Changes made on one copy need to be reflected by the others, as quickly as possible.</p>
<p>One way to accomplish this is to serialize each change and broadcast it over the network. If you and I are collaborating on a todo list, and I mark the fifth item as done, my replica emits some serialized event meaning “Mark item #5 as done”. If you then add an item ‘get groceries’ in the third position, your replica emits an event meaning “Insert ‘get groceries’ before item #3”.</p>
<p>This works fine as long as enough time passes for each of us to receive the others’ changes before making our own change. If not, things break down.</p>
<p>Suppose we start a collaboration session at time 0 with a list of two items, <em>Get groceries</em> and <em>Do laundry</em>.
At time 1, I mark <em>Do laundry</em> as done, and you simultaneously add a new item called <em>Clean kitchen</em> to the middle of the list. When my replica sees your edit at time 2, your change is appropriately applied on top of mine and I see the correct state. But when my change (“mark item 2 as done”) reaches your replica, “item 2” refers to the item you just added, not the one I actually checked. Our lists have diverged.</p>
<img src="https://driftingin.space/images/crdt.png" alt="A timeline showing a to-do list converging."/>
<p>The problem comes down to the interplay of two facts:</p>
<ol>
<li>Operations on our data structure are not <a href="https://en.wikipedia.org/wiki/Commutative_property">commutative</a>: the result of applying them depends on the order in which they are applied.</li>
<li>Our operations are <strong>unordered</strong>. Each replica might receive and apply the changes in a different order.</li>
</ol>
<p>If we can design a system in which <em>either one</em> of these statements is no longer true, we can ensure that our data structure is eventually-consistent. Each of the two items represents a different path we can take.</p>
<p>Path #1 represents <strong>CRDTs</strong>. Broadly, you can think of CRDTs (specifically, operation-based CRDTs) as a family of useful data structures (lists, sets, maps, counters) carefully designed such that all operations are commutative. I&#39;m brushing over some details, but it’s a useful mental model for understanding the shape of the problem that CRDTs solve.</p>
<p>Path #2 in its pure form represents <a href="https://en.wikipedia.org/wiki/State_machine_replication">state machine replication</a>. We ensure that each replica receives changes in the same “global” order, and apply change on each replica in that same global order. This ensures that each replica stays in sync, even if change operations are not commutative.</p>
<p>In practice, most of the systems we’ve looked at could be described as hybrid approaches that borrow ideas from both paths. They represent operations as commutative where possible so that they can apply them immediately on the local replica without worrying about where they appear in the global order, but they ultimately depend on a global order for convergence.</p>
<h3>Aside: Convergence vs. Correctness</h3>
<p>Both paths will allow us to ensure that each replica converges on the same state, but that alone does not guarantee that this state is the “correct” state from the point of view of user intent.</p>
<p>For example, in the to-do example, it’s possible that the server sees your “add Clean kitchen” change before my “check item #1” change, and incorrectly marks the new item as checked.</p>
<p>A typical solution in this case (applicable to both paths) is to generate a random UUID for each item when it is created, so that my change is instead represented as “check item <code>8e50…3f34</code>”, and is applied correctly regardless of <em>where</em> the item I intend to check is in the list by the time my change is applied on a replica.</p>
<p>State machine replication is not a silver bullet; we still need to be thoughtful about how change operations apply when the underlying data has changed. Our <a href="https://aper.dev/">Aper</a> Rust library is an experiment in seeing how much of this can be generalized into a data structures library.</p>
<h3>Global order</h3>
<p>So far, our assumption has been that we have a reliable but unordered broadcast channel (in practice, it may be a <a href="https://en.wikipedia.org/wiki/Gossip_protocol">gossip protocol</a> on top of a mesh network). This is a fitting assumption for a true peer-to-peer app, where it is difficult to get every peer to come to a consensus about the “true” ordering of events. CRDTs are complex, in both the runtime overhead and cognitive load senses, but in a peer-to-peer environment, this is a necessary cost.</p>
<p>In contrast, browsers are inherently <em>not</em> peer-to-peer. To run an application from the web, you connect to a server. Since the server is centralized anyway, we can have it enforce a <em>global ordering</em> over the events. That is, every replica receives events in the same orer. With this, we can sidestep the need to pay the CRDT complexity tax.</p>
<p>Evan Wallace of Figma <a href="https://www.figma.com/blog/how-figmas-multiplayer-technology-works/">writes</a>:</p>
<blockquote>
<p>Figma isn&#39;t using true CRDTs […]. CRDTs are designed for decentralized systems where there is no single central authority to decide what the final state should be. There is some unavoidable performance and memory overhead with doing this. Since Figma is centralized (our server is the central authority), we can simplify our system by removing this extra overhead and benefit from a faster and leaner implementation.</p>
</blockquote>
<p>With a global order, we don’t need to bend over backwards to ensure that data mutations are commutative, we can use the global order to apply them in the same order on every replica.</p>
<p>(A modern web application is likely deployed to multiple servers, not one, which complicates using “the server” as a source of truth. Figma solves this by routing messages to <a href="https://www.figma.com/blog/rust-in-production-at-figma/">a dedicated process</a> for each live document. <a href="https://plane.dev/">Plane</a> and <a href="https://jamsocket.com">Jamsocket</a> generalize that approach.)</p>
<h3>Composition</h3>
<p>Generic data structures, like lists and maps, are often used as a foundation for building more complex data structures, like graphs and relational data tables.</p>
<p>It’s tempting to wonder if we could just swap out their underlying data structures for the equivalent CRDTs, and automatically gain a CRDT for our composite data type.</p>
<p>Unfortunately, these composite data types usually rely on the fact that all changes to the underlying data structure go through a particular code path. This is necessary to enforce invariants that they rely on.</p>
<p>For example, suppose our document state represents a directed acyclic graph as a list, where elements can reference other items by index. Even if each replica ensures that changes made to it don’t introduce a cycle, two innocent changes made concurrently on two replicas could combine to break the invariant.</p>
<img src="https://driftingin.space/images/combined-dag.png" alt=""/>
<p>If we naively try to replicate this tree by replicating the underlying list CRDT, we lose control of this invariant. Two concurrent modifications may result in a cycle when they are combined, even if neither introduces a cycle in isolation.</p>
<p>When we instead have a global order of changes, data structures with invariants are easier to reason about. The authoritative server can apply the change locally to detect if invariants are violated. If they are, instead of broadcasting the change, it can notify the sender that there is a conflict.</p>
<h3>Overthinking things</h3>
<p>Developers may find it tempting to treat collaborative applications as any other distributed systems, and in many ways that’s a useful way to look at them. But they differ in an important way, which is that they always have humans-in-the-loop. As a result, many edge cases can simply be deferred to the user.</p>
<p>For example, every multiplayer application has to decide how to handle two users modifying the same object concurrently. In practice, this tends to be rare, because of something I call <em>social locking</em>: the tendency of reasonable people not to clobber each other’s work-in-progress, even in the absence of software-based locking features. This is especially the case when applications have presence features that provide hints to other users about where their attention is (cursor position, selection, etc.) In the rare times it does occur, the users can sort it out among themselves.</p>
<p>A general theme of successful multiplayer approaches we’ve seen is not overcomplicating things. We’ve heard a number of companies confess that their multiplayer approach feels naive — especially compared to the academic literature on the topic — and yet it works just fine in practice.</p>
<h3>When CRDTs make sense</h3>
<p>Although CRDTs aren’t always the best solution for always-online collaborative apps, it’s still fascinating tech that has real use cases.</p>
<p>Ink &amp; Switch, the exceedingly capable team behind the popular CRDT library <a href="https://automerge.org/">Automerge</a>, have a compelling vision for <a href="https://www.inkandswitch.com/local-first/">Local-first software</a>, which makes heavy use of CRDTs. Apps that need to run offline in general are good candidates for CRDTs.</p>
<p>I’ve also read <a href="https://blog.kevinjahns.de/are-crdts-suitable-for-shared-editing/">some</a> <a href="https://zed.dev/blog/crdts">posts</a> lately extolling the virtues of CRDTs for text, especially plain text. I’m not up on text synchronization except to know that it presents its own challenges, so the fact that the people who have given it a lot of thought are landing on CRDTs is a strong signal in their favor.</p>
<h3>Share</h3>
<blockquote><p lang="en" dir="ltr">New from us: You might not need a CRDT.<a href="https://t.co/5solT6we3S">https://t.co/5solT6we3S</a></p>— Drifting in Space (@drifting_corp) <a href="https://twitter.com/drifting_corp/status/1599777237707853826?ref_src=twsrc%5Etfw">December 5, 2022</a></blockquote>
<!-- --> <!-- -->
<p>For more like this, subscribe to our <a href="https://digest.browsertech.com/">Browsertech Digest</a> or follow <a href="https://twitter.com/drifting_corp">@drifting_corp</a> on Twitter.</p></article></div></div></div></div>
  </body>
</html>
