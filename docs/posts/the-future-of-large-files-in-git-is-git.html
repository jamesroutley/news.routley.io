<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tylercipriani.com/blog/2025/08/15/git-lfs/">Original</a>
    <h1>The Future of Large Files in Git Is Git</h1>
    
    <div id="readability-page-1" class="page"><article class="page">







<div id="pagebody">

<section id="content" role="main">

<p>If Git had a nemesis, itâ€™d be large files.</p>
<p>Large files bloat Gitâ€™s storage, slow down <code>git clone</code>,
and wreak havoc on Git forges.</p>
<p>In 2015, GitHub released Git LFSâ€”a Git extension that hacked around
problems with large files. But Git LFS added new complications and
storage costs.</p>
<p>Meanwhile, the Git project has been quietly working on large files.
And while LFS ainâ€™t dead yet, the latest Git release shows the path
towards a future where LFS is, finally, obsolete.</p>
<section id="what-you-can-do-today-replace-git-lfs-with-git-partial-clone">
<h2>What you can do today: replace Git LFS with Git partial clone</h2>
<p>Git LFS works by storing large files outside your repo.</p>
<p>When you clone a project via LFS, you get the repoâ€™s history and
small files, but skip large files. Instead, Git LFS downloads only the
large files you need for your working copy.</p>
<p>In 2017, the Git project introduced <strong>partial clones</strong>
that provide the same benefits as Git LFS:</p>
<blockquote>
<p>Partial clone allows us to avoid downloading [large binary assets]
<em>in advance</em> during clone and fetch operations and thereby reduce
download times and disk usage.</p>
<p>â€“ Partial Clone Design Notes, <a href="https://git-scm.com/docs/partial-clone">git-scm.com</a></p>
</blockquote>
<p>Gitâ€™s partial clone and LFS both make for:</p>
<ol type="1">
<li><strong>Small checkouts</strong> â€“ On clone, you get the latest copy
of big files instead of <strong>every</strong> copy.</li>
<li><strong>Fast clones</strong> â€“ Because you avoid downloading large
files, each clone is fast.</li>
<li><strong>Quick setup</strong> â€“ Unlike shallow clones, you get the
entire history of the projectâ€”you can get to work right away.</li>
</ol>
<p><strong>What is a partial clone?</strong></p>
<p>A Git partial clone is a clone with a <code>--filter</code>.</p>
<p>For example, to avoid downloading files bigger than 100KB, youâ€™d
use:</p>
<pre><code>git clone --filter=&#39;blobs:size=100k&#39; &lt;repo&gt;</code></pre>
<p>Later, Git will lazily download any files over 100KB you need for
your checkout.</p>
<p>By default, if I <code>git clone</code> a repo with many revisions of
a noisome 25 MB PNG file, then cloning is slow and the checkout is
obnoxiously large:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>$</span> time git clone https://github.com/thcipriani/noise-over-git</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span>Cloning</span> into <span>&#39;/tmp/noise-over-git&#39;</span>...</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span>Receiving</span> objects: 100% <span>(</span><span>153/153</span><span>)</span><span>,</span> 1.19 GiB</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span>real</span>    3m49.052s</span></code></pre></div>
<p>Almost four minutes to check out a single 25MB file!</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>$</span> du <span>--max-depth</span><span>=</span>0 <span>--human-readable</span> noise-over-git/.</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span>1.3G</span>    noise-over-git/.</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>$</span> ^ ðŸ¤¬</span></code></pre></div>
<p>And 50 revisions of that single 25MB file eat 1.3GB of space.</p>
<p>But a partial clone side-steps these problems:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>$</span> git config <span>--global</span> alias.pclone <span>&#39;clone --filter=blob:limit=100k&#39;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>$</span> time git pclone https://github.com/thcipriani/noise-over-git</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span>Cloning</span> into <span>&#39;/tmp/noise-over-git&#39;</span>...</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span>...</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span>Receiving</span> objects: 100% <span>(</span><span>1/1</span><span>)</span><span>,</span> 24.03 MiB</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span>real</span>    0m6.132s</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span>$</span> du <span>--max-depth</span><span>=</span>0 <span>--human-readable</span> noise-over-git/.</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span>49M</span>     noise-over-git/</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span>$</span> ^ ðŸ˜» <span>(</span><span>the</span> same size as a git lfs checkout<span>)</span></span></code></pre></div>
<p>My filter made cloning 97% faster (3m 49s â†’ 6s), and it reduced my
checkout size by 96% (1.3GB â†’ 49M)!</p>
<p>But there are still some caveats here.</p>
<p>If you run a command that needs data you filtered out, Git will need
to make a trip to the server to get it. So, commands like
<code>git diff</code>, <code>git blame</code>, and
<code>git checkout</code> will require a trip to your Git host to
run.</p>
<p>But, for large files, this is the same behavior as Git LFS.</p>
<p>Plus, I canâ€™t remember the last time I ran <code>git blame</code> on
a PNG ðŸ™ƒ.</p>
</section>
<section id="why-go-to-the-trouble-whats-wrong-with-git-lfs">
<h2>Why go to the trouble? Whatâ€™s wrong with Git LFS?</h2>
<p>Git LFS foists Gitâ€™s problems with large files onto users.</p>
<p>And the problems are significant:</p>
<ul>
<li><strong>ðŸ–• High vendor lock-in</strong> â€“ When GitHub wrote Git LFS,
the other large file systemsâ€”Git Fat, Git Annex, and Git Mediaâ€”were
agnostic about the server-side. But GitHub locked users to their
proprietary server implementation and charged folks to use it.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></li>
<li><strong>ðŸ’¸ Costly</strong> â€“ GitHub won because it let users host
repositories for free. But Git LFS started as a paid product. Nowadays,
thereâ€™s a free tier, but youâ€™re dependent on the whims of GitHub to set
pricing. Today, a 50GB repo on GitHub will cost $40/year for storage. In
contrast, storing 50GB on Amazonâ€™s S3 standard storage is $13/year.</li>
<li><strong>ðŸ˜° Hard to undo</strong> â€“ Once youâ€™ve moved to Git LFS,
itâ€™s impossible to undo the move without rewriting history.</li>
<li><strong>ðŸŒ€ Ongoing set-up costs</strong> â€“ All your collaborators
need to install Git LFS. Without Git LFS installed, your collaborators
will get confusing, metadata-filled text files instead of the large
files they expect.</li>
</ul>
</section>
<section id="the-future-git-large-object-promisors">
<h2>The future: Git large object promisors</h2>
<p>Large files create problems for Git forges, too.</p>
<p>GitHub and GitLab put limits on file size<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>
because big files cost more money to host. Git LFS keeps server-side
costs low by offloading large files to CDNs.</p>
<p>But the Git project has a new solution.</p>
<p>Earlier this year, Git merged a new feature: <strong>large object
promisers</strong>. Large object promisors aim to provide the same
server-side benefits as LFS, minus the hassle to users.</p>
<blockquote>
<p>This effort aims to especially improve things on the server side, and
especially for large blobs that are already compressed in a binary
format.</p>
<p>This effort aims to provide an alternative to Git LFS</p>
<p>â€“ Large Object Promisors, <a href="https://git-scm.com/docs/large-object-promisors">git-scm.com</a></p>
</blockquote>
<p><strong>What is a large object promisor?</strong></p>
<p>Large object promisors are special Git remotes that only house large
files.</p>
<p>In the bright, shiny future, large object promisors will work like
this:</p>
<ol type="1">
<li>You push a large file to your Git host.</li>
<li>In the background, your Git host offloads that large file to a large
object promisor.</li>
<li>When you clone, the Git host tells your Git client about the
promisor.</li>
<li>Your client will clone from the Git host, and automagically nab
large files from the promisor remote.</li>
</ol>
<p>But weâ€™re still a ways off from that bright, shiny future.</p>
<p>Git large object promisors are still a work in progress. Pieces of
large object promisors merged to Git in <a href="https://lore.kernel.org/git/xmqqfrjfilc8.fsf@gitster.g/">March of
2025</a>. But thereâ€™s <a href="https://gitlab.com/groups/gitlab-org/-/epics/9094">more to do</a>
and <a href="https://gitlab.com/groups/gitlab-org/-/epics/15972">open
questions</a> yet to answer.</p>
<p>And so, for today, youâ€™re stuck with Git LFS for giant files. But
once large object promisors see broad adoption, maybe GitHub will let
you push files bigger than 100MB.</p>
</section>
<section id="the-future-of-large-files-in-git-is-git.">
<h2>The future of large files in Git is Git.</h2>
<p>The Git project is thinking hard about large files, so you donâ€™t have
to.</p>
<p>Today, weâ€™re stuck with Git LFS.</p>
<p>But soon, the only obstacle for large files in Git will be your
half-remembered, ominous hunch that itâ€™s a bad idea to stow your MP3
library in Git.</p>
<hr/>

</section>


</section>









</div>



</article></div>
  </body>
</html>
