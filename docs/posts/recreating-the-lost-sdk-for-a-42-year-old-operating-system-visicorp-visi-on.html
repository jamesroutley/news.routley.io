<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/index.md">Original</a>
    <h1>Recreating the lost SDK for a 42-year-old operating system: VisiCorp Visi On</h1>
    
    <div id="readability-page-1" class="page"><div>

  
  <div>
    
    <div>
      <div><h2 id="on-recreating-the-lost-sdk-for-a-42-year-old-operating-system-visicorp-visi-on"><a href="#on-recreating-the-lost-sdk-for-a-42-year-old-operating-system-visicorp-visi-on" rel="nofollow noopener">#</a>On recreating the lost SDK for a 42-year-old operating system: VisiCorp Visi On</h2>
<p>Back in 1983, an office software giant VisiCorp released a graphical multitasking operating system for the IBM PC called VisiOn (or Visi On, or Visi-On, it was before the Internet, so anything goes). It was an &#34;open system&#34;, so anyone could make programs for it. Well, if they owned an expensive VAX computer and were prepared to shell out $7,000 on the Software Development Kit.</p>
<p>VisiOn was released earlier than Microsoft Windows, Digital Research GEM, or Apple Macintosh. Its COMDEX demo even predates the annoucement of Apple Lisa. But being first doesn&#39;t mean getting things right, so this VisiOn of the future did not win the market. Not a single third-party program was released for the system. No one preserved the SDK for the system. The technical documentation roughly amounts to three terse magazine articles and a single Usenet post. Heck, even the copies of the operating system itself are hard to come by.</p>
<p>Despite its low popularity, VisiOn is historically important. It influenced Microsoft&#39;s decisions about Windows, and it is a lesson about failing. So, I thought it would be nice to recreate the SDK for it, Homebrew-style. How difficult could it be, right?!</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/bitmap_adachi.gif"/></p>
<p>It took me a month of working 1-2 hours a day to produce a specification that allowed Atsuko to implement a <a href="https://en.wikipedia.org/wiki/Clean-room_design" rel="nofollow noopener">clean-room</a> homebrew application for VisiOn that is capable of bitmap display, menus and mouse handling.</p>
<p>If you&#39;re wondering what it felt like: this project is the largest &#34;Sudoku puzzle&#34; I have ever tried to solve. In this note, I have tried to explain the process of solving this puzzle, as well as noteworthy things about VisiOn and its internals. But, first things first...</p>
<h3 id="the-first-ever-third-party-application-for-vision"><a href="#the-first-ever-third-party-application-for-vision" rel="nofollow noopener">#</a>The first-ever third-party application for VisiOn</h3>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/bitmapped_app.png"/></p>
<p>Pyramid Game is a simple patience card game that demonstrates the basics of application development for VisiOn. It comes with an installer and features loadable fonts, bitmaps, clickable areas (&#34;buttons&#34;), and a menu system.</p>
<p>You now can download the <a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/pyramid.zip" rel="nofollow noopener">floppy image and the distribution files</a>. Obviously, you will need an installed VisiOn system to run it. The rules of the game can be found <a href="https://en.wikipedia.org/wiki/Pyramid_(solitaire)" rel="nofollow noopener">on Wikipedia</a>.</p>
<p>The source code is available in <a href="https://git.sr.ht/~nkali/vision-homebrew-test-app" rel="nofollow noopener">its own repo</a>.</p>
<p>The claim of Pyramid being &#34;the first-ever&#34; third-party application is a bit strong. VisiOn was an &#34;open system&#34;, and so it is theoretically possible someone bought a VisiOn ToolKit and made third-party applications for VisiOn. But even if they did, they never published or sold them. So, Pyramid is the first-ever published third-party application for VisiOn.</p>
<h3 id="target-audience-of-this-note"><a href="#target-audience-of-this-note" rel="nofollow noopener">#</a>Target audience of this note</h3>
<p>This note is aimed at technically inclined readers with software engineering and coding background who want to learn more about vintage operating systems and reverse engineering. I&#39;ll try to keep the explanations simple at the expense of obscuring some of the technical details; if you want the details, please check out <a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/braindump/index.md" rel="nofollow noopener">the verbose notes</a> and the <a href="https://git.sr.ht/~nkali/vision-homebrew-test-app" rel="nofollow noopener">test application</a>. I hope to document the operating system at a later date.</p>
<p>This note is quite long. Feel free to scroll to a part that interests you and read from there.</p>
<p>Personally, I find this project fascinating in terms of solarpunk and permacomputing. Imagine: you find an ancient device (42 years is ancient for computers, right?!), an artefact of a previous era, without any documentation. You have all the modern knowledge, and you want to make this mysterious device do things it was not supposed to do originally. Of course, with Visi On it&#39;s not quite the same; it runs on the IBM PC, a very well-documented and researched hardware platform.</p>
<p>If you have any feedback or comments, please leave them in the <a href="https://tech.lgbt/@nina_kali_nina/115657816408003907" rel="nofollow noopener">Mastodon thread</a> or in the <a href="https://todo.sr.ht/~nkali/vision-homebrew" rel="nofollow noopener">sr.ht ToDo project</a>. Questions are fine, too!</p>
<h2 id="a-tour-of-vision-quirks"><a href="#a-tour-of-vision-quirks" rel="nofollow noopener">#</a>A tour of VisiOn quirks</h2>
<p>VisiOn was made before many common user interface conventions were invented. It targeted a computer with a tiny resolution of 640x200 pixels, so its authors decided not use any icons. Therefore, VisiOn looks a bit alien. At the same time, it was made by people who knew what they were doing, and it is mostly coherent in its interface decisions.</p>
<p>Here is a copy of the OS tour I gave on <a href="https://tech.lgbt/@nina_kali_nina/115441268919687952" rel="nofollow noopener">Mastodon</a>. I did not insert the clips as inline GIFs because the animations cannot be paused and are very distracting.</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/boot.mov.gif" rel="nofollow noopener">Clip: boot process</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/hourglass.png"/></p>
<p>One immediately obvious thing here is the &#34;hourglass&#34; icon. Some believe that it might have been the first OS to use the hourglass mouse icon, but no, Xerox and InterLisp had it earlier. Apple Lisa, a contemporary, also had a similar mouse cursor.</p>
<p>The main application of the Visi On Application Manager is called &#34;Services&#34;. The biggest diference between &#34;Services&#34; and other applications is that its &#34;exit&#34; button shuts down the whole OS.</p>
<p>You can see the screen has a System Menu at the bottom. The system menu is here to manage windows: make them FULL screen, re-FRAME them, CLOSE into an on-desktop button (we&#39;d say &#34;minimise&#34; today) or OPEN them back. You cannot move the windows by their title bars. The system is very happy to beep at you, like it&#39;s a vintage PC game.</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/windowing.mov.gif" rel="nofollow noopener">Clip: window management</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/windowing.png"/></p>
<p>VisiOn is a multi-tasking operating system, and it allows launching multiple instances of the same application. To differentiate between them, the user can input the window name during the application startup.</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/wordy.mov.gif" rel="nofollow noopener">Clip: multiple windows of the same program</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/window_name.png"/></p>
<p>In VisiOn, the Tutorial and Help apps implement a simple hyper-text system based on the &#34;button&#34; primitive. The &#34;button&#34; is simply a clickable area on the screen. It highlights by reversing the background and foreground colour when the mouse hovers over the button.</p>
<p>The system uses left-click for most operations. The right click is needed for the &#34;scroll&#34; operation. The user can scroll the documents (if there&#39;s something that can be scrolled) and the menu. You can see that the application menu isn&#39;t always fully visible, right?</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/buttons_and_scroll.mov.gif" rel="nofollow noopener">Clip: buttons and scroll</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/help.png"/></p>
<p>The application menu system in VisiOn is hierarchical. Some operations make the menu behave like a modal window would in Windows or Mac. It is common not to add a &#34;cancel&#34; button in the menu. Instead, the system button STOP is used to cancel the operation.</p>
<p>In other situations, the menu can be navigated back by using the hierarchical menu selector. In either case, the system is &#34;verb&#34; driven - you choose the action (&#34;verb&#34;), and then you choose where the action should apply. The biggest problem is probably that the menu system is inconsistent. Some menus have &#34;back&#34; or &#34;cancel&#34; options, and some don&#39;t. Some &#34;verbs&#34; are actually nouns - &#34;Printing&#34;. Some verbs start with a capital letter - &#34;Configure&#34; - like they are nouns. Perhaps it is a sign of a menu element that doesn&#39;t require &#34;an object&#34;. The &#34;object&#34; here is more &#34;grammatical&#34; than a software concept.</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/app_menu_stop.mov.gif" rel="nofollow noopener">Clip: application menu bar</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/menu.png"/></p>
<p>The Archives app is the built-in file manager for the VisiOn and is one of the standard apps. Somewhat surprisingly, it puts deleted files into the &#34;Wastebasket&#34; folder. Windows couldn&#39;t do that because of Apple&#39;s patents - but Apple clearly wasn&#39;t the first (I bet it&#39;s coming from Xerox).</p>
<p>The Archives app makes it clear that VisiOn&#39;s file system supports long file names. VisiOn runs on top of MS-DOS 2.0, so it has to implement its own FS on top of FAT for this to work. The app can also work in two-pane mode, but it divides the screen horizontally, so long file names would fit on the screen easily.</p>
<p>The &#34;verb&#34;-oriented interface requires the app to show a &#34;NEW&#34; item on the screen, though it is a bit confusing. Can you rename a &#34;NEW&#34; file?</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/archives.mov.gif" rel="nofollow noopener">Clip: the Archives application</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/archive.png"/></p>
<p>There are some mysterious buttons we have not explored in VisiOn just yet. One of them, TRANSFER, is used to command the applications to perform a &#34;copy-paste&#34; operation. It is impossible to just &#34;copy&#34; a thing and then &#34;paste&#34; it multiple times.</p>
<p>You can see that the OPEN command is completely unnecessary, because the closed window can be opened simply by clicking its minimised button. It would be nice for VisiOn to remove the OPEN button and replace TRANSFER with separate COPY and PASTE buttons. It shouldn&#39;t be too difficult to implement - Transfer From and Transfer Into are different system events from the application point of view. The concept of Copy&amp;Paste wasn&#39;t ubiqiutous, but it was not unheard of either, because the VisiOn Word has these options in the application menu, in addition to the system&#39;s TRANSFER.</p>
<p>By the way, did you notice a cute VisiOn icon in front of some app names? It is actually two &#34;non-printable&#34; characters, 0x16 and 0x17. The system font <a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/braindump/fontrap.png" rel="nofollow noopener">has a few more useful icons</a> hidden in it.</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/transfer.mov.gif" rel="nofollow noopener">Clip: copy and paste</a></p>
<p>The last important button on the system menu of the VisiOn operating system is OPTIONS. Some applications have a configuration file, and the contents of the configuration file can be displayed on the right side of the window. The Options window behaves like a separate app with a separate menu. It is kind of similar to a pop-up window.</p>
<p>Curiously, it is possible to open the Options window from within the application. The same Options dialogue is shown by Word either by clicking &#34;OPTIONS&#34; or by clicking &#34;Print&gt;local-print&#34;. But then Word also has Cut&amp;Paste menu system that allows copying and pasting <em>within</em> the application (but not between the application windows).</p>
<p><a href="https://git.sr.ht/~nkali/vision-sdk/tree/main/item/note/clips/options.mov.gif" rel="nofollow noopener">Clip: &#34;options&#34; side-bar</a></p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/clips/options.png"/></p>
<h2 id="now-to-the-technical-stuff"><a href="#now-to-the-technical-stuff" rel="nofollow noopener">#</a>Now, to the technical stuff</h2>
<h3 id="what-we-thought-we-knew-about-visi-on"><a href="#what-we-thought-we-knew-about-visi-on" rel="nofollow noopener">#</a>What we thought we knew about Visi On</h3>
<p>At face value, Visi On is a sleek, minimalist-looking windowing system for office applications. But it was built by people involved with early object-oriented programming, and the sales pitch for the system made some pretty bold claims. Were they true? Let&#39;s find out.</p>
<h4 id="fact-checking"><a href="#fact-checking" rel="nofollow noopener">#</a>Fact-checking</h4>
<p>This is a spoliers section for those who thought they knew things about Visi On! For everyone else, this is going to be boring - if so, skip to the next section :)</p>
<blockquote>
<p>The primary objectives of Visi-On is a consistent user interface and portability. Visi-On is designed to run on any operating system. (&#34;The Visi On experience&#34;)</p>
</blockquote>
<p>Sort of. Claiming &#34;Visi-On is designed to run on any operating system&#34; is like claiming &#34;Unix is designed to run on any hardware&#34;. Clearly, it was made with portability in mind, but even supporting CP/M-86 on IBM PC would require a completely different VISION.EXE, and a different installer floppy format (i.e. you couldn&#39;t install Visi On Calc we have on a VisiOn running on top of CP/M). Supporting a different computer architecture would have been quite an ordeal.</p>
<blockquote>
<p>It did this by providing a kind of non machine specific &#34;virtual machine&#34; (called the Visi Machine) that all applications were written for. (Toasty Tech)</p>
</blockquote>
<blockquote>
<p>What you have above Visi On or VOS itself is an interface we call the Visimachine interface. That is all of the calls that you need as a product designer to use all of the facilities provided by Visi On. This is the virtual machine? For product designers, this is the virtual machine. (&#34;Byte&#34;, 1983/6)</p>
</blockquote>
<p>The term &#34;virtual machine&#34; used by VisiOn developers means something different from what we mean by the words &#34;virtual machine&#34; today. The closest word we use today would be &#34;API&#34;. That&#39;s right, Visi On applications use a cross-platform API. Just like almost any other operating system today. I bet it was a really cool idea back in 1983, though.</p>
<p>By the way, &#34;VisiHost&#34; for IBM PC is VISION.EXE. The &#34;VisiMachine&#34;, which is not a virtual machine, but a set of system libraries and the desktop manager, is also known as &#34;VOS&#34;, &#34;VisiOn Operating System&#34;, &#34;Application Manager&#34; or simply &#34;Services&#34;.</p>
<blockquote>
<p>The virtual machine provided supports virtual memory and concurrent processing. (&#34;The Visi On Operating Environment&#34;, IEEE TCDE Bulletin, September 1983)</p>
</blockquote>
<p>Half-true. Visi On indeed implements virtual memory, but it is a software implementation without any memory protection mechanisms. Nothing but good will stops applications from reading or corrupting memory used by other applications.</p>
<p>The words &#34;concurrent processing&#34; might lead you to believe that VisiOn is a truly multitasking system. But its concurrent processing capabilities are quite limited. It is most definitely not a preemptive multitasking system, because if an application hangs, the whole system hangs. There seem to be <em>some</em> provisions for background data processing, at least for printer spooling. I think a flavour of <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking" rel="nofollow noopener">cooperative multitasking</a> might be possible in VisiOn, but so far I could not find a way to run an application in the background, so maybe it is not multitasking at all!</p>
<blockquote>
<p>[The virtual machine] comprises 12 abstract data types. Each abstract data type responds to messages and provides a specific type of service. (&#34;The Visi On Operating Environment&#34;, IEEE TCDE Bulletin, September 1983)</p>
</blockquote>
<p>Unclear. It seems there are some &#34;messaging&#34; capabilities, but most of the interaction with the OS is still done through regular system calls. So far, I have discovered only messages that create a window, define a menu and request events from the OS. And the messages aren&#39;t really related to the &#34;abstract data types&#34;. Perhaps, the representation of the objects and data types was different on the source code-level?</p>
<p>Also, this statement contradicts what the authors said about the system in an earlier interview.</p>
<blockquote>
<p>Visihost is an object-oriented operating system, and it’s composed of 10 object types... You can establish instances of the objects by just sending messages to them on a Smalltalk message-class type interface. (&#34;Byte&#34;, 6/1983)</p>
</blockquote>
<p>Half-true. The &#34;objects&#34; do not seem to be &#34;objects&#34; in a modern sense. There is no system of attributes, methods and classes. Instead, there are instances of structures that are passed through the API to the OS. Most of the communication with the OS doesn&#39;t happen through messages; it happens through system calls.</p>
<p>In fact, the very same interview confirms this:</p>
<blockquote>
<p>An object in Smalltalk basically is a message, yes, that carries with it something that says what can be done to it. Visi On objects are not that complex. They’re objects... yes, they do have context of what their formatting is, but they aren’t Smalltalk objects.</p>
</blockquote>
<p>Next!</p>
<blockquote>
<p>Activities request services from the Visi-Machine via Visi-Ops or via BITS (Basic Interaction Techniques). The two are distinguished in that a Visi-Op call requires a process ID. (A 16 bit number assigned by Visi-Corp to a given application program). (&#34;Visi On from a Software Developer&#39;s point of view&#34;, 1983)</p>
</blockquote>
<p>Mostly false. It seems VisiCorp itself couldn&#39;t agree on what BITS means; sometimes it is used for low-level system calls for the kernel (&#34;VisiHost&#34;), and sometimes it is used to talk about patterns of the user interface. Also, a process ID is not assigned by Visi-Corp; it is evaluated at run time.</p>
<blockquote>
<p>VOS <em>(note: VisiMachine)</em> is the only activity that actually does direct Visihost calls. All other calls come through VOS itself. (&#34;Byte&#34;, 6/1983)</p>
</blockquote>
<p>Mostly true. On the machine code level, applications can and do call the kernel (&#34;VisiHost&#34;) directly. But all the existing applications only do so to talk to the Services (&#34;VisiMachine&#34;). On the machine code level, nothing stops the application from calling the VisiHost - this is how VisiMachine is getting things done - but presumably this would harm portability.</p>
<blockquote>
<p>Visi On did not, however, include a graphical file manager. (&#34;Visi On&#34;, Wikipedia, November 2025)</p>
</blockquote>
<p>False. There is an application called Archive, which is a part of the &#34;Services&#34;, and it is a bona fide file manager. It does not have icons, though; but there are no icons in any other parts of VisiOn, either.</p>
<blockquote>
<p>The scripts capability is another important aspect of ease of use. It’s a learn mode. It has a window that you can interact with. You can stop that learn mode at any time and tell the system to accept a variable. You open a scripts window and say, “learn.” Then the system prompts you for a name, you type in the name, and that will be the name of a script. (&#34;Byte&#34;, 6/1983)</p>
</blockquote>
<p>Unfortunately, this part of VisiOn seems to be missing from the release. And speaking of missing features, the demo from 1983 also has a <a href="https://guidebookgallery.org/pics/articles/aguidedtourofvision/screenshots.big.jpg" rel="nofollow noopener">mysterious SAVE button</a> that is not present in the final release.</p>
<h4 id="external-sources"><a href="#external-sources" rel="nofollow noopener">#</a>External sources</h4>
<p>Most of the technical documentation about the system available until now comes from the following articles and posts:</p>
<ul>
<li><a href="http://toastytech.com/guis/vision.html" rel="nofollow noopener">Visi On page in the Toastytech&#39;s GUI Gallery</a></li>
<li><a href="https://en.wikipedia.org/wiki/Visi_On" rel="nofollow noopener">Wikipedia page</a></li>
<li><a href="https://guidebookgallery.org/articles/thevisionexperience" rel="nofollow noopener">The Visi On™ experience – From concept to marketplace</a> by George Woodmansee, from Proceedings of INTERACT ’84</li>
<li><a href="https://guidebookgallery.org/articles/aguidedtourofvision" rel="nofollow noopener">A Guided Tour of Visi On</a> Byte, issue 6/1983</li>
<li><a href="https://guidebookgallery.org/articles/visionsinterfacedesign" rel="nofollow noopener">Visi On’s Interface Design</a> Byte, issue 7/1983</li>
<li><a href="https://groups.google.com/g/net.works/c/OWaHfyTmaXM/m/QB5Rk4qb9ioJ" rel="nofollow noopener">Visi On from a Software Developer&#39;s point of view</a> Usenet report written for INFO-IBMPC, 1983</li>
<li><a href="http://sites.computer.org/debull/83SEP-CD.pdf" rel="nofollow noopener">The Visi On Operating Environment</a>, IEEE TCDE Bulletin, September 1983</li>
</ul>
<h2 id="the-fun-begins"><a href="#the-fun-begins" rel="nofollow noopener">#</a>The fun begins!</h2>
<h3 id="initial-investigation"><a href="#initial-investigation" rel="nofollow noopener">#</a>Initial investigation</h3>
<p>Visi On is meant to run on an IBM PC XT with a hard disk. It won&#39;t run properly on an IBM PC AT, and it won&#39;t run in most emulators. The pre-installed unprotected version with an AT patch available on ToastyTech runs in some emulators (86Box and PCEm). There are three software packages that can be installed in VisiOn: Word, Calc and Graph. Trying to install them from any old floppy is not possible due to various copy-protection methods (more on this soon).</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/notaprogdisk.png"/></p>
<p>The installed copy of VisiOn on the hard drive has the executable file <code>VISION.EXE</code>, and a bunch of cryptic files in the <code>VISI_ON</code> folder. Most interesting of those are:</p>
<pre><code>     856 PROGRAMS.VOS -- ??? binary data
  200000 RESERVED.VOS -- resources for the applications? swap?
  777728 SEG00000.VOS -- the actual software installed in the OS?
    3290 SEGMENTS.VOS -- ??? binary data
</code></pre>
<p>The files don&#39;t have an obvious structure. To grasp a feeling of the file, I use my favourite tool: Load Image From Raw Data in GNU IMP.</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/seeking_tutor.png"/></p>
<p>Scrolling through the segments surfaces a high-resolution font file and a garbled startup screen:</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/logo.png"/></p>
<p>Are the installed files encrypted?</p>
<h3 id="checking-the-installation-media"><a href="#checking-the-installation-media" rel="nofollow noopener">#</a>Checking the installation media</h3>
<p>The installation floppies have the files with names matching those on the hard disk, but they have different content. It is obvious that the contents are encrypted by some simple method. For example, here is the contents of the first installation floppy:</p>
<pre><code>    3110 16 Dec  1983 00000009.VOS -- same as the installed version, but encrypted
   10334 16 Dec  1983 00000010.VOS -- same as the installed version, but encrypted
     110 16 Dec  1983 H0000000.VOS -- a binary directory of files
   65536 16 Dec  1983 SEG10002.VOS -- overlay, seemingly encrypted
   65536 16 Dec  1983 SEG10003.VOS -- overlay, -&#34;&#34;-
   65536 16 Dec  1983 SEG10005.VOS -- overlay, -&#34;&#34;-
   44604 16 Dec  1983 VINSTALL.COM -- installer tool
   71680 16 Dec  1983 VISION.EXE   -- the program itself, very clearly it is encrypted in some simple way
</code></pre>
<p>The contents of the files show a repeating pattern. For example, in SEG10003.VOS:</p>
<pre><code>0000fe50  3c 6a 4f 3c 3c 6a 4f 3c  3c 6a 4f 3c 3c 6a 4f 3c  |&lt;jO&lt;&lt;jO&lt;&lt;jO&lt;&lt;jO&lt;|
0000fe60  3c 6a b0 3c c3 6a 4f 3c  3c 6a 4f 3c 3c 6a 4f 3c  |&lt;j.&lt;.jO&lt;&lt;jO&lt;&lt;jO&lt;|
0000fe70  3c 6a 4f 3c 3c 6a 4f 3c  3c 6a 4f 3c 3c 6a 4f 3c  |&lt;jO&lt;&lt;jO&lt;&lt;jO&lt;&lt;jO&lt;|
</code></pre>
<p>Such a repeating pattern is indicative of an <a href="https://en.wikipedia.org/wiki/XOR_cipher" rel="nofollow noopener">encryption with XOR</a>. This is a very poor encryption technique; not only can the encryption key be guessed easily, but a long sequence of zero-bytes will expose the key as it is.</p>
<h3 id="tweaking-the-installation-media"><a href="#tweaking-the-installation-media" rel="nofollow noopener">#</a>Tweaking the installation media</h3>
<p>The installation floppies are not only encrypted, but also copy-protected with &#34;out-of-bounds&#34; sectors. They require special emulation methods, but thankfully those methods are well described in 86Box and HxC floppy tool documentation.</p>
<p>With a simple encryption and decryption tool, I managed to change the text in the Tutorial app shipped with the operating system and package it back to the (still copy-protected) floppy.</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/tut_after.png"/></p>
<h3 id="figuring-out-the-floppy-file-system"><a href="#figuring-out-the-floppy-file-system" rel="nofollow noopener">#</a>Figuring out the floppy file system</h3>
<p>A floppy with a Visi On program has dozens of files named <code>00001000.VOS</code>, <code>00001234.VOS</code> and so on. Which files are mandatory, and what is in them? Lots of trial and error (&#34;let&#39;s delete this file, let&#39;s put back this file&#34;) shows that a floppy must have the following files:</p>
<ul>
<li><code>00000000.VOS</code> - simply 12 zeroes</li>
<li><code>00001000.VOS</code> - the description of the floppy (disk label and the list of programs on it), encrypted</li>
<li><code>00001001.VOS</code> - a copy-protection mechanism, twice-encrypted</li>
<li>an installation script referenced from <code>00001000.VOS</code>,</li>
<li>components of the program referenced from the installation script</li>
</ul>
<p>The patterns in the unencrypted files can be observed by simply looking at the files. For example, this is a fragment of <code>00001000.VOS</code> from the Visi On Calc package:</p>
<pre><code>00000080  16 17 20 43 6f 6e 76 65  72 74 20 74 6f 20 43 61  |.. Convert to Ca|
00000090  6c 63 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |lc..............|
000000a0  31 2e 30 00 00 00 00 00  00 00 00 00 01 00 41 04  |1.0...........A.|
000000b0  00 00 00 00 00 00 00 00                           |........|
</code></pre>
<p>Note: IBM PC is a little-endian architecture. The byte sequence <code>41 04</code> should be read as <code>0x0441</code>, or 1089 in decimal. Sure enough, <code>00001089.VOS</code> stores the installation script for the program, referencing other files on the floppy disk:</p>
<pre><code>00000000  a7 43 16 17 20 43 6f 6e  76 65 72 74 20 74 6f 20  |.C.. Convert to | &lt;- magic number + logo + name
00000010  43 61 6c 63 00 00 00 00  00 00 00 00 00 00 00 00  |Calc............|
00000020  00 00 31 2e 30 00 00 00  00 00 00 00 00 00 01 00  |..1.0...........| &lt;- version
00000030  03 00 02 00 00 00 00 00  00 00 00 00 00 00 0a 00  |................|
00000040  00 00 01 00 42 04 01 00  02 00 43 04 01 00 01 00  |....B.....C.....| &lt;- 0x442 - first file to install 
00000050  44 04 01 00 02 00 45 04  01 00 02 00 46 04 01 00  |D.....E.....F...|
00000060  02 00 47 04 01 00 02 00  48 04 01 00 01 00 49 04  |..G.....H.....I.|
00000070  01 00 01 00 4a 04 01 00  01 00 4b 04 01 00 01 00  |....J.....K.....|
00000080  00 00 02 00 4c 04                                 |....L.|           &lt;- .... 0x44c - last file to install
</code></pre>
<h3 id="unencrypted-installer"><a href="#unencrypted-installer" rel="nofollow noopener">#</a>Unencrypted installer</h3>
<p>A big obstacle in developing applications is the copy-protection mechanism in <code>00001001.VOS</code>. The file itself is lightly encrypted with XOR, and then heavily encrypted with XOR once again. Decrypting it and loading it in Ghidra allowed me to understand (generally speaking) that this little tool is an x86 program with a custom header and a single entry point. This entry point is called by the installer to check that the floppy is copy-protected and to decrypt the contents of the floppy.</p>
<p>Atsuko eventually <a href="https://git.sr.ht/~nkali/vision-homebrew-test-app/tree/v8/item/tools/copyprotection.asm" rel="nofollow noopener">rewrote</a> the copy-protection binary, to skip the encryption and floppy checks. This version of <code>00001001.VOS</code> is very useful even for installing VisiCorp&#39;s programs, as it allows using regular floppy disks, or to tweak the program sources before the installation.</p>
<p>Fun note: the XOR encryption key on software disks is stored in plain text at the beginning of every <code>00001001.VOS</code> file. Such a glaring oversight!</p>
<h3 id="installer-script-linking-script"><a href="#installer-script-linking-script" rel="nofollow noopener">#</a>Installer script; linking script</h3>
<p>Checking unencrypted files (looking closely at their contents in a hex editor) revealed the internal structure of a program package:</p>
<ul>
<li>An installer script: it describes which VOS files are needed by the program,</li>
<li>One or more &#34;code segment&#34; files: these mostly contain <a href="https://en.wikipedia.org/wiki/Position-independent_code" rel="nofollow noopener">position-independent machine code</a> for the Intel 8086 CPU (defeating the theory of VisiOn implementing a virtual machine),</li>
<li>One &#34;data segment&#34; file: it stores the data needed by the program at all times,</li>
<li>One linking script, which is somewhat similar to a header in EXE, DLL or ELF files: it points to a list of all &#34;entry points&#34; in the &#34;code segment&#34; files, and tells the OS where the program&#39;s  <code>main()</code> function is, and</li>
<li>One mini file system with a collection of various files used by the program.</li>
</ul>
<p>The type of VOS file is determined by two independent factors:</p>
<ul>
<li>The installer script marks the header file and the mini file system in a special way,</li>
<li>&#34;Data&#34; and &#34;code&#34; segment files have an 8-byte header (four 16-bit numbers: <a href="https://en.wikipedia.org/wiki/File_format#Magic_number" rel="nofollow noopener">magic</a>, type of the segment, number of the segment, the length of the segment in bytes)</li>
</ul>
<h2 id="running-under-the-debugger"><a href="#running-under-the-debugger" rel="nofollow noopener">#</a>Running under the debugger</h2>
<p>Operating system development needs a good debugger. Even the history of Windows hints that <a href="https://www.ninakalinina.com/notes/win2/" rel="nofollow noopener">a good debugger is essential for building a trillion-dollar software empire</a>. And, as you can imagine, Visi On doesn&#39;t run under debuggers, so an IBM PC emulator with a built-in debugger is a must.</p>
<h3 id="bochs"><a href="#bochs" rel="nofollow noopener">#</a>Bochs</h3>
<p>There are multiple debugging emulators: Qemu, MAME, Bochs, DosBox and MartyPC. None could run Visi On. Among these, Bochs was my primary target, as it can emulate a Mouse Systems mouse - the only mouse type supported by Visi On. Thanks to built-in debugging features, I produced a simple patch that allowed Visi On to boot in Bochs and Qemu. The patch simply skips a few mouse-related checks:</p>
<pre><code>--- visionat.exe.dmp
+++ viatmice.exe.dmp
@@ -2534,4 +2534,4 @@
 0000a010  e8 7a 00 eb 49 b0 83 e8  47 00 e8 81 00 8b 1e 80  |.z..I...G.......|
-0000a020  0b 8d 57 05 ec a8 01 74  f8 8d 57 00 ec 24 f8 3c  |..W....t..W..$.&lt;|
-0000a030  80 75 ee e8 78 00 e8 54  00 eb 23 c7 06 7e 0b ff  |.u..x..T..#..~..|
+0000a020  0b 8d 57 05 ec a8 01 90  90 8d 57 00 ec 24 f8 3c  |..W.......W..$.&lt;|
+0000a030  80 90 90 e8 78 00 e8 54  00 eb 23 c7 06 7e 0b ff  |....x..T..#..~..|
 0000a040  ff 06 b0 33 b4 35 cd 21  8c c0 07 0b c3 bb 7a 06  |...3.5.!......z.|
</code></pre>
<p>The Bochs interface rhymes visually with VisiOn, being monochrome and pixelated.
<img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/bochs.png"/></p>
<h3 id="mouse-driver"><a href="#mouse-driver" rel="nofollow noopener">#</a>Mouse driver</h3>
<p>If you want to reverse engineer a multi-tasking graphical operating system, the first thing you probably should figure out is its mouse driver. When you start an application, you cannot know where it will be loaded into the computer&#39;s memory until it is started. And when it is started, it is already too late to look at the application&#39;s initialisation. We need to stop the operating system the very moment we ask to start the program. In other words, the moment we release the mouse button after the double click.</p>
<p>Visi On uses serial mice connected over the COM port. Looking at the emulator events, I can see that the COM port is configured to be <a href="https://en.wikipedia.org/wiki/Interrupt" rel="nofollow noopener">interrupt</a>-driven. On an IBM PC, the handler for COM1 port interrupts is known as IRQ4/INT 0x0c. In other words, the address of the mouse driver is recorded in the interrupt table of the computer - it is set to <code>1a68:0000</code>, which, by the way, is exactly where it is in VISION.EXE.</p>
<p>In Bochs, you cannot set up a breakpoint (sometimes known as <a href="https://en.wikipedia.org/wiki/Breakpoint" rel="nofollow noopener">&#34;pause&#34;</a>) at the interrupt address, but you can set up a breakpoint for the next instruction. When I figured this out, it was easy to set a breakpoint at the mouse driver and understand how the mouse driver works.</p>
<p>Now I could simulate mouse clicking in the following way. RAM address <code>0x1f21b</code> holds the mouse button status. Writing &#34;1&#34; there makes the OS think there was a right button click. Writing &#34;2&#34; and then &#34;0&#34; works as &#34;press and release the left mouse button&#34;. With this, I managed to pinpoint the moment the OS starts an applications.</p>
<h2 id="reverse-engineering-pains"><a href="#reverse-engineering-pains" rel="nofollow noopener">#</a>Reverse-engineering pains</h2>
<p>A tool that can convert machine code back to something human-readable is called a disassembler. There are many options, but I went with NSA&#39;s Ghidra as it is the tool I&#39;ve used in the past to <a href="https://tech.lgbt/@nina_kali_nina/109700724534323810" rel="nofollow noopener">reverse-engineer the Sumikko Gurashi computer</a>.</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/note/ghidra.png"/></p>
<p>Normally, disassembly is a straightforward process. Truth to be told, I expected the whole reverse engineering process to take a couple of weekends. If only life was so simple...</p>
<h3 id="visi-on-was-compiled-by-a-vintage-c-compiler"><a href="#visi-on-was-compiled-by-a-vintage-c-compiler" rel="nofollow noopener">#</a>Visi On was compiled by a vintage C compiler</h3>
<p>Here is a bit of the disassembly of now-open-source contemporary text editor EDLIN from Microsoft, as seen by Ghidra:</p>
<pre><code>       0000:0119 50              PUSH       AX
       0000:011a b4 30           MOV        AH,0x30     ; syscall 0x30
       0000:011c cd 21           INT        0x21        ; an MS-DOS call
       0000:011e 3c 02           CMP        AL,0x2
       0000:0120 7d 05           JGE        LAB_0000_0127
       0000:0122 ba 8a 10        MOV        DX,0x108a   ; pointer to an error message
       0000:0125 eb e7           JMP        LAB_0000_010e
</code></pre>
<p>Here is the corresponding source code:</p>
<pre><code>;----- Check Version Number --------------------------------------------;
        push    ax
        mov     ah,Get_Version
        int     21h
        cmp     al,2
        jae     vers_ok                         ; version &gt;= 2, enter editor
        mov     dx,offset dg:bad_vers_err
        jmp     short errj
;-----------------------------------------------------------------------;
</code></pre>
<p>The disassembly basically matches the source code and thus is easy to understand.</p>
<p>Compare with the disassembly coming from VisiOn:</p>
<pre><code>       64c5:0c55 c7 06 16        MOV        word ptr [0x16],0x0
                 00 00 00
       64c5:0c5b 8b 1e 16 00     MOV        BX,word ptr [0x16]
       64c5:0c5f 89 1e 18 00     MOV        word ptr [0x18],BX
       64c5:0c63 8b 0e 18 00     MOV        CX,word ptr [0x18]
       64c5:0c67 89 0e 9c 15     MOV        word ptr [0x159c],CX
       64c5:0c6b 8b 16 9c 15     MOV        DX,word ptr [0x159c]
       64c5:0c6f 89 16 de 09     MOV        word ptr [0x9de],DX
       64c5:0c73 83 ec 02        SUB        SP,0x2
       64c5:0c76 c7 46 d6        MOV        word ptr [BP + -0x2a],0x1
                 01 00
       64c5:0c7b 83 ec 02        SUB        SP,0x2
       64c5:0c7e c7 46 d4        MOV        word ptr [BP + -0x2c],0x1742
                 42 17
       64c5:0c83 e8 9e 00        CALL       define_window
</code></pre>
<p>Can you follow the logic?</p>
<pre><code>var_0x16 = 0
BX = var_0x16
var_0x18 = BX
CX = var_0x18
var_0x159c = CX
DX = var_0x159c
var_0x9de = DX
**whack the stack!**
BP[-0x2a] = 1
**whack the stack!**
BP[-0x2c] = 0x1742
CALL       define_window
</code></pre>
<p>Do you also feel your blood boiling from seeing the &#34;hot potato&#34; variable definition? It should have been</p>
<pre><code>var_0x16 = 0
var_0x18 = 0
var_0x9de = 0
var_0x159c = 0
BX = 0
CX = 0
DX = 0
CALL define_window(0x1742, 1)
</code></pre>
<h3 id="bp-stack-frame"><a href="#bp-stack-frame" rel="nofollow noopener">#</a>BP stack frame</h3>
<p>The comment &#34;whack the stack!&#34; above is quite representative of what is happening in the code.</p>
<p>Most computers nowadays have a <a href="https://en.wikipedia.org/wiki/Stack-based_memory_allocation" rel="nofollow noopener">stack</a>. If you don&#39;t know what a &#34;stack&#34; is, imagine: you work as a clerk, and your assignments come in the form of sheets of paper with tasks. You put new sheets with tasks on top of the sheets you already have. When you need to process the next task, you usually take the topmost sheet. You might feel bad for all the old tasks at the bottom of the stack, but it is the easiest way to keep track of things.</p>
<p>Here is where &#34;stack frames&#34; come. Now, imagine that you have a coworker obsessed with efficiency. They think that some old tasks should be done before newer tasks, and some new tasks should be done after old tasks. To do so, they take a chunk of the sheets from the stack, rearrange them as they see fit, and put them back in. Sometimes they even grab multiple unrelated chunks of the stack at once. A chunk of a stack is a &#34;stack frame&#34;.</p>
<p>Using stack frames simplifies code compilation for subroutines, because a subroutine can assume that it can do whatever it wants with its stack frame, treating it like its own private memory allocated on the global stack. &#34;Forgetting&#34; the data from the stack frame is as simple as moving the stack pointer.</p>
<p>This technique used to be common on x86-based computers some 40 years ago. Ghidra doesn&#39;t support it at all. Bochs doesn&#39;t care about the BP stack and can only show you the SP stack. VisiOn almost never uses the SP stack directly; most of the applications are working with the BP stack. That doesn&#39;t mean that the SP isn&#39;t changed when the values on the BP stack are changed; quite the opposite.</p>
<p>To make things more unusual, the BP register is used differently from the modern C compilers that support the BP stack frame. Instead of only relying on the local stack frame for local variables and arguments, the code also uses the BP register (assumed to be the stack frame point of reference) to put data on top of the real stack (in roughly 2/3 of the cases; 1/3 still uses pushes/pops and SP). Local variables, structures passed to VisiMachine through pointers (and sometimes used after &#34;free&#34;), variables prepared to be arguments for a function call, even return values from function calls, all appear as if they were shuffled across the BP stack frame and the stack itself.</p>
<p>If that doesn&#39;t sound fun enough, a copy of registers is preserved in the stack frame <em>sometimes</em>, depending on whether a function call was cross-segment or from the local segment (more on that later). The code snippet that preserves the registers is always <code>CALL</code>ed, but it never returns. An extra address <em>sometimes</em> left on the stack on the return from the function? Nothing a simple stack manipulation can&#39;t fix!</p>
<p>An abundance of commands that do nothing with the stack (<code>add sp, 0 ; sub sp, 0</code>) ties all of this back to the vintage C compiler. I believe this machine code is a result of using an immature C compiler, and has nothing to do with the Visi On&#39;s API. And, according to some reports, Visi On used a now-long-lost Lantech C, the first cross-compiler for Intel x86. It is probably safe to assume that Visi On compiled with a different compiler or for other platforms would have been easier to disassemble.</p>
<h3 id="unusual-cross-segment-calls-and-magic-long-pointers"><a href="#unusual-cross-segment-calls-and-magic-long-pointers" rel="nofollow noopener">#</a>Unusual cross-segment calls and &#34;magic&#34; long pointers</h3>
<h4 id="segment-model"><a href="#segment-model" rel="nofollow noopener">#</a>Segment model</h4>
<p>The IBM PC, VisiOn target computer, is built around the Intel 8088 processor. A remarkable thing about this processor is that it uses the <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation" rel="nofollow noopener">segment memory model</a>. In a nutshell, at any given moment in time, the program has access to no more than four fragments of the computer&#39;s RAM, each 64 kilobytes in size: the code segment, the data segment, the stack segment, and the &#34;extra&#34; segment. This memory organisation simplifies porting programs from 8-bit computers, and in theory allows a straightforward implementation of multi-tasking for small programs. If you have 640 kilobytes of RAM, and your program is configured to use a single segment for all four segments (CS, DS, SS and ES), you could easily load 10 programs at once.</p>
<p>But, as it happens, segments are quite limiting. A single data segment can store about 35 pages of &#34;plain text&#34; in a <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" rel="nofollow noopener">common 8-bit encoding</a>. If you want to store a long document in the computer&#39;s RAM (a novel or a thesis), your program will need to switch between multiple data segments.</p>
<p>By the way, a memory reference to data within a single segment is called a &#34;short pointer&#34;. A memory reference to a different segment is called a &#34;far segment&#34;. To unambiguously identify a region in memory, you need a &#34;long pointer&#34; consisting of a segment and offset pair.</p>
<p>Things are much worse if a program doesn&#39;t fit in a single code segment. For programs running under DOS, it is usually not an issue: the program can assume it has a monopoly over the computer&#39;s RAM and just use &#34;CALL FAR&#34; and &#34;JMP FAR&#34; to change the current code segment. Even so, the operating system might load the program into any available memory segment. If the program uses &#34;far&#34; calls or pointers, the operating system must perform a <a href="https://en.wikipedia.org/wiki/Relocation_(computing)" rel="nofollow noopener">&#34;relocation&#34;</a>. This is how things were done in DOS and early Windows versions.</p>
<p>VisiOn&#39;s approach to memory management is different from DOS. Each code segment is <a href="https://en.wikipedia.org/wiki/Position-independent_code" rel="nofollow noopener">position-independent</a>; it cannot use far CALLs or long pointers. Large programs are split into multiple code segments. When a program is executing a code segment 1 and needs to call a function from a code segment 2, for example, it must do so through the operating system. The benefit of this approach is a software implementation of &#34;virtual memory&#34;. If a program is, for example, 2 megabytes large, and the computer only has 512 kB of RAM, the operating system can only keep in RAM the segments of the program that are being executed right now. When a program requests a segment not in the RAM, the OS can load it from the hard drive, in a form of <a href="https://en.wikipedia.org/wiki/Virtual_memory#Address_space_swapping" rel="nofollow noopener">swapping</a>.</p>
<p>By the way, most of the time the ES segment is set to the kernel/OS/VisiHost data segment, and SS is set to DS (the current applications&#39; data segment).</p>
<h4 id="magic-pointers"><a href="#magic-pointers" rel="nofollow noopener">#</a>&#34;Magic&#34; pointers</h4>
<p>Even so, VisiOn could have been &#34;normal&#34; about their implementation of virtual memory. A <em>far</em> call might have looked like this: <code>call_segment(segment_number, function_address)</code>. Instead, it looks like this: <code>call(). Magic!</code></p>
<p>This is what cross-segment calls look like in Ghidra (and it would look exactly the same in any other disassembler):</p>
<pre><code>    5e32:009b cd c1       INT 0xc1                    ; Call operating system entry point 0xc1
    5e32:009d 28 08       SUB byte ptr [BX + SI],CL   ; ??? Change a random memory byte ???
</code></pre>
<p>The disassembler assumes that bytes <code>0x28 0x08</code> encode a command. It is a normal thing to assume; this is how the Intel x86 processor normally works. But in this case, it is not a command, it is a 16-bit number: <code>0x0828</code>. The OS tweaks the return address from the INT 0xc1 handler so these two bytes are skipped by the processor.</p>
<p>I call this kind of number &#34;magic pointers&#34;, because a long pointer normally must be two 16-bit numbers: a segment and an offset. But in VisiOn, a single 16-bit number encodes both. This is implemented in a really clever way. Remember the &#34;entry points&#34; table I mentioned?</p>
<p>The &#34;entry points&#34; table has pairs of 16-bit numbers: segment and offset. For example, if a function is stored in a segment file 0x0002 at the offset 0x1234, the table will have both numbers written down:</p>
<pre><code>&lt;entry_points_table:0&gt; 0x1234 0x0002
</code></pre>
<p>Now, what is the &#34;magic pointer&#34; then? It is a pointer (or offset) to the address of a row in this table, in bytes, relative to the beginning of the code segment where the entry points table is stored. Baaam!</p>
<p>The code above, <code>INT 0xc1 ; 0x0828</code> basically tells the OS:</p>
<ol>
<li>Load the code segment with the entry points table - we told you about it when we installed the program</li>
<li>Go to the position 0x0828 in this code segment and read two numbers from there: <code>offset</code> and <code>segment</code></li>
<li>Do the <em>far</em> call to a function at <code>segment:offset</code></li>
<li>When the function is finished, return everything the way it was before</li>
</ol>
<p>Moreover, the <code>segment</code> references in the entry points table are dynamically refreshed. The operating system keeps track of the physical RAM address where each segment is loaded.</p>
<h4 id="code-segment-reallocations"><a href="#code-segment-reallocations" rel="nofollow noopener">#</a>Code segment reallocations</h4>
<p>VisiOn is unusually aggressive at memory management compared to its contemporaries; it keeps swapping code segments in and out. This is very troublesome for debugging.</p>
<p>Imagine that the program you are debugging, currently loaded to the computer&#39;s RAM at segment <code>0x5e32</code>, makes a cross-segment call at the offset <code>0x9b</code> (like in the code snippet in the previous chapter). Let&#39;s say you&#39;re not interested in what is happening in this call, and you want to just &#34;step over&#34; the function call. You expect that when the <em>far</em> call is completed, your program will continue starting from the address <code>0x5e32:0x09f</code> (the next command after the &#34;magic pointer&#34;). Oh, how naive!</p>
<p>The operating system can (and often does) decide to swap your program out of RAM during the <em>far</em> call. When the OS swaps your program back in, it will put it in the next available code segment, for example, <code>0x4c4b</code>. The execution will continue not from <code>0x5e3d:0x09f</code> but from <code>0x4c4b:0x09f</code>. Your breakpoint at <code>0x5e32:0x09f</code> won&#39;t activate; the debugger&#39;s &#34;step over&#34; function simply doesn&#39;t work.</p>
<h4 id="note-the-only-thing-the-application-absolutely-emmustem-do-is-embounce-off-the-trampolineem"><a href="#note-the-only-thing-the-application-absolutely-emmustem-do-is-embounce-off-the-trampolineem" rel="nofollow noopener">#</a>Note: the only thing the application absolutely <em>must</em> do is <em>bounce off the trampoline</em></h4>
<p>All the code segments in VisiOn have a command <code>jmp [es:0x0]</code> at the address <code>0x9</code>.</p>
<p>When an application&#39;s function is called (be it <code>main</code>, an event handler, or a &#34;magic pointer&#34; call), the OS pushes <code>0x9</code> on the stack as the <code>return address</code> before <code>jmp</code> to the function&#39;s entry point.</p>
<p>When a function finishes its work and executes a <code>ret</code> command, the CPU gets the return address from the stack (<code>0x9</code>) and executes the command <code>jmp [es:0x0]</code>. This is a <em>far</em> jump, but where does it jump to? The answer is: the CPU reads a long pointer from <code>es:0</code> (the beginning of the OS kernel data segment); then jumps to it. The code at this point will decide what is the next <code>jmp</code> destination. This technique is called &#34;jumping into a <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)" rel="nofollow noopener">trampoline</a>&#34;.</p>
<p>If you&#39;re writing your program in assembly (and you shouldn&#39;t be), then no one stops you from replacing <code>ret</code> at the end of your functions with:</p>
<pre><code>add SP, 2
jmp [es:0x0]
</code></pre>
<p>You can avoid &#34;returning to <code>0x9</code>&#34;, but you still must jump into the trampoline. Fun!</p>
<h2 id="talking-to-visihost"><a href="#talking-to-visihost" rel="nofollow noopener">#</a>Talking to VisiHost</h2>
<p>A major part of the reverse-engineering effort was focused on trying to understand the internals of two smallest applications available for the OS, the Tutorial app (&#34;tutor&#34;) and the Convert To Calc app (&#34;cvtcalc&#34;). The Tutorial app is 6.3 kilobytes of machine code, but that&#39;s actually quite a lot: 3525 lines (about 80 A4 sheets) of disassembly.</p>
<h3 id="leveraging-magic-breakpoints"><a href="#leveraging-magic-breakpoints" rel="nofollow noopener">#</a>Leveraging magic breakpoints</h3>
<p>One thing that really simplified the debugging was adding Bochs&#39; &#34;magic breakpoints&#34; to the Tutor and CVTCalc apps. Magic breakpoints work like this: when the emulator encounters a useless instruction - <code>xchg bx, bx</code> - it treats it as a breakpoint. These breakpoints happen as if by &#34;magic&#34;, without any need to simulate mouse click events or figure out segment relocation between the calls to the OS. The only downside: this command needs to be &#34;squeezed in&#34; into the existing machine code. Thankfully, some of the machine instructions in the Tutor app are <code>NOP</code> (&#34;do nothing&#34;), so I replaced a few of those with <code>xchg bx, bx</code>.</p>
<h3 id="system-calls"><a href="#system-calls" rel="nofollow noopener">#</a>System calls</h3>
<p>Most operating systems provide &#34;system calls&#34;, a set of library methods that can manage disks, RAM, and so on. Graphical operating systems often provide calls for creating windows, and even handling the mouse and keyboard. Visi On is no exception.</p>
<p>A standard way to make a system call on an IBM PC-compatible is to call a <a href="https://en.wikipedia.org/wiki/Interrupt#Software_interrupts" rel="nofollow noopener">software interrupt</a>. The operating system tells the CPU that it can handle a certain software interrupt; a program uses this interrupt to communicate with the OS; the OS can return control to the program when the system call is finished. This is how system calls work in MS-DOS, for example:</p>
<pre><code>;; Print a character
mov DL, &#39;!&#39;     ; the character to print in the DL register
mov AH, 2       ; function number 2 in the AH register
int 0x21        ; MS-DOS system call
</code></pre>
<p>VisiOn registers multiple interrupt handlers; among those, three are commonly used: <code>0xc0</code>, <code>0xc1</code> and <code>0xc2</code>. The interrupts <code>0xc1</code> and <code>0xc2</code> are used for direct and indirect &#34;magic pointer&#34; function calls. <code>0xc0</code> is the system call interrupt; it is the interface to the VisiHost.</p>
<p>Designed with portability in mind, VisiHost accepts arguments to the system calls through the stack: different processors might have different registers, but VisiOn most definitely needs to have a stack to work. A VisiOn system call looks like this:</p>
<pre><code>;; Get the Segment ID for own data segment
push process_id         ; put &#34;process_id&#34; variable on the stack
push 0x219              ; push the syscall number and the size of the arguments in bytes on the stack
int 0xc0                ; call VisiHost
</code></pre>
<p>I originally thought that <code>0x219</code> is the number of the syscall, but very quickly discovered that there are only ~0x70 syscall handlers, so the actual syscall number is simply <code>0x19</code>. It took a bit of trial, error, reading the disassembly of the kernel, and stepping through a call to understand that <code>0x02</code> is the number of the arguments passed to the syscall times two.</p>
<p>The reason for that is simple: the application&#39;s stack is stored in its own data segment. When the operating system takes control, it uses its own data segment with its own stack. To pass the parameters between the stacks, the OS copies all the syscall arguments from one stack to the other.</p>
<h3 id="get_process_id-and-get_segment_id"><a href="#get_process_id-and-get_segment_id" rel="nofollow noopener">#</a>Get_Process_ID and Get_Segment_ID</h3>
<p>There aren&#39;t that many system calls that a regular application makes. Among those, the first two calls an application makes are <code>0x17</code> and <code>0x19</code>.</p>
<p><code>0x17</code> returns the process ID for the current application.</p>
<p><code>0x19</code> takes a process ID as an argument and returns the data segment ID for the application. A VisiOn application absolutely must know its own Data Segment ID. The Segment ID is passed to all the syscalls; for example, when the application asks the OS to print a string on the screen, it needs to pass around not only the offset to the string relative to a data segment, but also the Segment ID for this data segment.</p>
<p>These two are followed by a system call <code>0x18</code> - &#34;get Application Manager data&#34; - which I will describe later.</p>
<h3 id="messages"><a href="#messages" rel="nofollow noopener">#</a>Messages</h3>
<p>A bare-bones application for VisiOn must:</p>
<ul>
<li>create a window,</li>
<li>then create a menu,</li>
<li>then wait for a menu click,</li>
<li>and then destroy the menu and the window.</li>
</ul>
<p>All of this is done with system calls <code>0x21</code> and <code>0x22</code>. How did I find this out? There was no silver bullet, I&#39;ve been running the same code in the debugger over and over again, tweaking some parameters, commenting out some bits of code here and there, and eventually asking Atsuko to write a small assembly program following the specifications I provided to confirm the discoveries experimentally.</p>
<p>Originally, I thought that <code>0x21</code> was something like &#34;create windows &amp; menus&#34; and <code>0x22</code> was &#34;redraw the window and maybe wait for an event&#34;. But something didn&#39;t feel right. <code>0x21</code> is always called with a different structure as the argument: sometimes it defines a window, sometimes it defines a menu and the event handlers, and sometimes it destroys all the created UI elements. <code>0x22</code> always returns a value, and sometimes it makes the application go into the background.</p>
<p>So, my conclusion is: most likely, <code>0x21</code> is &#34;send the message&#34; and <code>0x22</code> is &#34;receive the message (maybe wait for one)&#34;. I don&#39;t have many examples of &#34;messages&#34;, but I managed to partially describe &#34;create the window&#34; and &#34;wait for the events&#34; structures.</p>
<p>These messages resemble Smalltalk, but they are relatively rare compared to other types of system calls. It makes me think that at some point VisiOn left behind its Smalltalk roots, and the &#34;messages&#34; subsystem might be just a remnant of the original design.</p>
<h4 id="fake-stack"><a href="#fake-stack" rel="nofollow noopener">#</a>Fake stack</h4>
<p>&#34;Create the menu and wait for an event&#34; function does something wacky. The structure we pass to the syscall <code>0x21</code> accepts a pointer as one of the arguments. In the original VisiOn apps, it points to a structure created on a stack. For the sake of simplicity, we placed this structure in the data segment. Things worked until we added on-screen buttons; clicking a button would crash the system. Why? The operating system used this pointer to access data from both after <em>and</em> before the pointer. In other words, this is a pointer to the middle of a structure!</p>
<p>Why would anyone do that? No idea. This detail of the implementation likely didn&#39;t matter for programs written in Visi C, and most developers probably didn&#39;t even know about it.</p>
<h2 id="reaching-out-to-visimachine"><a href="#reaching-out-to-visimachine" rel="nofollow noopener">#</a>Reaching out to VisiMachine</h2>
<p>The articles in the BYTE magazine tell us that if an application wants to draw on the screen, print a text, read a file from the disk, or define an on-screen button, it needs to do so through VisiMachine. Indeed, while VisiHost system calls can do a great many things, the applications I tried to reverse-engineer never called them directly. For example, there are syscalls <code>0x34</code> and <code>0x35</code> for drawing a bitmap on the screen and copying a bitmap from the screen, but these syscalls are only ever called from the Services app. Moreover, they&#39;re not &#34;window-aware&#34;: with these calls, the application can draw on the screen outside of its own window!</p>
<p>So, if we want to be good citizens, we need to follow the standard call convention and reach out to the VisiMachine. But how?!</p>
<h3 id="syscall-0x1e"><a href="#syscall-0x1e" rel="nofollow noopener">#</a>Syscall 0x1e</h3>
<p>The most common system call in any application is <code>0x1e</code>. This call seemingly does almost anything, including but not limited to: reading data from files, printing text on the screen and creating on-screen buttons. Sounds like a &#34;VisiOp&#34; (VisiMachine) call, doesn&#39;t it?</p>
<p>Figuring out the VisiOp calls was really challenging. The number of arguments for the call is always different, and even the arguments themselves are different between different runs of the same program. This call is intense!</p>
<p>When a program <em>starts</em>, it asks the OS for the Application Manager data segment using syscall <code>0x18</code>. From this segment, the program copies into its own segment:</p>
<ul>
<li>12 &#34;virtual device&#34; IDs unique to the copy of the application,</li>
<li>1 long (segment+offset) pointer to Application Manager,</li>
<li>2 more &#34;system&#34; IDs, and then</li>
<li>170 more &#34;function&#34; IDs.</li>
</ul>
<p>If you&#39;re just looking at disassembly, this operation is simply copying 372 bytes (12 + 1 * 2 + 2 + 170 words) from one segment to the other.</p>
<p>When a program needs to call a VisiOp, the syscall <code>0x1e</code> receives:</p>
<ul>
<li>total number of arguments,</li>
<li>one of the &#34;system&#34; IDs,</li>
<li>one of the &#34;function&#34; IDs,</li>
<li>number of arguments minus 2 (e.g. not counting two IDs above)</li>
<li>one of the &#34;virtual device&#34; IDs,</li>
<li>one or more extra arguments, some of which might be the application&#39;s segment ID.</li>
</ul>
<p>Additionally, the application sets a flag at the <code>segment+offset</code> of the Application Manager before this call, and clears it after the call.</p>
<h3 id="system-ids-and-virtual-device-ids"><a href="#system-ids-and-virtual-device-ids" rel="nofollow noopener">#</a>System IDs and Virtual Device IDs</h3>
<p>My understanding of the Virtual Device IDs is limited and is based on the actions taken by the OS.</p>
<pre><code>// VT = Virtual Terminal
#define DEVICE_VT 0x3
#define DEVICE_MEM 0x4
#define DEVICE_MENU 0xc

#define SYS_MESSAGE 0x0
#define SYS_CALL 0x1
</code></pre>
<p>The &#34;Virtual Device&#34; IDs are sort of similar to the list of &#34;data types&#34; from the article &#34;The Visi On Operating Environment&#34;:</p>
<pre><code>PROGRAM 
PROCESS 
MEMORY SEGMENT
PORT 
RASTER
DEVICE
FILE
BACKGROUND 
FONT
MOUSE
SOUNDMAKER 
KEYBOARD
</code></pre>
<p>But it couldn&#39;t be the same thing! Both &#34;font management&#34; (FONT) and &#34;define clickable area&#34; (MOUSE) are managed through the <code>DEVICE_VT</code>. Did the specification for the system change between this article and the OS release? No idea.</p>
<h3 id="function-ids"><a href="#function-ids" rel="nofollow noopener">#</a>Function IDs</h3>
<p>Things get really interesting and confusing if you consider that the <code>0x1e</code> system call requires a &#34;function&#34; ID to operate. For example, if you want to load a font, you need to look up the &#34;function&#34; ID <code>0x18</code>, and pass it along with the <code>DEVICE_VT</code>.</p>
<p>As you can imagine, it is impossible to load a font in a <code>DEVICE_MEM</code>, and it is impossible to read a file from <code>DEVICE_VT</code>. What is the point of using both device ID and function ID, then? I don&#39;t know. But considering that we pass the <em>number of arguments</em> twice, perhaps, there is no meaning to it. Perhaps, VisiOps were implemented by <a href="https://en.wikipedia.org/wiki/Conway%27s_law" rel="nofollow noopener">two different teams</a> who couldn&#39;t agree on how to pass the arguments between the VisiHost and the VisiMachine.</p>
<p>The true nature of &#34;function&#34; IDs is &#34;magic&#34; pointers. The &#34;function ID&#34; for any VisiOp is simply an offset to a function in the &#34;magic&#34; pointers list <em>for the Application Manager</em>. There are over 600 &#34;magic&#34; pointers in the Application Manager (you can find the list in <code>SEG10003.VOS</code> at offset <code>0xa600</code>), but only 170 of them are used as VisiOps.</p>
<h3 id="direct-access-to-the-memory-manager"><a href="#direct-access-to-the-memory-manager" rel="nofollow noopener">#</a>Direct access to the memory manager</h3>
<p>While VisiOn has a VisiOp that can copy data between two segments by their Segment IDs, every now and then it can be useful to resolve the physical address for a given memory segment. This is most definitely not a cross-platform approach, but VisiOn applications use it when they want to peek inside the Application Manager&#39;s data segment.</p>
<p>The memory access dance is done this way:</p>
<ol>
<li>Assume ES = OS segment</li>
<li>The table of segments in the memory manager begins at <code>segID2seg = es:[[es:0x6]+[es:0x4]]</code></li>
<li>The word at <code>es:[segID2seg+segID]</code> stores flags of the segment ID (swapped in/out, used for read/write)</li>
<li>The word at <code>es:[segID2seg+segID+2]</code> stores the physical location of the segment in the RAM, if it is loaded</li>
</ol>
<p>If the segment is not present in RAM (swapped out), it is possible to ask the OS to load it for you. I highly suspect syscall <code>0x05</code> is responsible for segment loading, but most apps are not using it. All the normally required memory segments are present in the RAM as if by &#34;magic&#34;, anyways. The Pyramid game is using this call to ensure the font segment is in the RAM. Without this call, it might not load in time on a slow machine like an XT; this is probably related to the DMA disk operations initiated by the OS.</p>
<h2 id="outstanding-hackery-of-bitmap-displays"><a href="#outstanding-hackery-of-bitmap-displays" rel="nofollow noopener">#</a>Outstanding hackery of bitmap displays</h2>
<p>It isn&#39;t too difficult to use VisiOn&#39;s Virtual Terminal Device for text output and on-screen buttons, but displaying graphics and custom fonts required a bit of trial and error. The reason, of course, is the lack of references: VisiOn only displays images on the splash screen of programs like Word and Calc!</p>
<h3 id="custom-fonts-as-a-bitmap-format"><a href="#custom-fonts-as-a-bitmap-format" rel="nofollow noopener">#</a>Custom fonts as a bitmap format</h3>
<p>I think there must be a VisiOp function for displaying a bitmapped image. But, for some reason, when VisiOn Calc draws a splash screen, it uses something completely different: a custom font.</p>
<p>The bitmapped image is divided into glyphs, glyphs (1-127) are loaded as a font, and then the image on the screen is printed as if it was just a string. The Convert To Calc logo, printed with the default font, looks like this:</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/default_font.png"/></p>
<p>You can see that this method allows image compression: empty blocks are represented by spaces.</p>
<h3 id="finding-a-segment-id-for-a-segment"><a href="#finding-a-segment-id-for-a-segment" rel="nofollow noopener">#</a>Finding a Segment ID for a segment</h3>
<p>The VisiOp &#34;load font&#34; loads a font from a Segment ID passed to it. This means an application must know how to find a (dynamically-assigned!) Segment ID for any of its segments. The code that resolves a Segment ID for a magic pointer <code>0x810</code> is so clever it made me flip my table:</p>
<pre><code>mov ax, [cs:0x810+2]
</code></pre>
<p>Convert To Calc has multiple code and data segments. One of those segments has a table of &#34;magic&#34; pointers. The &#34;magic&#34; pointer at offset <code>0x810</code> is a &#34;magic&#34; pointer to the file with the font. So far, nothing out of the ordinary.</p>
<p>As I mentioned before, the operating system fills out the &#34;magic&#34; pointer table (list of entry points) with the Segment IDs when it starts an application. The Segment IDs are filled out &#34;in place&#34;. The entry points list in the Tutorial app is stored in a segment that doesn&#39;t have any code in it.</p>
<p>But Convert To Calc has a couple of functions exported from the &#34;entry points and magic pointers&#34; segment. When a cross-segment call is made to such a function, the current list of magic pointers and Segment IDs is stored <em>right in the same code segment</em>. A &#34;magic&#34; pointer, simply being an offset from the beginning of the file, can be read with a simple <code>mov</code>:</p>
<pre><code>mov ax, [cs:magic_pointer]   ;; entry point offset
mov ax, [cs:magic_pointer+2] ;; entry point Segment ID
</code></pre>
<p>So, <code>mov ax, [cs:0x810+2]</code> called from the code segment with the entry points table allows the program to know what Segment ID was assigned to the font segment.</p>
<h3 id="rops"><a href="#rops" rel="nofollow noopener">#</a>ROPs</h3>
<p>Printing text through the VisiOn&#39;s virtual terminal in the graphical mode, for all intents and purposes, behaves like a proper <a href="https://en.wikipedia.org/wiki/Bit_blit" rel="nofollow noopener">Bit blit</a>. One of the VisiOp parameters accepts a ROP code (&#34;Raster OPeration&#34;).</p>
<p>VisiOn takes an interesting approach to ROPs and bitmap displaying. You might know that Windows supported ternary BitBLT with <a href="https://en.wikipedia.org/wiki/Just-in-time_compilation" rel="nofollow noopener">JIT-generated</a> machine code for display rendering. VisiOn uses binary ROPs, similar to the ROPs in Xerox Alto or Bell Labs BLIT, and it also produces JIT machine code, but it produces the code for the &#34;glyph space&#34;.</p>
<p>Among other things, VisiOn will break each character into bits when you load a font and then emit the machine code that will produce the required bits. Basically, if your font array was <code>font[char_id][bit_num]</code>, it will be converted into <code>font_jit[bit_num][char_id]</code>. I am not sure why; maybe there are some performance benefits to this approach.</p>
<p>If this sounds like an unnecessary headache, remember that bitmapped output on CGA <em>is</em> a headache already. The screen buffer in CGA is interlaced: odd and even lines are stored in separate memory blocks. The pixels on the screen are bit-packed, too. If you want to plot a pixel at coordinates (1,1), your program will need to:</p>
<ol>
<li>Understand if you&#39;re drawing a pixel on an even or on an odd line,</li>
<li>Resolve the memory offset for the correct interlaced block,</li>
<li>Divide the Y coordinate by 2, and the X coordinate by 8 to find the byte that stores the pixel,</li>
<li>Read this byte from the video memory,</li>
<li>Flip a single bit in this byte, corresponding to the pixel you want to set or reset,</li>
<li>Write the byte back.</li>
</ol>
<p>These calculations are expensive, so it only makes sense to make the video driver slightly more complicated but feature-rich. For example, if you&#39;re reading the pixel from RAM anyway, you can choose between ADD, OR, NOT, or XOR pixel operations for free.</p>
<p>There are 16 available ROPs in total. Here is a checkerboard background and a circle drawn on top of it with different ROPs:</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/rops.png"/></p>
<h2 id="mini-fs"><a href="#mini-fs" rel="nofollow noopener">#</a>Mini-FS</h2>
<p>Each application is shipped with something I call a &#34;mini-file-system&#34;. The format of it is primitive: the number of entries, the list of pointers to the entries, and then the entries themselves. Each entry has a header similar to the &#34;segment header&#34; used by the installer, consisting of the magic number and the length of the entry.</p>
<p>The mini-FS, among other things, is used for the built-in help system. Entries to the mini-FS can be referenced from the menu system, so the OS could &#34;magically&#34; display the right entry when the user clicks &#34;HELP&#34;.</p>
<p>Naturally, the application can read entries from the mini-FS with a simple VisiOp call.</p>
<h2 id="whats-next"><a href="#whats-next" rel="nofollow noopener">#</a>What&#39;s next?</h2>
<p>This reverse-engineering project ended up being much bigger than I anticipated. We have a working application, yes, but so far I&#39;ve documented less than 10% of all the VisiHost and VisiOp calls. We still don&#39;t know how to implement keyboard input, or how to work with timers and background processes (if it is possible).</p>
<p>Atsuko and I would like to continue working on this SDK, but considering our other projects, I cannot imagine it taking as much priority as it has so far. This may be as far as we get. But this is <em>pretty far</em> already. If one were to follow these notes, they should be able to discover and document new VisiOps, say, from Word or Graph, very fast.</p>
<h2 id="bloopers"><a href="#bloopers" rel="nofollow noopener">#</a>Bloopers</h2>
<p>I discovered two funny bugs in the process of reverse-engineering.</p>
<h3 id="the-window-is-too-small"><a href="#the-window-is-too-small" rel="nofollow noopener">#</a>The window is too small!</h3>
<p>If you&#39;ve done any graphical programming for windowed environments, you would expect that the <code>Create_Window()</code> function requires window dimensions for a freshly-created window. VisiOn is free from such prejudice. As far as I can tell, applications are not supposed to freely decide what their window size should be. The Application Manager&#39;s option sheet has fields &#34;window width&#34; and &#34;window height&#34; that define the dimensions for most windows (except for the Application Manager, Help and Tutorial windows).</p>
<p>Naturally, the application can <em>read</em> the dimensions of its window so it can resize the contents inside. But if the window dimensions are too small, some of the applications would crash, and would take down the whole system:</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/divide_overflow.png"/></p>
<h3 id="let-me-beep"><a href="#let-me-beep" rel="nofollow noopener">#</a>Let me BEEP</h3>
<p>VisiOn loves to beep at the user. It beeps every time a menu option is chosen or an on-screen button is clicked.</p>
<p>If you are tired of the noise, you&#39;d appreciate that Application Manager has an option to replace the sound with a &#34;visual beep&#34;. It is implemented as a flashing area of 32x16 pixels around the mouse cursor. Every time the flashing is about to happen, an image &#34;below&#34; the cursor is preserved in RAM to be restored after the &#34;visual beep&#34; is over. However, the memory allocated for this bitmap is never freed. It takes between 200 and 1000 clicks to fill the RAM with useless copies of the mouse cursor, and then the system crashes.</p>
<p><img alt="" src="https://git.sr.ht/~nkali/vision-sdk/blob/main/braindump/nearly_full.png"/></p>
<hr/>
<h2 id="thanks"><a href="#thanks" rel="nofollow noopener">#</a>Thanks</h2>
<p>Huge thanks to:</p>
<ul>
<li>Atsuko Ito for moral support and for the actual Homebrew app implementation,</li>
<li>Tom Stepleton for proofreading and early feedback on this note,</li>
<li>Nathan Lineback for an extensive research into VisiOn, and for his software preservation efforts,</li>
<li>VisiOn developers,</li>
<li>you, the reader!</li>
</ul>
</div>
    </div>
    
</div>


    
    


  
</div></div>
  </body>
</html>
