<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://b.tuxes.uk/avoiding-emacs-bankruptcy.html">Original</a>
    <h1>Avoiding Emacs Bankruptcy</h1>
    
    <div id="readability-page-1" class="page">
    
    <p><small>Disclaimer: All ways of using Emacs are valid ways of using
	Emacs. This is describing just one.</small></p>
    <p>Emacs is a complex program, to the point that the dreaded <a href="https://www.emacswiki.org/emacs/DotEmacsBankruptcy"><em>emacs
	  bankruptcy</em></a> afflicts many, in which your config “gets so large
      that you really need to start over”.</p>
    <p>I’ve nearly been there, drawn in with the allure of a useful package
      here and there, which results in various long-term costs:</p>
    <ul>
      <li>random slow downs, on startup/file open/file save/etc.</li>
      <li>packages interacting poorly in hard to diagnose ways</li>
      <li>packages breaking from lack of maintenance</li>
      <li>finding it difficult to root-cause and produce minimal test
	cases</li>
      <li>finding myself far from a standard installation, effectively
	maintaining my own fork</li>
    </ul>
    <p><img src="https://b.tuxes.uk/life-of-a-software-engineer.png"/></p>
    <p>But over time I’ve settled on an approach that has kept me far from
      bankruptcy using off-the-shelf financial advice: frugality, and paying
      back debt.</p>
    <h2 id="frugality">Frugality</h2>
    <p>This idea is that packages must have a high power-to-weight ratio:
      providing useful functionality, but not incurring many long-term
      costs.</p>
    <p>Emacs provides a set of subsystems that play well together, and offer
      hooks for extension. Third party packages vary on how well they adhere
      to these subsystems.</p>
    <h3 id="minibuffer-completion">Minibuffer completion</h3>
    <p>Emacs has a variety of minibuffer completion tools: the UI you see
      when you <code>M-x</code>. Older tools such as Ivy/Helm/Swiper offer a
      popular UI, but do so without interoperating with the wider
      ecosystem.</p>
    <p>Around 2020, a suite of interopable alternatives were developed that
      build upon the built-in <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Minibuffer-Completion.html"><code>completing-read</code></a>
      function: <a href="https://github.com/minad/vertico">Vertico</a>, <a href="https://github.com/oantolin/orderless">Orderless</a>, <a href="https://github.com/minad/consult">Consult</a>, and the built-in
      <code>(vertical-fido-mode)</code>.</p>
    <p><a href="https://github.com/minad/vertico#alternatives">Vertico’s
	docs</a> discuss this more.</p>
    <p>Recommendation: Use the built-in <code>(vertical-fido-mode)</code>.
      If you want something more, look into Vertico.</p>
    <h3 id="syntax-checking">Syntax checking</h3>
    <p><a href="https://www.gnu.org/software/emacs/manual/html_node/flymake/index.html">Flymake</a>
      has been in Emacs since 2004. Due to its lack of features, the
      third-party <a href="https://github.com/flycheck/flycheck">flycheck</a>
      brought in a wave of innovation, and became the defacto standard syntax
      checker.</p>
    <p>Since Emacs 26, Flymake has achieved <a href="https://www.flycheck.org/en/latest/user/flycheck-versus-flymake.html">~feature
	parity</a>. Flycheck’s extensive checkers can be used in Flymake via the
      <a href="https://github.com/purcell/flymake-flycheck">flymake-flycheck</a>
      adapter.</p>
    <p>Recommendation: Use the built-in Flymake. Try
      <code>(consult-flymake)</code> as a UI.</p>
    <h3 id="language-server-protocol">Language server protocol</h3>
    <p><a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language
	Server Protocol</a> is the open protocol to allow editors to use
      external servers that provide language intelligence tools.</p>
    <p><a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> was the
      first popular implementation, which came with its own ecosystem.</p>
    <p>Eglot was then developed, reusing other Emacs subsystems such as
      Flymake, ElDoc, Xref and Project. Eglot is now <a href="https://www.gnu.org/software/emacs/manual/html_mono/eglot.html">built-in
	with Emacs</a>.</p>
    <p>Recommendation: Use the built-in eglot.</p>
    <h3 id="project">Project</h3>
    <p>In 2011, <a href="https://github.com/bbatsov/projectile">Projectile</a> was created
      to provide project support, e.g. find files within a Git repo.</p>
    <p>Emacs 25 introduced <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Projects.html">built-in
	project support</a>, which now has integration with other
      subsysytems.</p>
    <p>Projectile still has a wider feature set, but I live without
      these.</p>
    <p>Recommendation: Use the built-in project package. Try
      <code>C-x p p</code>.</p>
    <h3 id="version-control">Version control</h3>
    <p>Emacs has built-in <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Version-Control.html">version
	control support</a>, which abstracts which VCS (Git, Hg, SVN, …) you are
      using. <a href="https://github.com/dgutov/diff-hl">diff-hl</a> extends
      this to provide in-buffer highlighting of diffs.</p>
    <p><a href="https://magit.vc/">Magit</a> is a great UI for interacting
      with Git.</p>
    <p>I have no recommendations here. I use magit and vc.el. I’d love to
      see a Magit-inspired UI built on top of vc.el.</p>
    <h3 id="visualising-the-undo-tree">Visualising the undo tree</h3>
    <p>Emacs stores a rich <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Undo.html">undo
	history</a> that is best visualised as a tree.</p>
    <p>Historically, <a href="https://github.com/emacsmirror/undo-tree">undo-tree</a> provided
      this, but in doing so it reimplemented a large part of undo
      functionality, resulting in a 4500 line package.</p>
    <p><a href="https://github.com/casouri/vundo">vundo</a> is a simpler
      package that reuses the built-in undo functionality, and weighs in at
      1500 lines.</p>
    <p>Recommendation: Use vundo.</p>
    <h2 id="paying-back-debt">Paying back debt</h2>
    <p>The second idea is to pay back debt.</p>
    <p>All config is debt. The ideal way to reduce this is to upstream an
      improvement that makes you happy with defaults. But sometimes that’s not
      always possible.</p>
    <p>The next best alternative is to ruthlessly delete config that’s
      providing marginal value:</p>
    <ul>
      <li>custom keybindings for rarely used commands?</li>
      <li>settings that fix a slight UI annoyance?</li>
      <li>config for a editing languages I rarely write in?</li>
    </ul>
    <p>All gone!</p>
    <h2 id="did-i-throw-the-baby-out-with-the-bath-water">Did I throw the
      baby out with the bath water?</h2>
    <p><a href="https://en.wikipedia.org/wiki/Don%27t_throw_the_baby_out_with_the_bathwater"><img src="https://b.tuxes.uk/baby-bathwater.png"/></a></p>
    <p>Since Emacs’s strength is its customisability, then have I sacrified
      its very strength by taking this frugal approach?</p>
    <p>A little bit, yes. But Emacs’s primary benefits for me
      (introspectibility, extensibility, durability) still stand, even in the
      face of frugality.</p>
    <h2 id="what-about-emacs-distributions-such-as-doom-emacs">What about
      Emacs distributions, such as Doom Emacs?</h2>
    <p>I don’t have any experience with these, but <a href="https://github.com/doomemacs/doomemacs">Doom Emacs</a> looks to
      produce a great out-the-box experience. I prefer my upstream to be
      Emacs, and to build my base on the well thought-out and documented
      abstractions of plain Emacs.</p>
    <h2 id="summary">Summary</h2>
    <p>In summary:</p>
    <ul>
      <li>Use packages that offer high power-to-weight, and interoperate with
	built-in abstractions.</li>
      <li>Pay back debt, by ruthlessly deleting config that’s of marginal
	value</li>
    </ul>
  

</div>
  </body>
</html>
