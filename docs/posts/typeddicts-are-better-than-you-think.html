<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.changs.co.uk/typeddicts-are-better-than-you-think.html">Original</a>
    <h1>TypedDicts are better than you think</h1>
    
    <div id="readability-page-1" class="page"><section id="content">
    <article>
      <header>
        
      </header>

      <div>
<!-- /.post-info -->        <p><code>TypedDict</code> was introduced in <a href="https://peps.python.org/pep-0589/">PEP-589</a> which landed in Python 3.8.</p>
<p>The primary use case was to create type annotations for dictionaries. For example,</p>
<div><pre><span></span><code><span>class</span> <span>Movie</span><span>(</span><span>TypedDict</span><span>):</span>
    <span>title</span><span>:</span> <span>str</span>


<span>movie</span><span>:</span> <span>Movie</span> <span>=</span> <span>{</span><span>&#34;title&#34;</span><span>:</span> <span>&#34;Avatar&#34;</span><span>}</span>
</code></pre></div>

<p>I remember thinking at the time that this was pretty neat, but I tend to use <code>dataclass</code> or <code>pydantic</code> to represent &#39;record&#39; type data. Instead I use dictionaries more as a collection, so the standard <code>dict[KT, VT]</code> annotation is enough.</p>
<h3>Non-totality</h3>
<p>I revisited typeddicts when I looked at implementing a HTTP patch endpoint.</p>
<p>Let&#39;s suppose I have a data structure represented by the following dataclass:</p>
<div><pre><span></span><code><span>@dataclass</span>
<span>class</span> <span>User</span><span>:</span>
    <span>id</span><span>:</span> <span>UUID</span>
    <span>name</span><span>:</span> <span>str</span>
    <span>subscription</span><span>:</span> <span>str</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
</code></pre></div>

<p>Where <code>subscription = None</code> means no subscription.</p>
<p>Let&#39;s say we want to option to patch name, subscription. You might define the patch body using dataclass:</p>
<div><pre><span></span><code><span>@dataclass</span>
<span>class</span> <span>PatchUser</span><span>:</span>
    <span>name</span><span>:</span> <span>str</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
    <span>subscription</span><span>:</span> <span>str</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
</code></pre></div>

<p>Here we have a problem, for subscription does <code>None</code> mean don&#39;t change or remove subscription. </p>
<p>We can fix this a number of ways, for example, we can take the string <code>&#39;none&#39;</code> to mean no subscription instead, or make a new sentinel value called <code>NoChange</code> to indicate no changes.</p>
<p>These solutions all feel a little awkward, this is because dataclasses don&#39;t have a concept of a field being missing. But this is where dictionaries shine. Dictionaries are not general expected to have all the fields available. We get a <code>KeyError</code> if a field is missing and there are convenience methods such as <code>.get(key, [default])</code> to fetch a key that is not guaranteed to be present.</p>
<p>This makes <code>TypedDict</code> the ideal data structure in this scenario:</p>
<div><pre><span></span><code><span>class</span> <span>PatchUser</span><span>(</span><span>TypedDict</span><span>,</span> <span>total</span><span>=</span><span>False</span><span>):</span>
    <span>name</span><span>:</span> <span>str</span> <span>|</span> <span>None</span>
    <span>subscription</span><span>:</span> <span>str</span> <span>|</span> <span>None</span> <span>=</span> <span>None</span>
</code></pre></div>

<p>Since <code>total</code> is False here (by default it is set to True), <code>name</code> or <code>subscription</code> can be absent from the dictionary. Which represents the PATCH operation much better than a <code>dataclass</code> or Pydantic model.</p>
<p>Further additions in <a href="https://peps.python.org/pep-0655/">PEP-655</a> allows us to mark individual fields as <code>Required</code> or <code>NotRequired</code> which further increases its flexibility.</p>
<blockquote>
<p>If you&#39;re wondering about FastAPI support for TypedDict, <a href="https://docs.pydantic.dev/2.3/usage/types/dicts_mapping/#typeddict">Pydantic supports it out of the box</a>. So your TypedDict can be used in a FastAPI endpoint.</p>
</blockquote>
<h3>Using <code>TypedDict</code> as <code>**kwargs</code></h3>
<p><a href="https://peps.python.org/pep-0692/">PEP-692</a> introduced the ability to type variadic keyword arguments using <code>TypedDict</code>.</p>
<p>So the following two snippets are equivalent.
Without <code>TypedDict</code>:</p>
<div><pre><span></span><code><span>def</span> <span>my_function</span><span>(</span><span>*</span><span>,</span> <span>option1</span><span>:</span> <span>int</span><span>,</span> <span>option2</span><span>:</span> <span>str</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>...</span>
</code></pre></div>

<p>Using <code>TypedDict</code>:</p>
<div><pre><span></span><code><span>from</span> <span>typing</span> <span>import</span> <span>TypedDict</span><span>,</span> <span>Unpack</span>


<span>class</span> <span>Options</span><span>(</span><span>TypedDict</span><span>):</span>
    <span>option1</span><span>:</span> <span>int</span>
    <span>option2</span><span>:</span> <span>str</span>


<span>def</span> <span>my_function</span><span>(</span><span>**</span><span>options</span><span>:</span> <span>Unpack</span><span>[</span><span>Options</span><span>])</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>...</span>
</code></pre></div>

<p>At a glance I can say that the TypedDict option is rather verbose. Though it does become more useful if Options were used in multiple function definitions.</p>
<div><pre><span></span><code><span>def</span> <span>my_function2</span><span>(</span><span>**</span><span>options</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>...</span>


<span>def</span> <span>my_function3</span><span>(</span><span>*</span><span>,</span> <span>other_option</span><span>:</span> <span>str</span><span>,</span> <span>**</span><span>options</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
    <span>...</span>
</code></pre></div>

<p>Where it truely shines is once again with non-totality.</p>
<p>Suppose we have the following scenario, where we want to create a custom version of pytest.fixture, but still pass through some arguments.</p>
<div><pre><span></span><code><span>def</span> <span>fixture</span><span>(</span><span>scope</span><span>:</span> <span>str</span> <span>=</span> <span>&#34;module&#34;</span><span>,</span> <span>autouse</span><span>:</span> <span>bool</span> <span>=</span> <span>False</span><span>):</span>
    <span>return</span> <span>pytest</span><span>.</span><span>fixture</span><span>(</span><span>scope</span><span>,</span> <span>autouse</span><span>)</span>
</code></pre></div>

<p>Here to get the typing right I not only have to find the type of each argument but also the default value. It would be better if we use <code>**kwargs</code> so we can just avoid passing the arguments through. And to keep type information we just need to use our trusty <code>TypedDict</code> once more:</p>
<div><pre><span></span><code><span>class</span> <span>FixtureOptions</span><span>(</span><span>TypedDict</span><span>,</span> <span>total</span><span>=</span><span>False</span><span>):</span>
    <span>scope</span><span>:</span> <span>str</span>
    <span>autouse</span><span>:</span> <span>bool</span>


<span>def</span> <span>fixture</span><span>(</span><span>**</span><span>options</span><span>:</span> <span>Unpack</span><span>[</span><span>FixtureOptions</span><span>]):</span>
    <span># Some custom implementations</span>
    <span>...</span>
    <span>return</span> <span>pytest</span><span>.</span><span>fixture</span><span>(</span><span>**</span><span>options</span><span>)</span>
</code></pre></div>

<p>Non-totallity means that we don&#39;t have to pass in scope and autouse. We can just have the default.</p>
<h4>Sentinels</h4>
<p>We can achieve similar behaviour with sentinels:</p>
<div><pre><span></span><code><span>UNSPECIFIED</span><span>:</span> <span>Any</span> <span>=</span> <span>object</span><span>()</span>  <span># Has to be Any type so it could be set as default for other types.</span>

<span>def</span> <span>my_func</span><span>(</span><span>option1</span><span>:</span> <span>bool</span> <span>=</span> <span>UNSPECIFIED</span><span>,</span> <span>...</span><span>)</span> <span>-&gt;</span> <span>...</span><span>:</span>
    <span>if</span> <span>option1</span> <span>is</span> <span>UNSPECIFIED</span><span>:</span>
        <span>...</span>
    <span>...</span>
</code></pre></div>

<p>Sentinels work well enough here, but we have to remember to handle them. Additionally type annotations for sentinels can be a bit awkward, here we made <code>UNSPECIFIED</code> an <code>Any</code> type, but it means that inside the function <code>option1</code> is only typed as <code>bool</code>. There are options to expose the sentinel type but they may add even more confusion.</p>
<h3>Using <code>TypedDict</code> to pass in dependencies</h3>
<p>We can do even more with <a href="https://peps.python.org/pep-0692/">PEP-692</a>! When I first learned about the PEP, I thought it was only about function signature. But reading through it more thoroughly, I discovered that another consequence of the PEP is that type checkers can now check for function invocation when using TypedDicts:</p>
<div><pre><span></span><code><span>def</span> <span>purge</span><span>(</span><span>queue</span><span>:</span> <span>str</span><span>,</span> <span>timeout</span><span>:</span> <span>float</span><span>)</span> <span>-&gt;</span> <span>...</span><span>:</span>
    <span>...</span>


<span>class</span> <span>Options</span><span>(</span><span>TypedDict</span><span>):</span>
    <span>queue</span><span>:</span> <span>str</span>
    <span>timeout</span><span>:</span> <span>float</span>


<span>class</span> <span>WrongOptions</span><span>(</span><span>TypedDict</span><span>):</span>
    <span>queue</span><span>:</span> <span>str</span>
    <span>timeout</span><span>:</span> <span>timedelta</span>


<span>options</span><span>:</span> <span>Options</span> <span>=</span> <span>...</span>
<span>purge</span><span>(</span><span>**</span><span>options</span><span>)</span>  <span># ✅</span>

<span>wrong_options</span><span>:</span> <span>WrongOptions</span> <span>=</span> <span>...</span>
<span>purge</span><span>(</span><span>**</span><span>wrong_options</span><span>)</span>  <span># ❌</span>
</code></pre></div>

<p>This feature is necessary in many situations such as cases where we pass through the kwargs. For example, in the <code>fixture</code> example, when we invoke <code>pytest.fixture(**options)</code> the type checker will perform proper type checking.</p>
<p>But we can use it in more creative ways.</p>
<h4>Dependency Injection</h4>
<p>Let&#39;s consider a situation where we have many resources that share some dependencies. </p>
<div><pre><span></span><code><span>class</span> <span>UserClient</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>db</span><span>:</span> <span>Engine</span><span>,</span> <span>user_service</span><span>:</span> <span>APIClient</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>...</span>


<span>class</span> <span>ProjectClient</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>db</span><span>:</span> <span>Engine</span><span>,</span> <span>user_service</span><span>:</span> <span>APIClient</span><span>,</span> <span>project_service</span><span>:</span> <span>APIClient</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>...</span>
</code></pre></div>

<p>We want a way to create all the dependencies in one place and pass in the dependencies.</p>
<p>Essentially we need something that is the union of all kwargs of the resources. That suddernly sounds a lot like a TypedDict:</p>
<div><pre><span></span><code><span>class</span> <span>Dependencies</span><span>(</span><span>TypedDict</span><span>):</span>
    <span>db</span><span>:</span> <span>Engine</span>
    <span>user_service</span><span>:</span> <span>APIClient</span>
    <span>project_service</span><span>:</span> <span>APIClient</span>


<span>def</span> <span>create_deps</span><span>(</span><span>...</span><span>)</span> <span>-&gt;</span> <span>Dependencies</span><span>:</span>
    <span>...</span>
</code></pre></div>

<p>Unfortunately this won&#39;t work since <code>UserClient</code> can&#39;t take <code>project_service</code> as a kwarg.</p>
<p>To fix this, we need to rewrite the resources such that we accept arbitrary arguments.</p>
<div><pre><span></span><code><span>class</span> <span>UserClient</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>...</span><span>,</span> <span>**</span><span>_</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>...</span>
<span>...</span>
</code></pre></div>

<p>And then we can do the injection like this:</p>
<div><pre><span></span><code><span>class</span> <span>ResourceWithMissing</span><span>:</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>,</span> <span>other</span><span>:</span> <span>Any</span><span>,</span> <span>**</span><span>_</span><span>)</span> <span>-&gt;</span> <span>None</span><span>:</span>
        <span>...</span>


<span>def</span> <span>inject</span><span>(</span><span>deps</span><span>:</span> <span>Dependencies</span><span>):</span>
    <span>UserClient</span><span>(</span><span>**</span><span>deps</span><span>)</span>  <span># ✅</span>
    <span>ProjectClient</span><span>(</span><span>**</span><span>deps</span><span>)</span>  <span># ✅</span>
    <span>ResourceWithMissing</span><span>(</span><span>**</span><span>deps</span><span>)</span>  <span># ❌</span>
    <span>...</span>


<span>inject</span><span>(</span><span>create_deps</span><span>(</span><span>...</span><span>))</span>
</code></pre></div>

<p>With the solution complete, we can now rely on the type system to check the dependency injection to see if any arguments are incorrect or missing. </p>
<p>I will admit that changing resource signature with <code>**_</code> is not ideal, but this is a smaller change than most dependency injection frameworks. And we get static type checking which a lot of the frameworks won&#39;t support.</p>
<h3>Upcoming Features</h3>
<p><a href="https://peps.python.org/pep-0728/">PEP-728</a> will allow types of extra items to be defined, and a typed dict to be closed meaning no extra items can be defined.</p>
<p>This new change looks like it&#39;ll help us define record types more precisely.</p>
<p>I personally haven&#39;t thought of many other use cases for it, but as I&#39;ve demonstrated above it&#39;s always worth reading through the PEP and experimenting with the new change. </p>
<p><a href="https://peps.python.org/pep-0705/">PEP-705</a> might already be out by the time you read this. This will allow for read only items to be specified.</p>
<p>This is primarily intended for situations where different typed dicts intuitively should be compatible but potential mutations (deletions) can create problems.</p>
      </div><!-- /.entry-content -->

    </article>
  </section><div id="contentinfo">
                        <address id="about">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </div></div>
  </body>
</html>
