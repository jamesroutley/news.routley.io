<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/garyexplains/piccolo_os_v1">Original</a>
    <h1>Piccolo OS, a Small Multitasking OS for the Raspberry Pi Pico</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">Piccolo OS is a small multitasking OS for the Raspberry Pi Pico. It is designed primarily as a teaching tool.
It demonstrates the fundamentals of a co-operative multitasking OS and the Arm Cortex-M0+.</p>

<p dir="auto">Many! Including lack of per-task memory, multicore support, mutexes, queues, a file system, networking, a shell, and so on...</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">A Comma A Day Keeps The Pedants Away</h2><a id="user-content-a-comma-a-day-keeps-the-pedants-away" aria-label="Permalink: A Comma A Day Keeps The Pedants Away" href="#a-comma-a-day-keeps-the-pedants-away"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Since the Internet seems to be full of people with way too much time on their hands, I would just like to kindly shoo away any C/C++ pedants out there.
Yes, I am sure there are a million different ways to achieve many of the same results. Yes, I am sure there are some fine points of language semantics that could be argued about. Yes, I am sure you have a more efficient way of writing some of the functions.</p>
<p dir="auto">To be honest, I am not interested.</p>
<p dir="auto">Having said that, like-minded people who wish to contribute and extend Piccolo OS are welcome. See <strong>Contributing</strong></p>

<p dir="auto">Make sure you have the Pico C/C++ SDK installed and working on your machine. <a href="https://datasheets.raspberrypi.org/pico/getting-started-with-pico.pdf" rel="nofollow">Getting started with Raspberry Pi Pico is
the best place to start.</a></p>
<p dir="auto">You need to have PICO_SDK_PATH defined, e.g. <code>export PICO_SDK_PATH=/home/pi/pico/pico-sdk/</code></p>
<p dir="auto">Clone the code from the repository. Change directory into <code>build</code> and run <code>cmake -DCMAKE_BUILD_TYPE=Debug ..</code> (for a debug build) or <code>cmake ..</code> (for a release build).</p>
<p dir="auto">Run <code>make</code></p>
<p dir="auto">The resulting file <code>piccolo_os_demo.elf</code> can be flashed on your Pico in the normal way.</p>

<p dir="auto">First to define some terminology. The <em>kernel</em> is the <code>main()</code> function (and later <code>piccolo_start()</code> which is called by <code>main()</code> and never returns.) The job of the
kernel is to allow for tasks to be created and then, in a round-robin fashion, pick the next task that needs to be run, save the kernel stack, restore the task&#39;s stack and jump to the program counter (PC) last used by the user task.</p>
<p dir="auto">A <em>task</em> (i.e. <em>user task</em>) is a function that is run by Piccolo in a round-robin fashion along with the other <em>tasks</em>. For example, a function that flashes the onboard LED. Each <em>task</em> has its own stack, separate from the main stack (which is used by the kernel).</p>
<p dir="auto">So, there are two types of stack, the Main Stack Pointer (MSP) and Process Stack Pointer (PSP). The Process Stack Pointer (PSP) is used by the current task, and the MSP is used by OS Kernel and exception handlers.</p>
<p dir="auto">To switch from the kernel to a task, Piccolo needs to save the kernel state on the main stack, restore the user state from the process stack, and jump to the task PC that was saved. To switch from a task to the kernel, the opposite happens, in that the user stack is saved, the kernel stack is restored. The task to kernel switch happens via an interrupt, a SVC.</p>
<p dir="auto">Piccolo OS uses a set of stacks, one for each task. The stacks are defined in <code>piccolo_os_internals_t</code> along with the number of created tasks, plus the index to the current task.</p>

<p dir="auto"><code>piccolo_init()</code> initializes the number of created tasks to zero, then calls the standard Pico SDK initialization function <code>stdio_init_all()</code>. After reset, the processor is
in thread (privileged) mode. __piccolo_task_init_stack() switches to handler mode to ensure an appropriate exception return.</p>
<p dir="auto">Once <code>piccolo_init()</code> has been called the rest of <code>main()</code>, and any other functions like <code>piccolo_start()</code> will be run in handler mode. This can cause problems with the Pico C/C++ SDK, especially with the timers as they are hardware/interrupt based.</p>

<p dir="auto">To create a task the initial stack frame is created. It needs to mimic what would be saved by hardware and by the software. Once the stack is initialized, <code>__piccolo_pre_switch()</code> is called to simulate a return from the exception state. The stack is then ready to be used for context switching.</p>

<p dir="auto">This is an infinite loop that picks the next stack (i.e. next task) to use in a round-robin fashion. When <code>piccolo_yield()</code> or <code>piccolo_syscall()</code> is called an exception is raised (a SVC exception), which causes the interrupt handler <code>isr_svcall</code> to be called.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">piccolo_yield() / piccolo_syscall()</h3><a id="user-content-piccolo_yield--piccolo_syscall" aria-label="Permalink: piccolo_yield() / piccolo_syscall()" href="#piccolo_yield--piccolo_syscall"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">This function is very simple:</p>

<p dir="auto">The SVC instruction causes an exception which is handled by <code>isr_svcall</code>.</p>

<p dir="auto">This is invoked via the SVC exception. It saves the current user task onto the PSP and then restores the kernel stack. It then returns to the last PC used by the kernel before it was switched out. Control returns to the kernel (<code>main()</code> or  <code>piccolo_start()</code>).</p>

<p dir="auto"><code>__piccolo_pre_switch()</code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack. Then, the task state (the register R4 to R11 and the LR) are restored from the task&#39;s PSP stack. This is in R0, which is used to set the PSP register. The code then jumps to the LR (restored from the PSP).</p>
<p dir="auto">If the LR is THREAD_PSP (i.e. 0xFFFFFFFD, a special return address recognized by the CPU) then THREAD_PSP forces a return to Thread mode, execution continues using the PSP.</p>

<p dir="auto">Since Piccolo OS isn&#39;t preemptive, then using the Pico&#39;s C/C++ sleep functions will cause execution to block. <code>piccolo_sleep()</code> is a replacement function that calls <code>piccolo_yield()</code> while waiting for the specified amount of time to pass.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Thread mode and Handler mode in the Cortex-M0+</h2><a id="user-content-thread-mode-and-handler-mode-in-the-cortex-m0" aria-label="Permalink: Thread mode and Handler mode in the Cortex-M0+" href="#thread-mode-and-handler-mode-in-the-cortex-m0"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">When the Cortex-M0+ processor is running a program it can be either in Thread mode or Handler mode. Thread mode and Handler mode are almost completely the same.
The only difference is that Thread mode uses (if desired) the Process Stack Pointer (PSP) rather than the Main Stack Pointer (MSP).</p>
<p dir="auto">After reset, the processor is in Thread mode.</p>

<p dir="auto">The Cortex-M0 and Cortex-M0+ processors (also applicable to Cortex-M3/M4/M7) have two Stack Pointers (SPs).
There are two types of stack, the Main Stack Pointer (MSP) and Process Stack Pointer (PSP).
The Process Stack Pointer (PSP) is used by the current task, and the MSP is used by OS Kernel and exception handlers. The stack pointer selection is
determined by the CONTROL register, a special registers.
When a context switch occurs the status is saved on the stack.</p>

<ol dir="auto">
<li>Piccolo OS -&gt; save kernel state on MSP -&gt;</li>
<li>restore TASK1 state from PSP_1 -&gt; TASK1 -&gt; save TASK1 state to PSP_1 -&gt;</li>
<li>restore kernel state from MSP -&gt; Piccolo OS -&gt; save kernel on MSP -&gt;</li>
<li>restore TASK2 state from PSP_2 -&gt; TASK2 -&gt; save TASK2 state to PSP_2 -&gt;</li>
<li>restore kernel state from MSP -&gt; Piccolo OS -&gt; save kernel on MSP -&gt;</li>
<li>restore TASK3 state from PSP_3 -&gt; TASK3 -&gt; save TASK3 state to PSP_3 -&gt;</li>
<li>restore kernel state from MSP -&gt; Go to step 1.</li>
</ol>

<div data-snippet-clipboard-copy-content="        Exception frame saved by the hardware onto stack:
        +------+
        | xPSR | 0x01000000 i.e. PSR Thumb bit
        |  PC  | Pointer to task function
        |  LR  | 
        |  R12 | 
        |  R3  | 
        |  R2  | 
        |  R1  | 
        |  R0  | 
        +------+
        Registers saved by the software (isr_svcall):
        +------+
        |  LR  | THREAD_PSP i.e. 0xFFFFFFFD
        |  R7  | 
        |  R6  | 
        |  R5  | 
        |  R4  | 
        |  R11 | 
        |  R10 | 
        |  R9  | 
        |  R8  | 
        +------+"><pre><code>        Exception frame saved by the hardware onto stack:
        +------+
        | xPSR | 0x01000000 i.e. PSR Thumb bit
        |  PC  | Pointer to task function
        |  LR  | 
        |  R12 | 
        |  R3  | 
        |  R2  | 
        |  R1  | 
        |  R0  | 
        +------+
        Registers saved by the software (isr_svcall):
        +------+
        |  LR  | THREAD_PSP i.e. 0xFFFFFFFD
        |  R7  | 
        |  R6  | 
        |  R5  | 
        |  R4  | 
        |  R11 | 
        |  R10 | 
        |  R9  | 
        |  R8  | 
        +------+
</code></pre></div>

<div data-snippet-clipboard-copy-content="        Registers saved by the software (__piccolo_pre_switch):
        +------+
        |  LR  |
        |  R7  |
        |  R6  |
        |  R5  |
        |  R4  |
        |  R12 | NB: R12  (i.e IP) is included, unlike user state
        |  R11 |
        |  R10 |
        |  R9  |
        |  R8  | 
        +------+"><pre><code>        Registers saved by the software (__piccolo_pre_switch):
        +------+
        |  LR  |
        |  R7  |
        |  R6  |
        |  R5  |
        |  R4  |
        |  R12 | NB: R12  (i.e IP) is included, unlike user state
        |  R11 |
        |  R10 |
        |  R9  |
        |  R8  | 
        +------+
</code></pre></div>

<p dir="auto">When the CPU is interrupted, the hardware will store R0 to R3, the PC etc., onto the stack. It is automatic. The interrupt handler <code>isr_svcall()</code> needs to save <strong>all</strong> the registers (the whole context) so it saves R4 to R11, etc. This means all the registered are saved. However, you may have noticed that when there is a switch from the <em>kernel</em> to a <em>task</em> via <code>__piccolo_pre_switch()</code> then this is software only (no SVC instruction, no interrupt) and so the kernel&#39;s R0 to R3 are not saved on the main stack. The reason is that the calling ARM calling convention (when you call a function) states that R0 to R3 are scratch registers and you can&#39;t rely on their contents after a branch to another bit of code. So R0 to R3 don&#39;t need to be saved as the C compiler knows not to rely on the value of those registers after a function call, and invoking <code>__piccolo_pre_switch()</code> is a function call!</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Typical sequence of events</h2><a id="user-content-typical-sequence-of-events" aria-label="Permalink: Typical sequence of events" href="#typical-sequence-of-events"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Let say you have two tasks, <em>task1</em> and <em>task2</em>. All they do is yield control back to the kernel. Like this:</p>
<div data-snippet-clipboard-copy-content="void task1(void) {
  while (true) {
    piccolo_yield();
  }
}"><pre><code>void task1(void) {
  while (true) {
    piccolo_yield();
  }
}
</code></pre></div>
<p dir="auto">Below, {T} means Thread mode, {H} means Handler mode, {HI} means Handler mode, but in actual Interrupt handler.</p>
<p dir="auto">Remember that, the <em>kernel</em> is the <code>main()</code> function and later <code>piccolo_start()</code> (which is called by <code>main()</code> and never returns).</p>
<p dir="auto">The typical sequence of events, from start-up, is:</p>
<ol dir="auto">
<li>{T} The processor starts in Thread mode</li>
<li>{T} <code>piccolo_init()</code> which calls <code>__piccolo_task_init()</code></li>
</ol>
<ul dir="auto">
<li><code>__piccolo_task_init()</code> creates a dummy stack and calls <code>__piccolo_task_init_stack()</code></li>
<li><code>__piccolo_task_init_stack()</code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack.</li>
<li>It then switches to the PSP (which is, in fact, a dummy stack) and triggers an interrupt</li>
</ul>
<ol start="3" dir="auto">
<li>{HI} <code>isr_svcall()</code> handles the interrupt. It saves the current task state (R4 to R11 and the LR) onto the PSP (the dummy stack).</li>
</ol>
<ul dir="auto">
<li>{HI} It then restores the kernel state from the main stack and returns to the kernel using the LR saved on the main stack in 2.</li>
</ul>
<ol start="4" dir="auto">
<li>{H} After the interrupt, processing continues in <code>__piccolo_task_init()</code> and eventually <code>piccolo_init()</code> but now in Handler mode.</li>
<li>{H} Next <em>task1</em> is created via <code>piccolo_create_task(&amp;task1);</code></li>
<li>{H} In <code>__piccolo_os_create_task()</code> a new stack is initialized for the task, including the frames saved by the hardware when an interrupt is called (see Context Switching above).</li>
<li>{H} Once the stack has been set up, <code>__piccolo_pre_switch()</code> is called passing the stack as a parameter.</li>
<li>{H} <code>__piccolo_pre_switch()</code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack.</li>
<li>{H} The task state (the register R4 to R11 and the LR) are restored from the stack passed in at step 7. This is in R0.</li>
<li>{H} R0 is set as the PSP and a jump is made to the LR, which is actually THREAD_PSP (i.e. 0xFFFFFFFD, a special return address recognized by the CPU)</li>
<li>{T} THREAD_PSP forces a return to Thread mode, execution continues using the PSP. The PSP has the address of <em>task1</em>, as set up in step 6. See <code>stack[15] = (unsigned int)start;</code> in <code>__piccolo_os_create_task()</code></li>
<li>{T} <em>task1</em> is just a loop that calls <code>piccolo_yield()</code></li>
<li>{T} <code>piccolo_yield()</code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> handles the interrupt. It saves the state of <em>tasks1</em> task (R4 to R11 and the LR) onto the PSP belonging <em>task1</em> (see steps 10. and 11.).</li>
</ol>
<ul dir="auto">
<li>{HI} It then restores the kernel state from the main stack and returns to the kernel using the LR saved on the main stack in 8.</li>
</ul>
<ol start="15" dir="auto">
<li>{H} After the interrupt, processing continues in <code>main()</code></li>
<li>{H} Next <em>task2</em> is created via <code>piccolo_create_task(&amp;task2);</code></li>
<li>Steps 6. to 15. are repeated, but now for <em>task2</em></li>
<li>{H} After the interrupt, processing continues in <code>main()</code>. Now that our tasks are created and running, we call <code>piccolo_start();</code></li>
<li>{H} Using a simple round-robin algorithm, <code>piccolo_start();</code> just picks the next task and calls <code>__piccolo_pre_switch()</code> passing the tasks stack as a parameter.</li>
</ol>
<ul dir="auto">
<li>{H} <code>__piccolo_pre_switch()</code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack.</li>
<li>{H} The task state (the register R4 to R11 and the LR) are restored from the stack passed as the parameter to <code>__piccolo_pre_switch()</code>. This is in R0.</li>
<li>{H} R0 is set as the PSP and a jump is made to the LR, which is actually THREAD_PSP (i.e. 0xFFFFFFFD, a special return address recognized by the CPU)</li>
<li>{T} THREAD_PSP forces a return to Thread mode, execution continues using the PSP. The PSP has the address of where to continue in the task. This address was saved into the LR (and saved onto the PSP stack) when the call to <code>piccolo_yield()</code> was made.</li>
<li>{T} Execution continues until <code>piccolo_yield()</code> is called again.</li>
</ul>
<ol start="20" dir="auto">
<li>{T} <code>piccolo_yield()</code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> handles the interrupt. It saves the state of the current task (R4 to R11 and the LR) onto the PSP belonging to the task.</li>
</ol>
<ul dir="auto">
<li>{HI} It then restores the kernel state from the main stack and returns to the kernel using the LR saved on the main stack.</li>
</ul>
<ol start="22" dir="auto">
<li>{H} After the interrupt, processing continues in <code>piccolo_start();</code></li>
<li>Jump to step 19.</li>
</ol>

<p dir="auto">Below, {T} means Thread mode, {H} means Handler mode, {HI} means Handler mode, but in actual Interrupt handler.</p>
<p dir="auto">Remember that, the <em>kernel</em> is the <code>main()</code> function and later <code>piccolo_start()</code> (which is called by <code>main()</code> and never returns).</p>
<ol dir="auto">
<li>{T} The processor starts in Thread mode, switch to Handler mode</li>
<li>{H} Create <em>task1</em></li>
</ol>
<ul dir="auto">
<li>{H} Initialize a stack for the task, including the frames saved by the hardware when an interrupt is called (see Context Switching above).</li>
<li>{H} <code>__piccolo_pre_switch()</code> saves the kernel state, onto the main stack; and restores the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code>piccolo_yield()</code> is called.</li>
</ul>
<ol start="3" dir="auto">
<li>{T} <code>piccolo_yield()</code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> saves the state of <em>tasks1</em> onto the PSP.  It then restores the kernel state from the main stack and returns to the kernel.</li>
<li>{H} Create <em>task2</em></li>
</ol>
<ul dir="auto">
<li>{H} Initialize a stack for the task, including the frames saved by the hardware when an interrupt is called (see Context Switching above).</li>
<li>{H} <code>__piccolo_pre_switch()</code> saves the kernel state, onto the main stack; and restores the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code>piccolo_yield()</code> is called.</li>
</ul>
<ol start="6" dir="auto">
<li>Now that our tasks are created and running, we call <code>piccolo_start();</code></li>
<li>{H} Using a simple round-robin algorithm, <code>piccolo_start();</code> just picks the next task and calls <code>__piccolo_pre_switch()</code> passing the tasks stack as a parameter.</li>
</ol>
<ul dir="auto">
<li>{H} <code>__piccolo_pre_switch()</code> saves the kernel state, onto the main stack.</li>
<li>{H} The task state are restored from the task&#39;s PSP</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code>piccolo_yield()</code> is called again.</li>
</ul>
<ol start="8" dir="auto">
<li>{T} <code>piccolo_yield()</code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> saves the state of the task onto its PSP.  It then restores the kernel state from the main stack and returns to the kernel (i.e. <code>piccolo_start();</code>)</li>
<li>Go to step 7.</li>
</ol>

<p dir="auto">Below, {T} means Thread mode, {H} means Handler mode.</p>
<p dir="auto">Remember that, the <em>kernel</em> is the <code>main()</code> function and later <code>piccolo_start()</code> (which is called by <code>main()</code> and never returns).</p>
<ol dir="auto">
<li>{T} The processor starts in Thread mode, switch to Handler mode</li>
<li>{H} Create <em>task1</em></li>
</ol>
<ul dir="auto">
<li>{H} Initialize a stack for it (PSP) then save the kernel state, onto the main stack; and restore the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP until <code>piccolo_yield()</code> is called.</li>
</ul>
<ol start="3" dir="auto">
<li>{T} <code>piccolo_yield()</code> intentionally forces an interrupt that saves the state of <em>tasks1</em> onto the PSP and restores the kernel state from the main stack. Execution continues in the kernel.</li>
<li>{H} Create <em>task2</em></li>
</ol>
<ul dir="auto">
<li>{H} Initialize a stack for it (PSP) then save the kernel state, onto the main stack; and restore the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP until <code>piccolo_yield()</code> is called.</li>
</ul>
<ol start="5" dir="auto">
<li>{T} <code>piccolo_yield()</code> intentionally forces an interrupt that saves the state of <em>tasks2</em> onto the PSP and restores the kernel state from the main stack. Execution continues in the kernel.</li>
<li>Now that our tasks are created and running, we call <code>piccolo_start()</code></li>
<li><code>piccolo_start()</code> just picks the next task and calls <code>__piccolo_pre_switch()</code> to saves the kernel state, onto the main stack; and then restored the next task from the task&#39;s PSP</li>
</ol>
<ul dir="auto">
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code>piccolo_yield()</code> is called again.</li>
</ul>
<ol start="8" dir="auto">
<li><code>piccolo_yield()</code> forces an interrupt that saves the state of the task onto its PSP.  It then restores the kernel state from the main stack and returns to the kernel (i.e. <code>piccolo_start();</code>)</li>
<li>Go to step 7.</li>
</ol>
<div dir="auto"><h3 tabindex="-1" dir="auto">Give me the Tom and Jerry version</h3><a id="user-content-give-me-the-tom-and-jerry-version" aria-label="Permalink: Give me the Tom and Jerry version" href="#give-me-the-tom-and-jerry-version"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Remember that, the <em>kernel</em> is the <code>main()</code> function and later <code>piccolo_start()</code> (which is called by <code>main()</code> and never returns).</p>
<ol dir="auto">
<li>Create <em>task1</em> and start running it using its own stack (PSP). It will run until <code>piccolo_yield()</code> is called.</li>
<li>Via an interrupt <code>piccolo_yield()</code> will saves the state of <em>tasks1</em> onto its PSP and restore the kernel state from the main stack. Execution continues in the kernel.</li>
<li>Create <em>task2</em> and start running it using its own stack (PSP). It will run until <code>piccolo_yield()</code> is called.</li>
<li>Via an interrupt <code>piccolo_yield()</code> will saves the state of <em>tasks2</em> onto its PSP and restore the kernel state from the main stack. Execution continues in the kernel.</li>
<li>Now that our tasks are created and running, we call <code>piccolo_start()</code></li>
<li><code>piccolo_start()</code> just picks the next task, saves the kernel state, onto the main stack; and then restores the next task from the task&#39;s PSP</li>
<li>Continue executing the next task using its own stack until <code>piccolo_yield()</code> is called.</li>
<li>Via an interrupt <code>piccolo_yield()</code> will saves the state of the current task onto its PSP and restores the kernel state from the main stack. Execution continues in the kernel (i.e. in <code>piccolo_start()</code>).</li>
<li>Go to 6.</li>
</ol>
<div dir="auto"><h2 tabindex="-1" dir="auto">Keep track of all those stacks!</h2><a id="user-content-keep-track-of-all-those-stacks" aria-label="Permalink: Keep track of all those stacks!" href="#keep-track-of-all-those-stacks"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Here is a brief look at some of the stacks and switches in and out of handler mode, which should help you visual what is happening with all those stacks!</p>

<p dir="auto">After call to <code>piccolo_init()-&gt;__piccolo_task_init()-&gt;__piccolo_task_init_stack()</code></p>
<div data-snippet-clipboard-copy-content="Main stack (MSP)			
+---------------+
|  R4-R12,LR    |			Saved by __piccolo_task_init_stack(), LR is back to main()
+---------------+"><pre><code>Main stack (MSP)			
+---------------+
|  R4-R12,LR    |			Saved by __piccolo_task_init_stack(), LR is back to main()
+---------------+
</code></pre></div>
<p dir="auto"><code>__piccolo_task_init_stack()</code> switches to using PSP0, the dummy stack from <code>__piccolo_task_init()</code>, and then drops into <code>piccolo_syscall()</code> which raises an SVC interrupt</p>
<div data-snippet-clipboard-copy-content="Dummy stack (PSP0)
+---------------+			Saved by isr_svcall() using r0 which is the address of PSP0
|  R4-R12,LR    |			LR will be 0xFFFFFFFD as this is an exception (interrupt).
+---------------+
|  R0-R3,LR,PC  |			Saved by hardware on PSP0
+---------------+"><pre><code>Dummy stack (PSP0)
+---------------+			Saved by isr_svcall() using r0 which is the address of PSP0
|  R4-R12,LR    |			LR will be 0xFFFFFFFD as this is an exception (interrupt).
+---------------+
|  R0-R3,LR,PC  |			Saved by hardware on PSP0
+---------------+
</code></pre></div>
<p dir="auto">The kernel, that is <code>main()</code>, context is restored from the stack, MSP is now empty
The last instruction is <code>POP {PC}</code> which pops off the LR and causes a jump back to the
kernel, i.e. <code>main()</code></p>
<div data-snippet-clipboard-copy-content="Main stack (MSP)			
+---------------+
+---------------+"><pre><code>Main stack (MSP)			
+---------------+
+---------------+
</code></pre></div>
<p dir="auto">Back in <code>main()</code> now, but the CPU is in handler mode because it has not yet returned from the exception.</p>
<p dir="auto">The dummy stack is discarded and never used again.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">piccolo_create_task(&amp;task1_func)</h3><a id="user-content-piccolo_create_tasktask1_func" aria-label="Permalink: piccolo_create_task(&amp;task1_func)" href="#piccolo_create_tasktask1_func"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Create task1: <code>piccolo_create_task() -&gt; __piccolo_os_create_task()</code></p>
<p dir="auto">Create an initial process stack PSP1 that mimics the stack from an interrupt call:</p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+			As would be saved by software, LR needs to be 0xFFFFFFFD
|  R4-R12,LR    |					
+---------------+			As would be saved by hardware on PSP1
|  R0-R3,LR,PC  |			PC is pointer task function (i.e. task1_func)
+---------------+"><pre><code>Task 1 stack (PSP1)
+---------------+			As would be saved by software, LR needs to be 0xFFFFFFFD
|  R4-R12,LR    |					
+---------------+			As would be saved by hardware on PSP1
|  R0-R3,LR,PC  |			PC is pointer task function (i.e. task1_func)
+---------------+
</code></pre></div>
<p dir="auto">Then call <code>__piccolo_pre_switch(task_stack)</code> using the newly created stack:</p>
<p dir="auto"><code>__piccolo_pre_switch()</code> saves the kernel state on the main stack:</p>
<div data-snippet-clipboard-copy-content="Main stack (MSP)			
+---------------+			Saved by __piccolo_pre_switch(), 
|  R4-R12,LR    |			LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()
+---------------+"><pre><code>Main stack (MSP)			
+---------------+			Saved by __piccolo_pre_switch(), 
|  R4-R12,LR    |			LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()
+---------------+
</code></pre></div>
<p dir="auto">Load the state (the registers) for task1 from the stack created above. The address of that stack is in r0.
Set the PSP register to R0 and then branch to LR. Since LR is 0xFFFFFFFD then this causes the CPU to end
exit handler mode and return to thread mode.</p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+			As would be saved by hardware on PSP1
|  R0-R3,LR,PC  |			PC is pointer task function (i.e. task1_func)
+---------------+"><pre><code>Task 1 stack (PSP1)
+---------------+			As would be saved by hardware on PSP1
|  R0-R3,LR,PC  |			PC is pointer task function (i.e. task1_func)
+---------------+
</code></pre></div>
<p dir="auto">It now restores R0 to R3 and uses the PC to carry on execution using PSP1. PC is the pointer to <code>task1_func()</code>.</p>
<p dir="auto">PSP1 is now empty:</p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+
+---------------+"><pre><code>Task 1 stack (PSP1)
+---------------+
+---------------+
</code></pre></div>

<p dir="auto">Task 1 will run until it calls <code>piccolo_yield()</code>. <code>piccolo_yield()</code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+			Saved by isr_svcall() using r0 which is the address of PSP1
|  R4-R12,LR    |			LR will be 0xFFFFFFFD as this is an exception (interrupt).
+---------------+
|  R0-R3,LR,PC  |			Saved by hardware on PSP1
+---------------+"><pre><code>Task 1 stack (PSP1)
+---------------+			Saved by isr_svcall() using r0 which is the address of PSP1
|  R4-R12,LR    |			LR will be 0xFFFFFFFD as this is an exception (interrupt).
+---------------+
|  R0-R3,LR,PC  |			Saved by hardware on PSP1
+---------------+
</code></pre></div>
<p dir="auto">PSP1 is now ready to be used later to return to Task 1 when needed. Using a similar setup to how Task 1 was created in the first place.</p>
<p dir="auto">Remember the main stack from earlier? It is still intact, as it was:</p>
<div data-snippet-clipboard-copy-content="Main stack (MSP)			
+---------------+			Saved by __piccolo_pre_switch(), 
|  R4-R12,LR    |			LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()
+---------------+"><pre><code>Main stack (MSP)			
+---------------+			Saved by __piccolo_pre_switch(), 
|  R4-R12,LR    |			LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()
+---------------+
</code></pre></div>
<p dir="auto"><code>isr_svcall()</code> restores the kernel state from the main stack and returns to the kernel using the LR. Execution continues in <code>__piccolo_pre_switch()</code>, which eventually returns to
<code>piccolo_create_task()</code> and then <code>main()</code>.</p>
<div dir="auto"><h3 tabindex="-1" dir="auto">piccolo_create_task(&amp;task2_func) and ultimatley piccolo_yield()</h3><a id="user-content-piccolo_create_tasktask2_func-and-ultimatley-piccolo_yield" aria-label="Permalink: piccolo_create_task(&amp;task2_func) and ultimatley piccolo_yield()" href="#piccolo_create_tasktask2_func-and-ultimatley-piccolo_yield"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Task 2 and PSP2 are created in exactly the same way as Task 1. Eventually Task 2 calls <code>piccolo_yield()</code>, then ultimately the execution returns to main(). After all the tasks have been created then <code>piccolo_start()</code> is called.</p>

<p dir="auto"><code>piccolo_start()</code> selects the next task and calls <code>__piccolo_pre_switch()</code> passing the pointer to the PSP. Let&#39;s assume Task 1 is next, so it passed in PSP1.</p>
<p dir="auto">Remember the state of PSP?</p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+			Saved by isr_svcall() using r0 which is the address of PSP1
|  R4-R12,LR    |			LR will be 0xFFFFFFFD as this is an exception (interrupt).
+---------------+
|  R0-R3,LR,PC  |			Saved by hardware on PSP1
+---------------+"><pre><code>Task 1 stack (PSP1)
+---------------+			Saved by isr_svcall() using r0 which is the address of PSP1
|  R4-R12,LR    |			LR will be 0xFFFFFFFD as this is an exception (interrupt).
+---------------+
|  R0-R3,LR,PC  |			Saved by hardware on PSP1
+---------------+
</code></pre></div>
<p dir="auto"><code>__piccolo_pre_switch()</code> saves the kernel state on the main stack:</p>
<div data-snippet-clipboard-copy-content="Main stack (MSP)			
+---------------+			Saved by __piccolo_pre_switch(), 
|  R4-R12,LR    |			LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()
+---------------+"><pre><code>Main stack (MSP)			
+---------------+			Saved by __piccolo_pre_switch(), 
|  R4-R12,LR    |			LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()
+---------------+
</code></pre></div>
<p dir="auto">It then loads the state (the registers) for task1 from PSP1.
It sets the PSP register to R0 and then branches to LR. Since LR is 0xFFFFFFFD then this causes the CPU to end
exit handler mode and return to thread mode.</p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+			Saved by hardware on PSP1
|  R0-R3,LR,PC  |			PC is a pointer to somewhere in the task function, 
+---------------+ 			just after the call to piccolo_yield()"><pre><code>Task 1 stack (PSP1)
+---------------+			Saved by hardware on PSP1
|  R0-R3,LR,PC  |			PC is a pointer to somewhere in the task function, 
+---------------+ 			just after the call to piccolo_yield()
</code></pre></div>
<p dir="auto">It now restores R0 to R3 and uses the PC to carry on execution using PSP1. PC is the pointer to somewhere in the task function, just after the call to <code>piccolo_yield()</code></p>
<p dir="auto">PSP1 is now empty or in whatever state it was before Task 1 called <code>piccolo_yield()</code></p>
<div data-snippet-clipboard-copy-content="Task 1 stack (PSP1)
+---------------+
+---------------+"><pre><code>Task 1 stack (PSP1)
+---------------+
+---------------+
</code></pre></div>
<p dir="auto">Execution continues until <code>piccolo_yield()</code> is called again.</p>

<p dir="auto">At the moment Piccolo OS is co-operative, in that a task will continue to run until <code>piccolo_yield()</code> is called.</p>
<p dir="auto">It should be possible to force a context switch using a timer or an interrupt like SysTick which in turn triggers a PendSV. However, my attempts to implement this have so far failed. I have ported the same code to an STM32 BluePill with a Cortex-M3 and pre-emptive tasking works via SysTick/PendSV.</p>
<p dir="auto">My initial thoughts are that once <code>main()</code> is running in handler mode then the Pico C/C++ SDK doesn&#39;t process interrupts as expected. The &#34;traditional&#34; approach is to set the
interrupt priorities so that the SysTick has a high priority, however my attempts to do that that have so far been without success.</p>
<p dir="auto">More work is needed.</p>

<p dir="auto">I would like to keep this basic version of Piccolo OS intact, as a learning tool. I don&#39;t plan on expanding it, even to including pre-emptive multi-tasking (see above).</p>
<p dir="auto">However, if there is interest then a V2.0 could be started which expands on V1.0 to include pre-emptive multitasking, as well as other things like mutexes, queues, per task memory, etc.</p>
<p dir="auto">If there is interest then I will start a V2.0 repo and start accepting pull requests.</p>
<p dir="auto">Having said that, please feel free to fork and continue working on Piccolo OS as you see fit.</p>

<p dir="auto"><a href="https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf" rel="nofollow">https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf</a></p>
<p dir="auto"><a href="https://raspberrypi.github.io/pico-sdk-doxygen/index.html" rel="nofollow">https://raspberrypi.github.io/pico-sdk-doxygen/index.html</a></p>
<p dir="auto"><a href="https://interrupt.memfault.com/blog/cortex-m-rtos-context-switching" rel="nofollow">https://interrupt.memfault.com/blog/cortex-m-rtos-context-switching</a></p>
<p dir="auto"><a href="https://www.adamh.cz/blog/2016/07/context-switch-on-the-arm-cortex-m0/" rel="nofollow">https://www.adamh.cz/blog/2016/07/context-switch-on-the-arm-cortex-m0/</a></p>
<p dir="auto"><a href="https://chromium.googlesource.com/chromiumos/platform/ec/" rel="nofollow">https://chromium.googlesource.com/chromiumos/platform/ec/</a></p>
<p dir="auto"><a href="https://github.com/n-k/cortexm-threads">https://github.com/n-k/cortexm-threads</a></p>
<p dir="auto"><a href="https://github.com/scttnlsn/cmcm">https://github.com/scttnlsn/cmcm</a></p>
<p dir="auto"><a href="https://github.com/chris-stones/ShovelOS">https://github.com/chris-stones/ShovelOS</a></p>
<p dir="auto"><a href="https://github.com/jserv/mini-arm-os">https://github.com/jserv/mini-arm-os</a></p>
<p dir="auto"><a href="https://stackoverflow.com/questions/48537618/cortex-m0-setting-the-priority-of-the-system-exception" rel="nofollow">https://stackoverflow.com/questions/48537618/cortex-m0-setting-the-priority-of-the-system-exception</a></p>
<p dir="auto"><a href="https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/exception-entry-and-return" rel="nofollow">https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/exception-entry-and-return</a></p>
<p dir="auto"><a href="https://developer.arm.com/documentation/dui0497/a/the-cortex-m0-processor/programmers-model/core-registers" rel="nofollow">https://developer.arm.com/documentation/dui0497/a/the-cortex-m0-processor/programmers-model/core-registers</a></p>
<p dir="auto"><a href="https://github.com/dwelch67/raspberrypi-pico">https://github.com/dwelch67/raspberrypi-pico</a></p>
<p dir="auto"><a href="https://github.com/davidgiven/FUZIX/tree/rpipico/Kernel/platform-rpipico">https://github.com/davidgiven/FUZIX/tree/rpipico/Kernel/platform-rpipico</a></p>
<p dir="auto"><a href="https://archive.fosdem.org/2018/schedule/event/multitasking_on_cortexm/attachments/slides/2602/export/events/attachments/multitasking_on_cortexm/slides/2602/Slides.pdf" rel="nofollow">https://archive.fosdem.org/2018/schedule/event/multitasking_on_cortexm/attachments/slides/2602/export/events/attachments/multitasking_on_cortexm/slides/2602/Slides.pdf</a></p>
<div dir="auto"><h2 tabindex="-1" dir="auto">License - 3-Clause BSD License</h2><a id="user-content-license---3-clause-bsd-license" aria-label="Permalink: License - 3-Clause BSD License" href="#license---3-clause-bsd-license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Copyright (C) 2021, Gary Sims
All rights reserved.</p>
<p dir="auto">SPDX short identifier: BSD-3-Clause</p>

<p dir="auto">Some portions of code, intentionally or unintentionally, may or may not be attributed to the following people:</p>
<p dir="auto">Copyright (C) 2017 Scott Nelson: CMCM - <a href="https://github.com/scttnlsn/cmcm">https://github.com/scttnlsn/cmcm</a></p>
<p dir="auto">Copyright (C) 2015-2018 National Cheng Kung University, Taiwan: mini-arm-os - <a href="https://github.com/jserv/mini-arm-os">https://github.com/jserv/mini-arm-os</a></p>
<p dir="auto">Copyright (C) 2014-2017 Chris Stones: Shovel OS - <a href="https://github.com/chris-stones/ShovelOS">https://github.com/chris-stones/ShovelOS</a></p>
</article></div></div>
  </body>
</html>
