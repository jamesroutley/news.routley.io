<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://veryth.ink/blog/rc-w123-week-four/">Original</a>
    <h1>RC W1&#39;23 | Wk 4/14</h1>
    
    <div id="readability-page-1" class="page"><section><p><em>A summary of my fourth week in Winter 1 &#39;23, a shorter one due to Thanksgiving.</em></p><span id="continue-reading"></span><hr/><p><strong>TLDR;</strong> Got a couple of solid days at RC in before taking somewhat of a break for Thanksgiving. This week I made progress working with Bevy to make a card game interface and spent some time learning about Svelte, the front-end web framework, and I even practiced some Blender sculpting and pixel art animation with Aseprite.</p><hr/><p>After debugging some network issues with my still fresh Arch installation (<strong>Pro-tip:</strong> Don&#39;t run competing network services). I started getting my Bevy developer environment dialed-in, this meant applying the recommended compiler optimizations presented in the official guide. And then I set to work getting my project set up, eventually rendering a single rectangle which would eventually behave like a card, probably?</p><p>After that I paired with someone incredibly knowledgeable in the growing field of AI-safety who was generous enough to spend most of our hour together explaining the fundamentals of NNs, LLMs, as well as going over some calculus concepts my math-deficient brain hadn&#39;t soaked-up. All the while giving me plenty of opportunity to ask questions and come up with my own answers to keep me engaged. Just a really wonderful experience that piqued my interest in the topic. I won&#39;t be pursuing it at this moment though since I have enough going on. Though refreshing myself on calculus got bumped near the top of my growing task list!</p><p>Later, I spent some time rediscovering the joy of writing tiny scripts to accomplish small but common tasks.</p><h2 id="a-fishy-interlude">A fishy interlude</h2><p>I use <a href="https://fishshell.com">Fish</a> as my shell, as I have for about 2 years now, but in all this time I never really took advantage of it. I also manage an ever-growing collection of music locally using a program called <a href="https://beets.io/">Beets</a>, this lets me list and filter my music by a number of fields, among other things. I also use <a href="https://mpv.io"><code>mpv</code></a> for most of my media playback needs. To play my music, I would combine both <code>mpv</code> and <code>beet</code> by running something like <code>mpv (beet ls -p &#39;albumartist:Anamanaguchi&#39;)</code>. Which in summary, tells Beets &#34;I would like paths to all the songs in my library that belong to album-artist Anamanaguchi&#34; which then passes all of those paths to <code>mpv</code> which will happily start playing them in order. This is fine, but there&#39;s got to be <a href="https://media.tenor.com/0RQyqOfqS-sAAAAC/infomercial-help.gif">a better way</a>, right?</p><p>To start solving this minor inconvenience, I made use of the Beets plugin, <a href="https://beets.readthedocs.io/en/v1.6.0/plugins/smartplaylist.html">Smart Playlist</a>. This plugin lets you use queries to generate <code>.m3u</code> playlists, this way I could query for all songs released in a certain year and add that to a playlist, or by a single artist. But this would be tedious to do for every album-artist, thankfully there&#39;s a way to automate even this using beet&#39;s template syntax in the name of the playlist. By simply using the <code>$albumartist.m3u</code> as the name of the playlist, providing an empty query, and running <code>beet splupdate</code>, I ended up with a playlist for each album-artist, containing all of their songs!</p><pre data-lang="yaml"><code data-lang="yaml"><span># ~/.config/beets/config.yaml
</span><span># ...
</span><span>smartplaylist</span><span>:
</span><span>  </span><span>playlist_dir</span><span>: </span><span>~/.config/beets/playlists
</span><span>  </span><span>playlists</span><span>:
</span><span>    - </span><span>name</span><span>: </span><span>all.m3u
</span><span>      </span><span>query</span><span>: &#39;&#39;
</span><span>
</span><span>    - </span><span>name</span><span>: &#39;</span><span>$albumartist.m3u</span><span>&#39;
</span><span>      </span><span>query</span><span>: &#39;&#39;
</span><span># ...
</span></code></pre><p>Now all I had to do was type <code>mpv ~/.config/beets/playlists/Anamanaguchi.m3u</code>, but I knew I could do better! With this in mind I used fish&#39;s <code>funced</code> to create a simple function which would take the playlist title as an argument and use it to form the path to then pass into <code>mpv</code>.</p><pre data-lang="fish"><code data-lang="fish"><span># ~/.config/fish/functions/play_pl.fish
</span><span>function </span><span>play_pl
</span><span>    </span><span>mpv </span><span>--shuffle --no-video </span><span>&#34;</span><span>$</span><span>HOME</span><span>/.config/beets/playlists/</span><span>$</span><span>argv</span><span>.m3u</span><span>&#34;
</span><span>end
</span></code></pre><p>Simple, but effective! But there was something that became evident as I tested/used it. While I could probably memorize what playlists were available to me, it would be nice to have some completions! This led me to learn how to use fish&#39;s <code>complete</code> command and write the following fish script.</p><pre data-lang="fish"><code data-lang="fish"><span># ~/.config/fish/completions/play_pl.fish
</span><span>function </span><span>__autocompletes
</span><span>    </span><span>set </span><span>pl_directory </span><span>$</span><span>HOME</span><span>/.config/beets/playlists/
</span><span>    </span><span>set </span><span>completions </span><span>(</span><span>ls </span><span>$</span><span>pl_directory</span><span>)
</span><span>
</span><span>    </span><span>for </span><span>completion </span><span>in $</span><span>completions
</span><span>        </span><span>echo </span><span>(</span><span>basename </span><span>$</span><span>completion </span><span>&#39;</span><span>.m3u</span><span>&#39;</span><span>)
</span><span>    </span><span>end
</span><span>end
</span><span>
</span><span>complete </span><span>-f -c </span><span>play_pl </span><span>-a </span><span>&#34;</span><span>(__autocompletes)</span><span>&#34;
</span></code></pre><p>And just like that I had tab-complete for every playlist! There was something else bothering me, but this was good enough for now.</p><h2 id="i-also-started-sculpting-a-dragon">I also started sculpting a dragon</h2><p>I promised a friend I would sculpt them a dragon and 3D-print it, but I had been struggling getting my integrated GPU to play nicely with Blender which had been delaying me. But since I had a fresh installation to work with I decided to give it another go and ended up with this.</p><img alt="A low-poly mesh of a dragon&#39;s head" src="https://www.wgbh.org/news/local/2023-11-17/dragon-11-20.png"/><blockquote><p>I wasn&#39;t entirely happy with the way this guy reads, but also not too bad for not having done anything in Blender for some time.</p></blockquote><h2 id="just-a-little-bit-of-yak-shaving">Just a little bit of yak-shaving</h2><p>I started the day by indulging in a bit of yak-shaving, that is, continuing to improve my little playlist fish script. As I alluded to previously, there was one other thing I wanted from this script. I wanted to be able to pass multiple playlists and have them all sampled from collectively. So I thought I could just pass all the playlist paths to <code>mpv</code> and call it a day.</p><pre data-lang="fish"><code data-lang="fish"><span>function </span><span>play_pl
</span><span>    </span><span>set </span><span>playlist_dir &#34;</span><span>$</span><span>HOME</span><span>/.config/beets/playlists</span><span>&#34;
</span><span>    </span><span>set </span><span>selected_playlists </span><span>(</span><span>echo </span><span>&#34;</span><span>$</span><span>argv</span><span>&#34; </span><span>| </span><span>tr </span><span>&#39; &#39; &#39;</span><span>\n</span><span>&#39;</span><span>)
</span><span>    </span><span>set </span><span>playlist_paths
</span><span>
</span><span>    </span><span>for </span><span>pl </span><span>in $</span><span>selected_playlists
</span><span>        </span><span># Append each path to playlist_paths
</span><span>        </span><span>set </span><span>playlist_paths </span><span>$</span><span>playlist_paths </span><span>&#34;</span><span>$</span><span>playlist_dir</span><span>/</span><span>$</span><span>pl</span><span>.m3u</span><span>&#34;
</span><span>    </span><span>end
</span><span>
</span><span>    </span><span>mpv </span><span>--shuffle --no-video </span><span>$</span><span>playlist_paths
</span><span>
</span><span>end
</span></code></pre><p>I started rolling with this when I realized that while the music was being shuffled, it was only from one playlist! As it turned out, passing multiple playlist files, <code>mpv</code> will play each in sequence. My first thought was to concatenate the contents of all the playlist files into one temporary file and then pass that to <code>mpv</code> instead. Turns out that was a pretty good idea.</p><pre data-lang="fish"><code data-lang="fish"><span>function </span><span>play_pl
</span><span>    </span><span>set </span><span>playlist_dir &#34;</span><span>$</span><span>HOME</span><span>/.config/beets/playlists</span><span>&#34;
</span><span>    </span><span># Make a temporary (/tmp) file 
</span><span>    </span><span>set </span><span>playlist_contents </span><span>(</span><span>mktemp</span><span>)
</span><span>
</span><span>    </span><span>for </span><span>pl </span><span>in $</span><span>argv
</span><span>        </span><span># Append the contents of each playlist to the temporary file
</span><span>        </span><span>cat </span><span>&#34;</span><span>$</span><span>playlist_dir</span><span>/</span><span>$</span><span>pl</span><span>.m3u</span><span>&#34; </span><span>&gt;&gt; $</span><span>playlist_contents
</span><span>    </span><span>end
</span><span>    </span><span># Using the --playlist flag forces mpv to parse the file as a .m3u file
</span><span>    </span><span>mpv </span><span>--shuffle --no-video --playlist=</span><span>$</span><span>playlist_contents
</span><span>    </span><span># Might as well clean up after ourselves
</span><span>    </span><span>rm </span><span>$</span><span>playlist_contents
</span><span>end
</span></code></pre><p>Finally, this script worked the way I wanted to and I could move on to other things.</p><h2 id="back-to-bevy">Back to Bevy</h2><p>I had a basic Bevy project set up and was rendering a single rectangle now it was time to start getting something resembling a card interface working. The first goal was to figure out how to translate the mouse pointer from the window position to the world position. Once I got that figured out the next goal was to have the rectangle simply follow my mouse.</p><img alt="A white rectangle against a black background following a mouse pointer" src="https://www.wgbh.org/news/local/2023-11-17/bevy-card-1.gif"/><blockquote><p>Success!</p></blockquote><p>You can check out the source <a href="https://github.com/ChrisRenfrow/bevy-cards/commit/c8f5857e63e78d18bb53a9e1b1295d5f8d568fa2">here</a>, but the core of this simple functionality lies in this system:</p><pre data-lang="rs"><code data-lang="rs"><span>fn </span><span>move_cards</span><span>(
</span><span>    </span><span>time</span><span>: Res&lt;Time&gt;,
</span><span>    </span><span>mut </span><span>q_card</span><span>: Query&lt;</span><span>(</span><span>&amp;</span><span>mut</span><span> Transform, </span><span>&amp;</span><span>Card</span><span>)</span><span>&gt;,
</span><span>    </span><span>q_win</span><span>: Query&lt;</span><span>&amp;</span><span>Window, With&lt;PrimaryWindow&gt;&gt;,
</span><span>    </span><span>q_cam</span><span>: Query&lt;</span><span>(</span><span>&amp;</span><span>Camera, </span><span>&amp;</span><span>GlobalTransform</span><span>)</span><span>, With&lt;MainCamera&gt;&gt;,
</span><span>) {
</span><span>    </span><span>let </span><span>(</span><span>cam, cam_transform</span><span>) =</span><span> q_cam.</span><span>single</span><span>()</span><span>;
</span><span>    </span><span>let</span><span> window </span><span>=</span><span> q_win.</span><span>single</span><span>()</span><span>;
</span><span>    </span><span>if </span><span>let </span><span>Some</span><span>(</span><span>world_pos</span><span>) =</span><span> window
</span><span>        .</span><span>cursor_position</span><span>()
</span><span>        .</span><span>and_then</span><span>(|</span><span>cursor</span><span>| </span><span>cam.</span><span>viewport_to_world</span><span>(</span><span>cam_transform, cursor</span><span>))
</span><span>        .</span><span>map</span><span>(|</span><span>ray</span><span>| </span><span>ray.origin.</span><span>truncate</span><span>())
</span><span>    </span><span>{
</span><span>        </span><span>for </span><span>(</span><span>mut</span><span> card_transform, </span><span>_</span><span>) </span><span>in &amp;</span><span>mut</span><span> q_card </span><span>{
</span><span>            card_transform.translation.y </span><span>=</span><span> world_pos.y;
</span><span>            card_transform.translation.x </span><span>=</span><span> world_pos.x;
</span><span>        </span><span>}
</span><span>    </span><span>}
</span><span>}
</span></code></pre><h2 id="learning-svelte">Learning Svelte</h2><p>I started working through the <a href="https://learn.svelte.dev/">official Svelte tutorial</a> over the weekend and stopped at the &#34;Advanced Svelte&#34; section. Today I resumed where I left off and got through the first half of that section, which most notably covered the component composition features of Svelte, such as Slots.</p><p>Today RC faculty had gone on vacation for Thanksgiving for the remainder of the week and a number of recursers it seemed had followed suit. I chose to treat the remainder of my week more or less the same as I would have normally but perhaps a little more quietly.</p><h2 id="bevy-what-a-drag">Bevy, what a drag!</h2><p>I decided to continue working on my Bevy card interface, today I made it possible to drag cards around! I think today the Entity Component System finally &#34;clicked&#34; for me. I found an older <a href="https://stackoverflow.com/questions/65396065/what-is-an-acceptable-approach-to-dragging-sprites-with-bevy-0-4">Stack Overflow</a> question regarding dragging sprites around and I used that as a jumping-off point to make my cards draggable.</p><img alt="Two rectangles against a black background, one grey and one white, the white one is draggable and the grey one is not" src="https://www.wgbh.org/news/local/2023-11-17/bevy-card-2.gif"/><blockquote><p>One non-draggable card, and one very much draggable card!</p></blockquote><p>By adding marker components like <code>Draggable</code>, <code>Hoverable</code>, <code>Dragged</code> and <code>Hovered</code>, I was able to define systems that would handle adding and removing these components under the correct conditions, enabling the behavior you see above!</p><p>Here is <a href="https://github.com/ChrisRenfrow/bevy-cards/commit/6367efe281a736ea9e4160655de939401842ba9e">the commit</a> so you can see what changed.</p><h2 id="speaking-of-dragon">Speaking of dragon</h2><p>I also did some more sculpting, the issues that made it difficult to use Blender in the first place began manifesting again. I achieved this by compulsively saving after every major modification.</p><img alt="A low poly dragon mesh, but this time it has eyes and is a little more detailed" src="https://www.wgbh.org/news/local/2023-11-17/dragon-11-22.png"/><blockquote><p>Now with eyeballs and teeth!</p></blockquote><p>Today was Thanksgiving Day and while we didn&#39;t have plans to travel we did decide to do a small dinner, so I helped with that. But before we started I was deciding how to best handle animating flipping cards in my Bevy card interface. The options were to use Aseprite to animate the flip, or use some kind of texture transformation in-engine. I decided I would try both and started with the Aseprite method.</p><img alt="A pixelated card with a blank side and a back spinning endlessly" src="https://www.wgbh.org/news/local/2023-11-17/card-flip.gif"/><blockquote><p>Spinny!</p></blockquote><p>I didn&#39;t do much today aside from trying to sort out the issues I was having with Blender regarding my integrated graphics. Apparently the issues I was having were common with the Intel CPU I had on-board, so I had to make use of my discrete GPU instead. After a short session with Blender it seemed like the problem had been resolved!</p><p>A short and somewhat quiet week but overall still productive. I was still able to move toward my batch goals and made time for art practice!</p></section></div>
  </body>
</html>
