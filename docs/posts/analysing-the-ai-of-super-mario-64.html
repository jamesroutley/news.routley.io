<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gamedeveloper.com/blogs/analysing-the-ai-of-super-mario-64">Original</a>
    <h1>Analysing the AI of Super Mario 64</h1>
    
    <div id="readability-page-1" class="page"><p><strong><em>&#39;AI and Games&#39; is a crowdfunded YouTube series that explores research and applications of artificial intelligence in video games.  You can support this work by visiting my <a href="http://www.patreon.com/ai_and_games">Patreon </a>page.</em></strong></p><p>Super Mario 64, it’s one of the most important and beloved videogames ever made. It set the standard 3D games at a critical phase in the industry. Not just influencing titles on the Nintendo 64, but subsequent releases on many a competing platform.</p><p>But how did it actually work? Is there anything interesting happening in the minds of the Goombas, Koopas and other enemies we find idling around Bob-Omb mountain, Whomp’s Fortress, and Tick Tock Clock? Well, let’s find out.</p><div>
<h2 id="cracking-open-the-hood">Cracking open the Hood</h2>

<p><em>Super Mario 64</em><span> </span>is now over 25 years old, and while the AI may be quite simple, it’s important to recognise what this game represents. It’s a pivotal point in the history of game development. It is the top-selling title of the Nintendo 64 and is reflective of a time when game development was migrating to 3D. It had a huge influence on how three-dimensional games were designed. While it wasn’t the first 3D platformer, nor even the first 3D title made by Nintendo,<span> </span><em>Super Mario 64</em>‘s legacy cannot be understated, with designers such as Tim Schaeffer and Michael John outright stating the huge influence it had on projects of their own such as<span> </span><em>Psychonauts<span> </span></em>and<span> </span><em>Spyro the Dragon</em><span> </span>respectively. While areas such as camera controls would merit further iteration, aspects of visual design, character animation, player movement, level and mission construction set the template for many other games to follow.</p>

<p>While the AI is undoubtedly rudimentary, it’s worth analysing to see how Nintendo went about structuring and designing behaviour. To make this happen, I downloaded<span> </span><a data-id="https://github.com/n64decomp/sm64" data-type="URL" href="https://github.com/n64decomp/sm64" rel="noreferrer noopener" target="_blank">the Mario 64 decompilation hosted on GitHub</a>. This project was first published back in 2019 and is just one of a number of works from a community of hobbyist decompilers who take it upon themselves to reverse engineer the raw binary of the ROM file into parsable, legible code in the C programming language. So what I’m covering is based not on the original source by Nintendo themselves, but the reversed engineered code that is publically accessible and designed to be as close to the original as possible.</p>



<p>
        <picture>
        <source type="image/webp" media="(max-width: 576px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt510c7a46ee9d9cdb/621680e7ba1c6a10726d921f/Mario_64_Bowser.png?width=480&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(max-width: 767px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt510c7a46ee9d9cdb/621680e7ba1c6a10726d921f/Mario_64_Bowser.png?width=768&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt510c7a46ee9d9cdb/621680e7ba1c6a10726d921f/Mario_64_Bowser.png?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/jpeg" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt510c7a46ee9d9cdb/621680e7ba1c6a10726d921f/Mario_64_Bowser.png?width=828&amp;quality=80&amp;format=jpg&amp;disable=upscale"/>
        <img data-image="4s80jneag7oa" src="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt510c7a46ee9d9cdb/621680e7ba1c6a10726d921f/Mario_64_Bowser.png?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale" data-sys-asset-uid="blt510c7a46ee9d9cdb" alt="Mario 64 Bowser.png"/>
        </picture>
        </p>


<p>The decompiled source code, once properly configured, allows you to compile the ROM file for each regional version of the final game (Japan, US and Europe). However, in order to create a fully playable game, you still need a copy of the original game ROM, given this project only contains community-written source code. It doesn’t have any of the in-game assets. Meaning you can’t just compile it and<span> </span><em>voila</em>: free copy of the game.</p>

<h2 id="objects-behaviours">Objects &amp; Behaviours</h2>

<p>The first thing you need to understand about how Mario 64’s code is broken up, is that pretty much every single element in the world, outside of the level geometry, is considered an<span> </span><strong>object</strong>. And then most game objects can then have a<span> </span><strong>behaviour<span> </span></strong>attached to them as well.</p>

<p>Behaviours enable a variety of common functions, be it to spawn an object at the location such as a coin, make the object fall as a result of an interaction, customise the hitbox for collisions between in-game objects, turn to face the camera when prompted, disable the renderer because its destroyed and much more. Behaviour scripts are not exclusive to AI characters: moving platforms, doors, coins, fireballs, shockwaves, and even some trees and butterflies are considered to have behaviours, given they all respond to the game world in some form or another as a result of interactions or the passing of time.</p>

<p>But all objects that carry Behaviour Scripts have two main functions, their<span> </span><em>begin()</em><span> </span>function and their<span> </span><em>update()</em><span> </span>function. These do two very specific things, begin() is responsible for configuring this object for the game now that it has spawned in, while update() handles the behaviour of the object for each tick or frame of the game. Mario 64 typically ran it around 30 frames per second, with some of the most intense parts of the game running at around 20 frames. So while begin() is only called the first frame the object exists, update() is called every frame afterwards. If you’re a game developer yourself, then this will all sound very familiar to you, given the likes of Unity and Unreal engine have a similar structure.</p>

<p>The<span> </span><em>update()</em><span> </span>function handled the execution of common behaviour commands for each object type, unit movement along the x and z-axis, as well as on the y-axis, compensating for gravity. Plus it pays attention to all the logic for managing timers for actions, whether the object had switched from one action to another, all of which is a crudely implemented finite state machine, largely derived from conditional branches in the code. But the most important thing, given it’s literally the first bit of computation each object does, is checks where Mario is relative to it.</p><p>
        <picture>
        <source type="image/webp" media="(max-width: 576px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/bltefaf0eef5112e01f/62167f8fafbfe87d1cbeee74/Mario64-Haunted.png?width=480&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(max-width: 767px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/bltefaf0eef5112e01f/62167f8fafbfe87d1cbeee74/Mario64-Haunted.png?width=768&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/bltefaf0eef5112e01f/62167f8fafbfe87d1cbeee74/Mario64-Haunted.png?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/jpeg" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/bltefaf0eef5112e01f/62167f8fafbfe87d1cbeee74/Mario64-Haunted.png?width=828&amp;quality=80&amp;format=jpg&amp;disable=upscale"/>
        <img data-image="6fpnrvau15vp" src="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/bltefaf0eef5112e01f/62167f8fafbfe87d1cbeee74/Mario64-Haunted.png?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale" data-sys-asset-uid="bltefaf0eef5112e01f" alt="Mario 64 Haunted House.png"/>
        </picture>
        </p>



<p>The first two calculations of each object with a behaviour script are to figure out the distance from Mario and the angle required to turn and face him. This is used for a variety of AI features, which we’ll see shortly. But it’s also used critically for the rendering of in-game objects. Every behaviour-driven object in Super Mario 64 decides based on its proximity to Mario whether it should render or not. Each has its own drawing distance parameter, and every frame it checks to see if Mario is now farther away than the draw distance, at which point it tells the renderer for that object to disable itself. Interestingly I couldn’t find evidence to suggest that the behaviours don’t execute when Mario is too far away.</p>

<p>The one exception to this is if it’s in a room. Mario levels are built either as open spaces, such as Bob-Omb Battlefield, or they’re comprised of multiple rooms. The three notable examples of this are of course Peach’s Castle, but also Big Boo’s Haunt and Hazy Maze Cave. In these instances, the object will only render when Mario is in the same room. And in fact, a lot of behaviour scripts are also only activated when Mario is in that room as well.</p>

<p>Now outside of the main behaviour functions, an object would also carry a pointer to a separate behaviour command script. These scripts are written for more bespoke elements of the game, and allow for the execution of the bulk of the game’s interactions and behavioural logic. There are over 500 of these in the game, and range from everything like specific NPC behaviours, to the triggering of red coin collections, activating traps, even ending the level by collecting the power star.</p>

<p>But on top of all this, there are hitboxes that dictate how Mario interacts with objects If you’re not familiar with the idea, the hitbox helps tell the game logic that the two game objects are interacting and with a bit of logic, we can make it so that the depending on the context, different stuff happens. Like Mario killing an enemy, or the enemy hurting the player. Interestingly, pretty much all enemies in Mario 64 have two hitboxes and they’re both cylindrical. The standard object hitbox for a lot of in-game collisions and logic, but also the<span> </span><em>hurtbox</em>, which is exclusively for situations where Mario will get hurt. Most NPCs use the hurtbox, and it is often a different height and radius compared to the regular one. However, there are some exceptions to this, notably Koopa the Quick, who doesn’t use the hurtbox given he just pushes by you rather than actually triggering damage upon collision.</p>

<h2 id="npc-design">NPC Design</h2>

<p>Like the main behaviour script, the separate behaviour actions used by NPCs have their own<span> </span><em>begin()</em><span> </span>and<span> </span><em>update()</em><span> </span>functions. I’m going to walk through some of the interesting stuff that I found in there.</p>

<p>As mentioned already, all game objects compute their distance and angle relative to Mario for rendering, but also many of the NPC use this for their core logic. Those who have played the game will have noticed this, given the likes of Koopas and Goombas react to Mario’s presence.</p>

<p>But on top of this, many of them record their ‘<em>home</em>‘. This is a location in the game world that is, meaning they store a reference to where they spawned into the map, or very close to it. This is used so that the NPC knows roughly where in the world it appeared when the level loaded in.</p>

<p>It’s worth mentioning that NPCs in Mario 64 can’t compute on the likes of a navigation mesh to figure out how to move around the world. Because, well, there isn’t one – and what we now consider a navmesh in game engines didn’t exist until Quake III Arena in 1999. Instead, NPCs such as the Goomba and Koopa Troopa will wander around, with fixed rules on how far they go before changing distance and often rotating in fixed angles. You’ll note that they stay on the surface they started on the majority of the time, and a lot of Mario 64’s levels aren’t filled with clutter, meaning it’s harder for them to get stuck behind obstacles. There’s only a handful of enemies that will ever move across platforms but that’s largely due to dumb luck from jumping, or they fly around than anything happening at a code level.</p><p>
        <picture>
        <source type="image/webp" media="(max-width: 576px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt1c6ace62f50b5a07/62167fc8ffee157ecc8b6652/Mario64-Whomp.png?width=480&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(max-width: 767px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt1c6ace62f50b5a07/62167fc8ffee157ecc8b6652/Mario64-Whomp.png?width=768&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt1c6ace62f50b5a07/62167fc8ffee157ecc8b6652/Mario64-Whomp.png?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/jpeg" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt1c6ace62f50b5a07/62167fc8ffee157ecc8b6652/Mario64-Whomp.png?width=828&amp;quality=80&amp;format=jpg&amp;disable=upscale"/>
        <img data-image="w0nb6hnwxlxn" src="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt1c6ace62f50b5a07/62167fc8ffee157ecc8b6652/Mario64-Whomp.png?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale" data-sys-asset-uid="blt1c6ace62f50b5a07" alt="Mario 64 Whomp.png"/>
        </picture>
        </p>



<p>But as they move around, they often pay attention to two things. The first is whether they’re going to collide with walls, in which case they will turn away from them. But how does it know it’s facing a wall? There are functions that allow for them to resolve collisions based on their current heading, and often there’s some wriggle room there. The same applies for when they are looking at Mario, given it’s not based on their exact heading (given that’s too precise), but whether within some range of their heading that the object is in front of them. In some instances, notably the Goomba, a character will simply react to Mario being within a certain distance of them, regardless of heading.</p>

<p>The second key fact they focus on is how far away from home they are. Each NPC has different rules on how far away from home they’re allowed to go, and whether it’s the total distance from home (which is the logic used by a Goomba and Koopa) or if the distance on a specific axis has been reached (which is used by Bob-Omb) or in the case of the Boo, whether it falls within a radius of their origin (calculated using their X and Z movement). In any case, the general rule is that they will turn around, face towards home and start wandering back in that direction. But in some cases, notably Bob-Omb and the Bully, they only return back home if it’s deemed safe, which is determined by whether Mario is currently in proximity of their home location.</p>

<p>And it’s this logic that encapsulates most characters, but they all have their own unique caveats. Goombas make hard turns away from walls and double back to home if their total distance is too far away. Then they will chase Mario if he’s too close, regardless of angle, at around 500 units. With chases always pre-empted by a jump. For reference: distance units almost map directly to in-world centimetres. Given Mario is 161 units tall in the game, and is also – according to the Mario wiki – 155cm tall. So when we say within 500 units for the Goomba, it’s just shy of 5 meters.</p><p>
        <picture>
        <source type="image/webp" media="(max-width: 576px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt6b680fec0d65460b/62167fecfcf3a2107981f70b/Mario64-Goomba.jpeg?width=480&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(max-width: 767px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt6b680fec0d65460b/62167fecfcf3a2107981f70b/Mario64-Goomba.jpeg?width=768&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/webp" media="(min-width: 768px)" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt6b680fec0d65460b/62167fecfcf3a2107981f70b/Mario64-Goomba.jpeg?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale"/>
        <source type="image/jpeg" srcset="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt6b680fec0d65460b/62167fecfcf3a2107981f70b/Mario64-Goomba.jpeg?width=828&amp;quality=80&amp;format=jpg&amp;disable=upscale"/>
        <img data-image="80jnjgz0dff9" src="https://eu-images.contentstack.com/v3/assets/blt95b381df7c12c15d/blt6b680fec0d65460b/62167fecfcf3a2107981f70b/Mario64-Goomba.jpeg?width=828&amp;quality=80&amp;format=webply&amp;disable=upscale" data-sys-asset-uid="blt6b680fec0d65460b" alt="Mario 64 Goomba.jpeg"/>
        </picture>
        </p>



<p>Meanwhile, Koopa Troopas have a similar logic, albeit they run away from Mario within 300 units. The interesting part in the Koopa logic is that once you jump on them, they can lose their shell. In general, they will try to run back to their shell, but quite often Mario is too close and forces them to run away. However, if the shell is close enough, despite Mario also being close, it will take the gamble and try and dive back into its shell.</p>

<p>As mentioned Bob-Ombs patrol based on how far away on any axis they’ve travelled from their home. Although to be fair it’s difficult for them to ever go anywhere of distance without subsequently blowing themselves up. But unlike enemies such as Goombas, when a bob-omb dies, it triggers a respawner in the code, that will create a brand new bob-omb where the last one appeared after Mario has safely left the area.</p>

<p>Meanwhile, other enemies like Whomps check their distance from home and compares that against a predefined patrol distance. This is then configured on a per-level basis. In the case of Whomp, it has the same patrol distance for all levels, with exception of Bowser in the Sky, which is much much shorter.</p>

<p>Heave-Ho’s that appear in Tick Tock Clock and Wet Dry World also exploit the home and Mario locations, but in a slightly different way: in this case the Heave Ho records its home location on start. But once Mario gets within a certain range of home, then it starts homing in on you.</p>

<p>Now I can’t possibly talk about Mario 64 and not mention the fish! The fish spawn in two variations, blue and cyan. Plus the schools of fish that spawn come in two variations: the large school of 20 fish, and the smaller school of 5 fish. Fish when spawned in start with different starting speeds (given a little bit of random noise is added), plus their height in the water is also varied to make sure they’re not all clumped too close together.</p>

<p>The fish themselves have a pretty simple set of behaviour, they dive and ascend, turn a fixed angle plus some random noise, and then make sure they turn back. Their height is typically capped such that they can’t get close to the water surface, with a strong negative vertical speed applied if they get too close. The one exception to this is the Secret Aquarium because there is no water surface in that level.</p>

<p>To make sure they don’t wade too far from their origin, fish can only move within a fixed range of around 700 units. But also the school usually spawns somewhere between 1500 and 2000 units of Mario being in the map. So, 700 units mean the fish only really swim in a range of just shy of 7 meters. And the fish spawn around 15-20 meters away from Mario. Plus, all fish will react to Mario being in the water. When Mario is less than 150 units away, they turn to be pointing away from Mario, and all of them speed up. Setting a standard that the games industry would continue to follow, for many years to come.</p>

<p>For more quirky facts, be sure to check out the ‘speed round’ segment of the YouTube video.</p>

<h2 id="closing">Closing</h2>

<p>Given this was the 64th episode of the YouTube series, it made sense to make this all about Super Mario 64. For more Nintendo 64 analysis, consider my writings on the AI of Goldeneye 007. Plus, if you enjoy these episodes where I crack open the source code, be sure to check out my work on the AI of<span> </span><a data-id="https://www.gamedeveloper.com/design/exploring-the-ai-of-command-conquer" data-type="URL" href="https://www.gamedeveloper.com/design/exploring-the-ai-of-command-conquer" rel="noreferrer noopener" target="_blank">Command and Conquer</a>,<span> </span><a data-id="https://www.youtube.com/watch?v=JyF0oyarz4U" data-type="URL" href="https://www.youtube.com/watch?v=JyF0oyarz4U" rel="noreferrer noopener" target="_blank">Half-Life</a><span> </span>and<span> </span><a data-id="https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning" data-type="URL" href="https://www.gamedeveloper.com/design/building-the-ai-of-f-e-a-r-with-goal-oriented-action-planning" rel="noreferrer noopener" target="_blank">FEAR</a>. </p></div></div>
  </body>
</html>
