<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scottaaronson.blog/?p=2725">Original</a>
    <h1>The 8000th Busy Beaver number eludes ZF set theory (2016)</h1>
    
    <div id="readability-page-1" class="page"><div>
				<p>I’ve supervised a lot of great student projects in my nine years at MIT, but my inner nerdy teenager has never been as <em>personally</em> delighted by a project as it is right now.  Today, I’m proud to announce that Adam Yedidia, a PhD student at MIT (but an MEng student when he did most of this work), has explicitly constructed a one-tape, two-symbol Turing machine with 7,918 states, whose behavior (when run on a blank tape) can never be proven from the usual axioms of set theory, under reasonable consistency hypotheses.  Adam has also constructed a 4,888-state Turing machine that halts iff there’s a counterexample to Goldbach’s Conjecture, and a 5,372-state machine that halts iff there’s a counterexample to the Riemann Hypothesis.  In all three cases, this is the first time we’ve had a reasonable explicit upper bound on how many states you need in a Turing machine before you can see the behavior in question.</p>
<p><a href="http://www.scottaaronson.com/busybeaver.pdf">Here’s our research paper</a>, on which Adam generously included me as a coauthor, even though he did the heavy lifting.  Also, <a href="https://github.com/adamyedidia/parsimony">here’s a github repository</a> where you can download all the code Adam used to generate these Turing machines, and even use it to build your own small Turing machines that encode interesting mathematical statements.  Finally, <a href="https://www.youtube.com/watch?v=Rt_SfOkk0YM">here’s a YouTube video</a> where Adam walks you through how to use his tools.</p>
<p>A more precise statement of our main result is this: we give a 7,918-state Turing machine, called Z (and actually explicitly listed in our paper!), such that:</p>
<ol>
<li>Z runs forever, assuming the consistency of a large-cardinal theory called SRP (Stationary Ramsey Property), but</li>
<li>Z can’t be <em>proved</em> to run forever in ZFC (Zermelo-Fraenkel set theory with the Axiom of Choice, the usual foundation for mathematics), assuming that ZFC is consistent.</li>
</ol>
<p>A bit of background: it follows, as an immediate consequence of Gödel’s Incompleteness Theorem, that there’s <em>some</em> computer program, of <em>some</em> length, that eludes the power of ordinary mathematics to prove what it does, when it’s run with an unlimited amount of memory.  So for example, such a program could simply enumerate all the possible consequences of the ZFC axioms, one after another, and halt if it ever found a contradiction (e.g., a proof of 1+1=3).  Assuming ZFC is consistent, this program must run forever.  But again assuming ZFC is consistent, ZFC can’t <em>prove</em> that the program runs forever, since if it did, then it would prove its own consistency, thereby violating the Second Incompleteness Theorem!</p>
<p>Alas, this argument still leaves us in the dark about <em>where</em>, in space of computer programs, the “Gödelian gremlin” rears its undecidable head.  A program that searches for an inconsistency in ZFC is a fairly complicated animal: it needs to encode not only the ZFC axiom schema, but also the language and inference rules of first-order logic.  Such a program might be thousands of lines long if written in a standard programming language like C, or millions of instructions if compiled down to a bare-bones machine code.  You’d certainly never run across such a program by chance—not even if you had a computer the size of the observable universe, trying one random program after another for billions of years in a “primordial soup”!</p>
<p>So the question stands—a question that strikes me as <em>obviously</em> important, even though as far as I know, only one or two people ever asked the question before us; <a href="http://mathoverflow.net/questions/62859/simpler-statements-equivalent-to-conpa-or-conzfc">see here</a> for example.  Namely: do the axioms of set theory suffice to analyze the behavior of every computer program that’s at most, let’s say, 50 machine instructions long?  Or are there super-short programs that <em>already</em> exhibit “Gödelian behavior”?</p>
<p>Theoretical computer scientists might object that this is “merely a question of constants.”  Well yes, OK, but the origin of life in our universe—a not entirely unrelated puzzle—is also “merely a question of constants”!  In more detail, we know that it’s <em>possible</em> with our laws of physics to build a self-replicating machine: say, DNA or RNA and their associated paraphernalia.  We also know that tiny molecules like H<sub>2</sub>O and CO<sub>2</sub> are not self-replicating.  But we don’t know <em>how small</em> the smallest self-replicating molecule can be—and that’s an issue that influences whether we should expect to find ourselves alone in the universe or find it teeming with life.</p>
<p>Some people might also object that what we’re asking about has already been studied, in the half-century quest to design the <a href="https://en.wikipedia.org/wiki/Universal_Turing_machine#Smallest_machines">smallest universal Turing machine</a> (the subject of <a href="https://en.wikipedia.org/wiki/Wolfram%27s_2-state_3-symbol_Turing_machine">Stephen Wolfram’s $25,000 prize</a> in 2007, to which I responded with my own <a href="https://scottaaronson.blog/?p=284">$25.00 prize</a>).  But I see that as fundamentally different, for the following reason.  A universal Turing machine—that is, a machine that simulates any other machine that’s described to it on its input tape—has the privilege of offloading almost all of its complexity onto the description format for the input machine.  So indeed, that’s exactly what all known tiny universal machines do!  But a program that checks (say) Goldbach’s Conjecture, or the Riemann Hypothesis, or the consistency of set theory, on an initially blank tape, has no such liberty.  For such machines, the number of states really <em>does</em> seem like an intrinsic measure of complexity, because the complexity can’t be shoehorned anywhere else.</p>
<p>One can also phrase what we’re asking in terms of the infamous <a href="https://en.wikipedia.org/wiki/Busy_beaver">Busy Beaver function</a>.  Recall that BB(n), or the n<sup>th</sup> Busy Beaver number, is defined to be the maximum number of steps that any n-state Turing machine takes when run on an initially blank tape, assuming that the machine eventually halts. The Busy Beaver function was the centerpiece of my 1998 essay <a href="http://www.scottaaronson.com/writings/bignumbers.html">Who Can Name the Bigger Number?</a>, which <i>might</i> still attract more readers than anything else I’ve written since. As I stressed there, if you’re in a biggest-number-naming contest, and you write “BB(10000),” you’ll <em>destroy</em> any opponent—however otherwise mathematically literate they are—who’s innocent of computability theory.  For BB(n) grows faster than any computable sequence of integers: indeed, if it didn’t, then one could use that fact to solve the halting problem, contradicting Turing’s theorem.</p>
<p>But the BB function has a second amazing property: namely, it’s a perfectly well-defined integer function, and yet once you fix the axioms of mathematics, only finitely many values of the function can ever be <em>proved</em>, even in principle.  To see why, consider again a Turing machine M that halts if and only if there’s a contradiction in ZF set theory.  Clearly such a machine could be built, with some finite number of states k.  But then ZF set theory can’t possibly determine the value of BB(k) (or BB(k+1), BB(k+2), etc.), unless ZF is inconsistent!  For to do so, ZF would need to prove that M ran forever, and therefore prove its own consistency, and therefore be inconsistent by Gödel’s Theorem.</p>
<p>OK, but we can now ask a quantitative question: <em>how many</em> values of the BB function is it possible for us to know?  Where exactly is the precipice at which this function “departs the realm of mortals and enters the realm of God”: is it closer to n=10 or to n=10,000,000?  In practice, <em>four</em> values of BB have been determined so far:</p>
<ul>
<li>BB(1)=1</li>
<li>BB(2)=6</li>
<li>BB(3)=21 (Lin and Rado 1965)</li>
<li>BB(4)=107 (Brady 1975)</li>
</ul>
<p>We also know some lower bounds:</p>
<ul>
<li>BB(5) ≥ 47,176,870 (Marxen and Buntrock 1990)</li>
<li>BB(6) ≥ 7.4 × 10<sup>36,534</sup> (Kropitz 2010)</li>
<li>$$BB(7)\gt 10^{10^{10^{10^{10^{7}}}}}$$ (<a href="http://googology.wikia.com/wiki/User_blog:Wythagoras/A_good_bound_for_S(7)%3F">“Wythagoras” 2014</a>)</li>
<li>BB(23) &gt; <a href="https://en.wikipedia.org/wiki/Graham%27s_number">Graham’s number</a> (a famous huge number from Ramsey theory, obtained by iterating the Ackermann function 64 times) (<a href="http://googology.wikia.com/wiki/User_blog:Deedlit11/Okay,_more_Turing_machines">“Deedlit” and “Wythagoras” 2013</a>)</li>
</ul>
<p>See <a href="http://www.drb.insel.de/~heiner/BB/">Heiner Marxen’s page</a> or the <a href="http://googology.wikia.com/wiki/Googology_Wiki">Googology Wiki</a> (which somehow I only learned about today) for more information.</p>
<p>Some Busy Beaver enthusiasts have opined that even BB(6) will never be known exactly.  On the other hand, the abstract argument from before tells us only that, if we confine ourselves to (say) ZF set theory, then there’s <em>some</em> k—possibly in the tens of millions or higher—such that the values of BB(k), BB(k+1), BB(k+2), and so on can never be proven.  So again: is the number of knowable values of the BB function more like 10, or more like a million?</p>
<p>This is the question that Adam and I (but mostly Adam) have finally addressed.</p>
<p>It’s hopeless to design a Turing machine by hand for all but the simplest tasks, so as a first step, Adam created a new programming language, called Laconic, specifically for writing programs that compile down to small Turing machines.  Laconic programs actually compile to an intermediary language called TMD (Turing Machine Descriptor), and from there to Turing machines.</p>
<p>Even then, we estimate that a direct attempt to write a Laconic program that searched for a contradiction in ZFC would lead to a Turing machine with millions of states.  There were three ideas needed to get the state count down to something reasonable.</p>
<p>The first was to take advantage of the <a href="https://u.osu.edu/friedman.8/foundational-adventures/publications/">work of Harvey Friedman</a>, who’s one of the one or two people I mentioned earlier who’s written about these problems before.  In particular, Friedman has been laboring since the 1960s to find “natural” arithmetical statements that are provably independent of ZFC or other strong set theories.  (See <a href="http://www.ams.org/notices/200604/fea-davis.pdf">this <em>AMS Notices</em> piece</a> by Martin Davis for a discussion of Friedman’s progress as of 2006.)  Not only does Friedman’s quest continue, but some of his most important progress has come only within the last year.  His statements—typically involving objects called “order-invariant graphs”—strike me as alien, and as far removed from anything I’d personally have independent reasons to think about (but is that just a sign of my limited perspective?).  Be that as it may, Friedman’s statements <em>still</em> seem a lot easier to encode as short computer programs than the full apparatus of first-order logic and set theory!  So that’s what we started with; our work wouldn’t have been possible without Friedman (who we consulted by email throughout the project).</p>
<p>The second idea was something we called “on-tape processing.”  Basically, instead of compiling directly from Laconic down to Turing machine, Adam wrote an <em>interpreter</em> in Turing machine (which took about 4000 states—a single, fixed cost), and then had the final Turing machine first write a higher-level program onto its tape and then interpret that program.  Instead of the compilation process producing a huge multiplicative overhead in the number of Turing machine states (and a repetitive machine), this approach gives us only an additive overhead.  We found that this one idea decreased the number of states by roughly an order of magnitude.</p>
<p>The third idea was first suggested in 2002 by Ben-Amram and Petersen (and refined for us by Luke Schaeffer); we call it “introspective encoding.”  When we write the program to be interpreted onto the Turing machine tape, the naïve approach would use one Turing machine state per bit.  But that’s clearly wasteful, since in an n-state Turing machine, every state contains ~log(n) bits of information (because of the other states it needs to point to).  A better approach tries to exploit as many of those bits as it can; doing that gave us up to a factor-of-5 additional savings in the number of states.</p>
<p>For Goldbach’s Conjecture and the Riemann Hypothesis, we paid the same 4000-state overhead for the interpreter, but then the program to be interpreted was simpler, giving a smaller overall machine.  Incidentally, it’s not intuitively obvious that the Riemann Hypothesis is equivalent to the statement that some particular computer program runs forever, but it is—that follows, for example, from <a href="http://www.math.lsa.umich.edu/~lagarias/doc/elementaryrh.pdf">work by Lagarias</a> and by <a href="http://mathoverflow.net/questions/31846/is-the-riemann-hypothesis-equivalent-to-a-pi-1-sentence">Davis, Matijasevich, and Robinson</a> (we used the latter; an earlier version of this post incorrectly stated that we used the Lagarias result).</p>
<p>To preempt the inevitable question in the comments section: yes, we <em>did</em> run these Turing machines for a while, and no, none of them had halted after a day or so.  But before you interpret that as evidence in favor of Goldbach, Riemann, and the consistency of ZFC, you should probably know that a Turing machine to test whether <em>all perfect squares are less than 5</em>, produced using Laconic, needed to run for more than an hour before it found the first counterexample (namely, 3<sup>2</sup>=9) and halted.  Laconic Turing machines are optimized only for the number of states, not for speed, to put it mildly.</p>
<p>Of course, three orders of magnitude still remain between the largest value of n (namely, 4) for which BB(n) is known to be knowable in ZFC-based mathematics, and the smallest value of n (namely, 7,918) for which BB(n) is known to be unknowable.  I’m optimistic that further improvements are possible to the machine Z—whether that means simplifications to Friedman’s statement, a redesigned interpreter (possibly using lambda calculus?), or a “multi-stage rocket model” where a bare-bones interpreter would be used to unpack a second, richer interpreter which would be used to unpack a third, etc., until you got to the actual program you cared about.  But I’d be <em>shocked</em> if anyone in my lifetime determined the value of BB(10), for example, or proved the value independent of set theory.  Even after the Singularity happens, I imagine that our robot overlords would find the determination of BB(10) quite a challenge.</p>
<p>In an <a href="https://scottaaronson.blog/?p=152">early <em>Shtetl-Optimized</em> post</a>, I described theoretical computer science as “quantitative epistemology.”  Constructing small Turing machines whose behavior eludes set theory is not conventional theoretical computer science by any stretch of the imagination: it’s closer in practice to programming languages or computer architecture, or even the recreational practice known as <a href="https://en.wikipedia.org/wiki/Code_golf">code-golfing</a>.  On the other hand, I’ve never been involved with any other project that was so clearly, explicitly about pinning down the quantitative boundary between the knowable and the unknowable.</p>
<p>Comments on our paper are welcome.</p>
<p><span><strong>Addendum:</strong></span> Some people might wonder “why Turing machines,” as opposed to a more reasonable programming language like C or Python.  Well, first of all, we needed a language that could address an unlimited amount of memory.  Also, the BB function is traditionally defined in terms of Turing machines.  But the most important issue is that we wanted there to be <em>no suspicion whatsoever</em> that our choice of programming language was artificially helping to make our machine small.  And hopefully everyone can agree that one-tape, two-symbol Turing machines aren’t designed for <em>anyone’s</em> convenience!</p>

		
				
				<p>
					<small>
						This entry was posted
												on Tuesday, May 3rd, 2016 at 6:04 pm						and is filed under <a href="https://scottaaronson.blog/?cat=31" rel="category">Announcements</a>, <a href="https://scottaaronson.blog/?cat=11" rel="category">Nerd Interest</a>.
						You can follow any responses to this entry through the <a href="https://scottaaronson.blog/?feed=rss2&amp;p=2725">RSS 2.0</a> feed.

													Responses are currently closed, but you can <a href="https://scottaaronson.blog/wp-trackback.php?p=2725 " rel="trackback">trackback</a> from your own site.

						
					</small>
				</p>

			</div></div>
  </body>
</html>
