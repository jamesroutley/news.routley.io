<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/supabase/pg_replicate">Original</a>
    <h1>Show HN: Pg_replicate â€“ Build Postgres replication applications in Rust</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto"><code>pg_replicate</code> is a Rust crate to quickly build replication solutions for Postgres. It provides building blocks to construct data pipelines which can continually copy data from Postgres to other systems. It builds abstractions on top of Postgres&#39;s <a href="https://www.postgresql.org/docs/current/protocol-logical-replication.html" rel="nofollow">logical streaming replication protocol</a> and pushes users towards the pit of success without letting them worry about low level details of the protocol.</p>

<p dir="auto">To quickly try out <code>pg_replicate</code>, you can run the <code>stdout</code> example, which will replicate the data to standard output. First, create a publication in Postgres which includes the tables you want to replicate:</p>
<div data-snippet-clipboard-copy-content="create publication my_publication
for table table1, table2;"><pre><code>create publication my_publication
for table table1, table2;
</code></pre></div>
<p dir="auto">Then run the <code>stdout</code> example:</p>
<div data-snippet-clipboard-copy-content="cargo run --example stdout -- --db-host localhost --db-port 5432 --db-name postgres --db-username postgres --db-password password cdc my_publication stdout_slot"><pre><code>cargo run --example stdout -- --db-host localhost --db-port 5432 --db-name postgres --db-username postgres --db-password password cdc my_publication stdout_slot
</code></pre></div>
<p dir="auto">In the above example, <code>pg_replicate</code> connects to a Postgres database named <code>postgres</code> running on <code>localhost:5432</code> with a username <code>postgres</code> and password <code>password</code>. The slot name <code>stdout_slot</code> will be created by <code>pg_replicate</code> automatically.</p>
<p dir="auto">Refer to the <a href="https://github.com/imor/pg_replicate/tree/main/pg_replicate/examples">examples</a> folder to run examples for sinks other than <code>stdout</code> (currently only <code>bigquery</code> and <code>duckdb</code> supported). A quick tip: to see all the command line options, run the example wihout any options specified, e.g. <code>cargo run --example bigquery</code> will print the detailed usage instructions for the <code>bigquery</code> sink.</p>

<p dir="auto">To use <code>pg_replicate</code> in your Rust project, add it via a git dependency in <code>Cargo.toml</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
pg_replicate = { git = &#34;https://github.com/imor/pg_replicate&#34; }"><pre>[<span>dependencies</span>]
<span>pg_replicate</span> = { <span>git</span> = <span><span>&#34;</span>https://github.com/imor/pg_replicate<span>&#34;</span></span> }</pre></div>
<p dir="auto">The git dependency is needed for now because <code>pg_replicate</code> is not yet published on crates.io. You&#39;d also need to add a dependency to tokio:</p>
<div dir="auto" data-snippet-clipboard-copy-content="[dependencies]
...
tokio = { version = &#34;1.38&#34; }"><pre>[<span>dependencies</span>]
<span>...</span>
<span>tokio</span> = { <span>version</span> = <span><span>&#34;</span>1.38<span>&#34;</span></span> }</pre></div>
<p dir="auto">Now your <code>main.rs</code> can have code like the following:</p>
<div dir="auto" data-snippet-clipboard-copy-content="use std::error::Error;

use pg_replicate::pipeline::{
    data_pipeline::DataPipeline,
    sinks::stdout::StdoutSink,
    sources::postgres::{PostgresSource, TableNamesFrom},
    PipelineAction,
};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let host = &#34;localhost&#34;;
    let port = 5432;
    let database = &#34;postgres&#34;;
    let username = &#34;postgres&#34;;
    let password = Some(&#34;password&#34;.to_string());
    let slot_name = Some(&#34;my_slot&#34;.to_string());
    let table_names = TableNamesFrom::Publication(&#34;my_publication&#34;.to_string());

    // Create a PostgresSource
    let postgres_source = PostgresSource::new(
        host,
        port,
        database,
        username,
        password,
        slot_name,
        table_names,
    )
    .await?;

    // Create a StdoutSink. This sink just prints out the events it receives to stdout
    let stdout_sink = StdoutSink;

    // Create a `DataPipeline` to connect the source to the sink
    let mut pipeline = DataPipeline::new(postgres_source, stdout_sink, PipelineAction::Both);

    // Start the `DataPipeline` to start copying data from Postgres to stdout
    pipeline.start().await?;

    Ok(())
}
"><pre><span>use</span> std<span>::</span>error<span>::</span><span>Error</span><span>;</span>

<span>use</span> pg_replicate<span>::</span>pipeline<span>::</span><span>{</span>
    data_pipeline<span>::</span><span>DataPipeline</span><span>,</span>
    sinks<span>::</span>stdout<span>::</span><span>StdoutSink</span><span>,</span>
    sources<span>::</span>postgres<span>::</span><span>{</span><span>PostgresSource</span><span>,</span> <span>TableNamesFrom</span><span>}</span><span>,</span>
    <span>PipelineAction</span><span>,</span>
<span>}</span><span>;</span>

<span>#<span>[</span>tokio<span>::</span>main<span>]</span></span>
<span>async</span> <span>fn</span> <span>main</span><span>(</span><span>)</span> -&gt; <span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>,</span> <span>Box</span><span>&lt;</span><span>dyn</span> <span>Error</span><span>&gt;</span><span>&gt;</span> <span>{</span>
    <span>let</span> host = <span>&#34;localhost&#34;</span><span>;</span>
    <span>let</span> port = <span>5432</span><span>;</span>
    <span>let</span> database = <span>&#34;postgres&#34;</span><span>;</span>
    <span>let</span> username = <span>&#34;postgres&#34;</span><span>;</span>
    <span>let</span> password = <span>Some</span><span>(</span><span>&#34;password&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>let</span> slot_name = <span>Some</span><span>(</span><span>&#34;my_slot&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>let</span> table_names = <span>TableNamesFrom</span><span>::</span><span>Publication</span><span>(</span><span>&#34;my_publication&#34;</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>)</span><span>;</span>

    <span>// Create a PostgresSource</span>
    <span>let</span> postgres_source = <span>PostgresSource</span><span>::</span><span>new</span><span>(</span>
        host<span>,</span>
        port<span>,</span>
        database<span>,</span>
        username<span>,</span>
        password<span>,</span>
        slot_name<span>,</span>
        table_names<span>,</span>
    <span>)</span>
    <span>.</span><span>await</span>?<span>;</span>

    <span>// Create a StdoutSink. This sink just prints out the events it receives to stdout</span>
    <span>let</span> stdout_sink = <span>StdoutSink</span><span>;</span>

    <span>// Create a `DataPipeline` to connect the source to the sink</span>
    <span>let</span> <span>mut</span> pipeline = <span>DataPipeline</span><span>::</span><span>new</span><span>(</span>postgres_source<span>,</span> stdout_sink<span>,</span> <span>PipelineAction</span><span>::</span><span>Both</span><span>)</span><span>;</span>

    <span>// Start the `DataPipeline` to start copying data from Postgres to stdout</span>
    pipeline<span>.</span><span>start</span><span>(</span><span>)</span><span>.</span><span>await</span>?<span>;</span>

    <span>Ok</span><span>(</span><span>(</span><span>)</span><span>)</span>
<span>}</span></pre></div>
<p dir="auto">For more examples, please refer to the <a href="https://github.com/imor/pg_replicate/tree/main/pg_replicate/examples">examples</a> folder in the source.</p>

<p dir="auto">The repository is a cargo workspace. Each of the individual sub-folders are crate in the workspace. A brief explanation of each crate is as follows:</p>
<ul dir="auto">
<li><code>api</code> - REST api used for hosting <code>pg_replicate</code> in a cloud environment.</li>
<li><code>config-types</code> - Common types for configuration used in projects across the workspace.</li>
<li><code>pg_replicate</code> - The main library crate containing the core logic.</li>
<li><code>replicator</code> - A binary crate using <code>pg_replicate</code>. Packaged as a docker container for use in cloud hosting.</li>
</ul>

<p dir="auto"><code>pg_replicate</code> is still under heavy development so expect bugs and papercuts but overtime we plan to add the following sinks.</p>
<ul>
<li> Add BigQuery Sink</li>
<li> Add DuckDb Sink</li>
<li> Add MotherDuck Sink</li>
<li> Add Snowflake Sink</li>
<li> Add ClickHouse Sink</li>
<li> Many more to come...</li>
</ul>
<p dir="auto">Note: DuckDb and MotherDuck sinks do no use the batched pipeline, hence they currently perform poorly. A batched pipeline version of these sinks is planned.</p>
<p dir="auto">See the <a href="https://github.com/imor/pg_replicate/issues">open issues</a> for a full list of proposed features (and known issues).</p>

<p dir="auto">Distributed under the Apache-2.0 License. See <code>LICENSE</code> for more information.</p>

<p dir="auto">To create the docker image for <code>replicator</code> run <code>docker build -f ./replicator/Dockerfile .</code> from the root of the repo. Similarly, to create the docker image for <code>api</code> run <code>docker build -f ./api/Dockerfile .</code>.</p>

<p dir="auto">Applications can use data sources and sinks from <code>pg_replicate</code> to build a data pipeline to continually copy data from the source to the sink. For example, a data pipeline to copy data from Postgres to DuckDB takes about 100 lines of Rust.</p>
<p dir="auto">There are three components in a data pipeline:</p>
<ol dir="auto">
<li>A data source</li>
<li>A data sink</li>
<li>A pipline</li>
</ol>
<p dir="auto">The data source is an object from where data will be copied. The data sink is an object to which data will be copied. The pipeline is an object which drives the data copy operations from the source to the sink.</p>
<div data-snippet-clipboard-copy-content=" +----------+                       +----------+
 |          |                       |          |
 |  Source  |---- Data Pipeline ---&gt;|   Sink   |
 |          |                       |          |
 +----------+                       +----------+"><pre><code> +----------+                       +----------+
 |          |                       |          |
 |  Source  |---- Data Pipeline ---&gt;|   Sink   |
 |          |                       |          |
 +----------+                       +----------+
</code></pre></div>
<p dir="auto">So roughly you write code like this:</p>
<div dir="auto" data-snippet-clipboard-copy-content="let postgres_source = PostgresSource::new(...);
let duckdb_sink = DuckDbSink::new(..);
let pipeline = DataPipeline(postgres_source, duckdb_sink);
pipeline.start();"><pre><span>let</span> postgres_source = <span>PostgresSource</span><span>::</span><span>new</span><span>(</span>..<span>.</span><span></span><span>)</span><span>;</span>
<span>let</span> duckdb_sink = <span>DuckDbSink</span><span>::</span><span>new</span><span>(</span>..<span>)</span><span>;</span>
<span>let</span> pipeline = <span>DataPipeline</span><span>(</span>postgres_source<span>,</span> duckdb_sink<span>)</span><span>;</span>
pipeline<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Of course, the real code is more than these four lines, but this is the basic idea. For a complete example look at the <a href="https://github.com/imor/pg_replicate/blob/main/pg_replicate/examples/duckdb.rs">duckdb example</a>.</p>

<p dir="auto">A data source is the source for data which the pipeline will copy to the data sink. Currently, the repository has only one data source: <a href="https://github.com/imor/pg_replicate/blob/main/pg_replicate/src/pipeline/sources/postgres.rs"><code>PostgresSource</code></a>. <code>PostgresSource</code> is the primary data source; data in any other source or sink would have originated from it.</p>

<p dir="auto">A data sink is where the data from a data source is copied. There are two kinds of data sinks. Those which retain the essential nature of data coming out of a <code>PostgresSource</code> and those which don&#39;t. The former kinds of data sinks can act as a data source in future. The latter kind can&#39;t act as a data source and are data&#39;s final resting place.</p>
<p dir="auto">For instance, <a href="https://github.com/imor/pg_replicate/blob/main/pg_replicate/src/pipeline/sinks/duckdb.rs"><code>DuckDbSink</code></a> ensures that the change data capture (CDC) stream coming in from a source is materialized into tables in a DuckDB database. Once this lossy data transformation is done, it can not be used as a CDC stream again.</p>
<p dir="auto">Contrast this with a potential future sink <code>S3Sink</code> or <code>KafkaSink</code> which just copies the CDC stream as is. The data deposited in the sink can later be used as if it was coming from Postgres directly.</p>

<p dir="auto">A data pipeline encapsulates the business logic to copy the data from the source to the sink. It also orchestrates resumption of the CDC stream from the exact location it was last stopped at. The data sink participates in this by persisting the resumption state and returning it to the pipeline when it restarts.</p>
<p dir="auto">If a data sink is not transactional (e.g. <code>S3Sink</code>), it is not always possible to keep the CDC stream and the resumption state consistent with each other. This can result in these non-transactional sinks having duplicate portions of the CDC stream. Data pipeline helps in deduplicating these duplicate CDC events when the data is being copied over to a transactional store like DuckDB.</p>
<p dir="auto">Finally, the data pipeline reports back the log sequence number (LSN) upto which the CDC stream has been copied in the sink to the <code>PostgresSource</code>. This allows the Postgres database to reclaim disk space by removing WAL segment files which are no longer required by the data sink.</p>
<div data-snippet-clipboard-copy-content=" +----------+                       +----------+
 |          |                       |          |
 |  Source  |&lt;---- LSN Numbers -----|   Sink   |
 |          |                       |          |
 +----------+                       +----------+"><pre><code> +----------+                       +----------+
 |          |                       |          |
 |  Source  |&lt;---- LSN Numbers -----|   Sink   |
 |          |                       |          |
 +----------+                       +----------+
</code></pre></div>

<p dir="auto">CDC stream is not the only kind of data a data pipeline performs. There&#39;s also full table copy, aka backfill. These two kinds can be performed either together or separately. For example, a one-off data copy can use the backfill. But if you want to regularly copy data out of Postgres and into your OLAP database, backfill and CDC stream both should be used. Backfill to get the intial copies of the data and CDC stream to keep those copies up to date and changes in Postgres happen to the copied tables.</p>

<p dir="auto">Currently the data source and sinks copy table row and CDC events one at a time. This is expected to be slow. Batching, and other strategies will likely improve the performance drastically. But at this early stage the focus is on correctness rather than performance. There are also zero benchmarks at this stage, so commentary about performance is closer to speculation than reality.</p>
</article></div></div>
  </body>
</html>
