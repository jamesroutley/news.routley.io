<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://geohot.github.io//blog/jekyll/update/2023/11/18/imitation-learning.html">Original</a>
    <h1>Imitation Learning (2023)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>7 years ago I started <a href="https://comma.ai">comma.ai</a> with a simple idea.</p>

<ol>
  <li>Gather tons of human driving data, state action pairs: <code>(S_t, A_t)</code></li>
  <li>Train a supervised model <code>f(S_t) -&gt; A_t</code></li>
  <li>Drive cars with that model.</li>
</ol>

<p>The exact original formulation was a model that predicts steering angle from image, then used a PID loop to bring the wheel to that desired angle.</p>

<p><code>f_steerangle(img_t) -&gt; steerangle_t</code></p>

<p>This turns out not to work, it couldn’t even drive straight on highways. It would drive for maybe 10 seconds, but then <a href="https://www.ri.cmu.edu/pub_files/2015/3/InvitationToImitation_3_1415.pdf">error would accumulate</a> and it would drift to one side of the lane or the other (funny enough, it did show reluctance to cross the lane line, but it was unusable as an ADAS system)</p>

<hr/>


<p>comma’s first solution was a model that predicted lane position.</p>

<p><code>f_lane(img_t) -&gt; (left_lane_pos_t, right_lane_pos_t)</code></p>

<p>While that alone couldn’t drive a car (especially not around turns), it functioned as a unbiased correction for the steering angle model, where <code>α</code> is the correction factor.</p>

<p><code>(f_steerangle(img_t) - α*f_lane(img_t).mean()) -&gt; steerangle_t</code></p>

<p>This was basically shipped in the first version of <a href="https://github.com/commaai/openpilot">openpilot</a>.</p>

<hr/>


<p>One major issue this struggled with was ground truthing the lane line model. Unlike steering angle, which has a simple sensor to measure it, “lane lines” don’t have a clear definition. They broke the end-to-endness of the system.</p>

<p>We referred to lanes as the “original sin” of comma, and tried really hard to remove them. I’m sad to say that there’s still lanes in our ground truthing stack today, but we have <a href="https://blog.comma.ai/end-to-end-lateral-planning/">made amazing strides</a> in removing them, to the point that openpilot in 2020 could <a href="https://twitter.com/comma_ai/status/1309248079808229377?lang=en">drive on a dirt road</a> without any lane lines.</p>

<p>However, the removal of lanes was done with a whole bunch of other hand coding. We have extended this to removing explicit use of cars with <a href="https://blog.comma.ai/090release/">experimental mode</a>, but some of our hand coded assumptions break down a bit more in the longitudinal case vs the lateral case.</p>

<hr/>


<p>Funny enough, things have come full circle, and we think we have a solution to behavioral cloning. I will explain the problem as I best understand it, and leave the solution as an exercise to the reader.</p>

<p>Imagine running the steering angle model over time. At each time step, any model makes <code>ε</code> error.</p>

<div><div><pre><code>f_steerangle(img_t0) + ε_t0 -&gt; steerangle_t0
f_steerangle(img_t1) + ε_t1 -&gt; steerangle_t1
f_steerangle(img_t2) + ε_t2 -&gt; steerangle_t2
f_steerangle(img_t3) + ε_t3 -&gt; steerangle_t3
...
</code></pre></div></div>

<p>This model is easy to train, and can achieve very low losses on a holdout set. However, it won’t drive a car, and that’s due to the <code>ε</code> errors altering the next image. Note that the errors don’t alter the next image in either train or test, but on the road it looks like:</p>

<div><div><pre><code>f_steerangle(img_t0) + ε_t0 -&gt; steerangle_t0
f_steerangle(img_t1&#39;) + ε_t1 -&gt; steerangle_t1
f_steerangle(img_t2&#39;&#39;) + ε_t2 -&gt; steerangle_t2
f_steerangle(img_t3&#39;&#39;&#39;) + ε_t3 -&gt; steerangle_t3
...
</code></pre></div></div>

<p>If it is driving well depends on how far <code>img_t3&#39;&#39;&#39;</code> is from <code>img_t3</code>, which depends on what <code>ε_t0 + ε_t1 + ε_t2 + ε_t3 + ...</code> looks like in the limit.</p>

<p>Are the <code>ε</code> correlated? In the best case they aren’t, but in practice they almost always are. And even if they aren’t correlated, that error <em>still</em> grows unbounded. You need them to be <b>anti-correlated</b>. You need the limit of that sum to be 0.</p>

<hr/>


<p>You need an estimator of accumulated episilon. Above, we use <code>f_lane(img_t).mean()</code>, but imagine the generic form.</p>

<div><div><pre><code>f_steerangle(img_t0) + ε_t0 -&gt; steerangle_t0
f_steerangle(img_t1&#39;) + ε_t1 - α*ε_t0  -&gt; steerangle_t1
f_steerangle(img_t2&#39;) + ε_t2 - α*(ε_t1 - α*ε_t0) -&gt; steerangle_t2
f_steerangle(img_t3&#39;) + ε_t3 - α*(ε_t2 - α*(ε_t1 - α*ε_t0))-&gt; steerangle_t3
...
</code></pre></div></div>

<p>Replace that <code>α*</code> expression at time t with a function <code>f_correction(img_t)</code>, and you are back at the working formulation above.</p>

<p><code>(f_steerangle(img_t) - α*f_correction(img_t)) -&gt; steerangle_t</code></p>

<p>The billion dollar question, how do you end-to-end ground truth <code>f_correction</code>?</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
