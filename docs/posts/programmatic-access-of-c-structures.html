<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://debamitro.github.io/blog/programmatic-access-of-c-structures/">Original</a>
    <h1>Programmatic Access of C Structures</h1>
    
    <div id="readability-page-1" class="page"><div>
        
<p>More than a year ago, I was looking for a project which would help me learn the <a href="https://www.rust-lang.org">Rust programming language</a>. I like creating small projects from scratch, so I thought of solving a problem I had encountered occasionally at work. C (and C++ as well) doesn’t have a standard way of accessing its data structures programmatically. Some languages have type introspection capabilities, and C/C++ obviously don’t have that either. As a result, we often need to implement boilerplate utility code for dealing with C/C++ structures. Some examples are:</p>
<ul>
<li>Code for pretty printing a structure (something like <a href="https://www.php.net/manual/en/function.var-dump.php">php’s var_dump</a>)</li>
<li>Code for serialization/deserialization of a structure</li>
</ul>
<p>These needs are solved in different ways by every software product. I wanted <em>one</em> standard library which could allow programmatic access to C/C++ data structures. I thought I’d get started using Rust.</p>

<p>Rust seemed like a good language for writing something low-level like a parser, without having to worry a lot about memory errors.
It also comes with a nice string library, which is the first thing one needs for parsing.</p>

<p>I saw projects using the <a href="https://crates.io/crates/nom">nom</a> library, and I probably could have been more productive using it. I chose to write things from scratch, without any dependencies other than the standard library. This was a purely personal preference, as I wanted to learn Rust.</p>

<p>I called it <a href="http://github.com/debamitro/c-introspect-rs">c-introspect-rs</a> as my idea was close enough to type introspection. It is not actually introspection though. I guess I’ll have to live with the name. As of now it provides an Iterator over C/C++ structs</p>
<div><pre tabindex="0"><code data-lang="rust"><span>use</span> c_introspect_rs::c_parser::parse_c_file;
...
<span>// Sample usage
</span><span></span>    <span>if</span> <span>let</span> Some(itr) <span>=</span> parse_c_file(filename) {
        <span>for</span> c_struct <span>in</span> itr {
            <span>// For every struct, loop over the fields
</span><span></span>            <span>for</span> field <span>in</span> c_struct.fields.iter() {
            }
        }
    }
</code></pre></div><p>Here are the Rust data structures provided by the Iterator</p>
<div><pre tabindex="0"><code data-lang="rust"><span>pub</span> <span>struct</span> <span>C_Declaration</span> {
    <span>pub</span> typename: String,
    <span>pub</span> name: String,
}

<span>pub</span> <span>struct</span> <span>C_Struct</span> {
    <span>pub</span> name: String,
    <span>pub</span> fields: Vec<span>&lt;</span>C_Declaration<span>&gt;</span>,
}
</code></pre></div>
<p>Here is the <code>parse_c_file</code> routine, which is the only functionality exported by my library.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>pub</span> <span>struct</span> <span>C_StructIter</span> {
    finished: <span>bool</span>,
    buf_reader: <span>BufReader</span><span>&lt;</span>File<span>&gt;</span>,
}

<span>pub</span> <span>fn</span> <span>parse_c_file</span>(filename: <span>&amp;</span><span>str</span>) -&gt; Option<span>&lt;</span>C_StructIter<span>&gt;</span> {}
</code></pre></div><p>The <code>parse_c_file</code> routine returns a lazy iterator of type <code>C_StructIter</code>. Whenever <code>C_StructIter::next()</code> is called, the parsing mechanism starts off from wherever it stopped earlier. At the lowest level is a tokenizer which is also a lazy iterator of type <code>c_parser::c_tokenizer::TokenItr</code>. Whenever the parser calls <code>TokenItr::next()</code>, the tokenizer reads the next characters from the file and returns a token. The parser is probably a top-down parser with backtracking, which I feel is the easiest way to hand-code a parser. I wrote ‘probably’ because I didn’t start from a definite parsing strategy. I looked at the syntax of C and C++ structs and asked myself ‘hey, how can my program recognize this’. So far it seems to be working for a number of structs. I still need to work on handling more datatypes for the fields of the struct, and for handling recursive structures.</p>

<p>I started out with a tiny hand-written file with one struct. Then, I added one more. Next I tried to parse stdlib.h - one of the established Unix system headers. Once I was able to do that I went ahead and parsed all files with a ‘.h’ suffix under /usr/include. There were arond 1700 headers in all. That was fun! In fact this is the point where I managed to make my program panic. Some of the headers had Unicode characters inside comments, and I was going through the multi-byte characters incorrectly.</p>

<p>Although I had started this project one year ago on the side, I never got it off the ground properly. I am currently doing a six-week batch at the <a href="https://www.recurse.com">Recurse Center</a> and that’s where I have been able to devote a number of days to it.</p>
<p>What did I learn?</p>
<ul>
<li>The biggest thing I learnt while doing this is the ownership of objects in Rust. Rust keeps a strict check on who owns an object and who can have access to it. Following the Rust compiler’s preferences helped me organize my data logically, keeping things where they fit in logically.</li>
<li>I also learnt how cargo allows you to run examples for a library. This is very useful, because it is very easy to illustrate how a library should be used, if you can run some example code. All you need to do is to put your examples inside an ‘example’ directory at the same place where your Cargo.toml is.</li>
</ul>

      </div></div>
  </body>
</html>
