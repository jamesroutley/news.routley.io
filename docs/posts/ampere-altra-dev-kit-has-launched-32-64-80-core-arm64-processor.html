<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ipi.wiki/products/com-hpc-ampere-altra">Original</a>
    <h1>Ampere Altra Dev Kit has launched 32, 64, 80 core arm64 processor</h1>
    
    <div id="readability-page-1" class="page"><div><section><div><div id="post-content-parent"><div id="post-content-wrapper"><p>We have a set of villages on a map. And at first, which means each village is isolated from other villages.</p>
<ol>
<li><p>If village A is connected to village B, then village B is also connected to village A. That means a connection is <strong>symmetric</strong>.</p>
</li>
<li><p>If village A is connected to village B, and village B is connected to village c, then we say that village A is also connected to village C. That means a connection is <strong>transitive</strong>.</p>
</li>
</ol>
<p>Each time, we can build a road to connect any two villages if they are not connected. Based on this situation, it comes with a few problems to be resolved:</p>
<p>We want to know how many disjoint components exist after some connecting operations. We want to know which village belongs to which disjoint component efficiently. Given any two villages, we need to know if they are connected. Given any two villages, we need to be able to connect them if they are not connected.</p>
<p>So this is the interface we need, represented in a Rust trait:</p>
<pre><code><span><span>trait</span> <span>DisjointSet</span></span>&lt;T&gt; {
    <span><span>type</span> <span>ElementIdentifier</span></span>;

    <span>/// Creates a new subset with a single element `elem`. If the operation</span>
    <span>/// succeeded, it returns a Some with a unique identifier that can be used</span>
    <span>/// in future calls to the disjoint set in order to operate on the new</span>
    <span>/// subset.</span>
    <span><span>fn</span> <span>make_subset</span></span>(&amp;<span>mut</span> <span>self</span>, elem: T) -&gt; <span>Option</span>&lt;Self::ElementIdentifier&gt;;

    <span>/// Checks if two elements are in the same set, returning Some(true) if they</span>
    <span>/// are, Some(false) if they aren&#39;t, or None if either isn&#39;t present.</span>
    <span><span>fn</span> <span>same_set</span></span>(
        &amp;<span>self</span>,
        elem_a: Self::ElementIdentifier,
        elem_b: Self::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;<span>bool</span>&gt;;

    <span>/// Merges the subsets containing the two elements so that `same_set(A, C)</span>
    <span>/// == true` both if it already was, or if before the union `same_set(B, C)</span>
    <span>/// == true`, and vice versa. I.E. {A} ∪ {B, C} == {A, C} ∪ B == {A, C}</span>
    <span>/// ∪ B. Returns Some(true) if the operation was performed, Some(false) if</span>
    <span>/// they were already in the same set, and None if either doesn&#39;t exist.</span>
    <span><span>fn</span> <span>union</span></span>(
        &amp;<span>mut</span> <span>self</span>,
        elem_a: Self::ElementIdentifier,
        elem_b: Self::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;<span>bool</span>&gt;;
}
</code></pre>
<p>The seemingly obvious implementation is a 2D array:</p>
<pre><code><span>#[derive(Debug, PartialEq, Eq)]</span>
<span><span>struct</span> <span>NaiveDisjointSet</span></span>&lt;T: <span>Eq</span> + Hash&gt; {
    sets: <span>Vec</span>&lt;HashSet&lt;T&gt;&gt;,
}

<span>impl</span>&lt;T: <span>Eq</span> + Hash + <span>Clone</span>&gt; DisjointSet&lt;T&gt; <span>for</span> NaiveDisjointSet&lt;T&gt; {
    <span><span>type</span> <span>ElementIdentifier</span></span> = <span>usize</span>;

    <span><span>fn</span> <span>make_subset</span></span>(&amp;<span>mut</span> <span>self</span>, elem: T) -&gt; <span>Option</span>&lt;Self::ElementIdentifier&gt; {
        <span>let</span> elem_set_idx = <span>self</span>.sets.len();

        <span>self</span>.sets.push(HashSet::from([elem]));

        <span>Some</span>(elem_set_idx)
    }

    <span><span>fn</span> <span>same_set</span></span>(
        &amp;<span>self</span>,
        elem_a_set_idx: Self::ElementIdentifier,
        elem_b_set_idx: Self::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;<span>bool</span>&gt; {
        <span>Some</span>(elem_a_set_idx == elem_b_set_idx)
    }

    <span><span>fn</span> <span>union</span></span>(
        &amp;<span>mut</span> <span>self</span>,
        elem_a_set_idx: Self::ElementIdentifier,
        elem_b_set_idx: Self::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;<span>bool</span>&gt; {
        <span>let</span> set_a = <span>self</span>.sets.remove(elem_a_set_idx);
        <span>let</span> set_b = <span>self</span>.sets.remove(elem_b_set_idx);

        <span>self</span>.sets.push(set_a.union(&amp;set_b).cloned().collect());

        <span>Some</span>(<span>true</span>)
    }
}
</code></pre>
<p>But this has some problems. Mainly, the issue is that the <code>union</code> operation is really expensive both in terms of time and memory: we have to perform a O(n) <code>HashSet</code> union operation on potentially larger and larger N&#39;s as more and more village sets get merged together. And there&#39;s another problem that Rust makes more obvious: the need for <code>clone</code> and <code>collect</code>, which are also O(n) operations themselves. This also means that the types have a <code>T: Hash + Clone</code> restriction, which also is especially inelegant.</p>
<p>More importantly than even any of those, in this case the <em>caller</em> is responsible for keeping track of the internals of which element is in which set index, otherwise they&#39;re not able to perform operations on them. And while we could make the internals more complicated to account for that, long story short: it is quite difficult to do and ultimately still results in internals being exposed in awkward ways.</p>
<p>There is a better way, and while it may seem more complex on the surface, it is in many ways remarkably elegant: the disjoint set forest.</p>
<pre><code><span>/// A common implementation of a disjoint set involving a forest.</span>
<span><span>struct</span> <span>DisjointSetForest</span></span>&lt;T: <span>PartialEq</span>&gt; {
    roots: HashSet&lt;<span>usize</span>&gt;,
    nodes: <span>Vec</span>&lt;Node&gt;,
    elems: <span>Vec</span>&lt;T&gt;,
}

<span><span>struct</span> <span>Node</span></span> {
    rank: <span>usize</span>,
    parent: Cell&lt;<span>usize</span>&gt;,
}

<span>impl</span>&lt;T: <span>PartialEq</span>&gt; DisjointSet&lt;T&gt; <span>for</span> DisjointSetForest&lt;T&gt; {
    <span><span>type</span> <span>ElementIdentifier</span></span> = <span>usize</span>;

    <span><span>fn</span> <span>make_subset</span></span>(&amp;<span>mut</span> <span>self</span>, elem: T) -&gt; <span>Option</span>&lt;Self::ElementIdentifier&gt; {
        <span>if</span> <span>self</span>.elems.contains(&amp;elem) {
            <span>return</span> <span>None</span>;
        }

        <span>// This is the index where the element will be inserted, thanks to</span>
        <span>// 0-indexing. We need to get this before we actually push the element.</span>
        <span>let</span> element_idx = <span>self</span>.elems.len();

        <span>self</span>.elems.push(elem);

        <span>self</span>.nodes.push(Node {
            rank: <span>0</span>,
            parent: Cell::new(element_idx),
        });

        <span>self</span>.roots.insert(element_idx);

        <span>Some</span>(element_idx)
    }

    <span><span>fn</span> <span>same_set</span></span>(
        &amp;<span>self</span>,
        elem_a: Self::ElementIdentifier,
        elem_b: Self::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;<span>bool</span>&gt; {
        <span>Some</span>(<span>self</span>.find_root(elem_a)? == <span>self</span>.find_root(elem_b)?)
    }

    <span><span>fn</span> <span>union</span></span>(
        &amp;<span>mut</span> <span>self</span>,
        elem_a: Self::ElementIdentifier,
        elem_b: Self::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;<span>bool</span>&gt; {
        <span>let</span> (<span>mut</span> a_root_idx, <span>mut</span> b_root_idx) = (<span>self</span>.find_root(elem_a)?, <span>self</span>.find_root(elem_b)?);

        <span>// In this case, they&#39;re already in the same set. We don&#39;t use same_set</span>
        <span>// to check this because if it&#39;s not true, then we perform redundant</span>
        <span>// work since we need the representatives for future work.</span>
        <span>if</span> a_root_idx == b_root_idx {
            <span>return</span> <span>Some</span>(<span>false</span>);
        }

        <span>if</span> <span>self</span>.nodes[a_root_idx].rank &lt; <span>self</span>.nodes[b_root_idx].rank {
            <span>// We want the element we call A to always be higher rank.</span>
            <span>self</span>.nodes.swap(a_root_idx, b_root_idx);
            mem::swap(&amp;<span>mut</span> a_root_idx, &amp;<span>mut</span> b_root_idx);
        }

        <span>// Now a_root.rank &gt;= b_root.rank no matter what.</span>
        <span>// Therefore, make A the parent of B.</span>
        <span>self</span>.nodes[b_root_idx].parent.set(a_root_idx);
        <span>self</span>.roots.remove(&amp;b_root_idx);
        <span>if</span> <span>self</span>.nodes[a_root_idx].rank == <span>self</span>.nodes[b_root_idx].rank {
            <span>self</span>.nodes[a_root_idx].rank += <span>1</span>;
        }

        <span>Some</span>(<span>true</span>)
    }
}

<span>impl</span>&lt;T: <span>PartialEq</span>&gt; <span>Default</span> <span>for</span> DisjointSetForest&lt;T&gt; {
    <span><span>fn</span> <span>default</span></span>() -&gt; <span>Self</span> {
        <span>Self</span> {
            roots: HashSet::new(),
            nodes: <span>vec!</span>[],
            elems: <span>vec!</span>[],
        }
    }
}

<span>impl</span>&lt;T: <span>PartialEq</span>&gt; DisjointSetForest&lt;T&gt; {
    <span><span>fn</span> <span>new</span></span>() -&gt; <span>Self</span> {
        Self::default()
    }

    <span><span>fn</span> <span>find_root</span></span>(
        &amp;<span>self</span>,
        elem: &lt;<span>Self</span> <span>as</span> DisjointSet&lt;T&gt;&gt;::ElementIdentifier,
    ) -&gt; <span>Option</span>&lt;&lt;<span>Self</span> <span>as</span> DisjointSet&lt;T&gt;&gt;::ElementIdentifier&gt; {
        <span>if</span> <span>self</span>.roots.contains(&amp;elem) {
            <span>return</span> <span>Some</span>(elem);
        }

        <span>let</span> <span>mut</span> current_idx = elem;
        <span>let</span> <span>mut</span> current = <span>self</span>.nodes.get(current_idx)?;

        <span>while</span> current.parent.get() != current_idx {
            <span>let</span> parent_idx = current.parent.get();
            <span>let</span> parent = &amp;<span>self</span>.nodes[parent_idx];

            <span>// Set the current node&#39;s parent to its grandparent. This is called</span>
            <span>// *path splitting*: (see the Wikipedia page for details) a simpler</span>
            <span>// to implement, one-pass version of path compression that also</span>
            <span>// turns out to be more efficient in practice.</span>
            current.parent.set(parent.parent.get());

            <span>// Move up a level</span>
            current_idx = parent_idx;
            current = parent;
        }

        <span>Some</span>(current_idx)
    }
}
</code></pre>
<p>This results in a forest of trees that make themselves simpler to look through every time they&#39;re looked through, which means that the gains add up extremely fast in a large operation with many sets and many union operations. It&#39;s super cool!</p>
<p>If you want to read more about this, as cliche as it sounds, the Wikipedia article on union-find is actually a really good explanation once you understand what the goal is, which you hopefully do now. If you liked this, please do share your thoughts on it in the comments below!</p>
</div></div></div></section></div></div>
  </body>
</html>
