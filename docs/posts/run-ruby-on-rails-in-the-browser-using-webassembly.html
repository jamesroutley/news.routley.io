<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://web.dev/blog/ruby-on-rails-on-webassembly">Original</a>
    <h1>Run Ruby on Rails in the browser using WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div>

  
    






<p>
  Published: January 31, 2025
</p>


<p>Imagine running a fully functional blog in your browser—not just the frontend,
but the backend, too. No servers or clouds involved—just you, your browser,
and… <a href="https://webassembly.org/">WebAssembly</a>! By allowing server-side
frameworks to run locally, WebAssembly is blurring the boundaries of classic
web development and opening up exciting new possibilities.
In this post, Vladimir Dementyev (Head of Backend at <a href="https://evilmartians.com/">Evil
Martians</a>) shares the progress on making <a href="https://rubyonrails.org/">Ruby on
Rails</a> Wasm- and browser-ready:</p>

<ul>
<li>How to bring Rails into the browser in 15 minutes.</li>
<li>Behind the scenes of Rails wasmification.</li>
<li>Future of Rails and Wasm.</li>
</ul>

<h2 id="ruby_on_rails_famous_blog_in_15_minutes_now_running_right_in_your_browser" data-text="Ruby on Rails&#39; famous &#34;blog in 15 minutes&#34; now running right in your browser" tabindex="-1">Ruby on Rails&#39; famous &#34;blog in 15 minutes&#34; now running right in your browser</h2>

<p>Ruby on Rails is a web framework focused on developer productivity and shipping
things fast. It&#39;s the technology used by industry leaders such as
<a href="https://github.blog/engineering/architecture-optimization/building-github-with-ruby-and-rails/">GitHub</a>
and
<a href="https://shopify.engineering/shopify-made-patterns-in-our-rails-apps">Shopify</a>.
The popularity of the framework began many years ago with the release of the
famous
<a href="https://www.youtube.com/watch?v=Gzj723LkRJY">&#34;How to build a blog in 15 minutes&#34;</a>
video published by David Heinemeier Hansson (or DHH). Back in 2005, it was
unimaginable to build a fully working web application in such a short time. It
felt like <em>magic</em>!</p>

<p>Today, I&#39;d like to bring this magical feeling back by creating a Rails
application that runs fully in your browser. Your journey starts with creating a
basic Rails application the usual way, and then packaging it for Wasm.</p>

<h2 id="background_a_blog_in_15_minutes_on_the_command_line" data-text="Background: a &#34;blog in 15 minutes&#34; on the command line" tabindex="-1">Background: a &#34;blog in 15 minutes&#34; on the command line</h2>

<p>Assuming you have
<a href="https://guides.rubyonrails.org/v5.0/getting_started.html#installing-rails">Ruby and Ruby on Rails installed on your machine</a>,
you start with creating a new Ruby on Rails application and scaffolding some
functionality (just like in the original &#34;blog in 15 minutes&#34; video):</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">
$<span> </span>rails<span> </span>new<span> </span>--css<span>=</span>tailwind<span> </span>web_dev_blog

<span>  </span>create<span>  </span>.ruby-version
<span>  </span>...

$<span> </span><span>cd</span><span> </span>web_dev_blog

$<span> </span>bin/rails<span> </span>generate<span> </span>scaffold<span> </span>Post<span> </span>title:string<span> </span>date:date<span> </span>body:text

<span>  </span>create<span>    </span>db/migrate/20241217183624_create_posts.rb
<span>  </span>create<span>    </span>app/models/post.rb
<span>  </span>...

$<span> </span>bin/rails<span> </span>db:migrate

<span>==</span><span> </span><span>20241217183624</span><span> </span>CreatePosts:<span> </span><span>migrating</span><span> </span><span>====================</span>
--<span> </span>create_table<span>(</span>:posts<span>)</span>
<span>   </span>-&gt;<span> </span><span>0</span>.0017s
<span>==</span><span> </span><span>20241217183624</span><span> </span>CreatePosts:<span> </span>migrated<span> </span><span>(</span><span>0</span>.0018s<span>)</span><span> </span><span>===========</span>
</code></pre></devsite-code>
<p>Without even touching the codebase, you can now run the application and see it
in action:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">$<span> </span>bin/dev

<span>=</span>&gt;<span> </span>Booting<span> </span><span>Puma</span>
<span>=</span>&gt;<span> </span>Rails<span> </span><span>8</span>.0.1<span> </span>application<span> </span>starting<span> </span><span>in</span><span> </span>development
...
*<span> </span>Listening<span> </span>on<span> </span>http://127.0.0.1:3000
</code></pre></devsite-code>
<p>Now, you can open <em>your</em> blog at
<a href="http://localhost:3000/posts">http://localhost:3000/posts</a> and start writing
posts!</p>

<p><img src="https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d.png" alt="A Ruby on Rails blog launched from the command line running in the browser." srcset="https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_36.png 36w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_48.png 48w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_72.png 72w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_96.png 96w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_480.png 480w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_720.png 720w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_856.png 856w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_960.png 960w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_1440.png 1440w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_1920.png 1920w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--rv7ehku4d_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/></p>

<p>You have a very bare-bone, but functional blog application built in minutes.
It&#39;s a full-stack, <em>server-controlled</em> application: you have a database
(<a href="https://www.sqlite.org/">SQLite</a>) to keep your data, a web server to handle
HTTP requests (<a href="https://puma.io/">Puma</a>), and a Ruby program to keep your
business logic, provide UI, and process user interactions. Finally, there is a
thin layer of JavaScript (<a href="https://turbo.hotwired.dev/">Turbo</a>) to streamline
the browsing experience.</p>

<p>The official Rails demo continues in the direction of deploying this application
onto a bare metal server and, thus, making it production-ready. Your journey
will continue in the opposite direction: instead of putting your application
somewhere far away, you&#39;ll &#34;deploy&#34; it locally.</p>

<h2 id="next_level_a_blog_in_15_minutes_in_wasm" data-text="Next level: a &#34;blog in 15 minutes&#34; in Wasm" tabindex="-1">Next level: a &#34;blog in 15 minutes&#34; in Wasm</h2>

<p>Since the addition of WebAssembly, browsers became capable of running not only
JavaScript code, but any code compilable into Wasm. And Ruby is not an
exception. Surely, Rails is more than Ruby, but before digging into the
differences, let us continue the demo and <em>wasmify</em> (a verb coined by the
<a href="https://github.com/palkan/wasmify-rails">wasmify-rails</a> library) the Rails
application!</p>

<p>You only need to execute a few commands to compile your blog application into a
Wasm module and run it in the browser.</p>

<p>First, you install the wasmify-rails library using Bundler (the <code translate="no" dir="ltr">npm</code> of Ruby)
and run its generator using the Rails CLI:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">$<span> </span>bundle<span> </span>add<span> </span>wasmify-rails

$<span> </span>bin/rails<span> </span>wasmify:install

<span>  </span>create<span>  </span>config/wasmify.yml
<span>  </span>create<span>  </span>config/environments/wasm.rb
<span>  </span>...
<span>  </span>info<span>  </span>✅<span> </span>The<span> </span>application<span> </span>is<span> </span>prepared<span> </span><span>for</span><span> </span>Wasm-ificaiton!
</code></pre></devsite-code>
<p>The <code translate="no" dir="ltr">wasmify:rails</code> command configures a dedicated &#34;wasm&#34;
<a href="https://docs.ruby-lang.org/en/3.3/Process.html#module-Process-label-Execution+Environment">execution environment</a>
(in addition to the default &#34;development&#34;, &#34;test&#34;, and &#34;production&#34;
environments) and installs the required dependencies. For a greenfield Rails
application, this is enough to make it Wasm-ready.</p>

<p>Next, build the core Wasm module containing the Ruby runtime, the standard
library, and all the application dependencies:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">$<span> </span>bin/rails<span> </span>wasmify:build

<span>==</span>&gt;<span> </span>RubyWasm::BuildSource<span>(</span><span>3</span>.3<span>)</span><span> </span>--<span> </span>Building
...
<span>==</span>&gt;<span> </span>RubyWasm::CrossRubyProduct<span>(</span>ruby-3.3-wasm32-unknown-wasip1-full-4aaed4fbda7afe0bdf4e22167afd101e<span>)</span><span> </span>--<span> </span><span>done</span><span> </span><span>in</span><span> </span><span>47</span>.37s
INFO:<span> </span>Packaging<span> </span>gem:<span> </span>rake-13.2.1
...
INFO:<span> </span>Packaging<span> </span>gem:<span> </span>wasmify-rails-0.2.0
INFO:<span> </span>Packaging<span> </span>setup.rb:<span> </span>bundle/setup.rb
INFO:<span> </span>Size:<span> </span><span>73</span>.77<span> </span>MB
</code></pre></devsite-code>
<p>This step can take some time: you must build Ruby from source to properly link
native extensions (written in C) from the third-party libraries. This
(temporary) drawback is covered later in the post.</p>

<p>The compiled Wasm module is just a <em>foundation</em> for your application. You must
also <em>pack</em> the application code itself and all the <em>assets</em> (for example,
images, CSS, JavaScript). Before doing the packing, create a basic launcher
application that could be used to run the <em>wasmified</em> Rails in the browser. For
that, there&#39;s also a generator command:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">$<span> </span>bin/rails<span> </span>wasmify:pwa

<span>  </span>create<span>  </span>pwa
<span>  </span>create<span>  </span>pwa/boot.html
<span>  </span>create<span>  </span>pwa/boot.js
<span>  </span>...
<span>  </span>prepend<span>  </span>config/wasmify.yml
</code></pre></devsite-code>
<p>The previous command generates a minimal PWA application built with
<a href="https://vite.dev/">Vite</a> that can be used locally to test the compiled Rails
Wasm module or be deployed statically to distribute the app.</p>

<p>Now, with the launcher, all you need is to pack the whole application into a
single Wasm binary:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">$<span> </span>bin/rails<span> </span>wasmify:pack
...
Packed<span> </span>the<span> </span>application<span> </span>to<span> </span>pwa/app.wasm
Size:<span> </span><span>76</span>.2<span> </span>MB
</code></pre></devsite-code>
<p>That&#39;s it! Run the launcher app and see your Rails blogging application running
fully within the browser:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Bash"><code translate="no" dir="ltr">$<span> </span><span>cd</span><span> </span>pwa/

$<span> </span>yarn<span> </span>dev

<span>  </span>VITE<span> </span>v4.5.5<span>  </span>ready<span> </span><span>in</span><span> </span><span>290</span><span> </span>ms

<span>  </span>➜<span>  </span>Local:<span>   </span>http://localhost:5173/
</code></pre></devsite-code>
<p>Go to <a href="http://localhost:5173">http://localhost:5173</a>, wait a bit for the
&#34;Launch&#34; button to become active, and click it—enjoy working with the Rails app
running locally in your browser!</p>

<p><img src="https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld.png" alt="A Ruby on Rails blog launched from a browser tab running in another browser tab." srcset="https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_36.png 36w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_48.png 48w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_72.png 72w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_96.png 96w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_480.png 480w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_720.png 720w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_856.png 856w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_960.png 960w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_1440.png 1440w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_1920.png 1920w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--zy63y1yawld_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/></p>

<p>Doesn&#39;t it feel like magic running a monolithic server-side application not just
on your machine but within the browser sandbox? For me (even though I&#39;m the
&#34;sorcerer&#34;), it still looks like a fantasy. But there is no magic involved, only
the progress of technology.</p>

<h2 id="demo" data-text="Demo" tabindex="-1">Demo</h2>

<p>You can experience the demo embedded in the article or launch the <a href="https://rails-blog-on-wasm.vladem.com/boot.html">demo in a
standalone window</a>. Check out
the <a href="https://github.com/palkan/rails-15min-blog-on-wasm">source code on
GitHub</a>.</p>



<h2 id="behind_the_scenes_of_rails_on_wasm" data-text="Behind the scenes of Rails on Wasm" tabindex="-1">Behind the scenes of Rails on Wasm</h2>

<p>To better understand the challenges (and solutions) of packing a server-side
application into a Wasm module, the rest of this post explains the components
that are part of this architecture.</p>

<p>A web application depends on many more things than just a programming language
used to write the application code. Each component must also be brought to
your_ local deployment environment_—the browser. What&#39;s exciting about the &#34;blog
in 15 minutes&#34; demo, is that this can be achieved without rewriting the
application code. The same code was used to run the application in a classic,
server-side mode and in the browser.</p>

<p><img src="https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi.png" alt="The components that make up a Ruby on Rails app: a web server, a database, a queue, and storage. Plus the core Ruby components: the gems, native extensions, system tools, and the Ruby VM." srcset="https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_36.png 36w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_48.png 48w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_72.png 72w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_96.png 96w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_480.png 480w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_720.png 720w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_856.png 856w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_960.png 960w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_1440.png 1440w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_1920.png 1920w,https://web.dev/static/blog/ruby-on-rails-on-webassembly/webdevrubyonra--ova3x5e0ifi_2880.png 2880w" sizes="(max-width: 840px) 100vw, 856px"/></p>

<p>A framework, like Ruby on Rails, gives you an interface, an abstraction to
<em>communicate</em> with infrastructure components. The following section discusses
how you can employ the framework architecture to serve the somewhat esoteric
local serving needs.</p>

<h3 id="the_foundation_rubywasm" data-text="The foundation: ruby.wasm" tabindex="-1">The foundation: ruby.wasm</h3>

<p>Ruby became officially
<a href="https://www.ruby-lang.org/en/news/2022/12/25/ruby-3-2-0-released/">Wasm-ready in 2022</a>
(since version 3.2.0) meaning that the C source code could be compiled to Wasm
and bring a Ruby VM anywhere you want. The
<a href="https://github.com/ruby/ruby.wasm">ruby.wasm</a> project ships precompiled modules
and JavaScript bindings to run Ruby in the browser (or any other JavaScript
runtime). The ruby:wasm project also comes with the build tools that lets You
build a custom Ruby version with additional dependencies—this is very
important for projects relying on libraries with C extensions. Yes, you can
compile native extensions into Wasm, too! (Well, not any extension yet, but most
of them).</p>

<p>Currently, Ruby fully supports the WebAssembly System Interface, <a href="https://wasi.dev/interfaces#wasi-01">WASI
0.1</a>. <a href="https://wasi.dev/interfaces#wasi-02">WASI
0.2</a> which includes the <a href="https://component-model.bytecodealliance.org/">Component
Model</a> is already in the alpha
state and a few steps from completion.Once WASI 0.2 is supported it will
eliminate the current need of recompiling the whole language every time you need
to add new native dependencies: they could be componentized.</p>

<p>As a side effect, the Component Model should also help with reducing the bundle
size.
You can learn more about the ruby.wasm development and progress from the
<a href="https://speakerdeck.com/kateinoigakukun/what-you-can-do-with-ruby-on-webassembly">What you can do with Ruby on WebAssembly</a>
talk.</p>

<p>So, the Ruby part of the Wasm equation is solved. But Rails as a web framework
needs all of the components shown in the previous diagram. Read on to learn how
to put other components into the browser and link them together in Rails.</p>

<h3 id="connect_to_a_database_running_in_the_browser" data-text="Connect to a database running in the browser" tabindex="-1">Connect to a database running in the browser</h3>

<p>SQLite3 comes with an official <a href="https://sqlite.org/wasm/doc/trunk/index.md">Wasm
distribution</a> and a corresponding
<a href="https://www.npmjs.com/package/@sqlite.org/sqlite-wasm">JavaScript wrapper</a>,
therefore is ready to be embedded in-browser. PostgreSQL for Wasm is available
through the <a href="https://pglite.dev/">PGlite</a> project. Therefore, you only need to
figure out how to connect to the in-browser database from the Rails on Wasm
application.</p>

<p>A component, or <em>sub-framework</em>, of Rails responsible for data modeling and
database interactions is called Active Record (yes, named after the <a href="https://en.wikipedia.org/wiki/Active_record_pattern">ORM design
pattern</a>). Active Record
abstracts away the actual SQL-speaking database implementation from the
application code through the database adapters. Out of the box, Rails gives you
SQLite3, PostgreSQL, and MySQL adapters. However, they all assume connecting to
<em>real</em> databases available over the network. To overcome this, you can write
your own adapters to connect to <em>local</em>, in-browser databases!</p>

<p>This is how SQLite3 Wasm and PGlite adapters implemented as a part of the
Wasmify Rails project are created:</p>

<ul>
<li>The adapter class inherits from the corresponding built-in adapter (for
example, <code translate="no" dir="ltr">class PGliteAdapter &lt; PostgreSQLAdapter</code>), so you can re-use the
actual query preparation and results parsing logic.</li>
<li>Instead of the low-level database connection, you use an <strong>external
interface</strong> object that lives in the JavaScript runtime—a bridge between a
Rails Wasm module and a database.</li>
</ul>

<p>For example, here is the bridge implementation for SQLite3 Wasm:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="JavaScript"><code translate="no" dir="ltr"><span>export</span><span> </span><span>function</span><span> </span><span>registerSQLiteWasmInterface</span><span>(</span><span>worker</span><span>,</span><span> </span><span>db</span><span>,</span><span> </span><span>opts</span><span> </span><span>=</span><span> </span><span>{})</span><span> </span><span>{</span>
<span>  </span><span>const</span><span> </span><span>name</span><span> </span><span>=</span><span> </span><span>opts</span><span>.</span><span>name</span><span> </span><span>||</span><span> </span><span>&#34;sqliteForRails&#34;</span><span>;</span>

<span>  </span><span>worker</span><span>[</span><span>name</span><span>]</span><span> </span><span>=</span><span> </span><span>{</span>
<span>    </span><span>exec</span><span>:</span><span> </span><span>function</span><span> </span><span>(</span><span>sql</span><span>)</span><span> </span><span>{</span>
<span>      </span><span>let</span><span> </span><span>cols</span><span> </span><span>=</span><span> </span><span>[];</span>
<span>      </span><span>let</span><span> </span><span>rows</span><span> </span><span>=</span><span> </span><span>db</span><span>.</span><span>exec</span><span>(</span><span>sql</span><span>,</span><span> </span><span>{</span><span> </span><span>columnNames</span><span>:</span><span> </span><span>cols</span><span>,</span><span> </span><span>returnValue</span><span>:</span><span> </span><span>&#34;resultRows&#34;</span><span> </span><span>});</span>

<span>      </span><span>return</span><span> </span><span>{</span>
<span>        </span><span>cols</span><span>,</span>
<span>        </span><span>rows</span><span>,</span>
<span>      </span><span>};</span>
<span>    </span><span>},</span>

<span>    </span><span>changes</span><span>:</span><span> </span><span>function</span><span> </span><span>()</span><span> </span><span>{</span>
<span>      </span><span>return</span><span> </span><span>db</span><span>.</span><span>changes</span><span>();</span>
<span>    </span><span>},</span>
<span>  </span><span>};</span>
<span>}</span>
</code></pre></devsite-code>
<p>From the application perspective, the shift from a <em>real</em> database to an
in-browser one is just a matter of configuration:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="YAML"><code translate="no" dir="ltr"><span># config/database.yml</span>
<span>development</span><span>:</span>
<span>  </span><span>adapter</span><span>:</span><span> </span><span>sqlite3</span>

<span>production</span><span>:</span>
<span>  </span><span>adapter</span><span>:</span><span> </span><span>sqlite3</span>

<span>wasm</span><span>:</span>
<span>  </span><span>adapter</span><span>:</span><span> </span><span>sqlite3_wasm</span>
<span>  </span><span>js_interface</span><span>:</span><span> </span><span>&#34;sqliteForRails&#34;</span>
</code></pre></devsite-code>
<p>Working with a local database doesn&#39;t require a lot of effort. However, if data
synchronization with some <em>central</em> source of truth is required, then you may
face a challenge of a higher level. This question is out of the scope of this
post (hint: check out the
<a href="https://github.com/palkan/rails-on-wasm-playground/pull/7">Rails on PGlite and ElectricSQL demo</a>).</p>

<h2 id="service_worker_as_a_web_server" data-text="Service worker as a web server" tabindex="-1">Service worker as a web server</h2>

<p>Another essential component of any web application is a web server. Users
interact with web applications using HTTP requests. Thus, you need a way to route
HTTP requests triggered by navigation or form submissions to your Wasm module.
Luckily, the browser has an answer for that—<strong>service workers</strong>.</p>

<p>A service worker is a special kind of a Web Worker that acts as a proxy between
the JavaScript application and the network. It can intercept requests and
manipulate them, for example: serve cached data, redirect to other URLs or… to
Wasm modules! Here is a sketch of a service working serving requests using a
Rails application running in Wasm:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="JavaScript"><code translate="no" dir="ltr"><span>// The vm variable holds a reference to the Wasm module with a</span>
<span>// Ruby VM initialized</span>
<span>let</span><span> </span><span>vm</span><span>;</span>
<span>// The db variable holds a reference to the in-browser</span>
<span>// database interface</span>
<span>let</span><span> </span><span>db</span><span>;</span>

<span>const</span><span> </span><span>initVM</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>(</span><span>progress</span><span>,</span><span> </span><span>opts</span><span> </span><span>=</span><span> </span><span>{})</span><span> </span><span>=</span>&gt;<span> </span><span>{</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>vm</span><span>)</span><span> </span><span>return</span><span> </span><span>vm</span><span>;</span>
<span>  </span><span>if</span><span> </span><span>(</span><span>!</span><span>db</span><span>)</span><span> </span><span>{</span>
<span>    </span><span>await</span><span> </span><span>initDB</span><span>(</span><span>progress</span><span>);</span>
<span>  </span><span>}</span>
<span>  </span><span>vm</span><span> </span><span>=</span><span> </span><span>await</span><span> </span><span>initRailsVM</span><span>(</span><span>&#34;/app.wasm&#34;</span><span>);</span>
<span>  </span><span>return</span><span> </span><span>vm</span><span>;</span>
<span>};</span>

<span>const</span><span> </span><span>rackHandler</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>RackHandler</span><span>(</span><span>initVM</span><span>});</span>

<span>self</span><span>.</span><span>addEventListener</span><span>(</span><span>&#34;fetch&#34;</span><span>,</span><span> </span><span>(</span><span>event</span><span>)</span><span> </span><span>=</span>&gt;<span> </span><span>{</span>
<span>  </span><span>// ...</span>
<span>  </span><span>return</span><span> </span><span>event</span><span>.</span><span>respondWith</span><span>(</span>
<span>    </span><span>rackHandler</span><span>.</span><span>handle</span><span>(</span><span>event</span><span>.</span><span>request</span><span>)</span>
<span>  </span><span>);</span>
<span>});</span>
</code></pre></devsite-code>
<p>The &#34;fetch&#34; is triggered every time a request is made by the browser. You can
obtain the request information (URL, HTTP headers, body) and construct your own
request object.</p>

<p>Rails, like most Ruby web applications, relies on the <a href="https://github.com/rack/rack">Rack
interface</a> for working with HTTP requests. Rack
interface describes the format of the request and response objects as well as
the interface of the underlying HTTP handler (application). You can express
these properties as follows:</p>
<devsite-code><pre translate="no" dir="ltr" is-upgraded="" syntax="Ruby"><code translate="no" dir="ltr"><span>request</span><span> </span><span>=</span><span> </span><span>{</span>
<span>   </span><span>&#34;REQUEST_METHOD&#34;</span><span> </span><span>=</span>&gt;<span> </span><span>&#34;GET&#34;</span><span>,</span>
<span>   </span><span>&#34;SCRIPT_NAME&#34;</span><span>    </span><span>=</span>&gt;<span> </span><span>&#34;&#34;</span><span>,</span>
<span>   </span><span>&#34;SERVER_NAME&#34;</span><span>  </span><span>=</span>&gt;<span> </span><span>&#34;localhost&#34;</span><span>,</span>
<span>   </span><span>&#34;SERVER_PORT&#34;</span><span> </span><span>=</span>&gt;<span> </span><span>&#34;3000&#34;</span><span>,</span>
<span>   </span><span>&#34;PATH_INFO&#34;</span><span>      </span><span>=</span>&gt;<span> </span><span>&#34;/posts&#34;</span>
<span>}</span>

<span>handler</span><span> </span><span>=</span><span> </span><span>proc</span><span> </span><span>do</span><span> </span><span>|</span><span>env</span><span>|</span>
<span>  </span><span>[</span>
<span>    </span><span>200</span><span>,</span>
<span>    </span><span>{</span><span>&#34;Content-Type&#34;</span><span> </span><span>=</span>&gt;<span> </span><span>&#34;text/html&#34;</span><span>},</span>
<span>    </span><span>[</span><span>&#34;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;Hello Web!&lt;/body&gt;&lt;/html&gt;&#34;</span><span>]</span>
<span>  </span><span>]</span>
<span>end</span>

<span>handler</span><span>.</span><span>call</span><span>(</span><span>request</span><span>)</span><span> </span><span>#=&gt; [200, {...}, [...]]</span>
</code></pre></devsite-code>
<p>If you found the request format familiar, then you&#39;ve probably worked with
<a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a> back in the
days.</p>

<p>The <code translate="no" dir="ltr">RackHandler</code> JavaScript object is responsible for converting requests and
responses between JavaScript and Ruby realms. Given that Rack is used by most
Ruby web applications, the implementation becomes universal, not Rails-specific.
The
<a href="https://github.com/palkan/wasmify-rails/blob/main/src/rack.js">actual implementation</a>
is too long to post here though.</p>

<p>A service worker is one of the key integral points of an in-browser web
application. It&#39;s not only an HTTP proxy, but also a caching layer and a
<em>network switcher</em> (that is, you can build a <em>local-first</em> or <em>offline-capable</em>
application). This is also a component that can help you serve user-uploaded
files.</p>

<h3 id="keep_file_uploads_in_the_browser" data-text="Keep file uploads in the browser" tabindex="-1">Keep file uploads in the browser</h3>

<p>One of the first additional features to implement in your fresh blog application
is likely to be support for file uploads, or more specifically, attaching images
to posts. To achieve this, you need a way to store and serve files.</p>

<p>In Rails, the part of the framework responsible for dealing with file uploads is
called <a href="https://guides.rubyonrails.org/active_storage_overview.html">Active
Storage</a>. Active
Storage gives developers abstractions and interfaces to work with files without
thinking about the low-level storage mechanism. No matter where you store your
files, on a hard drive or in the cloud, the application code stays unaware of
it.</p>

<p>Similarly to Active Record, in order to support a custom storage mechanism, all
you need is to implement a corresponding <em>storage service</em> adapter. Where to
store files in the browser?</p>

<p>The traditional option is to use a database. Yes, you can store files as blobs
in the database, no additional infrastructure components required. And there is
already a ready-made plugin for that in Rails,
<a href="https://github.com/WizardComputer/activestorage_database">Active Storage Database</a>.
However, serving files stored in a database through the Rails application
running within WebAssembly is not ideal because it involves rounds of
(de-)serialization that are not free.</p>

<p>A better and more browser-optimized solution would be to use File System APIs
and process file uploads and server uploaded files directly from the service
worker. A perfect candidate for such infrastructure is the
<a href="https://developer.mozilla.org/docs/Web/API/File_System_API/Origin_private_file_system">OPFS</a>
(origin private file system), a very recent browser API that will definitely
play an important role for the future in-browser applications.</p>

<h2 id="what_rails_and_wasm_can_achieve_together" data-text="What Rails and Wasm can achieve together" tabindex="-1">What Rails and Wasm can achieve together</h2>

<p>I&#39;m pretty sure you&#39;ve been asking yourself this question as you started reading
the article: why run a server-side framework in the browser?
The idea of a framework or a library being server-side (or client-side) is just
a label. Good code and, especially, a good abstraction works everywhere. Labels
shouldn&#39;t stop you from exploring new possibilities and pushing boundaries of
the framework (for example, Ruby on Rails) as well as the boundaries of the
runtime (WebAssembly). Both could benefit from such unconventional use cases.</p>

<p>There are plenty of <em>conventional</em>, or practical, use cases, too.</p>

<p>First, bringing the framework to the browser opens enormous <strong>learning and
prototyping opportunities</strong>. Imagine being able to play with libraries, plugins,
and patterns right in your browser and together with other people.
<a href="https://stackblitz.com/">Stackblitz</a> made this possible for JavaScript
frameworks. Another example is a <a href="https://web.dev/articles/wordpress-playground">WordPress
Playground</a> that made it possible
to play with WordPress themes without leaving the web page. Wasm could enable
something similar for Ruby and its ecosystem.</p>

<p>There&#39;s a special case of in-browser coding especially useful to open source
developers—<strong>triaging and debugging issues</strong>. Again, StackBlitz made this a
thing for JavaScript projects: you create a minimal reproduction script, point
at the link in a GitHub Issue, and spare maintainers the time on reproducing
your scenario. And, actually, it&#39;s already started happening in Ruby thanks to
the <a href="https://runruby.dev/">RunRuby.dev</a> project (here is an
<a href="https://github.com/palkan/action_policy-graphql/issues/53#issuecomment-2492483778">example issue</a>
resolved with the in-browser reproduction).</p>

<p>Another use case is <strong>offline-capable</strong> (or offline-aware) <strong>applications</strong>.
Offline-capable applications that usually work using the network, but when there
is no connection, they stay usable. For example, an email client that lets you
search through your inbox while offline. Or, a music library application with
the &#34;Store on device&#34; capability, so your favourite music keeps beating even if
there is no network connection. Both examples depend on the <strong>data stored
locally</strong>, not just using a cache as with classic PWAs.</p>

<p>Finally, building local (or desktop) applications with Rails also makes sense,
because the productivity the framework gives you doesn&#39;t depend on the runtime.
Full-featured frameworks suit well for building personal data- and logic-heavy
applications. And using Wasm as a portable distribution format is also a viable
option.</p>

<p>It&#39;s just the beginning of this Rails on Wasm journey. You can learn more about
the challenges and solutions in the
<a href="https://writebook-on-wasm.fly.dev/5/ruby-on-rails-on-webassembly/">Ruby on Rails on WebAssembly</a>
ebook (which, by the way, is an offline-capable Rails application itself).</p>

  

  
</div></div>
  </body>
</html>
