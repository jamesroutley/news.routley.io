<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lelanthran.com/chap9/content.html">Original</a>
    <h1>The C Programming Language: Myths and Reality</h1>
    
    <div id="readability-page-1" class="page">

<blockquote>
<p>The Internet is the first thing that humanity has built that humanity doesn’t understand, the largest experiment in anarchy that we have ever had.</p>
<pre><code>-- Eric Schmidt</code></pre>
</blockquote>
<hr/>

<p>
Posted by Lelanthran
</p>

<p>
2023-06-28
</p>

<table>
<tbody>
<tr>
<td><img src="https://imgs.xkcd.com/comics/duty_calls.png" alt="Balance!"/></td>
</tr>
<tr>
<td><em>Balance!</em></td>
</tr>
</tbody>
</table>
<p>All too often someone, somewhere, on some forum … will lament the lack of encapsulation and isolation in the <em>C programming language</em>. This happens with such regularity that I now feel compelled to address the myth once and forever. This means I can post links to this page for any future assertion of that nature without having to retype the explanation in everytime <a href="https://xkcd.com/386/">someone is wrong on the internet</a></p>
<p>Just to be clear, <em>C</em> is an old language lacking many, many, <em>many</em> modern features. One of the features it <em>does not lack</em> is encapsulation and isolation.</p>

<p>Lets look at a class definition that has <code>private</code> members; after all, that’s where the isolation comes from, right? If all the fields were public, then it’d be just like <em>C</em> but with inheritance.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>class</span> <span>StringBuilder</span> {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>   <span>private</span> <span>String</span> payload;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>   <span>public</span> <span>void</span> <span>Append</span>(<span>String</span> snippet) {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>      payload = payload + snippet;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>   }</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>};</span></code></pre></div>
<p>Any attempt by a caller to access the field <code>payload</code> results in a compilation error. Pretty nifty. You can see why this can be useful.</p>
<table>
<tbody>
<tr>
<td><img src="https://turnoff.us/image/en/private-cloud.png" width="300" alt="PrivateWrong!"/></td>
</tr>
<tr>
<td><em>Private Wrong, a Major Pain!</em></td>
</tr>
</tbody>
</table>
<p>The <em>C</em> programming language doesn’t have classes<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>, but it does have <code>structs</code>, which look like this:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>struct</span> StringBuilder {</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>   <span>char</span> *payload;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>};</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span>void</span> Append(<span>struct</span> StringBuilder *obj, <span>const</span> <span>char</span> *snippet);</span></code></pre></div>
<p>There are no access modifiers; all fields in a struct are public. This is why there is always someone complaining that <em>C</em> doesn’t provide encapsulation or isolation: everything is visible in a struct, to everyone, all the time, even the callers of the function <code>Append()</code>.</p>

<p>The complaint isn’t necessarily true. While you <em>can indeed</em> dump everything into a single source file and call it a day, the more common option is to split things into different files and modules.</p>
<p>When code is in different source files, they <em>are</em> are encapsulated into a <em>module</em>. Each <em>“module”</em> in <em>C</em> consists of an interface file which callers can use to call functions which exist in the implementation file.</p>
<p>The interface file, called the <strong>header file</strong> (with a file extension of <code>.h</code>) is a <strong>contract</strong> that tells the user of the module what functions and types are needed to use the implementation, frequently simply called the <strong>source file</strong>. After compilation, you might have a compiled <strong>implementation</strong>, and thus may not even have access to the source code of <code>Append()</code>.</p>

<p>The calling programs <strong>have</strong> to use the <em>header file</em> in order to make legal (under <em>C</em>) calls to <code>Append()</code>; the implementation might only be available in compiled form, after all, and not source code form.</p>
<p>So, in the header you do:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span>typedef</span> <span>struct</span> StringBuilder StringBuilder;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span>void</span> Append(StringBuilder *obj, <span>const</span> <span>char</span> *snippet);</span></code></pre></div>
<p>In the implementation you do:</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span>struct</span> StringBuilder {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>   <span>char</span> *payload;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>};</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span>void</span> Append(StringBuilder *obj, <span>const</span> <span>char</span> *snippet)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>{</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>   ...</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>And … that’s <em>it!</em></p>
<p>Now any code using a struct of type <code>StringBuilder</code> can use it all they want to build up a string, but they can never see the fields within it.</p>
<p>Hell, they cannot even <code>malloc()</code> their own <code>StringBuilder</code> instance, because even the size of the <code>StringBuilder</code> is hidden. They have to use creation and deletion functions provided in the implementation as specified in the interface.</p>

<p>So now you have a way to create an instance of an object with all its fields hidden from any caller. You have also forced all callers to stop messing about with the fields in your object - all access to the object is guarded by the functions in the implementation (as specified in the header).</p>
<p>You don’t have inheritance, but you <em>do</em> have one very important characteristic: you can create objects from this class, and use them, from within Python.</p>
<p>Or PHP.</p>
<p>Ruby, even.</p>
<p>It’ll work with most Lisp implementations.</p>
<p>You can call it from Java.</p>
<p>In fact, I don’t believe there is a single programming language in common use which <em>cannot</em> use this object. In many cases the programmer from the other language won’t even have to do much work to use this class.<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>]</p>
<p>My <code>Makefiles</code> already have rules to <strong>automatically</strong> generate the interface so that the <em>C</em> code I write in this manner is callable from within Android applications.</p>

<p>And that’s how you get encapsulation and isolation with strong guarantees in <em>C</em>. Don’t believe everything you read on the internet.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<hr/>

<p>
Posted by Lelanthran
</p>

<p>
2023-06-28
</p>



</div>
  </body>
</html>
