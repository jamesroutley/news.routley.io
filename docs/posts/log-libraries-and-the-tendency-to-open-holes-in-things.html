<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2021/12/18/log/">Original</a>
    <h1>Log libraries and the tendency to open holes in things</h1>
    
    
<p>
Logging stuff is in the news this week.  Specifically, people with Java 
and log4j somewhere in their lives are having a miserable time.  I 
figured I'd re-tell a story about terrible things done by way of a bunch 
of feature-rich libraries and dubious interconnections.  I've mentioned 
this in passing before, but this time I've tried to be much more 
specific about how it works.
</p><p>
This is a tale that's happened at multiple distinct companies, and I 
have to imagine it's happening (or *is happening*) at several more.  
Note that while I'm picking on the G* stuff here since it's open source 
and thereby more likely to resonate with readers, reimplementations of 
these libraries under other names have also introduced the same 
problems to those companies.
</p><p>
Part 1: the flags.
</p><p>
There is a C++ library called GFLAGS.  The "G" implies it came from 
Google, and that's good, because it did.  It works by letting you call a 
DEFINE_xxxx macro in the top of your code, regardless of how deep in the 
code it's buried.  This then becomes a global (!) flag/argument.  
</p><p>
<pre>
DEFINE_bool(enable_foo, false, "Enable the foo feature");
 
...
 
void my_func() {
  if (FLAGS_enable_foo) {
    do_something();
  }
}
</pre>
</p><p>
Besides being accessible from anywhere in the scope where you did the 
DEFINE, you can also do an equivalent DECLARE_xxxx and then make it 
available in your scope.  You can do this from a completely separate 
compilation unit, even, as long as it eventually gets linked with 
something else that did that DEFINE for you.
</p><p>
<pre>
DECLARE_bool(enable_foo);
 
...
 
void other_func() {
  // Turns out we need foo enabled to do our stuff.
  FLAGS_enable_foo = true;
  // ...
}
</pre>
</p><p>
If you're wondering how some code that's buried so deeply in the program 
can get to see what's in the commandline args, that's easy.  There's 
usually an InitCompanyName() function that you call from inside your 
main() where you pass it argc and argv, so it gets to consume all of 
that tasty config data.
</p><p>
<pre>
int main(int argc, char** argv) {
  InitCompany(argc, argv);  // populates FLAGS_ of all kinds
  // ...
}
</pre>
</p><p>
So, when you call that program with --enable_foo, it flips that bool to 
true.  Or, when something makes other_func() run, it also flips that 
bool to true.  Anything can read or write these things, so keep that in 
mind as you follow the rest of the story.
</p><p>
Part 2: the logs.
</p><p>
Next up is GLOG, and as you may have derived from the name, it's a C++ 
library from Google that does logging.  When it's being used, it 
frequently shows up like this:
</p><p>
<pre>
  LOG(INFO) &lt;&lt; "Something happened, value=" &lt;&lt; value;
</pre>
</p><p>
GLOG is no small thing, and it has tons of features.  It can log to 
stderr, sure, but it can also log directly to a file.  How does this 
work?  Oh, that's easy: it uses GFLAGS, naturally, and it has a flag for 
that!  Set it to log to a file and it totally will log to that file.
</p><p>
One of its many features is "log to email".  Yep, you can set up an 
e-mail address, and any time it has something to say, it'll kick off 
/usr/lib/sendmail and deliver the log message that way.  You'll find a 
flag for turning on that feature, and another for setting the e-mail 
address.
</p><p>
Oh, but what if your tool to send mails isn't at that exact path?  No 
problem!  There's another flag which will let you point at something 
else.  You can have it use /usr/local/my_company/mail/sender instead.
</p><p>
Part 3: the status wrappers.
</p><p>
The company might have a small HTTP or RPC server that automatically 
gets baked into most network server software.  It comes up on a given 
port and it hands out status information about the program.  It might do 
things like export the values of counters so that something else can 
fetch them and store them, so yet another tool can be used to monitor 
and/or graph them.
</p><p>
It might even export the program's internal config values, like 
whatever it read from a config file.  This way you can see what it is 
actually using to make its decisions instead of trying to guess what the 
state is like inside the program.
</p><p>
Invariably, someone wires this up to GFLAGS, so now you can see what 
*all* of those global config flags are set to.  This is pretty 
interesting, since now you can get some idea of what args are being used 
with a given instance of your server software.
</p><p>
In my experience, this sort of thing appears both via a simple HTTP URL 
and over some kind of company-specific RPC mechanism, such that you can 
fire off a GET /something (if HTTP) or a GetFlags (if RPC) type request 
and get back all of the flags and their settings.
</p><p>
Can you guess what happens next?
</p><p>
Part 4: the status setters.
</p><p>
Someone eventually decides that it would be an <em>amazing feature</em> 
if those HTTP and RPC interfaces could also be used to *change* the 
settings of those GFLAGS.  Imagine that!  You're running something, and 
you forget to set verbose mode, and you really, really need to debug it 
without restarting it.
</p><p>
Have no fear!  Hit the right HTTP endpoint and just _set_ verbose to 1!
Or, equivalently, poke it with the right RPC with the variable name of 
"verbose" and a new value of "1".
</p><p>
Either way, somewhere inside the code, something is reaching into the 
global set of GFLAGS and is setting the value to whatever you just 
handed it.  This becomes effective immediately and then there's your 
verbose debugging info, all without restarting a thing.
</p><p>
You might think this is awesome, but it's usually not, all because of 
what comes after this.
</p><p>
Part 5: the snarky engineers.
</p><p>
Sooner or later, someone puts all of this together in their head and 
realizes they now have a giant hole that they can exploit for their own 
purposes.  The chained logic goes like this:
</p><p>
<ol>
<li>You go searching around the company's code base for "exec()" or 
"system()" or similar and turn up the logging code with its email 
feature.
</p><p>
<li>You discover this logging code will execute an external program 
when it's set to "log to email". 
</p><p>
<li>If only the external program was something I controlled...
</p><p>
<li>... and if only I could enable the "log to email" mode...
</p><p>
<li>Hmm, these are all controlled by GFLAGS.
</p><p>
<li>Wait a minute, they export GFLAGS through a public HTTP and/or RPC 
interface!
</p><p>
<li>Does that interface let me CHANGE values?  IT DOES!
</p><p>
<li>So can I say mail_program = /my/evil/path and then flip log_to_email 
to TRUE?  I CAN!
</p><p>
<li>Can I then get it to log something to run the logging path?  Sure!
Just poke it in such a way that it calls LOG for some reason.  If 
they love INFO logs, this should be trivial.
</p><p>
<li>And... okay, I own this thing.
</ol>
</p><p>
Around this point, the snarky engineers realize that every single 
program at $COMPANY uses this logging suite and so might be exposed this 
way.  It turns out the ones which don't listen to the network are not 
vulnerable, but anything running that HTTP status server or RPC 
subsystem *is*, and wow, is that a long list.
</p><p>
This is how a bunch of small bits of cleverness can multiply into a 
raging dumpster fire.
</p><p>
Incidentally, if you can't make it run a subprocess but can flip 
arbitrary flags as a completely unauthenticated requester, you can still 
have all kinds of evil fun with most programs.  Plenty of 
vulnerabilities exist which amount to "we have a debug flag which 
disables password checks that's only used by developers which is never 
set in prod, but someone used the flag-flipper to enable it in prod, 
and, well..."
</p><p>
You get the idea.  Runtime flag flipping and variable setting is scary.
</p>

  </body>
</html>
