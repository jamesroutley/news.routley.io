<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nick-black.com/dankwiki/index.php?title=PC_Fans">Original</a>
    <h1>More than you cared to know about PC fans</h1>
    
    <div id="readability-page-1" class="page"><div id="bodyContent"><div id="mw-content-text" lang="en" dir="ltr"><div><p>Fans, an active cooling element, move air in a system. Heat must be removed from the site of its production, and from the system as a whole. A fan increases heat convection with surrounding air via airflow. Air is at its highest pressure immediately in front of the fan, and at lowest pressure immediately behind it.
</p><p>Fans for personal computers are governed by specifications from Intel and <a href="https://nick-black.com/dankwiki/index.php?title=Noctua" title="Noctua">Noctua</a>:
</p>
<ul><li>Intel&#39;s <a rel="nofollow" href="https://www.intel.com/content/dam/support/us/en/documents/intel-nuc/intel-4wire-pwm-fans-specs.pdf">4-Wire Pulse Width Modulation Controlled Fans</a> spec, revision 1.3 (2005-09)</li>
<li>Noctua&#39;s <a rel="nofollow" href="https://noctua.at/pub/media/wysiwyg/Noctua_PWM_specifications_white_paper.pdf">PWM Specification White Paper</a> (unknown date, but it references 1.3 <i>ibid</i>)</li></ul>
<p>Almost all available fans are either 5V, 12V, or 24V, with 12V dominating personal computers:
</p>
<ul><li>there is no readily-available 24V source from an <a href="https://nick-black.com/dankwiki/index.php?title=ATX" title="ATX">ATX</a> power supply, but you&#39;ll see 24V in e.g. <a href="https://nick-black.com/dankwiki/index.php?title=3D_printers" title="3D printers">3D printers</a></li>
<li>5V fans are seen in conjunction with MCUs such as <a href="https://nick-black.com/dankwiki/index.php?title=Raspberry_Pi" title="Raspberry Pi">Raspberry Pi</a></li></ul>
<p>Fans operating at higher voltages will require less current for the same work. Two-pin fans offer neither feedback nor dedicated PWM control. Three-pin fans typically offer a tachometer signal on the third wire. Four-pin fans add a PWM control on the fourth wire. PWM is a <b>5V logical control</b> that does not modify supplied power. In the absence of PWM support, some control can be effected by varying voltage (voltage ought be held constant for a PWM fan), but since a minimum voltage is necessary to avoid stalling, only the higher-speed range is available. &#34;Low-frequency PWM&#34; applies PWM to the power wire itself, but suffers from audible commutation noise and must apply pulse stretching to the tachometer.
</p><p>Fans can be run at less than their maximum duty to reduce acoustic noise, consume less power, and potentially extend their lifetimes.
</p><p>I have collected extensive specs for <a href="https://nick-black.com/dankwiki/index.php?title=Noctua" title="Noctua">Noctua</a>, <a href="https://nick-black.com/dankwiki/index.php?title=Phanteks" title="Phanteks">Phanteks</a>, <a href="https://nick-black.com/dankwiki/index.php?title=EK-Vardar" title="EK-Vardar">EK-Vardar</a>, and <a href="https://nick-black.com/dankwiki/index.php?title=140mm_fans" title="140mm fans">140mm fans</a> in general (140mm fans are in many ways optimal for a <a href="https://nick-black.com/dankwiki/index.php?title=MORA3" title="MORA3">MORA3</a>).
</p>


<h2><span id="Power_draw">Power draw</span></h2>
<p>Intel&#39;s spec mandates 12V±5% (11.4–12.6V). A fan in its steady state operating in <a rel="nofollow" href="https://en.wikipedia.org/wiki/Freestream">freestream</a> (V<sub>∞</sub>) conditions ought not draw more than 1.5A (this would be a maximum of 18.9W; most consumer fans draw far less). During startup, 2.2A of inrush current may be drawn for a period of no more than 1s (27.72W).
</p><p>Note that the powerful (and bracingly loud) <a rel="nofollow" href="https://noctua.at/en/nf-f12-industrialppc-3000-pwm">Noctua iPPC-3000</a> is speced at 3.6W, i.e. 0.3 amps, just 20% of the allowed draw. On the other hand, truly industrial fans exist: Delta&#39;s <a rel="nofollow" href="https://www.delta-fan.com/technology/pfc1212de-f00.html">PFC1212DE</a> 5500RPM behemoth draws 4A for an out-of-spec 48W. At this point, system designers really must begin considering heat added to the system by the fan:
</p>
<blockquote><p>If the supply fan is downstream of the cooling coil in a draw-through configuration, the fan heat increases the supply air temperature, increasing the supply air volume required to meet a given space load. If the fan is upstream of the coil in a blow-through configuration, the fan heat is absorbed directly by the coil. In either case, the fan heat adds to the cooling coil load. —James S. Elleson, <i>Cold Air Distribution</i> (1996)</p></blockquote>
<p>Most motherboard fan headers (always 12V) are rated for between one and two amps. More current than this can be drawn from independently-powered fan controllers. One hears a rule of thumb that more than three consumer fans ought not be hooked up to a single header, but just add the damn amps and check the motherboard manual.
</p>
<h2><span id="PWM">PWM</span></h2>
<p>Pulse width modulation controls the power delivered by dividing time up into quanta, and supplying current only during part of each quantum. The signal is characterized by the quantum length (∝ 1/frequency); the level can then be varied from none to the entirety of the quantum. 100% PWM is equivalent to constant current supply, while 0% PWM is equivalent to no supply.
</p><p>PC fans are ideally controlled via 25KHz PWM, though the range 21KHz to 28KHz is deemed acceptable (why 21KHz? so that you can&#39;t hear it (more precisely, so that you can&#39;t hear the commutation noise from switching the drive coils on and off): children hear up to about 20KHz, adults 17). The PWM high signal ought be 5V with an absolute maximum of 5.25V. The absolute max current drawn is 5mA. The maximum value of logic low is 0.8V. In the absence of a valid signal, the fan ought run at maximum speed. Intel&#39;s document puts fairly strict requirements on the PWM-RPM relationship: the fan speed shall be a &#34;continuous and monotonic function of the duty cycle&#34; (a reasonable requirement), and furthermore that the effected speed, as a percentage of maximum speed, should match the PWM duty cycle to within ±10%. If the PWM duty cycle is e.g. 50%, and the fan&#39;s max speed is 1900 RPM, conformance requires fan speed of 760–1140 RPM. The response curve must thus be more-or-less linear in the large.
</p><p>Fans have a minimum rotation speed, corresponding to some minimum PWM duty cycle; duty cycles below this minimum result in the the fan running at less than or equal to the minimum speed (perhaps not running at all). The fan will never *start* spinning at less than the minimum rotation speed. The minimum rotation speed must not be more than 30% of the maximum speed.
</p><p><i>(an aside about Intel terminology: a &#34;Type A&#34; fan never shuts down, a &#34;Type B&#34; fan shuts down at 0% PWM, and a &#34;Type C&#34; fan shuts down at all PWM duty cycles below some threshold; one would think it sufficient to specify a &#34;maximum PWM for shutdown&#34; and simply specify -1 for &#34;Type A&#34; fans, but who knows?)</i>
</p>
<h3><span id="Controlling_PWM">Controlling PWM</span></h3>
<h4><span id="On_microcontrollers">On microcontrollers</span></h4>
<p>Controlling fans using a microcontroller has some complexity. The first difficulty is generating a 25KHz PWM signal. On <a href="https://nick-black.com/dankwiki/index.php?title=Arduino" title="Arduino">Arduino</a> UNOs and MEGAs, this is not available via the standard libraries, and the hardware must be programmed directly. Here&#39;s a sample implementation for the MEGA, providing eight-bit resolution (PWM values [0..255]), and using timer 5 for a PWM signal:
</p>
<div dir="ltr"><pre><span></span><span>static</span><span> </span><span>void</span><span> </span><span>setup_timers</span><span>(</span><span>int</span><span> </span><span>freq</span><span>){</span><span>      </span>
<span>  </span><span>TCCR5A</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>                                                                                                                       </span>
<span>  </span><span>TCCR5B</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>                                                                                                                       </span>
<span>  </span><span>TCNT5</span><span>  </span><span>=</span><span> </span><span>0</span><span>;</span><span>                                                                                                                       </span>
<span>  </span><span>// Mode 10: phase correct PWM with ICR5 as Top (phase-correct needs a                                                             </span>
<span>  </span><span>// factor of 2 in division below). OC5C as Non-Inverted PWM output.                                                               </span>
<span>  </span><span>// 16MHz / (25KHz * 2) == 320 cycles per interrupt.                                                                               </span>
<span>  </span><span>ICR5</span><span> </span><span>=</span><span> </span><span>(</span><span>F_CPU</span><span> </span><span>/</span><span> </span><span>freq</span><span>)</span><span> </span><span>/</span><span> </span><span>2</span><span>;</span><span>                                                                                                 </span>
<span>  </span><span>TCCR5A</span><span> </span><span>=</span><span> </span><span>_BV</span><span>(</span><span>COM5C1</span><span>)</span><span> </span><span>|</span><span> </span><span>_BV</span><span>(</span><span>WGM51</span><span>);</span><span>                                                                                                </span>
<span>  </span><span>TCCR5B</span><span> </span><span>=</span><span> </span><span>_BV</span><span>(</span><span>WGM53</span><span>)</span><span> </span><span>|</span><span> </span><span>_BV</span><span>(</span><span>CS50</span><span>);</span><span>                                                                                                  </span>
<span>}</span><span></span>

<span>static</span><span> </span><span>void</span><span> </span><span>set_pwm</span><span>(</span><span>unsigned</span><span> </span><span>pwm</span><span>){</span><span></span>
<span>  </span><span>OCR5C</span><span> </span><span>=</span><span> </span><span>ICR5</span><span> </span><span>*</span><span> </span><span>pwm</span><span> </span><span>/</span><span> </span><span>255</span><span>;</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>The relevant pin ought be placed into <tt>OUTPUT</tt> mode, and must be associated with timer 5 (say, Pin 44). No direct manipulation of the pins is necessary, and the PWM is handled in hardware.
</p><p>The <a href="https://nick-black.com/dankwiki/index.php?title=ESP32&amp;action=edit&amp;redlink=1" title="ESP32 (page does not exist)">ESP32</a>&#39;s <a rel="nofollow" href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/peripherals/ledc.html"><tt>ledc</tt></a> library can be harnessed to do this at a higher level, using hardware PWM. Supply a chosen channel (of 8) and an <tt>OUTPUT</tt> pin, together with a <tt>freq</tt> of 25000, to e.g.:
</p>
<div dir="ltr"><pre><span></span><span>static</span><span> </span><span>int</span><span> </span><span>initialize_pwm</span><span>(</span><span>ledc_channel_t</span><span> </span><span>channel</span><span>,</span><span> </span><span>int</span><span> </span><span>pin</span><span>,</span><span> </span><span>int</span><span> </span><span>freq</span><span>){</span><span>                                                                      </span>
<span>  </span><span>ledc_channel_config_t</span><span> </span><span>conf</span><span>;</span><span>                                                                                                       </span>
<span>  </span><span>memset</span><span>(</span><span>&amp;</span><span>conf</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>conf</span><span>));</span><span>                                                                                                   </span>
<span>  </span><span>conf</span><span>.</span><span>gpio_num</span><span> </span><span>=</span><span> </span><span>pin</span><span>;</span><span>                                                                                                              </span>
<span>  </span><span>conf</span><span>.</span><span>speed_mode</span><span> </span><span>=</span><span> </span><span>LEDC_HIGH_SPEED_MODE</span><span>;</span><span>                                                                                           </span>
<span>  </span><span>conf</span><span>.</span><span>intr_type</span><span> </span><span>=</span><span> </span><span>LEDC_INTR_DISABLE</span><span>;</span><span>                                                                                               </span>
<span>  </span><span>conf</span><span>.</span><span>timer_sel</span><span> </span><span>=</span><span> </span><span>FANPWM_TIMER</span><span>;</span><span>                                                                                                    </span>
<span>  </span><span>conf</span><span>.</span><span>duty</span><span> </span><span>=</span><span> </span><span>FANPWM_BIT_NUM</span><span>;</span><span>                                                                                                       </span>
<span>  </span><span>conf</span><span>.</span><span>channel</span><span> </span><span>=</span><span> </span><span>channel</span><span>;</span><span>                                                                                                           </span>
<span>  </span><span>if</span><span>(</span><span>ledc_channel_config</span><span>(</span><span>&amp;</span><span>conf</span><span>)</span><span> </span><span>!=</span><span> </span><span>ESP_OK</span><span>){</span><span>                                                                                         </span>
<span>    </span><span>return</span><span> </span><span>-1</span><span>;</span><span>                                                                                                                      </span>
<span>  </span><span>}</span><span>                                                                                                                                 </span>
<span>  </span><span>ledc_timer_config_t</span><span> </span><span>ledc_timer</span><span>;</span><span>                                                                                                   </span>
<span>  </span><span>memset</span><span>(</span><span>&amp;</span><span>ledc_timer</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>sizeof</span><span>(</span><span>ledc_timer</span><span>));</span><span>                                                                                       </span>
<span>  </span><span>ledc_timer</span><span>.</span><span>speed_mode</span><span> </span><span>=</span><span> </span><span>LEDC_HIGH_SPEED_MODE</span><span>;</span><span>                                                                                     </span>
<span>  </span><span>ledc_timer</span><span>.</span><span>bit_num</span><span> </span><span>=</span><span> </span><span>FANPWM_BIT_NUM</span><span>;</span><span>                                                                                              </span>
<span>  </span><span>ledc_timer</span><span>.</span><span>timer_num</span><span> </span><span>=</span><span> </span><span>FANPWM_TIMER</span><span>;</span><span>                                                                                              </span>
<span>  </span><span>ledc_timer</span><span>.</span><span>freq_hz</span><span> </span><span>=</span><span> </span><span>freq</span><span>;</span><span></span>
<span>  </span><span>if</span><span>(</span><span>ledc_timer_config</span><span>(</span><span>&amp;</span><span>ledc_timer</span><span>)</span><span> </span><span>!=</span><span> </span><span>ESP_OK</span><span>){</span><span>                                                                                     </span>
<span>    </span><span>return</span><span> </span><span>-1</span><span>;</span><span>                                                                                                                      </span>
<span>  </span><span>}</span><span>                                                                                                                                 </span>
<span>  </span><span>return</span><span> </span><span>0</span><span>;</span><span>                                                                                                                         </span>
<span>}</span><span></span>
</pre></div>
<p>and then set the PWM duty cycle by calling on that same channel:
</p>
<div dir="ltr"><pre><span></span><span>static</span><span> </span><span>int</span><span> </span><span>set_pwm</span><span>(</span><span>ledc_channel_t</span><span> </span><span>channel</span><span>,</span><span> </span><span>unsigned</span><span> </span><span>p</span><span>){</span><span>                                                                                                     </span>
<span>  </span><span>if</span><span>(</span><span>ledc_set_duty</span><span>(</span><span>LEDC_HIGH_SPEED_MODE</span><span>,</span><span> </span><span>channel</span><span>,</span><span> </span><span>p</span><span>)</span><span> </span><span>!=</span><span> </span><span>ESP_OK</span><span>){</span><span>                                                                 </span>
<span>    </span><span>return</span><span> </span><span>-1</span><span>;</span><span>                                                                                                                      </span>
<span>  </span><span>}</span><span></span>
<span>  </span><span>if</span><span>(</span><span>ledc_update_duty</span><span>(</span><span>LEDC_HIGH_SPEED_MODE</span><span>,</span><span> </span><span>channel</span><span>)</span><span> </span><span>!=</span><span> </span><span>ESP_OK</span><span>){</span><span>                                                           </span>
<span>    </span><span>return</span><span> </span><span>-1</span><span>;</span><span>                                                                                                                      </span>
<span>  </span><span>}</span><span>                                                                                                                                 </span>
<span>  </span><span>return</span><span> </span><span>0</span><span>;</span><span>                                                                                                                         </span>
<span>}</span><span></span>
</pre></div>
<p>The ESP8266 requires a call to <tt>analogWriteFreq(25000);</tt> before using <tt>analogWrite()</tt> to set an 8-bit duty cycle. This is a global setting, and will affect any other <tt>analogWrite()</tt>s in your program. If you don&#39;t like it, you can always bitbang.
</p><p>Note that 25KHz is beyond the capability of many general-purpose PWM ICs (e.g. TLC5940, PCA9685).
</p>
<h4><span id="On_Linux">On Linux</span></h4>
<p>PWM fans are controlled through the <a rel="nofollow" href="https://www.kernel.org/doc/Documentation/hwmon/sysfs-interface"><tt>hwmon</tt></a> <a href="https://nick-black.com/dankwiki/index.php?title=Sysfs" title="Sysfs">sysfs</a> interface, using the &#34;PWM&#34; type (<i>not</i> the &#34;fan&#34; type). This is dependent on your hardware controller (usually some SMBus shadynasty on the motherboard) being supported and detected. You&#39;ll need set <tt>pwmX_enable</tt> to 1 for manual control, at which point you ought be able to write a value [0..255] to <tt>pwmX</tt>. When the PWM is under automatic control, you ought be able to read the current level by reading this latter file.
</p>
<h2><span id="Tachometer">Tachometer</span></h2>
<p>Two pulses (momentarily closed circuit) per revolution on an <a rel="nofollow" href="https://en.wikipedia.org/wiki/Open_collector">open collector</a>. Maximum current is 5mA for 5V and 12V fans, and 2mA for 24V fans. V<sub>CC</sub> ought be 13V for 12V fans (so claims Noctua. Other places, and my experience, suggest that 5V is sufficient), and 6V for 5V and 24V fans, necessitating at least the following pullup resistors:
</p>
<ul><li>5V: 1.2KΩ (6V, 5mA)</li>
<li>12V: 2.6KΩ (13V, 5mA) (or 1KΩ assuming 5V, see above)</li>
<li>24V: 3KΩ (6V, 2mA)</li></ul>
<p>Arduino 5V internal pullup resistors are several tens of thousands of ohms, so they can be used to simplify the circuit (on a 3.3V MCU, you&#39;ll need hook up the tachometers to at least a 5V V<sub>CC</sub>, so this won&#39;t help you there). The tach will pull the signal low. It&#39;s best to detect this via hardware interrupts:
</p>
<div dir="ltr"><pre><span></span><span>static</span><span> </span><span>volatile</span><span> </span><span>unsigned</span><span> </span><span>Pulses</span><span>;</span><span></span>

<span>static</span><span> </span><span>void</span><span> </span><span>rpm</span><span>(</span><span>void</span><span>){</span><span></span>
<span>  </span><span>if</span><span>(</span><span>Pulses</span><span> </span><span>&lt;</span><span> </span><span>UINT_MAX</span><span>){</span><span> </span><span>// saturate</span>
<span>    </span><span>++</span><span>Pulses</span><span>;</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>

<span>static</span><span> </span><span>void</span><span> </span><span>setup_interrupt</span><span>(</span><span>int</span><span> </span><span>pin</span><span>){</span><span></span>
<span>  </span><span>pinMode</span><span>(</span><span>pin</span><span>,</span><span> </span><span>INPUT_PULLUP</span><span>);</span><span></span>
<span>  </span><span>attachInterrupt</span><span>(</span><span>digitalPinToInterrupt</span><span>(</span><span>pin</span><span>),</span><span> </span><span>rpm</span><span>,</span><span> </span><span>FALLING</span><span>);</span><span></span>
<span>}</span><span></span>

<span>...</span><span></span>
<span>unsigned</span><span> </span><span>p</span><span>;</span><span></span>
<span>noInterrupts</span><span>();</span><span></span>
<span>p</span><span> </span><span>=</span><span> </span><span>Pulses</span><span>;</span><span></span>
<span>Pulses</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span></span>
<span>interrupts</span><span>();</span><span></span>
<span>...</span><span></span>
</pre></div>
<p><tt>p</tt> can then be used to calculate RPM. Remember to divide by 2 due to two pulses per revolution. The pin must be associated with some hardware interrupt.
</p><p>A junction must propagate only one tachometer signal, i.e. if three fans are connected to a splitter, only one tach value is reported. Whether this is a maximum, or an average, or something else is undefined, but every junction I&#39;ve ever seen, from passive splitters to active controllers, simply connects only one tachometer to the wire (controllers using a side channel in addition to the fan connector might of course report multiple tach signals, as does the <a rel="nofollow" href="https://shop.aquacomputer.de/product_info.php?products_id=3832&amp;language=en">Aquacomputer OCTO</a> via USB).
</p>
<h2><span id="Physical">Physical</span></h2>
<h3><span id="Connector_and_wiring">Connector and wiring</span></h3>
<div><div><p><a href="https://nick-black.com/dankwiki/index.php?title=File:Pwm.jpeg"><img alt="" src="https://nick-black.com/dankwiki/images/thumb/b/bc/Pwm.jpeg/300px-Pwm.jpeg" decoding="async" width="300" height="231" srcset="/dankwiki/images/thumb/b/bc/Pwm.jpeg/450px-Pwm.jpeg 1.5x, /dankwiki/images/thumb/b/bc/Pwm.jpeg/600px-Pwm.jpeg 2x"/></a></p><div><p>Pinout (GND, power, tach, PWM).</p></div></div></div>
<p>Intel specifies UL1430 wire with a minimum AWG26, 300V capacity, with rating of at least 105℃.
</p><p>The fan wire ought be terminated with a four-pin housing (Wieson 2510C888-001, Molex 47054-1000, or equivalent).
</p><p>The intended mating header ought be housed in Wieson 2366C888-007, Molex 47053-1000, Foxconn HF27040-M1, Tyco 1470947-1, or equivalent.
</p><p>Pinout: GND (black), Power (yellow), Tach (green), PWM (blue)
</p><p>Both connectors ought employ a polarizing rib between the third and fourth pin to ensure correct connection. The absence of such does not preclude mating with a ribbed connector; an offset connection is almost certain to blow the tachometer circuit <a rel="nofollow" href="https://kampidh.blogspot.com/2021/02/even-deeper-into-rabbit-hole-4-pin-pwm.html">if the device is externally powered</a>.
</p>
<h3><span id="Form_factor">Form factor</span></h3>
<p><b>FIXME</b>
</p>
<h2><span id="Parameters">Parameters</span></h2>
<p>Static pressure is the pressure created in front of the fan within an enclosure. Airflow is the volume of air moved per unit time.  A fan&#39;s output is characterized in terms of maximum static pressure and maximum airflow, but <b>it does not hit both maxima at once</b>. Maximum airflow is achieved when completely unobstructed. As the amount of obstruction increases, airflow is reduced, and static pressure increases. At a given level of output, airflow is roughly inversely proportional to static pressure. In a turbulent system at low velocities, P = KrQ², where:
</p>
<ul><li>P is static pressure</li>
<li>K is load factor</li>
<li>r is fluid density</li>
<li>Q is flow</li></ul>
<p>Q being raised to the second power is characteristic of a turbulent (chaotic) system (a laminar system would only see Q raised to the first power). Each fan has a performance curve relating airflow to static pressure (technically, a curve per PWM level). The environment defines the impedance curve, and the real pressure and airflow are specified where these two intersect.
</p>
<table>
<tbody><tr>
<th>variable</th>
<th>when speed changes</th>
<th>when density changes
</th></tr>
<tr>
<td>flow</td>
<td>flow₂ = flow₁(rpm₂ / rpm₁)</td>
<td>flow₂ = flow₁(ρ₂ / ρ₁)
</td></tr>
<tr>
<td>pressure</td>
<td>P₂ = P₁(rpm₂ / rpm₁)²</td>
<td>P₂ = P₁(ρ₂ / ρ₁)
</td></tr>
<tr>
<td>power</td>
<td>W₂ = W₁(rpm₂ / rpm₁)³</td>
<td>W₂ = W₁(ρ₂ / ρ₁)
</td></tr>
<tr>
<td>noise</td>
<td>N₂ = N₁ + 50log₁₀(rpm₂ / rpm₁)</td>
<td>N₂ = N₁ + 20log₁₀(ρ₂ / ρ₁)
</td></tr>
</tbody></table>
<h2><span id="Accessories">Accessories</span></h2>
<ul><li><a rel="nofollow" href="https://dewire.shop/collections/all">Dewire</a> from the Netherlands sells their Relay in various lengths, perfect for running down the side of a radiator or up the height of a full tower.</li>
<li><a rel="nofollow" href="https://shop.aquacomputer.de">Aquacomputer</a> from Germany sells the <a rel="nofollow" href="https://shop.aquacomputer.de/index.php?cPath=62_4621">QUADRO and OCTO</a> for four and eight fans, respectively, with independent tach and PWM on all. It&#39;s controlled by USB.</li>
<li>Any number of fan hubs, generally powered by Molex or SATA (requiring only the 12V line on each) and with a two-wire cable for tach+PWM. Some arbitrary header will be connected to tach; PWM will be distributed to all headers.</li>
<li>Any number of fan extenders/splitters, taking their power from the motherboard header. Same deal as a fan hub, except with fewer amps available.</li>
<li>Devices, often in 5.25 bay form factor, with knobs for manual control of connected fans. Manual control is lame so fuck that.</li></ul>
<h2></h2>
<p>Pumps will use the fan header for tach and PWM, though not power nor ground (these will be externally supplied by some other source). Some flowmeters use a two- or three-pin connector, for power and optionally tach.
</p>
<h2><span id="External_links">External links</span></h2>
<ul><li><a rel="nofollow" href="https://kampidh.blogspot.com/2019/11/down-rabbit-hole-d5-pwm-pump-flaw-and.html">Down The Rabbit Hole - D5 PWM Pump Issue and Possible No RPM Fix</a> on <a rel="nofollow" href="https://kampidh.blogspot.com/">Kampidh&#39;s</a> blog</li>
<li><a rel="nofollow" href="https://docs.arduino.cc/tutorials/generic/secrets-of-arduino-pwm">Secrets of Arduino PWM</a></li>
<li><a rel="nofollow" href="https://www.analog.com/en/analog-dialogue/articles/how-to-control-fan-speed.html">Why and How to Control Fan Speed</a>, Analog Devices</li>
<li><a rel="nofollow" href="https://blog.orientalmotor.com/fan-basics-air-flow-static-pressure-impedance">Fan Basics: Airflow, Static Pressure, and Impedance</a> at Oriental Motor</li>
<li><a rel="nofollow" href="https://www.digikey.com/Site/Global/Layouts/DownloadPdf.ashx?pdfUrl=6393BE679DD7468BB8B9221E21CE1BB0">Establishing Cooling Requirements: Airflow vs Pressure</a> at Digikey</li></ul>
<h2><span id="See_also">See also</span></h2>
<ul><li><a href="https://nick-black.com/dankwiki/index.php?title=InaMORAta" title="InaMORAta">InaMORAta</a></li>
<li><a href="https://nick-black.com/dankwiki/index.php?title=Counterforce" title="Counterforce">Counterforce</a></li></ul>
<!-- 
NewPP limit report
Cached time: 20221123032830
Cache expiry: 86400
Reduced expiry: false
Complications: []
CPU time usage: 0.052 seconds
Real time usage: 0.054 seconds
Preprocessor visited node count: 75/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 18061/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1500-0!canonical and timestamp 20221123032830 and revision id 9087. Serialized with JSON.
 -->
</div></div>
</div></div>
  </body>
</html>
