<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blogs.gentoo.org/mgorny/2024/09/23/overview-of-cross-architecture-portability-problems/">Original</a>
    <h1>Overview of cross-architecture portability problems</h1>
    
    <div id="readability-page-1" class="page"><article id="post-2142">
	<!-- .entry-header -->

	
	
	<div>
		<p>Ideally, you’d want your program to work everywhere.  Unfortunately, that’s not that simple, even if you’re using high-level “portable” languages such as Python.  In this blog post, I’d like to focus on some aspects of cross-architecture problems I’ve seen or heard about during my time in Gentoo.  Please note that I don’t mean this to be a comprehensive list of problems — instead, I’m aiming for an interesting read.</p>
<h2>What breaks programs on 32-bit systems?</h2>
<h3>Basic integer type sizes</h3>
<p>If you asked anyone what’s the primary difference between 64-bit and 32-bit architectures, they will probably answer that it’s register sizes.  For many people, register sizes imply differences in basic integer types, and therefore the primary source of problems on 32-bit architectures, when programs are tested on 64-bit architectures only (which is commonly the case nowadays).  Actually, it’s not that simple.</p>
<p>Contrary to common expectations, the differences in basic integer types are minimal.  Most importantly, your plain <kbd>int</kbd> is 32-bit everywhere.  The only type that’s actually different is <kbd>long</kbd> — it’s 32-bit on 32-bit architectures, and 64-bit on 64-bit architectures.  However, people don’t use <kbd>long</kbd> all that often in modern programs, so that’s not very likely to cause issues.</p>
<p>Perhaps some people worry about integer sizes because they still foggily remember the issues from porting old 32-bit software to 64-bit architectures.  As I’ve mentioned before, <kbd>int</kbd> remained 32-bit — but pointers became 64-bit.  As a result, if you attempted to cast pointers (or related data) to <kbd>int</kbd>, you’d be in trouble (hence we have <kbd>size_t</kbd>, <kbd>ssize_t</kbd>, <kbd>ptrdiff_t</kbd>).  Of course, the same thing (i.e. casting pointers to <kbd>long</kbd>) made for 64-bit architectures is ugly but won’t technically cause problems on 32-bit architectures.</p>
<p>Note that I’m talking about System V ABI here.  Technically, the POSIX and the C standards don’t specify exact integer sizes, and permit a lot more flexibility (the C standard especially — up to having, say, all the types exactly 32-bit).</p>
<h3>Address space size</h3>
<p>Now, a more likely problem is the address space limitation.  Since pointers are 32-bit on 32-bit architectures, a program can address no more than 4 GiB of memory (in reality, somewhat less than that).  What’s really important here is that this limits <em>allocated</em> memory, even it is never actually used.</p>
<p>This can cause curious issues.  For example, let’s say that you have a program that allocates a lot of memory, but doesn’t use most of it.  If you run this program on a 64-bit system with 2 GiB of total memory, it works just fine.  However, if you run it on 32-bit userland with a lot of memory, it fails.  And why is that?  It’s because the system permitted the program to allocate more memory than it could ever provide — risking an <abbr title="out-of-memory">OOM</abbr> if the program actually tried to use it all; but on the 32-bit architecture, it simply cannot fit all these allocations into 32-bit addresses.</p>
<p>The following sample can trivially demonstrate this:</p>
<pre>$ cat &gt; mem-demo.c &lt;&lt;EOF
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    void *allocs[100];
    int i, j;
    FILE *urandom = fopen(&#34;/dev/urandom&#34;, &#34;r&#34;);

    for (i = 0; i &lt; 100; ++i) {
        allocs[i] = malloc(1024 * 1024 * 1024);
        if (!allocs[i]) {
            printf(&#34;malloc for i = %d failed\n&#34;, i);
            return 1;
        }
        fread(allocs[i], 1024, 1, urandom);
    }

    for (i = 0; i &lt; 100; ++i)
        free(allocs[i]);
    fclose(urandom);

    return 0;
}
EOF
$ cc -m64 mem-demo.c -o mem-demo &amp;&amp; ./mem-demo
$ cc -m32 mem-demo.c -o mem-demo &amp;&amp; ./mem-demo 
malloc for i = 3 failed</pre>
<p>The program allocates a grand total of 100 GiB of memory, but uses only the first KiB of each allocation.  This works just fine on 64-bit architectures but fails on 32-bit because of failing allocation.</p>
<p>At this point, it’s probably worth noting that we are talking about limitations applicable to a single process.  A 32-bit kernel can utilize more than 4 GiB of memory, and therefore multiple processes can use a total of more than 4 GiB.  There are also cursed ways of making it possible for a single process to access more than 4 GiB of memory.  For example, one could use <kbd>memfd_create()</kbd> (or equivalently, files on <kbd>tmpfs</kbd>) to create in-memory files that exceed process’ address space, or use <abbr title="Inter-Process Communication">IPC</abbr> to exchange data between multiple processes having separate address spaces (thanks to Arsen Arsenović and David Seifert for their hints on this).</p>
<h3>Large File Support</h3>
<p>Another problem faced by 32-bit programs is that the file-related types are traditionally 32-bit.  This has two implications.  The more obvious one is that <kbd>off_t</kbd>, the type used to express file sized and offsets, is a signed 32-bit integer, so you cannot <kbd>stat()</kbd> and therefore open files larger than 2 GiB.  The less obvious implication is that <kbd>ino_t</kbd>, the type used to express inode numbers, is also 32-bit, so you cannot open files with inode numbers 2^32 and higher.  In other words, given large enough filesystem, you may suddenly be unable to open random files, even if they are smaller than 2 GiB.</p>
<p>Now, this is a problem that can be solved.  Modern programs usually define <kbd>_FILE_OFFSET_BITS=64</kbd> and get 64-bit types instead.  In fact, musl libc unconditionally provides 64-bit types, rendering this problem a relic of the past — and apparently glibc is planning to switch the default in the future as well.</p>
<p>Here’s a trivial demo:</p>
<pre>$ cat &gt; lfs-demo.c &lt;&lt;EOF
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fd = open(&#34;lfs-test&#34;, O_RDONLY);

    if (fd == -1) {
        perror(&#34;open() failed&#34;);
        return 1;
    }

    close(fd);
    return 0;
}
EOF
$ truncate -s 2G lfs-test
$ cc -m64 lfs-demo.c -o lfs-demo &amp;&amp; ./lfs-demo
$ cc -m32 lfs-demo.c -o lfs-demo &amp;&amp; ./lfs-demo 
open() failed: Value too large for defined data type
$ cc -m32 -D_FILE_OFFSET_BITS=64 lfs-demo.c \
    -o lfs-demo &amp;&amp; ./lfs-demo</pre>
<p>Unfortunately, while fixing a single package is trivial, a global switch is not.  The sizes of <kbd>off_t</kbd> and <kbd>ino_t</kbd> change, and so effectively does the ABI of any libraries that use these types in the API — i.e. if you rebuild the library without rebuilding the programs using it, they could break in unexpected ways.  What you can do is either switch everything simultaneously, or go slowly and add change the types via a new API, preserving the old one for compatibility.  The latter is unlikely to happen, given there’s very little interest in 32-bit architecture support these days.  The former also isn’t free of issues — technically speaking, you may end up introducing incompatibility with prebuilt software that used the 32-bit types, and effectively lose the ability to run some proprietary software entirely.</p>
<h3>time_t and the y2k38 problem</h3>
<p>The low-level way of representing timestamps in C is through the number of seconds since the so-called epoch.  This number is represented in a <kbd>time_t</kbd> type, which, as you can probably guess, was a signed 32 bit integer on 32-bit architectures.  This means that it can hold positive values up to 2<sup>31</sup> – 1 seconds, which roughly corresponds to 68 years.  Since the epoch on POSIX systems was defined as 1970, this means that the type can express timestamps up to 2038.</p>
<p>What does this mean in practice?  Programs using 32-bit <kbd>time_t</kbd> can’t express dates beyond the cutoff 2038 date.  If you try to do arithmetic spanning beyond this date (e.g. “20 years from now”), you get an overflow.  <kbd>stat()</kbd> is going to fail on files with timestamps beyond that point (though, interestingly, <kbd>open()</kbd> works on glibc, so it’s not entirely symmetric with the LFS case).  Past the overflow date, you get an error even trying to get the current time — and if your program doesn’t account for the possibility of <kbd>time()</kbd> failing, it’s going to be forever stuck 1 second before the epoch, or 1969-12-31 23:59:59.  Effectively, it may end up hanging randomly (waiting for some wall clock time to pass), not firing events or seeding a <abbr title="Pseudo-Random Number Generator">PRNG with a constant.</abbr></p>
<p>Again, modern glibc versions provide a switch.  If you define <kbd>_TIME_BITS=64</kbd> (plus LFS flags, as a prerequisite), your program is going to get a 64-bit <kbd>time_t</kbd>.  Modern versions of musl libc also default to the 64-bit type (since 1.2.0).  Unfortunately, switching to the 64-bit type brings the same risks as switching to LFS globally — or perhaps even worse because <kbd>time_t</kbd> seems to be more common in library API than file size-related types were.</p>
<p>These solutions only work for software that is built from source, and uses <kbd>time_t</kbd> correctly.  Converting timestamps to <kbd>int</kbd> will cause overflow bugs.  File formats with 32-bit timestamp fields are essentially broken.  Most importantly, all proprietary software will remain broken and in need of serious workarounds.</p>
<p>Here are some samples demonstrating the problems.  Please note that the first sample assumes the system clock is set beyond 2038.</p>
<pre>$ cat &gt; time-test.c &lt;&lt;EOF
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main() {
    time_t t = time(NULL);

    if (t != -1) {
        struct tm *dt = gmtime(&amp;t);
        char out[32];

        strftime(out, sizeof(out), &#34;%F %T&#34;, dt);
        printf(&#34;%s\n&#34;, out);
    } else
        perror(&#34;time() failed&#34;);

    return 0;
}
EOF
$ cc -m64 time-test.c -o time-test &amp;&amp; ./time-test
2060-03-04 11:13:02
$ cc -m32 time-test.c -o time-test &amp;&amp; ./time-test
time() failed: Value too large for defined data type
$ cc -m32 -D_FILE_OFFSET_BITS=64 -D_TIME_BITS=64 \
    time-test.c -o time-test &amp;&amp; ./time-test
2060-03-04 11:13:32
$ cat &gt; mtime-test.c &lt;&lt;EOF
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

int main() {
    struct stat st;
    int fd;

    if (stat(&#34;time-data&#34;, &amp;st) == 0) {
        char buf[32];
        struct tm *tm = gmtime(&amp;st.st_mtime);
        strftime(buf, sizeof(buf), &#34;%F %T&#34;, tm);
        printf(&#34;mtime: %s\n&#34;, buf);
    } else
        perror(&#34;stat() failed&#34;);

    fd = open(&#34;time-data&#34;, O_RDONLY);
    if (fd == -1) {
        perror(&#34;open() failed&#34;);
        return 1;
    }
    close(fd);

    return 0;
}
$ touch -t &#39;206001021112&#39; mtime-data
$ cc -m64 mtime-test.c -o mtime-test &amp;&amp; ./mtime-test
mtime: 2060-01-02 10:12:00
$ cc -m32 mtime-test.c -o mtime-test &amp;&amp; ./mtime-test
stat() failed: Value too large for defined data type
$ cc -m32 -D_FILE_OFFSET_BITS=64 -D_TIME_BITS=64 \
    mtime-test.c -o mtime-test &amp;&amp; ./mtime-test
mtime: 2060-01-02 10:12:00</pre>
<h3>Are these problems specific to C?</h3>
<p>It is probably worth noting that while portability issues are generally discussed in terms of C, not all of them are specific to C, or to programs directly interacting with C API.</p>
<p>For example, address space limitations affect all programming languages, unless they take special effort to work around them (I’m not aware of any that do).  So a Python program will be limited by the 4 GiB of address space the same way C programs are — except that Python programs don’t allocate memory explicitly, so the limit will be rather on memory used than allocated.  On the minus side, Python programs will probably be less memory efficient than C programs.</p>
<p>File and time type sizes also sometimes affect programming languages internally.  Modern versions of Python are built with Large File Support enabled, so they aren’t limited to 32-bit file sizes and inode numbers.  However, they are limited to 32-bit timestamps:</p>
<pre>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime.datetime(2060, 1, 1)
datetime.datetime(2060, 1, 1, 0, 0)
&gt;&gt;&gt; datetime.datetime(2060, 1, 1).timestamp()
Traceback (most recent call last):
  File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
OverflowError: timestamp out of range for platform time_t</pre>
<h2>Other generic issues</h2>
<h3>Byte order (endianness)</h3>
<p>The predominant byte order nowadays is little endian.  X86 was always little endian.  ARM is bi-endian, but defaults to running little endian (and there were never much incentive to run big endian ARM).  PowerPC used to default to big endian, but these days PPC64 systems are mostly running little endian instead.</p>
<p>It’s not that either byte order is superior in some way.  It’s just that x86 happened to arbitrarily use that byte order.  Given its popularity, a lot of non-portable software has been written that worked correctly on little endian only.  Over time, people lost the incentive to run big endian systems and this eventually led to even worse big endian support overall.</p>
<p>The most common issues related to byte order occur when implementing binary data formats, particularly file formats and network protocols.  A missing byte order conversion can lead to the program throwing an error or incorrectly reading files written on other platforms, writing incorrect files or failing to communicate with peers on other platforms correctly.  In extreme cases, a program that missed some byte order conversions may be unable to read a file it has written before.</p>
<p>Again, byte order problems are not limited to C.  For example, the <a rel="external" href="https://docs.python.org/3/library/struct.html#struct-alignment">struct module in Python uses explicit byte order, size and alignment modifiers</a>.</p>
<p>Curious enough, byte order issues are not limited to low-level data formats either.  To give another example, the UTF-16 and UTF-32 encodings also have little endian and big endian variations.  When the user does not request a specific byte order, Python uses host’s byte order and adds a <abbr title="Byte order mark">BOM</abbr> to the string, that is used to detect the correct byte order when decoding.</p>
<pre>&gt;&gt;&gt; &#34;foo&#34;.encode(&#34;UTF-16LE&#34;)
b&#39;f\x00o\x00o\x00&#39;
&gt;&gt;&gt; &#34;foo&#34;.encode(&#34;UTF-16BE&#34;)
b&#39;\x00f\x00o\x00o&#39;
&gt;&gt;&gt; &#34;foo&#34;.encode(&#34;UTF-16&#34;)
b&#39;\xff\xfef\x00o\x00o\x00&#39;</pre>
<h3>char signedness</h3>
<p>This is probably one of the most confusing portability problems you may see.  Roughly, the problem is that the C standard does not specify the signedness of <kbd>char</kbd> type (unlike <kbd>int</kbd>).  Some platforms define it as signed, others as unsigned.  In fact, the standard goes a step further and defines <kbd>char</kbd> as a distinct type from both <kbd>signed char</kbd> and <kbd>unsigned char</kbd>, rather than an alias to either of them.</p>
<p>For example, the System V ABI for x86 and SPARC specifies that <kbd>char</kbd> is signed, whereas for MIPS and PowerPC it is unsigned.  Assuming either and doing arithmetic on top of that could lead to surprising results on the other set of platforms.  In fact, one of the most confusing cases I’ve seen was with code that was used only for big endian platforms, and therefore worked on PowerPC but not on SPARC (even though it would also fail on x86, if it was used there).</p>
<p>Here is an example inspired by it.  The underlying idea is to read a little endian 32-bit unsigned integer from a <kbd>char</kbd> array:</p>
<pre>$ cat &gt; char-sign.c &lt;&lt;EOF
#include &lt;inttypes.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main() {
        char buf[] = {0x00, 0x40, 0x80, 0xa0};
        char *p = buf;
        uint32_t val = 0;

        val |= (*p++);
        val |= (*p++) &lt;&lt; 8;
        val |= (*p++) &lt;&lt; 16;
        val |= (*p++) &lt;&lt; 24;

        printf(&#34;%08&#34; PRIx32 &#34;\n&#34;, val);
}
EOF
$ cc -funsigned-char char-sign.c -o char-sign
$ ./char-sign
a0804000
$ cc -fsigned-char char-sign.c -o char-sign
$ ./char-sign
ff804000</pre>
<p>Please note that for the sake of demonstration, the example uses <kbd>-fsigned-char</kbd> and <kbd>-funsigned-char</kbd> switches to override the default platform signedness.  In real code, you’d explicitly use <kbd>unsigned char</kbd> instead.</p>
<h3>Strict alignment</h3>
<p>I feel that alignment is not a well-known problem, so perhaps I should start by explaining it a bit.  Long story short, alignment is about ensuring that particular types are placed across appropriate memory boundaries.  For example, on most platforms 32-bit types are expected to be aligned at 32-bit (= 4 byte) boundaries.  In other words, you expect that the type’s memory address would be a multiple of 4 bytes — irrespective of whether it’s on stack or heap, used directly, in an array, a structure or perhaps an array of structures.</p>
<p>Perhaps the simplest way to explain that is to show how the compiler achieves alignment in structures.  Please consider the following type:</p>
<pre>struct {
    int16_t a;
    int32_t b;
    int16_t c;
}</pre>
<p>As you can see, it contains two 2-byte types and one 4-byte type — that would be a total of 8 bytes, right?  Nothing more wrong, at least on platforms requiring 32-bit alignment for <kbd>int32_t</kbd>.  To guarantee that <kbd>b</kbd> would be correctly aligned whenever the whole structure is correctly aligned, the compiler needs to move it to an offset being a multiple of 4.  Furthermore, to guarantee that if the structure is used in array, every instance is correctly aligned, it also needs to increase its size to a multiple of 4.</p>
<p>Effectively, the resulting structure resembles the following:</p>
<pre>struct {
    int16_t a;
    int16_t _pad1;
    int32_t b;
    int16_t c;
    int16_t _pad2;
}</pre>
<p>In fact, you can find some libraries actually defining structures with explicit padding.  So you get a padding of 2 + 2 bytes, <kbd>b</kbd> at offset 4, and a total size of 12 bytes.</p>
<p>Now, what would happen if the alignment requirements weren’t met?  On the majority of platforms, misaligned types are still going to work, usually at a performance penalty.  However, on some platforms like SPARC, they will actually cause the program to terminate with a <kbd>SIGBUS</kbd>.  Consider the following example:</p>
<pre>$ cat &gt; align-test.c &lt;&lt;EOF
#include &lt;inttypes.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;

int main() {
	uint8_t buf[6] = {0, 0, 0, 4, 0, 0};
	int32_t *number = (int32_t *) &amp;buf[2];
	printf(&#34;%&#34; PRIi32 &#34;\n&#34;, *number);
	return 0;
}
EOF
$ cc align-test.c -o align-test
$ ./align-test
1024</pre>
<p>The code is meant to resemble a cheap way of reading data from a file, and then getting a 32-bit integer at offset 2.  However, on SPARC this code will not work as expected:</p>
<pre>$ ./align-test
Bus error (core dumped)</pre>
<p>As you can probably guess, there is a fair number of programs suffering from issues like that simply because they don’t crash on x86, and it’s easy to silence the normal compiler warnings (e.g. by type punning, as used it in the example).  However, as noted before, this code will not only cause a crash on SPARC — it may also cause a performance penalty everywhere else.</p>
<h3>Stack size</h3>
<p>As low-level C programmers tend to learn, there are two main kinds of memory available to the program: the heap and the stack.  The heap is the main memory area from which explicit allocations are done.  The stack is a relatively small area of memory that is given to the program for its immediate use.</p>
<p>The main difference is that the use of heap is controlled — a well-written written program allocates as much memory as it needs, and doesn’t access areas outside of that.  On the other hand, stack use is “uncontrolled” — programs generally don’t check stack bounds.  As you may guess, this means that if a program uses it too much, it’s going to exceed the available stack — i.e. hit a stack overflow, which generally manifests itself as a “weird” segmentation fault.</p>
<p>And how do you actually use a lot of stack memory?  In C, local function variables are kept on stack — so the more variables you use, the more stack you fill.  Furthermore, some ABIs use stack to pass function parameters and return values — e.g. x86 (but not the newer amd64 or x32 ABIs).  But most importantly, stack frames are used to record the function call history — and this means the deeper you call, the larger the stack use.</p>
<p>This is precisely why programmers are cautioned against recursive algorithms — especially if built without protection against deep recursion, they provide a trivial way to cause a stack overflow.  And this last problem is not limited to C — recursive function calls in Python also result in recursive function calls in C.  Python comes with a default recursion limit to prevent this from happening.  However, as we recently found out the hard way, this limit needs to be adjusted across different architectures and compiler configurations, as their stack <a rel="external" href="https://github.com/python/cpython/pull/124264#issuecomment-2363825291" title="A list of stack frame sizes for a dummy function across a number of architectures">frame sizes may differ drastically</a>: from a baseline of 8–16 bytes on common architectures such as x86 or ARM, through 112–128 bytes on PPC64, up to 160–176 bytes on s390x and SPARC64.</p>
<p>On top of that, <a rel="external" href="https://wiki.musl-libc.org/functional-differences-from-glibc.html#Thread-stack-size">the default thread stack size varies across the standard C libraries</a>.  On glibc, it is usually between 2 MiB and 10 MiB, whereas on musl it is 128 KiB.  Therefore, in some cases you may actually need to explicitly request a larger stack.</p>
<h2>The wondrous world of floating-point types</h2>
<h3>x87 math</h3>
<p>The x86 platform supports two modes of floating-point arithmetic:</p>
<ol>
<li>The legacy 387 floating-point arithmetic that utilizes 80-bit precision registers (<kbd>-mfpmath=387</kbd>).</li>
<li>The more modern SSE arithmetic that supports all of 32-bit, 64-bit and 80-bit precision types (<kbd>-mfpmath=sse</kbd>).</li>
</ol>
<p>The former is the default on 32-bit x86 platforms using the System V ABI, the latter everywhere else.  And why does that matter?  Because the former may imply performing some computations using the extended 80-bit precision before converting the result back to the original type, effectively implying a smaller rounding error than performing the same computations on the original type directly.</p>
<p>Consider the following example:</p>
<pre>$ cat &gt; float-demo.c &lt;&lt;EOF
#include &lt;stdio.h&gt;

__attribute__((noipa))
double fms(double a, double b, double c) {
	return a * b - c;
}

int main() {
	printf(&#34;%+.40f\n&#34;, fms(1./3, 1./3, 1./9));
	return 0;
}
EOF
$ cc -mfpmath=sse float-demo.c -o float-demo
$ ./float-demo
+0.0000000000000000000000000000000000000000
$ cc -mfpmath=387 float-demo.c -o float-demo
$ ./float-demo
-0.0000000000000000061663998560113064684174</pre>
<p>What’s happening here?  The program is computing <kbd>1/3 * 1/3 - 1/9</kbd>, which we know should be zero.  Except that it isn’t when using x87 FPU instructions.  Why?</p>
<p>Normally, this computation is done in two steps.  First, the multiplication <kbd>1/3 * 1/3</kbd> is done.  Afterwards, <kbd>1/9</kbd> is subtracted from the result.  In SSE mode, both steps are done directly on the <kbd>double</kbd> type.  However, in x87 mode the doubles are converted to 80-bit floats first, both computations are done on these and then the result is converted back to double.  We can see that looking at the respective assembly fragments:</p>
<pre>$ cc -mfpmath=sse float-demo.c -S -o -
[…]
	movsd	-8(%rbp), %xmm0
	mulsd	-16(%rbp), %xmm0
	subsd	-24(%rbp), %xmm0
[…]
$ cc -mfpmath=387 float-demo.c -S -o -
[…]
	fldl	-8(%rbp)
	fmull	-16(%rbp)
	fsubl	-24(%rbp)
	fstpl	-32(%rbp)
[…]</pre>
<p>Now, neither ⅓ nor ⅑ can be precisely expressed in binary system.  So <kbd>1./3</kbd> is actually ⅓ + some error, and <kbd>1./9</kbd> is ⅑ + another error.  It happens that <kbd>1./3 * 1./3</kbd> after rounding is giving the same value as <kbd>1./9</kbd> — so subtracting one from the other yields zero.  However, when computations are done using an intermediate type of higher precision, the squared error from <kbd>1./3 * 1./3</kbd> is rounded at a higher precision — and therefore different from the one in <kbd>1./9</kbd>.  So counter-intuitively, higher precision here amplifies a rounding error and yields the “incorrect” result!</p>
<p>Of course, this is not that big of a deal — we are talking about 17 decimal places, and user-facing programs will probably round that down to 0.  However, this can lead to problems in programs written to expect an exact value — e.g. in test suites.</p>
<p>Gentoo has already switched amd64 multilib profiles to force <kbd>-mfpmath=sse</kbd> for 32-bit builds, and it is planning to switch the x86 profiles as well.  While this doesn’t solve the underlying issue, it yields more consistent results across different architectures and therefore reduces the risk of our users hitting these bugs.  However, this has a surprising downside: some packages actually adapted to expect different results on 32-bit x86, and now fail when SSE arithmetic is used there.</p>
<h3>It doesn’t take two architectures to make a rounding problem</h3>
<p>Actually, you don’t have to run a program on two different architectures to see rounding problems — different optimization levels, particularly CPU instruction sets can also result in different rounding errors.  Let’s try compiling the previous example with and without FMA instructions:</p>
<pre>$ cc -mno-fma -O2 float-demo.c -o float-demo
$ ./float-demo
+0.0000000000000000000000000000000000000000
$ cc -mfma -O2 float-demo.c -o float-demo
$ ./float-demo
-0.0000000000000000061679056923619804377437</pre>
<p>The first invocation is roughly the same as before.  The second one enables use of the FMA instruction set that performs the multiplication and subtraction in one step:</p>
<pre>$ cc -mfma -O2 float-demo.c -S -o -
[…]
	vfmsub132sd	%xmm1, %xmm2, %xmm0
[…]</pre>
<p>Again, this means that the rounding of the intermediate value is not rounded down to <kbd>double</kbd> — and therefore doesn’t carry the same error as <kbd>1./9</kbd>.</p>
<p>Bottom line is this: never match floating-point computation results exactly, allow for some error.  Even if something works for you, it may fail not only for a different architecture, but even for different optimization flags.  And counter-intuitively, more precise results may amplify errors and yields intuitively “wrong” values.</p>
<h3>The long double type</h3>
<p>As you can probably guess by now, the C standard doesn’t define precisely what <kbd>float</kbd>, <kbd>double</kbd> and <kbd>long double</kbd> types are.  Fortunately, it seems that the first two types are uniformly implemented as, respectively, a single-precision (32-bit) and a double-precision (64-bit) IEEE 754 floating point number.  However, as far as the third type is concerned, we might find it to be any of:</p>
<ul>
<li>the same type as <kbd>double</kbd> — on architectures such as 32-bit ARM,</li>
<li>the 80-bit x87 extended precision type — on amd64 and x86,</li>
<li>a type implementing double-double arithmetic — i.e. representing the number as a sum of two <kbd>double</kbd> values, giving roughly 106-bit precision, e.g. on PowerPC,</li>
<li>the quadruple precision (128-bit) IEEE 754 type — e.g. on SPARC.</li>
</ul>
<p>Once again, this is primarily a matter of precision, and therefore it only breaks test suites that assume specific precision for the type.  To demonstrate the differences in precision, we can use the following sample program:</p>
<pre>#include &lt;stdio.h&gt;

int main() {
	printf(&#34;%0.40Lf\n&#34;, 1.L/3);
	return 0;
}</pre>
<p>Running it across different architectures, we’re going to see:</p>
<pre>arm64: 0.3333333333333333333333333333333333172839
ppc64: 0.3333333333333333333333333333333292246828
amd64: 0.3333333333333333333423683514373792036167
arm32: 0.3333333333333333148296162562473909929395</pre>
<h2>Summary</h2>
<p>Portability is no trivial matter, that’s clear.  What’s perhaps more surprising is that portability problems aren’t limited to C and similar low-level languages — I have shown multiple examples of how they leak into Python.</p>
<p>Perhaps the most common portability issues these days come from 32-bit architectures.  Many projects today are tested only on 64-bit systems, and therefore face regressions on 32-bit platforms.  Perhaps surprisingly, most of the issues stem not from incorrect type use in C, but rather from platform limitations — available address space, lack of support for large files or large <kbd>time_t</kbd>.  All of these limitations apply to non-C programs that are built on C runtime as well, and sometimes require non-trivial fixes.  Notably, switching to a 64-bit <kbd>time_t</kbd> is going to be a major breaking change (and one that I’ll cover in a separate post).</p>
<p>Other issues may be more obscure, and specific to individual architectures.  On PPC64 or SPARC, we hit issues related to big endian byte order.  On MIPS and PowerPC, we may be surprised by <kbd>char</kbd> being unsigned.  On SPARC, we’re going to hit crashes if we don’t align types properly.  Again, on PPC64 and SPARC we are also more likely to hit stack overflows.  And on i386, we may discover problems due to different precision in floating-point computations.</p>
<p>These are just some examples, and they definitely do not deplete the possible issues.  Furthermore, sometimes you may discover a combination of two different problems, furthering your confusion — just like the package that was broken only on big endian systems with signed <kbd>char</kbd>.</p>
<p>On the other hand, all these differences provide an interesting opportunity: by testing the package on a bunch of architectures and knowing their characteristics, you can guess what could be wrong with it.  Say, if it fails on PPC64 but passes on PPC64LE, you may guess it’s a byte order issue — and then it turns out it was actually a stack overflow, because big endian PPC64 happens to default to ELFv1 ABI that uses slightly larger stack frames.  But hey, usually it does help.</p>
<p>Portability is important.  The problematic architectures may constitute a tiny portion of your user base — in fact, sometimes I do wonder if some of the programs we’re fixing are actually going to be used by any real user of these architectures, or if we’re merely cargo culting keywords added a long time ago.  You may even argue that it’s better for the environment if people discarded these machines rather than kept having them burn energy.  However, portability makes for good code.  What may seem like bothering for a tiny minority today, may turn out to prevent a major security incident for all your users tomorrow.</p>
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
