<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://flak.tedunangst.com/post/forbidden-secrets-of-ancient-X11-scaling-technology-revealed">Original</a>
    <h1>Ancient X11 scaling technology</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>People keep telling me that X11 doesn’t support DPI scaling, or fractional scaling, or multiple monitors, or something. There’s nothing you can do to make it work. I find this surprising. Why doesn’t it work? I figure the best way to find out is try the impossible and see how far we get.</p><p>I’m just going to draw a two inch circle on the screen. This screen, that screen, any screen, the circle should always be two inches. Perhaps not the most exciting task, but I figure it’s isomorphic to any other scaling challenge. Just imagine it’s the letter o or a button we wish to draw at a certain size.</p><p>I have gathered around me a few screens of different sizes and resolutions. My laptop screen, and then a bit to the right a desktop monitor, and then somewhere over that way a nice big TV. Specifically:</p><pre><code>$ xrandr | grep \ connected
eDP connected primary 2880x1800+0+0 (normal left inverted right x axis y axis) 302mm x 189mm
DisplayPort-0 connected 2560x1440+2880+0 (normal left inverted right x axis y axis) 590mm x 334mm
DisplayPort-1 connected 3840x2160+5440+0 (normal left inverted right x axis y axis) 1600mm x 900mm</code></pre><p>I think I just spoiled the ending, but here we go anyway.</p><p>I’m going to draw the circle with OpenGL, using a simple shader and OBT. There’s a bunch of not very exciting code to create a window and a GLX context, but eventually we’re going to be looking at the shader. This may not be the best way to draw a circle, but it’s my way. For reference, the full code is in <a href="https://humungus.tedunangst.com/r/xtoys/v/tip/f/circle.c">circle.c</a>.</p><pre><code><span>void</span> main<span>(</span><span>)</span>
<span>{</span>
    float thick <span>=</span> radius <span>/</span> <span>10</span>;
    <span>if</span> <span>(</span>abs<span>(</span>center<span>.</span>y <span>-</span> gl_FragCoord<span>.</span>y<span>)</span> <span>&lt;</span> thick<span>/</span><span>2</span><span>)</span> 
        thick <span>=</span> <span>2</span>;
    float pi <span>=</span> <span>3</span><span>.</span><span>14159</span>;
    float d <span>=</span> distance<span>(</span>gl_FragCoord<span>.</span>xy<span>,</span> center<span>)</span>;
    float angle <span>=</span> atan<span>(</span>gl_FragCoord<span>.</span>y <span>-</span> center<span>.</span>y<span>,</span> gl_FragCoord<span>.</span>x <span>-</span> center<span>.</span>x<span>)</span>;
    angle <span>/=</span> <span>2</span> <span>*</span> pi;
    angle <span>+=</span> <span>0</span><span>.</span><span>5</span>;
    angle <span>+=</span> <span>0</span><span>.</span><span>25</span>;
    <span>if</span> <span>(</span>angle <span>&gt;</span> <span>1</span><span>.</span><span>0</span><span>)</span> angle <span>-=</span> <span>1</span><span>.</span><span>0</span>;
    float amt <span>=</span> <span>(</span>thick <span>-</span> abs<span>(</span>d <span>-</span> radius<span>)</span><span>)</span> <span>/</span> thick;
    <span>if</span> <span>(</span>d <span>&lt;</span> radius <span>+</span> thick &amp;&amp; d <span>&gt;</span> radius <span>-</span> thick<span>)</span> 
        fragment <span>=</span> vec4<span>(</span>rgb<span>(</span>angle<span>)</span><span>*</span>amt<span>,</span> <span>1</span><span>.</span><span>0</span><span>)</span>;
    <span>else</span> 
        discard;
<span>}</span></code></pre><p>I got a little carried away and made a pretty color wheel instead of a flat circle.</p><p>The key variable is <code>radius</code> which tells us how many pixels from the center the circle should be. But where does the shader get this from?</p><pre><code>    glUniform1f(0, radius);</code></pre><p>Okay, but seriously. We listen for configure events. This is the X server telling us our window has been moved or resized. Something has changed, so we should figure out where we are and adjust accordingly.</p><pre><code>        <span>case</span> ConfigureNotify<span>:</span>
            <span>{</span>
                XConfigureEvent <span>*</span>xev <span>=</span> <span>(</span><span>void</span> <span>*</span><span>)</span>&amp;ev;
                <span>int</span> x <span>=</span> xev<span>-&gt;</span>x;
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>16</span>; i<span>++</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>x <span>&gt;=</span> screen_x<span>[</span>i<span>]</span> &amp;&amp; x <span>-</span> screen_x<span>[</span>i<span>]</span> <span>&lt;</span> screen_w<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                        float r <span>=</span> screen_w<span>[</span>i<span>]</span> <span>/</span> screen_mm<span>[</span>i<span>]</span> <span>*</span> <span>25</span><span>.</span><span>4</span>;
                        <span>if</span> <span>(</span>r <span>!=</span> radius<span>)</span> <span>{</span>
                            radius <span>=</span> r;
                        <span>}</span>
                        <span>break</span>;
                    <span>}</span>
                <span>}</span>
                width <span>=</span> xev<span>-&gt;</span>width;
                height <span>=</span> xev<span>-&gt;</span>height;
            <span>}</span></code></pre><p>Getting closer. The numbers we need come from the X server.</p><pre><code>    XRRScreenResources <span>*</span>res <span>=</span> XRRGetScreenResourcesCurrent<span>(</span>disp<span>,</span> root<span>)</span>;
    float screen_mm<span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0</span> <span>}</span>;
    float screen_w<span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0</span> <span>}</span>;
    float screen_x<span>[</span><span>16</span><span>]</span> <span>=</span> <span>{</span> <span>0</span> <span>}</span>;
    <span>int</span> j <span>=</span> <span>0</span>;
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> res<span>-&gt;</span>noutput; i<span>++</span><span>)</span> <span>{</span>
        XRROutputInfo <span>*</span>info <span>=</span> XRRGetOutputInfo<span>(</span>disp<span>,</span> res<span>,</span> res<span>-&gt;</span>outputs<span>[</span>i<span>]</span><span>)</span>;
        screen_mm<span>[</span>j<span>++</span><span>]</span> <span>=</span> info<span>-&gt;</span>mm_width;
    <span>}</span>
    j <span>=</span> <span>0</span>;
    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> res<span>-&gt;</span>ncrtc; i<span>++</span><span>)</span> <span>{</span>
        XRRCrtcInfo <span>*</span>info <span>=</span> XRRGetCrtcInfo<span>(</span>disp<span>,</span> res<span>,</span> res<span>-&gt;</span>crtcs<span>[</span>i<span>]</span><span>)</span>;
        screen_w<span>[</span>j<span>]</span> <span>=</span> info<span>-&gt;</span>width;
        screen_x<span>[</span>j<span>++</span><span>]</span> <span>=</span> info<span>-&gt;</span>x;
    <span>}</span></code></pre><p>It’s somewhat annoying that physical width and virtual width are in different structures, and we have to put the puzzle back together, but there it is.</p><p>Some more code to handle expose events, the draw loop, etc., and that’s it. A beautiful circle sized just right. Drag it over onto the next monitor, and it changes size. Or rather, it maintains its size. Send it over to the next monitor, and same as before.</p><p>Time for the visual proof. A nice pretty circle on my laptop. Another circle on my monitor. And despite the 4K resolution, a somewhat pixely circle on my TV. Turns out the hardest part of this adventure was trying to hold an uncooperative tape measure in place with one hand while trying to get a decent, or not, photo with the other. </p><p><img src="https://flak.tedunangst.com/images/circles.jpg"/></p><p>We were so close to perfection. Somebody at the factory screwed up, and my TV is actually 66.5” wide, not the claimed 63 inches. So if we learn anything today, it’s that you shouldn’t use a consumer LG TV for accurately measuring the scale of structural engineering diagrams, at least not without further calibration.</p><p>The good news is we’ve done the impossible. Even better, I didn’t mention that I wasn’t actually running this program on my laptop. It was running on my router in another room, but everything worked as if by <span>MIT-MAGIC-COOKIE-1</span>. Alas, we are still no closer to understanding why people say this is impossible.</p><p>Anyway, I think the point is we should probably ignore the people who can’t do something when they tell us we can’t do it either. I woke up this morning not knowing precisely how to draw a scaled circle, having never done so before, but armed with a vague sense that surely it must be possible, because come on of course it is, I got it working. And now look at me, driven insane by the relentless stare of three unblinking eyes.</p><p>With my new knowledge, I also wrote an onscreen <a href="https://humungus.tedunangst.com/r/xtoys/v/tip/f/ruler.c">ruler</a> using the shape extension. Somewhat tautological for measuring the two inch circle, but in the event anyone asks, I can now tell them my terminal line height is 1/8”, and yes, I measured.</p><p><img src="https://flak.tedunangst.com/images/terminal-ruler.jpg"/>
</p></div><div><p>
Posted 24 Jun 2025 17:59 by tedu Updated: 24 Jun 2025 17:59 
</p></div></div>
  </body>
</html>
