<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.matecdev.com/posts/why-fortran-still-used.html">Original</a>
    <h1>Reasons why Fortran is still used (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Fortran is such an old programming language, that most people assume it isn’t used anymore. But then, how could it be that some people in physics departments, supercomputing centers, or government agencies are still using Fortran? Before going in depth, let’s try to put it in a few words:</p>
<p><strong>Fortran is a language that is specialized for high-performance computing</strong>. Good reasons for its continued use today include its <strong>performance-centric culture</strong>, an <strong>easy-to-use array syntax</strong>, the <strong>guarantee of long code longevity</strong>, and <strong>intrinsic distributed-memory parallelism via coarrays</strong>.</p>
<p>We should notice that in 2010, Fortran was described as coming very close to being <a href="https://queue.acm.org/detail.cfm?id=1820518">‘The ideal HPC programming language’</a>.</p>
<p>This post is an attempt at summarizing the <strong>historical strengths of Fortran</strong>, and also to <strong>wonder whether they continue to hold, or not</strong>.</p>
<h3 id="fortran-was-built-around-a-performance-centric-culture">Fortran was built around a performance-centric culture</h3>
<p>For rather self-explanatory reasons, performance has been the top priority of the high-performance computing community. </p>
<p>The development of Fortran historically had optimization as the main focus. This often meant that, in order to <strong>give the compiler the best possible chances of aggressively optimizing code</strong>, the language imposed many restrictions on the programmer. </p>
<p>Simply put, they made it <strong>very hard to write slow code in Fortran</strong>, while in other languages, most notably in C, you had the freedom to do things that would lead to slow code.</p>
<p>It should be noted that it took some time for C/C++ compilers to catch up with the speed that the Fortran compilers had enjoyed historically, thanks to the straightforward restriction-based approach they had put forth since the beginning. For example, <strong>the C99 standard introduced restricted pointers</strong>, which enable better optimization by the compiler (see the Wikipedia entry about the <a href="https://en.wikipedia.org/wiki/Restrict">restrict keyword</a>).</p>
<p>Over the years, compiler theory and practice improved, and compilers got better at optimizing all sorts of code. Consequently, both in Fortran and in other languages, the focus has been shifting towards adding features that would enhance programmer’s productivity.</p>
<p>One of the latest developments in the compiler area has been <strong>Julia</strong>, which can be just as fast as some Fortran compilers, such as the popular and open-source gfortran, as I’ve checked out <a href="https://www.matecdev.com/posts/numpy-julia-fortran.html">in this test</a>, both for single-threaded and multi-threaded cases.</p>
<h3 id="fortran-is-easier-to-use-than-cc-for-scientific-computing">Fortran is easier to use than C/C++ for scientific computing</h3>
<p>The competing “fast” languages of the past were mostly C/C++. </p>
<p>Those languages are very convenient for general purpose programming. However, one has to incur in significant <strong>syntactic overhead</strong> to perform the most basic operations of scientific computing, such as dealing with mutidimensional arrays and complex numbers.</p>
<p>Fortran, on the other hand, has had <strong>native support for multidimensional arrays, complex numbers, and even some special functions, almost from the very beginning.</strong> </p>
<p>Fortran also introduced <strong>the original array syntax</strong> that was later employed by Matlab. Actually, Matlab was first referred to as “an improved Fortran” mainly because it preserved and improved that syntax. It should also be noted that, even today, modern Fortran has array capabilities that C++ doesn’t, such as <strong>array comprehensions.</strong></p>
<p>Of course, C/C++ made some progress in this area, like incorporating <strong>native complex numbers in the C99 standard</strong>. However, it should be noted that certain changes in the C standard just take a very long time to propagate. For example, Python’s ctypes (which provide compatibility with C and should conform to the standard) still does not support complex numbers, according to <a href="https://bugs.python.org/issue16899">this issue</a>. </p>
<p>As for multidimensional arrays, one significant problem faced by C++ developers is the number of possible libraries to choose from. The choices are, at least: <a href="https://eigen.tuxfamily.org/">Eigen</a>, <a href="https://bitbucket.org/blaze-lib/blaze/src/master/">Blaze</a>, <a href="https://github.com/romeric/Fastor">Fastor</a>, <a href="http://arma.sourceforge.net/">Armadillo</a>, <a href="https://xtensor.readthedocs.io/en/latest/">XTensor</a>, <a href="https://www.boost.org/doc/libs/1_61_0/libs/multi_array/doc/user.html">Boost.MultiArray</a>. To add fuel to the fire, many developers reinvented their own multidimensional array libraries. </p>
<p>The lack of a standard in the area makes it difficult to share code among developers who have made different choices of these basic libraries. <strong>This will change with C++23, which, finally, will make multidimensional arrays part of the standard</strong>.</p>
<h3 id="code-longevity-and-backward-compatibility-in-scientific-computing">Code longevity and backward compatibility in scientific computing</h3>
<p>From time to time, I still compile Fortran code that was written decades ago, and many people in scientific computing also do. </p>
<p>Numerical computing doesn’t get outdated as fast as, say, web design. Code longevity is a much-desired characteristic in scientific computing. Anybody who puts significant effort into writing numerical code would also like to make sure that it will <strong>still work for decades to come</strong>, largely unchanged. </p>
<p>If anything, <strong>Fortran is a guarantee for long-term code longevity</strong> because of its <strong>strict backward compatibility policy.</strong> Regrettably, this also introduces significant inertia, as language features don’t become deprecated. </p>
<h3 id="intrinsic-distributed-memory-parallelism-via-coarrays">Intrinsic distributed-memory parallelism via Coarrays</h3>
<p>The Fortran 2008 standard introduced a significant innovation, adding <strong>parallel processing on distributed memory systems as part of the language</strong>, in the form of Coarrays. </p>
<p>In the most recent versions of Fortran, only small changes are required to convert existing single-threaded or multi-threaded code, into distributed-memory parallel code, which has been usually much more challenging to write.</p>
<p>MPI began as a standardized network layer and has formed the backbone of cluster computing for the last 25 years. However, it has lately been showing signs of age. In particular, <strong>MPI requires programmers to write what is now considered very low-level code</strong>, using “send” and “receive” statements. </p>
<p>In numerical computing, <strong>developers would rather think in terms of distributed arrays or similar abstractions</strong>, and let some networking library do their job at handling and optimizing communications.</p>
<p><strong>Coarray Fortran (or CAF) is among the first post-MPI programming models for HPC</strong>. By making it part of the standard, there is a guarantee that CAF will not simply fade away due to lack of interest or an excessive dispersion of efforts, like previous attempts at developing new parallel programming models on top of other languages, like it was the case with <a href="https://upc.lbl.gov/">Unified Parallel C</a>.</p>
<h3 id="fortran-is-still-evolving">Fortran is still evolving</h3>
<p>Believe it or not, Fortran is still in active development. On one hand, the Fortran Standard Committee is in charge of revising the language periodically. </p>
<p>More importantly, there are interesting efforts to “resurrect” Fortran as a valid choice for new projects.</p>
<p>At present, Fortran is lacking modern toolings like a build system and a package manager, a thriving open-source community, and even a standard library.</p>
<p>Most of these issues are being addressed at the new <a href="https://fortran-lang.org/">Fortran-lang.org</a>, a vendor-neutral community. There is even <a href="https://lfortran.org/">LFortran</a>, an interactive compiler, under development, presently in the pre-alpha stage. See also the pre-print <a href="https://arxiv.org/abs/2109.07382">Toward Modern Fortran Tooling and a Thriving Developer Community</a> by the same authors of these initiatives.</p>
<p>The efforts for adapting Fortran into the internet era are extremely worthwhile. <strong>A good question is whether a sufficient number of Fortran developers will adopt the open-source culture required to make this work</strong>.</p>

<p>There are still very valid reasons for the continued use of Fortran today, mostly in close relation to its existing codebase. </p>
<p>However, you might have hinted that some or even <strong>all of the reasons for the continued use of Fortran can be challenged by some other languages</strong>. </p>
<p>I fact, <strong>I actually believe that Julia will end up replacing Fortran for most new projects, even in Fortran’s HPC niche</strong>. You can read about this in my post: <a href="https://www.matecdev.com/posts/will-julia-replace-fortran-hpc.html">Will Julia replace Fortran for high-performance computing?</a>.</p>
<p>In particular, I believe that <strong>the network effects of a thriving open-source community</strong> are rapidly becoming the dominant factor by which we choose one programming language over another. Julia seems to be already well ahead than Fortran in that regard, is not limited by any performance issues, and it incorporates most of the legacy of mathematical programming languages, among other new language features.</p>
<h2 id="do-you-need-help-with-fortran">Do you need help with Fortran?</h2>
<p>I wrote an few articles about Fortran on this blog, like: </p>
<ul>
<li><a href="https://www.matecdev.com/posts/fortran-in-python.html">How to Call Fortran from Python</a>.</li>
<li><a href="https://www.matecdev.com/posts/fortran-legacy-code.html">How to Work with Legacy Fortran Code: A Short Guideline</a>.</li>
</ul>
<p>If you are looking for general advice, or have a small bug, etc, a great resource to ask for help is the <a href="https://fortran-lang.discourse.group/">Fortran Forum</a>.</p>
<p>If you still need more help with your project, a good idea is to <strong>hire a freelancer at Fiverr</strong>, like the ones recommended below (or find more!):</p>

</div></div>
  </body>
</html>
