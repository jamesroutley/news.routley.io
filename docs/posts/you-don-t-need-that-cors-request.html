<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nickolinger.com/blog/2021-08-04-you-dont-need-that-cors-request/">Original</a>
    <h1>You don&#39;t need that CORS request</h1>
    
    <div id="readability-page-1" class="page"><div><p><img src="http://mrcoles.com/images/angry-browser.jpg"/></p><p>You&#39;re working on a site, <em>foobarbaz.app</em>, and you&#39;ve deployed your API to a subdomain at <em>api.foobarbaz.app</em>. The <code>api.</code> prefix <em>feels</em> like a nice touch because it&#39;s separated from the rest of your application.</p><h2>Preflight Requests</h2><p>Have you ever wondered what that <code>OPTIONS</code> request is executing before your actual <code>GET</code>/<code>POST</code>/<code>PUT</code>/<code>DELETE</code> when making requests to <code>api.foobarbaz.app</code>?</p><p><a href="https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request">MDN Web Docs</a> defines this as:</p><blockquote><p>A CORS preflight request is a CORS request that checks to see if the CORS protocol is understood and a server is aware using specific methods and headers.</p></blockquote><p>That definition makes sense once you understand what CORS is, seeing as it&#39;s self-referencing, but not so much before. Distilled down, it&#39;s a conversation between the browser and the API. It goes something like this:</p><blockquote><p><strong>Browser</strong>: &#34;Hey API, can I make this request?&#34;</p><p><strong>API</strong>: &#34;Hey Browser, sure.&#34;</p><p><strong>Browser</strong>: &#34;Thanks, API. Sending my request now&#34;</p></blockquote><p>The Web Hypertext Application Technology Working Group (WHATWG) CORS spec has <a href="https://fetch.spec.whatwg.org/#example-simple-cors">an excellent walk-through</a> of a basic scenario.</p><h2>Cut your network requests in half</h2><p>This conversation between the browser and the API is only necessary because our API at <code>api.foobarbaz.app</code> is not of the same origin as <code>foobarbaz.app</code>, specifically our <em>hostname</em> is now different. <em>Port</em> (<code>:443</code>, <code>:80</code>, etc) and <em>protocol</em> (<code>HTTP</code>, <code>HTTPS</code>) also follow the same logic as <em>hostname</em>, so any differences in the page&#39;s hostname, port, and protocol and a request executed on the page will require a CORS request. web.dev&#39;s <a href="https://web.dev/same-site-same-origin/">Understanding &#34;same-site&#34; and &#34;same-origin&#34;</a> does a great job of breaking down the parts of a URL.</p><p>You&#39;ll notice that a header, <code>sec-fetch-site</code>, is attached to any XHR request in Firefox and Chrome which will indicate whether this was a <code>same-origin</code> request or not.</p><p>Below is an example of cross origin request headers in Firefox. Note the <code>Sec-Fetch-Site: cross-site</code>. You can read more about <code>Sec-Fetch-Site</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site">here on MDN</a>.</p><p><img src="http://mrcoles.com/images/screenshots/request-headers.jpg"/></p><p>If you&#39;re using a service, like Fastly or Cloudflare, to proxy to your application or if you have a proxy setup — this shouldn&#39;t be an invasive change since the aim is simply to create an alias on the hostname where the original application loaded. Routing <code>https://api.foobarbaz.app</code> to <code>https://foobarbaz.app/api</code> and moving over the JavaScript clients using the <code>api.</code> subdomain will cut your network traffic in half.</p><h3>Context</h3><p>While working at <a href="https://meetup.com">meetup.com</a>, I worked on a team focused on improving p95 latencies, which is actually interesting, engaging work. One afternoon another engineer and myself were having a hard time identifying low-effort, high impact changes when we stumbled across the 40-90ms each network request was making from the browser for preflight requests. In one afternoon, we removed our CORs requests — a change that drastically improved the desktop and mobile web&#39;s experience.</p></div></div>
  </body>
</html>
