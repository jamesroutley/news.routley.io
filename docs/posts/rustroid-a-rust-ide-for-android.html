<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rustroid.is-a.dev/story">Original</a>
    <h1>Rustroid, a Rust IDE for Android</h1>
    
    <div id="readability-page-1" class="page"><div data-v-d668f7cc=""><div data-v-d668f7cc=""><!--[--><!--]--><main data-v-d668f7cc=""><div data-v-d668f7cc=""><div><p>If you don&#39;t already know, <a href="https://play.google.com/store/apps/details?id=com.mohammedkhc.ide.rust" target="_blank" rel="noreferrer">Rustroid</a> is a Rust IDE for Android that runs locally on the device.</p><h2 id="it-all-began-with-minecraft" tabindex="-1">It All Began with Minecraft <a href="#it-all-began-with-minecraft" aria-label="Permalink to “It All Began with Minecraft”">​</a></h2><p>Back in my past, I was a 12-year-old watching YouTubers play on Minecraft Java Edition servers with mods. The mods were awesome and mind-blowing, and I wanted to try them.</p><p>But I didn&#39;t have a PC or even Minecraft Java. All I had was a mobile phone with Minecraft Bedrock Edition, which didn&#39;t have any amazing mods. So, I decided to try to create a mod myself for the mobile edition. I didn&#39;t know what to do or where to start. I just downloaded a bunch of mods and tried to open their files to understand how they worked.</p><p><strong>That was the moment I realized that the Android ecosystem lacked any kind of developer tools.</strong></p><p>Back then, all the mods for Bedrock were just JSON files. I wanted a JSON editor, and all I could find was an application named QuickEdit. It wasn&#39;t very advanced, but it had useful features like syntax highlighting, undo/redo, and search/replace. However, it lacked a linter, autocompletion, diagnostics, or any of the features that make programmers happy.</p><p>In the end, I started copying and pasting some parts from here and there and created the most advanced Morph mod for Bedrock Edition at the time, using only my mobile phone.</p><p><em>And then i <strong>deleted</strong> the mod and moved on to other things, but that&#39;s not the point of this article. 😃</em></p><h2 id="moving-on-from-minecraft" tabindex="-1">Moving on from Minecraft <a href="#moving-on-from-minecraft" aria-label="Permalink to “Moving on from Minecraft”">​</a></h2><p>After what I would call a huge success, I wanted to move on and do other things. I wanted to do more.</p><p>I started experimenting with the Java language because I wanted to know how to make a game that could compete with Minecraft (which, by the way, was a silly idea), again all from my Android phone. I started watching a really good tutorial by RyiSnow on creating a 2D top-down adventure game <a href="https://www.youtube.com/watch?v=om59cwR7psI&amp;list=PL_QPQmz5C6WUF-pOQDsbsKbaBZqXj4qSq" target="_blank" rel="noreferrer">Playlist link</a>.</p><p>The tutorial explained how to create a 2D game using Java swing/awt graphics. And, as you may know, Android is built on top of Java, so everything should work, right?</p><p>Well, no. It turns out that Android does not include the full Java. It only includes parts of it, and Java swing/awt is not included. But Android does have an alternative. Android apps consist of <a href="https://developer.android.com/reference/android/app/Activity" target="_blank" rel="noreferrer"><code>Activity</code></a> which is the entry point of the app.</p><p>and <a href="https://developer.android.com/reference/android/view/View" target="_blank" rel="noreferrer"><code>View</code></a> which is like the alternative to <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html" target="_blank" rel="noreferrer"><code>JComponent</code></a>, and views does contain an <a href="https://developer.android.com/reference/android/view/View#onDraw(android.graphics.Canvas)" target="_blank" rel="noreferrer"><code>onDraw(Canvas)</code></a> method that is responsible for drawing stuff on the screen It&#39;s very similar to java&#39;s <a href="https://docs.oracle.com/javase/8/docs/api/javax/swing/JComponent.html#paintComponent-java.awt.Graphics-" target="_blank" rel="noreferrer"><code>JComponent.paintComponent(Graphics)</code></a>. So, I began to follow the tutorial, but I replaced anything Swing related with the Android alternative.</p><p>Oh, right, I didn&#39;t say how I was able to follow the tutorial without an IDE, a Java compiler, or even an Android APK generator. Well, there was a new application in town called <a href="https://github.com/tyron12233/CodeAssist" target="_blank" rel="noreferrer">CodeAssist</a>. It allowed the user to build Android applications with Java. (Btw, it&#39;s not maintained anymore, and it was, and still is, in beta or even alpha, I don&#39;t know.) I ported a large amount of the game and was genuinely happy.</p><h2 id="the-small-beginning" tabindex="-1">The Small Beginning <a href="#the-small-beginning" aria-label="Permalink to “The Small Beginning”">​</a></h2><p>I wanted to create an IDE for Java using CodeAssist. I know, very original. But you always want to replicate the tools you use. I tried using CodeAssist to create it, and I would say I got somewhere. I got familiar with the Android SDK and how APK generation, the Java compiler, and other things work.</p><p><em>But again, that&#39;s not what this article is about.</em></p><h2 id="the-real-beginning" tabindex="-1">The Real Beginning <a href="#the-real-beginning" aria-label="Permalink to “The Real Beginning”">​</a></h2><p>I finally got my hands on a PC. I tried Rust to see why there was so much hype about it, and yeah, I kind of liked its ecosystem. You know, all things in one: the compiler, the package manager, the test suite, the docs. they are all one and the same (named cargo).</p><p>I installed Android Studio, created a new project, and literally dumped everything else that I had created. I called the project <strong>Rustroid</strong>.</p><p>You may ask why I created a Rust IDE and not a Java one. Well, there were three reasons (Or maybe more, I don&#39;t know, LOL).</p><ol><li>I discovered that Rust is the most admired language.</li><li>There was a very good IDE for Android that was currently being worked on, called AndroidIDE. (AndroidIDE is also unmaintained now. 😕)</li><li>I just loved the language.</li></ol><p>When I was creating the project, I set the language to Java and was going to make the app with the views-based approach, like I used to on my phone. But I wanted to try Kotlin with Jetpack Compose because Kotlin and Jetpack Compose were Android Studio&#39;s recommended defaults for new projects. And oh boy, I fell in love with Kotlin and Jetpack Compose. I didn&#39;t go back to Java after that.</p><h2 id="how-does-rustroid-work" tabindex="-1">How Does Rustroid Work? <a href="#how-does-rustroid-work" aria-label="Permalink to “How Does Rustroid Work?”">​</a></h2><p>To understand how Rustroid works, you first have to understand how Android works. Android is an operating system based on Linux, which means it shares the same internals as a fully featured Linux distro. And Android supports Java, which itself supports <a href="https://developer.android.com/reference/java/lang/Process" target="_blank" rel="noreferrer"><code>Process</code></a> and the ability to execute native processes. So it should be possible to run Rust on Android. I just needed to grab the Rust version that is compiled for <code>aarch64-linux</code> (My phone&#39;s architecture) and execute it on Android, and it should work, right?</p><p>Well, no. It turns out that there is a fundamental difference between regular Linux distro binaries and Android binaries. Linux binaries are linked against <code>gnu&#39;s libc</code>, while Android is linked against <code>bionic&#39;s libc</code>.</p><h2 id="the-implementation" tabindex="-1">The Implementation <a href="#the-implementation" aria-label="Permalink to “The Implementation”">​</a></h2><p>I figured out that there are a bunch of folks who are porting almost every Linux package to Android. How? Well, they are compiling it with the Android NDK, which links them with <code>bionic&#39;s libc</code>. These folks are the guys behind <a href="https://github.com/termux/termux-app" target="_blank" rel="noreferrer"><code>Termux</code></a> (a terminal emulator for Android). So, I copied their compiled Rust with its dependencies, patched some parts of it, and boom, it works.</p><div><p>Note</p><p>When I mentioned the people behind Termux, I was referring to the <a href="https://github.com/termux/termux-packages" target="_blank" rel="noreferrer"><code>Termux-Packages</code></a> project. The packages they compile are licensed under the same license as the original package, so their Rust package, for instance, is licensed under either Apache 2.0 or the MIT license. You can also find all the license information in the about screen of my app. When i said the guys behind Termux i was referring to . And the packages that they compile are licened under the same license as the original package. (So their rust is licened under APACHE2/MIT).</p></div><p>Now, what does an IDE need?</p><ol><li>A powerful code editor (with LSP)</li><li>A terminal emulator</li><li>A file explorer and a good interface</li></ol><p>The third was the easiest and not very difficult, I would say.</p><h3 id="the-code-editor" tabindex="-1">The Code Editor <a href="#the-code-editor" aria-label="Permalink to “The Code Editor”">​</a></h3><p>I wanted to implement the code editor with at least the following features:</p><ul><li>A fast and memory-efficient text buffer.</li><li>An undo and redo manager.</li><li>Syntax highlighting using TextMate.</li><li>LSP integration.</li></ul><hr/><h3 id="the-text-buffer" tabindex="-1">The Text Buffer <a href="#the-text-buffer" aria-label="Permalink to “The Text Buffer”">​</a></h3><p>At first, I wrote it using an array of lines, but the performance wasn&#39;t that great, and it had several disadvantages. But then, my eyes caught this article from VS Code: <a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation" target="_blank" rel="noreferrer">VS Code Text Buffer Reimplementation</a>. It&#39;s a great article; I recommend you give it a shot. From the VS Code&#39;s article:</p><blockquote><p>The mental model for an editor is line-based. Developers read and write source code line by line, compilers provide line/column-based diagnostics, stack traces contain line numbers, tokenization engines run line by line, etc. Although simple, the text buffer implementation powering VS Code hadn&#39;t changed much since the first day we kicked off the Monaco project. We used an array of lines.</p><p>However, we kept receiving reports that opening certain files would cause Out-Of-Memory crashes in VS Code. For example, one user failed to open a 35 MB file. The root cause was that the file had too many lines, 13.7 million. We would create a <code>ModelLine</code> object for each line, and every object used around 40-60 bytes, so the line array used around 600MB of memory to store the document. That&#39;s roughly 20 times the initial file size!</p><p>Another problem with the line array representation was the speed of opening a file. To construct the array of lines, we had to split the content by line breaks, such that we would get a string object per line. The split itself hurts performance, which you&#39;ll see in benchmarks further down.</p></blockquote><p>I know that this shouldn&#39;t even be a problem for my app, as no one would open such big files on their smartphone, right? Well, yes! But I implemented the piece tree buffer anyway. 😉</p><p>It took some days, but it was working, and I ported the VS Code piece tree text buffer tests to Kotlin. And all of them passed.</p><p>By the way, I don&#39;t write tests for my code. I either stea... I mean, copy them, or just leave the code without tests.</p><hr/><h3 id="the-undo-redo-manager" tabindex="-1">The Undo &amp; Redo Manager <a href="#the-undo-redo-manager" aria-label="Permalink to “The Undo &amp; Redo Manager”">​</a></h3><p>Well, that wasn&#39;t hard. Just create a list of an <code>Action</code> class that has an <code>undo</code> and <code>redo</code> method, and create an index variable. Insert/delete the text based on whether we are undoing or redoing. When undoing, decrease the index, and when redoing, increase the index. And that&#39;s it.</p><hr/><h3 id="the-syntax-highlighting" tabindex="-1">The Syntax Highlighting <a href="#the-syntax-highlighting" aria-label="Permalink to “The Syntax Highlighting”">​</a></h3><p>Well, I just ported the <a href="https://github.com/microsoft/vscode-textmate" target="_blank" rel="noreferrer">VS Code implementation of TextMate</a> to Kotlin and used it. By the way, porting Microsoft&#39;s code is not that easy; just because I said I <em>just</em> ported it doesn&#39;t mean it&#39;s easy. I think they are trying to make the code more complicated than needed on purpose. So, yeah.</p><hr/><h3 id="the-lsp-the-fundamental-part-of-the-ide" tabindex="-1">the LSP (The Fundamental Part of the IDE) <a href="#the-lsp-the-fundamental-part-of-the-ide" aria-label="Permalink to “the LSP (The Fundamental Part of the IDE)”">​</a></h3><p>The LSP stands for Language Server Protocol.</p><p>The first thing to do was to read the <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/" target="_blank" rel="noreferrer">LSP spec</a>.</p><p>The brief of the protocol is that the IDE (the client) and the language server communicate through <code>std in &amp; out</code> or TCP, or Unix sockets, or whatever, and it&#39;s based on JSON-RPC.</p><p>The base protocol consists of a header and a content part (comparable to HTTP).</p><p>Thanks to Kotlin sealed classes and <code>kotlinx.serialization</code>, implementing the LSP wasn&#39;t very hard. And that&#39;s it: the client and the server send a bunch of requests/responses to each other, and boom, everything works!</p><hr/><h3 id="the-terminal" tabindex="-1">The Terminal <a href="#the-terminal" aria-label="Permalink to “The Terminal”">​</a></h3><p>I took the terminal emulation part from Jackpal&#39;s <a href="https://github.com/jackpal/Android-Terminal-Emulator" target="_blank" rel="noreferrer">Android Terminal Emulator</a>, converted it to Kotlin, converted it to Jetpack Compose code instead of Android-specific code, and fixed some bugs, you know, things like that.</p><h2 id="other-things" tabindex="-1">Other Things <a href="#other-things" aria-label="Permalink to “Other Things”">​</a></h2><p>You know, there are other things to take into consideration: the code editor needs to measure text and render text, handle scrolling, update cursor position, and make sure that the cursor is not in the middle of a surrogate pair.</p><div><p>Note</p><p>Java does not use UTF-8 it used UTF-16, so some characters (e.g., emojis) have two codepoints instead of one.</p></div><p>Creating hover, signature help, completion, diagnostics popups, go-to-definition, declaration, implementation, etc.</p><h2 id="publishing-the-app" tabindex="-1">Publishing the app <a href="#publishing-the-app" aria-label="Permalink to “Publishing the app”">​</a></h2><p>At first, I wanted to make it open source and publish it on Google Play so I could get contributors from all around the world and, at the same time, make it available to almost all Android users.</p><p>In fact, early on, I did actually publish the source code on GitLab for about 3 days or so. But then I deleted it.</p><h3 id="why-not-open-source" tabindex="-1">Why not open source <a href="#why-not-open-source" aria-label="Permalink to “Why not open source”">​</a></h3><p>As you can see, both CodeAssist and AndroidIDE are not maintained anymore. I think this is due to a lack of funding, which completely removes the motivation for continuing to develop them. Sure, there are donations that come once in a while, but that&#39;s not enough to make someone continue working on a project, especially if he has no job and no other source of income (like me). Maybe, just maybe, in the future, I will reconsider making it open source to benefit the community and even myself.</p><h3 id="closed-source-distribution" tabindex="-1">Closed source distribution <a href="#closed-source-distribution" aria-label="Permalink to “Closed source distribution”">​</a></h3><p>Now there are four options to distribute the app.</p><ol><li>Distributing it for free without ads.</li><li>Distributing it for free with ads.</li><li>Distributing it for free with limited features and offering in-app purchases to unlock the app&#39;s full potential.</li><li>Distributing it with a one-time purchase.</li></ol><p>I can&#39;t choose number one, as that would make me broke 😃.</p><p>And I can&#39;t choose number two either. I don&#39;t like the idea of ads; they are just really annoying, and I just don&#39;t like them.</p><p>Now it&#39;s all about number three and four. Number three is not that bad.</p><p>So that leaves only number four: making it paid.</p><p>The app&#39;s price is $7.00 USD.</p><p>If you are in a country that does not support Google Play purchases (ex. Syria), or you just don&#39;t have enough money, <a href="mailto:contact.mohammedkhc@gmail.com" target="_blank" rel="noreferrer">Contact me</a> and I will <strong>try</strong> to give it for you for free, In sha Allah.</p><h2 id="the-end" tabindex="-1">The End <a href="#the-end" aria-label="Permalink to “The End”">​</a></h2><p>I know that i haven&#39;t said a lot; I am really too lazy to write. Man, I do hate writing.</p><p>Creating this IDE allowed me to learn a lot, and I mean a lot. I am too lazy to write what I learned, but I mean it.</p><p>Now I am in the last year of high school (I&#39;m 17, by the way). I hope to find time to keep working on the app this year (by this year, I mean 2026 😉).</p><p>Btw, I did convert the IDE to Compose Multiplatform so that I can run it on my PC without having to connect an Android phone (To make the development of it easier.). Also, I do plan to create an IDE for every language out there (In sha Allah) since I implemented the foundation of the IDE, so stay tuned!</p><p>You can download the app from Google Play, via this <a href="https://play.google.com/store/apps/details?id=com.mohammedkhc.ide.rust" target="_blank" rel="noreferrer">link</a>.</p><p>Best regards,</p><p>Oh, right, that&#39;s not an email. Ignore the last part. LOL.</p></div></div></main><!--[--><!--]--></div></div></div>
  </body>
</html>
