<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/wouterken/crystalruby">Original</a>
    <h1>Embed Crystal code directly in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><table>
  <tbody><tr>
    <td><a target="_blank" rel="noopener noreferrer" href="https://github.com/wouterken/crystalruby/blob/main/logo.png"><img src="https://github.com/wouterken/crystalruby/raw/main/logo.png" alt="logo" width="150"/></a></td>
    <td>
      
      <p dir="auto">
        <a href="https://rubygems.org/gems/crystalruby" rel="nofollow">
          <img alt="GEM Version" src="https://camo.githubusercontent.com/d346892b40779fe1a14a2309de9312bf254002753f40dd1d4a498a33015db5cb/68747470733a2f2f696d672e736869656c64732e696f2f67656d2f762f6372797374616c727562793f636f6c6f723d31363841464526696e636c7564655f70726572656c6561736573266c6f676f3d72756279266c6f676f436f6c6f723d464531363136" data-canonical-src="https://img.shields.io/gem/v/crystalruby?color=168AFE&amp;include_prereleases&amp;logo=ruby&amp;logoColor=FE1616"/>
        </a></p>
    </td>
  </tr>
</tbody></table>
<p dir="auto"><code>crystalruby</code> is a gem that allows you to write Crystal code, inlined in Ruby. All you need is a modern crystal compiler installed on your system.</p>
<p dir="auto">You can then turn simple methods into Crystal methods as easily as demonstrated below:</p>
<div dir="auto" data-snippet-clipboard-copy-content="require &#39;crystalruby&#39;

module MyTestModule
  # The below method will be replaced by a compiled Crystal version
  # linked using FFI.
  crystalize [a: :int, b: :int] =&gt; :int
  def add(a, b)
    a + b
  end
end

# This method is run in Crystal, not Ruby!
MyTestModule.add(1, 2) # =&gt; 3"><pre><span>require</span> <span>&#39;crystalruby&#39;</span>

<span>module</span> <span>MyTestModule</span>
  <span># The below method will be replaced by a compiled Crystal version</span>
  <span># linked using FFI.</span>
  <span>crystalize</span> <span>[</span><span>a</span>: <span>:int</span><span>,</span> <span>b</span>: <span>:int</span><span>]</span> <span>=&gt;</span> <span>:int</span>
  <span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>a</span> + <span>b</span>
  <span>end</span>
<span>end</span>

<span># This method is run in Crystal, not Ruby!</span>
<span>MyTestModule</span><span>.</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span> <span># =&gt; 3</span></pre></div>
<p dir="auto">With as small a change as this, you should be able to see a significant increase in performance for some Ruby code.
E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
require &#39;crystalruby&#39;
require &#39;benchmark&#39;

module Fibonnaci
  crystalize [n: :int32] =&gt; :int32
  def fib_cr(n)
    a = 0
    b = 1
    n.times { a, b = b, a + b }
    a
  end

  module_function

  def fib_rb(n)
    a = 0
    b = 1
    n.times { a, b = b, a + b }
    a
  end
end

puts(Benchmark.realtime { 1_000_000.times { Fibonnaci.fib_rb(30) } })
puts(Benchmark.realtime { 1_000_000.times { Fibonnaci.fib_cr(30) } })
"><pre><span>require</span> <span>&#39;crystalruby&#39;</span>
<span>require</span> <span>&#39;benchmark&#39;</span>

<span>module</span> <span>Fibonnaci</span>
  <span>crystalize</span> <span>[</span><span>n</span>: <span>:int32</span><span>]</span> <span>=&gt;</span> <span>:int32</span>
  <span>def</span> <span>fib_cr</span><span>(</span><span>n</span><span>)</span>
    <span>a</span> <span>=</span> <span>0</span>
    <span>b</span> <span>=</span> <span>1</span>
    <span>n</span><span>.</span><span>times</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>b</span><span>,</span> <span>a</span> + <span>b</span> <span>}</span>
    <span>a</span>
  <span>end</span>

  <span>module_function</span>

  <span>def</span> <span>fib_rb</span><span>(</span><span>n</span><span>)</span>
    <span>a</span> <span>=</span> <span>0</span>
    <span>b</span> <span>=</span> <span>1</span>
    <span>n</span><span>.</span><span>times</span> <span>{</span> <span>a</span><span>,</span> <span>b</span> <span>=</span> <span>b</span><span>,</span> <span>a</span> + <span>b</span> <span>}</span>
    <span>a</span>
  <span>end</span>
<span>end</span>

<span>puts</span><span>(</span><span>Benchmark</span><span>.</span><span>realtime</span> <span>{</span> <span>1_000_000</span><span>.</span><span>times</span> <span>{</span> <span>Fibonnaci</span><span>.</span><span>fib_rb</span><span>(</span><span>30</span><span>)</span> <span>}</span> <span>}</span><span>)</span>
<span>puts</span><span>(</span><span>Benchmark</span><span>.</span><span>realtime</span> <span>{</span> <span>1_000_000</span><span>.</span><span>times</span> <span>{</span> <span>Fibonnaci</span><span>.</span><span>fib_cr</span><span>(</span><span>30</span><span>)</span> <span>}</span> <span>}</span><span>)</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="3.193121999996947 # Ruby
0.29086600001028273 # Crystal"><pre>3.193121999996947 <span><span>#</span> Ruby</span>
0.29086600001028273 <span><span>#</span> Crystal</span></pre></div>
<p dir="auto"><em>Note</em>: The first run of the Crystal code will be slower, as it needs to compile the code first. The subsequent runs will be much faster.</p>
<p dir="auto">You can call embedded crystal code, from within other embedded crystal code.
E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="module Cache

  crystalize [key: :string] =&gt; :string
  def redis_get(key)
    rds = Redis::Client.new
    value = rds.get(key).to_s
  end

  crystalize [key: :string, value: :string] =&gt; :string
  def redis_set_and_return(key)
    redis = Redis::Client.new
    redis.set(key, value)
    Cache.redis_get(key)
  end
end
Cache.redis_set_and_return(&#39;test&#39;, &#39;abc&#39;)
puts Cache.redis_get(&#39;test&#39;)"><pre><span>module</span> <span>Cache</span>

  <span>crystalize</span> <span>[</span><span>key</span>: <span>:string</span><span>]</span> <span>=&gt;</span> <span>:string</span>
  <span>def</span> <span>redis_get</span><span>(</span><span>key</span><span>)</span>
    <span>rds</span> <span>=</span> <span>Redis</span>::<span>Client</span><span>.</span><span>new</span>
    <span>value</span> <span>=</span> <span>rds</span><span>.</span><span>get</span><span>(</span><span>key</span><span>)</span><span>.</span><span>to_s</span>
  <span>end</span>

  <span>crystalize</span> <span>[</span><span>key</span>: <span>:string</span><span>,</span> <span>value</span>: <span>:string</span><span>]</span> <span>=&gt;</span> <span>:string</span>
  <span>def</span> <span>redis_set_and_return</span><span>(</span><span>key</span><span>)</span>
    <span>redis</span> <span>=</span> <span>Redis</span>::<span>Client</span><span>.</span><span>new</span>
    <span>redis</span><span>.</span><span>set</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>)</span>
    <span>Cache</span><span>.</span><span>redis_get</span><span>(</span><span>key</span><span>)</span>
  <span>end</span>
<span>end</span>
<span>Cache</span><span>.</span><span>redis_set_and_return</span><span>(</span><span>&#39;test&#39;</span><span>,</span> <span>&#39;abc&#39;</span><span>)</span>
<span>puts</span> <span>Cache</span><span>.</span><span>redis_get</span><span>(</span><span>&#39;test&#39;</span><span>)</span></pre></div>



<p dir="auto">Where the Crystal syntax is also valid Ruby syntax, you can just write Ruby.
It&#39;ll be compiled as Crystal automatically.</p>
<p dir="auto">E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="crystalize [a: :int, b: :int] =&gt; :int
def add(a, b)
  puts &#34;Adding #{a} and #{b}&#34;
  a + b
end"><pre><span>crystalize</span> <span>[</span><span>a</span>: <span>:int</span><span>,</span> <span>b</span>: <span>:int</span><span>]</span> <span>=&gt;</span> <span>:int</span>
<span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>puts</span> <span>&#34;Adding <span><span>#{</span><span>a</span><span>}</span></span> and <span><span>#{</span><span>b</span><span>}</span></span>&#34;</span>
  <span>a</span> + <span>b</span>
<span>end</span></pre></div>

<p dir="auto">Some Crystal syntax is not valid Ruby, for methods of this form, we need to
define our functions using a :raw parameter.</p>
<div dir="auto" data-snippet-clipboard-copy-content="crystalize :raw, [a: :int, b: :int] =&gt; :int
def add(a, b)
  &lt;&lt;~CRYSTAL
    c = 0_u64
    a + b + c
  CRYSTAL
end"><pre><span>crystalize</span> <span>:raw</span><span>,</span> <span>[</span><span>a</span>: <span>:int</span><span>,</span> <span>b</span>: <span>:int</span><span>]</span> <span>=&gt;</span> <span>:int</span>
<span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
  <span>&lt;&lt;~CRYSTAL</span><span></span>
<span>    c = 0_u64</span>
<span>    a + b + c</span>
<span>  CRYSTAL</span>
<span>end</span></pre></div>

<p dir="auto">The below is a stand-alone one-file script that allows you to quickly see crystalruby in action.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# crystalrubytest.rb
require &#39;bundler/inline&#39;

gemfile do
  source &#39;https://rubygems.org&#39;
  gem &#39;crystalruby&#39;
end

require &#39;crystalruby&#39;

module Adder
  crystalize [a: :int, b: :int] =&gt; :int
  def add(a, b)
    a + b
  end
end

puts Adder.add(1, 2)"><pre><span># crystalrubytest.rb</span>
<span>require</span> <span>&#39;bundler/inline&#39;</span>

<span>gemfile</span> <span>do</span>
  <span>source</span> <span>&#39;https://rubygems.org&#39;</span>
  <span>gem</span> <span>&#39;crystalruby&#39;</span>
<span>end</span>

<span>require</span> <span>&#39;crystalruby&#39;</span>

<span>module</span> <span>Adder</span>
  <span>crystalize</span> <span>[</span><span>a</span>: <span>:int</span><span>,</span> <span>b</span>: <span>:int</span><span>]</span> <span>=&gt;</span> <span>:int</span>
  <span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>a</span> + <span>b</span>
  <span>end</span>
<span>end</span>

<span>puts</span> <span>Adder</span><span>.</span><span>add</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span></pre></div>

<p dir="auto">Currently primitive types are supported.
Composite types are supported using JSON serialization.
C-Structures are a WIP.
To see the list of currently supported primitive type mappings of FFI types to crystal types, you can check: <code>CrystalRuby::Typemaps::CRYSTAL_TYPE_MAP</code>
E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="CrystalRuby::Typemaps::CRYSTAL_TYPE_MAP
=&gt; {:char=&gt;&#34;Int8&#34;,
 :uchar=&gt;&#34;UInt8&#34;,
 :int8=&gt;&#34;Int8&#34;,
 :uint8=&gt;&#34;UInt8&#34;,
 :short=&gt;&#34;Int16&#34;,
 :ushort=&gt;&#34;UInt16&#34;,
 :int16=&gt;&#34;Int16&#34;,
 :uint16=&gt;&#34;UInt16&#34;,
 :int=&gt;&#34;Int32&#34;,
 :uint=&gt;&#34;UInt32&#34;,
 :int32=&gt;&#34;Int32&#34;,
 :uint32=&gt;&#34;UInt32&#34;,
 :long=&gt;&#34;Int32 | Int64&#34;,
 :ulong=&gt;&#34;UInt32 | UInt64&#34;,
 :int64=&gt;&#34;Int64&#34;,
 :uint64=&gt;&#34;UInt64&#34;,
 :long_long=&gt;&#34;Int64&#34;,
 :ulong_long=&gt;&#34;UInt64&#34;,
 :float=&gt;&#34;Float32&#34;,
 :double=&gt;&#34;Float64&#34;,
 :bool=&gt;&#34;Bool&#34;,
 :void=&gt;&#34;Void&#34;,
 :string=&gt;&#34;String&#34;}"><pre><span>CrystalRuby</span>::<span>Typemaps</span>::<span>CRYSTAL_TYPE_MAP</span>
<span>=&gt;</span> <span>{</span><span>:char</span><span>=&gt;</span><span>&#34;Int8&#34;</span><span>,</span>
 <span>:uchar</span><span>=&gt;</span><span>&#34;UInt8&#34;</span><span>,</span>
 <span>:int8</span><span>=&gt;</span><span>&#34;Int8&#34;</span><span>,</span>
 <span>:uint8</span><span>=&gt;</span><span>&#34;UInt8&#34;</span><span>,</span>
 <span>:short</span><span>=&gt;</span><span>&#34;Int16&#34;</span><span>,</span>
 <span>:ushort</span><span>=&gt;</span><span>&#34;UInt16&#34;</span><span>,</span>
 <span>:int16</span><span>=&gt;</span><span>&#34;Int16&#34;</span><span>,</span>
 <span>:uint16</span><span>=&gt;</span><span>&#34;UInt16&#34;</span><span>,</span>
 <span>:int</span><span>=&gt;</span><span>&#34;Int32&#34;</span><span>,</span>
 <span>:uint</span><span>=&gt;</span><span>&#34;UInt32&#34;</span><span>,</span>
 <span>:int32</span><span>=&gt;</span><span>&#34;Int32&#34;</span><span>,</span>
 <span>:uint32</span><span>=&gt;</span><span>&#34;UInt32&#34;</span><span>,</span>
 <span>:long</span><span>=&gt;</span><span>&#34;Int32 | Int64&#34;</span><span>,</span>
 <span>:ulong</span><span>=&gt;</span><span>&#34;UInt32 | UInt64&#34;</span><span>,</span>
 <span>:int64</span><span>=&gt;</span><span>&#34;Int64&#34;</span><span>,</span>
 <span>:uint64</span><span>=&gt;</span><span>&#34;UInt64&#34;</span><span>,</span>
 <span>:long_long</span><span>=&gt;</span><span>&#34;Int64&#34;</span><span>,</span>
 <span>:ulong_long</span><span>=&gt;</span><span>&#34;UInt64&#34;</span><span>,</span>
 <span>:float</span><span>=&gt;</span><span>&#34;Float32&#34;</span><span>,</span>
 <span>:double</span><span>=&gt;</span><span>&#34;Float64&#34;</span><span>,</span>
 <span>:bool</span><span>=&gt;</span><span>&#34;Bool&#34;</span><span>,</span>
 <span>:void</span><span>=&gt;</span><span>&#34;Void&#34;</span><span>,</span>
 <span>:string</span><span>=&gt;</span><span>&#34;String&#34;</span><span>}</span></pre></div>
<div dir="auto"><h2 tabindex="-1" dir="auto">Composite Types (using JSON serialization)</h2><a id="user-content-composite-types-using-json-serialization" aria-label="Permalink: Composite Types (using JSON serialization)" href="#composite-types-using-json-serialization"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">The library allows you to pass complex nested structures using JSON as a serialization format.
The type signatures for composite types can use ordinary Crystal Type syntax.
Type conversion is applied automatically.</p>
<p dir="auto">E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="crystalize [a: json{ Int64 | Float64 | Nil }, b: json{ String | Array(Bool)  } ] =&gt; :void
def complex_argument_types
  puts &#34;Got #{a} and #{b}&#34;
end

crystalize [] =&gt; json{ Int32 | String | Hash(String, Array(NamedTuple(hello: Int32)) | Time)}
def complex_return_type
  return {
    &#34;hello&#34; =&gt; [
      {
        hello: 1,
      },
    ],
    &#34;world&#34; =&gt; Time.utc
  }
end"><pre><span>crystalize</span> <span>[</span><span>a</span>: <span>json</span><span>{</span> <span>Int64</span> | <span>Float64</span> | <span>Nil</span> <span>}</span><span>,</span> <span>b</span>: <span>json</span><span>{</span> <span>String</span> | <span>Array</span><span>(</span><span>Bool</span><span>)</span>  <span>}</span> <span>]</span> <span>=&gt;</span> <span>:void</span>
<span>def</span> <span>complex_argument_types</span>
  <span>puts</span> <span>&#34;Got <span><span>#{</span><span>a</span><span>}</span></span> and <span><span>#{</span><span>b</span><span>}</span></span>&#34;</span>
<span>end</span>

<span>crystalize</span> <span>[</span><span>]</span> <span>=&gt;</span> <span>json</span><span>{</span> <span>Int32</span> | <span>String</span> | <span>Hash</span><span>(</span><span>String</span><span>,</span> <span>Array</span><span>(</span><span>NamedTuple</span><span>(</span><span>hello</span>: <span>Int32</span><span>)</span><span>)</span> | <span>Time</span><span>)</span><span>}</span>
<span>def</span> <span>complex_return_type</span>
  <span>return</span> <span>{</span>
    <span>&#34;hello&#34;</span> <span>=&gt;</span> <span>[</span>
      <span>{</span>
        <span>hello</span>: <span>1</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
    <span>&#34;world&#34;</span> <span>=&gt;</span> <span>Time</span><span>.</span><span>utc</span>
  <span>}</span>
<span>end</span></pre></div>
<p dir="auto">Type signatures validations are applied to both arguments and return types.</p>
<div dir="auto" data-snippet-clipboard-copy-content="[1] pry(main)&gt; Foo.complex_argument_types(nil, &#34;test&#34;)
Got  and test
=&gt; nil

[2] pry(main)&gt; Foo.complex_argument_types(88, [true, false, true])
Got 88 and [true, false, true]
=&gt; nil

[3] pry(main)&gt; Foo.complex_argument_types(88, [true, false, 88])
ArgumentError: Expected Bool but was Int at line 1, column 15
from crystalruby.rb:303:in `block in compile!&#39;"><pre><span>[</span><span>1</span><span>]</span><span></span> <span>pry</span><span>(</span><span>main</span><span>)</span>&gt; <span>Foo</span><span>.</span><span>complex_argument_types</span><span>(</span><span>nil</span><span>,</span> <span>&#34;test&#34;</span><span>)</span>
<span>Got</span>  <span>and</span> <span>test</span>
<span>=&gt;</span> <span>nil</span>

<span>[</span><span>2</span><span>]</span><span></span> <span>pry</span><span>(</span><span>main</span><span>)</span>&gt; <span>Foo</span><span>.</span><span>complex_argument_types</span><span>(</span><span>88</span><span>,</span> <span>[</span><span>true</span><span>,</span> <span>false</span><span>,</span> <span>true</span><span>]</span><span>)</span>
<span>Got</span> <span>88</span> <span>and</span> <span>[</span><span>true</span><span>,</span> <span>false</span><span>,</span> <span>true</span><span>]</span>
<span>=&gt;</span> <span>nil</span>

<span>[</span><span>3</span><span>]</span><span></span> <span>pry</span><span>(</span><span>main</span><span>)</span>&gt; <span>Foo</span><span>.</span><span>complex_argument_types</span><span>(</span><span>88</span><span>,</span> <span>[</span><span>true</span><span>,</span> <span>false</span><span>,</span> <span>88</span><span>]</span><span>)</span>
<span>ArgumentError</span>: <span>Expected</span> <span>Bool</span> <span>but</span> <span>was</span> <span>Int</span> <span>at</span> <span>line</span> <span>1</span><span>,</span> <span>column</span> <span>15</span>
<span>from</span> <span>crystalruby</span><span>.</span><span>rb</span><span>:303</span>:<span>in</span> `<span>block</span> <span>in</span> <span>compile!</span>&#39;</pre></div>

<p dir="auto">You can name your types, for more succinct method signatures.
The type names will be mirrored in the generated Crystal code.
E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
IntArrOrBoolArr = crtype{ Array(Bool) | Array(Int32) }

crystalize [a: IntArrOrBoolArr] =&gt; json{ IntArrOrBoolArr }
def method_with_named_types(a)
  return a
end"><pre><span>IntArrOrBoolArr</span> <span>=</span> <span>crtype</span><span>{</span> <span>Array</span><span>(</span><span>Bool</span><span>)</span> | <span>Array</span><span>(</span><span>Int32</span><span>)</span> <span>}</span>

<span>crystalize</span> <span>[</span><span>a</span>: <span>IntArrOrBoolArr</span><span>]</span> <span>=&gt;</span> <span>json</span><span>{</span> <span>IntArrOrBoolArr</span> <span>}</span>
<span>def</span> <span>method_with_named_types</span><span>(</span><span>a</span><span>)</span>
  <span>return</span> <span>a</span>
<span>end</span></pre></div>

<p dir="auto">Exceptions thrown in Crystal code can be caught in Ruby.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Installing shards and writing non-embedded Crystal code</h2><a id="user-content-installing-shards-and-writing-non-embedded-crystal-code" aria-label="Permalink: Installing shards and writing non-embedded Crystal code" href="#installing-shards-and-writing-non-embedded-crystal-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">You can use any Crystal shards and write ordinary, stand-alone Crystal code.</p>
<p dir="auto">The default entry point for the crystal shared library generated by the gem is
inside <code>./crystalruby/src/main.cr</code>. This file is not automatically overridden by the gem, and is safe for you to define and require new files relative to this location to write additional stand-alone Crystal code.</p>
<p dir="auto">You can define shards inside <code>./crystalruby/src/shard.yml</code>
Run the below to install new shards</p>
<div dir="auto" data-snippet-clipboard-copy-content="bundle exec crystalruby install"><pre>bundle <span>exec</span> crystalruby install</pre></div>
<p dir="auto">Remember to require these installed shards after installing them. E.g. inside <code>./crystalruby/src/main.cr</code></p>
<p dir="auto">You can edit the default paths for crystal source and library files from within the <code>./crystalruby.yaml</code> config file.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Wrapping Crystal code in Ruby</h2><a id="user-content-wrapping-crystal-code-in-ruby" aria-label="Permalink: Wrapping Crystal code in Ruby" href="#wrapping-crystal-code-in-ruby"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Sometimes you may want to wrap a Crystal method in Ruby, so that you can use Ruby before the Crystal code to prepare arguments, or after the Crystal code, to apply transformations to the result. A real-life example of this might be an ActionController method, where you might want to use Ruby to parse the request, perform auth etc., and then use Crystal to perform some heavy computation, before returning the result from Ruby.
To do this, you simply pass a block to the <code>crystalize</code> method, which will serve as the Ruby entry point to the function. From within this block, you can invoke <code>super</code> to call the Crystal method, and then apply any Ruby transformations to the result.</p>
<div dir="auto" data-snippet-clipboard-copy-content="module MyModule
  crystalize [a: :int32, b: :int32] =&gt; :int32 do |a, b|
    # In this example, we perform automated conversion to integers inside Ruby.
    # Then add 1 to the result of the Crystal method.
    result = super(a.to_i, b.to_i)
    result + 1
  end
  def add(a, b)
    a + b
  end
end

MyModule.add(&#34;1&#34;, &#34;2&#34;)"><pre><span>module</span> <span>MyModule</span>
  <span>crystalize</span> <span>[</span><span>a</span>: <span>:int32</span><span>,</span> <span>b</span>: <span>:int32</span><span>]</span> <span>=&gt;</span> <span>:int32</span> <span>do</span> |<span>a</span><span>,</span> <span>b</span>|
    <span># In this example, we perform automated conversion to integers inside Ruby.</span>
    <span># Then add 1 to the result of the Crystal method.</span>
    <span>result</span> <span>=</span> <span>super</span><span>(</span><span>a</span><span>.</span><span>to_i</span><span>,</span> <span>b</span><span>.</span><span>to_i</span><span>)</span>
    <span>result</span> + <span>1</span>
  <span>end</span>
  <span>def</span> <span>add</span><span>(</span><span>a</span><span>,</span> <span>b</span><span>)</span>
    <span>a</span> + <span>b</span>
  <span>end</span>
<span>end</span>

<span>MyModule</span><span>.</span><span>add</span><span>(</span><span>&#34;1&#34;</span><span>,</span> <span>&#34;2&#34;</span><span>)</span></pre></div>

<p dir="auto"><code>crystalruby</code> also allows you to write inline Crystal code that does not require binding to Ruby. This can be useful for e.g. performing setup or teardown operations.</p>
<p dir="auto">Follow these steps for a toy example of how we can use crystalized ruby and inline chunks to expose the <a href="https://github.com/stefanwille/crystal-redis">crystal-redis</a> library to Ruby.</p>
<ol dir="auto">
<li>Start our toy project</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="mkdir crystalredis
cd crystalredis
bundle init"><pre>mkdir crystalredis
<span>cd</span> crystalredis
bundle init</pre></div>
<ol start="2" dir="auto">
<li>Add dependencies to our Gemfile and run <code>bundle install</code></li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="# frozen_string_literal: true

source &#34;https://rubygems.org&#34;

gem &#39;crystalruby&#39;

# Let&#39;s see if performance is comparable to that of the redis gem.
gem &#39;benchmark-ips&#39;
gem &#39;redis&#39;"><pre><span># frozen_string_literal: true</span>

<span>source</span> <span>&#34;https://rubygems.org&#34;</span>

<span>gem</span> <span>&#39;crystalruby&#39;</span>

<span># Let&#39;s see if performance is comparable to that of the redis gem.</span>
<span>gem</span> <span>&#39;benchmark-ips&#39;</span>
<span>gem</span> <span>&#39;redis&#39;</span></pre></div>
<ol start="3" dir="auto">
<li>Write our Redis client</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="# Filename: crystalredis.rb
require &#39;crystalruby&#39;

module CrystalRedis

  crystal do
    CLIENT = Redis.new
    def self.client
      CLIENT
    end
  end

  crystalize [key: :string, value: :string] =&gt; :void
  def set(key, value)
    client.set(key, value)
  end

  crystalize [key: :string] =&gt; :string
  def get(key)
    client.get(key).to_s
  end
end"><pre><span># Filename: crystalredis.rb</span>
<span>require</span> <span>&#39;crystalruby&#39;</span>

<span>module</span> <span>CrystalRedis</span>

  <span>crystal</span> <span>do</span>
    <span>CLIENT</span> <span>=</span> <span>Redis</span><span>.</span><span>new</span>
    <span>def</span> <span>self</span><span>.</span><span>client</span>
      <span>CLIENT</span>
    <span>end</span>
  <span>end</span>

  <span>crystalize</span> <span>[</span><span>key</span>: <span>:string</span><span>,</span> <span>value</span>: <span>:string</span><span>]</span> <span>=&gt;</span> <span>:void</span>
  <span>def</span> <span>set</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>)</span>
    <span>client</span><span>.</span><span>set</span><span>(</span><span>key</span><span>,</span> <span>value</span><span>)</span>
  <span>end</span>

  <span>crystalize</span> <span>[</span><span>key</span>: <span>:string</span><span>]</span> <span>=&gt;</span> <span>:string</span>
  <span>def</span> <span>get</span><span>(</span><span>key</span><span>)</span>
    <span>client</span><span>.</span><span>get</span><span>(</span><span>key</span><span>)</span><span>.</span><span>to_s</span>
  <span>end</span>
<span>end</span></pre></div>
<ol start="4" dir="auto">
<li>Load the modules (without running them) to generate our Crystal project skeleton.</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="bundle exec ruby crystalredis.rb"><pre>bundle <span>exec</span> ruby crystalredis.rb</pre></div>
<ol start="5" dir="auto">
<li>Add the missing Redis dependency to our shard.yml</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="# filename:  crystalruby/src/shard.yml
dependencies:
  redis:
    github: stefanwille/crystal-redis"><pre><span><span>#</span> filename:  crystalruby/src/shard.yml</span>
<span>dependencies</span>:
  <span>redis</span>:
    <span>github</span>: <span>stefanwille/crystal-redis</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="# filename: main.cr
require &#34;redis&#34;
require &#34;./generated/index&#34;"><pre><span># filename: main.cr</span>
<span>require</span> <span>&#34;redis&#34;</span>
<span>require</span> <span>&#34;./generated/index&#34;</span></pre></div>
<div dir="auto" data-snippet-clipboard-copy-content="bundle exec crystalruby install"><pre>bundle <span>exec</span> crystalruby install</pre></div>
<ol start="6" dir="auto">
<li>Compile and benchmark our new module in Ruby</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="# Filename: benchmark.rb
# Let&#39;s compare the performance of our CrystalRedis module to the Ruby Redis gem
require_relative &#34;crystalredis&#34;
require &#39;redis&#39;
require &#39;benchmark/ips&#39;

Benchmark.ips do |x|
  rbredis = Redis.new

  x.report(:crredis) do
    CrystalRedis.set(&#34;hello&#34;, &#34;world&#34;)
    CrystalRedis.get(&#34;hello&#34;)
  end

  x.report(:rbredis) do
    rbredis.set(&#34;hello&#34;, &#34;world&#34;)
    rbredis.get(&#34;hello&#34;)
  end
end"><pre><span># Filename: benchmark.rb</span>
<span># Let&#39;s compare the performance of our CrystalRedis module to the Ruby Redis gem</span>
<span>require_relative</span> <span>&#34;crystalredis&#34;</span>
<span>require</span> <span>&#39;redis&#39;</span>
<span>require</span> <span>&#39;benchmark/ips&#39;</span>

<span>Benchmark</span><span>.</span><span>ips</span> <span>do</span> |<span>x</span>|
  <span>rbredis</span> <span>=</span> <span>Redis</span><span>.</span><span>new</span>

  <span>x</span><span>.</span><span>report</span><span>(</span><span>:crredis</span><span>)</span> <span>do</span>
    <span>CrystalRedis</span><span>.</span><span>set</span><span>(</span><span>&#34;hello&#34;</span><span>,</span> <span>&#34;world&#34;</span><span>)</span>
    <span>CrystalRedis</span><span>.</span><span>get</span><span>(</span><span>&#34;hello&#34;</span><span>)</span>
  <span>end</span>

  <span>x</span><span>.</span><span>report</span><span>(</span><span>:rbredis</span><span>)</span> <span>do</span>
    <span>rbredis</span><span>.</span><span>set</span><span>(</span><span>&#34;hello&#34;</span><span>,</span> <span>&#34;world&#34;</span><span>)</span>
    <span>rbredis</span><span>.</span><span>get</span><span>(</span><span>&#34;hello&#34;</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<ol start="7" dir="auto">
<li>Run the benchmark</li>
</ol>
<div dir="auto" data-snippet-clipboard-copy-content="$ bundle exec ruby benchmark.rb"><pre>$ bundle <span>exec</span> ruby benchmark.rb</pre></div>

<div dir="auto" data-snippet-clipboard-copy-content="
#crystalredis wins! (Warm up during first run will be slow for crredis, due to first compilation)

ruby 3.3.0 (2023-12-25 revision 5124f9ac75) [arm64-darwin22]
Warming up --------------------------------------
             crredis     1.946k i/100ms
             rbredis     1.749k i/100ms
Calculating -------------------------------------
             crredis     22.319k (± 1.7%) i/s -    112.868k in   5.058448s
             rbredis     16.861k (± 9.1%) i/s -     83.952k in   5.024941s"><pre><span><span>#</span>crystalredis wins! (Warm up during first run will be slow for crredis, due to first compilation)</span>

ruby 3.3.0 (2023-12-25 revision 5124f9ac75) [arm64-darwin22]
Warming up --------------------------------------
             crredis     1.946k i/100ms
             rbredis     1.749k i/100ms
Calculating -------------------------------------
             crredis     22.319k (± 1.7%) i/s -    112.868k <span>in</span>   5.058448s
             rbredis     16.861k (± 9.1%) i/s -     83.952k <span>in</span>   5.024941s</pre></div>

<p dir="auto">You can control whether CrystalRuby builds in debug or release mode by setting following config option</p>
<div dir="auto" data-snippet-clipboard-copy-content="CrystalRuby.configure do |config|
  config.debug = false
end"><pre><span>CrystalRuby</span><span>.</span><span>configure</span> <span>do</span> |<span>config</span>|
  <span>config</span><span>.</span><span>debug</span> <span>=</span> <span>false</span>
<span>end</span></pre></div>
<p dir="auto">By default, Crystal code is only JIT compiled. In production, you likely want to compile the Crystal code ahead of time. To do this, you can create a dedicated file which</p>
<ul dir="auto">
<li>Preloads all files Ruby code with embedded crystal</li>
<li>Forces compilation.</li>
</ul>
<p dir="auto">E.g.</p>
<div dir="auto" data-snippet-clipboard-copy-content="# E.g. crystalruby_build.rb
require &#34;crystalruby&#34;

CrystalRuby.configure do |config|
  config.debug = false
end

require_relative &#34;foo&#34;
require_relative &#34;bar&#34;

CrystalRuby.compile!"><pre><span># E.g. crystalruby_build.rb</span>
<span>require</span> <span>&#34;crystalruby&#34;</span>

<span>CrystalRuby</span><span>.</span><span>configure</span> <span>do</span> |<span>config</span>|
  <span>config</span><span>.</span><span>debug</span> <span>=</span> <span>false</span>
<span>end</span>

<span>require_relative</span> <span>&#34;foo&#34;</span>
<span>require_relative</span> <span>&#34;bar&#34;</span>

<span>CrystalRuby</span><span>.</span><span>compile!</span></pre></div>
<p dir="auto">Then you can run this file as part of your build step, to ensure all Crystal code is compiled ahead of time.</p>

<p dir="auto">The logic to detect when to JIT recompile is not robust and can end up in an inconsistent state. To remedy this it is useful to clear out all generated assets and build from scratch.</p>
<p dir="auto">To do this execute:</p>
<div dir="auto" data-snippet-clipboard-copy-content="bundle exec crystalruby clean"><pre>bundle <span>exec</span> crystalruby clean</pre></div>

<p dir="auto"><code>crystalruby</code>&#39;s primary purpose is to provide ergonomic access to Crystal from Ruby, over FFI.
For simple usage, advanced knowledge of Crystal should not be required.</p>
<p dir="auto">However, the abstraction it provides should remain simple, transparent, and easy to hack on and it should not preclude users from supplementing its capabilities with a more direct integration using ffi primtives.</p>
<p dir="auto">It should support escape hatches to allow it to coexist with code that performs a more direct <a href="https://github.com/ffi/ffi">FFI</a> integration to implement advanced functionality not supported by <code>crystalruby</code>.</p>
<p dir="auto">The library is currently in its infancy. Planned additions are:</p>
<ul dir="auto">
<li>Simple mixin/concern that utilises <code>FFI::Struct</code> for bi-directional passing of Ruby objects and Crystal objects (by value).</li>
<li>Install command to generate a sample build script, and supports build command (which simply verifies then invokes this script)</li>
<li>Call Ruby from Crystal using FFI callbacks (implement <code>.expose_to_crystal</code>)</li>
<li>Support long-lived synchronized objects (through use of synchronized memory arena to prevent GC).</li>
<li>Support for passing <code>crystalruby</code> types by reference (need to contend with GC).</li>
<li>Explore mechanisms to safely expose true parallelism using <a href="https://github.com/ffi/ffi/wiki/Ractors">FFI over Ractors</a></li>
</ul>

<p dir="auto">To get started, add this line to your application&#39;s Gemfile:</p>

<p dir="auto">And then execute:</p>

<p dir="auto">Or install it yourself as:</p>
<div dir="auto" data-snippet-clipboard-copy-content="$ gem install crystalruby"><pre>$ gem install crystalruby</pre></div>
<p dir="auto"><code>crystalruby</code> requires some basic initialization options inside a crystalruby.yaml file in the root of your project.
You can run <code>crystalruby init</code> to generate a configuration file with sane defaults.</p>

<div dir="auto" data-snippet-clipboard-copy-content="crystal_src_dir: &#34;./crystalruby/src&#34;
crystal_lib_dir: &#34;./crystalruby/lib&#34;
crystal_main_file: &#34;main.cr&#34;
crystal_lib_name: &#34;crlib&#34;"><pre><span>crystal_src_dir</span>: <span><span>&#34;</span>./crystalruby/src<span>&#34;</span></span>
<span>crystal_lib_dir</span>: <span><span>&#34;</span>./crystalruby/lib<span>&#34;</span></span>
<span>crystal_main_file</span>: <span><span>&#34;</span>main.cr<span>&#34;</span></span>
<span>crystal_lib_name</span>: <span><span>&#34;</span>crlib<span>&#34;</span></span></pre></div>

<p dir="auto">After checking out the repo, run <code>bin/setup</code> to install dependencies. Then, run <code>rake test</code> to run the tests. You can also run <code>bin/console</code> for an interactive prompt that will allow you to experiment.</p>
<p dir="auto">To install this gem onto your local machine, run <code>bundle exec rake install</code>. To release a new version, update the version number in <code>version.rb</code>, and then run <code>bundle exec rake release</code>, which will create a git tag for the version, push git commits and the created tag, and push the <code>.gem</code> file to <a href="https://rubygems.org" rel="nofollow">rubygems.org</a>.</p>

<p dir="auto">Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/wouterken/crystalruby">https://github.com/wouterken/crystalruby</a>. This project is intended to be a safe, welcoming space for collaboration, and contributors are expected to adhere to the <a href="https://github.com/wouterken/crystalruby/blob/master/CODE_OF_CONDUCT.md">code of conduct</a>.</p>

<p dir="auto">The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT" rel="nofollow">MIT License</a>.</p>

<p dir="auto">Everyone interacting in the <code>crystalruby</code> project&#39;s codebases, issue trackers, chat rooms and mailing lists is expected to follow the <a href="https://github.com/wouterken/crystalruby/blob/master/CODE_OF_CONDUCT.md">code of conduct</a>.</p>
</article></div></div>
  </body>
</html>
