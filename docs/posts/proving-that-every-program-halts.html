<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/proving-that-every-program-halts/?utm_source=atom&amp;utm_medium=feed">Original</a>
    <h1>Proving that every program halts</h1>
    
    <div id="readability-page-1" class="page"><div><p>One of the best known hard problems in computer science is the halting problem.
In fact, it&#39;s widely thought that you cannot write a program that will, for any arbitrary program as input, tell you correctly whether or not it will terminate.
This is written from the framing of computers, though: can we do better with a human in the loop?</p>
<p>It turns out, we can.
And we can use a method that&#39;s generalizable, which many people can follow for many problems.
Not everyone can use the method, which you&#39;ll see why in a bit.
But lots of people can apply this proof technique.
Let&#39;s get started.</p>
<p>* * *</p>
<p>We&#39;ll start by formalizing what we&#39;re talking about, just a little bit.
I&#39;m not going to give the full formal proofâ€”that will be reserved for when this is submitted to <a href="https://sigbovik.org">a prestigious conference</a> next year.</p>
<p>We will call the set of all programs <code>P</code>.
We want to answer, for any <code>p</code> in <code>P</code>, whether or not <code>p</code> will eventually halt.
We will call this <code>h(p)</code> and <code>h(p) = true</code> if <code>p</code> eventually finished and <code>false</code> otherwise.</p>
<p>Actually, scratch that.
Let&#39;s simplify it and just say that yes, every program does halt eventually, so <code>h(p) = true</code> for all <code>p</code>.
That makes our lives easier.</p>
<p>Now we need to get from our starting assumptions, the world of logic we live in, to the truth of our statement.
We&#39;ll call our goal, that <code>h(p) = true</code> for all <code>p</code>, the statement <code>H</code>.
Now let&#39;s start with some facts.</p>
<p><em>Fact one:</em> I think it&#39;s always an appropriate time to play the saxophone. *honk*!</p>
<p><em>Fact two:</em> My wife thinks that it&#39;s sometimes inappropriate to play the saxophone, such as when it&#39;s &#34;time for bed&#34; or &#34;I was in the middle of a <em>sentence!</em></p>
<p>We&#39;ll give the statement &#34;It&#39;s always an appropriate time to play the saxophone&#34; the name <code>A</code>.
We know that I believe <code>A</code> is true.
And my wife believes that <code>A</code> is false.
So now we run into the snag:</p>
<p><em>Fact three:</em> The wife is always right.</p>
<p>This is a truism in American culture, useful for settling debates.
It&#39;s also useful here for solving major problems in computer science because, babe, we&#39;re both the wife.
We&#39;re both right!</p>
<p>So now that we&#39;re both right, we know that <code>A</code> and <code>!A</code> are both true.
And we&#39;re in luck, we can apply a whole lot of fancy classical logic here.
Since <code>A and !A</code> we know that <code>A</code> is true and we also know that <code>!A</code> is true.
From <code>A</code> being true, we can conclude that <code>A or H</code> is true.
And then we can apply disjunctive syllogism which says that if <code>A or H</code> is true and <code>!A</code> is true, then <code>H</code> must be true.
This makes sense, because if you&#39;ve excluded one possibility then the other must be true.
And we do have <code>!A</code>, so that means: <code>H</code> is true!</p>
<p>There we have it.
We&#39;ve proved our proposition, <code>H</code>, which says that for any program <code>p</code>, <code>p</code> will eventually halt.
The previous logic is, mostly, sound.
It uses the <a href="https://en.wikipedia.org/wiki/Principle_of_explosion">principle of explosion</a>, though I prefer to call it &#34;proof by married lesbian.&#34;</p>
<p>* * *</p>
<p>Of course, we know that this is wrong.
It falls apart with our assumptions.
We built the system on contradictory assumptions to begin with, and this is something we avoid in logic.
If we allow contradictions, then we can prove truly anything.
I could have also proved (by married lesbian) that <em>no</em> program will terminate.</p>
<p>This has been a silly traipse through logic.
If you want a <em>good</em> journey through logic, I&#39;d recommend Hillel Wayne&#39;s <a href="https://leanpub.com/logic">Logic for Programmers</a>.
I&#39;m sure that, after reading it, you&#39;ll find absolutely <em>no</em> flaws in my logic here.</p>
<p>After all, I&#39;m the wife, so I&#39;m always right.</p>
<hr/>
</div><p>
  If you&#39;re looking to grow more effective as a software engineer, please consider my <a href="https://ntietz.com/coaching/">coaching services</a>.
  </p></div>
  </body>
</html>
