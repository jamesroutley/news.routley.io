<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hezmatt.org/~mpalmer/blog/2023/11/07/postgresql-encryption-options.html">Original</a>
    <h1>PostgreSQL Encryption: The Available Options</h1>
    
    <div id="readability-page-1" class="page"><div id="body">
			
			<div id="content">

				
				<p>
					Posted: Tue,  7 November 2023
					| <a href="https://www.hezmatt.org/~mpalmer/blog/2023/11/07/postgresql-encryption-options.html">permalink</a>
					| <a href="https://www.hezmatt.org/~mpalmer/blog/2023/11/07/postgresql-encryption-options.html#comments">
						
							No comments
						
					</a>
				</p>
<p>On <a href="https://postgres.fm/episodes/anniversary-mailbag">an episode</a> of <a href="https://postgres.fm">Postgres FM</a>, the hosts had a (very brief) discussion of data encryption in PostgreSQL.
While Postgres FM is a podcast well worth a subscribe, the hosts aren’t data security experts, and so as someone who builds <a href="https://enquo.org">a queryable database encryption system</a>, I found the coverage to be somewhat… lacking.
I figured I’d provide a more complete survey of the available options for PostgreSQL-related data encryption.</p>



<p>By default, when you install PostgreSQL, there is no data encryption at all.
That means that anyone who gets access to any part of the system can read all the data they have access to.</p>

<p>This is, of course, not peculiar to PostgreSQL: basically everything works much the same way.</p>

<p>What’s stopping an attacker from nicking off with all your data is the fact that they can’t access the database at all.
The things that are acting as protection are “perimeter” defences, like putting the physical equipment running the server in a secure datacenter, firewalls to prevent internet randos connecting to the database, and strong passwords.</p>

<p>This is referred to as “tortoise” security – it’s tough on the outside, but soft on the inside.
Once that outer shell is cracked, the delicious, delicious data is ripe for the picking, and there’s absolutely nothing to stop a miscreant from going to town and making off with everything.</p>

<p>It’s a good idea to plan your defenses on the <a href="https://www.forbes.com/sites/forbestechcouncil/2022/04/13/why-every-cybersecurity-leader-should-assume-breach/">assumption you’re going to get breached</a> sooner or later.
Having good defence-in-depth includes denying the attacker to your data even if they compromise the database.
This is where encryption comes in.</p>



<p>To protect against the compromise of the storage that your database uses (physical disks, EBS volumes, and the like), it’s common to employ encryption-at-rest, such as <a href="https://en.wikipedia.org/wiki/Disk_encryption">full-disk encryption</a>, or volume encryption.
These mechanisms protect against “offline” attacks, but provide no protection while the system is actually running.
And therein lies the rub: your database is <em>always</em> running, so encryption at rest typically doesn’t provide much value.</p>

<p>If you’re running physical systems, disk encryption is essential, but more to prevent accidental data loss, due to things like failing to wipe drives before disposing of them, rather than physical theft.
In systems where volume encryption is only a tickbox away, it’s also worth enabling, if only to prevent inane questions from your security auditors.
Relying solely on storage-layer defences, though, is very unlikely to provide any appreciable value in preventing data loss.</p>



<p>If you’ve used proprietary database systems in high-security environments, you might have come across Transparent Database Encryption (TDE).
There are also a couple of proprietary extensions for PostgreSQL that provide this functionality.</p>

<p>TDE is essentially encryption-at-rest implemented inside the database server.
As such, it has much the same drawbacks as disk encryption: few real-world attacks are thwarted by it.
There is a <em>very</em> small amount of additional protection, in that “physical” level backups (as produced by <code>pg_basebackup</code>) are protected, but the vast majority of attacks aren’t stopped by TDE.
Any attacker who can access the database while it’s running can just ask for an SQL-level dump of the stored data, and they’ll get the unencrypted data quick as you like.</p>



<p>If you want to take the database out of the threat landscape, you really need to encrypt sensitive data before it even gets near the database.
This is the realm of field encryption, more commonly known as application-level encryption.</p>

<p>This technique involves encrypting each field of data before it is sent to be stored in the database, and then decrypting it again after it’s retrieved from the database.
Anyone who gets the data from the database directly, whether via a backup or a direct connection, is out of luck: they can’t decrypt the data, and therefore it’s worthless.</p>

<p>There are, of course, some limitations of this technique.</p>

<p>For starters, every ORM and data mapper out there has rolled their own encryption format, meaning that there’s basically zero interoperability.
This isn’t a problem if you build everything that accesses the database using a single framework, but if you ever feel the need to migrate, or use the database from multiple codebases, you’re likely in for a rough time.</p>

<p>The other big problem of traditional application-level encryption is that, when the database can’t understand what data its storing, it can’t run queries against that data.
So if you want to encrypt, say, your users’ dates of birth, but you also need to be able to query on that field, you need to choose between one or the other: you can’t have both at the same time.</p>

<p>You may think to yourself, “but this isn’t any good, an attacker that breaks into my application can still steal all my data!”.
That is true, but security is never binary.
The name of the game is reducing the attack surface, making it <em>harder</em> for an attacker to succeed.
If you leave all the data unencrypted in the database, an attacker can steal all your data by breaking into the database <em>or</em> by breaking into the application.
Encrypting the data reduces the attacker’s options, and allows you to focus your resources on hardening the application against attack, safe in the knowledge that an attacker who gets into the database directly isn’t going to get anything valuable.</p>

<h2 id="sidenote-the-curious-case-of-pgcrypto">Sidenote: The Curious Case of <code>pg_crypto</code></h2>

<p>PostgreSQL ships a “contrib” module called <code>pg_crypto</code>, which provides encryption and decryption functions.
This sounds ideal to use for encrypting data within our applications, as it’s available no matter what we’re using to write our application.
It avoids the problem of framework-specific cryptography, because you call the same PostgreSQL functions no matter what language you’re using, which produces the same output.</p>

<p>However, I don’t recommend <em>ever</em> using <code>pg_crypto</code>’s data encryption functions, and I doubt you will find many other cryptographic engineers who will, either.</p>

<p>First up, and most horrifyingly, it requires you to pass the long-term keys to the database server.
If there’s an attacker actively in the database server, they can capture the keys as they come in, which means all the data encrypted using that key is exposed.
Sending the keys can also result in the keys ending up in query logs, both on the client and server, which is obviously a terrible result.</p>

<p>Less scary, but still very concerning, is that <code>pg_crypto</code>’s available cryptography is, to put it mildly, antiquated.
We have a lot of newer, safer, and faster techniques for data encryption, that aren’t available in <code>pg_crypto</code>.
This means that if you do use it, you’re leaving a lot on the table, and need to have skilled cryptographic engineers on hand to avoid the potential pitfalls.</p>

<p>In short: friends don’t let friends use <code>pg_crypto</code>.</p>



<p>All this brings us to the project I run: <a href="https://enquo.org">Enquo</a>.
It takes application-layer encryption to a new level, by providing a language- and framework-agnostic cryptosystem that <em>also</em> enables encrypted data to be efficiently queried by the database.</p>

<p>So, you can encrypt your users’ dates of birth, in such a way that anyone with the appropriate keys can query the database to return, say, all users over the age of 18, but an attacker just sees unintelligible gibberish.
This should greatly increase the amount of data that can be encrypted, and as the Enquo project expands its available data types and supported languages, the coverage of encrypted data will grow and grow.
My eventual goal is to encrypt all data, all the time.</p>

<p>If this appeals to you, visit <a href="https://enquo.org">enquo.org</a> to use or contribute to the open source project, or <a href="https://enquodb.com">EnquoDB.com</a> for commercial support and hosted database options.</p>


<hr/>
			
			

			</div>
		</div></div>
  </body>
</html>
