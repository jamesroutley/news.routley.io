<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jhm.dev/posts/papers-please/">Original</a>
    <h1>Fixing Stutters in Papers Please on Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        <h4>Tue Dec 28, 2021</h4>
        <p>Since I switched to Linux some time ago, I had my fair share of problems with running games on Linux. To be fair, most of these were not designed to run on linux, but the awesome Proton and its main project wine make it easy to run most games I am interested in seamlessly. Most of the time, games refuse to start, but some workaround exists to make it run.</p>
<p>When I wanted to play some Papers Please I was delighted to see that a native port exists, which <em>should</em> make it easy to run it. Installing and starting the game from GOG was easy enough, but starting in the main menu, something was off. After starting a game it was clear that the animations were pausing every few seconds for around a second, which made it almost unplayable.</p>
<p>Looking at <a href="https://www.protondb.com/app/239030">ProtonDB</a>, people are complaining about stutters. Some are reporting that the 64-bit version stutters, whereas the 32-bit version works. Unlucky for me, GOG only has a download for 64-bit on Linux. One comment says there is “a half a second freeze every few seconds”, which seems similar to my experience.</p>
<p>There has to be an answer why the client stutters, the developers must have tested this configuration! As a side note, I am wondering if the 64-bit version worked at some point, but without a good starting point it is hard to test. So let’s investigate where the pauses are coming from. Linux features a whole suite of tools to debug many different aspects from performance to correctness. And here I am assuming that the stutters are not inherent in the game logic, because the 32-bit version works correctly.</p>
<h3 id="what-is-going-on">What is going on?</h3>
<p>The first tool I am using is <code>strace</code>. In its default configuration it runs a program and records all system calls, which a program makes, and reports them on the console. Without any flags <em>every</em> call is reported which can be overwhelming, but without a hint where to look, I have to record everything.</p>
<p>After some digging through useful options, I discover the <code>-T</code> and <code>-t</code> flags which record the time spent in the syscall and the timestamp when calling. So I record some data using <code>strace -T -t ./PapersPlease &gt; log.txt</code> and sift through the mess:</p>
<pre tabindex="0"><code>...
13:08:06.067929 pselect6(9, [8], NULL, NULL, {tv_sec=0, tv_nsec=0}, NULL) = 0 (Timeout) &lt;0.000005&gt;
13:08:06.067946 recvmsg(8, {msg_namelen=0}, 0) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000004&gt;
13:08:06.067962 pselect6(9, [8], NULL, NULL, {tv_sec=0, tv_nsec=0}, NULL) = 0 (Timeout) &lt;0.000005&gt;
13:08:06.068033 getpid()                = 2541133 &lt;0.000005&gt;
13:08:06.068048 getpid()                = 2541133 &lt;0.000004&gt;
13:08:06.068062 getpid()                = 2541133 &lt;0.000004&gt;
13:08:06.068077 getpid()                = 2541133 &lt;0.000004&gt;
13:08:06.068091 getpid()                = 2541133 &lt;0.000004&gt;
13:08:06.068105 getpid()                = 2541133 &lt;0.000004&gt;
13:08:06.068119 poll([{fd=8, events=0}], 1, 0) = 0 (Timeout) &lt;0.000005&gt;
13:08:06.068138 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.019100&gt;
-------------------------------------------------------------------------------
13:08:06.087261 ioctl(19, _IOC(_IOC_READ|_IOC_WRITE, 0x46, 0x52, 0x10), 0x7ffce133ef70) = 0 &lt;0.000008&gt;
13:08:06.087288 sched_yield()           = 0 &lt;0.000005&gt;
13:08:06.087306 sched_yield()           = 0 &lt;0.000005&gt;
13:08:06.087325 sched_yield()           = 0 &lt;0.000004&gt;
13:08:06.087340 sched_yield()           = 0 &lt;0.000004&gt;
13:08:06.087357 recvmsg(8, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base=&#34;\6\0\324\0015\304j\10\352\1\0\0\v\0\300\3\0\0\0\0\36\6)\3X\3t\1\20\0\1\0&#34;..., iov_len=4096}], msg_i&gt;
13:08:06.087391 recvmsg(8, {msg_namelen=0}, 0) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000005&gt;
13:08:06.087410 recvmsg(8, {msg_namelen=0}, 0) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000006&gt;
13:08:06.087433 recvmsg(8, {msg_namelen=0}, 0) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000005&gt;
13:08:06.087454 recvmsg(8, {msg_namelen=0}, 0) = -1 EAGAIN (Resource temporarily unavailable) &lt;0.000005&gt;
...
</code></pre><p><code>strace</code> records a lot of information like the parameters passed into the syscalls, as well as the return value. For some parameters, like flags, <code>strace</code> knows their meaning. We can also see that the game calls at least <em>some</em> syscall every few milliseconds. I have highlighted the longest gap between syscalls, which originates from the previous syscall taking 19 milliseconds to complete. The first parameter to poll contains a file descriptor, which we can resolve to a path using <code>lsof -p &lt;pid&gt;</code>. In this case it resolves to <code>/dev/nvidia0</code>, so some communication with my graphics card. The delay of 19 ms is close to the infamous 16.67 ms which game developers can use to draw a single frame to still achieve 60 fps. This might be related to a v-sync and allows us to filter normal operation.</p>
<p>Using this knowledge, we can filter for polling on file descriptor 19 using <code>grep &#34;fd=19&#34; log.txt</code>:</p>
<pre tabindex="0"><code>...
13:08:05.987848 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.018904&gt;
13:08:06.007749 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.019502&gt;
13:08:06.028516 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.018306&gt;
13:08:06.048071 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.018689&gt;
13:08:06.068138 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.019100&gt;
13:08:06.088641 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.018155&gt;
13:08:06.108200 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.018565&gt;
-------------------------------------------------------------------------------
13:08:07.519463 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.000005&gt;
13:08:07.522046 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.004434&gt;
13:08:07.539017 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.008308&gt;
13:08:07.554338 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.012495&gt;
13:08:07.570526 poll([{fd=19, events=POLLIN|POLLPRI}], 1, 1000) = 1 ([{fd=19, revents=POLLIN|POLLPRI}]) &lt;0.016243&gt;
...
</code></pre><p>Most of the time, the poll is called around every 19-20 ms, but this is interrupted by a 1.4 s pause. The following poll returns in effectively zero time, because the v-sync is late and no pause is needed to achieve a consistent frame rate. The length of 1.4 s is also very noticeable for a player and consistent with the comment on ProtonDB about the half second stuttering. The difference between 0.5 s and 1.4 s might be human perception or the problem might be worse on my system, either way we have a clue.</p>
<p>During the long pause a few syscalls stand out, because I have not seen them elsewhere:</p>
<pre tabindex="0"><code>13:08:06.127285 openat(AT_FDCWD, &#34;/dev/input&#34;, O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 29 &lt;0.000010&gt;
13:08:06.127311 newfstatat(29, &#34;&#34;, {st_mode=S_IFDIR|0755, st_size=720, ...}, AT_EMPTY_PATH) = 0 &lt;0.000005&gt;
13:08:06.127340 getdents64(29, 0x55fb3ef36880 /* 36 entries */, 32768) = 1128 &lt;0.000014&gt;
13:08:06.127369 stat(&#34;/dev/input/event10&#34;, {st_mode=S_IFCHR|0660, st_rdev=makedev(0xd, 0x4a), ...}) = 0 &lt;0.000005&gt;
13:08:06.127388 openat(AT_FDCWD, &#34;/dev/input/event10&#34;, O_RDONLY) = 32 &lt;0.000007&gt;
13:08:06.127406 ioctl(32, EVIOCGBIT(0, 8), [EV_SYN EV_KEY EV_MSC]) = 8 &lt;0.000006&gt;
13:08:06.127430 ioctl(32, EVIOCGBIT(EV_KEY, 96), [KEY_POWER KEY_SLEEP KEY_WAKEUP]) = 96 &lt;0.000004&gt;
13:08:06.127447 ioctl(32, EVIOCGBIT(EV_ABS, 8), []) = 8 &lt;0.000005&gt;
13:08:06.127463 close(32)               = 0 &lt;0.039483&gt;
13:08:06.173139 stat(&#34;/dev/input/event9&#34;, {st_mode=S_IFCHR|0660, st_rdev=makedev(0xd, 0x49), ...}) = 0 &lt;0.000008&gt;
13:08:06.173177 openat(AT_FDCWD, &#34;/dev/input/event9&#34;, O_RDONLY) = 32 &lt;0.000009&gt;
13:08:06.173200 ioctl(32, EVIOCGBIT(0, 8), [EV_SYN EV_KEY EV_REL EV_ABS ...]) = 8 &lt;0.000005&gt;
13:08:06.173219 ioctl(32, EVIOCGBIT(EV_KEY, 96), [KEY_ESC KEY_ENTER KEY_KPMINUS KEY_KPPLUS ...]) = 96 &lt;0.000005&gt;
13:08:06.173239 ioctl(32, EVIOCGBIT(EV_ABS, 8), [ABS_VOLUME]) = 8 &lt;0.000005&gt;
13:08:06.173256 close(32)               = 0 &lt;0.023215&gt;
...
13:08:07.465881 stat(&#34;/dev/input/event0&#34;, {st_mode=S_IFCHR|0660, st_rdev=makedev(0xd, 0x40), ...}) = 0 &lt;0.000008&gt;
13:08:07.465904 openat(AT_FDCWD, &#34;/dev/input/event0&#34;, O_RDONLY) = 32 &lt;0.000009&gt;
13:08:07.465926 ioctl(32, EVIOCGBIT(0, 8), [EV_SYN EV_KEY]) = 8 &lt;0.000005&gt;
13:08:07.465943 ioctl(32, EVIOCGBIT(EV_KEY, 96), [KEY_POWER]) = 96 &lt;0.000004&gt;
13:08:07.465958 ioctl(32, EVIOCGBIT(EV_ABS, 8), []) = 8 &lt;0.000004&gt;
13:08:07.465974 close(32)               = 0 &lt;0.017162&gt;
13:08:07.483156 getdents64(29, 0x55fb3ef36880 /* 0 entries */, 32768) = 0 &lt;0.000007&gt;
13:08:07.483179 close(29)               = 0 &lt;0.000006&gt;
</code></pre><p>The snippet starts with opening <code>/dev/input</code>, which is a folder containing input devices, with the resulting file descriptor 29. Using <code>getdents</code> the program iterates over the directory entries, which are subsequently opened, checked for some flags and closed. Finally, file descriptor 29 is closed. Overall, this operation takes around 1.4 s, it seems we found, where the pause originates. The main delay is caused by the close operations, which takes up to 100 ms (not included in the snippet). This result is unexpected, as a simple operation like close should be much faster. If we look at the last line of the snippet, we can even see an example, closing file descriptor 29 only takes 6 µs. That is more than a factor of 100.000 faster! Something fishy is going on here.</p>
<p>We can further understand what is going on, when we know the calling stack trace, which results in the slow close operation. Luckily, <code>strace</code> is loaded with many useful features like <code>-k</code> which does exactly what we need, it records the calling trace. We only need the stack traces for <code>close</code> calls, which we can filter using <code>-e trace=close</code>. This results in a trace like this:</p>
<pre tabindex="0"><code>13:08:07.465974 close(32)               = 0 &lt;0.017162&gt;
 &gt; /usr/lib/libpthread-2.33.so(__close+0x3b) [0x1282b]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(MaybeAddDevice+0x127) [0x4a6d07]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(LINUX_JoystickDetect+0x1db) [0x4a70eb]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(LINUX_JoystickInit+0x91) [0x4a7191]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(SDL_JoystickInit+0x3f) [0x47d8ff]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(SDL_InitSubSystem_REAL+0x1c5) [0x471c15]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(lime::SDLApplication::SDLApplication()+0xa1) [0xea6a1]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(lime::CreateApplication()+0x1b) [0xeb23b]
 &gt; ~/Games/gog/papers-please/game/lime.ndll(lime::lime_application_create()+0x9) [0xb9929]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(lime::_internal::backend::native::NativeApplication_obj::__construct(hx::ObjectPtr&lt;lime::app::Application_obj&gt;)+0x48b) [&gt;
 &gt; ~/Games/gog/papers-please/game/PapersPlease(lime::_internal::backend::native::NativeApplication_obj::__alloc(hx::ImmixAllocator*, hx::ObjectPtr&lt;lime::app::Applicati&gt;
 &gt; ~/Games/gog/papers-please/game/PapersPlease(lime::app::Application_obj::__construct()+0xf6) [0xdfc206]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(openfl::display::Application_obj::__construct()+0x3b) [0x5d8a9b]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(openfl::display::Application_obj::__alloc(hx::ImmixAllocator*)+0x41) [0x5d8da1]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(ApplicationMain_obj::create(Dynamic)+0x6d) [0xdf3a4d]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(ApplicationMain_obj::main()+0x66) [0x2b8936]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(main+0x51) [0x2be641]
 &gt; /usr/lib/libc-2.33.so(__libc_start_main+0xd5) [0x27b25]
 &gt; ~/Games/gog/papers-please/game/PapersPlease(_start+0x2a) [0x2bf48a]
</code></pre><p>The PapersPlease binary contains symbols, which is helping a lot. The function calling close is <code>MaybeAddDevice</code> which is called from a function with a <code>SDL_</code> prefix. Searching through GitHub, I can find the following code for <a href="https://github.com/libsdl-org/SDL/blob/40d808620d18037b8ffbf9b708f40fcffb248312/src/joystick/linux/SDL_sysjoystick.c#L305">MaybeAddDevice</a>. The code opens some path, checks if it is a joystick, and closes it again. It does this for every input device on my computer. Somehow, there are 30 input devices in my <code>/dev/input</code> which might make the effect more prolonged on my computer.</p>
<p>At this point, we have an idea what is going on: PapersPlease uses SDL on Linux, which checks every few seconds if a joystick has been connected. To do this, every input device is checked. Normally, this operation should be almost instantaneous, but takes between 20-100 ms. On computers with a lot of input devices this can easily take more than a second, which results in a noticable stutter, because the operation takes place on the main gameloop.</p>
<h3 id="why-is-close-slow">Why is <code>close</code> slow?</h3>
<p>Time to bring out the big guns, <a href="https://github.com/iovisor/bcc">bcc</a>. This toolkit can be used to instrument processes and calls at various stages. While writing tools with this toolkit is not too hard, it also comes bundled with a few handy tools. One of these is funcslower, which takes a symbol from a process or a kernel symbol and measures how long each invocation takes. If it takes longer than a threshold, it is logged. With <code>/usr/share/bcc/tools/funcslower /usr/lib/libpthread-2.33.so:close -p &lt;pid&gt;</code> we can filter <code>close</code> calls which take longer than 1 ms.</p>
<pre tabindex="0"><code>Tracing function calls slower than 1 ms... Ctrl+C to quit.
TIME       COMM           PID    LAT(ms)             RVAL FUNC
0.000000   PapersPlease   539544   43.49                0 /usr/lib/libpthread-2.33.so:close
0.043507   PapersPlease   539544   32.42                0 /usr/lib/libpthread-2.33.so:close
0.075961   PapersPlease   539544   20.86                0 /usr/lib/libpthread-2.33.so:close
...
1.163494   PapersPlease   539544   21.81                0 /usr/lib/libpthread-2.33.so:close
1.185336   PapersPlease   539544   31.48                0 /usr/lib/libpthread-2.33.so:close
1.216830   PapersPlease   539544   21.78                0 /usr/lib/libpthread-2.33.so:close
3.000077   PapersPlease   539544   23.92                0 /usr/lib/libpthread-2.33.so:close
3.024016   PapersPlease   539544   32.80                0 /usr/lib/libpthread-2.33.so:close
3.056834   PapersPlease   539544   39.98                0 /usr/lib/libpthread-2.33.so:close
...
4.261013   PapersPlease   539544   35.80                0 /usr/lib/libpthread-2.33.so:close
4.296830   PapersPlease   539544   26.65                0 /usr/lib/libpthread-2.33.so:close
4.323498   PapersPlease   539544   26.65                0 /usr/lib/libpthread-2.33.so:close
6.000148   PapersPlease   539544   43.33                0 /usr/lib/libpthread-2.33.so:close
6.043497   PapersPlease   539544   39.99                0 /usr/lib/libpthread-2.33.so:close
6.083495   PapersPlease   539544   26.66                0 /usr/lib/libpthread-2.33.so:close
...
7.265320   PapersPlease   539544   31.49                0 /usr/lib/libpthread-2.33.so:close
7.296819   PapersPlease   539544   26.66                0 /usr/lib/libpthread-2.33.so:close
7.323483   PapersPlease   539544   26.66                0 /usr/lib/libpthread-2.33.so:close
</code></pre><p>This recreates the results from our earlier analysis, that every few seconds, <code>close</code> calls are slow. We can even see that the stuttering starts every three seconds and on my machine takes 1.2 - 1.4 s. But where is this latency coming from? In principle, the close function should just invoke the syscall and then return, so it should not introduce latency itself, at least not measurable in milliseconds. The syscall is handled in the kernel in the <code>_sys_close</code> function, which on my machine has the prefix <code>__x64</code>. So we start funcslower again with <code>/usr/share/bcc/tools/funcslower __x64_sys_close -p &lt;pid&gt; -t</code> and we get, …, nothing. Either we used the wrong function or the function completes quicker than 1 ms. With the <code>-u 1</code> flag, we can filter invocations which take longer than 1 µs. And with this setup we do get results:</p>
<pre tabindex="0"><code>TIME       COMM           PID    LAT(us)             RVAL FUNC
0.000000   PapersPlease   539544    1.00                0 __x64_sys_close
2.240417   PapersPlease   539544    1.55                0 __x64_sys_close
2.269315   PapersPlease   539544    1.33                0 __x64_sys_close
2.311854   PapersPlease   539544    1.03                0 __x64_sys_close
2.535184   PapersPlease   539544    1.31                0 __x64_sys_close
2.591848   PapersPlease   539544    1.11                0 __x64_sys_close
2.725182   PapersPlease   539544    1.14                0 __x64_sys_close
3.018515   PapersPlease   539544    1.00                0 __x64_sys_close
3.151844   PapersPlease   539544    1.04                0 __x64_sys_close
3.205187   PapersPlease   539544    1.55                0 __x64_sys_close
3.259313   PapersPlease   539544    1.08                0 __x64_sys_close
3.485194   PapersPlease   539544    1.49                0 __x64_sys_close
5.240487   PapersPlease   539544    1.54                0 __x64_sys_close
5.274988   PapersPlease   539544    1.14                0 __x64_sys_close
</code></pre><p>We can still see a repetition after three seconds, the time between the second and the second to last call. But 11 of the 30 calls to close are recorded and the latency is very close to 1 µs, most likely, the missing calls were slighly faster than 1 µs. Still, the kernel is fast enough to not matter for our 50 ms delay.</p>
<p>In theory, if the kernel does not add latency, the measured delay has to come from the <code>libpthread</code> close function. We can use gdb to disassemble a specific function, <code>gdb -batch -ex &#34;file /usr/lib/libpthread-2.33.so&#34; -ex &#34;disas close&#34;</code>. The resulting disassembly is shown below. The three main points are the two calls to some pthread functions as well as the syscall instruction, which is effectively a call into the kernel. The remaining instructions are negligible from a latency perspective. Ideally, we would use a profiling tool like perf to locate where the latency originates, but I do not know how to use perf for analyzing a single function. perf records samples of the stack every few ticks, but at this time, the process may be doing something else and the moment where the <code>MaybeAddDevice</code> function is running might not be recorded.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre tabindex="0"><code>Dump of assembler code for function close:
   ...
   0x0000000000012810 &lt;+32&gt;:	sub    $0x18,%rsp
   0x0000000000012814 &lt;+36&gt;:	mov    %edi,0xc(%rsp)
   0x0000000000012818 &lt;+40&gt;:	call   0x12450 &lt;__pthread_enable_asynccancel&gt;
   0x000000000001281d &lt;+45&gt;:	mov    0xc(%rsp),%edi
   0x0000000000012821 &lt;+49&gt;:	mov    %eax,%r8d
   0x0000000000012824 &lt;+52&gt;:	mov    $0x3,%eax
   0x0000000000012829 &lt;+57&gt;:	syscall
   0x000000000001282b &lt;+59&gt;:	cmp    $0xfffffffffffff000,%rax
   0x0000000000012831 &lt;+65&gt;:	ja     0x12868 &lt;close+120&gt;
   0x0000000000012833 &lt;+67&gt;:	mov    %r8d,%edi
   0x0000000000012836 &lt;+70&gt;:	mov    %eax,0xc(%rsp)
   0x000000000001283a &lt;+74&gt;:	call   0x124d0 &lt;__pthread_disable_asynccancel&gt;
   0x000000000001283f &lt;+79&gt;:	mov    0xc(%rsp),%eax
   0x0000000000012843 &lt;+83&gt;:	add    $0x18,%rsp
   0x0000000000012847 &lt;+87&gt;:	ret
   ...
   0x0000000000012868 &lt;+120&gt;:	mov    0x9739(%rip),%rdx        # 0x1bfa8
   0x000000000001286f &lt;+127&gt;:	neg    %eax
   0x0000000000012871 &lt;+129&gt;:	mov    %eax,%fs:(%rdx)
   0x0000000000012874 &lt;+132&gt;:	mov    $0xffffffff,%eax
   0x0000000000012879 &lt;+137&gt;:	jmp    0x12833 &lt;close+67&gt;
</code></pre><p>We can build our own toy profiler with the related <code>funclatency</code> tool from bcc, which records a histogram of all latencies, so we do not miss any calls. In addition to specifying a function, with its corresponding address, which we want to trace, we can define an offset in the function, where the tracing begins. Using this feature, we can start tracing at different points inside the function and see how the latencies change. The added latency is then the difference between the latency before and after the instruction. This method is not reliable when we are microprofiling on the order of microseconds or shorter, but our latency is long enough to make a measurable difference.</p>
<p>As the main latency should come from the three calls, we can measure at the two points between the calls. For my testing, I used the offset 57 and 59, so right before and after the syscall. With this setup I get the following histograms.</p>
<pre tabindex="0"><code>#&gt; /usr/share/bcc/tools/funclatency /lib/libpthread-2.33.so:close -o 57 -p &lt;pid&gt;
     nsecs               : count     distribution
         0 -&gt; 1          : 0        |                                        |
         2 -&gt; 3          : 0        |                                        |
         4 -&gt; 7          : 0        |                                        |
         8 -&gt; 15         : 0        |                                        |
        16 -&gt; 31         : 0        |                                        |
        32 -&gt; 63         : 0        |                                        |
        64 -&gt; 127        : 0        |                                        |
       128 -&gt; 255        : 0        |                                        |
       256 -&gt; 511        : 0        |                                        |
       512 -&gt; 1023       : 0        |                                        |
      1024 -&gt; 2047       : 0        |                                        |
      2048 -&gt; 4095       : 0        |                                        |
      4096 -&gt; 8191       : 0        |                                        |
      8192 -&gt; 16383      : 0        |                                        |
     16384 -&gt; 32767      : 0        |                                        |
     32768 -&gt; 65535      : 0        |                                        |
     65536 -&gt; 131071     : 0        |                                        |
    131072 -&gt; 262143     : 0        |                                        |
    262144 -&gt; 524287     : 0        |                                        |
    524288 -&gt; 1048575    : 0        |                                        |
   1048576 -&gt; 2097151    : 0        |                                        |
   2097152 -&gt; 4194303    : 0        |                                        |
   4194304 -&gt; 8388607    : 0        |                                        |
   8388608 -&gt; 16777215   : 0        |                                        |
  16777216 -&gt; 33554431   : 17       |*****************                       |
  33554432 -&gt; 67108863   : 39       |****************************************|
  67108864 -&gt; 134217727  : 2        |**                                      |

avg = 46994220 nsecs, total: 2725664779 nsecs, count: 58
</code></pre><pre tabindex="0"><code>#&gt; /usr/share/bcc/tools/funclatency /lib/libpthread-2.33.so:close -o 59 -p &lt;pid&gt;
     nsecs               : count     distribution
         0 -&gt; 1          : 0        |                                        |
         2 -&gt; 3          : 0        |                                        |
         4 -&gt; 7          : 0        |                                        |
         8 -&gt; 15         : 0        |                                        |
        16 -&gt; 31         : 0        |                                        |
        32 -&gt; 63         : 0        |                                        |
        64 -&gt; 127        : 0        |                                        |
       128 -&gt; 255        : 0        |                                        |
       256 -&gt; 511        : 0        |                                        |
       512 -&gt; 1023       : 15       |********                                |
      1024 -&gt; 2047       : 68       |****************************************|
      2048 -&gt; 4095       : 27       |***************                         |
      4096 -&gt; 8191       : 1        |                                        |

avg = 1678 nsecs, total: 186310 nsecs, count: 111
</code></pre><p>This is as far as I can analyze this problem. I think, this proves that the latency originates in the kernel, but not directly from the <code>__x64_sys_close</code> function, but by something else, that the kernel is doing. Doing some analysis with perf, I came across the <code>synchronize_rcu</code> function inside the kernel, which might be the root cause. It is part of the RCU system in the kernel, which provides asynchronous access to data structures. This is a rabbit hole, I am not going down this time.</p>
<p>With all this information, it is not obvious how to fix this problem, I am not a kernel developer, and this latency might still come from some other process accessing the same data. So a regular fix is not possible, but the whole point of enumerating the input devices every few seconds is to detect connected joysticks. Papers Please is not the type of game where a joystick or more likely a game controller is helpful. So why do we need this functionality in the first place?</p>
<h3 id="binary-patching">Binary patching</h3>
<p>The function which we are looking at is named <code>MaybeAddDevice</code>. So according to this name, <em>not</em> adding the device should be an appropriate behaviour. So changing the implementation to just return immediately seems like a sensible option. We can do this change by editing the binary at the point where the function is located.</p>
<p><code>MaybeAddDevice</code> is part of <code>lime.ndll</code>, a shared library, probably containing the game engine. With <code>objdump -t</code> we can see all the symbols which <code>lime.ndll</code> imports or exports, shown below. The first number is the address where the function will be loaded at runtime, plus a random offset. After the type of the symbol is given, here we have a global and a local symbol. With this information, we could use a hexeditor and patch the binary directly, but there is a, in my opinion, more elegant way.</p>
<pre tabindex="0"><code>000000000049c030 g     F .text	0000000000000009              SDL_SemWait
...
00000000004a6be0 l     F .text	000000000000032d              MaybeAddDevice
</code></pre><p>On linux, there is a mechanism, where we can inject our own code into a process. We can load our own shared library using the <code>LD_PRELOAD</code> environment variable. Every global function from a shared library can be overwritten using this technique. You may have noticed that the function which we are interested in is not a global function. This complicates our endeavour slightly. Instead of overriding the library directly, we override the library loading function <code>dlopen</code>. We inject ourselves into the loading process. So we forward most calls to the original <code>dlopen</code> calls, until we encounter the <code>lime.ndll</code> library.</p>
<p>At this point, the library is loaded into memory, but we do not know where. We can query the location of global symbols using <code>dlsym</code> and using the information from <code>objdump</code> we can calculate where <code>MaybeAddDevice</code> is located relative to <code>SDL_SemWait</code>. Because both of these are located in the same section, <code>.text</code>, their relative location does not change. So we just write to the calculated address, right? Well on modern systems there are protections installed, that memory with executable cannot be written. This is an important protection to reduce the attack surface of software, because an attacker could write his own code into memory and just jump there, but we want to use this power for good! Fortunately, linux also includes the ability to change the protections at runtime using <code>mprotect</code>. Otherwise software using JIT could not be implemented.</p>
<p>So, we inject the library loading process, find the location of the function, change the memory protection to writable and patch the function. The patching itself is rather easy, we just inject a <code>ret</code> as the first instruction, which is encoded as <code>0xc3</code>. The next time this function is called, it returns immediately.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>void</span> <span>patch_function</span>(<span>void</span><span>*</span> ptr, size_t offset) {
	<span>char</span><span>*</span> func <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span>(ptr);
	func <span>+=</span> offset;
	<span>const</span> <span>long</span> page_size <span>=</span> sysconf(_SC_PAGESIZE);
	<span>int</span> result <span>=</span> mprotect(page_round_down(func, page_size), <span>1</span>, PROT_READ <span>|</span> PROT_WRITE <span>|</span> PROT_EXEC);
	<span>if</span>(result) {
		fprintf(stderr, <span>&#34;result %d %d</span><span>\n</span><span>&#34;</span>, result, errno);
		<span>return</span>;
	}
	func[<span>0</span>] <span>=</span> <span>0xc3</span>; <span>// the actual patching
</span><span></span>	mprotect(page_round_down(func, page_size), <span>1</span>, PROT_READ <span>|</span> PROT_EXEC);
}

<span>using</span> dlopen_t <span>=</span> <span>void</span><span>*</span> (<span>*</span>)(<span>const</span> <span>char</span><span>*</span>, <span>int</span>);

<span>extern</span> <span>&#34;C&#34;</span>
<span>void</span><span>*</span> dlopen(<span>const</span> <span>char</span><span>*</span> filename, <span>int</span> flags) {
	<span>static</span> dlopen_t real_dlopen <span>=</span> <span>nullptr</span>;
    <span>if</span>(<span>!</span>real_dlopen)
        real_dlopen <span>=</span> <span>reinterpret_cast</span><span>&lt;</span>dlopen_t<span>&gt;</span>(dlsym(RTLD_NEXT, <span>&#34;dlopen&#34;</span>));
	<span>void</span><span>*</span> handle <span>=</span> real_dlopen(filename, flags);
	<span>if</span>(<span>!</span>filename <span>||</span> filename <span>!=</span> <span>&#34;././lime.ndll&#34;</span>s) {
		<span>return</span> handle;
	}
	<span>void</span><span>*</span> func <span>=</span> dlsym(handle, <span>&#34;SDL_SemWait&#34;</span>);
	<span>if</span>(<span>!</span>func) {
		fprintf(stderr, <span>&#34;could not find symbol: %s</span><span>\n</span><span>&#34;</span>, symbol);
		<span>return</span> handle;
	}
	patch_function(func, <span>43952</span>);
	<span>return</span> handle;
}
</code></pre></div><p>We can load compile this code to a shared library and inject it using <code>LD_PRELOAD</code>. A full implementation can be found <a href="https://gist.github.com/Henje/eff3fb2cf0bf47910dc9145256a53cfe">here</a>. I have changed the code to allow setting the function which we look up and the offset using an environment variable. This way, even if the binary changes, the code does not need to be recompiled.</p>
<p>The environment variables can be set in the <code>launch.sh</code> file like this:</p>
<div><pre tabindex="0"><code data-lang="bash">export LD_PRELOAD<span>=</span><span>$(</span>realpath papers_please_fix.so<span>)</span>
export PP_SYMBOL<span>=</span>SDL_SemWait PP_OFFSET<span>=</span><span>43952</span>
</code></pre></div><p>With all of this in place, Papers Please works as intended, at least of you do not play it with your joystick. Unfortunately, I still do not know if the slow <code>close</code> call is a bug and if so, where does it come from? Nevertheless, I can finally play Papers Please and I hope you can too or at least learned something along the way.</p>
    </div></div>
  </body>
</html>
