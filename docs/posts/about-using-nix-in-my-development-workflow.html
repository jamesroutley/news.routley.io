<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ejpcmac.net/blog/about-using-nix-in-my-development-workflow/">Original</a>
    <h1>About using Nix in my development workflow</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p><em>This article was originally published on
<a href="https://medium.com/@ejpcmac/about-using-nix-in-my-development-workflow-12422a1f2f4c">Medium</a>.</em></p>
<p><em><strong>TL;DR</strong> If you don’t want to read how I’ve got to use Nix and general information
about it but only focus on its use to setup a development environment, please
jump to Using Nix. Even from that part, the reading can take some time as I
wanted to share what I’ve learned and found useful accross two months of
intensive usage. I had some initial questions I have answered to after reading a
great portion of the documentation or asking to people. I wanted to share them
with you so you can get into using Nix quickly, still understanding what you are
doing.</em></p>
<hr/>
<p>Two years ago, whenever I needed to use some language or tool which wasn’t
available on my machine, I would have used the system’s package manager to
install it. It worked on my computer, but when I needed to reproduce the setup
elsewhere it was another story. I was still a student then.</p>
<p>I remember a group project in which we were using Node.js. I had a recent
version installed on my Mac via Homebrew, while at the university and on other
student’s computer based on Ubuntu Linux, it was installed from the default
repos. Then, my code using default parameters in functions would run on my
machine but not on other’s, since their Node.js version was greatly outdated.</p>
<p>Using this approach can quickly become a nightmare, especially when you try to
write a documentation on how to set up the development environment. You end up
writing things like: “If you are on macOS please do this, on Debian do that, and
Fedora run this other command.” You can verify it works now, but there is no
guarantee it will still work in a few months.</p>

<p>At the end of my studies, while starting my internship, I started to do <em>a lot
more</em> software development at home. Mainly because I didn’t have to worry
anymore about not doing my homework. This is back then I discovered
<a href="https://elixir-lang.org/">Elixir</a> and started to build up my workflow, seeking
for quality, reproducibility and joy of use. With my Node.js story in mind, I
discovered language version managers. I went for
<a href="https://github.com/asdf-vm/asdf">asdf</a> as it would handle for me quite a bunch
of languages, including Erlang, Elixir, Node.js and Ruby.</p>
<p>If you are not familiar with it, asdf can install exactly the version you want
for each language it handles through a plugin system. You can even have multiple
versions installed on the same machine and set the wanted one for every project
using a <code>.tool-versions</code> file which looks like this:</p>
<pre><code><span>erlang 21.0
</span><span>elixir 1.7.3-otp-21
</span></code></pre>
<p>It is simple to use, and you can set up easily your build environment on
different machines, running <code>asdf install</code> in a project directory.</p>
<p>Yet, if the setup process is simplified, there are still issues:</p>
<ul>
<li>after installing asdf, you need to install all the needed plugins. It is only
a matter of <code>asdf plugin-install &lt;plugin-name&gt;</code> commands, but it is not
automated;</li>
<li>some languages require dependencies to build. Erlang, for instance, needs some
packages to be installed before <code>asdf install erlang &lt;version&gt;</code> works. You
need a compiler, ncurses, OpenSSL and quite a few more. <strong>Setup instructions
depends on the system you use;</strong></li>
<li>If your project depends on other tools like, say, <code>fwup</code> for
<a href="https://nerves-project.org/">Nerves</a> projects, you still have to provide
manual setup instructions.</li>
</ul>
<p>This is where Nix enters the game.</p>

<p><a href="https://nixos.org/nix/">Nix</a> defines itself as <em>The Purely Functional Package
Manager</em>. Having learned the advantages of Functional Programming while using
Elixir and looking at Haskell and other FP languages over the past year, its
concept was very tempting to me.</p>
<p>Being purely functional means <strong>given an input, you always get the same
output</strong>. That is, given a version of <code>nixpkgs</code> and a set of packages, you
always get the same environment. In fact, packages are named <em>derivations</em> in
the Nix jargon: they are functions that takes other derivations—their
dependencies—as input and produce a derived result. They are built in isolation,
so all dependencies must be explicitely stated. This ensures
<strong>reproducibility</strong>.</p>
<p>Nix stores all the built derivations in the <em>Nix store</em>, usually located at
<code>/nix/store</code>. A same package can be present multiple times in the Nix store, at
different versions or even at the same version but using different versions of
its dependencies. Remember: a built derivation is the product of all its
dependencies; if you change something, it is a different product.</p>
<p>To achieve a unique naming for each derivation, a hash is computed from the set
of its dependencies. You then get a path like:</p>
<pre><code><span>/nix/store/k13mm9jqxm2ndlwzsj7zicsq7lpmmjlg-elixir-1.7.3
</span></code></pre>
<p>Unlike other package managers, Nix does not use the conventional
<code>/{,usr,usr/local}/{bin,sbin,lib,share,etc}</code> directories. Instead, it uses a lot
of symbolic links to create <em>profiles</em>. A profile is a kind of derivation used to
setup a user environment. In a profile, you get a standard Unix tree with
symbolic links to executables and configuration files stored in other derivation
outputs. For instance, <code>~/.nix-profile/bin/elixir</code> is a symbolic link to:</p>
<pre><code><span>/nix/store/k13mm9jqxm2ndlwzsj7zicsq7lpmmjlg-elixir-1.7.3/bin/elixir
</span></code></pre>
<p>Actually, <code>~/.nix-profile</code> is itself a link:</p>
<pre><code><span>~/.nix-profile -&gt; /nix/var/nix/profiles/per-user/***/profile
</span></code></pre>
<p>Which itself points to <code>profile-56-link</code> wich finally points to somewhere in the
Nix store:</p>
<pre><code><span>profile-56-link -&gt; /nix/store/5yw8dnp9908ia6sdfvx01jzis4l2hni7-user-environment
</span></code></pre>
<p>That is, as I have said above, a profile is a derivation. It <em>derives</em> from a
set of packages, that themselves <em>derive</em> from other packages. <em>Depends on</em>
becomes in Nix <em>derives from</em>. This is conceptual but you get the idea.</p>
<p>Updating a symbolic link has the interesting property of being an atomic
operation. This enables atomic transactions: when performing an upgrade, a new
<code>user-environment</code> derivation is built, with a different hash. Then, a new
generation is created for the profile—understand: a new symbolic link
<code>profile-57-link</code> pointing to the new derivation. Then, and only then, the
<code>profile</code> link is updated to point to <code>profile-57-link</code>. You’ve just performed
an atomic upgrade. If things went south, you’ve also got atomic rollbacks for
free: just update again the <code>profile</code> link to point to <code>profile-56-link</code>and you
are back in the past.</p>
<p>Moreover, only what you asked for is made available in the environment. For
instance, Elixir depends on Erlang. Erlang is then installed somewhere in the
Nix store and the Elixir installation is aware of it so it can work correctly.
But unless you explicitely asked to also install Erlang, only Elixir binaries
will be linked in your user environment.</p>
<h2 id="nix-as-a-declarative-configuration-manager">Nix as a declarative configuration manager</h2>
<p>Package managers usually work in an imperative way. That is, you ask them to
install this, to perform an upgrade or to uninstall that. One really neat
feature of Nix is <em>Nix</em>, the language. It is a purely functional domain-specific
language that comes with Nix.</p>
<p>The primary use of Nix, the language, is to write derivations. Yet, different
applications of Nix also leverage the language to manage packages and
configuration declaratively. In <a href="https://nixos.org/nixos/">NixOS</a>—a special
GNU/Linux distribution based on Nix—, all the system configuration and globally
installed packages are declared in <code>/etc/nixos/configuration.nix</code>. It can look
like:</p>
<pre data-lang="nix"><code data-lang="nix"><span>{ </span><span>config, pkgs, ... </span><span>}</span><span>:
</span><span>
</span><span>{
</span><span>  </span><span>network</span><span>.</span><span>hostname </span><span>= &#34;</span><span>nixos-test</span><span>&#34;;
</span><span>  </span><span>time</span><span>.</span><span>timeZone </span><span>= &#34;</span><span>Europe/Paris</span><span>&#34;;
</span><span>
</span><span>  </span><span># Omitting a lot of options, this is just a sample.
</span><span>
</span><span>  </span><span>environment</span><span>.</span><span>systemPackages </span><span>= </span><span>with </span><span>pkgs</span><span>; [
</span><span>    </span><span>curl
</span><span>    </span><span>git
</span><span>    </span><span>gnupg
</span><span>    </span><span>htop
</span><span>    ...
</span><span>  ];
</span><span>}
</span></code></pre>
<p>To change the state of the system, you just have to edit the file, then ask
NixOS to <em>switch</em> to the new environment:</p>
<pre><code><span># nixos-rebuild switch
</span></code></pre>
<p>It derives a new system environment, switches to it and reloads services as
needed. With this kind of configuration, you can easily reproduce your system
setup on different machines.</p>
<p>Another example is <a href="https://github.com/rycee/home-manager"><code>home-manager</code></a>. It
aims to provide the same kind of declarative configuration as NixOS but at the
user level. I <a href="https://github.com/ejpcmac/config_files">personally use it</a> to
manage my dotfiles and my set of user-wide-available utilities accross different
machines.</p>
<p>Apart system and user environments, Nix can be used to setup a third kind of
environment. Let’s talk about it.</p>
<h2 id="nix-as-a-reproducible-environment-builder">Nix as a reproducible environment builder</h2>
<p>It is neither practical nor wantable to update your system or user environment
each time you need a particular dependency for a given project. First, the given
dependency can be required only by a specific project: you do not need to have
it available (system|user)-wide. Second, you want your environment to be
shareable with other developers. Asking them to update their global environment
with this or that requirement is not the best thing to do. This is where <em>Nix
shells</em> enter.</p>
<p>A Nix shell is a temporary environment where build inputs of a derivation are
made available to the user. Let’s say it more simply with an example: you can
create a <code>shell.nix</code> file at the root of your project containing something like:</p>
<pre data-lang="nix"><code data-lang="nix"><span>{ </span><span>pkgs ? </span><span>import </span><span>&lt;nixpkgs&gt; </span><span>{} </span><span>}</span><span>:
</span><span>
</span><span>with </span><span>pkgs</span><span>;
</span><span>
</span><span>mkShell </span><span>{
</span><span>  </span><span>buildInputs </span><span>= [ </span><span>ocaml git </span><span>];
</span><span>}
</span></code></pre>
<p>Then, run the <code>nix-shell</code> command. You are in a Nix shell, with OCaml and Git
made available to you. The <code>shell.nix</code> can be committed, thus shared between
developers.</p>
<h2 id="using-nix">Using Nix</h2>
<p>To start working on a project using Nix, the first step is to install Nix
itself. From <a href="https://nixos.org/nix/download.html">the official documentation</a>,
all you have to do is running:</p>
<pre><code><span>$ curl https://nixos.org/nix/install | sh
</span></code></pre>
<p>There are in fact two kinds of installation for Nix:</p>
<ul>
<li>the single-user installation, where <code>/nix/store</code> is owned by the user
installing Nix. This is the simplest way to install Nix if you are the only
user on your machine and don’t want to use Nix extensively outside of setting
your development environment. It is also the easiest to uninstall as you just
have to delete the <code>/nix</code> directory;</li>
<li>the multi-user installation, where <code>/nix/store</code> is owned by <code>root</code> and a
<code>nixbld</code> group has write access to it. All Nix operations are then performed
by <code>nix-daemon</code>. Different users can use Nix simultaneously and you gain a
system environment like on NixOS. In the multi-user installation, builds are
performed by special builder users in complete isolation. It is a little bit
more complex to manage, but this is the recommended way to install Nix if you
plan to use it a lot, even if you are the only user on your machine. It is
supported on macOS and all Linux running <code>systemd</code> with SELinux disabled.</li>
</ul>
<p>As far as I know, the default installer currently choses automatically the type
of installation. It could change in the near future to prompting the user for a
choice. In the meantime, you can force how to install Nix by doing, for a
single-user installation:</p>
<pre><code><span>$ sh &lt;(curl https://nixos.org/nix/install) --no-daemon
</span></code></pre>
<p>For a multi-user installation it is:</p>
<pre><code><span>$ sh &lt;(curl https://nixos.org/nix/install) --daemon
</span></code></pre>
<p>Nix being installed on you machine, you can create a <code>shell.nix</code> in your
project:</p>
<pre data-lang="nix"><code data-lang="nix"><span># This defines a function taking `pkgs` as parameter, and uses
</span><span># `nixpkgs` by default if no argument is passed to it.
</span><span>{ </span><span>pkgs ? </span><span>import </span><span>&lt;nixpkgs&gt; </span><span>{} </span><span>}</span><span>:
</span><span>
</span><span># This avoids typing `pkgs.` before each package name.
</span><span>with </span><span>pkgs</span><span>;
</span><span>
</span><span># Defines a shell.
</span><span>mkShell </span><span>{
</span><span>  </span><span># Sets the build inputs, i.e. what will be available in our
</span><span>  </span><span># local environment.
</span><span>  </span><span>buildInputs </span><span>= [ </span><span>elixir git </span><span>];
</span><span>}
</span></code></pre>
<p>Then, all you have to do is running:</p>
<pre><code><span>$ nix-shell
</span></code></pre>
<p>Nix will copy or build derivations, then run a shell in which Elixir and Git are
available. By default, the Nix shell is a <code>bash</code>. If you are like me and want to
keep your good old <code>zsh</code> for your day-to-day environment, there is <a href="https://github.com/chisui/zsh-nix-shell">an
interesting plugin</a> for that.</p>
<p>In a standard Nix shell, your system-wide environment is still available. While
it is quite useful for day-to-day work, you can easily miss a dependency when
first building your environment. <strong>If you want to be sure not to miss any
dependency and ensure reproducibility, you should run a pure Nix shell</strong>, that
is a Nix shell where only the inputs explicitely stated in the shell.nix are
available:</p>
<pre><code><span>$ nix-shell --pure
</span></code></pre>
<p>You loose all your environment, all your aliases, all your usually available
programs. You are in a standardised <code>bash</code> that will be the same on every
machine where you run a pure shell. It is not a comfortable place to work, but
it is really comfortable when your application builds in such a shell. It means
any other developer or the future you will be able to setup the same environment
and build the application as expected. But for your comfort, you can use a
standard Nix shell most of the time.</p>
<hr/>
<p>In addition to Nix shells, you may sometimes want to make a tool globally
available in your user environment. If you don’t use
<a href="https://github.com/rycee/home-manager"><code>home-manager</code></a> to manage it in a
declarative way, you always can do it in an imperative way:</p>
<pre><code><span>$ nix-env -i &lt;package&gt;
</span></code></pre>
<p>If you are looking for a better user experience in installing packages,
<a href="https://github.com/madjar/nox"><code>nox</code></a> is the way to go:</p>
<pre><code><span>$ nix-env -i nox
</span></code></pre>
<p>Then just call <code>nox</code> with some search string:</p>
<pre><code><span>$ nox gcc
</span><span>1 avr-gcc-8.2.0 (nixpkgs.avrgcc)
</span><span>    GNU Compiler Collection, version 8.2.0 for AVR microcontrollers
</span><span>2 gcc-wrapper-7.3.0 (nixpkgs.gcc)
</span><span>    GNU Compiler Collection, version 7.3.0 (wrapper script)
</span><span>3 gcc-arm-embedded-6-2017-q2-update (nixpkgs.gcc-arm-embedded)
</span><span>    Pre-built GNU toolchain from ARM Cortex-M &amp; Cortex-R processors (Cortex-M0/M0+/M3/M4/M7, Cortex-R4/R5/R7/R8)
</span><span>4 gcc-7.3.0 (nixpkgs.gcc-unwrapped)
</span><span>    GNU Compiler Collection, version 7.3.0
</span><span>5 gcc-wrapper-4.8.5 (nixpkgs.gcc48)
</span><span>    GNU Compiler Collection, version 4.8.5 (wrapper script)
</span><span>6 gcc-wrapper-5.5.0 (nixpkgs.gcc5)
</span><span>    GNU Compiler Collection, version 5.5.0 (wrapper script)
</span><span>7 gcc-wrapper-6.4.0 (nixpkgs.gcc6)
</span><span>    GNU Compiler Collection, version 6.4.0 (wrapper script)
</span><span>8 stdenv-darwin (nixpkgs.gcc7Stdenv)
</span><span>    The default build environment for Unix packages in Nixpkgs
</span><span>9 gcc-wrapper-8.2.0 (nixpkgs.gcc8)
</span><span>    GNU Compiler Collection, version 8.2.0 (wrapper script)
</span><span>...
</span><span>Packages to install:
</span></code></pre>
<p>It will print you different alternatives so you can choose which one to install
directly by entering its number. It is also a good way to quickly search a
package name before adding it to a <code>shell.nix</code>.</p>
<p>In the example above, you can see several packages are available for <code>gcc</code>. The
real package name to include in a <code>shell.nix</code> is the one in parentheses. If
you’ve done <code>with pkgs;</code>, <code>pkgs</code> being by default <code>nixpkgs</code> in the <code>shell.nix</code>
examples I’ve shown you before, you can then omit <code>nixpkgs</code>. from package names.</p>
<h2 id="keeping-nixpkgs-up-to-date">Keeping nixpkgs up to date</h2>
<p>When you first install Nix, it also automatically installs the <code>nixpkgs</code> channel
for you. <a href="https://github.com/NixOS/nixpkgs"><code>nixpkgs</code></a> is the main channel in
the Nix community, and efforts are concentrated to it. You can event participate
if you want as it is as easy as opening a pull-request on GitHub. You are likely
willing to update it sometimes to get fresh versions of your packages. To do so,
run:</p>
<pre><code><span>$ nix-channel --update
</span></code></pre>
<p>Don’t forget to run the command as the user managing <code>nixpkgs</code>. If you’ve done a
single-user installation, it is your standard user. In a multi-user
installation, <code>root</code> is responsible for managing this channel, so you must run
the command as <code>root</code>.</p>
<p>If you have installed derivations via <code>nix-env -i</code> or <code>nox</code>, once you have
updated <code>nixpkgs</code>, you should run <code>nix-env -u</code> to rebuild them—understand:
update them—on top of the last <code>nixpkgs</code>. If you have installed derivations on
NixOS at the system level, or at the user level using <code>home-manager</code>, you have
to run <code>nixos-rebuild switch</code> or <code>home-manager switch</code> to rebuild your
environment.</p>
<p>When you update <code>nixpkgs</code>, remember that you are changing an input. The
environments you build are now using derivations from this new version. It is
not <em>fully</em> reproducible since you can’t now which version of <code>nixpkgs</code> another
user have. In most cases, this is not an issue. Packages that could cause
incompatibilities between versions, like languages or libraries, often provide
different packages ready to use. For instance, while <code>elixir</code> provides a given
version of Elixir—theorically the last one—built on a given version of Erlang
that is not fixed and will evolve with <code>nixpkgs</code> updates, there is
<code>beam.packages.erlangR21.elixir_1_7</code> which provides you the latest Elixir 1.7 on
the latest Erlang 21. At the time I am writing this article, it is namely Elixir
1.7.3 on Erlang 21.0. Yes, a <code>nixpkgs</code> update could bring you to Elixir 1.7.4 on
Erlang 21.1, say, but they are compatible versions. Using this derivation, you
will never end up with Elixir 1.8 or 2.0. However, if you really want to set
<code>nixpkgs</code> to a given version to provide a fully-reproducible environment, this
is possible. All you have to do is setting the <code>pkgs</code> variable differently in
your <code>shell.nix</code>:</p>
<pre data-lang="nix"><code data-lang="nix"><span>let
</span><span>  </span><span>pkgs </span><span>= </span><span>import </span><span>(</span><span>fetchTarball </span><span>{
</span><span>    </span><span>url </span><span>= </span><span>https://github.com/NixOS/nixpkgs/archive/&lt;rev&gt;</span><span>.</span><span>tar</span><span>.</span><span>gz</span><span>;
</span><span>  }) {};
</span><span>
</span><span>  </span><span># I’m also showing here you can define any variable.
</span><span>  </span><span>elixir </span><span>= </span><span>pkgs</span><span>.</span><span>beam</span><span>.</span><span>packages</span><span>.</span><span>erlangR20</span><span>.</span><span>elixir_1_6</span><span>;
</span><span>in
</span><span>
</span><span>with </span><span>pkgs</span><span>;
</span><span>
</span><span>mkShell </span><span>{
</span><span>  </span><span># `elixir` is not the latest Elixir anymore, but the latest
</span><span>  </span><span># version of the 1.6 branch built on the latest Erlang 20 at the
</span><span>  </span><span># time when `nixpkgs` was at &lt;commit-hash&gt;, as stated above.
</span><span>  </span><span># Same for the version of Git.
</span><span>  </span><span>buildInputs </span><span>= [ </span><span>elixir git </span><span>];
</span><span>}
</span></code></pre>
<h2 id="collecting-garbage">Collecting garbage</h2>
<p>As we have seen before, Nix stores the derivations outputs in <code>/nix/store</code>. It
then builds environments linking to files in the store. But what happens when
you update, uninstall a program or when you exit a Nix shell? Nothing. New
environments are built, but nothing is removed from the store. After some time
of use, the Nix store can grow a bit too much for your taste. While it is good
to keep a cache between two <code>nix-shell</code> calls to avoid fetching again all
dependencies, it can be useful to clean a bit the store sometimes.</p>
<p>Nix has a built-in garbage collector that looks for unreferenced
derivations—derivation that are not part of an environment or a running Nix
shell. You can call it by running:</p>
<pre><code><span>$ nix-collect-garbage
</span></code></pre>
<p>Doing this has nevertheless a limitation: it does not clean old generations of
profiles. Remember: when doing changes to environments, you don’t mutate its
state: you create a new generation and switch to it. This is what makes
rollbacks possible. To reclame space on disk, old generation need to be removed.
You can ask the garbage collector to delete them before to collect garbage:</p>
<pre><code><span>$ nix-collect-garbage -d
</span></code></pre>
<p>However, it is a good pratice do keep old generations for some time, just in
case. You can tell the garbage collector to delete old generation only if they
are older than a given amount of time. To keep old generation 30 day, for
instance, you would do:</p>
<pre><code><span>$ nix-collect-garbage --delete-older-than 30d
</span></code></pre>
<p>Garbage collection has one downside though: as shell environments are not
symlinked in the GC roots like profiles, the garbage collector systematically
deletes them. In the next section about <code>direnv</code>, we’ll see there is a way to
persist them and avoid this kind of issue.</p>
<hr/>
<p>Apart from collecting garbage, there is another way to optimise the Nix store in
term of disk space. When some derivation gets updated, all derivations depending
on it have to be rebuilt since one of their inputs has changed. Many of their
files—if not all—remain the same, so it is possible to reclaim space by
hard-linking them:</p>
<pre><code><span>$ nix-store --optimise -v
</span></code></pre>
<p>You can also make Nix auto-optimise its store when writing new files to it:</p>
<pre><code><span>$ mkdir -p ~/.config/nix
</span><span>$ echo &#34;auto-optimise-store = true&#34; &gt;&gt; ~/.config/nix/nix.conf
</span></code></pre>
<p>Please use this option with caution though. If it works really well on a
single-user installation, I’ve seen race conditions on <code>/nix/store/.links</code> files
creation when using several builder simultaneously. I prefer to run it by hand
then. With a good alias like
<a href="https://github.com/ejpcmac/config_files/blob/368f515bc8f878d219fca9907f00cc8bac9bbd99/zsh/nix.zsh#L39"><code>nso</code></a>
it’s quick.</p>

<p>While Nix provides a much richer developer experience, asdf has a very
comfortable feature: you don’t have to run a command each time you want to get
your environment configured. The right versions of your languages are
automatically picked up depending on which directory you are in. As Nix lacks of
this feature—is not its role anyway—let me introduce direnv.</p>
<p><a href="https://github.com/direnv/direnv">direnv</a> is a tool for automatically switching
between environments, based on your current directory. To cite its
documentation:</p>
<blockquote>
<p>Before each prompt, direnv checks for the existence of a “.envrc” file in the
current and parent directories. If the file exists (and is authorized), it is
loaded into a <strong>bash</strong> sub-shell and all exported variables are then captured
by direnv and then made available to the current shell.</p>
</blockquote>
<p>One really neat thing about direnv is its awareness of Nix. You can just put
<code>use nix</code> in a <code>.envrc</code> and direnv knows how to update you current shell to behave
like a Nix shell. Let’s start with installing direnv:</p>
<pre><code><span>$ nix-env -i direnv
</span></code></pre>
<p>For direnv to work, you then need to hook it into your shell. Edit your
<code>~/.&lt;shell&gt;rc</code> and put:</p>
<pre data-lang="sh"><code data-lang="sh"><span>eval </span><span>&#34;$</span><span>(</span><span>direnv</span><span> hook </span><span>&lt;</span><span>shell</span><span>&gt;</span><span>)</span><span>&#34;
</span></code></pre>
<p>Replace <code>&lt;shell&gt;</code> with <code>zsh</code>, <code>bash</code> or any <a href="https://github.com/direnv/direnv#setup">other supported
shell</a>.</p>
<p>In any project directory, you can then create a <code>.envrc</code> by running:</p>
<pre><code><span>$ direnv edit .
</span></code></pre>
<p>As your environment configuration is already handled by the <code>shell.nix</code>, simply
tell direnv to use Nix by writing:</p>
<pre><code><span>use nix
</span></code></pre>
<p>After saving the file and quitting your editor, direnv should automatically
update your shell environment whenever you enter or exit the project tree.</p>
<p>If you change the <code>.envrc</code> contents or clone a project where a <code>.envrc</code> is
already present, direnv will ask you to allow it. It is for security purpose:
you should always check what a <code>.envrc</code> contents do. To allow it:</p>
<pre><code><span>$ direnv allow
</span></code></pre>
<p>This is great, but you can however notice two things:</p>
<ul>
<li>the environment can take some time to build each time you run a shell in a
project directory;</li>
<li>the environment is not (yet) persistent: garbage collection would delete it
from the Nix store.</li>
</ul>
<p>In the <a href="https://github.com/direnv/direnv/wiki/Nix">direnv wiki page about Nix</a>,
you can find a
<a href="https://github.com/direnv/direnv/wiki/Nix#persistent-cached-shell">script</a> that
builds a persistent <em>and</em> cached shell, thus avoiding both the two remarks I
have written above. All you have to do to use it is adding it at the top of your
<code>.envrc</code> files, like in <a href="https://gist.github.com/ejpcmac/d9ecbfcb9c579e87de52b89a2b4e39d9">this
one</a>. This
script creates a <code>.direnv</code> directory at your project root, containing symbolic
links to derivation outputs in the Nix store. It also links them in the GC
roots, thus avoiding the shell environment to be garbage-collected as long as
the <code>.direnv</code> directory exists. For this to work as expected, you must tell Nix
to keep derivation outputs. Put this in your <code>~/.config/nix/nix.conf</code>:</p>
<pre><code><span>keep-outputs = true
</span><span>keep-derivations = true
</span></code></pre>
<p>If you are on a Mac, this script does not work out of the box: it indeed relies
on the GNU version of <code>readlink</code>. To make it work, you can install <code>coreutils</code>
in your user profile via Nix:</p>
<pre><code><span>$ nix-env -i coreutils
</span></code></pre>
<p>Please note that <code>coreutils</code> replaces some of the standard shell commands. While
GNU versions are good, they may lack of some refinements like <code>ls</code> being able to
show extended attributes. If you want to keep using your system <code>ls</code> while
installing <code>coreutils</code>, you can achive this by aliasing <code>ls</code> to <code>/usr/bin/ls</code>.</p>

<p><em><em>TL;DR</em> I have written some aliases for
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/nix.zsh">Nix</a>
and
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/direnv.zsh">direnv</a>.
You can also add a visual indicator to your prompt by <a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/themes/bazik.zsh-theme#L39-L53">checking if
<code>$IN_NIX_SHELL</code> is
set</a>.</em></p>
<p>As developers, we spend most of our day doing tasks on a computer. While some of
these tasks can be long and require a great focusing, some of them like using
tools as Git, Nix and direnv should be really quick and effortless. When in your
shell, you shouldn’t have to ask if you are in a Git repository, on each branch,
or wether you are in a Nix shell. Your shell should provide you information
without you asking for. In the same way, interacting with these tools should be
really quick. You shouldn’t end up typing things like:</p>
<pre><code><span>$ git status
</span><span>$ git checkout master
</span><span>$ nix-shell --pure
</span></code></pre>
<p>These commands are not long, but they are too long to type—even with
completion—for what they achieve. On my machines, I would do instead:</p>
<pre><code><span>$ gcm
</span><span>$ nisp
</span></code></pre>
<p>Note that I have omitted an alias for <code>git status</code>. This is because <a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/themes/bazik.zsh-theme#L56">my prompt
already shows me on which branch I
am</a>,
and if there are changes or something to push or pull. Also, if I am in a Nix
shell, <a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/themes/bazik.zsh-theme#L39-L53">my prompt is blue instead of
green</a>.</p>
<p>The purpose of this is not anymore about sharing a development environment with
others. It is all about personal comfort. The common base is made of full
commands: they can be run everywhere. You can always check the status of a
repository with <code>git status</code> and run a pure Nix shell with <code>nix-shell --pure</code>.
But on top of this common base, you should customise your environment so that
your computer really becomes an ergonomic tool. When I take photos I love to
think about my cameras like extensions of my arm, some of them being truly
ergonomic—hello Fuji GW690 II! When I am on a computer, I like to feel the same
way with my keyboard. Shortcuts and aliases, thanks to the muscular memory, are
<em>really</em> helpful to keep you in the flow.</p>
<p>This being said, if you want to get some inspiration, I have written some
aliases for
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/nix.zsh">Nix</a>
and
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/direnv.zsh">direnv</a>.
The direnv ones even contains <a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/direnv.zsh#L23-L27">some
aliases</a>
dedicated to the script for persistent cached shells. The idea is to help
cleaning old local environments by doing <code>dcl</code> or at the end of a project,
cleaning the environment by doing <code>dar &amp;&amp; ngco</code>.
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/direnv.zsh#L26"><code>dar</code></a>
is for “direnv archive”, that is, it denies the current <code>.envrc</code> and deletes the
<code>.direnv</code> directory. Running
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/nix.zsh#L36"><code>ngco</code></a>
then deletes the environment from the Nix store, as the <code>.direnv</code> directory is
gone. This is all about personal taste, customise as you prefer.</p>
<p>Last but not least: starting to use Nix and direnv in an existing project is as
easy as running <code>nixify</code>, which is defined
<a href="https://github.com/ejpcmac/config_files/blob/bc9ee4e7363e4e0ca97f4addbdd9370b83048d3c/zsh/direnv.zsh#L33-L138">here</a>.
It simply creates a <code>.envrc</code> and a <code>shell.nix</code> if they don’t exist.</p>

<p>Migrating from asdf to Nix has been an interesting journey. They both share some
ideas when it comes to managing the build environment. However, Nix is several
orders of magnitude more powerful than asdf.</p>
<p>If we only focus on Nix shells, Nix can not only manage the languages you use,
but also every other tool you would need for your development process. You can
use pure shells to check if your environment is complete, avoiding to use tools
available globally on <em>your</em> machine. Also, if a tool or version is not
available in <code>nixpkgs</code>, you can easily write your own derivations.</p>
<p>When it comes to environment switching, asdf seems to be a winner in the first
run, but once you have set up direnv you quickly forget about that.</p>
<p>Generally speaking, Nix is a more broader tool: you can use it to install
software on your machine without messing your system, manage your configuration
or automate your builds. If you are interested in Nix, you should also learn
about these aspects.</p>
<p>I still have to figure about using Nix as part of my Rust workflow. I have
especially questions about the RLS setup and cargo commands like <code>cargo watch</code>.
Once it is done, I may come with an article about it. I also plan to write a
much shorter article focused on Elixir projects—including Phoenix and Nerves—as
I have managed to build and run them in pure Nix shells.</p>
<hr/>
<p>I hope this article has been useful to you in your understanding of Nix. If
something is not clear, please tell me in a response: I will update the article
accordingly.</p>
<p><em>Edit: if you are an Elixir developer, you can read my article about <a href="https://ejpcmac.net/blog/using-nix-in-elixir-projects/">Using Nix
in Elixir projects</a>.</em></p>

    </div></div>
  </body>
</html>
