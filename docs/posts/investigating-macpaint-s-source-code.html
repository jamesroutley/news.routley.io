<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ztoz.blog/posts/macpaint-source-code/">Original</a>
    <h1>Investigating MacPaint&#39;s Source Code</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
    

    <p><time>2025-03-25</time></p>

    <p>MacPaint is a monochromatic raster image painting program that introduced many people to mouse-driven controls, tool palettes, and copy and paste integration with other applications. One of two launch applications for the Apple Macintosh in 1984, MacPaint is emblematic of the Macintosh’s early quirky revolutionary branding, focus on ease of use, and appeal to artistic customers. Using the source code, we examine the design and implementation of the application. We find that the buffer management and bucket filling algorithms demonstrate mechanical empathy with the 68k platform and leverage the limitations of the domain as a means to improve performance. We also find positive and negative aspects in the code style and architecture and its pliability for change. Finally, we dispute some claimed novel aspects of the program while also arguing for its significance and impact on the development of digital graphic systems.</p>
<figure><img src="https://ztoz.blog/posts/macpaint-source-code/MacPaint-1.5-WithContent.png" alt="Screenshot of MacPaint 1.5 with a drawing" width="100%"/><figcaption>
            <p>MacPaint 1.5 (1985)</p>
        </figcaption>
</figure>

<p><strong>Table of Contents</strong></p>
<ol>
<li><a href="#background">Background</a></li>
<li><a href="#timeline">Timeline</a></li>
<li><a href="#developer-bill-atkinson">Developer: Bill Atkinson</a></li>
<li><a href="#development-and-testing">Development and Testing</a></li>
<li><a href="#design-and-source-code">Design and Source Code</a></li>
<li><a href="#interesting-algorithms-and-designs">Interesting Algorithms and Designs</a></li>
<li><a href="#alternative-paths-and-competitors">Alternative Paths and Competitors</a></li>
<li><a href="#post-release">Post Release</a></li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#special-recognition">Special Recognition</a></li>
<li><a href="#references">References</a></li>
</ol>
<h2 id="background">Background</h2>
<p>At the Boston Computer Society’s general meeting on January 30th 1984, Steve Jobs laid out his rationale for why Apple’s newest product, the Macintosh computer, was the third milestone product of the computer industry after Apple’s own Apple II and the IBM PC. The Macintosh would be the “computer for the rest of us.” The Macintosh used the same software as the Lisa bringing the same ease of use from a point-and-click interface and pull down menus as well as sharing the same fast Motorola 68000 processor.</p>
<p>After highlighting hardware features such as portability, the 3.5&#34; diskette drive, and the AppleBus support, Jobs let the computer do a demo on its own. Booting the Mac from a diskette, the Mac displayed its name and the “Insanely Great” logo, and then showed the first real, application image: a MacPaint screenshot showing a woodcut of a Japanese lady.</p>
<figure><img src="https://ztoz.blog/posts/macpaint-source-code/04_applegeisha.gif" alt="Screenshot of MacPaint with Japanese lady" width="100%"/><figcaption>
            <p>MacPaint screenshot with Japanese Lady (1984)</p>
        </figcaption>
</figure>

<p>Apple used the screenshot heavily within their advertisements and most of the audience would have seen static screenshots of MacPaint and MacWrite in the months beforehand, but the audience was still delighted.</p>
<p>Twenty-nine minutes in, Jobs introduces a panel of the Macintosh development team and Bill Atkinson starts the first demo, a demo of MacPaint that he developed.</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/1tQ5XwvjPmA?si=Lq4yE_8IbbeYdNhk&amp;start=1770" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>Over the next seven minutes, Atkinson demonstrates how to make art with the program. The audience’s first applause comes when he uses an eraser to erase little chunks of previously drawn lines and rectangles. The applause is due to both how easy and quick the tool is to use but also that it demonstrates the program is working with actual pixels; he isn’t creating new clipping regions or restricted to deleting entire shapes. The audience also applauded when Bill draw lines filled with patterns and then again when, by holding down the spray can, the paint grows denser. Heralding the feature’s value, the fourth applause comes when Bill zooms in and manipulates individual pixels using the Fat Bits mode. The audience similarly loves the many ways areas of the image can be selected, moved and copied.</p>
<p>Atkinson finishes the demo by copying an image of a fish that will soon be pasted into a MacWrite document. In an unspoken nod to the limits of the Macintosh’s hardware, Atkinson closes MacPaint so the memory can be used by MacWrite.</p>
<p>Randy Wigginton, who is about to demo MacWrite, pauses to praise Bill’s work on QuickDraw, the foundational graphical library for the Lisa and the Macintosh. “Without Bill, none of us would be up here on stage.”</p>
<p>Bill Atkinson’s contributions at Apple, including foundational user interface contributions for the Lisa and Macintosh computers, and one of the two application programs that shipped with the “Insanely Great” Macintosh as the advertisements claimed, have been well-recorded. With the <a href="https://computerhistory.org/blog/macpaint-and-quickdraw-source-code/">release of the QuickDraw and MacPaint source code</a> in 2010, we have an opportunity to examine the technical design and implementation of his work. This article examines the MacPaint application, how it was built, what are some of the interesting algorithms and engineering trade offs, and how we might measure its impact against the larger industry trends around image painting and rastering technology.</p>
<h2 id="timeline">Timeline</h2>
<p>The development of MacPaint is intertwined with the development of the mouse and the graphical user interface, the Lisa and Macintosh computers, and QuickDraw, the foundational graphics library used by both the Lisa and the Macintosh. This timeline focuses on MacPaint and contemporary competitor painting programs, not on the overall history of raster drawing programs. See (Smith 2001) for a history of early raster drawing programs and their commercial applications and development.</p>
<p><strong>1982</strong></p>
<p>Over a period of six weeks, Atkinson develops a prototype painting program that “sort-of worked” (Young 1985, pg 315). The source code file <code>MyTools.text</code>, later renamed to <code>MyTools.a</code>, states it was created October 31st.</p>
<p><strong>1983</strong></p>
<p>In January, Apple announces the Lisa Computer, although no units are shipped until June. The Lisa includes Atkinson’s QuickDraw library.</p>
<p>Microsoft broadens the development of mouse-based applications by releasing their first <em>Microsoft Mouse</em>. The package includes a color raster drawing program program called ‘Doodle.’ Doug Wolfgram releases perhaps the first third-party drawing program with ‘Mouse Draw,’ which uses the Microsoft Mouse.</p>
<p>Atkinson resumes work on MacPaint, at this point called MacSketch. The set of palettes and tools is already very close to the eventual MacPaint UI. The image in the screenshot (below) is celebrating ROM 2.0; based on MyTools.a, this would date the image between February 13th and March 16th, when the file was regenerated for ROM 2.0 but before ROM 2.4.</p>
<figure><a href="https://www.folklore.org/Busy_Being_Born,_Part_2.html"><img src="https://ztoz.blog/posts/macpaint-source-code/early_macpaint_t.jpg" alt="Screenshot of MacSketch with UI similar to MacPaint"/></a><figcaption>
            <p>MacSketch (MacPaint c. 1983; Source folklore.org)</p>
        </figcaption>
</figure>

<p>MacSketch is renamed MacPaint in April. Between then and October, Atkinson iterates on the program adding features and improving performance. The last entry in MyTools.a is dated September 1983.</p>
<p>In December, Apple advertises the Macintosh with a <a href="https://www.digibarn.com/collections/ads/apple-mac/index.htm">full-color brochure</a>. MacPaint is featured prominently and is used to educate the public on how tool palettes, menus, and copy-paste work. The ad also mentions that the content area can be scrolled for more work space.</p>
<p><strong>1984</strong></p>
<p>With great fanfare, the Apple Macintosh is shown at the Boston Computer Society January 30th General Meeting. Bill Atkinson demos MacPaint (and implicitly, QuickDraw) to the crowd. The original Macintosh 128k comes with two applications: MacWrite and MacPaint.</p>
<p>In May, MacPaint 1.3 is released as part of a free software update to customers. This version adds the ability to lasso an object and repeatedly fill it (via the Fill item in the Edit menu) with a pattern.</p>
<p>In September, MacPaint 1.4 is released along with the Macintosh 512k.</p>
<p>Competitors quickly adopt the MacPaint interface. In June, Mouse Systems ships <em>PC Paint 1.0</em> bundled with a mouse in competition with Microsoft. <em>PC Paint</em> is based on <em>Mouse Draw</em>, which they purchased from Wolfgram, but with a MacPaint-like interface. Similarly, ZSoft Corporation ships their <em>PC Paintbrush</em>, also DOS-based but with an interface derived from MacPaint.</p>
<p><strong>1985</strong></p>
<p>Microsoft releases a new version of their mouse. They drop their ‘Doodle’ program and replace it with a rebranded version of <em>PC Paintbrush</em>, licensed from ZSoft Corporation. In April, Apple releases System Software 2.0 which includes MacPaint 1.5 (<a href="https://archive.org/details/mac_Paint_2">https://archive.org/details/mac_Paint_2</a>). This is the last version until 1988, when MacPaint 2.0 is released by a <a href="https://www.folklore.org/Evolution_of_a_classic.html">new developer</a>. There are no more official releases of MacPaint.</p>
<h2 id="developer-bill-atkinson">Developer: Bill Atkinson</h2>
<p>When you start MacPaint, the name Bill Atkinson briefly flashes in the credits. You can also find Atkinson’s name and a small portrait in the About menu.</p>
<figure><img src="https://ztoz.blog/posts/macpaint-source-code/MacPaint-1.5-AboutWindowCropped.png" alt="Screenshot of About window from MacPaint showing Bill Atkinson as author with portrait" width="100%"/><figcaption>
            <p>MacPaint 1.5 About Window (1985)</p>
        </figcaption>
</figure>

<p>Ironically for someone who would rise to be an Apple Fellow, Bill Atkinson did not receive classical training in computing. His undergraduate education was in chemistry and biochemistry with graduate training in neuroscience. However, he was not disconnected from the computing scene. He built both an IMSAI and an Altair computer (Atkinson 2004, pg 4). Further, his college work emphasized using computers and he made contacts that would prove highly influential to his career.</p>
<p>While at UC San Diego, Atkinson met Jef Raskin and was introduced to Raskin’s unconventional computer lab which emphasized direct and real-time connections with computers. He also met Guy Bud Tribble at UCSD, who would later live with Atkinson and help develop the Macintosh. Atkinson’s mentor at the University of Washington, Kent Wilson, introduced him to computer graphics and innovations in the field, such as Ivan Sutherland’s work on Sketchpad.</p>
<p>Lured to Apple in 1978 by Jef Raskin, Atkinson became the company’s first application software developer. His first project was a stock portfolio evaluator because, while Apple featured one in an advertisement, they did not have any in the catalog (Atkinson 2004, pg 7). His second major project was helping port the UCSD Pascal system to the Apple II. With no other structured programming options, Lisa development adopted this version of Pascal (Atkinson 2004, pg 9).</p>
<p>In 1979, Steve Jobs made visits to Xerox Parc along with a small group of Apple employees, including Atkinson. At Parc they were shown the Alto computer, Smalltalk programming language, and (likely) the Bravo text editor (Atkinson 2004, pg 18). Transferred to the Lisa project, Atkinson was responsible for LisaGraf, the foundational graphics library (later named QuickDraw), as well as the original window manager, menu manager, and event manager (Atkinson 2004, pg 20).</p>
<p>Since the Macintosh re-used software from the Lisa, in particular Atkinson’s user interface and graphics code, he moved onto the Macintosh team where he started to work on MacPaint in earnest in 1983.</p>
<p>Unlike the founders of Adobe, Atkinson did not come from the computer graphics research world, but was familiar with research advances through his academic mentors and had met luminaries such as Douglas Engelbart. Similar to the Adobe founders who worked on the same problems multiple times, he had time to iterate, with several years of experiments as Lisa developed from a research effort into a product. Intentionally straddling both foundational and application development, Atkinson had the viewpoint of a “vertical integrator,” able to control where functionality should go and how the interfaces should work.</p>
<h2 id="development-and-testing">Development and Testing</h2>
<p>Finding life in the Apple office too “busy” (Atkinson 2004, pg 20), he worked out of a home laboratory using a prototype Apple Lisa. The Lisa had a “Workshop” mode which featured a <a href="https://winworldpc.com/product/apple-lisa-pascal-workshop/20">graphical editor and a command-line environment</a> for compiling and other development activities.</p>
<p>Atkinson took Polaroids of the user interface as it evolved and drove into work to share them with the team. Fortunately for posterity, Atkinson saved the Polaroids and we have a detailed visual history of the evolution of the Lisa interface and QuickDraw capabilities as shown in the 2022 CHM interview below. (SketchPad is briefly shown and discussed, starting at 9:45.)</p>
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Qg0mHFcB510?si=o2WL679_4p7r2gbl" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>The Macintosh team used the ‘Monkey’ as a durability and robustness test mechanism. Developed by Steve Capps, the Monkey would randomly type keys, move objects, and interact with menus (Atkinson 2010, pg 14-15). The team used a computer running in Monkey mode to effectively stress-test an application. MacPaint was able to survive two weeks without crashing. Monkey mode can be seen in the source code:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span><span>6
</span></span><span>7
</span><span>8
</span><span>9
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm">         <span>.FUNC</span> <span>Monkey</span>
<span>;---------------------------------------------------------------------
</span><span>;
</span><span>;  FUNCTION Monkey: BOOLEAN;
</span><span>;
</span><span><span></span>         <span>TST</span>      <span>MonkeyLives</span>                <span>;IS THE MONKEY ACTIVE ?
</span></span><span></span>         <span>SGE</span>      <span>4</span>(<span>SP</span>)                      <span>;YES IF &gt;= ZERO
</span><span></span>         <span>NEG.B</span>    <span>4</span>(<span>SP</span>)                      <span>;CONVERT TO PASCAL BOOLEAN
</span><span></span>         <span>RTS</span>
</code></pre></td></tr></tbody></table>
</div>
</div><p>To prevent Monkey mode from quitting the program and thus ending the test prematurely, the Pascal code calls this function to selectively disable the Apple menu, File menu, and the Quit Program command.</p>
<p>Susan Kare, who served as the graphics designer for the Macintosh, was the main customer of MacPaint. Atkinson watched her use MacPaint and “see what she stumbled on or wished she had” (Atkinson 2004, pg 47). As the only true artist on the team, and someone who used MacPaint as a tool for their job, Kare’s feedback was invaluable. Andy Hertzfeld characterized her impact as “I think a lot of the refinement of MacPaint came from watching an actual user, an actual artist use the program on a day-to-day basis.” (Atkinson 2010, pg 9). Similarly, Atkinson states “I would credit Susan Kare as a co-designer of MacPaint because she used it as I was trying to write it.” (ibid).</p>
<h2 id="design-and-source-code">Design and Source Code</h2>
<h3 id="physical-description">Physical Description</h3>
<p>The MacPaint 1.3 distribution consists of five files:</p>
<ol>
<li><code>MacPaint.p</code>, 4,688 lines of Pascal (<a href="http://pascal.hansotten.com/ucsd-p-system/apple-pascal/">Lisa Pascal variant</a>)</li>
<li><code>MacPaint.rsrc</code>, resource description for the program containing icons, strings, and other localizable attributes. The version string identifies itself as version 1.3.</li>
<li><code>MyHeapAsm.a</code>, 67 lines of assembly for calls into system memory management routines</li>
<li><code>MyTools.a</code>, 300 lines of assembly defining traps or external calls into QuickDraw. A comment states this file was mostly generated via <code>MakeTTraps</code>. This is the only file with a change log and content attributed to someone other than Bill Atkinson.</li>
<li><code>PaintAsm.a</code>, 1,809 lines of assembly containing application code called from the Pascal code</li>
</ol>
<p>We counted physical lines of code using the <code>pascal_count</code> and <code>asm_count</code> programs, both part of David A. Wheeler’s SLOCCount suite.</p>
<h3 id="data-types-and-structures">Data Types and Structures</h3>
<p>MacPaint defines very few datatypes for its own use, leveraging instead types from QuickDraw such as Point, Rect (Rectangle), Pattern, and BitMap.</p>
<p>The Pascal code heavily uses global variables; the list extends from lines 212 through 370, with white-space used to group them by commonality. Most of the global variables are used to store various flags or interface state, such as the current font specification. This list is distinct from global constants (lines 27 through 190). Most of the constants are used to specify menu items, buttons, or other interface elements.</p>
<p>The application is a set of tools that, ultimately, modify the document which is a fixed size 1-bit bitmap stored as an array of integers. The document lacks dynamic metadata. As pixels are pretty simple, few abstractions or data types are required.</p>
<h3 id="pascal-vs-assembly">Pascal vs. Assembly</h3>
<p>Roughly one-third of MacPaint’s lines of code are in Motorola 68000 assembly, while two-thirds are in Pascal. In (Young 1985, pg 316), Atkinson explains the rationale and benefit of both languages:</p>
<blockquote>
<p>By frequency of working on it, I would bring up the Pascal file 20 or 30 times for every one time I brought up the assembly language file. Basically, the information in assembly language doesn’t really need a lot of maintenance. The assembly-language portion contains things that are there for speed, or that were small and I knew wouldn’t need a lot of maintenance. I put them in assembly language just to reduce the code size. By keeping the main control, flow, and logic in Pascal, the program was more pliable.</p>
</blockquote>
<p>Atkinson’s rationale is supported by the list of procedures in each language. Performance-critical code, such as that which manipulates the buffers directly, is in assembly. User interface control logic is in Pascal, as well as code that handles initial setup or rare operations. Operating system calls, such as checking the amount of spare space in the disk drive or invoking the system beep, are in assembly. Since MacPaint was developed concurrently with the operating system, some functionality may have existed in the ROM but had not yet been exposed by Pascal system libraries.</p>
<p>As an example of Atkinson’s assembly style and quality, we present the <code>NearPt</code> function:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm">         <span>.FUNC</span> <span>NearPt</span>
<span>;-----------------------------------------------------------
</span><span>;
</span><span>;  FUNCTION NearPt(pt1,pt2: Point; tol: INTEGER): BOOLEAN;
</span><span>;
</span><span>;  NearPt:=((ABS(pt1.h-pt2.h) &lt; tol) AND (ABS(pt1.v-pt2.v) &lt; tol));
</span><span>;
</span><span></span>         <span>MOVE.L</span>   (<span>SP</span>)<span>+</span>,<span>A0</span>                   <span>;pop return addr
</span><span></span>         <span>MOVE</span>     (<span>SP</span>)<span>+</span>,<span>D0</span>                   <span>;pop tolerance
</span><span></span>         <span>MOVE.L</span>   (<span>SP</span>)<span>+</span>,<span>D1</span>                   <span>;pop pt2
</span><span></span>         <span>MOVE.L</span>   (<span>SP</span>)<span>+</span>,<span>D2</span>                   <span>;pop pt1
</span><span></span>         <span>CLR.B</span>    (<span>SP</span>)                       <span>;assume result FALSE
</span><span></span>         <span>SUB.W</span>    <span>D1</span>,<span>D2</span>                      <span>;calc delta horiz
</span><span></span>         <span>BGE.S</span>    <span>DHPOS</span>                      <span>;continue if dh positive
</span><span></span>         <span>NEG.W</span>    <span>D2</span>                         <span>;else negate for abs value
</span><span></span><span>DHPOS</span>    <span>CMP.W</span>    <span>D0</span>,<span>D2</span>                      <span>;is ABS(dh) &lt; tol ?
</span><span></span>         <span>BGE.S</span>    <span>FALSE</span>                      <span>;no, return false
</span><span></span>         <span>SWAP</span>     <span>D1</span>                         <span>;get pt2.v
</span><span></span>         <span>SWAP</span>     <span>D2</span>                         <span>;get pt1.v
</span><span></span>         <span>SUB.W</span>    <span>D1</span>,<span>D2</span>                      <span>;calc delta vert
</span><span></span>         <span>BGE.S</span>    <span>DVPOS</span>                      <span>;continue if dv positive
</span><span></span>         <span>NEG.W</span>    <span>D2</span>                         <span>;else negate for abs value
</span><span></span><span>DVPOS</span>    <span>CMP.W</span>    <span>D0</span>,<span>D2</span>                      <span>;is ABS(dv) &lt; tol ?
</span><span></span>         <span>BGE.S</span>    <span>FALSE</span>                      <span>;no, return FALSE
</span><span></span>         <span>MOVE.B</span>   <span>#1,(SP)                    ;result := TRUE
</span><span></span><span>FALSE</span>    <span>JMP</span>      (<span>A0</span>)                       <span>;and return
</span></code></pre></td></tr></tbody></table>
</div>
</div><p><code>NearPt</code> returns true if two points are “close enough,” even if they are not truly equal. Since points use integral values, this code is not for handling floating point error, but for human imprecision. For instance, if a user was trying to close a polygon by clicking on a previous point, the code allows the polygon to be closed if the user clicks within a few pixels of an earlier point. Similarly, the mouse may slip a small distance during a double click. While this is not particularly performance critical code as it is called a relatively small number of times, it is code that is unlikely to need to change.</p>
<p>As is typical for his assembly code, the function is documented with the Pascal calling convention. This function is further documented with a mathematical definition; few functions or procedures warranted descriptive comments. Each line is commented semantically. Almost every assembly line in <code>PaintAsm.a</code> is similarly commented.</p>
<p>In contrast, <code>HVConstain</code> is a Pascal procedure. We chose it as an example because it is relatively short and self-enclosed. This procedure is used to constrain or trap an anchor while drawing to a particular direction or a 45 degree angle. For example, the user can hold down shift while drawing a rectangle to force the drawing of a square. Or, while drawing a line, force it to be parallel with the edges of the screen.</p>
<div linesno="table"><pre tabindex="0"><code data-lang="ada">	<span>PROCEDURE</span> <span>HVConstrain</span>(VAR newPt: Point);
	VAR dh,dv: <span>INTEGER</span>;
	<span>BEGIN</span>
	  <span>IF</span> shiftFlag <span>THEN</span>  <span>{</span> constrain to horiz <span>or</span> vert <span>}</span>
	    <span>BEGIN</span>
	      <span>IF</span> hConstrain <span>AND</span> vConstrain <span>THEN</span>  <span>{</span> still chosing direction <span>}</span>
	        <span>BEGIN</span>
	          dh := <span>ABS</span>(newPt.h<span>-</span>ptConstrain.h);
	          dv := <span>ABS</span>(newPt.v<span>-</span>ptConstrain.v);
	          <span>IF</span> (dh <span>&gt;</span> dv) <span>AND</span> (dh <span>&gt;</span> <span>1</span>) <span>THEN</span> vConstrain := <span>FALSE</span>;
	          <span>IF</span> (dv <span>&gt;</span> dh) <span>AND</span> (dv <span>&gt;</span> <span>1</span>) <span>THEN</span> hConstrain := <span>FALSE</span>;
	        <span>END</span>;
	      <span>IF</span> hConstrain <span>THEN</span> newPt.v := ptConstrain.v;  <span>{</span> horiz <span>}</span>
	      <span>IF</span> vConstrain <span>THEN</span> newPt.h := ptConstrain.h;  <span>{</span> vert  <span>}</span>
	    <span>END</span>;
	<span>END</span>;
</code></pre></div><p>Atkinson has a very consistent naming style for his variables and the code is usually highly readable. In contrast to his assembly code, comments are rare and terse in the Pascal code, although still focused on explaining the semantic purpose of the line.</p>
<p><code>HVConstrain</code> uses one global variable, <code>shiftFlag</code>, to track the user mode, and three global variables to store state: <code>hConstrain</code>, <code>vConstrain</code>, and <code>ptConstrain</code>. Although global variables, there is only one other procedure that accesses the latter three variables directly: <code>InitConstrain</code>. The three variables are commented as belonging to <code>HVConstrain</code>. The design allows a developer to use the variables without proper initialization or accidentally modifying them. Although this is a violation of the design principle of encapsulation, we believe this was an effective trade-off of code complexity and memory resources.</p>
<h3 id="message-loop">Message Loop</h3>
<p>MacPaint is an early event-driven program. The core of the program is:</p>
<div><pre tabindex="0"><code data-lang="ada">	REPEAT
			<span>[</span>...<span>]</span>
		    <span>IF</span> GetNextEvent(everyEvent,theEvent) <span>THEN</span> ProcessTheEvent;
			<span>[</span>...<span>]</span>
	<span>UNTIL</span> quitFlag;
</code></pre></div><p><code>GetNextEvent</code> is a Toolbox Event Manager function that fetches the next event, if it exists, from the event queue. <code>ProcessTheEvent</code> is an application procedure that is a long CASE statement that maps event locations to buttons or, more accurately rectangular areas of the screen. <code>ProcessTheEvent</code> calls other application procedures that control tool-specific modes. <code>ProcessTheEvent</code> is sufficiently low-level it has to measure the time since the last click to differentiate between single and double clicks. Since the user interface is fixed (windows cannot be moved), the code is tedious but easy to follow.</p>
<h3 id="example-straight-line-tool">Example: Straight Line Tool</h3>
<p>The Straight Line tool is an exemplar of the software design and the intermix of Pascal, assembly, and QuickDraw functionality. For the <code>StraightLine</code> procedure to be invoked, the user will have previously selected the straight line tool from the tool palette and then clicked (and held) the mouse within the content area. While in this procedure (the straight line “mode”), one end of the line will be anchored at the initial point (<code>startPt</code>) while the other end will follow the cursor until the user releases the mouse button. The mode-driven interface gives the user continuous feedback on what the eventual line will look like within the painting.</p>
<div linesnos="table"><pre tabindex="0"><code data-lang="ada">	<span>{$</span>S         <span>}</span>
	<span>PROCEDURE</span> <span>StraightLine</span>;
	VAR newPt,oldPt,startPt: Point;
	    lineTop,lineBot: <span>INTEGER</span>;
	<span>BEGIN</span>
	  JamLine;
	  PinGridMouse(startPt);
	  oldPt.h := <span>1000</span>;      <span>{</span> force first time <span>}</span>
	  REPEAT
	    PinGridMouse(newPt);
	    <span>IF</span> shiftFlag <span>THEN</span> Constrain(startPt,newPt,<span>TRUE</span>);
	    <span>IF</span> <span>NOT</span> EqualPt(newPt,oldPt) <span>THEN</span>
	      <span>BEGIN</span>
	        MainToAlt;        <span>{</span> erase old <span>}</span>
	        AltBufLine(startPt,newPt,oldPt);
	        oldPt := newPt;
	      <span>END</span>;
	  <span>UNTIL</span> <span>NOT</span> StillDown;
	<span>END</span>;
</code></pre></div><p>The first line <code>{$S      }</code> is a compiler directive stating that this procedure should live in the default main segment (for more about segments, see the section below <em>Allocation Failure and Segment Anti-Fragmentation</em>)</p>
<p><code>JamLine</code> resets some QuickDraw state using <code>PenNormal</code> and then sets the pen’s size, pattern, and mode (depending on keys being depressed) to the current palette settings.</p>
<p><code>PinGridMouse</code> sets the passed in variable to the current position of the mouse as modified by various modes (e.g. snap to grid, fat bits). Similarly, <code>Constrain</code> sets  <code>newPt</code> to a 45-degree constrained point value if the user is holding down the shift key.</p>
<p>The <code>REPEAT</code> block tests the <code>StillDown</code> condition. <code>StillDown</code> is a Toolbox Event Manager function that will return false even if the user released and then quickly pressed the mouse button again between invocations.</p>
<p>If a line exists (<code>IF NOT EqualPt</code>), the main buffer will be copied into the alt(ernate) buffer. (QuickDraw uses integral values for a <code>Point</code>’s coordinates, so <code>EqualPt</code> does not need a tolerance parameter.) <code>MainToAlt</code> calls <code>BufToBuf</code>, which is an assembly routine that includes the same <code>MOVEM</code> optimization as <code>BufToScrn</code> (see section <em>Fast Buffer to Screen Copy</em>). <code>AltBufLine</code> writes, to the alt buffer, the line from <code>startPt</code> to <code>newPt</code> using the <code>MoveTo</code> and <code>LineTo</code> QuickDraw routines. The contents from the alt buffer are then sent to the screen buffer using a boundary box that includes the <code>oldPt</code>, thus eliminating (by redrawing) any previous line sent to the screen, but also reducing the amount of written data. (<code>BandToScrn</code> also takes care to hide and show the cursor.)</p>
<p>The <code>lineTop</code> and <code>lineBot</code> variables are declared but unused. Our assumption is that part of the functionality of <code>AltBufLine</code> originally was part of the <code>StraightLine</code> as it is the only other block to use variables with the same names. The program also uses the constant <code>lineTop</code> to describe the top of the line size palette window, so the compiler must not have considered duplicate <code>lineTop</code> declarations as an error.</p>
<h2 id="interesting-algorithms-and-designs">Interesting Algorithms and Designs</h2>
<h3 id="fast-buffer-to-screen-copy">Fast Buffer to Screen Copy</h3>
<p>In an interview with the Macintosh team (Lemmon 1984), the team explains their process for optimizing code size and processing time. After arguing that code must be first made correct before being made fast, Atkinson brings up register allocation. He states:</p>
<blockquote>
<p>This little baby, the 68000, has sixteen 32-bit registers sitting there, and the way you get performance out of that is to keep them full. Keep the registers full of important stuff all the time. That’s the way you make this processor sing.</p>
</blockquote>
<p>The buffer copying code, which is performance critical, illustrates this technique.</p>
<p>MacPaint uses two off-screen buffers for rendering which are then copied to the screen buffer for display. Within the pascal code, the two buffer’s storage are declared as:</p>
<div><pre tabindex="0"><code data-lang="ada">   mainBuf:            <span>ARRAY</span><span>[</span><span>0.</span>.<span>239</span>,<span>0.</span>.<span>12</span><span>]</span> <span>OF</span> LongInt;     
   altBuf:             <span>ARRAY</span><span>[</span><span>0.</span>.<span>239</span>,<span>0.</span>.<span>12</span><span>]</span> <span>OF</span> LongInt;  
</code></pre></div><p>In Pascal, range definitions are inclusive, so each buffer contains 240 rows of 13 LongInts each. The content area is fixed at 416 pixels by 240 pixels. Since a LongInt contains 32 bits, each row stores 416 single-bit pixels.</p>
<p>While MacPaint’s user interface looks well-proportioned to the Macintosh’s display, Atkinson could have designed the content area to be larger or adjusted the design for a portrait arrangement. However, the need to keep registers full suggests the technical reason for the given layout. If we look at the <code>BufToScrn</code> assembly code:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span><span>25
</span></span><span><span>26
</span></span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm">        <span>.PROC</span> <span>BufToScrn</span>,<span>2</span>
<span>;--------------------------------------------------------
</span><span>;
</span><span>;  PROCEDURE BufToScrn(bufPtr,scrnPtr: Ptr; top,bottom: INTEGER);
</span><span>;
</span><span>;  top and bottom coords are relative to start of buffer
</span><span>;
</span><span>;  cursor has already been hidden.
</span><span>;
</span><span></span>          <span>MOVE.L</span>    (<span>SP</span>)<span>+</span>,<span>D0</span>                 <span>;POP RETURN ADDR
</span><span></span>          <span>MOVE</span>      (<span>SP</span>)<span>+</span>,<span>D1</span>                 <span>;POP BOTTOM
</span><span></span>          <span>MOVE</span>      (<span>SP</span>)<span>+</span>,<span>D2</span>                 <span>;POP TOP
</span><span></span>          <span>MOVE.L</span>    (<span>SP</span>)<span>+</span>,<span>A1</span>                 <span>;POP SCRNPTR
</span><span></span>          <span>MOVE.L</span>    (<span>SP</span>)<span>+</span>,<span>A0</span>                 <span>;POP BUFPTR
</span><span></span>          <span>MOVE.L</span>    <span>D0</span>,-(<span>SP</span>)                 <span>;PUSH RETURN ADDR
</span><span></span>          <span>MOVEM.L</span>   <span>D3-D7</span><span>/</span><span>A2-A6</span>,-(<span>SP</span>)        <span>;SAVE REGS
</span><span></span>          <span>SUB</span>       <span>D2</span>,<span>D1</span>                    <span>;CALC HEIGHT
</span><span></span>          <span>BLE.S</span>     <span>GOHOME</span>                   <span>;QUIT IF COUNT &lt;= 0
</span><span></span>          <span>MOVE</span>      <span>D1</span>,-(<span>SP</span>)                 <span>;INIT ROW COUNT
</span><span></span>          <span>MOVE</span>      <span>D2</span>,<span>D1</span>                    <span>;COPY TOP COORD
</span><span></span>          <span>MULU</span>      <span>#52,D1                   ;CALC SRC OFFSET
</span><span></span>          <span>ADD.L</span>     <span>D1</span>,<span>A0</span>                    <span>;OFFSET SRCPTR
</span><span></span>          <span>MULU</span>      <span>screenRow</span>,<span>D2</span>             <span>;CALC SCRN OFFSET
</span><span></span>          <span>ADD.L</span>     <span>D2</span>,<span>A1</span>                    <span>;OFFSET SCRNPTR
</span><span><span></span><span>NXTROW</span>    <span>MOVEM.L</span>   (<span>A0</span>),<span>D0-D7</span><span>/</span><span>A2-A6</span>         <span>;SUCK UP 13 LONGS FROM BUF
</span></span><span><span></span>          <span>MOVEM.L</span>   <span>D0-D7</span><span>/</span><span>A2-A6</span>,(<span>A1</span>)         <span>;SPIT THEM OUT TO SCREEN
</span></span><span></span>          <span>ADD</span>       <span>#52,A0                   ;BUMP SRCPTR
</span><span></span>          <span>ADD</span>       <span>screenRow</span>,<span>A1</span>             <span>;BUMP SCREENPTR
</span><span></span>          <span>SUB</span>       <span>#1,(SP)                  ;DECREMENT ROWCOUNT
</span><span></span>          <span>BNE</span>       <span>NXTROW</span>                   <span>;LOOP 240 ROWS
</span><span></span>          <span>TST</span>       (<span>SP</span>)<span>+</span>                    <span>;POP ROW COUNT
</span><span></span><span>GOHOME</span>    <span>MOVEM.L</span>   (<span>SP</span>)<span>+</span>,<span>D3-D7</span><span>/</span><span>A2-A6</span>        <span>;RESTORE REGS
</span><span></span>          <span>RTS</span>                                <span>;AND RETURN
</span></code></pre></td></tr></tbody></table>
</div>
</div><p>The <code>NXTROW</code> loop is executed 240 times with each execution copying 13 LongInts from the buffer. The Motorola 68k supports a <a href="https://www.looksgoodworkswell.com/elegance-of-macpaint-code/">“move multiple” (MOVEM) instruction that accepts up to 13 registers</a> as the source or destination. (The <code>.L</code> informs the assembler we are copying long values.) According to (Motorola 1993), a MOVEM instruction requires \(12 + 4n\) clock periods to move memory from an address stored in an A register to registers and \(8 + 8n\) clock periods to move values stored in registers to a memory location (Table 9-16). Thus, memory transfers require \(20 + 12n\) (where \(n\) is the number of registers) or 176 clock periods. In contrast, if the transfers were performed via MOVE instructions, each transfer requires 12 clock periods or 312 clock periods total (Table 9-18). By maximizing the throughput possible with MOVEM by populating all (relevant) registers, each buffer to screen transfer saves 136 clock periods.</p>
<h3 id="bucket-fill-seed-fill">Bucket Fill (Seed Fill)</h3>
<p>Bucket Fill is an algorithm that, starting from a given pixel, travels along all adjacent pixels sharing a base color and transforms those pixels to a target color. MacPaint implements a variant of this function by filling the space with a pattern, rather than just a single color. As the boundaries can be arbitrarily complex, this can be an expensive computation. In the worst-case, filling an empty screen, this requires 416 by 240 pixel checks or 99,840 checks in total. Through various tricks, Atkinson’s implementation reduces the amount of work and makes the operation feel fast.</p>
<p>(This algorithm is not used when the boundaries are known, such as painting a filled in rectangle. QuickDraw supported drawing filled in polygons directly.)</p>
<p>By 1983, several researchers had investigated and published algorithms for bucket filling. <em>SuperPaint</em>, in the mid 1970s, was likely the first implementation of the idea  (Glassner 2001); (Lieberman 1978) and (Smith 1979) represent early research papers. The MacPaint algorithm is similar to Lieberman’s algorithm as the algorithm travels along vertical and horizontal pixel paths and supports filling in with patterns as well as colors. MacPaint’s code has been optimized for the restrictions in the domain, i.e. one-bit bitmaps.</p>
<p>Within the source code, the Bucket Fill tool is called <code>SeedFill</code>. The <code>SeedFill</code> procedure contains the top-level business logic for the tool:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ada"><span>PROCEDURE</span> <span>SeedFill</span>(startPt: Point);
VAR firstBlack: <span>BOOLEAN</span>;
<span>BEGIN</span>
  firstBlack := PixelTrue(startPt.h,startPt.v,mainBits);
  CalcMask(mainBits,altBits,altBits.bounds,startPt,firstBlack,<span>FALSE</span>);

  SetPortBits(altBits);
  PenPat(thePat);
  <span>IF</span> firstBlack <span>THEN</span>
    <span>BEGIN</span>
      PenMode(patBic);
      PaintRect(altBits.bounds);
      InvertBuf(<span>@</span>altBuf);
      BufAndBuf(<span>@</span>mainBuf,<span>@</span>altBuf);
    <span>END</span>
  <span>ELSE</span>
    <span>BEGIN</span>
      <span>PenMode</span><span>(</span><span>notPatBic</span><span>)</span>;
      PaintRect(altBits.bounds);
      BufOrBuf(<span>@</span>mainBuf,<span>@</span>altBuf);
    <span>END</span>;

  PenNormal;
  AltToScrn;
  clickTime := TickCount;
  GetMouse(clickLoc);
  LocalToGlobal(clickLoc);
  killDouble := <span>TRUE</span>;
<span>END</span>;
</code></pre></td></tr></tbody></table>
</div>
</div><p>Based on the position of the mouse click (<code>startPt</code>) and the current state of the image (<code>mainBits</code>), the procedure determines if the clicked pixel is black (<code>firstBlack</code> is true) or white. The assembly <code>CalcMask</code> procedure travels the image in <code>mainBits</code>, from the <code>startPt</code>, and computes a mask for the eventual pattern, storing this in <code>altBits</code>.</p>
<p>After the boundaries for the fill are determined by <code>CalcMask</code>, the graphics port is set to the alternate buffer and the pattern is set to the currently selected pattern. The pattern transfer mode (<code>patBic</code> or <code>notPatBic</code>) is set to effectively erase the destinations content. The pattern is then filled within the bounding box, inverting the color depending on if the object’s boundary is a black or white pixel. Afterwards, the alternate buffer is sent to the screen and the procedures performs some cleanup. If the result is not what the user wishes, they can undo the action, whereupon the screen switches to the other buffer which contains the content prior to the fill.</p>
<p><code>CalcMask</code> contains the complicated parts of the program. <code>CalcMask</code> is also shared with the Lasso tool, which similarly needs to match arbitrary shapes.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span><span>83
</span><span>84
</span><span>85
</span><span>86
</span><span>87
</span><span>88
</span><span>89
</span><span>90
</span><span>91
</span><span>92
</span><span>93
</span><span>94
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ada"><span>PROCEDURE</span> <span>CalcMask</span>(<span>*</span> srcBits,dstBits: BitMap;
                     limitRect: Rect;
                     firstPt: Point;
                     firstBlack: BOOLEAN;
                     invertDst: BOOLEAN <span>*</span>);

<span>{</span> given data <span>in</span> srcBits, compute mask into dstBits <span>}</span>
<span>{</span> WARNING: srcBits <span>and</span> dstBits must be the wired<span>-</span><span>in</span> size <span>}</span>

LABEL <span>9</span>;

CONST row  <span>=</span> <span>52</span>;         <span>{</span> rowbytes <span>}</span>
      queueSize <span>=</span> <span>400</span>;   <span>{</span> how many entries big <span>}</span>

VAR aQueue,bQueue: <span>ARRAY</span><span>[</span><span>0.</span>.queueSize<span>]</span> <span>OF</span> QueueEntry;
    readPtr:   <span>Entry</span><span>Ptr</span>;
    writePtr:  <span>Entry</span><span>Ptr</span>;
    donePtr:   <span>Entry</span><span>Ptr</span>;
    dstStart,dstLimit,srcOffset: LongInt;
    firstByte,firstMask: <span>INTEGER</span>;
    firstPtr: <span>^</span><span>INTEGER</span>;
    dh,dv:    <span>INTEGER</span>;
    leftByte,rightByte:     <span>INTEGER</span>;
    wordsWide,height: <span>INTEGER</span>;

<span>BEGIN</span>
  ZeroBuf(dstBits.baseAddr);

  <span>IF</span> <span>NOT</span> firstBlack <span>THEN</span> InvertBuf(srcBits.baseAddr);

  dh := <span>-</span>dstBits.bounds.left;
  dv := <span>-</span>dstBits.bounds.top;
  OffsetRect(limitRect,dh,dv);  <span>{</span> make global <span>}</span>
  firstPt.h := firstPt.h <span>+</span> dh;
  firstPt.v := firstPt.v <span>+</span> dv;

  limitRect.left := BitAnd(limitRect.left,<span>$</span>FFF0);       <span>{</span> round down to word <span>}</span>
  limitRect.right := BitAnd(limitRect.right<span>+</span><span>15</span>,<span>$</span>FFF0);  <span>{</span> round up to word <span>}</span>

  leftByte  := limitRect.left DIV <span>8</span>;
  rightByte := limitRect.right DIV <span>8</span>;

  dstStart := ORD(dstBits.baseAddr) <span>+</span> limitRect.top <span>*</span> row <span>+</span> leftByte;
  dstLimit := ORD(dstBits.baseAddr) <span>+</span> limitRect.bottom <span>*</span> row <span>+</span> leftByte;
  srcOffset := ORD(srcBits.BaseAddr) <span>-</span> ORD(dstBits.baseAddr);

  firstByte := <span>2</span><span>*</span>(firstPt.h DIV <span>16</span>);
  firstPtr := Pointer(ORD(srcBits.baseAddr) <span>+</span> firstPt.v <span>*</span> row <span>+</span> firstByte);

  firstMask := <span>0</span>;
  BitSet(<span>@</span>firstMask,BitAnd(firstPt.h,<span>15</span>));
  firstMask := VertSeed(firstMask,firstPtr<span>^</span>);
  <span>IF</span> firstMask <span>=</span> <span>0</span> <span>THEN</span> <span>GOTO</span> <span>9</span>;

  <span>{</span> Prime <span>&#34;aQueue&#34;</span> <span>with</span> seed <span>at</span> first point <span>}</span>

  writePtr := <span>@</span>aQueue;
  <span>WITH</span> writePtr<span>^</span> <span>DO</span>
    <span>BEGIN</span>
      addr := ORD(firstPtr)<span>-</span>srcOffset;
      bump := <span>2</span>;
      twoH := firstByte <span>-</span> leftByte;
      mask := firstMask;
    <span>END</span>;
  writePtr := Pointer(ORD(writePtr) <span>+</span> SizeOf(queueEntry));

 <span>{</span> Ping pong between the two Queues.  Read each <span>entry</span> <span>from</span> <span>one</span> <span>queue</span> <span>}</span>
 <span>{</span> <span>and</span> <span>push</span> <span>all</span> <span>the</span> <span>untried</span> <span>ones</span> <span>it</span> <span>spawns</span> <span>onto</span> <span>the</span> <span>other</span> <span>queue</span>.     <span>}</span>

  <span>REPEAT</span>

    <span>donePtr</span> := <span>writePtr</span>;
    readPtr := <span>@</span>aQueue;                         <span>{</span> read from queue A <span>}</span>
    writePtr := <span>@</span>bQueue;                        <span>{</span> push into queue B <span>}</span>
    MaskIt(dstStart,dstLimit,srcOffset,
           rightByte<span>-</span>leftByte,row,readPtr,donePtr,writePtr);

    donePtr := writePtr;
    readPtr := <span>@</span>bQueue;                         <span>{</span> read from queue B <span>}</span>
    writePtr := <span>@</span>aQueue;                        <span>{</span> push into queue A <span>}</span>
    MaskIt(dstStart,dstLimit,srcOffset,
           rightByte<span>-</span>leftByte,row,readPtr,donePtr,writePtr);

  <span>UNTIL</span> writePtr <span>=</span> <span>@</span>aQueue;                     <span>{</span> <span>until</span> aQueue <span>is</span> empty <span>}</span>

<span>9</span>: <span>IF</span> <span>NOT</span> firstBlack <span>THEN</span> InvertBuf(srcBits.baseAddr);   <span>{</span> restore src <span>}</span>

  <span>IF</span> invertDst <span>THEN</span>
    <span>BEGIN</span>
      height := limitRect.bottom <span>-</span> limitRect.top;
      wordsWide := (limitRect.right <span>-</span> limitRect.left) DIV <span>16</span>;
      InvertChunk(dstStart,wordsWide,height);
    <span>END</span>;
<span>END</span>;
</code></pre></td></tr></tbody></table>
</div>
</div><p>At a high-level, <code>CalcMask</code> is very similar to (Lieberman 1978)’s fill algorithm. The initial point, the seed, is expanded left and right until a boundary is found, and then the program checks up and down. Lieberman’s version uses a queue, while Atkinson’s uses two arrays as queues. Because a queue can be completed consumed before ‘ping pong’ing to the other queue, iteration and appending items are simpler than using a single queue.</p>
<p>The <code>MaskIt</code> procedure scans right and left from an initial position, and then seeks to expand up and down the image. Based on the movement direction, the algorithm is looking for boundary conditions. Two lower-level algorithms implement much of the bit-level logic: <code>HSeed</code> and <code>VSeed</code>. Both are “local functions,” they are effectively inlined functions within the assembly rather than functions callable (and requiring a stack frame) from Pascal. We will focus on <code>VSeed</code> because it is simpler.</p>
<p>Conceptually, <code>VSeed</code> is trying to extrude the seed up (or down, the directions are equivalent) through the “grill” of the data. If a slice of the seed can flow into an open space of the grill, it will then also flow right and left within the grill to the edge or to a boundary. For clarity of visualization, in the table below we use a 3-bit word size. The one bits in the mask represent the set bits of the target color being “pushed” into the data. The data may be full of the target color, in which case we push into the entire “word”. However, we might encounter a wall, such as “data empty”, in which case we are unable to push to any location, resulting in zero. In the case of a hook, we flow both up and to the open left.</p>
<table>
<thead>
<tr>
<th></th>
<th>Open</th>
<th>Blocked</th>
<th>Same</th>
<th>Offset</th>
<th>Hook Left</th>
<th>Hook Right</th>
</tr>
</thead>
<tbody>
<tr>
<td>Data</td>
<td>111</td>
<td>000</td>
<td>010</td>
<td>100</td>
<td>110</td>
<td>011</td>
</tr>
<tr>
<td>Mask</td>
<td>010</td>
<td>010</td>
<td>010</td>
<td>010</td>
<td>010</td>
<td>010</td>
</tr>
<tr>
<td>Result</td>
<td>111</td>
<td>000</td>
<td>010</td>
<td>000</td>
<td>110</td>
<td>011</td>
</tr>
</tbody>
</table>
<p>The assembly code implementation:</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="asm"><span>;---------------------------------------------------
</span><span>;
</span><span>;  LOCAL FUNCTION VSeed(mask,data: INTEGER ): INTEGER;
</span><span>;
</span><span>;  ENTER WITH:  D4 MASK
</span><span>;               D1 DATA
</span><span>;               D3 ALL ONES
</span><span>;
</span><span>;  RETURNS      D6 SEED
</span><span>;
</span><span>;  CLOBBERS     D0,D1,D2
</span><span>;
</span><span></span><span>VSEED</span>   <span>MOVE</span>    <span>D4</span>,<span>D6</span>                           <span>;COPY MASK
</span><span></span>        <span>AND</span>     <span>D1</span>,<span>D6</span>                           <span>;SEED := MASK AND DATA
</span><span></span>        <span>BNE.S</span>   <span>NOTZERO</span>                         <span>;CONTINUE IF RESULT NONZERO
</span><span></span>        <span>RTS</span>                                     <span>;ELSE RETURN ZERO
</span><span></span>
<span>NOTZERO</span> <span>CMP</span>     <span>D3</span>,<span>D1</span>                           <span>;IS DATA ALL ONES ?
</span><span></span>        <span>BNE.S</span>   <span>NOTONES</span>                         <span>;NO, CONTINUE
</span><span></span>        <span>MOVE</span>    <span>D1</span>,<span>D6</span>                           <span>;YES, RESULT = ONES
</span><span></span>        <span>RTS</span>                                     <span>;AND QUIT
</span><span></span>
<span>NOTONES</span> <span>CMP</span>     <span>D1</span>,<span>D6</span>                           <span>;IS SEED = DATA ?
</span><span></span>        <span>BNE.S</span>   <span>RIGHTLP</span>                         <span>;NO, CONTINUE
</span><span></span>        <span>RTS</span>                                     <span>;YES WE&#39;RE DONE
</span><span></span>
<span>RIGHTLP</span> <span>MOVE</span>    <span>D6</span>,<span>D2</span>                           <span>;REMEMBER OLDSEED
</span><span></span>        <span>MOVE</span>    <span>D6</span>,<span>D0</span>                           <span>;COPY SEED
</span><span></span>        <span>LSR</span>     <span>#1,D0                           ;SHIFT SEED RIGHT
</span><span></span>        <span>OR</span>      <span>D0</span>,<span>D6</span>                           <span>;LEAK SEED TO RIGHT
</span><span></span>        <span>AND</span>     <span>D1</span>,<span>D6</span>                           <span>;AND WITH DATA TO LIMIT
</span><span></span>        <span>CMP</span>     <span>D6</span>,<span>D2</span>                           <span>;IS SEED SAME AS OLD SEED ?
</span><span></span>        <span>BNE</span>     <span>RIGHTLP</span>                         <span>;NO TRY SOME MORE
</span><span></span>
<span>LEFTLP</span>  <span>MOVE</span>    <span>D6</span>,<span>D2</span>                           <span>;REMEMBER OLDSEED
</span><span></span>        <span>MOVE</span>    <span>D6</span>,<span>D0</span>                           <span>;COPY SEED
</span><span></span>        <span>ADD</span>     <span>D0</span>,<span>D0</span>                           <span>;SHIFT SEED LEFT
</span><span></span>        <span>OR</span>      <span>D0</span>,<span>D6</span>                           <span>;LEAK SEED TO LEFT
</span><span></span>        <span>AND</span>     <span>D1</span>,<span>D6</span>                           <span>;AND WITH DATA TO LIMIT
</span><span></span>        <span>CMP</span>     <span>D6</span>,<span>D2</span>                           <span>;IS SEED SAME AS OLD SEED ?
</span><span></span>        <span>BNE</span>     <span>LEFTLP</span>                          <span>;NO TRY SOME MORE
</span><span></span>        <span>RTS</span>                                     <span>;AND RETURN
</span></code></pre></td></tr></tbody></table>
</div>
</div><p>The first half of <code>VSeed</code> is equivalent to the pseudo-code:</p>
<pre tabindex="0"><code>switch (mask bitand data)
	case 0: return 0
	case -1: return -1
	case mask /* mask = data */: return mask
</code></pre><p>The last half performs iterative bit-twiddling to flow the seed into adjoining spaces of data.</p>
<p>The test of the seed against the earlier data also demonstrates the value of ‘playing the odds.’ Although boundaries may be arbitrary, they are often regular in shape – e.g. a boundary being a vertical line. Expensive computations can be reused if a relatively simple check is made first. Atkinson relates this technique to a similar domain in (Lemmons 1984, pg 76):</p>
<blockquote>
<p>So play your odds. People draw characters in OR mode a whole lot, and OR mode is about twice as fast as the other modes, so 95 percent of all characters are drawn in OR mode. Statistical measuring of the use of the thing allows you to get much more performance on your average throughput than you can if you don’t go back and measure.”</p>
</blockquote>
<p>In cases where the fillable area is open, or edges are regular, the algorithm can effectively process a 32 pixels at a time with much higher throughput than checking each individual pixel.</p>
<h3 id="fatbits">FatBits</h3>
<p>One of the “Goodies” – additional MacPaint features selectable via the menubar – FatBits is a mode that magnifies the image. When in this mode, a small picture-in-picture provides the artist context of the full image while the rest of the content area expands to make it easier to manipulate individual pixels (below). Originally MacPaint only allowed the Pencil tool to be used in FatBits mode, but Atkinson extended support for all the tools (Young 1985, pg 315).</p>
<figure><img src="https://ztoz.blog/posts/macpaint-source-code/MacPaint-1.5-WithContentFatBits.png" alt="Screenshot of MacPaint 1.5 with magnified content" width="100%"/><figcaption>
            <p>MacPaint 1.5 in FatBits Mode (1985)</p>
        </figcaption>
</figure>

<p>As suggested by the title of an early manual <em>Inside MacPaint: Sailing through the Sea of FatBits on a Single-Pixel Raft</em>, FatBits was a killer feature for MacPaint. For Susan Kare, Apple’s in-house graphic designer, the mode accelerated the development of Macintosh’s small bitmap icons where every pixel mattered.</p>
<p>Marketing pushed to rename “FatBits” “Magnify”, but Atkinson won the argument, arguing that the name gave the program some personality (Young 1985).</p>
<p>FatBits is restricted to a single zoom level and, within the code, is handled via many special-cased changes to the input and output. The single zoom level restriction was due to the limited hardware; an arbitrary scaling factor would have required too much CPU (Atkinson 2010, pg 10). The contemporary PostScript program supported arbitrary scaling via a transformation matrix but operated with looser performance requirements and greater hardware capabilities.</p>
<p>While an important and impactful feature, <code>IF fatFlag</code> is called 36 times in the Pascal code. A cross-cutting feature, it requires special handling when mapping input coordinates, screen rendering, and buffer manipulation. Thus, we consider it an expensive feature because it violates the open-closed design principle — existing code needed to be modified to support it and future tools need special-cased code to support the mode. Functional composition is used to reduce the impact in certain code paths (e.g. <code>GetFatMouse</code> calls <code>GetMouse</code> and internally performs any necessary conversion), but there are too few abstractions overall to keep the cross-cutting nature of the feature constrained.</p>
<h3 id="allocation-failure-and-segment-anti-fragmentation">Allocation Failure and Segment Anti-Fragmentation</h3>
<p>As a way to work within the limited memory of the Macintosh, developers could divide their application code into multiple segments. A segment could be unloaded when not needed, for example, printing routines (Inside-Vol2 1985, pg II-55). In the Pascal code, the compiler directive <code>{$S SegPrint }</code> places the procedure or function into the <code>SegPrint</code> segment. An empty name (e.g, <code>{$S       }</code> denotes the default, main segment.) In the assembly code, <code>.SEG</code> is used.</p>
<p>Other than the main segment, MacPaint has the following eleven segments: SegBrush, SegFlip, SegHelp, SegInit, SegPage, SetPaste, SegPatEdit, SegPrint, SegScrap, SegSym, and SegUpdate.</p>
<p>Within the main event loop, each of these segments is unloaded after each loop. Per (Inside-Vol2 1985, II-57), this is recommended practice as unloading a segment that is not loaded is a no-op and presumably cheap.</p>
<p>Although a program may have sufficient free space to work, the layout of allocated memory might not leave a block large enough for an allocation to succeed. MacPaint’s design was robust to a certain level of memory fragmentation.</p>
<p>Within the main event loop, the code tests for <code>heapJam</code> to be set and, if it is, calls the <code>MaxMem</code> system routine. This routine compacts and frees unused memory, acting as a kind of garbage collector and compactor. Once fragmentation is reduced, the next memory allocation is likely to succeed.</p>
<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="ada">    <span>IF</span> heapJam <span>THEN</span>
      <span>BEGIN</span>
        tempLong := MaxMem(tempLong);   <span>{</span> purge heap <span>}</span>
        heapJam := <span>FALSE</span>;
      <span>END</span>;
</code></pre></td></tr></tbody></table>
</div>
</div><p>MacPaint’s implementation largely avoids dynamic memory allocation, but there are eight calls to <code>NewHandle</code> (which allocates memory). Of these, only <code>AllocMask</code> tests the return value of <code>NewHandle</code> to verify it is non-Nil and sets the <code>heapJam</code> global variable if it is. The reason why <code>AllocMask</code> is the only path that checks for a memory allocation failure may be due to its unusually large allocation request. <code>AllocMask</code> asks for 12,480 bytes to store a mask which is nearly 10% of the Macintosh’s 128k memory in total. Other than some calls that are used for initialization, the next largest called to <code>NewHandle</code> is 3,024 bytes and the rest below 100 bytes. As these other calls are much less likely to fail, it is perhaps acceptable that they lacked similar error detection.</p>
<p>All callers of <code>AllocMask</code> check the return status and return early if the call failed. Although the user would need to retry their operation, the program would not suffer a crash due to the failed memory allocation.</p>
<p>Atkinson recounted this general technique in (Atkinson 2010, pg 15):</p>
<blockquote>
<p>When code segments were loaded, you needed some code to do this job and that job. They would be loaded sort of at the first available place. But if you needed another code segment and this one would go out, it might leave a hole there that wasn’t quite big enough for the next one that you needed but now you had sort of what we called memory fragmentation. That even though you had enough memory total, you couldn’t load the pieces of code that you needed. And I developed a little technique for this which is setting a flag at the top of the event loop, saying that we failed and as I went to load code segments, if I failed to load one then I would beep and let it go back to the top of the event loop without doing anything. And it would say uh-oh, there’s a failure here. Whereas if I succeeded and got to the right part of the code and got everything in, then I would set the flag to say we succeeded. The net result was the user would go to draw something and it would beep and they would try it again and it would work, and they’d shrug and they’d never know that they just avoided crashing the program.</p>
</blockquote>
<h2 id="alternative-paths-and-competitors">Alternative Paths and Competitors</h2>
<p>As a counter-factual, if MacPaint had not shipped with the Macintosh, Apple may instead have shipped a vector drawing program. The Lisa shipped with LisaDraw, a vector drawing program which was the basis for MacDraw. However, MacDraw was likely not available in time for the January launch, as the September/October issue of MacWorld states MacDraw is “soon-to-be-released”. Since MacPaint was finished several months prior to the Macintosh’s release date, we are unaware of any historical “Plan B”.</p>
<p>Competively, there were several digital painting programs released in parallel. The year prior to the release of MacPaint, 1983, saw the release of the first Microsoft Mouse and two drawing programs that used it: Microsoft’s <em>Doodle</em> program (below) and Doug Wolfgram’s <em>Mouse Draw</em>. Notably, both programs supported color but the user interfaces can be charitably treated as primitive.</p>
<figure><a href="https://winworldpc.com/product/microsoft-mouse/1x"><img src="https://ztoz.blog/posts/macpaint-source-code/Microsoft-Doodle.png" alt="Screenshot of Microsoft Doodle showing lack of tool and pattern palettes"/></a><figcaption>
            <p>Microsoft Doodle (1983)</p>
        </figcaption>
</figure>

<p>After the release of MacPaint and the Macintosh at the beginning of 1984, competitors quickly adopted the user interface. Mouse Systems purchased the rights to <em>Mouse Draw</em>, modified the interface to be similar to MacPaint, and then resold it as <em>PC Paint 1.0</em> along with their own mice. ZSoft Corporation released their own <em>PC Paintbrush</em>, also with an interface modeled after MacPaint. Both programs were DOS-based and supported color. A year later, Microsoft updated their mouse and dropped <em>Doodle</em>, replacing it with a licensed but rebranded version of <em>PC Paintbrush</em>.</p>
<p>Thus, the demand for painting programs, tied to sales of mice, was recognized independently of the Macintosh and multiple vendors were attempting to fill that need. That said, within the consumer market, MacPaint seems to be the first “great” painting program and highly influential.</p>
<p>Technologically, was MacPaint novel? The site <a href="http://macpaint.org/history.html">macpaint.org claims</a> the following aspects of MacPaint were novel:</p>
<blockquote>
<p>The marching ants around a selection; the palette of drawing tools; the (rudimentary) ability to zoom in; the spray can; the paint bucket; copying and pasting images between programs; just moving the mouse and drawing: we take these for granted in the 21st century, but Macpaint did them first, with only 128k of RAM available.</p>
</blockquote>
<p>While we concede the marching ants and maybe the spray can were novel to MacPaint, MacPaint has historical antecedents in research and commercial systems. As a contrary example, <em>SuperPaint</em>, which displayed its first picture in 1973, supported color, and featured a tool palette and the following functions: Paint, Shrink 2x, Expand 2x, Move, Copy, Store and Load, Text, Video In, Make Brush, Draw Lines, Gridding, Area Fill, and various color table animation tools (Shoup 2001). Originally aimed at television graphics use cases, this research system was rapidly supplanted by commercial offerings. For example, the Quantel <em>Paintbox</em>, a dedicated computer for compositing broadcast video and graphics, was first released in 1981 and was quickly adopted by the major TV networks.</p>
<p>Although the Macintosh was opening up new markets for consumer and small-scale digital production, broadcasting and commercial computer animation firms had been operating for several years. In Alvy Ray Smith’s article “Digital paint systems: an anecdotal and historical overview” (Smith 2001), he focuses on “systems” rather than “programs” and eliminates 1-bit and 3-bit systems from his article’s scope because of their lack of influence. MacPaint is thus eliminated both due to its limited functionality and its 1-bit nature. Is this restriction fair?</p>
<p>Certainly, the professional market was developing on its own, without regard for the hobbyist market. The Macintosh was not capable until the late 80s to support the monied use cases which required color and higher-performance. However, consumer technology eventually caught up and the existence of consumer-level tools provided a path for artists to “graduate” to professional-grade tools. Photoshop is an example of this progression.</p>
<p>The Knoll brothers, who developed Photoshop in 1988, were both exposed to the original Macintosh when their <a href="https://web.archive.org/web/20070626182822/http://www.storyphoto.com/multimedia/multimedia_photoshop.html">father bought one</a> in mid-1984. Thomas Knoll used a Macintosh Plus in 1987 to assist in his PhD work, which also came with MacPaint. The Plus did not support gray scale, so Thomas started working on image manipulation routines. John, who was working at Industrial Lights and Magic at the time, saw connections between what Thomas was developing and the features in the Pixar Image Computer. Combining the use case insights from professional animators with a graphical user interface led to Photoshop.</p>
<p>Photoshop was widely adopted both by professionals but also by aspiring students and hobbyists. It represents a joining of two pathways, one from the personal, consumer world, and the other from the research and commercial world.</p>
<p><strong>Impact of Source Code?</strong></p>
<p>In 1984, event-driven programming was a relatively new paradigm in software design. A possible additional influence of MacPaint was the program being used to train developers on how to develop an event-driven program and how to program for the mouse. Atkinson believes Apple gave the source to some developers [Atkinson 2010, pg 8], although we have not seen evidence for this elsewhere. (At least among external developers; the Macintosh team certainly had access to the code and there are three programmers attested in MyTools.a, including Andy Hertzfeld.) <em>Inside Macintosh</em>, the official developer documentation, includes an Example Program that demonstrates basic window management and handling. Comparing the Example Program to MacPaint, we find there are similarities in naming and structure, which suggests MacPaint may have been a reference when writing the documentation.</p>
<h2 id="post-release">Post Release</h2>
<p>MacPaint saw two more releases in 1984, the first as a free update with System Software 1.1 and the second with the release of the Macintosh 512K model. In 1985, System Software was updated to version 2.0 and included version 1.5 of MacPaint.</p>
<p>Under pressure from third-party developers for less competition from system shipped  software, in 1987 Apple spun off their internally built applications to the Claris company, including MacPaint. Claris released version 2.0 of MacPaint in 1988 which featured tear off palettes, support for multiple documents open at once, the magic eraser, and <a href="https://macgui.com/usenet/?group=14&amp;id=10855">other features</a>.</p>
<p>The release seemed also perfunctory, as evidenced by the developer working on the 2.0 release to <a href="https://www.folklore.org/Evolution_of_a_classic.html">fill time and the lack of any product specs</a>. By April 1988, as listed by <a href="https://archive.org/details/MacWorld_8804_April_1988/page/n53/mode/2up">Macworld</a>, MacPaint was in competition with an array of graphics programs, including <em>PixelPaint</em>, <em>Modern Artist</em>, <em>Aldus Freehand</em>, and <em>Adobe Illustrator</em>. Furthermore, the Macintosh II had been announced in 1987 with support for 8-bit color, limiting the appeal of a monochrome only application. No more versions were officially released and Claris discontinued the product in 1998.</p>
<h2 id="conclusion">Conclusion</h2>
<p>(Knuth Shustek, 2021) has this to say about MacPaint and QuickDraw’s source code:</p>
<blockquote>
<p>They are brilliant programs, beautifully organized and structured, that are a treat to read and deserve to be annotated and studied.</p>
</blockquote>
<p>This article does not cover QuickDraw, but do we agree with these claims as they relate to MacPaint?</p>
<p><strong>Is it brilliant?</strong></p>
<p>It is uncontroversial that MacPaint strongly influenced the user interfaces of painting and drawing programs. Contemporary competitors changed their UIs to be similar to MacPaint and much of interface design live on in Photoshop, Illustrator, and other programs. Many of the tool modifiers, such as the shift key to constrain boxes and lines, became informally standardized. Although MacPaint was not the earliest painting program and did not invent all it is often credited with, it was the first “great” implementation, was widely available, and helped cement Macintosh’s reputation as a computer for creative people.</p>
<p><strong>Is it beautifully organized and structured? A treat to read?</strong></p>
<p>This is subjective, so we’ll examine certain aspects of the code.</p>
<p>If we look at the physical sequencing of functions and procedures within the code, we find that the first five callables within the <code>PaintAsm.a</code> file are:</p>
<ol>
<li>EjectReset (eject disks)</li>
<li>PixelTrue (return state of specific pixel within bitmap)</li>
<li>Monkey (test for reliability testing mechanism)</li>
<li>Stretch2x (re-samples buffer for higher resolution printing)</li>
<li>MySetItemStyle (type coercion utility)</li>
</ol>
<p>Within the Pascal <code>MacPaint.p</code> file, after a long list of EXTERNAL declarations, we find:</p>
<ol>
<li>KeyIsDown (function to test if a specific key is pressed)</li>
<li>GetFatMouse (get mouse position in fat bit coordinates)</li>
<li>GridPoint (modify point to a grid or truncated position)</li>
<li>GetGridMouse (get mouse position in grid coordinates)</li>
<li>PinGridMouse (clamp grid mouse position within rectangle)</li>
</ol>
<p>We reject the idea that the physical organization of the code is “beautifully organized”; if someone wanted to understand the core functionality and design of the program, they should not read it linearly. However, we suspect this was not the foundation of Knuth and Shustek’s claim, as outside of very short or a few literate programs, programs are not read linearly.</p>
<p>Readers will often start with the entry point to the program. In this case, the reader will find a significant number of lines dedicated to <code>UnloadSeg</code> and <code>MoreMaster</code>, both efforts to mitigate the constrained memory. Outside of that, the master block contains sequence of <code>Init...</code> calls, followed by the main loop. The naming and structure facilitate distinguishing between the business logic and the system interfaces. So, we find that the main block is not necessarily beautiful, since it interleaves both kinds of logic, but the organization and structure are praise-worthy.</p>
<p>Within a procedure or function, Pascal mandates some aspects of the ordering, but we find that the code does not fight language idioms. In general, in terms of code style, we find it is easy to read and follow. Anecdotally, while we were writing this article, another programmer saw the Pascal code on our laptop screen (main method) and noted that it appeared clean. (They also thought it looked “old” and certainly procedural code has a different visual appearance than functional or OOP code.)</p>
<p><strong>Does it deserve to be annotated and studied?</strong></p>
<p>There are three primary audiences for a historical source code artifact: 1) historians, interested in the context and impact of an artifact, 2) software practitioners, who can see it as a way to improve their craft, and 3) students, who may be introduced to techniques, practices, and paradigms and use it as training material.</p>
<p>For historians, MacPaint exhibits the engineering trade-offs necessary to bring forth an application within the limitations of the Macintosh hardware, as well as an example of how a graphical program was expected to be designed by someone who also wrote one of the largest, most foundational libraries. Historians of algorithms can place the use of multiple buffers and the seed fill algorithm into the published history of graphics algorithms and how that informs the interrelation of commercial and academic research.</p>
<p>Unless a practitioner is working within extreme resource limits or is working on legacy devices, we suspect the MacPaint source code has less to offer them. User interfaces are now asynchronous and callback based, languages are far richer than Pascal in their support of abstractions and encapsulation, and few use cases are restricted to 1-bit displays.</p>
<p>However, we see many advantages as an artifact of study for students of computer science. First, MacPaint is not a toy, but a full-featured program, yet is quite small so there is little to distract the student. MacPaint’s domain — painting — is readily understood and does not require students to understand unfamiliar domains such as finance or physics. Students are expected to understand multiple languages. Pascal and M68k assembly test a student’s ability to learn a new language while neither is particularly difficult nor obscure.</p>
<p>Although MacPaint runs in emulation and students can easily play with it, a disadvantage is that students would have difficulty modifying the source code and running their own versions. MacPaint doesn’t even run on late series Macintoshes as it was too tightly bound to the hardware. That said, there are many potential assignments that do not require modifying and running the source code:</p>
<ul>
<li>Code Explanation. A student prepares a presentation or document explaining how a certain tool function is implemented or how a data structure is used. More advanced students might calculate the computational complexity of an algorithm.</li>
<li>Design Alternative. A student shows how a certain feature might be re-designed with features from a different programming language or within a certain framework. Compare and contrast qualitatively and quantitatively.</li>
<li>Develop Tooling. Pascal is relatively easy to parse and Apple’s documentation on <em>Lisa Pascal</em> features detailed railroad diagrams for the syntax. Students could write tooling, similar to <code>cflow</code>, to analyze the program. (This tooling be reused to analyze the <em>Lisa</em> source code.)</li>
</ul>
<p>So, yes, MacPaint deserves to be studied.</p>
<h2 id="special-recognition">Special Recognition</h2>
<p>Releasing the source code was surprisingly <a href="https://web.archive.org/web/20100721233205/http://www.businessweek.com/technology/ByteOfTheApple/blog/archives/2010/07/apple_donates_macpaint_source_code_to_computer_history_museum.html">long and difficult</a>. I thank those involved for their dogged persistence that gave me the opportunity to study this source code.</p>
<h2 id="references">References</h2>
<p>(Atkinson 2004) Atkinson, Bill, and Andy Hertzfeld. 2004. MacPaint oral history with Bill Atkinson and Andy Hertzfeld Interview by Grady Booch. Oral history collection. <a href="https://www.computerhistory.org/collections/catalog/102658007">https://www.computerhistory.org/collections/catalog/102658007</a>.</p>
<p>(Atkinson 2010) Atkinson, Bill, and Andy Hertzfeld. 2010. MacPaint Interview and Demonstration with Bill Atkinson and Andy Herzfeld. <a href="https://www.computerhistory.org/collections/catalog/102743021">https://www.computerhistory.org/collections/catalog/102743021</a>.</p>
<p>(Glassner 2001) Glassner, Andrew. 2001. “Fill ’er up! [Graphics Filling Algorithms].” IEEE Computer Graphics and Applications 21 (1): 78–85.</p>
<p>(Inside-Vol2 1985) Apple Computer, Inc. 1985. Inside Macintosh. Vol. 2. Addison-Wesley Publishing Company, Inc. <a href="https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_I_1985.pdf">https://vintageapple.org/inside_o/pdf/Inside_Macintosh_Volume_I_1985.pdf</a>.</p>
<p>(Knuth Shustek, 2021) Knuth, Donald, and Len Shustek. 2021. “Let’s Not Dumb down the History of Computer Science.” Communications of the ACM 64 (2): 33–35. <a href="https://doi.org/10.1145/3442377">https://doi.org/10.1145/3442377</a>.</p>
<p>(Lemmons 1984) Lemmons, Phil. 1984. “An Interview: The Macintosh Design Team.” BYTE, February 1984.</p>
<p>(Lieberman 1978) Lieberman, Henry. 1978. How to color in a coloring book. In Proceedings of the 5th annual conference on Computer graphics and interactive techniques (SIGGRAPH ‘78). Association for Computing Machinery, New York, NY, USA, 111–116. <a href="https://doi.org/10.1145/800248.807380">https://doi.org/10.1145/800248.807380</a></p>
<p>(Shoup 2001) Shoup, Richard. 2001. “SuperPaint: An Early Frame Buffer Graphics System.” IEEE Annals of the History of Computing 23 (2): 32–37.</p>
<p>(Smith 1979) Smith, Alvy Ray. 1979. Tint fill. SIGGRAPH Comput. Graph. 13, 2 (August 1979), 276–283. <a href="https://doi.org/10.1145/965103.807456">https://doi.org/10.1145/965103.807456</a></p>
<p>(Smith 2001) Smith, Alvy Ray. 2001. “Digital Paint Systems: An Anecdotal and Historical Overview.” IEEE Annals of the History of Computing 23 (2): 4–30.</p>
<p>(Young 1985) Young, Jeffrey S. 1985. Inside MacPaint: Sailing through the Sea of FatBits on a Single-Pixel Raft. Microsoft Press.</p>
</article>

        </div></div>
  </body>
</html>
