<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scd31.com/posts/extreme-server-side-rendering">Original</a>
    <h1>EXTREME SERVER SIDE RENDERING</h1>
    
    <div id="readability-page-1" class="page"><div><h2>What is (Normal) Server Side Rendering?</h2><section><p>Before we get into extreme server side rendering (XSSR), we have to talk about normal server side rendering (SSR). This comes in two flavours, which I&#39;m calling old-school and new-school.</p><p>Old-school SSR involves having a server which uses some logic to create the HTML of the web page on-the-fly. For example, you might hit <code>/users/39</code>, and it might give you the details of user 39. These details might be from a database, or they might come from somewhere else. The important part is there&#39;s no corresponding <code>39.html</code> on the disk. The HTML is created dynamically by the back-end server. On the front-end side, there&#39;s no JavaScript or other logic required to render the page. As a result, once the page is loaded, there&#39;s no ability for it to be dynamic.</p><p>New-school SSR is similar to old-school SSR, but it does involve a bit of front-end JavaScript logic. Generally, the way it&#39;s implemented is that when the user will interacts with the web page, the JS will make a request to the back-end. Then, the back-end will return some HTML, and the JS front-end will insert that HTML somewhere into the page. This allows us to have dynamic pages, at the cost of having to maintain some front-end logic.</p><p><i>Wouldn&#39;t it be nice if there was a better way?</i></p></section><h2>Very slow HTTP servers</h2><section><p>As a quick aside, let&#39;s talk about HTTP servers! When you make an HTTP request, what actually happens? Well, the server returns a bunch of ASCII text corresponding to some headers and the actual HTML content itself. This is sent one character at a time. Well, there&#39;s some buffering, but we can ignore this as it&#39;s not relevant to our purpose.</p><p>What happens if we send the HTML slowly, like at human rates? Below is a video where I use netcat to be a human HTTP server, and I have a browser connect to me. Netcat is line-buffered, meaning that each line is sent to the browser when I press enter.</p>
<p>You&#39;ll notice that the page renders on-the-fly as new HTML comes in. This is awesome, and it even works across both browsers I tested (Firefox and Chromium). Furthermore, even CSS works, so you could conceivably constantly move elements around (or hide existing elements and then add new ones). <b>So, if we keep the HTTP connection open indefinitely, we can dynamically update the page from the server, without any JavaScript!</b></p></section><h2>Getting User Input</h2><section><p>Updating the page from the server is cool, but it would be nice to accept user input as well. The normal way to do this without JS is a <code>&lt;form&gt;</code> element. Unfortunately, this requires a page load, which defeats the point of XSSR! If we&#39;re willing to deal with reloading the page, normal old-school SSR would work fine. My friend <a href="https://dj-chase.com/">DJ Chase</a> pointed out a pretty cool trick, though:</p><pre><span>  &lt;</span><span>iframe </span><span>style</span><span>=&#34;display: none;&#34; </span><span>name</span><span>=&#34;</span><span>transFrame</span><span>&#34; </span><span>id</span><span>=&#34;</span><span>transFrame</span><span>&#34;&gt;&lt;/</span><span>iframe</span><span>&gt;
</span><span>  &lt;</span><span>form </span><span>target</span><span>=&#34;</span><span>transFrame</span><span>&#34; </span><span>method</span><span>=&#34;</span><span>POST</span><span>&#34; </span><span>action</span><span>=&#34;</span><span>/action</span><span>&#34;&gt;
</span><span>    &lt;</span><span>input </span><span>type</span><span>=&#34;</span><span>hidden</span><span>&#34; </span><span>name</span><span>=&#34;</span><span>uuid</span><span>&#34; </span><span>value</span><span>=&#34;</span><span>USER-UUID-GOES-HERE</span><span>&#34; /&gt;
</span><span>    &lt;</span><span>input </span><span>type</span><span>=&#34;</span><span>Submit</span><span>&#34; </span><span>value</span><span>=&#34;&#34; /&gt;
</span><span>  &lt;/</span><span>form</span><span>&gt;
</span></pre>
<p>Basically, you can point a form at an iframe, which will cause that iframe to be reloaded on form submission instead of the main page. If you hide that iframe, then user input is completely seamless!</p><p>Also worth pointing out is the <code>uuid</code> value, which can be generated by the server on initial page load. This is used to tie events to the original page (to prevent mixing up users when responding to events).</p></section><h2>Building something with XSSR</h2><section><p>Okay, so in theory we have everything we need to build a responsive web app. What should we build?</p><p>Why not a <a href="https://flappybird.scd31.com/">Flappy Bird clone</a>? (Source code is available <a href="https://gitlab.scd31.com/stephen/streaming-http-flappy-bird">here</a>.)</p><p>There&#39;s a few things to point out here. First of all, notice that we have everything a &#34;real&#34; Flappy Bird clone needs. We have dynamic text for the score, the pipes move as expected, and clicking causes the bird to jump. The latter is accomplished using the iframe trick above, combined with a hidden button that covers the entire screen. This allows you to click anywhere - in fact, after clicking once to select the invisible button, spacebar and enter both work to continue clicking.</p><p>Second of all, notice that the page never stops loading. This is because the physics engine runs entirely in the back-end, and new CSS is constantly being sent to update the position of the pipes, the bird, and the content of the score text at 60 FPS. Again, no front-end JS is required - turn it off and notice the site works exactly the same! You can also try <code>curl</code>-ing the page to see the infinite CSS in all its glory.</p></section><h2>This isn&#39;t as bad as you might think</h2><h3>Performance</h3><section><p>Performance, both client-side and server-side, is actually not awful. I will concede that the site does get laggy after a few minutes on both Firefox and Chromium. That said, we <i>are</i> streaming at 60 FPS, and for a page that updates e.g. only after user interaction, this might not even be a practical issue.</p><p>Server-side is even better. On my simple Rust server implementation, I can run about 500 games at the same time per core on a relatively old server in my homelab. This is significantly better than even a moderately-complex Ruby on Rails app! (I say this with love - I love Ruby on Rails). If you lowered the framerate, or used XSSR for a page that only updates after user interaction, performance could be increased significantly.</p></section><h3>Bandwidth</h3><section><p>Bandwidth usage is... entirely reasonable! One game takes about 20KiB/s of bandwidth to run. For perspective, this means it would take about 49 seconds of gaming to use the same bandwidth as loading a 1MB JavaScript application (which unfortunately is on the smaller side these days). Again, cutting down the framerate would improve this significantly.</p></section><h3>Latency</h3><section><p><i>oh no.</i></p><p>So, depending on where you are in the world, that demo might have majorly sucked. This is because every time you click, it requires a round trip to the server - both to update the physics engine on the server with your action, and then to return the new position of the bird to your browser. This is almost entirely dominated by the on-the-wire transit time. As a result, the demo is extremely playable if you&#39;re in Atlantic Canada (near-ish my house, where the server lives), and gradually gets more laggy the further you get. Lower down the East Coast, the latency is noticeable, but correctable as a human (you just need to click a little earlier). On the West Coast, it&#39;s distracting, and on the other side of the world, it&#39;s unplayable. If you were unimpressed by the demo, and you live far away from me, I highly recommend cloning the <a href="https://gitlab.scd31.com/stephen/streaming-http-flappy-bird">source code</a> and running it locally.</p><p>But all the cool kids are into putting things on the edge, right? So uhh just do that I guess, and then it doesn&#39;t matter!</p></section><h2>Taking Down Fedi</h2><section><p>I was pretty proud of my demo, so I posted it on my Fediverse server (running Pleroma). Shortly after, it went down and stopped allowing posts to load. After about 20 minutes or so, it came back up, and I got a burst of notifications telling me people had reposted my post. Then it went down again! This cycle repeated 3 or 4 times before things stabilized. I can only assume that other Pleroma servers that saw the post went through similar rolling blackouts.</p><p>Turns out that some applications really don&#39;t like sites that keep the connection open indefinitely, slowly trickling data through! My friend <a href="https://gitlab.computer.surgery/olivia">Olivia</a> went through Pleroma&#39;s source code and found that it was an issue when generating link previews, which happens server-side. I ended up logging a security bug, since this is a DoS attack vector, which was quickly patched.</p></section><h2>Future Work</h2><section><p>I think it would be funny to build a React fork that runs entirely server-side. The virtual DOM could be diff&#39;d, and the diffs could be transmitted to the front-end via XSSR (again, no front-end JS required). I don&#39;t think this is very practical but it would be cool.</p><p>As a slightly more useful idea, I wonder how XSSR works on older devices. I assume it works reasonably well - slower internet may mean that dynamic rendering on-the-fly was an intentional feature. This makes me think you could write a proxy service that uses a headless browser instance to render web pages into a DOM. This DOM could be transmitted to the front-end via XSSR. I think this would let you use modern web pages on older devices that don&#39;t support JavaScript at all.</p></section></div></div>
  </body>
</html>
