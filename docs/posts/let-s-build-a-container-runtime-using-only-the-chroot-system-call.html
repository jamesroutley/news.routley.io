<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://earthly.dev/blog/chroot/">Original</a>
    <h1>Let’s build a container runtime using only the chroot system call</h1>
    
    <div id="readability-page-1" class="page"><div><div>
<p><img width="320px" src="https://amedee.me/blog/generated/assets/images/chroot/7290-800-cf8e33b4d.png" srcset="/blog/generated/assets/images/chroot/7290-400-cf8e33b4d.png 400w, /blog/generated/assets/images/chroot/7290-600-cf8e33b4d.png 600w, /blog/generated/assets/images/chroot/7290-800-cf8e33b4d.png 800w, /blog/generated/assets/images/chroot/7290-1000-cf8e33b4d.png 1000w"/></p>
<figcaption>
Every explanation is a simplification.
</figcaption>
</div>
<p>There are many ways to understand how containers work, but most useful explanations are actually simplifications.</p>
<p>Many people have settled on explaining containers by calling them ‘light-weight VMs’ and they are light-weight because they ‘share the kernel with the host’. This is useful, but it simplifies a lot away. What is a ‘light-weight VM’? What does sharing the kernel mean?</p>
<p>Others will tell you containers are about namespaces and specific kernel visibility tweaks. This is also a helpful explanation because namespaces partition visibility, so that running containers can’t see other things on the same machine.</p>
<p>But for me, containers are just chrooted processes. Sure, they are more than that: Containers have a nice developer experience, an open-source foundation, and a whole ecosystem of cloud-native companies pushing them forward. But, let me show you why I think <code>chroot</code><a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> is the key.</p>
<p><strong>So, let’s build a container runtime using only the chroot system call.</strong> Doing so, we can learn a little about <code>chroot</code>, a little about container runtimes, and it will also be fun!</p>
<h2 id="the-goal">The Goal<a href="#the-goal" title=""><span></span><i></i></a></h2>
<p>By the end, I’ll have something that looks like docker run, called <code>chrun</code>, where you can pull docker images:</p>
<div id="cb1" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>&gt;</span> <span>chrun</span> pull redis</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span>Pulling</span> image redis</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span>export</span> <span>image</span> 16b87aa63c8f3a1e14a50feb94cba39eaa5d19bec64d90ff76c3ded058ad09c8</span></code></pre></div>
<p>And then run them:</p>
<div id="cb2" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>&gt;</span> <span>chrun</span> run redis <span>&#34;/usr/local/bin/redis-server&#34;</span></span></code></pre></div>
<pre><code>Running /usr/local/bin/redis-server in /tmp/_assets_redis_tar_gz4234401501
4360:C 31 Oct 2022 16:07:57.253 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
4360:C 31 Oct 2022 16:07:57.253 # Redis version=7.0.5, bits=64, 
4360:C 31 Oct 2022 16:07:57.253 # Warning: no config file specified, using the 
4360:M 31 Oct 2022 16:07:57.256 * Increased maximum number of open files to 
4360:M 31 Oct 2022 16:07:57.256 * monotonic clock: POSIX clock_gettime
                _._                                                  
           _.-``__ &#39;&#39;-._                                             
      _.-``    `.  `_.  &#39;&#39;-._           Redis 7.0.5 (00000000/0) 64 bit
  .-`` .-` `.  ` `\/    _.,_ &#39;&#39;-._                                  
 (    &#39;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
 |    `-._   `._    /     _.-&#39;    |     PID: 4360
  `-._    `-._  `-./  _.-&#39;    _.-&#39;                                   
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|                                  
 |    `-._`-._        _.-&#39;_.-&#39;    |           https://redis.io       
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;                                   
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|                                  
 |    `-._`-._        _.-&#39;_.-&#39;    |                                  
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;                                   
      `-._    `-.__.-&#39;    _.-&#39;                                       
          `-._        _.-&#39;                                           
              `-.__.-&#39;                                               

4360:M 31 Oct 2022 16:07:57.260 # Server initialized
4360:M 31 Oct 2022 16:07:57.265 * Ready to accept connections</code></pre>
<p>And it will do this using chroot. But first, some background.</p>
<h2 id="history-of-chroot">History of <code>chroot</code><a href="#history-of-chroot" title=""><span></span><i></i></a></h2>
<div>
<p><picture><source srcset="/blog/generated/assets/images/chroot/5730-1000-8a7b05e99.webp 1000w, /blog/generated/assets/images/chroot/5730-1200-8a7b05e99.webp 1200w" type="image/webp"/><source srcset="/blog/generated/assets/images/chroot/5730-1000-8a7b05e99.png 1000w, /blog/generated/assets/images/chroot/5730-1200-8a7b05e99.png 1200w" type="image/png"/><img src="https://amedee.me/blog/generated/assets/images/chroot/5730-800-8a7b05e99.png"/></picture></p>
<figcaption>
To the <del>Observatory</del> Unix Source
</figcaption>
</div>
<p><code>chroot</code> probably doesn’t get a lot of mention now that containers exist, but it’s a Unix system call. This means it’s a way to request something from the operating system kernel. It is also a utility program, so it’s easy to call from the shell.</p>

<p>All it does is change the root directory (<code>/</code>) to a new value. That’s all chrooting does. It just changes what <code>/</code> means. That sounds simple, but file paths are at the heart of how Unix works, so you can do a lot with this call.</p>
<p>Chroot is a much older system call than the ones modern container runtimes use, which means, in theory, the <code>chrun</code> shown above could run on a much older linux kernel. But how far back into Linux history could we go?</p>
<p>Actually, we can go back to way before the creation of Linux. chroot first appeared in 1979 for Unix v7.</p>
<p>(I know this because Diomidis Spinellis put together this excellent <a href="https://github.com/dspinellis/unix-history-repo" target="_blank">github repository</a> that recreates the history of Unix from the earliest available source to today’s modern variations<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. The history recreated in this repo stretches back to 1970 and includes the original <a href="https://en.wikipedia.org/wiki/PDP-7#/media/File:Pdp7-oslo-2005.jpeg" target="_blank">PDP-7</a> assembly code of the first iteration of Unix.)</p>
<p>It came along with chdir ( the system call equivalent of <code>cd</code> ) and looked like this:</p>
<div id="cb5" data-caption="usr/sys/sys/sys4.c (UNIX V7)"><pre><span>usr/sys/sys/sys4.c (UNIX V7)</span><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>chdir()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>{</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    chdirec(&amp;u.u_cdir);</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>}</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>chroot()</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>{</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>    <span>if</span> (suser())</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>        chdirec(&amp;u.u_rdir);</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>}</span></code></pre></div>
<figcaption>
chroot and chdir - Source: <a href="https://github.com/dspinellis/unix-history-repo/blob/b69600335168d140ef119fcc1eba3265faed094e/usr/sys/sys/sys4.c#L199" target="_blank">Research-V7 tag of Unix History Repo</a>
</figcaption>
<div id="cb6" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span>struct</span> user</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span>{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>    <span>...</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span>struct</span> inode *u_cdir<span>;</span>        <span>/*</span> pointer to inode of current directory */</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>    <span>struct</span> inode *u_rdir<span>;</span>        <span>/*</span> root directory of current process */</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>    <span>...</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<figcaption>
<code>&amp;u</code> is a reference to the <a href="https://github.com/earthly/website/blob/0b2db0fd5b48f4a950d1cfc6ba69c1da83d1ae64/blog/_posts/2022-10-20-chroot.md#L101" target="_blank">current users struct</a>, which holds <code>u_rdir</code> and <code>u_cdir</code>.
</figcaption>
<p>So, a user on a Unix system has a current directory and root directory and chroot is a way to change the root value (<code>u_rdir</code>) in the same way <code>cd</code> changes the current working directory (<code>u_cdir</code>). In Unix V7 that’s basically all the <code>chroot</code> code I see, except for the syscall list and some userland code so that you can call <code>chroot</code> from your shell:</p>
<div id="cb7" data-caption="usr/src/libc/sys/chroot.s (UNIX V7)"><pre><span>usr/src/libc/sys/chroot.s (UNIX V7)</span><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>/ C library -- chroot</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>/ error = chroot(string);</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>.globl    _chroot</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>.globl    cerror</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>.chroot = <span>61.</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>_chroot:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    mov    r5,-(sp)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>    mov    sp,r5</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>    mov    <span>4</span>(r5),<span>0</span><span>f</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>    sys    <span>0</span>; <span>9</span><span>f</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>    bec    <span>1</span><span>f</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>    jmp    cerror</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a><span>1</span>:</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>    clr    r0</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>    mov    (sp)+,r5</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>    rts    pc</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>.data</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span>9</span>:</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a>    sys    .chroot; <span>0</span>:..</span></code></pre></div>
<figcaption>
chroot.s in Unix V7 - Source: <a href="https://github.com/dspinellis/unix-history-repo/blob/b69600335168d140ef119fcc1eba3265faed094e/usr/src/libc/sys/chroot.s#L5" target="_blank">Research-V7 tag of Unix History Repo</a>
</figcaption>
<p>So chroot goes way back, back into the 70s, and while the implementation has probably changed over the years, semantically it still matches the description found in the UNIX V7 Manual:</p>
<blockquote>
<p>Chroot sets the root directory, the starting point for path names beginning with <code>/</code>. The call is restricted to the super-user.</p>
</blockquote>
<p>Ok, history lesson over. Let’s start building things.</p>
<h2 id="using-chroot-directly">Using <code>chroot</code> Directly<a href="#using-chroot-directly" title=""><span></span><i></i></a></h2>
<p>Let’s start with the command-line and work towards our docker run clone.</p>
<p>The most straightforward docker run is hello-world:</p>
<div id="cb8" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span>&gt;</span> <span>docker</span> run hello-world</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span>Hello</span> from Docker!</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span>This</span> message shows that your installation appears to be working correctly.</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span>To</span> generate this message, Docker took the following steps:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a> <span>1.</span> The Docker client contacted the Docker daemon.</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a> <span>2.</span> The Docker daemon pulled the <span>&#34;hello-world&#34;</span> image from the Docker Hub.</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span>(</span><span>amd64</span><span>)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a> <span>3.</span> The Docker daemon created a new container from that image which runs the</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>    <span>executable</span> that produces the output you are currently reading.</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a> <span>4.</span> The Docker daemon streamed that output to the Docker client, which sent it</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    <span>to</span> your terminal.</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a><span>...</span></span></code></pre></div>
<p>To recreate run this hello-world in <code>chroot jail</code><a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> is relatively straightforward.</p>
<h2 id="chroot-hello-world"><code>chroot</code> Hello World<a href="#chroot-hello-world" title=""><span></span><i></i></a></h2>
<p>At the command line, I can setup the hello-world in a changed root like so:</p>
<div id="cb9" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span>&gt;</span> <span>mkdir</span> /testroot</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span>&gt;</span> <span>cp</span> hello /testroot</span></code></pre></div>
<p>Then run it:</p>
<div id="cb10" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span>&gt;</span> <span>chroot</span>  /testroot /hello</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span>Hello</span> from Docker!</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span>This</span> message shows that your installation appears to be working correctly.</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span>To</span> generate this message, Docker took the following steps:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a> <span>1.</span> The Docker client contacted the Docker daemon.</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a> <span>2.</span> The Docker daemon pulled the <span>&#34;hello-world&#34;</span> image from the Docker Hub.</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>    <span>(</span><span>amd64</span><span>)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a> <span>3.</span> The Docker daemon created a new container from that image which runs the</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span>executable</span> that produces the output you are currently reading.</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a> <span>4.</span> The Docker daemon streamed that output to the Docker client, which sent it</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>    <span>to</span> your terminal.</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a><span>To</span> try something more ambitious, you can run an Ubuntu container with:</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a> $ <span>docker</span> run -it ubuntu bash</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true"></a><span>Share</span> images, automate workflows, and more with a free Docker ID:</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true"></a> <span>https</span>://hub.docker.com/</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true"></a><span>For</span> more examples and ideas, visit:</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true"></a> <span>https</span>://docs.docker.com/get-started/</span></code></pre></div>
<section id="the-root-of-the-matter">
<h2>The Root of the Matter</h2>
<p><code>chroot</code> only works as a root user, so assume from here on out everything is being done as root on a Linux machine.</p>
<p>If you try as a non-root user, you will get something like this:</p>
<div id="cb11" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span>&gt;</span> <span>chroot</span> /testroot /hello</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span>chroot</span>: cannot change root directory to <span>&#39;/testroot&#39;</span>: Operation not permitted</span></code></pre></div>
</section>
<p>We can also do this from go, making the system call directly:</p>
<div id="cb12" data-caption="chrun.go"><pre><span>chrun.go</span><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span>package</span> main</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span>import</span> (</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    <span>&#34;os&#34;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>    <span>&#34;os/exec&#34;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>    <span>&#34;syscall&#34;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a><span>func</span> main() <span>{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>    <span>cmd</span> := exec.Command(<span>&#34;/hello&#34;</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    <span>syscall.Chroot</span>(<span>&#34;/testroot&#34;</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>    <span>cmd.Stdin</span> = os.Stdin</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>    <span>cmd.Stdout</span> = os.Stdout</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>    <span>cmd.Stderr</span> = os.Stderr</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>    <span>cmd.Run</span>()</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>And the output is the same:</p>
<div id="cb13" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span>&gt;</span> <span>go</span> run go-change-root.go </span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span>Hello</span> from Docker!</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span>This</span> message shows that your installation appears to be working correctly.</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span>...</span></span></code></pre></div>
<p>That hello process runs with a filesystem rooted to <code>/testroot</code>. So there is nothing in the filesystem it can see besides itself.</p>
<p>I could verify that by running a shell inside it and poking around. However, when you change the root, the command passed is relative to the new root, so running <code>/bin/sh</code> will fail.</p>
<div id="cb14" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span>&gt;</span> <span>chroot</span> /testroot /bin/sh</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span>chroot</span>: /bin/sh: No such file or directory</span></code></pre></div>
<p>I could <code>cp</code> <code>/bin/sh</code> into <code>/testroot</code>, but <code>sh</code> dynamically links in libc and probably other stuff. Those file pointers won’t point to anything in our new root so it won’t work. This is also why you can’t shell into the hello-world image with <code>docker run</code>:</p>
<div id="cb15" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span>&gt;</span> <span>docker</span> run -it hello-world /bin/sh</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span>exec</span>: <span>&#34;/bin/sh&#34;</span>: stat /bin/sh: no such file or directory: unknown.</span></code></pre></div>
<p>Predictably, you can only shell into an image with a shell (and supporting userspace dependencies) inside it. So I’m going to be using <code>redis:latest</code> today:</p>
<div id="cb16" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span>&gt;</span> <span>docker</span> run -it redis /bin/sh</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span>&gt;</span> <span>cd</span> /</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span>&gt;</span> <span>ls</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span>bin</span>  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a><span>sbin</span>  srv  sys  tmp  usr  var</span></code></pre></div>
<p>Now let’s try to chroot into this redis image. But to do that, I first need to get the file-system out of the image so I can pass it to <code>chroot</code>.</p>

<p>To extract file-system from the image, the first thing I’ll try is to grab the image and extract it:</p>
<div id="cb17" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span>docker</span> save redis -o redisImage.tar</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span>mkdir</span> redis</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span>cd</span> redis <span>&amp;&amp;</span> <span>tar</span> -mxvf ../redisImage.tar </span></code></pre></div>
<p>I can then look inside it:</p>
<div id="cb18" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span>redis</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>├── <span>131d224a301217b1d881f2464837d310dc8e0bf701d049fc30fb9eabddd98cbc</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>│   ├── <span>VERSION</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>│   ├── <span>json</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>│   └── <span>layer.tar</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>├── <span>2279e9cb00a8a268cb01a1ccd1b7c0a01dc6b9ec619a7877dda2ca81e7409428</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>│   ├── <span>VERSION</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>│   ├── <span>json</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>│   └── <span>layer.tar</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>├── <span>2d0405b8f23157bc9f45cadc12b8b7ff23446dfe968bfa7473cb78ec2444d198</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>│   ├── <span>VERSION</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>│   ├── <span>json</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>│   └── <span>layer.tar</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>├── <span>770413d3495f9ba555e345d5c5397580a61cc64d9a945135b4b2235eed19d07b</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>│   ├── <span>VERSION</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>│   ├── <span>json</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>│   └── <span>layer.tar</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>├── <span>beb3916dbc72988060eaa0ba9ba119c76eb1c07db1c18ea53d3ca4f40a03c436</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>│   ├── <span>VERSION</span></span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>│   ├── <span>json</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true"></a>│   └── <span>layer.tar</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true"></a>├── <span>c2342258f8ca7ab5af86e82df6e9ade908a949216679667b0f39b59bcd38c4e9.json</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true"></a>├── <span>f7b46deebf614151dce2888bcb81e312da2ac791230b02688a5dbab1dee7ea91</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true"></a>│   ├── <span>VERSION</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true"></a>│   ├── <span>json</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true"></a>│   └── <span>layer.tar</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true"></a>├── <span>manifest.json</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true"></a>└── <span>repositories</span></span></code></pre></div>
<p>I’m on the right track, but this is not exactly what I wanted. Each <code>layer.tar</code> is the union file-system changes for that image layer. To build the completed file structure I would need to extract each of these and combine them in the right order.</p>
<p>Thankfully, I can just ask docker to do that for us with <code>docker export</code>.</p>
<div id="cb19" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span>&gt;</span> <span>docker</span> export <span>$(</span><span>docker</span> create redis<span>)</span> -o redis.tar.gz</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span>&gt;</span> <span>mkdir</span> redis <span>&amp;&amp;</span> <span>cd</span> redis</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span>&gt;</span> <span>tar</span> --no-same-owner --no-same-permissions --owner=0 --group=0 <span>\</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span>-mxf</span> ../redis.tar.gz</span></code></pre></div>
<p>Then I end up with the extracted redis file structure:</p>
<div id="cb20" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span>./redis</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>├── <span>bin</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>├── <span>boot</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>├── <span>data</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>├── <span>dev</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>├── <span>etc</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>├── <span>home</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>├── <span>lib</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>├── <span>lib64</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>├── <span>media</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>├── <span>mnt</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>├── <span>opt</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>├── <span>proc</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>├── <span>root</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a>├── <span>run</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a>├── <span>sbin</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a>├── <span>sys</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>├── <span>tmp</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>├── <span>usr</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>└── <span>var</span></span></code></pre></div>
<p>And so if I wrap that <code>docker export</code> up into a bash script, I can grab the file system for any image on docker hub, turning any Linux container image into a tar file.</p>
<div id="cb21" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span>./pull</span> <span>&#34;redis&#34;</span>                </span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span>Pulling</span> image redis</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span>export</span> <span>image</span> <span>c20f5ecac2f9c49521b32433ffc6abeade950e77592805b0fc61fea00d6e32f5</span></span></code></pre></div>
<figcaption>
Pull the file-system from an image. ( <a href="https://github.com/adamgordonbell/chroot-containers/blob/main/pull" target="_blank">source</a>)
</figcaption>
<p>From there, my trusty rusty <code>chroot</code> command works much like my <code>docker run -it redis /bin/sh</code> from a couple of steps ago:</p>
<div id="cb22" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span>&gt;</span> <span>chroot</span> ./redis /bin/sh</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a><span>&gt;</span> <span>ls</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a><span>bin</span>  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a> <span>sbin</span>  srv  sys  tmp  usr  var</span></code></pre></div>
<h3 id="its-just-a-process">It’s Just a Process<a href="#its-just-a-process" title=""><span></span><i></i></a></h3>
<p><img width="260px" src="https://amedee.me/blog/generated/assets/images/chroot/6560-800-5a95e7059.png" srcset="/blog/generated/assets/images/chroot/6560-400-5a95e7059.png 400w, /blog/generated/assets/images/chroot/6560-600-5a95e7059.png 600w, /blog/generated/assets/images/chroot/6560-800-5a95e7059.png 800w, /blog/generated/assets/images/chroot/6560-1000-5a95e7059.png 1000w"/></p>
<p>Here is why this is interesting from a learning perspective:</p>
<p>When I run <code>docker run ..</code> something happens – an image is turned into a container and started up. It’s not really a VM, but if you shell inside and look around, it seems like one. But now, with chroot at hand, you can see what ’not really a VM means: It’s just a process!</p>
<p>Namespaces mean when you start a container, you can’t see it in your process list, and cgroups mean that the process can have CPU and memory limits placed on it, but really, at a conceptual level, it’s just a process running with a different file-system root. Really containers are just a fancier way to chroot something!</p>
<p>Ok, let’s keep going.</p>
<h2 id="chrun-time">ChRun Time<a href="#chrun-time" title=""><span></span><i></i></a></h2>
<p>Another thing you may have noticed about containers is that they are ephemeral and relatively isolated. I can run N containers from one image and they will each be unique. Modern container runtimes use a union file-system ( like overlayfs ) for this but I get close to that with just temp directories.</p>
<p>Here’s my plan. When <code>chrun pull &lt;imagename&gt;</code> is called, I grab a tar of the image and store it somewhere. Then each time <code>chrun run &lt;imagename&gt;</code> is called, I’ll do the following:</p>
<ul>
<li>Create a temporary directory</li>
<li>Extract <code>&lt;imagename&gt;.tar.gz</code> into it</li>
<li>Change root into that directory</li>
<li>On exit, delete the directory</li>
</ul>
<p>It’s looks like this:</p>
<div id="cb23" data-caption="chrun.go"><pre><span>chrun.go</span><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span>func</span> main() {</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    tar := fmt.Sprintf(<span>&#34;./assets/%s.tar.gz&#34;</span>, os.Args[<span>2</span>])</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    cmd := os.Args[<span>3</span>]</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>    dir := createTempDir(tar)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>    <span>defer</span> os.RemoveAll(dir)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    must(unTar(tar, dir))</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    chroot(dir, cmd)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>}</span></code></pre></div>
<p>First, I create a temp directory:</p>
<div id="cb24" data-caption="chrun.go"><pre><span>chrun.go</span><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span>func</span> createTempDir(name <span>string</span>) <span>string</span> {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>    <span>var</span> nonAlphanumericRegex = regexp.MustCompile(<span>`[^a-zA-Z0-9 ]+`</span>)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    prefix := nonAlphanumericRegex.ReplaceAllString(name, <span>&#34;_&#34;</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    dir, err := ioutil.TempDir(<span>&#34;&#34;</span>, prefix)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>    <span>if</span> err != <span>nil</span> {</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>        log.Fatal(err)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>    }</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>    <span>return</span> dir</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>Then I untar things:</p>
<div id="cb25" data-caption="chrun.go"><pre><span>chrun.go</span><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span>func</span> unTar(source <span>string</span>, dst <span>string</span>) <span>error</span> {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>    r, err := os.Open(source)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>    <span>if</span> err != <span>nil</span> {</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>        <span>return</span> err</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>    }</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>    <span>defer</span> r.Close()</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>    ctx := context.Background()</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>    <span>return</span> extract.Archive(ctx, r, dst, <span>nil</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>}</span></code></pre></div>
<p>And then <code>chroot</code>, and we’re off:</p>
<div id="cb26" data-caption="chrun.go"><pre><span>chrun.go</span><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span>func</span> chroot(root <span>string</span>, call <span>string</span>) {</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>    fmt.Printf(<span>&#34;Running %s in %s</span><span>\n</span><span>&#34;</span>, call, root)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>    cmd := exec.Command(call)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>    must(syscall.Chroot(root))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>    cmd.Stdin = os.Stdin</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>    cmd.Stdout = os.Stdout</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>    cmd.Stderr = os.Stderr</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>    must(cmd.Run())</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>}</span></code></pre></div>
<p>( There are actually a couple more bits to it, but they are uninteresting. Entire file in <a href="https://github.com/adamgordonbell/chroot-containers" target="_blank">this repo</a>. )</p>
<p>And with that, I can do things like start up a redis client and server and have them talk to each other:</p>
<div id="cb27" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span>&gt;</span> <span>./chrun</span> pull redis</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span>Pulling</span> image redis</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a><span>export</span> <span>image</span> 16b87aa63c8f3a1e14a50feb94cba39eaa5d19bec64d90ff76c3ded058ad09c8</span></code></pre></div>
<figcaption>
<code>chrun</code> pulls an image from docker hub and builds a tar archive it. (<code>docker export</code> does the heavy lifting)
</figcaption>
<div id="cb28" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span>&gt;</span> <span>chrun</span> run redis <span>&#34;/usr/local/bin/redis-server&#34;</span></span></code></pre></div>
<pre><code>Running /usr/local/bin/redis-server in /tmp/_assets_redis_tar_gz4234401501
4360:C 31 Oct 2022 16:07:57.253 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
4360:C 31 Oct 2022 16:07:57.253 # Redis version=7.0.5, bits=64, 
4360:C 31 Oct 2022 16:07:57.253 # Warning: no config file specified, using the 
4360:M 31 Oct 2022 16:07:57.256 * Increased maximum number of open files to 10032 (it was originally set to 1024).
4360:M 31 Oct 2022 16:07:57.256 * monotonic clock: POSIX clock_gettime
                _._                                                  
           _.-``__ &#39;&#39;-._                                             
      _.-``    `.  `_.  &#39;&#39;-._           Redis 7.0.5 (00000000/0) 64 bit
  .-`` .-` `.  ` `\/    _.,_ &#39;&#39;-._                                  
 (    &#39;      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
 |    `-._   `._    /     _.-&#39;    |     PID: 4360
  `-._    `-._  `-./  _.-&#39;    _.-&#39;                                   
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|                                  
 |    `-._`-._        _.-&#39;_.-&#39;    |           https://redis.io       
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;                                   
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|                                  
 |    `-._`-._        _.-&#39;_.-&#39;    |                                  
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;                                   
      `-._    `-.__.-&#39;    _.-&#39;                                       
          `-._        _.-&#39;                                           
              `-.__.-&#39;                                               

4360:M 31 Oct 2022 16:07:57.260 # Server initialized
4360:M 31 Oct 2022 16:07:57.265 * Ready to accept connections</code></pre>
<figcaption>
<code>chrun</code> run extracts the tar to a temp dir, changes root to it, and then starts the passed command. Afterward, it cleans up the temp dir.
</figcaption>
<div id="cb30" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span>&gt;</span> <span>chrun</span> run redis <span>&#34;/usr/local/bin/redis-cli&#34;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a><span>Running</span> /usr/local/bin/redis-cli in /tmp/_assets_redis_tar_gz1366317376</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a><span>127.0.0.1</span>:<span>6379&gt;</span> SET mykey <span>&#34;Hello\nWorld&#34;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a><span>OK</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a><span>127.0.0.1</span>:<span>6379&gt;</span> GET mykey</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a><span>&#34;Hello\nWorld&#34;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a><span>127.0.0.1</span>:<span>6379&gt;</span> </span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a><span>127.0.0.1</span>:<span>6379&gt;</span> exit</span></code></pre></div>
<figcaption>
Because of the temp dirs, you can start many processes from one image, and each gets its own file-system. They can talk to each other over the network.
</figcaption>
<p>And after I stop them, the temp dir is removed, and they disappear. <strong>So there you go, ‘containers’ using only chroot.</strong></p>
<p>The source is <a href="https://github.com/adamgordonbell/chroot-containers/" target="_blank">on github</a>.</p>
<h2 id="who-cares">Who Cares?<a href="#who-cares" title=""><span></span><i></i></a></h2>
<p>So who cares? I mean, many container runtimes already exist (runC, containerd, gVisor, StarStruck) and they’re all better than this one in almost every way<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>Well, it could just be me, but understanding that a container is very similar to a process that has been chrooted – so it’s running against the same operating system but with a different root – that understanding helps ground my knowledge of what containers are. It makes them seem less magical<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a> and lets me think about new possibilities<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>And so containers are great. Namespaces, cgroups v2, runC, overlayfs, the OCI image format, and everything else in this space is impressive engineering. It’s incredible forward progress we can all take advantage of. But it’s not magic. It’s just a long series of progressive refinements ( and a bit of marketing ) on top of a feature that has been in Unix since … let me check:</p>
<div id="cb31" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span>&gt;</span> <span>git</span> log usr/src/libc/sys/chroot.s <span>|</span> <span>head</span> -5</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span>commit</span> a0b0c390d5f37060bf64b63bba8e9f0a1dceb337</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a><span>Author</span>: Dennis Ritchie <span>&lt;</span>dmr@research.uucp<span>&gt;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a><span>Date</span>:   Wed Jan 10 14:59:44 1979 -0500</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>    <span>Research</span> V7 development</span></code></pre></div>
<div>
<p>
While you’re here:
</p>
<p>
<a href="https://earthly.dev/">Earthly</a> is the effortless CI/CD framework. </p>
</div>
<!-- markdownlint-disable MD046 -->

</div></div>
  </body>
</html>
