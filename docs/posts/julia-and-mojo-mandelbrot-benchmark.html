<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://discourse.julialang.org/t/julia-mojo-mandelbrot-benchmark/103638">Original</a>
    <h1>Julia and Mojo Mandelbrot Benchmark</h1>
    
    <div id="readability-page-1" class="page"><div itemscope="" itemtype="http://schema.org/DiscussionForumPosting">
      <meta itemprop="headline" content="Julia &amp; Mojo Mandelbrot Benchmark"/>
        <meta itemprop="articleSection" content="General Usage"/>
      <meta itemprop="keywords" content=""/>
      

          <div id="post_1">
            
            <div itemprop="articleBody">
              <p>For those of you who aren’t aware, the Mojo SDK was recently released, so I thought I would take the opportunity to start benchmarking some Julia code against Mojo. As a first test, I am calculating the Mandelbrot set using the <a href="https://docs.modular.com/mojo/notebooks/Mandelbrot.html" rel="noopener nofollow ugc">code provided by Modular</a>.</p>
<p>This is my Julia implementation:</p>
<pre data-code-wrap="jl"><code>using Plots 

const xn = 960
const yn = 960
const xmin = -2.0
const xmax = 0.6
const ymin = -1.5
const ymax = 1.5
const MAX_ITERS = 200

function mandelbrot_kernel(c)
    z = c
    for i = 1:MAX_ITERS
        z = z * z + c
        if abs2(z) &gt; 4
            return i
        end
    end
    return MAX_ITERS
end


function compute_mandelbrot()
    result = zeros(yn, xn)

    x_range = range(xmin, xmax, xn)
    y_range = range(ymin, ymax, xn)

    Threads.@threads for j = 1:yn
        for i = 1:xn
            x = x_range[i]
            y = y_range[j]
            result[j, i] = mandelbrot_kernel(complex(x, y))
        end
    end
    return result
end

result = compute_mandelbrot()

x_range = range(xmin, xmax, xn)
y_range = range(ymin, ymax, yn)
heatmap(x_range, y_range, result)
</code></pre>
<p>I then benchmarked the Julia code</p>
<pre><code>julia&gt; @btime compute_mandelbrot()
  7.452 ms (341 allocations: 7.07 MiB)
</code></pre>
<p>For completeness, this is the Mojo code I used</p>
<pre><code>from benchmark import Benchmark
from complex import ComplexSIMD, ComplexFloat64
from math import iota
from python import Python
from runtime.llcl import num_cores, Runtime
from algorithm import parallelize, vectorize
from tensor import Tensor
from utils.index import Index

alias width = 960
alias height = 960
alias MAX_ITERS = 200

alias min_x = -2.0
alias max_x = 0.6
alias min_y = -1.5
alias max_y = 1.5

alias float_type = DType.float64
alias simd_width = simdwidthof[float_type]()


def show_plot(tensor: Tensor[float_type]):
    alias scale = 10
    alias dpi = 64

    np = Python.import_module(&#34;numpy&#34;)
    plt = Python.import_module(&#34;matplotlib.pyplot&#34;)
    colors = Python.import_module(&#34;matplotlib.colors&#34;)

    numpy_array = np.zeros((height, width), np.float64)

    for row in range(height):
        for col in range(width):
            numpy_array.itemset((col, row), tensor[col, row])

    fig = plt.figure(1, [scale, scale * height // width], dpi)
    ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], False, 1)
    light = colors.LightSource(315, 10, 0, 1, 1, 0)

    image = light.shade(
        numpy_array, plt.cm.hot, colors.PowerNorm(0.3), &#34;hsv&#34;, 0, 0, 1.5
    )
    plt.imshow(image)
    plt.axis(&#34;off&#34;)
    plt.show()


fn mandelbrot_kernel_SIMD[
    simd_width: Int
](c: ComplexSIMD[float_type, simd_width]) -&gt; SIMD[float_type, simd_width]:
    &#34;&#34;&#34;A vectorized implementation of the inner mandelbrot computation.&#34;&#34;&#34;
    var z = ComplexSIMD[float_type, simd_width](0, 0)
    var iters = SIMD[float_type, simd_width](0)

    var in_set_mask: SIMD[DType.bool, simd_width] = True
    for i in range(MAX_ITERS):
        if not in_set_mask.reduce_or():
            break
        in_set_mask = z.squared_norm() &lt;= 4
        iters = in_set_mask.select(iters + 1, iters)
        z = z.squared_add(c)

    return iters


fn parallelized():
    let t = Tensor[float_type](height, width)

    @parameter
    fn worker(row: Int):
        let scale_x = (max_x - min_x) / width
        let scale_y = (max_y - min_y) / height

        @parameter
        fn compute_vector[simd_width: Int](col: Int):
            &#34;&#34;&#34;Each time we oeprate on a `simd_width` vector of pixels.&#34;&#34;&#34;
            let cx = min_x + (col + iota[float_type, simd_width]()) * scale_x
            let cy = min_y + row * scale_y
            let c = ComplexSIMD[float_type, simd_width](cx, cy)
            t.data().simd_store[simd_width](
                row * width + col, mandelbrot_kernel_SIMD[simd_width](c)
            )

        # Vectorize the call to compute_vector where call gets a chunk of pixels.
        vectorize[simd_width, compute_vector](width)

    with Runtime() as rt:

        @parameter
        fn bench_parallel[simd_width: Int]():
            parallelize[worker](rt, height, 5 * num_cores())

        alias simd_width = simdwidthof[DType.float64]()
        let parallelized = Benchmark().run[bench_parallel[simd_width]]() / 1e6
        print(&#34;Parallelized:&#34;, parallelized, &#34;ms&#34;)

    try:
        _ = show_plot(t)
    except e:
        print(&#34;failed to show plot:&#34;, e.value)


def main():
    parallelized()

</code></pre>
<p>This gave me the result:</p>
<pre><code>Parallelized: 2.1398090000000001 ms
</code></pre>
<p>On my machine, the Mojo code will run in <strong>2.14 ms</strong>. The Julia code takes <strong>7.45 ms</strong>. I’m using 32 threads for Julia, but I admit that I haven’t fine tuned that number. I was wondering if anyone would be willing to offer up ways to improve the Julia code further? I don’t really know what else I can do and I think this would be an excellent way to learn more about squeezing every last drop of performance out of Julia. If we could end up beating the Mojo code that’d be fantastic! Doubly so because of how much more elegant the Julia code is.</p>
<p>Thank you all for your time.</p>
            </div>

            

            

          </div>
          <div id="post_2" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/mkitti"><span itemprop="name">mkitti</span></a>
                
              </span></p>

                

              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T01:06:27Z">
                    September 8, 2023,  1:06am
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T01:06:27Z"/>
              <span itemprop="position">2</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>We probably should use SIMD on the Julia side as well.</p>


            </div>

            

            

          </div>
          <div id="post_3" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>The difference here appears to be whether you get vectorization. Getting vectorized complex numbers isn’t entirely trivial in julia but at the very least you should be able to pretty easily decompose it for something this simple.</p>

            

            

          </div>
          <div id="post_4" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/liuyxpp"><span itemprop="name">liuyxpp</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T01:39:22Z">
                    September 8, 2023,  1:39am
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T01:39:43Z"/>
              <span itemprop="position">4</span>
              </span>
            </p></div>
            <p>I know I shouldn’t say so but I can’t help: I dislike the looking of the Mojo code. Those <code>[ ]</code> seem to appear everywhere and it hurts my eyes.</p>

            

            

          </div>
          <div id="post_5" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/adienes"><span itemprop="name">adienes</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T01:39:30Z">
                    September 8, 2023,  1:39am
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T01:39:30Z"/>
              <span itemprop="position">5</span>
              </span>
            </p></div>
            <p>changing <code>z = z * z + c</code> to <code>z = muladd(z, z, c)</code> gets about 25% faster right off the bat</p>

            

            

          </div>
          <div id="post_6" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/jling"><span itemprop="name">jling</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T03:08:07Z">
                    September 8, 2023,  3:08am
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T03:08:07Z"/>
              <span itemprop="position">6</span>
              </span>
            </p></div>
            

            

            

          </div>
          <div id="post_7" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              
<p>Instead, I would try</p>
<pre><code>function compute_mandelbrot()
    result = zeros(yn, xn)

    x_range = range(xmin, xmax, xn)
    y_range = range(ymin, ymax, yn)

    Threads.@threads for i = 1:xn
        for j = 1:yn
            x = x_range[i]
            y = y_range[j]
            # Note Julia arrays contiguous in columns
            result[j, i] = mandelbrot_kernel(complex(x, y))
        end
        #You could also do without second loop
        #result[:,i] .= mandelbrot_kernel.(complex.(x, y_range)
    end
    return result
end
</code></pre>
            </div>

            

            

          </div>
          <div id="post_8" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              <p>This was one of the questions I had when writing the code. When I was reading through the Julia <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">performance tips</a>, I found this section</p>
<blockquote>
<ul>
<li>Write <a href="https://docs.julialang.org/en/v1/base/base/#Base.SimdLoop.@simd"><code>@simd</code></a> in front of <code>for</code> loops to promise that the iterations are independent and may be reordered. Note that in many cases, Julia can automatically vectorize code without the <code>@simd</code> macro</li>
</ul>
</blockquote>
<p>I tried adding <code>@simd</code>, but I didn’t see a change in performance, so I figured the code was already vectorized, am I mistaken? What are the situations where Julia can automatically vectorize and how can I know that my code is properly vectorized?</p>
            </div>

            

            

          </div>
          <div id="post_9" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>The <code>@simd</code> macro is very limited and specifically, it can’t see through the function call.</p>

            

            

          </div>
          <div id="post_10" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>Use loopvectorization and decompose the complex number into a pair of numbers. Try that.</p>

            

            

          </div>
          <div id="post_11" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/nsajko"><span itemprop="name">nsajko</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T04:48:26Z">
                    September 8, 2023,  4:48am
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T04:48:26Z"/>
              <span itemprop="position">11</span>
              </span>
            </p></div>
            <div itemprop="text">
              <p>There’s a bunch of differences between your Julia code and your Mojo code that could perhaps matter for performance. For example, in Mojo you just do</p>

<p>… for the linear interpolation, while in Julia you use the FP ranges that do extra work in an attempt of preserving accuracy. The Mojo Mandelbrot kernel also seems to be written somewhat differently than your Julia version.</p>
            </div>

            

            

          </div>
          <div id="post_12" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              <blockquote>
<p>while in Julia you use the FP ranges that do extra work in an attempt of preserving accuracy.</p>
</blockquote>
<p>Basically none of this matters because all the time is in the Mandelbrot kernel</p>
            </div>

            

            

          </div>
          <div id="post_13" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/DNF"><span itemprop="name">DNF</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T05:48:08Z">
                    September 8, 2023,  5:48am
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T05:48:08Z"/>
              <span itemprop="position">13</span>
              </span>
            </p></div>
            <div itemprop="text">
              
<p>The kernel function contains a conditional return statement, I would be very impressed if Loopvectorization can handle this.</p>
<p>To me this seems like a classic case for manual vectorization using SIMD.jl. One can read the Mojo implementation for tips on how to do it.</p>
            </div>

            

            

          </div>
          <div id="post_14" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>I wrote one with a fixed iteration number. That’s how I do it.</p>

            

            

          </div>
          <div id="post_15" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <p>If I read the Mojo code correctly, the tensor allocation <code>let t = Tensor[...]</code> seems to not be part of the benchmark time (it is outside the <code>worker</code> function), whereas the julia function <code>compute_mandelbrot</code> allocates the <code>result</code> array which is timed. I don’t know if it makes a big difference however but perhaps it should be passed as a parameter instead as <code>compute_mandelbrot!(result)</code>.</p>

            

            

          </div>
          <div id="post_16" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              <p>This one runs <s>5x</s> 8x faster then the original julia example posted here, and illustrates nicely how something like ComplexSIMD can be defined quite easily in Julia:</p>
<pre><code>const xn = 960
const yn = 960
const xmin = -2.0
const xmax = 0.6
const ymin = -1.5
const ymax = 1.5
const MAX_ITERS = 200

struct ComplexSIMD{N,T}
    re::NTuple{N,T}
    im::NTuple{N,T}
end

Base.abs2(z::ComplexSIMD) = z.re .* z.re .+ z.im .* z.im
Base.:(*)(a::ComplexSIMD, b::ComplexSIMD) = ComplexSIMD(
    a.re .* b.re .- a.im .* b.im,
    a.re .* b.im .+ a.im .* b.re
)
Base.:(+)(a::ComplexSIMD, b::ComplexSIMD) = ComplexSIMD(a.re .+ b.re, a.im .+ b.im)

@inline function mandelbrot_kernel(c::ComplexSIMD{N,T}) where {N,T}
    z = c
    mask = ntuple(k -&gt; true, N)
    iters = ntuple(k -&gt; T(0), N)
    for i in 1:MAX_ITERS
        !any(mask) &amp;&amp; return iters
        mask = abs2(z) .&lt;= 4.0
        iters = iters .+ (mask .* 1)
        z = z * z + c
    end
    return iters
end

@inbounds function inner(result, x_range, y_range, y, ::Val{N}) where N
    ci = y_range[y]
    for x in 1:N:length(x_range)
        # Calculate whether the (x:x+7)-th real coordinates with
        # the y-th imaginary coordinate belong to the
        # mandelbrot set.
        c = ComplexSIMD(ntuple(k -&gt; x_range[x+k-1], N), ntuple(k -&gt; ci, N))
        iters = mandelbrot_kernel(c)
        foreach(enumerate(iters)) do (k, v)
            # Write the result to the output array
            result[y, x+k-1] = v
        end
    end
end

function mandelbrot(result, x_range, y_range, N)
    @sync for y in eachindex(y_range)
        # Threads.@spawn allows dynamic scheduling instead of static scheduling
        # of Threads.@threads macro.
        # See &lt;https://github.com/JuliaLang/julia/issues/21017&gt;.
        Threads.@spawn @inbounds begin
            inner(result, x_range, y_range, y, N)
        end
    end
    return result
end

using BenchmarkTools
result = zeros(yn, xn)
x_range = range(xmin, xmax, xn)
y_range = range(ymin, ymax, xn)
@btime mandelbrot(result, x_range, y_range, Val(4));
</code></pre>
<p><strong>Edit</strong>:</p>
<p>(Adapted from <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/program/mandelbrot-julia-7.html" rel="noopener nofollow ugc">mandelbrot Julia #7 program (Benchmarks Game)</a>)</p>
            </div>

            

            

          </div>
          <div id="post_17" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              <pre><code>using Plots
using SharedArrays
using Distributed

# Add worker processes. If you started Julia without `-p`, then this will add 3 worker processes.
# Otherwise, it&#39;s redundant and can be skipped.
# addprocs(3)

# Constants
const xmin = -2.0
const xmax = 0.6
const xn = 960
const ymin = -1.5
const ymax = 1.5
const yn = 960
const max_iter = 200

function mandelbrot_kernel(c::Complex{Float64})
    z = c
    for i in 1:max_iter
        if abs2(z) &gt; 4.0
            return i
        end
        z = z * z + c
    end
    return max_iter
end

@everywhere begin
    # Ensuring all processes have access to the constants and the kernel function
    const xmin = -2.25
    const xmax = 0.75
    const xn = 450
    const ymin = -1.25
    const ymax = 1.25
    const yn = 375
    const max_iter = 200

    function mandelbrot_kernel(c::Complex{Float64})
        z = c
        for i in 1:max_iter
            if abs2(z) &gt; 4.0
                return i
            end
            z = z * z + c
        end
        return max_iter
    end
end

function mandelbrot_parallel()
    x_vals = LinRange(xmin, xmax, xn)
    y_vals = LinRange(ymin, ymax, yn)
    
    result = SharedArray{Int}(yn, xn)

    @distributed for y in 1:yn
        for x in 1:xn
            result[y, x] = mandelbrot_kernel(complex(x_vals[x], y_vals[y]))
        end
    end
    
    return result
end

function make_plot_julia(m)
    heatmap(m, color=:hot, axis=false)
end

function main()
    start_time = time()
    mandelbrot_set = mandelbrot_parallel()
    end_time = time()
    execution_time = (end_time - start_time) * 1000  # Make it milliseconds

    make_plot_julia(mandelbrot_set)
    println(&#34;Execution time for Parallelized Julia Mandelbrot: &#34;, execution_time, &#34; ms&#34;)
end

main()
</code></pre>
<p>I used this code for paralleized version with the same params as mandelbrot</p>
            </div>

            

            

          </div>
          <div id="post_18" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              <p>Actually this seems to benefit from 24 threads on my 12 core machine, so now I’m at 8x faster.</p>
<p><a href="http://bookwyrm.social/u/radu_mihai_diaconu">@Radu_Mihai_Diaconu</a>, are you sure this is correct?</p><div><a href="https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/9/3/9312f3e3c04d7a6836110132080e749a0fb4e1cc.png" data-download-href="/uploads/short-url/kZ4NezY3Y4ALUPsZz0eWbXZrclK.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://global.discourse-cdn.com/business5/uploads/julialang/optimized/3X/9/3/9312f3e3c04d7a6836110132080e749a0fb4e1cc_2_690x488.png" alt="image" data-base62-sha1="kZ4NezY3Y4ALUPsZz0eWbXZrclK" width="690" height="488" srcset="https://global.discourse-cdn.com/business5/uploads/julialang/optimized/3X/9/3/9312f3e3c04d7a6836110132080e749a0fb4e1cc_2_690x488.png, https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/9/3/9312f3e3c04d7a6836110132080e749a0fb4e1cc.png 1.5x, https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/9/3/9312f3e3c04d7a6836110132080e749a0fb4e1cc.png 2x" data-dominant-color="463C3A"/></a></div>
            </div>

            

            

          </div>
          <div id="post_19" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            
            <div itemprop="text">
              <p>my plot is not empty. Yeah you are right to 450 part<br/>
</p><div><a href="https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/1/2/12bc36d3db08d3592d72928b6f5a44f226cd6aac.png" data-download-href="/uploads/short-url/2FJQaBmm757lbIKSUhQbDW6QE1e.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/1/2/12bc36d3db08d3592d72928b6f5a44f226cd6aac.png" alt="image" data-base62-sha1="2FJQaBmm757lbIKSUhQbDW6QE1e" width="690" height="124" data-dominant-color="0F0F0E"/></a></div>
<div><a href="https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/a/7/a7ba1005c9a41672fda30e766129c224e47d1c69.png" data-download-href="/uploads/short-url/nVMneOzasByOFyMM6KKaZUurasN.png?dl=1" title="image" rel="noopener nofollow ugc"><img src="https://global.discourse-cdn.com/business5/uploads/julialang/optimized/3X/a/7/a7ba1005c9a41672fda30e766129c224e47d1c69_2_690x462.png" alt="image" data-base62-sha1="nVMneOzasByOFyMM6KKaZUurasN" width="690" height="462" srcset="https://global.discourse-cdn.com/business5/uploads/julialang/optimized/3X/a/7/a7ba1005c9a41672fda30e766129c224e47d1c69_2_690x462.png, https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/a/7/a7ba1005c9a41672fda30e766129c224e47d1c69.png 1.5x, https://global.discourse-cdn.com/business5/uploads/julialang/original/3X/a/7/a7ba1005c9a41672fda30e766129c224e47d1c69.png 2x" data-dominant-color="705E5C"/></a></div>
            </div>

            

            

          </div>
          <div id="post_20" itemprop="comment" itemscope="" itemtype="http://schema.org/Comment">
            <div>
              <p><span itemprop="author" itemscope="" itemtype="http://schema.org/Person">
                <a itemprop="url" href="https://discourse.julialang.org/u/liuyxpp"><span itemprop="name">liuyxpp</span></a>
                
              </span></p>


              <p><span>
                  <time itemprop="datePublished" datetime="2023-09-08T12:06:20Z">
                    September 8, 2023, 12:06pm
                  </time>
                  <meta itemprop="dateModified" content="2023-09-08T12:06:20Z"/>
              <span itemprop="position">20</span>
              </span>
            </p></div>
            <p>Remarkable! Much cleaner than Mojo. I love it!</p>

            

            

          </div>
    </div></div>
  </body>
</html>
