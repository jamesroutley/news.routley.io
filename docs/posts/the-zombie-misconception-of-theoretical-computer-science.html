<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scottaaronson.blog/?p=8106">Original</a>
    <h1>The zombie misconception of theoretical computer science</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>In Michael Sipser’s <a href="https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X"><em>Introduction to the Theory of Computation</em> textbook</a>, he has one Platonically perfect homework exercise, so perfect that I can reconstruct it from memory despite not having opened the book for over a decade.  It goes like this:</p>



<ul>
<li>Let f:{0,1}*→{0,1} be the constant 1 function if God exists, or the constant 0 function if God does not exist. Is f computable? (<em>Hint:</em> The answer does not depend on your religious beliefs.)</li>
</ul>



<p>The correct answer is that yes, f is computable.  Why?  Because the constant 1 function is computable, and so is the constant 0 function, so if f is one or the other, then it’s computable.</p>



<p>If you’re still tempted to quibble, then consider the following parallel question:</p>



<ul>
<li>Let n equal 3 if God exists, or 5 if God does not exist.  Is n prime?</li>
</ul>



<p>The answer is again yes: even though n hasn’t been completely mathematically specified, it’s been specified <em>enough</em> for us to say that it’s prime (just like if we’d said, “n is an element of the set {3,5}; is n prime?”).  Similarly, f has been specified enough for us to say that it’s computable.</p>



<p>The deeper lesson Sipser was trying to impart is that the concept of <a href="https://en.wikipedia.org/wiki/Computable_function">computability</a> applies to <em>functions</em> or <em>infinite sequences</em>, not to individual yes-or-no questions or individual integers.  Relatedly, and even more to the point: computability is about whether a computer program <em>exists</em> to map inputs to outputs in a specified way; it says nothing about how hard it might be to <em>choose</em> or <em>find</em> or <em>write</em> that program.  Writing the program could even require settling God’s existence, for all the definition of computability cares.</p>



<hr/>



<p>Dozens of times in the past 25 years, I’ve gotten some variant on the following question, always with the air that I’m about to bowled over by its brilliance:</p>



<ul>
<li>Could the P versus NP question <em>itself</em> be NP-hard, and therefore impossible to solve?</li>
</ul>



<p>Every time I get this one, I struggle to unpack the layers of misconceptions.  But for starters: the concept of <a href="https://en.wikipedia.org/wiki/NP-hardness">“NP-hard”</a> applies to <em>functions</em> or <em>languages</em>, like 3SAT or Independent Set or Clique or whatnot, all of which <em>take an input</em> (a Boolean formula, a graph, etc) and produce a corresponding output.  NP-hardness means that, if you had a polynomial-time algorithm to map the inputs to the outputs, then you could convert it via reductions into a polynomial-time algorithm for any language or function in the class NP.</p>



<p><a href="https://www.scottaaronson.com/papers/pnp.pdf">P versus NP</a>, by contrast, is an individual yes-or-no question.  Its answer (for all we know) could be independent of the <a href="https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory">Zermelo-Fraenkel axioms</a> of set theory, but there’s no sense in which the question could be uncomputable or NP-hard.  Indeed, a fast program that correctly answers the P vs. NP question trivially exists:</p>



<ul>
<li>If P=NP, then the program prints “P=NP.”</li>



<li>If P≠NP, then the program prints “P≠NP.”</li>
</ul>



<hr/>



<p>In the comments of <a href="https://scottaaronson.blog/?p=8088">last week’s post</a> on the breakthrough determination of Busy Beaver 5, I got several variants on the following question:</p>



<ul>
<li>What’s the smallest n for which the value of BB(n) is uncomputable?  Could BB(6) already be uncomputable?</li>
</ul>



<p>Once again, I explained that the Busy Beaver <em>function</em> is uncomputable, but the concept of computability doesn’t apply to individual integers like BB(6).  Indeed, whichever integer k turns out to equal BB(6), the program “print k” clearly exists, and it clearly outputs that integer!</p>



<p>Again, we can ask for the smallest n such that the value of BB(n) is <em>unprovable in ZF set theory</em> (or some other system of axioms)—precisely the question that Adam Yedidia and I <a href="https://arxiv.org/abs/1605.04343">did ask in 2016</a> (the current record stands at n=745, improving my and Adam’s n=8000).  But <em>every</em> specific integer is “computable”; it’s only the BB function <em>as a whole</em> that’s uncomputable.</p>



<p>Alas, in return for explaining this, I got more pushback, and even ridicule and abuse that I chose to leave in the moderation queue.</p>



<hr/>



<p>So, I’ve come to think of this as the Zombie Misconception of Theoretical Computer Science: this constant misapplication of concepts that were designed for infinite sequences and functions, to individual integers and open problems. (Or, relatedly: the constant conflation of the uncomputability of the halting problem with Gödel incompleteness.  While they’re closely related, only Gödel lets you talk about <em>individual</em> statements rather than infinite families of statements, and only Turing-computability is absolute, rather than relative to a system of axioms.)</p>



<p>Anyway, I’m writing this post mostly just so that I have a place to link the <em>next</em> time this pedagogical zombie rises from its grave, muttering “UNCOMPUTABLE INTEGERRRRRRS….”  But also so I can query my readers: what are <em>your</em> ideas for how to keep this zombie down?</p>

		
				
				<p>
					<small>
						This entry was posted
												on Monday, July 8th, 2024 at 3:07 pm						and is filed under <a href="https://scottaaronson.blog/?cat=5" rel="category">Complexity</a>.
						You can follow any responses to this entry through the <a href="https://scottaaronson.blog/?feed=rss2&amp;p=8106">RSS 2.0</a> feed.

													You can <a href="#respond">leave a response</a>, or <a href="https://scottaaronson.blog/wp-trackback.php?p=8106" rel="trackback">trackback</a> from your own site.

						
					</small>
				</p>

			</div></div>
  </body>
</html>
