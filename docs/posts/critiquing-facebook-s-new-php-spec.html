<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.paulbiggar.com/critiquing-facebooks-new-php-spec/">Original</a>
    <h1>Critiquing Facebook’s new PHP spec</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>

            <header>

                

                    


                            </header>

            <section>
                <p><em>Originally posted July 31, 2014 on the CircleCI blog</em></p><p>Yesterday, Facebook released an <a href="https://web.archive.org/web/20150316005440/http://hhvm.com/blog/5723/announcing-a-specification-for-php">initial draft specification for PHP</a>. Written by a team of Facebook employees including a veteran of many specification committees, it looks like a serious effort to provide a needed specification to a language that has gone without it for a long time.</p><p>So I thought I’d take a look and see if it was any good.</p><figure><a href="https://web.archive.org/web/20150316005440/http://blog.circleci.com/wp-content/uploads/2014/07/elephant.jpg"><img src="https://web.archive.org/web/20150316005440im_/http://blog.circleci.com/wp-content/uploads/2014/07/elephant-300x214.jpg" alt="PHP elephant" loading="lazy" width="300" height="214"/></a></figure><p>To start with it might be worth mentioning some background. I worked on a <a href="https://web.archive.org/web/20150316005440/http://phpcompiler.org/">PHP compiler</a> for about 4 years from 2005-2009, in which I implemented lots of code generation, static analysis and optimization for PHP, and <a href="https://web.archive.org/web/20150316005440/http://paulbiggar.com/research/#phd-dissertation">wrote a PhD</a> on it. If you’ve heard of me before (apart from on the <a href="https://web.archive.org/web/20150316005440/https://circleci.com/">CircleCI</a> blog), it’s probably for my <a href="https://web.archive.org/web/20150316005440/http://blog.paulbiggar.com/archive/a-rant-about-php-compilers-in-general-and-hiphop-in-particular/">rant about HipHop</a>.</p><p>As one of the few people outside Facebook and the PHP community that has built a compiler for PHP, and as the author of the most advanced static analyzer for PHP (again, excluding Facebook’s one), my thoughts on Facebook’s PHP spec might be interesting to a larger audience.</p><p>Let me summarize this post by saying I <em>love</em> this <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md">specification</a> (I’m linking to the version current at time of writing). Both the fact that they wrote it, and the spec itself are awesome.</p><p>I don’t just love it because it is a specification, and because PHP sorely needed one, but because I truly think this is well done. It describes the current implementation exceptionally well, and it’s clear they have a ton of expertise in understanding how PHP works. Not only that, but it’s exceptionally clear and well written, and I haven’t been able to find a single flaw in the semantics at all (“semantics” in the programming language world just means “how does the language work”).</p><p>A quick aside here. In my PhD, I discussed how PHP, along with Ruby, Python and some others, are languages defined by their implementations. There’s really only one very good discussion of how the PHP implementation works, which is a book from 2006 by Sara Golemon called <a href="https://web.archive.org/web/20150316005440/http://www.amazon.com/Extending-Embedding-PHP-Sara-Golemon/dp/067232704X">Embedding and Extending PHP</a>.</p><p>The book serves as a reference for the entire PHP implementation. I had a dog-eared copy that I read cover to cover about four times, and it basically taught me the PHP memory model. There are few people as qualified to discuss the implications of copy-on-write and change-on-write sets, and the other weirdness of the PHP implementation and its effect on PHP’s semantics than its author Sara Golemon. So it’s no surprise really that one of the folks leading the charge on the HHVM team is Sara, and it feels like this is indicative of quality I saw in the spec.</p><p>Since “PHP” is such an overloaded term in this post, I’m going to refer to the PHP interpreter as the “Zend engine”, refer to PHP the language as “the language”, and refer to Facebook’s PHP specification as “the spec”.</p><p>One of the most interesting things is the places they’ve chosen to deviate from how the Zend engine does things. This is an interesting political move. In a couple of places, the spec says that an implementation can choose how to implement the language, and that other implementations can go a different way. Each case is pretty well chosen, and although the reasoning isn’t presented, there’s a pretty clear goal of allowing HHVM to deviate from the language’s weird corner cases.</p><p>This is interesting because they’re changing the definition of the language through a sort of back-channel. They’re allowing breaking changes by effectively deciding that other implementation choices are equally valid.</p><p>I’ll give you an example, which I’ll get into more below. There’s a little known bug in the Zend engine around copying arrays that contain references. <a href="https://web.archive.org/web/20150316005440/http://dl.acm.org/citation.cfm?id=1480908">IBM wrote a paper</a> about this bug in 2009. Basically, this bug was necessary in Zend to make copying arrays fast, and IBM figured out a way to do it in a way that was actually correct, for only a 10% performance penalty.</p><p>The spec describes this use case in great detail, and then says you don’t need to implement it this way. They say:</p><blockquote>If <code>$source</code>‘s VStore has a <code>refcount</code> that is greater than 1, the Engine uses an implementation-defined algorithm to decide whether to copy the element using value assignment (<code>$destination = $source</code>) or byRef assignment (<code>$destination =&amp; $source</code>).</blockquote><p>This is one of eighteen times in the spec that they use the phrase “implementation-defined”. So they actually let an implementation choose between different ways of doing it – the Zend way and what I assume is the HHVM way. This isn’t just a sane option, it’s actually the only sane option.</p><p>I presume this came directly from the requirements of HHVM, but by effectively saying “look, we don’t want to be bound by this decade old mistake” they not only free HHVM from having to implement this, but they actually change the rules for what Zend itself has to implement going forward. A very nice move, in my opinion.</p><p>One of the best things in the spec is the <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#the-memory-model">description of the language’s memory model</a>. A “memory model” is a technical term for “how variables and values and assignment and stuff works”.</p><p>They made a very interesting choice of how to specify this. Rather than trying to specify the exact algorithm for everything (which is what the <a href="https://web.archive.org/web/20150316005440/http://www.ecma-international.org/publications/standards/Ecma-262.htm">JS spec</a> typically does, for example), they chose to describe the Zend model (or close enough) and say “it has to appear to work like this”.</p><p>So the spec provides a high-level model based on the idea that there are variables (called <em>VSlots</em>), and separately there are values (called <em>VStores</em>) which hold integers and other scalars or refer to objects, strings or arrays, and then there is extra thing called <em>HStore</em>, which is where objects and arrays are kept.</p><p>This gets to the crux of the Zend memory model, and its a really strong abstraction of it. It isn’t perfectly representative of how Zend actually works under the hood, which they own up to, but they also say that you can’t tell the difference between this and Zend. I think that’s correct, or at least can’t think of any counter-examples, and I’ve spent a long time thinking of weird counter examples.</p><p>This is also one of those areas where the writing is really good. It’s not perfect, but for the most part they describe very complicated stuff in very clear language, systematically going through all the edge cases: whether the assignment is to or from an array, whether the values involved are references, and whether the assignments are by reference. Very high quality stuff.</p><h2 id="reference-counting">Reference counting</h2><p>One thing they abstract over is reference counting. Zend is implemented using reference counting, and the reference counting allows Zend to implement an optimization called “copy-on-write”. This means when the Zend engine copies a value, it doesn’t actually copy it, it just increments the value’s reference count and says that it’s copied. If the value gets changed later (the “write” in “copy-on-write”), then the copy happens lazily when the change happens.</p><p>Since the semantics of this sometimes leak out to the world, you would imagine the spec would need to include the reference-counting semantics. Instead, they <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#byref-assignment-for-scalar-types-with-local-variables">tease out the exact details</a> of the copy-on-write semantics, and describe that in high-level terms, with examples. Which is a really powerful way to avoid hamstringing future implementors by specifying the Zend engine’s behaviour.</p><p>Here’s a good test of your PHP knowledge: describe the difference between</p><p><code>$a = new Point(1, 3)</code></p><p>and</p><p><code>$a =&amp; new Point (1, 3)</code></p><p><strong>Answer</strong>: I forget! I think it’s that the next assignment to “$a` will do something odd, but honestly I don’t remember the subtleties.</p><p>However, clearly the spec’s authors haven’t forgotten the subtleties, and the spec <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#assignment">describes them in great detail</a>. If you want to understand the PHP language’s idiosyncrasies (ignore the inconsistent parameter ordering, reference semantics are the real mess), this makes a good read.</p><p>One of the more interesting discussions in the spec is around “<a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#deferred-array-copying">deferred array copying</a>“, which is that thing in the IBM paper I mentioned earlier. You have an array which contains a value which references another value. When you go to copy that array, you have a choice: does the referenced value exist in both arrays? Or do you make a copy of it like you did the array? Well, the latter probably makes more sense but Zend implements the former.</p><p>Here’s an example from the spec of code that triggers this behaviour:</p><pre><code>$x = 0;
$a = array(&amp;$x);
$b = $a;
$x = 2;
unset($x);
$b[1]++;
$b[0]++;
echo $a[0], &#39; &#39;, $b[0];
</code></pre><p>The spec says that you can have an “implementation-defined algorithm” to choose between different ways to implement it. I presume this is because HHVM chose a different algorithm than Zend did. At least, they should because the Zend choice doesn’t make sense (“but at least it’s fast!”), and anyone relying on this behaviour deserves what they get.</p><p>Now, as much as I like the spec, I think there a few mistakes in here. One of them is the description of <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#storage-duration">when to do garbage collection</a>.</p><p>The spec declares that you have to GC the memory that holds variables at the end of a scope:</p><blockquote>A variable having automatic storage duration comes into being and is initialized at its declaration or on its first use, if it has no declaration. Its lifetime is delimited by an enclosing scope. The automatic variable’s lifetime ends at the end of that scope. Automatic variables lend themselves to being stored on a stack where they can help support argument passing and recursion. Local variables, which include function parameters, have automatic storage duration.</blockquote><p>To my reading, this says that you must keep the variables alive until they fall out of scope (until the function ends, for example). Similarly:</p><blockquote>The Engine must reclaim each VSlot when the storage duration of its corresponding variable ends, when the variable is explicitly unset by the programmer, or when the script exits, whichever comes first. In the case where a VSlot is contained within an HStore (i.e. an array element or an object instance property), the engine must immediate reclaim the VSlot when it is explicitly unset by the programmer, when the containing HStore is reclaimed, or when the script exits, whichever comes first.</blockquote><p>I read this as saying that when a variable dies, you must immediately clear it up. I suspect that this will make the GC a little less flexible than it has to be. For example, some advanced garbage collectors might want to keep the variables alive a little bit longer. Alternatively, an implementation might want to share storage for a pair of variables which it knows aren’t alive at the same time. My read here is that they won’t allow that.</p><p>[<strong>Edit: thanks to HN user wvenable for </strong><a href="https://web.archive.org/web/20150316005440/https://news.ycombinator.com/item?id=8115126"><strong>pointing this out</strong></a><strong>!</strong>]</p><p>One side effect of the new GC behaviour is that the HStore (representing an object) does not have to be reclaimed immediately. That’s great if you’re writing an implementation with a GC – cleaning up objects later is ideal for advanced garbage collectors. But it’s not so great if you rely on RAII, which the Zend engine currently supports. It looks like this is going to be a pretty big language change if it goes through as is. An implementation supporting RAII would still be <em>allowed</em>, just not <em>required</em>.</p><p>[RAII means “Resource Acquisition is Initialization”. It means you grab everything you need in your constructor, and free it in your destructor. This is possible in languages like C++ which have explicit rules that you must call your destructor when something goes out of scope, but not in say Java where finalizers run when the GC gets around to it. Zend effectively has C++’s rules, which the spec is closer to Java’s rules.]</p><h2 id="array-cursors-and-threading">Array cursors and threading</h2><p>One other thing they specified is that <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#general-21">array cursors are internal</a>. (To be honest, I didn’t much like the description of arrays itself, but that might be the computer scientist in me: A PHP is an ordered map, really). This would manifest if a new PHP implementation wanted to use a different threading model: would two threads looping through the same array use the same cursor? Sounds pretty racy. Per-thread cursors or optional external cursors might be good options here, and leaving the door open to this might be useful.</p><h2 id="aliases">Aliases</h2><p>I’m also not crazy about some of the wording they chose. They use words like “pointer” and “memory location” and “aliases” in ways that are not strictly correct, or which are at least confusing since those words hold a different meaning to how they use them in the spec. <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#byref-assignment-for-scalar-types-with-local-variables">For example</a>, they say two VSlots (variables) are “aliased” if they hold values which are references to each other (aka “point to the same VStore”). While I agree that those are aliases in the technical sense, that definition excludes other aliased values, such as two variables pointing to the same object (which would be two VSlots pointing to two VStores pointing to one HStore, in the spec’s terminology).</p><p>By the way, this might be a good time to reflect on how specific this nitpicking is. Imagine how good a job they did on the whole thing if these are the depths to which I have to go to find something they did wrong!</p><h2 id="overflow">Overflow</h2><p>That said, I think their <a href="https://web.archive.org/web/20150316005440/https://github.com/php/php-langspec/blob/ad1d40eec406d9abbe152ac387e7d0843d5dd910/spec/php-spec-draft.md#the-integer-type">choice of how overflow works</a> is unfortunate. They allow the implementation to define both the type and value of overflows, and I think this is a really bad idea. Call me a purist, but I think we should have a very specific understanding of exactly what happens when integers overflow.</p><p>I suspect the reason here is that Zend’s choice is poor, and Facebook wants to go in a different direction with HHVM. I loved that approach before with the deferred array copies, so it seems harsh to condemn here what I was happy with before, but integer overflow is important. Still, they’re likely to be hamstrung by Zend’s implementation, which has to remain valid since Zend is by definition a correct implementation.</p><p>Overall, I’d say this is a pretty great spec, and a welcome addition to the PHP implementation writer’s repertoire. It’s clear that some work remains (I didn’t highlight explanations that were poor, etc, and there are a few), but I feel confident that this is very close to being an excellent doc. The HHVM team did a great job!</p>
            </section>

        </article>

    
                
</div></div>
  </body>
</html>
