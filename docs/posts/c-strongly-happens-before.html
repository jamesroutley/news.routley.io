<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nekrozqliphort.github.io/posts/happens-b4/">Original</a>
    <h1>C&#43;&#43;: Strongly Happens Before?</h1>
    
    <div id="readability-page-1" class="page"><div><p>It started innocently enough. I just wanted to brush up on C++ memory orderings. It’s been a while since I last stared into the abyss of <code>std::atomic</code>, so I figured, why not revisit some good ol’ <code>std::memory_order</code> mayhem?</p><p>Then I saw it. <strong>Strongly happens before</strong>.</p><p>Wait, what? When did we get a stronger version of happens before?</p><p>Turns out, it has been there for quite some time (since C++20 in fact), and it’s actually solving a very real problem in the memory model. If you’re also wondering what it is, why it exists, and whether you should care — that’s exactly what we’re going to explore today.</p><p>Let’s start off with a small program:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td><pre><span>#include</span> <span>&lt;atomic&gt;</span><span>
#include</span> <span>&lt;thread&gt;</span><span>
</span>
<span>std</span><span>::</span><span>atomic</span><span>&lt;</span><span>int</span><span>&gt;</span> <span>x</span><span>{</span><span>0</span><span>},</span> <span>y</span><span>{</span><span>0</span><span>};</span>

<span>void</span> <span>thread_1</span><span>()</span> <span>{</span>
    <span>// Thread 1</span>
    <span>x</span><span>.</span><span>store</span><span>(</span><span>1</span><span>,</span> <span>std</span><span>::</span><span>memory_order_seq_cst</span><span>);</span>
    <span>y</span><span>.</span><span>store</span><span>(</span><span>1</span><span>,</span> <span>std</span><span>::</span><span>memory_order_release</span><span>);</span>
<span>}</span>
 
<span>void</span> <span>thread_2</span><span>()</span> <span>{</span>
    <span>// Thread 2</span>
    <span>int</span> <span>b</span> <span>=</span> <span>y</span><span>.</span><span>fetch_add</span><span>(</span><span>1</span><span>,</span> <span>std</span><span>::</span><span>memory_order_seq_cst</span><span>);</span> <span>// b = 1</span>
    <span>int</span> <span>c</span> <span>=</span> <span>y</span><span>.</span><span>load</span><span>(</span><span>std</span><span>::</span><span>memory_order_relaxed</span><span>);</span> <span>// c = 3</span>
<span>}</span>
 
<span>void</span> <span>thread_3</span><span>()</span> <span>{</span>
    <span>// Thread 3</span>
    <span>y</span><span>.</span><span>store</span><span>(</span><span>3</span><span>,</span> <span>std</span><span>::</span><span>memory_order_seq_cst</span><span>);</span>
    <span>int</span> <span>a</span> <span>=</span> <span>x</span><span>.</span><span>load</span><span>(</span><span>std</span><span>::</span><span>memory_order_seq_cst</span><span>);</span> <span>// a = 0</span>
<span>}</span>
 
<span>int</span> <span>main</span><span>()</span> <span>{</span>
    <span>std</span><span>::</span><span>thread</span> <span>a</span><span>(</span><span>thread_1</span><span>);</span>
    <span>std</span><span>::</span><span>thread</span> <span>b</span><span>(</span><span>thread_2</span><span>);</span>
    <span>std</span><span>::</span><span>thread</span> <span>c</span><span>(</span><span>thread_3</span><span>);</span>
    <span>a</span><span>.</span><span>join</span><span>();</span> <span>b</span><span>.</span><span>join</span><span>();</span> <span>c</span><span>.</span><span>join</span><span>();</span>
<span>}</span>
</pre></td></tr></tbody></table></code></p></div><p>The comments show the values each thread observed. Now, the big question: is this execution even possible under the C++ memory model?</p><p>Here’s where our little adventure begins. We’ll gradually build up the execution graph by adding edges as we layer in more constraints on the possible orderings.</p><p><a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/initial-state-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/initial-state-light.png" alt="Initial Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/initial-state-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/initial-state-dark.png" alt="Initial Execution Graph" loading="lazy"/></a> <em>Initial Execution Graph</em></p><p>Just to be clear, from <a href="https://eel.is/c++draft/thread.thread.constr#6">[thread.thread.constr]/6</a>:</p><blockquote><p>The completion of the invocation of the constructor synchronizes with the beginning of the invocation of the copy of f.</p></blockquote><p>This gives us a synchronizes-with relationship between thread construction and the start of the thread function. As a result, we’re allowed to establish the initial happens-before edges in the graph.</p><p>The first set of constraints we’ll add are all related to the modification order of <code>x </code>and <code>y</code>. As a quick refresher (from <a href="https://eel.is/c++draft/intro.multithread#intro.races-4">[intro.races]/4</a>):</p><blockquote><p>All modifications to a particular atomic object M occur in some particular total order, called the modification order of M.</p></blockquote><p>Note that this total order exists per atomic object. Let’s bring in a few more rules from <a href="https://eel.is/c++draft/intro.multithread#intro.races">[intro.races]</a> to get a clearer picture of the constraints imposed through modification order. Here are the relevant sections:</p><blockquote><p>An evaluation A happens before an evaluation B (or, equivalently, B happens after A) if either</p><ul><li>A is sequenced before B, or</li><li>A synchronizes with B, or</li><li>A happens before X and X happens before B.</li></ul></blockquote><blockquote><p>If an operation A that modifies an atomic object M happens before an operation B that modifies M, then A is earlier than B in the modification order of M. (write-write coherence)</p></blockquote><blockquote><p>If a value computation A of an atomic object M happens before a value computation B of M, and A takes its value from a side effect X on M, then the value computed by B is either the value stored by X or the value stored by a side effect Y on M, where Y follows X in the modification order of M. (read-read coherence)</p></blockquote><blockquote><p>If a value computation A of an atomic object M happens before an operation B that modifies M, then A takes its value from a side effect X on M, where X precedes B in the modification order of M. (read-write coherence)</p></blockquote><blockquote><p>If a side effect X on an atomic object M happens before a value computation B of M, then the evaluation B takes its value from X or from a side effect Y that follows X in the modification order of M. (write-read coherence)</p></blockquote><p>Here’s an image to better illustrate the C++ coherence rules mentioned above. <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/coherence-explanation-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/coherence-explanation-light.png" alt="Illustration for C++ Coherence Rules" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/coherence-explanation-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/coherence-explanation-dark.png" alt="Illustration for C++ Coherence Rules" loading="lazy"/></a> <em>Illustration for C++ Coherence Rules</em></p><p>Using these, we can now establish the following constraints in our execution:</p><ul><li>$(1) \rightarrow (2)$: Establish from write-write coherence, as $(1)$ happens before $(2)$.</li><li>$(3) \rightarrow (4)$: Establish from write-write coherence, as $(3)$ happens before $(4)$ (synchronizes-with from <a href="https://eel.is/c++draft/atomics.order#2">[atomics.order]/2</a>).</li><li>$(4) \rightarrow (6)$: Establish from write-read coherence, as $(4)$ happens before $(5)$ hence $(5)$ can only takes its value from $(4)$ or some other side effect that follows $(4)$ in the modification order of <code>y</code>. Since $(5)$ can only take the value of the write at $(6)$, $(6)$ must follow $(4)$ in the modification order of <code>y</code></li></ul><p>Here is the current execution graph with the added constraints: <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/mo-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/mo-light.png" alt="MO Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/mo-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/mo-dark.png" alt="MO Execution Graph" loading="lazy"/></a> <em>Execution Graph with Modification Order</em></p><p>Let’s continue with another constraint, coherence-ordered before. To understand what this means, let’s take a quick look at <a href="https://eel.is/c++draft/atomics.order#3">[atomics.order]/3</a>.</p><blockquote><p>An atomic operation A on some atomic object M is coherence-ordered before another atomic operation B on M if</p><ul><li>A is a modification, and B reads the value stored by A, or</li><li>A precedes B in the modification order of M, or</li><li>A and B are not the same atomic read-modify-write operation, and there exists an atomic modification X of M such that A reads the value stored by X and X precedes B in the modification order of M, or</li><li>there exists an atomic modification X of M such that A is coherence-ordered before X and X is coherence-ordered before B.</li></ul></blockquote><p>A few important things to note:</p><ol><li>The modification order we previously established is used to establish a coherence-ordered before relationship.</li><li>The coherence-ordered before relation is transitive.</li></ol><p>For our purposes, we’re mainly interested in the specific case described by the following criterion:</p><blockquote><p>A is a modification, and B reads the value stored by A We’ll refer to this as the “read-from” relationship in the diagrams going forward, just to keep things visually clearer.</p></blockquote><p>Here are the edges we can now add to our diagram, based on the read-from relationship:</p><ul><li>$(1) \rightarrow (7)$: $(7)$ reads from the value stored by $(1)$.</li><li>$(3) \rightarrow (4)$: $(4)$ reads from the value stored by $(3)$.</li><li>$(6) \rightarrow (5)$: $(5)$ reads from the value stored by $(6)$.</li></ul><p>And with that, here’s the updated execution graph: <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rf-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rf-light.png" alt="RF Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rf-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rf-dark.png" alt="RF Execution Graph" loading="lazy"/></a> <em>Execution Graph with Read-From Relationship</em></p><p>So far so good, we have a perfectly fine execution graph. However, let’s take a look if there’s anything we missed.</p><blockquote><p>An atomic operation A on some atomic object M is coherence-ordered before another atomic operation B on M if</p><ul><li>…</li><li>A and B are not the same atomic read-modify-write operation, and there exists an atomic modification X of M such that A reads the value stored by X and X precedes B in the modification order of M</li><li>…</li></ul></blockquote><p>Interestingly, this gives us another constraint:</p><ul><li>$(7) \rightarrow (2)$: $(2)$ and $(7)$ are indeed not the same atomic read-modify-write operation, $(7)$ reads from $(1)$ and $(1)$ precedes $(2)$ in the modification order of <code>x</code>.</li></ul><p>We will use the “read-before” relationship to signify this in the execution graph, as shown here: <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-light.png" alt="RF Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-dark.png" alt="RF Execution Graph" loading="lazy"/></a> <em>Execution Graph with Read-Before Relationship</em></p><p>Alright, so what’s the point of going through all of this? The actual goal here is to establish a single total order over all <code>memory_order::seq_cst</code> operations. For that, let’s look at one final requirement from <a href="https://eel.is/c++draft/atomics.order#4">[atomics.order]/4</a>:</p><blockquote><p>There is a single total order S on all <code>memory_order​::​seq_cst</code> operations, including fences, that satisfies the following constraints. First, if A and B are <code>memory_order​::​seq_cst</code> operations and A strongly happens before B, then A precedes B in S. Second, for every pair of atomic operations A and B on an object M, where A is coherence-ordered before B, the following four conditions are required to be satisfied by S:</p><ul><li>if A and B are both <code>memory_order​::​seq_cst</code> operations, then A precedes B in S; and</li><li>…</li></ul></blockquote><p>(We can safely ignore the rest for now, as we don’t deal with fences in this example.)</p><p>Now, this is where the strongly happens before relation comes into play. But for the sake of this blog, let’s momentarily relax the definition and replace “strongly happens before” with just “happens before” to see what happens.</p><p>Under this relaxed definition, we find that we cannot establish a total order over all <code>memory_order::seq_cst</code> operations due to a cycle in the graph: $(2) \rightarrow (4) \rightarrow (6) \rightarrow (7) \rightarrow (2)$. This cycle makes the execution inconsistent with the standard’s requirements for <code>memory_order::seq_cst</code>, rendering it not a valid execution.</p><p>So what’s the issue?</p><p>Unfortunately, this execution is allowed by certain compilers and architectures, notably Power. We’ll take a closer look at why that’s the case shortly. But for now, it’s important to highlight the key decision faced by the C++ committee:</p><p>Should the implementations be fixed, or should the C++ standard itself be adjusted?</p><p>According to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html">P0668R5</a>, enforcing a stricter rule would introduce a significant performance penalty on acquire/release synchronization, essentially defeating the purpose of <code>memory_order_acquire</code> and <code>memory_order_release</code>.</p><p>Given this tradeoff, the committee chose the alternative: fix the standard instead of the implementations.</p><p>Before we look at what that fix entails, it helps to understand why architectures like Power permit such executions in the first place.</p><p>The unfortunate reality is that the only real way to understand why this behavior is allowed is to look at the assembly generated, and that’s exactly what we’re going to do. You can find the full Godbolt link <a href="https://godbolt.org/z/8rnfhPvb7">here</a> to explore the generated assembly in more detail.</p><p>But first, let’s verify that the outcome is actually possible on the Power architecture using <a href="https://diy.inria.fr/"><code>herd7</code></a>. Here’s the test case we’ll use:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre>PPC Strongly-Happens-B4-Example
{
x = 0;
y = 0;

0:r2=x; 0:r4=y;
1:r4=y;
2:r4=y; 2:r8=x;
}
P0           | P1              | P2           ;
li r1,1      | L_retry:        | li r1,3      ;
stw r1,0(r2) | lwarx r1,r0,r4  | stw r1,0(r4) ;
lwsync       | addi r2,r1,1    | sync         ;
stw r1,0(r4) | stwcx. r2,r0,r4 | lwz r2,0(r8) ;
             | bne L_retry     |              ;
             | isync           |              ;
             | lwz r3,0(r4)    |              ;

exists (1:r1=1 /\ 1:r3=3 /\ 2:r2=0)
</pre></td></tr></tbody></table></code></p></div><p>And here’s the result from <code>herd7</code>:</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
</pre></td><td><pre>Loop Ok
Witnesses
Positive: 1 Negative: 18
Condition exists (1:r1=1 /\ 1:r3=3 /\ 2:r2=0)
</pre></td></tr></tbody></table></code></p></div><p>This confirms that the execution we previously marked as invalid under the “happens-before” interpretation is in fact valid on Power.</p><p>Below is the execution graph generated by <code>herd7</code> for this scenario: <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/ppc-test-with-bg.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/ppc-test-with-bg.png" alt="Herd7 Test Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/ppc-test-without-bg-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/ppc-test-without-bg-dark.png" alt="Herd7 Test Execution Graph" loading="lazy"/></a></p><p>Now, we don’t need to understand every low-level detail, but we do need a rough sense of how synchronization works on Power. A good starting point is the <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf">PLDI 2011 paper on Understanding Power Multiprocessors</a> along with this <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf">tutorial-style supplement</a>. Additionally, it’s worth checking out the <a href="https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html">mapping of C++ atomic operations to instruction sequences</a>, which sheds light on what instructions get emitted under various memory orders on different architectures.</p><p>However, for brevity, we’ll only highlight the relevant synchronization constructs and constraints here. First, let’s look at the memory barriers (taken from the <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf">tutorial notes</a>):</p><div><table><thead><tr><th>Operations</th><th><code>sync</code>/<code>hwsync</code></th><th><code>lwsync</code></th></tr></thead><tbody><tr><td>$R \rightarrow R$</td><td>For two reads separated by a <code>sync</code>, the barrier </td><td>Same as <code>sync</code>/<code>hwsync</code></td></tr><tr><td>$R \rightarrow W$</td><td>For a read before a write, separated by a <code>sync</code>,</td><td>Same as <code>sync</code>/<code>hwsync</code></td></tr><tr><td>$W \rightarrow W$</td><td>For a write before a write, separated by a <code>sync</code>,</td><td>For a write before a write, separated by a <code>lwsync</code>,</td></tr><tr><td>$W \rightarrow R$</td><td>For a write before a read, separated by a <code>sync</code>, the</td><td>For a write before a read, separated by a <code>lwsync</code>, </td></tr></tbody></table></div><p>Even though Power multiprocessors use a highly relaxed memory model, one key guarantee is preserved: For each memory location, there exists a single linear order of all writes to that location that must be respected by all threads. This property is known as coherence.</p><p>Here are a few important coherence constraints to help illustrate the idea:</p><ul><li>$R \rightarrow R$: A pair of reads by a thread cannot read contrary to the coherence order.</li><li>$W \rightarrow W$: The coherence order must respect program order for a pair of writes by a thread .</li><li>$W \rightarrow R$: A read cannot read from a write that is coherence-hidden by another write program-order preceding the read.</li><li>$R \rightarrow W$: A write cannot coherence order-precede a write that a program-order-preceding read from.</li></ul><p>For a clear illustration, see the coherence section in <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf">Understanding Power Multiprocessors</a>.</p><p>Now, let’s take a look at a simpler illustration of the program we’ve been examining: <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/power-assembly-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/power-assembly-light.png" alt="Simpler Power Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/power-assembly-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/power-assembly-dark.png" alt="Simpler Power Execution Graph" loading="lazy"/></a></p><p>We want to understand why this execution is allowed on Power. Let’s walk through a few key observations:</p><ol><li>Thread 1’s $R[y]^* = 1$ implies that $W[y] = 1$ from Thread 0 must have propagated to Thread 1. By the $R \rightarrow W$ coherence rule, this means Thread 1’s $W[y]^* = 2$ must be coherence-ordered after $W[y] = 1$.</li><li>Thread 2’s $W[y] = 3$ cannot be coherence-ordered before either $W[y] = 1$ or $W[y]* = 2$, because that would violate $W \rightarrow R$ coherence (as $R[y] = 3$ comes after).</li><li>However, coherence does not require $W[y] = 1$ to propagate to Thread 2. And with only <code>lwsync</code> in Thread 0, $W[x] = 1$ is not required to propagate to Thread 2 either.</li></ol><p>Hence, we have our following sequence of events:</p><ol><li>Thread 0 performs $W[x] = 1$ and $W[y] = 1$, and both writes propagate to Thread 1.</li><li>Thread 1 reads $R[y]* = 1$, then writes $W[y]* = 2$.</li><li>Thread 2 performs $W[y] = 3$ and issues a sync, forcing that write to propagate to Thread 0 and Thread 1 before the $R[x]$ is satisfied.</li><li>Thread 1 reads $R[y] = 3$.</li><li>Thread 2 reads $R[x] = 0$, since $W[x] = 1$ from Thread 0 never propagated to it.</li></ol><p>Unfortunately, <code>stwcx.</code> appears to have issues when used with <code>rmem</code>. As an alternative, <a href="https://www.cl.cam.ac.uk/~sf502/regressions/rmem/#%7B%22test%22%3A%22PPC%20Strongly-Happens-B4-Alternate-Example%5Cn%7B%5Cnx%20%3D%200%3B%5Cny%20%3D%200%3B%5Cn%5Cn0%3Ar2%3Dx%3B%200%3Ar4%3Dy%3B%5Cn1%3Ar4%3Dy%3B%201%3Ar8%3Dy%3B%5Cn2%3Ar4%3Dy%3B%202%3Ar8%3Dx%3B%5Cn%7D%5CnP0%20%20%20%20%20%20%20%20%20%20%20%7C%20P1%20%20%20%20%20%20%20%20%20%20%20%7C%20P2%20%20%20%20%20%20%20%20%20%20%20%3B%5Cnli%20r1%2C1%20%20%20%20%20%20%7C%20lwz%20r1%2C0(r4)%20%7C%20li%20r1%2C3%20%20%20%20%20%20%3B%5Cnstw%20r1%2C0(r2)%20%7C%20addi%20r2%2Cr1%2C1%20%7C%20stw%20r1%2C0(r4)%20%3B%5Cnlwsync%20%20%20%20%20%20%20%7C%20stw%20r2%2C0(r4)%20%7C%20sync%20%20%20%20%20%20%20%20%20%3B%5Cnstw%20r1%2C0(r4)%20%7C%20cmpw%20r1%2Cr1%20%20%20%7C%20lwz%20r2%2C0(r8)%20%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%20beq%20%20CTRL%20%20%20%20%7C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%20CTRL%3A%20%20%20%20%20%20%20%20%7C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%20isync%20%20%20%20%20%20%20%20%7C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%20lwz%20r3%2C0(r8)%20%7C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3B%5Cn%5Cnexists%20(1%3Ar1%3D1%20%2F%5C%5C%201%3Ar3%3D3%20%2F%5C%5C%202%3Ar2%3D0)%22%2C%22model_options%22%3A%7B%22model%22%3A%22pldi11%22%2C%22embedding%22%3A%22interpreter%22%2C%22force_sc%22%3A%22false%22%2C%22fetch_flat_idc%22%3A%22on%22%2C%22fetch_flat_dic%22%3A%22on%22%2C%22sequential_fetch%22%3A%22true%22%2C%22tree_speculation%22%3A%22allow%22%2C%22promise_first%22%3A%22anytime%22%2C%22flowing_topology_2%22%3A%22%5B0%2C1%5D%22%2C%22flowing_topology_3%22%3A%22%5B0%2C1%2C2%5D%22%2C%22flowing_topology_4%22%3A%22%5B0%2C1%2C2%2C3%5D%22%7D%2C%22history%22%3A%5B%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%223%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%224%22%2C%226%22%2C%223%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%223%22%2C%224%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%224%22%2C%223%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%224%22%2C%223%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%222%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%222%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%226%22%2C%223%22%2C%224%22%2C%222%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%223%22%2C%221%22%2C%224%22%2C%221%22%2C%222%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%221%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%220%22%2C%225%22%5D%2C%22panes%22%3A%7B%22horizontal%22%3A%7B%22sizes%22%3A%5B50%2C50%5D%2C%22contents%22%3A%5B%7B%22vertical%22%3A%7B%22sizes%22%3A%5B50.10775862068966%2C49.89224137931034%5D%2C%22contents%22%3A%5B%7B%22pane%22%3A%22state%22%7D%2C%7B%22vertical%22%3A%7B%22sizes%22%3A%5B49.94577006507592%2C49.94577006507592%5D%2C%22contents%22%3A%5B%7B%22pane%22%3A%22console%22%7D%2C%7B%22pane%22%3A%22help%22%7D%5D%7D%7D%5D%7D%7D%2C%7B%22vertical%22%3A%7B%22sizes%22%3A%5B50%2C50%5D%2C%22contents%22%3A%5B%7B%22pane%22%3A%22graph%22%7D%2C%7B%22pane%22%3A%22sources%22%7D%5D%7D%7D%5D%7D%7D%7D">this example</a> demonstrates the same behavior using regular stores and loads.</p><p>And there we have it, the trickiest part of this post! From here, we’re ready to transition back into the world of C++.</p><p>Let’s explore what strongly happens-before actually means, as defined in <a href="https://eel.is/c++draft/intro.multithread#intro.races-8">[intro.races]/8</a>.</p><blockquote><p>An evaluation A strongly happens before an evaluation D if, either</p><ul><li>A is sequenced before D, or</li><li>A synchronizes with D, and both A and D are sequentially consistent atomic operations, or</li><li>there are evaluations B and C such that A is sequenced before B, B happens before C, and C is sequenced before D, or</li><li>there is an evaluation B such that A strongly happens before B, and B strongly happens before D.</li></ul></blockquote><p>Now let’s revisit our example:</p><p><a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-light.png" alt="RF Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-dark.png" alt="RF Execution Graph" loading="lazy"/></a> <em>Execution Graph with Read-Before Relationship</em></p><p>Here, observe that the relation $(2) \rightarrow (4)$ does not satisfy any of the above conditions, so it does not qualify as a strongly happens-before relationship. As a result, in the single total order on all sequentially consistent operations, $(2) \rightarrow (4)$ is not necessarily preserved. In fact, to reflect the current observed behavior, we must not have $(2) \rightarrow (4)$. A valid total order consistent with this execution would be: $(4) \rightarrow (6) \rightarrow (7) \rightarrow (2)$.</p><p>Let’s take a look at the conditions that stands out here:</p><blockquote><ul><li>A synchronizes with D, and both A and D are sequentially consistent atomic operations, or</li><li>there are evaluations B and C such that A is sequenced before B, B happens before C, and C is sequenced before D</li></ul></blockquote><p>Recall from <a href="https://eel.is/c++draft/atomics.order#2">[atomics.order]/2</a>:</p><blockquote><p>An atomic operation A that performs a release operation on an atomic object M synchronizes with an atomic operation B that performs an acquire operation on M and takes its value from any side effect in the release sequence headed by A.</p></blockquote><p>The first condition above is especially interesting as it’s not immediately obvious why both A and D must be sequentially consistent atomic operations. The crucial insight is that on the Power architecture, A and D will both have a <code>sync</code>/<code>hwsync</code> before them (for leading sync; trailing sync is shown in the diagram below).</p><p><a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sw-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sw-light.png" alt="Synchronizes With Example" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sw-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sw-dark.png" alt="Synchronizes With Example" loading="lazy"/></a> <em>Synchronizes With Example Where A and D Are Sequentially Consistent</em></p><p>Note that D, and any sequentially consistent atomic operations that strongly happen after D, must observe the effects of those that strongly happen before A, precisely due to the placement of <code>sync</code>/<code>hwsync</code>.</p><p>The second condition is equally fascinating. It ensures that a <code>sync</code>/<code>hwsync</code> must exist somewhere along the path, thereby enforcing sequential consistency, even on Power.</p><p><a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sb-hb-sb-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sb-hb-sb-light.png" alt="SB-HB-SB Example" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sb-hb-sb-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/sb-hb-sb-dark.png" alt="SB-HB-SB Example" loading="lazy"/></a> <em>Sequenced Before $\rightarrow$ Happens Before $\rightarrow$ Sequenced Before Example</em></p><p><a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-light.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-light.png" alt="RF Execution Graph" loading="lazy"/></a> <a href="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-dark.png"><img src="https://nekrozqliphort.github.io/assets/img/posts_img/2025-08-11-happens-b4/rb-dark.png" alt="RF Execution Graph" loading="lazy"/></a> <em>Execution Graph with Read-Before Relationship</em> Let’s look at our example one more time. Earlier, we noted that the total order of sequentially consistent operations must not include $(2) \rightarrow (4)$. But at the same time, $(2)$ happens before $(4)$. Isn’t that a bit strange?</p><p>Indeed, this subtlety is even acknowledged in a note under <a href="https://eel.is/c++draft/atomics.order#6">[atomics.order]/6</a>. This behavior only arises when mixing sequentially consistent and non-sequentially consistent operations on the same atomic object. As always, mixing memory orders is tricky, especially when subtle interactions like this come into play.</p><p>And that’s a wrap! If you managed to read till here, thank you! This took quite a bit of effort to write up as it is not easy to understand all the necessary prerequisites. Special thanks to Prof. Peter Sewell for pointing me to the tools available for verifying executions for Power.</p><p>Till next time!</p><ol><li><a href="https://plv.mpi-sws.org/scfix/paper.pdf">Repairing Sequential Consistency in C/C++11</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0668r5.html">Proposal p0668r5</a></li><li><a href="https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html">C/C++11 mappings to processors</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2745.html">Example POWER Implementation for C/C++ Memory Model</a></li><li><a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf">Understanding POWER Multiprocessors</a></li><li><a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test7.pdf">A Tutorial Introduction to the ARM and POWER Relaxed Memory Models</a></li><li><a href="https://www.cl.cam.ac.uk/~sf502/regressions/rmem/">rmem Tool</a></li><li><a href="https://github.com/herd/herdtools7">herd7 Tool</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf">Working Draft Programming Languages — C++</a></li></ol></div></div>
  </body>
</html>
