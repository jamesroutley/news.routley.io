<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://people.csail.mit.edu/rachit/post/transpiler/">Original</a>
    <h1>Transpiler, a Meaningless Word (2023)</h1>
    
    <div id="readability-page-1" class="page"><section>
    <div>
      


<div>
<p>This tool is different from a <em>compiler</em> which often has a complex frontend, an optimizing middle end, and code generators for various backends.
The big problem around most of the arguments to distinguish between compilers and “transpilers” focus on language syntax. However, anyone who wants one of these tools to <em>actually work</em> has to contend with the fact that different languages will have different <em>semantics</em> and translating between those is a complex task; a task that <em>compilers</em> already do.</p>
<h2 id="lie-1-transpilers-don-t-have-frontends">Lie #1: Transpilers Don’t have Frontends</h2>
<p>Let’s look at a simple Python to C transpiler.<span>
<label for="sn-1">
</label>
</span>

<span>
Both <a rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/Nuitka/Nuitka">Nuitka</a> and <a rel="noopener nofollow noreferrer" target="_blank" href="https://docs.modular.com/mojo/">Mojo</a> both actually target this exact problem but sanely call themselves compilers.
</span>
 It takes python code that looks like this:</p>
<pre data-lang="py"><code data-lang="py"><span>def </span><span>fact</span><span>(</span><span>n</span><span>):
</span><span>    x = </span><span>1
</span><span>    </span><span>for </span><span>i </span><span>in </span><span>range</span><span>(</span><span>1</span><span>, n):
</span><span>        x *= i
</span><span>    </span><span>return </span><span>x
</span></code></pre>
<p>Into some C code like this:</p>
<pre data-lang="C"><code data-lang="C"><span>int </span><span>fact</span><span>(</span><span>int </span><span>n</span><span>) {
</span><span>    </span><span>int</span><span> x = </span><span>1</span><span>;
</span><span>    </span><span>for </span><span>(</span><span>int</span><span> i = </span><span>1</span><span>; i &lt; n; i++) {
</span><span>        x *= i;
</span><span>    }
</span><span>    </span><span>return</span><span> x;
</span><span>}
</span></code></pre>
<p>Wow, pretty simple! But of course, that piece of python is not very idiomatic. We can make it a bit more terse using list comprehensions:</p>
<pre data-lang="py"><code data-lang="py"><span>import </span><span>functools </span><span>as </span><span>ft
</span><span>def </span><span>fact</span><span>(</span><span>n</span><span>):
</span><span>    lst = </span><span>range</span><span>(</span><span>1</span><span>, n)
</span><span>    </span><span>return </span><span>ft.</span><span>reduce</span><span>(</span><span>lambda </span><span>acc</span><span>, </span><span>x</span><span>: acc*x, lst)
</span></code></pre>
<p>Now our “transpiler” is in a little bit of trouble.
The <a rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/python/cpython/blob/main/Lib/functools.py#L237">implementation of <code>reduce</code></a> is in pure Python so maybe we can still transpile it but <a rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/python/cpython/blob/d66bc9e8a7a8d6774d912a4b9d151885c4d8de1d/Objects/rangeobject.c#L24"><code>range</code> is implemented purely in C</a>.</p>
<p>Looking into the implementation, what’s even clearer is that matching the <em>semantics of this program</em> is even harder:
<code>range</code> is a Python generator which means that instead of actually computing the numbers from 1 to <code>n</code>, it only produces them when asked.
This allows our method to save memory because we don’t actually have to allocate <code>n</code> words and can work using just the memory for the lazy
implementation of the generator and the local variables.</p>
<p>Another problem is that there are hundreds of built-in library functions that need to be compiled from Python from C.
Even a moderately useful subset would be unwieldy to implement by hand in our simple “transpiler”.
Maybe one strategy we can take is to build a some sort of tool that would simplify these hundreds of definitions into a more uniform representation
to work with.</p>
<p>We’ll call it the <em>transpiler-not-frontend</em> to make sure people understand we’re not building a compiler here.<span>
<label for="sn-2">
</label>
</span>

<span>
It is <a rel="noopener nofollow noreferrer" target="_blank" href="https://github.com/topics/transpiler">not hard</a> to find examples of things mislabelled as transpilers. However, I won’t name any specific projects because this is just a dumb diatribe about words, I actually think the projects themselves are cool.
</span>
</p>
<h2 id="lie-2-transpilers-are-simple">Lie #2: Transpilers are Simple</h2>
<p>BabelJS is arguably one of the first “transpilers” that was developed so that people could experiment with JavaScript’s new language features that did not yet have browser implementations.<span>
<label for="sn-3">
</label>
</span>

<span>
Technically, ECMAScript features.
</span>
</p><p>For example, ES6 added support for generators (similar to those in Python) but a lot of browser frontends did not support them.
Generators are pretty nice:</p>
<pre data-lang="js"><code data-lang="js"><span>function *</span><span>range</span><span>(</span><span>max</span><span>) {
</span><span>  </span><span>for </span><span>(</span><span>var </span><span>i </span><span>= </span><span>0</span><span>; </span><span>i </span><span>&lt; </span><span>max</span><span>; </span><span>i </span><span>+= </span><span>1</span><span>) {
</span><span>    </span><span>yield </span><span>i</span><span>;
</span><span>  }
</span><span>}
</span><span>// Force the evaluation of the generator
</span><span>console</span><span>.</span><span>log</span><span>([</span><span>0</span><span>, ...</span><span>range</span><span>(</span><span>10</span><span>)])
</span></code></pre>
<p>Facebook’s <a rel="noopener nofollow noreferrer" target="_blank" href="http://facebook.github.io/regenerator/">regenerator</a> is a BabelJS-based “transpiler” to transform generators into language constructs that already existed
in JavaScript. Shouldn’t be too hard, right?</p>
<pre data-lang="js"><code data-lang="js"><span>var </span><span>_marked </span><span>= </span><span>/*#__PURE__*/</span><span>regeneratorRuntime</span><span>.</span><span>mark</span><span>(</span><span>range</span><span>);
</span><span>function </span><span>range</span><span>(</span><span>max</span><span>) {
</span><span>  </span><span>var </span><span>i</span><span>;
</span><span>  </span><span>return </span><span>regeneratorRuntime</span><span>.</span><span>wrap</span><span>(</span><span>function </span><span>range$</span><span>(</span><span>_context</span><span>) {
</span><span>    </span><span>while </span><span>(</span><span>1</span><span>) {
</span><span>      </span><span>switch </span><span>(</span><span>_context</span><span>.</span><span>prev </span><span>= </span><span>_context</span><span>.next) {
</span><span>        </span><span>case </span><span>0</span><span>:
</span><span>          </span><span>i </span><span>= </span><span>0</span><span>;
</span><span>        </span><span>case </span><span>1</span><span>:
</span><span>          </span><span>if </span><span>(!(</span><span>i </span><span>&lt; </span><span>max</span><span>)) {
</span><span>            </span><span>_context</span><span>.next = </span><span>7</span><span>;
</span><span>            </span><span>break</span><span>;
</span><span>          }
</span><span>          </span><span>_context</span><span>.next = </span><span>4</span><span>;
</span><span>          </span><span>return </span><span>i</span><span>;
</span><span>        </span><span>case </span><span>4</span><span>:
</span><span>          </span><span>i </span><span>+= </span><span>1</span><span>;
</span><span>          </span><span>_context</span><span>.next = </span><span>1</span><span>;
</span><span>          </span><span>break</span><span>;
</span><span>        </span><span>case </span><span>7</span><span>:
</span><span>        </span><span>case </span><span>&#34;</span><span>end</span><span>&#34;:
</span><span>          </span><span>return </span><span>_context</span><span>.</span><span>stop</span><span>();
</span><span>      }
</span><span>    }
</span><span>  }, </span><span>_marked</span><span>);
</span><span>}
</span><span>// Force the evaluation of the generator
</span><span>console</span><span>.</span><span>log</span><span>([</span><span>0</span><span>, ...</span><span>range</span><span>(</span><span>10</span><span>)]);
</span></code></pre>
<p>Guess what, it is. Implementing generators is a <em>whole-program transformation</em>: they fundamentally rely on the ability of the program to save its internal stack and pause its execution. In fact, making it fast requires enough tricks that <a href="https://people.csail.mit.edu/files/pubs/stopify-pldi18.pdf">we wrote a paper on it</a>.</p>
<p>The point here is that people call arbitrarily complex tools “transpilers”. Again, the problem is the misguided focus on language syntax and a lack of understanding of the semantic difference.</p>
<h2 id="lie-3-transpilers-target-the-same-level-of-abstraction">Lie #3: Transpilers Target the Same Level of Abstraction</h2>
<p>This is pretty much the same as (2). The input and output languages have the syntax of JavaScript but the fact that compiling <em>one feature</em> requires a whole program transformation gives away the fact that these are not <em>the same language</em>.
If we’re to get beyond the vagaries of syntax and <em>actually</em> talk about what the expressive power of languages is, we need to <a rel="noopener nofollow noreferrer" target="_blank" href="https://www.youtube.com/watch?v=43XaZEn2aLc">talk about semantics</a>.</p>
<h2 id="lie-4-transpilers-don-t-have-backends">Lie #4: Transpilers Don’t have Backends</h2>
<p>BabelJS has a <a rel="noopener nofollow noreferrer" target="_blank" href="https://babeljs.io/docs/babel-preset-env">list of “presets”</a> which target different versions of JavaScript.
This is not very different from LLVM having multiple different backends.<span>
<label for="sn-4">
</label>
</span>

<span>
If you’re going to argue that the backends all compile to the same language, see (3).
</span>
 People might argue that when Babel is compiling its operations, it can do it piecemeal: that is, the compilation of <a rel="noopener nofollow noreferrer" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment">nullish coaleascing operators</a> has nothing to how classes are compiled.</p>
<p>This is exactly what compiler frontends do as well: they transform a large surface area of syntax into a smaller language and a lot of operations are simple <em>syntactic sugar</em> which can be represented using other, more foundational primitives in the language.
For example, in the Rust compiler, the mid-level representation (MIR) does away with features like <code>if</code>-<code>let</code> by compiling them into <code>match</code> statements. In fact, <code>clippy</code>, a style suggestion tool for Rust, <em>implements this as source-to-source transformation</em>: if you have <a rel="noopener nofollow noreferrer" target="_blank" href="https://rust-lang.github.io/rust-clippy/master/index.html#/single_match">simple <code>match</code> statements in your program</a> in your program, Clippy will suggest a rewrite to you.</p>
<p>Compilers already do things that “transpilers” are supposed to do. And they do it better because they are built on the foundation of language semantics instead of syntactic manipulation.</p>
<h2 id="lie-5-compilers-only-target-machine-code">Lie #5: Compilers only Target Machine Code</h2>
<p>This one is interesting because instead of defining the characteristics of a “transpiler”, it focuses on <em>restricting</em> the definition of a compiler.
Unfortunately, this one too is wrong. The term is widely used in many contexts where we are not generating assembly code and instead generating bytecode for some sort of virtual machine.
For example, the JVM has an ahead-of-time compiler from Java source code to the JVM bytecode and another just-in-time compiler to native instructions. These kinds of multi-tier compilation schemes are extremely common in dynamic languages like JavaScript as well.</p>
<h2 id="lie-6-transpilers-are-not-compilers">Lie #6: Transpilers are not Compilers</h2>
<p>People seemed to scared of compilers and resort to claims like “I don’t want something as complex”, or “string interpolation is good enough”. This is silly. Anyone who has built one of these “transpilers” knows that inevitably, they get complex and poorly maintained precisely because of the delusion that they aren’t doing something complex.</p>
<p>Programming languages are not just syntax; they have semantics too.
Pretending that you can get away with just manipulating the former is delusional and results in bad tools.</p>
<p><em>Lindsey Kuper has a <a rel="noopener nofollow noreferrer" target="_blank" href="https://decomposition.al/blog/2017/07/30/what-do-people-mean-when-they-say-transpiler/">well-written article</a> on the same topic.</em></p>

</div>


    </div>
  </section></div>
  </body>
</html>
