<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://vrroom.github.io/blog/2024/02/23/comic-frame-segmentation.html">Original</a>
    <h1>Segmenting Comic book Frames</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p><em>This post is based on my project in my Computer Vision class last semester</em></p>



<p>As I was learning classical techniques in my Computer Vision class, I came across a <a href="https://maxhalford.github.io/blog/comic-book-panel-segmentation/">blog post</a> by Max Halford on extracting frames from comic books. He developed a very interesting algorithm where he applied <em>Canny</em> to detect the boundary of frames, filled holes and fit bounding boxes to contiguous regions.</p>

<p>This elegant algorithm did the job very well but had its shortcomings. For one, it didn’t handle arbitrary, un-aligned polygons and didn’t work on <em>negative frames</em>, which didn’t have a boundary of their own, but rather were defined by the boundaries of neighboring frames.</p>

<p>Given the hype around <em>foundation models</em> for segmentation such as <a href="https://github.com/facebookresearch/segment-anything">SAM</a>, I approached this problem by procedurally generating a synthetic dataset of comic books and finetuning SAM to detect the corner points of frames.</p>

<div>
<table>
<tbody><tr>
<td>
  <img src="https://vrroom.github.io/assets/comic_frame_seg/comic_panels.png" width="300px"/>
</td>
</tr>
</tbody><caption>Failure cases of heuristic approaches: (Top) Frames from Pepper and Carrot by David Revoy are polygons and not axis-aligned bounding boxes. (Bottom) Negative frames may not have a well defined border. </caption>
</table>
</div>



<p>There isn’t abundant data available for this problem. But that doesn’t mean that we should hold our head in our hands. A common technique that is widely used (see <a href="https://errollw.com/">Erroll Wood’s</a> work) is to procedurally generate training data.</p>

<p>In our case, this means simulating comic books. Note, we don’t really need to make gripping animations and tell a story, we just need to generate panels that look like comics from 50,000 feet. In order to do this, I wrote a procedural generator of layouts and assigned random boxes on an empty image. I filled these boxes with images sampled from the <a href="https://danbooru.donmai.us/">Danbooru</a> dataset.</p>

<p>In order to ensure that the sampled images were atleast semi-coherant, I used <a href="https://github.com/openai/CLIP">CLIP L/14 image encoder</a> to create an image index. While choosing images for a particular page, I sampled one image at random from Danbooru and filled the rest of the boxes using it’s k-nearest neighbors.</p>

<p>With this procedural generator, I had complete control of the size, shape and boundary properties of the box, which I could set appropriately to simulate <em>negative</em> and <em>polygonal</em> frames.</p>





<p>I used SAM as the backbone for my model. SAM is the state-of-the-art image segmentation model. It consists of a heavy, compute expensive image encoder and a light-weight decoder, which answers segmentation queries. The heavy encoder encodes an image only once, after which multiple segmentation queries are answered cheaply. This division of labor is particularly useful for deployment, where an enterprise serving a user can optimize for both speed and costs by keeping the heavy encoder inference on the cloud and using the user’s device for light-weight inference.</p>

<p>Since SAM predicts dense, per pixel mask, I modified it to predict points instead. An overview of the model can be seen below. The procedurally generated comic frame is fed to the image encoder (whose weights remain unchanged during training). A point is randomly sampled from a frame and given as a query/prompt. The light-weight decoder is trained to recover the corners of the frame.</p>

<div>
<table>
<tbody><tr>
<td>
  <img src="https://vrroom.github.io/assets/comic_frame_seg/architecture.png" width="500px"/>
</td>
</tr>
</tbody><caption>Model Overview</caption>
</table>
</div>

<p>I learned two lessons while training this model. Firstly, it was important to canonicalize the order in which the corners of the frame were predicted. Without this, the model got conflicting signals on the ordering of corner points and never converged. Secondly, it was important to use L1 instead of L2 loss since L2 optimized very quickly without improving the quality of predictions.</p>



<p>I compared my method against original SAM and Halford’s method. Note that Halford’s method is a bit disadvantaged in this comparison since my method also uses a query (set to the center of the ground truth frame to be predicted). Despite this, it is evident that our model trained on our procedurally generated dataset, generalizes on “real-world” comics (Pepper and Carrot abbrev. as P&amp;C), coming close to Halford in the process. It beats Halford on procedurally generated dataset (abbrev. Pr), since this dataset is designed to expose the flaws in the method.</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th>IoU (P&amp;C)</th>
      <th>PCK@0.1 (P&amp;C)</th>
      <th>L1 (P&amp;C)</th>
      <th>IoU (Pr)</th>
      <th>PCK@0.1 (Pr)</th>
      <th>L1 (Pr)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>SAM</td>
      <td>0.42</td>
      <td>0.52</td>
      <td>0.37</td>
      <td>0.81</td>
      <td>0.94</td>
      <td>0.08</td>
    </tr>
    <tr>
      <td>Halford</td>
      <td><strong>0.93</strong></td>
      <td>0.96</td>
      <td><strong>0.04</strong></td>
      <td>0.47</td>
      <td>0.61</td>
      <td>0.47</td>
    </tr>
    <tr>
      <td>Ours</td>
      <td>0.88</td>
      <td><strong>0.98</strong></td>
      <td>0.05</td>
      <td><strong>0.88</strong></td>
      <td><strong>0.99</strong></td>
      <td><strong>0.03</strong></td>
    </tr>
  </tbody>
</table>

<p>Here, IoU simply measures the area of intersection over union of the ground truth and predicted frames. PCK@0.1 refers to the percentage of times, the predicted frame corner lies within certain radius of the ground truth frame corner (0.1 refers to the radius as a percentage of the diagonal of the comic page). L1 is simply the L1 distance between ground truth and predicted frames.</p>

<p>Below are some qualitative results which demonstrate that our method works on “real-world” comics. We run it in two modes. On the left, we interactively provide a query and the model produces the corners. On the right, we sample a bunch of query on the image, predict polygons and filter them using <em>non-maximal suppression</em> like the original SAM paper.</p>





<p>There are still shortcomings to my method and it can often fail for complex, cluttered comic pages. But still, I like this approach to designing algorithm over composing OpenCV functions because it is often easier to see how to improve the dataset than to design new heuristics. Once you do that, you almost have a guarantee that the Neural Network machinery will get you the results.</p>

<p>The annotated Pepper and Carrot dataset that I used for evaluation can be found in my <a href="https://drive.google.com/file/d/1z8OE8TC8eupC6_ZNxUSVyfvk4rSkVIgE">drive link</a>. All my code and checkpoints are available in my <a href="https://github.com/Vrroom/segment-anything-comic">Github Repo</a>. If you think of any improvements to my approach, feel free to reach out!</p>

<hr/>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
