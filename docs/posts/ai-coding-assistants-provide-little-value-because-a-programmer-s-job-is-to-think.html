<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.doliver.org/articles/programming-is-a-thinkers-game">Original</a>
    <h1>AI Coding assistants provide little value because a programmer&#39;s job is to think</h1>
    
    <div id="readability-page-1" class="page"><div data-mdx-content="true"><p>Written code is a strikingly poor representation of a running program. Consider this event listener:</p>
<pre><code>const thing = document.querySelector(&#34;#thing&#34;);

thing.addEventListener(&#34;click&#34;, () =&gt; {
    console.log(&#34;this is: &#34;, this);
});
</code></pre>
<p>Almost none of what we need to reason about this effectively is represented in
the text of this little script:</p>
<ul>
<li>Nothing indicates how this should be run. Basic programming intuition tells
us that we should run something that interprets this, but the process with
browsers is far more circuitous than that.</li>
<li><code>getElementById</code>, <code>addEventListener</code>, and <code>console.log</code> are not functions
whose definitions are available within the script. Without external context,
we don&#39;t know what they do.</li>
<li>The script is most likely intended to run in E environments with V versions,
which really means ExV environments. Whether or not it will work in every
environment is not directly discoverable by any means (it requires human
reasoning and judgement).</li>
<li>The event handler will run in response to a click event which is an inversion
of control that means execution doesn&#39;t flow from top to bottom</li>
<li>In the handler, it&#39;s completely unclear that <code>this</code> is the <code>window</code>, which is
also the global object that can be referenced implicitly, so we could end up
defining values here that could be na√Øvely referenced from another scope.</li>
<li>The handler implicitly ignores arguments</li>
<li>Odds are good that this will be bundled, meaning that without additional
effort for source mapping, stack traces on runtime errors will be incorrect.</li>
<li><code>#thing</code> references a DOM element that&#39;s out of context here. The syntax used
refers back to CSS selectors - a concept defined in an entirely different
language.</li>
<li>This won&#39;t work if it&#39;s executed before the DOM has loaded.</li>
</ul>
<p>These are four lines of code from a script that does next to nothing. Obviously,
any real application will be far more complex.</p>
<p>I hear you saying, &#34;Just because JavaScript is trash doesn&#39;t mean that every
programming language is.&#34; And, I&#39;ll admit that I chose JavaScript because it&#39;s
on the more extreme side of written languages underrepresenting their runtime
considerations. But, between finite and unreliable resources, concurrency,
different environments, integrations, allocation, provisioning, functional
requirements, and so on, I think you&#39;ll find that the point stands: <strong>Written
code is not reflective of running code</strong>.</p>
<p>Of course, we humans, experienced engineers, are very capable of understanding
and reasoning about how the resulting program will run. But we can see that
thinking through all of these things that are not represented by the code is
critical and complex.</p>
<p>It&#39;s easy to write bad code that looks like it might work; writing good code
that <em>does</em> work is much more time consuming. So, engineering workflows should
be more about thinking and discussing than writing code. And, given the
plethora of battle-tested packages and example code out there, and given that
most code applications (packages, programs, web apps, etc.) are fairly similar
to each other, reasoning about our code application and filling in the gaps for
the 10% of our work that&#39;s actually different from everything else is really
what software engineering is really about.</p>
<p>This, then, is the problem with AI coding: Someone says, &#34;Eureka! I just made a
bot that will churn out code chunks that look like they might go together!&#34; But
AI doesn&#39;t think -- it predicts patterns in language. In other words, it writes
bad code that looks like it might work. When we use AI generated code:</p>
<ul>
<li>We have to go back and verify what the AI did</li>
<li>It&#39;s nearly always wrong for non-trivial things because it&#39;s not an engineer</li>
<li>Even if we keep some of what the AI did, it&#39;s harder to verify what it did
than what we would have done because:<!-- -->
<ol>
<li>It can&#39;t really explain it</li>
<li>It has slapped together pieces incoherently</li>
<li>It&#39;ll prefer inlining idioms over building useful abstractions, meaning
there&#39;s just more to read</li>
</ol>
</li>
</ul>
<p>The result is that we get a lot of bad code (the easy part) at the expense of
understanding and quality (the hard part). So, all in all, it&#39;s a pretty shitty
tradeoff.</p>
<p>On the other hand, modules offer interfaces, documentation, and well thought
out abstractions that get reusable code out of your hair. Example code from
project documentation and SO questions provide context on how code samples
work. Open source projects provide, at a minimum, relevant context and project
documentation. All of these are better alternatives to AI generated code that
enable engineers to do the <em>hard</em> things well.</p>
<p>I&#39;m reminded of <a href="https://lwn.net/2000/0914/a/lt-debugger.php3">something Linus Torvalds wrote on the subject of using
debuggers in the Linux kernel</a>:</p>
<blockquote>
<p>It&#39;s partly &#34;source vs binary&#34;, but it&#39;s more than that. It&#39;s not that you
have to look at the sources (of course you have to - and any good debugger
will make that <em>easy</em>). It&#39;s that you have to look at the level <em>above</em>
sources. At the meaning of things. Without a debugger, you basically have
to go the next step: understand what the program does. Not just that
particular line.</p>
<p>And quite frankly, for most of the real problems (as opposed to the stupid
bugs - of which there are many, as the latest crap with &#34;truncate()&#34; has
shown us) a debugger doesn&#39;t much help. And the real problems are what I
worry about. The rest is just details. It will get fixed eventually.</p>
</blockquote>
<p>Writing code is easy, but programming well is hard, and it&#39;s a thinker&#39;s game.</p></div></div>
  </body>
</html>
