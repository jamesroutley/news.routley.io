<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://netflixtechblog.com/maestro-netflixs-workflow-orchestrator-ee13a06f9c78">Original</a>
    <h1>Maestro: Netflix&#39;s Workflow Orchestrator</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><div><div><div><div><div><div><div><div><div><a href="https://netflixtechblog.medium.com" rel="noopener follow"><div><div aria-hidden="false"><div><div><p><img alt="Netflix Technology Blog" src="https://miro.medium.com/v2/resize:fill:88:88/1*BJWRqfSMf9Da9vsXG9EBRQ.jpeg" width="44" height="44" loading="lazy" data-testid="authorPhoto"/></p></div></div></div></div></a><a href="https://netflixtechblog.com" rel="noopener  ugc nofollow"><div><div><div aria-hidden="false"><div><div><p><img alt="Netflix TechBlog" src="https://miro.medium.com/v2/resize:fill:48:48/1*ty4NvNrGg4ReETxqU2N3Og.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto"/></p></div></div></div></div></div></a></div></div><div><div><p><span><div><p><span><div><p><span data-testid="storyReadTime">18 min read</span></p><p><span aria-hidden="true"><span>·</span></span></p><p>18 hours ago</p></div></span></p></div></span></p></div></div></div></div></div></div></div><p id="0ec7">By <a href="https://www.linkedin.com/in/jheua/" rel="noopener ugc nofollow" target="_blank">Jun He</a>, <a href="https://www.linkedin.com/in/natalliadzenisenka/" rel="noopener ugc nofollow" target="_blank">Natallia Dzenisenka</a>, <a href="https://www.linkedin.com/in/praneethy91/" rel="noopener ugc nofollow" target="_blank">Praneeth Yenugutala</a>, <a href="https://www.linkedin.com/in/yingyi-zhang-a0a164111/" rel="noopener ugc nofollow" target="_blank">Yingyi Zhang</a>, and <a href="https://www.linkedin.com/in/anjali-norwood-9521a16" rel="noopener ugc nofollow" target="_blank">Anjali Norwood</a></p><p id="3080">We are thrilled to announce that the Maestro source code is now open to the public! Please visit the <a href="https://github.com/Netflix/maestro" rel="noopener ugc nofollow" target="_blank">Maestro GitHub repository</a> to get started. If you find it useful, please <a href="https://github.com/Netflix/maestro" rel="noopener ugc nofollow" target="_blank">give us a star</a>.</p><h2 id="2bef">What is Maestro</h2><p id="3756">Maestro is a general-purpose, horizontally scalable workflow orchestrator designed to manage large-scale workflows such as data pipelines and machine learning model training pipelines. It oversees the entire lifecycle of a workflow, from start to finish, including retries, queuing, task distribution to compute engines, etc.. Users can package their business logic in various formats such as Docker images, notebooks, bash script, SQL, Python, and more. Unlike traditional workflow orchestrators that only support Directed Acyclic Graphs (DAGs), Maestro supports both acyclic and cyclic workflows and also includes multiple reusable patterns, including foreach loops, subworkflow, and conditional branch, etc.</p><h2 id="6c09">Our Journey with Maestro</h2><p id="f334">Since we first introduced Maestro in <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/orchestrating-data-ml-workflows-at-scale-with-netflix-maestro-aaa2b41b800c">this blog post</a>, we have successfully migrated hundreds of thousands of workflows to it on behalf of users with minimal interruption. The transition was seamless, and Maestro has met our design goals by handling our ever-growing workloads. Over the past year, we’ve seen a remarkable 87.5% increase in executed jobs. Maestro now launches thousands of workflow instances and runs half a million jobs daily on average, and has completed around 2 million jobs on particularly busy days.</p><h2 id="fd3e">Scalability and Versatility</h2><p id="5f06">Maestro is a fully managed workflow orchestrator that provides Workflow-as-a-Service to thousands of end users, applications, and services at Netflix. It supports a wide range of workflow use cases, including ETL pipelines, ML workflows, AB test pipelines, pipelines to move data between different storages, etc. Maestro’s horizontal scalability ensures it can manage both a large number of workflows and a large number of jobs within a single workflow.</p><p id="c621">At Netflix, workflows are intricately connected. Splitting them into smaller groups and managing them across different clusters adds unnecessary complexity and degrades the user experience. This approach also requires additional mechanisms to coordinate these fragmented workflows. Since Netflix’s data tables are housed in a single data warehouse, we believe a single orchestrator should handle all workflows accessing it.</p><p id="986e">Join us on this exciting journey by exploring the <a href="https://github.com/Netflix/maestro" rel="noopener ugc nofollow" target="_blank">Maestro GitHub repository</a> and contributing to its ongoing development. Your support and feedback are invaluable as we continue to improve the Maestro project.</p><p id="4941">Netflix Maestro offers a comprehensive set of features designed to meet the diverse needs of both engineers and non-engineers. It includes the common functions and reusable patterns applicable to various use cases in a loosely coupled way.</p><p id="1921">A workflow definition is defined in a JSON format. Maestro combines user-supplied fields with those managed by Maestro to form a flexible and powerful orchestration definition. An example can be found in the <a href="https://github.com/Netflix/maestro/wiki/Workflow-definition-example" rel="noopener ugc nofollow" target="_blank">Maestro repository wiki</a>.</p><p id="2ac0">A Maestro workflow definition comprises two main sections: properties and versioned workflow including its metadata. Properties include author and owner information, and execution settings. Maestro preserves key properties across workflow versions, such as author and owner information, run strategy, and concurrency settings. This consistency simplifies management and aids in trouble-shootings. If the ownership of the current workflow changes, the new owner can claim the ownership of the workflows without creating a new workflow version. Users can also enable the triggering or alerting features for a given workflow over the properties.</p><p id="656f">Versioned workflow includes attributes like a unique identifier, name, description, tags, timeout settings, and criticality levels (low, medium, high) for prioritization. Each workflow change creates a new version, enabling tracking and easy reversion, with the active or the latest version used by default. A workflow consists of steps, which are the nodes in the workflow graph defined by users. Steps can represent jobs, another workflow using subworkflow step, or a loop using foreach step. Steps consist of unique identifiers, step types, tags, input and output step parameters, step dependencies, retry policies, and failure mode, step outputs, etc. Maestro supports configurable retry policies based on error types to enhance step resilience.</p><p id="cf60">This high-level overview of Netflix Maestro’s workflow definition and properties highlights its flexibility to define complex workflows. Next, we dive into some of the useful features in the following sections.</p><h2 id="5be6">Workflow Run Strategy</h2><p id="ae40">Users want to automate data pipelines while retaining control over the execution order. This is crucial when workflows cannot run in parallel or must halt current executions when new ones occur. Maestro uses predefined run strategies to decide whether a workflow instance should run or not. Here is the list of predefined run strategies Maestro offers.</p><p id="a617"><strong>Sequential Run Strategy</strong></p><p id="9d17"><strong>Strict Sequential Run Strategy<br/></strong>With this run strategy, Maestro will run workflows in the order they are triggered but block execution if there’s a blocking error in the workflow instance history. Newly triggered workflow instances are queued until the error is resolved by manually restarting the failed instances or marking the failed ones unblocked.</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*NvdLiYWhhWb0tvL- 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*NvdLiYWhhWb0tvL- 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*NvdLiYWhhWb0tvL- 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*NvdLiYWhhWb0tvL- 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*NvdLiYWhhWb0tvL- 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*NvdLiYWhhWb0tvL- 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NvdLiYWhhWb0tvL- 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*NvdLiYWhhWb0tvL- 640w, https://miro.medium.com/v2/resize:fit:720/0*NvdLiYWhhWb0tvL- 720w, https://miro.medium.com/v2/resize:fit:750/0*NvdLiYWhhWb0tvL- 750w, https://miro.medium.com/v2/resize:fit:786/0*NvdLiYWhhWb0tvL- 786w, https://miro.medium.com/v2/resize:fit:828/0*NvdLiYWhhWb0tvL- 828w, https://miro.medium.com/v2/resize:fit:1100/0*NvdLiYWhhWb0tvL- 1100w, https://miro.medium.com/v2/resize:fit:1400/0*NvdLiYWhhWb0tvL- 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="An example of strict sequential run strategy" width="700" height="267" loading="lazy"/></picture></div></div></figure><p id="8320">In the above example, run5 fails at 5AM, then later runs are queued but do not run. When someone manually marks run5 unblocked or restarts it, then the workflow execution will resume. This run strategy is useful for time insensitive but business critical workflows. This gives the workflow owners the option to review the failures at a later time and unblock the executions after verifying the correctness.</p><p id="b23e"><strong>First-only Run Strategy</strong></p><p id="eaa2"><strong>Last-only Run Strategy</strong></p><p id="7523"><strong>Parallel with Concurrency Limit Run Strategy</strong></p><h2 id="3d04">Parameters and Expression Language Support</h2><p id="7591">In Maestro, parameters play an important role. Maestro supports dynamic parameters with code injection, which is super useful and powerful. This feature significantly enhances the flexibility and dynamism of workflows, allowing using parameters to control execution logic and enable state sharing between workflows and their steps, as well as between upstream and downstream steps. Together with other Maestro features, it makes the defining of workflows dynamic and enables users to define parameterized workflows for complex use cases.</p><p id="efd3">However, code injection introduces significant security and safety concerns. For example, users might unintentionally write an infinite loop that creates an array and appends items to it, eventually crashing the server with out-of-memory (OOM) issues. While one approach could be to ask users to embed the injected code within their business logic instead of the workflow definition, this would impose additional work on users and tightly couple their business logic with the workflow. In certain cases, this approach blocks users to design some complex parameterized workflows.</p><p id="ef02">To mitigate these risks and assist users to build parameterized workflows, we developed our own customized expression language parser, a simple, secure, and safe expression language (SEL). SEL supports code injection while incorporating validations during syntax tree parsing to protect the system. It leverages the Java Security Manager to restrict access, ensuring a secure and controlled environment for code execution.</p><p id="3a2f"><strong>Simple, Secure, and Safe Expression Language (SEL)<br/></strong>SEL is a homemade simple, secure, and safe expression language (SEL) to address the risks associated with code injection within Maestro parameterized workflows. It is a simple expression language and the grammar and syntax follow JLS (<a href="https://docs.oracle.com/javase/specs/" rel="noopener ugc nofollow" target="_blank">Java Language Specifications</a>). SEL supports a subset of JLS, focusing on Maestro use cases. For example, it supports data types for all Maestro parameter types, raising errors, datetime handling, and many predefined utility methods. SEL also includes additional runtime checks, such as loop iteration limits, array size checks, object memory size limits and so on, to enhance security and reliability. For more details about SEL, please refer to the <a href="https://github.com/Netflix/maestro/blob/main/netflix-sel/docs/index.md#welcome-to-sel" rel="noopener ugc nofollow" target="_blank">Maestro GitHub documentation</a>.</p><p id="0162"><strong>Output Parameters</strong></p><p id="e293"><strong>Parameterized Workflows</strong></p><ul><li id="ecc7">Static workflows are simple and easy to use but come with limitations. Often, users have to duplicate the same workflow multiple times to accommodate minor changes. Additionally, workflow and jobs cannot share the states without using parameters.</li><li id="26fe">On the other hand, completely dynamic workflows can be challenging to manage and support. They are difficult to debug or troubleshoot and hard to be reused by others.</li><li id="2cc0">Parameterized workflows strike a balance by being initialized step by step at runtime based on user defined parameters. This approach provides great flexibility for users to control the execution at runtime while remaining easy to manage and understand.</li></ul><p id="76e0">As we described in <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/orchestrating-data-ml-workflows-at-scale-with-netflix-maestro-aaa2b41b800c#360e">the previous Maestro blog post</a>, parameter support enables the creation of complex parameterized workflows, such as backfill data pipelines.</p><h2 id="03a6">Workflow Execution Patterns</h2><p id="7289">Maestro provides multiple useful building blocks that allow users to easily define dataflow patterns or other workflow patterns. It provides support for common patterns directly within the Maestro engine. Direct engine support not only enables us to optimize these patterns but also ensures a consistent approach to implementing them. Next, we will talk about the three major building blocks that Maestro provides.</p><p id="f47a"><strong>Foreach Support</strong></p><p id="d95e">The foreach pattern is frequently used to repeatedly run the same jobs with different parameters, such as data backfilling or machine learning model tuning. It would be tedious and time consuming to request users to explicitly define each iteration in the workflow definition (potentially hundreds of thousands of iterations). Additionally, users would need to create new workflows if the foreach range changes, further complicating the process.</p><p id="5686"><strong>Conditional Branch Support</strong></p><p id="9e17"><strong>Subworkflow Support<br/></strong>The subworkflow feature allows a workflow step to run another workflow, enabling the sharing of common functions across multiple workflows. This effectively enables “workflow as a function” and allows users to build a graph of workflows. For example, we have observed complex workflows consisting of hundreds of subworkflows to process data across hundreds tables, where subworkflows are provided by multiple teams.</p><p id="7d57">These patterns can be combined together to build composite patterns for complex workflow use cases. For instance, we can loop over a set of subworkflows or run nested foreach loops. One example that Maestro users developed is an auto-recovery workflow that utilizes both conditional branch and subworkflow features to handle errors and retry jobs automatically.</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*d7XTqfPjAkuCBv6C 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*d7XTqfPjAkuCBv6C 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*d7XTqfPjAkuCBv6C 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*d7XTqfPjAkuCBv6C 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*d7XTqfPjAkuCBv6C 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*d7XTqfPjAkuCBv6C 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d7XTqfPjAkuCBv6C 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*d7XTqfPjAkuCBv6C 640w, https://miro.medium.com/v2/resize:fit:720/0*d7XTqfPjAkuCBv6C 720w, https://miro.medium.com/v2/resize:fit:750/0*d7XTqfPjAkuCBv6C 750w, https://miro.medium.com/v2/resize:fit:786/0*d7XTqfPjAkuCBv6C 786w, https://miro.medium.com/v2/resize:fit:828/0*d7XTqfPjAkuCBv6C 828w, https://miro.medium.com/v2/resize:fit:1100/0*d7XTqfPjAkuCBv6C 1100w, https://miro.medium.com/v2/resize:fit:1400/0*d7XTqfPjAkuCBv6C 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="An example of auto-recovery ETL workflows" width="700" height="227" loading="lazy"/></picture></div></div></figure><p id="add9">In this example, subworkflow `job1` runs another workflow consisting of extract-transform-load (ETL) and audit jobs. Next, a status check job leverages the Maestro parameter and SEL support to retrieve the status of the previous job. Based on this status, it can decide whether to complete the workflow or to run a recovery job to address any data issues. After resolving the issue, it then executes subworkflow `job2`, which runs the same workflow as subworkflow `job1`.</p><h2 id="dd55">Step Runtime and Step Parameter</h2><p id="8600"><strong>Step Runtime Interface<br/></strong>In Maestro, we use step runtime to describe a job at execution time. The step runtime interface defines two pieces of information:</p><ol><li id="2de4">A set of basic APIs to control the behavior of a step instance at execution runtime.</li><li id="7fbd">Some simple data structures to track step runtime state and execution result.</li></ol><p id="e253">Maestro offers a few step runtime implementations such as foreach step runtime, subworkflow step runtime (mentioned in previous section). Each implementation defines its own logic for start, execute and terminate operations. At runtime, these operations control the way to initialize a step instance, perform the business logic and terminate the execution under certain conditions (i.e. manual intervention by users).</p><p id="17d4">Also, Maestro step runtime internally keeps track of runtime state as well as the execution result of the step. The runtime state is used to determine the next state transition of the step and tell if it has failed or terminated. The execution result hosts both step artifacts and the timeline of step execution history, which are accessible by subsequent steps.</p><p id="ddb1"><strong>Step Parameter Merging<br/></strong>To control step behavior in a dynamic way, Maestro supports both runtime parameters and tags injection in step runtime. This makes a Maestro step more flexible to absorb runtime changes (i.e. overridden parameters) before actually being started. Maestro internally maintains a step parameter map that is initially empty and is updated by merging step parameters in the order below:</p><ul><li id="8853"><strong>Default General Parameters</strong>: Parameters merging starts from default parameters that in general every step should have. For example, workflow_instance_id, step_instance_uuid, step_attempt_id and step_id are required parameters for each maestro step. They are internally reserved by maestro and cannot be passed by users.</li><li id="4d0d"><strong>Injected Parameters</strong>: Maestro then merges injected parameters (if present) into the parameter map. The injected parameters come from step runtime, which are dynamically generated based on step schema. Each type of step can have its own schema with specific parameters associated with this step. The step schema can evolve independently with no need to update Maestro code.</li><li id="54c3"><strong>Default Typed Parameters</strong>: After injecting runtime parameters, Maestro tries to merge default parameters that are related to a specific type of step. For example, foreach step has loop_params and loop_index default parameters which are internally set by maestro and used for foreach step only.</li><li id="0a3b"><strong>Workflow and Step Info Parameters</strong>: These parameters contain information about step and the workflow it belongs to. This can be identity information, i.e. workflow_id and will be merged to step parameter map if present.</li><li id="0292"><strong>Undefined New Parameters</strong>: When starting or restarting a maestro workflow instance, users can specify new step parameters that are not present in initial step definition. ParamsManager merges these parameters to ensure they are available at execution time.</li><li id="d548"><strong>Step Definition Parameters</strong>: These step parameters are defined by users at definition time and get merged if they are not empty.</li><li id="3f46"><strong>Run and Restart Parameters</strong>: When starting or restarting a maestro workflow instance, users can override defined parameters by providing run or restart parameters. These two types of parameters are merged at the end so that step runtime can see the most recent and accurate parameter space.</li></ul><p id="7dbf">The parameters merging logic can be visualized in the diagram below.</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*bARelX8reZTdmFgr 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*bARelX8reZTdmFgr 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*bARelX8reZTdmFgr 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*bARelX8reZTdmFgr 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*bARelX8reZTdmFgr 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*bARelX8reZTdmFgr 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bARelX8reZTdmFgr 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*bARelX8reZTdmFgr 640w, https://miro.medium.com/v2/resize:fit:720/0*bARelX8reZTdmFgr 720w, https://miro.medium.com/v2/resize:fit:750/0*bARelX8reZTdmFgr 750w, https://miro.medium.com/v2/resize:fit:786/0*bARelX8reZTdmFgr 786w, https://miro.medium.com/v2/resize:fit:828/0*bARelX8reZTdmFgr 828w, https://miro.medium.com/v2/resize:fit:1100/0*bARelX8reZTdmFgr 1100w, https://miro.medium.com/v2/resize:fit:1400/0*bARelX8reZTdmFgr 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="Diagram of the parameters merging logic" width="700" height="207" loading="lazy"/></picture></div></div></figure><h2 id="d5a8">Step Dependencies and Signals</h2><p id="9493">Steps in the Maestro execution workflow graph can express execution dependencies using step dependencies. A step dependency specifies the data-related conditions required by a step to start execution. These conditions are usually defined based on signals, which are pieces of messages carrying information such as parameter values and can be published through step outputs or external systems like SNS or Kafka messages.</p><p id="5a67">Signals in Maestro serve both signal trigger pattern and signal dependencies (a publisher-subscriber) pattern. One step can publish an output signal (<a href="https://github.com/Netflix/maestro/blob/main/maestro-common/src/testFixtures/resources/fixtures/instances/sample-step-instance-failed.json#L151-L215" rel="noopener ugc nofollow" target="_blank">a sample example</a>) that can unblock the execution of multiple other steps that depend on it. A <a href="https://github.com/Netflix/maestro/blob/main/maestro-common/src/main/java/com/netflix/maestro/models/definition/SignalOutputsDefinition.java" rel="noopener ugc nofollow" target="_blank">signal definition</a> includes a list of mapped parameters, allowing Maestro to perform “signal matching” on a subset of fields. Additionally, Maestro supports <a href="https://github.com/Netflix/maestro/blob/main/maestro-common/src/main/java/com/netflix/maestro/models/parameter/SignalOperator.java" rel="noopener ugc nofollow" target="_blank">signal operators</a> like &lt;, &gt;, etc., on signal parameter values.</p><p id="652d">Netflix has built various abstractions on top of the concept of signals. For instance, a ETL workflow can update a table with data and send signals that unblock steps in downstream workflows dependent on that data. Maestro supports “signal lineage,” which allows users to navigate all historical instances of signals and the workflow steps that match (i.e. publishing or consuming) those signals. Signal triggering guarantees exactly-once execution for the workflow subscribing a signal or a set of joined signals. This approach is efficient, as it conserves resources by only executing the workflow or step when the specified conditions in the signals are met. A signal service is implemented for those advanced abstractions. Please refer to the <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/orchestrating-data-ml-workflows-at-scale-with-netflix-maestro-aaa2b41b800c#1fdf">Maestro blog</a> for further details on it.</p><h2 id="28e5">Breakpoint</h2><p id="8764">Maestro allows users to set breakpoints on workflow steps, functioning similarly to code-level breakpoints in an IDE. When a workflow instance executes and reaches a step with a breakpoint, that step enters a “paused” state. This halts the workflow graph’s progression until a user manually resumes from the breakpoint. If multiple instances of a workflow step are paused at a breakpoint, resuming one instance will only affect that specific instance, leaving the others in a paused state. Deleting the breakpoint will cause all paused step instances to resume.</p><p id="cace">This feature is particularly useful during the initial development of a workflow, allowing users to inspect step executions and output data. It is also beneficial when running a step multiple times in a “foreach” pattern with various input parameters. Setting a single breakpoint on a step will cause all iterations of the foreach loop to pause at that step for debugging purposes. Additionally, the breakpoint feature allows human intervention during the workflow execution and can also be used for other purposes, e.g. supporting mutating step states while the workflow is running.</p><h2 id="7ab1">Timeline</h2><p id="ed4f">Maestro includes a step execution timeline, capturing all significant events such as execution state machine changes and the reasoning behind them. This feature is useful for debugging, providing insights into the status of a step. For example, it logs transitions such as “Created” and “Evaluating params”, etc. An example of a timeline is included <a href="https://github.com/Netflix/maestro/blob/main/maestro-common/src/testFixtures/resources/fixtures/instances/sample-step-instance-failed.json#L137-L150" rel="noopener ugc nofollow" target="_blank">here</a> for reference. The implemented step runtimes can add the timeline events into the timeline to surface the execution information to the end users.</p><h2 id="461d">Retry Policies</h2><p id="33ba">Maestro supports retry policies for steps that reach a terminal state due to failure. Users can specify the number of retries and configure retry policies, including delays between retries and exponential backoff strategies, in addition to fixed interval retries. Maestro distinguishes between two types of retries: “platform” and “user.” Platform retries address platform-level errors unrelated to user logic, while user retries are for user-defined conditions. Each type can have its own set of retry policies.</p><p id="46fa">Automatic retries are beneficial for handling transient errors that can be resolved without user intervention. Maestro provides the flexibility to set retries to zero for non-idempotent steps to avoid retry. This feature ensures that users have control over how retries are managed based on their specific requirements.</p><h2 id="ef2f">Aggregated View</h2><p id="4c03">Because a workflow instance can have multiple runs, it is important for users to see an aggregated state of all steps in the workflow instance. Aggregated view is computed by merging base aggregated view with current runs instance step statuses. For example, as you can see on the figure below simulating a simple case, there is a first run, where step1 and step2 succeeded, step3 failed, and step4 and step5 have not started. When the user restarts the run, the run starts from step3 in run 2 with step1 and step2 skipped which succeeded in the previous run. After all steps succeed, the aggregated view shows the run states for all steps.</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*UC1Sj36z5IfvDz9X 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*UC1Sj36z5IfvDz9X 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*UC1Sj36z5IfvDz9X 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*UC1Sj36z5IfvDz9X 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*UC1Sj36z5IfvDz9X 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*UC1Sj36z5IfvDz9X 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UC1Sj36z5IfvDz9X 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*UC1Sj36z5IfvDz9X 640w, https://miro.medium.com/v2/resize:fit:720/0*UC1Sj36z5IfvDz9X 720w, https://miro.medium.com/v2/resize:fit:750/0*UC1Sj36z5IfvDz9X 750w, https://miro.medium.com/v2/resize:fit:786/0*UC1Sj36z5IfvDz9X 786w, https://miro.medium.com/v2/resize:fit:828/0*UC1Sj36z5IfvDz9X 828w, https://miro.medium.com/v2/resize:fit:1100/0*UC1Sj36z5IfvDz9X 1100w, https://miro.medium.com/v2/resize:fit:1400/0*UC1Sj36z5IfvDz9X 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="An example of aggregated views" width="700" height="469" loading="lazy"/></picture></div></div></figure><h2 id="0eeb">Rollup</h2><p id="6431">Rollup provides a high-level summary of a workflow instance, detailing the status of each step and the count of steps in each status. It flattens steps across the current instance and any nested non-inline workflows like subworkflows or foreach steps. For instance, if a successful workflow has three steps, one of which is a subworkflow corresponding to a five-step workflow, the rollup will indicate that seven steps succeeded. Only leaf steps are counted in the rollup, as other steps serve merely as pointers to concrete workflows.</p><p id="4d8c">Rollup also retains references to any non-successful steps, offering a clear overview of step statuses and facilitating easy navigation to problematic steps, even within nested workflows. The aggregated rollup for a workflow instance is calculated by combining the current run’s runtime data with a base rollup. The current state is derived from the statuses of active steps, including aggregated rollups for foreach and subworkflow steps. The base rollup is established when the workflow instance begins and includes statuses of inline steps (excluding foreach and subworkflows) from the previous run that are not part of the current run.</p><p id="957b">For subworkflow steps, the rollup simply reflects the rollup of the subworkflow instance. For foreach steps, the rollup combines the base rollup of the foreach step with the current state rollup. The base is derived from the previous run’s aggregated rollup, excluding the iterations to be restarted in the new run. The current state is periodically updated by aggregating rollups of running iterations until all iterations reach a terminal state.</p><p id="2610">Due to these processes, the rollup model is eventually consistent. While the figure below illustrates a straightforward example of rollup, the calculations can become complex and recursive, especially with multiple levels of nested foreaches and subworkflows.</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*ISib6wPtCLtAbOuU 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*ISib6wPtCLtAbOuU 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*ISib6wPtCLtAbOuU 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*ISib6wPtCLtAbOuU 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*ISib6wPtCLtAbOuU 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*ISib6wPtCLtAbOuU 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ISib6wPtCLtAbOuU 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*ISib6wPtCLtAbOuU 640w, https://miro.medium.com/v2/resize:fit:720/0*ISib6wPtCLtAbOuU 720w, https://miro.medium.com/v2/resize:fit:750/0*ISib6wPtCLtAbOuU 750w, https://miro.medium.com/v2/resize:fit:786/0*ISib6wPtCLtAbOuU 786w, https://miro.medium.com/v2/resize:fit:828/0*ISib6wPtCLtAbOuU 828w, https://miro.medium.com/v2/resize:fit:1100/0*ISib6wPtCLtAbOuU 1100w, https://miro.medium.com/v2/resize:fit:1400/0*ISib6wPtCLtAbOuU 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="An example of the rollup model" width="700" height="409" loading="lazy"/></picture></div></div></figure><h2 id="fb0a">Maestro Event Publishing</h2><p id="8676">When workflow definition, workflow instance or step instance is changed, Maestro generates an event, processes it internally and publishes the processed event to external system(s). Maestro has both internal and external events. The internal event tracks changes within the life cycle of workflow, workflow instance or step instance. It is published to an internal queue and processed within Maestro. After internal events are processed, some of them will be transformed into external event and sent out to the external queue (i.e. SNS, Kafka). The external event carries maestro status change information for downstream services. The event publishing flow is illustrated in the diagram below:</p><figure><div role="button" tabindex="0"><div><picture><source srcset="https://miro.medium.com/v2/resize:fit:640/format:webp/0*n2Kiea-ngDjnKppJ 640w, https://miro.medium.com/v2/resize:fit:720/format:webp/0*n2Kiea-ngDjnKppJ 720w, https://miro.medium.com/v2/resize:fit:750/format:webp/0*n2Kiea-ngDjnKppJ 750w, https://miro.medium.com/v2/resize:fit:786/format:webp/0*n2Kiea-ngDjnKppJ 786w, https://miro.medium.com/v2/resize:fit:828/format:webp/0*n2Kiea-ngDjnKppJ 828w, https://miro.medium.com/v2/resize:fit:1100/format:webp/0*n2Kiea-ngDjnKppJ 1100w, https://miro.medium.com/v2/resize:fit:1400/format:webp/0*n2Kiea-ngDjnKppJ 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px" type="image/webp"/><source data-testid="og" srcset="https://miro.medium.com/v2/resize:fit:640/0*n2Kiea-ngDjnKppJ 640w, https://miro.medium.com/v2/resize:fit:720/0*n2Kiea-ngDjnKppJ 720w, https://miro.medium.com/v2/resize:fit:750/0*n2Kiea-ngDjnKppJ 750w, https://miro.medium.com/v2/resize:fit:786/0*n2Kiea-ngDjnKppJ 786w, https://miro.medium.com/v2/resize:fit:828/0*n2Kiea-ngDjnKppJ 828w, https://miro.medium.com/v2/resize:fit:1100/0*n2Kiea-ngDjnKppJ 1100w, https://miro.medium.com/v2/resize:fit:1400/0*n2Kiea-ngDjnKppJ 1400w" sizes="(min-resolution: 4dppx) and (max-width: 700px) 50vw, (-webkit-min-device-pixel-ratio: 4) and (max-width: 700px) 50vw, (min-resolution: 3dppx) and (max-width: 700px) 67vw, (-webkit-min-device-pixel-ratio: 3) and (max-width: 700px) 65vw, (min-resolution: 2.5dppx) and (max-width: 700px) 80vw, (-webkit-min-device-pixel-ratio: 2.5) and (max-width: 700px) 80vw, (min-resolution: 2dppx) and (max-width: 700px) 100vw, (-webkit-min-device-pixel-ratio: 2) and (max-width: 700px) 100vw, 700px"/><img alt="A diagram of the event publishing flow" width="700" height="226" loading="lazy"/></picture></div></div></figure><p id="8ae3">As shown in the diagram, the Maestro event processor bridges the two aforementioned Maestro events. It listens on the internal queue to get the published <a href="https://github.com/Netflix/maestro/tree/main/maestro-engine/src/main/java/com/netflix/maestro/engine/jobevents" rel="noopener ugc nofollow" target="_blank">internal events</a>. Within the processor, the internal job event is processed based on its type and gets converted to an <a href="https://github.com/Netflix/maestro/tree/main/maestro-common/src/main/java/com/netflix/maestro/models/events" rel="noopener ugc nofollow" target="_blank">external event</a> if needed. The notification publisher at the end emits the external event so that downstream services can consume.</p><p id="da33">The downstream services are mostly event-driven. The Maestro event carries the most useful message for downstream services to capture different changes in Maestro. In general, these changes can be classified into two categories: workflow change and instance status change. The workflow change event is associated with actions at workflow level, i.e definition or properties of a workflow has changed. Meanwhile, instance status change tracks status transition on workflow instance or step instance.</p><p id="5db4">Maestro has been extensively used within Netflix, and today, we are excited to make the Maestro source code publicly available. We hope that the scalability and usability that Maestro offers can expedite workflow development outside Netflix. We invite you to try Maestro, use it within your organization, and contribute to its development.</p><p id="7494">You can find the Maestro code repository at <a href="https://github.com/Netflix/maestro" rel="noopener ugc nofollow" target="_blank">github.com/Netflix/maestro</a>. If you have any questions, thoughts, or comments about Maestro, please feel free to create a <a href="https://github.com/Netflix/maestro/issues" rel="noopener ugc nofollow" target="_blank">GitHub issue</a> in the Maestro repository. We are eager to hear from you.</p><p id="f320">We are taking workflow orchestration to the next level and constantly solving new problems and challenges, please stay tuned for updates. If you are passionate about solving large scale orchestration problems, please <a href="https://jobs.netflix.com/search?team=Data+Platform" rel="noopener ugc nofollow" target="_blank">join us</a>.</p><p id="d8df">Thanks to other Maestro team members, <a href="https://www.linkedin.com/in/binbing-hou/" rel="noopener ugc nofollow" target="_blank">Binbing Hou</a>, <a href="http://linkedin.com/in/zhuoran-d-96848b154" rel="noopener ugc nofollow" target="_blank">Zhuoran Dong</a>, <a href="https://www.linkedin.com/in/brittany-truong-a35b54bb" rel="noopener ugc nofollow" target="_blank">Brittany Truong</a>, <a href="https://www.linkedin.com/in/rdeepak2002/" rel="noopener ugc nofollow" target="_blank">Deepak Ramalingam</a>, <a href="http://linkedin.com/in/moctarba" rel="noopener ugc nofollow" target="_blank">Moctar Ba</a>, for their contributions to the Maestro project. Thanks to our Product Manager <a href="https://www.linkedin.com/in/ashpokh/" rel="noopener ugc nofollow" target="_blank">Ashim Pokharel</a> for driving the strategy and requirements. We’d also like to thank <a href="https://www.linkedin.com/in/andrew-seier/" rel="noopener ugc nofollow" target="_blank">Andrew Seier</a>, <a href="https://www.linkedin.com/in/romain-cledat-4a211a5" rel="noopener ugc nofollow" target="_blank">Romain Cledat</a>, <a href="https://www.linkedin.com/in/agorajek/" rel="noopener ugc nofollow" target="_blank">Olek Gorajek</a>, and other stunning colleagues at Netflix for their contributions to the Maestro project. We also thank Prashanth Ramdas, Eva Tse, David Noor, Charles Smith and other leaders of Netflix engineering organizations for their constructive feedback and suggestions on the Maestro project.</p></div></div></div></div></section></div>
  </body>
</html>
