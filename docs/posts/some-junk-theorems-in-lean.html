<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/James-Hanson/junk-theorems-in-lean">Original</a>
    <h1>Some Junk Theorems in Lean</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">This is a small collection of formally verified junk theorems provable in Lean 4 + Mathlib that, in my experience, are quite surprising and upsetting to mathematicians who are not familiar with type theory (and in the case of Theorems 13 and 14, also to mathematicians who are familiar with type theory). <a href="https://github.com/James-Hanson/junk-theorems-in-lean/blob/main/JunkTheorems.lean">See the main .lean file here.</a></p>

<blockquote>
<p dir="auto"><strong>Theorem 1.</strong> <em>The third coordinate of the rational number <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\frac{1}{2}$</math-renderer> is a bijection.</em></p>
</blockquote>
<blockquote>
<p dir="auto"><strong>Theorem 2.</strong> <em>The first coordinate of the polynomial <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$X^2(X^3 + X + 1)$</math-renderer> is equal to the prime factorization of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$30$</math-renderer>.</em></p>
</blockquote>
<blockquote>
<p dir="auto"><strong>Theorem 3.</strong> <em>Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$P$</math-renderer> be the multivariate polynomial <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$(X_0 + X_1 + X_2)^3$</math-renderer>. Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$Q$</math-renderer> be the univariate polynomial <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$X^2 + X + 1$</math-renderer>. The second coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$P$</math-renderer> applied to the first coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$Q$</math-renderer> is equal to the natural number <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$6$</math-renderer>.</em></p>
</blockquote>

<blockquote>
<p dir="auto"><strong>Theorem 4.</strong> <em>The set <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\{z : \mathbb{R} | z \neq 0\}$</math-renderer> is a continuous, non-monotone surjection.</em></p>
</blockquote>
<blockquote>
<p dir="auto"><strong>Theorem 5.</strong> <em>The Riemann hypothesis is in the topological closure of the set not not.</em></p>
</blockquote>
<p dir="auto">Note though that showing that the Riemann hypothesis is in the topological closure of not will win you a million dollars.</p>
<blockquote>
<p dir="auto"><strong>Theorem 6.</strong> <em>The following are equivalent: The binary expansion of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$7$</math-renderer>.</em></p>
</blockquote>
<blockquote>
<p dir="auto"><strong>Theorem 7.</strong> <em>The dot product of not with itself. Moreover, the matrix determinant of or. However, not the determinant of and.</em></p>
</blockquote>
<blockquote>
<p dir="auto"><strong>Theorem 8.</strong> <em>The existential quantifier on the category of groups is a non-measurable set.</em></p>
</blockquote>

<p dir="auto">Famously, Lean, like many proof assistants, defines division so that <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\frac{1}{0} = 0$</math-renderer> and subtraction on the natural numbers so that <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2 - 3 = 0$</math-renderer>. In the first case, this leads to the following theorem (which is already in Mathlib).</p>
<blockquote>
<p dir="auto"><strong>Theorem 9.</strong> (<a href="https://leanprover-community.github.io/mathlib4_docs/Mathlib/NumberTheory/Harmonic/ZetaAsymp.html#riemannZeta_one" rel="nofollow"><code>riemannZeta_one</code></a>) <em><math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\zeta(1) = \frac{1}{2}(\gamma - \log 4 \pi)$</math-renderer>, where <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\zeta(s)$</math-renderer> is the Riemann zeta function.</em></p>
</blockquote>
<p dir="auto">If we try to avoid the junk theorem <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2 - 3 = 0$</math-renderer> with the partial subtraction function <code>psub</code>, we get the following.</p>
<blockquote>
<p dir="auto"><strong>Theorem 10.</strong> <em>Two minus three, where subtraction is understood to be a partial function on <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathbb{N}$</math-renderer>, is equal to the extended natural number <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$+\infty$</math-renderer>.</em></p>
</blockquote>

<p dir="auto">In this next theorem, <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathsf{QR}$</math-renderer> stands for quadratic reciprocity and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathsf{BCT}$</math-renderer> stands for the Baire category theorem.</p>
<blockquote>
<p dir="auto"><strong>Theorem 11.</strong> <em>Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$p$</math-renderer> be the unique proof of quadratic reciprocity, and let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$q$</math-renderer> be the unique proof that the Baire category theorem isn&#39;t false. The pair <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle \mathsf{QR},p\rangle$</math-renderer> is equal to the pair <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle\neg\neg\mathsf{BCT},q\rangle$</math-renderer> (in the sense of pointed types). Moreover, <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$q$</math-renderer> is a bijection.</em></p>
</blockquote>
<p dir="auto">However, one cannot even form the sentence &#39;The unique proof of quadratic reciprocity is a bijection.&#39; in Lean, because this would be as nonsensical as the sentence &#39;The natural number <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2$</math-renderer> is a bijection.&#39;</p>
<p dir="auto">Similarly, we can build an element <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$r$</math-renderer> of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathbb{Q}$</math-renderer> and a polynomial <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$P$</math-renderer> with coefficients in <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathbb{N}$</math-renderer>, and prove the following.</p>
<blockquote>
<p dir="auto"><strong>Theorem 12.</strong></p>
<ul dir="auto">
<li><em><math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$r$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\frac{1}{2}$</math-renderer>.</em></li>
<li><em><math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$P$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2X^2$</math-renderer>.</em></li>
<li><em>Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$A$</math-renderer> be the result of applying the third coordinate of the first coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$P$</math-renderer> to the natural number <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2$</math-renderer>. Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$B$</math-renderer> be the first coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$A$</math-renderer>. For the unique <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$z$</math-renderer> in the domain of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$B$</math-renderer>, <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$B(z)$</math-renderer> is equal to the third coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$r$</math-renderer>.</em></li>
</ul>
</blockquote>
<p dir="auto">Given the first two bullets of Theorem 12, it is perhaps surprising that we can&#39;t just take <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$r$</math-renderer> to literally be <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\frac{1}{2}$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$P$</math-renderer> to literally be <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2X^2$</math-renderer>. If we try to do this, Lean will inform us that the resulting proposition does not typecheck. In particular, the last sentence of the statement</p>
<ul dir="auto">
<li>Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$A$</math-renderer> be the result of applying the third coordinate of the first coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2X^2$</math-renderer> to the natural number <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2$</math-renderer>. Let <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$B$</math-renderer> be the first coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$A$</math-renderer>. For the unique <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$z$</math-renderer> in the domain of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$B$</math-renderer>, <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$B(z)$</math-renderer> is equal to the third coordinate of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\frac{1}{2}$</math-renderer>.&#39;</li>
</ul>
<p dir="auto">is completely meaningless, unlike the last sentence of Theorem 12.</p>
<p dir="auto">Finally, using the axiom of choice (in a meaningful way, mind), we can build three terms <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer>, <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$b$</math-renderer>, and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer> and prove the following:</p>
<blockquote>
<p dir="auto"><strong>Theorem 13.</strong> <em><math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$b$</math-renderer>, and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$b$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer>.</em></p>
</blockquote>
<p dir="auto">This may not seem so strange, but the issue is that if we now consider the obvious corollary <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a = c$</math-renderer>, Lean will tell us that <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer> don&#39;t have the same type, so the question of whether <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer> is as absurd as the question of whether the Banach space <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\ell^2$</math-renderer> is equal to the monster group. (And, yes, <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$b$</math-renderer> have the same type and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$b$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer> have the same type; there is no type coercion happening here.)</p>
<p dir="auto">It does make sense to ask whether <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer> are &#39;heterogeneously equal&#39; (i.e., is it the case that <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle A, a \rangle = \langle C, c\rangle$</math-renderer>, where <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$A$</math-renderer> is the type of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$a$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$C$</math-renderer> is the type of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$c$</math-renderer>?), but it also makes sense to ask whether <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle \text{Banach spaces}, \ell^2 \rangle$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle \text{groups}, \text{monster group}\rangle$</math-renderer> or to ask whether <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle\mathsf{Prop},\text{quadratic reciprocity}\rangle$</math-renderer> is equal to <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle \mathsf{Fin} 2, 0 \rangle$</math-renderer> (where <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathsf{Prop}$</math-renderer> is the type of propositions and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathsf{Fin} 2$</math-renderer> is the type of natural numbers less than <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2$</math-renderer>). The only formal difference is that, while you can prove <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle A, a \rangle = \langle C, c\rangle$</math-renderer> easily (since equality is transitive, after all), the statements <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle \text{Banach spaces}, \ell^2 \rangle = \langle \text{groups}, \text{monster group}\rangle$</math-renderer> and <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\langle \mathsf{Prop},\text{quadratic reciprocity}\rangle = \langle \mathsf{Fin} 2, 0 \rangle$</math-renderer> are independent of Lean.</p>

<p dir="auto">This last theorem requires a proof tactic that is (reasonably) banned in Mathlib (i.e., the infamous <code>native_decide</code>) as well as an explicit extra axiomatic assumption. (Think of this as being like an exotic counterexample in real analysis that requires <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$\mathsf{CH}$</math-renderer>.)</p>
<blockquote>
<p dir="auto"><strong>Theorem 14.</strong> <em>If we assume axiomatically that the type of natural numbers less than <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2147483649$</math-renderer> is equal to the type of integers in the interval <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$[0,2147483649)$</math-renderer> and that <a href="https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Lean.trustCompiler" rel="nofollow">we trust the Lean compiler</a>, then <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$0 = 1$</math-renderer>.</em></p>
</blockquote>
<p dir="auto">In other words, these axioms are inconsistent. This is notable firstly because it is consistent without the axioms used by <code>native_decide</code> (i.e., <code>Lean.trustCompiler</code> and <code>Lean.ofReduceBool</code>) that the type of natural numbers less than <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$2147483649$</math-renderer> is equal to the type of integers in the interval <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$[0,2147483649)$</math-renderer> (indeed it is consistent to assume that any two types of the same cardinality in the same universe are equal), but also secondly because the analogous axioms regarding numbers smaller than <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$k$</math-renderer> are seemingly consistent with <code>native_decide</code> for any <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$k &amp;lt; 2147483649$</math-renderer> (specifically, the analogous proof of <math-renderer data-run-id="f5d208a9b482766643b113586b250ddb">$0 = 1$</math-renderer> does not work).</p>
<hr/>
<p dir="auto">I should clarify some things. Theorems 1-10 (and to some extent Theorem 12) are artifacts of particular definitions made in Mathlib, although the convention that leads to Theorem 9 seems to be considered best practice (classically) for dealing with the fact that division is a partial function. Theorem 11 is not an artifact of particular definitions, but rather follows very directly from the treatment of propositions in type theory. (It&#39;s even provable constructively in type theories with propositional extensionality, such as HoTT.)</p>
<p dir="auto">Theorems 13 and 14 are unique to Lean and arise from some of its design decisions. Theorem 13 relies on definitional proof irrelevance and Lean&#39;s computational rules for quotient types, which also lead to the failure of subject reduction. In other proof assistants based on dependent type theory (e.g., Rocq and Agda), judgmental/definitional equality is transitive, so nothing like Theorem 13 can happen, even assuming choice. Theorem 14 relies on low-level implementation details of the Lean compiler.</p>
</article></div></div>
  </body>
</html>
