<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alexharri.com/blog/grid-engine-performance">Original</a>
    <h1>Making GRID&#39;s spreadsheet engine 10% faster</h1>
    
    <div id="readability-page-1" class="page"><div><main><p>GRID&#39;s product sports a feature-complete spreadsheet engine running in the browser, with advanced features such as <a target="_blank" href="https://grid.is/@hjalli/spilling-support-in-grid-Uq_xPRt7SXuKlWf2WnwYZA">spilling</a>, <a target="_blank" href="https://grid.is/@hjalli/iterative-calculations-example-hjmC1fe5RoqjEstgAEnaJw">iterative calculation</a>, and the <a target="_blank" href="https://grid.is/@grid/summarize-data-with-the-query-function-InXxO_7vS6KNkV6tYScx3Q"><code>QUERY</code> function</a>. It&#39;s a beaut.</p>
<p>The Engine Team regularly handles customer care requests relating to bugs and performance issues in spreadsheets. Last June, I took a look at a particularly large and complicated spreadsheet where a write to a single cell caused ~12.000 cells to be recalculated. The recalculation took &gt;700ms to execute on my machine (M1 Pro).</p>
<p>Profiling the recalculation, about 12.5% of the time was spent in a method called <code>_makeCalcCellEvaluationContext</code>.</p>
<p><img src="https://alexharri.com/images/posts/grid-engine-performance/profiler.png" width="100%"/></p>
<p>In this post, we&#39;ll explore the techniques I used to take this time to near zero.</p>
<h2>GRID&#39;s Spreadsheet Engine</h2>
<p>Spreadsheets have <em>a lot</em> of use cases, ranging from budget management and attendance sheets, all the way to complex financial models. At the heart of the more complex models are dependencies. Cells depending on other cells.</p>
<ul>
<li>A mortgage calculator may have cells depending, directly or indirectly, on a cell representing an <code>Interest Rate</code>.</li>
<li>In a spreadsheet to calculate marketing spend, you might instead have <code>Cost-per-Click</code> and <code>Conversion Rate</code> variables.</li>
</ul>
<p><img src="https://alexharri.com/images/posts/grid-engine-performance/mortgage-calculator.png" width="100%"/></p>
<p>An example of what the inputs to a mortgage calculator might look like</p>
<p>Different scenarios are modeled by adjusting the inputs and seeing how the model reacts.</p>
<blockquote>
<p><em>How high do the payments become when I reduce the loan term by X?</em></p>
<p><em>What if the interest rate rises to 9%?</em></p>
</blockquote>
<p>For the model to &#34;react&#34; to changes in an input cell:</p>
<ul>
<li>Cells depending on the changed input cell need to be recalculated.</li>
<li>To find the cell&#39;s dependents, the model employs a dependency graph.</li>
</ul>
<p>This cycle of recalculating dependents occurs recursively. A cell&#39;s value changing when recalculated causes cells depending on it to be recalculated, and so forth. In the following example, every cell — except the first cell — depends on the preceding cell, forming a chain of calculations.</p>


<p>What you&#39;re looking at is a GRID document, containing a graph powered by this underlying spreadsheet:</p>


<p>While this spreadsheet is small, more complex models often contain tens or hundreds of thousands of cells.</p>
<p>A single output cell is often the product of calculations encompassing dozens of thousands of cells. And the reverse: A single input cell is often used — directly or indirectly — in the majority of calculations in a spreadsheet.</p>
<h2>The cost of recalculation</h2>
<p>The cost of recalculation can be split into two distinct parts:</p>
<ol>
<li>Determining which cells to recalculate, and in which order.</li>
<li>Recalculating cells.</li>
</ol>
<p>The recalculation of cells can further be split up into the <strong>fixed cost</strong> associated with recalculating a cell, and the <strong>variable cost</strong> associated with recalculating a cell.</p>
<p>The variable cost is more immediately obvious: A cell invoking an expensive function like <code>QUERY</code> on a large dataset will take longer to recalculate than a cell adding two numbers together.</p>
<div><div><div><div><pre><p><span># This will take a while</span></p><p><span>=QUERY(A:E, &#34;select Name, Age where Age &gt; 18 order by Name desc&#34;);</span></p><p><span># This will take no time at all</span></p><p><span>=SUM(A1, B1)</span></p></pre></div></div></div></div>
<p>For the most part, the variable cost is derived from how expensive the cell&#39;s user-written formula is.</p>
<p>The fixed cost arises from setting up the context needed to evaluate the formula. For example, when evaluating a reference like <code>A1</code>, the engine needs a bit of context to know which workbook and sheet to resolve the reference to.</p>
<p>Given that the following formulas are written in <code>Sheet1</code> in <code>workbook.xlsx</code>:</p>
<div><div><div><div><pre><p><span># Resolves to &#39;[workbook.xlsx]Sheet1!A1&#39;</span></p><p><span>=A1</span></p><p><span># Resolves to &#39;[workbook.xlsx]Sheet2!A1&#39;</span></p><p><span>=Sheet2!A1</span></p><p><span># Resolves to &#39;[wb2.xlsx]Sheet3!A1&#39;</span></p><p><span>=[wb2.xlsx]Sheet3!A1</span></p></pre></div></div></div></div>
<p>In addition to the current workbook and sheet, there&#39;s other contextual information that the engine <em>may</em> require during recalculation. For example:</p>
<ul>
<li>When using structured references without a table name such as <code>[[#This row], [Value]]</code>, the engine needs to resolve the table encompassing the cell.</li>
<li>Because Excel and Google Sheets implement some (<em>a lot</em>) of functions differently, GRID has Excel and Google Sheets modes for compatibility. Spreadsheet functions need to be able to resolve the current mode to match mode-specific behaviors.</li>
</ul>
<p>To provide this contextual information, the engine constructs an object called the <em>evaluation context</em> in a method called  <code>_makeCalcCellEvaluationContext</code>. This is what we see taking 12.5% of recalculation time.</p>
<p><img src="https://alexharri.com/images/posts/grid-engine-performance/profiler.png" width="100%"/></p>
<p>Constructing the evaluation context is done once for each cell, and the cost of doing so is the same for every cell, which constitutes the fixed cost associated with recalculating a cell.</p>
<p>The proportion of the total work that is spent constructing the evaluation context depends on how high the variable cost (formula evaluation) is. In workbooks with fewer, more expensive formulas, the variable cost dominates over the fixed cost.</p>
<p><img src="https://alexharri.com/images/posts/grid-engine-performance/fixed-cost-ratio.png" width="100%"/></p>
<h2>Evaluating the fixed cost</h2>
<p>When recalculating a cell, the evaluation context is created and passed to a function that evaluates the cell&#39;s formula (more specifically, evaluates the formula&#39;s <a target="_blank" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>).</p>
<div><div><div><div><pre><p><span>const</span><span> ctx </span><span>=</span><span> </span><span>this</span><span>.</span><span>_makeCalcCellEvaluationContext</span><span>(</span><span>cell</span><span>,</span><span> ref</span><span>,</span><span> </span><span>...</span><span>)</span><span>;</span><span></span></p><p><span></span><span>const</span><span> value </span><span>=</span><span> </span><span>evaluateAST</span><span>(</span><span>cell</span><span>,</span><span> ctx</span><span>)</span><span>;</span><span></span></p></pre></div></div></div></div>
<p>The <code>_makeCalcCellEvaluationContext</code> method exists on the <code>Workbook</code> class, with the implementation along the lines of:</p>
<div><div><div><div><pre><p><span>class</span><span> </span><span>Workbook</span><span> </span><span>implements</span><span> </span><span>EvaluationContext</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>_makeCalcCellEvaluationContext</span><span> </span><span>(</span><span>cell</span><span>:</span><span> </span><span>Cell</span><span>,</span><span> ref</span><span>:</span><span> </span><span>Reference</span><span>,</span><span> </span><span>...</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> property1 </span><span>=</span><span> </span><span>...</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> property2 </span><span>=</span><span> </span><span>...</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> </span><span>method1</span><span> </span><span>=</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> </span><span>method2</span><span> </span><span>=</span><span> </span><span>(</span><span>)</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>;</span><span></span></p><p><span>    </span><span>const</span><span> evaluationContext</span><span>:</span><span> </span><span>EvaluationContext</span><span> </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>      </span><span>...</span><span>this</span><span>,</span><span></span></p><p><span>      property1</span><span>,</span><span></span></p><p><span>      property2</span><span>,</span><span></span></p><p><span>      method1</span><span>,</span><span></span></p><p><span>      method2</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span>;</span><span></span></p><p><span>    </span><span>return</span><span> evaluationContext</span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>A key observation is that not all of the properties and methods are necessarily used.</p>
<p>Whether a piece of information is used during evaluation depends entirely on the cell&#39;s formula, and the functions it invokes. By computing all properties ahead of time, we expend a fixed amount of effort for a variable amount of benefit.</p>
<p>In addition, the <code>Workbook</code> class is quite large, containing &gt;30 methods and properties. Assigning those to a new object is costly.</p>
<h2>Eliminating the fixed cost</h2>
<p>As with any performance optimization, the solution is doing less work.</p>
<p>The first way to do less work is to lazily compute information, which we implemented through the use of getters.</p>
<div><div><div><div><pre><p><span>const</span><span> method1 </span><span>=</span><span> </span><span>...</span><span>;</span><span></span></p><p><span></span><span>const</span><span> method2 </span><span>=</span><span> </span><span>...</span><span>;</span><span></span></p><p><span></span><span>const</span><span> evaluationContext</span><span>:</span><span> </span><span>EvaluationContext</span><span> </span><span>=</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>...</span><span>this</span><span>,</span><span></span></p><p><span>  </span><span>get</span><span> </span><span>property1</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>  </span><span>get</span><span> </span><span>property2</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>  method1</span><span>,</span><span></span></p><p><span>  method2</span><span>,</span><span></span></p><p><span></span><span>}</span><span>;</span><span></span></p><p><span></span><span>return</span><span> evaluationContext</span></p></pre></div></div></div></div>
<p>Now we only compute properties if they&#39;re actually used.</p>
<p>To avoid assigning <code>this</code> into a new object over and over, we created a single shared evaluation context object, encapsulated in a new <code>CellEvaluator</code> class.</p>
<div><div><div><div><pre><p><span>class</span><span> </span><span>CellEvaluator</span><span> </span><span>{</span><span></span></p><p><span>  </span><span>private</span><span> evaluationContext</span><span>:</span><span> </span><span>EvaluationContext</span><span>;</span><span></span></p><p><span>  </span><span>private</span><span> cell</span><span>:</span><span> </span><span>Cell</span><span>;</span><span></span></p><p><span>  </span><span>private</span><span> ref</span><span>:</span><span> </span><span>Reference</span><span>;</span><span></span></p><p><span>  </span><span>constructor</span><span> </span><span>(</span><span>workbook</span><span>:</span><span> </span><span>Workbook</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>const</span><span> self </span><span>=</span><span> </span><span>this</span><span>;</span><span></span></p><p><span>    </span><span>this</span><span>.</span><span>evaluationContext</span><span> </span><span>=</span><span> </span><span>Object</span><span>.</span><span>freeze</span><span>(</span><span>{</span><span></span></p><p><span>      </span><span>...</span><span>workbook</span><span>,</span><span></span></p><p><span>      </span><span>get</span><span> </span><span>property1</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>      </span><span>get</span><span> </span><span>property2</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>      </span><span>method1</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>      </span><span>method2</span><span> </span><span>(</span><span>)</span><span> </span><span>{</span><span> </span><span>...</span><span> </span><span>}</span><span>,</span><span></span></p><p><span>    </span><span>}</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span>  </span><span>evaluate</span><span> </span><span>(</span><span>cell</span><span>:</span><span> </span><span>Cell</span><span>,</span><span> ref</span><span>:</span><span> </span><span>Reference</span><span>,</span><span> </span><span>...</span><span>)</span><span> </span><span>{</span><span></span></p><p><span>    </span><span>this</span><span>.</span><span>cell</span><span> </span><span>=</span><span> cell</span><span>;</span><span></span></p><p><span>    </span><span>this</span><span>.</span><span>ref</span><span> </span><span>=</span><span> ref</span><span>;</span><span></span></p><p><span>    </span><span>return</span><span> </span><span>evaluateAST</span><span>(</span><span>cell</span><span>,</span><span> </span><span>this</span><span>.</span><span>evaluationContext</span><span>)</span><span>;</span><span></span></p><p><span>  </span><span>}</span><span></span></p><p><span></span><span>}</span><span></span></p></pre></div></div></div></div>
<p>The dynamic portion of the evaluation context (<code>cell</code>, <code>ref</code>, etc) is placed into private properties on <code>CellEvaluator</code>, accessible via the <code>self</code> reference. By mutating those properties, we effectively create a new evaluation context without creating a new object instance.</p>
<p>By only creating a single shared evaluation context object, we avoid spreading the workbook into a new object repeatedly — which also creates less work for the garbage collector.</p>
<p>As a small side benefit, the code for recalculation became a <em>tad</em> simpler:</p>
<div><div><div><div><pre><p><span></span><span>const</span><span> ctx </span><span>=</span><span> </span><span>this</span><span>.</span><span>_makeCalcCellEvaluationContext</span><span>(</span><span>cell</span><span>,</span><span> ref</span><span>,</span><span> </span><span>...</span><span>)</span><span>;</span><span></span></p><p><span></span><span>const</span><span> value </span><span>=</span><span> </span><span>evaluateAST</span><span>(</span><span>cell</span><span>,</span><span> ctx</span><span>)</span><span>;</span><span></span></p><p><span></span><span>const</span><span> value </span><span>=</span><span> </span><span>this</span><span>.</span><span>cellEvaluator</span><span>.</span><span>evaluate</span><span>(</span><span>cell</span><span>,</span><span> ref</span><span>,</span><span> </span><span>...</span><span>)</span><span>;</span><span></span></p></pre></div></div></div></div>
<h2>Evaluating the impact</h2>
<p>The Engine Team has developed a performance and regression testing suite for its spreadsheet engine. It runs on real public GRID documents, on which it performs a series of tests measuring:</p>
<ul>
<li>Initialization time</li>
<li>Write duration (recalculation performance)</li>
<li>Discrepancies (expected vs actual output)</li>
</ul>
<p>This suite enables the Engine Team to evaluate the performance impact of changes and detect discrepancies that our unit tests might fail to detect.</p>
<p>Running GRID&#39;s performance tests on this change shows that it yields, roughly, a 10% performance boost.</p>
<div><div><div><div><pre><p><span>Proportional differences from baseline</span></p><p><span>  Median -9.92%</span></p><p><span>  Weighted geometric mean -9.58%</span></p><p><span>  74.9% decreased to &lt;0.97x, 0.92% increased to &gt;1.03x</span></p><p><span>  59.8% decreased to &lt;0.93x, 0 increased to &gt;1.08x</span></p><p><span>  0.34% decreased to &lt;0.71x, 0 increased to &gt;1.4x</span></p><p><span>  0.04% decreased to &lt;0.5x, 0 increased to &gt;2x</span></p><p><span>  1% -24.3% | 10% -17.6% | 90% -0.153% | 99% +2.93%</span></p><p><span>  Extremes:</span></p><p><span>    -70.5% (from 148 ms to 43.5 ms)</span></p><p><span>    -52.6% (from 589 ms to 279 ms)</span></p><p><span>    +5.94% (from 55.4 ms to 58.7 ms)</span></p><p><span>    +6.60% (from 89.7 ms to 95.6 ms)</span></p></pre></div></div></div></div>
<h2>Conclusion</h2>
<p>Aside from the positive effect this change had on GRID&#39;s performance, I think it serves as a useful example to think about performance:</p>
<blockquote>
<p><em>Which information do we need to evaluate now, and which can we evaluate later?</em></p>
<p><em>What is the fixed cost associated with performing this operation?</em></p>
<p><em>Do we need to do this work in the first place?</em></p>
<p><em>Can we cache the result of this operation? How does that impact memory usage?</em></p>
</blockquote>
<p>Bear in mind that changes yielding a performance boost in some cases might cause degraded performance in others. Consider the worst case scenario and the circumstances under which it might occur.</p>
<p>As an example, the change from static properties to getters creates a worst-case scenario in which formulas repeatedly evaluate the same piece of information. This is the likely cause of the degraded performance we saw in a few documents (aside from noise). Maybe that could be mitigated with caching!</p>
<p>Anyway, I hope this served as an interesting read. Maybe you got some ideas that you can apply to your own code!</p>
<p>— Alex Harri</p>
<hr/>
<p>Big thank you to <a target="_blank" href="https://www.linkedin.com/in/gunnlaugur-briem/">Gunnlaugur Þór Briem</a> and <a target="_blank" href="https://www.linkedin.com/in/hjalli/">Hjálmar Gíslason</a> for reading the draft of this post and providing feedback!</p>
<p>PS: Check out <a target="_blank" href="https://grid.is/">GRID</a>! It&#39;s a fantastic tool for, amongst other things, building interactive documents on top of your spreadsheets.</p></main></div></div>
  </body>
</html>
