<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://catonmat.net/unix-utilities-pipe-viewer">Original</a>
    <h1>Pipe Viewer – A Unix Utility You Should Know About</h1>
    
    <div id="readability-page-1" class="page"><div>
                
    <p><img src="https://catonmat.net/wp-content/uploads/2009/02/unix-utilities.jpg" alt="Unix Utilities"/>Hi all! I&#39;m starting a new article series here. This one is going to be about Unix utilities that you should know about. The articles will discuss one Unix program at a time. I&#39;ll try to write a good introduction to the tool and give as many examples as I can think of.</p>
<p>The first post in this series is going to be about a not so well known but super powerful Unix program called <strong>Pipe Viewer</strong> or <strong>pv</strong> for short. Pipe viewer is a terminal-based tool for monitoring the progress of data through a pipeline. It can be inserted into any normal pipeline between two processes to give a visual indication of how quickly the data is passing through, how long it has taken, how near to completion it is, and an estimate of how long it will be until completion. </p>
<p>Pipe viewer is written by <a href="http://www.ivarch.com/">Andrew Wood</a>, an experienced Unix sysadmin. The homepage of pv utility is here: <a href="http://www.ivarch.com/programs/pv.shtml">pv utility</a>.</p>
<p>If you feel like you are interested in this stuff, I suggest that you subscribe to <a href="http://feeds.feedburner.com/catonmat">my rss feed</a> to receive my future posts automatically.</p>
<h2>How to use pv?</h2>
<p>Let&#39;s start with some really easy examples and progress to more complicated ones.</p>
<p>Suppose that you have a file <code>access.log</code> that is a tens of gigabytes in size and contains web logs. You want to compress it into a smaller file, let&#39;s say a gunzip archive (.gz). The obvious way to do it is:</p>
<pre>$ gzip -c access.log &gt; access.log.gz
</pre>
<p>As the file is so huge (tens of gigabytes), you have no idea how long to wait. Will it finish soon? Or will it take another 30 mins?</p>
<p>By using <code>pv</code> you can precisely time how long it will take:</p>
<pre>$ pv access.log | gzip &gt; access.log.gz
&lt;strong&gt;611MB 0:00:11 [58.3MB/s] [=&gt;      ] 15% ETA 0:00:59&lt;/strong&gt;
</pre>
<p>Pipe viewer acts as <code>cat</code> here, except it also adds a progress bar. We can see that gzip processed 611MB of data in 11 seconds. It has processed 15% of all data and it will take 59 more seconds to finish. So no coffee break.</p>
<p>You can stick several <code>pv</code> processes in your pipeline. For example, you can time how fast the data is being read from the disk with one <code>pv</code> and how much data has been gzipped via a second <code>pv</code>:</p>
<pre html="">$ pv -cN source access.log | gzip | pv -cN gzip &gt; access.log.gz
&lt;strong&gt;source:  760MB 0:00:15 [37.4MB/s] [=&gt;     ] 19% ETA 0:01:02
  gzip: 34.5MB 0:00:15 [1.74MB/s] [  &lt;=&gt;  ]&lt;/strong&gt;
</pre>
<p>Here we have specified the <code>-N</code> parameter to <code>pv</code> to create a named stream. The <code>-c</code> parameter makes sure the output is not garbaged by one pv process writing over the other.</p>
<p>This example shows that the <code>access.log</code> file is being read at the speed of 37.4MB/s but gzip is writing data at only 1.74MB/s. We can immediately calculate the compression rate. It&#39;s 37.4/1.74 = 21x!</p>
<p>Notice how <code>gzip</code> doesn&#39;t include how much data is left or how fast it will finish. It&#39;s because the <code>pv</code> process after <code>gzip</code> has no idea how much data <code>gzip</code> will produce (it&#39;s just outputting compressed data from input stream). The first pv process, however, knows how much data is left, because it&#39;s reading it from a known file.</p>
<p>Another similar example is be to pack the whole directory of files into a compressed tarball:</p>
<pre>$ tar -czf - . | pv &gt; out.tgz
&lt;strong&gt; 117MB 0:00:55 [2.7MB/s] [&gt;         ]&lt;/strong&gt;
</pre>
<p>In this example, <code>pv</code> only shows the output rate of the <code>tar -czf</code> command. It has no information about how bit the directory is or how long the <code>tar</code> process will run or how much data is left. We need to provide the total size of data we are tarring to pv. It can be done this way:</p>
<pre html="">$ tar -cf - . | pv -s $(du -sb . | awk &#39;{print $1}&#39;) | gzip &gt; out.tgz
&lt;strong&gt; 253MB 0:00:05 [46.7MB/s] [&gt;     ]  1% ETA 0:04:49&lt;/strong&gt;
</pre>
<p>What happens here is we tell tar to recursively (default mode) create (<code>-c</code> argument) an archive of all files in current dir (<code>.</code> argument) and output the data to stdout <code>-f - argument</code>. Next, we specify the size <code>-s</code> argument to pv of all files in current dir and all its subdirectories. The <code>du -sb . | awk &#39;{print $1}&#39;</code> command returns number of bytes in current dir and it&#39;s fed as the <code>-s</code> parameter to pv. Next, we gzip the content and output the result to <code>out.tgz</code> file. This way <code>pv</code> knows how much data is still left to be processed and shows us that it will take another 4 mins 49 secs to finish. So you can take a quick coffee break.</p>
<p>Another interesting example is copying large amounts of data over the network via the <code>nc</code> (netcat) utility that I will write about some other time.</p>
<p>(Update: Just wrote about it: <a href="https://catonmat.net/unix-utilities-netcat">Netcat – A Unix Utility You Should Know About</a>.)</p>
<p>Suppose you have two computers A and B. You want to transfer a directory from A to B very quickly. The fastest way to do it is to use <code>tar</code> and <code>nc</code>, and time the operation with <code>pv</code>.</p>
<p>On computer A with IP address 192.168.1.100 run this command:</p>
<pre>$ tar -cf - /path/to/dir | pv | nc -l -p 6666 -q 5
</pre>
<p>On computer B run this command:</p>
<pre>$ nc 192.168.1.100 6666 | pv | tar -xf -
</pre>
<p>That&#39;s it! All the files in <code>/path/to/dir</code> on computer A will get transferred to computer B, and you&#39;ll be able to see how fast the operation is going.</p>
<p>This will show how fast the data is being transferred but it won&#39;t show how much data is left. If you want this information, then you have to do the <code>pv -s $(...)</code> trick from the previous example and add it to <code>pv</code> on computer A.</p>
<p>Here&#39;s another fun example. It shows how fast the computer reads from <code>/dev/zero</code>:</p>
<pre>$ pv /dev/zero &gt; /dev/null
 157GB 0:00:38 [4.17GB/s]
</pre>
<p>That&#39;s it. I hope you enjoyed this post and learned something new. I love explaining things and teaching!  </p>
<h2>How to install pv?</h2>
<p>If you&#39;re on Debian or Debian based system such as Ubuntu do the following:</p>
<pre>$ sudo aptitude install pv
</pre>
<p>If you&#39;re on Fedora or Fedora based system such as CentOS do:</p>
<pre>$ sudo yum install pv
</pre>
<p>If you&#39;re on Mint, do:</p>
<pre>$ sudo apt-get install pv
</pre>
<p>If you&#39;re on Slackware, go to <a href="http://www.ivarch.com/programs/pv.shtml">pv homepage</a>, download the pv-version.tar.gz archive and do:</p>
<pre>$ tar -zxf pv-version.tar.gz
$ cd pv-version
$ ./configure &amp;&amp; sudo make install
</pre>
<p>If you&#39;re a Mac user:</p>
<pre>$ sudo port install pv
</pre>
<p>If you&#39;re OpenSolaris user:</p>
<pre>$ pfexec pkg install pv
</pre>
<p>If you&#39;re a Windows user on Cygwin:</p>
<pre>$ ./configure
$ export DESTDIR=/cygdrive/c/cygwin
$ make
$ make install
</pre>
<p>The manual of the utility can be found here <a href="http://www.ivarch.com/programs/quickref/pv.shtml">man pv</a>.</p>
<p>Have fun measuring your pipes with pv and until next time!</p>

            </div></div>
  </body>
</html>
