<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.veitheller.de/Simple_Sudoku_Solvers_SII%2C_EI%3A_Dyalog_APL.html">Original</a>
    <h1>Simple Sudoku Solvers SII, EI: Dyalog APL</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Welcome to the first post of the second season of <a href="https://blog.veitheller.de/sss/">Simple Sudoku Solvers</a>! If you
are unfamiliar with the series, I suggest you start with <a href="https://blog.veitheller.de/Six_Simple_Sudoku_Solvers_I:_Python_(Reference).html">the
first post</a>, otherwise buckle up, because we are going to look at a
lot of strange symbols today!</p>
<p>Today we’re going to look at APL, a strange old language fallen out
of time known for its terseness and strange alien symbols. Truth be
told, I could never get into it, and still can’t. Nonetheless, writing a
Sudoku solver seemed like the perfect weird challenge to get my hands
dirty on and give it an honest shot. And now I’m going to share the
bloody results with you!</p>
<p>Fair warning: in my efforts to make this code as “APL-like” as
possible, I’ve done a few iterations of golfing on it. Now the program
truly looks like APL, but might also be somewhat inscrutable to those
not in the know. To be clear, if I hadn’t written this code, I probably
would have trouble following it myself.</p>
<p>Another thing to note is that in this installment, contrary to prior
episodes, I will try to explain more or less every expression, in an
attempt to be a bit friendlier to my reader.</p>
<p>With all of the encouraging stuff out of the way, let’s dive right
in!</p>
<h2 id="why-apl">Why APL?</h2>
<p>APL is a language that looks like someone spilled a box of alien
maths onto your screen and then insisted this was a good idea. And maybe
they were right, I’m not smart enough to answer this question.</p>
<p>A few things make APL a fun fit for Sudoku even for mere mortals:</p>
<ul>
<li><strong>Everything is an array.</strong> Sudoku is a 9×9 array
problem. Matrices and arrays are APL’s food. It sounds like a match made
in heaven.</li>
<li><strong>Decoding indices and slicing submatrices is
built-in.</strong> We essentially just lean on basic operators to slice
and dice our rows, columns, and boxes.</li>
<li><strong>Set-ish operations are effortless.</strong> “Candidates are
digits minus used digits” is basically one operator. So is everything
else if you’re creative enough.</li>
<li><strong>Conciseness is not optional.</strong> APL will not let you
hide from your data model: if you choose a representation that’s
awkward, it will show immediately. It is also unforgiving toward clarity
of thought, which is both scary and cool.</li>
</ul>
<p>This post is not an APL primer. Hopefully I’ll explain enough to
follow along, but if you’ve never used APL before, the best strategy is:
keep reading, copy/paste code into an interpreter, and allow yourself to
be confused for a bit.</p>
<p>The dialect of APL I’m using is <a href="https://www.dyalog.com/">Dyalog APL</a>, which seems to be the
industry standard as far as I can tell. It’s a commercial offering, but
you can download the engine and IDE for free if you’re using it mostly
for play like me. It also comes with a program called
<code>dyalogscript</code>, which is a way of running Dyalog programs
from the terminal instead of their somewhat foreign IDE. Unfortunately
it’s pretty underspecified and typing APL is awkward to begin with, so I
spent way too much time trying to get this part to work. I recommend
just running it in their environment instead.</p>
<h2 id="the-implementation">The implementation</h2>
<p>As always, we initially represent the board as a matrix (9x9), where
<code>0</code> means “empty” and <code>1..9</code> are known digits. The
solver is the basic shape of filling, MRV, and backtracking/depth-first
search. This time, however, we’ll lean harder on array operations for
candidate computation, and keep everything else simple and obvious
(well, if you know how to read it).</p>
<p>In this installment, we’ll use the 9-bit boolean mask trick we’ve
used in previous installments to add extra flavor and because its
uniform length plays well with APL’s standard operations. It forces us
to compute masks and convert stuff, but since our actual implementation
is only ten ultra terse lines, we can afford it.</p>
<p>Importantly, internally we’ll deal with a single array of 81 values
to facilitate quicker operations. So we’ll start by getting a matrix,
and then flatten it, before printing it as a 9x9 matrix instead. The
high-level looks like this (<code>⍝</code> is the comment
delimiter):</p>
<pre><code>⍝ input matrix m (← is the assignment operator)
m←↑(
  (0 0 3 0 2 0 6 0 0)
  (9 0 0 3 0 5 0 0 1)
  (0 0 1 8 0 6 4 0 0)
  (0 0 8 1 0 2 9 0 0)
  (7 0 0 0 0 0 0 0 8)
  (0 0 6 7 0 8 2 0 0)
  (0 0 2 6 0 9 5 0 0)
  (8 0 0 2 0 3 0 0 9)
  (0 0 5 0 1 0 3 0 0)
)
⍝ flattened p
p←,m
⍝ S is the solver, 9 9⍴ prints it, assigning to ⎕ prints
⎕←9 9⍴S p</code></pre>
<p>We also set indexing to be 0-based (it’s 1-based by default), and
compute the space of possible digits <code>D</code>:</p>
<pre><code>⍝ the ⋄ sigil separates multiple expressions on one line
⎕IO←0 ⋄ D←1+⍳9</code></pre>
<p>With that out of the way, let’s look at the algorithm!</p>
<h3 id="the-main-solver">The main solver</h3>
<p>Staying true to the terseness of APL, we named the main solver
function <code>S</code>. It’s a unary function, and in APL we receive
that argument as <code>⍵</code>. With that out of the way, the rest of
the algorithm should be self-evident:</p>
<pre><code>S←{
  b←P ⍵ ⋄ 0=≢b:⍬ ⋄ ~0∊b:b
  i←⍸0=b ⋄ cs←↑(b∘C)¨i ⋄ l←+/cs ⋄ k←l⍳⌊/l ⋄ idx←i[k]
  sols←(⊂∘∇)¨({(⍵@idx)⊢b}¨cs[k;]/D)
  ⊃(((0&lt;(≢∘⊃)¨sols)/sols),⊂⍬)
}</code></pre>
<p>Sarcasm notwithstanding, the code is actually not as bad as it looks.
We start by propagating using <code>P</code>—more on that below—, and
assigning that to <code>b</code>. We return <code>⍬</code> if we get it
from <code>P</code> here, since this is our unsatisfiability marker
(<code>0=≢b:⍬</code>). If there are no zeros on the board, on the other
hand, we are done and return the board <code>b</code>
(<code>~0∊b:b</code>).</p>
<p>With the preconditions out of the way, we can move on to the main
branching algorithm. We get the indices <code>i</code> of the cells set
to zero (<code>i←⍸0=b</code>) and compute the candidates
(<code>cs←↑(b∘C)¨i</code>) and their respective counts
(<code>l←+/cs</code>). We then pick the cell with the fewest candidates
(<code>k←l⍳⌊/l</code>) and find its index (<code>idx←i[k]</code>).</p>
<p>After all of this, we are ready to solve the branches. We turn the
9-bit mask into the candidate digits (<code>cs[k;]/D</code>), and
produce a new board for all of them (<code>{(⍵@idx)⊢b}¨</code>,
<code>idx</code> being the index, and <code>@</code> the
functional/copying update). We pipe that into the solver, box each
result, and assign the vector of boxes to <code>sols</code>
(<code>sols←(⊂∘∇)¨</code>). All of that is one expression.</p>
<p>Finally, we just need to return the first match. We unbox each
solution and get its length (<code>(≢∘⊃)¨sols</code>), filter for the
non-empty ones (<code>0&lt;</code>), and take the first one, returning
<code>⍬</code> if we can’t find anything (<code>⊂⍬</code>).</p>
<p>Quick sidenote: you might ask yourself why we box <code>sols</code>
just to unbox it again. This is due to a feature of Dyalog APL, which
will happily mix the results of <code>∇¨</code> into a regular array if
it can, which breaks our filter/take first logic. Dyalog’s shape
coercion rule details are a bit much to get into here, but you can just
think of it as “if the shapes fit, smush them”, and that’s not what we
want here.</p>
<p>So, what we still need to define for this to click is the candidate
search <code>C</code> and propagation <code>P</code>.</p>
<h3 id="propagation">Propagation</h3>
<p>We will now tackle propagation, which thankfully is a bit less
involved (the next part will be simpler still!):</p>
<pre><code>P←{
  b←⍵ ⋄ i←⍸0=b ⋄ 0=≢i:b
  cs←↑(b∘C)¨i ⋄ l←+/cs ⋄ 0∊l:⍬
  f←l=1 ⋄ ~∨/f:b
  b[f/i]←(f⌿cs)+.×D ⋄ ∇b
}</code></pre>
<p>To remind ourselves: here we repeatedly fill any cell that has
exactly one candidate until we cannot any longer. We return
<code>⍬</code> on contradiction.</p>
<p>First, we assign our argument to <code>b</code>, because I’m a wuss
who wants descriptive names (<code>b←⍵</code>). Then, we get the indices
of empty cells again (<code>i←⍸0=b</code>, identical to above), and
compute the candidates (<code>cs←↑(b∘C)¨i</code>, again the same) and
their counts (<code>l←+/cs</code>). Here we need to guard against
impossibility: if any empty cell has 0 candidates, the current board is
impossible and we return <code>⍬</code> (<code>0∊l:⍬</code>). Then we
get the boolean masks of all cells with exactly one candidate
(<code>f←l=1</code>) and again guard: if there are no cells we can fill,
we return the board (<code>~∨/f:b</code>).</p>
<p>Finally, we can fill the board (<code>b[f/i]←(f⌿cs)+.×D</code>)! This
boils down to just getting the indices of what we need to fill
(<code>f/i</code>), selecting the corresponding masks
(<code>f⌿cs</code>), and converting it to a digit by computing the dot
product between rows and D (<code>(+.×D)</code>). The rest is an array
assignment.</p>
<p>The last expression is tail recursion: we will try to go for another
round of propagation (<code>∇b</code>).</p>
<h3 id="candidate-search">Candidate search</h3>
<p>Compared to the previous snippets, candidate search is almost easy to
grasp:</p>
<pre><code>C←{
  m←9 9⍴⍺ ⋄ r c←9 9⊤⍵ ⋄ r0 c0←3×⌊(r c)÷3
  ~(D∊0~⍨∪m[r;],m[;c],,m[r0+⍳3;c0+⍳3])
}</code></pre>
<p>Here we get a board and index and compute a mask. In “dyadic” APL
functions (one argument goes left and one goes right in the call), the
arguments are <code>⍺</code> and <code>⍵</code>.</p>
<p>So first we reshape the board back into a 9x9 matrix
(<code>m←9 9⍴⍺</code>), because rows, columns, and boxes fall out of
that more easily. We then decode the index into a row/column index pair
(<code>r c←9 9⊤⍵</code>) that we can use for the matrix and get the
start index of the box (<code>r0 c0←3×⌊(r c)÷3</code>, either
<code>0</code>, <code>3</code>, or <code>6</code>). We then collect the
row, column, and box values
(<code>m[r;], m[;c], ,m[r0+⍳3; c0+⍳3]</code>), make sure they’re unique
(<code>∪</code>), and remove 0 (<code>0~⍨</code>). We then turn it into
a candidate mask (<code>~(D∊&lt;expr&gt;)</code>) and return it!</p>
<p>In my opinion, this is where APL truly shines. Being able to easily
express column, row, and box indices is a superpower you only get from a
language that takes arrays and matrices as fundamental.</p>
<p>And this concludes our tour de force! Congratulations, you made
it!</p>
<h2 id="fin">Fin</h2>
<p>I don’t really know much about APL, but I think we did a pretty good
job of staying faithful to how you can work with it. I probably missed a
whole bunch of things that are obvious to more experienced sigil
slingers, but the easy immutable updating using <code>@</code>,
incredibly simple candidate selection, and very declarative search
algorithm (despite the scary syntax, it felt like just describing “solve
map over candidates, then pick first non-empty“) really did resonate
with me.</p>
<p>Thank you for tuning in for the first part of the second season of
our little Sudoku solver series. The next few episodes should be
somewhat less esoteric while still scratching that “mind-bending” itch.
See you around!</p>

      
    </div></div>
  </body>
</html>
