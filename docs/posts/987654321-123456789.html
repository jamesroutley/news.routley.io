<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.johndcook.com/blog/2025/10/26/987654321/">Original</a>
    <h1>987654321 / 123456789</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>I recently saw someone post [1] that 987654321/123456789 is very nearly 8, specifically 8.0000000729.</p>
<p>I wondered whether there’s anything distinct about base 10 in this. For example, would the ratio of 54321<sub>six</sub> and 12345<sub>six</sub> be close to an integer? The ratio is 4.00268, which is pretty close to 4.</p>
<p>What about a larger base? Let’s try base 16. The expression</p>
<pre>0xFEDCBA987654321 / 0x123456789ABCDEF</pre>
<p>in Python returns 14. The exact ratio is not 14, but it’s as close to 14 as a standard floating point number can be.</p>
<p>For a base <em>b</em>, let denom(<em>b</em>) to be the number formed by concatenating all the digits in ascending order and let num(<em>b</em>) be the number formed by concatenating all the digits in descending order.</p>
<p><img decoding="async" src="https://www.johndcook.com/desc_asc1.svg" alt="\begin{align*} \text{num}(b) &amp;= \sum_{k=1}^{b-1} kb^{k-1} \\ \text{denom}(b) &amp;= \sum_{k=1}^{b-1} (b-k)b^{k-1} \end{align*} " width="221" height="128"/></p>
<p>Then for <em>b</em> &gt; 2 we have</p>
<p><img decoding="async" src="https://www.johndcook.com/desc_asc2.svg" alt="\frac{\text{num}(b)}{\text{denom}(b)} = b - 2 + \frac{b-1}{\text{denom}(b)}" width="249" height="45"/></p>
<p>The following Python code demonstrates [2] that this is true for <em>b</em> up to 1000.</p>
<pre>num = lambda b: sum([k*b**(k-1) for k in range(1, b)])
denom = lambda b: sum([(b-k)*b**(k-1) for k in range(1, b)])

for b in range(3, 1001):
    n, d = num(b), denom(b)
    assert(n // d == b-2)
    assert(n % d == b-1)
</pre>
<p>So for any base the ratio is nearly an integer, namely <em>b</em> − 2, and the fractional part is roughly 1/<em>b</em><sup><em>b</em>−2</sup>.</p>
<p>When <em>b</em> = 16, as in the example above, the result is approximately</p>
<p>14 + 16<sup>−14</sup> = 8 + 4 + 2 + 2<sup>−56</sup></p>
<p>which would take 60 bits to represent exactly, but a floating point fraction only has 53 bits. That’s why our calculation returned exactly 14 with no fractional part.</p>

<p>[1] I saw @ColinTheMathmo post it on Mastodon. He said he saw it on Fermat’s Library somewhere. I assume it’s a very old observation and that the analysis I did above has been done many times before.</p>
<p>[2] Why include a script rather than a proof? One reason is that the proof is straight-forward but tedious and the script is compact.</p>
<p>A more general reason that I give computational demonstrations of theorems is that programs are complementary to proofs. Programs and proofs are both subject to bugs, but they’re not likely to have the <em>same</em> bugs. And because programs made details explicit by necessity, a program might fill in gaps that aren’t sufficiently spelled out in a proof.</p>
			</div></div>
  </body>
</html>
