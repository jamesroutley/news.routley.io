<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neugierig.org/software/blog/2024/12/jujutsu.html">Original</a>
    <h1>The Jujutsu version control system</h1>
    
    <div id="readability-page-1" class="page"><div>



<p><a href="https://github.com/martinvonz/jj">Jujutsu</a> is a new version control system that
seems pretty nice!</p>
<p>The first few times I tried it I bounced off
<a href="https://martinvonz.github.io/jj/latest/tutorial/">the docs</a>, which to my taste
has too much detail up front before I got the big picture. Someone else maybe
had a similar experience and wrote an
<a href="https://steveklabnik.github.io/jujutsu-tutorial/">alternative tutorial</a> but
it&#39;s in a rambly bloggy style that is also too focused on the commands for me.</p>
<p>I suspect, much like writing a monad tutorial, the path of understanding is
actually writing it down. So here&#39;s an attempt from me at an introduction /
tutorial.</p>
<p>Perhaps unlike the others, my goal is that this is high-level enough to read and
think about, without providing so much detail that it washes over you. Don&#39;t try
to memorize the commands here or anything, they&#39;re just here to communicate the
ideas. At the end if you&#39;re curious to try I recommend the docs found on their
website.</p>
<h2>Overview</h2>
<p>Omitting details, you can think of Jujutsu (hereafter &#34;jj&#34;) as a new Git
frontend. The underlying data is still stored in Git. The difference is how you
interact with your files locally, with a different conceptual model and a
different set of commands.</p>
<p>Git quiz: are commits snapshots of file state or diffs? The technical answer is
subtle — as a user you usually interact with them as diffs, while conceptually
they are snapshots, but concretely they are stored as deltas. The more useful
answer is that thinking about the details obfuscates the conceptual model.
Similarly, to describe jj in terms of what happens in Git is tempting but I
think ultimately clouds the explanation.</p>
<p>In practice what this means is try to put your knowledge of Git on hold, but
also be aware you can use jj and continue to interoperate with the larger Git
ecosystem, including e.g. pushing to GitHub.</p>
<h2>The big idea: everything is commits</h2>
<p>The purpose of a version control system is to keep track of the history of your
code. But interestingly in most, as soon as you edit a file locally in your
working copy, that new history (&#34;I have edited file X starting on version Y&#34;) is
is in a kind of limbo state outside of the system and managed separately.</p>
<p>This is so pervasive it&#39;s almost difficult to see. But consider how a command
like <code>git diff</code> has one mode that takes two commits to diff, and then a bunch of
other modes and flags to operate on the other kinds of things it tracks. You can
get a diff against your working copy but there&#39;s no way to name &#34;the working
copy&#34; in the diff command. (Git in particular adds the additional
not-quite-a-commit state of the index, with even more flavors of attendant
commands. The ultimate Git quiz: what are the different soft/hard/mixed
behaviors of <code>git reset</code>?)</p>
<p>Another example: consider how if you have a working copy change and and want to
check out other code you either have to put it in a new place (<code>git stash</code>, a
fourth place separate from the others) or make a temporary commit. Or how if you
have a working copy change that you want to transplant elsewhere you
<code>git checkout -m</code>, but to move around committed changes it&#39;s <code>git rebase</code>.</p>
<p>In jj, in contrast, your working copy state is always a commit. When making a
new change this is a new (descriptionless) commit. Any edit you make on disk is
immediately reflected in the current commit.</p>
<p>So many things fall out of this simple decision!</p>
<ul>
<li>
<p><code>jj diff</code> shows a commit&#39;s diff. With no argument it&#39;s the current commit&#39;s
diff, i.e. your current working copy&#39;s diff; otherwise you can specify which
historical one you want. Many other jj commands similarly have a pleasing
symmetry about their behavior like this.</p>
</li>
<li>
<p>You can draft the commit message for a work in progress commit before you&#39;re
done, using the same command you&#39;d use to edit any other commit message. There
is no final <code>jj commit</code> command, the commit is implicit. (Instead you <code>jj new</code>
to start a new empty commit when done.)</p>
</li>
<li>
<p>You never need to &#34;stash&#34; your current work to go do something else, it is
already stored in the current commit, and easy to jump back to.</p>
</li>
<li>
<p>In Git, to fix a typo in an old commit, you might make a new commit then
<code>git rebase -i</code> to move the patch around. In jj you directly check out the old
commit (because working copy == commit) and edit the files with no further
commands.
(<a href="https://lottia.net/notes/0013-git-jujutsu-miniature.html">This blog post</a>
walks through a real-world operation like this with Git and jj side by side.)</p>
</li>
</ul>
<p>From a Git perspective, jj is very &#34;rebasey&#34;. Editing a file is like a
<code>git commit --amend</code>, and in the &#34;fix a typo&#34; move above the edit implictly
rebases any downstream commits. To make that work out there are some other
conceptual leaps around conflict handling and branches that will come below
after the basics.</p>
<h2>The basic workflow</h2>
<p>In a Git repo:</p>
<pre><code>$ jj git init --colocate
</code></pre>
<p>This creates a <code>.jj</code> dir that works with the Git repo. Git commands will still
work but can be confusing.</p>
<p>The plain <code>jj</code> command runs <code>jj log</code>, showing recent commits. Here it is from
the repo for this blog:</p>
<pre><code>$ jj       
@  zyqszntn evan.martin@gmail.com 2024-12-12 11:58:52 21b06db8
│  (no description set)
○  pmnzyyru evan.martin@gmail.com 2024-12-12 11:58:48 86355427
│  unfinished drafts
◆  szzpmvlz evan.martin@gmail.com 2024-09-18 09:08:15 fcb1507d
│  syscalls
~
</code></pre>
<p>The leftmost letter string is the &#34;change id&#34;, which is the identifier you use
to refer to the change in a command like <code>diff</code>. They are stable across edits,
unlike the Git hashes on the right. In the terminal the change ids are colored
to show the necessary prefix to uniquely refer to them (a single letter) in
commands.</p>
<p>The topmost commit <code>zyqszntn</code> is the current one, containing this blog post as I
write it. As you would expect, if I run <code>jj status</code> it shows me the list of
edited files, and if I run <code>jj diff</code> it shows me a diff.</p>
<p>I can give it a description now or when I&#39;m done:</p>
<pre><code>$ jj desc -m &#39;post about jujutsu&#39;
</code></pre>
<p>And then create a new commit for the next change:</p>
<pre><code>$ jj new
</code></pre>
<h2>Iterating on changes</h2>
<p>That&#39;s enough for trivial changes, but often I work on more significant changes
where I might lose context across days. There are two ways you might do this
depending on how you work.</p>
<p>The first is to just describe your change as above and keep on editing it,
without running <code>jj new</code>. Each subsequent edit will update the change as you go.
This is simple to operate but it means <code>jj diff</code> will always show the whole
diff. In Git this is similar to just keeping a lot of edits in your working
copy.</p>
<p>The other option is called
&#34;<a href="https://steveklabnik.github.io/jujutsu-tutorial/real-world-workflows/the-squash-workflow.html">the squash workflow</a>&#34;
in the tutorial book. In this, when you do new work you <code>jj new</code> to create a new
distinct commit from your existing work, and when you are happy with it (by e.g.
examining <code>jj diff</code>, which shows you just the working copy&#39;s new changes) you
run <code>jj squash</code> to flush these new changes into the previous commit. To me this
feels pretty analogous to using the Git index as a staging area for a complex
change, or perhaps repeatedly using <code>git commit --amend</code>.</p>
<h2>Moving around and editing history</h2>
<p>These commands like <code>jj diff</code> and <code>jj desc</code> work on the current commit (or any
explicitly requested via the <code>-r flag</code>).</p>
<p>To switch the working copy to an existing change, it&#39;s <code>jj edit &lt;changeid&gt;</code>.
Again, any changes you make here, to the files or descriptions, or by making new
changes and squashing them, work directly on the historical commit you are
editing. I repeat this because it is both weird and obvious in retrospect.</p>
<h2>Conflicts</h2>
<p>Any operations on history cause implicit rebases that happen silently. Rebases
can conflict. jj has interesting handling of how this works.</p>
<p>In Git, rebase resolution happens through your working copy, so there is again
extra state around &#34;rebase in progress&#34; and <code>git rebase --continue</code>. In jj
instead, conflicting commits are just recorded as conflicting and marked as such
in the history, so rebases always &#34;succeed&#34; even if they produce a string of
conflicting commits.</p>
<p>If you go to fix a conflicting commit (via <code>jj edit</code> as above), you edit the
files as usual and once the conflict markers are removed it&#39;s no longer
considered conflicting.</p>
<p>As usual, once you make a history edit, downstream changes are again rebased,
possibly resolving their conflicted state after your edit. Again, the jj pattern
of &#34;all of the relevant information is modeled in the commits&#34; without having a
separate rebase mode with state etc. is a recurring powerful theme.</p>
<p>I don&#39;t have a lot of experience with this yet so I can&#39;t comment on how well it
works, except that the times I&#39;ve ran into it I was pleasantly surprised. The jj
docs seem proud of the modeling and behavior here which makes me think it&#39;s
plausibly sophisticated.</p>
<h2>Branches</h2>
<p>jj doesn&#39;t have named branches, but rather only keeps track of commits. Because
of the way jj juggles commits, where it&#39;s trivial to start adding commits at
random points in history, branch names are not as useful. In my experience so
far having useful commit descriptions is enough to keep track of what I&#39;m
working on. Coming from Git the lack of named branches is surprising, but I
believe this is comfortable for Mercurial users and Monotone worked similarly (I
think?).</p>
<p>It&#39;s worth highlighting the absence of branches because in particular when
interoperating with Git you still do need branches, if only to push. There is
support in jj for this (where &#34;bookmarks&#34; are pointers to specific commits) but
it feels a little clunky. On the other hand, I probably have Stockholm syndrome
about the <code>git push</code> syntax.</p>
<h2>What&#39;s missing: VSCode</h2>
<p>Working with jj made me realize how much I rely on VSCode&#39;s Git support, for
both viewing diffs and for merges.</p>
<p>When editing a given commit in jj, Git thinks all the files in the commit are in
the working tree and not the index. In other words, in the VSCode UI the current
diff shows up as pending changes just as they would in Git. This works pretty
well and is about all I would expect. I haven&#39;t yet touched the buttons that
interact with Git&#39;s index, for fear of what jj will do with it.</p>
<p>For technical reasons I do not quite understand — possibly VSCode only does
three-way file merges and jj needs three-way directory merges? — the two do not
quite cooperate for resolving conflicts. The jj docs recommend meld and I have
used meld in the past but I hadn&#39;t quite realized how VSCode had hooked me until
I missed using it for a merge.</p>
<h2>The future</h2>
<p>The author of jj works at Google and is possibly making it for the Google
internal version control system. (Above I wrote that jj is a Git frontend, but
officially it has pluggable backends; I&#39;m just unlikely to ever see a non-Git
one.)</p>
<p>When I
<a href="https://neugierig.org/software/blog/2021/07/leaving-google.html">left Google three years ago</a>
I recall they were trying to figure out what to do about either making Git
scale, or adopting Mercurial, or what. I remember talking to someone involved in
this area and thinking &#34;realistically your users have to use Git to work with
the larger world, so anything else you do is pure cost&#34;. I found
<a href="https://ahal.ca/blog/2024/jujutsu-mercurial-haven/">this post from a Mercurial fan</a>
about jj an interesting read in how it talks about Mercurial shortcomings it
fixes. From that perspective it is pretty interesting: it can replace the places
you currently use Git, while also providing a superior UI.</p>
<p>In all, jj seems pretty polished, has been around for years, and has a pretty
simple exit strategy if things go wrong — just bail out to the Git repo. I aim
to continue using it.</p>
<p>PS: every time I read the name &#34;jujutsu&#34; I kept thinking it was a misspelling of
&#34;jiu-jitsu&#34;, the martial art. But the Japanese word is じゅうじゅつ, it&#39;s
actually it&#39;s jiu-jitsu that is misspelled!
<a href="https://www.saferclimbing.org/en/article_misc/jiu-jitsu-or-jujutsu-romanisation-of-japanese">Read a longer article about it</a>.</p>

</div></div>
  </body>
</html>
