<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://earthly.dev/blog/aws-lambda-docker/">Original</a>
    <h1>Running Containers on AWS Lambda</h1>
    
    <div id="readability-page-1" class="page"><div>
      

      <section itemprop="text">
        
        <header>
          
          

  <p>
    

    

    
      
      

      <span>
        <i aria-hidden="true"></i>
        
          8 minute read
        
        
         	 <i aria-hidden="true"></i> Updated: <time datetime="2022-03-24T00:00:00-04:00">March 24, 2022</time>
        

      </span>
    
    <span>
      
      
      
      </span></p>
      
    
  


        </header>
      
        
          
        
        <p>Most of the code I’ve had running on AWS’s cloud has been in docker containers, running in Kubernetes clusters. And from my perspective, AWS was invisible. All I needed to concern myself with was the intricacies of getting the YAML for <code>kubectl apply</code> right. Of course, the cluster’s configuration was not my concern unless something went wrong, but I could then ping some Ops expert to help me out. But all that seems overkill for many tasks – the operational burden of maintaining Kubernetes is not free.</p>
<p>What if I want a simple container running in my AWS account, with some endpoints open to the world? What is the best way to get that in place? AWS offers many options: Amazon Elastic Container Service (ECS), Amazon Elastic Kubernetes Service (EKS), AWS App Runner, and AWS Lightsail. Maybe there are more options? I’m not sure how anyone keeps up with the myriad AWS possibilities. But, an option with some excellent attributes is AWS Lambda.</p>
<h2 id="containers-on-aws-lambda">Containers on AWS Lambda<a href="#containers-on-aws-lambda" title=""><span></span><i></i></a></h2>
<p>In its first revision, AWS Lambda supported giving the lambda a zip file of code, and that was about it. But it had two exciting scalability features. One, it could scale up to thousands of instances based on request load, and two, it scaled down to zero when no requests were coming in. That aggressive scheduling, combined with a billing structure where you only for the time your lambda is running, caused all the buzz around lambdas back when it was launched in 2014.</p>
<blockquote>
<p>AWS Lambda is a compute service that runs your code in response to events and automatically manages the compute resources for you, making it easy to build applications that respond quickly to new information. AWS Lambda starts running your code within milliseconds of an event such as an image upload, in-app activity, website click, or output from a connected device. You can also use AWS Lambda to create new back-end services where compute resources are automatically triggered based on custom requests.</p>
</blockquote>
<p>But, I never got interested in lambdas myself. I worked in Scala, which runs on the JVM, which has a slow start-up time, and I also was into containers as a packaging unit and so although I heard people talk about lambda’s I didn’t pay attention.</p>
<p>But then, in 2020, AWS added support for containers. This may be naive, but the lambda product suddenly made more sense to me. If I could take my app, wrap it up in a container, which I was doing already, and have it running in AWS Lambda, it was like getting to deploy things into a giant Kubernetes cluster in the sky. The horizontal scaling features that were hard to get right in Kubernetes (<code>HPAScaleToZero</code>), were built into lambdas, and if your app has a slow start up time, with provisioned concurrency, you can always keep some instances running, never scaling back right to zero.</p>
<p>All of this to say, 8 years after its launch, I’m starting to see what the hype is about. So let me show you the setup for running a container in a Lambda.</p>
<p>What I’m going to make will be pretty straightforward. It will be a small node.js app that will take a URL, download it, and return the results – basically a simple web proxy.</p>
<h2 id="typescript-lambda">TypeScript Lambda<a href="#typescript-lambda" title=""><span></span><i></i></a></h2>
<p>The first thing I’m going to do is create a TypeScript file that will be the bulk of my lambda. Any programming language that can run inside a container will work, though. The main trick is just conforming to the shape of input and output expected by a lambda.</p>
<p>For instance, when I make a request against the AWS API Gateway that I’ll be setting up shortly, like this:</p>
<div id="cb1" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span>curl</span> ((URL))<span>/endpoint</span>/<span>?url</span>=https://earthly.dev/blog/golang-monorepo/</span></code></pre></div>
<p>Then AWS Lambda will receive the event like this:</p>
<div id="cb2" data-caption="lambda input"><pre><span>lambda input</span><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span>{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span>&#34;queryStringParameters&#34;</span><span>:</span> <span>{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span>&#34;url&#34;</span><span>:</span> <span>&#34;https://earthly.dev/blog/golang-monorepo/&#34;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span>}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>And if I want to return a plain text 500 error from my lambda I need to return a JSON object like this:</p>
<div id="cb3" data-caption="lambda output"><pre><span>lambda output</span><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span>{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a> <span>&#34;statusCode&#34;</span> <span>:</span> <span>500</span><span>,</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span>&#34;headers&#34;</span> <span>:</span> <span>{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span>&#34;content-type&#34;</span><span>:</span> <span>&#34;text/plain; charset=utf-8&#34;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  <span>},</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  <span>&#34;body&#34;</span> <span>:</span> <span>&#34;Some error fetching the content&#34;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>With that in mind, my TypeScript code looks like this:</p>
<div id="cb4" data-caption="app.ts"><pre><span>app.ts</span><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span>&#39;use strict&#39;</span><span>;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>const axios <span>=</span> <span>require</span>(<span>&#34;axios&#34;</span>)<span>.</span><span>default</span><span>;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>exports<span>.</span><span>handler</span> <span>=</span> (event<span>:</span> { queryStringParameters<span>:</span> { url<span>:</span> <span>string</span><span>;</span> }<span>;</span> }) <span>=&gt;</span> {</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span>if</span> (<span>!</span>event<span>.</span><span>queryStringParameters</span> <span>||</span> <span>!</span>event<span>.</span><span>queryStringParameters</span><span>.</span><span>url</span>) {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>        let response <span>=</span> {</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>            statusCode<span>:</span> <span>200</span><span>,</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>            headers<span>:</span> {</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>                <span>&#34;content-type&#34;</span><span>:</span> <span>&#34;text/plain; charset=utf-8&#34;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>            }<span>,</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>            body<span>:</span> <span>&#34;Please provide a url as a query string parameter&#34;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>        }<span>;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>        <span>return</span> (<span>Promise</span><span>.</span><span>resolve</span>(response))<span>;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>    } else {</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>        const url <span>=</span> event<span>.</span><span>queryStringParameters</span><span>.</span><span>url</span><span>;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>        return <span>call</span>(url)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>    }</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a>}<span>;</span></span></code></pre></div>
<p>I’m returning an explanatory message in plain text if the URL is missing, and otherwise, I return the result of <code>call</code>.</p>
<p>Since this is running in a container, <code>call</code> could call out to other programs installed in the container – perhaps downloading the html, and running an html minimizer? But for tutorial purposes, all it does is download the html content and return it as text.</p>
<div id="cb5" data-caption="app.ts continued"><pre><span>app.ts continued</span><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span>function</span> <span>call</span>(url<span>:</span> <span>string</span>) {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    <span>console</span><span>.</span><span>log</span>(<span>&#34;Getting:&#34;</span> <span>+</span> url)<span>;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    return axios</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>        <span>.</span><span>get</span>(url)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>        <span>.</span><span>then</span>((response<span>:</span> { data<span>:</span> <span>string</span> }) <span>=&gt;</span> {</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>            <span>console</span><span>.</span><span>log</span>(<span>&#34;Got content for:&#34;</span> <span>+</span> url )<span>;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>            return {</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>                statusCode<span>:</span> <span>200</span><span>,</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>                headers<span>:</span> {</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>                    <span>&#34;content-type&#34;</span><span>:</span> <span>&#34;text/plain; charset=utf-8&#34;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>                }<span>,</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>                body<span>:</span> response</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true"></a>            }<span>;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true"></a>        })</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true"></a>        <span>.</span><span>catch</span>((error<span>:</span> Error) <span>=&gt;</span> {</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true"></a>            return {</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true"></a>                statusCode<span>:</span> <span>500</span><span>,</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true"></a>                headers<span>:</span> {</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true"></a>                    <span>&#34;content-type&#34;</span><span>:</span> <span>&#34;text/plain; charset=utf-8&#34;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true"></a>                }<span>,</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true"></a>                body<span>:</span> <span>&#34;Some error fetching the content&#34;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true"></a>            }<span>;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true"></a>        })<span>;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true"></a>}</span></code></pre></div>
<p>I build this file with <code>tsc</code> into <code>built/app.js</code>, and then I wrap it up into a docker container for deployment to AWS Lambda.</p>
<div id="cb6" data-caption="dockefile"><pre><span>dockefile</span><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span>FROM</span> public.ecr.aws/lambda/nodejs:12</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span>COPY</span> package*.json ./</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span>COPY</span> built/*.js ./</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span>RUN</span> npm install</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span>CMD</span> [ <span>&#34;app.handler&#34;</span> ]</span></code></pre></div>
<p>I’m using Amazon’s suggested base container for Node.js which is a Red Hat linux container with the AWS lambda runtime installed.</p>
<p>Using Amazon’s images, the lambda runtime is already installed, and everything is configured for it to start up. I can see this using <code>docker inspect</code></p>
<div id="cb7" data-caption="docker inspect"><pre><span>docker inspect</span><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span>{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a> <span>...</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a> <span>&#34;Env&#34;</span><span>:</span> <span>[</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span>&#34;LAMBDA_TASK_ROOT=/var/task&#34;</span><span>,</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>    <span>&#34;LAMBDA_RUNTIME_DIR=/var/runtime&#34;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>       <span>]</span><span>,</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a> <span>&#34;WorkingDir&#34;</span><span>:</span> <span>&#34;/var/task&#34;</span><span>,</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a> <span>&#34;Entrypoint&#34;</span><span>:</span> <span>[</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>    <span>&#34;/lambda-entrypoint.sh&#34;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    <span>]</span><span>,</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a> <span>...</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>Amazon provides several container bases, but you can also install the <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-create-from-alt" target="_blank">container base of your choosing</a>.</p>
<p>Now, let’s run something.</p>
<h2 id="testing-lambdas-locally">Testing Lambdas Locally<a href="#testing-lambdas-locally" title=""><span></span><i></i></a></h2>
<p>With the app containerized, it’s straightforward to test it locally:</p>
<p>First, I build it:</p>
<div id="cb8" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>$ <span>docker</span> build i  -t 733977735356.dkr.ecr.us-east-1.amazonaws.com/container-test .</span></code></pre></div>
<p>Then I can run it.</p>
<div id="cb9" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>$ <span>docker</span> run -p 9000:8080 /</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>    <span>733977735356.dkr.ecr.us-east-1.amazonaws.com</span>/container-test:<span>latest</span></span></code></pre></div>
<p>And exercise it.</p>
<div id="cb10" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>$ <span>curl</span> -XPOST <span>&#34;http://localhost:9000/2015-03-31/functions/function/invocations&#34;</span> -d <span>&#39;{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span>  &#34;queryStringParameters&#34;: {</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span>    &#34;url&#34;: &#34;https://icanhazip.com/&#34;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a><span>  }</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a><span>}&#39;</span></span></code></pre></div>
<div id="cb11" data-caption="Output"><pre><span>Output</span><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span>{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span>&#34;statusCode&#34;</span>:<span>200</span>,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span>&#34;headers&#34;</span>:</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>        <span>{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>            <span>&#34;content-type&#34;</span>:<span>&#34;text/plain; charset=utf-8&#34;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>        <span>}</span>,</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span>&#34;body&#34;</span>:<span>&#34;76.6.XXX.XXX\n&#34;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span>}</span></span></code></pre></div>
<p>Note how I need to make my requests in the same fashion the API Gateway will. My actual API can be accessed via GET requests with a URL parameter, but to exercise it when no API Gateway sits in front of it, I need to simulate the lambda runtime by using a properly formatted POST.</p>
<h3 id="elastic-container-registry">Elastic Container Registry<a href="#elastic-container-registry" title=""><span></span><i></i></a></h3>
<p>After that, I need to push my image to AWS ECR.</p>
<p>First I create a repository:</p>
<div>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/4460-1000-7e9402770.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/4460-1200-7e9402770.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/4460-1400-7e9402770.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/4460-1000-7e9402770.png 1000w, /blog/generated/assets/images/aws-lambda-docker/4460-1200-7e9402770.png 1200w, /blog/generated/assets/images/aws-lambda-docker/4460-1400-7e9402770.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/4460-800-7e9402770.png"/></picture></p>
<figcaption>
Create Repo in ECR
</figcaption>
</div>
<p>Then I log in and push to it.</p>
<div id="cb12" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>$ <span>aws</span> ecr get-login-password --region us-east-1 <span>|</span> <span>\</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>    <span>docker</span> login --username AWS --password-stdin <span>\</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span>XXXXXXXXXXXXXXXXXXX.dkr.ecr.us-east-1.amazonaws.com</span> </span></code></pre></div>
<div id="cb13" data-caption="Output"><pre><span>Output</span><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a> [<span>733977735356.dkr.ecr.us-east-1.amazonaws.com</span>/<span>container-test</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span>6f55f8f6a022</span>: Pushed </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span>ff595bbcde74</span>: Pushed </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a><span>428b5d37bdb8</span>: Pushed </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a><span>aa262ea90a60</span>: Pushed </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a><span>b84abea626b7</span>: Pushed </span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span>c51ba664b438</span>: Pushed </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a><span>2b9913d02f84</span>: Pushed </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span>d589926497ff</span>: Pushed </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span>00a4e675f0b7</span>: Pushed </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a><span>3f1bccf018a1</span>: Pushed </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a><span>latest</span>: digest: sha256:f5578098c6677638e2 size: 2420</span></code></pre></div>
<p>And then, create the lambda by selecting ‘Create Function’ and ‘Container Image’.</p>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/5170-1000-c75528bb2.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/5170-1200-c75528bb2.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/5170-1400-c75528bb2.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/5170-1000-c75528bb2.png 1000w, /blog/generated/assets/images/aws-lambda-docker/5170-1200-c75528bb2.png 1200w, /blog/generated/assets/images/aws-lambda-docker/5170-1400-c75528bb2.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/5170-800-c75528bb2.png"/></picture></p>
<p>Then I select my image.</p>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/5200-1000-33acbc839.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/5200-1200-33acbc839.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/5200-1400-33acbc839.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/5200-1000-33acbc839.png 1000w, /blog/generated/assets/images/aws-lambda-docker/5200-1200-33acbc839.png 1200w, /blog/generated/assets/images/aws-lambda-docker/5200-1400-33acbc839.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/5200-800-33acbc839.png"/></picture></p>
<p>And then create a trigger.</p>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/5320-1000-228ff823d.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/5320-1200-228ff823d.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/5320-1400-228ff823d.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/5320-1000-228ff823d.png 1000w, /blog/generated/assets/images/aws-lambda-docker/5320-1200-228ff823d.png 1200w, /blog/generated/assets/images/aws-lambda-docker/5320-1400-228ff823d.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/5320-800-228ff823d.png"/></picture></p>
<div>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/5430-1000-ed98b7584.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/5430-1200-ed98b7584.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/5430-1400-ed98b7584.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/5430-1000-ed98b7584.png 1000w, /blog/generated/assets/images/aws-lambda-docker/5430-1200-ed98b7584.png 1200w, /blog/generated/assets/images/aws-lambda-docker/5430-1400-ed98b7584.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/5430-800-ed98b7584.png"/></picture></p>
<figcaption>
</figcaption>
</div>
<p>At this point, I’m all set up, and I can start using my lambda.</p>
<h2 id="calling-my-endpoint">Calling My Endpoint<a href="#calling-my-endpoint" title=""><span></span><i></i></a></h2>
<p>Amazon provides me with an URL and an endpoint, which I can call via my web browser.</p>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/5520-1000-2d478f45a.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/5520-1200-2d478f45a.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/5520-1400-2d478f45a.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/5520-1000-2d478f45a.png 1000w, /blog/generated/assets/images/aws-lambda-docker/5520-1200-2d478f45a.png 1200w, /blog/generated/assets/images/aws-lambda-docker/5520-1400-2d478f45a.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/5520-800-2d478f45a.png"/></picture></p>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/5650-1000-0b6632765.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/5650-1200-0b6632765.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/5650-1400-0b6632765.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/5650-1000-0b6632765.png 1000w, /blog/generated/assets/images/aws-lambda-docker/5650-1200-0b6632765.png 1200w, /blog/generated/assets/images/aws-lambda-docker/5650-1400-0b6632765.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/5650-800-0b6632765.png"/></picture></p>
<p>It’s also simple to test it with a curl at the command line. The IP returned by requesting <a href="https://icanhazip.com/" target="_blank"><code>I can haz IP</code></a> via this simple proxy is not my IP, but the IP Amazon is using to make the requests.</p>
<div id="cb14" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>$ <span>curl</span> https://5f8lt8irs0.execute-api.us-east-1.amazonaws.com/default/container-test\?url\=https://icanhazip.com/</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span>100.27.35.7</span></span></code></pre></div>
<section id="side-note-home-path">
<h3>Side Note: Home Path</h3>
<p>If you are spawning processes and running things in a shell inside your container, inside your lambda, be aware that the home directory, as of March, 2022 is not properly configured and you will get an error like this:</p>
<div id="cb15" data-caption="error"><pre><span>error</span><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span>ENOENT</span>: no such file or directory, mkdir <span>&#39;/home/sbx_user1051/</span></span></code></pre></div>
<p>See <a href="https://github.com/alixaxel/chrome-aws-lambda/issues/131" target="_blank">this error</a>, but the easiest way to fix is just set <code>$HOME</code> to <code>/tmp</code> in the environmental variables section of lambda configuration.</p>
<p><picture><source srcset="/blog/generated/assets/images/aws-lambda-docker/7210-1000-81c638c29.webp 1000w, /blog/generated/assets/images/aws-lambda-docker/7210-1200-81c638c29.webp 1200w, /blog/generated/assets/images/aws-lambda-docker/7210-1400-81c638c29.webp 1400w" type="image/webp"/><source srcset="/blog/generated/assets/images/aws-lambda-docker/7210-1000-81c638c29.png 1000w, /blog/generated/assets/images/aws-lambda-docker/7210-1200-81c638c29.png 1200w, /blog/generated/assets/images/aws-lambda-docker/7210-1400-81c638c29.png 1400w" type="image/png"/><img src="http://harihareswara.net/blog/generated/assets/images/aws-lambda-docker/7210-800-81c638c29.png"/></picture></p>
</section>
<h3 id="deploying-changes">Deploying Changes<a href="#deploying-changes" title=""><span></span><i></i></a></h3>
<p>One thing that caught me out with this solution is that, although I’ve deployed <code>:latest</code>, updating the latest image doesn’t change whats running in the lambda. Instead, the lambda just uses the tag to look up the sha of a container, pulls based on that sha, and runs that.</p>
<p>I can quickly deploy a new image using the aws cli, though.</p>
<div id="cb16" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a> <span>aws</span> lambda update-function-code <span>\</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>      <span>--region</span> us-east-1 <span>\</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>      <span>--function-name</span> container-test <span>\</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>      <span>--image-uri</span> 733977735356.dkr.ecr.us-east-1.amazonaws.com/container-test:latest</span></code></pre></div>
<p>So there you go, I have containers working in lambdas. And this will work with any software stack that you can get inside a linux container.</p>
<h2 id="continuous-deployment">Continuous Deployment<a href="#continuous-deployment" title=""><span></span><i></i></a></h2>
<p>From where I’m at now, it’s not far to a full deployment solution.</p>
<p>To get there, first I’ll make my docker container inside an Earthfile.</p>
<div id="cb17" data-caption="Earthfile"><pre><span>Earthfile</span><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span>FROM</span> public.ecr.aws/lambda/nodejs:12</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>build:</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    <span>COPY</span> package*.json readme.txt ./</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span>COPY</span> built/*.js ./</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    <span>RUN</span> npm install</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    <span>CMD</span> [ <span>&#34;app.handler&#34;</span> ]</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    SAVE IMAGE 733977735356.dkr.ecr.us-east-1.amazonaws.com/container-test:latest</span></code></pre></div>
<p>Then, in the same Earthfile, I need a deploy step. First I use the <code>aws cli</code> image:</p>
<div id="cb18" data-caption="Earthfile"><pre><span>Earthfile</span><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>deploy:</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>    <span>FROM</span> amazon/aws-cli</span></code></pre></div>
<p>Then I need to pass in AWS config and AWS credentials as secrets. I do this using a secret mount.</p>
<pre><code> RUN --mount=type=secret,target=/root/.aws/config,id=+secrets/config \
     --mount=type=secret,target=/root/.aws/credentials,id=+secrets/credentials \
     --no-cache \</code></pre>
<p>This I deploy away, using <code>aws lambda update-function-code</code>. All together it looks like this:</p>
<div id="cb20" data-caption="Earthfile"><pre><span>Earthfile</span><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>deploy:</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>    <span>FROM</span> amazon/aws-cli</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>    <span>RUN</span> --mount=type=secret,target=/root/.aws/config,id=+secrets/config \</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>        --mount=type=secret,target=/root/.aws/credentials,id=+secrets/credentials \</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>        --no-cache \</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>        aws lambda update-function-code \</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>            --region us-east-1 \</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>            --function-name text-mode \</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>            --image-uri 733977735356.dkr.ecr.us-east-1.amazonaws.com/text-mode:latest</span></code></pre></div>
<p>Then in my chosen CI, when something is merged into my main branch, I just run <code>earthly +build --push</code>, and <code>earthly +deploy</code>, and my function will be updated.</p>
<div>
<p>Taking proper care of secrets is important, so I’m using Earthly’s secret support whenever I touch to my AWS credentials. This way I can ensure they aren’t cached.</p>
<p>To call my deploy step I need to pass my aws config files as secrets like this:</p>
<div id="cb21" data-caption="&gt;_"><pre><span>&gt;_</span><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a> <span>earthly</span> <span>\</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  <span>--secret-file</span> config=/Users/adam/.aws/config <span>\</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>  <span>--secret-file</span> credentials=/Users/adam/.aws/credentials <span>\</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  <span>+deploy</span></span></code></pre></div>
</div>
<p>And with that, I have a container running in AWS, where I’m only billed for the milliseconds it runs, with a full – although simple – deployment pipeline.</p>
<div>
<p>
<strong>While you’re here:</strong>
</p>
<p>
<a href="https://earthly.dev/">Earthly</a> is a syntax for defining your build. It works with your existing build system. Get repeatable and understandable builds today.
</p>
</div>

        
      </section>

      


<div itemscope="" itemtype="https://schema.org/Person">
  
    <div>
      
        <picture><source data-srcset="/blog/generated/assets/images/authors/adamgordonbell-240-fc29677ee.webp 240w" type="image/webp"/><source data-srcset="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png 240w" type="image/png"/><img data-src="/blog/generated/assets/images/authors/adamgordonbell-240-ad4309f1a.png" alt="Adam Gordon Bell %"/></picture>

      
    </div>
  
  <div>
    
      <p>
        Adam Gordon Bell
    
    
      
        
          <a href="https://twitter.com/adamgordonbell" rel="nofollow noopener noreferrer" target="_blank"><i aria-hidden="true"></i><span></span></a>
        
      
        
          <a href="mailto:adam+website@earthly.dev" rel="nofollow noopener noreferrer" target="_blank"><i aria-hidden="true"></i><span></span></a>
        
      
        
          <a href="https://corecursive.com" rel="nofollow noopener noreferrer" target="_blank"><i aria-hidden="true"></i><span></span></a>
        
      
    
      </p>
    
      <p>Spreading the word about Earthly. Host of CoRecursive podcast. Physical Embodiment of Cunningham’s Law</p>
    
  </div>

  
</div>

      

      
    </div></div>
  </body>
</html>
