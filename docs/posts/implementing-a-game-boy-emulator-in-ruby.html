<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sacckey.dev/posts/implementing-a-game-boy-emulator-in-ruby/">Original</a>
    <h1>Implementing a Game Boy emulator in Ruby</h1>
    
    <div id="readability-page-1" class="page"><div><h2 id="introduction">Introduction</h2><p>I created a Game Boy emulator in Ruby and released it as a gem called rubyboy!
(I‚Äôd be happy if you could give it a star!)</p><p><a href="https://github.com/sacckey/rubyboy" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://github-readme-stats.vercel.app/api/pin/?username=sacckey&amp;repo=rubyboy&amp;show_owner=true&amp;hide_border=true" alt="rubyboy by sacckey"/></a></p><p>And now it runs in the browser using WebAssembly!</p><p><strong><a href="https://sacckey.github.io/rubyboy/">Try the demo in your browser!</a></strong></p><h3 id="screenshots">Screenshots</h3><table><thead><tr><th><img loading="lazy" src="https://raw.githubusercontent.com/sacckey/rubyboy/main/resource/screenshots/pokemon.png" alt=""/></th><th><img loading="lazy" src="https://raw.githubusercontent.com/sacckey/rubyboy/main/resource/screenshots/puyopuyo.png" alt=""/></th></tr></thead></table><blockquote data-align="center" data-media-max-width="560"><p lang="ja" dir="ltr">Ruby„Åß„Ç≤„Éº„É†„Éú„Éº„Ç§„ÅÆ„Ç®„Éü„É•„É¨„Éº„Çø„Çí‰Ωú„Çä„Åæ„Åó„ÅüÔºÅ</p>‚Äî sacckey (@sacckey) <a href="https://twitter.com/sacckey/status/1769334370102587629?ref_src=twsrc%5Etfw">March 17, 2024</a></blockquote><p><img src="https://storage.googleapis.com/zenn-user-upload/04b2e5fb8827-20250115.png" width="500"/></p><h2 id="this-article">This Article</h2><p>While explaining the implementation process of Ruby Boy, I‚Äôll introduce the points where I got stuck and the techniques I devised.
I‚Äôll also introduce what I did to optimize Ruby Boy.</p><p>Finally, I‚Äôll show how Ruby Boy works in the browser using WebAssembly.</p><h2 id="why-i-created-a-game-boy-emulator">Why I Created a Game Boy Emulator</h2><ul><li>I wanted to do some personal development, but since web services incur maintenance costs, I wanted to create something that could be maintained for free</li><li>As I use Ruby for work, I had been wanting to create a Ruby gem for a while</li><li>Developing a game emulator has ‚Äúclear goals &amp; is fun when it works‚Äù, so it seemed like it would be easier to maintain motivation<ul><li>In particular, I have a special attachment to the Game Boy</li></ul></li></ul><p>‚Üí Let‚Äôs create a Game Boy emulator in Ruby and release it as a gem!</p><h2 id="emulator-overview">Emulator Overview</h2><p>The following image is the architecture of the Game Boy:</p><p><img src="https://storage.googleapis.com/zenn-user-upload/2a6af06959a6-20240408.png" width="500"/>
<em>&#34;Game Boy / Color Architecture - A Practical Analysis&#34; by Rodrigo Copetti, Published: February 21, 2019, Last Modified: January 9, 2024. Available at: https://www.copetti.org/writings/consoles/game-boy/. Licensed under Creative Commons Attribution 4.0 International License.</em></p><p>The goal is to implement a program that emulates this hardware.
The class diagram of Ruby Boy and the roles of each class are as follows:</p><p><img loading="lazy" src="https://storage.googleapis.com/zenn-user-upload/c11260f6c5a5-20240420.jpeg" alt=""/></p><ul><li>Console: Main class</li><li>Lcd: Handles screen rendering</li><li>Bus: Controller for implementing memory-mapped I/O. Mediates the reading and writing of configuration values from the CPU to various hardware</li><li>Cpu: Reads instructions from ROM, interprets and executes them</li><li>Registers: Performs reading and writing of registers</li><li>Cartridge: Performs reading and writing of ROM and RAM in the cartridge. Implementation differs for each type of MBC chip (explained later)</li><li>Apu: Generates audio data</li><li>Rom: Loads the game program from the cartridge</li><li>Ram: Performs reading and writing of RAM data in the cartridge and Game Boy</li><li>Interrupt: Manages interrupts. Interrupts are performed from the following three classes</li><li>Timer: Counts the number of cycles</li><li>Ppu: Generates pixel information to be rendered on the display</li><li>Joypad: Receives button inputs from the Game Boy</li></ul><p>In Ruby Boy, synchronization between components is achieved by having the CPU execute instructions and advancing the cycle count of Ppu, Timer, and Apu by the number of cycles taken for execution.
Therefore, the contents of the main loop are as follows:</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>cycles</span> <span>=</span> <span>@cpu</span><span>.</span><span>exec</span>
</span></span><span><span><span>@timer</span><span>.</span><span>step</span><span>(</span><span>cycles</span><span>)</span>
</span></span><span><span><span>@apu</span><span>.</span><span>step</span><span>(</span><span>cycles</span><span>)</span>
</span></span><span><span><span>if</span> <span>@ppu</span><span>.</span><span>step</span><span>(</span><span>cycles</span><span>)</span>
</span></span><span><span>  <span>@lcd</span><span>.</span><span>draw</span><span>(</span><span>@ppu</span><span>.</span><span>buffer</span><span>)</span>
</span></span><span><span>  <span>key_input_check</span>
</span></span><span><span>  <span>throw</span> <span>:exit_loop</span> <span>if</span> <span>@lcd</span><span>.</span><span>window_should_close?</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h2 id="implementation-process">Implementation Process</h2><p>I have compiled my implementation notes in a <a href="https://zenn.dev/sacckey/scraps/380c2f3ad3318d">scrap</a>. I will explain by extracting from this.</p><h3 id="ui-implementation">UI Implementation</h3><p>The UI part that handles screen rendering, audio playback, and keyboard input was implemented using SDL2 via the <a href="https://github.com/ffi/ffi">Ruby-FFI gem</a>.
I created a <a href="https://github.com/sacckey/rubyboy/blob/main/lib/rubyboy/sdl.rb">wrapper class</a> that aggregates the necessary SDL2 methods, and the design is to call SDL2 methods from there.</p><h3 id="rom-loading">ROM Loading</h3><p>First, I made it possible to load and use the game data.
For example, the title is stored at 0x0134~0x0143, so it can be retrieved as follows:</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>data</span> <span>=</span> <span>File</span><span>.</span><span>open</span><span>(</span><span>&#39;tobu.gb&#39;</span><span>,</span> <span>&#39;r&#39;</span><span>)</span> <span>{</span> <span>_1</span><span>.</span><span>read</span><span>.</span><span>bytes</span> <span>}</span>
</span></span><span><span><span>p</span> <span>data</span><span>[</span><span>0x134</span><span>..</span><span>0x143</span><span>].</span><span>pack</span><span>(</span><span>&#39;C*&#39;</span><span>)</span><span>.</span><span>strip</span>
</span></span><span><span><span>=&gt;</span> <span>&#34;TOBU&#34;</span>
</span></span></code></pre></div><h3 id="implementation-of-mbc-memory-bank-controller">Implementation of MBC (Memory Bank Controller)</h3><p>Many Game Boy games use MBC (Memory Bank Controller), which achieves address space expansion through bank switching.
There are different types of MBC chips such as MBC1, MBC3, MBC5, etc., each with different sizes of usable ROM and RAM, so implementation specific to the type of MBC chip is necessary.
Ruby Boy supports NoMBC (without MBC) and MBC1 games, and I used the Factory pattern to return the appropriate MBC implementation. By adding chip implementations and case handling, it‚Äôs possible to support other types of MBC chips as well.</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>module</span> <span>Rubyboy</span>
</span></span><span><span>  <span>module</span> <span>Cartridge</span>
</span></span><span><span>    <span>class</span> <span>Factory</span>
</span></span><span><span>      <span>def</span> <span>self</span><span>.</span><span>create</span><span>(</span><span>rom</span><span>,</span> <span>ram</span><span>)</span>
</span></span><span><span>        <span>case</span> <span>rom</span><span>.</span><span>cartridge_type</span>
</span></span><span><span>        <span>when</span> <span>0x00</span>
</span></span><span><span>          <span>Nombc</span><span>.</span><span>new</span><span>(</span><span>rom</span><span>)</span>
</span></span><span><span>        <span>when</span> <span>0x01</span><span>..</span><span>0x03</span>
</span></span><span><span>          <span>Mbc1</span><span>.</span><span>new</span><span>(</span><span>rom</span><span>,</span> <span>ram</span><span>)</span>
</span></span><span><span>        <span>when</span> <span>0x08</span><span>..</span><span>0x09</span>
</span></span><span><span>          <span>Nombc</span><span>.</span><span>new</span><span>(</span><span>rom</span><span>)</span>
</span></span><span><span>        <span>else</span>
</span></span><span><span>          <span>raise</span> <span>&#34;Unsupported cartridge type: </span><span>#{</span><span>rom</span><span>.</span><span>cartridge_type</span><span>}</span><span>&#34;</span>
</span></span><span><span>        <span>end</span>
</span></span><span><span>      <span>end</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h3 id="cpu-implementation">CPU Implementation</h3><p>I implemented a program that repeats the following CPU execution cycle:</p><ul><li>Fetch instruction from ROM</li><li>Decode the instruction</li><li>Execute the instruction</li></ul><p>To maintain motivation, instead of implementing all CPU and PPU processes at once, I first aimed to run the following minimal test ROM:</p><p><a href="https://github.com/dusterherz/gb-hello-world" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://github-readme-stats.vercel.app/api/pin/?username=dusterherz&amp;repo=gb-hello-world&amp;show_owner=true&amp;hide_border=true" alt="gb-hello-world by dusterherz"/></a></p><p>For debugging, I used a Game Boy emulator called <a href="https://bgb.bircd.org/">BGB</a>. It‚Äôs useful because you can execute step by step while displaying register and memory information, allowing you to compare the behavior with your own CPU.</p><p>I checked the required CPU instructions using BGB and implemented them. Then, implementing the PPU‚Äôs bg rendering process will make the test pass.</p><p><img src="https://storage.googleapis.com/zenn-user-upload/a05ad4a1c905-20240330.png" width="500"/></p><p>Next, I implemented all instructions and interrupt handling, aiming to pass two CPU test ROMs: <a href="https://github.com/retrio/gb-test-roms/tree/master/cpu_instrs/">cpu_instrs</a> and <a href="https://github.com/retrio/gb-test-roms/tree/master/instr_timing">instr_timing</a>.</p><h4 id="points-where-i-got-stuck">Points Where I Got Stuck</h4><ul><li>When setting the value of f in <code>pop af</code>, I hadn‚Äôt set the lower 4 bits to 0000<ul><li>The lower 4 bits of the f register are always 0000</li></ul></li><li>The c flag calculation was incorrect for two CPU instructions (opcode=0xe8, 0xf8): <code>ADD SP, e8</code> and <code>LD HL, SP + e8</code>.<ul><li>It passed with <code>cflag = (@sp &amp; 0xff) + (byte &amp; 0xff) &gt; 0xff</code></li></ul></li></ul><p>By fixing these, it successfully passed.</p><p><img src="https://storage.googleapis.com/zenn-user-upload/4c3b6b917e15-20240330.png" width="500"/></p><p>‚Ä¶The rendering looks a bit off, but the CPU processing is OK.</p><h3 id="ppu">PPU</h3><p>I aimed to implement the remaining rendering processes and pass <a href="https://github.com/mattcurrie/dmg-acid2">dmg-acid2</a>, which is a test ROM for PPU.</p><p>The test will pass by implementing window and sprite rendering, interrupt handling, and DMA transfer.
Care must be taken with the priority of sprite display.</p><p><img src="https://storage.googleapis.com/zenn-user-upload/92f2cf1d5e93-20240414.png" width="500"/></p><p>Now that rendering is possible, implementing the Joypad will make games playable.
The following is a video of running a game called <a href="https://tangramgames.dk/tobutobugirl/">Tobu Tobu Girl</a>:</p><blockquote data-align="center" data-media-max-width="560"><p lang="ja" dir="ltr">Tobu Tobu GirlÂãï„ÅÑ„ÅüÔºÅ</p>‚Äî sacckey (@sacckey) <a href="https://twitter.com/sacckey/status/1727284351371796791?ref_src=twsrc%5Etfw">November 22, 2023</a></blockquote><p>At this point, the game became operational! However, it‚Äôs extremely slow.
From here on, I worked on optimization.</p><h2 id="optimization">Optimization</h2><p>I‚Äôll introduce what I did to optimize Ruby Boy.
These techniques are not limited to emulator implementation and are likely applicable for improving the performance of Ruby programs in general.</p><p>Execution environment:</p><ul><li>PC: MacBook Pro (13-inch, 2018)</li><li>Processor: 2.3 GHz Quad-Core Intel Core i5</li><li>Memory: 16 GB 2133 MHz LPDDR3</li></ul><h3 id="benchmarking">Benchmarking</h3><p>I measured the time it took to execute the first 1500 frames of Tobu Tobu Girl without audio and rendering, repeating the measurement three times.
Since benchmarking will be done repeatedly, I recommend preparing a dedicated program and setting up a system where you can start benchmarking immediately with a command execution.</p><h3 id="profiler">Profiler</h3><p>I used the Stackprof gem.</p><p><a href="https://github.com/tmm1/stackprof" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://github-readme-stats.vercel.app/api/pin/?username=tmm1&amp;repo=stackprof&amp;show_owner=true&amp;hide_border=true" alt="stackprof by tmm1"/></a></p><p>It can be used simply by enclosing the area you want to measure in a block, and it‚Äôs recommended because it has low overhead.</p><h3 id="optimization-part-1">Optimization Part 1</h3><h4 id="enabling-yjit">Enabling YJIT</h4><p>By enabling YJIT, Ruby‚Äôs JIT compiler, the FPS improved.
YJIT has become practical from Ruby 3.2, and can be enabled by adding the <code>--yjit</code> option at runtime.</p><pre tabindex="0"><code>Ruby: 3.2.2
YJIT: false
1: 36.740829 sec
2: 36.468515 sec
3: 36.177083 sec
FPS: 41.1385591742566

Ruby: 3.2.2
YJIT: true
1: 32.305559 sec
2: 32.094778 sec
3: 31.889601 sec
FPS: 46.73385499531633
</code></pre><p>FPS: 41.1385591742566 ‚Üí 46.73385499531633</p><h4 id="avoid-creating-a-hash-for-sprites-every-time">Avoid Creating a Hash for Sprites Every Time</h4><p>According to Stackprof results, the render_sprites method is becoming a bottleneck.</p><pre tabindex="0"><code>==================================
  Mode: cpu(1000)
  Samples: 9081 (1.08% miss rate)
  GC: 4 (0.04%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      3727  (41.0%)        1920  (21.1%)     Rubyboy::Ppu#render_sprites
      1800  (19.8%)        1800  (19.8%)     Rubyboy::Operand#initialize
      1448  (15.9%)        1448  (15.9%)     Integer#zero?
      3346  (36.8%)        1296  (14.3%)     Enumerable#each_slice
       919  (10.1%)         919  (10.1%)     Integer#&lt;&lt;
       424   (4.7%)         424   (4.7%)     Integer#&lt;=&gt;
      3552  (39.1%)         294   (3.2%)     Array#each
...
</code></pre><p>Let‚Äôs investigate further to see which part within render_sprites is the bottleneck.</p><pre tabindex="0"><code>  code:
                                  |   220  |     def render_sprites
    3    (0.0%)                   |   221  |       return if @lcdc[LCDC[:sprite_enable]].zero?
                                  |   222  |
    2    (0.0%)                   |   223  |       sprite_height = @lcdc[LCDC[:sprite_size]].zero? ? 8 : 16
                                  |   224  |       sprites = []
                                  |   225  |       cnt = 0
 3346   (36.8%)                   |   226  |       @oam.each_slice(4).each do |sprite_attr|
                                  |   227  |         sprite = {
                                  |   228  |           y: (sprite_attr[0] - 16) % 256,
                                  |   229  |           x: (sprite_attr[1] - 8) % 256,
                                  |   230  |           tile_index: sprite_attr[2],
                                  |   231  |           flags: sprite_attr[3]
                                  |   232  |         }
                                  |   233  |         next if sprite[:y] &gt; @ly || sprite[:y] + sprite_height &lt;= @ly
                                  |   234  |
                                  |   235  |         sprites &lt;&lt; sprite
                                  |   236  |         cnt += 1
   15    (0.2%) /    15   (0.2%)  |   237  |         break if cnt == 10
 1887   (20.8%) /  1887  (20.8%)  |   238  |       end
  386    (4.3%) /    12   (0.1%)  |   239  |       sprites = sprites.sort_by.with_index { |sprite, i| [-sprite[:x], -i] }
                                  |   240  |
...
</code></pre><p>Line 226‚Äôs block occupies a high percentage of execution time. Upon closer inspection, it creates a Hash called sprite, and then adds sprite to an array called sprites if it meets certain conditions.
By modifying this to create sprite only when the conditions are met, the speed improved.</p><p>FPS: 46.73385499531633 ‚Üí 49.2233733053377</p><p>In this way, I steadily continued to identify and fix bottlenecks.</p><h4 id="calculate-tile_map_addr-outside-the-loop">Calculate tile_map_addr outside the loop</h4><p><a href="https://github.com/sacckey/rubyboy/commit/08273596838631334ee83fbd540feab5da09233e">commit</a></p><p>FPS: 49.2233733053377 ‚Üí 56.6580741129914</p><h4 id="calculate-tile_index-outside-the-loop">Calculate tile_index outside the loop</h4><p><a href="https://github.com/sacckey/rubyboy/commit/3e79628cf69f15bc690049f1695e3767ae48e8a9">commit</a></p><p>FPS: 56.6580741129914 ‚Üí 60.44140113483162</p><p>These are based on the basic principle ‚Äúdo outside the loop what can be done outside the loop‚Äù, but it‚Äôs critically important for emulators. Resolving these issues dramatically improved performance.</p><h4 id="ruby-v32---v33">Ruby v3.2 -&gt; v3.3</h4><p>At this point, Ruby Boy achieved about 60 FPS without rendering, but hit a wall.
There‚Äôs a trade-off between optimization and code readability. For example, abandoning the use of constants and directly writing mysterious integers would make it faster, but that‚Äôs not desirable.</p><p>While pondering this, Ruby 3.3.0 was released on 2023/12/25.
Ruby 3.3‚Äôs YJIT was <a href="https://k0kubun.hatenablog.com/entry/ruby-3-3-yjit">reported to be even faster</a>, so I tried updating‚Ä¶</p><p><img loading="lazy" src="https://storage.googleapis.com/zenn-user-upload/0809e3724053-20240330.png" alt=""/></p><p>!?</p><p>It got incredibly fast!!!!
Ruby 3.3 was faster than I imagined. Thank you so much üôè
By the way, this <a href="https://twitter.com/sacckey/status/1740342734857306595">comparison post</a> was even reposted by Matz. I‚Äôm thrilled.</p><h3 id="reducing-gc">Reducing GC</h3><p>Thanks to Ruby 3.3, performance improved significantly, but in exchange? GC occurrences increased dramatically.</p><pre tabindex="0"><code>rubyboy % stackprof stackprof-cpu-myapp.dump
==================================
  Mode: cpu(1000)
  Samples: 16405 (4.57% miss rate)
  GC: 5593 (34.09%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      3688  (22.5%)        3688  (22.5%)     (sweeping)
      2332  (14.2%)        2109  (12.9%)     Enumerable#flat_map
      2050  (12.5%)        2050  (12.5%)     Integer#&lt;=&gt;
      5593  (34.1%)        1679  (10.2%)     (garbage collection)
      1038   (6.3%)        1038   (6.3%)     Rubyboy::Ppu#to_signed_byte
      1004   (6.1%)        1004   (6.1%)     Rubyboy::SDL.RenderClear
       646   (3.9%)         646   (3.9%)     Rubyboy::Ppu#get_pixel
       437   (2.7%)         437   (2.7%)     Integer#&gt;&gt;
       701   (4.3%)         332   (2.0%)     Rubyboy::Ppu#render_sprites
      1354   (8.3%)         278   (1.7%)     Rubyboy::Lcd#draw
      3825  (23.3%)         257   (1.6%)     Rubyboy::Ppu#step
      1627   (9.9%)         255   (1.6%)     Rubyboy::Ppu#render_bg
       633   (3.9%)         247   (1.5%)     Enumerable#each_slice
       230   (1.4%)         230   (1.4%)     Rubyboy::Registers#read8
       226   (1.4%)         226   (1.4%)     (marking)
...
</code></pre><p>Also, in Pokemon Red, the performance from the title screen to the professor‚Äôs dialogue scene was still heavy, so resolving these issues became the next goal.</p><h4 id="gc-profiler">GC Profiler</h4><p>I used HeapProfiler to detect GC occurrence locations.</p><p><a href="https://github.com/Shopify/heap-profiler" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://github-readme-stats.vercel.app/api/pin/?username=Shopify&amp;repo=heap-profiler&amp;show_owner=true&amp;hide_border=true" alt="heap-profiler by Shopify"/></a></p><p>This can also be easily used by enclosing the area you want to detect in a block, but be careful as it may stop returning detection results when running for a long time.</p><p>Execution results (partial)</p><pre tabindex="0"><code>rubyboy % heap-profiler tmp/report
Total allocated: 563.01 MB (4198804 objects)
Total retained: 10.13 kB (252 objects)

allocated memory by file
-----------------------------------
 454.17 MB  rubyboy/lib/rubyboy/cpu.rb
  93.18 MB  rubyboy/lib/rubyboy/ppu.rb
  10.06 MB  rubyboy/lib/rubyboy/apu.rb

allocated memory by class
-----------------------------------
 462.20 MB  Hash
  49.79 MB  Array
  14.61 MB  Enumerator

allocated objects by file
-----------------------------------
   2839605  rubyboy/lib/rubyboy/cpu.rb
   1105342  rubyboy/lib/rubyboy/ppu.rb
    251462  rubyboy/lib/rubyboy/apu.rb

allocated objects by class
-----------------------------------
   2888757  Hash
    416967  Array
    273888  &lt;memo&gt; (IMEMO)
    273888  &lt;ifunc&gt; (IMEMO)
    251442  Float

retained memory by file
-----------------------------------
   3.92 kB  rubyboy/lib/rubyboy/cpu.rb
   2.20 kB  rubyboy/lib/rubyboy/ppu.rb

retained objects by file
-----------------------------------
        98  rubyboy/lib/rubyboy/cpu.rb
        54  rubyboy/lib/rubyboy/ppu.rb
        24  rubyboy/lib/rubyboy.rb
        18  rubyboy/lib/rubyboy/lcd.rb
        18  rubyboy/lib/rubyboy/apu.rb
</code></pre><p>Looking at this, it is clear that creating a large number of Hashes within the Cpu class is the cause of GC occurrences.</p><h4 id="change-instruction-arguments-from-hash-to-symbol">Change instruction arguments from Hash to Symbol</h4><p><a href="https://github.com/sacckey/rubyboy/commit/7cc25746dffcc91e9f6ad4162ec279e8547b9fe0">commit</a></p><div><pre tabindex="0"><code data-lang="diff"><span><span>case opcode
</span></span><span><span><span>-  when 0x01 then ld16({ type: :register16, value: :bc }, { type: :immediate16 }, cycles: 12)
</span></span></span><span><span><span></span><span>+  when 0x01 then ld16(:bc, :immediate16, cycles: 12)
</span></span></span></code></pre></div><h4 id="avoid-creating-hash-when-referencing-flags">Avoid creating Hash when referencing flags</h4><p><a href="https://github.com/sacckey/rubyboy/commit/947617508e726716b3905d41df1f4a4c1b5793c8">commit</a></p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>- def flags
</span></span></span><span><span><span>-   f_value = @registers.f
</span></span></span><span><span><span>-   {
</span></span></span><span><span><span>-     z: f_value[7] == 1,
</span></span></span><span><span><span>-     n: f_value[6] == 1,
</span></span></span><span><span><span>-     h: f_value[5] == 1,
</span></span></span><span><span><span>-     c: f_value[4] == 1
</span></span></span><span><span><span>-   }
</span></span></span><span><span><span>- end
</span></span></span><span><span><span></span>
</span></span><span><span><span>+ def flag_z
</span></span></span><span><span><span>+   @registers.f[7] == 1
</span></span></span><span><span><span>+ end
</span></span></span><span><span><span></span>
</span></span><span><span><span>+ def flag_n
</span></span></span><span><span><span>+   @registers.f[6] == 1
</span></span></span><span><span><span>+ end
</span></span></span><span><span><span></span>
</span></span><span><span><span>+ def flag_h
</span></span></span><span><span><span>+   @registers.f[5] == 1
</span></span></span><span><span><span>+ end
</span></span></span><span><span><span></span>
</span></span><span><span><span>+ def flag_c
</span></span></span><span><span><span>+   @registers.f[4] == 1
</span></span></span><span><span><span>+ end
</span></span></span></code></pre></div><p>With these modifications, GC occurrences were reduced to 2.71%.</p><h3 id="optimization-part-2">Optimization Part 2</h3><h4 id="reducing-integer">Reducing Integer#&lt;=&gt;</h4><p>At this point, the benchmark and Stackprof results are as follows:
It‚Äôs important to note that this result was measured with rendering enabled and at the heaviest part of Pokemon Red, so comparison with previous results is not meaningful.</p><pre tabindex="0"><code>Ruby: 3.3.0
YJIT: true
1: 26.798767 sec
FPS: 55.97272441676141
</code></pre><pre tabindex="0"><code>==================================
  Mode: cpu(1000)
  Samples: 10430 (5.57% miss rate)
  GC: 283 (2.71%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      2275  (21.8%)        2275  (21.8%)     Integer#&lt;=&gt;
      1267  (12.1%)        1267  (12.1%)     Rubyboy::SDL.RenderClear
      1186  (11.4%)        1186  (11.4%)     Rubyboy::Ppu#to_signed_byte
      2366  (22.7%)         864   (8.3%)     Rubyboy::Ppu#render_bg
       784   (7.5%)         784   (7.5%)     Rubyboy::Ppu#get_pixel
      1773  (17.0%)         641   (6.1%)     Rubyboy::Ppu#render_window
       992   (9.5%)         415   (4.0%)     Rubyboy::Ppu#render_sprites
       334   (3.2%)         334   (3.2%)     Integer#&gt;&gt;
       852   (8.2%)         319   (3.1%)     Enumerable#each_slice
      5453  (52.3%)         311   (3.0%)     Rubyboy::Ppu#step
      4199  (40.3%)         213   (2.0%)     Integer#times
       188   (1.8%)         188   (1.8%)     Rubyboy::Timer#step
       187   (1.8%)         187   (1.8%)     (sweeping)
       142   (1.4%)         142   (1.4%)     Rubyboy::SDL.UpdateTexture
       129   (1.2%)         129   (1.2%)     Array#size
       426   (4.1%)         114   (1.1%)     Rubyboy::Ppu#get_color
       851   (8.2%)         109   (1.0%)     Array#each
       981   (9.4%)         105   (1.0%)     Rubyboy::Cpu#get_value
       283   (2.7%)          85   (0.8%)     (garbage collection)
...
</code></pre><p>While GC has been reduced, performance is still below 60 FPS, and <code>Integer#&lt;=&gt;</code> (number comparison) appears to be the bottleneck.
Number comparisons occur frequently in address-based branching like the following:</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>read_byte</span><span>(</span><span>addr</span><span>)</span>
</span></span><span><span>  <span>case</span> <span>addr</span>
</span></span><span><span>  <span>when</span> <span>0x0000</span><span>..</span><span>0x7fff</span>
</span></span><span><span>    <span>@mbc</span><span>.</span><span>read_byte</span><span>(</span><span>addr</span><span>)</span>
</span></span><span><span>  <span>when</span> <span>0x8000</span><span>..</span><span>0x9fff</span>
</span></span><span><span>    <span>@ppu</span><span>.</span><span>read_byte</span><span>(</span><span>addr</span><span>)</span>
</span></span><span><span><span>...</span>
</span></span></code></pre></div><p>To eliminate these comparisons, I created an array called <code>@read_methods</code> in preprocessing, which contains the correspondence between addresses and processes. This allows for calling with just array reference during execution.</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>def</span> <span>set_methods</span>
</span></span><span><span>  <span>0x10000</span><span>.</span><span>times</span> <span>do</span> <span>|</span><span>addr</span><span>|</span>
</span></span><span><span>    <span>case</span> <span>addr</span>
</span></span><span><span>    <span>when</span> <span>0x0000</span><span>..</span><span>0x7fff</span>
</span></span><span><span>      <span>@read_methods</span><span>[</span><span>addr</span><span>]</span> <span>=</span> <span>-&gt;</span> <span>{</span> <span>@mbc</span><span>.</span><span>read_byte</span><span>(</span><span>addr</span><span>)</span> <span>}</span>
</span></span><span><span>    <span>when</span> <span>0x8000</span><span>..</span><span>0x9fff</span>
</span></span><span><span>      <span>@read_methods</span><span>[</span><span>addr</span><span>]</span> <span>=</span> <span>-&gt;</span> <span>{</span> <span>@ppu</span><span>.</span><span>read_byte</span><span>(</span><span>addr</span><span>)</span> <span>}</span>
</span></span><span><span><span>...</span>
</span></span></code></pre></div><p>This technique was inspired by <a href="https://github.com/mame/optcarrot">Optcarrot</a>, a NES emulator written in Ruby.</p><p>Let‚Äôs run the benchmark and Stackprof again.</p><pre tabindex="0"><code>rubyboy % RUBYOPT=--yjit bundle exec rubyboy bench
Ruby: 3.3.0
YJIT: true
1: 21.75409 sec
FPS: 68.95255099156066
</code></pre><pre tabindex="0"><code>rubyboy % bundle exec stackprof stackprof-cpu-myapp.dump
==================================
  Mode: cpu(1000)
  Samples: 9505 (6.87% miss rate)
  GC: 325 (3.42%)
==================================
     TOTAL    (pct)     SAMPLES    (pct)     FRAME
      1238  (13.0%)        1238  (13.0%)     Rubyboy::Ppu#to_signed_byte
      1208  (12.7%)        1208  (12.7%)     Rubyboy::SDL.RenderClear
      2558  (26.9%)         907   (9.5%)     Rubyboy::Ppu#render_bg
       865   (9.1%)         865   (9.1%)     Rubyboy::Ppu#get_pixel
       849   (8.9%)         849   (8.9%)     Rubyboy::Cartridge::Mbc1#set_methods
      1803  (19.0%)         663   (7.0%)     Rubyboy::Ppu#render_window
      1053  (11.1%)         460   (4.8%)     Rubyboy::Ppu#render_sprites
      5782  (60.8%)         346   (3.6%)     Rubyboy::Ppu#step
       906   (9.5%)         343   (3.6%)     Enumerable#each_slice
       313   (3.3%)         313   (3.3%)     Integer#&gt;&gt;
      4412  (46.4%)         245   (2.6%)     Integer#times
       237   (2.5%)         237   (2.5%)     (sweeping)
       197   (2.1%)         197   (2.1%)     Rubyboy::Timer#step
       193   (2.0%)         193   (2.0%)     Rubyboy::SDL.UpdateTexture
      1141  (12.0%)         162   (1.7%)     Rubyboy::Bus#set_methods
       433   (4.6%)         134   (1.4%)     Rubyboy::Ppu#get_color
       114   (1.2%)         114   (1.2%)     Array#size
       478   (5.0%)         109   (1.1%)     Rubyboy::Cpu#get_value
       918   (9.7%)          99   (1.0%)     Array#each
        75   (0.8%)          75   (0.8%)     Rubyboy::Cpu#increment_pc_by_byte
      9180  (96.6%)          68   (0.7%)     Rubyboy::Console#bench
       325   (3.4%)          65   (0.7%)     (garbage collection)
        49   (0.5%)          49   (0.5%)     Integer#&lt;=&gt;
...
</code></pre><p>The FPS improved from 55.97272441676141 to 68.95255099156066, and the proportion of <code>Integer#&lt;=&gt;</code> was reduced from 21.8% to 0.5%.
There‚Äôs still room for further optimization, but having achieved the goal, I‚Äôm considering this complete for now.</p><h3 id="optimization-results">Optimization Results</h3><table><thead><tr><th>Before(rubyboy v1.0.0, Ruby 3.2.2)</th><th>After(rubyboy v1.3.1, Ruby 3.3.0 + YJIT)</th></tr></thead><tbody><tr><td><img loading="lazy" src="https://storage.googleapis.com/zenn-user-upload/b29a44007817-20240416.gif" alt=""/></td><td><img loading="lazy" src="https://storage.googleapis.com/zenn-user-upload/6dff7cf43943-20240416.gif" alt=""/></td></tr></tbody></table><h3 id="optimization-part-3">Optimization Part 3</h3><p>I had considered the optimization complete, but when I tried it in the browser with ruby.wasm, it turned out to be slow, so I decided to optimize further.</p><p>For benchmarking, I used the same method as in Part 1: measuring the time to execute the first 1500 frames of Tobu Tobu Girl three times, without audio and rendering. Here are the current benchmark results:</p><pre tabindex="0"><code>rubyboy % RUBYOPT=--yjit bundle exec rubyboy-bench
Ruby: 3.3.0
YJIT: true
1: 11.963271 sec
2: 11.610802 sec
3: 11.64308 sec
FPS: 127.77864241325811
</code></pre><p>In the current implementation, frame data is generated pixel by pixel during rendering. This causes significant overhead.
To address this, I modified the implementation to generate frame data when VRAM is updated and cache it. During rendering, it just needs to reference the cached data.</p><p>I also focused on other performance bottlenecks: optimizing the render_bg method and changing the pixel format of the frame data.</p><p>These optimizations achieved more than a 2x speedup!
Here are the optimizations and FPS changes (details omitted):</p><ul><li>Cache tile data (<a href="https://github.com/sacckey/rubyboy/commit/6eb4f77fd1cf23ade795da92a2eac0857a0f31fc">commit</a>) ‚Üí 133FPS</li><li>Cache tile_map data (<a href="https://github.com/sacckey/rubyboy/commit/99a24a0706e83d785f65b39aebbe85932ebe56a5">commit</a>) ‚Üí 151FPS</li><li>Cache palette data (<a href="https://github.com/sacckey/rubyboy/commit/2eea5261743c8846364ddb1651b45495863c9298">commit</a>) ‚Üí 159FPS</li><li>Cache sprite data (<a href="https://github.com/sacckey/rubyboy/commit/eb1a23efbafe1e2bc53bd573a3270dff55838dc9">commit</a>) ‚Üí 185FPS</li><li>Change pixel format from RGB24 to ABGR8888 (<a href="https://github.com/sacckey/rubyboy/commit/d898688845c09e3ce7f6ae1ed1f303d8d8e8ef24">commit</a>) ‚Üí 219FPS</li><li>Optimize render_bg with tile-based processing (<a href="https://github.com/sacckey/rubyboy/commit/50e7ccdd15d1043ef021cbda597a0edf305e5b92">commit</a>) ‚Üí 263FPS</li><li>Use reverse and sort for sprite ordering (<a href="https://github.com/sacckey/rubyboy/commit/731794d73e81a0312c14865dea4de6f5cf210ac2">commit</a>) ‚Üí 274FPS</li></ul><h4 id="results">Results</h4><p>FPS: 127.77864241325811 ‚Üí 274.6885154318787</p><h2 id="works-in-browser-with-rubywasm">Works in browser with ruby.wasm</h2><p>I made Ruby Boy run in the browser using WebAssembly!</p><p><strong><a href="https://sacckey.github.io/rubyboy/">Try the demo in your browser!</a></strong></p><p><img src="https://storage.googleapis.com/zenn-user-upload/04b2e5fb8827-20250115.png" width="500"/></p><p>In this chapter, I explain how Ruby Boy runs in the browser. It should also be helpful for people who want to run Ruby programs in the browser.</p><h3 id="system-overview">System Overview</h3><p>I referenced the implementation of <a href="https://github.com/kateinoigakukun/optcarrot.wasm">optcarrot.wasm</a>, which runs <a href="https://github.com/mame/optcarrot">Optcarrot</a> (a NES emulator written in Ruby) using Wasm.</p><pre tabindex="0"><code>+----------------+       DOM Events           +----------------+
|   index.html   |     (Keyboard &amp; ROM)       |    index.js    |
|   (Browser)    |---------------------------&gt;| (Main Thread)  |
|                |&lt;---------------------------|                |
|                |   Frame Data (ImageData)   |                |
+----------------+                            +----------------+
                                                     |  ^
                                                     |  |
                                            Keyboard |  |  Frame Data
                                              States |  |  (ArrayBuffer)
                                                     v  |
+----------------+                            +----------------+
|  rubyboy.wasm  |      Keyboard States       |   worker.js    |
| (GB Emulator)  |&lt;---------------------------| (Game Thread)  |
|                |---------------------------&gt;|                |
|                |  Frame Data (Uint8Array)   |                |
+----------------+                            +----------------+
</code></pre><ul><li>index.js: Main thread. Sends keyboard input and ROM file input to the Worker, and updates canvas with frame data received from the Worker.</li><li>worker.js: Worker thread. Processes input events from the main thread, runs Ruby Boy and sends frame data to the main thread.</li><li>rubyboy.wasm: Ruby Boy packaged as Wasm. Emulates the Game Boy and generates frame data.</li></ul><h3 id="converting-ruby-boy-to-wasm">Converting Ruby Boy to Wasm</h3><p>Converting a Ruby Program to a Wasm package consists of two steps:</p><ol><li>Build CRuby to Wasm to create ruby.wasm. (Dependent gems are installed during the build process.)</li><li>Pack Ruby Program into ruby.wasm to create a program-specific wasm.</li></ol><p>The following diagram illustrates these steps:</p><pre tabindex="0"><code>+--------------+
|    gems      |   build
|     +        | ---------&gt;&gt; ruby.wasm ‚îÄ‚îê
|    CRuby     |                         |
+--------------+                         |   pack
                                         + --------&gt;&gt; ruby_with_program.wasm
+--------------+                         |
| Ruby Program | -----------------------‚îò
+--------------+
</code></pre><p>These build and pack operations are performed using the ruby_wasm gem.</p><p>The ruby_wasm gem, js gem (mentioned later), npm packages, and pre-built binaries are available in the following repository:</p><p><a href="https://github.com/ruby/ruby.wasm" target="_blank" rel="noopener noreferrer"><img loading="lazy" src="https://github-readme-stats.vercel.app/api/pin/?username=ruby&amp;repo=ruby.wasm&amp;show_owner=true&amp;hide_border=true" alt="ruby.wasm by ruby"/></a></p><h4 id="building">Building</h4><p>Using the ruby_wasm gem to create a wasm file that includes dependent gems.
For browser execution, the js gem is also required and should be installed alongside.</p><pre tabindex="0"><code>$ bundle add ruby_wasm js
$ bundle exec rbwasm build --ruby-version 3.3 -o ruby-js.wasm
</code></pre><h5 id="tips-building-only-required-gems">Tips: Building only required gems</h5><p>When running <code>rbwasm build</code>, all dependent gems in <code>Gemfile.lock</code> are built.
To exclude unnecessary gems like rspec or rubocop from the build, specify them in <code>RubyWasm::Packager::EXCLUDED_GEMS</code> and execute the command directly.</p><p>For Ruby Boy, only the js gem is needed, so adding all other gems to <code>EXCLUDED_GEMS</code> as follows:</p><div><pre tabindex="0"><code data-lang="ruby"><span><span><span>require</span> <span>&#39;bundler/setup&#39;</span>
</span></span><span><span><span>require</span> <span>&#39;ruby_wasm&#39;</span>
</span></span><span><span><span>require</span> <span>&#39;ruby_wasm/cli&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Exclude all gems except the &#39;js&#39; gem for packaging</span>
</span></span><span><span><span>definition</span> <span>=</span> <span>Bundler</span><span>.</span><span>definition</span>
</span></span><span><span><span>excluded_gems</span> <span>=</span> <span>definition</span><span>.</span><span>resolve</span><span>.</span><span>materialize</span><span>(</span><span>definition</span><span>.</span><span>requested_dependencies</span><span>)</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:name</span><span>)</span>
</span></span><span><span><span>excluded_gems</span> <span>-=</span> <span>%w[js]</span>
</span></span><span><span><span>RubyWasm</span><span>::</span><span>Packager</span><span>::</span><span>EXCLUDED_GEMS</span><span>.</span><span>concat</span><span>(</span><span>excluded_gems</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>command</span> <span>=</span> <span>%w[build --ruby-version 3.3 -o ./docs/ruby-js.wasm]</span>
</span></span><span><span><span>RubyWasm</span><span>::</span><span>CLI</span><span>.</span><span>new</span><span>(</span><span>stdout</span><span>:</span> <span>$stdout</span><span>,</span> <span>stderr</span><span>:</span> <span>$stderr</span><span>)</span><span>.</span><span>run</span><span>(</span><span>command</span><span>)</span>
</span></span></code></pre></div><p>Reference: <a href="https://speakerdeck.com/lnit/matrk11-ruby-wasm-msw?slide=73">https://speakerdeck.com/lnit/matrk11-ruby-wasm-msw?slide=73</a></p><h4 id="packing">Packing</h4><p>Pack the Ruby Boy code into the previously created ruby-js.wasm.</p><pre tabindex="0"><code># Pack Ruby Boy code located in ./lib
$ bundle exec rbwasm pack ruby-js.wasm --dir ./lib::/lib -o rubyboy.wasm
</code></pre><p>Now that rubyboy.wasm is complete, let‚Äôs run it in the browser.</p><h3 id="running-in-browser">Running in Browser</h3><p>System Architecture (revisited)</p><pre tabindex="0"><code>+----------------+       DOM Events           +----------------+
|   index.html   |     (Keyboard &amp; ROM)       |    index.js    |
|   (Browser)    |---------------------------&gt;| (Main Thread)  |
|                |&lt;---------------------------|                |
|                |   Frame Data (ImageData)   |                |
+----------------+                            +----------------+
                                                     |  ^
                                                     |  |
                                            Keyboard |  |  Frame Data
                                              States |  |  (ArrayBuffer)
                                                     v  |
+----------------+                            +----------------+
|  rubyboy.wasm  |      Keyboard States       |   worker.js    |
| (GB Emulator)  |&lt;---------------------------| (Game Thread)  |
|                |---------------------------&gt;|                |
|                |  Frame Data (Uint8Array)   |                |
+----------------+                            +----------------+
</code></pre><p>Next, I‚Äôll explain the processing details of worker.js and rubyboy.wasm in the lower part.</p><h4 id="vm-initialization">VM Initialization</h4><div><pre tabindex="0"><code data-lang="js:worker.js"><span><span><span>// worker.js
</span></span></span><span><span><span></span><span>import</span> <span>{</span> <span>DefaultRubyVM</span> <span>}</span> <span>from</span> <span>&#39;https://cdn.jsdelivr.net/npm/@ruby/<a href="https://sacckey.dev/cdn-cgi/l/email-protection" data-cfemail="483f293b25653f293b21087a667f6678">[email¬†protected]</a>/dist/browser/+esm&#39;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>const</span> <span>response</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#39;./rubyboy.wasm&#39;</span><span>);</span>
</span></span><span><span><span>const</span> <span>module</span> <span>=</span> <span>await</span> <span>WebAssembly</span><span>.</span><span>compileStreaming</span><span>(</span><span>response</span><span>);</span>
</span></span><span><span><span>const</span> <span>{</span> <span>vm</span><span>,</span> <span>wasi</span> <span>}</span> <span>=</span> <span>await</span> <span>DefaultRubyVM</span><span>(</span><span>module</span><span>);</span>
</span></span><span><span><span>vm</span><span>.</span><span>eval</span><span>(</span><span>`
</span></span></span><span><span><span>  require &#39;js&#39;
</span></span></span><span><span><span>  require_relative &#39;lib/executor&#39;
</span></span></span><span><span><span>
</span></span></span><span><span><span>  $executor = Executor.new
</span></span></span><span><span><span>`</span><span>);</span>
</span></span><span><span>
</span></span><span><span><span>this</span><span>.</span><span>vm</span> <span>=</span> <span>vm</span><span>;</span>
</span></span><span><span><span>this</span><span>.</span><span>rootDir</span> <span>=</span> <span>wasi</span><span>.</span><span>fds</span><span>[</span><span>3</span><span>].</span><span>dir</span><span>;</span>
</span></span></code></pre></div><p>Inside the Worker, creating a VM by passing rubyboy.wasm to the DefaultRubyVM method. Ruby Boy code runs on this VM.</p><p><code>wasi.fds[3].dir</code> is a Map that represents the root directory <a href="https://github.com/ruby/ruby.wasm/blob/main/packages/npm-packages/ruby-wasm-wasi/src/browser.ts#L25">preopened</a> by DefaultRubyVM.
Sending ROM data to the VM and receiving frame data from the VM through this Map.</p><h4 id="drawing-the-game-screen">Drawing the Game Screen</h4><div><pre tabindex="0"><code data-lang="js:worker.js"><span><span><span>// worker.js
</span></span></span><span><span><span></span><span>sendPixelData</span><span>()</span> <span>{</span>
</span></span><span><span>  <span>this</span><span>.</span><span>vm</span><span>.</span><span>eval</span><span>(</span><span>`$executor.exec(</span><span>${</span><span>this</span><span>.</span><span>directionKey</span><span>}</span><span>, </span><span>${</span><span>this</span><span>.</span><span>actionKey</span><span>}</span><span>)`</span><span>);</span>
</span></span><span><span>  <span>const</span> <span>file</span> <span>=</span> <span>this</span><span>.</span><span>rootDir</span><span>.</span><span>contents</span><span>.</span><span>get</span><span>(</span><span>&#39;video.data&#39;</span><span>);</span>
</span></span><span><span>  <span>const</span> <span>bytes</span> <span>=</span> <span>file</span><span>.</span><span>data</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>postMessage</span><span>({</span> <span>type</span><span>:</span> <span>&#39;pixelData&#39;</span><span>,</span> <span>data</span><span>:</span> <span>bytes</span><span>.</span><span>buffer</span> <span>},</span> <span>[</span><span>bytes</span><span>.</span><span>buffer</span><span>]);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The Worker executes Ruby Boy‚Äôs <code>Executor#exec</code> on the VM, reads the frame data written to /video.data, and posts it to index.js. index.js updates the canvas with the received frame data.
Repeating this process draws the game screen.</p><p>The implementation of Ruby Boy‚Äôs <code>Executor#exec</code> is below:</p><div><pre tabindex="0"><code data-lang="ruby:executor.rb"><span><span><span># executor.rb</span>
</span></span><span><span><span>def</span> <span>exec</span><span>(</span><span>direction_key</span> <span>=</span> <span>0b1111</span><span>,</span> <span>action_key</span> <span>=</span> <span>0b1111</span><span>)</span>
</span></span><span><span>  <span>bin</span> <span>=</span> <span>@emulator</span><span>.</span><span>step</span><span>(</span><span>direction_key</span><span>,</span> <span>action_key</span><span>)</span><span>.</span><span>pack</span><span>(</span><span>&#39;V*&#39;</span><span>)</span>
</span></span><span><span>  <span>File</span><span>.</span><span>binwrite</span><span>(</span><span>&#39;/video.data&#39;</span><span>,</span> <span>bin</span><span>)</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p>The exec method receives current button inputs (direction keys, A, B, Start, Select), emulates the Game Boy, and writes frame data to /video.data.</p><p>In Ruby Boy, frame data is managed as a Uint32 array in ABGR format like <code>[0xff555555]</code>, converting this using <code>.pack(&#39;V*&#39;)</code> to a Uint8 array in RGBA format like <code>[0x55, 0x55, 0x55, 0xff]</code> for canvas use.</p><h2 id="conclusion">Conclusion</h2><h3 id="positive-aspects">Positive Aspects</h3><h4 id="emulator-development-is-fun">Emulator Development is Fun</h4><p>As initially planned, I was able to implement while having fun. While it‚Äôs enjoyable when an emulator runs, I think a major factor is the abundance of documentation and test ROMs. Especially, since the test ROMs provide feedback on incorrect parts, I was able to progress without getting stuck and could refactor easily.
Also, I‚Äôm happy that I could run the cartridges that were lying dormant at my parents‚Äô home.</p><h4 id="published-a-ruby-gem">Published a Ruby Gem</h4><p>Having used Ruby for a while, I‚Äôm happy to finally publish a working gem.
<a href="https://rubygems.org/gems/rubyboy">https://rubygems.org/gems/rubyboy</a></p><p>Install it now with <code>gem install rubyboy</code>!</p><h4 id="learned-about-low-level-technology">Learned About Low-Level Technology</h4><p>Through implementing programs that mimic CPU, memory, registers, RAM, etc., I was able to deepen my knowledge about their roles and operations. It was enjoyable to see things I knew theoretically actually come up, leading to ‚Äúso that‚Äôs what it meant‚Äù discoveries. How about using this for experimental subjects in universities or technical colleges?</p><h4 id="gained-experience-in-program-optimization">Gained Experience in Program Optimization</h4><p>I experienced the steady process of ‚Äúcreating a benchmark program, running a profiler, and fixing suspicious areas‚Äù for optimization. I believe my resolution for optimization has improved and my sense for detecting bottlenecks has sharpened.</p><h4 id="experienced-designing-and-implementing-a-larger-program">Experienced Designing and Implementing a Larger Program</h4><p>I hadn‚Äôt written many large programs outside of web programming, so it was good to gain that experience. With emulators, I felt it was important to appropriately distribute responsibilities among classes and write generalized programs to increase reusability (especially for the CPU).</p><h3 id="impressions-of-ruby">Impressions of Ruby</h3><ul><li>Happy with the simple syntax!</li><li>Delighted by the many thoughtful methods!</li><li>Pleased with the abundance of useful gems!</li><li>Frustrated by the slow processing speed!<ul><li>Glad that it‚Äôs significantly faster than before thanks to YJIT‚Äôs evolution!</li></ul></li></ul><h3 id="future-plans">Future Plans</h3><p>I‚Äôm planning to work on the following:</p><ul><li>Fixing rendering bugs</li><li>Adding more MBC types</li><li><del>WebAssembly support</del></li><li>Improving the benchmark system<ul><li>Want to make it usable as a benchmark program for Ruby</li></ul></li></ul><h2 id="references">References</h2><h3 id="self-made-blog-posts">Self-Made Blog Posts</h3><p>These are articles about creating Game Boy emulators. I referred to them for implementation approaches, techniques, and potential pitfalls üôè</p><ul><li><a href="https://linoscope.github.io/writing-a-game-boy-emulator-in-ocaml/">Writing a Game Boy Emulator in OCaml - The Linoscope Machine</a></li><li><a href="https://voidproc.com/blog/archives/664">C++„Åß„Ç≤„Éº„É†„Éú„Éº„Ç§„Ç®„Éü„É•„É¨„Éº„Çø„ÇíËá™‰Ωú„Åó„Å¶„ÅÑ„Åæ„Åô | voidProc | „Ç≤„Éº„É†Ë£Ω‰Ωú„É≠„Ç∞</a></li><li><a href="https://mjhd.hatenablog.com/entry/2021/04/14/221813">Rust„Åß„Ç≤„Éº„É†„Éú„Éº„Ç§„Ç®„Éü„É•„É¨„Éº„Çø„ÇíËá™‰Ωú„Åó„ÅüË©± - MJHD</a></li><li><a href="https://keichi.dev/post/write-yourself-a-game-boy-emulator/">„Ç≤„Éº„É†„Éú„Éº„Ç§„ÅÆ„Ç®„Éü„É•„É¨„Éº„Çø„ÇíËá™‰Ωú„Åó„ÅüË©± ¬∑ Keichi Takahashi</a></li><li><a href="https://hackmd.io/@anqou/HJcvRrwy9">AQBoy: Yet Another Game Boy Emulator ÈñãÁô∫Ë®ò - HackMD</a></li></ul><h3 id="presentation-slides">Presentation Slides</h3><ul><li><a href="https://www.slideshare.net/mametter/ruby-65182128">Ruby „ÅßÈ´òÈÄü„Å™„Éó„É≠„Ç∞„É©„É†„ÇíÊõ∏„Åè | PPT</a><ul><li>Presentation slides by the creator of <a href="https://github.com/mame/optcarrot">Optcarrot</a>. These slides are packed with essential information about optimizing Ruby programs. I was able to achieve the optimization of Ruby Boy by referring to these slides.</li></ul></li></ul><h3 id="documentation">Documentation</h3><ul><li><a href="https://gbdev.io/pandocs/">Pan Docs</a><ul><li>A page that covers Game Boy specifications comprehensively, used like a dictionary.</li></ul></li><li><a href="https://gbdev.io/gb-opcodes/optables/">Game Boy CPU (SM83) instruction set</a><ul><li>CPU specification table. It displays a list of each instruction‚Äôs content, opcode, cycle count, and updated flags, and also provides JSON. I implemented CPU instructions while referring to this.</li></ul></li><li><a href="https://techbookfest.org/product/sBn8hcABDYBMeZxGvpWapf?productVariantID=2q95kwuw4iuRAkJea4BnKT">Rust„Åß‰Ωú„ÇãGAME BOY„Ç®„Éü„É•„É¨„Éº„ÇøÔºö‰Ωé„É¨„Ç§„É§ÊäÄË°ìÈÉ®</a><ul><li>A book about implementing a Game Boy emulator in Rust. It sets goals for each chapter, allowing for step-by-step progress. The explanations for each chapter are quite detailed, and it‚Äôs recommended even if you‚Äôre implementing in a language other than Rust. It was especially helpful for implementing PPU and APU.</li></ul></li></ul><h3 id="rubywasm">ruby.wasm</h3><p>I referenced the following articles and implementations for WebAssembly support:</p><ul><li><a href="https://evilmartians.com/chronicles/first-steps-with-ruby-wasm-or-building-ruby-next-playground">First steps with ruby.wasm: or how we built Ruby Next Playground‚ÄîMartian Chronicles, Evil Martians‚Äô team blog</a></li><li><a href="https://github.com/kateinoigakukun/optcarrot.wasm">kateinoigakukun/optcarrot.wasm: A NES emulator written in Ruby on browser powered by WebAssembly</a></li><li><a href="https://speakerdeck.com/lnit/matrk11-ruby-wasm-msw">https://speakerdeck.com/lnit/matrk11-ruby-wasm-msw</a></li><li><a href="https://aligach.net/diary/2024/0525/pack-ruby-script-with-wasm/">Wasm„ÅßÂ∞ë„Åó„Å†„ÅëÊâãËªΩ„Å´Ruby„Å®Ruby„Çπ„ÇØ„É™„Éó„Éà„ÇíÊåÅ„Å°ÈÅã„Å∂ (2024-05-25) | „ÅÇ„Éº„ÅÇ„Çä„Åå„Å°</a></li></ul></div></div>
  </body>
</html>
