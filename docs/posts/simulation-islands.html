<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://box2d.org/posts/2023/10/simulation-islands/">Original</a>
    <h1>Simulation Islands</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>Island management is a fundamental low level feature of physics engines and can have a big impact on solver design and performance. This was one of the first problems I decided to work on for Box2D version 3 (v3).</p>
<p>Since I began working on v3 I&#39;ve been comparing several algorithms for island management. My goal has been to make island building scale better with multiple CPU cores. Here are the three approaches I&#39;ve considered:</p>
<ul>
<li>Depth-first search (DFS)</li>
<li>Parallel union-find</li>
<li>Persistent islands</li>
</ul>
<p>Let&#39;s dive in!</p>
<h2 id="what-are-islands">What are islands?</h2>
<p>You can view a rigid body simulation as a graph where bodies are nodes and constraints are edges. Constraints consist of contacts (shapes touching) and joints (hinges, sliders, etc). From the graph point of view contacts and joints are the same.</p>
<p>In graph theory islands are called <a href="https://en.wikipedia.org/wiki/Component_(graph_theory)">connected components</a>. In rigid body simulation static bodies are not part of the graph. For example, this image shows three islands.</p>
<p><img src="https://box2d.org/images/islands.svg" alt="islands"/><em>Islands</em></p>
<p>Static bodies are not part of the island graph because they can be shared among multiple islands. They <strong>need</strong> to shared because in a video game lots of bodies will be touching the static ground. Without sharing the static bodies among multiple islands there will be far fewer islands. Islands then lose their value. Islands are not required for correctness. They are an optimization (as we shall see) and they only work well as an optimization if there are many islands. Static bodies <strong>can</strong> be shared because nothing in the simulation affects their position or velocity. Sharing static bodies among multiple islands requires a little bit of care in the algorithms, but this is straight forward and for simplicity I will not include such logic in my examples.</p>
<p>In practice an island is a data structure that keeps track of a set of bodies and a set of constraints. This is the island data structure in Box2D v2.4:</p>
<div><pre><code data-lang="cpp"><span>class</span> <span>b2Island</span>
{
    b2Body<span>*</span><span>*</span> bodies;
    b2Contact<span>*</span><span>*</span> contacts;
    b2Joint<span>*</span><span>*</span> joints;
    <span>int</span> bodyCount;
    <span>int</span> contactCount;
    <span>int</span> jointCount;
};
</code></pre></div><p>
The island uses arrays of pointers because the island does not own the bodies or constraints. An island is a subset of the simulation world.</p>
<p>Users of Box2D don&#39;t interact with islands. They are an implementation detail of the solver. Box2D v2.4 does not retain islands across time steps, so there is no way to access them.</p>
<h3 id="sleeping-and-waking">Sleeping and waking</h3>
<p>Islands are very useful in game physics. The most important aspect is sleeping. Sleeping rigid bodies are removed from the solver and this drastically reduces their CPU load. The engine checks islands during simulation for low energy. If all bodies in an island have low energy for several time steps, then all the bodies in the island are flagged as sleeping and no longer added to the active simulation. The Box2D debug display shows sleeping bodies as gray.</p>
<p><img src="https://box2d.org/images/sleep.png" alt="sleep"/></p>
<p>Sleeping must be done per island, not per body. I made this mistake early in my work on game physics. If you put a body to sleep but not the whole island then you will see shapes begin to overlap and joints begin to dislodge.</p>
<p>Sleep has a flip side as well: waking.</p>
<p>Bodies wake other sleeping bodies through constraints and this must propagate through all touching bodies immediately. Otherwise you get those nasty overlapping shapes and dislodged joints. Islands are just as important for waking as for sleeping.</p>
<h3 id="parallel-islands">Parallel islands</h3>
<p>Islands work well for multicore simulation. Game worlds often have many separate islands of bodies. A ragdoll over here. A pile of debris over there. This relates to the concept of <em>spatial coherence</em> as described by Gino van den Bergen in his book <a href="http://dtecta.com/publications">Collision Detection in Interactive 3D Environments</a>. Spatial conherence says that rigid bodies tend to spread out and we can take advantage of this to improve performance and lower memory usage.</p>
<p>An island can be simulated indepedently from other islands. Therefore an island can be simulated on a thread and you can send multiple islands to multiple threads using a task system such as <a href="https://github.com/dougbinks/enkiTS">enkiTS</a>. This scales very well with CPU core count as long as there are a sufficient number of islands. This is also cache efficient because the core is doing significant work on a subset of the simulation world.</p>
<p>Parallel islands simulation is not a silver bullet. There may not be enough islands to span all the CPU cores. In some games there may be a large pile or tower of rigid bodies that are in a single island. This large single island can dominate performance even with multithreading. It can lead to a situation where many cores are sitting idle. I plan to discuss large islands in a future post.</p>
<p><img src="https://box2d.org/images/tower.jpg" alt="tower"/><em>Large Island</em></p>
<h2 id="depth-first-search">Depth-first search</h2>
<p>Box2D v2.4 uses depth-first search <a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS</a> to build islands from scratch every time step. Version 2.4 does not have multithreading support, so islands are only used for sleeping and waking.</p>
<p>The <code>SolveIslands</code> function takes all the bodies and constraints of the simulation world and finds their simulation islands. Before finding the islands, it clears a mark (visitation flag) on every body and constraint. These marks ensure that a body or constraint is only added to a single island.</p>
<p>The algorithm has a simulation island <em>G</em> that is reused for each island found. The island finder loops over all bodies and looks for awake dynamic bodies to be the <em>seed</em> for the island. Starting from the <em>seed</em>, connected bodies and constraints are added to <em>G</em>. Once all the connected bodies have been traversed the island <em>G</em> is simulated, updating the constraint forces and the body velocities and positions. Then the algorithm continues looking for the next seed body that hasn&#39;t already been simulated in the current time step.</p>
<pre><code>function SolveIslands(bodies, constraints)
    ClearMarks(bodies)
    ClearMarks(constraints)
    let G be an island

    for seed in bodies
        if seed not marked and seed is dynamic and seed is awake
            Clear(G)
            Mark(seed)
            let S be a stack
            S.Push(seed)
            while S not empty
                b = S.Pop()
                G.Add(b)
                for c in b.GetConstraints()
                    if c not marked
                        G.Add(c)
                        Mark(c)
                        other = OtherBody(c)
                        if other not marked
                            S.Push(other)
            G.Simulate()
</code></pre><p>DFS has linear time complexity in the number of bodies. It can be made faster by only using awake bodies as seeds. This can be done by keeping an array of awake dynamic bodies.</p>
<p>Traversal mark management can also be expensive. At the cost of more memory, each body and constraint can hold a time step counter. The DFS can then compare a body&#39;s time step counter with the current time step count of the physics world. Marking a body or constraint is done by setting the local time step counter equal to the world time step count.</p>
<p>The DFS naturally wakes bodies. When a body is added to an island it is flagged as awake. A body can only be flagged as sleeping with another routine called <code>IslandSleep</code>.</p>
<p>Part of island simulation is checking for sleeping. Every body has velocity and a sleep timer. If the velocity is greater than a velocity threshold then sleep timer is reset. Otherwise it is advanced by the time step. If the minimum sleep timer of all bodies in an island is greater than a <em>time to sleep</em> threshold then the entire island is marked as sleeping.</p>
<pre><code>function IslandSleep(islandBodies, timeStep)
    minSleepTime = MAX_FLOAT
    for b in islandBodies
        if b velocity &gt; velocityThreshold
            b.sleepTime = 0
            minSleepTime = 0
        else
            b.sleepTime += timeStep
            minSleepTime = Min(minSleepTime, b.sleepTime)

    if minSleepTime &gt; timeToSleep
        for b in islandBodies
            MarkSleeping(b)
</code></pre><p>Then the next time step no collisions between sleeping bodies are updated and sleeping bodies are not added to simulation islands unless an awake body begins interacting with a sleeping body. This is a huge win for performance in large game worlds.</p>
<p>Watch this video if you want more details on DFS:

</p><p>
  <iframe src="https://www.youtube.com/embed/7fujbpJ0LB4" allowfullscreen="" title="YouTube Video"></iframe>
</p>

<h2 id="union-find">Union-find</h2>
<p>Union-find (UF) is a competitor to DFS for game physics island simulation. This algorithm is also called a <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set data structure</a>.</p>
<p>UF focuses on merging sets (islands). Each dynamic body starts alone in its own set. As constraints are added to the world the sets are merged. Within each set a single body is considered the root body and uniquely identifies the set. After all constraints have been added the union-find is complete.</p>
<p>This video series explains union-find very well: <a href="https://youtube.com/playlist?list=PLDV1Zeh2NRsBI1C-mR6ZhHTyfoEJWlxvq&amp;si=brluQ5CldgIXFMhv">https://youtube.com/playlist?list=PLDV1Zeh2NRsBI1C-mR6ZhHTyfoEJWlxvq&amp;si=brluQ5CldgIXFMhv</a>. If you are not familiar with union-find and/or path compression, please go watch this and come back.</p>
<p>Like DFS, union-find (with path compression) has linear time complexity for building islands. Union-find can be a drop-in replacement for DFS. However, some additional care must be used to ensure that all touching bodies are woke up.</p>
<h2 id="the-amdahl-problem">The Amdahl problem</h2>
<p>DFS and UF are fast but they are not parallel algorithms. So when I began multithreading Box2D I started to get timing results like this:</p>
<p><img src="https://box2d.org/images/dfs_island.png" alt="island gap"/></p>
<p>This is <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl&#39;s law</a> in action. Multi-core scaling is limited by single-threaded processing. You will also notice a single-threaded broadphase section which I&#39;ll discuss in a future post.</p>
<h2 id="parallel-union-find">Parallel union-find</h2>
<p>At the GDC 2022, Jorrit Rouwe introduced a parallel union-find algorithm. The slides are <a href="https://gdcvault.com/play/1027560/Architecting-Jolt-Physics-for-Horizon">here</a>. You can also find an implementation in <a href="https://github.com/jrouwe/JoltPhysics">Jolt Physics</a>.</p>
<p>I implemented this algorithm in Box2D v3. In the process I learned a lot about using atomics and lock-free algorithms. If you want to learn more about atomics and the C/C++ memory model, I highly recommend this two-part video by Herb Sutter:</p>

<p>
  <iframe src="https://www.youtube.com/embed/A8eCGOqgvH4" allowfullscreen="" title="YouTube Video"></iframe>
</p>

<p>The first challenge I faced was making the algorithm recursive so that it would wake entire islands in one time step. I needed to add some additional iteration to ensure that all touching bodies are woken up. After fumbling with atomics a bit, I got something working.</p>
<p>However, I quickly ran into a problem and did a lot of head scratching trying to figure out the problem. Fortunately I still have plenty of hair.</p>
<p>Parallel union-find uses atomic compare-and-swap (<a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS</a>) when merging islands. This means the order of constraints in the resulting islands is non-deterministic. The final order depends on which core happens to be faster at completing the CAS. This can change dramatically across time steps and repeated runs of the application.</p>
<p>This is a serious problem for the solver used in game physics because the constraints are solved one at a time, sequentially. The results from each constraint propagate to the next constraint. This contraint solver algorithm is formally called the <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method">Gauss-Seidel method</a>. The problem is magnified because Box2D uses <em>warm starting</em> for contacts, which gets confused when the contraint order varies each time step. You can read more about Gauss-Seidel and warm starting <a href="http://box2d.org/files/ErinCatto_IterativeDynamics_GDC2005.pdf">here</a>.</p>
<p>The constraints can be sorted after union-find and they can be sorted for each island independently. However, I could not find a faster way to do this than by using quicksort which is O(n log n). For large islands this added cost is significant, even when sorting a minimal index array. This video shows the effect of a parallel union-find and the resulting non-deterministic constraint order.</p>

<p>
  <iframe src="https://www.youtube.com/embed/3hMYUx6bIZ8" allowfullscreen="" title="YouTube Video"></iframe>
</p>

<p>The serial DFS and UF do not have this problem. They generate constraints in a deterministic order. The loss of determinism is due to multithreading and the use of atomic CAS. If you want to learn more about determinism and multithreading, I recommend this video:</p>

<p>
  <iframe src="https://www.youtube.com/embed/mXkPCaZUXhg" allowfullscreen="" title="YouTube Video"></iframe>
</p>

<h2 id="whats-next">What&#39;s next?</h2>
<p>After implementing the parallel union-find I took a step back and reconsidered my options and tried to look at the big picture.</p>
<p>First, I decided that I did not want to sacrifice determinism. As a programmer I value predictability in the software I write. Determinism affects my ability to debug and any Box2D user&#39;s ability to debug. I&#39;m willing to give up performance for my software to be debuggable.</p>
<p>Second, Amdahl says that the serial part of a program dominates scaling. However, having a very fast serial part might be okay. Not every algorithm needs to be parallel if it is fast enough. So maybe I can find something faster than DFS or serial UF.</p>
<p>Third, Gino also describes <em>temporal coherence</em> in his book. Temporal coherence says the configuration of rigid bodies in a simulation does not change much across a single time step. How often do islands change? I suspect islands change slowly.</p>
<p>Fourth, maybe the cost of islands can be spread out in other ways. For example, it is urgent that islands are merged within the current time step. This is necessary to wake islands immediately. On the other hand it is not urgent to put islands to sleep or to split islands when bodies stop interacting. Delayed sleep is a minor performance loss.</p>
<h2 id="persistent-islands">Persistent islands</h2>
<p>The points above led to me investigate persistent islands. Persistent islands are retained across time steps. They need to support adding and removing bodies and contraints incrementally.</p>
<p>When a dynamic body is created it also creates a new island: an island of a single body. Static bodies do not get islands.</p>
<p>When a constraint between two dynamic bodies is created the two associated islands are merged. It may be the case that the bodies are already in the same island and this is an early out in the island merger.</p>
<p>When a dynamic body is destroyed it is removed from its island. If that island is now empty then the island is also destroyed.</p>
<p>When a constraint is destroyed then it is removed from the island. The island becomes a candidate for splitting.</p>
<p>I need to merge persistent islands immediately. This is necessary to ensure that all bodies that should be awake are added to the active simulation.</p>
<p>Persistent island splitting can be deferred. I can put a quota on island splitting. For example, one island per time step can split. Maybe I can choose to split the largest island first. Or maybe I can choose to split the island with the most constraints removed. Some heuristic can be used. I suspect any reasonable heuristic is fine.</p>
<p>I modified the v2.4 island structure to support adding and removing bodies and constraints quickly using linked lists. This also makes it fast to merge islands. Linked lists are slow to traverse because of cache misses, but I suspect I will not need to traverse them often. I also added a flag <code>maySplit</code> to indicate that the island has had contacts or joints removed and it may be possible to split the island into two or more islands.</p>
<div><pre><code data-lang="c"><span>struct</span> b2Island
{
	<span>int</span> index;
	<span>int</span> parentIsland;

	<span>int</span> headBody;
	<span>int</span> tailBody;

	<span>int</span> headContact;
	<span>int</span> tailContact;

	<span>int</span> headJoint;
	<span>int</span> tailJoint;

	<span>bool</span> maySplit;
};</code></pre></div>
<p>If I have an existing set of islands I can add an edge and this may lead to two islands merging. Island merging should be fast and it has to be deterministic. I decided to stick with serial union-find for merging islands.</p>
<p>Here is the code for adding a contact constraint. Joints are similar. I abbreviated the code a bit and left out path compression. You can see the full version <a href="https://github.com/erincatto/box2c/blob/a0a9c6e72c9f2174fdf6582c5d4ba60f5343b2ba/src/island.c#L193">here</a>. Notice that islands are flagged as awake when they are merged.</p>
<div><pre><code data-lang="c"><span>void</span> <span>b2LinkContact</span>(b2Island<span>*</span> islands, b2Body<span>*</span> bodyA, b2Body<span>*</span> bodyB, b2Contact<span>*</span> contact)
{
	<span>int</span> islandIndexA <span>=</span> bodyA<span>-</span><span>&gt;</span>islandIndex;
	<span>int</span> islandIndexB <span>=</span> bodyB<span>-</span><span>&gt;</span>islandIndex;

	<span>if</span> (islandIndexA <span>=</span><span>=</span> islandIndexB)
	{
        <span>// bodyA and bodyB are already in the same island
</span><span></span>		b2AddContactToIsland(<span>&amp;</span>islands[islandIndexA], contact);
		<span>return</span>;
	}

	<span>// Find root of islandA
</span><span></span>	b2Island<span>*</span> rootA <span>=</span> <span>&amp;</span>islands[islandIndexA];
	b2WakeIsland(rootA);
    <span>while</span> (rootA<span>-</span><span>&gt;</span>parentIsland <span>!</span><span>=</span> B2_NULL_INDEX)
    {
        rootA <span>=</span> <span>&amp;</span>islands[rootA<span>-</span><span>&gt;</span>parentIsland];
        b2WakeIsland(rootA);
    }

	<span>// Find root of islandB
</span><span></span>	b2Island<span>*</span> rootB <span>=</span> <span>&amp;</span>islands[islandIndexB];
	b2WakeIsland(rootB);
    <span>while</span> (rootB<span>-</span><span>&gt;</span>parentIsland <span>!</span><span>=</span> B2_NULL_INDEX)
    {
        rootB <span>=</span> <span>&amp;</span>islands[rootB<span>-</span><span>&gt;</span>parentIsland];
        b2WakeIsland(rootB);
    }

	<span>// Make islandB a child of islandA
</span><span></span>	<span>if</span> (rootA <span>!</span><span>=</span> rootB)
	{
		rootB<span>-</span><span>&gt;</span>parentIsland <span>=</span> rootA<span>-</span><span>&gt;</span>index;
	}

	b2AddContactToIsland(rootA, contact);
}</code></pre></div>
<p>Removing a contact from an island involves linked list bookkeeping and flagging the island for spitting (<code>maySplit</code>). Union-find is not involved.</p>
<p>Once all the new constraints have been added to all islands, there is a serial merge step. Here is an abbreviated version of the code. The full version is <a href="https://github.com/erincatto/box2c/blob/a0a9c6e72c9f2174fdf6582c5d4ba60f5343b2ba/src/island.c#L578">here</a>. The function <code>b2MergeIslandWithParent</code> is just some boring bookkeeping code. Note that <code>b2DestroyIsland</code> invalidates the current island, so tread carefully.</p>
<div><pre><code data-lang="cpp"><span>void</span> <span>b2MergeIslands</span>(b2Island<span>*</span> islands, <span>int</span> count)
{
	<span>// Step 1: ensure every child island points directly to its root island
</span><span></span>	<span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> count; <span>+</span><span>+</span>i)
	{
		b2Island<span>*</span> island <span>=</span> <span>&amp;</span>islands[i];
		b2Island<span>*</span> rootIsland <span>=</span> island;

		<span>while</span> (rootIsland<span>-</span><span>&gt;</span>parentIsland <span>!</span><span>=</span> B2_NULL_INDEX)
		{
			rootIsland <span>=</span> <span>&amp;</span>islands[rootIsland<span>-</span><span>&gt;</span>parentIsland];
		}

		<span>if</span> (rootIsland <span>!</span><span>=</span> island)
		{
			island<span>-</span><span>&gt;</span>parentIsland <span>=</span> rootIsland<span>-</span><span>&gt;</span>index;
		}
	}

	<span>// Step 2: merge every awake island into its parent
</span><span></span>	<span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> count; <span>+</span><span>+</span>i)
	{
		b2Island<span>*</span> island <span>=</span> <span>&amp;</span>islands[i];
		<span>if</span> (island<span>-</span><span>&gt;</span>parentIsland <span>!</span><span>=</span> B2_NULL_INDEX)
		{
            b2MergeIslandWithParent(island);
            b2DestroyIsland(island);
		}
    }
}
</code></pre></div>
<p>These code snippets show that union-find builds multiple island trees then collapses each island tree into its root island. With persistence this process can occur incrementally as shapes come into contact.</p>
<h2 id="island-splitting">Island splitting</h2>
<p>I handle island splitting by taking an island and using all of its bodies as seeds for the DFS algorithm. This could be done with union-find as well. Any island finding algorithm will do. I&#39;m not really splitting the island, I just building new islands from the original island.</p>
<p>Because the island is guaranteed not to connect to other islands, the depth-first traversal is guaranteed to stay within the original island. This is critical to allow the original island to be split concurrently with other work.</p>
<p>Here is the pseudo-code for island splitting. It is very similar to the DFS algorithm above. Instead of dealing with all the bodies and constraints in the entire simulation world, it is limited to the bodies and constraints of a single island. After a new island is built, it is added to the world as a new persistent islands. After the island is split the original island is destroyed. This is fine because nothing should refer to the original island at this point.</p>
<pre><code>function SplitIsland(world, island)
    bodies = GetIslandBodies(island)
    constraints = GetIslandConstraints(island)
    ClearMarks(bodies)
    ClearMarks(constraints)

    let G be an island

    for seed in bodies
        if seed not marked and seed is dynamic and seed is awake
            Clear(G)
            Mark(seed)
            let S be a stack
            S.Push(seed)
            while S not empty
                b = S.Pop()
                G.Add(b)
                for c in b.GetConstraints()
                    if c not marked
                        G.Add(c)
                        Mark(c)
                        other = OtherBody(c)
                        if other not marked
                            S.Push(other)
            world.AddIsland(G)

    world.DestroyIsland(island)
</code></pre><p>The result of splitting the island is one or more new islands. It is a little sad if only one new island results, but it would be the correct result. Removing a constraint may or may not cause and island to split into two islands. Determining whether an island will split or not is similar to the work of doing the DFS, so I might as well optimistically attempt to split the island.</p>
<h2 id="making-persistent-islands-fast">Making persistent islands fast</h2>
<p>While working on parallel union-find I learned that the narrow-phase can drive island management. The narrow-phase is the simulation stage where contact points are computed between colliding shapes. The contact pairs that manage potentially colliding shapes are persisted across time steps. Each contact pair holds the current contact points. The number of contact points is 0, 1, or 2. If the number of contact points changes from zero to non-zero or vice-versa then there is an edge that should be added or removed from the island graph.</p>
<p>Scalability requires the narrow-phase to be executed in parallel. This is a naturally parallel algorithm because the contact points between one shape pair are not affected by other shape pairs. This is the easiest part of a physics engine to spread across multiple cores. Like butter on bread.</p>
<p>When a contact pair is updated there are three outcomes relevant to persistent islands:</p>
<ol>
<li>edge added</li>
<li>edge removed</li>
<li>unchanged</li>
</ol>
<p>The gambit is that most pairs fall in the third camp in a typical game scenario. This seems to be the case so far in my testing.</p>
<p>Edge additions need to be processed right away, before the islands are solved. I handle this with serial union-find as described above. Edge removals are less urgent. The contact constraint needs to be removed right away, but the island doesn&#39;t need to be split. Removing and edge doesn&#39;t mean the island will split. There may be other edges holding the island together. However, the island might split. So I flag the island as potentially splitting.</p>
<p>I can defer island splitting to later. For example, I can split an island after it has been solved, in the same task. This works because island A doesn&#39;t care if island B is split. Island A only cares if island B wants to merge with it. And merging is handled serially.</p>
<p>How about determinism? Determinism is maintained if the edge additions and removals are processed in deterministic order. It turns out in Box2D that the order of contact pairs in the world is deterministic, so I just need to process the edge changes according to the order of the contact pairs. However, there can be a huge number of contact pairs and looping over all the pairs serially looking for changes is going to be very slow.</p>
<p>There is one data structure that can have an large number of entries and still be fast to iterate across. The bit array! Modern CPUs help us do this quickly with bit scanning intrinsics. See <a href="https://en.wikipedia.org/wiki/Find_first_set">this</a> and <a href="https://lemire.me/blog/2018/02/21/iterating-over-set-bits-quickly/">this</a>.</p>
<p>The bit array can also work well with multithreading. Each narrow-phase worker can access a thread context that holds a local bit array. When the contact pair has an edge add or remove outcome, it flips a bit in the thread context bit array. Then after the narrow phase is complete, the main thread can bit-wise OR all the bit arrays together. This is quite fast using a bit array built on 64-bit words. And no atomics are needed.</p>
<p>Putting this all together I have the program flow shown below. This example has three threads in the narrow phase. Each thread gets its own bit array which is initially all zeros. When a contact pair is processed it checks if the number of contact points went from 0 to non-zero or vice-versa. In either case it sets the thread&#39;s bit array at the index associated with the contact pair. After all contact pairs are processed the bits from each thread are combined into a global bit array using bit-wise OR. Then a loop iterates over the global bit array looking for set bits. If a set bit is found, the code looks up the contact pair and determines if an edge should be added or removed from the island graph and then does that work. These additions and removals are done serially in the main thread. This retains a deterministic constraint order.</p>
<p><img src="https://box2d.org/images/persistent_island_bits.svg" alt="persistent island flow"/><em>Persistent island program flow</em></p>
<p>In practice the number of set bits is very small. Bit traversal is very fast, even for a large number of contact pairs.</p>
<h2 id="results">Results</h2>
<p>And performance? Performance is good. Gino was right!</p>
<p>This image shows a typical timing result. The blue bars are the contact pairs and the yellow bars are the island constraint solvers. The gap in between is the serial island management. The gap also includes island solver preparation and task system overhead.</p>
<p><img src="https://box2d.org/images/persistent_islands.png" alt="persistent island performance"/></p>
<p>Let&#39;s look at some benchmarks.</p>
<p>The first test is 182 pyramids with a base of 10 boxes, so 55 bodies each and a total of 10010 bodies. These pyramids are not moving and so this test favors persistent islands.</p>
<p><img src="https://box2d.org/images/pyramid_benchmark.png" alt="pyramid benchmark"/></p>
<p>The tumbler test has 2000 boxes inside a hollow box that is constantly rotating on a revolute joint. This test should be difficult for persistent islands because constraints are constantly being added and removed. The darker boxes are colored that way because Box2D considers them fast enough to engage continuous collision checks.</p>
<p><img src="https://box2d.org/images/tumbler_benchmark.png" alt="tumbler benchmark"/></p>
<p>Here are the results for the two tests. Times are in milliseconds. The first time value is the average and the value in parentheses is the maximum. For DFS I&#39;m using <a href="https://github.com/erincatto/box2c/commit/e105c0c3787d485ae3796f83cef301664dd88911">commit #32</a> of Box2D v3. For persistent islands I&#39;m using <a href="https://github.com/erincatto/box2c/commit/96c9978577d21d856b09e6a775d4e63d5643a24f">commit #36</a>.</p>
<p>For persistent islands there can be many frames in a row where the island management has no work, making it tricky to benchmark. Persistent islands are strangly fast. I had to verify the code was working a few times. Indeed it is doing real work as I have tested island merging and splitting as well as sleeping and waking.</p>
<p>Take the maximums with a grain of salt. They could be due to anything. I include them because the persistent island has a heavier load when the bodies are created and this is relevant to avoid frame rate dips.</p>
<table>
<thead>
<tr>
<th>Test</th>
<th>DFS</th>
<th>Persistent</th>
</tr>
</thead>
<tbody>
<tr>
<td>pyramids</td>
<td>0.69 (0.98)</td>
<td>0.01 (0.45)</td>
</tr>
<tr>
<td>tumbler</td>
<td>0.43 (0.87)</td>
<td>0.08 (0.43)</td>
</tr>
</tbody>
</table>
<p>Persistent islands are roughly an order of magnitude faster than DFS.</p>
<h2 id="what-about-splitting">What about splitting?</h2>
<p>The current implementation uses DFS to split at most one island per time step. My current heuristic is to split the largest island that has had one or more constraints removed.</p>
<p>Island splitting isn&#39;t free but it is usually easy to hide the cost. I have experimented with putting the island splitting at the end of an island solve task. When there are many islands and multiple cores then this time is almost completely hidden and insignificant, amounting to a few microseconds on a single core.</p>
<p>If there are a small number of large islands then the cost of splitting can be significant. Nevertheless, island splitting can be done in parallel with other work and this is a significant gain over the traditional serial DFS/UF.</p>
<h2 id="summary">Summary</h2>
<p>I covered a lot of material in this post and there are a lot of references and auxilliary knowledge. Simulation islands touch a lot of systems, so it is challenging to fully understand islands without understanding how a physics engine is put together. Hopefully I&#39;ve provided enough background knowledge so you can understand the scope of island mangement. If not, please let me know!</p>
<p>These are the main takeaways I have learned or reinforced while working on islands:</p>
<ul>
<li>island management can become a bottleneck in multicore simulation</li>
<li>determinism is important for game physics</li>
<li>spatial and temporal coherence provide many opportunities for improving performance</li>
<li>sometimes a fast serial algorithm may be better than a parallel algorithm</li>
<li>bit arrays are awesome!</li>
</ul>
<h2 id="whats-next-1">What&#39;s next?</h2>
<p>At the end of this journey I have many tools to work with islands. This will help me as I explore other aspects of improving Box2D.</p>
<p>There is more work to do on Box2D and more to write up. I plan to post more in the future on broad-phase improvements and dealing with large islands. Stay tuned!</p>

            </div></div>
  </body>
</html>
