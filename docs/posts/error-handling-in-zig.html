<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.aolium.com/karlseguin/4013ac14-2457-479b-e59b-e603c04673c8">Original</a>
    <h1>Error Handling in Zig</h1>
    
    <div id="readability-page-1" class="page"><div><p>There are two aspects to Zig&#39;s simple error handling: error sets and try/catch. Zig&#39;s error set are essentially a specialized enum that can be created implicitly:</p>
<pre><code>fn divide(dividend: u32, divisor: u32) !u32 {
  if (divisor == 0) {
    return error.DivideByZero;
  }
  return dividend / divisor;
}
</code></pre>
<p>Which is, in effect, the same as making it explicit:</p>
<pre><code>const DivideError = error {
  DivideByZero
};

fn divide(dividend: u32, divisor: u32) !u32 {
  if (divisor == 0) {
    return DivideError.DivideByZero;
  }
  return dividend / divisor;
}
</code></pre>
<p>In both cases our function returns an <code>!u32</code> where the exclamation mark, <code>!</code>, indicates that this function can return an error. Again, we can either be explicit about the error(s) that our function returns or implicit. In both of the above case, we&#39;ve taken the implicit route.</p>
<p>Alternatively, we could have used an explicit return type: <code>error{DivideByZero}!u32</code>. In the 2nd case we could have used the explicit error set: <code>DivideError!u32</code>.</p>
<p>Zig has a special type, <code>anyerror</code>, which can represent any error. It&#39;s worth pointing out that the return types <code>!u32</code> and <code>anyerror!u32</code> are different. The first form, the implicit return type, leaves it up to the compiler to determine what error(s) our function can return. There are cases where the compiler might not be able to infer type where we&#39;ll need to be explicit, or, if you&#39;re lazy like me, use <code>anyerror</code>. It&#39;s worth pointing out that the only time I&#39;ve run into this is when defining a function pointer type.</p>
<p>Calling a function that returns an error, as <code>divide</code> does, requires handling the error. We have two options. We can use <code>try</code> to bubble the error up or use <code>catch</code> to handle the error. <code>try</code> is like Go&#39;s tedious <code>if err != nil { return err }</code>:</p>
<pre><code>pub fn main() !void {
  const result = try divide(100, 10);
  _ = result; // use result
}
</code></pre>
<p>This works because <code>main</code> itself returns an error via <code>!void</code>. <code>catch</code> isn&#39;t much more complicated:</p>
<pre><code>const result = divide(100, 10) catch |err| {
  // handle the error, maybe log, or use a default
}
</code></pre>
<p>For more complicated cases, a common pattern is to switch on the caught error. From the top-level handler in <a href="https://github.com/karlseguin/http.zig/blob/bda55c35c6167d073f3ec5e870b6fce89651d35b/src/httpz.zig#L289">http.zig</a>:</p>
<pre><code>self.dispatch(action, req, res) catch |err| switch (err) {
  error.BodyTooBig =&gt; {
    res.status = 431;
    res.body = &#34;Request body is too big&#34;;
    res.write() catch return false;
  },
  error.BrokenPipe, error.ConnectionResetByPeer =&gt; return false,
  else =&gt; self._errorHandler(req, res, err),
}
</code></pre>
<p>Another somewhat common case with <code>catch</code> is to use <code>catch unreachable</code>. If <code>unreachable</code> is reached, the panic handler is executed. Applications can define their own panic handler, or <a href="https://github.com/ziglang/zig/blob/1c7798a3cde9e8dad31c276aab4c1affb2043ad2/lib/std/builtin.zig#L733">rely on the default one</a>. I use <code>catch unreachable</code> a lot in test code.</p>
<p>One final thing worth mentioning is <code>errdefer</code> which is like <code>defer</code> (think Go&#39;s <code>defer</code>) but it only executes if the function returns an error. This is extremely useful. You can see an example of it in the <a href="https://github.com/karlseguin/zuckdb.zig/blob/master/src/conn.zig#L27">duckdb driver</a></p>
<pre><code>pub fn open(db: DB) !Conn {
  const allocator = db.allocator;

  var slice = try allocator.alignedAlloc(u8, CONN_ALIGNOF, CONN_SIZEOF);

  // if we `return error.ConnectFail` a few lines down, this will execute 
  errdefer allocator.free(slice);

  const conn: *c.duckdb_connection = @ptrCast(slice.ptr);

  if (c.duckdb_connect(db.db.*, conn) == DuckDBError) {
    // if we reach this point and return an error, our above `errdefer` will execute
    return error.ConnectFail;
  }

  // ...
}
</code></pre>
<p>A serious challenge with Zig&#39;s simple approach to errors that our errors are nothing more than enum values. We cannot attach additional information or behavior to them. I think we can agree that being told &#34;SyntaxError&#34; when trying to parse an invalid JSON, with no other context, isn&#39;t great. This is currently an <a href="https://github.com/ziglang/zig/issues/2647">open issue</a>.</p>
<p>In the meantime, for more complex cases where I want to attach extra data to or need to attach behavior, I&#39;ve settled on leveraging Zig&#39;s tagged unions to create generic Results. Here&#39;s an example from a PostgreSQL driver I&#39;m playing with:</p>
<pre><code>pub fn Result(comptime T: type) T {
  return union(enum) {
    ok: T,
    err: Error,
  };
}

pub const Error = struct {
  raw: []const u8, // fields all reference this data
  allocator: Allocator, // we copy raw to ensure it outlives the connection

  code: []const u8,
  message: []const u8,
  severity: []const u8,

  pub fn deinit(self: Error) void {
    self.allocator.free(self.raw);
  }
};
</code></pre>
<p>Because Zig has exhaustive switching, we can still be sure that callers will have to handle errors one way or another. However, using this approach means  that the convenience of <code>try</code>, <code>catch</code> and <code>errdefer</code> are no longer available. Instead, you&#39;d have to do something like:</p>
<pre><code>const conn = switch (pg.connect()) {
  .ok =&gt; |conn| conn,
  .err =&gt; |err|  // TODO handle err
}
</code></pre>
<p>The &#34;TODO handle err&#34; is going to be specific to the application, but you could log the error and/or convert it into a standard zig error.</p>
<p>In our above <code>Error</code> you&#39;ll note that we&#39;ve defined a <code>deinit</code> function to free <code>self.raw</code>. So this is an example where our error has additional data (the <code>code</code>, <code>message</code> and <code>severity</code>) as well as behavior (freeing memory owned by the error).</p>
<p>To compensate for our loss of <code>try</code> and <code>catch</code>, we can enhance or <code>Result(T)</code> type. I haven&#39;t come up with anything great, but I do tend to add an <code>unwrap</code> function and a <code>deinit</code> function (assuming either <code>Error</code> or <code>T</code> implement <code>deinit</code>):</p>
<pre><code>pub fn unwrap(self: Self) !T {
  switch(self) {
    .ok =&gt; |ok| return ok,
    .err =&gt; |err| {
      err.deinit();
      return error.PG;
    }
  }
}

pub fn deinit(self: Self) void {
  switch (self) {
    .err =&gt; |err| err.deinit(),
    .ok =&gt; |value| {
      if (comptime std.meta.trait.hasFn(&#34;deinit&#34;)(T)) {
        value.deinit();
      }
    },
  }
}
</code></pre>
<p>Unlike Rust&#39;s <code>unwrap</code> which will panic on error, I&#39;ve opted to convert <code>Error</code> into an generic error  (which can then be used with Zig&#39;s built-in facilities). As for exposing <code>deinit</code> directly on <code>Result(T)</code> it just provides an alternative way to program against the result. Combined, we can consume <code>Result(T)</code> as such:</p>
<pre><code>const result = pg.connect();
defer result.deinit();  // will be forwarded to either `T` or `Error`
const conn = try result.unwrap();
</code></pre>
<p>In the end, the current error handling is sufficient in most cases, but I think anyone who tries to parse JSON using <code>std.json</code> will immediately recognize a gap in Zig&#39;s capabilities. You can work around those gaps by, for example, introducing a <code>Result</code> type, but then you lose the integration with the language. Of particular note, I would say losing <code>errdefer</code> is more than just an ergonomic issue.</p>
</div></div>
  </body>
</html>
