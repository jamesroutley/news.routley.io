<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w3d1-the-labors-of-the-functional-programming-enthusiast">Original</a>
    <h1>RC W3D1 - The labors of the functional programming enthusiast</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1946822">
    
      <div><p>To those who maintain a blog and wonder if you’re putting in too much effort relative to the value you get out of it: (1) Let’s chat (2) The person who finds this blog most helpful is myself.</p><p>It’s the start of Week 3, thankfully feeling a bit more centered. I had been wondering if I was learning Haskell for the wrong reasons, did a presentation last Friday, and felt reassured in my decision when I was able to draw line linking learning SICP in December to learning Haskell now.</p><p>In yesterday’s <a href="https://payments.posthaven.com/rc-w2d5-moving-between-extremes">post</a>, I reflected on doing things for the wrong reason. I suppose it’s common to do things in extremes, hence the stereotype of the investment banker ditching the high life to get into spirituality. My version of this is getting into functional programming after spending time working on infra (though to be fair, I didn’t do it for that long).</p><p>I imagine I’m also not alone in wanting to learn one thing and then discover whole new worlds. The starting point was SICP into Haskell. Then there was lambda calculus, type theory, category theory. Maybe proofs. Maybe other functional languages. Maybe implementation / compilers.</p><p>In a nutshell, way too much. Too much for a half batch, too much for a full batch. I’m not sure my significant other would love the idea of a year-long sabbatical.</p><p>What is it all for anyway? How does it make me a better programmer?</p><p>I’m one third into the half batch. I feel compelled to share ’the story so far’.</p><p>The question ‘what is functional programming?’ came up in FP study group last week. I like to think of the broader answer around &#39;functions as first-citizens&#39;, namely that you can pass functions as arguments and functions can return other functions (often referred to as closures). This way lots of other imperative languages like Python say can be written in a functional way.</p><p>Then there’s functional in the sense of ‘functional vs imperative’. In this context, functions are pure (no side effects) and variables are immutable. Thus calling the same function with the same arguments results in the same output every time.</p><p>Now I imagine lots of people wanting to get into functional programming pick up Haskell, but Haskell is additionally a lazy language. This means that evaluation is delayed until results are actually needed, whereas most functional languages are eager. As per <a href="https://payments.posthaven.com/rc-w2d2-lazy-vs-eager-evaluation">Brent Yorgey</a>, It’s impractical and unexpected for a lazy language to not be pure.</p><p>We next get to the question of types. Why the tight coupling between functional languages and types? I don’t have a good answer.</p><p>Some suggest it’s a practical consideration, but I’m less convinced given the examples of most lisps (functional but dynamically typed) and Rust (imperative but has algebraic data types). I lean more towards the explanation of the language designers being ‘people who like abstract ideas and want to implement abstract ideas’; there’s a tradition of the languages being academic or experimental before becoming ‘industrial strength’. Examples include ML becoming OCaml, and Haskell itself.</p><p>I got to the chapter on functors in UPenn&#39;s <a href="https://www.cis.upenn.edu/~cis1940/spring13/" title="Link: https://www.cis.upenn.edu/~cis1940/spring13/">CIS 194</a>, and thought they looked familiar. I had a little digression into Bartosz Milewski’s category theory videos (highly recommend the <a href="https://www.youtube.com/watch?v=I8LbkfSSR58">intro</a>, his enthusiasm is infectious). Functors appeared to me as ’this abstract idea is cool, let’s see what it looks like implemented in the language’.</p><p>OK so now we’re in real deep. The intro video talked about the Curry-Howard correspondence, which basically says there is a direct relationship between computer programs (namely the typed lambda calculus) and mathematical proofs. This was extended to the Curry-Howard-Lambek correspondence, that extended the equivalence (or isomorphism) to categories as well.</p><p>&#34;Stop, stop, I’m lost!”, you say. I hear you, so am I.</p><p>Where do I go from here? I plan to finish up Haskell via CIS 194 (surely you can’t skip monads). I just got a copy of The Little Typer, maybe get Types and Programming Languages in post-batch (Stanford&#39;s <a href="https://stanford-cs242.github.io/f19/">CS 242</a> looks pretty cool, even has a <a href="https://arxiv.org/abs/1904.06750">paper</a> on the teaching philosophy). RC has Impossible Projects Day on Thursday, here’s my excuse to jump head-long first and see where the tides take me.</p></div>
    
  </div></div>
  </body>
</html>
