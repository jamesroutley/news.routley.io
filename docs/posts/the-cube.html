<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://en.wikiversity.org/wiki/Foundations_of_Functional_Programming/The_%CE%BB-cube">Original</a>
    <h1>The λ-Cube</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p><a href="https://blog.benjojo.co.uk/wiki/File:Lambda_cube.png"><img alt="" src="https://upload.wikimedia.org/wikipedia/commons/1/19/Lambda_cube.png" decoding="async" width="321" height="294" data-file-width="321" data-file-height="294"/></a></p><p>The λ-cube. Direction of each arrow is direction of inclusion.</p></div></div>
<p>The λ-cube is a set of eight type theories which combine three different type system features in all the possible ways. These three features are:
</p>
<ul><li><b>Values depending on types</b>, also known as <i>polymorphic types</i>.</li>
<li><b>Types depending on types</b>, also known as <i>type constructors</i>.</li>
<li><b>Types depending on values</b>, also known as <i>dependent types</i>.</li></ul>
<p>The fourth natural item in this list, namely <b>values depending on values</b>, is a feature of all λ-calculi; any language with functions has this feature. Indeed, we can see each of these three type system features as a way of extending the notion of a function:
</p>
<ul><li><b>Polymorphically typed expressions</b> are functions from types to values.</li>
<li><b>Type constructors</b> are functions from types to types.</li>
<li><b>Dependent types</b> are functions from values to types.</li>
<li>And, of course, <b>functions from values to values</b> are a feature of all λ-calculi and have no special name.</li></ul>
<p>The description of polymorphically typed expressions as functions from types to values may sound unfamiliar to the ear. However, it is exactly how they are described in the <a href="https://blog.benjojo.co.uk/wiki/Foundations_of_Functional_Programming/Second-order_%CE%BB-calculus" title="Foundations of Functional Programming/Second-order λ-calculus">second-order λ-calculus</a>. An expression of type <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5abb46c20c4920595ada370cd8336ff892f85993" aria-hidden="true" alt="{\displaystyle \forall \alpha .\ \mathbf {T} }"/></span> has the form <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ff027d037518cf80003d8a08667dedbf811089d" aria-hidden="true" alt="{\displaystyle \Lambda \alpha .\ A}"/></span>, and to instantiate it to an expression of type <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e8b7a0e795c4e5bd58d238c96b2e7efa20442ee3" aria-hidden="true" alt="{\displaystyle \mathbf {T} [\alpha /\mathbf {U} ]}"/></span> you write <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6c3d14283b91740e1324d0bd08628e6785d72443" aria-hidden="true" alt="{\displaystyle (\Lambda \alpha .\ A)\mathbf {U} }"/></span>.
</p><p>This syntax makes it clear how polymorphically typed values can be understood as functions from types to values. A polymorphically typed value takes a type as an argument, and returns an instance of itself instantiated to that type.
</p>


<h2><span id="Basic_structure_of_the_.CE.BB-cube"></span><span id="Basic_structure_of_the_λ-cube">Basic structure of the λ-cube</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=1" title="Edit section: Basic structure of the λ-cube">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=1" title="Edit section: Basic structure of the λ-cube">edit source</a><span>]</span></span></h2>
<p>The basic structure of the λ-cube is explained by the following table:
</p>
<table>

<tbody><tr>
<th></th>
<th>Polymorphic types?</th>
<th>Type constructors?</th>
<th>Dependent types?
</th></tr>
<tr>
<td>λ→ (explicitly simply typed λ-calculus)
</td>
<td>No
</td>
<td>No
</td>
<td>No
</td></tr>
<tr>
<td>λ2 (explicitly typed second-order λ-calculus)
</td>
<td>Yes
</td>
<td>No
</td>
<td>No
</td></tr>
<tr>
<td>λ<u>ω</u>
</td>
<td>No
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>λP
</td>
<td>No
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>λω
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>λP2
</td>
<td>Yes
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>λP<u>ω</u>
</td>
<td>No
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>λPω (calculus of constructions)
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr></tbody></table>
<p>Two of these systems are familiar. λ→ is (modulo minor syntactic variations) the explicitly simply typed λ-calculus. λ2 is (modulo minor syntactic variations) the explicitly typed second-order λ-calculus. λPω, the fullest system in the λ-cube, is also called the &#34;calculus of constructions.&#34;
</p>
<h2><span id="Syntax">Syntax</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=2" title="Edit section: Syntax">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=2" title="Edit section: Syntax">edit source</a><span>]</span></span></h2>
<p>Unlike the systems we have considered so far, the systems of the λ-cube make no syntactic distinction between types and values. There is one kind of expression, encompassing both type and value expressions. This corresponds to the fact that in the systems of the λ-cube, types are in essence a special kind of value. Henceforth we will use the term &#34;value&#34; in a way which is inclusive of types.
</p><p>The systems of the λ-cube also introduce a distinction between <i>variables</i> and <i>constants</i> which was not present in the systems we have considered so far. This distinction corresponds roughly to the same distinction in programming languages. We will denote variables by <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3815f7ed7b25de237cc5a9abaa5441df6f514836" aria-hidden="true" alt="{\displaystyle a,b,c,...}"/></span> as before, and we will denote constants by ad hoc labels; but when we need to refer to an arbitrary constant, we will use bold lower case letters <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/912decd10e57760970362eb8b4aa5d0332bd7f91" aria-hidden="true" alt="{\displaystyle \mathbf {a} ,\mathbf {b} ,...}"/></span>. We continue to use <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f69218daf7f6374bc9fb967c628dbfe71723e07d" aria-hidden="true" alt="{\displaystyle A,B,C,...}"/></span> to denote arbitrary expressions.
</p><p>The syntax is as follows:
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/de932a332e1a6fddf06760b771c0cda6a4224d59" aria-hidden="true" alt="{\displaystyle {\begin{array}{rcl}{\text{Expr}}&amp;::=&amp;{\text{Var}}\\&amp;|&amp;{\text{Const}}\\&amp;|&amp;{\text{Expr}}\ {\text{Expr}}\\&amp;|&amp;\lambda \ {\text{Var}}\ :\ {\text{Expr}}.\ {\text{Expr}}\\&amp;|&amp;({\text{Var}}\ :\ {\text{Expr}})\to {\text{Expr}}\end{array}}}"/></span>
</p><p>This syntax should be somewhat familiar. In relation to the <a href="https://blog.benjojo.co.uk/wiki/Foundations_of_Functional_Programming/Second-order_%CE%BB-calculus" title="Foundations of Functional Programming/Second-order λ-calculus">explicitly typed second-order λ-calculus</a>, the λ-abstractions in this syntax serve both the role of the λ-abstractions and the Λ-abstractions of the explicitly typed second-order λ-calculus. That is, a λ-abstraction can denote a function which takes either a non-type value, or a type, as an argument.
</p>
<h3><span id="Dependent_function_type_syntax">Dependent function type syntax</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=3" title="Edit section: Dependent function type syntax">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=3" title="Edit section: Dependent function type syntax">edit source</a><span>]</span></span></h3>
<p>The syntax <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45a09c9f5cfc2b2544c3efbf350e4833774676dc" aria-hidden="true" alt="{\displaystyle (x:A)\to B}"/></span> is a generalization of the syntax <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d5b8dd84619daff17b52a08b77d15db2b9ad6c2a" aria-hidden="true" alt="{\displaystyle A\to B}"/></span> for a function type. This generalized syntax is needed to express dependent types. The syntax&#39;s special meaning arises when <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span> occurs free in <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span>. In this case, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45a09c9f5cfc2b2544c3efbf350e4833774676dc" aria-hidden="true" alt="{\displaystyle (x:A)\to B}"/></span> expresses the type of a function which takes a value <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span> of type <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span> and produces a value of type <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span>, where <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span> is an expression denoting a type which depends on the value of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span>.
</p><p>Let us give a simple example of this syntax being used. Suppose <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d6c878a47fd509f8d971d6ebf3136be98113a254" aria-hidden="true" alt="{\displaystyle {\text{Vect}}}"/></span> is a type constructor for fixed length vectors: so <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/429b9adb6bbe787657baacd741c3cd4b7edc6dfa" aria-hidden="true" alt="{\displaystyle {\text{Vect}}\ a\ n}"/></span>, where <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc" aria-hidden="true" alt="a"/></span> is a type and <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n"/></span> is a natural number, denotes the type of vectors of length <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n"/></span> with elements of type <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc" aria-hidden="true" alt="a"/></span>.
</p><p>Now consider a function <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c35a4d5ec70a724f099d3a75c53e19f88fe25c04" aria-hidden="true" alt="{\displaystyle {\text{rep}}}"/></span> which takes an integer <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span> and a natural number <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n"/></span>, and produces a vector consisting of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" aria-hidden="true" alt="n"/></span> copies of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span>. Such a function has type
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c08f9df91750f0b7f5fc279c53f2b828392941ea" aria-hidden="true" alt="{\displaystyle {\text{rep}}:{\text{Int}}\to (n:{\text{Nat}})\to {\text{Vect}}\ {\text{Int}}\ n}"/></span>
</p><p>In this example we have used the syntax <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4a10197259a7f761ee3ad284dc3c5a03c0e6ac83" aria-hidden="true" alt="{\displaystyle {\text{Int}}\to B}"/></span> as a shorthand for <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/29d4e4c74a8fbc2c9d6acae89bb141a750436db5" aria-hidden="true" alt="{\displaystyle (x:{\text{Int}})\to B}"/></span>, where <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span> does not occur free in <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span>. We will continue to do this. That is, in general,
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d5b8dd84619daff17b52a08b77d15db2b9ad6c2a" aria-hidden="true" alt="{\displaystyle A\to B}"/></span>
</p><p>is shorthand for
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45a09c9f5cfc2b2544c3efbf350e4833774676dc" aria-hidden="true" alt="{\displaystyle (x:A)\to B}"/></span>,
</p><p>where <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span> is a variable which does not occur free in <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span>.
</p><p>We will close this topic by noting that in most presentations of the λ-cube, the syntax <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/51adf0006f6ae7048a9253d9cef873559ba62562" aria-hidden="true" alt="{\displaystyle \Pi x:A.\ B}"/></span> is used instead of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/45a09c9f5cfc2b2544c3efbf350e4833774676dc" aria-hidden="true" alt="{\displaystyle (x:A)\to B}"/></span>. The former syntax is motivated by the analogy between dependent function types and dependent Cartesian products in higher mathematics. We prefer our syntax for its greater familiarity from a programming perspective.
</p>
<h3><span id="Sorts">Sorts</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=4" title="Edit section: Sorts">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=4" title="Edit section: Sorts">edit source</a><span>]</span></span></h3>
<p>The λ-cube is the first place we encounter the notion of &#34;sorts.&#34; A sort is best understood, in simple terms, as a &#34;type of types.&#34; In the λ-cube, where types are a kind of value, types generally have types, in the sense that they can appear on the left hand side of typing judgments.
</p><p>We shall denote the &#34;type of types&#34; by <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span>. <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> is the simplest example of a sort. (A more common notation for this sort is <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f1858484bef51b1435c2b986c728a81788051803" aria-hidden="true" alt="{\displaystyle \ast }"/></span>, but we choose our notation for greater familiarity, and for its use in programming languages such as Idris.)
</p><p>So far, I have given no reason to think that there are any sorts under than <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span>. If sorts are types of types, and <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> is the type of types, why would there be any sorts other than <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span>?
</p><p>The reason that the systems of the λ-cube (and many other λ-calculi) have more than one sort is to resolve the following problem. What is the type of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span>? It is natural to say that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span>, the type of types, is a type, and that therefore <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d26fb4475b8b095a6d0e6d673733c94159d0b17" aria-hidden="true" alt="{\displaystyle {\text{Type}}:{\text{Type}}}"/></span>. The problem is that the assumption that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d26fb4475b8b095a6d0e6d673733c94159d0b17" aria-hidden="true" alt="{\displaystyle {\text{Type}}:{\text{Type}}}"/></span> gives rise to paradoxes such as <a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube/Girard%27s_paradox&amp;action=edit&amp;redlink=1" title="Foundations of Functional Programming/The λ-cube/Girard&#39;s paradox (page does not exist)">Girard&#39;s paradox</a> which render λ-calculi <a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube/Consistency_in_%CE%BB-calculi&amp;action=edit&amp;redlink=1" title="Foundations of Functional Programming/The λ-cube/Consistency in λ-calculi (page does not exist)">logically inconsistent</a>.
</p><p>For this reason, many λ-calculi, including the systems of the λ-cube, come up with an additional sort, which we will call <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span>, and stipulate that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/717a96eb9ae08757cdf661063c87aa69dbef4d63" aria-hidden="true" alt="{\displaystyle {\text{Type}}:{\text{Type}}_{1}}"/></span>, rather than <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/8d26fb4475b8b095a6d0e6d673733c94159d0b17" aria-hidden="true" alt="{\displaystyle {\text{Type}}:{\text{Type}}}"/></span>. This choice preserves logical consistency. (A more common notation for <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span> is <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/029b77f09ebeaf7528fc831fe57848be51f2240b" aria-hidden="true" alt="{\displaystyle \Box }"/></span>.)
</p><p>Another word on notation. We will also denote <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> by <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/031faa19cba116884675834cc6a1238c44e61171" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{0}}"/></span>, and systems such as <a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube/Martin-L%C3%B6f_type_theory&amp;action=edit&amp;redlink=1" title="Foundations of Functional Programming/The λ-cube/Martin-Löf type theory (page does not exist)">Martin-Löf type theory</a> have an infinite hierarchy of sorts <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d4a7bed2120feb4696e4d5365a35886411bf048a" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{0},{\text{Type}}_{1},{\text{Type}}_{2},...}"/></span>. That is the reason for writing the sort of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> as <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span>.
</p><p>In the systems of the λ-cube, there are only two sorts: <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> (a.k.a. <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/031faa19cba116884675834cc6a1238c44e61171" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{0}}"/></span>) and <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span>. In the systems of the λ-cube, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span> does not belong to any sort; it does not appear on the left hand side of any typing judgments.
</p><p>Syntactically speaking, sorts are constants. The two sorts are the only constants we will specifically need to deal with; if we didn&#39;t need sorts, we could formulate the systems of the λ-cube without constants, as we did for previous calculi.
</p>
<h3><span id="Declarations_and_contexts">Declarations and contexts</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=5" title="Edit section: Declarations and contexts">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=5" title="Edit section: Declarations and contexts">edit source</a><span>]</span></span></h3>
<p>Declarations have the same syntax as before. However, contexts are defined differently in the systems of the λ-cube than in the systems we have seen so far.
</p><p>In the systems we have seen so far, contexts are sets of declarations. Sets are unordered collections. In the systems of the λ-cube, contexts are <i>sequences</i> -- ordered finite collections -- of declarations. We denote a context by a comma-separated list of its constituent declarations. An empty context is denoted by whitespace; so for example, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/372836e03f4753d100ddd770d0683876667e1c3b" aria-hidden="true" alt="{\displaystyle \vdash x:A}"/></span> means that the empty context entails that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/de8e6bbd3d79fcf79382d2f3c5ea242c39f5821e" aria-hidden="true" alt="{\displaystyle x:A}"/></span>.
</p><p>The reason for this is that in the systems of the λ-cube, often a declaration is required for another declaration to make sense. The simplest example is that for the typing judgment <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f17c0d63b9f82320c40b9c5ed7853f5d94ad9a" aria-hidden="true" alt="{\displaystyle x:a}"/></span> to make sense, where <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc" aria-hidden="true" alt="a"/></span> is a variable standing for a type and <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/87f9e315fd7e2ba406057a97300593c4802b53e4" aria-hidden="true" alt="x"/></span> a variable standing for an ordinary value, one must have <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0f97e67f8cc1647bd2d09b40cfd2d96f2277a7a0" aria-hidden="true" alt="{\displaystyle a:{\text{Type}}}"/></span>. A context consisting of the single declaration <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f17c0d63b9f82320c40b9c5ed7853f5d94ad9a" aria-hidden="true" alt="{\displaystyle x:a}"/></span> is not valid; however, the context <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2d6e94e8d07a49277cf57718604532590b6d2d0a" aria-hidden="true" alt="{\displaystyle a:{\text{Type}},\ x:a}"/></span> is valid. On the other hand, if we swap the order of the declarations, the resulting context <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aa6428c76dd3faba83a9af0f98584117476b0404" aria-hidden="true" alt="{\displaystyle x:a,\ a:{\text{Type}}}"/></span> is invalid, because at the occurrence of the declaration <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f17c0d63b9f82320c40b9c5ed7853f5d94ad9a" aria-hidden="true" alt="{\displaystyle x:a}"/></span> we don&#39;t know that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc" aria-hidden="true" alt="a"/></span> is a type.
</p><p>In the systems we considered before, this particular necessity did not exist because there was a syntactic distinction between types and values, and so you could tell just by looking at it that a variable represented a type.
</p><p>In greater generality, for a variable to occur on the right hand side of a statement, it must have a type declared in the context governing the statement. For a declaration <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f17c0d63b9f82320c40b9c5ed7853f5d94ad9a" aria-hidden="true" alt="{\displaystyle x:a}"/></span> which occurs within a context <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4cfde86a3f7ec967af9955d0988592f0693d2b19" aria-hidden="true" alt="\Gamma"/></span>, the context governing it is the part of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4cfde86a3f7ec967af9955d0988592f0693d2b19" aria-hidden="true" alt="\Gamma"/></span> which comes before <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7f17c0d63b9f82320c40b9c5ed7853f5d94ad9a" aria-hidden="true" alt="{\displaystyle x:a}"/></span>.
</p>
<h2><span id="Type_theory">Type theory</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=6" title="Edit section: Type theory">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=6" title="Edit section: Type theory">edit source</a><span>]</span></span></h2>
<p>The rules of β-reduction in all systems of the λ-cube are as they have been before.
</p><p>The different systems of the λ-cube differ in their rules defining valid type entailments. We will begin by giving the rules which are common to all of the systems. In the following rules, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/01d131dfd7673938b947072a13a9744fe997e632" aria-hidden="true" alt="s"/></span> denotes any sort (one of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> or <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span>).
</p>

<h3><span id=".CE.B2-conversion"></span><span id="β-conversion">β-conversion</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=7" title="Edit section: β-conversion">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=7" title="Edit section: β-conversion">edit source</a><span>]</span></span></h3>
<p>The final rule in the above table, the conversion rule, uses a symbol we have not seen before: <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fd5356b346c404d750fe4464ce5e95a0b4f11ca7" aria-hidden="true" alt="{\displaystyle \equiv _{\beta }}"/></span>, which stands for β-convertibility. We say that two expressions are β-convertible when they can be connected by a series of (forwards or backwards) β-reduction steps. More precisely, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fd5356b346c404d750fe4464ce5e95a0b4f11ca7" aria-hidden="true" alt="{\displaystyle \equiv _{\beta }}"/></span> is the smallest equivalence relation which holds between two expressions if one is β-reducible to another. This mathematical definition needs more unpacking.
</p><p>In mathematics, a &#34;binary relation&#34; (or just a &#34;relation&#34;) on a set <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2" aria-hidden="true" alt="S"/></span> is a set <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b0bfb3769bf24d80e15374dc37b0441e2616e33" aria-hidden="true" alt="{\displaystyle R}"/></span> of ordered pairs <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d7e5710198f33b00695903460983021e75860e2c" aria-hidden="true" alt="(a,b)"/></span> of elements of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2" aria-hidden="true" alt="S"/></span>. Given elements <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/3e9e26744e55d92ec56132c49a80435df0ef4cb0" aria-hidden="true" alt="{\displaystyle a,b\in S}"/></span>, we typically write <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c8b0b52168739fd16b254298771ec07b900e5a6e" aria-hidden="true" alt="{\displaystyle aRb}"/></span> to mean that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/74368fbf491df6119b707e6a93b6918b0564b659" aria-hidden="true" alt="{\displaystyle (a,b)\in R}"/></span>. <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/c8b0b52168739fd16b254298771ec07b900e5a6e" aria-hidden="true" alt="{\displaystyle aRb}"/></span> means that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc" aria-hidden="true" alt="a"/></span> is related to <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f11423fbb2e967f986e36804a8ae4271734917c3" aria-hidden="true" alt="b"/></span> by the relation <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b0bfb3769bf24d80e15374dc37b0441e2616e33" aria-hidden="true" alt="{\displaystyle R}"/></span>.
</p><p>A simple example of a relation is the relation <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/440568a09c3bfdf0e1278bfa79eb137c04e94035" aria-hidden="true" alt="{\displaystyle \leq }"/></span> on the set of natural numbers, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fdf9a96b565ea202d0f4322e9195613fb26a9bed" aria-hidden="true" alt="{\displaystyle \mathbb {N} }"/></span>. <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/440568a09c3bfdf0e1278bfa79eb137c04e94035" aria-hidden="true" alt="{\displaystyle \leq }"/></span>, as a relation in the mathematical sense, is the set of pairs <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d7e5710198f33b00695903460983021e75860e2c" aria-hidden="true" alt="(a,b)"/></span> of natural numbers such that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/ffd2487510aa438433a2579450ab2b3d557e5edc" aria-hidden="true" alt="a"/></span> is less than or equal to <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f11423fbb2e967f986e36804a8ae4271734917c3" aria-hidden="true" alt="b"/></span>.
</p><p>An &#34;equivalence relation&#34; on a set <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2" aria-hidden="true" alt="S"/></span> is a relation <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b0bfb3769bf24d80e15374dc37b0441e2616e33" aria-hidden="true" alt="{\displaystyle R}"/></span> on <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2" aria-hidden="true" alt="S"/></span> satisfying the following axioms:
</p>

<p>A simple example of an equivalence relation is the identity relation on any set <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2" aria-hidden="true" alt="S"/></span>: that is, the relation which an object bears only to itself. A more complex example of an equivalence relation is the relation on natural numbers of being congruent modulo seven: i.e., of having the same remainder when divided by seven.
</p><p>The relation <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fd5356b346c404d750fe4464ce5e95a0b4f11ca7" aria-hidden="true" alt="{\displaystyle \equiv _{\beta }}"/></span>, called β-convertibility, is the least equivalence relation on the set of expressions of the λ-cube such that if an expression <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span> is β-reducible to an expression <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span>, then <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/884e96ff5ea440ce3cad00c858e8c2d4274504e0" aria-hidden="true" alt="{\displaystyle A\equiv _{\beta }B}"/></span>. More precisely, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/fd5356b346c404d750fe4464ce5e95a0b4f11ca7" aria-hidden="true" alt="{\displaystyle \equiv _{\beta }}"/></span> is the intersection (in the set-theoretic sense) of all equivalence relations <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b0bfb3769bf24d80e15374dc37b0441e2616e33" aria-hidden="true" alt="{\displaystyle R}"/></span> on λ-cube expressions such that if <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span> β-reduces to <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span> then <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/502810c1e1f25a859fc2ee0fe60d0907010a3671" aria-hidden="true" alt="{\displaystyle ARB}"/></span>. It can be proven that this intersection is itself an equivalence relation.
</p>
<h3><span id="System-specific_rules">System-specific rules</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=8" title="Edit section: System-specific rules">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=8" title="Edit section: System-specific rules">edit source</a><span>]</span></span></h3>
<p>The systems of the λ-cube differ in what kinds of functions they allow. The kinds of functions under consideration are: functions from values to values; functions from types to values; functions from types to types; and functions from values to types. For each of these four types of functions, there is a rule to the effect that functions of that type exist.
</p><p>For example, the rule stating that functions from values to values exist reads as follows:
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5a643e5125dbcbbe9e2a455fafa2c10ec2eeddc4" aria-hidden="true" alt="{\displaystyle {\frac {\Gamma \vdash A:{\text{Type}}\quad \Gamma ,\ x:A\vdash B:{\text{Type}}}{\Gamma \vdash (x:A)\to B:{\text{Type}}}}}"/></span>
</p><p>The rule stating that functions from types to values exist reads as follows:
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/5f1decd1113be8a682281cc484e6d194cca44364" aria-hidden="true" alt="{\displaystyle {\frac {\Gamma \vdash A:{\text{Type}}_{1}\quad \Gamma ,\ x:A\vdash B:{\text{Type}}}{\Gamma \vdash (x:A)\to B:{\text{Type}}}}}"/></span>
</p><p>The difference between these rules is the sort of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span>; in the former rule, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span> is a <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> (a type of regular values), and in the latter rule, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span> is a <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span> (a type of types).
</p><p>The general pattern is that <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7daff47fa58cdfd29dc333def748ff5fa4c923e3" aria-hidden="true" alt="A"/></span> is a <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> for functions taking regular values, and a <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span> for functions taking types. Similarly, <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span> is a <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7ab98d8a984ca3a526098bdd672041558847d892" aria-hidden="true" alt="{\displaystyle {\text{Type}}}"/></span> for functions producing regular values, and a <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/98148554c52651675d4deb614b9a5436e56a8899" aria-hidden="true" alt="{\displaystyle {\text{Type}}_{1}}"/></span> for functions producing types. The sort of the resulting function type is the same as the sort of <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/47136aad860d145f75f3eed3022df827cee94d7a" aria-hidden="true" alt="B"/></span>.
</p><p>Now we describe the general pattern formally. Let <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/eb8baad278d51283e0ef3c99898d583cf2c8a8fd" aria-hidden="true" alt="{\displaystyle s_{1}}"/></span> and <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d4b9a7acc0ae8f54da4b7f4eef2c777d44faecd4" aria-hidden="true" alt="{\displaystyle s_{2}}"/></span> be sorts. The &#34;<span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/36e69e85cc25e90202a3d20fbceba7529e964391" aria-hidden="true" alt="{\displaystyle (s_{1},s_{2})}"/></span> rule&#34; is the rule:
</p><p><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7895cb7e9f8609a1469c3abfa8fb9116982673fb" aria-hidden="true" alt="{\displaystyle {\frac {\Gamma \vdash A:s_{1}\quad \Gamma ,\ x:A\vdash B:s_{2}}{\Gamma \vdash (x:A)\to B:s_{2}}}}"/></span>
</p><p>The systems of the λ-cube are differentiated by which of the <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/36e69e85cc25e90202a3d20fbceba7529e964391" aria-hidden="true" alt="{\displaystyle (s_{1},s_{2})}"/></span> rules they have. The following table describes the <span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/36e69e85cc25e90202a3d20fbceba7529e964391" aria-hidden="true" alt="{\displaystyle (s_{1},s_{2})}"/></span> rules of each system, and the feature each rule provides:
</p>
<table>

<tbody><tr>
<th>Feature:</th>
<th>Ordinary functions</th>
<th>Polymorphic types</th>
<th>Type constructors</th>
<th>Dependent types
</th></tr>
<tr>
<th>Rule:</th>
<th><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/33a0879b66b42d9089624e2bee42673d6414f89b" aria-hidden="true" alt="{\displaystyle ({\text{Type}},{\text{Type}})}"/></span></th>
<th><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/7c37850064ab1bdab36d9559342643121548b4c4" aria-hidden="true" alt="{\displaystyle ({\text{Type}}_{1},{\text{Type}})}"/></span></th>
<th><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/df2f73ed8214e2163d2e1a85f408eb01c5e8e2c1" aria-hidden="true" alt="{\displaystyle ({\text{Type}}_{1},{\text{Type}}_{1})}"/></span></th>
<th><span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/328a82cb4ab2d30e454c843b15e767ed3fba33a0" aria-hidden="true" alt="{\displaystyle ({\text{Type}},{\text{Type}}_{1})}"/></span>
</th></tr>
<tr>
<td>λ→ (explicitly simply typed λ-calculus)
</td>
<td>Yes
</td>
<td>No
</td>
<td>No
</td>
<td>No
</td></tr>
<tr>
<td>λ2 (explicitly typed second-order λ-calculus)
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>No
</td>
<td>No
</td></tr>
<tr>
<td>λ<u>ω</u>
</td>
<td>Yes
</td>
<td>No
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>λP
</td>
<td>Yes
</td>
<td>No
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>λω
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>No
</td></tr>
<tr>
<td>λP2
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>No
</td>
<td>Yes
</td></tr>
<tr>
<td>λP<u>ω</u>
</td>
<td>Yes
</td>
<td>No
</td>
<td>Yes
</td>
<td>Yes
</td></tr>
<tr>
<td>λPω (calculus of constructions)
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td>
<td>Yes
</td></tr></tbody></table>
<h2><span id="Properties_of_the_calculi">Properties of the calculi</span><span><span>[</span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;veaction=edit&amp;section=9" title="Edit section: Properties of the calculi">edit</a><span> | </span><a href="https://blog.benjojo.co.uk/w/index.php?title=Foundations_of_Functional_Programming/The_%CE%BB-cube&amp;action=edit&amp;section=9" title="Edit section: Properties of the calculi">edit source</a><span>]</span></span></h2>
<p>All systems of the λ-cube have the following properties:
</p>

<!-- 
NewPP limit report
Parsed by mw1413
Cached time: 20220108105952
Cache expiry: 1814400
Reduced expiry: false
Complications: []
CPU time usage: 0.272 seconds
Real time usage: 0.335 seconds
Preprocessor visited node count: 926/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/500
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 5904/5000000 bytes
Number of Wikibase entities loaded: 0/400
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key enwikiversity:pcache:idhash:193283-0!canonical and timestamp 20220108105952 and revision id 2252346. Serialized with JSON.
 -->
</div></div>
  </body>
</html>
