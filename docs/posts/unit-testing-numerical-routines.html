<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buchanan.one/blog/testing-numerical-algorithms/">Original</a>
    <h1>Unit Testing Numerical Routines</h1>
    
    <div id="readability-page-1" class="page"><div>
    
<article>

<dl>
  <dt>Published</dt>
  <dd>2024-11-12</dd>
  <dt>Reading Time</dt>
  <dd>7 minutes.</dd>
</dl>
<h2 id="how-would-you-unit-test-this-function">How would you unit test this function?</h2>
<pre data-lang="c++"><code data-lang="c++"><span>std::tuple&lt;</span><span>double</span><span>, </span><span>double</span><span>, </span><span>double</span><span>&gt; </span><span>ecef_to_lla</span><span>(</span><span>const</span><span> Eigen::Vector3d</span><span>&amp; </span><span>position_ecef_m);
</span></code></pre>
<p>This prototype takes a position expressed as cartesian coordinates in the
<a href="https://en.wikipedia.org/wiki/Earth-centered,_Earth-fixed_coordinate_system">Earth Centered, Earth Fixed (ECEF)</a>
reference frame and converts it into latitude, longitude, and altitude. If you are not familiar with aerospace
coordinate systems you will still be able to follow along. Think of it as a fancy cartesian to spherical
coordinate transform.</p>
<p>As a prudent programmer, you probably do not consider your code finished until
it has passed a rigorous set of unit tests. However, numerical routines such as
this one present difficulties for unit testing. How can you be confident the
function is correct in general? What if you don&#39;t know the expected output? What
if the underlying algorithm changes?</p>
<h2 id="level-1-magic-numbers">Level 1: Magic Numbers</h2>
<p>Your first attempt at testing might be to pull out an existing script and
copy-paste the inputs and expected results into your unit test. For our routine,
you might use <a href="https://www.oc.nps.edu/oc2902w/coord/llhxyz.htm">this website</a>.
You might create something like this:</p>
<pre data-lang="c++"><code data-lang="c++"><span>TEST_CASE(</span><span>&#34;Check ecef_to_lla against web-app result&#34;</span><span>, </span><span>&#34;[magic numbers]&#34;</span><span>) {
</span><span>  </span><span>// Input point, reversed from output using
</span><span>  </span><span>// https://www.oc.nps.edu/oc2902w/coord/llhxyz.htm
</span><span>  </span><span>const</span><span> Eigen::Vector3d pos{</span><span>1318610.</span><span>, </span><span>-</span><span>4504041.</span><span>, </span><span>4306196.</span><span>};
</span><span>
</span><span>  </span><span>// Do calculation
</span><span>  </span><span>const auto </span><span>[lat, lon, alt] </span><span>= </span><span>ecef_to_lla(pos);
</span><span>
</span><span>  </span><span>// Check results to 0.001 degrees and 1m
</span><span>  REQUIRE_THAT(lat, WithinAbs(</span><span>42.730</span><span>, </span><span>0.001</span><span>));
</span><span>  REQUIRE_THAT(lon, WithinAbs(</span><span>-</span><span>73.682</span><span>, </span><span>0.001</span><span>));
</span><span>  REQUIRE_THAT(alt, WithinAbs(</span><span>1000.0</span><span>, </span><span>1.</span><span>));
</span><span>}
</span></code></pre>
<p>This is certainly better than not having a test. If the script
used to generate the test case is trusted and stable, it&#39;s a great way
to verify you meet requirements. However, if the algorithm is unstable, it
may be difficult to maintain. Which version of <code>c_ECEF2geo_final_v2.m</code>
did you use to make this unit test? It also doesn&#39;t help if your
original implementation was wrong.</p>
<h2 id="level-2-trivial-points">Level 2: Trivial Points</h2>
<p>Instead of focusing on input-output pairs, let&#39;s make sure the function is
returning results that make sense. This requires you to build an intuitive
understanding of the system under test.</p>
<p>For example, we know that by definition the x-axis of the ECEF coordinate
system must pass through the point at the intersection of the equatorial
plane and the prime meridian. We also know that because this point lies
on the equator, it must have a distance from the earth&#39;s center equal
to the ellipsoid&#39;s semi-major axis. We can construct such a point, and
assert it lands where expected.</p>
<pre data-lang="c++"><code data-lang="c++"><span>TEST_CASE(</span><span>&#34;Point at the intersection of the ellipsoid and the x-axis&#34;</span><span>,
</span><span>          </span><span>&#34;[hand calculations]&#34;</span><span>) {
</span><span>  </span><span>// Point on the ellipsoid at y=0 and z=0
</span><span>  </span><span>const</span><span> Eigen::Vector3d pos{semi_major_axis_m, </span><span>0</span><span>, </span><span>0</span><span>};
</span><span>
</span><span>  </span><span>// Do calculation
</span><span>  </span><span>const auto </span><span>[lat, lon, alt] </span><span>= </span><span>ecef_to_lla(pos);
</span><span>
</span><span>  </span><span>// Check results are at the intersection of prime meridian and equator.
</span><span>  REQUIRE_THAT(lat, WithinAbs(</span><span>0.0</span><span>, </span><span>0.001</span><span>));
</span><span>  REQUIRE_THAT(lon, WithinAbs(</span><span>0.0</span><span>, </span><span>0.001</span><span>));
</span><span>  REQUIRE_THAT(alt, WithinAbs(</span><span>0.0</span><span>, </span><span>1.0</span><span>));
</span><span>}
</span></code></pre>
<p>Other points worth testing might be the North Pole and points directly above
those other points. The key here is to look for inputs where the output can be
trivially derived. Zeros are a good place to start.</p>
<p>Trivial points are great for developing an understanding, but it is still
possible for errors to be lurking in the points you do not test.</p>
<h2 id="level-3-property-based-testing">Level 3: Property-Based Testing</h2>
<p>What if we could automatically check trivial points over a wide variety of inputs?
Unit testing frameworks like Catch2 allow this with property-based testing.
The idea is to generate random input, and then assert that some property of the
output holds, rather than checking for specific output.</p>
<p>For example, the sign of a point&#39;s latitude is controlled entirely by the sign
of its Z coordinate. Using the <code>GENERATE</code> macro, we can pick random points
to test this property on.</p>
<pre data-lang="c++"><code data-lang="c++"><span>TEST_CASE(</span><span>&#34;Latitude has correct sign&#34;</span><span>, </span><span>&#34;[property based]&#34;</span><span>) {
</span><span>  </span><span>constexpr int</span><span> N </span><span>= </span><span>10</span><span>;
</span><span>  </span><span>const double</span><span> z </span><span>=
</span><span>      GENERATE(take(N, random(</span><span>-</span><span>semi_major_axis_m, semi_major_axis_m)));
</span><span>
</span><span>  </span><span>// This code is reached 10 times, with z taking on a random value each time
</span><span>}
</span></code></pre>
<p><code>const double z = GENERATE(...)</code> tells Catch to create new unit tests
with <code>z</code> taking on different values based on the rules inside the macro.</p>
<p>These rules are called generators, and they are composable. Here <code>take(N, ...)</code> is a generator
that returns the first <code>N</code> values from another generator. We use this because we do not want an infinite
number of examples.</p>
<p>Next, <code>random(min, max)</code> generates random numbers between <code>min</code> and <code>max</code>. We
choose, somewhat arbitrarily, to generate points that are between the top and
bottom of the earth (approximately). The full test follows:</p>
<pre data-lang="c++"><code data-lang="c++"><span>TEST_CASE(</span><span>&#34;Latitude has correct sign&#34;</span><span>, </span><span>&#34;[property based]&#34;</span><span>) {
</span><span>  </span><span>const double</span><span> z </span><span>=
</span><span>      GENERATE(take(</span><span>10</span><span>, random(</span><span>-</span><span>semi_major_axis_m, semi_major_axis_m)));
</span><span>
</span><span>  </span><span>// this code is reached 10 times, with z taking on a random value each time
</span><span>
</span><span>  </span><span>const double</span><span> x </span><span>= </span><span>1318610.</span><span>;
</span><span>  </span><span>const double</span><span> y </span><span>= -</span><span>4504041.</span><span>;
</span><span>
</span><span>  </span><span>// Do computation
</span><span>  </span><span>const auto </span><span>[lat, lon, alt] </span><span>= </span><span>ecef_to_lla({x, y, z});
</span><span>
</span><span>  </span><span>// Check the property that `lat` and `z` have the same sign
</span><span>  REQUIRE(std::</span><span>signbit</span><span>(lat) </span><span>== </span><span>std::</span><span>signbit</span><span>(z));
</span><span>}
</span></code></pre>
<p>Finding these properties requires an understanding of your function,
but developing that understanding is essential for writing correct code. For
conversion functions like this, it can often be helpful to assert that composition with
the inverse (<code>ecef_to_lla(lla_to_ecef(...))</code>) yields the identity.</p>
<p>It is also important for these properties to hold true for all implementations
that meet your requirements. They should be based in math or physics, rather
than your implementation.</p>
<h2 id="level-4-checking-against-a-specification">Level 4: Checking Against a Specification</h2>
<p>If you are lucky, you can test against a specification. In this case, the WGS84
ellipsoid and the ECEF frame derived from it are defined by the National
Geospatial-Intelligence Agency in
<a href="https://nsgreg.nga.mil/doc/view?i=4085">NGA.STND.0036_1.0.0_WGS84</a>. Using a
specification is very similar to the magic number technique, but instead of coming
from a poorly change-controlled matlab script, it comes from a peer-reviewed
standard.</p>
<p>The WGS84 specification contains a list of reference stations, with their positions given in
ECEF and LLA coordinates. We will test the implementation against these values.</p>
<p>The most basic usage of <code>GENERATE</code> is to give it a comma-separated list of values
you want your variable to take on. Here, we give it a list of tuples containing the
name, ECEF coordinates, latitude, longitude, and ellipsoid height of each station.</p>
<pre data-lang="c++"><code data-lang="c++"><span>TEST_CASE(</span><span>&#34;Test against WGS84 Reference Stations&#34;</span><span>, </span><span>&#34;[spec]&#34;</span><span>) {
</span><span>  </span><span>using</span><span> Catch::Matchers::WithinAbs;
</span><span>
</span><span>  </span><span>// Air Force Reference Station Locations from NGA.STND.0036_1.0.0_WGS84
</span><span>  </span><span>const auto </span><span>[name, x, y, z, lat_spec, lon_spec, alt_spec] </span><span>= </span><span>GENERATE(
</span><span>      std::make_tuple(</span><span>&#34;Colorado Springs&#34;</span><span>, </span><span>-</span><span>1248599.695</span><span>, </span><span>-</span><span>4819441.002</span><span>,
</span><span>                      </span><span>3976490.117</span><span>, </span><span>38.80293817</span><span>, </span><span>255.47540411</span><span>, </span><span>1911.778</span><span>),
</span><span>      std::make_tuple(</span><span>&#34;Ascension&#34;</span><span>, </span><span>6118523.866</span><span>, </span><span>-</span><span>1572350.772</span><span>, </span><span>-</span><span>876463.909</span><span>,
</span><span>                      </span><span>-</span><span>7.95132931</span><span>, </span><span>345.58786964</span><span>, </span><span>106.281</span><span>),
</span><span>      std::make_tuple(</span><span>&#34;Diego Garcia&#34;</span><span>, </span><span>1916196.855</span><span>, </span><span>6029998.797</span><span>, </span><span>-</span><span>801737.183</span><span>,
</span><span>                      </span><span>-</span><span>7.26984216</span><span>, </span><span>72.37092367</span><span>, </span><span>-</span><span>64.371</span><span>),
</span><span>      std::make_tuple(</span><span>&#34;Kwajalein&#34;</span><span>, </span><span>-</span><span>6160884.028</span><span>, </span><span>1339852.169</span><span>, </span><span>960843.154</span><span>,
</span><span>                      </span><span>8.72250188</span><span>, </span><span>167.73052378</span><span>, </span><span>39.652</span><span>),
</span><span>      std::make_tuple(</span><span>&#34;Hawaii&#34;</span><span>, </span><span>-</span><span>5511980.264</span><span>, </span><span>-</span><span>2200246.752</span><span>, </span><span>2329481.004</span><span>,
</span><span>                      </span><span>21.56149239</span><span>, </span><span>201.76066695</span><span>, </span><span>425.789</span><span>),
</span><span>      std::make_tuple(</span><span>&#34;Cape Canaveral&#34;</span><span>, </span><span>918988.062</span><span>, </span><span>-</span><span>5534552.894</span><span>, </span><span>3023721.362</span><span>,
</span><span>                      </span><span>28.48373823</span><span>, </span><span>279.42769502</span><span>, </span><span>-</span><span>24.083</span><span>));
</span><span>
</span><span>  </span><span>// NGA data uses longitude east, even for the western hemisphere. Wrap that to
</span><span>  </span><span>// have negative degrees
</span><span>  </span><span>const auto</span><span> lon_spec_wrapped </span><span>=</span><span> lon_spec </span><span>&gt; </span><span>180 </span><span>?</span><span> lon_spec </span><span>- </span><span>360 </span><span>:</span><span> lon_spec;
</span><span>
</span><span>  </span><span>// Compute the latitude, longitude and ellipsoid height
</span><span>  </span><span>const auto </span><span>[lat_computed, lon_computed, alt_computed] </span><span>=
</span><span>      ecef_to_lla({x, y, z});
</span><span>
</span><span>  </span><span>// Check that the results match the spec values
</span><span>  REQUIRE_THAT(lat_computed, WithinAbs(lat_spec, </span><span>1e-6</span><span>));
</span><span>  REQUIRE_THAT(lon_computed, WithinAbs(lon_spec_wrapped, </span><span>1e-6</span><span>));
</span><span>  REQUIRE_THAT(alt_computed, WithinAbs(alt_spec, </span><span>0.1</span><span>));
</span><span>}
</span></code></pre>
<p>You are of course lucky if your outputs are so well defined. For most
routines, you will have to fall back on the previous techniques. With
a good set of sanity checks, you will save time and money when
it comes to performing Verification &amp; Validation. In fact, the more of your
Verification &amp; Validation plan that can be written up as unit tests, and
integrated into your CI/CD pipeline, the faster your subject matter experts
and software engineers will be able to iterate.</p>
<hr/>



</article>

  </div></div>
  </body>
</html>
