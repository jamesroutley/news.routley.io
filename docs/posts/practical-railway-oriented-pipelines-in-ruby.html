<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ismaelcelis.com/posts/practical-railway-oriented-pipelines-in-ruby/">Original</a>
    <h1>Practical Railway-Oriented Pipelines in Ruby</h1>
    
    <div id="readability-page-1" class="page"><section><p>Some years ago I <a href="https://ismaelcelis.com/posts/composable-pipelines-in-ruby/">explored patterns</a> for building composable processing pipelines in Ruby, using a Railway-oriented paradigm.</p>
<p>Here, I describe a simplified implementation for practical use.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span># An illustrative data processing pipeline</span>
<span>DataImporter</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>ExtractData</span>
  pl<span>.</span>step <span>TransformData</span>
  pl<span>.</span>step <span>LoadData</span>
<span>end</span>
</code></pre></div><p>I’ve relied on versions of this approach in various projects for some time now, and I’ve found it to be a very effective way to build and maintain complex data processing workflows.</p>
<h2 id="the-result-class">The result class</h2>
<p>A generic <code>Result</code> wraps values passed through the pipeline, and can be in one of two states: <code>Continue</code> or <code>Halt</code>.
The values themselves can be anything relevant to the domain, but <code>Result</code> offers a consistent interface for handling them in the pipeline, as well as metadata such as user input, errors and arbitrary context.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span># Initial result</span>
result <span>=</span> <span>Result</span><span>.</span>continue(<span>[</span><span>1</span>, <span>2</span>, <span>3</span>, <span>4</span><span>]</span>)
result<span>.</span>input <span># {}</span>
result<span>.</span>errors <span># {}</span>
result<span>.</span>context <span># {}</span>
result<span>.</span>continue? <span># =&gt; true</span>
result <span>=</span> result<span>.</span>halt
result<span>.</span>continue? <span># =&gt; false</span>
</code></pre></div><p><code>Result</code> instances can be initialised or copied to add input, errors or context data.</p>
<div><pre tabindex="0"><code data-lang="ruby">result <span>=</span> <span>Result</span><span>.</span>continue(<span>[</span><span>1</span>, <span>2</span>, <span>3</span>, <span>4</span><span>]</span>, <span>input</span>: { <span>limit</span>: <span>2</span> })
result<span>.</span>input <span># { limit: 2 }</span>
<span># Produce a new Result with some context data.</span>
result <span>=</span> result<span>.</span>with_context(<span>:count</span>, <span>4</span>)
result<span>.</span>context<span>[</span><span>:count</span><span>]</span> <span>=</span> <span>4</span>
</code></pre></div><ul>
<li>The <code>input</code> Hash is meant to pass external user or system input relevant for processing.</li>
<li>The <code>errors</code> Hash is meant to accumulate errors during processing.</li>
<li>The <code>context</code> Hash is meant to pass arbitrary data between pipeline steps.</li>
</ul>
<p>Helper methods such as <code>#with_context</code> and <code>#with_error</code> as well as <code>#halt</code> and <code>#continue</code> work to help manipulate result instances as it moves through the pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby">result <span>=</span> result<span>.</span>halt<span>.</span>with_error(<span>:limit</span>, <span>&#34;Exceeded&#34;</span>)
<span># result.continue? =&gt; false</span>
<span># result.errors =&gt; { limit: &#34;Exceeded&#34; }</span>
</code></pre></div><h2 id="the-pipeline">The pipeline</h2>
<p>A pipeline is a sequence of steps that process a <code>Result</code> and return a new <code>Result</code>.
a <code>Step</code> is a simple object that responds to <code>#call</code> and takes a <code>Result</code> as input, returning a new <code>Result</code>.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>MyPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  <span># Anything that responds to #call can be a step</span>
  pl<span>.</span>step <span>MyCustomStep</span><span>.</span>new

  <span># Or a simple proc. This one limits the set by the :limit input</span>
  pl<span>.</span>step <span>do</span> <span>|</span>result<span>|</span>
    set <span>=</span> result<span>.</span>value<span>.</span>first(result<span>.</span>input<span>[</span><span>:limit</span><span>]</span>)
    result<span>.</span>continue(set)
  <span>end</span>
<span>end</span>

<span># Usage</span>
initial_result <span>=</span> <span>Result</span><span>.</span>continue((<span>1</span><span>..</span><span>100</span>), <span>input</span>: { <span>limit</span>: <span>5</span> })
result <span>=</span> <span>MyPipeline</span><span>.</span>call(initial_result)
result<span>.</span>value <span># =&gt; [1, 2, 3, 4, 5]</span>
</code></pre></div><p>There’s very little to the <code>Pipeline</code> class itself.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>Pipeline</span>
  <span>attr_reader</span> <span>:steps</span>

  <span>def</span> <span>initialize</span>(<span>&amp;</span>block)
    @steps <span>=</span> <span>[]</span>
    block<span>.</span>call(self) <span>and</span> @steps<span>.</span>freeze <span>if</span> block_given?
  <span>end</span>

  <span>def</span> <span>step</span>(callable, <span>&amp;</span>block)
    callable <span>||=</span> block
    <span>raise</span> <span>ArgumentError</span>, <span>&#34;Step must respond to #call&#34;</span> <span>unless</span> callable<span>.</span>respond_to?(<span>:call</span>)
    steps <span>&lt;&lt;</span> callable
    self
  <span>end</span>

  <span># Iterate steps, call each one in turn,</span>
  <span># passing the result of the previous step to the next.</span>
  <span>def</span> <span>call</span>(result)
    steps<span>.</span>reduce(result) { <span>|</span>r, step<span>|</span> step<span>.</span>call(r) }
  <span>end</span>
<span>end</span>
</code></pre></div><h2 id="the-railway-bit">The Railway bit</h2>
<p>Where this becomes useful is in the ability to “halt” processing at any point in the pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>MyPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  <span># This step halts processing if the set size is greater than 100</span>
  pl<span>.</span>step <span>do</span> <span>|</span>result<span>|</span>
    <span>if</span> result<span>.</span>value<span>.</span>size <span>&gt;</span> <span>100</span>
      <span>return</span> result<span>.</span>halt<span>.</span>with_error(<span>:value</span>, <span>&#34;Too many elements&#34;</span>)
    <span>end</span>
    result
  <span>end</span>

  <span># This step should never be called if the previous one halted the result</span>
  pl<span>.</span>step <span>do</span> <span>|</span>result<span>|</span>
    result<span>.</span>continue(result<span>.</span>value<span>.</span>map { <span>|</span>n<span>|</span> n <span>*</span> <span>2</span> })
  <span>end</span>
<span>end</span>
</code></pre></div><p>To make this work, we just need to make a small tweak to the <code>#call</code> method in the <code>Pipeline</code> class.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>def</span> <span>call</span>(result)
  steps<span>.</span>reduce(result) <span>do</span> <span>|</span>r, step<span>|</span>
    <span># If the result is halted, return it untouched.</span>
    r<span>.</span>continue? ? step<span>.</span>call(r) : r
  <span>end</span>
<span>end</span>
</code></pre></div><p>Now, any step that returns a <em>halt</em> will just skip further steps downstream. Lets do some number crunching:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span># A portable step to validate set size</span>
<span>class</span> <span>ValidateSetSize</span>
  <span>def</span> <span>initialize</span>(<span>lte</span>:) <span>=</span> @lte <span>=</span> lte

  <span>def</span> <span>call</span>(result)
    <span>return</span> result<span>.</span>halt<span>.</span>with_error(<span>:value</span>, <span>&#34;Too many elements&#34;</span>) <span>if</span> result<span>.</span>value<span>.</span>size <span>&gt;</span> @lte
    result
  <span>end</span>
<span>end</span>

<span># A step to multiply each number in the set by a factor</span>
<span># This one is a Proc that returns a Proc.</span>
<span>MultiplyBy</span> <span>=</span> proc <span>do</span> <span>|</span>factor<span>|</span>
  proc <span>do</span> <span>|</span>result<span>|</span>
    result<span>.</span>continue(result<span>.</span>value<span>.</span>map { <span>|</span>n<span>|</span> n <span>*</span> factor })
  <span>end</span>
<span>end</span>

<span># A step to limit the set to the first N elements, as per input[:limit]</span>
<span>LimitSet</span> <span>=</span> proc <span>do</span> <span>|</span>result<span>|</span>
  set <span>=</span> result<span>.</span>value<span>.</span>first(result<span>.</span>input<span>[</span><span>:limit</span><span>]</span>)
  result<span>.</span>continue(set)
<span>end</span>

<span># Compose the pipeline</span>
<span>NumberCruncher</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>ValidateSetSize</span><span>.</span>new(<span>lte</span>: <span>100</span>)
  pl<span>.</span>step <span>MultiplyBy</span><span>.</span>(<span>2</span>)
  pl<span>.</span>step <span>LimitSet</span>
<span>end</span>
</code></pre></div><p>In this example, the first <code>ValidateSetSize</code> step will halt the pipeline if the set size is greater than 100, preventing <code>MultiplyBy</code> and <code>LimitSet</code> steps from running.</p>
<div><pre tabindex="0"><code data-lang="ruby">initial_result <span>=</span> <span>Result</span><span>.</span>continue((<span>1</span><span>..</span><span>101</span>), <span>input</span>: { <span>limit</span>: <span>5</span> })
result <span>=</span> <span>NumberCruncher</span><span>.</span>call(initial_result)
result<span>.</span>continue? <span># =&gt; false</span>
result<span>.</span>errors <span># =&gt; { value: &#34;Too many elements&#34; }</span>
</code></pre></div>
<ul>
    <li>1. <code>ValidateSetSize.new(lte: 100)</code></li>
    <li>2. <code>MultiplyBy.(2)</code></li>
    <li>3. <code>LimitSet</code></li>
</ul>
<p>However, if all steps return a <em>continue</em> result, the pipeline processes all steps and returns the final result.</p>
<div><pre tabindex="0"><code data-lang="ruby">initial_result <span>=</span> <span>Result</span><span>.</span>continue((<span>1</span><span>..</span><span>99</span>), <span>input</span>: { <span>limit</span>: <span>5</span> })
result <span>=</span> <span>MyPipeline</span><span>.</span>call(initial_result)
result<span>.</span>continue? <span># =&gt; true</span>
<span># Each number in set was multiplied by 2, then limited to the first 5</span>
result<span>.</span>value <span># =&gt; [2, 4, 6, 8, 10]</span>
</code></pre></div><ul>
    <li>1. <code>ValidateSetSize.new(lte: 100)</code></li>
    <li>2. <code>MultiplyBy.(2)</code></li>
    <li>3. <code>LimitSet</code></li>
</ul>
<h2 id="composing-pipelines">Composing pipelines</h2>
<p>Since <code>Pipeline</code> itself implements the <code>#call(Result) Result</code> interface, it can be used as a step in another pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>BigPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>Step1</span> <span># a regular step</span>
  pl<span>.</span>step <span>NumberCruncher</span> <span># a nested pipeline</span>
  pl<span>.</span>step <span>Step3</span> <span># another regular step</span>
<span>end</span>
</code></pre></div><p>This allows “packaging up” complex processing workflows into reusable components, where each component can be composed of multiple steps if need be.
It’s also possible to have factory methods that parameterise the creation of pipelines.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span># A component to validate and coerce a set of numbers</span>
<span># It returns a 2-step pipeline that can be composed into a larger pipeline</span>
<span>module</span> NumberValidation
  <span>def</span> <span>self</span><span>.</span><span>new</span>(<span>lte</span>:)
    <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
      pl<span>.</span>step <span>ValidateSetSize</span><span>.</span>new(<span>lte</span>: lte)
      pl<span>.</span>step <span>CoerceToIntegers</span>
    <span>end</span>
  <span>end</span>

  <span>CoerceToIntegers</span> <span>=</span> proc <span>do</span> <span>|</span>result<span>|</span>
    result<span>.</span>continue(result<span>.</span>value<span>.</span>map(<span>&amp;</span><span>:to_i</span>))
  <span>end</span>
<span>end</span>

<span># Compose a larger pipeline</span>
<span>BigPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>Step1</span>
  pl<span>.</span>step <span>NumberValidation</span><span>.</span>new(<span>lte</span>: <span>100</span>) <span># a nested pipeline</span>
  pl<span>.</span>step <span>Step3</span>
<span>end</span>
</code></pre></div><p>Pipelines can also be used internally by custom classes.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>NumberValidation</span>
  <span>def</span> <span>initialize</span>(<span>lte</span>:)
    @pipeline <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
      pl<span>.</span>step <span>ValidateSetSize</span><span>.</span>new(<span>lte</span>: lte)
      <span># Use a Method object as step</span>
      pl<span>.</span>step method(<span>:coerce_to_integers</span>)
    <span>end</span>
  <span>end</span>

  <span># The Step interface</span>
  <span>def</span> <span>call</span>(result) <span>=</span> @pipeline<span>.</span>call(result)

  <span>private</span> <span>def</span> <span>coerce_to_integers</span>(result)
    result<span>.</span>continue(result<span>.</span>value<span>.</span>map(<span>&amp;</span><span>:to_i</span>))
  <span>end</span>
<span>end</span>
</code></pre></div><p>Which approach to use will depend on each step’s internals. Other than the simple <code>#call</code> interface, steps are effective black boxes and refactoring them is straightforward.</p>
<h2 id="extending-the-pipeline">Extending the pipeline</h2>
<p>The <code>Pipeline</code> class itself can be subclassed or extended to add domain-specific functionality. One that I’ve found helpful is to add a terse DSL for input validation.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>NumberCruncher</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  <span># the #input helper adds a step to validate input</span>
  pl<span>.</span>input <span>do</span>
    field(<span>:limit</span>)<span>.</span>type(<span>:integer</span>)<span>.</span>required<span>.</span>default(<span>5</span>)
    field(<span>:lte</span>)<span>.</span>type(<span>:integer</span>)<span>.</span>required
  <span>end</span>

  <span># ... other steps here</span>
<span>end</span>
</code></pre></div><p>All <code>#input</code> does is register a step using a specialised class that knows how to validate input. That class exposes the <code>#call(Result) Result</code> interface, and halts the pipeline if input is invalid.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>Pipeline</span>
  <span># ... etc</span>

  <span>def</span> <span>input</span>(<span>&amp;</span>block)
    step <span>InputValidator</span><span>.</span>new(<span>&amp;</span>block)
  <span>end</span>
<span>end</span>
</code></pre></div><p>I use my <a href="https://github.com/ismasan/parametric">Parametric</a> gem for this, but anything that makes sense for your domain will do. <a href="https://dry-rb.org/gems/dry-types/">Dry::Types</a> is another good option. Or Rails&#39; <a href="https://api.rubyonrails.org/classes/ActiveModel/Validations.html">ActiveModel::Validations</a> if you’re in a Rails app.</p>
<p>This means that complex operations can now be packaged up and validate their own inputs.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span># A portable step to multiply each number in the set by a factor.</span>
<span>Multiplier</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>input <span>do</span>
    field(<span>:factor</span>)<span>.</span>type(<span>:integer</span>)<span>.</span>required<span>.</span>default(<span>1</span>)
  <span>end</span>

  pl<span>.</span>step <span>do</span> <span>|</span>result<span>|</span>
    factor <span>=</span> result<span>.</span>input<span>[</span><span>:factor</span><span>]</span>
    result<span>.</span>continue(result<span>.</span>value<span>.</span>map { <span>|</span>n<span>|</span> n <span>*</span> factor })
  <span>end</span>
<span>end</span>

<span># A portable step to limit the set to the first N elements.</span>
<span># It defines its own required input.</span>
<span>Limiter</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>input <span>do</span>
    field(<span>:limit</span>)<span>.</span>type(<span>:integer</span>)<span>.</span>required<span>.</span>default(<span>5</span>)
  <span>end</span>

  pl<span>.</span>step <span>do</span> <span>|</span>result<span>|</span>
    set <span>=</span> result<span>.</span>value<span>.</span>first(result<span>.</span>input<span>[</span><span>:limit</span><span>]</span>)
    result<span>.</span>continue(set)
  <span>end</span>
<span>end</span>
</code></pre></div><div><pre tabindex="0"><code data-lang="ruby"><span>NumberCruncher</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>NumberValidation</span><span>.</span>new(<span>lte</span>: <span>100</span>)
  pl<span>.</span>step <span>Multiplier</span>
  pl<span>.</span>step <span>Limiter</span>
<span>end</span>
</code></pre></div><p>I use helper methods to simplify domain-specific pipelines. Some other examples include:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>MyPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  <span># A helper to filter elements in a set.</span>
  <span># Returns a new [Result] with the filtered set.</span>
  pl<span>.</span>filter <span>do</span> <span>|</span>element<span>|</span>
    element <span>&gt;</span> <span>10</span>
  <span>end</span>

  <span># A helper to sort elements in a set</span>
  pl<span>.</span>sort <span>do</span> <span>|</span>a, b<span>|</span>
    a <span>&lt;=&gt;</span> b
  <span>end</span>

  <span># A development helper to invoke a Byebug or Pry session at this point</span>
  pl<span>.</span>debugger
<span>end</span>
</code></pre></div><p>For most, the implementation is trivial.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>def</span> <span>filter</span>(<span>&amp;</span>block)
  step <span>do</span> <span>|</span>result<span>|</span>
    set <span>=</span> result<span>.</span>value<span>.</span>filter(<span>&amp;</span>block)
    result<span>.</span>continue(set)
  <span>end</span>
<span>end</span>

<span>def</span> <span>sort</span>(<span>&amp;</span>block)
  step <span>do</span> <span>|</span>result<span>|</span>
    set <span>=</span> result<span>.</span>value<span>.</span>sort(<span>&amp;</span>block)
    result<span>.</span>continue(set)
  <span>end</span>
<span>end</span>

<span>def</span> <span>debugger</span>
  step <span>do</span> <span>|</span>result<span>|</span>
    binding<span>.</span>pry
    result
  <span>end</span>
<span>end</span>
</code></pre></div><h2 id="tracing-step-positions">Tracing step positions</h2>
<p>As workflows become more complex, it’s helpful to have ways to trace and instrospect execution.
For example, when a step halts the pipeline, I would like to know exactly what step it was, and at what depth in the pipeline it sits.</p>
<p>Well deal with the latter first. The following tweaks <code>Pipeline#call</code> to keep track of the current step position relative to its parent pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>Pipeline</span>
  <span># ... etc</span>

  <span># For each step, keep track of its position in the pipeline</span>
  <span># in the result context.</span>
  <span>def</span> <span>call</span>(result)
    trace <span>=</span> result<span>.</span>context<span>[</span><span>:trace</span><span>]</span> <span>||</span> <span>[]</span>
    steps<span>.</span>each<span>.</span>with_index(<span>1</span>)<span>.</span>reduce(result) <span>do</span> <span>|</span>res, (step, position)<span>|</span>
      <span>if</span> res<span>.</span>continue?
        step<span>.</span>call(res<span>.</span>with_context(<span>:trace</span>, trace <span>+</span> <span>[</span>position<span>]</span>))
      <span>else</span>
        res
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div><p>With this, the <code>Result</code> instance passed to each step will have a <code>:trace</code> key in its context, which is an array of integers representing the position of the step in the pipeline.</p>
<p>For example:</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>OkStep</span> <span>=</span> <span>-&gt;</span>(result) { result<span>.</span>continue }

<span>FailStep</span> <span>=</span> <span>-&gt;</span>(result) { result<span>.</span>halt }

<span>ChildPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>OkStep</span>
  pl<span>.</span>step <span>FailedStep</span> <span># &lt;- this one halts the pipeline</span>
  pl<span>.</span>step <span>OkStep</span>
<span>end</span>

<span>BigPipeline</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  pl<span>.</span>step <span>OkStep</span>
  pl<span>.</span>step <span>OkStep</span>
  pl<span>.</span>step <span>ChildPipeline</span> <span># &lt;- 2nd step in this pipeline halts</span>
  pl<span>.</span>step <span>OkStep</span>
<span>end</span>
</code></pre></div><p><code>FailedStep</code> inside the child pipeline will be the last step in the trace, and <code>#context[:trace]</code> will be <code>[3, 2]</code>, because it’s the third step in the child pipeline, and the child pipeline is the second step in the parent pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby">result <span>=</span> <span>BigPipeline</span><span>.</span>call(<span>Result</span><span>.</span>continue)
result<span>.</span>continue? <span># =&gt; false</span>
result<span>.</span>context<span>[</span><span>:trace</span><span>]</span> <span># =&gt; [3, 2]</span>
</code></pre></div><p>In other words:</p>
<ul>
    <li>[1] <code>OkStep</code></li>
    <li>[2] <code>OkStep</code></li>
    <li>
        [3] <code>ChildPipeline</code>
        <ul>
            <li>[3,1] <code>OkStep</code></li>
            <li>[3,2] <code>FailedStep</code></li>
            <li>[3,3] <code>OkStep</code></li>
        </ul>
    </li>
    <li>[4] <code>OkStep</code></li>
</ul>
<h2 id="middleware">Middleware</h2>
<p>Now we’ll add <code>context[:halted_step]</code> to the <code>Result</code> instance, so that we know exactly what step halted the pipeline.
For that, we’ll use a middleware approach. We’ll tweak <code>Pipeline#step</code> to wrap all registered steps with a middleware that adds the <code>halted_step</code> to the result context if the step halts the pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>Pipeline</span>
  <span># ... etc</span>

  <span>def</span> <span>step</span>(callable, <span>&amp;</span>block)
    callable <span>||=</span> block
    <span>raise</span> <span>ArgumentError</span>, <span>&#34;Step must respond to #call&#34;</span> <span>unless</span> callable<span>.</span>respond_to?(<span>:call</span>)

    <span># Wrap the step with a middleware</span>
    callable <span>=</span> <span>StepTracker</span><span>.</span>new(callable)
    steps <span>&lt;&lt;</span> callable
    self
  <span>end</span>
<span>end</span>
</code></pre></div><p>A middleware step wraps around the execution of another step.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>StepTracker</span> <span>&lt;</span> <span>SimpleDelegator</span>
  <span>def</span> <span>call</span>(result)
    step <span>=</span> __getobj__
    result <span>=</span> step<span>.</span>call(result)
    <span>return</span> result<span>.</span>with_context(<span>:halted_step</span>, step) <span>unless</span> result<span>.</span>continue?
    result
  <span>end</span>
<span>end</span>
</code></pre></div><p>Now, <code>context[:halted_step]</code> will be set to the step that halted the pipeline, and <code>context[:trace]</code> will be set to the position of that step in the pipeline.</p>
<div><pre tabindex="0"><code data-lang="ruby">result <span>=</span> <span>BigPipeline</span><span>.</span>call(<span>Result</span><span>.</span>continue)
result<span>.</span>continue? <span># =&gt; false</span>
result<span>.</span>context<span>[</span><span>:halted_step</span><span>]</span> <span># =&gt; FailedStep</span>
result<span>.</span>context<span>[</span><span>:trace</span><span>]</span> <span># =&gt; [3, 2]</span>
</code></pre></div><p>Note that the same middleware approach can be used to add other tracing and introspection features to the pipeline. Some examples:</p>
<div><pre tabindex="0"><code data-lang="ruby">callable <span>=</span> <span>Instrumentation</span><span>.</span>new(callable)
callable <span>=</span> <span>Logging</span><span>.</span>new(callable, <span>Rails</span><span>.</span>logger)
callable <span>=</span> <span>StepTracker</span><span>.</span>new(callable)
steps <span>&lt;&lt;</span> callable
</code></pre></div><p>It’s also possible to add class-level configuration to register middleware for <code>Pipeline</code> subclasses.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>MyPipeline</span> <span>&lt;</span> <span>Pipeline</span>
  middleware <span>Instrumentation</span><span>.</span>new(<span>api_key</span>: <span>ENV</span><span>.</span>fetch(<span>&#39;API_KEY&#39;</span>))
  middleware <span>Logging</span><span>.</span>new(<span>Rails</span><span>.</span>logger)
<span>end</span>
</code></pre></div><p>A framework-agnostic implementation for that is included in the <a href="https://gist.github.com/ismasan/0bdcc76c2ea48f4259b38fafe131edb8">code gist</a></p>
<blockquote>
<p>Middleware steps might look similar to regular steps, but they are not.
Each registered middleware step wraps around every regular step, including in nested pipelines.</p>
</blockquote>
<h2 id="clis">CLIs</h2>
<p>A CLI-tailored pipeline class can leverage step tracing to print step positions and halt reasons to the console.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>StepPrinter</span> <span>&lt;</span> <span>SimpleDelegator</span>
  <span>def</span> <span>call</span>(result)
    step <span>=</span> __getobj__
    position <span>=</span> result<span>.</span>context<span>[</span><span>:trace</span><span>].</span>join(<span>&#34;.&#34;</span>)
    result <span>=</span> step<span>.</span>call(result)
    status <span>=</span> result<span>.</span>success? ? <span>&#39;OK&#39;</span> : <span>&#39;ERROR&#39;</span>
    errors <span>=</span> result<span>.</span>errors<span>.</span>any? ? <span>&#34;Errors: </span><span>#{</span>result<span>.</span>errors<span>}</span><span>&#34;</span> : <span>&#34;&#34;</span>
    puts <span>&#34;</span><span>#{</span>position<span>}</span><span>. [</span><span>#{</span>status<span>}</span><span>] </span><span>#{</span>step<span>}</span><span> </span><span>#{</span>errors<span>}</span><span>&#34;</span>
    result
  <span>end</span>
<span>end</span>
</code></pre></div><pre tabindex="0"><code>1. [OK] InputStep
2. [OK] ParseCSV
3. [OK] ValidateCSV
3.1. [OK] ValidateHeaders
3.2. [ERROR] ValidateRows Errors: { 1: &#34;Invalid format&#34; }
</code></pre><h2 id="caching-middleware">Caching middleware</h2>
<p>A piece of middleware can optimise expensive operations by caching their results.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>class</span> <span>CachedStep</span> <span>&lt;</span> <span>SimpleDelegator</span>
  <span>def</span> <span>initialize</span>(step, cache)
    @cache <span>=</span> cache
    <span>super</span>(step)
  <span>end</span>

  <span>def</span> <span>call</span>(result)
    cache_key <span>=</span> result<span>.</span>value<span>.</span>hash <span># or something else</span>
    <span># Only call expensive operation if not in cache</span>
    <span># and store the result in the cache</span>
    @cache<span>.</span>fetch(cache_key) <span>do</span>
      __getobj__<span>.</span>call(result)
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div><ul>
    <li>1. <code>Expensive Operation 1</code><span>cached, skipped</span></li>
    <li>2. <code>Expensive Operation 2</code><span>cached, skipped</span></li>
    <li>3. <code>Expensive Operation 3</code><span>not cached, running</span></li>
    <li>4. <code>ExpensiveOperation4</code><span>pending</span></li>
</ul>
<p>Caching can also be controlled selectively for one or more steps, via a custom sub-pipeline and a helper method.</p>
<div><pre tabindex="0"><code data-lang="ruby">pl<span>.</span>step <span>OkStep</span>
pl<span>.</span>cached <span>do</span> <span>|</span>ch<span>|</span>
  ch<span>.</span>step <span>ExpensiveStep</span>
  ch<span>.</span>step <span>AnotherExpensiveStep</span>
<span>end</span>
pl<span>.</span>step <span>OkStep</span>
</code></pre></div><h2 id="other-use-cases">Other use cases</h2>
<p>I’ve found that these pipelines make it simple to assemble a wide range of processing workflows big and small. Most specialisation can be contained in the steps themselves, and the pipeline class can be kept simple and generic.</p>
<h3 id="query-builders">Query builders</h3>
<p>You can use it to build complex queries for databases or APIs.</p>
<div><pre tabindex="0"><code data-lang="ruby">pl<span>.</span>step <span>do</span> <span>|</span>result<span>|</span>
  query <span>=</span> result<span>.</span>value <span># An ActiveRecord::Relation or a Sequel::Dataset</span>
  account_id <span>=</span> result<span>.</span>input<span>[</span><span>:account_id</span><span>]</span>
  query <span>=</span> query<span>.</span>where(<span>account_id</span>:) <span>if</span> account_id
  result<span>.</span>continue(query)
<span>end</span>

<span># Composable query components</span>
pl<span>.</span>step <span>FullTextSearch</span>
</code></pre></div><h3 id="durable-execution">Durable execution</h3>
<p>You can use it to build durable execution workflows, where each step is a task that can be retried or rolled back.
This can be used to build robust and fault-tolerant operations. For example background jobs, or long-running <a href="https://learn.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga">sagas</a>.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>HolidayBookingSaga</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  <span># Custom middleware to store the result of last successful step</span>
  <span># In case of failure, the pipeline can be resumed from the last successful step</span>
  middleware <span>DurableExecution</span><span>.</span>new(<span>store</span>: <span>Redis</span><span>.</span>new)

  pl<span>.</span>step <span>BookFlights</span>
  pl<span>.</span>step <span>BookHotel</span>
  pl<span>.</span>step <span>BookCarRental</span>
  pl<span>.</span>step <span>SendConfirmationEmail</span>
<span>end</span>
</code></pre></div><h3 id="concurrent-execution">Concurrent execution</h3>
<p>It’s reasonably straightforward to build a pipeline that runs steps concurrently, for example to optimise I/O-bound operations.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>HolidayBookingSaga</span> <span>=</span> <span>Pipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
  <span># .. etc</span>

  <span># Run these steps concurrently, then collect their results in order.</span>
  <span># For example using Fibers or Threads.</span>
  <span># This block can implement _all_ or _any_ semantics.</span>
  pl<span>.</span>concurrent <span>do</span> <span>|</span>c<span>|</span>
    c<span>.</span>step <span>BookFlights</span>
    c<span>.</span>step <span>BookHotel</span>
    c<span>.</span>step <span>BookCarRental</span>
  <span>end</span>

  <span># Send email once all bookings are confirmed</span>
  pl<span>.</span>step <span>SendConfirmationEmail</span>
<span>end</span>
</code></pre></div><h3 id="http-handlers">HTTP handlers</h3>
<p>In Ruby we have plenty of incredible web frameworks to choose from, but a pipeline-oriented approach to web handling could be a good fit for some use cases. A bit like Elixir’s <a href="https://hexdocs.pm/plug/readme.html">Plug</a>.</p>
<div><pre tabindex="0"><code data-lang="ruby"><span>module</span> API
  <span>CreateUserHandler</span> <span>=</span> <span>HTTPPipeline</span><span>.</span>new <span>do</span> <span>|</span>pl<span>|</span>
    pl<span>.</span>input <span>do</span>
      field(<span>:name</span>)<span>.</span>type(<span>:string</span>)<span>.</span>required
      field(<span>:email</span>)<span>.</span>type(<span>:string</span>)<span>.</span>required
    <span>end</span>

    pl<span>.</span>step <span>ValidateUserInput</span>
    pl<span>.</span>step <span>CreateUser</span>
    pl<span>.</span>step <span>SendWelcomeEmail</span>
    pl<span>.</span>respond_with(<span>201</span>, <span>:created</span>)
    pl<span>.</span>respond_with(<span>400</span>, <span>:bad_request</span>)
  <span>end</span>
<span>end</span>
</code></pre></div><h2 id="testability">Testability</h2>
<p>Testing any complex workflow can be challenging. Composable pipelines allows me to use a “divide and conquer” approach to testing.</p>
<ol>
<li>Unit test each step in isolation.</li>
</ol>
<div><pre tabindex="0"><code data-lang="ruby">step <span>=</span> <span>MultiplyBy</span><span>.</span>(<span>2</span>)
initial_result <span>=</span> <span>Result</span><span>.</span>continue(<span>[</span><span>1</span>, <span>2</span>, <span>3</span>, <span>4</span><span>]</span>)
result <span>=</span> step<span>.</span>call(initial_result)
expect(result<span>.</span>value)<span>.</span>to eq(<span>[</span><span>2</span>, <span>4</span>, <span>6</span>, <span>8</span><span>]</span>)
</code></pre></div><ol start="2">
<li>Test that the pipeline is composed correctly.</li>
</ol>
<div><pre tabindex="0"><code data-lang="ruby"><span># An RSpec helper to assert that a pipeline is composed of a sequence of steps</span>
expect(<span>NumberCruncher</span>)<span>.</span>to be_composed_of_steps(
  <span>ValidateSetSize</span>,
  <span>MultiplyBy</span><span>.</span>(<span>2</span>),
  <span>LimitSet</span>
)
</code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Like anything, this approach has its trade-offs. If you prefer inheritance over composition, or the processing required can’t be easily broken down into steps, then this approach might not be the best fit.</p>
<p>In general, I’ve found it provides a <em>simple</em> mental model to reason about problems (in <a href="https://www.youtube.com/watch?v=SxdOUGdseq4">the Rick Hickey sense</a>).</p>
<p>Any operation that can be coerced into complying with the <a href="https://blog.ploeh.dk/2017/10/06/monoids/">Monoid Laws</a> can be a good candidate.</p>
<p>The basic implementation used in this article is <a href="https://gist.github.com/ismasan/0bdcc76c2ea48f4259b38fafe131edb8">here</a>.</p>
</section></div>
  </body>
</html>
