<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Kindelia/HVM">Original</a>
    <h1>High-order Virtual Machine (HVM): Massively parallel, optimal functional runtime</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
          <article itemprop="text">
<p dir="auto"><strong>High-order Virtual Machine (HVM)</strong> is a pure functional compile target that
is <strong>lazy</strong>, <strong>non-garbage-collected</strong> and <strong>massively parallel</strong>. It is also
<strong>beta-optimal</strong>, meaning that, in several cases, it can be exponentially
faster than most functional runtimes, including Haskell&#39;s GHC.</p>
<p dir="auto">That is possible due to a new model of computation, the Interaction Net, which
combines the Turing Machine with the Lambda Calculus. Previous implementations
of this model have been inefficient in practice, however, a recent breakthrough
has drastically improved its efficiency, giving birth to the HVM. Despite being
a prototype, it already beats mature compilers in many cases, and is set to
scale towards uncharted levels of performance.</p>
<p dir="auto"><strong>Welcome to the inevitable parallel, functional future of computers!</strong></p>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<h4 dir="auto"><a id="user-content-1-install-it" aria-hidden="true" href="#1-install-it"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>1. Install it</h4>
<p dir="auto">First, install <a href="https://www.rust-lang.org/" rel="nofollow">Rust</a>. Then, type:</p>

<h4 dir="auto"><a id="user-content-2-create-an-hvm-file" aria-hidden="true" href="#2-create-an-hvm-file"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>2. Create an HVM file</h4>
<p dir="auto">HVM files look like untyped Haskell. Save the file below as <code>main.hvm</code>:</p>
<div data-snippet-clipboard-copy-content="// Creates a tree with `2^n` elements
(Gen 0) = (Leaf 1)
(Gen n) = (Node (Gen(- n 1)) (Gen(- n 1)))

// Adds all elements of a tree
(Sum (Leaf x))   = x
(Sum (Node a b)) = (+ (Sum a) (Sum b))

// Performs 2^n additions in parallel
(Main n) = (Sum (Gen n))"><pre><span>// Creates a tree with `2^n` elements</span>
<span>(</span><span>Gen</span> <span>0</span><span>)</span> <span>=</span> <span>(</span><span>Leaf</span> <span>1</span><span>)</span>
<span>(</span><span>Gen</span> <span>n</span><span>)</span> <span>=</span> <span>(</span><span>Node</span> <span>(</span><span>Gen</span><span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span> <span>(</span><span>Gen</span><span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span><span>)</span>

<span>// Adds all elements of a tree</span>
<span>(</span><span>Sum</span> <span>(</span><span>Leaf</span> <span>x</span><span>)</span><span>)</span>   <span>=</span> <span>x</span>
<span>(</span><span>Sum</span> <span>(</span><span>Node</span> <span>a</span> <span>b</span><span>)</span><span>)</span> <span>=</span> <span>(</span><span>+</span> <span>(</span><span>Sum</span> <span>a</span><span>)</span> <span>(</span><span>Sum</span> <span>b</span><span>)</span><span>)</span>

<span>// Performs 2^n additions in parallel</span>
<span>(</span><span>Main</span> <span>n</span><span>)</span> <span>=</span> <span>(</span><span>Sum</span> <span>(</span><span>Gen</span> <span>n</span><span>)</span><span>)</span></pre></div>
<p dir="auto">The program above creates a perfect binary tree with <code>2^n</code> elements and adds
them up. Since it is recursive, HVM will parallelize it automatically.</p>
<h4 dir="auto"><a id="user-content-3-run-and-compile" aria-hidden="true" href="#3-run-and-compile"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>3. Run and compile</h4>
<div data-snippet-clipboard-copy-content="hvm r main 10                      # runs it with n=10
hvm c main                         # compiles HVM to C
clang -O2 main.c -o main -lpthread # compiles C to BIN
./main 30                          # runs it with n=30"><pre>hvm r main 10                      <span><span>#</span> runs it with n=10</span>
hvm c main                         <span><span>#</span> compiles HVM to C</span>
clang -O2 main.c -o main -lpthread <span><span>#</span> compiles C to BIN</span>
./main 30                          <span><span>#</span> runs it with n=30</span></pre></div>
<p dir="auto">The program above runs in about <strong>6.4 seconds</strong> in a modern 8-core processor,
while the identical Haskell code takes about <strong>19.2 seconds</strong> in the same
machine with GHC. This is HVM: write a functional program, get a parallel C
runtime. And that&#39;s just the tip of iceberg!</p>
<p dir="auto"><a href="https://github.com/Kindelia/HVM/blob/master/NIX.md">See Nix usage documentation here.</a></p>

<p dir="auto">HVM has two main advantages over GHC: automatic parallelism and beta-optimality.
I&#39;ve selected 5 common micro-benchmarks to compare them. Keep in mind that HVM
is still an early prototype, so it <strong>obviously</strong> won&#39;t beat GHC in general, but
it does quite well already and should improve steadily as optimizations are
implemented. Tests were compiled with <code>ghc -O2</code> for Haskell and <code>clang -O2</code> for
HVM, on an 8-core M1 Max processor. The complete files to replicate these
results are in <a href="https://github.com/Kindelia/HVM/blob/master/bench">the /bench directory</a>.</p>
<h2 dir="auto"><a id="user-content-list-fold-sequential" aria-hidden="true" href="#list-fold-sequential"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>List Fold (Sequential)</h2>
<table>
<tbody><tr>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/ListFold/main.hvm"> main.hvm </a></td>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/ListFold/main.hs"> main.hs </a></td>
</tr>
<tr>
<td>
<div data-snippet-clipboard-copy-content="// Folds over a list
(Fold Nil         c n) = n
(Fold (Cons x xs) c n) = (c x (Fold xs c n))

// A list from 0 to n
(Range 0 xs) = xs
(Range n xs) =
  let m = (- n 1)
  (Range m (Cons m xs))

// Sums a big list with fold
(Main n) =
  let size = (* n 1000000)
  let list = (Range size Nil)
  (Fold list λaλb(+ a b) 0)"><pre><span>// Folds over a list</span>
<span>(</span><span>Fold</span> <span>Nil</span>         <span>c</span> <span>n</span><span>)</span> <span>=</span> <span>n</span>
<span>(</span><span>Fold</span> <span>(</span><span>Cons</span> <span>x</span> <span>xs</span><span>)</span> <span>c</span> <span>n</span><span>)</span> <span>=</span> <span>(</span><span>c</span> <span>x</span> <span>(</span><span>Fold</span> <span>xs</span> <span>c</span> <span>n</span><span>)</span><span>)</span>

<span>// A list from 0 to n</span>
<span>(</span><span>Range</span> <span>0</span> <span>xs</span><span>)</span> <span>=</span> <span>xs</span>
<span>(</span><span>Range</span> <span>n</span> <span>xs</span><span>)</span> <span>=</span>
  <span>let</span> <span>m</span> <span>=</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span>
  <span>(</span><span>Range</span> <span>m</span> <span>(</span><span>Cons</span> <span>m</span> <span>xs</span><span>)</span><span>)</span>

<span>// Sums a big list with fold</span>
<span>(</span><span>Main</span> <span>n</span><span>)</span> <span>=</span>
  <span>let</span> <span>size</span> <span>=</span> <span>(</span><span>*</span> <span>n</span> <span>1000000</span><span>)</span>
  <span>let</span> <span>list</span> <span>=</span> <span>(</span><span>Range</span> <span>size</span> <span>Nil</span><span>)</span>
  <span>(</span><span>Fold</span> <span>list</span> <span>λaλb</span><span>(</span><span>+</span> <span>a</span> <span>b</span><span>)</span> <span>0</span><span>)</span></pre></div>
</td>
<td>
<div data-snippet-clipboard-copy-content="-- Folds over a list
fold Nil         c n = n
fold (Cons x xs) c n = c x (fold xs c n)

-- A list from 0 to n
range 0 xs = xs
range n xs =
  let m = n - 1
  in range m (Cons m xs)

-- Sums a big list with fold
main = do
  n &lt;- read.head &lt;$&gt; getArgs :: IO Word32
  let size = 1000000 * n
  let list = range size Nil
  print $ fold list (+) 0"><pre><span><span>--</span> Folds over a list</span>
fold <span>Nil</span>         c n <span>=</span> n
fold (<span>Cons</span> x xs) c n <span>=</span> c x (fold xs c n)

<span><span>--</span> A list from 0 to n</span>
range <span>0</span> xs <span>=</span> xs
range n xs <span>=</span>
  <span>let</span> m <span>=</span> n <span>-</span> <span>1</span>
  <span>in</span> range m (<span>Cons</span> m xs)

<span><span>--</span> Sums a big list with fold</span>
main <span>=</span> <span>do</span>
  n <span>&lt;-</span> <span>read</span><span>.</span><span>head</span> <span>&lt;$&gt;</span> getArgs <span>::</span> <span><span>IO</span></span> <span>Word32</span>
  <span>let</span> size <span>=</span> <span>1000000</span> <span>*</span> n
  <span>let</span> list <span>=</span> range size <span>Nil</span>
  <span>print</span> <span>$</span> fold list <span>(+)</span> <span>0</span></pre></div>
</td>
</tr>
</tbody></table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Kindelia/HVM/blob/master/bench/_results_/ListFold.png"><img src="https://github.com/Kindelia/HVM/raw/master/bench/_results_/ListFold.png" alt=""/></a>
<sub> *the lower the better </sub></p>
<p dir="auto">In this micro-benchmark, we just build a huge list of numbers, and fold over
it to sum them. Since lists are sequential, and since there are no higher-order
lambdas, HVM doesn&#39;t have any technical advantage over GHC. As such, both
runtimes perform very similarly.</p>
<h2 dir="auto"><a id="user-content-tree-sum-parallel" aria-hidden="true" href="#tree-sum-parallel"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Tree Sum (Parallel)</h2>
<table>
<tbody><tr>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/TreeSum/main.hvm"> main.hvm </a></td>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/TreeSum/main.hs"> main.hs </a></td>
</tr>
<tr>
<td>
<div data-snippet-clipboard-copy-content="// Creates a tree with `2^n` elements
(Gen 0) = (Leaf 1)
(Gen n) = (Node (Gen(- n 1)) (Gen(- n 1)))

// Adds all elemements of a tree
(Sum (Leaf x))   = x
(Sum (Node a b)) = (+ (Sum a) (Sum b))

// Performs 2^n additions
(Main n) = (Sum (Gen n))"><pre><span>// Creates a tree with `2^n` elements</span>
<span>(</span><span>Gen</span> <span>0</span><span>)</span> <span>=</span> <span>(</span><span>Leaf</span> <span>1</span><span>)</span>
<span>(</span><span>Gen</span> <span>n</span><span>)</span> <span>=</span> <span>(</span><span>Node</span> <span>(</span><span>Gen</span><span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span> <span>(</span><span>Gen</span><span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span><span>)</span><span>)</span>

<span>// Adds all elemements of a tree</span>
<span>(</span><span>Sum</span> <span>(</span><span>Leaf</span> <span>x</span><span>)</span><span>)</span>   <span>=</span> <span>x</span>
<span>(</span><span>Sum</span> <span>(</span><span>Node</span> <span>a</span> <span>b</span><span>)</span><span>)</span> <span>=</span> <span>(</span><span>+</span> <span>(</span><span>Sum</span> <span>a</span><span>)</span> <span>(</span><span>Sum</span> <span>b</span><span>)</span><span>)</span>

<span>// Performs 2^n additions</span>
<span>(</span><span>Main</span> <span>n</span><span>)</span> <span>=</span> <span>(</span><span>Sum</span> <span>(</span><span>Gen</span> <span>n</span><span>)</span><span>)</span></pre></div>
</td>
<td>
<div data-snippet-clipboard-copy-content="-- Creates a tree with 2^n elements
gen 0 = Leaf 1
gen n = Node (gen(n - 1)) (gen(n - 1))

-- Adds all elements of a tree
sun (Leaf x)   = 1
sun (Node a b) = sun a + sun b

-- Performs 2^n additions
main = do
  n &lt;- read.head &lt;$&gt; getArgs :: IO Word32
  print $ sun (gen n)"><pre><span><span>--</span> Creates a tree with 2^n elements</span>
gen <span>0</span> <span>=</span> <span>Leaf</span> <span>1</span>
gen n <span>=</span> <span>Node</span> (gen(n <span>-</span> <span>1</span>)) (gen(n <span>-</span> <span>1</span>))

<span><span>--</span> Adds all elements of a tree</span>
sun (<span>Leaf</span> x)   <span>=</span> <span>1</span>
sun (<span>Node</span> a b) <span>=</span> sun a <span>+</span> sun b

<span><span>--</span> Performs 2^n additions</span>
main <span>=</span> <span>do</span>
  n <span>&lt;-</span> <span>read</span><span>.</span><span>head</span> <span>&lt;$&gt;</span> getArgs <span>::</span> <span><span>IO</span></span> <span>Word32</span>
  <span>print</span> <span>$</span> sun (gen n)</pre></div>
</td>
</tr>
</tbody></table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Kindelia/HVM/blob/master/bench/_results_/TreeSum.png"><img src="https://github.com/Kindelia/HVM/raw/master/bench/_results_/TreeSum.png" alt=""/></a></p>
<p dir="auto">TreeSum recursively builds and sums all elements of a perfect binary tree. HVM
outperforms Haskell by a wide margin because this algorithm is embarassingly
parallel, allowing it to fully use the available cores.</p>
<h2 dir="auto"><a id="user-content-quicksort-parallel" aria-hidden="true" href="#quicksort-parallel"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>QuickSort (Parallel)</h2>
<table>
<tbody><tr>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/QuickSort/main.hvm"> main.hvm </a></td>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/QuickSort/main.hs"> main.hs </a></td>
</tr>
<tr>
<td>
<div data-snippet-clipboard-copy-content="// QuickSort
(QSort p s Nil)          = Empty
(QSort p s (Cons x Nil)) = (Single x)
(QSort p s (Cons x xs))  =
  (Split p s (Cons x xs) Nil Nil)

// Splits list in two partitions
(Split p s Nil min max) =
  let s   = (&gt;&gt; s 1)
  let min = (QSort (- p s) s min)
  let max = (QSort (+ p s) s max)
  (Concat min max)
(Split p s (Cons x xs) min max) =
  (Place p s (&lt; p x) x xs min max)

// Sorts and sums n random numbers
(Main n) =
  let list = (Randoms 1 (* 100000 n))
  (Sum (QSort Pivot Pivot list))"><pre><span>// QuickSort</span>
<span>(</span><span>QSort</span> <span>p</span> <span>s</span> <span>Nil</span><span>)</span>          <span>=</span> <span>Empty</span>
<span>(</span><span>QSort</span> <span>p</span> <span>s</span> <span>(</span><span>Cons</span> <span>x</span> <span>Nil</span><span>)</span><span>)</span> <span>=</span> <span>(</span><span>Single</span> <span>x</span><span>)</span>
<span>(</span><span>QSort</span> <span>p</span> <span>s</span> <span>(</span><span>Cons</span> <span>x</span> <span>xs</span><span>)</span><span>)</span>  <span>=</span>
  <span>(</span><span>Split</span> <span>p</span> <span>s</span> <span>(</span><span>Cons</span> <span>x</span> <span>xs</span><span>)</span> <span>Nil</span> <span>Nil</span><span>)</span>

<span>// Splits list in two partitions</span>
<span>(</span><span>Split</span> <span>p</span> <span>s</span> <span>Nil</span> <span>min</span> <span>max</span><span>)</span> <span>=</span>
  <span>let</span> <span>s</span>   <span>=</span> <span>(</span><span>&gt;&gt;</span> <span>s</span> <span>1</span><span>)</span>
  <span>let</span> <span>min</span> <span>=</span> <span>(</span><span>QSort</span> <span>(</span><span>-</span> <span>p</span> <span>s</span><span>)</span> <span>s</span> <span>min</span><span>)</span>
  <span>let</span> <span>max</span> <span>=</span> <span>(</span><span>QSort</span> <span>(</span><span>+</span> <span>p</span> <span>s</span><span>)</span> <span>s</span> <span>max</span><span>)</span>
  <span>(</span><span>Concat</span> <span>min</span> <span>max</span><span>)</span>
<span>(</span><span>Split</span> <span>p</span> <span>s</span> <span>(</span><span>Cons</span> <span>x</span> <span>xs</span><span>)</span> <span>min</span> <span>max</span><span>)</span> <span>=</span>
  <span>(</span><span>Place</span> <span>p</span> <span>s</span> <span>(</span><span>&lt;</span> <span>p</span> <span>x</span><span>)</span> <span>x</span> <span>xs</span> <span>min</span> <span>max</span><span>)</span>

<span>// Sorts and sums n random numbers</span>
<span>(</span><span>Main</span> <span>n</span><span>)</span> <span>=</span>
  <span>let</span> <span>list</span> <span>=</span> <span>(</span><span>Randoms</span> <span>1</span> <span>(</span><span>*</span> <span>100000</span> <span>n</span><span>)</span><span>)</span>
  <span>(</span><span>Sum</span> <span>(</span><span>QSort</span> <span>Pivot</span> <span>Pivot</span> <span>list</span><span>)</span><span>)</span></pre></div>
</td>
<td>
<div data-snippet-clipboard-copy-content="-- QuickSort
qsort p s Nil          = Empty
qsort p s (Cons x Nil) = Single x
qsort p s (Cons x xs)  =
  split p s (Cons x xs) Nil Nil

-- Splits list in two partitions
split p s Nil min max =
  let s&#39;   = shiftR s 1
      min&#39; = qsort (p - s&#39;) s&#39; min
      max&#39; = qsort (p + s&#39;) s&#39; max
  in  Concat min&#39; max&#39;
split p s (Cons x xs) min max =
  place p s (p &lt; x) x xs min max

-- Sorts and sums n random numbers
main = do
  n &lt;- read.head &lt;$&gt; getArgs :: IO Word32
  let list = randoms 1 (100000 * n)
  print $ sun $ qsort pivot pivot $ list "><pre><span><span>--</span> QuickSort</span>
qsort p s <span>Nil</span>          <span>=</span> <span>Empty</span>
qsort p s (<span>Cons</span> x <span>Nil</span>) <span>=</span> <span>Single</span> x
qsort p s (<span>Cons</span> x xs)  <span>=</span>
  split p s (<span>Cons</span> x xs) <span>Nil</span> <span>Nil</span>

<span><span>--</span> Splits list in two partitions</span>
split p s <span>Nil</span> <span>min</span> <span>max</span> <span>=</span>
  <span>let</span> s&#39;   <span>=</span> shiftR s <span>1</span>
      min&#39; <span>=</span> qsort (p <span>-</span> s&#39;) s&#39; <span>min</span>
      max&#39; <span>=</span> qsort (p <span>+</span> s&#39;) s&#39; <span>max</span>
  <span>in</span>  <span>Concat</span> min&#39; max&#39;
split p s (<span>Cons</span> x xs) <span>min</span> <span>max</span> <span>=</span>
  place p s (p <span>&lt;</span> x) x xs <span>min</span> <span>max</span>

<span><span>--</span> Sorts and sums n random numbers</span>
main <span>=</span> <span>do</span>
  n <span>&lt;-</span> <span>read</span><span>.</span><span>head</span> <span>&lt;$&gt;</span> getArgs <span>::</span> <span><span>IO</span></span> <span>Word32</span>
  <span>let</span> list <span>=</span> randoms <span>1</span> (<span>100000</span> <span>*</span> n)
  <span>print</span> <span>$</span> sun <span>$</span> qsort pivot pivot <span>$</span> list </pre></div>
</td>
</tr>
</tbody></table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Kindelia/HVM/blob/master/bench/_results_/QuickSort.png"><img src="https://github.com/Kindelia/HVM/raw/master/bench/_results_/QuickSort.png" alt=""/></a></p>
<p dir="auto">This test modifies QuickSort to return a concatenation tree instead of a flat
list. This makes it embarassingly parallel, allowing HVM to outperform GHC by a
wide margin again. It even beats Haskell&#39;s sort from Data.List! Note that
flattening the tree will make the algorithm sequential. That&#39;s why we didn&#39;t
chose MergeSort, as <code>merge</code> operates on lists. In general, trees should be
favoured over lists on HVM.</p>
<h2 dir="auto"><a id="user-content-composition-optimal" aria-hidden="true" href="#composition-optimal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Composition (Optimal)</h2>
<table>
<tbody><tr>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/Composition/main.hvm"> main.hvm </a></td>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/Composition/main.hs"> main.hs </a></td>
</tr>
<tr>
<td>
<div data-snippet-clipboard-copy-content="// Computes f^(2^n)
(Comp 0 f x) = (f x)
(Comp n f x) = (Comp (- n 1) λk(f (f k)) x)

// Performs 2^n compositions
(Main n) = (Comp n λx(x) 0)"><pre><span>// Computes f^(2^n)</span>
<span>(</span><span>Comp</span> <span>0</span> <span>f</span> <span>x</span><span>)</span> <span>=</span> <span>(</span><span>f</span> <span>x</span><span>)</span>
<span>(</span><span>Comp</span> <span>n</span> <span>f</span> <span>x</span><span>)</span> <span>=</span> <span>(</span><span>Comp</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span> <span>λk</span><span>(</span><span>f</span> <span>(</span><span>f</span> <span>k</span><span>)</span><span>)</span> <span>x</span><span>)</span>

<span>// Performs 2^n compositions</span>
<span>(</span><span>Main</span> <span>n</span><span>)</span> <span>=</span> <span>(</span><span>Comp</span> <span>n</span> <span>λx</span><span>(</span><span>x</span><span>)</span> <span>0</span><span>)</span></pre></div>
</td>
<td>
<div data-snippet-clipboard-copy-content="-- Computes f^(2^n)
comp 0 f x = f x
comp n f x = comp (n - 1) (\x -&gt; f (f x)) x

-- Performs 2^n compositions
main = do
  n &lt;- read.head &lt;$&gt; getArgs :: IO Int
  print $ comp n (\x -&gt; x) (0 :: Int)"><pre><span><span>--</span> Computes f^(2^n)</span>
comp <span>0</span> f x <span>=</span> f x
comp n f x <span>=</span> comp (n <span>-</span> <span>1</span>) (<span>\</span>x <span>-&gt;</span> f (f x)) x

<span><span>--</span> Performs 2^n compositions</span>
main <span>=</span> <span>do</span>
  n <span>&lt;-</span> <span>read</span><span>.</span><span>head</span> <span>&lt;$&gt;</span> getArgs <span>::</span> <span><span>IO</span></span> <span><span>Int</span></span>
  <span>print</span> <span>$</span> comp n (<span>\</span>x <span>-&gt;</span> x) (<span>0</span> <span>::</span> <span><span>Int</span></span>)</pre></div>
</td>
</tr>
</tbody></table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Kindelia/HVM/blob/master/bench/_results_/Composition.png"><img src="https://github.com/Kindelia/HVM/raw/master/bench/_results_/Composition.png" alt=""/></a></p>
<p dir="auto">This chart isn&#39;t wrong: HVM is <em>exponentially</em> faster for function composition,
due to optimality, depending on the target function. There is no parallelism
involved here. In general, if the composition of a function <code>f</code> has a
constant-size normal form, then <code>f^(2^N)(x)</code> is linear-time (<code>O(N)</code>) on HVM,
and exponential-time (<code>O(2^N)</code>) on GHC. This can be taken advantage of to design
novel functional algorithms. I highly encourage you to try composing different
functions and watching how their complexity behaves. Can you tell if it will be
linear or exponential? Or how recursion will affect it? That&#39;s a very
insightful experience!</p>
<h2 dir="auto"><a id="user-content-lambda-arithmetic-optimal" aria-hidden="true" href="#lambda-arithmetic-optimal"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Lambda Arithmetic (Optimal)</h2>
<table>
<tbody><tr>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/LambdaArithmetic/main.hvm"> main.hvm </a></td>
  <td><a href="https://github.com/Kindelia/HVM/blob/master/bench/LambdaArithmetic/main.hs"> main.hs </a></td>
</tr>
<tr>
<td>
<div data-snippet-clipboard-copy-content="// Increments a Bits by 1
(Inc xs) = λex λox λix
  let e = ex
  let o = ix
  let i = λp (ox (Inc p))
  (xs e o i)

// Adds two Bits
(Add xs ys) = (App xs λx(Inc x) ys)

// Multiplies two Bits
(Mul xs ys) = 
  let e = End
  let o = λp (B0 (Mul p ys))
  let i = λp (Add ys (B0 (Mul p ys)))
  (xs e o i)

// Squares (n * 100k)
(Main n) =
  let a = (FromU32 32 (* 100000 n))
  let b = (FromU32 32 (* 100000 n))
  (ToU32 (Mul a b))"><pre><span>// Increments a Bits by 1</span>
<span>(</span><span>Inc</span> <span>xs</span><span>)</span> <span>=</span> <span>λex</span> <span>λox</span> <span>λix</span>
  <span>let</span> <span>e</span> <span>=</span> <span>ex</span>
  <span>let</span> <span>o</span> <span>=</span> <span>ix</span>
  <span>let</span> <span>i</span> <span>=</span> <span>λp</span> <span>(</span><span>ox</span> <span>(</span><span>Inc</span> <span>p</span><span>)</span><span>)</span>
  <span>(</span><span>xs</span> <span>e</span> <span>o</span> <span>i</span><span>)</span>

<span>// Adds two Bits</span>
<span>(</span><span>Add</span> <span>xs</span> <span>ys</span><span>)</span> <span>=</span> <span>(</span><span>App</span> <span>xs</span> <span>λx</span><span>(</span><span>Inc</span> <span>x</span><span>)</span> <span>ys</span><span>)</span>

<span>// Multiplies two Bits</span>
<span>(</span><span>Mul</span> <span>xs</span> <span>ys</span><span>)</span> <span>=</span> 
  <span>let</span> <span>e</span> <span>=</span> <span>End</span>
  <span>let</span> <span>o</span> <span>=</span> <span>λp</span> <span>(</span><span>B0</span> <span>(</span><span>Mul</span> <span>p</span> <span>ys</span><span>)</span><span>)</span>
  <span>let</span> <span>i</span> <span>=</span> <span>λp</span> <span>(</span><span>Add</span> <span>ys</span> <span>(</span><span>B0</span> <span>(</span><span>Mul</span> <span>p</span> <span>ys</span><span>)</span><span>)</span><span>)</span>
  <span>(</span><span>xs</span> <span>e</span> <span>o</span> <span>i</span><span>)</span>

<span>// Squares (n * 100k)</span>
<span>(</span><span>Main</span> <span>n</span><span>)</span> <span>=</span>
  <span>let</span> <span>a</span> <span>=</span> <span>(</span><span>FromU32</span> <span>32</span> <span>(</span><span>*</span> <span>100000</span> <span>n</span><span>)</span><span>)</span>
  <span>let</span> <span>b</span> <span>=</span> <span>(</span><span>FromU32</span> <span>32</span> <span>(</span><span>*</span> <span>100000</span> <span>n</span><span>)</span><span>)</span>
  <span>(</span><span>ToU32</span> <span>(</span><span>Mul</span> <span>a</span> <span>b</span><span>)</span><span>)</span></pre></div>
</td>
<td>
<div data-snippet-clipboard-copy-content="-- Increments a Bits by 1
inc xs = Bits $ \ex -&gt; \ox -&gt; \ix -&gt;
  let e = ex
      o = ix
      i = \p -&gt; ox (inc p)
  in get xs e o i

-- Adds two Bits
add xs ys = app xs (\x -&gt; inc x) ys

-- Multiplies two Bits
mul xs ys = 
  let e = end
      o = \p -&gt; b0 (mul p ys)
      i = \p -&gt; add ys (b1 (mul p ys))
  in get xs e o i

-- Squares (n * 100k)
main = do
  n &lt;- read.head &lt;$&gt; getArgs :: IO Word32
  let a = fromU32 32 (100000 * n)
  let b = fromU32 32 (100000 * n)
  print $ toU32 (mul a b)"><pre><span><span>--</span> Increments a Bits by 1</span>
inc xs <span>=</span> <span>Bits</span> <span>$</span> <span>\</span>ex <span>-&gt;</span> <span>\</span>ox <span>-&gt;</span> <span>\</span>ix <span>-&gt;</span>
  <span>let</span> e <span>=</span> ex
      o <span>=</span> ix
      i <span>=</span> <span>\</span>p <span>-&gt;</span> ox (inc p)
  <span>in</span> get xs e o i

<span><span>--</span> Adds two Bits</span>
add xs ys <span>=</span> app xs (<span>\</span>x <span>-&gt;</span> inc x) ys

<span><span>--</span> Multiplies two Bits</span>
mul xs ys <span>=</span> 
  <span>let</span> e <span>=</span> end
      o <span>=</span> <span>\</span>p <span>-&gt;</span> b0 (mul p ys)
      i <span>=</span> <span>\</span>p <span>-&gt;</span> add ys (b1 (mul p ys))
  <span>in</span> get xs e o i

<span><span>--</span> Squares (n * 100k)</span>
main <span>=</span> <span>do</span>
  n <span>&lt;-</span> <span>read</span><span>.</span><span>head</span> <span>&lt;$&gt;</span> getArgs <span>::</span> <span><span>IO</span></span> <span>Word32</span>
  <span>let</span> a <span>=</span> fromU32 <span>32</span> (<span>100000</span> <span>*</span> n)
  <span>let</span> b <span>=</span> fromU32 <span>32</span> (<span>100000</span> <span>*</span> n)
  <span>print</span> <span>$</span> toU32 (mul a b)</pre></div>
</td>
</tr>
</tbody></table>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/Kindelia/HVM/blob/master/bench/_results_/LambdaArithmetic.png"><img src="https://github.com/Kindelia/HVM/raw/master/bench/_results_/LambdaArithmetic.png" alt=""/></a></p>
<p dir="auto">This example takes advantage of beta-optimality to implement multiplication
using lambda-encoded bitstrings. Once again, HVM halts instantly, while GHC
struggles to deal with all these lambdas. Lambda encodings have wide practical
applications. For example, Haskell&#39;s Lists are optimized by converting them to
lambdas (foldr/build), its Free Monads library has a faster version based on
lambdas, and so on. HVM&#39;s optimality open doors for an entire unexplored field
of lambda-encoded algorithms that were simply impossible before.</p>
<p dir="auto"><em>Charts made on <a href="https://chart-studio.plotly.com/" rel="nofollow">plotly.com</a>.</em></p>

<p dir="auto">Check <a href="https://github.com/Kindelia/HVM/blob/master/HOW.md">HOW.md</a>.</p>

<p dir="auto">Most importantly, if you appreciate our work, help spreading the project! Posting on
Reddit, communities, etc. helps more than you think.</p>
<p dir="auto">Second, I&#39;m looking for partners! I believe HVM&#39;s current design is ready to
scale and become the fastest runtime in the world, but much needs to be done to
get there. We&#39;re also building interesting products built on top of it. If you&#39;d
like to get involved, please <a href="mailto:victor.taelin@gmail.com">email me</a>, or just
send me a personal message on <a href="https://twitter.com/victortaelin" rel="nofollow">Twitter</a>.</p>

<p dir="auto">To just follow the project, join our <a href="https://t.me/formality_lang" rel="nofollow">Telegram
Chat</a>, the <a href="https://discord.gg/VV7ppaVWYn" rel="nofollow">Kindelia community on
Discord</a> or
<a href="https://matrix.to/#/#kindelia:kde.org" rel="nofollow">Matrix</a>!</p>
</article>
        </div></div>
  </body>
</html>
