<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2023/faas-in-go-with-wasm-wasi-and-rust/">Original</a>
    <h1>FaaS in Go with WASM, WASI and Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    <div>
    <section id="content">
        <article>
            
            <div>
                
                <p>This post is best described as a technology demonstration; it melds together
web servers, plugins, WebAssembly, Go, Rust and ABIs. Here&#39;s what it shows:</p>
<ul>
<li>How to load WASM code with WASI in a Go environment and hook it up to a web
server.</li>
<li>How to implement web server plugins in any language that can be compiled to
WASM.</li>
<li>How to translate Go programs into WASM that uses WASI.</li>
<li>How to translate Rust programs into WASM that uses WASI.</li>
<li>How to write WAT (WebAssembly Text) code that uses WASI to interact with
a non-JS environment.</li>
</ul>
<p>We&#39;re going to build a simple <strong>FAAS</strong> (Function as a Service) server in Go
that lets us write <em>modules</em> in any language that has a WASM
target. Comparing to existing technologies, it&#39;s something
between GCP&#39;s <a href="https://cloud.google.com/functions">Cloud Functions</a>, <a href="https://cloud.google.com/run">Cloud
Run</a> and good old <a href="https://en.wikipedia.org/wiki/Common_Gateway_Interface">CGI</a>.</p>
<div id="design">
<h2>Design</h2>
<p>Let&#39;s start with a high-level diagram describing how the system works:</p>
<p><img alt="Diagram showing flow of events in this program, also described below" src="https://eli.thegreenplace.net/images/2023/wasm-faas.png"/></p><p>The steps numbered in the diagram are:</p>
<ol>
<li>The FAAS server receives an <tt>HTTP GET</tt> request, with a path consisting of
a module name (<tt>func</tt> in the example in the diagram) and an arbitrary
query string.</li>
<li>The FAAS server finds and loads the WASM module corresponding to the module
name it was provided, and invokes it with a description of the HTTP request.</li>
<li>The module emits output to its stdout, which is captured by the FAAS server.</li>
<li>The FAAS server uses the module&#39;s stdout as the contents of an HTTP Response
to the request it received.</li>
</ol>
</div>
<div id="the-faas-server">
<h2>The FAAS server</h2>
<p>We&#39;ll start our deep dive with the FAAS server itself (<a href="https://github.com/eliben/code-for-blog/tree/master/2023/wasm-faas">full code here</a>). The
HTTP handling part is straightforward:</p>
<div><pre><span></span><span>func</span><span> </span><span>httpHandler</span><span>(</span><span>w</span><span> </span><span>http</span><span>.</span><span>ResponseWriter</span><span>,</span><span> </span><span>req</span><span> </span><span>*</span><span>http</span><span>.</span><span>Request</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>parts</span><span> </span><span>:=</span><span> </span><span>strings</span><span>.</span><span>Split</span><span>(</span><span>strings</span><span>.</span><span>Trim</span><span>(</span><span>req</span><span>.</span><span>URL</span><span>.</span><span>Path</span><span>,</span><span> </span><span>&#34;/&#34;</span><span>),</span><span> </span><span>&#34;/&#34;</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>len</span><span>(</span><span>parts</span><span>)</span><span> </span><span>&lt;</span><span> </span><span>1</span><span> </span><span>{</span><span></span>
<span>    </span><span>http</span><span>.</span><span>Error</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;want /{modulename} prefix&#34;</span><span>,</span><span> </span><span>http</span><span>.</span><span>StatusBadRequest</span><span>)</span><span></span>
<span>    </span><span>return</span><span></span>
<span>  </span><span>}</span><span></span>
<span>  </span><span>mod</span><span> </span><span>:=</span><span> </span><span>parts</span><span>[</span><span>0</span><span>]</span><span></span>
<span>  </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;module %v requested with query %v&#34;</span><span>,</span><span> </span><span>mod</span><span>,</span><span> </span><span>req</span><span>.</span><span>URL</span><span>.</span><span>Query</span><span>())</span><span></span>

<span>  </span><span>env</span><span> </span><span>:=</span><span> </span><span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>{</span><span></span>
<span>    </span><span>&#34;http_path&#34;</span><span>:</span><span>   </span><span>req</span><span>.</span><span>URL</span><span>.</span><span>Path</span><span>,</span><span></span>
<span>    </span><span>&#34;http_method&#34;</span><span>:</span><span> </span><span>req</span><span>.</span><span>Method</span><span>,</span><span></span>
<span>    </span><span>&#34;http_host&#34;</span><span>:</span><span>   </span><span>req</span><span>.</span><span>Host</span><span>,</span><span></span>
<span>    </span><span>&#34;http_query&#34;</span><span>:</span><span>  </span><span>req</span><span>.</span><span>URL</span><span>.</span><span>Query</span><span>().</span><span>Encode</span><span>(),</span><span></span>
<span>    </span><span>&#34;remote_addr&#34;</span><span>:</span><span> </span><span>req</span><span>.</span><span>RemoteAddr</span><span>,</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>modpath</span><span> </span><span>:=</span><span> </span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>&#34;target/%v.wasm&#34;</span><span>,</span><span> </span><span>mod</span><span>)</span><span></span>
<span>  </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;loading module %v&#34;</span><span>,</span><span> </span><span>modpath</span><span>)</span><span></span>
<span>  </span><span>out</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>invokeWasmModule</span><span>(</span><span>mod</span><span>,</span><span> </span><span>modpath</span><span>,</span><span> </span><span>env</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;error loading module %v&#34;</span><span>,</span><span> </span><span>modpath</span><span>)</span><span></span>
<span>    </span><span>http</span><span>.</span><span>Error</span><span>(</span><span>w</span><span>,</span><span> </span><span>&#34;unable to find module &#34;</span><span>+</span><span>modpath</span><span>,</span><span> </span><span>http</span><span>.</span><span>StatusNotFound</span><span>)</span><span></span>
<span>    </span><span>return</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>// The module&#39;s stdout is written into the response.</span><span></span>
<span>  </span><span>fmt</span><span>.</span><span>Fprint</span><span>(</span><span>w</span><span>,</span><span> </span><span>out</span><span>)</span><span></span>
<span>}</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>mux</span><span> </span><span>:=</span><span> </span><span>http</span><span>.</span><span>NewServeMux</span><span>()</span><span></span>
<span>  </span><span>mux</span><span>.</span><span>HandleFunc</span><span>(</span><span>&#34;/&#34;</span><span>,</span><span> </span><span>httpHandler</span><span>)</span><span></span>
<span>  </span><span>log</span><span>.</span><span>Fatal</span><span>(</span><span>http</span><span>.</span><span>ListenAndServe</span><span>(</span><span>&#34;:8080&#34;</span><span>,</span><span> </span><span>mux</span><span>))</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>This server listens on port 8080 (feel free to change this or make it
more configurable), and registers a catch-all handler for the root path. The
handler parses the actual request URL to find the module name. It then stores
some information to pass to the loaded module in the <tt>env</tt> map.</p>
<p>The loaded module is found with a filesystem lookup in the <tt>target</tt> directory
relative to the FAAS server binary. All of this is just for demonstration
purposes and can be easily changed, of course. The handler then calls
<tt>invokeWasmModule</tt>, which we&#39;ll get to shortly. This function returns the
invoked module&#39;s stdout, which the handler prints out into the HTTP response.</p>
</div>
<div id="running-wasm-code-in-go">
<h2>Running WASM code in Go</h2>
<p>Given a WASM module, how do we run it programmatically in Go? There are several
high-quality WASM <em>runtimes</em> that work outside the browser environment, and many
of them have Go bindings; for example <a href="https://github.com/bytecodealliance/wasmtime-go">wasmtime-go</a>. The one I like most,
however, is <a href="https://github.com/tetratelabs/wazero">wazero</a>; it&#39;s a
zero-dependency, pure Go runtime that doesn&#39;t have any prerequisites except
running a <tt>go get</tt>. Our FAAS server is using <tt>wazero</tt> to load and run
WASM modules.</p>
<p>Here&#39;s <tt>invokeWasmModule</tt>:</p>
<div><pre><span></span><span>// invokeWasmModule invokes the given WASM module (given as a file path),</span><span></span>
<span>// setting its env vars according to env. Returns the module&#39;s stdout.</span><span></span>
<span>func</span><span> </span><span>invokeWasmModule</span><span>(</span><span>modname</span><span> </span><span>string</span><span>,</span><span> </span><span>wasmPath</span><span> </span><span>string</span><span>,</span><span> </span><span>env</span><span> </span><span>map</span><span>[</span><span>string</span><span>]</span><span>string</span><span>)</span><span> </span><span>(</span><span>string</span><span>,</span><span> </span><span>error</span><span>)</span><span> </span><span>{</span><span></span>
<span>  </span><span>ctx</span><span> </span><span>:=</span><span> </span><span>context</span><span>.</span><span>Background</span><span>()</span><span></span>

<span>  </span><span>r</span><span> </span><span>:=</span><span> </span><span>wazero</span><span>.</span><span>NewRuntime</span><span>(</span><span>ctx</span><span>)</span><span></span>
<span>  </span><span>defer</span><span> </span><span>r</span><span>.</span><span>Close</span><span>(</span><span>ctx</span><span>)</span><span></span>
<span>  </span><span>wasi_snapshot_preview1</span><span>.</span><span>MustInstantiate</span><span>(</span><span>ctx</span><span>,</span><span> </span><span>r</span><span>)</span><span></span>

<span>  </span><span>// Instantiate the wasm runtime, setting up exported functions from the host</span><span></span>
<span>  </span><span>// that the wasm module can use for logging purposes.</span><span></span>
<span>  </span><span>_</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>r</span><span>.</span><span>NewHostModuleBuilder</span><span>(</span><span>&#34;env&#34;</span><span>).</span><span></span>
<span>    </span><span>NewFunctionBuilder</span><span>().</span><span></span>
<span>    </span><span>WithFunc</span><span>(</span><span>func</span><span>(</span><span>v</span><span> </span><span>uint32</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;[%v]: %v&#34;</span><span>,</span><span> </span><span>modname</span><span>,</span><span> </span><span>v</span><span>)</span><span></span>
<span>    </span><span>}).</span><span></span>
<span>    </span><span>Export</span><span>(</span><span>&#34;log_i32&#34;</span><span>).</span><span></span>
<span>    </span><span>NewFunctionBuilder</span><span>().</span><span></span>
<span>    </span><span>WithFunc</span><span>(</span><span>func</span><span>(</span><span>ctx</span><span> </span><span>context</span><span>.</span><span>Context</span><span>,</span><span> </span><span>mod</span><span> </span><span>api</span><span>.</span><span>Module</span><span>,</span><span> </span><span>ptr</span><span> </span><span>uint32</span><span>,</span><span> </span><span>len</span><span> </span><span>uint32</span><span>)</span><span> </span><span>{</span><span></span>
<span>      </span><span>// Read the string from the module&#39;s exported memory.</span><span></span>
<span>      </span><span>if</span><span> </span><span>bytes</span><span>,</span><span> </span><span>ok</span><span> </span><span>:=</span><span> </span><span>mod</span><span>.</span><span>Memory</span><span>().</span><span>Read</span><span>(</span><span>ptr</span><span>,</span><span> </span><span>len</span><span>);</span><span> </span><span>ok</span><span> </span><span>{</span><span></span>
<span>        </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;[%v]: %v&#34;</span><span>,</span><span> </span><span>modname</span><span>,</span><span> </span><span>string</span><span>(</span><span>bytes</span><span>))</span><span></span>
<span>      </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span></span>
<span>        </span><span>log</span><span>.</span><span>Printf</span><span>(</span><span>&#34;[%v]: log_string: unable to read wasm memory&#34;</span><span>,</span><span> </span><span>modname</span><span>)</span><span></span>
<span>      </span><span>}</span><span></span>
<span>    </span><span>}).</span><span></span>
<span>    </span><span>Export</span><span>(</span><span>&#34;log_string&#34;</span><span>).</span><span></span>
<span>    </span><span>Instantiate</span><span>(</span><span>ctx</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>err</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>wasmObj</span><span>,</span><span> </span><span>err</span><span> </span><span>:=</span><span> </span><span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>wasmPath</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>err</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>// Set up stdout redirection and env vars for the module.</span><span></span>
<span>  </span><span>var</span><span> </span><span>stdoutBuf</span><span> </span><span>bytes</span><span>.</span><span>Buffer</span><span></span>
<span>  </span><span>config</span><span> </span><span>:=</span><span> </span><span>wazero</span><span>.</span><span>NewModuleConfig</span><span>().</span><span>WithStdout</span><span>(</span><span>&amp;</span><span>stdoutBuf</span><span>)</span><span></span>

<span>  </span><span>for</span><span> </span><span>k</span><span>,</span><span> </span><span>v</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>env</span><span> </span><span>{</span><span></span>
<span>    </span><span>config</span><span> </span><span>=</span><span> </span><span>config</span><span>.</span><span>WithEnv</span><span>(</span><span>k</span><span>,</span><span> </span><span>v</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>// Instantiate the module. This invokes the _start function by default.</span><span></span>
<span>  </span><span>_</span><span>,</span><span> </span><span>err</span><span> </span><span>=</span><span> </span><span>r</span><span>.</span><span>InstantiateWithConfig</span><span>(</span><span>ctx</span><span>,</span><span> </span><span>wasmObj</span><span>,</span><span> </span><span>config</span><span>)</span><span></span>
<span>  </span><span>if</span><span> </span><span>err</span><span> </span><span>!=</span><span> </span><span>nil</span><span> </span><span>{</span><span></span>
<span>    </span><span>return</span><span> </span><span>&#34;&#34;</span><span>,</span><span> </span><span>err</span><span></span>
<span>  </span><span>}</span><span></span>

<span>  </span><span>return</span><span> </span><span>stdoutBuf</span><span>.</span><span>String</span><span>(),</span><span> </span><span>nil</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Interesting things to note about this code:</p>
<ul>
<li><tt>wazero</tt> supports WASI, which has to be instantiated explicitly to be usable
by the loaded modules.</li>
<li>A lot of the code deals with exporting logging functions from the host (the
Go code of the FAAS server) to the WASM module.</li>
<li>We set up the loaded module&#39;s stdout to be redirected to a buffer, and set up
its environment variables to match the <tt>env</tt> map passed in.</li>
</ul>
<p>There are several way for host code to interact with WASM modules using only the
WASI API and ABI. Here, we opt for using environment variables for input and
stdout for output, but there are other options (see the <em>Other resources</em>
section in the bottom for some pointers).</p>
<p>This is it - the whole FAAS server, about 100 LOC of commented Go code. Now
let&#39;s move on to see some WASM modules this thing can load and run.</p>
</div>
<div id="writing-modules-in-go">
<h2>Writing modules in Go</h2>
<p>We can compile Go code to WASM that uses WASI. Here&#39;s a basic Go program that
emits a greeting and a listing of its environment variables to stdout:</p>
<div><pre><span></span><span>package</span><span> </span><span>main</span><span></span>

<span>import</span><span> </span><span>(</span><span></span>
<span>  </span><span>&#34;fmt&#34;</span><span></span>
<span>  </span><span>&#34;os&#34;</span><span></span>
<span>)</span><span></span>

<span>func</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>  </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34;goenv environment:&#34;</span><span>)</span><span></span>

<span>  </span><span>for</span><span> </span><span>_</span><span>,</span><span> </span><span>e</span><span> </span><span>:=</span><span> </span><span>range</span><span> </span><span>os</span><span>.</span><span>Environ</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>fmt</span><span>.</span><span>Println</span><span>(</span><span>&#34; &#34;</span><span>,</span><span> </span><span>e</span><span>)</span><span></span>
<span>  </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Until recently, the only way to compile Go code to WASM that works outside the
browser was by using the <a href="https://tinygo.org/">TinyGo</a> compiler. In our
FAAS project structure, the invocation from the root directory is:</p>
<div><pre><span></span>$ tinygo build -o target/goenv.wasm -target=wasi examples/goenv/goenv.go
</pre></div>
<p>Sharp-eyed readers will recall that the <tt>target/</tt> directory is precisely where
the FAAS server looks for <tt>*.wasm</tt> files to load as modules. Now that we&#39;ve
placed a module named <tt>goenv.wasm</tt> there, we&#39;re ready to launch our server
with <tt>go run .</tt> in the root directory. We can issue a HTTP request to its
<tt>goenv</tt> module in a separate terminal:</p>
<div><pre><span></span>$ curl &#34;localhost:8080/goenv?foo=bar&amp;id=1234&#34;
goenv environment:
  http_method=GET
  http_host=localhost:8080
  http_query=foo=bar&amp;id=1234
  remote_addr=127.0.0.1:59268
  http_path=/goenv
</pre></div>
<p>And looking at the terminal where the FAAS server runs we&#39;ll see some logging
like:</p>
<div><pre><span></span>2023/04/29 06:35:59 module goenv requested with query map[foo:[bar] id:[1234]]
2023/04/29 06:35:59 loading module target/goenv.wasm
</pre></div>
<p>As I&#39;ve mentioned before, this was the main way to compile to WASI <em>until
recently</em>. In the upcoming Go release (version 1.21), new support for the WASI
target is included in the main Go toolchain (the <tt>gc</tt> compiler) <a href="#footnote-1" id="footnote-reference-1">[1]</a>. It&#39;s
easy to try today either by building Go from source, or using <a href="https://pkg.go.dev/golang.org/dl/gotip">gotip</a>:</p>
<div><pre><span></span>$ GOOS=wasip1 GOARCH=wasm gotip build -o target/goenv.wasm examples/goenv/goenv.go
</pre></div>
<p>(the <tt>wasip1</tt> target name refers to &#34;WASI Preview 1&#34;)</p>
</div>
<div id="writing-modules-in-rust">
<h2>Writing modules in Rust</h2>
<p>Rust is another language that has good support for WASM and WASI in the build
system. After adding the <tt><span>wasm32-wasi</span></tt> target with <tt>rustup</tt>, it&#39;s as simple
as passing the target name to <tt>cargo</tt>:</p>
<div><pre><span></span>$ cargo build --target wasm32-wasi --release
</pre></div>
<p>The code is straightforward, similarly to the Go version:</p>
<div><pre><span></span><span>use</span><span> </span><span>std</span>::<span>env</span><span>;</span><span></span>

<span>fn</span> <span>main</span><span>()</span><span> </span><span>{</span><span></span>
<span>    </span><span>println!</span><span>(</span><span>&#34;rustenv environment:&#34;</span><span>);</span><span></span>

<span>    </span><span>for</span><span> </span><span>(</span><span>key</span><span>,</span><span> </span><span>value</span><span>)</span><span> </span><span>in</span><span> </span><span>env</span>::<span>vars</span><span>()</span><span> </span><span>{</span><span></span>
<span>        </span><span>println!</span><span>(</span><span>&#34;  {key}: {value}&#34;</span><span>);</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
</div>
<div id="writing-modules-in-webassembly-text-wat">
<h2>Writing modules in WebAssembly Text (WAT)</h2>
<p>As we&#39;ve seen, compiling Go and Rust code to WASM is fairly easy; looking for a
challenge, let&#39;s write a module in WAT! As <a href="https://eli.thegreenplace.net/2023/webassembly-text-code-samples/">I&#39;ve written before</a>, I enjoy
writing directly in WAT; it&#39;s educational, and produces remarkably compact
binaries.</p>
<p>The &#34;educational&#34; aspect quickly becomes apparent when thinking about our task.
How exactly am I supposed to write to stdout or read environment variables using
WASM? This is where WASI comes in. WASI defines both an API and ABI, both of
which will be visible in our sample. The following shows some code snippets with
explanations; for the full code check out the <a href="https://github.com/eliben/code-for-blog/tree/master/2023/wasm-faas">sample repository</a>.</p>
<p>First, I want to show how output to stdout is done; we start by importing
the <tt>fd_write</tt> WASI system call:</p>
<div><pre><span></span><span>(</span><span>import</span> <span>&#34;wasi_snapshot_preview1&#34;</span> <span>&#34;fd_write&#34;</span> <span>(</span><span>func</span> <span>$fd_write</span> <span>(</span><span>param</span> <span>i32</span> <span>i32</span> <span>i32</span> <span>i32</span><span>)</span> <span>(</span><span>result</span> <span>i32</span><span>)))</span>
</pre></div>
<p>Apparently, it has four <tt>i32</tt> parameters and returns an <tt>i32</tt>; what do all
of these mean? Unfortunately, WASI documentation could use a lot of work; the
resources I found useful are <a href="#footnote-2" id="footnote-reference-2">[2]</a>:</p>
<ol>
<li><a href="https://github.com/WebAssembly/WASI/blob/main/legacy/preview1/docs.md#fd_write">Legacy preview 1 specs</a></li>
<li><a href="https://github.com/WebAssembly/wasi-libc/blob/main/libc-bottom-half/headers/public/wasi/api.h#L1754">C header descriptions of these functions</a></li>
</ol>
<p>With this in hand, I was able to concoct a useful <tt>println</tt> equivalent in
WAT that uses <tt>fd_write</tt> under the hood:</p>
<div><pre><span></span><span>;; println prints a string to stdout using WASI.</span>
<span>;; It takes the string&#39;s address and length as parameters.</span>
<span>(</span><span>func</span> <span>$println</span> <span>(</span><span>param</span> <span>$strptr</span> <span>i32</span><span>)</span> <span>(</span><span>param</span> <span>$len</span> <span>i32</span><span>)</span>
    <span>;; Print the string pointed to by $strptr first.</span>
    <span>;;   fd=1</span>
    <span>;;   data vector with the pointer and length</span>
    <span>(</span><span>i32.store</span> <span>(</span><span>global.get</span> <span>$datavec_addr</span><span>)</span> <span>(</span><span>local.get</span> <span>$strptr</span><span>))</span>
    <span>(</span><span>i32.store</span> <span>(</span><span>global.get</span> <span>$datavec_len</span><span>)</span> <span>(</span><span>local.get</span> <span>$len</span><span>))</span>
    <span>(</span><span>call</span> <span>$fd_write</span>
        <span>(</span><span>i32.const</span> <span>1</span><span>)</span>
        <span>(</span><span>global.get</span> <span>$datavec_addr</span><span>)</span>
        <span>(</span><span>i32.const</span> <span>1</span><span>)</span>
        <span>(</span><span>global.get</span> <span>$fdwrite_ret</span><span>)</span>
    <span>)</span>
    <span>drop</span>

    <span>;; Print out a newline.</span>
    <span>(</span><span>i32.store</span> <span>(</span><span>global.get</span> <span>$datavec_addr</span><span>)</span> <span>(</span><span>i32.const</span> <span>850</span><span>))</span>
    <span>(</span><span>i32.store</span> <span>(</span><span>global.get</span> <span>$datavec_len</span><span>)</span> <span>(</span><span>i32.const</span> <span>1</span><span>))</span>
    <span>(</span><span>call</span> <span>$fd_write</span>
        <span>(</span><span>i32.const</span> <span>1</span><span>)</span>
        <span>(</span><span>global.get</span> <span>$datavec_addr</span><span>)</span>
        <span>(</span><span>i32.const</span> <span>1</span><span>)</span>
        <span>(</span><span>global.get</span> <span>$fdwrite_ret</span><span>)</span>
    <span>)</span>
    <span>drop</span>
<span>)</span>
</pre></div>
<p>This uses some globals that you&#39;ll have to look up in the <a href="https://github.com/eliben/code-for-blog/blob/master/2023/wasm-faas/examples/watenv.wat">full code sample</a>
if you&#39;re interested. Here&#39;s another helper function that prints out a
zero-terminated string to stdout:</p>
<div><pre><span></span><span>;; show_env emits a single env var pair to stdout. envptr points to it,</span>
<span>;; and it&#39;s 0-terminated.</span>
<span>(</span><span>func</span> <span>$show_env</span> <span>(</span><span>param</span> <span>$envptr</span> <span>i32</span><span>)</span>
    <span>(</span><span>local</span> <span>$i</span> <span>i32</span><span>)</span>
    <span>(</span><span>local.set</span> <span>$i</span> <span>(</span><span>i32.const</span> <span>0</span><span>))</span>

    <span>;; for i = 0; envptr[i] != 0; i++</span>
    <span>(</span><span>loop</span> <span>$count_loop</span> <span>(</span><span>block</span> <span>$break_count_loop</span>
        <span>(</span><span>i32.eqz</span> <span>(</span><span>i32.load8_u</span> <span>(</span><span>i32.add</span> <span>(</span><span>local.get</span> <span>$envptr</span><span>)</span> <span>(</span><span>local.get</span> <span>$i</span><span>))))</span>
        <span>br_if</span> <span>$break_count_loop</span>

        <span>(</span><span>local.set</span> <span>$i</span> <span>(</span><span>i32.add</span> <span>(</span><span>local.get</span> <span>$i</span><span>)</span> <span>(</span><span>i32.const</span> <span>1</span><span>)))</span>
        <span>br</span> <span>$count_loop</span>
    <span>))</span>

    <span>(</span><span>call</span> <span>$println</span> <span>(</span><span>local.get</span> <span>$envptr</span><span>)</span> <span>(</span><span>local.get</span> <span>$i</span><span>))</span>
<span>)</span>
</pre></div>
<p>The fun part about writing assembly is that there are no abstractions.
Everything is out in the open. You know how strings are typically represented
using either zero termination (like in C) or a <tt>(start, len)</tt> pair?
In manual WAT code that uses WASI we have the pleasure of using both approaches
in the same program :-)</p>
<p>Finally, our main function:</p>
<div><pre><span></span><span>(</span><span>func</span> <span>$main</span> <span>(</span><span>export</span> <span>&#34;_start&#34;</span><span>)</span>
    <span>(</span><span>local</span> <span>$i</span> <span>i32</span><span>)</span>
    <span>(</span><span>local</span> <span>$num_of_envs</span> <span>i32</span><span>)</span>
    <span>(</span><span>local</span> <span>$next_env_ptr</span> <span>i32</span><span>)</span>

    <span>(</span><span>call</span> <span>$log_string</span> <span>(</span><span>i32.const</span> <span>750</span><span>)</span> <span>(</span><span>i32.const</span> <span>19</span><span>))</span>

    <span>;; Find out the number of env vars.</span>
    <span>(</span><span>call</span> <span>$environ_sizes_get</span> <span>(</span><span>global.get</span> <span>$env_count</span><span>)</span> <span>(</span><span>global.get</span> <span>$env_len</span><span>))</span>
    <span>drop</span>

    <span>;; Get the env vars themselves into memory.</span>
    <span>(</span><span>call</span> <span>$environ_get</span> <span>(</span><span>global.get</span> <span>$env_ptrs</span><span>)</span> <span>(</span><span>global.get</span> <span>$env_buf</span><span>))</span>
    <span>drop</span>

    <span>;; Print out the preamble</span>
    <span>(</span><span>call</span> <span>$println</span> <span>(</span><span>i32.const</span> <span>800</span><span>)</span> <span>(</span><span>i32.const</span> <span>19</span><span>))</span>

    <span>;; for i = 0; i != *env_count; i++</span>
    <span>;;   show env var i</span>
    <span>(</span><span>local.set</span> <span>$num_of_envs</span> <span>(</span><span>i32.load</span> <span>(</span><span>global.get</span> <span>$env_count</span><span>)))</span>
    <span>(</span><span>local.set</span> <span>$i</span> <span>(</span><span>i32.const</span> <span>0</span><span>))</span>
    <span>(</span><span>loop</span> <span>$envvar_loop</span> <span>(</span><span>block</span> <span>$break_envvar_loop</span>
        <span>(</span><span>i32.eq</span> <span>(</span><span>local.get</span> <span>$i</span><span>)</span> <span>(</span><span>local.get</span> <span>$num_of_envs</span><span>))</span>
        <span>(</span><span>br_if</span> <span>$break_envvar_loop</span><span>)</span>

        <span>;; next_env_ptr &lt;- env_ptrs[i*4]</span>
        <span>(</span><span>local.set</span>
            <span>$next_env_ptr</span>
            <span>(</span><span>i32.load</span> <span>(</span><span>i32.add</span>  <span>(</span><span>global.get</span> <span>$env_ptrs</span><span>)</span>
                                <span>(</span><span>i32.mul</span> <span>(</span><span>local.get</span> <span>$i</span><span>)</span> <span>(</span><span>i32.const</span> <span>4</span><span>)))))</span>

        <span>;; print out this env var</span>
        <span>(</span><span>call</span> <span>$show_env</span> <span>(</span><span>local.get</span> <span>$next_env_ptr</span><span>))</span>

        <span>(</span><span>local.set</span> <span>$i</span> <span>(</span><span>i32.add</span> <span>(</span><span>local.get</span> <span>$i</span><span>)</span> <span>(</span><span>i32.const</span> <span>1</span><span>)))</span>
        <span>(</span><span>br</span> <span>$envvar_loop</span><span>)</span>
    <span>))</span>
<span>)</span>
</pre></div>
<p>We can now compile this WAT code into a FAAS module and re-run the server:</p>
<div><pre><span></span>$ wat2wasm examples/watenv.wat -o target/watenv.wasm
$ go run .
</pre></div>
<p>Let&#39;s try it:</p>
<div><pre><span></span>$ curl &#34;localhost:8080/watenv?foo=bar&amp;id=1234&#34;
watenv environment:
http_host=localhost:8080
http_query=foo=bar&amp;id=1234
remote_addr=127.0.0.1:43868
http_path=/watenv
http_method=GET
</pre></div>
<div id="wasi-api-and-abi">
<h3>WASI: API and ABI</h3>
<p>I&#39;ve mentioned the <em>WASI API and ABI</em> earlier; now it&#39;s a good time to explain
what that means. An API is a set of functions that programs using WASI have
access to; one can think of it as a standard library of sorts. Go programmers
have access to the <tt>fmt</tt> package and the <tt>Println</tt> function within it.
Programs targeting WASI have access to the <tt>fd_write</tt> system call in the
<tt>wasi_snapshow_preview1</tt> module, and so on. The API of <tt>fd_write</tt> also
defines how this function takes parameters and what it returns. Our sample uses
three WASI functions: <tt>fd_write</tt>, <tt>environ_sizes_get</tt> and <tt>environ_get</tt>.</p>
<p>An ABI is a little bit less familiar to most programmers; it&#39;s the run-time
contract between a program and its environment. The WASI ABI is currently
unstable and is <a href="https://github.com/WebAssembly/WASI/blob/main/legacy/application-abi.md">described here</a>. In
our program, the ABI manifests in two ways:</p>
<ol>
<li>The main entry point we export is the <tt>_start</tt> function. This is
automatically called by a WASI-supporting host after setup.</li>
<li>Our WASM code exports its linear memory to the host with
<tt>(memory (export &#34;memory&#34;) 1)</tt>. Since WASI APIs require passing pointers
to memory, both the host and the WASM module need a shared understanding
of how to access this memory.</li>
</ol>
<p>Naturally, both the Go and Rust implementations of FAAS modules comply to the
WASI API and ABI, but this is hidden by the compiler from programmers. In the
Go program, for example, all we need to do is write a <tt>main</tt> function as usual
and therein emit to stdout using <tt>Println</tt>. The Go compiler will properly
export <tt>_start</tt> and <tt>memory</tt>:</p>
<div><pre><span></span>$ wasm-objdump -x target/goenv.wasm

... snip

Export[2]:
 - func[1028] &lt;_rt0_wasm_wasip1&gt; -&gt; &#34;_start&#34;
 - memory[0] -&gt; &#34;memory&#34;

... snip
</pre></div>
<p>And will properly hook things up to call our code from <tt>_start</tt>, etc.</p>
</div>
</div>
<div id="wasi-and-plugins">
<h2>WASI and plugins</h2>
<p>The FAAS server presented in this post is clearly an example of developing
<em>plugins</em> using WASM and WASI. This is an emerging and exciting area in
programming and lots of progress is being made on multiple fronts. Right now,
WASI modules are limited to interacting with the environment via means like
environment variables and stdin/stdout; while this is fine for interacting
with the outside world, for host-to-module communication it&#39;s not amazing, in
my experience. Therefore the WASM standards committee is working of further
improvements to WASI that may include sockets and other means of passing data
between hosts and modules.</p>
<p>In the meantime, projects are making do with what they have. For example, the
<a href="https://sqlc.dev/">sqlc Go package</a> supports WASM plugins. The communication
with plugins happens as follows: the host encodes a command into a protobuf
and emits it to the plugin&#39;s stdin; it then reads the plugin&#39;s stdout for a
protobuf-encoded response.</p>
<p>Other projects are taking more maverick approaches; for example, <a href="https://www.envoyproxy.io/">the Envoy
proxy</a> supports WASM plugins by defining a custom
API and ABI between the host and WASM modules. I&#39;ll probably write more about
this in a later post.</p>
</div>
<div id="other-resources">
<h2>Other resources</h2>
<p>Here are some additional resources on the same topic as this post:</p>
<ul>
<li><a href="https://blog.scottlogic.com/2022/04/16/wasm-faas.html">Building a WebAssembly-powered serverless platform</a> - the
post that inspired this one. Other WASM-related articles from that blog are
also recommended.</li>
<li><a href="https://github.com/deislabs/wagi">wagi</a> - a more featured approch with
the same idea, implemented in Rust.</li>
<li><a href="https://wasmer.io/posts/announcing-wcgi">WCGI</a> - an even more
CGI-conformant approach.</li>
</ul>
<hr/>


</div>

            </div>
            <!-- /.entry-content -->
<hr/>
<p>
For comments, please send me
<a href="mailto:eliben@gmail.com"><i></i> an email</a>.
</p>        </article>
    </section>

    </div>
</div></div>
  </body>
</html>
