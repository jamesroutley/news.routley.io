<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://domain-j.com/Igneous-Linearizer/uuid/9e30337c-b890-4fd9-a0bd-51a7aa6e65b0">Original</a>
    <h1>Igneous Linearizer: semi-structured source code</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Intro</h2><p>I&#39;ve long wanted more structured source code than just plaintext.</p><p>The solution I&#39;ve been waiting for is <i>source-code-in-the-database</i>. I&#39;m cheering on multiple projects attempting this. I still hope it&#39;s the future, but in the meantime I&#39;ve been experimenting with a stopgap measure.</p><p>What about <i>source-code-as-hypertext</i>?</p><h2>Enter Obsidian</h2><p>My favorite form of hypertext to write by hand at the moment is <a href="https://domain-j.com/Obsidian/uuid/499a4241-e118-4ae5-be61-3079a019fb36"><span>üíæ‚Äâ<span>Obsidian</span></span></a> Markdown. Notably it provides links, backlinks, renaming, attributes and transclusion, all based on <code>[[wikilinks]]</code>.</p><p>That&#39;s interesting, because these are a lot like what a code editor provides. <code>[[links]]</code> are &#34;Jump to Definition&#34;. Backlinks are &#34;Find References&#34;. Vault-wide link renaming is &#34;Rename Symbol&#34;.</p><p>And while attributes and transclusion don&#39;t have equivalents in code editors, I can think of ways they could be useful. Most notably transclusion‚Äî I really want to be able to duplicate a note into multiple doc comments and know it will stay up-to-date, or vice versa duplicate a piece of code into multiple notes.</p><p>Thus Obsidian, IDE.</p><h2>Example</h2><p>Take the following program in the form of three files:</p><div><h3><a href="https://domain-j.com/sicp.compound.square/uuid/4a53858c-cb82-4e7b-98cc-d5c9cda15fd0">square</a></h3><div><pre>(define (square x) (* x x))
</pre></div></div><p>The above is about how they look when viewed in Obsidian. Viewed in a plaintext editor they look like this:</p><h3><code>square.md</code></h3><pre><code>(define (square x) (* x x))</code></pre><h3><code>sum-of-squares.md</code></h3><pre><code>(define (sum-of-squares x y)
	(+ ([[square]] x) ([[square]] y)))</code></pre><h3><code>main.md</code></h3><pre><code>(display ([[sum-of-squares]] 2 3))</code></pre>
<p>The linearizer transpiles them into a form that can be executed:</p><pre><code>$ igneous-linearizer main.md &gt; main.scm</code></pre><p>The linearizer can&#39;t assume that sibling files of the root file are part of the same program. This might be the user&#39;s personal Obsidian vault with thousands of pages in it. Instead it crawls links from <code>main.md</code>, topologically sorts the results, concatenates them, and outputs the following:</p><h3><code>main.scm</code></h3><pre><code>(define (square x) (* x x))

(define (sum-of-squares x y)
    (+ (square x) (square y)))

(display (sum-of-squares 2 3))</code></pre>
<h2>Tradeoffs vs. Source-in-a-Database</h2><p>Unlike storing ASTs in a database you don&#39;t get guaranteed-correct syntax.</p><p>In return for this you get a reasonably &#34;normalish&#34; development experience, for better or worse. You can still use any text editor to inspect the state of your codebase. Most importantly you can still use git.</p><p>Also, this strategy is completely langauge-agnostic. Scheme, Rust, your new protolang, whatever you want, the linearizer can handle it.</p><h2>Wait, How Serious is This?</h2><p>Not very. To actually have an ergonomic programming experience in Obsidian you&#39;d need a lot of plugins that don&#39;t exist. This project is just scouting and tire kicking.</p><p>With a couple exceptions...</p><ul><li>Publishing, such as this website. The linearizer allows a form of literate programming with granular code definitions alongside prose.</li><li>Protolangs, since some tooling is better than none.</li></ul><h2>If You&#39;re Going to Use It Anyway</h2><p>The main thing you need to be aware of is the difference between hyperstrings and Markdown.</p><p>The linearizer takes hyperstring files as input, preceded by optional frontmatter. &#34;Hyperstring&#34; is a made up term for plaintext plus links. Here are the types:</p><div><h3><a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1">HyperstringSegment</a></h3><div><pre>#[derive(PartialEq, Debug, Clone)]
pub enum HyperstringSegment {
    Text(String),
    Link(String),
    Transclusion(String),
}
</pre></div></div><p>This is not Obsidian Markdown, but rather a subset of it. Using Obsidian to write hyperstrings is a hack. It works OK in editing mode, but in &#34;Reading view&#34; (used to display transclusions) the indentation will be messed up.</p><p>In the same way if you&#39;re using hyperstrings as the source for a static site generator you&#39;ll need to control the output. If parsed as Markdown and then rendered indentation will be interpreted wrong. You need to parse it as a hyperstring and then wrap the rendered result in a <code>&lt;pre&gt;</code> tag.</p><h2>Read More</h2><ul><li><a href="https://domain-j.com/Igneous-Linearizer-%28pre-development-README%29/uuid/ab4789b0-6ffa-4626-9cd0-3f0a2cb019fa"><span>üêâ‚Äâ<span>Igneous Linearizer (pre-development README)</span></span></a></li><li><a href="https://domain-j.com/Hypermedia-Source-Code---SICP-1.1.4-Example/uuid/19652cc9-69a2-4bda-aede-e6b24fde51e2"><span>üìù‚Äâ<span>Hypermedia Source Code: SICP 1.1.4 Example</span></span></a></li></ul><h2>Implementation</h2><p>The rest of this page is the linearizer itself.</p><p>See the <a href="https://github.com/seagreen/igneous_linearizer">GitHub repo</a> if you want to run it.</p><h2>Graph</h2><h2>Code</h2><h3>Main</h3><div><h3><a href="https://domain-j.com/igneous.main/uuid/3b23a239-cc49-465f-9edb-e466724ab102">main</a></h3><div><pre>fn main() {
    let args = <a href="https://domain-j.com/igneous.Args/uuid/2bbb74cd-be92-4cdd-817d-741c8e0a0473"><span><span>Args</span></span></a>::parse();

    let vault_dir = args.root_file.parent().unwrap();
    let root_file_name = args.root_file.file_name().unwrap().to_str().unwrap();
    let root_base_name = root_file_name
        .strip_suffix(&#34;.md&#34;)
        .unwrap_or(&#34;Initial file must start with .md&#34;);

    let page_map = <a href="https://domain-j.com/igneous.crawl/uuid/23fa5bfd-bf48-4a84-b7ec-f2c2412ca5c1"><span><span>crawl</span></span></a>(vault_dir, root_base_name);

    let hyperstrings = <a href="https://domain-j.com/igneous.transform/uuid/78ebcfc2-76ff-48a1-8880-631e30194b44"><span><span>transform</span></span></a>(&amp;page_map, root_base_name);

    // It&#39;s tempting to try to handle `--single` earlier and exit,
    // but even `--single` still needs to:
    //
    // + crawl to depth 1 for link titles
    // + possibly crawl more if it has transclusions
    // + check for transclusion cycles
    //
    if args.single {
        let root_page = page_map.get(root_base_name).unwrap();
        println!(&#34;{}&#34;, root_page.hyperstring.<a href="https://domain-j.com/igneous.to_plaintext/uuid/71638d9e-3f2e-45d5-a8e1-3ba63a334efa"><span><span>to_plaintext</span></span></a>(&amp;page_map));
    } else {
        println!(&#34;{}&#34;, <a href="https://domain-j.com/igneous.hyperstrings_to_string/uuid/35c6799b-e49e-4ffa-96d9-651e220bce87"><span><span>hyperstrings_to_string</span></span></a>(page_map, hyperstrings));
    }
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.Args/uuid/2bbb74cd-be92-4cdd-817d-741c8e0a0473">Args</a></h3><div><pre>#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    #[arg(value_name = &#34;ROOT_FILE_PATH&#34;)]
    root_file: PathBuf,

    #[arg(
        long,
        help = concat!(
            &#34;Only transpile ROOT_FILE_PATH, don&#39;t crawl its dependencies and include them in the output as well.&#34;,
            &#34; Useful for compiling import blocks that must be at the start of a file,&#34;,
            &#34; e.g. `igneous-linearizer --single import.md &gt; main.rs; igneous-linearierizer main.md &gt;&gt; main.rs&#34;
        )
    )]
    single: bool,
}
</pre></div></div><h3>Input</h3><div><h3><a href="https://domain-j.com/igneous.crawl/uuid/23fa5bfd-bf48-4a84-b7ec-f2c2412ca5c1">crawl</a></h3><div><pre>/// Read in all files transitively referenced by `root_base_name`.
///
/// This is the only input phase of the program, after this is processing and output.
pub fn crawl(vault_dir: &amp;Path, root_base_name: &amp;str) -&gt; HashMap&lt;String, <a href="https://domain-j.com/igneous.Page/uuid/72fac517-39aa-43d9-a340-02361d3f2a87"><span><span>Page</span></span></a>&gt; {
    let mut visited: HashMap&lt;String, Page&gt; = HashMap::new();
    let mut to_visit: Vec&lt;String&gt; = vec![root_base_name.to_string()];

    while let Some(base_name) = to_visit.pop() {
        if visited.contains_key(&amp;base_name) {
            continue;
        }
        let full_path = vault_dir.join(format!(&#34;{}.md&#34;, base_name));
        let file_content = fs::read_to_string(&amp;full_path)
            .unwrap_or_else(|_| panic!(&#34;Attempted to read the file {}&#34;, full_path.display()));
        let (metadata, hyperstring) = <a href="https://domain-j.com/igneous.parse_page/uuid/5b80d963-938f-418b-a0f8-e6d5b05fb165"><span><span>parse_page</span></span></a>(&amp;file_content);

        for reference in hyperstring.<a href="https://domain-j.com/igneous.references/uuid/2e3088b9-1ea3-48cb-bbcf-7fa1b0eb8881"><span><span>references</span></span></a>() {
            to_visit.push(reference);
        }
        visited.insert(
            base_name,
            <a href="https://domain-j.com/igneous.Page/uuid/72fac517-39aa-43d9-a340-02361d3f2a87"><span><span>Page</span></span></a> {
                metadata,
                hyperstring: hyperstring.clone(),
            },
        );
    }

    visited
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.parse_page/uuid/5b80d963-938f-418b-a0f8-e6d5b05fb165">parse_page</a></h3><div><pre>/// Parse a single page consisting of YAML frontmatter, Dataview attributes, and a hyperstring.
///
/// The frontmatter and Dataview attributes are optional.
///
/// Dataview attributes looks like `key:: value`.
/// This section will eventually go away as Obsidian&#39;s frontmatter support matures.
pub fn parse_page(input: &amp;str) -&gt; (HashMap&lt;String, gray_matter::Pod&gt;, <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>) {
    let (frontmatter, content_without_frontmatter) = <a href="https://domain-j.com/igneous.parse_frontmatter/uuid/69f6b48a-6f93-466d-9699-8c46831b21a5"><span><span>parse_frontmatter</span></span></a>(input);
    let final_content = <a href="https://domain-j.com/igneous.strip_dataview_block/uuid/405ad342-b428-4d8e-a8d8-42a28859d899"><span><span>strip_dataview_block</span></span></a>(&amp;content_without_frontmatter);
    let hyperstring = <a href="https://domain-j.com/igneous.parse_hyperstring/uuid/ca0f2ad5-25ce-456a-a720-11164d5091c7"><span><span>parse_hyperstring</span></span></a>(&amp;final_content);
    (frontmatter, hyperstring)
}
#[cfg(test)]
mod parse_page_tests {
    use super::*;

    #[test]
    fn test_parse_input() {
        let input = r#&#34;---
foo: bar
---

baz::quux

lorem ipsum

&#34;#;
        let (frontmatter, content) = parse_page(input);
        let expected_frontmatter = HashMap::from([(
            &#34;foo&#34;.to_string(),
            gray_matter::Pod::String(&#34;bar&#34;.to_string()),
        )]);
        let expected = <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Text(&#34;lorem ipsum\n&#34;.to_string())]);
        assert_eq!(frontmatter, expected_frontmatter);
        assert_eq!(content, expected);
    }
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.parse_frontmatter/uuid/69f6b48a-6f93-466d-9699-8c46831b21a5">parse_frontmatter</a></h3><div><pre>/// Parses frontmatter if present. Returns it and the non-frontmatter remainder of the input.
pub fn parse_frontmatter(file_content: &amp;str) -&gt; (HashMap&lt;String, gray_matter::Pod&gt;, String) {
    let matter = Matter::&lt;gray_matter::engine::YAML&gt;::new();
    let result = matter.parse(file_content);

    let frontmatter = match result.data {
        Some(data) =&gt; match data {
            gray_matter::Pod::Hash(map) =&gt; map,
            _ =&gt; panic!(&#34;Expected Pod::Hash but found other variant&#34;),
        },
        None =&gt; HashMap::new(),
    };

    (frontmatter, result.content)
}

#[cfg(test)]
mod parse_frontmatter_tests {
    use super::*;

    #[test]
    fn test_frontmatter() {
        let content = r#&#34;---
foo: bar
---
lorem ipsum

&#34;#;
        let (frontmatter, content) = parse_frontmatter(content);
        let expected = HashMap::from([(
            &#34;foo&#34;.to_string(),
            gray_matter::Pod::String(&#34;bar&#34;.to_string()),
        )]);
        assert_eq!(frontmatter, expected);
        assert_eq!(content, &#34;lorem ipsum\n&#34;);
    }
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.strip_dataview_block/uuid/405ad342-b428-4d8e-a8d8-42a28859d899">strip_dataview_block</a></h3><div><pre>/// Strips a block of Dataview attributes if present. Returns the non-Dataview remainder of the input.
pub fn strip_dataview_block(input: &amp;str) -&gt; String {
    let pattern = r&#34;^\n*([^\s:]+::.*\n)+\n*&#34;;
    let re = Regex::new(pattern).unwrap();

    re.replace(input, &#34;&#34;).to_string()
}

#[cfg(test)]
mod strip_dataview_block_tests {
    use super::*;

    #[test]
    fn test_dataview() {
        let input = r#&#34;

foo::bar

lorem ipsum
&#34;#;
        let expected = &#34;lorem ipsum\n&#34;;
        assert_eq!(strip_dataview_block(input), expected);

        let input_with_no_match = &#34;\n\nfoo\nbar\n&#34;;
        assert_eq!(
            strip_dataview_block(input_with_no_match),
            input_with_no_match
        );
    }
}
</pre></div></div><h3>Transform</h3><div><h3><a href="https://domain-j.com/igneous.cyclic_transclusion_check/uuid/27f61c60-cc72-42d0-ba4f-f16d4fd533ad">cyclic_transclusion_check</a></h3><div><pre>/// If transclusions form a cycle return `Some` and the base filename of one of the pages involved.
/// Otherwise return `None`.
pub fn cyclic_transclusion_check(page_map: &amp;HashMap&lt;String, <a href="https://domain-j.com/igneous.Page/uuid/72fac517-39aa-43d9-a340-02361d3f2a87"><span><span>Page</span></span></a>&gt;) -&gt; Option&lt;String&gt; {
    let mut node_map: HashMap&lt;String, _&gt; = HashMap::new();
    let mut graph: Graph&lt;&amp;str, ()&gt; = DiGraph::new();

    for base_name in page_map.keys() {
        let node = graph.add_node(base_name);
        node_map.insert(base_name.clone(), node);
    }

    for (base_name, page) in page_map {
        let node = node_map.get(base_name).unwrap();
        for transclusion in &amp;page.hyperstring.<a href="https://domain-j.com/igneous.transclusions/uuid/b7f1ca8d-66a8-487e-a486-740877fd127c"><span><span>transclusions</span></span></a>() {
            let target_node = node_map.get(transclusion).unwrap();
            graph.add_edge(*node, *target_node, ());
        }
    }

    match petgraph::algo::toposort(&amp;graph, None) {
        Ok(_) =&gt; None,
        Err(cycle) =&gt; Some(graph.node_weight(cycle.node_id()).unwrap().to_string()),
    }
}

#[cfg(test)]
mod cyclic_transclusion_check_tests {
    use super::*;

    #[test]
    fn test_cycle() {
        let mut page_map = HashMap::new();
        page_map.insert(
            &#34;page-1&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Transclusion(
                    &#34;page-2&#34;.to_string(),
                )]),
            },
        );
        page_map.insert(
            &#34;page-2&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Transclusion(
                    &#34;page-3&#34;.to_string(),
                )]),
            },
        );
        page_map.insert(
            &#34;page-3&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Transclusion(
                    &#34;page-1&#34;.to_string(),
                )]),
            },
        );
        let result = cyclic_transclusion_check(&amp;page_map);
        assert!(
            matches!(result, Some(page) if page == &#34;page-1&#34; || page == &#34;page-2&#34; || page == &#34;page-3&#34;)
        );
    }

    #[test]
    fn test_loop() {
        let mut page_map = HashMap::new();
        page_map.insert(
            &#34;page-1&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Transclusion(
                    &#34;page-1&#34;.to_string(),
                )]),
            },
        );

        let result = cyclic_transclusion_check(&amp;page_map);
        assert_eq!(result, Some(&#34;page-1&#34;.to_string()));
    }

    #[test]
    fn test_no_cycle() {
        let mut page_map = HashMap::new();
        page_map.insert(
            &#34;page-1&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Transclusion(
                    &#34;page-2&#34;.to_string(),
                )]),
            },
        );
        page_map.insert(
            &#34;page-2&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![HyperstringSegment::Transclusion(
                    &#34;page-3&#34;.to_string(),
                )]),
            },
        );
        page_map.insert(
            &#34;page-3&#34;.to_string(),
            Page {
                metadata: HashMap::new(),
                hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![]),
            },
        );
        assert_eq!(cyclic_transclusion_check(&amp;page_map), None);
    }
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.linearize/uuid/c7aef55f-a015-4822-9145-3bc3db9cf50f">linearize</a></h3><div><pre>/// Topologically sort all pages transitively referenced by the root page.
///
/// Invariant: always returns the root page as the first element of the output vector.
///
/// Transclusions will have their transitive references included.
/// So if you transclude some code which itself references other pages,
/// those pages will appear in the output vector.
///
/// The transclusion itself though will not
/// (assuming it&#39;s only used as a transclusion and never linked to).
/// In that case it&#39;s assumed to be a snippet not a standalone code definition.
/// Therefore it shouldn&#39;t appear at the top level of the eventual output file
/// and thus isn&#39;t included at the top level of the output vector here.
pub fn linearize(page_map: &amp;HashMap&lt;String, <a href="https://domain-j.com/igneous.Page/uuid/72fac517-39aa-43d9-a340-02361d3f2a87"><span><span>Page</span></span></a>&gt;, root_base_name: &amp;str) -&gt; Vec&lt;<a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>&gt; {
    let all_links: HashSet&lt;String&gt; = page_map
        .values()
        .flat_map(|page| page.hyperstring.<a href="https://domain-j.com/igneous.links/uuid/ecb2e766-b60c-496f-8f3b-f01ba4438a15"><span><span>links</span></span></a>())
        .collect();

    let mut result = Vec::new();
    let mut seen_set: HashSet&lt;String&gt; = HashSet::new();
    let mut stack = vec![root_base_name.to_string()];

    while let Some(base_name) = stack.pop() {
        let page = page_map.get(&amp;base_name).unwrap();
        if base_name == root_base_name || all_links.contains(&amp;base_name) {
            result.push(page.hyperstring.clone());
        }
        for reference in page.hyperstring.<a href="https://domain-j.com/igneous.references/uuid/2e3088b9-1ea3-48cb-bbcf-7fa1b0eb8881"><span><span>references</span></span></a>() {
            if !seen_set.contains(&amp;reference) {
                stack.push(reference.clone());
                seen_set.insert(reference.clone());
            }
        }
    }

    result
}
</pre></div></div><h3>Output</h3><h3>Page</h3><div><h3><a href="https://domain-j.com/igneous.Page/uuid/72fac517-39aa-43d9-a340-02361d3f2a87">Page</a></h3><div><pre>pub struct Page {
    pub metadata: HashMap&lt;String, gray_matter::Pod&gt;,
    pub hyperstring: <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>,
}
</pre></div></div><h3>Hyperstring</h3><div><h3><a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1">HyperstringSegment</a></h3><div><pre>#[derive(PartialEq, Debug, Clone)]
pub enum HyperstringSegment {
    Text(String),
    Link(String),
    Transclusion(String),
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.transclusions/uuid/b7f1ca8d-66a8-487e-a486-740877fd127c">transclusions</a></h3><div><pre>impl <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a> {
    pub fn transclusions(&amp;self) -&gt; Vec&lt;String&gt; {
        self.0
            .iter()
            .filter_map(|segment| {
                if let <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Transclusion(transclusion) = segment {
                    Some(transclusion.clone())
                } else {
                    None
                }
            })
            .collect()
    }
}
</pre></div></div><div><h3><a href="https://domain-j.com/igneous.parse_hyperstring/uuid/ca0f2ad5-25ce-456a-a720-11164d5091c7">parse_hyperstring</a></h3><div><pre>pub fn parse_hyperstring(input: &amp;str) -&gt; <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a> {
    let opening_brackets = r&#34;\[\[&#34;;
    let closing_brackets = r&#34;\]\]&#34;;
    let pattern = format!(&#34;(({opening_brackets}|!{opening_brackets})(.+?){closing_brackets})&#34;);
    let re = Regex::new(&amp;pattern).unwrap();

    let mut segments: Vec&lt;<a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>&gt; = Vec::new();
    let mut last_end = 0;

    // Need to do this instead of having `Link` and `Text` named matches,
    // because if we make the latter `.+` is will gobble everything up.
    // If we make it `.+?` it outputs `Text(&#34;f&#34;), Text(&#34;o&#34;), Text(&#34;o&#34;)`` etc.
    for cap in re.captures_iter(input) {
        let start = cap.get(0).unwrap().start();
        let end = cap.get(0).unwrap().end();
        let text = &amp;input[last_end..start];
        if !text.is_empty() {
            segments.push(<a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(text.to_string()));
        }
        if cap[0].starts_with(&#34;!\u{005B}\u{005B}&#34;) {
            segments.push(<a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Transclusion(cap[3].to_string()));
        } else {
            segments.push(<a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Link(cap[3].to_string()));
        }
        last_end = end;
    }

    if last_end &lt; input.len() {
        segments.push(<a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(input[last_end..].to_string()));
    }

    Hyperstring(segments)
}

#[cfg(test)]
mod parse_hyperstring_tests {
    use super::*;

    const OPEN: &amp;str = &#34;\u{005B}\u{005B}&#34;; // Two `[`s

    #[test]
    fn test_parse_hyperstring() {
        let input = format!(&#34;foo {OPEN}bar]] baz&#34;);
        let hyperstring = parse_hyperstring(&amp;input);
        let expected = <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34;foo &#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Link(&#34;bar&#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34; baz&#34;.to_string()),
        ]);
        assert_eq!(hyperstring, expected);
    }

    #[test]
    fn test_parse_transclusion_hyperstring() {
        let input = format!(&#34;foo !{OPEN}bar]] baz&#34;);
        let hyperstring = parse_hyperstring(&amp;input);
        let expected = <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34;foo &#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Transclusion(&#34;bar&#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34; baz&#34;.to_string()),
        ]);
        assert_eq!(hyperstring, expected);
    }

    #[test]
    fn test_parse_hyperstring_trailing() {
        let input = format!(&#34;foo {OPEN}bar]] baz]]&#34;);
        let hyperstring = parse_hyperstring(&amp;input);
        let expected = <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34;foo &#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Link(&#34;bar&#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34; baz]]&#34;.to_string()),
        ]);
        assert_eq!(hyperstring, expected);
    }

    // Consider forbidding this.
    #[test]
    fn test_parse_hyperstring_interior() {
        let input = format!(&#34;foo {OPEN}ba]r]] baz&#34;);
        let hyperstring = parse_hyperstring(&amp;input);
        let expected = <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a>(vec![
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34;foo &#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Link(&#34;ba]r&#34;.to_string()),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(&#34; baz&#34;.to_string()),
        ]);
        assert_eq!(hyperstring, expected);
    }
}

</pre></div></div><div><h3><a href="https://domain-j.com/igneous.link_title_or_name/uuid/b23b7746-0f68-43fb-8a82-e018bc947017">link_title_or_name</a></h3><div><pre>pub fn link_title_or_name(page_map: &amp;HashMap&lt;String, Page&gt;, base_name: &amp;str) -&gt; String {
    match page_map.get(base_name) {
        Some(page) =&gt; match page.metadata.get(&#34;title&#34;) {
            Some(gray_matter::Pod::String(title)) =&gt; title.clone(),
            Some(other) =&gt; panic!(
                &#34;Expected the title value of {} to be a string, got: {:?}&#34;,
                base_name, other
            ),
            None =&gt; base_name.to_string(),
        },
        None =&gt; base_name.to_string(),
    }
}
</pre></div></div><h3>Import</h3><div><h3><a href="https://domain-j.com/Igneous-Linearizer-imports/uuid/4421ab6f-0b95-4a16-a6b2-9e015b838d60">Igneous Linearizer imports</a></h3><div><pre>use clap::Parser;
use gray_matter::Matter;
use petgraph::graph::DiGraph;
use petgraph::Graph;
use regex::Regex;
use std::collections::HashMap;
use std::collections::HashSet;
use std::fmt;
use std::fs;
use std::path::Path;
use std::path::PathBuf;

</pre></div></div><h3>Snippets</h3><div><h3><a href="https://domain-j.com/Igneous-Linearizer-snippets/uuid/48d7f111-dc4b-4937-94fe-6916d1373b06">Igneous Linearizer snippets</a></h3><div><pre>impl fmt::Display for <a href="https://domain-j.com/igneous.Hyperstring/uuid/cca31ccd-db07-4d36-9650-e27a3262908f"><span><span>Hyperstring</span></span></a> {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for segment in &amp;self.0 {
            write!(f, &#34;{}&#34;, segment)?;
        }
        Ok(())
    }
}

impl fmt::Display for <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a> {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Text(text) =&gt; write!(f, &#34;{}&#34;, text),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Link(link) =&gt; write!(f, &#34;\u{005B}\u{005B}{}]]&#34;, link),
            <a href="https://domain-j.com/igneous.HyperstringSegment/uuid/c987b419-6bbb-4d6d-b919-36c75a6886e1"><span><span>HyperstringSegment</span></span></a>::Transclusion(transclusion) =&gt; {
                write!(f, &#34;!\u{005B}\u{005B}{}]]&#34;, transclusion)
            }
        }
    }
}
</pre></div></div></div></div>
  </body>
</html>
