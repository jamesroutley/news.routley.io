<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dafny.org/blog/2023/12/15/teaching-program-verification-in-dafny-at-amazon/">Original</a>
    <h1>Teaching Program Verification in Dafny at Amazon (2023)</h1>
    
    <div id="readability-page-1" class="page"><div>
<h2 id="sec-introduction" data-line="18" data-heading-depth="1"><span data-line="18"></span>Introduction</h2>
<p data-line="20"><span data-line="20"></span>We recently made available some teaching material that we have used to teach program verification to scientists and engineers at Amazon. 
It composed of <span data-line="21"></span><a href="https://dafny.org/teaching-material/"><span data-line="21"></span>lecture slides<span data-line="21"></span></a><span data-line="21"></span> 
and <span data-line="22"></span><a href="https://github.com/dafny-lang/teaching-material/tree/main/Exercises"><span data-line="22"></span>exercises with solution<span data-line="22"></span></a><span data-line="22"></span>. 
If you want to learn about Dafny and program verification, you can jump right in. You will learn how to program in Dafny, how to do
use Dafny as a proof assistant, and finally how to verify programs. If instead you are more interested in teaching program
verification, you may find the organization of the lectures and the focus on Dafny
as a proof assistant surprising, and the following note should provide some context and explanations. 
</p><h2 id="sec-dafny--program-verifier-and-proof-assistant" data-line="28" data-heading-depth="1"><span data-line="28"></span>Dafny: Program Verifier and Proof Assistant</h2>
<blockquote data-line="30">

<p data-line="30"><span data-line="30"></span>A proof plays two roles. <span data-line="30"></span></p></blockquote>
<p data-line="40"><span data-line="40"></span>One way to introduce program verification, including writing specifications and proofs,
is exemplified by the book <span data-line="41"></span><a href="https://mitpress.mit.edu/9780262546232/program-proofs/"><span data-line="41"></span>Program Proofs<span data-line="41"></span></a><span data-line="41"></span> authored by 
K. Rustan M. Leino and published by MIT press. A defining characteristic of the methodology in that book is that verification is
not only always motivated by programs, but specifications and proofs are attributes of programs. 
The book starts by considering simple imperative programs whose specification is written as pre and post conditions, and proving is done
by writing annotations for loops and, on occasion, additional assertions. The curriculum continues with programs of increasing complexity, and specification
and proofs continue to <span data-line="46"></span>“decorate”<span data-line="46"></span> programs.
The concept of a proof is introduced somewhat implicitly through a program logic that details the effect of different programming constructs on the validity of a specification. 
This is an effective way to teach program verification: combined with Dafny<span data-line="48"></span>&#39;<span data-line="48"></span>s automation, one can verify programs by 
decorating them with a few assertions that explain at a high-level why the specification should hold. It promotes a style of
program verification where <span data-line="50"></span>“proving”<span data-line="50"></span> amounts to explaining. 
</p>
<p data-line="52"><span data-line="52"></span>Unfortunately, when automation comes short, it may not always be clear what explanations will help with the verification.
It may seem as if one needs to provide the
right assertion at the right place, without a clear methodology to figure it out. This can be frustrating to a developer for whom program verification,
after appearing so simple for a while, may now seem ad hoc. We attempt to address this problem by providing a complementary perspective on
program verification in Dafny. The key idea is to introduce Dafny as a proof assistant and to study proofs explicitly and independently of programs.
With this perspective, we not only learn how to write intuitive proofs that take advantage of automation, but we also learn to write detailed formal proofs
in natural deduction. This methodology opens the possibility of proving by convincing: a handful of rules can be used to refine a proof that will eventually
pass the verification if it is indeed valid. 
</p>
<p data-line="61"><span data-line="61"></span>The course is organized in 3 distinct parts. In the first two, Dafny is in turn introduced as a programming language (with no verification) and as a proof
assistant (with no programming). Program verification is introduced last and emphasizes extrinsic verification. 
</p><h2 id="sec-part-1--dafny-as-a-programming-language" data-line="64" data-heading-depth="1"><span data-line="64"></span>Part 1: Dafny as a Programming Language</h2>
<p data-line="66"><span data-line="66"></span>The first set of lectures introduces Dafny as a programming language, without any consideration for verification. 
The primary motivation is to allow Dafny newcomers to familiarize themselves with
the syntax and semantics of the language, and its tools (CLI, IDE). It also makes it easy for more seasoned Dafny developers to skip directly to
verification. Finally, it emphasizes that Dafny is at its core a full-fledged and classic programming language 
with strong static typing,  object-orientation, and functional features. It may be an opportunity to introduce
Dafny<span data-line="71"></span>&#39;<span data-line="71"></span>s foreign function interface and the idea that Dafny can be used as part of a large software project. 
</p>
<p data-line="73"><span data-line="73"></span>We introduce in turn <span data-line="73"></span><a href="https://dafny.org/teaching-material/Lectures/1-1-Programming-Functional.html"><span data-line="73"></span>functional programming<span data-line="73"></span></a><span data-line="73"></span>, 
<span data-line="74"></span><a href="https://dafny.org/teaching-material/Lectures/1-2-Programming-Imperative.html"><span data-line="74"></span>imperative programming<span data-line="74"></span></a><span data-line="74"></span>, and 
<span data-line="75"></span><a href="https://dafny.org/teaching-material/Lectures/1-3-Programming-ObjectOriented.html"><span data-line="75"></span>object-oriented programming<span data-line="75"></span></a><span data-line="75"></span>. We usually keep
the presentation of the module system to a minimum.
</p><h2 id="sec-part-2--dafny-as-a-proof-assistant" data-line="78" data-heading-depth="1"><span data-line="78"></span>Part 2: Dafny as a Proof Assistant</h2>
<p data-line="80"><span data-line="80"></span>After introducing Dafny as a programming language while ignoring verification, we learn about Dafny as a proof assistant while ignoring programming. 
 
We start by introducing the <span data-line="82"></span><a href="https://dafny.org/teaching-material/Lectures/2-1-Logic-Propositions.html"><span data-line="82"></span>language of specification<span data-line="82"></span></a><span data-line="82"></span>
of Dafny. At its core, a Dafny specification is composed of uninterpreted symbols of type, constant, predicate, and function symbols and the language of formulas is
a variant of Church<span data-line="84"></span>&#39;<span data-line="84"></span>s simple type theory or higher-order logic. The lecture also introduces lemma as a way to declare a family of formulas and axiomatize the meaning of
symbols. In particular, the primitive types and operations such as reals or sets are presented as specific theories. 
</p>
<p data-line="87"><span data-line="87"></span>We then explain how to <span data-line="87"></span><a href="https://dafny.org/teaching-material/Lectures/2-2-Logic-Definitions.html"><span data-line="87"></span>define<span data-line="87"></span></a><span data-line="87"></span> types, constants, predicates, and functions instead
of axiomatizing them and assuming their existence. This is an opportunity to talk about partiality, termination of functions, fixed-points, and algebraic datatypes.
</p>
<p data-line="90"><span data-line="90"></span>Finally, we start studying proofs in Dafny in the more intuitive way that aims to
<span data-line="91"></span><a href="https://dafny.org/teaching-material/Lectures/2-3-Logic-ProvingByExplaining.html"><span data-line="91"></span>prove by explaining<span data-line="91"></span></a><span data-line="91"></span>. In this style, which is the more
idiomatic Dafny style of proofs, one can prove in a way that is similar to the kind of proofs that we write in a high-school geometry class by
making intermediate assertions, appealing to know results, fixing values and assumptions (e,g, <span data-line="93"></span><em>let x be a fixed but arbitrary odd number</em><span data-line="93"></span>), 
and high-level proof methods such as proof by contradiction, proof by case analysis, or proof by induction.
</p>
<p data-line="96"><span data-line="96"></span>Lastly, and most importantly, we study proofs in a much more formal way by explaining how to develop completely detailed and rigorous proofs using the 
rules of natural deduction (and sequent calculus). This systematic approach to formal proofs in Dafny allows one to 
<span data-line="98"></span><a href="https://dafny.org/teaching-material/Lectures/2-4-Logic-ProvingByConvincing.html"><span data-line="98"></span>prove by convincing<span data-line="98"></span></a><span data-line="98"></span>, with the fundamental idea that you can 
always provide enough details so that the verifier will eventually accept your proof if it is indeed valid. 
</p><h2 id="sec-part-3--program-verification-in-dafny" data-line="101" data-heading-depth="1"><span data-line="101"></span>Part 3: Program Verification in Dafny</h2>
<p data-line="103"><span data-line="103"></span>As we mentioned in the introduction, a typical path to learning about program verification in a language like Dafny would be to start with
simple imperative programs, specifications as program annotations, and proofs as program annotations in a program logic. However, since we introduced
proofs independently of programs by taking the unusual point of view that Dafny is a proof assistant and that proofs are expressed in natural deduction, our
journey into program verification is somewhat different. <span data-line="106"></span> <span data-line="106"></span> 
</p>
<p data-line="108"><span data-line="108"></span>We start with verification of functional programs, as it is largely similar to verifying mathematics. More specially, we first review
<span data-line="109"></span><a href="https://dafny.org/teaching-material/Lectures/3-1-Verification-Functional-Independent.html"><span data-line="109"></span>extrinsic verification of functional programs<span data-line="109"></span></a><span data-line="109"></span>, meaning that 
we keep function and type definitions separate (as much as possible) from specifying and proving their properties. In practice, it means that we do not
annotate functions with properties but instead state and prove them as separate lemmas. Only then do we go over 
<span data-line="112"></span><a href="https://dafny.org/teaching-material/Lectures/3-2-Verification-Functional-Dependent.html"><span data-line="112"></span>intrinsic verification of functional programs<span data-line="112"></span></a><span data-line="112"></span> with pre and post conditions,
and subset types. The motivation for keeping extrinsic and intrinsic verification separate is to emphasize the importance of being mindful about proof brittleness
and that it may be a better strategy in general to introduce intrinsic verification where it simplifies verification the most, rather than making it the default
verified programming strategy.
</p>
<p data-line="117"><span data-line="117"></span>We then discuss <span data-line="117"></span><a href="https://dafny.org/teaching-material/Lectures/3-3-Verification-Imperative.html"><span data-line="117"></span>verification of imperative programs<span data-line="117"></span></a><span data-line="117"></span>. First, we
introduce local state and finally mention briefly program logic, loop invariants, and ghost state. We also emphasize an 
<span data-line="119"></span><a href="https://dafny.org/blog/2023/08/14/clear-specification-and-implementation/"><span data-line="119"></span>important methodology<span data-line="119"></span></a><span data-line="119"></span> where
instead of proving properties of an imperative program directly, one first proves that it behaves as a functional model and then prove interesting properties 
on that functional model. 
</p>
<p data-line="123"><span data-line="123"></span>Finally, we talk about verification of <span data-line="123"></span><a href="https://dafny.org/teaching-material/Lectures/3-4-Verification-ObjectOriented.html"><span data-line="123"></span>object-oriented programs<span data-line="123"></span></a><span data-line="123"></span>. The material is standard, but we emphasize the importance of defining an object<span data-line="123"></span>&#39;<span data-line="123"></span>s API by 
writing clients first to avoid coming up with an API that is inconsistent or cannot actually be used. We also emphasize that ghost representations need not
be limited to sets and that it is tremendously useful to capture as much as possible the intended structure of a class in the type of its representation. Lastly, 
we emphasize the importance of <span data-line="126"></span><em>master</em><span data-line="126"></span> nodes in data structures that can make verification significantly easier.
</p><h2 id="sec-conclusion" data-line="129" data-heading-depth="1"><span data-line="129"></span>Conclusion</h2>
<p data-line="131"><span data-line="131"></span>The first version of this course was designed as a complement to <span data-line="131"></span><a href="https://mitpress.mit.edu/9780262546232/program-proofs/"><span data-line="131"></span>Program Proofs<span data-line="131"></span></a><span data-line="131"></span>.
Its goal was to introduce seasoned Dafny software engineers to a different way of thinking about proofs by introducing them to some of the material
from a <span data-line="133"></span><a href="https://wikimpri.dptinfo.ens-cachan.fr/doku.php?id=cours:c-2-7-1"><span data-line="133"></span>course on the foundations of proof systems<span data-line="133"></span></a><span data-line="133"></span> ; natural deduction and sequent calculus
in particular.
There is anecdotal evidence that it was effective and we have continued to develop this curriculum to use it both as an introduction to program verification, 
and as a way to help experts take their proving skills to the next level. Automation can be a significant challenge to teaching formal proofs in Dafny because
it makes it difficult to work on simple examples and exercises, but the lecture on proving by convincing shows one attempt to do so.
</p></div></div>
  </body>
</html>
