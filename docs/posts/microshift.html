<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://next.redhat.com/2022/01/19/introducing-microshift/">Original</a>
    <h1>MicroShift</h1>
    
    <div id="readability-page-1" class="page"><div>
				
				
				<div>
				
				
				
<p id="h-exploring-a-small-form-factor-openshift-designed-for-field-deployed-edge-computing-devices"><strong>Exploring a small form factor OpenShift designed for field deployed edge computing devices</strong></p>



<p>Edge Computing spans a broad range of use cases and deployment models. On one end, it can refer to micro data centers located in controlled environments that are formed by a small number of servers. On the other end, edge computing includes embedded systems with low-power CPUs and few GBs of RAM deployed in the field under harsh environmental conditions, e.g. sparse and costly network connectivity and no physical access security. </p>



<p><em><strong>Note:</strong> Red Hat’s Emerging Technologies blog includes posts that discuss technologies that are under active development in upstream open source communities and at Red Hat. We believe in sharing early and often the things we’re working on, but we want to note that unless otherwise stated the technologies and how-tos shared here aren’t part of supported products, nor promised to be in the future.</em></p>



<p>Kubernetes distributions like OpenShift have traditionally been engineered for the cloud and data center-like environments. For example, OpenShift can deploy cloud-native applications as well as lifecycle-manage Kubernetes cluster, underlying OS and infrastructure. </p>



<p>Systems deployed in remote edge locations often use device management software to lifecycle-manage these systems including the OS. Companies are looking for the best of both worlds for these remote systems: using Kubernetes to manage cloud-native applications and device management to manage OS and underlying hardware.</p>



<p>MicroShift is a project that we are currently working on. Though not currently supported, it is being designed for field-deployed edge computing devices and to provide workload portability and a consistent management experience – very similar to the functionality we find in Red Hat OpenShift. As we work on this project, we would like to share what we are working on and gather some early feedback from those of you that are interested in collaborating with us.</p>



<figure><img loading="lazy" width="1024" height="602" src="https://next.redhat.com/wp-content/uploads/2022/01/Raspberry_Pi_4_Model_B_-_Side-1024x602.jpeg" alt="Raspberry Pi 4 Model B - Photo credit: Laserlicht under CC license - https://creativecommons.org/licenses/by-sa/4.0/" srcset="https://next.redhat.com/wp-content/uploads/2022/01/Raspberry_Pi_4_Model_B_-_Side-1024x602.jpeg 1024w, https://next.redhat.com/wp-content/uploads/2022/01/Raspberry_Pi_4_Model_B_-_Side-980x577.jpeg 980w, https://next.redhat.com/wp-content/uploads/2022/01/Raspberry_Pi_4_Model_B_-_Side-480x282.jpeg 480w" sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw"/><figcaption><em>Raspberry Pi 4 Model B – one example of the small-footprint devices where MicroShift can be run</em></figcaption></figure>



<h2 id="h-what-makes-field-deployed-devices-different">What makes field-deployed devices different?</h2>



<p>In comparison to a system for managing field-deployed devices, OpenShift has been optimized for the needs and conditions of the cloud. Architectural decisions like self-managing clusters orchestrating changes across Kubernetes, OS, and machines are a result of this. </p>



<p>Arguably, optimizing for field-deployed devices would have resulted in different trade-offs, e.g. optimizing for adverse network conditions or minimizing resource footprint. This situation motivated us to investigate an edge-centric way of applying the concepts of Kubernetes, and the result of our ideas is a project called MicroShift.</p>



<p>“Field-deployed” refers to mass-deployment and operations in remote, uncontrolled locations with highly challenging network connectivity. There are dozens of use cases where having a field-deployed edge computing device might bring the processing and storage capabilities we need closer to the user. Imagine one of these small devices located in a vehicle to run AI algorithms for autonomous driving, or being able to monitor oil and gas plants in remote locations to perform predictive maintenance, or running workloads in a satellite as you would do in your own laptop. Now contrast this to centralized, highly controlled data centers where power and network conditions are usually very stable thanks to high available infrastructure — this is one of the key differences that define edge environments. </p>



<p>Field-deployed devices are often <em>Single Board Computers </em>(SBCs) chosen based on performance-to-energy/cost ratio, usually with lower-end memory and CPU options.  These devices are centrally imaged by the manufacturer or the end user’s central IT before getting shipped to remote sites such as roof-top cabinets housing 5G antennas, manufacturing plants, etc. </p>



<p>At the remote site, a technician will screw the device to the wall, plug the power and the network cables and the work is done. Provisioning of these devices is “plug &amp; go” with no console, keyboard or qualified personnel. In addition, these systems lack out-of-band management controllers so the provisioning model totally differs from those that we use with regular full-size servers.</p>



<p>Indeed, in field-deployed environments, autonomous registration* and configuration models are a necessary step in the configuration process. A very common scenario might be to push a faulty version of software, or network configuration that might brick the device. Therefore, devices that are deployed in a pre-registered, pre-configured state must also be able to autonomously recover from the failed update rolling back to a previous state.</p>



<p><em>* A very good example is the <a href="https://fidoalliance.org/intro-to-fido-device-onboard/">FIDO Device Onboarding</a> specification that allows an automated IoT device provisioning workflow designed with security in mind.</em></p>



<figure><img loading="lazy" width="1024" height="512" src="https://next.redhat.com/wp-content/uploads/2022/01/microshift_1-1024x512.jpg" alt="NVIDIA Jetson TX1 - Photo credit: NVIDIA Corporation, under CC license: https://creativecommons.org/licenses/by-nc-nd/2.0/" srcset="https://next.redhat.com/wp-content/uploads/2022/01/microshift_1-980x490.jpg 980w, https://next.redhat.com/wp-content/uploads/2022/01/microshift_1-480x240.jpg 480w" sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw"/><figcaption><em>NVIDIA Jetson TX1, another small-footprint target for MicroShift use cases.</em></figcaption></figure>



<h2>What is MicroShift?</h2>



<p><a href="https://github.com/redhat-et/microshift">MicroShift</a> is an explorative project created by the Edge Computing team in Red Hat’s Office of the CTO. MicroShift’s goal is to tailor OpenShift for field-deployed device use cases, providing a consistent development and management experience across all footprints. </p>



<p>The idea is for MicroShift to be an application that users can optionally deploy onto their field-deployed devices running an edge-optimized OS like RHEL (using its edge extension such as  rpm-ostree based transactional updates and greenboot-based auto-rollbacks designed for field-deployment), and then manage those devices as MicroShift clusters through ACM as they can with OpenShift.</p>



<figure><img loading="lazy" width="1024" height="470" src="https://next.redhat.com/wp-content/uploads/2022/01/microshift_vs_openshift-1024x470.png" alt="Structural Comparison of OpenShift and MicroShift" srcset="https://next.redhat.com/wp-content/uploads/2022/01/microshift_vs_openshift-980x450.png 980w, https://next.redhat.com/wp-content/uploads/2022/01/microshift_vs_openshift-480x220.png 480w" sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw"/><figcaption><em>MicroShift as compared to OpenShift</em></figcaption></figure>



<p>Functionally, MicroShift repackages OpenShift core components** into a single binary that weighs in at a relatively tiny 160MB executable (without any compression/optimization). As a monolith, it provides an “all-or-nothing” start/stop behavior that works well with systemd and enables fast (re)start times of a few seconds.</p>



<p>*<em>* etcd, kube-{apiserver,controller-manager,scheduler}, openshift-{apiserver,controller-manager} </em></p>



<p>This also vastly simplifies changes including updates and roll-backs and obviates the need for cluster operators to orchestrate across components. Dropping cluster operators significantly reduces MicroShift’s resource footprint, but comes at the cost of requiring more manual, lower level configuration from users if operating outside of MicroShift’s opinionated parameters.</p>



<p>On its own, the monolith core can handle a few very basic use cases. To expand upon these capabilities, MicroShift by default deploys a small subset of services*** using OpenShift’s container images.</p>



<p><em>*** currently only openshift-dns, openshift-ingress, service-ca, and local-storage-provisioner</em></p>



<figure><img loading="lazy" width="1024" height="416" src="https://next.redhat.com/wp-content/uploads/2022/01/microshift_production-1024x416.png" alt="MicroShift production diagram" srcset="https://next.redhat.com/wp-content/uploads/2022/01/microshift_production-980x398.png 980w, https://next.redhat.com/wp-content/uploads/2022/01/microshift_production-480x195.png 480w" sizes="(min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw"/><figcaption><em>MicroShift Production</em></figcaption></figure>



<p>MicroShift has been specifically designed for edge computing use cases, with a goal of fitting in the limited storage capacity of field-deployed devices that can be embedded into a variety of appliances such as cars, factory lines, airplanes or even satellites. </p>



<p>But as a great addition, and thanks to its small footprint, it can also be very handy for developers that want to run a minimal OpenShift flavor on their laptops. MicroShift is a very useful environment for developers to write, test, and deploy new cloud-native applications.</p>



<p>MicroShift has been demo’ed to run on <a href="https://asciinema.org/a/MJZ69vE544HEUi2fpmwtcGpZe">macOS</a> and <a href="https://asciinema.org/a/9frtMf59Z2lwbXf2suCQg88w8">Windows 10</a>, on <a href="https://asciinema.org/a/zeA0SRBuYAgR3p51LsgEhGqKB">ARM</a>64 and <a href="https://drive.google.com/file/d/1L5V9X28qlvRP2xeSWvNYI3IWX0hhMKNy/view?usp=sharing">RISC-V</a> CPU architectures. Curious to see it in action? Have a look at the end-to-end provisioning demo <a href="https://www.youtube.com/watch?v=QOiB8NExtA4">video</a>. </p>


			</div>
			</div></div>
  </body>
</html>
