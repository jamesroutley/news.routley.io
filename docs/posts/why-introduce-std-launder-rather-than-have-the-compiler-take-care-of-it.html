<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://stackoverflow.com/questions/66176720/why-introduce-stdlaunder-rather-than-have-the-compiler-take-care-of-it">Original</a>
    <h1>Why introduce `std::launder` rather than have the compiler take care of it?</h1>
    
    <div id="readability-page-1" class="page"><div id="mainbar" role="main" aria-label="question and answers">

                
<div data-questionid="66176720" data-position-on-page="0" data-score="25" id="question">
    


    <div>
        

        

<div>
    
    <div itemprop="text">
                
<p>I&#39;ve just read</p>
<p><a href="https://stackoverflow.com/q/39382501/1593077">What is the purpose of std::launder?</a></p>
<p>and frankly, I am left scratching my head.</p>
<p>Let&#39;s start with the second example in @NicolBolas&#39; accepted answer:</p>
<blockquote>
<pre><code>aligned_storage&lt;sizeof(int), alignof(int)&gt;::type data; 
new(&amp;data) int; 
int *p = std::launder(reinterpret_cast&lt;int*&gt;(&amp;data)); 
</code></pre>
<p>[basic.life]/8 tells us that, if you allocate a new object in the
storage of the old one, you cannot access the new object through
pointers to the old. <code>std::launder</code> allows us to side-step that.</p>
</blockquote>
<p>So, why not just change the language standard so that accessing <code>data</code> through a <code>reinterpret_cast&lt;int*&gt;(&amp;data)</code> is valid/appropriate? In real life, money laundering is a way to hide reality from the law. But we don&#39;t have anything to hide - we&#39;re doing something perfectly legitimate here. So why can&#39;t the compiler just change it&#39;s behavior to its <code>std::launder()</code> behavior when it notices we&#39;re accessing <code>data</code> this way?</p>
<p>On to the first example:</p>
<blockquote>
<pre><code>X *p = new (&amp;u.x) X {2};
</code></pre>
<p>Because X is trivial, we need not destroy the old object before
creating a new one in its place, so this is perfectly legal code. The
new object will have its n member be 2.</p>
<p>So tell me... what will <code>u.x.n</code> return?</p>
<p>The obvious answer will be 2. But that&#39;s wrong, because the compiler
is allowed to assume that a truly <code>const</code> variable (not merely a const&amp;,
but an object variable declared <code>const</code>) will never change. But we just
changed it.</p>
</blockquote>
<p>So why not make the compiler <em>not</em> be allowed to make the assumption when we write this kind of code, accessing the constant field through the pointer?</p>
<p>Why is it reasonable to have this pseudo-function for punching a hole in formal language semantics, rather than setting the semantics to what they need to be depending on whether or not the code does something like in these examples?</p>
    </div>

        

    <div>
        <div>
            

                
            <div>
                <div>
    <p>
        asked <span title="2021-02-12 17:51:41Z">Feb 12 &#39;21 at 17:51</span>
    </p>
    <div>
        <a href="https://otee.dev/users/1593077/einpoklum"><p><img src="https://www.gravatar.com/avatar/10c44e0d9568e48d05708ae196ad936f?s=64&amp;d=identicon&amp;r=PG" alt="" width="32" height="32"/></p></a>
    </div>
    <div itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <p><a href="https://otee.dev/users/1593077/einpoklum">einpoklum</a><span itemprop="name">einpoklum</span></p><p><span title="reputation score 96,771" dir="ltr">96.8k</span><span title="45 gold badges" aria-hidden="true"><span></span><span>45</span></span><span>45 gold badges</span><span title="260 silver badges" aria-hidden="true"><span></span><span>260</span></span><span>260 silver badges</span><span title="513 bronze badges" aria-hidden="true"><span></span><span>513</span></span><span>513 bronze badges</span>
        </p>
    </div>
</div>


            </div>
        </div>
    </div>
    
</div>




            <p><span itemprop="commentCount">15</span></p>
    </div>
</div>



                <div id="answers">

                    


                                          
<div id="answer-66178351" data-answerid="66178351" data-score="13" data-position-on-page="1" data-highest-scored="1" data-question-has-accepted-highest-score="1" itemprop="acceptedAnswer" itemscope="" itemtype="https://schema.org/Answer">
    <div>
        

        

<div>
    
    <div itemprop="text">
<blockquote>
<p>depending on whether or not the code does something like in these examples</p>
</blockquote>
<p>Because the compiler cannot always know when <code>data</code> is being accessed &#34;this way&#34;.</p>
<p>As things currently stand, the compiler is allowed to assume that, for the following code:</p>
<pre><code>struct foo{ int const x; };

void some_func(foo*);

int bar() {
    foo f { 123 };
    some_func(&amp;f);
    return f.x;
}
</code></pre>
<p><code>bar</code> will always return 123. The compiler <em>may</em> generate code that actually accesses the object. But the object model does not <em>require</em> this. <code>f.x</code> is a <code>const</code> object (not a reference/pointer to <code>const</code>), and therefore it cannot be changed. And <code>f</code> is required to always name the same object (indeed, these are the parts of the standard you would have to change). Therefore, the value of <code>f.x</code> cannot be changed by any non-UB means.</p>
<blockquote>
<p>Why is it reasonable to have this pseudo-function for punching a hole in formal language semantics</p>
</blockquote>
<p>This was <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0532r0.pdf" rel="noreferrer">actually discussed</a>. That paper brings up how long these issues have existed (ie: since C++03) and often optimizations made possible by this object model have been employed.</p>
<p>The proposal was rejected on the grounds that it would not actually fix the problem. From <a href="https://botondballo.wordpress.com/2017/03/27/trip-report-c-standards-meeting-in-kona-february-2017/" rel="noreferrer">this trip report</a>:</p>
<blockquote>
<p>However, during discussion it came to light that the proposed alternative would not handle all affected scenarios (particularly scenarios where vtable pointers are in play), and it did not gain consensus.</p>
</blockquote>
<p>The report doesn&#39;t go into any particular detail on the matter, and the discussions in question are not publicly available. But the proposal itself does point out that it wouldn&#39;t allow devirtualizing a <em>second</em> virtual function call, as the first call may have build a new object. So even P0532 would not make <code>launder</code> unnecessary, merely less necessary.</p>
    </div>
    <div>
        <div>
            
            <div>
<div>
    
    <div>
        <a href="https://otee.dev/users/1593077/einpoklum"><p><img src="https://www.gravatar.com/avatar/10c44e0d9568e48d05708ae196ad936f?s=64&amp;d=identicon&amp;r=PG" alt="" width="32" height="32"/></p></a>
    </div>
    <div>
        <p><a href="https://otee.dev/users/1593077/einpoklum">einpoklum</a></p><p><span title="reputation score 96,771" dir="ltr">96.8k</span><span title="45 gold badges" aria-hidden="true"><span></span><span>45</span></span><span>45 gold badges</span><span title="260 silver badges" aria-hidden="true"><span></span><span>260</span></span><span>260 silver badges</span><span title="513 bronze badges" aria-hidden="true"><span></span><span>513</span></span><span>513 bronze badges</span>
        </p>
    </div>
</div>
            </div>


            <div>
                <div>
    <p>
        answered <span title="2021-02-12 20:01:40Z">Feb 12 &#39;21 at 20:01</span>
    </p>
    <div>
        <a href="https://otee.dev/users/734069/nicol-bolas"><p><img src="https://www.gravatar.com/avatar/a356923f858fbe363dad1dc566837fc6?s=64&amp;d=identicon&amp;r=PG" alt="" width="32" height="32"/></p></a>
    </div>
    <div itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <p><a href="https://otee.dev/users/734069/nicol-bolas">Nicol Bolas</a><span itemprop="name">Nicol Bolas</span></p><p><span title="reputation score 401,678" dir="ltr">402k</span><span title="59 gold badges" aria-hidden="true"><span></span><span>59</span></span><span>59 gold badges</span><span title="679 silver badges" aria-hidden="true"><span></span><span>679</span></span><span>679 silver badges</span><span title="876 bronze badges" aria-hidden="true"><span></span><span>876</span></span><span>876 bronze badges</span>
        </p>
    </div>
</div>


            </div>
        </div>
        
    
    </div>
    
</div>




            <p><span itemprop="commentCount">15</span></p>
    </div>
</div>

                        


                            <h2 data-loc="1">
Not the answer you&#39;re looking for? Browse other questions tagged <a href="https://otee.dev/questions/tagged/c%2b%2b" title="show questions tagged &#39;c++&#39;" rel="tag">c++</a> <a href="https://otee.dev/questions/tagged/c%2b%2b17" title="show questions tagged &#39;c++17&#39;" rel="tag">c++17</a> <a href="https://otee.dev/questions/tagged/language-lawyer" title="show questions tagged &#39;language-lawyer&#39;" rel="tag">language-lawyer</a> <a href="https://otee.dev/questions/tagged/rationale" title="show questions tagged &#39;rationale&#39;" rel="tag">rationale</a> <a href="https://otee.dev/questions/tagged/stdlaunder" title="show questions tagged &#39;stdlaunder&#39;" rel="tag">stdlaunder</a>  or <a href="https://otee.dev/questions/ask">ask your own question</a>.                            </h2>
                </div>
            </div></div>
  </body>
</html>
