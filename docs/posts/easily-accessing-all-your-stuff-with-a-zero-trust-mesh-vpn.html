<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://changelog.complete.org/archives/10478-easily-accessing-all-your-stuff-with-a-zero-trust-mesh-vpn">Original</a>
    <h1>Easily accessing all your stuff with a zero-trust mesh VPN</h1>
    
    <div id="readability-page-1" class="page"><div>
		        <p>Probably everyone is familiar with a regular VPN.  The traditional use case is to connect to a corporate or home network from a remote location, and access services as if you were there.</p>
<p>But these days, the notion of “corporate network” and “home network” are less based around physical location.  For instance, a company may have no particular office at all, may have a number of offices plus a number of people working remotely, and so forth.  A home network might have, say, a PVR and file server, while highly portable devices such as laptops, tablets, and phones may want to talk to each other regardless of location.  For instance, a family member might be traveling with a laptop, another at a coffee shop, and those two devices might want to communicate, in addition to talking to the devices at home.</p>
<p>And, in both scenarios, there might be questions about giving limited access to friends.  Perhaps you’d like to give a friend access to part of your file server, or as a company, you might have contractors working on a limited project.</p>
<p>Pretty soon you wind up with a mess of VPNs, forwarded ports, and tricks to make it all work.  With the increasing prevalence of <a href="https://en.wikipedia.org/wiki/Carrier-grade%5FNAT">CGNAT</a>, a lot of times you can’t even open a port to the public Internet.  Each application or device probably has its own gateway just to make it visible on the Internet, some of which you pay for.</p>
<p>Then you add on the question of: should you really trust your LAN anyhow?  With possibilities of guests using it, rogue access points, etc., the answer is probably “no”.</p>
<p>We can move the responsibility for dealing with NAT, fluctuating IPs, encryption, and authentication, from the application layer further down into the network stack.  We then arrive at a much simpler picture for all.</p>
<p>So this page is fundamentally about making the network work, simply and effectively.</p>
<h2 id="how-do-we-make-the-internet-work-in-these-scenarios">How do we make the Internet work in these scenarios?</h2>
<p>We’re going to combine three concepts:</p>
<ol>
<li>A VPN, providing fully encrypted and authenticated communication and stable IPs</li>
<li><a href="https://www.complete.org/mesh-network/">Mesh Networking</a>, in which devices automatically discover optimal paths to reach each other</li>
<li><a href="https://en.wikipedia.org/wiki/Zero%5Ftrust%5Fsecurity%5Fmodel">Zero-trust</a> networking, in which we do not need to trust anything about the underlying LAN, because all our traffic uses the secure systems in points 1 and 2.</li>
</ol>
<p>By combining these concepts, we arrive at some nice results:</p>
<ul>
<li>You can <code>ssh hostname</code>, where hostname is one of your machines (server, laptop, whatever), and as long as <code>hostname</code> is up, you can reach it, wherever it is, wherever you are.
<ul>
<li>Combined with <a href="https://mosh.org/">mosh</a>, these sessions will be durable even across moving to other host networks.</li>
<li>You could just as well use telnet, because the underlying network should be secure.</li>
</ul>
</li>
<li>You don’t have to mess with encryption keys, certs, etc., for every internal-only service.  Since IPs are now trustworthy, that’s all you need.  hosts.allow could make a comeback!</li>
<li>You have a way of transiting out of extremely restrictive networks.  Every tool discussed here has a way of falling back on routing things via a broker (relay) on TCP port 443 if all else fails.</li>
</ul>
<p>There might sometimes be tradeoffs.  For instance:</p>
<ul>
<li>On LANs faster than 1Gbps, performance may degrade due to encryption and encapsulation overhead.  However, these tools should let hosts discover the locality of each other and not send traffic over the Internet if the devices are local.</li>
<li>With some of these tools, hosts local to each other (on the same LAN) may be unable to find each other if they can’t reach the control plane over the Internet (Internet is down or provider is down)</li>
</ul>
<p>Some other features that some of the tools provide include:</p>
<ul>
<li>Easy sharing of limited access with friends/guests</li>
<li>Taking care of everything you need, including SSL certs, for exposing a certain on-net service to the public Internet</li>
<li>Optional routing of your outbound Internet traffic via an exit node on your network.  Useful, for instance, if your local network is blocking tons of stuff.</li>
</ul>
<p>Let’s dive in.</p>
<h2 id="types-of-mesh-vpns">Types of Mesh VPNs</h2>
<p>I’ll go over several types of meshes in this article:</p>
<ol>
<li>
<p>Fully decentralized with automatic hop routing</p>
<p>This model has no special central control plane.  Nodes discover each other in various ways, and establish routes to each other.  These routes can be direct connections over the Internet, or via other nodes.  This approach offers the greatest resilience.  Examples I’ll cover include Yggdrasil and tinc.</p>
</li>
<li>
<p>Automatic peer-to-peer with centralized control</p>
<p>In this model, nodes, by default, communicate by establishing direct links between them.  A regular node never carries traffic on behalf of other nodes.  Special-purpose relays are used to handle cases in which <a href="https://tailscale.com/blog/how-nat-traversal-works/">NAT traversal</a> is impossible.  This approach tends to offer simple setup.  Examples I’ll cover include Tailscale, Zerotier, Nebula, and Netmaker.</p>
</li>
<li>
<p>Roll your own and hybrid approaches</p>
<p>This is a “grab bag” of other ideas; for instance, running Yggdrasil over Tailscale.</p>
</li>
</ol>
<h2 id="terminology">Terminology</h2>
<p>For the sake of consistency, I’m going to use common language to discuss things that have different terms in different ecosystems:</p>
<ul>
<li>Every tool discussed here has a way of dealing with NAT traversal.  It may assist with establishing direct connections (eg, STUN), and if that fails, it may simply relay traffic between nodes.  I’ll call such a relay a “broker”.  This may or may not be the same system that is a control plane for a tool.</li>
<li>All of these systems operate over lower layers that are unencrypted.  Those lower layers may be a LAN (wired or wireless, which may or may not have Internet access), or the public Internet (IPv4 and/or IPv6).  I’m going to call the unencrypted lower layer, whatever it is, the “clearnet”.</li>
</ul>
<h2 id="evaluation-criteria">Evaluation Criteria</h2>
<p>Here are the things I want to see from a solution:</p>
<ul>
<li>Secure, with all communications end-to-end <a href="https://www.complete.org/encrypted/">encrypted</a> and authenticated, and prevention of traffic from untrusted devices.</li>
<li>Flexible, adapting to changes in network topology quickly and automatically.</li>
<li>Resilient, without single points of failure, and with devices local to each other able to communicate even if cut off from the Internet or other parts of the network.</li>
<li>Private, minimizing leakage of information or metadata about me and my systems</li>
<li>Able to traverse CGNAT without having to use a broker whenever possible</li>
<li>A lesser requirement for me, but still a nice to have, is the ability to include others via something like Internet publishing or inviting guests.</li>
<li>Fully or nearly fully Open Source</li>
<li>Free or very cheap for personal use</li>
<li>Wide operating system support, including headless Linux on x86_64 and ARM.</li>
</ul>
<h2 id="fully-decentralized-vpns-with-automatic-hop-routing">Fully Decentralized VPNs with Automatic Hop Routing</h2>
<p>Two systems fit this description: Yggdrasil and Tinc.  Let’s dive in.</p>
<h3 id="yggdrasil">Yggdrasil</h3>
<p>I’ll start with <a href="https://www.complete.org/yggdrasil/">Yggdrasil</a> because I’ve written so much about it already.  It featured in prior posts such as:</p>
<ul>
<li><a href="https://changelog.complete.org/archives/10319-make-the-internet-yours-again-with-an-instant-mesh-network">Make the Internet Yours Again With an Instant Mesh Network</a>, which described the tyranny of IP rigidity and using Yggdrasil as a global mesh overlay.</li>
<li><a href="https://www.complete.org/using-yggdrasil-as-an-automatic-mesh-fabric-to-connect-all-your-docker-containers-vms-and-servers/">Using Yggdrasil As an Automatic Mesh Fabric to Connect All Your Docker Containers, VMs, and Servers</a> is, in a significant sense, a more specific implementation of the ideas contained here; it’s a private Yggdrasil mesh providing the communications layer for dispersed Docker containers.</li>
<li><a href="https://www.complete.org/recovering-our-lost-free-will-online-tools-and-techniques-that-are-available-now/">Recovering Our Lost Free Will Online: Tools and Techniques That Are Available Now</a> features Yggdrasil.</li>
</ul>
<h4 id="yggdrasil-can-be-a-private-mesh-vpn-or-something-more">Yggdrasil can be a private mesh VPN, or something more</h4>
<p>Yggdrasil can be a private mesh VPN, just like the other tools covered here.  It’s unique, however, in that a key goal of the project is to also make it useful as a planet-scale global mesh network.  As such, Yggdrasil is a testbed of new ideas in distributed routing designed to scale up to massive sizes and all sorts of connection conditions.  As of 2023-04-10, the main global Yggdrasil mesh has over 5000 nodes in it.  You can choose whether or not to participate.</p>
<p>Every node in a Yggdrasil mesh has a public/private keypair.  Each node then has an IPv6 address (in a private address space) derived from its public key.   Using these IPv6 addresses, you can communicate right away.</p>
<p>Yggdrasil differs from most of the other tools here in that it does not necessarily seek to establish a direct link on the clearnet between, say, host A and host G for them to communicate.  It will prefer such a direct link if it exists, but it is perfectly happy if it doesn’t.</p>
<p>The reason is that every Yggdrasil node is also a router in the Yggdrasil mesh.  Let’s sit with that concept for a moment.  Consider:</p>
<ul>
<li>If you have a bunch of machines on your LAN, but only one of them can peer over the clearnet, that’s fine; all the other machines will discover this route to the world and use it when necessary.</li>
<li>All you need to run a broker is just a regular node with a public IP address.  If you are participating in the global mesh, you can use one (or more) of the free <a href="https://github.com/yggdrasil-network/public-peers">public peers</a> for this purpose.</li>
<li>It is not necessary for every node to know about the clearnet IP address of every other node (improving privacy).  In fact, it’s not even necessary for every node to know about the <em>existence</em> of all the other nodes, so long as it can find a route to a given node when it’s asked to.</li>
<li>Yggdrasil can find one <em>or more</em> routes between nodes, and it can use this knowledge of multiple routes to <a href="https://github.com/yggdrasil-network/yggdrasil-go/issues/500#issuecomment-521063577">aggressively optimize</a> for varying network conditions, including combinations of, say, downloads and low-latency ssh sessions.</li>
</ul>
<p>Behind the scenes, Yggdrasil calculates optimal routes between nodes as necessary, using a mesh-wide <a href="https://en.wikipedia.org/wiki/Distributed%5Fhash%5Ftable">DHT</a> for initial contact and then deriving more optimal paths.  (You can also read <a href="https://yggdrasil-network.github.io/2021/06/19/preparing-for-v0-4.html">more details</a> about the routing algorithm.)</p>
<p>One final way that Yggdrasil is different from most of the other tools is that there is no separate control server.  No node is “special”, in charge, the sole keeper of metadata, or anything like that.  The entire system is completely distributed and auto-assembling.</p>
<h4 id="meeting-neighbors">Meeting neighbors</h4>
<p>There are two ways that Yggdrasil knows about peers:</p>
<ul>
<li>By broadcast discovery on the local LAN</li>
<li>By listening on a specific port (or being told to connect to a specific host/port)</li>
</ul>
<p>Sometimes this might lead to multiple ways to connect to a node; Yggdrasil prefers the connection auto-discovered by broadcast first, then the lowest-latency of the defined path.  In other words, when your laptops are in the same room as each other on your local LAN, your packets will flow directly between them without traversing the Internet.</p>
<h4 id="unique-uses">Unique uses</h4>
<p>Yggdrasil is uniquely suited to network-challenged situations.  As an example, in a post-disaster situation, Internet access may be unavailable or flaky, yet there may be many local devices – perhaps ones that had never known of each other before – that could share information.  Yggdrasil meets this situation perfectly.  The combination of broadcast auto-detection, distributed routing, and so forth, basically means that if there is any physical path between two nodes, Yggdrasil will find and enable it.</p>
<p>Ad-hoc wifi is rarely used because it is a real pain.  Yggdrasil actually makes it useful!  Its broadcast discovery doesn’t require any IP address provisioned on the interface at all (it just uses the IPv6 link-local address), so you don’t need to figure out a DHCP server or some such.  And, Yggdrasil will tend to perform routing along the contours of the RF path.   So you could have a laptop in the middle of a long distance relaying communications from people farther out, because it could see both.  Or even a chain of such things.</p>
<h4 id="yggdrasil-security-and-privacy">Yggdrasil: Security and Privacy</h4>
<p>Yggdrasil’s mesh is aggressively greedy.  It will peer with any node it can find (unless told otherwise) and will find a route to anywhere it can.  There are two main ways to make sure you keep unauthorized traffic out: by restricting who can talk to your mesh, and by firewalling the Yggdrasil interface.  Both can be used, and they can be used simultaneously.</p>
<p>I’ll discuss firewalling more at the end of this article.  Basically, you’ll almost certainly want to do this if you participate in the public mesh, because doing so is akin to having a globally-routable public IP address direct to your device.</p>
<p>If you want to restrict who can talk to your mesh, you just disable the broadcast feature on all your nodes (empty <code>MulticastInterfaces</code> section in the config), and avoid telling any of your nodes to connect to a public peer.  You can set a list of authorized public keys that can connect to your nodes’ listening interfaces, which you’ll probably want to do.  You will probably want to either open up some inbound ports (if you can) or set up a node with a known clearnet IP on a place like a $5/mo VPS to help with NAT traversal (again, setting <code>AllowedPublicKeys</code> as appropriate).  Yggdrasil doesn’t allow filtering multicast clients by public key, only by network interface, so that’s why we disable broadcast discovery.  You can easily enough teach Yggdrasil about static internal LAN IPs of your nodes and have things work that way.  (Or, set up an internal “gateway” node or two, that the clients just connect to when they’re local).  But fundamentally, you need to put a bit more thought into this with Yggdrasil than with the other tools here, which are closed-only.</p>
<p>Compared to some of the other tools here, Yggdrasil is better about information leakage; nodes only know details, such as clearnet IPs, of directly-connected peers.  You can obtain the list of directly-connected peers of any known node in the mesh – but that list is the public keys of the directly-connected peers, not the clearnet IPs.</p>
<p>Some of the other tools contain a limited integrated firewall of sorts (with limited ACLs and such).  Yggdrasil does not, but is fully compatible with on-host firewalls.  I recommend these anyway even with many other tools.</p>
<h4 id="yggdrasil-connectivity-and-nat-traversal">Yggdrasil: Connectivity and NAT traversal</h4>
<p>Compared to the other tools, Yggdrasil is an interesting mix.  It provides a fully functional mesh and facilitates connectivity in situations in which no other tool can.  Yet its NAT traversal, while it exists and does work, results in using a broker under some of the more challenging CGNAT situations more often than some of the other tools, which can impede performance.</p>
<p>Yggdrasil’s underlying protocol is TCP-based.  Before you run away screaming that it must be slow and unreliable like OpenVPN over TCP – it’s not, and it is even surprisingly good around bufferbloat.  I’ve found its performance to be on par with the other tools here, and it works as well as I’d expect even on flaky 4G links.</p>
<p>Overall, the NAT traversal story is mixed.  On the one hand, you can run a node that listens on port 443 – and Yggdrasil can even make it speak TLS (even though that’s unnecessary from a security standpoint), so you can likely get out of most restrictive firewalls you will ever encounter.  If you join the public mesh, know that plenty of <a href="https://github.com/yggdrasil-network/public-peers">public peers</a> do listen on port 443 (and other well-known ports like 53, plus random high-numbered ones).</p>
<p>If you connect your system to multiple public peers, there is a chance – though a very small one – that some public transit traffic might be routed via it.  In practice, public peers hopefully are already peered with each other, preventing this from happening (you can verify this with <code>yggdrasilctl debug_remotegetpeers key=ABC...</code>).  I have never experienced a problem with this.  Also, since latency is a factor in routing for Yggdrasil, it is highly unlikely that random connections we use are going to be competitive with datacenter peers.</p>
<h4 id="yggdrasil-sharing-with-friends">Yggdrasil: Sharing with friends</h4>
<p>If you’re open to participating in the public mesh, this is one of the easiest things of all.  Have your friend install Yggdrasil, point them to a public peer, give them your Yggdrasil IP, and that’s it.  (Well, presumably you also open up your firewall – you did follow my advice to set one up, right?)</p>
<p>If your friend is visiting at your location, they can just hop on your wifi, install Yggdrasil, and it will automatically discover a route to you.  Yggdrasil even has a zero-config mode for ephemeral nodes such as certain Docker containers.</p>
<p>Yggdrasil doesn’t directly support publishing to the clearnet, but it is certainly possible to proxy (or even NAT) to/from the clearnet, and people do.</p>
<h4 id="yggdrasil-dns">Yggdrasil: DNS</h4>
<p>There is no particular extra DNS in Yggdrasil.  You can, of course, run a DNS server within Yggdrasil, just as you can anywhere else.  Personally I just add relevant hosts to <code>/etc/hosts</code> and leave it at that, but it’s up to you.</p>
<h4 id="yggdrasil-source-code-pricing-and-portability">Yggdrasil: Source code, pricing, and portability</h4>
<p>Yggdrasil is fully <a href="https://github.com/yggdrasil-network/yggdrasil-go">open source</a> (LGPLv3 plus additional permissions in an exception) and highly portable.  It is written in Go, and has <a href="https://yggdrasil-network.github.io/installation.html">prebuilt binaries</a> for all major platforms (including a <a href="https://packages.debian.org/search?keywords=yggdrasil">Debian package</a> which I made).</p>
<p>There is no charge for anything with Yggdrasil.  Listed public peers are free and run by volunteers.  You can run your own peers if you like; they can be public and unlisted, public and listed (just submit a PR to get it listed), or private (accepting connections only from certain nodes’ keys).  A “peer” in this case is just a node with a known clearnet IP address.</p>
<p>Yggdrasil encourages use in other projects.  For instance, <a href="https://www.complete.org/nncp/">NNCP</a> integrates a Yggdrasil node for easy communication with other NNCP nodes.</p>
<h4 id="yggdrasil-conclusions">Yggdrasil conclusions</h4>
<p>Yggdrasil is tops in reliability (having no single point of failure) and flexibility.  It will maintain opportunistic connections between peers even if the Internet is down.
The unique added feature of being able to be part of a global mesh is a nice one.
The tradeoffs include being more prone to need to use a broker in restrictive CGNAT environments.  Some other tools have clients that override the OS DNS resolver to also provide resolution of hostnames of member nodes; Yggdrasil doesn’t, though you can certainly run your own DNS infrastructure over Yggdrasil (or, for that matter, let public DNS servers provide Yggdrasil answers if you wish).</p>
<p>There is also a need to pay more attention to firewalling or maintaining separation from the public mesh.  However, as I explain below, many other options have potential impacts if the control plane, or your account for it, are compromised, meaning you ought to firewall those, too.  Still, it may be a more immediate concern with Yggdrasil.</p>
<p>Although Yggdrasil is listed as experimental, I have been using it for over a year and have found it to be rock-solid.  They did change how mesh IPs were calculated when moving from 0.3 to 0.4, causing a global renumbering, so just be aware that this is a possibility while it is experimental.</p>
<h3 id="tinc">tinc</h3>
<p><a href="http://tinc-vpn.org/">tinc</a> is the oldest tool on this list; version 1.0 came out in 2003!  You can think of tinc as something akin to “an older Yggdrasil without the public option.”</p>
<p>I will be discussing tinc 1.0.36, the latest stable version, which came out in 2019.  The development branch, 1.1, has been going since 2011 and had its latest release in 2021.  The last commit to the Github repo was in June 2022.</p>
<p>Tinc is the only tool here to support both tun and tap style interfaces.  I go into the difference more in the Zerotier review below.  Tinc actually provides a better tap implementation than Zerotier, with various sane options for broadcasts, but I still think the call for an Ethernet, as opposed to IP, VPN is small.</p>
<p>To <a href="https://tinc-vpn.org/documentation/Configuration.html#Configuration">configure tinc</a>, you generate a per-host configuration and then distribute it to every tinc node.  It contains a host’s public key.  Therefore, adding a host to the mesh means distributing its key everywhere; de-authorizing it means removing its key everywhere.  This makes it rather unwieldy.</p>
<p>tinc can do LAN broadcast discovery and mesh routing, but generally speaking you must manually teach it where to connect initially.  Somewhat confusingly, the examples all mention listing a public address for a node.  This doesn’t make sense for a laptop, and I suspect you’d just omit it.  I think that address is used for something akin to a Yggdrasil peer with a clearnet IP.</p>
<p>Unlike all of the other tools described here, tinc has no tool to inspect the running state of the mesh.</p>
<p>Some of the properties of tinc made it clear I was unlikely to adopt it, so this review wasn’t as thorough as that of Yggdrasil.</p>
<h4 id="tinc-security-and-privacy">tinc: Security and Privacy</h4>
<p>As mentioned above, every host in the tinc mesh is authenticated based on its public key.  However, to be more precise, this key is validated only at the point it connects to its next hop peer.  (To be sure, this is also the same as how the list of allowed pubkeys works in Yggdrasil.)  Since IPs in tinc are not derived from their key, and any host can assign itself whatever mesh IP it likes, this implies that a compromised host could impersonate another.</p>
<p>It is unclear whether packets are end-to-end encrypted when using a tinc node as a router.  The fact that they can be routed at the kernel level by the tun interface implies that they may not be.</p>
<h4 id="tinc-connectivity-and-nat-traversal">tinc: Connectivity and NAT traversal</h4>
<p>I was unable to find much information about NAT traversal in tinc, other than that it does support it.  tinc can run over UDP or TCP and auto-detects which to use, preferring UDP.</p>
<h4 id="tinc-sharing-with-friends">tinc: Sharing with friends</h4>
<p>tinc has no special support for this, and the difficulty of configuration makes it unlikely you’d do this with tinc.</p>
<h4 id="tinc-source-code-pricing-and-portability">tinc: Source code, pricing, and portability</h4>
<p>tinc is fully open source (GPLv2).  It is written in C and generally portable.  It supports some very old operating systems.  Mobile support is iffy.</p>
<p>tinc does not seem to be very actively maintained.</p>
<h4 id="tinc-conclusions">tinc conclusions</h4>
<p>I haven’t mentioned performance in my other reviews (see the section at the end of this post).  But, it is so poor as to only run about 300Mbps on my 2.5Gbps network.  That’s 1/3 the speed of Yggdrasil or Tailscale.  Combine that with the unwieldiness of adding hosts and some uncertainties in security, and I’m not going to be using tinc.</p>
<h2 id="automatic-peer-to-peer-mesh-vpns-with-centralized-control">Automatic Peer-to-Peer Mesh VPNs with centralized control</h2>
<p>These tend to be the options that are frequently discussed.  Let’s talk about the options.</p>
<h3 id="tailscale">Tailscale</h3>
<p><a href="https://tailscale.com/">Tailscale</a> is a popular choice in this type of VPN.  To use Tailscale, you first sign up on tailscale.com.  Then, you install the tailscale client on each machine.  On first run, it prints a URL for you to click on to authorize the client to your mesh (“tailnet”).  Tailscale assigns a mesh IP to each system.  The Tailscale client lets the Tailscale control plane gather IP information about each node, including all detectable public and private clearnet IPs.</p>
<p>When you attempt to contact a node via Tailscale, the client will fetch the known contact information from the control plane and attempt to establish a link.  If it can contact over the local LAN, it will (it doesn’t have broadcast autodetection like Yggdrasil; the information must come from the control plane).  Otherwise, it will try various NAT traversal options.  If all else fails, it will use a broker to relay traffic; Tailscale calls a broker a <a href="https://tailscale.com/kb/1232/derp-servers/">DERP relay server</a>.  Unlike Yggdrasil, a Tailscale node never relays traffic for another; all connections are either direct P2P or via a broker.</p>
<p>Tailscale, like several others, is based around Wireguard; though wireguard-go rather than the in-kernel Wireguard.</p>
<p>Tailscale has a number of somewhat unique features in this space:</p>
<ul>
<li><a href="https://tailscale.com/kb/1223/tailscale-funnel/">Funnel</a>, which lets you expose ports on your system to the public Internet via the VPN.</li>
<li><a href="https://tailscale.com/kb/1103/exit-nodes/">Exit nodes</a>, which automate the process of routing your public Internet traffic over some other node in the network.  This is possible with every tool mentioned here, but Tailscale makes switching it on or off a couple of quick commands away.</li>
<li><a href="https://tailscale.com/kb/1084/sharing/">Node sharing</a>, which lets you share a subset of your network with guests</li>
<li>A fantastic <a href="https://tailscale.com/kb/">set of documentation</a>, easily the best of the bunch.</li>
</ul>
<p>Funnel, in particular, is interesting.  With a couple of “tailscale serve”-style commands, you can expose a directory tree (or a development webserver) to the world.  Tailscale gives you a public hostname, obtains a cert for it, and proxies inbound traffic to you.  This is subject to some unspecified bandwidth limits, and you can only choose from three public ports, so it’s not really a production solution – but as a quick and easy way to demonstrate something cool to a friend, it’s a neat feature.</p>
<h4 id="tailscale-security-and-privacy">Tailscale: Security and Privacy</h4>
<p>With Tailscale, as with the other tools in this category, one of the main threats to consider is the control plane.  What are the consequences of a compromise of Tailscale’s control plane, or of the credentials you use to access it?</p>
<p>Let’s begin with the credentials used to access it.  Tailscale operates no identity system itself, instead relying on third parties.  For individuals, this means Google, Github, or Microsoft accounts; Okta and other SAML and similar identity providers are also supported, but this runs into complexity and expense that most individuals aren’t wanting to take on.  Unfortunately, all three of those types of accounts often have saved auth tokens in a browser.  Personally I would rather have a separate, very secure, login.</p>
<p>If a person does compromise your account or the Tailscale servers themselves, they can’t directly eavesdrop on your traffic because it is end-to-end encrypted.  However, assuming an attacker obtains access to your account, they could:</p>
<ul>
<li>Tamper with your Tailscale ACLs, permitting new actions</li>
<li>Add new nodes to the network</li>
<li>Forcibly remove nodes from the network</li>
<li>Enable or disable optional features</li>
</ul>
<p>Of note is that they cannot just commandeer an existing IP.  I would say the riskiest possibility here is that could add new nodes to the mesh.  Because they could also tamper with your ACLs, they could then proceed to attempt to access all your internal services.  They could even turn on <a href="https://tailscale.com/kb/1100/services/?q=service">service collection</a> and have Tailscale tell them what and where all the services are.</p>
<p>Therefore, as with other tools, I recommend a local firewall on each machine with Tailscale.  More on that below.</p>
<p>Tailscale has a new alpha feature called <a href="https://tailscale.com/kb/1226/tailnet-lock/?q=lock">tailnet lock</a> which helps with this problem.  It requires existing nodes in the mesh to sign a request for a new node to join.  Although this doesn’t address ACL tampering and some of the other things, it does represent a significant help with the most significant concern.  However, tailnet lock is in alpha, only available on the Enterprise plan, and has a waitlist, so I have been unable to test it.</p>
<p>Any Tailscale node can request the IP addresses belonging to any other Tailscale node.  The Tailscale control plane captures, and exposes to you, this information about every node in your network: the OS hostname, IP addresses and port numbers, operating system, creation date, last seen timestamp, and NAT traversal parameters.  You can optionally enable service data capture as well, which sends data about open ports on each node to the control plane.</p>
<p>Tailscale likes to highlight their <a href="https://tailscale.com/kb/1028/key-expiry">key expiry and rotation feature</a>.  By default, all keys expire after 180 days, and traffic to and from the expired node will be interrupted until they are renewed (basically, you re-login with your provider and do a renew operation).  Unfortunately, the only mention I can see of warning of impeding expiration is in the Windows client, and even there you need to <a href="https://tailscale.com/kb/1189/install-windows-msi/?q=expiration%20warning%20registry#ts%5Fkeyexpirationnotice">edit a registry key</a> to get the warning more than the default 24 hours in advance.  In short, it seems likely to cut off communications when it’s most important.  You can disable key expiry on a per-node basis in the admin console web interface, and I mostly do, due to not wanting to lose connectivity at an inopportune time.</p>
<h4 id="tailscale-connectivity-and-nat-traversal">Tailscale: Connectivity and NAT traversal</h4>
<p>When thinking about reliability, the primary consideration here is being able to reach the Tailscale control plane.  While it is <a href="https://forum.tailscale.com/t/does-tailscale-work-completely-offline/3522/3">possible in limited circumstances</a> to reach nodes without the Tailscale control plane, it is “a fairly brittle setup” and notably will not survive a client restart.  So if you use Tailscale to reach other nodes on your LAN, that won’t work unless your Internet is up and the control plane is reachable.</p>
<p>Assuming your Internet is up and Tailscale’s infrastructure is up, there is little to be concerned with.  Your own comfort level with cloud providers and your Internet should guide you here.</p>
<p>Tailscale wrote a fantastic article about <a href="https://tailscale.com/blog/how-nat-traversal-works/">NAT traversal</a> and they, predictably, do very well with it.  Tailscale prefers UDP but falls back to TCP if needed.  Broker (DERP) servers step in as a last resort, and Tailscale clients automatically select the best ones.  I’m not aware of anything that is more successful with NAT traversal than Tailscale.  This maximizes the situations in which a direct P2P connection can be used without a broker.</p>
<p>I have found Tailscale to be a bit slow to notice changes in network topography compared to Yggdrasil, and sometimes needs a kick in the form of restarting the client process to re-establish communications after a network change.  However, it’s possible (maybe even probable) that if I’d waited a bit longer, it would have sorted this all out.</p>
<h4 id="tailscale-sharing-with-friends">Tailscale: Sharing with friends</h4>
<p>I touched on the funnel feature earlier.  The <a href="https://tailscale.com/kb/1084/sharing/">sharing</a> feature lets you give an invite to an outsider.  By default, a person accepting a share can make only outgoing connections to the network they’re invited to, and cannot receive incoming connections from that network – this makes sense.  When sharing an exit node, you get a checkbox that lets you share access to the exit node as well.  Of course, the person accepting the share needs to install the Tailnet client.  The combination of funnel and sharing make Tailscale the best for ad-hoc sharing.</p>
<h4 id="tailscale-dns">Tailscale: DNS</h4>
<p><a href="https://tailscale.com/kb/1054/dns">Tailscale’s DNS</a> is called <a href="https://tailscale.com/kb/1081/magicdns/">MagicDNS</a>.  It runs as a layer atop your standard DNS – taking over <code>/etc/resolv.conf</code> on Linux – and provides resolution of mesh hostnames and some other features.  This is a concept that is pretty slick.</p>
<p>It also is a bit flaky on Linux; dueling programs want to write to <code>/etc/resolv.conf</code>.  I can’t really say this is entirely Tailscale’s fault; they <a href="https://tailscale.com/kb/1188/linux-dns/">document the problem and some workarounds</a>.</p>
<p>I would love to be able to add custom records to this service; for instance, to override the public IP for a service to use the in-mesh IP.  Unfortunately, that’s <a href="https://github.com/tailscale/tailscale/issues/1543">not yet possible</a>.  However, MagicDNS can query existing nameservers for certain domains in a split DNS setup.</p>
<h4 id="tailscale-source-code-pricing-and-portability">Tailscale: Source code, pricing, and portability</h4>
<p>Tailscale is <a href="https://tailscale.com/opensource/">almost</a> fully open source and the client is highly portable.  The client is open source (BSD 3-clause) on open source platforms, and closed source on closed source platforms.  The DERP servers are open source.  The coordination server is closed source, although <a href="https://github.com/juanfont/headscale">there is an open source coordination server called Headscale</a> (also BSD 3-clause) made available with Tailscale’s blessing and informal support.  It supports most, but not all, features in the Tailscale coordination server.</p>
<p>Tailscale’s <a href="https://tailscale.com/pricing/">pricing</a> (which does not apply when using Headscale) provides a free plan for 1 user with up to 20 devices.  A Personal Pro plan expands that to 100 devices for $48 per year - not a bad deal at $4/mo.  A “Community on Github” plan also exists, and then there are more business-oriented plans as well.  See the pricing page for details.</p>
<p>As a small note, I appreciated Tailscale’s install script.  It properly added Tailscale’s apt key in a way that it can only be used to authenticate the Tailscale repo, rather than as a systemwide authenticator.  This is a nice touch and speaks well of their developers.</p>
<h4 id="tailscale-conclusions">Tailscale conclusions</h4>
<p>Tailscale is tops in sharing and has a broad feature set and excellent documentation.  Like other solutions with a centralized control plane, device communications can stop working if the control plane is unreachable, and the threat model of the control plane should be carefully considered.</p>
<h3 id="zerotier">Zerotier</h3>
<p><a href="https://www.zerotier.com/">Zerotier</a> is a close competitor to Tailscale, and is similar to it in a lot of ways.  So rather than duplicate all of the Tailscale information here, I’m mainly going to describe how it differs from Tailscale.</p>
<p>The primary difference between the two is that Zerotier emulates an Ethernet network via a Linux tap interface, while Tailscale emulates a TCP/IP network via a Linux tun interface.</p>
<p>However, Zerotier has a number of things that make it be a somewhat imperfect Ethernet emulator.  For one, it has a problem with <a href="https://docs.zerotier.com/zerotier/manual/">broadcast amplification</a>; the machine sending the broadcast sends it to all the other nodes that should receive it (up to a set maximum).  I wouldn’t want to have a lot of programs broadcasting on a slow link.  While in theory this could let you run Netware or DECNet across Zerotier, I’m not really convinced there’s much call for that these days, and Zerotier is clearly IP-focused as it allocates IP addresses and such anyhow.  Zerotier provides special support for emulated ARP (IPv4) and NDP (IPv6).  While you could theoretically run Zerotier as a bridge, this eliminates the zero trust principle, and Tailscale supports <a href="https://tailscale.com/kb/1019/subnets/">subnet routers</a>, which provide much of the same feature set anyhow.</p>
<p>A somewhat obscure feature, but possibly useful, is Zerotier’s built-in <a href="https://docs.zerotier.com/zerotier/multipath/">support for multipath WAN</a> for the public interface.  This actually lets you do a somewhat basic kind of channel bonding for WAN.</p>
<h4 id="zerotier-security-and-privacy">Zerotier: Security and Privacy</h4>
<p>The picture here is similar to Tailscale, with the difference that you can create a Zerotier-local account rather than relying on cloud authentication.  I was unable to find as much detail about Zerotier as I could about Tailscale - notably I couldn’t find anything about how “sticky” an IP address is.  However, the configuration screen lets me delete a node and assign additional arbitrary IPs within a subnet to other nodes, so I think the assumption here is that if your Zerotier account (or the Zerotier control plane) is compromised, an attacker could remove a legit device, add a malicious one, and assign the previous IP of the legit device to the malicious one.  I’m not sure how to mitigate against that risk, as firewalling specific IPs is ineffective if an attacker can simply take them over.  Zerotier also lacks anything akin to Tailnet Lock.</p>
<p>For this reason, I didn’t proceed much further in my Zerotier evaluation.</p>
<h4 id="zerotier-connectivity-and-nat-traversal">Zerotier: Connectivity and NAT traversal</h4>
<p>Like Tailscale, Zerotier has NAT traversal with STUN.  However, it looks like it’s <a href="https://zerotier.atlassian.net/wiki/spaces/SD/pages/6815768/Router+Configuration+Tips">more limited</a> than Tailscale’s, and in particular is incompatible with double NAT that is often seen these days.  Zerotier operates brokers (“root servers”) that can do relaying, including TCP relaying.  So you should be able to connect even from hostile networks, but you are less likely to form a P2P connection than with Tailscale.</p>
<h4 id="zerotier-sharing-with-friends">Zerotier: Sharing with friends</h4>
<p>I was unable to find any special features relating to this in the Zerotier documentation.  Therefore, it would be at the same level as Yggdrasil: possible, maybe even not too difficult, but without any specific help.</p>
<h4 id="zerotier-dns">Zerotier: DNS</h4>
<p>Unlike Tailscale, Zerotier <a href="https://zerotier.atlassian.net/wiki/spaces/SD/pages/900431890/DNS+Management">does not support</a> automatically adding DNS entries for your hosts.  Therefore, your options are approximately the same as Yggdrasil, though with the added option of pushing configuration pointing to your own non-Zerotier DNS servers to the client.</p>
<h4 id="zerotier-source-code-pricing-and-portability">Zerotier: Source code, pricing, and portability</h4>
<p>The client ZeroTier One is <a href="https://github.com/zerotier/ZeroTierOne">available on Github</a> under a custom “business source license” which prevents you from using it in certain settings.  This license would preclude it being included in Debian.  Their library, libzt, is <a href="https://github.com/zerotier/libzt">available</a>  under the same license.  The <a href="https://www.zerotier.com/pricing/">pricing page</a> mentions a community edition for self hosting, but the documentation is sparse and it was difficult to understand what its feature set really is.</p>
<p>The free plan lets you have 1 user with up to 25 devices.  Paid plans are also available.</p>
<h4 id="zerotier-conclusions">Zerotier conclusions</h4>
<p>Frankly I don’t see much reason to use Zerotier.  The “virtual Ethernet” model seems to be a weird hybrid that doesn’t bring much value.  I’m concerned about the implications of a compromise of a user account or the control plane, and it lacks a lot of Tailscale features (MagicDNS and sharing).  The only thing it may offer in particular is multipath WAN, but that’s esoteric enough – and also solvable at other layers – that it doesn’t seem all that compelling to me.  Add to that the strange license and, to me anyhow, I don’t see much reason to bother with it.</p>
<h3 id="netmaker">Netmaker</h3>
<p><a href="https://www.netmaker.io/">Netmaker</a> is one of the projects that is making noise these days.  Netmaker is the only one here that is a wrapper around in-kernel Wireguard, which can make a performance difference when talking to peers on a 1Gbps or faster link.  Also, unlike other tools, it has an <a href="https://www.netmaker.io/">ingress gateway</a> feature that lets people that don’t have the Netmaker client, but do have Wireguard, participate in the VPN.  I believe I also saw a reference somewhere to nodes as routers as with Yggdrasil, but I’m failing to dig it up now.</p>
<p>The project is in a bit of an early state; you can <a href="https://www.netmaker.io/beta">sign up</a> for an “upcoming closed beta” with a SaaS host, but really you are generally pointed to self-hosting using the code in the <a href="https://github.com/gravitl/netmaker">github repo</a>.  There are community and enterprise editions, but it’s not clear how to actually choose.  The server has a bunch of <a href="https://github.com/gravitl/netmaker">components</a>: binary, CoreDNS, database, and web server.  It also requires elevated privileges on the host, in addition to a container engine.  Contrast that to the single binary that some others provide.</p>
<p>It looks like <a href="https://github.com/gravitl/netmaker/releases">releases are frequent</a>, but sometimes break things, and have a somewhat more laborious upgrade processes than most.</p>
<p>I don’t want to spend a lot of time managing my mesh.  So because of the heavy needs of the server, the upgrades being labor-intensive, it taking over iptables and such on the server, I didn’t proceed with a more in-depth evaluation of Netmaker.  It has a lot of promise, but for me, it doesn’t seem to be in a state that will meet my needs yet.</p>
<h3 id="nebula">Nebula</h3>
<p><a href="https://github.com/gravitl/netmaker/releases">Nebula</a> is an interesting mesh project that originated within Slack, seems to still be primarily sponsored by Slack, but is also being developed by <a href="https://www.defined.net/">Defined Networking</a> (though their product looks early right now).  Unlike the other tools in this section, Nebula doesn’t have a web interface at all.  Defined Networking looks likely to provide something of a SaaS service, but for now, you will need to run a broker (“lighthouse”) yourself; perhaps on a $5/mo VPS.</p>
<p>Due to the poor firewall traversal properties, I didn’t do a full evaluation of Nebula, but it still has a very interesting design.</p>
<h4 id="nebula-security-and-privacy">Nebula: Security and Privacy</h4>
<p>Since Nebula lacks a traditional control plane, the root of trust in Nebula is a CA (certificate authority).  The documentation gives <a href="https://github.com/slackhq/nebula#4-nebula-host-keys-and-certificates-generated-from-that-certificate-authority">this example</a> of setting it up:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>./nebula-cert sign -name &#34;lighthouse1&#34; -ip &#34;192.168.100.1/24&#34;
</span></span><span><span>./nebula-cert sign -name &#34;laptop&#34; -ip &#34;192.168.100.2/24&#34; -groups &#34;laptop,home,ssh&#34;
</span></span><span><span>./nebula-cert sign -name &#34;server1&#34; -ip &#34;192.168.100.9/24&#34; -groups &#34;servers&#34;
</span></span><span><span>./nebula-cert sign -name &#34;host3&#34; -ip &#34;192.168.100.10/24&#34;
</span></span></code></pre></div><p>So the cert contains your IP, hostname, and group allocation.  Each host in the mesh gets your CA certificate, and the per-host cert and key generated from each of these steps.</p>
<p>This leads to a really nice security model.  Your CA is the gatekeeper to what is trusted in your mesh.  You can even have it airgapped or something to make it exceptionally difficult to breach the perimeter.</p>
<p>Nebula contains an integrated firewall.  Because the ability to keep out unwanted nodes is so strong, I would say this may be the one mesh VPN you might consider using without bothering with an additional on-host firewall.</p>
<p>You can define static mappings from a Nebula mesh IP to a clearnet IP.  I haven’t found information on this, but theoretically if NAT traversal isn’t required, these static mappings may allow Nebula nodes to reach each other even if Internet is down.  I don’t know if this is truly the case, however.</p>
<h4 id="nebula-connectivity-and-nat-traversal">Nebula: Connectivity and NAT traversal</h4>
<p>This is a weak point of Nebula.  Nebula sends all traffic over a <a href="https://nebula.defined.net/docs/config/listen/">single UDP port</a>; there is no provision for using TCP.  This is an issue at certain hotel and other public networks which open only TCP egress ports 80 and 443.</p>
<p>I couldn’t find a lot of detail on what Nebula’s NAT traversal is capable of, but according to a certain <a href="https://github.com/slackhq/nebula/issues/33">Github issue</a>, this has been a sore spot for years and isn’t as capable as Tailscale.</p>
<p>You can designate nodes in Nebula as brokers (<a href="https://nebula.defined.net/docs/config/relay/">relays</a>).  The concept is the same as Yggdrasil, but it’s less versatile.  You have to manually designate what relay to use.  It’s unclear to me what happens if different nodes designate different relays.  Keep in mind that this always happens over a UDP port.</p>
<h4 id="nebula-sharing-with-friends">Nebula: Sharing with friends</h4>
<p>There is no particular support here.</p>
<h4 id="nebula-dns">Nebula: DNS</h4>
<p>Nebula has <a href="https://nebula.defined.net/docs/guides/using-lighthouse-dns/">experimental DNS support</a>.  In contrast with Tailscale, which has an internal DNS server on every node, Nebula only runs a DNS server on a lighthouse.  This means that it can’t forward requests to a DNS server that’s upstream for your laptop’s particular current location.  Actually, Nebula’s DNS server doesn’t forward at all.  It also doesn’t resolve its own name.</p>
<p>The Nebula documentation makes reference to using multiple lighthouses, which you may want to do for DNS redundancy or performance, but it’s unclear to me if this would make each lighthouse form a complete picture of the network.</p>
<h4 id="nebula-source-code-pricing-and-portability">Nebula: Source code, pricing, and portability</h4>
<p>Nebula is fully open source (MIT).  It consists of a single Go binary and configuration.  It is fairly portable.</p>
<h4 id="nebula-conclusions">Nebula conclusions</h4>
<p>I am attracted to Nebula’s unique security model.  I would probably be more seriously considering it if not for the lack of support for TCP and poor general NAT traversal properties.  Its datacenter connectivity heritage does show through.</p>
<h2 id="roll-your-own-and-hybrid">Roll your own and hybrid</h2>
<p>Here is a grab bag of ideas:</p>
<h3 id="running-yggdrasil-over-tailscale">Running Yggdrasil over Tailscale</h3>
<p>One possibility would be to use Tailscale for its superior NAT traversal, then allow Yggdrasil to run over it.  (You will need a firewall to prevent Tailscale from trying to run over Yggdrasil at the same time!)  This creates a closed network with all the benefits of Yggdrasil, yet getting the NAT traversal from Tailscale.</p>
<p>Drawbacks might be the overhead of the double encryption and double encapsulation.  A good Yggdrasil peer may wind up being faster than this anyhow.</p>
<h3 id="public-vpn-provider-for-nat-traversal">Public VPN provider for NAT traversal</h3>
<p>A public VPN provider such as <a href="https://mullvad.net/en">Mullvad</a> will often offer incoming port forwarding and nodes in many cities.  This could be an attractive way to solve a bunch of NAT traversal problems: just use one of those services to get you an incoming port, and run whatever you like over that.</p>
<p>Be aware that a number of public VPN clients have a “kill switch” to prevent any traffic from egressing without using the VPN; see, for instance, <a href="https://mullvad.net/en/help/using-mullvad-vpn-app/#killswitch">Mullvad’s</a>.  You’ll need to disable this if you are running a mesh atop it.</p>
<h2 id="other">Other</h2>
<h3 id="combining-with-local-firewalls">Combining with local firewalls</h3>
<p>For most of these tools, I recommend using a local firewal in conjunction with them.  I have been using <a href="https://firehol.org/">firehol</a> and find it to be quite nice.  This means you don’t have to trust the mesh, the control plane, or whatever.  The catch is that you do need your mesh VPN to provide strong association between IP address and node.  Most, but not all, do.</p>
<h3 id="performance">Performance</h3>
<p>I tested some of these for performance using iperf3 on a 2.5Gbps LAN.  Here are the results.  All speeds are in Mbps.</p>
<table>
<thead>
<tr>
<th>Tool</th>
<th>iperf3 (default)</th>
<th>iperf3 -P 10</th>
<th>iperf3 -R</th>
</tr>
</thead>
<tbody>
<tr>
<td>Direct (no VPN)</td>
<td>2406</td>
<td>2406</td>
<td>2764</td>
</tr>
<tr>
<td>Wireguard (kernel)</td>
<td>1515</td>
<td>1566</td>
<td>2027</td>
</tr>
<tr>
<td>Yggdrasil</td>
<td>892</td>
<td>1126</td>
<td>1105</td>
</tr>
<tr>
<td>Tailscale</td>
<td>950</td>
<td>1034</td>
<td>1085</td>
</tr>
<tr>
<td>Tinc</td>
<td>296</td>
<td>300</td>
<td>277</td>
</tr>
</tbody>
</table>
<p>You can see that Wireguard was significantly faster than the other options.  Tailscale and Yggdrasil were roughly comparable, and Tinc was terrible.</p>
<h3 id="ip-collisions">IP collisions</h3>
<p>When you are communicating over a network such as these, you need to trust that the IP address you are communicating with belongs to the system you think it does.  This protects against two malicious actor scenarios:</p>
<ol>
<li>Someone compromises one machine on your mesh and reconfigures it to impersonate a more important one</li>
<li>Someone connects an unauthorized system to the mesh, taking over a trusted IP, and uses the privileges of the trusted IP to access resources</li>
</ol>
<p>To summarize the state of play as highlighted in the reviews above:</p>
<ul>
<li>Yggdrasil derives IPv6 addresses from a public key</li>
<li>tinc allows any node to set any IP</li>
<li>Tailscale IPs aren’t user-assignable, but the assignment algorithm is unknown</li>
<li>Zerotier allows any IP to be allocated to any node at the control plane</li>
<li>I don’t know what Netmaker does</li>
<li>Nebula IPs are baked into the cert and signed by the CA, but I haven’t verified the enforcement algorithm</li>
</ul>
<p>So this discussion really only applies to Yggdrasil and Tailscale.  tinc and Zerotier lack detailed IP security, while Nebula expects IP allocations to be handled outside of the tool and baked into the certs (therefore enforcing rigidity at that level).</p>
<p>So the question for Yggdrasil and Tailscale is: how easy is it to commandeer a trusted IP?</p>
<p>Yggdrasil has a brief <a href="https://yggdrasil-network.github.io/configuration.html#generating-stronger-addresses-and-prefixes">discussion</a> of this.  In short, Yggdrasil offers you both a dedicated IP and a rarely-used /64 prefix which you can delegate to other machines on your LAN.  Obviously by taking the dedicated IP, a lot more bits are available for the hash of the node’s public key, making “collisions technically impractical, if not outright impossible.”  However, if you use the /64 prefix, a collision may be more possible.  Yggdrasil’s hashing algorithm includes some optimizations to make this more difficult.  Yggdrasil includes a <code>genkeys</code> tool that uses more CPU cycles to generate keys that are maximally difficult to collide with.</p>
<p>Tailscale doesn’t document their IP assignment algorithm, but I think it is safe to say that the larger subnet you use, the better.  If you try to use a /24 for your mesh, it is certainly conceivable that an attacker could remove your trusted node, then just manually add the 240 or so machines it would take to get that IP reassigned.  It might be a good idea to use a purely IPv6 mesh with Tailscale to minimize this problem as well.</p>
<p>So, I think the risk is low in the default configurations of both Yggdrasil and Tailscale (certainly lower than with tinc or Zerotier).  You can drive the risk even lower with both.</p>
<h2 id="final-thoughts">Final thoughts</h2>
<p>For my own purposes, I suspect I will remain with Yggdrasil in some fashion.  Maybe I will just take the small performance hit that using a relay node implies.  Or perhaps I will get clever and use an incoming VPN port forward or go over Tailscale.</p>
<p>Tailscale was the other option that seemed most interesting.  However, living in a region with Internet that goes down more often than I’d like, I would like to just be able to send as much traffic over a mesh as possible, trusting that if the LAN is up, the mesh is up.</p>
<p>I have one thing that really benefits from performance in excess of Yggdrasil or Tailscale: NFS.  That’s between two machines that never leave my LAN, so I will probably just set up a direct Wireguard link between them.  Heck of a lot easier than trying to do Kerberos!</p>
<p>Finally, I wrote this intending to be useful.  I dealt with a lot of complexity and under-documentation, so it’s possible I got something wrong somewhere.  Please let me know if you find any errors.</p>

<hr/><p>This blog post is a copy of a <a href="https://www.complete.org/easily-accessing-all-your-stuff-with-a-zero-trust-mesh-vpn/">page on my website</a>.  That page may be periodically updated.</p>	</div></div>
  </body>
</html>
