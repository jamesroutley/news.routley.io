<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/felixge/fgtrace">Original</a>
    <h1>Fgtrace – The Full Go Tracer</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto"><a href="https://github.com/felixge/fgtrace/actions/workflows/go.yml?query=branch%3Amain"><img src="https://camo.githubusercontent.com/ced4c408f22b7970a36b49d801cb8f4ffe7399aa3f2b875964dd0ec99a6bd3f4/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f776f726b666c6f772f7374617475732f66656c697867652f666774726163652f476f3f6c6162656c3d7465737473" alt="ci test status" data-canonical-src="https://img.shields.io/github/workflow/status/felixge/fgtrace/Go?label=tests"/></a>
<a href="https://pkg.go.dev/github.com/felixge/fgtrace" rel="nofollow"><img src="https://camo.githubusercontent.com/a6ec91b268e20eb70ae61b3b8cb28309627474f7f72eb2adf6becf4fa843bc4a/687474703a2f2f696d672e736869656c64732e696f2f62616467652f676f646f632d7265666572656e63652d626c75652e737667" alt="documentation" data-canonical-src="http://img.shields.io/badge/godoc-reference-blue.svg"/></a></p>
<p dir="auto">fgtrace is an experimental profiler/tracer that is capturing wallclock timelines for each goroutine. It&#39;s very similar to the Chrome profiler.</p>
<p dir="auto"><g-emoji alias="warning" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/26a0.png">⚠️</g-emoji> fgtrace may cause noticeable stop-the-world pauses in your applications. It is intended for dev and testing environments for now.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/fgtrace-example.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/fgtrace-example.png"/></a></p>
<h2 dir="auto"><a id="user-content-quick-start" aria-hidden="true" href="#quick-start"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Quick Start</h2>
<p dir="auto">To capture an fgtrace of your program, simply add the one-liner shown below. This will cause the creation of a <code>fgtrace.json</code> file in the current working directory that you can view by opening it in the <a href="https://ui.perfetto.dev/" rel="nofollow">Perfetto UI</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import &#34;github.com/felixge/fgtrace&#34;

func main() {
	defer fgtrace.Config{Dst: fgtrace.File(&#34;fgtrace.json&#34;)}.Trace().Stop()

	// &lt;code to trace&gt;
}"><pre><span>package</span> main

<span>import</span> <span>&#34;github.com/felixge/fgtrace&#34;</span>

<span>func</span> <span>main</span>() {
	<span>defer</span> fgtrace.<span>Config</span>{<span>Dst</span>: <span>fgtrace</span>.<span>File</span>(<span>&#34;fgtrace.json&#34;</span>)}.<span>Trace</span>().<span>Stop</span>()

	<span>// &lt;code to trace&gt;</span>
}</pre></div>
<p dir="auto">Alternatively you can configure fgtrace as a <code>http.Handler</code> and request traces on-demand by hitting <code>http://localhost:1234/debug/fgtrace?seconds=30&amp;hz=100</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="package main

import (
	&#34;net/http&#34;
	&#34;github.com/felixge/fgtrace&#34;
)

func main() {
	http.DefaultServeMux.Handle(&#34;/debug/fgtrace&#34;, fgtrace.Config{})
	http.ListenAndServe(&#34;:1234&#34;, nil)
}"><pre><span>package</span> main

<span>import</span> (
	<span>&#34;net/http&#34;</span>
	<span>&#34;github.com/felixge/fgtrace&#34;</span>
)

<span>func</span> <span>main</span>() {
	<span>http</span>.<span>DefaultServeMux</span>.<span>Handle</span>(<span>&#34;/debug/fgtrace&#34;</span>, fgtrace.<span>Config</span>{})
	<span>http</span>.<span>ListenAndServe</span>(<span>&#34;:1234&#34;</span>, <span>nil</span>)
}</pre></div>
<p dir="auto">For more advanced use cases, have a look at the <a href="https://pkg.go.dev/github.com/felixge/fgtrace#Config" rel="nofollow">API Documentation</a>.</p>
<h2 dir="auto"><a id="user-content-comparison-with-similar-tools" aria-hidden="true" href="#comparison-with-similar-tools"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Comparison with Similar Tools</h2>
<p dir="auto">Below is a <a href="https://github.com/felixge/fgtrace/blob/main/testdata/readme">simple program</a> that spends its time sleeping, requesting a website, capturing the response body and then hashing it a few times.</p>
<div dir="auto" data-snippet-clipboard-copy-content="for i := 0; i &lt; 10; i++ {
	time.Sleep(10 * time.Millisecond)
}

res, err := http.Get(&#34;https://github.com/&#34;)
if err != nil {
	panic(err)
}
defer res.Body.Close()

var buf bytes.Buffer
if _, err := io.Copy(&amp;buf, res.Body); err != nil {
	panic(err)
}

for i := 0; i &lt; 1000; i++ {
	sha1.Sum(buf.Bytes())
}"><pre><span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>10</span>; <span>i</span><span>++</span> {
	<span>time</span>.<span>Sleep</span>(<span>10</span> <span>*</span> <span>time</span>.<span>Millisecond</span>)
}

<span>res</span>, <span>err</span> <span>:=</span> <span>http</span>.<span>Get</span>(<span>&#34;https://github.com/&#34;</span>)
<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
	<span>panic</span>(<span>err</span>)
}
<span>defer</span> <span>res</span>.<span>Body</span>.<span>Close</span>()

<span>var</span> <span>buf</span> bytes.<span>Buffer</span>
<span>if</span> <span>_</span>, <span>err</span> <span>:=</span> <span>io</span>.<span>Copy</span>(<span>&amp;</span><span>buf</span>, <span>res</span>.<span>Body</span>); <span>err</span> <span>!=</span> <span>nil</span> {
	<span>panic</span>(<span>err</span>)
}

<span>for</span> <span>i</span> <span>:=</span> <span>0</span>; <span>i</span> <span>&lt;</span> <span>1000</span>; <span>i</span><span>++</span> {
	<span>sha1</span>.<span>Sum</span>(<span>buf</span>.<span>Bytes</span>())
}</pre></div>
<p dir="auto">Now let&#39;s have a look at how fgtrace and other tools allow you to understand the performance of such a program.</p>
<h3 dir="auto"><a id="user-content-fgtrace" aria-hidden="true" href="#fgtrace"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>fgtrace</h3>
<p dir="auto">Looking at our main goroutine (G1), we can easily recognize the operations of the program, their order, and how long they are taking (~100ms <code>time.Sleep</code>, ~65ms <code>http.Get</code>, ~30ms <code>io.Copy</code>ing the response and ~300ms calling <code>sha1.Sum</code> to hash it).</p>
<p dir="auto">However, it&#39;s important to note that this data is captured by sampling goroutine stack traces rather than actual tracing. Therefore fgtrace does not know that there were ten <code>time.Sleep()</code> function calls lasting <code>10ms</code> each. Instead it just merges its samples into one big <code>time.Sleep()</code> call that appears to take <code>100ms</code>.</p>
<p dir="auto">Another detail are the virtual goroutine state indicators on top, e.g. <code>sleep</code>, <code>select</code>, <code>sync.Cond.Wait</code> and <code>running/runnable</code>. These are not part of the real stack traces and meant to help understanding On-CPU activity (<code>running/runnable</code>) vs Off-CPU states. You can disable them via configuration.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/fgtrace-example.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/fgtrace-example.png"/></a></p>
<p dir="auto">To break down the latency of our main goroutine, we can also look at other goroutines used by the program. E.g. below is a closer look on how the <code>http.Get</code> operation is broken down into resolving the IP address, connecting to it, and performing a TLS handshake.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/fgtrace-example2.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/fgtrace-example2.png"/></a></p>
<p dir="auto">So as you can see, fgtrace offers an intuitive, yet powerful way to understand the operation of Go programs. However, since it always captures the activity of all goroutines and has no information about how they communicate with each other, it may create overwhelming amounts of data in some cases.</p>
<h3 dir="auto"><a id="user-content-fgprof" aria-hidden="true" href="#fgprof"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>fgprof</h3>
<p dir="auto">You can think of <a href="https://github.com/felixge/fgprof">fgprof</a> as a more simplified version of fgtrace. Instead of capturing a timeline for each goroutine, it aggregates the same data into a single profile as shown in the flame graph below.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/fgprof-example.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/fgprof-example.png"/></a></p>
<p dir="auto">This means that the x-axis represents duration rather than time, so function calls are ordered alphabetically rather than chronologically. E.g. notice how <code>time.Sleep</code> is shown after <code>sha1.Sum</code> in the graph above even so it&#39;s the first operation completed by our program.</p>
<p dir="auto">Additionally the data of all goroutines ends up in the same graph which can be difficult to read without having a good understanding of the underlaying code and number of goroutines that are involved.</p>
<p dir="auto">Despite these disadvantages, fgprof may still be useful in certain situations where the detail provided by the timeline may be overwhelming and a simpler view of the average program behavior is desirable. Additionally fgprof under Go 1.19 has less <a href="https://go-review.googlesource.com/c/go/+/387415" rel="nofollow">negative impact</a> on the performance of the profiled program than fgtrace.</p>
<h3 dir="auto"><a id="user-content-runtimetrace" aria-hidden="true" href="#runtimetrace"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>runtime/trace</h3>
<p dir="auto">The <code>runtime/trace</code> package is a true execution tracer that is capable of capturing even more detailed information than fgtrace. However, it&#39;s mostly designed to understand the decisions made by the Go scheduler. So the default timeline is focused on how goroutines are scheduled onto the CPU (processors). This means only the <code>sha1.Sum</code> operation stands out in green, and full stack traces can only be seen by clicking on the individual scheduler activities.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/runtime-example.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/runtime-example.png"/></a></p>
<p dir="auto">The goroutine analysis view offers a more useful breakdown. Here we can see that our goroutine is spending <code>271ms</code> in <code>Execution</code> on CPU, but it&#39;s not clear from this view alone that this is the <code>sha1.Sum</code> operation. Our networking activity (<code>http.Get</code> and <code>io.Copy</code>) gets grouped into <code>Sync block</code> rather than <code>Network wait</code> because the networking is done through channels via other goroutines. And our <code>time.Sleep</code> activity is shown as a grey component of the bar diagram, but not explicitly listed in the table. So while a lot of information is available here, it&#39;s difficult to interpret for casual users.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/runtime-example2.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/runtime-example2.png"/></a></p>
<p dir="auto">Last but not least it&#39;s possible to click on the goroutine id in the view above in order to see a timeline for the individual goroutine, as well as the other goroutines it is communicating with. However, the view is also CPU-centric, so remains difficult to understand the sleep and networking operations of our program.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/felixge/fgtrace/blob/main/assets/runtime-example3.png"><img src="https://github.com/felixge/fgtrace/raw/main/assets/runtime-example3.png"/></a></p>
<p dir="auto">That being said, some of the limitations of <code>runtime/trace</code> could probably be resolved with changes to the UI or converting the traces into a format that <a href="https://ui.perfetto.dev/" rel="nofollow">Perfetto UI</a> can understand which might be a fun project for another time.</p>
<h2 dir="auto"><a id="user-content-how-it-works" aria-hidden="true" href="#how-it-works"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How it Works</h2>
<p dir="auto">The current implementation of fgtrace is incredibly hacky. It calls <a href="https://pkg.go.dev/runtime#Stack" rel="nofollow"><code>runtime.Stack()</code></a> on a regular frequency (default 100 Hz) to capture textual stack traces of all goroutines and parses them using the <a href="https://github.com/DataDog/gostackparse">gostackparse</a> package. Each call to <code>runtime.Stack()</code> is a blocking stop-the-world operation, so it scales very poorly to programs using ten thousand or more goroutines.</p>
<p dir="auto">After the data is captured, it is converted into the <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/preview" rel="nofollow">Trace Event Format</a> which is one of the data formats understood by <a href="https://ui.perfetto.dev/" rel="nofollow">Perfetto UI</a>.</p>
<h2 dir="auto"><a id="user-content-the-future" aria-hidden="true" href="#the-future"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Future</h2>
<p dir="auto">fgtrace is mostly a <a href="http://paulgraham.com/ds.html" rel="nofollow">&#34;Do Things that Don&#39;t Scale&#34;</a> kind of project. If enough people like it, it will motivate me and perhaps others to invest into putting it on a solid technical foundation.</p>
<p dir="auto">The Go team has previously <a href="https://github.com/golang/go/issues/41324#issuecomment-703796820" data-hovercard-type="issue" data-hovercard-url="/golang/go/issues/41324/hovercard">declined</a> the idea of adding wallclock profiling capabilities similar to fgprof (which is similar to fgtrace) to the Go project and is more likely to invest in <code>runtime/trace</code> going forward.</p>
<p dir="auto">That being said, I still think fgtrace can help by:</p>
<ol dir="auto">
<li>Showing the usefulness of stack-trace/wallclock focused timeline views in addition to the CPU-centric views used by <code>runtime/trace</code> to perhaps implement the future developement of the runtime tracer.</li>
<li>Starting a conversation (link to GH issue will follow ...) to offer more powerful goroutine profiling APIs to allow user-space tooling like this to thrive without having to hack around the <a href="https://github.com/DataDog/go-profiler-notes/blob/main/goroutine.md#feature-matrix">existing APIs</a> while reducing their overhead.</li>
</ol>
<h2 dir="auto"><a id="user-content-license" aria-hidden="true" href="#license"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>License</h2>
<p dir="auto">fgtrace is licensed under the MIT License.</p>
</article>
          </div></div>
  </body>
</html>
