<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://a3nm.net/blog/adversarial_tetris.html">Original</a>
    <h1>Can you be sure to clear a line at Tetris?</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p><em>Summary: it is possible to play Tetris and guarantee that you will score at
least one line, no matter which pieces are given to you, i.e., even assuming
they are chosen adversarially.</em></p>
<p>There are many things that can be found online about the game
<a href="https://en.wikipedia.org/wiki/Tetris">Tetris</a>: high scores (see
for instance this great
<a href="https://en.wikipedia.org/wiki/Ecstasy_of_Order:_The_Tetris_Masters">documentary</a>),
implementation details (did you know there was a
<a href="https://tetris.fandom.com/wiki/Tetris_Guideline">specification for Tetris games</a>?),
intellectual property surprises (this post is not related to or endorsed by <a href="https://en.wikipedia.org/wiki/The_Tetris_Company">The Tetris
Company</a>)... But for many years
I have not been able to find on the Internet the answer to this question: <strong>can
you be sure to clear a line at Tetris?</strong></p>
<p>Of course, in practice, most Tetris players seem to be able to clear lines at least
some of the time<sup>[citation needed]</sup>. But maybe they are just being lucky!
Maybe an evil computer or extreme bad luck could prevent you from ever
clearing a line, no matter how you played. For instance, consider the
game <a href="https://qntm.org/files/hatetris/hatetris.html">Hatetris</a>, which is
programmed to give you unpleasant pieces. Clearing a line in Hatetris is much more
challenging, though good players can do it. Could a worse
version of Hatetris, with a more clever opponent, give you pieces that will <strong>always
make you lose without scoring a single line</strong>?</p>
<p>Mathematically, we can formulate this a
<a href="https://en.wikipedia.org/wiki/Sequential_game">sequential</a> <a href="https://en.wikipedia.org/wiki/Zero-sum_game">zero-sum
game</a> with <a href="https://en.wikipedia.org/wiki/Perfect_information">perfect
information</a>. We have a
standard Tetris board of 10 columns by 20 rows. The computer and human play
alternatively: the computer gives a piece to the human (one of the seven
tetrominoes), and the human responds by positioning it somewhere according
to the usual Tetris rules. If the screen is filled up then the human has lost,
and if the human completes a line then the human has won. Mathematically, there
are then only two possibilities:</p>
<ul>
<li>either the computer has a strategy to give pieces (depending on how the human
  has played so far) that guarantees that the human will lose without completing
  a single line, no matter what they do;</li>
<li>or the human has a strategy to place pieces that guarantee that they will
  score a line before losing, no matter which pieces they receive from the
  computer.</li>
</ul>
<p>My question was to figure out which one of the two is true. After some coding
and much computation, it turns out that <strong>the human wins</strong>: it is possible to
guarantee a non-zero score when playing Tetris. If you want to see an example strategy,
you can test it with the Tetris board below. You play the computer, i.e., you
select which piece to give, and the chosen piece will be placed according
to a winning strategy. Try preventing your opponent from scoring a line! (the
point of this post is that this is impossible)</p>


<p>An alternative challenge: try preventing the computer from
scoring a line in the 5 bottom rows! This is possible for precisely 759 piece
sequences out of the 427513 winning sequences. Can you find them?</p>
<p>In the rest of the post, I explain some details about the exact problem statement,
and give more details about the strategy and how to check it. Then, I explain how I
computed the strategy, possible improvements to the computation, and then
present related work and remaining open problems.</p>
<h2>Technical details</h2>
<p>Here are some detail about the problem and strategy:</p>
<ul>
<li>I restrict the human player to <strong>only rotate and then drop pieces vertically</strong>,
  i.e., playing a piece means choosing a rotation and a column where to drop it.
  (You cannot slide a block under another block, no t-spins, etc.) Of course, if
  the human can win under this restriction, they can win even when we allow more
  moves.</li>
<li>I do not require the computer to <strong>show the next piece</strong>, i.e., commit to what the
  next piece will be before the human has dropped their current piece. Of
  course, if the human can win in such conditions, they can also win with a next
  piece display.</li>
<li>Under such circumstances, the human can play so as to guarantee that they can
  complete <strong>one of the lowest 6 rows</strong> of the board. The exploration also shows
  that the computer can prevent the human from scoring one of the bottom 5
  lines, subject to the above restrictions, and assuming that the human does not
  play &#34;above&#34; the fifth line, i.e., dropped pieces cannot touch a <em>full
  column</em> which has height at least 5. (See below to know more about this
  limitation.<sup id="fnref:adversarial_tetris_louisb"><a href="#fn:adversarial_tetris_louisb">1</a></sup>)</li>
<li>In the worst case, the human needs to position <strong>13 pieces</strong> to complete its first
  line among the bottom 6 rows. This is optimal under the above restrictions:
  when only considering completion of the first 6 rows, dropping pieces without
  sliding them, and prohibiting dropped pieces from touching a
  full column. I think it is
  very likely that the human can win faster if we allow the player to slide
  pieces; and possible that the human can win faster by going above the 6th row.</li>
<li>Where several moves achieve the same distance to a win, they are chosen
  arbitrarily, following the order in which the possible choices of where to put
  a piece are considered (first by rotation, then by column). This is why the
  strategy above is not symmetric, e.g., between l-shaped and j-shaped
  tetrominoes.</li>
</ul>
<h2>Checking the strategy</h2>
<p>I provide the strategy as a <a href="https://vishnubharathi.codes/blog/cuelang/adversarial_tetris/strategy.txt">file</a> describing
how the human can play and
guarantee a win. Each line of this file corresponds to a possible &#34;game state&#34;,
numbered from <span><span id="MathJax-Element-1-Frame"><span id="MJXc-Node-1" role="math"><span id="MJXc-Node-2"><span id="MJXc-Node-3"><span>0</span></span></span></span></span></span> to 5249 (the file has 5250
lines<sup id="fnref:adversarial_tetris_minstate"><a href="#fn:adversarial_tetris_minstate">2</a></sup>). Each line consists of 21
integers, numbered from <span><span id="MathJax-Element-2-Frame"><span id="MJXc-Node-4" role="math"><span id="MJXc-Node-5"><span id="MJXc-Node-6"><span>0</span></span></span></span></span></span> to <span><span id="MathJax-Element-3-Frame"><span id="MJXc-Node-7" role="math"><span id="MJXc-Node-8"><span id="MJXc-Node-9"><span>20</span></span></span></span></span></span> as <span><span id="MathJax-Element-4-Frame"><span id="MJXc-Node-10" role="math"><span id="MJXc-Node-11"><span id="MJXc-Node-12"><span>3</span></span><span id="MJXc-Node-13"><span>p</span></span><span id="MJXc-Node-14"><span>+</span></span><span id="MJXc-Node-15"><span>q</span></span></span></span></span></span> with <span><span id="MathJax-Element-5-Frame"><span id="MJXc-Node-16" role="math"><span id="MJXc-Node-17"><span id="MJXc-Node-18"><span>0</span></span><span id="MJXc-Node-19"><span>≤</span></span><span id="MJXc-Node-20"><span>p</span></span><span id="MJXc-Node-21"><span>&lt;</span></span><span id="MJXc-Node-22"><span>7</span></span></span></span></span></span> and <span><span id="MathJax-Element-6-Frame"><span id="MJXc-Node-23" role="math"><span id="MJXc-Node-24"><span id="MJXc-Node-25"><span>0</span></span><span id="MJXc-Node-26"><span>≤</span></span><span id="MJXc-Node-27"><span>q</span></span><span id="MJXc-Node-28"><span>&lt;</span></span><span id="MJXc-Node-29"><span>3</span></span></span></span></span></span>. The triple <span><span id="MathJax-Element-7-Frame"><span id="MJXc-Node-30" role="math"><span id="MJXc-Node-31"><span id="MJXc-Node-32"><span>3</span></span><span id="MJXc-Node-33"><span>p</span></span><span id="MJXc-Node-34"><span>,</span></span><span id="MJXc-Node-35"><span>3</span></span><span id="MJXc-Node-36"><span>p</span></span><span id="MJXc-Node-37"><span>+</span></span><span id="MJXc-Node-38"><span>1</span></span><span id="MJXc-Node-39"><span>,</span></span><span id="MJXc-Node-40"><span>3</span></span><span id="MJXc-Node-41"><span>p</span></span><span id="MJXc-Node-42"><span>+</span></span><span id="MJXc-Node-43"><span>2</span></span></span></span></span></span> explains what to do when receiving piece <span><span id="MathJax-Element-8-Frame"><span id="MJXc-Node-44" role="math"><span id="MJXc-Node-45"><span id="MJXc-Node-46"><span>p</span></span></span></span></span></span>:
the number <span><span id="MathJax-Element-9-Frame"><span id="MJXc-Node-47" role="math"><span id="MJXc-Node-48"><span id="MJXc-Node-49"><span>3</span></span><span id="MJXc-Node-50"><span>p</span></span></span></span></span></span> indicates the rotation <span><span id="MathJax-Element-10-Frame"><span id="MJXc-Node-51" role="math"><span id="MJXc-Node-52"><span id="MJXc-Node-53"><span>0</span></span><span id="MJXc-Node-54"><span>≤</span></span><span id="MJXc-Node-55"><span>r</span></span><span id="MJXc-Node-56"><span>&lt;</span></span><span id="MJXc-Node-57"><span>4</span></span></span></span></span></span> to use, the number <span><span id="MathJax-Element-11-Frame"><span id="MJXc-Node-58" role="math"><span id="MJXc-Node-59"><span id="MJXc-Node-60"><span>3</span></span><span id="MJXc-Node-61"><span>p</span></span><span id="MJXc-Node-62"><span>+</span></span><span id="MJXc-Node-63"><span>1</span></span></span></span></span></span>
indicates the column <span><span id="MathJax-Element-12-Frame"><span id="MJXc-Node-64" role="math"><span id="MJXc-Node-65"><span id="MJXc-Node-66"><span>−</span></span><span id="MJXc-Node-67"><span>2</span></span><span id="MJXc-Node-68"><span>≤</span></span><span id="MJXc-Node-69"><span>c</span></span><span id="MJXc-Node-70"><span>&lt;</span></span><span id="MJXc-Node-71"><span>10</span></span></span></span></span></span> where to drop the piece, and the number
<span><span id="MathJax-Element-13-Frame"><span id="MJXc-Node-72" role="math"><span id="MJXc-Node-73"><span id="MJXc-Node-74"><span>3</span></span><span id="MJXc-Node-75"><span>p</span></span><span id="MJXc-Node-76"><span>+</span></span><span id="MJXc-Node-77"><span>2</span></span></span></span></span></span> indicates the game state from which we should follow the rest of the winning strategy
(the special value &#34;-1&#34; indicates that the player has won).
The pieces, rotations, and column offsets are according to the following
description of the pieces:</p>
<pre>== piece 0 rotation 0 ==
#...
#...
#...
#...
== piece 0 rotation 1 ==
....
....
....
####
== piece 0 rotation 2 ==
...#
...#
...#
...#
== piece 0 rotation 3 ==
####
....
....
....
== piece 1 rotation 0 ==
.#..
##..
#...
....
== piece 1 rotation 1 ==
....
....
##..
.##.
== piece 1 rotation 2 ==
....
...#
..##
..#.
== piece 1 rotation 3 ==
.##.
..##
....
....
== piece 2 rotation 0 ==
.##.
##..
....
....
== piece 2 rotation 1 ==
....
#...
##..
.#..
== piece 2 rotation 2 ==
....
....
..##
.##.
== piece 2 rotation 3 ==
..#.
..##
...#
....
== piece 3 rotation 0 ==
###.
.#..
....
....
== piece 3 rotation 1 ==
....
#...
##..
#...
== piece 3 rotation 2 ==
....
....
..#.
.###
== piece 3 rotation 3 ==
...#
..##
...#
....
== piece 4 rotation 0 ==
###.
#...
....
....
== piece 4 rotation 1 ==
....
#...
#...
##..
== piece 4 rotation 2 ==
....
....
...#
.###
== piece 4 rotation 3 ==
..##
...#
...#
....
== piece 5 rotation 0 ==
###.
..#.
....
....
== piece 5 rotation 1 ==
....
##..
#...
#...
== piece 5 rotation 2 ==
....
....
.#..
.###
== piece 5 rotation 3 ==
...#
...#
..##
....
== piece 6 rotation 0 ==
##..
##..
....
....
== piece 6 rotation 1 ==
....
....
##..
##..
== piece 6 rotation 2 ==
....
....
..##
..##
== piece 6 rotation 3 ==
..##
..##
....
....
</pre>

<p>The strategy thus describes a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> (with labeled edges).
In particular, we can get to the same game state by different paths, and indeed
the same game state can correspond to different states of the board but from
which we can use the same winning strategy.</p>
<p>The strategy in this file is the one used in the Javascript game above. I have
written a <a href="https://vishnubharathi.codes/git/tetrisolve/file/verify.cpp.html">program</a> (with <a href="https://vishnubharathi.codes/git/tetrisolve/file/common_tetris.cpp.html">helper
file</a>) that checks the strategy by
systematically going over all possible moves by the computer, playing according
to the strategy, and checking that the human indeed wins when the strategy says
they do. Hence, the mathematical &#34;proof&#34; that the human has a winning strategy
would consist of this file and of the verification program.</p>
<h2>Finding the strategy</h2>
<p>I could stop here and say that the strategy and the verification program are an
answer to the question I had posed :) but let me say a few words about how I found it.
This is performed using the <strong><a href="https://en.wikipedia.org/wiki/Minimax">minimax
algorithm</a></strong>, i.e., systematically
exploring the game tree. Formally, we define inductively who
wins on a given board state, among the human (H) and computer (C):</p>
<ul>
<li>Base 1: H wins on board states where <strong>one of the bottom 6 rows is
  filled</strong></li>
<li>Base 2: C wins on board states where <strong>we cannot
  place a piece without touching a full column</strong>, i.e., one where there are
  already blocks above the 6th row.</li>
<li>Induction 1: In a given board state <span><span id="MathJax-Element-14-Frame"><span id="MJXc-Node-78" role="math"><span id="MJXc-Node-79"><span id="MJXc-Node-80"><span>b</span></span></span></span></span></span> where H is given some piece <span><span id="MathJax-Element-15-Frame"><span id="MJXc-Node-81" role="math"><span id="MJXc-Node-82"><span id="MJXc-Node-83"><span>p</span></span></span></span></span></span>, if H
  can drop it and get to a board state which is winning for H, then <span><span id="MathJax-Element-16-Frame"><span id="MJXc-Node-84" role="math"><span id="MJXc-Node-85"><span id="MJXc-Node-86"><span>(</span></span><span id="MJXc-Node-87"><span>b</span></span><span id="MJXc-Node-88"><span>,</span></span><span id="MJXc-Node-89"><span>p</span></span><span id="MJXc-Node-90"><span>)</span></span></span></span></span></span> is
  winning for H; if all moves by H get to a board state which is losing for H, then <span><span id="MathJax-Element-17-Frame"><span id="MJXc-Node-91" role="math"><span id="MJXc-Node-92"><span id="MJXc-Node-93"><span>(</span></span><span id="MJXc-Node-94"><span>b</span></span><span id="MJXc-Node-95"><span>,</span></span><span id="MJXc-Node-96"><span>p</span></span><span id="MJXc-Node-97"><span>)</span></span></span></span></span></span> is losing for H.</li>
<li>Induction 2: In a given board state <span><span id="MathJax-Element-18-Frame"><span id="MJXc-Node-98" role="math"><span id="MJXc-Node-99"><span id="MJXc-Node-100"><span>b</span></span></span></span></span></span>, if C can give H a piece <span><span id="MathJax-Element-19-Frame"><span id="MJXc-Node-101" role="math"><span id="MJXc-Node-102"><span id="MJXc-Node-103"><span>p</span></span></span></span></span></span> such that
  <span><span id="MathJax-Element-20-Frame"><span id="MJXc-Node-104" role="math"><span id="MJXc-Node-105"><span id="MJXc-Node-106"><span>(</span></span><span id="MJXc-Node-107"><span>b</span></span><span id="MJXc-Node-108"><span>,</span></span><span id="MJXc-Node-109"><span>p</span></span><span id="MJXc-Node-110"><span>)</span></span></span></span></span></span> is losing for H, then <span><span id="MathJax-Element-21-Frame"><span id="MJXc-Node-111" role="math"><span id="MJXc-Node-112"><span id="MJXc-Node-113"><span>b</span></span></span></span></span></span> is losing for H; if any pieces given by C
  are such that <span><span id="MathJax-Element-22-Frame"><span id="MJXc-Node-114" role="math"><span id="MJXc-Node-115"><span id="MJXc-Node-116"><span>(</span></span><span id="MJXc-Node-117"><span>b</span></span><span id="MJXc-Node-118"><span>,</span></span><span id="MJXc-Node-119"><span>p</span></span><span id="MJXc-Node-120"><span>)</span></span></span></span></span></span> is winning for H then <span><span id="MathJax-Element-23-Frame"><span id="MJXc-Node-121" role="math"><span id="MJXc-Node-122"><span id="MJXc-Node-123"><span>b</span></span></span></span></span></span> is winning for H.</li>
</ul>
<p>This is just a simple recursive exploration. The naive way to implement this
would be to compute who wins on every board state, remembering in the board
state if each cell of the bottom 6 rows is filled
or not: this would be <span><span id="MathJax-Element-24-Frame"><span id="MJXc-Node-124" role="math"><span id="MJXc-Node-125"><span id="MJXc-Node-126"><span><span id="MJXc-Node-127"><span>2</span></span></span><span><span id="MJXc-Node-128"><span id="MJXc-Node-129"><span id="MJXc-Node-130"><span>6</span></span><span id="MJXc-Node-131"><span>×</span></span><span id="MJXc-Node-132"><span>10</span></span></span></span></span></span></span></span></span></span> possible board states, where 10 is the
number of columns. This
amounts to 1153 peta states, which is too much.</p>
<p>Since we are only allowing pieces to be dropped (without sliding them), we can do
better: in each column, we only need to remember the <strong>height of the
highest completed block</strong><sup id="fnref:adversarial_tetris_louis"><a href="#fn:adversarial_tetris_louis">3</a></sup>.
The status of the cells below the topmost filled cell
of a column have no influence on which moves are possible. The only
extra thing to remember is the <strong>set of rows having a &#34;hole&#34;</strong>,
i.e., an empty cell above which there is a filled cell. As we cannot slide
pieces, these holes can never be filled, so we must remember that the rows that
have a hole cannot be completed. We say that these lines are &#34;sacrificed&#34;.</p>
<p><strong>For an example</strong>, consider the state of the board after dropping a vertical
I-tetromino in the second column, pictured below. We represent this as the
sequence of heights written at the bottom.</p>
<p><img src="https://vishnubharathi.codes/blog/adversarial_tetris/config0.svg"/></p>
<p>Imagine now that we drop a vertically oriented z-block, getting to the
configuration below:</p>
<p><img src="https://vishnubharathi.codes/blog/adversarial_tetris/config1.svg"/></p>
<p>Columns 2 and 3 are now full, i.e., the blocks stack up to the 6th row. Hence,
we store their height as 6, and forget what happens above the 6th row (i.e., we
forget the block
in column 3 with a black cross) -- because of this, we will no longer allow
blocks to touch one of these full columns. Further, the new block has now created
holes -- the gray cells with red crosses. The sequence of heights does not
account for these holes; to remember that they are there, we store that the
bottom 5 rows have been &#34;sacrificed&#34;, materialized by the red crosses to the
left of the board. This is sufficient, because our way to drop pieces will never
allow H to slide a piece and fill these holes. Now, the 6th row is the only row
where H can ever hope to complete a line. (In fact, the configuration is now
clearly losing for H:
if C no longer gives H any I-tetromino, H can never fill the cell at column 1
and row 6, so H can never complete the only non-sacrificed line.)</p>
<p>To summarize, the board state consists of the <strong>height of each column</strong> (between 0
and 6 inclusive) and the <strong>set of sacrificed lines</strong>, for a total of <span><span id="MathJax-Element-25-Frame"><span id="MJXc-Node-133" role="math"><span id="MJXc-Node-134"><span id="MJXc-Node-135"><span><span id="MJXc-Node-136"><span>7</span></span></span><span><span id="MJXc-Node-137"><span id="MJXc-Node-138"><span id="MJXc-Node-139"><span>10</span></span></span></span></span></span><span id="MJXc-Node-140"><span>×</span></span><span id="MJXc-Node-141"><span><span id="MJXc-Node-142"><span>2</span></span></span><span><span id="MJXc-Node-143"><span>6</span></span></span></span></span></span></span></span> board states. This is much better: there are now 18 billion states. There are
other small savings, e.g., board states where all lines are sacrificed are
immediately losing. In practice, a complete exploration
considers around 2 billion states, i.e., only around 11% of the possible board
states are reached.</p>
<p>For efficient implementation, a board state is represented as a <strong>64-bit
integer</strong> consisting of a 16-bit mask describing the sacrificed lines (only the 6 lowest
bits are useful), and 10 4-bit integers describing the heights (only the 3
lowest bits are useful).</p>
<p>As the same board state can be reached by many different paths in the game tree,
we use <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>: when we are
done exploring the tree from some board state, we remember whether this state is
losing or winning, and if it is winning we remember in how many moves. This is
done with a hash table (a C++ <a href="https://en.cppreference.com/w/cpp/container/unordered_set">unordered set</a>).
This means that the program requires a
large quantity of RAM to run (around 20-30 GB): for this, I thank the
<a href="https://www.telecom-paris.fr/en/the-school/teaching-research-departments/computer-sciences-and-networks">INFRES
department</a>
at <a href="https://www.telecom-paris.fr/en/home">Télécom Paris</a> for giving us access to
suitable computing resources.</p>
<p>This explains how the winning strategy is found. It is fast (one hour) to check
that a winning strategy <strong>exists</strong> by terminating the search for a board state and
piece as soon as a winning move is found. It is longer (18 hours) to find a
strategy that wins <strong>as fast as possible</strong>, because this requires us to explore the
full tree. To speed things up, we use a form of <strong><a href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">alpha-beta
pruning</a></strong>: when trying
to put a piece, when we have found a winning option, we consider other options
but only exploring them up to a depth that would give a strictly shorter
strategy than the currently known best option. This lowers the running time to
10 hours and lowers the number of explored states from 2 billion states to around
750 million states, of which 9 million are winning. The resulting program is
<a href="https://vishnubharathi.codes/git/tetrisolve/file/bruteforce.cpp.html">here</a>. (Sorry, it is not very
clean...)</p>
<p>Once the program has produced a strategy, we need to &#34;compress&#34; it. To do so, we
first &#34;trim&#34; it by <strong>removing unreachable board states</strong>: we go from 9 million
states to just 21 thousand states: this is done <a href="https://vishnubharathi.codes/git/tetrisolve/file/make_graph.cpp.html">here</a>. Then we <a href="https://en.wikipedia.org/wiki/DFA_minimization">minimize
it</a> by
<strong>merging states from which the strategy is the same</strong>: this is done
<a href="https://vishnubharathi.codes/git/tetrisolve/file/minify_graph.py.html">here</a>. As the DAG is acyclic, we can
perform this in linear time simply by processing the DAG
bottom-up and hashing configurations. We get to the 5250 states of the strategy
file.</p>
<h2>Other possible optimizations</h2>
<p>The following optimizations would have been possible, but I did not implement
them:</p>
<ul>
<li>There be an easy saving of a factor 2 by <strong>breaking the left-right symmetry</strong>,
  which would also probably make the winning strategy more concise (but it is
  less convenient to reconstruct it).</li>
<li>When checking the cache of possible board states, we could check <strong>&#34;shifted&#34;
  configurations</strong> where we remove any one of the lowest <span><span id="MathJax-Element-26-Frame"><span id="MJXc-Node-144" role="math"><span id="MJXc-Node-145"><span id="MJXc-Node-146"><span>d</span></span></span></span></span></span> lines, provided each
  column has a height of at least <span><span id="MathJax-Element-27-Frame"><span id="MJXc-Node-147" role="math"><span id="MJXc-Node-148"><span id="MJXc-Node-149"><span>d</span></span></span></span></span></span>. We could also check configurations with a
  subset, or superset, of sacrificed rows: if a configuration with identical column
  heights and with a subset of
  sacrificed rows is known to be losing then the current configuration also is, and if a
  configuration with identical column heights and a superset of sacrificed rows
  is known to be winning then the current configuration also is.</li>
<li>Rather than exploring all possibilities to the maximal depth before giving up,
  a better solution is to use <strong><a href="https://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search">iterative
  deepening</a></strong>.
  I did this in an earlier version of the code that followed a different approach. Likewise, ordering the possible moves with a piece using some heuristic (e.g., putting the piece as low as possible, or sacrificing as little new lines as possible) would possibly make the search faster (thanks to alpha-beta pruning).</li>
</ul>
<h2>Related work</h2>
<p>For the related question of whether the player can <em>win</em> at Tetris, i.e., play
indefinitely, it is known that this is not the case. The computer can force the
player to lose, even with a strategy which is oblivious to how the human plays
and alternates S-shaped and Z-shaped pieces: see Burgiel&#39;s 1997 paper <a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.55.8562&amp;rep=rep1&amp;type=pdf">&#34;How to Lose
at Tetris&#34;</a>
or <a href="https://harddrop.com/wiki/A_deadly_piece_sequence">this page</a>. This does not
contradict the result presented here, which says we can clear a line (but
eventually lose). Optimizing the number of lines cleared (in the worse case or
in expectation) vs guaranteeing that you make one line are different goals, that
may be at odds with each other.</p>
<p>On the other hand, with stronger assumptions on how the computer can propose
pieces, it is possible to play forever: see <a href="https://harddrop.com/wiki/Playing_forever">this page</a>.</p>
<p>There are other results of this kind in Brzustowski&#39;s 1992 master thesis <a href="https://open.library.ubc.ca/soa/cIRcle/collections/ubctheses/831/items/1.0079748">Can you win
at Tetris?</a>.</p>
<p>There is <a href="https://arxiv.org/abs/cs/0210020">a 2002 study</a> by Demaine et al. of the
computational complexity of Tetris play, which does not seem related to the
results here. For more related work on Tetris, there is a great literature
review in <a href="https://arxiv.org/pdf/2202.10771.pdf">this FUN&#39;2022 paper by Dallant and
Iacono</a>.</p>
<p>There are many Tetris implementations that try to give the worst possible pieces to the
player: at least <a href="https://qntm.org/files/hatetris/hatetris.html">Hatetris</a> and
<a href="https://tetris.fandom.com/wiki/Bastard_Tetris">bastet</a>.</p>
<p>The most relevant study of Tetris to what I present here seems to be the study of &#34;adversarial Tetris&#34;,
introduced at a reinforcement learning competition in 2009 (see
<a href="https://www.springerprofessional.de/en/minimax-search-and-reinforcement-learning-for-adversarial-tetris/3287482">here</a>),
and followup, e.g.,
<a href="https://medium.com/@amoghhgoma/beatris-an-evil-tetris-ai-88fee6b068">Beatris</a>.
However, I wasn&#39;t able to find works there which considered the question of
whether the human could guarantee that they score at least one line assuming perfect play.</p>
<h2>Open problems</h2>
<p>I do not know what is the minimal number of rows and/or maximal necessary height
to score a line <strong>if the human can slide or rotate pieces</strong>
as they fall; the latter would depend on the exact rules implemented for
rotation which is somewhat unpleasant (similar subtleties are considered in
Demaine et al.&#39;s paper).</p>
<p>I do not know what happens for a <strong>different number of columns</strong>. Odd number of
columns clearly allow the computer to win by giving only square tetrominoes, and
two columns clearly allow the human to win (every piece can score a line by itself in every
configuration except I-tetrominoes where this can be achieved in two moves). Of
course one can generalize the problem to different polyomino sets, etc.</p>
<p>I do not know if the human can guarantee <strong>scoring multiple lines at once</strong>: if
the computer only gives O-shaped blocks then the human cannot hope to score
three or four lines at once<sup id="fnref:adversarial_tetris_ted"><a href="#fn:adversarial_tetris_ted">4</a></sup>; I don&#39;t know if guaranteeing that you can score two
lines at once is possible.</p>
<p>I do not know if the result implies that the human can score <strong>any
arbitrary number of lines</strong> provided that the board is sufficiently high. The
strategy I presented does not ensure this, because it only works from the empty
board; it could be the case (although unlikely) that the board states reached
after scoring one line in this strategy no longer themselves have a winning
strategy (no matter the height). More generally, one can ask what is the behavior of the function that
maps the number of rows of the board to the number of lines that can be
guaranteed by the player.</p>

  </div></div>
  </body>
</html>
