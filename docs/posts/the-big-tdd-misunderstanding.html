<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://linkedrecords.com/the-big-tdd-misunderstanding-8e22c2f1fc21?gi=ad2ecbd53ba3">Original</a>
    <h1>The Big TDD Misunderstanding</h1>
    
    <div id="readability-page-1" class="page"><section><div><div><p id="54c7"><strong>üí°Originally the unit in ‚Äúunit test‚Äù did not refer to the system under test but the test itself. Meaning the test can be executed as one unit and does not depend on other tests to run upfront (see </strong><a href="https://tanzu.vmware.com/content/blog/what-is-a-unit-test-the-answer-might-surprise-you" rel="noopener ugc nofollow" target="_blank"><strong>here</strong></a>, <strong>here</strong> <strong>and </strong><a href="https://www.youtube.com/watch?v=HNjlJpuA5kQ" rel="noopener ugc nofollow" target="_blank"><strong>here</strong></a><strong>).</strong></p><p id="4c49">When people started to think of the unit as the system under test the quality of the tests suites went pretty bad. You change a little thing in your code and the only thing the tests suite tells you is that you will be busy the rest of the day fixing false positives.</p><p id="f27c">There are two main styles when it comes to testing: mockist vs classicist. Here are my personal tips on how to write good tests mostly <strong>inspired</strong> by the classicist style.</p><p id="99ce"><strong>Rule #1</strong>: Write the tests from outside in. Originally the test pyramid forbids a lot of end-to-end and integration tests. Instead the pyramid says we should write a lot of unit tests. This often leads to an inside out approach testing the structure of the system rather its behaviour. Challenge the traditional testing pyramid and think how much, end-to-end, integration and unit tests make sense in your context. Also consider more recent alternatives to the test pyramid: ‚Äú<a href="https://www.oreilly.com/library/view/hands-on-microservices/9781789133608/7c9f1260-b0c5-4416-816f-1cad140b56dd.xhtml" rel="noopener ugc nofollow" target="_blank">Honeycomb</a>‚Äù and ‚Äú<a href="https://twitter.com/kentcdodds/status/960723172591992832" rel="noopener ugc nofollow" target="_blank">The Testing Trophy</a>‚Äù.</p><p id="7af0"><strong>Rule #2</strong>: Do not isolate code when you test it. If you do so, the tests become fragile and do not help you in case you refactor the software.</p><p id="0854"><strong>Rule #3</strong>: Only use mocks for truly external systems (e.g. mail service). The database should be part of the tests. Do not stub it.</p><p id="37e5"><strong>Rule #4</strong>: Never change your code without having a red test. This is pretty common practice in TDD. This has two benefits: 1) it is the tests of the tests itself. When it is red, you know it works. 2) it makes sure you have a high test coverage. This of course does not apply when you refactor your code.</p></div></div></section></div>
  </body>
</html>
