<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.nilenso.com/blog/2025/09/15/ai-unit-of-work/">Original</a>
    <h1>The quality of AI-assisted software depends on unit of work management</h1>
    
    <div id="readability-page-1" class="page"><div><p>The craft of AI-assisted software creation is substantially about correctly managing units of work.</p>

<p>When I was new to this emerging craft of AI-assisted coding, I was getting lousy results, despite the models being rather intelligent. Turns out the major bottleneck is not intelligence, but rather providing the correct context.</p>

<p>Andrej Karpathy, <a href="https://youtube.com/clip/Ugkx7m0MVzHTnKXdoDjlqei60zlK4DWCXWr2?si=kIwnm0xQXdSKMQCC">while referencing</a> my <a href="https://blog.nilenso.com/blog/2025/05/29/ai-assisted-coding/">earlier article on this topic</a>, described the work of AI-assisted engineering as “putting AI on a tight leash”. What does a tight leash look like for a process where AI agents are operating on your code more independently than ever? He dropped a hint: work on small chunks of a single concrete thing.</p>

<h2 id="the-right-sized-unit-of-work-respects-the-context">The right sized unit of work respects the context</h2>

<p>I like the term <a href="https://simonwillison.net/2023/Jan/23/riley-goodside/">context engineering</a>, because it has opened up the vocabulary to better describe why managing units of work is perhaps the most important technique to get better results out of AI tools. It centers our discussion around the “canvas” against which our AI is generating code.</p>

<p>I like <a href="https://blog.nilenso.com/blog/2025/09/15/ai-unit-of-work/docs.anthropic.com/en/docs/build-with-claude/context-windows">Anthropic’s visualisation</a> from their docs:</p>

<p><img src="https://blog.nilenso.com/images/blog/context-window-thinking-tools.jpg" alt="Anthropic&#39;s visualisation of a context window filling up for each turn until it exceeds the window limit"/></p>

<p>The generated output of the LLM is a sample of the next token probability. Every time we generate a token, what has already been generated in the previous iteration is appended to the context window. What this context window looks like has a huge influence on the quality of your generated output.</p>

<p><a href="https://www.dbreunig.com/2025/06/26/how-to-fix-your-context.html">Drew Breunig wrote an excellent article</a> about all kinds of things that can go wrong with your context and proposed various techniques to fix them.</p>

<p>The best AI-assisted craftsmen are often thinking about the design and arrangement of their context to get the AI to one-shot a solution. This is tricky and effortful, contrary to what the AI coding hype suggests.</p>

<p>If you don’t provide the necessary information in the context to do a good job, your AI will hallucinate or generate code that is not congruent with the practices of your codebase. It is especially brittle at integration points of your software system.</p>

<p>On the other hand, if you fill up the context with too much information, and <a href="https://research.trychroma.com/context-rot">the quality of your output degrades</a>, because of a lack of focused attention.</p>

<p>Breaking down your task into “right-sized” units of work, which describe just the right amount of detail is perhaps the most powerful lever to improve your context window, and thus the correctness and quality of the generated code.</p>

<h2 id="the-right-sized-unit-of-work-controls-the-propagation-of-errors">The right sized unit of work controls the propagation of errors</h2>

<p>Time for some napkin maths.</p>

<p>Let’s say your AI agent has a 5% chance of making a mistake. I’m not just referring to hallucinations—it could be a subtle mistake because it forgot to look up some documentation or you missed a detail in your specification.</p>

<p>In an agentic multi-turn workflow, which is what all coding workflows are converging to, this error compounds. If your task takes 10 turns to implement, you will have a (1 – 0.95)<sup>10</sup> = 59.9% chance of success. Not very high.</p>

<p><a href="https://utkarshkanwat.com/writing/betting-against-agents">Utkarsh Kanwat in his blog post</a> has made the same argument. His conclusion was that any AI agent would need some kind of pause-and-verify gating mechanism at each step for a long-horizon task.</p>

<table>
  <thead>
    <tr>
      <th rowspan="2">Per-action</th>
      <th colspan="4">Overall Success Rate</th>
    </tr>
    <tr>
      <th>5 turns</th>
      <th>10 turns</th>
      <th>20 turns</th>
      <th>50 turns</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>0.1%</td><td>99.5%</td><td>99.0%</td><td>98.0%</td><td>95.1%</td></tr>
    <tr><td>1%</td><td>95.1%</td><td>90.4%</td><td>81.8%</td><td>60.5%</td></tr>
    <tr><td>5%</td><td>77.4%</td><td>59.9%</td><td>35.8%</td><td>7.7%</td></tr>
    <tr><td>10%</td><td>59.0%</td><td>34.9%</td><td>12.2%</td><td>0.5%</td></tr>
    <tr><td>20%</td><td>32.8%</td><td>10.7%</td><td>1.2%</td><td>0.0%</td></tr>
  </tbody>
</table>

<p>What does the state of the art for multi-turn error rates look like? METR recently published a popular chart <a href="https://metr.org/blog/2025-07-14-how-does-time-horizon-vary-across-domains/">describing how AI models are getting better at long-horizon tasks</a>. Currently GPT-5 is at the top of the leaderboard, where it can perform ~2-hour long tasks at around a 70% success rate. Working backwards (let’s say a 2 hour task is 50+ turns) this would amount to a sub-1% error rate per action.</p>

<p><img src="https://blog.nilenso.com/images/blog/metr.png" alt="Chart showing results of METR&#39;s chart showing task horizons increasing over time"/></p>

<p>Doesn’t a &lt;1% error rate per action seem suspicious to you? As a regular user of agentic coding tools (my current one is Codex CLI), I’ll eat my shoe if GPT-5 starts nailing my tasks 99.9% of the time.</p>

<p>My intuition derived from experience tells me that even the best AI right now isn’t even 95% likely to be correct. So where is the difference coming from? It needs a closer look at the actual paper:</p>

<blockquote>
  <p>Our tasks typically use environments that do not significantly change unless directly acted upon by the agent. In contrast, real tasks often occur in the context of a changing environment.</p>

  <p>[…]</p>

  <p>Similarly, very few of our tasks are punishing of single mistakes. This is in part to reduce the expected cost of collecting human baselines.</p>
</blockquote>

<p>This is not at all like the tasks I am doing.</p>

<p>METR acknowledges the messiness of the real world. They have come up with a “messiness rating” for their tasks, and the “mean messiness” of their tasks is 3.2/16.</p>

<p>By METR’s definitions, the kind of software engineering work that I’m mostly exposed to would score at least around 7-8, given that software engineering projects are path-dependent, dynamic and without clear counterfactuals. I have worked on problems that get to around 13/16 levels of messiness.</p>

<blockquote>
  <p>An increase in task messiness by 1 point reduces mean success rates by roughly 8.1%</p>
</blockquote>

<p>Extrapolating from METR’s measured effect of messiness, GPT-5 would go from 70% to around 40% success rate for 2-hour tasks. This maps to my experienced reality.</p>

<p>I am not certain that pure intelligence can solve for messiness. Robustness to environmental chaos and the fuzzy nature of reality is fundamentally about managing context well. Until we find the magic sauce that solves this, it is clear that we need a workflow that can break down our problem into units of work, with verifiable checkpoints to manage the compounding of errors.</p>

<p>These verifiable checkpoints need to be <em>legible to humans</em>.</p>

<p><img src="https://blog.nilenso.com/images/blog/unit-of-work-management.jpg" alt="A diagram of boxes that represent units of work, with circles that represent checkpoints where users can verify outcomes and make corrections"/></p>

<h2 id="so-what-is-the-right-sized-unit-of-work">So, what is the “right sized” unit of work?</h2>

<p>The right sized unit of work needs to be small and describe the desired outcome concisely.</p>

<p>The desired outcome on completion of a unit of work needs to be human-legible. I argue that it needs to provide legible <em>business value</em>. Ultimately, the users of software are going to be humans (or systems that model human constructs). Therefore, an elegant way to break down a project is to model it as small units of work that provide legible business value at each checkpoint. This will serve the purpose of respecting the context window of the LLM and help manage the propagation of errors.</p>

<p>Software engineers have already defined a unit of work that provides business value and serve as the placeholder for all the context and negotiation of scope—User Stories. I think they are a good starting point to help us break down a large problem into smaller problems that an LLM can one-shot, while providing a concrete result. They center <em>user outcomes</em>, which unlike “tasks”, are robust to the messy dynamic environment of software development.</p>

<p>Deliverable business value is also what all stakeholders can understand and work with. Software is not built in a vacuum by developers—it needs the coordination of teams, product owners, business people and users. The fact that AI agents work in their own context environment separate from the other stakeholders hurts effectiveness and transfer of its benefits. I think this is an important gap that needs to be bridged.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>unit size</th>
      <th>outcome of completion</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TODO item</td>
      <td>small</td>
      <td>incremental technical value</td>
    </tr>
    <tr>
      <td>“Plan Mode”</td>
      <td>large</td>
      <td>technical value</td>
    </tr>
    <tr>
      <td>Amazon Kiro Spec</td>
      <td>small</td>
      <td>technical value</td>
    </tr>
    <tr>
      <td>User Story</td>
      <td>small</td>
      <td>business value</td>
    </tr>
  </tbody>
</table>

<p>Most AI agents today have well-functioning “planning” modes. These are good at keeping the agent on rails, but they mostly provide technical value, and not necessarily a legible business outcome. I believe planning is complementary to our idea of breaking down a project into small units of business value. My proposed unit of work can be planned with existing planning tools. And I believe this is superior to planning over a large unit of work due to the context rot issues described earlier.</p>

<p>Of course, plain old User Stories as described in the Agile canon is not sufficient. It needs to be accompanied by “something more” that can nudge the agents to gather the right context that serves the business value outcome of the stories. What that “something more” could look like is something we hope to answer in the coming months.</p>

<h2 id="the-storymachine-experiment">The StoryMachine experiment</h2>

<p>To test whether user stories with “something more” can indeed serve as optimal units of work that that have the properties I described above, we are running an experiment called <a href="https://github.com/nilenso/storymachine">StoryMachine</a>. Currently StoryMachine does not do much—it reads your PRD and Tech Specs and produces story cards. It is still early days. But we will set up an evaluation system that will help us iterate to a unit of work description that helps us build useful software effortlessly. I hope to share updates on what we find in the coming months.</p>

<p>I want the craft of AI-assisted development to be less effortful and less like a slot-machine. And our best lever to get there is managing the unit of work.</p>
</div></div>
  </body>
</html>
