<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.panasiti.me/blog/modular-rails-applications-rails-engines-active-storage-dashboard/">Original</a>
    <h1>Building Modular Rails Applications: A Deep Dive into Rails Engines</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>I’ve been building Rails applications for the last 10 years on a daily base and almost all of them use active storage now. Users are uploading files and then the questions start rolling in from the team and they are always the same:</p>

<p><em>“How much storage are we actually using?”</em>
<em>“Can we see which files aren’t attached to anything anymore?”</em>
<em>“What types of files are users uploading the most?”</em>
<em>“Is there a way to browse through all our stored files?”</em></p>

<p>I usually open the Rails console, write a few queries, and get the answers for the team or for the stakeholders. But you know this isn’t sustainable. What I need is a proper dashboard, something visual, something that non-technical team members can use, something that doesn’t require SSH access to production servers.</p>

<p>This is exactly the problem I faced, and it led me down a fascinating journey into the world of Rails engines, ultimately resulting in the creation of Active Storage Dashboard, a mountable Rails engine that provides a modern interface for monitoring and managing Active Storage data. Always the same screen for every app, over and over. Easy to mount and easy to use.</p>

<h2 id="introducing-active-storage-dashboard">Introducing Active Storage Dashboard</h2>

<p><a href="https://github.com/giovapanasiti/active_storage_dashboard">Active Storage Dashboard</a> is more than just a simple admin interface. It’s a fully-featured Rails engine that seamlessly integrates into any Rails application, providing immediate visibility into your file storage ecosystem. With zero external dependencies (pure vanilla JavaScript and CSS), it offers a beautiful, animated interface that feels natural in modern web applications.</p>

<p>The gem provides comprehensive insights including:</p>
<ul>
  <li>Real-time storage statistics and usage metrics</li>
  <li>Browsable interfaces for blobs, attachments, and variant records</li>
  <li>Advanced filtering capabilities for finding specific files</li>
  <li>Direct download functionality from the dashboard</li>
  <li>Maintenance tasks for cleaning up orphaned files</li>
  <li>Support for both table and card view layouts</li>
  <li>Beautiful visualizations of content type distributions</li>
</ul>

<p>Active Storage Dashboard is a <strong>Rails engine</strong>, and understanding Rails engines opens up a whole new world of possibilities for Ruby developers so I used this experience to share my journey and to invite you to do the same and try to use engines more often.</p>

<h2 id="rails-engines-the-heroes-of-modular-design">Rails Engines: The Heroes of Modular Design</h2>

<p>Rails engines are perhaps one of the most powerful yet underutilized features of the Ruby on Rails framework. At their core, engines are miniature Rails applications that can be mounted inside a host Rails application. They can come complete with their own models, views, controllers, routes, and assets—essentially everything a Rails app has, but designed to be pluggable and reusable.</p>

<p>Think of Rails engines as the Ruby equivalent of microservices, but without the operational complexity. They allow you to build self-contained features that can be shared across multiple applications or extracted from existing monoliths when certain functionalities become too complex or need to be reused.</p>

<h3 id="the-anatomy-of-a-rails-engine">The Anatomy of a Rails Engine</h3>

<p>Looking at the Active Storage Dashboard’s directory structure reveals the beautiful symmetry between engines and regular Rails applications:</p>

<div><div><pre><code>app/
├── controllers/
├── helpers/
└── views/
config/
├── routes.rb
lib/
├── active_storage_dashboard.rb
├── active_storage_dashboard/
│   ├── engine.rb
│   └── version.rb
</code></pre></div></div>

<p>This structure should feel immediately familiar to any Rails developer. The <code>app</code> directory contains the MVC components, <code>config</code> holds the routes, and <code>lib</code> contains the engine’s core logic. The key difference is the presence of the <code>engine.rb</code> file, which is where the magic happens.</p>

<h3 id="the-engine-class-where-configuration-meets-convention">The Engine Class: Where Configuration Meets Convention</h3>

<p>Let’s examine the heart of any Rails engine: the <strong>engine class</strong> itself.</p>

<div><div><pre><code><span>module</span> <span>ActiveStorageDashboard</span>
  <span>class</span> <span>Engine</span> <span>&lt;</span> <span>::</span><span>Rails</span><span>::</span><span>Engine</span>
    <span>isolate_namespace</span> <span>ActiveStorageDashboard</span>

    <span>initializer</span> <span>&#34;active_storage_dashboard.url_options&#34;</span> <span>do</span> <span>|</span><span>app</span><span>|</span>
      <span>ActiveStorageDashboard</span><span>::</span><span>Engine</span><span>.</span><span>routes</span><span>.</span><span>default_url_options</span> <span>=</span> 
        <span>app</span><span>.</span><span>routes</span><span>.</span><span>default_url_options</span>
    <span>end</span>

    <span>config</span><span>.</span><span>active_storage_dashboard</span> <span>=</span> <span>ActiveSupport</span><span>::</span><span>OrderedOptions</span><span>.</span><span>new</span>

    <span>config</span><span>.</span><span>before_initialize</span> <span>do</span>
      <span>config</span><span>.</span><span>active_storage_dashboard</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>key</span><span>,</span> <span>value</span><span>|</span>
        <span>ActiveStorageDashboard</span><span>.</span><span>public_send</span><span>(</span><span>&#34;</span><span>#{</span><span>key</span><span>}</span><span>=&#34;</span><span>,</span> <span>value</span><span>)</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>The <code>isolate_namespace</code> directive is crucial to ensures that all of the engine’s components (models, controllers, helpers) are namespaced, preventing naming conflicts with the host application. This isolation is what allows engines to be truly modular and reusable.</p>

<h2 id="building-a-production-ready-engine-lessons-learned-from-active-storage-dashboard">Building a Production-Ready Engine: Lessons learned from Active Storage Dashboard</h2>

<p>Creating a Rails engine that’s both powerful and easy to use requires careful attention to several key areas. Let me walk you through the design decisions and implementation details that make Active Storage Dashboard a joy to integrate and use (or at least I hope so).</p>

<h3 id="1-routing-and-url-generation">1. Routing and URL Generation</h3>

<p>One of the trickiest aspects of building engines is handling routing correctly. Active Storage Dashboard uses a sophisticated approach to ensure URLs are generated properly regardless of where the engine is mounted:</p>

<div><div><pre><code><span># In routes.rb</span>
<span>ActiveStorageDashboard</span><span>::</span><span>Engine</span><span>.</span><span>routes</span><span>.</span><span>draw</span> <span>do</span>
  <span>root</span> <span>to: </span><span>&#39;dashboard#index&#39;</span>
  
  <span>resources</span> <span>:blobs</span><span>,</span> <span>only: </span><span>[</span><span>:index</span><span>,</span> <span>:show</span><span>]</span> <span>do</span>
    <span>member</span> <span>do</span>
      <span>get</span> <span>&#39;download(/:disposition)&#39;</span><span>,</span> <span>action: :download</span><span>,</span> <span>as: :download</span>
    <span>end</span>
  <span>end</span>
  
  <span>resources</span> <span>:attachments</span><span>,</span> <span>only: </span><span>[</span><span>:index</span><span>,</span> <span>:show</span><span>]</span> <span>do</span>
    <span>member</span> <span>do</span>
      <span>get</span> <span>&#39;download(/:disposition)&#39;</span><span>,</span> <span>action: :download</span><span>,</span> <span>as: :download</span>
    <span>end</span>
  <span>end</span>
  
  <span>resources</span> <span>:variant_records</span><span>,</span> <span>only: </span><span>[</span><span>:index</span><span>,</span> <span>:show</span><span>]</span>
<span>end</span>
</code></pre></div></div>

<p>Notice the optional disposition parameter in the download routes. This allows for flexible file handling—files can be downloaded as attachments or displayed inline in the browser.</p>

<h3 id="2-configuration-flexibility-and-authentication-strategies">2. Configuration Flexibility and Authentication Strategies</h3>

<p>A well-designed engine should be configurable without being complicated, and security is often the first concern when integrating admin tools. Active Storage Dashboard provides multiple authentication strategies, allowing developers to choose the approach that best fits their application’s existing security infrastructure.</p>

<h4 id="controller-based-authentication">Controller-Based Authentication</h4>

<p>The engine allows host applications to customize the base controller class, enabling seamless integration with existing authentication systems:</p>

<div><div><pre><code><span>module</span> <span>ActiveStorageDashboard</span>
  <span>mattr_accessor</span> <span>:base_controller_class</span><span>,</span> <span>default: </span><span>&#34;ActionController::Base&#34;</span>
<span>end</span>
</code></pre></div></div>

<p>This approach means that if your application already has an <code>AdminController</code> with authentication filters, you can simply configure the engine to inherit from it:</p>

<div><div><pre><code><span># In config/application.rb or config/environments/production.rb</span>
<span>config</span><span>.</span><span>active_storage_dashboard</span><span>.</span><span>base_controller_class</span> <span>=</span> <span>&#34;AdminController&#34;</span>
</code></pre></div></div>

<p>This pattern is particularly powerful because it automatically inherits all the authentication logic, authorization rules, and even layout configurations from your existing admin infrastructure. Your <code>AdminController</code> might look something like:</p>

<div><div><pre><code><span>class</span> <span>AdminController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span>before_action</span> <span>:authenticate_admin!</span>
  <span>before_action</span> <span>:set_admin_timezone</span>
  <span>layout</span> <span>&#39;admin&#39;</span>
  
  <span>private</span>
  
  <span>def</span> <span>authenticate_admin!</span>
    <span>redirect_to</span> <span>login_path</span> <span>unless</span> <span>current_user</span><span>&amp;</span><span>.</span><span>admin?</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>By setting this as the base controller, every Active Storage Dashboard controller automatically requires admin authentication without any additional configuration.</p>

<h4 id="route-level-authentication-constraints">Route-Level Authentication Constraints</h4>

<p>For applications that prefer to handle authentication at the routing layer, Active Storage Dashboard works seamlessly with Rails route constraints. This approach is often cleaner and more explicit:</p>

<div><div><pre><code><span># config/routes.rb</span>
<span>authenticate</span> <span>:user</span><span>,</span> <span>-&gt;</span> <span>(</span><span>user</span><span>)</span> <span>{</span> <span>user</span><span>.</span><span>admin?</span> <span>}</span> <span>do</span>
  <span>mount</span> <span>ActiveStorageDashboard</span><span>::</span><span>Engine</span><span>,</span> <span>at: </span><span>&#34;/active-storage-dashboard&#34;</span>
<span>end</span>
</code></pre></div></div>

<p>For Devise users, the integration is even more sophisticated. You can use complex constraints that check both session and warden authentication:</p>

<div><div><pre><code><span># config/routes.rb</span>
<span>constraints</span> <span>lambda</span> <span>{</span> <span>|</span><span>req</span><span>|</span> 
  <span>req</span><span>.</span><span>session</span><span>[</span><span>:user_id</span><span>].</span><span>present?</span> <span>||</span> 
  <span>(</span><span>req</span><span>.</span><span>env</span><span>[</span><span>&#39;warden&#39;</span><span>]</span> <span>&amp;&amp;</span> <span>req</span><span>.</span><span>env</span><span>[</span><span>&#39;warden&#39;</span><span>].</span><span>user</span><span>(</span><span>:user</span><span>))</span> 
<span>}</span> <span>do</span>
  <span>mount</span> <span>ActiveStorageDashboard</span><span>::</span><span>Engine</span><span>,</span> <span>at: </span><span>&#34;/active-storage-dashboard&#34;</span>
<span>end</span>
</code></pre></div></div>

<h3 id="3-cross-rails-version-compatibility">3. Cross-Rails Version Compatibility</h3>

<p>One of the biggest challenges in building Rails engines is maintaining compatibility across different Rails versions. Active Storage Dashboard handles this gracefully, detecting features available in different Rails versions and adapting accordingly:</p>

<div><div><pre><code><span>if</span> <span>defined?</span><span>(</span><span>ActiveStorage</span><span>::</span><span>VariantRecord</span><span>)</span>
  <span>@variant_records</span> <span>=</span> <span>paginate</span><span>(</span><span>ActiveStorage</span><span>::</span><span>VariantRecord</span><span>.</span><span>order</span><span>(</span><span>id: :desc</span><span>))</span>
<span>else</span>
  <span>@variant_records</span> <span>=</span> <span>[]</span>
<span>end</span>
</code></pre></div></div>

<p>This approach ensures the engine works seamlessly from Rails 5.2 all the way to Rails 8.x, degrading gracefully when newer features aren’t available.</p>

<h3 id="4-zero-external-dependencies-philosophy">4. Zero External Dependencies Philosophy</h3>

<p>In an ecosystem often plagued by dependency hell, Active Storage Dashboard takes a radical approach: zero external dependencies. The entire UI is built with vanilla JavaScript and CSS, featuring smooth animations, responsive layouts, and modern design patterns—all without requiring jQuery, Bootstrap, or any other framework.</p>

<p>This decision pays dividends in several ways:</p>
<ul>
  <li>Faster load times</li>
  <li>No version conflicts with host applications</li>
  <li>Easier maintenance and debugging</li>
  <li>Better long-term stability</li>
</ul>

<h3 id="5-database-agnostic-implementation">5. Database-Agnostic Implementation</h3>

<p>The engine’s statistics and querying features are carefully designed to work across different database adapters. Here’s how the dashboard handles timeline data generation across SQLite, MySQL, and PostgreSQL:</p>

<div><div><pre><code><span>def</span> <span>adapter_specific_timeline_data</span>
  <span>adapter</span> <span>=</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection</span><span>.</span><span>adapter_name</span><span>.</span><span>downcase</span>
  
  <span>if</span> <span>adapter</span><span>.</span><span>include?</span><span>(</span><span>&#39;sqlite&#39;</span><span>)</span>
    <span>result</span> <span>=</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection</span><span>.</span><span>execute</span><span>(</span>
      <span>&#34;SELECT strftime(&#39;%Y-%m&#39;, created_at) as month, COUNT(*) as count &#34;</span> <span>+</span>
      <span>&#34;FROM </span><span>#{</span><span>table_name</span><span>}</span><span> GROUP BY strftime(&#39;%Y-%m&#39;, created_at)&#34;</span>
    <span>)</span>
  <span>elsif</span> <span>adapter</span><span>.</span><span>include?</span><span>(</span><span>&#39;mysql&#39;</span><span>)</span>
    <span>result</span> <span>=</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection</span><span>.</span><span>execute</span><span>(</span>
      <span>&#34;SELECT DATE_FORMAT(created_at, &#39;%Y-%m&#39;) as month, COUNT(*) as count &#34;</span> <span>+</span>
      <span>&#34;FROM </span><span>#{</span><span>table_name</span><span>}</span><span> GROUP BY DATE_FORMAT(created_at, &#39;%Y-%m&#39;)&#34;</span>
    <span>)</span>
  <span>else</span> <span># PostgreSQL</span>
    <span>result</span> <span>=</span> <span>ActiveRecord</span><span>::</span><span>Base</span><span>.</span><span>connection</span><span>.</span><span>execute</span><span>(</span>
      <span>&#34;SELECT TO_CHAR(created_at, &#39;YYYY-MM&#39;) as month, COUNT(*) as count &#34;</span> <span>+</span>
      <span>&#34;FROM </span><span>#{</span><span>table_name</span><span>}</span><span> GROUP BY TO_CHAR(created_at, &#39;YYYY-MM&#39;)&#34;</span>
    <span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>



<p>Rather than depending on gems like Kaminari or WillPaginate, the engine implements its own lightweight pagination:</p>

<div><div><pre><code><span>def</span> <span>paginate</span><span>(</span><span>scope</span><span>,</span> <span>per_page</span> <span>=</span> <span>20</span><span>)</span>
  <span>@page</span> <span>=</span> <span>[</span><span>params</span><span>[</span><span>:page</span><span>].</span><span>to_i</span><span>,</span> <span>1</span><span>].</span><span>max</span>
  <span>scope</span><span>.</span><span>limit</span><span>(</span><span>per_page</span><span>).</span><span>offset</span><span>((</span><span>@page</span> <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>per_page</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<p>This approach keeps the engine lightweight while providing all the pagination features users need.</p>

<h3 id="smart-file-preview-handling">Smart File Preview Handling</h3>

<p>The engine intelligently handles file previews based on content type and Rails version capabilities:</p>

<div><div><pre><code><span>def</span> <span>previewable_blob?</span><span>(</span><span>blob</span><span>)</span>
  <span>return</span> <span>false</span> <span>unless</span> <span>blob</span><span>.</span><span>present?</span>
  
  <span>content_type</span> <span>=</span> <span>blob</span><span>.</span><span>content_type</span>
  <span>image_types</span> <span>=</span> <span>[</span><span>&#39;image/jpeg&#39;</span><span>,</span> <span>&#39;image/png&#39;</span><span>,</span> <span>&#39;image/gif&#39;</span><span>,</span> <span>&#39;image/webp&#39;</span><span>]</span>
  <span>return</span> <span>true</span> <span>if</span> <span>image_types</span><span>.</span><span>include?</span><span>(</span><span>content_type</span><span>)</span>
  
  <span>if</span> <span>defined?</span><span>(</span><span>ActiveStorage</span><span>::</span><span>Blob</span><span>.</span><span>new</span><span>.</span><span>preview</span><span>)</span> <span>&amp;&amp;</span> 
     <span>blob</span><span>.</span><span>respond_to?</span><span>(</span><span>:previewable?</span><span>)</span> <span>&amp;&amp;</span> 
     <span>blob</span><span>.</span><span>previewable?</span>
    <span>return</span> <span>true</span>
  <span>end</span>
  
  <span>false</span>
<span>end</span>
</code></pre></div></div>

<h3 id="rake-tasks-for-maintenance">Rake Tasks for Maintenance</h3>

<p>One of the most requested feature, that wansn’t present in the first versions was the ability to purge orphan files. I found a rake task to be the most efficient way to tackle this problem since every other solution would have required to use a queue system to schedule a massive deletion. I provided powerful maintenance tasks that can be run via command line:</p>

<div><div><pre><code><span>namespace</span> <span>:active_storage</span> <span>do</span>
  <span>namespace</span> <span>:dashboard</span> <span>do</span>
    <span>desc</span> <span>&#34;Purge blobs that have no attachments&#34;</span>
    <span>task</span> <span>purge_orphans: :environment</span> <span>do</span>
      <span>ActiveStorageDashboard</span><span>::</span><span>OrphanPurger</span><span>.</span><span>call</span>
    <span>end</span>

    <span>desc</span> <span>&#34;Re-analyze blobs that are not yet analyzed&#34;</span>
    <span>task</span> <span>reanalyze: :environment</span> <span>do</span>
      <span>ActiveStorageDashboard</span><span>::</span><span>Analyzer</span><span>.</span><span>call</span>
    <span>end</span>

    <span>desc</span> <span>&#34;Recreate missing or outdated variants&#34;</span>
    <span>task</span> <span>regenerate_variants: :environment</span> <span>do</span>
      <span>ActiveStorageDashboard</span><span>::</span><span>VariantRegenerator</span><span>.</span><span>call</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>
<p>These tasks showcase how engines can provide not just UI features but also operational tools for maintaining application health.</p>

<h2 id="the-broader-impact-why-rails-engines-matter">The Broader Impact: Why Rails Engines Matter</h2>

<p>The success of gems like Active Storage Dashboard points to a larger trend in the Rails ecosystem: the need for modular, reusable components that can be easily integrated into existing applications. <strong>Rails engines</strong> fulfill this need perfectly, offering several advantages:</p>

<h3 id="1-rapid-feature-development">1. Rapid Feature Development</h3>

<p>Engines allow teams to develop features in isolation, with their own test suites and dependencies. This parallel development model can significantly speed up delivery times for complex features. We are using this pattern to build a bunch of specific-features that are shared in all our rails applications. This is basically allowing us to replace expensive microservices with engines.</p>

<h3 id="2-code-reusability-across-projects">2. Code Reusability Across Projects</h3>

<p>Once built, an engine can be used across multiple applications. Imagine building an authentication engine, a payment processing engine, or an admin dashboard engine once and reusing it across all your projects.</p>

<h3 id="3-gradual-monolith-decomposition">3. Gradual Monolith Decomposition</h3>

<p>For teams looking to break apart monolithic applications, engines provide a stepping stone. Features can be extracted into engines while still running in the same process, allowing for gradual decomposition without the operational overhead of microservices.</p>

<h3 id="4-open-source-contribution-opportunities">4. Open Source Contribution Opportunities</h3>

<p>Engines make it easier to extract and share functionality with the community. A feature that starts as an internal tool can be polished and released as an open-source engine, benefiting the entire Rails ecosystem. This is the case of active_storage_dashboard</p>

<h2 id="best-practices-for-engine-development-i-learned">Best Practices for Engine Development I Learned</h2>

<p>Based on my experience building Active Storage Dashboard and studying other successful engines, here are key best practices for engine development:</p>

<h3 id="1-namespace-everything">1. Namespace Everything</h3>

<p>Always use <code>isolate_namespace</code> and ensure all your classes, modules, and database tables are properly namespaced. This prevents conflicts and makes your engine truly reusable.</p>

<div><div><pre><code><span>module</span> <span>ActiveStorageDashboard</span>
  <span>class</span> <span>Engine</span> <span>&lt;</span> <span>::</span><span>Rails</span><span>::</span><span>Engine</span>
    <span>isolate_namespace</span> <span>ActiveStorageDashboard</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>This isolation extends beyond just Ruby classes. Consider these namespacing strategies:</p>

<ul>
  <li><strong>Database tables</strong>: Prefix all tables with your engine name (e.g., <code>active_storage_dashboard_settings</code>)</li>
  <li><strong>CSS classes</strong>: Use a unique prefix for all styles (e.g., <code>.asd-dashboard</code>, <code>.asd-card</code>)</li>
  <li><strong>JavaScript functions</strong>: Wrap all JS in a namespaced object</li>
  <li><strong>Helper methods</strong>: Ensure helpers don’t conflict with common names</li>
  <li><strong>Route helpers</strong>: The engine’s routes are automatically namespaced</li>
</ul>

<p>Remember that even seemingly unique names can conflict. A method like <code>format_bytes</code> might exist in the host application, so I suggesto you to namespace it within its own helper module.</p>

<h3 id="2-provide-configuration-options">2. Provide Configuration Options</h3>

<p>Make your engine configurable but provide sensible defaults. <strong>Users should be able to get started quickly</strong> while having the flexibility to customize as needed.</p>

<p>Beyond basic configuration, consider these patterns:</p>

<div><div><pre><code><span>module</span> <span>ActiveStorageDashboard</span>
  <span># Class-level configuration</span>
  <span>mattr_accessor</span> <span>:base_controller_class</span><span>,</span> <span>default: </span><span>&#34;ActionController::Base&#34;</span>
  <span>mattr_accessor</span> <span>:per_page</span><span>,</span> <span>default: </span><span>20</span>
  <span>mattr_accessor</span> <span>:enable_delete</span><span>,</span> <span>default: </span><span>false</span>
  
  <span># Configuration block pattern</span>
  <span>def</span> <span>self</span><span>.</span><span>configure</span>
    <span>yield</span> <span>self</span>
  <span>end</span>
  
  <span># Configuration validation</span>
  <span>def</span> <span>self</span><span>.</span><span>validate_configuration!</span>
    <span>unless</span> <span>base_controller_class</span><span>.</span><span>constantize</span> <span>&lt;</span> <span>ActionController</span><span>::</span><span>Base</span>
      <span>raise</span> <span>ConfigurationError</span><span>,</span> <span>&#34;base_controller_class must inherit from ActionController::Base&#34;</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>This allows for elegant configuration:</p>

<div><div><pre><code><span>ActiveStorageDashboard</span><span>.</span><span>configure</span> <span>do</span> <span>|</span><span>config</span><span>|</span>
  <span>config</span><span>.</span><span>base_controller_class</span> <span>=</span> <span>&#34;AdminController&#34;</span>
  <span>config</span><span>.</span><span>per_page</span> <span>=</span> <span>50</span>
  <span>config</span><span>.</span><span>enable_delete</span> <span>=</span> <span>Rails</span><span>.</span><span>env</span><span>.</span><span>development?</span>
<span>end</span>
</code></pre></div></div>

<h3 id="3-document-thoroughly">3. Document Thoroughly</h3>

<p>Include comprehensive README documentation with clear installation instructions, configuration options, and usage examples. Consider including screenshots for UI-heavy engines.</p>

<p>Great documentation should include:</p>

<ul>
  <li><strong>Quick Start Guide</strong>: Get users running in under 5 minutes</li>
  <li><strong>Detailed Installation</strong>: Cover edge cases and troubleshooting</li>
  <li><strong>Configuration Reference</strong>: Document every option with examples</li>
  <li><strong>Screenshots/GIFs</strong>: Visual elements dramatically improve comprehension</li>
  <li><strong>Upgrade Guides</strong>: Help users migrate between versions</li>
  <li><strong>API Documentation</strong>: If your engine provides programmatic interfaces</li>
  <li><strong>Contributing Guidelines</strong>: Encourage community involvement</li>
</ul>

<h3 id="4-keep-dependencies-minimal">4. Keep Dependencies Minimal</h3>

<p>Every dependency you add is a potential source of conflicts for users. When possible, implement functionality yourself rather than pulling in additional gems.</p>

<p>Active Storage Dashboard demonstrates this principle by implementing:</p>
<ul>
  <li>Custom pagination instead of Kaminari/WillPaginate</li>
  <li>Vanilla JS instead of jQuery or Stimulus</li>
  <li>Pure CSS instead of Bootstrap or Tailwind</li>
  <li>Native Rails helpers instead of additional view libraries</li>
</ul>

<p>When you must add dependencies:</p>
<ul>
  <li>Pin to specific versions cautiously</li>
  <li>Document why each dependency is necessary</li>
  <li>Consider making optional features that require additional gems</li>
  <li>Regularly audit and update dependencies</li>
</ul>

<h3 id="5-design-for-extension">5. Design for Extension</h3>

<p>Provide hooks and extension points where users might want to customize behavior. Use Rails’ built-in patterns like concerns and callbacks to make extension natural.</p>

<div><div><pre><code><span>module</span> <span>ActiveStorageDashboard</span>
  <span>module</span> <span>Controllers</span>
    <span>module</span> <span>Blobs</span>
      <span>extend</span> <span>ActiveSupport</span><span>::</span><span>Concern</span>
      
      <span>included</span> <span>do</span>
        <span>before_action</span> <span>:set_blob</span><span>,</span> <span>only: </span><span>[</span><span>:show</span><span>,</span> <span>:download</span><span>]</span>
        <span>after_action</span> <span>:track_download</span><span>,</span> <span>only: </span><span>[</span><span>:download</span><span>]</span>
      <span>end</span>
      
      <span># Users can override these methods in their own controllers</span>
      <span>def</span> <span>blob_scope</span>
        <span>ActiveStorage</span><span>::</span><span>Blob</span><span>.</span><span>all</span>
      <span>end</span>
      
      <span>private</span>
      
      <span>def</span> <span>track_download</span>
        <span># Override this method to add download tracking</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<h3 id="6-handle-errors-gracefully">6. Handle Errors Gracefully</h3>

<p>Engines should never crash the host application. Implement robust error handling:</p>

<div><div><pre><code><span>def</span> <span>load_timeline_data</span>
  <span>begin</span>
    <span># Complex database query</span>
  <span>rescue</span> <span>ActiveRecord</span><span>::</span><span>StatementInvalid</span> <span>=&gt;</span> <span>e</span>
    <span>Rails</span><span>.</span><span>logger</span><span>.</span><span>error</span> <span>&#34;Timeline data error: </span><span>#{</span><span>e</span><span>.</span><span>message</span><span>}</span><span>&#34;</span>
    <span>@timeline_data</span> <span>=</span> <span>[]</span>
  <span>rescue</span> <span>=&gt;</span> <span>e</span>
    <span>Rails</span><span>.</span><span>logger</span><span>.</span><span>error</span> <span>&#34;Unexpected error: </span><span>#{</span><span>e</span><span>.</span><span>message</span><span>}</span><span>&#34;</span>
    <span>generate_fallback_data</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<h3 id="7-security-first">7. Security First</h3>

<p>Never trust user input and always consider security implications:</p>

<ul>
  <li>Sanitize all user inputs</li>
  <li>Use strong parameters</li>
  <li>Implement CSRF protection</li>
  <li>Validate file types and sizes</li>
  <li>Never expose internal IDs in URLs when possible</li>
  <li>Rate limit expensive operations</li>
</ul>

<h3 id="8-semantic-versioning">8. Semantic Versioning</h3>

<p>Follow semantic versioning religiously:</p>
<ul>
  <li>MAJOR: Breaking changes</li>
  <li>MINOR: New features (backward compatible)</li>
  <li>PATCH: Bug fixes</li>
</ul>

<p>Document breaking changes clearly in your CHANGELOG.</p>

<h2 id="engines-as-a-path-to-better-software-architecture">Engines as a Path to Better Software Architecture</h2>

<p>Active Storage Dashboard demonstrates that Rails engines aren’t just a nice-to-have feature. They’re a powerful tool for building maintainable and reusable solutions to common problems. By embracing engines, we can build better software architectures that are both monolithic in deployment and modular in design.</p>

<p>The journey of building this engine taught me that the Rails ecosystem still has much to offer in terms of architectural patterns and best practices. Engines provide a middle ground between monolithic applications and microservices, offering the benefits of modularity without the operational complexity.</p>

<h3 id="go-open-source-if-you-can">Go open source if you can</h3>

<p>For developers looking to level up their Rails skills, I encourage you to explore engines. Start by extracting a feature from an existing application into an engine. Build tools that solve problems you face repeatedly. Share your solutions with the community. The Rails ecosystem thrives when developers create and share modular, reusable components.</p>

<p>The next time you find yourself building a feature that could benefit other applications, whether it’s an admin dashboard, an authentication system, or a domain-specific tool, consider building it as an engine. You might just create the next essential tool that thousands of developers will thank you for.</p>

<p>Active Storage Dashboard is available on GitHub at <a href="https://github.com/giovapanasiti/active_storage_dashboard">https://github.com/giovapanasiti/active_storage_dashboard</a>, and I welcome contributions, feedback, and stories about how you’re using it in your applications. Together, we can continue to push the boundaries of what’s possible with Rails engines and create a more modular, maintainable future for Rails applications.</p>

    </div></div>
  </body>
</html>
