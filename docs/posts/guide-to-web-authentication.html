<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://webauthn.guide/">Original</a>
    <h1>Guide to Web Authentication</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
            
                <div><div><div><main><div id="intro"><div><div><p><h5>A better alternative for securing our sensitive information online</h5></p><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/illi-hero-copy.svg"/></p></div></div><div><div><p><h2>Our online existence is built on passwords.</h2></p></div><div><div><h4>Often a password is all that lies between a malicious user and our bank accounts, social media accounts, and other sensitive data.</h4><p>Passwords have an ever-growing list of problems associated with them, both for users and developers.  Users have to worry about passwords being stolen by phishing tools, or their passwords being leaked online if websites they have accounts with are compromised. They have to worry about creating and remembering passwords without dedicated password management tools. Developers have to worry about all the complications of passing passwords through systems and safely storing them in databases.</p></div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/illi-key-burden.svg"/></p></div></div><div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-10.svg"/></p></div></div></div><div><p><h2>There is a better way forward.</h2></p></div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/illi-way-forward.svg"/></p></div></div><div id="about-webauthn"><div><p><h3>Introducing Public Key Cryptography and Web Authentication (WebAuthn)</h3></p></div><div><div><h5>The Web Authentication API (also known as WebAuthn) is a <a href="https://w3c.github.io/webauthn/">specification</a> written by the <a rel="noopener" href="https://www.w3.org/" target="_blank">W3C</a> and <a rel="noopener" href="https://fidoalliance.org" target="_blank">FIDO</a>, with the participation of Google, Mozilla, Microsoft, Yubico, and others. The API allows servers to register and authenticate users using public key cryptography instead of a password. </h5><p>It allows servers to integrate with the strong authenticators now built into devices, like Windows Hello or Apple‚Äôs Touch ID. Instead of a password, a private-public keypair (known as a <b>credential</b>) is created for a website. The private key is stored securely on the user‚Äôs device; a public key and randomly generated credential ID is sent to the server for storage. The server can then use that public key to prove the user‚Äôs identity.</p><p>The public key is not secret, because it is effectively useless without the corresponding private key. The fact that the server receives no secret has far-reaching implications for the security of users and organizations. Databases are no longer as attractive to hackers, because the public keys aren‚Äôt useful to them.</p><p>WebAuthn is part of the <a rel="noopener" href="https://duo.com/blog/developments-to-webauthn-and-the-fido2-framework" target="_blank">FIDO2 framework</a>, which is a set of technologies that enable passwordless authentication between servers, browsers, and authenticators. As of January 2019, WebAuthn is supported on Chrome, Firefox, and Edge, and Safari.</p></div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/key-pair.svg"/></p><div><div><p><img src="https://webauthn.guide/dist/images/oval-5.svg" role="presentation" alt=""/></p><h5>What is Public Key Cryptography?</h5><p>Public key cryptography was invented in the 1970s, and was a solution to the problem of shared secrets. It is a pillar of modern internet security; for example, every time we connect to an HTTPS website, a public key transaction takes place.</p><p>Public key cryptography uses the concept of a keypair; a private key that is stored securely with the user, and a public key that can be shared with the server. These &#34;keys&#34; are long, random numbers that have a mathematical relationship with each other.</p></div></div></div></div></div><div><p><h3>Web Authentication relies on three major properties:</h3></p><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-6.svg"/></p><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/flexing.svg"/></p><p><h5>Strong</h5></p><div><p>
    Authentication is ideally backed by a Hardware Security Module, which can safely store private keys and perform the cryptographic operations needed for WebAuthn.
</p></div></div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-6.svg"/></p><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/scope.svg"/></p><p><h5>Scoped</h5></p><div><p>
A keypair is only useful for a specific origin, like browser cookies. A keypair registered at &#39;webauthn.guide&#39; cannot be used at &#39;evil-webauthn.guide&#39;, mitigating the threat of phishing.
</p></div></div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-6.svg"/></p><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/attested.svg"/></p><p><h5>Attested</h5></p><div><p>
Authenticators can provide a certificate that helps servers verify that the public key did in fact come from an authenticator they trust, and not a fraudulent source.
</p></div></div></div></div></div><div id="webauthn-api"><div><p><h2>Using the API</h2></p><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/illi-web-authn-api.svg"/></p></div></div></div><div id="registration"><div><div><h3>Registering a WebAuthn Credential</h3><p>In a password-based user registration flow, a server will typically present a form to a user asking for a username and password. The password would be sent to the server for storage.</p><p>In WebAuthn, a server must provide data that binds a user to a credential (a private-public keypair); this data includes identifiers for the user and organization (also known as the &#34;relying party&#34;). The website would then use the Web Authentication API to prompt the user to create a new keypair. It is important to note that we need a randomly generated string from the server as a challenge to prevent replay attacks. </p></div><div><div><div><div><div><p><span>I want to create a new account.</span></p></div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/phone-avatar-copy.svg"/></p></div></div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/browser-avatar-copy-2.svg"/></p><div><p><span>Sure! Send me a public key.</span></p></div></div></div><div><div><div><div><div><p><span>All right! Creating a new keypair.</span></p><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/new-keys.svg"/></p></div></div></div></div></div></div><div><div><div><div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/envelope.svg"/></p></div><p><span>Okay, here&#39;s the public key!</span></p></div></div></div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/phone-avatar-copy.svg"/></p></div></div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/browser-avatar-copy-2.svg"/></p><div><p><span>Thanks! Registration complete.</span></p></div></div></div></div></div></div><div><div><div><h5><code>navigator.credentials.create()</code></h5><p>A server would begin creating a new credential by calling <span>navigator.credentials.create()</span> on the client.</p></div><div><pre><code><span><span>const</span><span> credential </span><span>=</span><span> </span><span>await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span><span>(</span><span>{</span><span>
</span></span><span><span>    publicKey</span><span>:</span><span> publicKeyCredentialCreationOptions
</span></span><span><span></span><span>}</span><span>)</span><span>;</span><span>
</span></span><span>
</span></code></pre></div></div></div><div><p>The <code>publicKeyCredentialCreationOptions</code> object contains a number of required and optional fields that a server specifies to create a new credential for a user.</p><div><div><pre><code><span><span>const</span><span> publicKeyCredentialCreationOptions </span><span>=</span><span> </span><span>{</span><span>
</span></span><span><span>    challenge</span><span>:</span><span> Uint8Array</span><span>.</span><span>from</span><span>(</span><span>
</span></span><span><span>        randomStringFromServer</span><span>,</span><span> c </span><span>=&gt;</span><span> c</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>,</span><span>
</span></span><span><span>    rp</span><span>:</span><span> </span><span>{</span><span>
</span></span><span><span>        name</span><span>:</span><span> </span><span>&#34;Duo Security&#34;</span><span>,</span><span>
</span></span><span><span>        id</span><span>:</span><span> </span><span>&#34;duosecurity.com&#34;</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>,</span><span>
</span></span><span><span>    user</span><span>:</span><span> </span><span>{</span><span>
</span></span><span><span>        id</span><span>:</span><span> Uint8Array</span><span>.</span><span>from</span><span>(</span><span>
</span></span><span><span>            </span><span>&#34;UZSL85T9AFC&#34;</span><span>,</span><span> c </span><span>=&gt;</span><span> c</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>,</span><span>
</span></span><span><span>        name</span><span>:</span><span> </span><span>&#34;lee@webauthn.guide&#34;</span><span>,</span><span>
</span></span><span><span>        displayName</span><span>:</span><span> </span><span>&#34;Lee&#34;</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>,</span><span>
</span></span><span><span>    pubKeyCredParams</span><span>:</span><span> </span><span>[</span><span>{</span><span>alg</span><span>:</span><span> </span><span>-</span><span>7</span><span>,</span><span> type</span><span>:</span><span> </span><span>&#34;public-key&#34;</span><span>}</span><span>]</span><span>,</span><span>
</span></span><span><span>    authenticatorSelection</span><span>:</span><span> </span><span>{</span><span>
</span></span><span><span>        authenticatorAttachment</span><span>:</span><span> </span><span>&#34;cross-platform&#34;</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>,</span><span>
</span></span><span><span>    timeout</span><span>:</span><span> </span><span>60000</span><span>,</span><span>
</span></span><span><span>    attestation</span><span>:</span><span> </span><span>&#34;direct&#34;</span><span>
</span></span><span><span></span><span>}</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>const</span><span> credential </span><span>=</span><span> </span><span>await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>create</span><span>(</span><span>{</span><span>
</span></span><span><span>    publicKey</span><span>:</span><span> publicKeyCredentialCreationOptions
</span></span><span><span></span><span>}</span><span>)</span><span>;</span><span>
</span></span><span>
</span></code></pre></div><div><div><p><code>challenge<!-- -->: </code>The challenge is a buffer of cryptographically random bytes generated on the server, and is needed to prevent &#34;replay attacks&#34;.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-challenge">Read the spec.</a></p><p><code>rp<!-- -->: </code>This stands for ‚Äúrelying party‚Äù; it can be considered as describing the organization <!-- --> <!-- -->responsible for registering and authenticating the user. <!-- --> <!-- -->The <code>id</code> must be a subset of the domain currently in the browser. <!-- --> <!-- -->For example, a valid <code>id</code> for this page is <!-- --> <code>webauthn.guide</code>.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-rp">Read the spec.</a></p><p><code>user<!-- -->: </code>This is information about the user currently registering. <!-- --> <!-- -->The authenticator uses the <code>id</code> to associate a credential with the user. It is suggested to not use personally identifying information as the <code>id</code>, as it may be stored in an authenticator.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-user">Read the spec.</a></p><p><code>pubKeyCredParams<!-- -->: </code>This is an array of objects describing what public key types are acceptable to a server. <!-- --> <!-- -->The <code>alg</code> is a number described in the <a rel="noopener" href="https://www.iana.org/assignments/cose/cose.xhtml#algorithms" target="_blank">COSE</a> registry; for example, <code>-7</code> <!-- --> <!-- -->indicates that the server accepts Elliptic Curve public keys using a SHA-256 signature algorithm.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-pubkeycredparams">Read the spec.</a></p><p><code>authenticatorSelection<!-- -->: </code>This optional object helps relying parties make further restrictions on the type of authenticators allowed for registration. In this example we are indicating we want to register a <code>cross-platform</code> authenticator (like a Yubikey) instead of <!-- --> <!-- -->a <code>platform</code> authenticator like Windows Hello or Touch ID.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-authenticatorselection">Read the spec.</a></p><p><code>timeout<!-- -->: </code>The time (in milliseconds) that the user has to respond to a prompt <!-- --> <!-- -->for registration before an error is returned.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialcreationoptions-timeout">Read the spec.</a></p><p><code>attestation<!-- -->: </code>The <i>attestation</i> data that is returned from the authenticator has information that <a rel="noopener" href="https://w3c.github.io/webauthn/#sec-attestation-privacy" target="_blank">could be used to track users.</a> <!-- --> This option allows servers to indicate how important the attestation data is to this registration event. A value of <code>&#34;none&#34;</code> indicates that the server does not care about attestation. A value of <code>&#34;indirect&#34;</code> means that the server will allow for anonymized attestation data. <code>direct</code> means that the server wishes to receive the attestation data from the authenticator.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#attestation-conveyance">Read the spec.</a></p></div></div></div></div><div><div><p>The <code>credential</code> object returned from the <code>create()</code> <!-- --> <!-- -->call is an object containing the public key and other attributes used to validate the registration event.</p></div><div><div><pre><code><span><span>console</span><span>.</span><span>log</span><span>(</span><span>credential</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span>PublicKeyCredential </span><span>{</span><span>
</span></span><span><span>    id</span><span>:</span><span> </span><span>&#39;ADSUllKQmbqdGtpu4sjseh4cg2TxSvrbcHDTBsv4NSSX9...&#39;</span><span>,</span><span>
</span></span><span><span>    rawId</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>59</span><span>)</span><span>,</span><span>
</span></span><span><span>    response</span><span>:</span><span> AuthenticatorAttestationResponse </span><span>{</span><span>
</span></span><span><span>        clientDataJSON</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>121</span><span>)</span><span>,</span><span>
</span></span><span><span>        attestationObject</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>306</span><span>)</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>,</span><span>
</span></span><span><span>    type</span><span>:</span><span> </span><span>&#39;public-key&#39;</span><span>
</span></span><span><span></span><span>}</span></span></code></pre></div><div><div><p><code>id<!-- -->: </code>The ID for the newly generated credential; it will be used<!-- --> <!-- -->to identify the credential when authenticating the user. The ID is provided here as a base64-encoded string.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#ref-for-dom-credential-id">Read the spec.</a></p><p><code>clientDataJSON<!-- -->: </code>This represents data passed from the browser to the authenticator in order to associate the new credential with the server and browser. The authenticator provides it as a UTF-8 byte array.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dictdef-collectedclientdata">Read the spec.</a></p><p><code>attestationObject<!-- -->: </code>This object contains the credential public key, an optional attestation certificate, and other metadata used also to validate the registration event. It is binary data encoded in CBOR.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-authenticatorattestationresponse-attestationobject">Read the spec.</a></p></div></div></div></div><div><div><h5>Parsing and Validating the Registration Data</h5><p>After the <code>PublicKeyCredential</code> has been obtained, it is sent to the server for validation. The WebAuthn specification describes a <a rel="noopener" href="https://w3c.github.io/webauthn/#registering-a-new-credential" target="_blank">19-point procedure to validate the registration data</a>; what this looks like will vary depending on the language your server software is written in.</p><p>Duo Labs has provided full example projects implementing WebAuthn written in <a rel="noopener" href="https://github.com/duo-labs/py_webauthn" target="_blank">Python</a> and <a rel="noopener" href="https://github.com/duo-labs/webauthn" target="_blank">Go.</a></p></div></div><div><p><b>Example: Parsing the clientDataJSON</b></p><div><div><pre><code><span><span>
</span></span><span><span></span><span>const</span><span> utf8Decoder </span><span>=</span><span> </span><span>new</span><span> </span><span>TextDecoder</span><span>(</span><span>&#39;utf-8&#39;</span><span>)</span><span>;</span><span>
</span></span><span><span></span><span>const</span><span> decodedClientData </span><span>=</span><span> utf8Decoder</span><span>.</span><span>decode</span><span>(</span><span>
</span></span><span><span>    credential</span><span>.</span><span>response</span><span>.</span><span>clientDataJSON</span><span>)</span><span>
</span></span><span>
</span><span><span></span><span>
</span></span><span><span></span><span>const</span><span> clientDataObj </span><span>=</span><span> </span><span>JSON</span><span>.</span><span>parse</span><span>(</span><span>decodedClientData</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span>console</span><span>.</span><span>log</span><span>(</span><span>clientDataObj</span><span>)</span><span>
</span></span><span>
</span><span><span></span><span>{</span><span>
</span></span><span><span>    challenge</span><span>:</span><span> </span><span>&#34;p5aV2uHXr0AOqUk7HQitvi-Ny1....&#34;</span><span>,</span><span>
</span></span><span><span>    origin</span><span>:</span><span> </span><span>&#34;https://webauthn.guide&#34;</span><span>,</span><span>
</span></span><span><span>    type</span><span>:</span><span> </span><span>&#34;webauthn.create&#34;</span><span>
</span></span><span><span></span><span>}</span></span></code></pre></div><div><div><p>The <code>clientDataJSON</code> is parsed by converting the UTF-8 byte array <!-- --> <!-- -->provided by the authenticator into a JSON-parsable string. On this server, this (and the other <code>PublicKeyCredential</code> data) will be verified to ensure that the registration event is valid.</p><p><code>challenge<!-- -->: </code>This is the same challenge that was passed into the <code>create()</code> call. The server must validate that this returned challenge matches the one generated for this registration event.<!-- --> <!-- --> </p><p><code>origin<!-- -->: </code>The server must validate that this &#34;origin&#34; string matches up with the origin of the application.<!-- --> <!-- --> </p><p><code>type<!-- -->: </code>The server validates that this string is in fact <code>&#34;webauthn.create&#34;</code>. If another string is provided, it indicates that the authenticator performed an incorrect operation.<!-- --> <!-- --> </p></div></div></div></div><div><p><b>Example: Parsing the attestationObject</b></p><div><div><pre><code><span><span>
</span></span><span><span></span><span>const</span><span> decodedAttestationObj </span><span>=</span><span> </span><span>CBOR</span><span>.</span><span>decode</span><span>(</span><span>
</span></span><span><span>    credential</span><span>.</span><span>response</span><span>.</span><span>attestationObject</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span>console</span><span>.</span><span>log</span><span>(</span><span>decodedAttestationObject</span><span>)</span><span>;</span><span>
</span></span><span><span></span><span>{</span><span>
</span></span><span><span>    authData</span><span>:</span><span> </span><span>Uint8Array</span><span>(</span><span>196</span><span>)</span><span>,</span><span>
</span></span><span><span>    fmt</span><span>:</span><span> </span><span>&#34;fido-u2f&#34;</span><span>,</span><span>
</span></span><span><span>    attStmt</span><span>:</span><span> </span><span>{</span><span>
</span></span><span><span>        sig</span><span>:</span><span> </span><span>Uint8Array</span><span>(</span><span>70</span><span>)</span><span>,</span><span>
</span></span><span><span>        x5c</span><span>:</span><span> </span><span>Array</span><span>(</span><span>1</span><span>)</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>,</span><span>
</span></span><span><span></span><span>}</span></span></code></pre></div><div><div><p><code>authData<!-- -->: </code>The <b>authenticator data</b> is here is a byte array that contains metadata about the registration event, as well as the public key we will use for future authentications.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#authenticator-data">Read the spec.</a></p><p><code>fmt<!-- -->: </code>This represents the <b>attestation format</b>. Authenticators can provide attestation data in a number of ways; this indicates how the server should parse and validate the attestation data.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#attestation-statement-format">Read the spec.</a></p><p><code>attStmt<!-- -->: </code>This is the <b>attestation statement</b>. This object will look different depending on the attestation format indicated. In this case, we are given a signature <code>sig</code> and attestation certificate <code>x5c</code>. Servers use this data to cryptographically <i>verify</i> the credential public key came from the authenticator. Additionally, servers can use the certificate to reject authenticators that are believed to be weak.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#attestation-statement">Read the spec.</a></p></div></div></div></div><div><p><b>Example: Parsing the authenticator data</b></p><div><div><pre><code><span><span>const</span><span> </span><span>{</span><span>authData</span><span>}</span><span> </span><span>=</span><span> decodedAttestationObject</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>
</span></span><span><span></span><span>const</span><span> dataView </span><span>=</span><span> </span><span>new</span><span> </span><span>DataView</span><span>(</span><span>
</span></span><span><span>    </span><span>new</span><span> </span><span>ArrayBuffer</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span><span>
</span></span><span><span></span><span>const</span><span> idLenBytes </span><span>=</span><span> authData</span><span>.</span><span>slice</span><span>(</span><span>53</span><span>,</span><span> </span><span>55</span><span>)</span><span>;</span><span>
</span></span><span><span>idLenBytes</span><span>.</span><span>forEach</span><span>(</span><span>
</span></span><span><span>    </span><span>(</span><span>value</span><span>,</span><span> index</span><span>)</span><span> </span><span>=&gt;</span><span> dataView</span><span>.</span><span>setUint8</span><span>(</span><span>
</span></span><span><span>        index</span><span>,</span><span> value</span><span>)</span><span>)</span><span>;</span><span>
</span></span><span><span></span><span>const</span><span> credentialIdLength </span><span>=</span><span> dataView</span><span>.</span><span>getUint16</span><span>(</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>
</span></span><span><span></span><span>const</span><span> credentialId </span><span>=</span><span> authData</span><span>.</span><span>slice</span><span>(</span><span>
</span></span><span><span>    </span><span>55</span><span>,</span><span> </span><span>55</span><span> </span><span>+</span><span> credentialIdLength</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>
</span></span><span><span></span><span>const</span><span> publicKeyBytes </span><span>=</span><span> authData</span><span>.</span><span>slice</span><span>(</span><span>
</span></span><span><span>    </span><span>55</span><span> </span><span>+</span><span> credentialIdLength</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>
</span></span><span><span></span><span>const</span><span> publicKeyObject </span><span>=</span><span> </span><span>CBOR</span><span>.</span><span>decode</span><span>(</span><span>
</span></span><span><span>    publicKeyBytes</span><span>.</span><span>buffer</span><span>)</span><span>;</span><span>
</span></span><span><span>console</span><span>.</span><span>log</span><span>(</span><span>publicKeyObject</span><span>)</span><span>
</span></span><span>
</span><span><span></span><span>{</span><span>
</span></span><span><span>    </span><span>1</span><span>:</span><span> </span><span>2</span><span>,</span><span>
</span></span><span><span>    </span><span>3</span><span>:</span><span> </span><span>-</span><span>7</span><span>,</span><span>
</span></span><span><span>    </span><span>-</span><span>1</span><span>:</span><span> </span><span>1</span><span>,</span><span>
</span></span><span><span>    </span><span>-</span><span>2</span><span>:</span><span> </span><span>Uint8Array</span><span>(</span><span>32</span><span>)</span><span> </span><span>...</span><span>
</span></span><span><span>    </span><span>-</span><span>3</span><span>:</span><span> </span><span>Uint8Array</span><span>(</span><span>32</span><span>)</span><span> </span><span>...</span><span>
</span></span><span><span></span><span>}</span></span></code></pre></div><div><div><p>The <code>authData</code> is a byte array described in the spec. Parsing it will involve slicing bytes from the array and converting them into usable objects.</p><p>The <code>publicKeyObject</code> retrieved at the end is an object encoded in a standard called <a rel="noopener" href="https://www.iana.org/assignments/cose/cose.xhtml#algorithms" target="_blank">COSE</a>, which is a concise way to describe the credential public key and the metadata needed to use it.</p><p><code>1<!-- -->: </code>The <code>1</code> field describes the key type. The value of <code>2</code> indicates that the key type is in the Elliptic Curve format.<!-- --> <!-- --> </p><p><code>3<!-- -->: </code>The <code>3</code> field describes the algorithm used to generate authentication signatures. The <code>-7</code> value indicates this authenticator will be using ES256.<!-- --> <!-- --> </p><p><code>-1<!-- -->: </code>The <code>-1</code> field describes this key&#39;s &#34;curve type&#34;. The value <code>1</code> indicates the that this key uses the &#34;P-256&#34; curve.<!-- --> <!-- --> </p><p><code>-2<!-- -->: </code>The <code>-2</code> field describes the x-coordinate of this public key.<!-- --> <!-- --> </p><p><code>-3<!-- -->: </code>The <code>-3</code> field describes the y-coordinate of this public key.<!-- --> <!-- --> </p></div></div></div><p>If the validation process succeeded, the server would then store the <code>publicKeyBytes</code> and <code>credentialId </code>in a database, associated with the user. </p></div></div><div id="authentication"><div><div><h3>Authenticating with a WebAuthn Credential</h3><p>After registration has finished, the user can now be authenticated. During authentication an<i> assertion</i> is created, which is proof that the user has possession of the private key. This assertion contains a <i>signature</i> created using the private key. The server uses the public key retrieved during registration to verify this signature.</p></div><div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/phone-avatar-copy.svg"/></p></div></div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/browser-avatar-copy-2.svg"/></p><div><div><div><p><span>Please sign this data so I really know it&#39;s you.</span></p><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/data-envelope.svg"/></p></div></div></div></div></div></div><div><div><div><div><div><p>Creating a signature with the private key...</p><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/signature.svg"/></p></div></div></div></div></div></div><div><div><div><div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/signed-signature-envelope.svg"/></p></div><p>Okay, here&#39;s the signature.</p></div></div></div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/phone-avatar-copy.svg"/></p></div></div><div><div><div><div><div><p>Verifying the signature with the public key...</p><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/verifying-signature.svg"/></p></div></div></div></div></div></div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/browser-avatar-copy-2.svg"/></p><div><p>Great! This checks out. You can sign in.</p></div></div></div></div></div><div><div><div><h5><code>navigator.credentials.get()</code></h5><p>During authentication the user proves that they own the private key they registered with. <!-- --> <!-- -->They do so by providing an <code>assertion</code>, which is generated by calling <code>navigator.credentials.get()</code> on the client. This will retrieve the credential generated during registration with a signature included.</p></div><div><pre><code><span><span>const</span><span> credential </span><span>=</span><span> </span><span>await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span><span>(</span><span>{</span><span>
</span></span><span><span>    publicKey</span><span>:</span><span> publicKeyCredentialRequestOptions
</span></span><span><span></span><span>}</span><span>)</span><span>;</span><span>
</span></span><span>
</span></code></pre></div></div></div><div><div><p>The <code>publicKeyCredentialCreationOptions</code> object contains a number of required and optional fields that a server specifies to create a new credential for a user.</p></div><div><div><pre><code><span><span>const</span><span> publicKeyCredentialRequestOptions </span><span>=</span><span> </span><span>{</span><span>
</span></span><span><span>    challenge</span><span>:</span><span> Uint8Array</span><span>.</span><span>from</span><span>(</span><span>
</span></span><span><span>        randomStringFromServer</span><span>,</span><span> c </span><span>=&gt;</span><span> c</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>,</span><span>
</span></span><span><span>    allowCredentials</span><span>:</span><span> </span><span>[</span><span>{</span><span>
</span></span><span><span>        id</span><span>:</span><span> Uint8Array</span><span>.</span><span>from</span><span>(</span><span>
</span></span><span><span>            credentialId</span><span>,</span><span> c </span><span>=&gt;</span><span> c</span><span>.</span><span>charCodeAt</span><span>(</span><span>0</span><span>)</span><span>)</span><span>,</span><span>
</span></span><span><span>        type</span><span>:</span><span> </span><span>&#39;public-key&#39;</span><span>,</span><span>
</span></span><span><span>        transports</span><span>:</span><span> </span><span>[</span><span>&#39;usb&#39;</span><span>,</span><span> </span><span>&#39;ble&#39;</span><span>,</span><span> </span><span>&#39;nfc&#39;</span><span>]</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>]</span><span>,</span><span>
</span></span><span><span>    timeout</span><span>:</span><span> </span><span>60000</span><span>,</span><span>
</span></span><span><span></span><span>}</span><span>
</span></span><span>
</span><span><span></span><span>const</span><span> assertion </span><span>=</span><span> </span><span>await</span><span> navigator</span><span>.</span><span>credentials</span><span>.</span><span>get</span><span>(</span><span>{</span><span>
</span></span><span><span>    publicKey</span><span>:</span><span> publicKeyCredentialRequestOptions
</span></span><span><span></span><span>}</span><span>)</span><span>;</span></span></code></pre></div><div><div><p><code>challenge<!-- -->: </code>Like during registration, this must be cryptographically random bytes generated on the server.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialrequestoptions-challenge">Read the spec.</a></p><p><code>allowCredentials<!-- -->: </code>This array tells the browser which credentials the server would like the user to authenticate with. The <code>credentialId</code> retrieved and saved during registration is passed in here. The server can optionally indicate what <i>transports</i> it prefers, like USB, NFC, and Bluetooth.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialrequestoptions-allowcredentials">Read the spec.</a></p><p><code>timeout<!-- -->: </code>Like during registration, this optionally indicates the time (in milliseconds) that the user has to respond to a prompt for authentication.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredentialrequestoptions-timeout">Read the spec.</a></p></div></div></div></div><div><div><p>The <code>assertion</code> object returned from the <!-- --> <code>get()</code> call is again a <code>PublicKeyCredential</code> object. It is slightly different from the object we received during registration; in particular, it includes a <code>signature</code> member, and does not include the public key.</p></div><div><div><pre><code><span><span>console</span><span>.</span><span>log</span><span>(</span><span>assertion</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span>PublicKeyCredential </span><span>{</span><span>
</span></span><span><span>    id</span><span>:</span><span> </span><span>&#39;ADSUllKQmbqdGtpu4sjseh4cg2TxSvrbcHDTBsv4NSSX9...&#39;</span><span>,</span><span>
</span></span><span><span>    rawId</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>59</span><span>)</span><span>,</span><span>
</span></span><span><span>    response</span><span>:</span><span> AuthenticatorAssertionResponse </span><span>{</span><span>
</span></span><span><span>        authenticatorData</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>191</span><span>)</span><span>,</span><span>
</span></span><span><span>        clientDataJSON</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>118</span><span>)</span><span>,</span><span>
</span></span><span><span>        signature</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>70</span><span>)</span><span>,</span><span>
</span></span><span><span>        userHandle</span><span>:</span><span> </span><span>ArrayBuffer</span><span>(</span><span>10</span><span>)</span><span>,</span><span>
</span></span><span><span>    </span><span>}</span><span>,</span><span>
</span></span><span><span>    type</span><span>:</span><span> </span><span>&#39;public-key&#39;</span><span>
</span></span><span><span></span><span>}</span></span></code></pre></div><div><div><p><code>id<!-- -->: </code>The identifier for the credential that was used to generate the authentication assertion.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#ref-for-dom-credential-id">Read the spec.</a></p><p><code>rawId<!-- -->: </code>The identifier again, but in binary form.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-publickeycredential-rawid">Read the spec.</a></p><p><code>authenticatorData<!-- -->: </code>The <b>authenticator data</b> is similar to the <i>authData</i> received during registration, with the notable exception that the public key is not included here. It is another item used during authentication as source bytes to generate the assertion signature.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#authenticator-data">Read the spec.</a></p><p><code>clientDataJSON<!-- -->: </code>As during registration, the <b>clientDataJSON</b> is a collection of the data passed from the browser to the authenticator. It is one of the items used during authentication as the source bytes to generate the signature.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dictdef-collectedclientdata">Read the spec.</a></p><p><code>signature<!-- -->: </code>The signature generated by the private key associated with this credential. On the server, the public key will be used to verify that this signature is valid.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-authenticatorassertionresponse-signature">Read the spec.</a></p><p><code>userHandle<!-- -->: </code>This field is optionally provided by the authenticator, and represents the <code>user.id </code>that was supplied during registration. It can be used to relate this assertion to the user on the server. It is encoded here as a UTF-8 byte array.<!-- --> <!-- --> <a target="_blank" href="https://w3c.github.io/webauthn/#dom-authenticatorassertionresponse-userhandle">Read the spec.</a></p></div></div></div></div><div><div><h5>Parsing and Validating the Authentication Data</h5><p>After the assertion has been obtained, it is sent to the server for validation. After the authentication data is fully validated, the signature is <i>verified</i> using the public key stored in the database during registration.</p><p>See these projects by Duo Labs for examples of validating the authentication data on the server, written in <a rel="noopener" href="https://github.com/duo-labs/py_webauthn" target="_blank">Python</a> and <a rel="noopener" href="https://github.com/duo-labs/webauthn" target="_blank">Go.</a></p></div></div><div><p><b>Example: Verifying the assertion signature on the server (pseudo-code)</b></p><div><div><pre><code><span><span>const</span><span> storedCredential </span><span>=</span><span> </span><span>await</span><span> </span><span>getCredentialFromDatabase</span><span>(</span><span>
</span></span><span><span>    userHandle</span><span>,</span><span> credentialId</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>const</span><span> signedData </span><span>=</span><span> </span><span>(</span><span>
</span></span><span><span>    authenticatorDataBytes </span><span>+</span><span>
</span></span><span><span>    hashedClientDataJSON</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>const</span><span> signatureIsValid </span><span>=</span><span> storedCredential</span><span>.</span><span>publicKey</span><span>.</span><span>verify</span><span>(</span><span>
</span></span><span><span>    signature</span><span>,</span><span> signedData</span><span>)</span><span>;</span><span>
</span></span><span>
</span><span><span></span><span>if</span><span> </span><span>(</span><span>signatureIsValid</span><span>)</span><span> </span><span>{</span><span>
</span></span><span><span>    </span><span>return</span><span> </span><span>&#34;Hooray! User is authenticated! üéâ&#34;</span><span>;</span><span>
</span></span><span><span></span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span><span><span>    </span><span>return</span><span> </span><span>&#34;Verification failed. üò≠&#34;</span><span>
</span></span><span><span></span><span>}</span></span></code></pre></div><div><p>Verification will look different depending on the language and cryptography library used on the server. However, the general procedure remains the same.</p><ul><li>The server retrieves the public key object associated with the user</li><li>The server uses the public key to verify the signature, which was generated using the<code>authenticatorData</code> bytes and a SHA-256 hash of the <code>clientDataJSON</code></li></ul></div></div></div></div><div id="looking-ahead"><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/illi-conclusion.svg"/></p><div><h2>Looking Ahead</h2><p>While Web Authentication is an important tool,<!-- --> <!-- -->it is always important to remember that security is not a single technology;<!-- --> <!-- -->it is a <i>way of thinking</i> that should be incorporated into every step of how software<!-- --> <!-- -->is designed and developed. Web Authentication can be an important part of this process,<!-- --> <!-- -->by forcing 80% of hacking attacks to either adapt or die.</p></div></div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/suby-placeholder.svg"/></p></div><div><h5>Suby Raman</h5><p>Suby is a software engineer at Duo Security, working on the team responsible<!-- --> <!-- -->for Duo&#39;s Authentication Prompt. He has helped drive<!-- --> <!-- -->Web Authentication development at Duo.</p><p>Notably, he has contributed over 175 custom emoji to Duo&#39;s Slack workspace.</p><p><a rel="noopener" href="https://twitter.com/subyraman" target="_blank"><svg aria-label="Link to Suby Raman&#39;s Twitter Page" role="img" viewBox="0 0 300.00006 244.18703"><title>Link To Suby Raman&#39;s Twitter page</title><g transform="translate(-539.17946,-568.85777)" id="layer1"><path id="path3611" d="m 633.89823,812.04479 c 112.46038,0 173.95627,-93.16765 173.95627,-173.95625 0,-2.64628 -0.0539,-5.28062 -0.1726,-7.90305 11.93799,-8.63016 22.31446,-19.39999 30.49762,-31.65984 -10.95459,4.86937 -22.74358,8.14741 -35.11071,9.62551 12.62341,-7.56929 22.31446,-19.54304 26.88583,-33.81739 -11.81284,7.00307 -24.89517,12.09297 -38.82383,14.84055 -11.15723,-11.88436 -27.04079,-19.31655 -44.62892,-19.31655 -33.76374,0 -61.14426,27.38052 -61.14426,61.13233 0,4.79784 0.5364,9.46458 1.58538,13.94057 -50.81546,-2.55686 -95.87353,-26.88582 -126.02546,-63.87991 -5.25082,9.03545 -8.27852,19.53111 -8.27852,30.73006 0,21.21186 10.79366,39.93837 27.20766,50.89296 -10.03077,-0.30992 -19.45363,-3.06348 -27.69044,-7.64676 -0.009,0.25652 -0.009,0.50661 -0.009,0.78077 0,29.60957 21.07478,54.3319 49.0513,59.93435 -5.13757,1.40062 -10.54335,2.15158 -16.12196,2.15158 -3.93364,0 -7.76596,-0.38716 -11.49099,-1.1026 7.78383,24.2932 30.35457,41.97073 57.11525,42.46543 -20.92578,16.40207 -47.28712,26.17062 -75.93712,26.17062 -4.92898,0 -9.79834,-0.28036 -14.58427,-0.84634 27.05868,17.34379 59.18936,27.46396 93.72193,27.46396"></path></g></svg></a><a rel="noopener" href="https://twitter.com/subyraman" target="_blank">@subyraman</a></p></div></div><div><div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-6.svg"/></p><p><span>There&#39;s been a massive amount of progress made by both vendors and the <!-- --> <!-- -->authors of Web Authentication to bring this spec into usage in browsers and <!-- --> <!-- -->websites - here&#39;s what&#39;s new in WebAuthn and FIDO2.</span></p></div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-6.svg"/></p><p><span>While Duo is extremely bullish about the security properties of U2F,<!-- --> <!-- -->we think that the biggest change in strong authentication is coming soon.<!-- --> <!-- -->Get a look back at biometric authentication and how it&#39;s evolved over the years.</span></p></div><div><p><img role="presentation" alt="" src="https://webauthn.guide/dist/images/oval-6.svg"/></p><p><span>James Barclay and Nick Steele recently shared their thoughts on a <!-- --> <!-- -->passwordless future during a Twitter chat with Yubico. Get their insights on the <!-- --> <!-- -->pain points of passwords, their hopes for the future, and explore some of our resources around <!-- --> <!-- -->industry advancements paving the way, like passwordless authentication, <!-- --> <!-- -->multi-factor authentication and WebAuthn.</span></p></div></div></div></div></main></div></div></div>
              
        </div></div>
  </body>
</html>
