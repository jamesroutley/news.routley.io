<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://borretti.me/article/astronomical-calculations-for-hard-sf-common-lisp">Original</a>
    <h1>Astronomical Calculations for Hard SF in Common Lisp</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>In <a href="https://borretti.me/fiction/eog581"><em>The Epiphany of Gliese 581</em></a>, a group of explorers search the
mortal remains of a dead superintelligence. The expedition begins in Beta
Pictoris—today an unremarkable blue star; in the story, a posthuman <a href="https://en.wikipedia.org/wiki/Dyson_sphere#Dyson_swarm">Dyson
swarm</a> civilization of quadrillions—then passes through <a href="https://en.wikipedia.org/wiki/Gliese_581">Gliese
581</a>, and ends where it started.</p>

<p>I wanted to build a timeline of the story, and, because this is hard science
fiction, this means doing real math on real astronomical data. I ended up
writing a small framework for doing astronomical calculations. In Common Lisp,
for old time’s sake.</p>

<p>The code is in <a href="https://github.com/eudoxia0/astro-eog581">this repo</a>. The rest of this post is a walkthrough of the
astronomy framework, followed by the story-specific code.</p>



<p>Building a timeline requires knowing travel times, which requires knowing the
distances between the stars. Which requires knowing the <em>positions</em> of the
stars<sup id="fnref:drift" role="doc-noteref"><a href="#fn:drift" rel="footnote">1</a></sup>. So I had to download the <a href="https://github.com/astronexus/HYG-Database">HYG</a> database, which has all the
information I need.</p>

<p><em>But</em>. The characters don’t travel in a straight-line ballistic
trajectory. They’re digital people, so they can travel at the speed of light by
sending their mental states over an interstellar communications network. And,
because lasers decohere with distance, each “jump” is limited to a relatively
short distance. So the fastest route from A to B is not a straight line on a
rocket, but a zig-zagging trajectory on an optical link. To find the fastest
network route I wrote an implementation of <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra’s algorithm</a> and
ran it over a graph of stars, the edges linking all stars whose distance is less
than the laser cutoff distance.</p>

<p>An added constraint: Gliese 581 is not on the network, because it was inhabited
by a taciturn superintelligence. So I had to write even more code to find the
star <em>closest</em> to Gliese 581, from which the characters complete the last leg of
the journey on a fusion rocket.</p>



<p>The most widely used unit of length in astronomy is the parsec, some weird
trigonometry thing about parallax. It’s just as geocentric as lightyears but
harder to intuit. We will want to convert to light years to present the results.</p>

<p>We could just use floats, but I have a peculiar malady where I enjoy writing
CLOS class definitions too much. Also, if I don’t have distinct types for the
two units, I <em>will</em> confuse them and ruin all subsequent calculations.</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>light-years</span> <span>()</span>
  <span>((</span><span>value</span> <span>:reader</span> <span>value</span>
          <span>:initarg</span> <span>:value</span>
          <span>:type</span> <span>real</span>
          <span>:documentation</span> <span>&#34;The underlying value.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents distance in light years.&#34;</span><span>))</span>

<span>(</span><span>defclass</span> <span>parsecs</span> <span>()</span>
  <span>((</span><span>value</span> <span>:reader</span> <span>value</span>
          <span>:initarg</span> <span>:value</span>
          <span>:type</span> <span>real</span>
          <span>:documentation</span> <span>&#34;The underlying value.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents distance in parsecs.&#34;</span><span>))</span>

<span>(</span><span>defun</span> <span>make-parsecs</span> <span>(</span><span>value</span><span>)</span>
  <span>&#34;Create an instance of PARSECS from a numeric value.&#34;</span>
  <span>(</span><span>make-instance</span> <span>&#39;parsecs</span> <span>:value</span> <span>value</span><span>))</span>
</code></pre></div></div>
<p>We can easily convert between the two units by multiplying by a constant:</p>

\[\begin{align*}
pc &amp;= ly \times 0.306601 \\
ly &amp;= pc \times 3.26156
\end{align*}\]

<p>In Common Lisp these can be implemented as:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>light-years-to-parsecs</span> <span>(</span><span>ly</span><span>)</span>
  <span>&#34;Convert the given distance in light years to parsecs.&#34;</span>
  <span>(</span><span>make-parsecs</span> <span>(</span><span>*</span> <span>(</span><span>value</span> <span>ly</span><span>)</span> <span>0.306601</span><span>)))</span>

<span>(</span><span>defun</span> <span>parsecs-to-light-years</span> <span>(</span><span>pc</span><span>)</span>
  <span>&#34;Convert the given distance in parsecs to light years.&#34;</span>
  <span>(</span><span>make-instance</span> <span>&#39;light-years</span> <span>:value</span> <span>(</span><span>*</span> <span>(</span><span>value</span> <span>pc</span><span>)</span> <span>3.26156</span><span>)))</span>
</code></pre></div></div>

<p>For example:</p>

<div><div><pre><code><span>CL-USER&gt;</span> <span>(</span><span>make-parsecs</span> <span>5.0</span><span>)</span>
<span>#</span><span>&lt;PARSECS</span> <span>5.0pc&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>parsecs-to-light-years</span> <span>*</span><span>)</span>
<span>#</span><span>&lt;LIGHT-YEARS</span> <span>16.3ly&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>light-years-to-parsecs</span> <span>*</span><span>)</span>
<span>#</span><span>&lt;PARSECS</span> <span>5.0pc&gt;</span>
</code></pre></div></div>



<p>Star positions are typically given in <a href="https://en.wikipedia.org/wiki/Equatorial_coordinate_system">equatorial coordinates</a>, a
spherical coordinate system where positions in space are represented by two
angles (called right ascension (RA) and declination (DEC)), and a radius (the
star’s distance from the Sun). For historical reasons, right ascension is
reported in hours-minutes-seconds format, and declination is reported in
degrees-minutes-seconds.</p>

<p>Luckily, the HYG database contains the Cartesian (X, Y, Z) coordinates<sup id="fnref:coords" role="doc-noteref"><a href="#fn:coords" rel="footnote">2</a></sup>
as well. This makes it much easier to calculate distances and, later, to make
star maps (see the appendix for dealing with equatorial coordinates).</p>

<p>The <code>cartesian-position</code> class represents a Cartesian triple:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>cartesian-position</span> <span>()</span>
  <span>((</span><span>x</span> <span>:reader</span> <span>x</span>
      <span>:initarg</span> <span>:x</span>
      <span>:type</span> <span>parsecs</span>
      <span>:documentation</span> <span>&#34;The X coordinate in parsecs.&#34;</span><span>)</span>
   <span>(</span><span>y</span> <span>:reader</span> <span>y</span>
      <span>:initarg</span> <span>:y</span>
      <span>:type</span> <span>parsecs</span>
      <span>:documentation</span> <span>&#34;The Y coordinate in parsecs.&#34;</span><span>)</span>
   <span>(</span><span>z</span> <span>:reader</span> <span>z</span>
      <span>:initarg</span> <span>:z</span>
      <span>:type</span> <span>parsecs</span>
      <span>:documentation</span> <span>&#34;The Z coordinate in parsecs.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;A position in Cartesian (X, Y, Z) coordinates.&#34;</span><span>))</span>
</code></pre></div></div>

<p>And the <code>euclidean-distance</code> function calculates the distance between two points:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>euclidean-distance</span> <span>(</span><span>p1</span> <span>p2</span><span>)</span>
  <span>&#34;Calculate the Euclidean distance between two Cartesian coordinates.
Returns a value in parsecs.&#34;</span>
  <span>(</span><span>with-slots</span> <span>((</span><span>x1</span> <span>x</span><span>)</span> <span>(</span><span>y1</span> <span>y</span><span>)</span> <span>(</span><span>z1</span> <span>z</span><span>))</span> <span>p1</span>
    <span>(</span><span>with-slots</span> <span>((</span><span>x2</span> <span>x</span><span>)</span> <span>(</span><span>y2</span> <span>y</span><span>)</span> <span>(</span><span>z2</span> <span>z</span><span>))</span> <span>p2</span>
      <span>(</span><span>let</span> <span>((</span><span>x1</span> <span>(</span><span>value</span> <span>x1</span><span>))</span>
            <span>(</span><span>y1</span> <span>(</span><span>value</span> <span>y1</span><span>))</span>
            <span>(</span><span>z1</span> <span>(</span><span>value</span> <span>z1</span><span>))</span>
            <span>(</span><span>x2</span> <span>(</span><span>value</span> <span>x2</span><span>))</span>
            <span>(</span><span>y2</span> <span>(</span><span>value</span> <span>y2</span><span>))</span>
            <span>(</span><span>z2</span> <span>(</span><span>value</span> <span>z2</span><span>)))</span>
        <span>(</span><span>make-parsecs</span> <span>(</span><span>sqrt</span> <span>(</span><span>+</span> <span>(</span><span>expt</span> <span>(</span><span>-</span> <span>x1</span> <span>x2</span><span>)</span> <span>2</span><span>)</span>
                               <span>(</span><span>expt</span> <span>(</span><span>-</span> <span>y1</span> <span>y2</span><span>)</span> <span>2</span><span>)</span>
                               <span>(</span><span>expt</span> <span>(</span><span>-</span> <span>z1</span> <span>z2</span><span>)</span> <span>2</span><span>))))))))</span>
</code></pre></div></div>

<p>We can use this like this:</p>

<div><div><pre><code><span>CL-USER&gt;</span> <span>(</span><span>defparameter</span> <span>a</span>
           <span>(</span><span>make-instance</span> <span>&#39;cartesian-position</span>
                          <span>:x</span> <span>(</span><span>make-parsecs</span> <span>3.4</span><span>)</span>
                          <span>:y</span> <span>(</span><span>make-parsecs</span> <span>-6.7</span><span>)</span>
                          <span>:z</span> <span>(</span><span>make-parsecs</span> <span>-1.2</span><span>)))</span>
<span>#</span><span>&lt;CARTESIAN-POSITION</span> <span>X=3.4pc</span> <span>Y=-6.7pc</span> <span>Z=-1.2pc&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>defparameter</span> <span>b</span>
           <span>(</span><span>make-instance</span> <span>&#39;cartesian-position</span>
                          <span>:x</span> <span>(</span><span>make-parsecs</span> <span>9.1</span><span>)</span>
                          <span>:y</span> <span>(</span><span>make-parsecs</span> <span>4.3</span><span>)</span>
                          <span>:z</span> <span>(</span><span>make-parsecs</span> <span>-7.2</span><span>)))</span>
<span>#</span><span>&lt;CARTESIAN-POSITION</span> <span>X=9.1pc</span> <span>Y=4.3pc</span> <span>Z=-7.2pc&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>euclidean-distance</span> <span>a</span> <span>b</span><span>)</span>
<span>#</span><span>&lt;PARSECS</span> <span>13.8pc&gt;</span>
</code></pre></div></div>



<p>The HYG database is a straightforward CSV, so we can parse it easily. We use the
<code>parse-number</code> library to parse floats (the alternative is <code>read-from-string</code>,
which is heavy and insecure).</p>

<p>First, a class to store the database:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>hyg-database</span> <span>()</span>
  <span>((</span><span>stars</span> <span>:reader</span> <span>database-stars</span>
          <span>:initarg</span> <span>:stars</span>
          <span>:type</span> <span>(</span><span>vector</span> <span>star</span><span>)</span>
          <span>:documentation</span> <span>&#34;The star vector.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;The in-memory HYG database.&#34;</span><span>))</span>

<span>(</span><span>defun</span> <span>star-count</span> <span>(</span><span>db</span><span>)</span>
  <span>(</span><span>length</span> <span>(</span><span>database-stars</span> <span>db</span><span>)))</span>
</code></pre></div></div>

<p>And another to represent the star data we care about:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>star</span> <span>()</span>
  <span>((</span><span>id</span> <span>:reader</span> <span>star-id</span>
       <span>:initarg</span> <span>:id</span>
       <span>:type</span> <span>integer</span>
       <span>:documentation</span> <span>&#34;The star&#39;s ID in the HYG database.&#34;</span><span>)</span>
   <span>(</span><span>proper</span> <span>:reader</span> <span>star-proper</span>
           <span>:initarg</span> <span>:proper</span>
           <span>:type</span> <span>(</span><span>or</span> <span>null</span> <span>string</span><span>)</span>
           <span>:documentation</span> <span>&#34;The star&#39;s proper name, if known.&#34;</span><span>)</span>
   <span>(</span><span>hip</span> <span>:reader</span> <span>star-hip</span>
        <span>:initarg</span> <span>:hip</span>
        <span>:type</span> <span>(</span><span>or</span> <span>null</span> <span>string</span><span>)</span>
        <span>:documentation</span> <span>&#34;The star&#39;s name in the Hipparcos catalog, if known.&#34;</span><span>)</span>
   <span>(</span><span>hd</span> <span>:reader</span> <span>star-hd</span>
       <span>:initarg</span> <span>:hd</span>
       <span>:type</span> <span>(</span><span>or</span> <span>null</span> <span>string</span><span>)</span>
       <span>:documentation</span> <span>&#34;The star&#39;s name in the Henry Draper catalog, if known.&#34;</span><span>)</span>
   <span>(</span><span>gliese</span> <span>:reader</span> <span>star-gliese</span>
        <span>:initarg</span> <span>:gliese</span>
        <span>:type</span> <span>(</span><span>or</span> <span>null</span> <span>string</span><span>)</span>
           <span>:documentation</span> <span>&#34;The star&#39;s name in the the third edition of the Gliese Catalog of Nearby Stars, if known.&#34;</span><span>)</span>
   <span>(</span><span>bayer</span> <span>:reader</span> <span>star-bayer</span>
          <span>:initarg</span> <span>:bayer</span>
          <span>:type</span> <span>(</span><span>or</span> <span>null</span> <span>string</span><span>)</span>
          <span>:documentation</span> <span>&#34;The star&#39;s Bayer-Flamsteed designation, if known.&#34;</span><span>)</span>
   <span>(</span><span>distance</span> <span>:reader</span> <span>star-distance</span>
             <span>:initarg</span> <span>:distance</span>
             <span>:type</span> <span>parsecs</span>
             <span>:documentation</span> <span>&#34;The star&#39;s distance from the Sun in parsecs.&#34;</span><span>)</span>
   <span>(</span><span>cartesian-position</span> <span>:reader</span> <span>star-cartesian-position</span>
                       <span>:initarg</span> <span>:cartesian-position</span>
                       <span>:documentation</span> <span>&#34;The star&#39;s Cartesian (X, Y, Z) position.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents a star from the HYG database.&#34;</span><span>))</span>

<span>(</span><span>defun</span> <span>star-name</span> <span>(</span><span>star</span><span>)</span>
  <span>&#34;A star&#39;s name. The following are tried in order: proper name, Bayer
designation, Gliese name, HIP name, HD name. If the star doesn&#39;t have any names,
returns &#39;?&#39;.&#34;</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>proper</span> <span>bayer</span> <span>gliese</span> <span>hip</span><span>)</span> <span>star</span>
    <span>(</span><span>or</span> <span>proper</span>
        <span>bayer</span>
        <span>gliese</span>
        <span>(</span><span>if</span> <span>hip</span>
            <span>(</span><span>concatenate</span> <span>&#39;string</span> <span>&#34;HIP &#34;</span> <span>hip</span><span>)</span>
            <span>&#34;?&#34;</span><span>))))</span>
</code></pre></div></div>

<p>And the parsing code is very straightforward:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>load-hyg-database</span> <span>(</span><span>pathname</span><span>)</span>
  <span>&#34;Load the HYG database from a CSV file.&#34;</span>
  <span>(</span><span>with-open-file</span> <span>(</span><span>stream</span> <span>pathname</span> <span>:direction</span> <span>:input</span><span>)</span>
    <span>;; Discard the header.</span>
    <span>(</span><span>read-line</span> <span>stream</span> <span>nil</span><span>)</span>
    <span>(</span><span>let</span> <span>((</span><span>stars</span> <span>(</span><span>make-array</span> <span>0</span> <span>:adjustable</span> <span>t</span> <span>:element-type</span> <span>&#39;star</span> <span>:fill-pointer</span> <span>0</span><span>)))</span>
      <span>(</span><span>loop</span> <span>for</span> <span>line</span> <span>=</span> <span>(</span><span>read-line</span> <span>stream</span> <span>nil</span><span>)</span>
            <span>while</span> <span>line</span>
            <span>do</span>
               <span>(</span><span>let</span> <span>((</span><span>columns</span> <span>(</span><span>uiop:split-string</span> <span>line</span> <span>:separator</span> <span>&#34;,&#34;</span><span>)))</span>
                 <span>(</span><span>let</span> <span>((</span><span>star</span> <span>(</span><span>parse-star</span> <span>columns</span><span>)))</span>
                   <span>(</span><span>vector-push-extend</span> <span>star</span> <span>stars</span><span>))))</span>
      <span>(</span><span>make-instance</span> <span>&#39;hyg-database</span> <span>:stars</span> <span>stars</span><span>))))</span>

<span>(</span><span>defun</span> <span>parse-star</span> <span>(</span><span>cells</span><span>)</span>
  <span>&#34;Parse a star from a row (a list of CSV cells).&#34;</span>
  <span>(</span><span>destructuring-bind</span> <span>(</span><span>id</span> <span>hip</span> <span>hd</span> <span>hr</span> <span>gliese</span> <span>bayer</span> <span>proper</span> <span>ra</span> <span>dec</span> <span>dist</span> <span>prma</span> <span>prdec</span> <span>rv</span> <span>mag</span> <span>absmag</span> <span>spect</span> <span>ci</span> <span>x</span> <span>y</span> <span>z</span> <span>&amp;rest</span> <span>etc</span><span>)</span> <span>cells</span>
    <span>(</span><span>declare</span> <span>(</span><span>ignore</span> <span>hr</span> <span>ra</span> <span>dec</span> <span>prma</span> <span>prdec</span> <span>rv</span> <span>mag</span> <span>absmag</span> <span>spect</span> <span>ci</span> <span>etc</span><span>))</span>
    <span>(</span><span>make-instance</span> <span>&#39;star</span>
                   <span>:id</span> <span>(</span><span>parse-integer</span> <span>id</span><span>)</span>
                   <span>:proper</span> <span>(</span><span>string-or-nil</span> <span>proper</span><span>)</span>
                   <span>:hip</span> <span>(</span><span>string-or-nil</span> <span>hip</span><span>)</span>
                   <span>:hd</span> <span>(</span><span>string-or-nil</span> <span>hd</span><span>)</span>
                   <span>:gliese</span> <span>(</span><span>string-or-nil</span> <span>gliese</span><span>)</span>
                   <span>:bayer</span> <span>(</span><span>string-or-nil</span> <span>bayer</span><span>)</span>
                   <span>:distance</span> <span>(</span><span>make-parsecs</span> <span>(</span><span>parse-number:parse-real-number</span> <span>dist</span><span>))</span>
                   <span>:cartesian-position</span> <span>(</span><span>make-instance</span> <span>&#39;cartesian-position</span>
                                                      <span>:x</span> <span>(</span><span>parse-parsecs</span> <span>x</span><span>)</span>
                                                      <span>:y</span> <span>(</span><span>parse-parsecs</span> <span>y</span><span>)</span>
                                                      <span>:z</span> <span>(</span><span>parse-parsecs</span> <span>z</span><span>)))))</span>

<span>(</span><span>defun</span> <span>string-or-nil</span> <span>(</span><span>str</span><span>)</span>
  <span>(</span><span>if</span> <span>(</span><span>string=</span> <span>str</span> <span>&#34;&#34;</span><span>)</span> <span>nil</span> <span>str</span><span>))</span>

<span>(</span><span>defun</span> <span>parse-parsecs</span> <span>(</span><span>str</span><span>)</span>
  <span>(</span><span>make-parsecs</span> <span>(</span><span>parse-number:parse-real-number</span> <span>str</span><span>)))</span>
</code></pre></div></div>

<p>And, finally, some code to find stars by name:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>find-star-by-name</span> <span>(</span><span>db</span> <span>name</span><span>)</span>
  <span>(</span><span>loop</span> <span>for</span> <span>star</span> <span>across</span> <span>(</span><span>database-stars</span> <span>db</span><span>)</span> <span>do</span>
    <span>(</span><span>when</span> <span>(</span><span>string=</span> <span>name</span> <span>(</span><span>star-name</span> <span>star</span><span>))</span>
      <span>(</span><span>return-from</span> <span>find-star-by-name</span> <span>star</span><span>)))</span>
  <span>nil</span><span>)</span>
</code></pre></div></div>

<p>Now we can query the database:</p>

<div><div><pre><code><span>CL-USER&gt;</span> <span>(</span><span>defparameter</span> <span>db</span> <span>(</span><span>load-hyg-database</span> <span>#p&#34;hygdata_v3.csv&#34;</span><span>))</span>
<span>DB</span>

<span>CL-USER&gt;</span> <span>(</span><span>defparameter</span> <span>star</span> <span>(</span><span>find-star-by-name</span> <span>db</span> <span>&#34;Gl 581&#34;</span><span>))</span>
<span>#</span><span>&lt;STAR</span> <span>Gl</span> <span>581&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>star-name</span> <span>star</span><span>)</span>
<span>&#34;Gl 581&#34;</span>

<span>CL-USER&gt;</span> <span>(</span><span>star-distance</span> <span>star</span><span>)</span>
<span>#</span><span>&lt;PARSECS</span> <span>6.2pc&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>star-cartesian-position</span> <span>star</span><span>)</span>
<span>#</span><span>&lt;CARTESIAN-POSITION</span> <span>X=-4.0pc</span> <span>Y=-4.7pc</span> <span>Z=-.8pc&gt;</span>
</code></pre></div></div>



<p>Since Gliese 581 is not on the network, we need to find the star closest to
it. First, this function returns all stars within a given radius of a position:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>find-stars-within-radius</span> <span>(</span><span>db</span> <span>pos</span> <span>radius</span><span>)</span>
  <span>&#34;Given an HYG database, a position in Cartesian coordinates, and a radius in
parsecs, return a vector of all the stars that are within the radius from that
position.&#34;</span>
  <span>(</span><span>let</span> <span>((</span><span>stars</span> <span>(</span><span>make-array</span> <span>0</span> <span>:adjustable</span> <span>t</span> <span>:element-type</span> <span>&#39;star</span> <span>:fill-pointer</span> <span>0</span><span>)))</span>
    <span>(</span><span>loop</span> <span>for</span> <span>star</span> <span>across</span> <span>(</span><span>database-stars</span> <span>db</span><span>)</span> <span>do</span>
      <span>(</span><span>let</span> <span>((</span><span>star-pos</span> <span>(</span><span>star-cartesian-position</span> <span>star</span><span>)))</span>
        <span>(</span><span>when</span> <span>(</span><span>&lt;</span> <span>(</span><span>value</span> <span>(</span><span>euclidean-distance</span> <span>pos</span> <span>star-pos</span><span>))</span>
                 <span>(</span><span>value</span> <span>radius</span><span>))</span>
          <span>(</span><span>vector-push-extend</span> <span>star</span> <span>stars</span><span>))))</span>
    <span>stars</span><span>))</span>
</code></pre></div></div>

<p>Now, the driver code. First, we load the database:</p>

<div><div><pre><code><span>(</span><span>defparameter</span> <span>+db+</span>
  <span>(</span><span>load-hyg-database</span> <span>#p&#34;hygdata_v3.csv&#34;</span><span>))</span>

<span>(</span><span>assert</span> <span>(</span><span>=</span> <span>(</span><span>star-count</span> <span>+db+</span><span>)</span> <span>119614</span><span>))</span>
</code></pre></div></div>

<p>Then we find all the stars within 3 parsecs of Gliese 581, sort them, and print
them out:</p>

<div><div><pre><code><span>(</span><span>defparameter</span> <span>+g581+</span> <span>(</span><span>find-star-by-name</span> <span>+db+</span> <span>&#34;Gl 581&#34;</span><span>))</span>

<span>(</span><span>let</span> <span>((</span><span>stars</span> <span>(</span><span>find-stars-within-radius</span> <span>+db+</span>
                                       <span>(</span><span>star-cartesian-position</span> <span>+g581+</span><span>)</span>
                                       <span>(</span><span>make-parsecs</span> <span>3.0</span><span>))))</span>
  <span>;; Sort stars by distance.</span>
  <span>(</span><span>flet</span> <span>((</span><span>dist</span> <span>(</span><span>star</span><span>)</span>
           <span>;; Distance to Gliese 581.</span>
           <span>(</span><span>star-euclidean-distance</span> <span>+g581+</span> <span>star</span><span>)))</span>
    <span>(</span><span>let</span> <span>((</span><span>sorted</span> <span>(</span><span>sort</span> <span>stars</span>
                        <span>#&#39;</span><span>(</span><span>lambda</span> <span>(</span><span>star-a</span> <span>star-b</span><span>)</span>
                            <span>(</span><span>&lt;</span> <span>(</span><span>value</span> <span>(</span><span>dist</span> <span>star-a</span><span>))</span>
                               <span>(</span><span>value</span> <span>(</span><span>dist</span> <span>star-b</span><span>)))))))</span>
      <span>;; Print the list of stars.</span>
      <span>(</span><span>format</span> <span>t</span> <span>&#34;Ten stars closest to Gliese 581:~%~%&#34;</span><span>)</span>
      <span>(</span><span>format</span> <span>t</span> <span>&#34;~8@A ~12@A~%&#34;</span> <span>&#34;Dist&#34;</span> <span>&#34;Star&#34;</span><span>)</span>
      <span>(</span><span>format</span> <span>t</span> <span>&#34;---------------------~%&#34;</span><span>)</span>
      <span>; subseq because the first star is Gl581 itself, and because we only want the top 10</span>
      <span>(</span><span>loop</span> <span>for</span> <span>star</span> <span>across</span> <span>(</span><span>subseq</span> <span>sorted</span> <span>1</span> <span>11</span><span>)</span> <span>do</span>
        <span>(</span><span>format</span> <span>t</span> <span>&#34;~6,2fly ~12@A~%&#34;</span>
                <span>(</span><span>value</span> <span>(</span><span>parsecs-to-light-years</span> <span>(</span><span>dist</span> <span>star</span><span>)))</span>
                <span>(</span><span>star-name</span> <span>star</span><span>)))</span>
      <span>(</span><span>let</span> <span>((</span><span>star</span> <span>(</span><span>elt</span> <span>sorted</span> <span>1</span><span>)))</span>
        <span>(</span><span>format</span> <span>t</span> <span>&#34;~%The star closest to Gliese 581 is ~A at ~0,2fly&#34;</span>
                <span>(</span><span>star-name</span> <span>star</span><span>)</span>
                <span>(</span><span>value</span> <span>(</span><span>parsecs-to-light-years</span> <span>(</span><span>dist</span> <span>star</span><span>))))))))</span>

<span>(</span><span>defun</span> <span>star-euclidean-distance</span> <span>(</span><span>a</span> <span>b</span><span>)</span>
  <span>&#34;The Euclidean distance between two stars in parsecs.&#34;</span>
  <span>(</span><span>euclidean-distance</span> <span>(</span><span>star-cartesian-position</span> <span>a</span><span>)</span> <span>(</span><span>star-cartesian-position</span> <span>b</span><span>)))</span>
</code></pre></div></div>

<p>The output here is:</p>

<div><div><pre><code>Ten stars closest to Gliese 581:

    Dist         Star
---------------------
  4.25ly       Gl 555
  5.15ly      Gl 570B
  5.17ly      Gl 570A
  7.43ly      NN 3877
  7.87ly    Gl 563.2A
  8.17ly      Gl 644B
  8.18ly      Gl 644C
  8.21ly       Gl 628
  8.34ly      Gl 644A
  8.83ly       Gl 643

The star closest to Gliese 581 is Gl 555 at 4.25ly
</code></pre></div></div>

<p>Now we have to find a route from Beta Pictoris to Gliese 555.</p>



<p>The shortest path between two points is the Euclidean distance. But rockets are
slow, and light is fast. And the characters, being uploads, have the option of
travelling by simply sending copies of their mind over a communications
network. Optical transceivers have a limited range, but even then, an indirect,
zig-zagging trajectory at the speed of light is faster than a straight-line
trajectory on a spacecraft moving at maybe 10% of the speed of light.</p>

<p>So: what’s the shortest path between two stars, when each hop is limited by
technology and economics to some constant distance? To find the answer, I just
implemented Dijkstra’s algorithm and ran it over the graph of stars and network
connections.</p>

<p>The <code>edge</code> and <code>graph</code> classes represent a graph where edges have a cost:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>edge</span> <span>()</span>
  <span>((</span><span>start</span> <span>:reader</span> <span>edge-start</span>
          <span>:initarg</span> <span>:start</span>
          <span>:type</span> <span>integer</span>
          <span>:documentation</span> <span>&#34;The ID of the start node.&#34;</span><span>)</span>
   <span>(</span><span>end</span> <span>:reader</span> <span>edge-end</span>
        <span>:initarg</span> <span>:end</span>
        <span>:type</span> <span>integer</span>
        <span>:documentation</span> <span>&#34;The ID of the end node.&#34;</span><span>)</span>
   <span>(</span><span>cost</span> <span>:reader</span> <span>edge-cost</span>
         <span>:initarg</span> <span>:cost</span>
         <span>:type</span> <span>number</span>
         <span>:documentation</span> <span>&#34;The cost of traversing this edge.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents an edge in a graph.&#34;</span><span>))</span>

<span>(</span><span>defmethod</span> <span>initialize-instance</span> <span>:after</span> <span>((</span><span>edge</span> <span>edge</span><span>)</span> <span>&amp;key</span><span>)</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>start</span> <span>end</span> <span>cost</span><span>)</span> <span>edge</span>
    <span>;; Check edges are not degenerate.</span>
    <span>(</span><span>when</span> <span>(</span><span>=</span> <span>start</span> <span>end</span><span>)</span>
      <span>(</span><span>error</span> <span>&#34;Degenerate edge: start and end IDs are the same: ~A&#34;</span> <span>start</span><span>))</span>
    <span>;; Check cost is non-negative.</span>
    <span>(</span><span>when</span> <span>(</span><span>&lt;</span> <span>cost</span> <span>0.0</span><span>)</span>
      <span>(</span><span>error</span> <span>&#34;Edge cost is negative: ~A&#34;</span> <span>cost</span><span>))))</span>

<span>(</span><span>defclass</span> <span>graph</span> <span>()</span>
  <span>((</span><span>vertices</span> <span>:accessor</span> <span>graph-vertices</span>
             <span>:initarg</span> <span>:vertices</span>
             <span>:type</span> <span>(</span><span>vector</span> <span>integer</span><span>)</span>
             <span>:documentation</span> <span>&#34;A vector of vertex IDs.&#34;</span><span>)</span>
   <span>(</span><span>edges</span> <span>:accessor</span> <span>graph-edges</span>
          <span>:initarg</span> <span>:edges</span>
          <span>:type</span> <span>(</span><span>vector</span> <span>edge</span><span>)</span>
          <span>:documentation</span> <span>&#34;A vector of edge objects.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents a graph.&#34;</span><span>))</span>
</code></pre></div></div>

<p>This convenience function builds a graph object from the vector of edges:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>make-graph-from-edges</span> <span>(</span><span>edges</span><span>)</span>
  <span>&#34;Construct a graph from a vector of edges.&#34;</span>
  <span>(</span><span>let</span> <span>((</span><span>vertex-table</span> <span>(</span><span>make-hash-table</span> <span>:test</span> <span>&#39;equal</span><span>))</span> <span>; table of seen IDs</span>
        <span>(</span><span>vertices</span> <span>(</span><span>make-array</span> <span>0</span> <span>:adjustable</span> <span>t</span> <span>; vertex accumulator</span>
                                <span>:element-type</span> <span>&#39;integer</span>
                                <span>:fill-pointer</span> <span>0</span><span>)))</span>
    <span>(</span><span>loop</span> <span>for</span> <span>edge</span> <span>across</span> <span>edges</span> <span>do</span>
      <span>(</span><span>with-slots</span> <span>(</span><span>start</span> <span>end</span><span>)</span> <span>edge</span>
        <span>(</span><span>unless</span> <span>(</span><span>gethash</span> <span>start</span> <span>vertex-table</span><span>)</span>
          <span>(</span><span>vector-push-extend</span> <span>start</span> <span>vertices</span><span>)</span>
          <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>start</span> <span>vertex-table</span><span>)</span> <span>t</span><span>))</span>
        <span>(</span><span>unless</span> <span>(</span><span>gethash</span> <span>end</span> <span>vertex-table</span><span>)</span>
          <span>(</span><span>vector-push-extend</span> <span>end</span> <span>vertices</span><span>)</span>
          <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>end</span> <span>vertex-table</span><span>)</span> <span>t</span><span>))))</span>
    <span>(</span><span>make-instance</span> <span>&#39;graph</span> <span>:vertices</span> <span>vertices</span>
                          <span>:edges</span> <span>edges</span><span>)))</span>
</code></pre></div></div>

<p>Given a graph whose edges have a cost, Dijkstra’s algorithm finds the cheapest
path between given start and end nodes. When cost represents distance, this is
the shortest path.</p>

<p>At the highest level: Dijkstra is breadth-first beam search on a tree rooted at
the start vertex.</p>

<p>More detailed: Dijkstra begin with the start vertex, and performs breadth-first
search by building up a tree through the neighbouring nodes. Each leaf node
knows its cost, that is, the sum of the edge costs in the path from the root to the
leaf. In normal breadth-first search, the search order is just the iteration
order of the node’s children. Dijkstra picks the next node that minimizes
cost. That’s the beam part of beam search.</p>

<p>Even more detailed, here’s the full pseudocode:</p>

<p><strong>Dijkstra’s Algorithm</strong></p>

<ol>
  <li>Inputs:
    <ol>
      <li>$G : \text{Graph}$</li>
      <li>$V_i: \text{Vertex}$: the start vertex.</li>
      <li>$V_f: \text{Vertex}$: the end vertex.</li>
    </ol>
  </li>
  <li>Let:
    <ol>
      <li>$D: \text{Map}[\text{Vertex}, \mathbb{R}]$ is the table of distances from
$V_i$ to every other vertex. Initially, we set $D[V_i] := 0$ and $D[v] :=
+\infty, \forall v \in G$ for all other vertices.</li>
      <li>$L : \text{Map}[\text{Vertex}, \text{Option}[\text{Vertex}]]$ is the previous links
table, which keeps track of the path we build while the algorithm runs. It
maps a vertex to the previous vertex in the path. Initially, $L[v] :=
\text{NIL}, \forall v \in G$.</li>
      <li>$Q : \text{Queue}[\text{Vertex}]$ is a <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a> of vertices
ordered by $D[v]$. This is initialized to contain every vertex in
$G$. This supports one operation, $\text{pop}$, which takes the vertex $v$
with the minimum value of $D[v]$, removes it from $Q$, and returns it.</li>
    </ol>
  </li>
  <li>While $Q$ is non-empty:
    <ol>
      <li>Let $u := \text{pop}(Q)$.</li>
      <li>If $u = V_f$:
        <ol>
          <li>Break out of the loop (found the target).</li>
        </ol>
      </li>
      <li>If $D[u] = +\infty$:
        <ol>
          <li>Failed: there is no path from $V_i$ to $V_f$.</li>
        </ol>
      </li>
      <li>Else:
        <ol>
          <li>For each pair $(v, c)$ in the neighbours of $u$:
            <ol>
              <li>Let $d := c + D[u]$.</li>
              <li>If $d &lt; D[v]$:
                <ol>
                  <li>$D[v] := d$.</li>
                  <li>$L[v] := u$.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>Let $P: \text{List}[\text{Vertex}] = ()$.</li>
  <li>Let $l := V_f$.</li>
  <li>While $L[l] \neq \text{NIL}$:
    <ol>
      <li>Append $l$ to $P$.</li>
      <li>$l := P[l]$.</li>
    </ol>
  </li>
  <li>Reverse $P$ and return it.</li>
</ol>

<p>In Common Lisp we can realize this as follows:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>dijkstra</span> <span>(</span><span>graph</span> <span>source</span> <span>destination</span><span>)</span>
  <span>&#34;Find a path from the source node to the destination in the given graph.
GRAPH is an instance of GRAPH. SOURCE and DESTINATION are integer vertex IDs.
Returns a vector of integer vertex IDs.&#34;</span>
  <span>;; Table of distances.</span>
  <span>(</span><span>let</span> <span>((</span><span>dist</span> <span>(</span><span>make-hash-table</span> <span>:test</span> <span>&#39;equal</span><span>)))</span>
    <span>(</span><span>loop</span> <span>for</span> <span>vertex</span> <span>across</span> <span>(</span><span>graph-vertices</span> <span>graph</span><span>)</span> <span>do</span>
      <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>vertex</span> <span>dist</span><span>)</span> <span>double-float-positive-infinity</span><span>))</span>
    <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>source</span> <span>dist</span><span>)</span> <span>0.0</span><span>)</span>
    <span>;; Table of previous nodes.</span>
    <span>(</span><span>let</span> <span>((</span><span>previous</span> <span>(</span><span>make-hash-table</span> <span>:test</span> <span>&#39;equal</span><span>)))</span>
      <span>(</span><span>loop</span> <span>for</span> <span>vertex</span> <span>across</span> <span>(</span><span>graph-vertices</span> <span>graph</span><span>)</span> <span>do</span>
        <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>vertex</span> <span>previous</span><span>)</span> <span>nil</span><span>))</span>
      <span>;; Table of neighbor costs.</span>
      <span>(</span><span>let</span> <span>((</span><span>neighbors</span> <span>(</span><span>make-neighbors</span> <span>graph</span><span>)))</span>
        <span>;; Queue.</span>
        <span>(</span><span>let</span> <span>((</span><span>q</span> <span>(</span><span>make-hash-table</span> <span>:test</span> <span>&#39;equal</span><span>)))</span>
          <span>(</span><span>loop</span> <span>for</span> <span>vertex</span> <span>across</span> <span>(</span><span>graph-vertices</span> <span>graph</span><span>)</span> <span>do</span>
            <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>vertex</span> <span>q</span><span>)</span> <span>t</span><span>))</span>
          <span>(</span><span>loop</span> <span>while</span> <span>(</span><span>&gt;</span> <span>(</span><span>hash-table-count</span> <span>q</span><span>)</span> <span>0</span><span>)</span> <span>do</span>
            <span>(</span><span>let</span> <span>((</span><span>u</span> <span>(</span><span>pop-min</span> <span>q</span> <span>dist</span><span>)))</span>
              <span>(</span><span>when</span> <span>(</span><span>or</span> <span>(</span><span>=</span> <span>u</span> <span>destination</span><span>)</span>
                        <span>(</span><span>=</span> <span>(</span><span>gethash</span> <span>u</span> <span>dist</span><span>)</span> <span>double-float-positive-infinity</span><span>))</span>
                <span>(</span><span>return</span><span>))</span>
              <span>;; Adjust neighbor distances.</span>
              <span>(</span><span>let</span> <span>((</span><span>neighbors</span> <span>(</span><span>gethash</span> <span>u</span> <span>neighbors</span><span>)))</span>
                <span>(</span><span>loop</span> <span>for</span> <span>v</span> <span>being</span> <span>the</span> <span>hash-keys</span> <span>of</span> <span>neighbors</span> <span>do</span>
                  <span>(</span><span>let</span> <span>((</span><span>cost</span> <span>(</span><span>gethash</span> <span>v</span> <span>neighbors</span><span>)))</span>
                    <span>(</span><span>let</span> <span>((</span><span>alt</span> <span>(</span><span>+</span> <span>cost</span> <span>(</span><span>gethash</span> <span>u</span> <span>dist</span><span>))))</span>
                      <span>(</span><span>when</span> <span>(</span><span>&lt;</span> <span>alt</span> <span>(</span><span>gethash</span> <span>v</span> <span>dist</span><span>))</span>
                        <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>v</span> <span>dist</span><span>)</span> <span>alt</span><span>)</span>
                        <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>v</span> <span>previous</span><span>)</span> <span>u</span><span>))))))))</span>
          <span>;; Build path</span>
          <span>(</span><span>build-path</span> <span>destination</span> <span>previous</span><span>))))))</span>
</code></pre></div></div>

<p>Using the following auxiliary functions:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>build-path</span> <span>(</span><span>destination</span> <span>previous</span><span>)</span>
  <span>&#34;Given a vertex ID, and a hash table from vertex IDs to vertex IDs,
follow the path starting from DESTINATION through the hash table, and
return a vector of vertex IDs from the last visited node to the DESTINATION.&#34;</span>
  <span>(</span><span>let</span> <span>((</span><span>path</span> <span>(</span><span>make-array</span> <span>0</span> <span>:adjustable</span> <span>t</span> <span>:element-type</span> <span>&#39;integer</span> <span>:fill-pointer</span> <span>0</span><span>)))</span>
    <span>(</span><span>let</span> <span>((</span><span>u</span> <span>destination</span><span>))</span>
      <span>(</span><span>loop</span> <span>while</span> <span>(</span><span>gethash</span> <span>u</span> <span>previous</span><span>)</span> <span>do</span>
        <span>(</span><span>vector-push-extend</span> <span>u</span> <span>path</span><span>)</span>
        <span>(</span><span>setf</span> <span>u</span> <span>(</span><span>gethash</span> <span>u</span> <span>previous</span><span>)))</span>
      <span>(</span><span>vector-push-extend</span> <span>u</span> <span>path</span><span>)</span>
      <span>(</span><span>reverse</span> <span>path</span><span>))))</span>

<span>(</span><span>defun</span> <span>make-neighbors</span> <span>(</span><span>graph</span><span>)</span>
  <span>&#34;Construct the neighbors map. This is a hash table from vertex IDs to a hash
  table of vertex IDs to costs. That is:
Map[ID, Map[ID, Float]]&#34;</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>vertices</span> <span>edges</span><span>)</span> <span>graph</span>
    <span>(</span><span>let</span> <span>((</span><span>neighbors</span> <span>(</span><span>make-hash-table</span> <span>:test</span> <span>&#39;equal</span><span>)))</span>
      <span>;; Initialize.</span>
      <span>(</span><span>loop</span> <span>for</span> <span>vertex</span> <span>across</span> <span>vertices</span> <span>do</span>
        <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>vertex</span> <span>neighbors</span><span>)</span> <span>(</span><span>make-hash-table</span> <span>:test</span> <span>&#39;equal</span><span>)))</span>
      <span>;; Fill.</span>
      <span>(</span><span>loop</span> <span>for</span> <span>edge</span> <span>across</span> <span>edges</span> <span>do</span>
        <span>(</span><span>with-slots</span> <span>(</span><span>start</span> <span>end</span> <span>cost</span><span>)</span> <span>edge</span>
          <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>end</span> <span>(</span><span>gethash</span> <span>start</span> <span>neighbors</span><span>))</span> <span>cost</span><span>)</span>
          <span>(</span><span>setf</span> <span>(</span><span>gethash</span> <span>start</span> <span>(</span><span>gethash</span> <span>end</span> <span>neighbors</span><span>))</span> <span>cost</span><span>)))</span>
      <span>;; Return</span>
      <span>neighbors</span><span>)))</span>

<span>(</span><span>defun</span> <span>pop-min</span> <span>(</span><span>queue</span> <span>dist</span><span>)</span>
  <span>&#34;The worst priority queue implementation ever written.&#34;</span>
  <span>(</span><span>let</span> <span>((</span><span>min-id</span> <span>nil</span><span>)</span>
        <span>(</span><span>min-dist</span> <span>nil</span><span>))</span>
    <span>(</span><span>loop</span> <span>for</span> <span>vertex</span> <span>being</span> <span>the</span> <span>hash-keys</span> <span>of</span> <span>queue</span> <span>do</span>
      <span>(</span><span>when</span> <span>(</span><span>or</span> <span>(</span><span>null</span> <span>min-id</span><span>)</span>
                <span>(</span><span>&lt;</span> <span>(</span><span>gethash</span> <span>vertex</span> <span>dist</span><span>)</span> <span>min-dist</span><span>))</span>
        <span>(</span><span>setf</span> <span>min-id</span> <span>vertex</span><span>)</span>
        <span>(</span><span>setf</span> <span>min-dist</span> <span>(</span><span>gethash</span> <span>vertex</span> <span>dist</span><span>))))</span>
    <span>(</span><span>assert</span> <span>(</span><span>not</span> <span>(</span><span>null</span> <span>min-id</span><span>)))</span>
    <span>(</span><span>assert</span> <span>(</span><span>not</span> <span>(</span><span>null</span> <span>min-dist</span><span>)))</span>
    <span>(</span><span>remhash</span> <span>min-id</span> <span>queue</span><span>)</span>
    <span>min-id</span><span>))</span>
</code></pre></div></div>

<p>Now we can build the star graph. This function takes a vector of stars, and
creates a graph where the nodes are star IDs, and two nodes are connected if the
distance between two stars is less than the threshold:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>make-graph</span> <span>(</span><span>stars</span> <span>dist</span><span>)</span>
  <span>&#34;Create a graph from a vector of stars. Only create edges between
stars that are less than DIST parsecs apart.&#34;</span>
  <span>(</span><span>let</span> <span>((</span><span>n</span> <span>(</span><span>length</span> <span>stars</span><span>))</span> <span>; Number of stars.</span>
        <span>(</span><span>edges</span> <span>(</span><span>make-array</span> <span>0</span> <span>:adjustable</span> <span>t</span> <span>:element-type</span> <span>&#39;edge</span> <span>:fill-pointer</span> <span>0</span><span>)))</span> <span>; edge accumulator</span>
    <span>;; Do the Cartesian product.</span>
    <span>(</span><span>loop</span> <span>for</span> <span>i</span> <span>from</span> <span>0</span> <span>to</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span> <span>do</span>
      <span>(</span><span>loop</span> <span>for</span> <span>j</span> <span>from</span> <span>(</span><span>+</span> <span>i</span> <span>1</span><span>)</span> <span>to</span> <span>(</span><span>-</span> <span>n</span> <span>1</span><span>)</span> <span>do</span>
        <span>(</span><span>let</span> <span>((</span><span>a</span> <span>(</span><span>elt</span> <span>stars</span> <span>i</span><span>))</span>
              <span>(</span><span>b</span> <span>(</span><span>elt</span> <span>stars</span> <span>j</span><span>)))</span>
          <span>(</span><span>assert</span> <span>(</span><span>not</span> <span>(</span><span>=</span> <span>(</span><span>star-id</span> <span>a</span><span>)</span> <span>(</span><span>star-id</span> <span>b</span><span>))))</span>
          <span>;; Find the distance between the two stars.</span>
          <span>(</span><span>let</span> <span>((</span><span>d</span> <span>(</span><span>euclidean-distance</span> <span>(</span><span>star-cartesian-position</span> <span>a</span><span>)</span>
                                       <span>(</span><span>star-cartesian-position</span> <span>b</span><span>))))</span>
            <span>;; If the distance is within the radius, add the edge to the graph.</span>
            <span>(</span><span>when</span> <span>(</span><span>&lt;=</span> <span>(</span><span>value</span> <span>d</span><span>)</span> <span>(</span><span>value</span> <span>dist</span><span>))</span>
              <span>(</span><span>vector-push-extend</span> <span>(</span><span>make-instance</span> <span>&#39;edge</span>
                                                 <span>:start</span> <span>(</span><span>star-id</span> <span>a</span><span>)</span>
                                                 <span>:end</span> <span>(</span><span>star-id</span> <span>b</span><span>)</span>
                                                 <span>:cost</span> <span>(</span><span>value</span> <span>d</span><span>))</span>
                                  <span>edges</span><span>))))))</span>
    <span>;; Construct the graph from the edges.</span>
    <span>(</span><span>make-graph-from-edges</span> <span>edges</span><span>)))</span>
</code></pre></div></div>

<p>The HYG database has over 100k stars, but all the stars in the story are very
close to the Sun. So we can pare down the graph considerably by dropping every
star over 70 light years (22 parsecs) from the Sun:</p>

<div><div><pre><code><span>(</span><span>defparameter</span> <span>+stars+</span>
  <span>(</span><span>remove-if</span> <span>#&#39;</span><span>(</span><span>lambda</span> <span>(</span><span>star</span><span>)</span>
                 <span>(</span><span>&gt;</span> <span>(</span><span>value</span> <span>(</span><span>star-distance</span> <span>star</span><span>))</span> <span>22.0</span><span>))</span>
             <span>(</span><span>copy-seq</span> <span>(</span><span>database-stars</span> <span>+db+</span><span>))))</span>
</code></pre></div></div>

<p>Interstellar laser links reach ~16 light years (5 parsecs).</p>

<div><div><pre><code><span>(</span><span>defparameter</span> <span>+laser-limit+</span> <span>(</span><span>make-parsecs</span> <span>5.0</span><span>))</span>
</code></pre></div></div>

<p>(This number is completely arbitrary, and arguably too high.)</p>

<p>Now we build the star graph:</p>

<div><div><pre><code><span>(</span><span>defparameter</span> <span>+graph+</span>
  <span>(</span><span>make-graph</span> <span>+stars+</span> <span>+laser-limit+</span><span>))</span>

<span>(</span><span>format</span> <span>t</span> <span>&#34;Star graph has ~A vertices and ~A edges.~%~%&#34;</span>
        <span>(</span><span>length</span> <span>(</span><span>graph-vertices</span> <span>+graph+</span><span>))</span>
        <span>(</span><span>length</span> <span>(</span><span>graph-edges</span> <span>+graph+</span><span>)))</span>
</code></pre></div></div>

<p>And run Dijkstra’s algorithm to get the shortest network route and print it out:</p>

<div><div><pre><code><span>(</span><span>defparameter</span> <span>+path+</span>
  <span>(</span><span>loop</span> <span>for</span> <span>id</span> <span>across</span> <span>(</span><span>dijkstra</span> <span>+graph+</span> <span>(</span><span>star-id</span> <span>+bpic+</span><span>)</span> <span>(</span><span>star-id</span> <span>+g555+</span><span>))</span>
        <span>collecting</span> <span>(</span><span>find</span> <span>id</span> <span>(</span><span>database-stars</span> <span>+db+</span><span>)</span> <span>:key</span> <span>#&#39;</span><span>star-id</span><span>)))</span>

<span>(</span><span>format</span> <span>t</span> <span>&#34;Network route has ~A jumps.~%~%&#34;</span> <span>(</span><span>1-</span> <span>(</span><span>length</span> <span>+path+</span><span>)))</span>

<span>;;; Print the network route.</span>

<span>(</span><span>format</span> <span>t</span> <span>&#34;~12@A ~12@A ~10@A~%&#34;</span> <span>&#34;Start&#34;</span> <span>&#34;End&#34;</span> <span>&#34;Dist&#34;</span><span>)</span>
<span>(</span><span>format</span> <span>t</span> <span>&#34;------------------------------------~%&#34;</span><span>)</span>
<span>(</span><span>loop</span> <span>for</span> <span>(</span><span>a</span> <span>b</span><span>)</span> <span>on</span> <span>+path+</span> <span>by</span> <span>#&#39;</span><span>cdr</span> <span>while</span> <span>b</span> <span>do</span>
  <span>(</span><span>format</span> <span>t</span> <span>&#34;~12@A ~12@A ~8,2fly~%&#34;</span>
          <span>(</span><span>star-name</span> <span>a</span><span>)</span>
          <span>(</span><span>star-name</span> <span>b</span><span>)</span>
          <span>(</span><span>value</span> <span>(</span><span>parsecs-to-light-years</span> <span>(</span><span>star-euclidean-distance</span> <span>a</span> <span>b</span><span>)))))</span>
</code></pre></div></div>

<p>The output is:</p>

<div><div><pre><code>Star graph has 2333 vertices and 32266 edges.

Network route has 7 jumps.

       Start          End       Dist
------------------------------------
     Bet Pic       Gl 238    14.08ly
      Gl 238    HIP 27887    12.11ly
   HIP 27887    HIP 31293    16.27ly
   HIP 31293    HIP 31292     1.10ly
   HIP 31292    HIP 58910    15.46ly
   HIP 58910    Gl 563.2A    12.99ly
   Gl 563.2A       Gl 555     6.24ly
</code></pre></div></div>

<p>Now let’s add up the distances, and compare it to the Euclidean distance:</p>

<div><div><pre><code><span>(</span><span>format</span> <span>t</span> <span>&#34;Distance from Beta Pictoris to Gliese 555: ~,2fly~%~%&#34;</span>
        <span>(</span><span>value</span> <span>(</span><span>parsecs-to-light-years</span> <span>(</span><span>star-euclidean-distance</span> <span>+bpic+</span> <span>+g555+</span><span>))))</span>

<span>(</span><span>let</span> <span>((</span><span>length</span> <span>0.0</span><span>))</span>
  <span>(</span><span>loop</span> <span>for</span> <span>(</span><span>a</span> <span>b</span><span>)</span> <span>on</span> <span>+path+</span> <span>by</span> <span>#&#39;</span><span>cdr</span> <span>while</span> <span>b</span> <span>do</span>
    <span>(</span><span>incf</span> <span>length</span> <span>(</span><span>value</span> <span>(</span><span>star-euclidean-distance</span> <span>a</span> <span>b</span><span>))))</span>
  <span>(</span><span>format</span> <span>t</span> <span>&#34;Total network route length: ~,2fly~%&#34;</span>
          <span>(</span><span>value</span> <span>(</span><span>parsecs-to-light-years</span> <span>(</span><span>make-parsecs</span> <span>length</span><span>)))))</span>
</code></pre></div></div>

<p>This outputs:</p>

<div><div><pre><code>Distance from Beta Pictoris to Gliese 555: 70.80ly

Total network route length: 78.25ly
</code></pre></div></div>

<p>A journey on the network is eight years longer than a straight-line journey, but
fusion rockets are limited to ~10% of the speed of light, so the straight-line
ballistic trajectory would take 700 years.</p>



<p>I wanted to make a map of all the stars mentioned in the story, as well as a map
showing the network route. Part to verify that the calculations were actually
correct, part to have a better understanding of the story’s geography: a picture
is easier to understand that a table of numbers.</p>

<p>The simplest way to do this—without writing my own graphics code—is to use a
3D scatter plot. There aren’t any good plotting libraries for Common Lisp, so I
used Python’s <a href="https://matplotlib.org/">matplotlib</a>, and used a CSV to transfer the data.</p>

<p>Plotting is always tedious, but happily I was able to use <a href="https://openai.com/blog/chatgpt">ChatGPT</a> to
write most of the plotting code. I asked it to generate a simple example of a
scatterplot with labeled points—that is, stars. Then I modified the
presentation a bit, changing colours and font sizes, but the static plots have
the problem that the perspective makes it hard to know where places really are.</p>

<p>So I showed ChatGPT my plotting code, and asked it to rewrite it to create an
animated version where the entire plot is rotated about the vertical axis. It
rewrote the script, preserving bit-for-bit identical output, and added animation
support. I got an inscrutable error, showed it to ChatGPT, and it suggested a
fix. I’m really happy with this approach.</p>

<p>I’ll start with the output first. Here’s the animated map of all place names
mentioned in the story<sup id="fnref:libra" role="doc-noteref"><a href="#fn:libra" rel="footnote">3</a></sup>:</p>

<video width="100%" autoplay="true" loop="true">
  <source src="/assets/content/astronomical-calculations-hard-sf-common-lisp/all-stars.mp4" type="video/mp4"/>
</video>

<p>The map uses the in-universe names: Ctesiphon is <a href="https://en.wikipedia.org/wiki/Beta_Pictoris">Beta Pictoris</a>, Wepwawet
is <a href="https://en.wikipedia.org/wiki/Gliese_555">Gliese 555</a>, Ararat is <a href="https://en.wikipedia.org/wiki/Gliese_570">Gliese 570A</a>, Tigranes is <a href="http://simbad.u-strasbg.fr/simbad/sim-id?Ident=%40790560&amp;Name=HD%20%2035650&amp;submit=submit">HD
35650</a>.</p>

<p>Zoomed in around Gliese 581 for clarity:</p>

<video width="100%" autoplay="true" loop="true">
  <source src="/assets/content/astronomical-calculations-hard-sf-common-lisp/g581-environs.mp4" type="video/mp4"/>
</video>

<p>And this is the network route from Ctesiphon to Wepwawet:</p>

<video width="100%" autoplay="true" loop="true">
  <source src="/assets/content/astronomical-calculations-hard-sf-common-lisp/route.mp4" type="video/mp4"/>
</video>

<p>To transfer data from Common Lisp to Python, I dumped the stars to different
CSVs, one for each plot, with <code>X,Y,Z,Label</code> as the columns. I won’t post the
code since it’s very ordinary.</p>

<p>The main body of the Python plotting code (sans CSV parsing, etc.) is:</p>

<div><div><pre><code><span>def</span> <span>plot_stars</span><span>(</span><span>input_path</span><span>,</span> <span>output_path</span><span>,</span> <span>route</span><span>=</span><span>False</span><span>):</span>
    <span>&#34;&#34;&#34;
    Plot the stars from the CSV in `input_path`, writes an MP4
    animated scatterplot to `output_path`.

    If `route=True`, draws lines between adjacent points.
    &#34;&#34;&#34;</span>
    <span># Data.
</span>    <span>x</span><span>:</span> <span>list</span><span>[</span><span>float</span><span>]</span>    <span>=</span> <span>[]</span>
    <span>y</span><span>:</span> <span>list</span><span>[</span><span>float</span><span>]</span>    <span>=</span> <span>[]</span>
    <span>z</span><span>:</span> <span>list</span><span>[</span><span>float</span><span>]</span>    <span>=</span> <span>[]</span>
    <span>labels</span><span>:</span> <span>list</span><span>[</span><span>str</span><span>]</span> <span>=</span> <span>[]</span>

    <span># Parse the CSV.
</span>    <span># snipped
</span>
    <span># Create a figure and a 3D Axes.
</span>    <span>dpi</span> <span>=</span> <span>600</span>
    <span>fig</span> <span>=</span> <span>plt</span><span>.</span><span>figure</span><span>(</span><span>figsize</span><span>=</span><span>(</span><span>2</span><span>,</span><span>2</span><span>),</span> <span>dpi</span><span>=</span><span>dpi</span><span>)</span>
    <span>ax</span> <span>=</span> <span>fig</span><span>.</span><span>add_subplot</span><span>(</span><span>111</span><span>,</span> <span>projection</span><span>=</span><span>&#39;3d&#39;</span><span>)</span>

    <span># Create the scatterplot.
</span>    <span>scatter</span> <span>=</span> <span>ax</span><span>.</span><span>scatter</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>,</span> <span>c</span><span>=</span><span>&#39;b&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;.&#39;</span><span>,</span> <span>s</span><span>=</span><span>1</span><span>,</span> <span>alpha</span><span>=</span><span>0.5</span><span>)</span>

    <span># Add labels to each star.
</span>    <span>text</span> <span>=</span> <span>[</span>
        <span>ax</span><span>.</span><span>text</span><span>(</span><span>x</span><span>[</span><span>i</span><span>],</span> <span>y</span><span>[</span><span>i</span><span>],</span> <span>z</span><span>[</span><span>i</span><span>]</span> <span>+</span> <span>0.1</span><span>,</span> <span>label</span><span>,</span> <span>fontsize</span><span>=</span><span>2</span><span>)</span> <span>for</span> <span>i</span><span>,</span> <span>label</span> <span>in</span> <span>enumerate</span><span>(</span><span>labels</span><span>)</span>
    <span>]</span>

    <span># Draw the impulses.
</span>    <span>impulses</span> <span>=</span> <span>[</span>
        <span>ax</span><span>.</span><span>plot</span><span>([</span><span>x</span><span>[</span><span>i</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>]],</span> <span>[</span><span>y</span><span>[</span><span>i</span><span>],</span> <span>y</span><span>[</span><span>i</span><span>]],</span> <span>[</span><span>0</span><span>,</span> <span>z</span><span>[</span><span>i</span><span>]],</span> <span>&#39;:&#39;</span><span>,</span> <span>c</span><span>=</span><span>&#39;k&#39;</span><span>,</span> <span>linewidth</span><span>=</span><span>0.2</span><span>)</span> <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>x</span><span>))</span>
    <span>]</span>

    <span># Are we plotting a route? If so, draw the lines between the stars.
</span>    <span>if</span> <span>route</span><span>:</span>
        <span>lines</span> <span>=</span> <span>[</span>
            <span>ax</span><span>.</span><span>plot</span><span>(</span>
                <span>[</span><span>x</span><span>[</span><span>i</span><span>],</span> <span>x</span><span>[</span><span>i</span><span>+</span><span>1</span><span>]],</span>
                <span>[</span><span>y</span><span>[</span><span>i</span><span>],</span> <span>y</span><span>[</span><span>i</span><span>+</span><span>1</span><span>]],</span>
                <span>[</span><span>z</span><span>[</span><span>i</span><span>],</span> <span>z</span><span>[</span><span>i</span><span>+</span><span>1</span><span>]],</span>
                <span>color</span><span>=</span><span>&#39;r&#39;</span><span>,</span>
                <span>linewidth</span><span>=</span><span>0.1</span>
            <span>)</span>
            <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>labels</span><span>)</span><span>-</span><span>1</span><span>)</span>
        <span>]</span>
    <span>else</span><span>:</span>
        <span>lines</span> <span>=</span> <span>[]</span>

    <span># Plot the origin plane.
</span>    <span>GAP</span> <span>=</span> <span>1</span>
    <span>X</span><span>,</span> <span>Y</span> <span>=</span> <span>np</span><span>.</span><span>meshgrid</span><span>(</span>
        <span>np</span><span>.</span><span>linspace</span><span>(</span><span>min</span><span>(</span><span>x</span><span>)</span> <span>-</span> <span>GAP</span><span>,</span> <span>max</span><span>(</span><span>x</span><span>)</span> <span>+</span> <span>GAP</span><span>,</span> <span>10</span><span>),</span>
        <span>np</span><span>.</span><span>linspace</span><span>(</span><span>min</span><span>(</span><span>y</span><span>)</span> <span>-</span> <span>GAP</span><span>,</span> <span>max</span><span>(</span><span>y</span><span>)</span> <span>+</span> <span>GAP</span><span>,</span> <span>10</span><span>)</span>
    <span>)</span>
    <span>Z</span> <span>=</span> <span>np</span><span>.</span><span>zeros_like</span><span>(</span><span>X</span><span>)</span>
    <span>origin_plane</span> <span>=</span> <span>ax</span><span>.</span><span>plot_wireframe</span><span>(</span><span>X</span><span>,</span> <span>Y</span><span>,</span> <span>Z</span><span>,</span> <span>rstride</span><span>=</span><span>1</span><span>,</span> <span>cstride</span><span>=</span><span>1</span><span>,</span> <span>linewidths</span><span>=</span><span>0.1</span><span>)</span>

    <span># Hide the axes and grid planes.
</span>    <span>plt</span><span>.</span><span>axis</span><span>(</span><span>&#34;off&#34;</span><span>)</span>

    <span># Define the animation function.
</span>    <span>def</span> <span>animate</span><span>(</span><span>i</span><span>):</span>
        <span>ax</span><span>.</span><span>view_init</span><span>(</span><span>elev</span><span>=</span><span>30</span><span>,</span> <span>azim</span><span>=</span><span>i</span><span>)</span>

    <span># Create the animation object.
</span>    <span>anim</span> <span>=</span> <span>animation</span><span>.</span><span>FuncAnimation</span><span>(</span><span>fig</span><span>,</span> <span>animate</span><span>,</span> <span>frames</span><span>=</span><span>360</span><span>,</span> <span>interval</span><span>=</span><span>20</span><span>,</span> <span>blit</span><span>=</span><span>False</span><span>)</span>

    <span># Save the animation as an MP4 file.
</span>    <span>anim</span><span>.</span><span>save</span><span>(</span><span>output_path</span><span>,</span> <span>fps</span><span>=</span><span>30</span><span>,</span> <span>extra_args</span><span>=</span><span>[</span><span>&#39;-vcodec&#39;</span><span>,</span> <span>&#39;libx264&#39;</span><span>],</span> <span>dpi</span><span>=</span><span>dpi</span><span>)</span>
</code></pre></div></div>



<p>All of this had very little consequence to the story: a few throwaway
sentences. But I see it as a matter of respect for the audience. If it’s hard
SF, it’s hard SF.</p>



<p>This section describes to how accurately represent positions in equatorial
coordinates, and how to convert them to Cartesian coordinates for ease of use.</p>

<p>None of this is strictly necessary, because the HYG database has star positions
both in equatorial and Cartesian coordinates, but I had to solve this problem,
for two reasons. The first is that software is crystallized and verified
understanding: you know you understand something when you can write a computer
program that concretizes that understanding. The second is that when software
solves a problem, it solves it in perpetuity.</p>

<h2 id="representation">Representation</h2>

<p>A position in equatorial coordinates is a right ascension (RA, an angle, in
hours-minutes-seconds), a declination (DEC, an angle, in
degrees-minutes-seconds), and a distance from the Sun in parsecs.</p>

<p>The <code>equatorial-position</code> class represents this:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>equatorial-position</span> <span>()</span>
  <span>((</span><span>right-ascension</span> <span>:reader</span> <span>right-ascension</span>
                    <span>:initarg</span> <span>:right-ascension</span>
                    <span>:type</span> <span>hms-degrees</span>
                    <span>:documentation</span> <span>&#34;The right ascension in HMS.&#34;</span><span>)</span>
   <span>(</span><span>declination</span> <span>:reader</span> <span>declination</span>
                <span>:initarg</span> <span>:declination</span>
                <span>:type</span> <span>dms-degrees</span>
                <span>:documentation</span> <span>&#34;The declination in DMS.&#34;</span><span>)</span>
   <span>(</span><span>distance</span> <span>:reader</span> <span>distance</span>
             <span>:initarg</span> <span>:distance</span>
             <span>:type</span> <span>parsecs</span>
             <span>:documentation</span> <span>&#34;The distance in parsecs.&#34;</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;A position in equatorial (RA, DEC, DIST) coordinates.&#34;</span><span>))</span>
</code></pre></div></div>

<p>We could convert the right ascension and declination to angles eagerly, but I’d
rather represent things explicitly, and add conversion functions as needed.</p>

<p>We have three representations of angles: decimal degrees, hours-minutes-seconds,
and degrees-minutes-seconds. Each corresponds to a CLOS class:</p>

<div><div><pre><code><span>(</span><span>defclass</span> <span>decimal-degrees</span> <span>()</span>
  <span>((</span><span>value</span> <span>:reader</span> <span>value</span>
          <span>:initarg</span> <span>:value</span>
          <span>:type</span> <span>real</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents an angle in decimal degrees.&#34;</span><span>))</span>

<span>(</span><span>defclass</span> <span>hms-degrees</span> <span>()</span>
  <span>((</span><span>hours</span> <span>:reader</span> <span>hours</span>
          <span>:initarg</span> <span>:hours</span>
          <span>:type</span> <span>real</span><span>)</span>
   <span>(</span><span>minutes</span> <span>:reader</span> <span>minutes</span>
            <span>:initarg</span> <span>:minutes</span>
            <span>:type</span> <span>real</span><span>)</span>
   <span>(</span><span>seconds</span> <span>:reader</span> <span>seconds</span>
            <span>:initarg</span> <span>:seconds</span>
            <span>:type</span> <span>real</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents an angle in HMS (hours-minutes-seconds) format.&#34;</span><span>))</span>

<span>(</span><span>defclass</span> <span>dms-degrees</span> <span>()</span>
  <span>((</span><span>degrees</span> <span>:reader</span> <span>degrees</span>
            <span>:initarg</span> <span>:degrees</span>
            <span>:type</span> <span>real</span><span>)</span>
   <span>(</span><span>minutes</span> <span>:reader</span> <span>minutes</span>
            <span>:initarg</span> <span>:minutes</span>
            <span>:type</span> <span>real</span><span>)</span>
   <span>(</span><span>seconds</span> <span>:reader</span> <span>seconds</span>
            <span>:initarg</span> <span>:seconds</span>
            <span>:type</span> <span>real</span><span>))</span>
  <span>(</span><span>:documentation</span> <span>&#34;Represents an angle in DMS (degrees-minutes-seconds) format.&#34;</span><span>))</span>
</code></pre></div></div>

<p>We use <code>initialize-instance</code> methods to verify that all the values are in
range<sup id="fnref:checking" role="doc-noteref"><a href="#fn:checking" rel="footnote">4</a></sup>:</p>

<div><div><pre><code><span>(</span><span>defmethod</span> <span>initialize-instance</span> <span>:after</span> <span>((</span><span>d</span> <span>decimal-degrees</span><span>)</span> <span>&amp;key</span><span>)</span>
  <span>(</span><span>let</span> <span>((</span><span>d</span> <span>(</span><span>value</span> <span>d</span><span>)))</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;</span> <span>d</span> <span>-180.0</span><span>)</span> <span>(</span><span>&lt;=</span> <span>d</span> <span>180.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Value out of range for decimal degrees: ~A&#34;</span> <span>d</span><span>))))</span>

<span>(</span><span>defmethod</span> <span>initialize-instance</span> <span>:after</span> <span>((</span><span>angle</span> <span>hms-degrees</span><span>)</span> <span>&amp;key</span><span>)</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>hours</span> <span>minutes</span> <span>seconds</span><span>)</span> <span>angle</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;=</span> <span>hours</span> <span>0.0</span><span>)</span> <span>(</span><span>&lt;</span> <span>hours</span> <span>24.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Invalid value for hours in hms-degrees: ~a&#34;</span> <span>hours</span><span>))</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;=</span> <span>minutes</span> <span>0.0</span><span>)</span> <span>(</span><span>&lt;</span> <span>minutes</span> <span>60.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Invalid value for minutes in hms-degrees: ~a&#34;</span> <span>minutes</span><span>))</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;=</span> <span>seconds</span> <span>0.0</span><span>)</span> <span>(</span><span>&lt;</span> <span>seconds</span> <span>60.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Invalid value for seconds in hms-degrees: ~a&#34;</span> <span>seconds</span><span>))))</span>

<span>(</span><span>defmethod</span> <span>initialize-instance</span> <span>:after</span> <span>((</span><span>angle</span> <span>dms-degrees</span><span>)</span> <span>&amp;key</span><span>)</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>degrees</span> <span>minutes</span> <span>seconds</span><span>)</span> <span>angle</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;</span> <span>degrees</span> <span>-90.0</span><span>)</span> <span>(</span><span>&lt;=</span> <span>degrees</span> <span>90.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Invalid value for degrees in hms-degrees: ~a&#34;</span> <span>degrees</span><span>))</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;=</span> <span>minutes</span> <span>0.0</span><span>)</span> <span>(</span><span>&lt;</span> <span>minutes</span> <span>60.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Invalid value for minutes in hms-degrees: ~a&#34;</span> <span>minutes</span><span>))</span>
    <span>(</span><span>unless</span> <span>(</span><span>and</span> <span>(</span><span>&gt;=</span> <span>seconds</span> <span>0.0</span><span>)</span> <span>(</span><span>&lt;</span> <span>seconds</span> <span>60.0</span><span>))</span>
      <span>(</span><span>error</span> <span>&#34;Invalid value for seconds in hms-degrees: ~a&#34;</span> <span>seconds</span><span>))))</span>
</code></pre></div></div>

<h2 id="angle-conversion">Angle Conversion</h2>

<p>To convert from HMS and DMS to decimal, we have these functions:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>hms-to-decimal</span> <span>(</span><span>hms</span><span>)</span>
  <span>&#34;Convert an HMS (hours-minutes-seconds) angle to decimal degrees.&#34;</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>hours</span> <span>minutes</span> <span>seconds</span><span>)</span> <span>hms</span>
    <span>(</span><span>let</span> <span>((</span><span>d</span> <span>(</span><span>+</span> <span>(</span><span>*</span> <span>15.0</span> <span>hours</span><span>)</span>
                <span>(</span><span>/</span> <span>(</span><span>*</span> <span>15.0</span> <span>minutes</span><span>)</span> <span>60.0</span><span>)</span>
                <span>(</span><span>/</span> <span>(</span><span>*</span> <span>15.0</span> <span>seconds</span><span>)</span> <span>3600.0</span><span>))))</span>
      <span>(</span><span>make-instance</span> <span>&#39;decimal-degrees</span> <span>:value</span> <span>d</span><span>))))</span>

<span>(</span><span>defun</span> <span>dms-to-decimal</span> <span>(</span><span>dms</span><span>)</span>
  <span>&#34;Convert a DMS (degrees-minutes-seconds) angle to decimal degrees.&#34;</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>degrees</span> <span>minutes</span> <span>seconds</span><span>)</span> <span>dms</span>
    <span>(</span><span>let</span> <span>((</span><span>d</span> <span>(</span><span>*</span> <span>(</span><span>sign</span> <span>degrees</span><span>)</span>
                <span>(</span><span>+</span> <span>(</span><span>abs</span> <span>degrees</span><span>)</span>
                   <span>(</span><span>/</span> <span>minutes</span> <span>60.0</span><span>)</span>
                   <span>(</span><span>/</span> <span>seconds</span> <span>3600.0</span><span>)))))</span>
      <span>(</span><span>make-instance</span> <span>&#39;decimal-degrees</span> <span>:value</span> <span>d</span><span>))))</span>

<span>(</span><span>defun</span> <span>sign</span> <span>(</span><span>x</span><span>)</span>
  <span>(</span><span>cond</span> <span>((</span><span>&lt;</span> <span>x</span> <span>0.0</span><span>)</span>
         <span>-1</span><span>)</span>
        <span>((</span><span>=</span> <span>x</span> <span>0.0</span><span>)</span>
         <span>0</span><span>)</span>
        <span>(</span><span>t</span>
         <span>1.0</span><span>)))</span>
</code></pre></div></div>

<p>And we can use these like so:</p>

<div><div><pre><code><span>CL-USER&gt;</span> <span>(</span><span>make-instance</span> <span>&#39;hms-degrees</span> <span>:hours</span> <span>7.2</span> <span>:minutes</span> <span>2.24</span> <span>:seconds</span> <span>1.42</span><span>)</span>
<span>#</span><span>&lt;HMS-DEGREES</span> <span>7.2h2.2m1.4s&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>hms-to-decimal</span> <span>*</span><span>)</span>
<span>#</span><span>&lt;DECIMAL-DEGREES</span> <span>108.6</span><span>°</span><span>&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>make-instance</span> <span>&#39;dms-degrees</span> <span>:degrees</span> <span>51.2</span> <span>:minutes</span> <span>2.24</span> <span>:seconds</span> <span>1.42</span><span>)</span>
<span>#</span><span>&lt;DMS-DEGREES</span> <span>51.2</span><span>°</span><span>2.2m1.4s&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>dms-to-decimal</span> <span>*</span><span>)</span>
<span>#</span><span>&lt;DECIMAL-DEGREES</span> <span>51.2</span><span>°</span><span>&gt;</span>
</code></pre></div></div>

<p>Implementing <code>decimal-to-hms</code> and <code>decimal-to-dms</code> is left as an exercise to the
reader.</p>

<h2 id="equatorial-to-cartesian">Equatorial to Cartesian</h2>

<p>I got the formula from the <a href="http://www.projectrho.com/public_html/starmaps/trigonometry.php">Atomic Rockets</a> website:</p>

<div><div><pre><code><span>(</span><span>defun</span> <span>equatorial-to-cartesian</span> <span>(</span><span>pos</span><span>)</span>
  <span>&#34;Convert a position from equatorial to cartesian coordinates.&#34;</span>
  <span>(</span><span>with-slots</span> <span>(</span><span>right-ascension</span> <span>declination</span> <span>distance</span><span>)</span> <span>pos</span>
    <span>(</span><span>let</span> <span>((</span><span>φ</span> <span>(</span><span>value</span> <span>(</span><span>hms-to-decimal</span> <span>right-ascension</span><span>)))</span>
          <span>(</span><span>θ</span> <span>(</span><span>value</span> <span>(</span><span>dms-to-decimal</span> <span>declination</span><span>)))</span>
          <span>(</span><span>ρ</span> <span>(</span><span>value</span> <span>distance</span><span>)))</span>
      <span>(</span><span>let</span> <span>((</span><span>rvect</span> <span>(</span><span>*</span> <span>ρ</span> <span>(</span><span>cosr</span> <span>θ</span><span>))))</span>
        <span>(</span><span>let</span> <span>((</span><span>x</span> <span>(</span><span>*</span> <span>rvect</span> <span>(</span><span>cosr</span> <span>φ</span><span>)))</span>
              <span>(</span><span>y</span> <span>(</span><span>*</span> <span>rvect</span> <span>(</span><span>sinr</span> <span>φ</span><span>)))</span>
              <span>(</span><span>z</span> <span>(</span><span>*</span> <span>ρ</span>     <span>(</span><span>sinr</span> <span>θ</span><span>))))</span>
          <span>(</span><span>make-instance</span> <span>&#39;cartesian-position</span>
                         <span>:x</span> <span>(</span><span>make-parsecs</span> <span>x</span><span>)</span>
                         <span>:y</span> <span>(</span><span>make-parsecs</span> <span>y</span><span>)</span>
                         <span>:z</span> <span>(</span><span>make-parsecs</span> <span>z</span><span>)))))))</span>

<span>(</span><span>defun</span> <span>rad</span> <span>(</span><span>x</span><span>)</span>
  <span>(</span><span>*</span> <span>x</span> <span>0.0174532925</span><span>))</span>

<span>(</span><span>defun</span> <span>sinr</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>sin</span> <span>(</span><span>rad</span> <span>x</span><span>)))</span>
<span>(</span><span>defun</span> <span>cosr</span> <span>(</span><span>x</span><span>)</span> <span>(</span><span>cos</span> <span>(</span><span>rad</span> <span>x</span><span>)))</span>
</code></pre></div></div>

<p>We can use this like so:</p>

<div><div><pre><code><span>CL-USER&gt;</span> <span>(</span><span>defparameter</span> <span>tau-ceti</span>
  <span>(</span><span>make-instance</span> <span>&#39;equatorial-position</span>
                 <span>:right-ascension</span> <span>(</span><span>make-instance</span> <span>&#39;hms-degrees</span> <span>:hours</span> <span>1</span> <span>:minutes</span> <span>41</span> <span>:seconds</span> <span>45</span><span>)</span>
                 <span>:declination</span> <span>(</span><span>make-instance</span> <span>&#39;dms-degrees</span> <span>:degrees</span> <span>-16.0</span> <span>:minutes</span> <span>12.0</span> <span>:seconds</span> <span>0.0</span><span>)</span>
                 <span>:distance</span> <span>(</span><span>make-parsecs</span> <span>3.61</span><span>)))</span>
<span>#</span><span>&lt;EQUATORIAL-POSITION</span> <span>RA=1.0h41.0m45.0s</span> <span>DEC=-16.0</span><span>°</span><span>12.0m.0s</span> <span>D=3.6pc&gt;</span>

<span>CL-USER&gt;</span> <span>(</span><span>equatorial-to-cartesian</span> <span>tau-ceti</span><span>)</span>
<span>#</span><span>&lt;CARTESIAN-POSITION</span> <span>X=3.1pc</span> <span>Y=1.5pc</span> <span>Z=-1.0pc&gt;</span>
</code></pre></div></div>





  </article></div>
  </body>
</html>
