<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/saulshanabrook/saulshanabrook/discussions/36">Original</a>
    <h1>Bad idea: Compiling away equality saturation</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
			

<!-- This is from https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html. -->
<!-- The `type=module` is required if we want to use the "import" statement. -->


<p>Once upon a time I was given the following problem for a technical programming interview:</p>
<blockquote>
<p>Write a function <code>draw_circle(r)</code> that draws a circle with radius <code>r</code>. Use the given method <code>draw_pixel(x, y)</code> which takes a 2-dimensional point <code>(x, y)</code> and colors it in on the computer screen.</p>
</blockquote>
<p>For the solution, you can either collect all pixels (tuples) of <span>\(x\)</span> and <span>\(y\)</span> coordinate pairs, or just call <code>draw_pixel()</code> on them during the “search” for those pixels that must be filled in.</p>
<p>This post goes over several solutions, ultimately arriving at Bresenham’s algorithm.
The content of this post is merely a distillation of Section 3.3 from the book “Computer Graphics: Principles and Practice (1996)”.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>
The authors of the book state that their implementation results in code “essentially the same as that specified in patent 4,371,933 [a.k.a. Bresenham’s algorithm].”<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>I’ve gone all out and converted the “reference” implementations found in the book and translated them into Rust and Python.
The Python was written first, and I used a text-based drawing system to test the correctness.
However I became dissatisfied with the non-square “aspect ratio” of most monospaced fonts out there, which distorted the circles to look more like ellipses.
To fix this, I decided to port the Python code to Rust, and then target WASM so that I can use it to draw on the HTML5 <code>&lt;canvas&gt;</code> elements (and to eliminate the “aspect ratio” problem).
All of the drawings in this document are powered by the Rust code.</p>

<h2 id="drawable-canvas">Drawable canvas</h2>
<p>Before we start, let’s define the drawable surface (canvas) of pixels for this problem.
The pixels are arranged in a 2-dimensional grid.
The important thing here is the grid or coordinate system, with the pixel at the center of the grid having the traditional <code>(0, 0)</code> Cartesian coordinate.</p>
<p>Below is a sample grid to give you a sense of what this will look like.
There is a central <code>(0, 0)</code> origin pixel, and 15 pixels to the north, south, east, and west, and everything in-between.
Pixels that lie on interesting points of symmetry are highlighted in green.</p>
<canvas id="blank__14__20"></canvas>

<h2 id="mathematical-definitions">Mathematical definitions</h2>
<p>The exact definition of a circle (given infinite precision, as on the traditional Cartesian plane) centered at the origin is</p>
<p><span>\[
\begin{equation} \label{eq:circle}
x^2 + y^2 = r^2.
\end{equation}
\]</span></p>
<p>This resembles the Pythagorean Theorem</p>
<p><span>\[
a^2 + b^2 = c^2,
\]</span></p>
<p>for any right-angled triangle with sides <span>\(a\)</span> and <span>\(b\)</span> and hypotenuse <span>\(c\)</span>.
The resemblance is not a coincidence, because an infinite number of such triangles exists within the top right quadrant of the plane (that is, Quadrant I<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>, or the part of the plane such that <span>\(x \geq 0\)</span> and <span>\(y \geq 0\)</span>); in Quadrant I, for all points <span>\((x,y)\)</span> that make up this portion (or arc) of the circle, their radii is the same as the hypotenuses of these triangles (whose sides are <span>\(x\)</span> and <span>\(y\)</span>).
Later in this post, this will become relevant again when we discuss <a href="https://en.wikipedia.org/wiki/Pythagorean_triple">Pythagorean Triples</a>.</p>
<p>Anyway, solving for <span>\(y\)</span> in Equation <span>\(\ref{eq:circle}\)</span> gives</p>
<p><span>\[
\begin{equation} \label{eq:circle-y}
y = \pm\sqrt{r^2 - x^2}
\end{equation}
\]</span></p>
<p>to get 2 functions for the top-half and bottom-half of the circle (that’s what the <span>\(\pm\)</span> symbol means).
Consider the function <span>\(y = x\)</span>.
This function has slope 1 and is a diagonal line where all values of <span>\(x = y\)</span>.
Now consider how this line intersects the quarter-arc of the circle in Quadrant I.
This intersection point evenly divides the arc into 2 halves, and is where</p>
<p><span>\[
x = y = \tfrac{r}{\sqrt{2}},
\]</span></p>
<p>or simply the point</p>
<p><span>\[
\begin{equation}
(\tfrac{r}{\sqrt{2}}, \tfrac{r}{\sqrt{2}}).
\end{equation}
\]</span></p>
<p>This is because if <span>\(x = y\)</span>, then Equation <span>\(\ref{eq:circle}\)</span> becomes</p>
<p><span>\[
\begin{align}
x^2 + y^2 &amp;= r^2
\\
x^2 + x^2 &amp;= r^2
\\
2x^2 &amp;= r^2
\\
\tfrac{2x^2}{2} &amp;= \tfrac{r^2}{2}
\\
x^2 &amp;= \tfrac{r^2}{2}
\\
\sqrt{x^2} &amp;= \tfrac{\sqrt{r^2}}{\sqrt{2}}
\\
x &amp;= \tfrac{r}{\sqrt{2}}. \label{eq:arc-intersection}
\end{align}
\]</span></p>
<p>This is not that interesting for purposes of the algorithms in this post, but is something that is glossed over in the book.</p>
<h2 id="symmetry">Symmetry</h2>
<p>Because of symmetry, we can mirror the solution <span>\((x,y)\)</span> pairs we get in Quadrant I into the other quadrants.
This gives us 4-way symmetry because there are 4 quadrants.</p>
<div>
<div id="cb1" data-startfrom="164"><pre><code><span id="cb1-164"><a href="#cb1-164"></a><span>def</span> mirror_points_4(x, y):</span>
<span id="cb1-165"><a href="#cb1-165"></a>    <span>&#34;&#34;&#34; Return 4-way symmetry of points. &#34;&#34;&#34;</span></span>
<span id="cb1-166"><a href="#cb1-166"></a>    <span>return</span> [( x,  y),</span>
<span id="cb1-167"><a href="#cb1-167"></a>            (<span>-</span>x,  y),</span>
<span id="cb1-168"><a href="#cb1-168"></a>            ( x, <span>-</span>y),</span>
<span id="cb1-169"><a href="#cb1-169"></a>            (<span>-</span>x, <span>-</span>y)]</span></code></pre></div>

</div>
<p>Note, however, that there is actually 8-way symmetry at hand because (1) we can swap <span>\(x\)</span> and <span>\(y\)</span>, and (2) because of the way we can distribute the negative sign:</p>
<table>
<thead>
<tr>
<th>#</th>
<th>Coordinate</th>
<th>Quadrant</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>( x, y)</code></td>
<td>I</td>
</tr>
<tr>
<td>2</td>
<td><code>( y, x)</code></td>
<td>I</td>
</tr>
<tr>
<td>3</td>
<td><code>(-x, y)</code></td>
<td>II</td>
</tr>
<tr>
<td>4</td>
<td><code>(-y, x)</code></td>
<td>II</td>
</tr>
<tr>
<td>6</td>
<td><code>(-x,-y)</code></td>
<td>III</td>
</tr>
<tr>
<td>5</td>
<td><code>(-y,-x)</code></td>
<td>III</td>
</tr>
<tr>
<td>7</td>
<td><code>( x,-y)</code></td>
<td>IV</td>
</tr>
<tr>
<td>8</td>
<td><code>( y,-x)</code></td>
<td>IV</td>
</tr>
</tbody>
</table>
<div>
<div id="cb2" data-startfrom="172"><pre><code><span id="cb2-172"><a href="#cb2-172"></a><span>def</span> mirror_points_8(x, y):</span>
<span id="cb2-173"><a href="#cb2-173"></a>    <span>&#34;&#34;&#34; Return 8-way symmetry of points. &#34;&#34;&#34;</span></span>
<span id="cb2-174"><a href="#cb2-174"></a>    <span>return</span> [( x,  y),</span>
<span id="cb2-175"><a href="#cb2-175"></a>            ( y,  x),</span>
<span id="cb2-176"><a href="#cb2-176"></a>            (<span>-</span>x,  y),</span>
<span id="cb2-177"><a href="#cb2-177"></a>            (<span>-</span>y,  x),</span>
<span id="cb2-178"><a href="#cb2-178"></a>            ( x, <span>-</span>y),</span>
<span id="cb2-179"><a href="#cb2-179"></a>            ( y, <span>-</span>x),</span>
<span id="cb2-180"><a href="#cb2-180"></a>            (<span>-</span>x, <span>-</span>y),</span>
<span id="cb2-181"><a href="#cb2-181"></a>            (<span>-</span>y, <span>-</span>x)]</span></code></pre></div>

</div>
<p>Fun fact: the exact point at which <span>\(x\)</span> and <span>\(y\)</span> get “swapped” in Quadrant I is when <span>\(x = y = \tfrac{r}{\sqrt{2}}\)</span> (Equation <span>\(\ref{eq:arc-intersection}\)</span>).</p>

<p>When in doubt, brute force is always a great answer, because at least it gets you started on something that works given enough time and/or memory.<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>
Because we already have clear mathematical definitions, we can just translate them (albeit mechanically) to code.</p>
<div>
<div id="cb3" data-startfrom="7"><pre><code><span id="cb3-7"><a href="#cb3-7"></a><span>def</span> get_circle_points_naive_4(r):</span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span>&#34;&#34;&#34; Draw a circle by pairing up each Y value with an X value that lie on a</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span>    circle with radius &#39;r&#39;. This has a bug because some Y values get skipped.</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span>    Can you see why?</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    points <span>=</span> []</span>
<span id="cb3-13"><a href="#cb3-13"></a>    <span>for</span> x <span>in</span> <span>range</span>(r <span>+</span> <span>1</span>):</span>
<span id="cb3-14"><a href="#cb3-14"></a>        <span># isqrt() gets the integer square root.</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>        y <span>=</span> isqrt((r <span>*</span> r) <span>-</span> (x <span>*</span> x))</span>
<span id="cb3-16"><a href="#cb3-16"></a>        points.extend(mirror_points_4(x, y))</span>
<span id="cb3-17"><a href="#cb3-17"></a>    <span>return</span> points</span></code></pre></div>

</div>
<p><code>get_circle_points_naive_4()</code> is the simplest translation, although there is a bug, which is obvious when we visualize it (in this case, for <span>\(r = 15\)</span>):</p>
<canvas id="naive_4__15__20"></canvas>

<p>The <code>get_circle_points_naive_4()</code> is based on Equation <span>\(\ref{eq:circle-y}\)</span>.
We iterate <span>\(x\)</span> from <span>\(0\)</span> to <span>\(r\)</span> <a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>, and at each <span>\(x\)</span> try to find the best value for <span>\(y\)</span>.
The problem is that we’re only solving for 1 <span>\(y\)</span> value for every <span>\(x\)</span> value we increment by.
As we get near the left and right sides of the circle, we need to calculate more than just 1 <span>\(y\)</span> value for every <span>\(x\)</span>.<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>.</p>
<p>The <code>get_circle_points_naive_8()</code> function gets around this <span>\(y\)</span>-skip bug by invoking 8-way symmetry instead:</p>
<div>
<div id="cb4" data-startfrom="20"><pre><code><span id="cb4-20"><a href="#cb4-20"></a><span>def</span> get_circle_points_naive_8(r):</span>
<span id="cb4-21"><a href="#cb4-21"></a>    <span>&#34;&#34;&#34; Better than get_circle_points_naive_4, but wastes CPU cycles because</span></span>
<span id="cb4-22"><a href="#cb4-22"></a><span>    the 8-way symmetry overcorrects and we draw some pixels more than once.</span></span>
<span id="cb4-23"><a href="#cb4-23"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>    points <span>=</span> []</span>
<span id="cb4-25"><a href="#cb4-25"></a>    <span>for</span> x <span>in</span> <span>range</span>(r <span>+</span> <span>1</span>):</span>
<span id="cb4-26"><a href="#cb4-26"></a>        y <span>=</span> isqrt((r <span>*</span> r) <span>-</span> (x <span>*</span> x))</span>
<span id="cb4-27"><a href="#cb4-27"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb4-28"><a href="#cb4-28"></a>    <span>return</span> points</span></code></pre></div>

</div>
<canvas id="naive_8__15__20"></canvas>

<p>However the downside is that it results in multiple points that will be drawn 2 times, wasting CPU cycles.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>
To be more precise, all points around the gappy area in Quadrant I are redundant because that part of the arc is already mirrored nicely by the contiguous points from <span>\(x = 0\)</span> to <span>\(x = y\)</span>.</p>
<p>The <code>get_circle_points_naive_8_faster()</code> function avoids drawing the gappy areas by just breaking the loop when <span>\(x &gt; y\)</span>, but is otherwise the same:</p>
<div>
<div id="cb5" data-startfrom="31"><pre><code><span id="cb5-31"><a href="#cb5-31"></a><span>def</span> get_circle_points_naive_8_faster(r):</span>
<span id="cb5-32"><a href="#cb5-32"></a>    <span>&#34;&#34;&#34; Slightly faster than get_circle_points_naive_8, because of the break</span></span>
<span id="cb5-33"><a href="#cb5-33"></a><span>    condition at the middle of the arc. However this is still inefficient due</span></span>
<span id="cb5-34"><a href="#cb5-34"></a><span>    to the square root calculation with `isqrt()`.</span></span>
<span id="cb5-35"><a href="#cb5-35"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb5-36"><a href="#cb5-36"></a>    points <span>=</span> []</span>
<span id="cb5-37"><a href="#cb5-37"></a>    <span>for</span> x <span>in</span> <span>range</span>(r <span>+</span> <span>1</span>):</span>
<span id="cb5-38"><a href="#cb5-38"></a>        y <span>=</span> isqrt((r <span>*</span> r) <span>-</span> (x <span>*</span> x))</span>
<span id="cb5-39"><a href="#cb5-39"></a>        <span># When we cross the middle of the arc, stop, because we&#39;re already</span></span>
<span id="cb5-40"><a href="#cb5-40"></a>        <span># invoking 8-way symmetry.</span></span>
<span id="cb5-41"><a href="#cb5-41"></a>        <span>if</span> x <span>&gt;</span> y:</span>
<span id="cb5-42"><a href="#cb5-42"></a>            <span>break</span></span>
<span id="cb5-43"><a href="#cb5-43"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb5-44"><a href="#cb5-44"></a>    <span>return</span> points</span></code></pre></div>

</div>
<p>This is the best we can do with the simple mathematical translations to code.
Note that in all of these implementations we are still forced to calculate square roots in every iteration, which is certainly suboptimal.</p>

<p>This as also known as the “Midpoint Circle Algorithm,” where the name “midpoint” comes from the mathematical calculations that are done by considering the midpoint <strong>between</strong> pixels.
The gist of the algorithm is that instead of using Equation <span>\(\ref{eq:circle-y}\)</span> to calculate <span>\(y\)</span> for every <span>\(x\)</span>, instead you try to <em>move</em> along the arc of the circle, pixel-to-pixel, staying as close as possible to the true arc:</p>
<ol type="1">
<li>Start out from the top of the circle (color in pixel <span>\((0, r)\)</span>). Note that because of symmetry, we could start out from <span>\((0, -r)\)</span>, <span>\((r, 0)\)</span>, or even <span>\((-r, 0)\)</span> as Bresenham did in his paper.<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a></li>
<li>Move right (east (E)) or down-right (southeast (SE)), whichever is closer to the circle.</li>
<li>Stop when <span>\(x = y\)</span> (just like in <code>get_circle_points_naive_8_faster()</code>).</li>
</ol>
<p>The hard part is Step 2, where we just need to figure out which direction to move (E or SE) from the current pixel.
The brute force way here is to just calculate the distance away from the center of the circle for the E and SE pixels (using <a href="https://en.wikipedia.org/wiki/Euclidean_distance">Euclidean distance</a>, which is just a variation of Equation <span>\(\ref{eq:circle}\)</span> or the Pythagorean Theorem), and just choose the pixel that is closest to the arc of the circle.
This makes sense, but with the power of mathematics, we can do better.</p>
<h2 id="inside-on-or-outside-the-circle">Inside, on, or outside the circle?</h2>
<p>In order to figure out whether some point <span>\((x, y)\)</span> is inside, on, or outside of the circle depends on the definition of the circle from Equation <span>\(\ref{eq:circle}\)</span>.
We can tweak it in terms of any <span>\((x, y)\)</span> pair:</p>
<p><span>\[
\begin{equation} \label{eq:error-margin}
F(x,y) = x^2 + y^2 - r^2 = \text{distance from true circle line}.
\end{equation}
\]</span></p>
<p>Note that if <span>\(F(x,y) = 0\)</span>, then the point <span>\((x, y)\)</span> is <em>exactly</em> on the circle.
If <span>\(F(x,y) &gt; 0\)</span>, then the point is outside of the circle, and if <span>\(F(x,y) &lt; 0\)</span> then the point is inside of it.
In other words, given any point <span>\((x, y)\)</span>, <span>\(F(x, y)\)</span> is the distance from the true circle line.</p>
<h2 id="choosing-between-e-or-se">Choosing between E or SE</h2>
<p>Let’s remind ourselves that we’ll always be moving E or SE.
One critical (pragmatic) property here is that we’re dealing with a pixel grid with integer increments.
There is a very high chance that neither the E or SE pixels we’re moving to is <strong>exactly</strong> on the circle.
This is because the only time that the point <span>\((x,y)\)</span> will exactly be on the line of the circle is if the <span>\(x\)</span>, <span>\(y\)</span>, and <span>\(r\)</span> values (as integers) form a so-called <a href="https://en.wikipedia.org/wiki/Pythagorean_triple">Pythagorean Triple</a>.
For <span>\(r &lt; 100\)</span>, there are only 50 such triples:</p>
<pre><code>( 3, 4, 5)  (18,24,30)  (24,45,51)  (16,63,65)  (51,68,85)
( 6, 8,10)  (16,30,34)  (20,48,52)  (32,60,68)  (40,75,85)
( 5,12,13)  (21,28,35)  (28,45,53)  (42,56,70)  (36,77,85)
( 9,12,15)  (12,35,37)  (33,44,55)  (48,55,73)  (13,84,85)
( 8,15,17)  (15,36,39)  (40,42,58)  (24,70,74)  (60,63,87)
(12,16,20)  (24,32,40)  (36,48,60)  (45,60,75)  (39,80,89)
(15,20,25)  ( 9,40,41)  (11,60,61)  (21,72,75)  (54,72,90)
( 7,24,25)  (27,36,45)  (39,52,65)  (30,72,78)  (35,84,91)
(10,24,26)  (30,40,50)  (33,56,65)  (48,64,80)  (57,76,95)
(20,21,29)  (14,48,50)  (25,60,65)  (18,80,82)  (65,72,97)
</code></pre>
<p>In other words, for all practical purposes, <strong>there will always be some error</strong> and we’ll always be outside or inside the circle and never directly on it.
It’s sort of like driving a car and trying to stay within your designated lane: if you think you’re moving too much to the right, you turn your wheel left to stay “within” the lane (or some acceptable amount within the lane), and vice versa.</p>
<p>The idea is the same for moving along the circle: if we think we’re moving too far <em>outside</em> the circle, we try to move into it.
On the other hand, if we think we’re moving <em>into</em> the circle, we move out of it.
And so imagine yourself standing on point <span>\((0, r)\)</span>, our starting point.
The line of the circle is our “lane” we want to stay “on” as much as possible.
Choosing to go E is the same as turning “left”.
Choosing to go SE is the same as turning “right”.
Using this metaphor, if we were not to turn at all (go “straight”), we would be heading to the virtual “in-between” pixel between E and SE, the <strong>midpoint</strong> between them.</p>
<p>And so here’s the basic idea behind choosing E or SE:</p>
<ol type="1">
<li>If going “straight” would mean going into the circle (i.e., we’re currently veering too much to the right!), we course-correct by turning left (E).</li>
<li>Conversely, if going “straight” would mean going outside the circle (i.e., we’re currently veering too much to the left), we course-correct by turning right (SE).</li>
<li>Lastly, if going “straight” would mean staying exactly on the circle (we hit a Pythagorean Triple), we turn SE (from an engineering perspective it doesn’t really matter which way we turn in this case, as both E and SE result in some amount of error — although see <a href="#final-tweaks">“Final tweaks”</a> below for a note on aesthetics).</li>
</ol>
<p>Let’s convert this idea into pseudocode:</p>
<pre><code>Let M be the midpoint (going &#34;straight&#34;).

Then, F(M) tells us what direction we&#39;re headed relative to the true circle line.

If F(M) is &lt; 0, we&#39;re moving &#34;into&#34; the circle (veering right), so turn left by moving E.

Otherwise move SE.
</code></pre>
<p>Note that we only have to calculate <span>\(F(...)\)</span> for the midpoint <span>\(M\)</span>.
Isn’t this cool?
It is much better than calculating <span>\(F(E)\)</span> and <span>\(F(SE)\)</span> and having to compare them!</p>
<div id="cb8" data-startfrom="1"><pre><code><span id="cb8-1"><a href="#cb8-1"></a><span># This F() function is the same as the mathematical F(...) function</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span># discussed above (Equation 11).</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span>def</span> F(x, y, r):</span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span>return</span> (x <span>*</span> x) <span>+</span> (y <span>*</span> y) <span>-</span> (r <span>*</span> r)</span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span>def</span> get_circle_points_bresenham_WIP1(r):</span>
<span id="cb8-7"><a href="#cb8-7"></a>    points <span>=</span> []</span>
<span id="cb8-8"><a href="#cb8-8"></a>    x <span>=</span> <span>0</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>    y <span>=</span> r</span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span># Calculate F(M) for the very first time. That is, if we were to go</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span># &#34;straight&#34; from (0, r), would we be inside or outside the circle?</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>    xE, yE <span>=</span> (<span>1</span>, r)</span>
<span id="cb8-13"><a href="#cb8-13"></a>    xSE, ySE <span>=</span> (<span>1</span>, r <span>-</span> <span>1</span>)</span>
<span id="cb8-14"><a href="#cb8-14"></a>    xM, yM <span>=</span> (<span>1</span>, r <span>-</span> <span>0.5</span>)</span>
<span id="cb8-15"><a href="#cb8-15"></a>    F_M <span>=</span> F(xM, yM, r)</span>
<span id="cb8-16"><a href="#cb8-16"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb8-17"><a href="#cb8-17"></a>    <span>while</span> x <span>&lt;</span> y:</span>
<span id="cb8-18"><a href="#cb8-18"></a>        <span># If going straight would go &#34;into&#34; the circle (too much to the</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>        <span># right), try to move out of it by turning left by moving E.</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb8-21"><a href="#cb8-21"></a>            x <span>+=</span> <span>1</span></span>
<span id="cb8-22"><a href="#cb8-22"></a>            F_M <span>=</span> F(x, y, r)</span>
<span id="cb8-23"><a href="#cb8-23"></a>        <span># Otherwise move SE.</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>        <span>else</span>:</span>
<span id="cb8-25"><a href="#cb8-25"></a>            x <span>+=</span> <span>1</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>            y <span>-=</span> <span>1</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>            F_M <span>=</span> F(x, y, r)</span>
<span id="cb8-28"><a href="#cb8-28"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb8-29"><a href="#cb8-29"></a>    <span>return</span> points</span></code></pre></div>
<p>We can refactor the above slightly.
We can simplify the initial calculation of <code>F_M</code> to avoid calling <code>F()</code>, and also move out some of the redundant bits.
The very first midpoint we have to consider is <span>\((1, r - \tfrac{1}{2})\)</span>; plugging this into <span>\(F()\)</span> gets us</p>
<p><span>\[
\begin{align}
F(1, r - \tfrac{1}{2}) &amp;= 1^2 + (r - \tfrac{1}{2})^2 - r^2
\\
&amp;= 1 + (r^2 - r + \tfrac{1}{4}) - r^2
\\
&amp;= 1 + r^2 - r^2 - r + \tfrac{1}{4}
\\
&amp;= 1 - r + \tfrac{1}{4}
\\
&amp;= \tfrac{5}{4} - r.
\end{align}
\]</span></p>
<p>With that said, we can get this:</p>
<div id="cb9" data-startfrom="1"><pre><code><span id="cb9-1"><a href="#cb9-1"></a><span>def</span> get_circle_points_bresenham_WIP2(r):</span>
<span id="cb9-2"><a href="#cb9-2"></a>    points <span>=</span> []</span>
<span id="cb9-3"><a href="#cb9-3"></a>    x <span>=</span> <span>0</span></span>
<span id="cb9-4"><a href="#cb9-4"></a>    y <span>=</span> r</span>
<span id="cb9-5"><a href="#cb9-5"></a>    F_M <span>=</span> <span>5</span><span>/</span><span>4</span> <span>-</span> r</span>
<span id="cb9-6"><a href="#cb9-6"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span>while</span> x <span>&lt;</span> y:</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span># If going straight would go &#34;into&#34; the circle (too much to the</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>        <span># right), try to move out of it by turning left by moving E.</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb9-11"><a href="#cb9-11"></a>            <span>pass</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>        <span># Otherwise move SE.</span></span>
<span id="cb9-13"><a href="#cb9-13"></a>        <span>else</span>:</span>
<span id="cb9-14"><a href="#cb9-14"></a>            y <span>-=</span> <span>1</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb9-16"><a href="#cb9-16"></a>        F_M <span>=</span> F(x, y, r)</span>
<span id="cb9-17"><a href="#cb9-17"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb9-18"><a href="#cb9-18"></a>    <span>return</span> points</span></code></pre></div>
<p>The annoying bit is the call to <code>F()</code>.
Surprisingly, the call to <code>F()</code> can be elimitated entirely, because we can <em>calculate it once</em>, and then merely adjust it thereafter.</p>
<h2 id="calculate-once-adjust-thereafter">Calculate once, adjust thereafter</h2>
<p>We can just calculate <span>\(F(x,y)\)</span> <em>once</em> when we start out at <span>\((0, r)\)</span>, and then just <em>adjust it</em> depending on whether we move E or SE.
The key is that this “adjustment” computation is cheaper than calculating the full <span>\(F(x,y)\)</span> distance function all over again.</p>
<p>Let <span>\(M\)</span> be the midpoint <span>\((x + 1, y - \tfrac{1}{2})\)</span> between the E <span>\((x + 1, y)\)</span> and SE <span>\((x + 1, y - 1)\)</span> pixels.
Then <span>\(F(M)\)</span> is the result of going “straight” and tells us the direction we’re veering off from the circle line:</p>
<p><span>\[
\begin{equation}
F(M) = F(x + 1, y - \tfrac{1}{2}) = (x + 1)^2 + (y - \tfrac{1}{2})^2 - r^2.
\end{equation}
\]</span></p>
<p>The values for <span>\(x\)</span> and <span>\(y\)</span> are unknown, however they change in only 2 possible ways — by moving E or SE!</p>
<p>If we move E, then <span>\(M\)</span> will change from <span>\((x + 1, y - \tfrac{1}{2})\)</span> to <span>\((x + 2, y - \tfrac{1}{2})\)</span> because we add 1 to <span>\(x\)</span> to move 1 pixel east; the new value of <span>\(F(M)\)</span> at this pixel, which we can call <span>\(F(M_E)\)</span>, will then be:</p>
<p><span>\[
\begin{equation}
F(M_{E}) = F(x + 2, y - \tfrac{1}{2}) = (x + 2)^2 + (y - \tfrac{1}{2})^2 - r^2.
\end{equation}
\]</span></p>
<p>Now we can take the <strong>difference</strong> between these two full calculations.
That is, if we were to move E, how would <span>\(F(M)\)</span> change?
Simple, we just look at the change in <span>\(x\)</span> (<span>\(\Delta_{x}\)</span>) (we don’t care about the change in <span>\(y\)</span> or <span>\(r\)</span>, because they stay constant in this case).</p>
<p><span>\[
\begin{align}
\Delta_{E} &amp;= F(M_{E}) - F(M)
\\ &amp;= [(x + 2)^2 + (y - \tfrac{1}{2})^2 - r^2] - [(x + 1)^2 + (y - \tfrac{1}{2})^2 - r^2]
\\
&amp;= \Delta_{x}
\\
&amp;= (x + 2)^2 - (x + 1)^2 \label{eq:de1}
\\
&amp;= (x^2 + 4x + 4) - (x^2 + 2x + 1)
\\
&amp;= x^2 + 4x + 4 - x^2 - 2x - 1
\\
&amp;= x^2 - x^2 + 4x - 2x + 4 - 1
\\
&amp;= 2x + 3. \label{eq:de2}
\end{align}
\]</span></p>
<p>So <span>\(F(M)\)</span> will change by <span>\(2x + 3\)</span> if we move E.
So at any given point, if we move E, <span>\(F(M)\)</span> will <em>always</em> change by <span>\(2x + 3\)</span>.</p>
<p>How about for moving SE?
If we move SE, the new value of <span>\(M\)</span> will change from <span>\((x + 1, y - \tfrac{1}{2})\)</span> to <span>\((x + 2, y - \tfrac{3}{2})\)</span> because we add 1 to <span>\(x\)</span> and subtract 1 from <span>\(y\)</span> to move 1 pixel southeast; the new value of <span>\(F(M)\)</span> for this case, which we call <span>\(F(M_{SE})\)</span>, will then be:</p>
<p><span>\[
\begin{equation}
F(M_{SE}) = F(x + 2, y - \tfrac{3}{2}) = (x + 2)^2 + (y - \tfrac{3}{2})^2 - r^2.
\end{equation}
\]</span></p>
<p>We can do the same difference analysis here, but with the addition that we have to consider the change in <span>\(y\)</span> (<span>\(\Delta_{y}\)</span>) as well (because of the 1 we subtracted from <span>\(y\)</span>):</p>
<p><span>\[
\begin{align}
\Delta_{SE} &amp;= F(M_{SE}) - F(M)
\\
&amp;= [(x + 2)^2 + (y - \tfrac{3}{2})^2 - r^2] - [(x + 1)^2 + (y - \tfrac{1}{2})^2 - r^2]
\\
&amp;= \Delta_{x} + \Delta_{y}
\\
&amp;= [(x + 2)^2 - (x + 1)^2] + [(y - \tfrac{3}{2})^2 - (y - \tfrac{1}{2})^2]
\\
&amp;= (2x + 3) + [(y^2 - \tfrac{6y}{2} + \tfrac{9}{4}) - (y^2 - y + \tfrac{1}{4})]
\\
&amp;= (2x + 3) + (y^2 - 3y + \tfrac{9}{4} - y^2 + y - \tfrac{1}{4})
\\
&amp;= (2x + 3) + (y^2 - y^2 - 3y + y + \tfrac{9}{4} - \tfrac{1}{4})
\\
&amp;= (2x + 3) + (- 2y + \tfrac{8}{4})
\\
&amp;= (2x + 3) + (-2y + 2)
\\
&amp;= 2x + 3 - 2y + 2
\\
&amp;= 2x - 2y + 5
\\
&amp;= 2(x - y) + 5. \label{eq:se1}
\end{align}
\]</span></p>
<p>And so when moving SE, the new <span>\(F(M)\)</span> must change by <span>\(2(x - y) + 5\)</span>.</p>
<p>Now we have all the pieces to derive the complete algorithm!</p>
<div>
<div id="cb10" data-startfrom="6"><pre><code><span id="cb10-6"><a href="#cb10-6"></a><span>def</span> get_circle_points_bresenham_float_ese(r):</span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span>&#34;&#34;&#34; Draw a circle using a floating point variable, F_M. Draw by moving E or</span></span>
<span id="cb10-8"><a href="#cb10-8"></a><span>    SE.&#34;&#34;&#34;</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>    points <span>=</span> []</span>
<span id="cb10-10"><a href="#cb10-10"></a>    x <span>=</span> <span>0</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    y <span>=</span> r</span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span># F_M is a float.</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    F_M <span>=</span> <span>5</span> <span>/</span> <span>4</span> <span>-</span> r</span>
<span id="cb10-14"><a href="#cb10-14"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span>while</span> x <span>&lt;</span> y:</span>
<span id="cb10-16"><a href="#cb10-16"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb10-17"><a href="#cb10-17"></a>            F_M <span>+=</span> <span>2.0</span> <span>*</span> x <span>+</span> <span>3.0</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>        <span>else</span>:</span>
<span id="cb10-19"><a href="#cb10-19"></a>            F_M <span>+=</span> <span>2.0</span> <span>*</span> (x <span>-</span> y) <span>+</span> <span>5.0</span></span>
<span id="cb10-20"><a href="#cb10-20"></a>            y <span>-=</span> <span>1</span></span>
<span id="cb10-21"><a href="#cb10-21"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb10-23"><a href="#cb10-23"></a>    <span>return</span> points</span></code></pre></div>

</div>
<h2 id="integer-only-optimization">Integer-only optimization</h2>
<p>The initial value of <code>F_M</code> (<span>\(F(M)\)</span>) is <span>\(\tfrac{5}{4} - r\)</span>.
Notice how this is the only place where we have to perform division in the whole algorithm.
We can avoid this initial division (and subsequent floating point arithmetic) by initializing it to <span>\(1 - r\)</span> instead, which is a difference of <span>\(\tfrac{1}{4}\)</span> vs the original.</p>
<p>Because we tweaked the initialization by <span>\(\tfrac{1}{4}\)</span>, we have to do the same for all comparisons of <span>\(F(M)\)</span> moving forward.
That is, the comparison <span>\(F(M) &lt; 0\)</span> actually becomes <span>\(F(M) &lt; -\tfrac{1}{4}\)</span>.
<em>However, this fractional comparison is unnecessary</em> because we only deal with integer increments and decrements in the rest of the code, so we can just keep the same <span>\(F(M) &lt; 0\)</span> as before.
In other words, our algorithm only cares about whole numbers, so worrying about this extra <span>\(\tfrac{1}{4}\)</span> difference is meaningless.</p>
<div>
<div id="cb11" data-startfrom="26"><pre><code><span id="cb11-26"><a href="#cb11-26"></a><span>def</span> get_circle_points_bresenham_integer_ese(r):</span>
<span id="cb11-27"><a href="#cb11-27"></a>    <span>&#34;&#34;&#34; Like draw_circle_bresenham_float_ese, but F_M is an integer variable.</span></span>
<span id="cb11-28"><a href="#cb11-28"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>    points <span>=</span> []</span>
<span id="cb11-30"><a href="#cb11-30"></a>    x <span>=</span> <span>0</span></span>
<span id="cb11-31"><a href="#cb11-31"></a>    y <span>=</span> r</span>
<span id="cb11-32"><a href="#cb11-32"></a>    <span># F_M is an integer!</span></span>
<span id="cb11-33"><a href="#cb11-33"></a>    F_M <span>=</span> <span>1</span> <span>-</span> r</span>
<span id="cb11-34"><a href="#cb11-34"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb11-35"><a href="#cb11-35"></a>    <span>while</span> x <span>&lt;</span> y:</span>
<span id="cb11-36"><a href="#cb11-36"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb11-37"><a href="#cb11-37"></a>            <span># We can use a bit-shift safely because 2*n is the same as n &lt;&lt; 1</span></span>
<span id="cb11-38"><a href="#cb11-38"></a>            <span># in binary, and also because F_M is an integer.</span></span>
<span id="cb11-39"><a href="#cb11-39"></a>            F_M <span>+=</span> (x <span>&lt;&lt;</span> <span>1</span>) <span>+</span> <span>3</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>        <span>else</span>:</span>
<span id="cb11-41"><a href="#cb11-41"></a>            F_M <span>+=</span> ((x <span>-</span> y) <span>&lt;&lt;</span> <span>1</span>) <span>+</span> <span>5</span></span>
<span id="cb11-42"><a href="#cb11-42"></a>            y <span>-=</span> <span>1</span></span>
<span id="cb11-43"><a href="#cb11-43"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb11-44"><a href="#cb11-44"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb11-45"><a href="#cb11-45"></a>    <span>return</span> points</span></code></pre></div>

</div>
<h2 id="second-order-differences">Second-order differences</h2>
<p>There is a final optimization we can do.<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a>
In the <a href="#calculate-once-adjust-thereafter">“Calculate once, adjust thereafter” section</a> we avoided calculating <span>\(F(M)\)</span> from scratch on every iteration.
We can do the same thing for the differences themselves!</p>
<p>That is, we can avoid calculating <span>\(\Delta_{E} = (2x + 3)\)</span> and <span>\(\Delta_{SE} = 2(x - y) + 5\)</span> on every iteration, and instead just calculate them <em>once</em> and make adjustments to them, just like we did earlier for <span>\(F(M)\)</span>.</p>
<p>Let’s first consider how <span>\(\Delta_{E} = 2x + 3\)</span> changes.
First, we initialize <span>\(\Delta_{E}\)</span> by plugging in <span>\((0, r)\)</span> into Equation <span>\(\ref{eq:de2}\)</span>, our starting point.
Because there is no <span>\(y\)</span> variable in here, we get an initial value of</p>
<p><span>\[
\begin{equation} \label{eq:de-2ord-initial}
2(0) + 3 = 3.
\end{equation}
\]</span></p>
<p>If we go E, <span>\(\Delta_{E}\)</span> changes like this:
<span>\[
\begin{align}
\Delta_{E_{new}} = \Delta_{E_(x+1,y)} - \Delta_{E_(x,y)} &amp;= [2(x+1) + 3] - (2x + 3) \label{eq:de-2ord-e}
\\
&amp;= 2x + 2 + 3 - 2x - 3
\\
&amp;= 2x - 2x + 3 - 3 + 2
\\
&amp;= 2. \label{eq:e2ord}
\end{align}
\]</span></p>
<p>If we go SE, <span>\(\Delta_{E}\)</span> changes in the exact same way, because even though our new point is at <span>\((x+1, y-1)\)</span>, there is no <span>\(y\)</span> in <span>\(\Delta_{E} = 2x + 3\)</span>, so it doesn’t matter and <span>\(\Delta_{E_{new}} = 2\)</span> again.</p>
<p>Now let’s consider how <span>\(\Delta_{SE}\)</span> changes.
For the initial value, we again plug in <span>\((0, r)\)</span> into <span>\(2(x-y) + 5\)</span>, to get</p>
<p><span>\[
\begin{equation} \label{eq:dse-2ord-initial}
2(0-r) + 5 = -2r + 5.
\end{equation}
\]</span></p>
<p>If we go E, <span>\(\Delta_{SE}\)</span> changes like this:</p>
<p><span>\[
\begin{align}
\Delta_{SE_{new}} = \Delta_{SE_(x+1,y)} - \Delta_{SE_(x,y)} &amp;= [2((x + 1)-y) + 5] - [2(x - y) + 5] \label{eq:dse-2ord-e}
\\
&amp;= (2x + 2 - 2y + 5) - (2x - 2y + 5)
\\
&amp;= 2x - 2y + 7 - 2x + 2y - 5
\\
&amp;= 2x - 2x + 2y - 2y + 7 - 5
\\
&amp;= 2. \label{eq:se2ord1}
\end{align}
\]</span></p>
<p>If we go SE, <span>\(\Delta_{SE}\)</span> changes like this:</p>
<p><span>\[
\begin{align}
\Delta_{SE_{new}} = \Delta_{SE_(x+1,y-1)} - \Delta_{SE_(x,y)} &amp;= [2((x + 1)-(y - 1)) + 5] - [2(x - y) + 5] \label{eq:dse-2ord-se}
\\
&amp;= [2(x + 1 - y + 1) + 5] - (2x - 2y + 5)
\\
&amp;= (2x + 2 - 2y + 2 + 5) - 2x + 2y - 5
\\
&amp;= 2x- 2x + 2y - 2y + 5 - 5 + 2 + 2
\\
&amp;= 2 + 2
\\
&amp;= 4. \label{eq:se2ord2}
\end{align}
\]</span></p>
<p>The code should then look like this:</p>
<div id="cb12" data-startfrom="1"><pre><code><span id="cb12-1"><a href="#cb12-1"></a><span>def</span> get_circle_points_bresenham_2order(r):</span>
<span id="cb12-2"><a href="#cb12-2"></a>    points <span>=</span> []</span>
<span id="cb12-3"><a href="#cb12-3"></a>    x <span>=</span> <span>0</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>    y <span>=</span> r</span>
<span id="cb12-5"><a href="#cb12-5"></a>    F_M <span>=</span> <span>1</span> <span>-</span> r</span>
<span id="cb12-6"><a href="#cb12-6"></a>    d_e <span>=</span> <span>3</span> <span># Equation 40</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    d_se <span>=</span> <span>-</span>(<span>2</span> <span>*</span> r) <span>+</span> <span>5</span> <span># Equation 45</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb12-9"><a href="#cb12-9"></a>    <span>while</span> x <span>&lt;</span> y:</span>
<span id="cb12-10"><a href="#cb12-10"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb12-11"><a href="#cb12-11"></a>            F_M <span>+=</span> d_e</span>
<span id="cb12-12"><a href="#cb12-12"></a>            d_e <span>+=</span> <span>2</span>  <span># Equation 44</span></span>
<span id="cb12-13"><a href="#cb12-13"></a>            d_se <span>+=</span> <span>2</span> <span># Equation 50</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        <span>else</span>:</span>
<span id="cb12-15"><a href="#cb12-15"></a>            F_M <span>+=</span> d_se</span>
<span id="cb12-16"><a href="#cb12-16"></a>            d_e <span>+=</span> <span>2</span>  <span># Equation 44</span></span>
<span id="cb12-17"><a href="#cb12-17"></a>            d_se <span>+=</span> <span>4</span> <span># Equation 56</span></span>
<span id="cb12-18"><a href="#cb12-18"></a>            y <span>-=</span> <span>1</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb12-20"><a href="#cb12-20"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb12-21"><a href="#cb12-21"></a>    <span>return</span> points</span></code></pre></div>
<p>With a little refactoring, we can arrive at a slightly simpler version:</p>
<div>
<div id="cb13" data-startfrom="48"><pre><code><span id="cb13-48"><a href="#cb13-48"></a><span>def</span> get_circle_points_bresenham_integer_ese_2order(r):</span>
<span id="cb13-49"><a href="#cb13-49"></a>    <span>&#34;&#34;&#34; Like draw_circle_bresenham_integer_ese, but use 2nd-order differences</span></span>
<span id="cb13-50"><a href="#cb13-50"></a><span>    to remove multiplication from the inner loop. &#34;&#34;&#34;</span></span>
<span id="cb13-51"><a href="#cb13-51"></a>    points <span>=</span> []</span>
<span id="cb13-52"><a href="#cb13-52"></a>    x <span>=</span> <span>0</span></span>
<span id="cb13-53"><a href="#cb13-53"></a>    y <span>=</span> r</span>
<span id="cb13-54"><a href="#cb13-54"></a>    F_M <span>=</span> <span>1</span> <span>-</span> r</span>
<span id="cb13-55"><a href="#cb13-55"></a>    <span># Initial value for (0,r) for 2x + 3 = 0x + 3 = 3.</span></span>
<span id="cb13-56"><a href="#cb13-56"></a>    d_e <span>=</span> <span>3</span></span>
<span id="cb13-57"><a href="#cb13-57"></a>    <span># Initial value for (0,r) for 2(x - y) + 5 = 0 - 2y + 5 = -2y + 5.</span></span>
<span id="cb13-58"><a href="#cb13-58"></a>    d_se <span>=</span> <span>-</span>(r <span>&lt;&lt;</span> <span>1</span>) <span>+</span> <span>5</span></span>
<span id="cb13-59"><a href="#cb13-59"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb13-60"><a href="#cb13-60"></a>    <span>while</span> x <span>&lt;</span> y:</span>
<span id="cb13-61"><a href="#cb13-61"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb13-62"><a href="#cb13-62"></a>            F_M <span>+=</span> d_e</span>
<span id="cb13-63"><a href="#cb13-63"></a>        <span>else</span>:</span>
<span id="cb13-64"><a href="#cb13-64"></a>            F_M <span>+=</span> d_se</span>
<span id="cb13-65"><a href="#cb13-65"></a>            <span># Increment d_se by 2 (total 4) if we go southeast.</span></span>
<span id="cb13-66"><a href="#cb13-66"></a>            d_se <span>+=</span> <span>2</span></span>
<span id="cb13-67"><a href="#cb13-67"></a>            y <span>-=</span> <span>1</span></span>
<span id="cb13-68"><a href="#cb13-68"></a>        <span># Always increment d_e and d_se by 2!</span></span>
<span id="cb13-69"><a href="#cb13-69"></a>        d_e <span>+=</span> <span>2</span></span>
<span id="cb13-70"><a href="#cb13-70"></a>        d_se <span>+=</span> <span>2</span></span>
<span id="cb13-71"><a href="#cb13-71"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb13-72"><a href="#cb13-72"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb13-73"><a href="#cb13-73"></a>    <span>return</span> points</span></code></pre></div>

</div>
<p>The “purist” in me felt that the decrementing of <span>\(y\)</span> stood out like a sore thumb, and so I created a tweaked version that moves E and NE, starting out from <span>\((0, -r)\)</span> instead.
The mathematical techniques are the same, and due to symmetry the behavior of the algorithm does not change.</p>
<div>
<div id="cb14" data-startfrom="99"><pre><code><span id="cb14-99"><a href="#cb14-99"></a><span>def</span> get_circle_points_bresenham_integer_ene_2order(r):</span>
<span id="cb14-100"><a href="#cb14-100"></a>    <span>&#34;&#34;&#34; Like draw_circle_bresenham_integer_ene, but start from (0, -r) and move</span></span>
<span id="cb14-101"><a href="#cb14-101"></a><span>    E or NE. Notice how we only need the addition instruction in the while loop</span></span>
<span id="cb14-102"><a href="#cb14-102"></a><span>    (y is incremented, not decremented). &#34;&#34;&#34;</span></span>
<span id="cb14-103"><a href="#cb14-103"></a>    points <span>=</span> []</span>
<span id="cb14-104"><a href="#cb14-104"></a>    x <span>=</span> <span>0</span></span>
<span id="cb14-105"><a href="#cb14-105"></a>    y <span>=</span> <span>-</span>r</span>
<span id="cb14-106"><a href="#cb14-106"></a>    F_M <span>=</span> <span>1</span> <span>-</span> r</span>
<span id="cb14-107"><a href="#cb14-107"></a>    <span># Initial value for (0,-r) for 2x + 3 = 0x + 3 = 3.</span></span>
<span id="cb14-108"><a href="#cb14-108"></a>    d_e <span>=</span> <span>3</span></span>
<span id="cb14-109"><a href="#cb14-109"></a>    <span># Initial value for (0,-r) for 2(x + y) + 5 = 0 - 2y + 5 = -2y + 5.</span></span>
<span id="cb14-110"><a href="#cb14-110"></a>    d_ne <span>=</span> <span>-</span>(r <span>&lt;&lt;</span> <span>1</span>) <span>+</span> <span>5</span></span>
<span id="cb14-111"><a href="#cb14-111"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb14-112"><a href="#cb14-112"></a>    <span>while</span> x <span>&lt;</span> <span>-</span>y:</span>
<span id="cb14-113"><a href="#cb14-113"></a>        <span>if</span> F_M <span>&lt;</span> <span>0</span>:</span>
<span id="cb14-114"><a href="#cb14-114"></a>            F_M <span>+=</span> d_e</span>
<span id="cb14-115"><a href="#cb14-115"></a>        <span>else</span>:</span>
<span id="cb14-116"><a href="#cb14-116"></a>            F_M <span>+=</span> d_ne</span>
<span id="cb14-117"><a href="#cb14-117"></a>            d_ne <span>+=</span> <span>2</span></span>
<span id="cb14-118"><a href="#cb14-118"></a>            y <span>+=</span> <span>1</span></span>
<span id="cb14-119"><a href="#cb14-119"></a>        d_e <span>+=</span> <span>2</span></span>
<span id="cb14-120"><a href="#cb14-120"></a>        d_ne <span>+=</span> <span>2</span></span>
<span id="cb14-121"><a href="#cb14-121"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb14-122"><a href="#cb14-122"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb14-123"><a href="#cb14-123"></a>    <span>return</span> points</span></code></pre></div>

</div>
<p>Here are a couple drawings using Bresenham’s algorithm.
This one is for <span>\(r = 15\)</span>:</p>
<canvas id="bresenham_integer_ene_2order__15__20"></canvas>

<p>And for <span>\(r = 60\)</span>:</p>
<canvas id="bresenham_integer_ene_2order__60__5"></canvas>

<h2 id="comparisons-vs-naive-algorithm">Comparisons vs naive algorithm</h2>
<p>Here are some side-by-side comparisons for <span>\(0 \leq r \leq 10\)</span>.</p>
<table>
  <tbody><tr>
    <th>Radius</th>
    <th>Naive</th>
    <th>Bresenham</th>
  </tr>
  <tr>
    <td>0</td>
    <td><canvas id="naive_8__0__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__0__10"></canvas></td>
  </tr>
  <tr>
    <td>1</td>
    <td><canvas id="naive_8__1__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__1__10"></canvas></td>
  </tr>
  <tr>
    <td>2</td>
    <td><canvas id="naive_8__2__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__2__10"></canvas></td>
  </tr>
  <tr>
    <td>3</td>
    <td><canvas id="naive_8__3__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__3__10"></canvas></td>
  </tr>
  <tr>
    <td>4</td>
    <td><canvas id="naive_8__4__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__4__10"></canvas></td>
  </tr>
  <tr>
    <td>5</td>
    <td><canvas id="naive_8__5__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__5__10"></canvas></td>
  </tr>
  <tr>
    <td>6</td>
    <td><canvas id="naive_8__6__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__6__10"></canvas></td>
  </tr>
  <tr>
    <td>7</td>
    <td><canvas id="naive_8__7__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__7__10"></canvas></td>
  </tr>
  <tr>
    <td>8</td>
    <td><canvas id="naive_8__8__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__8__10"></canvas></td>
  </tr>
  <tr>
    <td>9</td>
    <td><canvas id="naive_8__9__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__9__10"></canvas></td>
  </tr>
  <tr>
    <td>10</td>
    <td><canvas id="naive_8__10__10"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__10__10"></canvas></td>
  </tr>
</tbody></table>

<h2 id="final-tweaks">Final tweaks</h2>
<p>It has been kindly <a href="https://www.reddit.com/r/programming/comments/m5g8ck/bresenhams_circle_drawing_algorithm/gr23aie?utm_source=share&amp;utm_medium=web2x&amp;context=3">pointed out</a> that the naive algorithm is aesthetically more pleasing if the calculations involving <span>\(r\)</span> is done with <span>\(r + \tfrac{1}{2}\)</span> instead of just <span>\(r\)</span> itself, like this:</p>
<div>
<div id="cb15" data-startfrom="47"><pre><code><span id="cb15-47"><a href="#cb15-47"></a><span>def</span> get_circle_points_naive_8_faster_tweaked_radius(r):</span>
<span id="cb15-48"><a href="#cb15-48"></a>    <span>&#34;&#34;&#34; This is much closer to Bresenham&#39;s algorithm aesthetically, by simply</span></span>
<span id="cb15-49"><a href="#cb15-49"></a><span>    using &#39;r + 0.5&#39; for the square root calculation instead of &#39;r&#39; directly.</span></span>
<span id="cb15-50"><a href="#cb15-50"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb15-51"><a href="#cb15-51"></a>    points <span>=</span> []</span>
<span id="cb15-52"><a href="#cb15-52"></a>    <span># In the square root calculation, we just use (r + 0.5) instead of just r.</span></span>
<span id="cb15-53"><a href="#cb15-53"></a>    <span># This is more pleasing to the eye and makes the lines a bit smoother.</span></span>
<span id="cb15-54"><a href="#cb15-54"></a>    r_tweaked <span>=</span> r <span>+</span> <span>0.5</span></span>
<span id="cb15-55"><a href="#cb15-55"></a>    <span>for</span> x <span>in</span> <span>range</span>(r <span>+</span> <span>1</span>):</span>
<span id="cb15-56"><a href="#cb15-56"></a>        y <span>=</span> sqrt((r_tweaked <span>*</span> r_tweaked) <span>-</span> (x <span>*</span> x))</span>
<span id="cb15-57"><a href="#cb15-57"></a>        <span>if</span> x <span>&gt;</span> y:</span>
<span id="cb15-58"><a href="#cb15-58"></a>            <span>break</span></span>
<span id="cb15-59"><a href="#cb15-59"></a>        points.extend(mirror_points_8(x, floor(y)))</span>
<span id="cb15-60"><a href="#cb15-60"></a>    <span>return</span> points</span></code></pre></div>

</div>
<p>Indeed, the small tweak seems to do wonders to the output for low values of <span>\(r\)</span>.</p>
<p>At the same time, there is a tweak we can do as well for the Bresenham algorithm.
Instead of turning E (“left”, or away from the circle) when <span>\(F(M) &lt; 0\)</span>, we can do so when <span>\(F(M) \leq 0\)</span>.</p>
<div>
<div id="cb16" data-startfrom="126"><pre><code><span id="cb16-126"><a href="#cb16-126"></a><span>def</span> get_circle_points_bresenham_integer_ene_2order_leq(r):</span>
<span id="cb16-127"><a href="#cb16-127"></a>    <span>&#34;&#34;&#34; Like draw_circle_bresenham_integer_ene_2order, but use &#39;f_m &lt;= 0&#39;</span></span>
<span id="cb16-128"><a href="#cb16-128"></a><span>    instead of &#39;f_m &lt; 0&#39;.</span></span>
<span id="cb16-129"><a href="#cb16-129"></a><span>    &#34;&#34;&#34;</span></span>
<span id="cb16-130"><a href="#cb16-130"></a>    points <span>=</span> []</span>
<span id="cb16-131"><a href="#cb16-131"></a>    x <span>=</span> <span>0</span></span>
<span id="cb16-132"><a href="#cb16-132"></a>    y <span>=</span> <span>-</span>r</span>
<span id="cb16-133"><a href="#cb16-133"></a>    F_M <span>=</span> <span>1</span> <span>-</span> r</span>
<span id="cb16-134"><a href="#cb16-134"></a>    d_e <span>=</span> <span>3</span></span>
<span id="cb16-135"><a href="#cb16-135"></a>    d_ne <span>=</span> <span>-</span>(r <span>&lt;&lt;</span> <span>1</span>) <span>+</span> <span>5</span></span>
<span id="cb16-136"><a href="#cb16-136"></a>    points.extend(mirror_points_8(x, y))</span>
<span id="cb16-137"><a href="#cb16-137"></a>    <span>while</span> x <span>&lt;</span> <span>-</span>y:</span>
<span id="cb16-138"><a href="#cb16-138"></a>        <span>if</span> F_M <span>&lt;=</span> <span>0</span>:</span>
<span id="cb16-139"><a href="#cb16-139"></a>            F_M <span>+=</span> d_e</span>
<span id="cb16-140"><a href="#cb16-140"></a>        <span>else</span>:</span>
<span id="cb16-141"><a href="#cb16-141"></a>            F_M <span>+=</span> d_ne</span>
<span id="cb16-142"><a href="#cb16-142"></a>            d_ne <span>+=</span> <span>2</span></span>
<span id="cb16-143"><a href="#cb16-143"></a>            y <span>+=</span> <span>1</span></span>
<span id="cb16-144"><a href="#cb16-144"></a>        d_e <span>+=</span> <span>2</span></span>
<span id="cb16-145"><a href="#cb16-145"></a>        d_ne <span>+=</span> <span>2</span></span>
<span id="cb16-146"><a href="#cb16-146"></a>        x <span>+=</span> <span>1</span></span>
<span id="cb16-147"><a href="#cb16-147"></a>        points.extend(mirror_points_8(x, y))</span>
<span id="cb16-148"><a href="#cb16-148"></a>    <span>return</span> points</span></code></pre></div>

</div>
<p>This makes us turn “left” slightly more often, and intuitively, should give us a slightly larger circle.</p>
<p>Anyway, see for yourself how the tweaks play out for <span>\(0 \leq r \leq 10\)</span>:</p>
<table>
  <tbody><tr>
    <th>Radius</th>
    <th>Naive</th>
    <th>Naive</th>
    <th>Bresenham</th>
    <th>Bresenham</th>
  </tr>
  <tr>
    <td>0</td>
    <td><canvas id="naive_8__0__6"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__0__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__0__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__0__7"></canvas></td>
  </tr>
  <tr>
    <td>1</td>
    <td><canvas id="naive_8__1__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__1__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__1__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__1__7"></canvas></td>
  </tr>
  <tr>
    <td>2</td>
    <td><canvas id="naive_8__2__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__2__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__2__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__2__7"></canvas></td>
  </tr>
  <tr>
    <td>3</td>
    <td><canvas id="naive_8__3__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__3__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__3__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__3__7"></canvas></td>
  </tr>
  <tr>
    <td>4</td>
    <td><canvas id="naive_8__4__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__4__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__4__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__4__7"></canvas></td>
  </tr>
  <tr>
    <td>5</td>
    <td><canvas id="naive_8__5__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__5__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__5__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__5__7"></canvas></td>
  </tr>
  <tr>
    <td>6</td>
    <td><canvas id="naive_8__6__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__6__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__6__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__6__7"></canvas></td>
  </tr>
  <tr>
    <td>7</td>
    <td><canvas id="naive_8__7__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__7__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__7__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__7__7"></canvas></td>
  </tr>
  <tr>
    <td>8</td>
    <td><canvas id="naive_8__8__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__8__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__8__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__8__7"></canvas></td>
  </tr>
  <tr>
    <td>9</td>
    <td><canvas id="naive_8__9__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__9__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__9__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__9__7"></canvas></td>
  </tr>
  <tr>
    <td>10</td>
    <td><canvas id="naive_8__10__7"></canvas></td>
    <td><canvas id="naive_8_faster_tweaked_radius__10__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order__10__7"></canvas></td>
    <td><canvas id="bresenham_integer_ene_2order_leq__10__7"></canvas></td>
  </tr>
</tbody></table>

<p>It appears to me that the most aesthetically pleasing algorithm is the tweaked version of the Bresenham algorithm.<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a>
When given equally bad choices (the case where <span>\(F(M) = 0\)</span>), this version draws a pixel <em>away</em> from the origin by choosing to go E, thereby drawing a slightly bigger circle.
You can see this play out in the above table for when <span>\(r = 6\)</span> and especially <span>\(r = 1\)</span>.
It’s a bit unfortunate that the authors of the book did not choose this version, as it seems to do a better job for small values of <span>\(r\)</span>.</p>
<p>We can carry over the same intuition over to the tweak to increase <span>\(r\)</span> by <span>\(\tfrac{1}{2}\)</span> for the naive algorithm — increasing <span>\(r\)</span> should result in a larger value of <span>\(y\)</span>, thereby resulting in drawing a larger circle (and in the process improving the aesthetics).
Neat!</p>

<p>To me, Bresenham’s algorithm is interesting because it does not try to be “perfect”.
Instead it merely does its best to reduce the amount of error, and in doing so, gets the job done remarkably well.</p>
<p>The technique of avoiding the full polynomial calculation behind <span>\(F(M)\)</span> (referred by the book as finding the first and second-order differences) took some time to get used to, but is intuitive enough in the end.
You just need to consider differences in terms of variables.
There’s also a connection to calculus because we’re dealing in terms of <em>differences</em> to “cut down” on the polynomial degrees — we go from the squares in Equation <span>\(\ref{eq:circle}\)</span> to just linear functions in Equations <span>\(\ref{eq:de2}\)</span> and <span>\(\ref{eq:se1}\)</span>, and again go one more step to just constant functions in Equations <span>\(\ref{eq:e2ord}\)</span>, <span>\(\ref{eq:se2ord1}\)</span>, and <span>\(\ref{eq:se2ord2}\)</span>.</p>
<p>I hope you learned something!</p>
<p>Happy hacking!</p>
<section id="footnotes" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1"><p>Foley, J. D., van Dam, A., Feiner, S. K., Hughes, J. F. (1996). Basic Raster Graphics Algorithms for Drawing 2D Primitives, Scan Converting Circles. <em>Computer Graphics: Principles and Practice</em> (pp. 81–87). Addison-Wesley. ISBN: 0201848406<a href="#fnref1" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Bresenham, J.E., D.G. Grice, and S.C. Pi, “Bi-Directional Display of Circular Arcs,” US Patent 4,371,933. February 1, 1983. <em>Note: unfortunately, trying to understand the original text of the patent is perhaps equally as difficult as inventing the algorithm on your own from scratch. Hence this blog post.</em><a href="#fnref2" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>There are 4 such <a href="https://en.wikipedia.org/wiki/Quadrant_(plane_geometry)">quadrants</a>: I, II, III, and IV.<a href="#fnref3" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>In some sense, all great algorithms are mere optimizations of brute force approaches.<a href="#fnref4" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>In code, we have to write <code>range(r + 1)</code> because the <code>range()</code> function does not include the last integer. Such “fence-post” or “off by one” logic is the bane of computer programmers.<a href="#fnref5" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>Mathematically, this is because the slope of the arc in Equation <span>\(\ref{eq:circle-y}\)</span> approach positive and negative infinity around these areas.<a href="#fnref6" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>In the <a href="https://github.com/listx/listx_blog/blob/master/rust-js/src/lib.rs">Rust WASM implementation</a> that is used for the graphics in this blog post, we actually use a bitmap such that we only draw a particular pixel just once. However, we still end up <em>setting</em> the a pixel as “on” more than once.<a href="#fnref7" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>Bresenham, Jack. “A Linear Algorithm for Incremental Digital Display of Circular Arcs.” Communications of the ACM, vol. 20, no. 2, 1977, pp. 100–106., <a href="doi:10.1145/359423.359432">doi:10.1145/359423.359432</a>.<a href="#fnref8" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>It is not clear to me if this change runs faster on modern CPUs, because I recall reading that multiplication can sometimes be faster than adding. But it’s still interesting.<a href="#fnref9" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>This version looks slightly better than the tweaked naive one for <span>\(r = 8\)</span>.<a href="#fnref10" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

		</div></div>
  </body>
</html>
