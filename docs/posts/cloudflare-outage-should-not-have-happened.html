<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ebellani.github.io/blog/2025/cloudflare-outage-should-not-have-happened-and-they-seem-to-be-missing-the-point-on-how-to-avoid-it-in-the-future/">Original</a>
    <h1>Cloudflare outage should not have happened</h1>
    
    <div id="readability-page-1" class="page"><div>
  <h2>Cloudflare outage should not have happened, and they seem to be missing the point on how to avoid it in the future
    <small>
      <time>November 26, 2025</time>
    by Eduardo Bellani


    </small>
  </h2><p><a href="https://ebellani.github.io/blog/2025/google-cloud-s-outage-should-not-have-happened-and-they-seem-to-be-missing-the-point-on-how-to-avoid-it-in-the-future/">Yet again</a>, another global IT outage happen (deja vu strikes again in our
industry). This time at
cloudflare(<a href="#citeproc_bib_item_4">Prince 2025</a>). Again, taking down
large swats of the internet with
it(<a href="#citeproc_bib_item_2">Booth 2025</a>).</p>
<p>And yes, like my previous analysis of the GCP and CrowdStrike’s outages,
this post critiques Cloudflare’s root cause analysis (RCA), which —
despite providing a great overview of what happened — misses the real
lesson.</p>
<p>Here’s the key section of their RCA:</p>
<blockquote>
<p>Unfortunately, there were assumptions made in the past, that the list of
columns returned by a query like this would only include the “default”
database:</p>
<p>SELECT
name,
type
FROM system.columns
WHERE
table = ‘http_requests_features’
order by name;</p>
<p>Note how the query does not filter for the database name. With us
gradually rolling out the explicit grants to users of a given ClickHouse
cluster, after the change at 11:05 the query above started returning
“duplicates” of columns because those were for underlying tables stored
in the r0 database.</p>
<p>This, unfortunately, was the type of query that was performed by the Bot
Management feature file generation logic to construct each input
“feature” for the file mentioned at the beginning of this section.</p>
<p>The query above would return a table of columns like the one displayed
(simplified example):</p>
<figure><img src="https://ebellani.github.io/ox-hugo/cf_table_sql_return.png"/>
</figure>

<p>However, as part of the additional permissions that were granted to the
user, the response now contained all the metadata of the r0 schema
effectively more than doubling the rows in the response ultimately
affecting the number of rows (i.e. features) in the final file output.</p>
</blockquote>
<p>A central database query didn’t have the right constraints to express
business rules. Not only it missed the database name, but it clearly
needs a distinct and a limit, since these seem to be crucial business
rules.</p>
<p>So, a new underlying security work manifested the (unintended) potential
already there in the query. Since this was by definition unintended, the
application code didn’t expect that value to be what it was, and reacted
poorly. This caused a crash loop across seemingly all of cloudflare’s
core systems. This bug wasn’t caught during rollout because the faulty
code path required data that was assumed to be impossible to be
generated.</p>
<p>Sounds familiar? It should. Any senior engineer has seen this pattern
before. This is classic database/application mismatch. With this in
mind, let’s review how Cloudflare is planning to prevent this from happening
again:</p>
<blockquote>
<ul>
<li>Hardening ingestion of Cloudflare-generated configuration files in the same way we would for user-generated input</li>
<li>Enabling more global kill switches for features</li>
<li>Eliminating the ability for core dumps or other error reports to overwhelm system resources</li>
<li>Reviewing failure modes for error conditions across all core proxy modules</li>
</ul>
</blockquote>
<p>These are all solid, reasonable steps. But here’s the problem: they
already do most of this—and the outage happened anyway.</p>
<p>Why? Because of they seem to mistake physical replication with not
having a single point of failure. This mistakes the physical layer with
the logical layer. One can have a logical single point of failure
without having any physical one, which was the case in this
situation.</p>
<p>I base my paragraph on their choice of abandoning PostgreSQL and
adopting
ClickHouse(<a href="#citeproc_bib_item_1">Bocharov 2018</a>). The
whole post is a great overview on trying to process data fast, without a
single line on how to garantee its logical correctness/consistency in
the face of changes.</p>
<p><strong>They are treating a logical problem as if it was a physical problem</strong></p>
<p>I’ll repeat the <a href="https://ebellani.github.io/blog/2025/google-cloud-s-outage-should-not-have-happened-and-they-seem-to-be-missing-the-point-on-how-to-avoid-it-in-the-future/">same advice</a> I offered in my previous article on GCP’s outage:</p>
<h2 id="the-real-cause">The real cause</h2>
<p>These kinds of outages stem from the uncontrolled interaction between
application logic and database schema. You can’t reliably catch that
with more tests or rollouts or flags. You prevent it by
construction—through analytical design.</p>
<ol>
<li>No nullable fiels.</li>
<li>(as a cororally of 1) full normalization of the database (<a href="https://ebellani.github.io/blog/2025/the-principles-of-database-design-or-the-truth-is-out-there/">The principles of database design, or, the Truth is out there</a>)</li>
<li>formally verified application code(<a href="#citeproc_bib_item_3">Chapman et al. 2024</a>)</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>FAANG-style companies are unlikely to adopt formal methods or relational
rigor wholesale. But for their most critical systems, they should. It’s
the only way to make failures like this impossible by design, rather
than just less likely.</p>
<p>The internet would thank them. (Cloud users too—caveat emptor.)</p>
<h2 id="references">References</h2>
<div>
  <div><p><a id="citeproc_bib_item_1"></a>Bocharov, Alex. 2018. “Http Analytics for 6m Requests per Second Using Clickhouse.” <a href="https://blog.cloudflare.com/http-analytics-for-6m-requests-per-second-using-clickhouse/">https://blog.cloudflare.com/http-analytics-for-6m-requests-per-second-using-clickhouse/</a>.</p></div>
  
  <p><a id="citeproc_bib_item_3"></a>Chapman, Roderick, Claire Dross, Stuart Matthews, and Yannick Moy. 2024. “Co-Developing Programs and Their Proof of Correctness.” <i>Commun. Acm</i> 67 (3): 84–94. <a href="https://doi.org/10.1145/3624728">https://doi.org/10.1145/3624728</a>.</p>
  <div><p><a id="citeproc_bib_item_4"></a>Prince, Matthew. 2025. “Cloudflare Outage on November 18, 2025.” <a href="https://blog.cloudflare.com/18-november-2025-outage/">https://blog.cloudflare.com/18-november-2025-outage/</a>.</p></div>
</div>
<figure><img src="https://ebellani.github.io/ox-hugo/2560px-Dehio_212_Cluny.jpg" alt="Figure 1: The Cluny library was one of the richest and most important in France and Europe. In 1790 during the French Revolution, the abbey was sacked and mostly destroyed, with only a small part surviving"/><figcaption>
            <p><span>Figure 1: </span>The Cluny library was one of the richest and most important in France and Europe. In 1790 during the French Revolution, the abbey was sacked and mostly destroyed, with only a small part surviving</p>
        </figcaption>
</figure>




   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   

   







      </div></div>
  </body>
</html>
