<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kerkour.com/high-performance-rust-with-sqlite">Original</a>
    <h1>15k inserts/s with Rust and SQLite (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>There is this growing sentiment in tech that stacking more and more layers of complexity to reach the sacrosanct &#34;infinite scalability&#34; is not the way forward.</p>
<p><img src="https://kerkour.com/2021/high-performance-rust-with-sqlite/debt.gif" alt="Debt."/></p>
<p>First, because it rarely materializes: you need a lot of other things than fancy tech to reach millions of people.</p>
<p>Second, because the tradeoffs of complex systems are often misunderstood, and most of the time, they bring more problems than benefits. And these problems compound over time.</p>
<p>So here is a little experiment to show you how to reach 15,000 inserts per second with simple technology, which is approximately 1.3 billion inserts per day. <strong>1.3 Billion</strong>.</p>
<p>Is it possible to improve this micro benchmark? Of course, by bundling all the inserts in a single transaction, for example, or by using another, non-async database driver, but it does not make sense as it&#39;s not how a real-world codebase accessing a database looks like. We favor <strong>simplicity</strong> over theorical numbers.</p>
<p>Without further ado, here are the results:</p>
<pre><code>$ cargo run --release -- -c 3 -i 100000
Inserting 100000 records. concurrency: 3
Time elapsed to insert 100000 records: 6.523381395s (15329.47 inserts/s)
</code></pre>
<h2 id="the-code">The code</h2>
<p><strong>Cargo.toml</strong></p>
<pre tabindex="0"><code><span><span>[<span>package</span>]
</span></span><span><span><span>name</span> = <span>&#34;high_performance_rust_with_sqlite&#34;</span>
</span></span><span><span><span>version</span> = <span>&#34;0.1.0&#34;</span>
</span></span><span><span><span>edition</span> = <span>&#34;2018&#34;</span>
</span></span><span><span>
</span></span><span><span><span># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>
</span></span><span><span>
</span></span><span><span>[<span>dependencies</span>]
</span></span><span><span><span>tokio</span> = { <span>version</span> = <span>&#34;1&#34;</span>, <span>features</span> = [<span>&#34;full&#34;</span>] }
</span></span><span><span><span>sqlx</span> = { <span>version</span> = <span>&#34;0.5&#34;</span>, <span>features</span> = [ <span>&#34;runtime-tokio-rustls&#34;</span>, <span>&#34;sqlite&#34;</span>, <span>&#34;uuid&#34;</span>, <span>&#34;chrono&#34;</span>, <span>&#34;migrate&#34;</span> ] }
</span></span><span><span><span>futures</span> = <span>&#34;0.3&#34;</span>
</span></span><span><span><span>chrono</span> = <span>&#34;0.4&#34;</span>
</span></span><span><span><span>uuid</span> = { <span>version</span> = <span>&#34;0.8&#34;</span>, <span>features</span> = [<span>&#34;v4&#34;</span>] }
</span></span><span><span><span>clap</span> = <span>&#34;2&#34;</span>
</span></span></code></pre><p><strong>main.rs</strong></p>
<pre tabindex="0"><code><span><span><span>use</span> clap::{App, Arg};
</span></span><span><span><span>use</span> futures::<span>*</span>;
</span></span><span><span><span>use</span> sqlx::{
</span></span><span><span>    sqlite::{SqliteConnectOptions, SqliteJournalMode, SqlitePoolOptions, SqliteSynchronous},
</span></span><span><span>    Pool, Sqlite,
</span></span><span><span>};
</span></span><span><span><span>use</span> std::time::{Duration, Instant};
</span></span><span><span><span>use</span> std::{fs, <span>str</span>::FromStr};
</span></span><span><span>
</span></span><span><span><span>struct</span> <span>User</span> {
</span></span><span><span>    id: <span>uuid</span>::Uuid,
</span></span><span><span>    created_at: <span>chrono</span>::DateTime<span>&lt;</span>chrono::Utc<span>&gt;</span>,
</span></span><span><span>    username: String,
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>#[tokio::main]</span>
</span></span><span><span><span>async</span> <span>fn</span> <span>main</span>() -&gt; Result<span>&lt;</span>(), Box<span>&lt;</span><span>dyn</span> std::error::Error<span>&gt;&gt;</span> {
</span></span><span><span>    <span>let</span> cli_matches <span>=</span> App::new(<span>&#34;Rust to the mooooon&#34;</span>)
</span></span><span><span>        .version(<span>&#34;1.0&#34;</span>)
</span></span><span><span>        .arg(
</span></span><span><span>            Arg::with_name(<span>&#34;concurrency&#34;</span>)
</span></span><span><span>                .short(<span>&#34;c&#34;</span>)
</span></span><span><span>                .long(<span>&#34;concurrency&#34;</span>)
</span></span><span><span>                .help(<span>&#34;Number of concurrent inserts&#34;</span>)
</span></span><span><span>                .default_value(<span>&#34;3&#34;</span>),
</span></span><span><span>        )
</span></span><span><span>        .arg(
</span></span><span><span>            Arg::with_name(<span>&#34;inserts&#34;</span>)
</span></span><span><span>                .short(<span>&#34;i&#34;</span>)
</span></span><span><span>                .long(<span>&#34;inserts&#34;</span>)
</span></span><span><span>                .help(<span>&#34;Number of inserts to perform&#34;</span>)
</span></span><span><span>                .default_value(<span>&#34;40000&#34;</span>),
</span></span><span><span>        )
</span></span><span><span>        .get_matches();
</span></span><span><span>
</span></span><span><span>    <span>let</span> concurrency <span>=</span> cli_matches
</span></span><span><span>        .value_of(<span>&#34;concurrency&#34;</span>)
</span></span><span><span>        .unwrap()
</span></span><span><span>        .parse::<span>&lt;</span><span>usize</span><span>&gt;</span>()
</span></span><span><span>        .unwrap_or(<span>1</span>);
</span></span><span><span>    <span>let</span> inserts <span>=</span> cli_matches
</span></span><span><span>        .value_of(<span>&#34;inserts&#34;</span>)
</span></span><span><span>        .unwrap()
</span></span><span><span>        .parse::<span>&lt;</span><span>usize</span><span>&gt;</span>()
</span></span><span><span>        .unwrap_or(<span>1</span>);
</span></span><span><span>
</span></span><span><span>    <span>let</span> database_file <span>=</span> <span>&#34;db.sqlite&#34;</span>;
</span></span><span><span>    <span>let</span> database_url <span>=</span> format!(<span>&#34;sqlite://{}&#34;</span>, database_file);
</span></span><span><span>    <span>let</span> pool_timeout <span>=</span> Duration::from_secs(<span>30</span>);
</span></span><span><span>    <span>// with pool_max_connections = 1, the pool timeout. maybe related to https://github.com/launchbadge/sqlx/issues/1210
</span></span></span><span><span><span></span>    <span>let</span> pool_max_connections <span>=</span> <span>if</span> concurrency <span>==</span> <span>1</span> {
</span></span><span><span>        <span>2</span>
</span></span><span><span>    } <span>else</span> {
</span></span><span><span>        concurrency <span>as</span> <span>u32</span>
</span></span><span><span>    };
</span></span><span><span>
</span></span><span><span>    <span>let</span> _ <span>=</span> fs::remove_file(database_file);
</span></span><span><span>
</span></span><span><span>    <span>let</span> connection_options <span>=</span> SqliteConnectOptions::from_str(<span>&amp;</span>database_url)<span>?</span>
</span></span><span><span>        .create_if_missing(<span>true</span>)
</span></span><span><span>        .journal_mode(SqliteJournalMode::Wal)
</span></span><span><span>        .synchronous(SqliteSynchronous::Normal)
</span></span><span><span>        .busy_timeout(pool_timeout);
</span></span><span><span>
</span></span><span><span>    <span>let</span> sqlite_pool <span>=</span> SqlitePoolOptions::new()
</span></span><span><span>        .max_connections(pool_max_connections)
</span></span><span><span>        .connect_timeout(pool_timeout)
</span></span><span><span>        .connect_with(connection_options)
</span></span><span><span>        .<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    sqlx::migrate<span>!</span>(<span>&#34;./db&#34;</span>).run(<span>&amp;</span>sqlite_pool).<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    sqlx::query(<span>&#34;pragma temp_store = memory;&#34;</span>)
</span></span><span><span>        .execute(<span>&amp;</span>sqlite_pool)
</span></span><span><span>        .<span>await</span><span>?</span>;
</span></span><span><span>    sqlx::query(<span>&#34;pragma mmap_size = 30000000000;&#34;</span>)
</span></span><span><span>        .execute(<span>&amp;</span>sqlite_pool)
</span></span><span><span>        .<span>await</span><span>?</span>;
</span></span><span><span>    sqlx::query(<span>&#34;pragma page_size = 4096;&#34;</span>)
</span></span><span><span>        .execute(<span>&amp;</span>sqlite_pool)
</span></span><span><span>        .<span>await</span><span>?</span>;
</span></span><span><span>
</span></span><span><span>    println!(
</span></span><span><span>        <span>&#34;Inserting {} records. concurrency: {}&#34;</span>,
</span></span><span><span>        inserts, concurrency
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    <span>let</span> start <span>=</span> Instant::now();
</span></span><span><span>    insert(inserts, concurrency, <span>&amp;</span>sqlite_pool).<span>await</span>;
</span></span><span><span>    <span>let</span> duration <span>=</span> start.elapsed();
</span></span><span><span>
</span></span><span><span>    <span>let</span> inserts_per_sec <span>=</span> inserts <span>as</span> <span>f64</span> <span>/</span> duration.as_secs_f64();
</span></span><span><span>    println!(
</span></span><span><span>        <span>&#34;Time elapsed to insert {} records: {:?} ({:.2} inserts/s)&#34;</span>,
</span></span><span><span>        inserts, duration, inserts_per_sec
</span></span><span><span>    );
</span></span><span><span>
</span></span><span><span>    Ok(())
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>async</span> <span>fn</span> <span>insert</span>(inserts: <span>usize</span>, concurrency: <span>usize</span>, sqlite_pool: <span>&amp;</span><span>Pool</span><span>&lt;</span>Sqlite<span>&gt;</span>) {
</span></span><span><span>    <span>let</span> stream <span>=</span> stream::iter(<span>0</span><span>..</span>inserts);
</span></span><span><span>
</span></span><span><span>    stream
</span></span><span><span>        .for_each_concurrent(concurrency, <span>|</span>_<span>|</span> <span>async</span> <span>move</span> {
</span></span><span><span>            <span>let</span> user <span>=</span> User {
</span></span><span><span>                id: <span>uuid</span>::Uuid::new_v4(),
</span></span><span><span>                created_at: <span>chrono</span>::Utc::now(),
</span></span><span><span>                username: String::from(<span>&#34;Hello&#34;</span>),
</span></span><span><span>            };
</span></span><span><span>
</span></span><span><span>            sqlx::query(
</span></span><span><span>                <span>&#34;INSERT INTO users (id, created_at, username)
</span></span></span><span><span><span>            VALUES (?, ?, ?)&#34;</span>,
</span></span><span><span>            )
</span></span><span><span>            .bind(user.id)
</span></span><span><span>            .bind(user.created_at)
</span></span><span><span>            .bind(<span>&amp;</span>user.username)
</span></span><span><span>            .execute(sqlite_pool)
</span></span><span><span>            .<span>await</span>
</span></span><span><span>            .expect(<span>&#34;inserting in db&#34;</span>);
</span></span><span><span>        })
</span></span><span><span>        .<span>await</span>;
</span></span><span><span>}
</span></span></code></pre><p><strong>db/000_init.sql</strong></p>
<pre tabindex="0"><code><span><span><span>CREATE</span> <span>TABLE</span> <span>IF</span> <span>NOT</span> <span>EXISTS</span> users (
</span></span><span><span>    id BLOB <span>PRIMARY</span> <span>KEY</span> <span>NOT</span> <span>NULL</span>,
</span></span><span><span>    created_at TEXT <span>NOT</span> <span>NULL</span>,
</span></span><span><span>    username TEXT <span>NOT</span> <span>NULL</span>
</span></span><span><span>);
</span></span><span><span>
</span></span><span><span><span>CREATE</span> <span>UNIQUE</span> <span>INDEX</span> idx_users_on_id <span>ON</span> users(id);
</span></span></code></pre><h2 id="concurrency">Concurrency</h2>
<p>Increasing concurrency should increase performance, right?</p>
<pre><code>$ cargo run --release -- -c 100 -i 100000
Inserting 100000 records. concurrency: 100
Time elapsed to insert 100000 records: 10.255768373s (9750.61 inserts/s)
</code></pre>
<p>What happens? <a href="https://www.sqlite.org/lockingv3.html">SQLite allows only one concurrent write</a> to a database. Thus, if we increase concurrency too much, we encounter lock contention, and performance is degraded.</p>
<p>One way to limit lock contention is to use concurrency primitives in your own code and a good scheduler. In this example, we use a <a href="https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html#method.for_each_concurrent">Stream</a> with <a href="https://tokio.rs/">tokio</a> which seem way better at handling concurrency than SQLite&#39;s locking mechanism.</p>
<h2 id="the-machine">The machine</h2>
<p>For the record, the server is a <a href="https://www.scaleway.com/en/pricing/#enterprise-instances">Scaleway ENT1-S</a>, so not the slowest VPS of the market, but not that expensive either.</p>
<pre tabindex="0"><code><span><span>$ sudo lscpu
</span></span></code></pre><pre><code>Architecture:                    x86_64
CPU op-mode(s):                  32-bit, 64-bit
Byte Order:                      Little Endian
Address sizes:                   40 bits physical, 48 bits virtual
CPU(s):                          8
On-line CPU(s) list:             0-7
Thread(s) per core:              1
Core(s) per socket:              8
Socket(s):                       1
NUMA node(s):                    1
Vendor ID:                       AuthenticAMD
CPU family:                      25
Model:                           1
Model name:                      AMD EPYC 7543 32-Core Processor
Stepping:                        1
CPU MHz:                         2794.750
BogoMIPS:                        5589.50
Virtualization:                  AMD-V
Hypervisor vendor:               KVM
Virtualization type:             full
L1d cache:                       512 KiB
L1i cache:                       512 KiB
L2 cache:                        4 MiB
L3 cache:                        16 MiB
NUMA node0 CPU(s):               0-7
Vulnerability Itlb multihit:     Not affected
Vulnerability L1tf:              Not affected
Vulnerability Mds:               Not affected
Vulnerability Meltdown:          Not affected
Vulnerability Spec store bypass: Mitigation; Speculative Store Bypass disabled via prctl and seccomp
Vulnerability Spectre v1:        Mitigation; usercopy/swapgs barriers and __user pointer sanitization
Vulnerability Spectre v2:        Mitigation; Full AMD retpoline, IBPB conditional, STIBP disabled, RSB filling
Vulnerability Srbds:             Not affected
Vulnerability Tsx async abort:   Not affected
Flags:                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx mmx
                                 ext fxsr_opt pdpe1gb rdtscp lm rep_good nopl cpuid extd_apicid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse
                                 4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm cmp_legacy svm cr8_l
                                 egacy abm sse4a misalignsse 3dnowprefetch osvw perfctr_core ssbd ibpb stibp vmmcall fsgsbase tsc_adjust bmi1 avx2 s
                                 mep bmi2 rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 wbnoinvd arat npt nrip_save umip vaes vpclm
                                 ulqdq arch_capabilities
</code></pre>
<pre tabindex="0"><code><span><span>$ sudo lshw -class disk -class storage
</span></span></code></pre><pre><code>  *-scsi
       description: SCSI storage controller
       product: Virtio SCSI
       vendor: Red Hat, Inc.
       physical id: 1
       bus info: pci@0000:00:01.0
       version: 01
       width: 64 bits
       clock: 33MHz
       capabilities: scsi msix bus_master cap_list
       configuration: driver=virtio-pci latency=0
       resources: iomemory:180-17f irq:21 memory:9100a000-9100afff memory:1800000000-1800003fff
  *-sata
       description: SATA controller
       product: 82801IR/IO/IH (ICH9R/DO/DH) 6 port SATA Controller [AHCI mode]
       vendor: Intel Corporation
       physical id: 1f.2
       bus info: pci@0000:00:1f.2
       version: 02
       width: 32 bits
       clock: 33MHz
       capabilities: sata msi ahci_1.0 bus_master cap_list
       configuration: driver=ahci latency=0
       resources: irq:36 ioport:1040(size=32) memory:91000000-91000fff
  *-scsi
       physical id: 5
       logical name: scsi0
     *-disk
          description: SCSI Disk
          product: b_ssd
          vendor: SCW
          physical id: 0.0.0
          bus info: scsi@0:0.0.0
          logical name: /dev/sda
          version: v42
          size: 13GiB (15GB)
          capabilities: 5400rpm gpt-1.00 partitioned partitioned:gpt
          configuration: ansiversion=5 guid=9ceb264d-ecc9-413c-a6dc-180fa42c5342 logicalsectorsize=512 sectorsize=4096
</code></pre>
<h2 id="conclusion">Conclusion</h2>
<p><strong>Less is more.</strong></p>
<p>This post was nothing more than just a reminder than you don&#39;t need a fancy serverless cluster (??) to crunch some serious numbers.</p>
<p>We all agree that testing new tech is fun and exciting, myself included (after all you are on a blog talking about Rust). But new tech is often marketed by hiding its drawbacks, and they will come back to bite you at the worst time when scaling your business.</p>
<p>If SQLite is not the best choice for you due to its <a href="https://www.sqlite.org/datatype3.html">anemic and dynamic typing</a>, or its lack of high-availability, take a look at <a href="https://www.postgresql.org">PostgreSQL</a> :)</p>
<h2 id="the-code-is-on-github">The code is on GitHub</h2>
<p>As usual, you can find the code on GitHub: <a href="https://github.com/skerkour/kerkour.com/tree/main/blog/2021/high_performance_rust_with_sqlite">github.com/skerkour/kerkour.com</a> (please don&#39;t forget to star the repo 🙏)</p>

  </div></div>
  </body>
</html>
