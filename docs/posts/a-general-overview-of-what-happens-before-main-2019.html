<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://embeddedartistry.com/blog/2019/04/08/a-general-overview-of-what-happens-before-main/">Original</a>
    <h1>A general overview of what happens before main() (2019)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p><a href="https://embeddedartistry.com/blog/2019/04/08/">8 April 2019</a>  • Last updated 22 August 2022</p><p>For most programmers, a <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;C&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A general-purpose imperative programming language widely used for embedded systems development.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/c/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">C</a> or <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;C++&lt;/div&gt;&lt;div class=glossaryItemBody&gt;C++ is a compiled programming language originally derived from C. C++ supports object-oriented, generic, and functional programming features.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/cpp/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">C++</a> program’s life begins at the <code>main</code> function. They are blissfully unaware of the hidden steps that happen between invoking a program and executing <code>main</code>. Depending on the program and the compiler, there are all kinds of interesting functions that get run before <code>main</code>, automatically inserted by the compiler and linker and invisible to casual observers.</p>
<p>Unfortunately for programmers who are curious about the program startup process, the literature on what happens before <code>main</code> is quite sparse.</p>
<p>Embedded Artistry has been hard at working creating a C++ embedded framework. The final piece of the puzzle was implementing program startup code. To aid in the design of our framework’s boot process, I performed an exploratory survey of existing program startup implementations. My goal was to identify a general program startup model. I also want to provide a more comprehensive look into how our programs get to <code>main</code>.</p>
<p>In this six-part series, we will be investigating what it takes to get to <code>main</code>:</p>
<ol><li>What Happens Before <code>main()</code>?</li>
<li><a href="https://embeddedartistry.com/blog/2019/4/16/exploring-startup-implementations-newlib-arm">Exploring Startup Implementations: Newlib (ARM)</a></li>
<li><a href="https://embeddedartistry.com/blog/2019/5/13/exploring-startup-implementations-os-x">Exploring Startup Implementations: OS X</a></li>
<li>Exploring Startup Implementations: Custom Embedded System with ThreadX</li>
<li>Abstracting a Generic Flow for Getting to <code>main</code></li>
<li>Implementing our Generic Startup Flow</li>
</ol><hr/><p>To begin our investigation into how programs start, we will provide a summary of what happens in a program before <code>main</code>. The steps and responsibilities we describe are generalized so that they apply to <em>many</em> systems. We will supplement the general theory in the following articles with an analysis of real-world implementations.</p>
<p><strong>Table of Contents:</strong></p>
<ol><li><a href="#genview">Getting to Main: A General Overview</a>
<ol><li><a href="#start">The <code>_start</code> Function</a></li>
<li><a href="#runtimesetup">Runtime Setup</a></li>
<li><a href="#otherscaffolding">Other Scaffolding</a></li>
<li><a href="#jumping">Jumping to <code>main</code></a></li>
<li><a href="#returning">Returning from <code>main</code></a></li>
</ol></li>
<li><a href="#how">How Do We Get to <code>_start</code>?</a>
<ol><li><a href="#baremetalresetvector">Baremetal: reset vector</a></li>
<li><a href="#bootloaderlaunchesapplication">Bootloader launches application</a></li>
<li><a href="#exec">OS Calls an <code>exec</code> function</a></li>
</ol></li>
<li><a href="#exploringonyourown">Exploring On Your Own</a></li>
<li><a href="#furtherreading">Further Reading</a></li>
</ol><h2 id="genview">Getting to Main: A General Overview</h2>
<p>Before we dive into our exploration of how existing systems get to <code>main</code>, we should develop a hypothesis about what generally happens. Since others have already explored program startup, we can start with a clear idea of what happens before <code>main</code>.</p>
<h3 id="start">The <code>_start</code> Function</h3>
<p>For most C and C++ programs, the true entry point is not <code>main</code>, it’s the <code>_start</code> function. This function initializes the program runtime and invokes the program’s <code>main</code> function.</p>
<p>The use of <code>_start</code> is merely a general convention. The entry function can vary depending on the system, compiler, and standard libraries. For example, <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;Operating System [OS]&lt;/div&gt;&lt;div class=glossaryItemBody&gt;System software that manages computer hardware, software resources, and provides common services for computer programs.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/operating-system/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">OS</a> X only has dynamically linked applications; the <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;Program Loader&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A program loader is the part of an OS that is responsible for loading programs and libraries for execution.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/program-loader/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">loader</a> takes care of setup, and the entry point to the program is actually <code>main</code>.</p>
<p>The linker controls the program’s entry point. The default entry point can be overridden by clang and GCC linkers using the <code>-e</code> flag, although this is rarely done for most programs.</p>
<p>The implementation of the <code>_start</code> function is usually supplied by <code><a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;libc&lt;/div&gt;&lt;div class=glossaryItemBody&gt;The C standard library is commonly known as &amp;quot;libc&amp;quot;. This library provides the macros, types, and function implementations for the C programming language.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/libc/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">libc</a></code>. The <code>_start</code> function is often written in assembly. Many implementations store the <code>_start</code> function in a file called <code>crt0.s</code>. Compilers typically ship with pre-compiled <code>crt0.o</code> object files for each supported architecture.</p>
<p>Although much of this code is usually implemented by the C runtime, program startup code behavior is not specified by the C and C++ standards. Instead, the standards describe the conditions that must be true when the <code>main</code> function is called. However, there are many steps that are commonly performed across the majority of <code>_start</code> implementations.</p>
<p>At a high level, the <code>_start</code> function handles:</p>
<ol><li>Early low-level initialization, such as:
<ol><li>Configuring processor registers</li>
<li>Initializing external memory</li>
<li>Enabling caches</li>
<li>Configuring the <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Memory Management Unit [MMU]&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=glossaryItemBody&gt;&amp;quot;A computer hardware unit having all memory references passed through itself, primarily performing the translation of virtual memory addresses to physical addresses.”&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/memory-management-unit/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">MMU</a></li>
</ol></li>
<li>Stack initialization, making sure that the stack is properly aligned per the <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Application-Binary Interface [ABI]&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=glossaryItemBody&gt;&amp;quot;An interface between two binary program modules. ABIs are commonly established between user programs and libraries, OS services, and programming languages.”&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/application-binary-interface/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">ABI</a> requirements</li>
<li>Frame pointer initialization</li>
<li>Initialization of the C/C++ runtime</li>
<li>Initialization of other scaffolding required by the system</li>
<li>Jumping to <code>main</code></li>
<li>Exiting the program with the return code from <code>main</code></li>
</ol><p>While the <code>_start</code> routine typically encompasses these activities, the specific order and implementation varies from system to system. For example, <em>early low-level initialization</em> code is commonly found with bare-metal embedded systems, but rarely on host machines with an OS. Your Linux or OS X program startup code will have multiple scaffolding functions which you will not find in embedded startup code.</p>
<p>Let’s take a look at a simple implementation of an x86_64 <code>_start</code> function taken from the <a href="https://wiki.osdev.org/Creating_a_C_Library">OS Dev wiki</a>. This example provides us with a preview of the basic skeleton for program startup. The implementations we will review later in this series are much more complex.</p>
<p>The startup code below assumes that the program loader put:</p>
<ul><li><code>*argv</code> and <code>*envp</code> variables on the stack</li>
<li><code>argc</code> in register <code>%rdi</code></li>
<li><code>argv</code> in register <code>%rsi</code></li>
<li><code>envc</code> in register <code>%rdx</code></li>
<li><code>envp</code> in register <code>%rcx</code></li>
</ul><p>Here’s the implementation of <code>_start</code>:</p>
<pre><code>.section .text

.global _start
_start:
    # Set up end of the stack frame linked list
    movq $0, %rbp
    pushq %rbp # rip=0
    pushq %rbp # rbp=0
    movq %rsp, %rbp

    # Save argc and argv on the stack
    # We need those in a moment when we call main
    pushq %rsi
    pushq %rdi

    # Prepare signals, memory allocation, stdio, etc.
    call initialize_standard_library

    # Run the global constructors.
    call _init

    # Restore argc and argv before calling main
    popq %rdi
    popq %rsi

    # Run main
    call main

    # Terminate the process with the exit code 
    # that was returned from main
    movl %eax, %edi
    call exit</code></pre>
<p>Let’s dive in and see what happens during the runtime setup process (<code>initialize_standard_library</code> above).</p>
<h3 id="runtimesetup">Runtime Setup</h3>
<p>C/C++ runtime setup is a universal <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;Requirement&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A requirement is a formal statement that identifies a condition to be met by a designed artifact.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/requirement/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">requirement</a> for program startup. At a high level, our runtime setup must accomplish the following:</p>
<ol><li>Relocate any relocatable sections (if not handled by the loader or linker)</li>
<li>Initializing global and static memory</li>
<li>Prepare the <code>argc</code> and <code>argv</code> variables for invoking <code>main</code> (even if it’s just setting these to <code>0</code>/<code>NULL</code>)</li>
<li>Perform any additional setup steps required by the C/C++ standard library implementation.</li>
</ol><p>Initializing global and static memory is broken down into two distinct steps that deserve additional details.</p>
<p>First, the runtime initializes a subset of <em>uninitialized</em> memory (no <code>=</code> in the declaration) to <code>0</code>. This includes global and static variables, but not stack variables. All uninitialized data that needs to be set to <code>0</code> is placed into the <a href="https://en.wikipedia.org/wiki/.bss"><code>.bss</code></a> section of the compiled program image by the linker. The location of the <code>.bss</code> section is identified during initialization, and the memory is typically set to <code>0</code> with <code>memset</code>.</p>
<p>Second, C++ global objects must be constructed before calling <code>main</code>. The linker places these constructors into the <code>.init</code>, <code>.init_array</code>, or <code>.ctors</code> section of the image. Some compilers also allow C and C++ functions to be marked as a constructor using a compiler attribute (e.g., <code>__attribute__((constuctor))</code>). The constructors are stored in a list by the linker. The runtime initialization process iterates through the list and calls each constructor.</p>
<p>These additional runtime initialization steps are run for many programs (but not all):</p>
<ol><li>Heap initialization</li>
<li>Initialize <code>stdio</code> (i.e., <code>stdin</code>, <code>stdout</code>, <code>stderr</code>)</li>
<li>Initialize exception support (if using C++)</li>
<li>Register destructors and other cleanup functions that will run when exiting the program (using <code>atexit</code> and <code>__cxa_atexit</code>)</li>
<li>Prepare environment variables</li>
</ol><p>In practice, the line between the responsibilities of <code>_start</code> and the C runtime initialization can be fuzzy. Some implementations of <code>_start</code> handle pieces of the runtime setup directly, such as setting the <code>.bss</code> section contents to <code>0</code> and calling global constructors. Other implementations handle these tasks as part of the C runtime setup routines.</p>
<p>Assembly files commonly found during this portion of the startup process are <code>crtbegin.s</code>, <code>crtend.s</code>, <code>crti.s</code>, and <code>crtn.s</code>. Compilers often ship pre-compiled object files for supported architectures. These files are related to calling global constructors and destructors. When the files are not used, equivalent functionality is often implemented in C and invoked during runtime initialization.</p>
<h3 id="otherscaffolding">Other Scaffolding</h3>
<p>The setup process may invoke other functions to set up program scaffolding that the system requires. Program scaffolding setup before <code>main</code> might include:</p>
<ol><li>Threading support and thread local storage</li>
<li><a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;Buffer Overflow&lt;/div&gt;&lt;div class=glossaryItemBody&gt;A buffer overflow (or buffer overrun) is an error that occurs when a program writes data to a buffer while overrunning that buffer&amp;#039;s boundary.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/buffer-overflow/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">Buffer overrun</a> detection</li>
<li>Stack logging</li>
<li>Run-time error checks</li>
<li>Locale settings</li>
<li>Math error handling</li>
<li>Default math library precision</li>
</ol><p>The specific scaffolding functions invoked vary across standard library implementations and operating systems.</p>
<h3 id="jumping">Jumping to <code>main</code></h3>
<p>Once we have a fully initialized system, we can safely jump to <code>main</code> and execute the programmer’s portion of the application.</p>
<p>The most important aspect: once the program reaches <code>main</code>, it must be in a standards-conforming state. Otherwise, the program’s assumptions will be invalidated.</p>
<h3 id="returning">Returning From <code>main</code></h3>
<p>While we were primarily interested in how we get to <code>main</code>, we should finish our explanation of the <code>_start</code> function’s responsibilities.</p>
<p>Because <code>_start</code> invokes <code>main</code>, it also handles its return. When control returns from <code>main</code> to <code>_start</code>, the next function to run is <code>exit</code>. The <code>exit</code> function calls all functions registered with <code>atexit</code>and <code>__cxa_atexit</code> during the startup process. Then <code>exit</code> calls the global destructors (those placed in the <code>.fini</code>, <code>.fini_array</code>, or <code>.dtors</code> sections). Finally, <code>exit</code> terminates the program with the return value provided by <code>main</code>.</p>
<p>The <code>exit</code> function is primarily used for hosted programs. Bare metal programs rarely have use for the <code>exit</code> function or global destructors.</p>
<h2 id="how">How Do We Get to <code>_start</code>?</h2>
<p>Now that we know how our program gets to <code>main</code> by way of the <code>_start</code> function, you may wonder how the program gets to <code>_start</code>.</p>
<p>There are three common paths:</p>
<ol><li><a href="#baremetal-reset-vector">Baremetal: reset vector</a></li>
<li><a href="#bootloader-launches-application">Bootloader launches application</a></li>
<li><a href="#os-calls-an-exec-function">OS Calls an <code>exec</code> function</a></li>
</ol><h3 id="baremetal:resetvector">Baremetal: Reset Vector</h3>
<p>A baremetal embedded application represents the simplest path to <code>_start</code>.</p>
<p>Consider a baremetal platform with a binary stored in flash memory. When power is applied to the processor, the processor will copy the program from flash and store it in RAM<sup>1</sup>. Once the program is loaded into memory, the processor jumps to the reset interrupt vector address.</p>
<p>The embedded program’s reset interrupt handler initializes the system after power-on or reset. The reset handler typically performs an initial configuration of the processor registers and critical hardware components (such as external RAM, caches, or MMU). Once this initial configuration is complete, the reset handler jumps to <code>_start</code>.</p>
<p>Some systems do not utilize the C standard library, and in that case <code>_start</code> will not be called. Instead, the reset handler will invoke other setup functions or will directly execute necessary program setup steps.</p>
<p><em><sup>1</sup>: If the chip supports execute-in-place (<a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;Execute-in-Place [XIP]&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=glossaryItemBody&gt;Refers to the capability for a processor to run a program directly from ROM (such as Flash). Processors without XIP capability must copy the entire program to memory before it can run.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/execute-in-place/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">XIP</a>), the processor will skip the copy step and run the program directly from flash memory.</em></p>
<h3 id="bootloaderlaunchesapplication">Bootloader Launches Application</h3>
<p>Many embedded applications are composed of multiple distinct images which run sequentially during the boot process.</p>
<p>Many systems use a bootloader or hypervisor, which runs before loading and executing the main application. Bootloaders perform a wide range of activities, including initializing system hardware, decryption, decompression, checking that a firmware image is valid before loading it, selecting a firmware image to boot, or determining whether to enter firmware update mode. Bootloader complexity depends on the system’s requirements; not of the listed tasks will be performed.</p>
<p>Other systems require an incremental boot process, especially when the main application is larger than the processor’s internal RAM capacity. The first boot stage is typically a small image which fits into the processor’s internal memory. This image will initialize external RAM and load the main application from flash into the external RAM. The first stage boot may perform additional steps, such as processor vector remapping or MMU configuration. Once the main application is loaded, the first stage boot invokes the reset vector of the main application.</p>
<p>Multi-stage boot scenarios complicate the program startup model. Each boot stage is technically a standalone program. However, not every stage will run through the full program startup process. Simple boot stages may only need to clear the <code>.bss</code> section to perform their duties, while complex bootloaders need a fully initialized C/C++ runtime. Program startup activities may be distributed across the boot process, with each stage handling specific tasks.</p>
<h3 id="exec">OS Calls an <code>exec</code> function</h3>
<p>The most complex scenario is running a program on a host machine with a fully-fledged OS.</p>
<p>When you launch a program, your shell or GUI invokes a program loader. The loader is responsible for copying the application image from the hard drive into memory and configuring the environment that the program will run in. On Linux or OS X, the loader is a function in the <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/environ.html"><code>exec()</code></a> family, typically <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/environ.html"><code>execve()</code> or <code>execvp()</code></a>. For Windows, the loader is the <code>LdrInitializeThunk</code>function in <code>ntdll.dll</code>.</p>
<p>Loaders will often perform the following actions:</p>
<ul><li>Check permissions</li>
<li>Allocate space for the program’s stack</li>
<li>Allocate space for the program’s heap</li>
<li>Initialize registers (e.g., stack pointer)</li>
<li>Push <code>argc</code>, <code>argv</code>, and <code>envp</code> onto the program stack</li>
<li>Map virtual address spaces</li>
<li>Dynamic linking</li>
<li>Relocations</li>
<li>Call pre-initialization functions</li>
</ul><p>Once the loader has configured the program environment, it calls the program’s <code>_start</code> function.</p>
<h2 id="exploringonyourown">Exploring On Your Own</h2>
<p>In the coming, we will review a selection of startup procedures which differ greatly in terms of process and style.</p>
<p>We won’t be reviewing Linux program startup, because there are already high-quality articles on that topic. For detailed descriptions about how Linux programs start, we recommend these articles:</p>
<ol><li><a href="https://lwn.net/Articles/630727/">How Programs Get Run</a></li>
<li><a href="https://%5Blwn.net/Articles/631631/%5D(http://lwn.net/Articles/631631/)">How Programs Get Run: ELF Binaries</a></li>
<li><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up or – How the heck do we get to main()?</a></li>
</ol><p>The startup code that your system runs is supplied by your <a href="https://github.com/embeddedartistry/libc"><code>libc</code></a> implementation and system libraries, and the implementations will also vary depending on the target architecture. Don’t be surprised if you find a different startup process than those described in this series and in <a href="#further-reading">other articles around the web</a>.</p>
<p>You can explore your own program’s startup behavior using <code>objdump</code> or a debugger (I.e. <code>gdb</code>, <code>lldb</code>). You can use <a aria-describedby="tt" data-cmtooltip="&lt;div class=glossaryItemTitle&gt;&lt;span class=&amp;quot;dashicons &amp;quot; data-icon=&amp;quot;&amp;quot; style=&amp;quot;display:inline;vertical-align:baseline;&amp;quot;&gt;&lt;/span&gt;Debugging [Dbg]&lt;/div&gt;&lt;div class=glossaryItemBody&gt;The process of identifying and resolving defects or errors within a computer program.&lt;/div&gt;" href="https://embeddedartistry.com/fieldmanual-terms/debugging/" data-gt-translate-attributes="[{&#34;attribute&#34;:&#34;data-cmtooltip&#34;, &#34;format&#34;:&#34;html&#34;}]">debugging</a> tools to tackle the problem from a variety of directions:</p>
<ol><li>Set a breakpoint at <code>main()</code> and run a backtrace to see the function call stack</li>
<li>Set a breakpoint at <code>_start()</code> (or whatever entry point your backtrace shows) and step through the execution</li>
<li>Dump the assembly output for the program using <code>objdump</code></li>
</ol><p>As Daniel Näslund pointed out in the comments, your debugger may be configured to suppress backtraces that go past the <code>main</code> function. For <code>gdb</code>, you can run the following command:</p>
<pre data-prompt="(gdb)"><code>set backtrace past-main on</code></pre>
<h2 id="furtherreading">Further Reading</h2>
<ul><li><a href="https://www.youtube.com/watch?v=dOfucXtyEsU">Matt Godbolt – The Bits Between the Bits: How We Get to main()</a></li>
<li><a href="https://github.com/embeddedartistry/libc">Embedded Artistry libc</a></li>
<li><a href="https://amzn.to/2I4GyAH">Real Time C++: Chapter 8 and Section 3.6.2</a></li>
<li><a href="https://lwn.net/Articles/630727/">How Programs Get Run</a></li>
<li><a href="https://%5Blwn.net/Articles/631631/%5D(http://lwn.net/Articles/631631/)">How Programs Get Run: ELF Binaries</a></li>
<li><a href="https://www.geeksforgeeks.org/executing-main-in-c-behind-the-scene/">Executing main in C/C++: Behind the Scenes</a></li>
<li><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html">Linux x86 Program Start Up or How the heck do we get to main()?</a></li>
<li><a href="https://www.embecosm.com/appnotes/ean9/html/ch05s02.html">The C Runtime Initialization, crt0.o</a></li>
<li><a href="https://www.bigmessowires.com/2015/10/02/what-happens-before-main/">What Happens Before Main</a></li>
<li><a href="https://wiki.osdev.org/Creating_a_C_Library">OSDev Wiki: Creating a C Library</a></li>
<li><a href="https://wiki.osdev.org/Calling_Global_Constructors">OSDev Wiki: Calling Global Constructors</a></li>
<li><a href="https://wiki.osdev.org/C%2B%2B">OSDev Wiki: C++</a></li>
<li><a href="https://www.linuxjournal.com/article/6463">Linkers and Loaders</a></li>
<li><a href="https://en.wikipedia.org/wiki/Loader_(computing)">Wikipedia: Loader (Computing)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dynamic_linker">Wikipedia: Dynamic Linker</a></li>
<li><a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/environ.html">Open Group: Execute a File</a></li>
<li><a href="https://en.wikipedia.org/wiki/.bss">Wikipedia: <code>.bss</code></a></li>
<li><a href="https://interrupt.memfault.com/blog/tag/zero-to-main">Memfault: Zero to Main() Series</a>
<ul><li><a href="https://interrupt.memfault.com/blog/zero-to-main-1">Bare Metal C</a></li>
<li><a href="https://interrupt.memfault.com/blog/how-to-write-a-bootloader-from-scratch">How to Write a Bootloader from Scratch</a></li>
</ul></li>
</ul><p id="jp-relatedposts">
	<h3><em>Related</em></h3>
</p><div><p>Related Terms:</p><ul><li><a href="https://embeddedartistry.com/fieldmanual-terms/application-binary-interface/">Term: Application-Binary Interface</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/memory-management-unit/">Term: Memory Management Unit</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/operating-system/">Term: Operating System</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/execute-in-place/">Term: Execute-in-Place</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/program-loader/">Term: Program Loader</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/buffer-overflow/">Term: Buffer Overflow</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/requirement/">Term: Requirement</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/debugging/">Term: Debugging</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/c/">Term: C</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/cpp/">Term: C++</a></li><li><a href="https://embeddedartistry.com/fieldmanual-terms/libc/">Term: libc</a></li></ul></div>	</div></div>
  </body>
</html>
