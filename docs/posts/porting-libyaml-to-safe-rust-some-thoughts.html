<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simonask.github.io/libyaml-safer/">Original</a>
    <h1>Porting Libyaml to Safe Rust: Some Thoughts</h1>
    
    <div id="readability-page-1" class="page"><div>
          
<span>
  
  ,
  
  <time datetime="2024-02-08">2024-02-08</time>
</span>
<hr/>




<p>The following is a loose collection of thoughts that came up while porting
<a href="https://github.com/dtolnay/unsafe-libyaml">unsafe-libyaml</a> to safe, idiomatic Rust, which may be useful to someone else
who is considering &#34;rewriting it in Rust&#34;, as the ancient journeyman prayer
goes.</p>
<p><em>Some context:</em> <a href="https://yaml.org/">YAML</a> is a commonly used markup language, similar to JSON, and
the primary way that Rust programmers interact with it is through <a href="https://crates.io/crates/serde_yaml">serde_yaml</a>,
a serializer/deserializer implementation targeting YAML through the very popular
Serde framework, which is backed by an almost verbatim machine translation of
the C <a href="https://pyyaml.org/wiki/LibYAML">libyaml</a> library into unsafe Rust, called <a href="https://github.com/dtolnay/unsafe-libyaml">unsafe-libyaml</a>. The
translation is made with <a href="https://c2rust.com/">c2rust</a>, with only minor fixes applied manually.</p>
<p>In my case, I was in a situation where I needed to interact with YAML in a way
where <a href="https://crates.io/crates/serde_yaml">serde_yaml</a> came up short. Specifically I needed input location markers
outside of error messages to support diagnostics and debugging in the context of
a game, where the AI behavior trees are defined in YAML files.</p>
<p>But the unsafe libyaml API is actually pretty unwieldy to use from Rust, even
when translated to Rust code, because it behaves exactly like the C code, so it
is no different than calling out to an actual C library with FFI. So I - perhaps
foolishly, in a flash of manic youthful optimism - decided to embark on the
journey of porting <a href="https://github.com/dtolnay/unsafe-libyaml">unsafe-libyaml</a> to safe Rust, function by function, line by
line. It took a little over a week.</p>
<p>The <a href="https://github.com/simonask/libyaml-safer">result is available on GitHub</a>.</p>
<h2 id="what-are-we-dealing-with">What are we dealing with?</h2>
<p>libyaml consists of two main components:</p>
<ul>
<li>YAML parser, which consumes a stream of bytes and produces &#34;events&#34;
representing the structure of the document.</li>
<li>YAML emitter, which consumes a stream of events and produces a stream of
bytes.</li>
</ul>
<p>The byte streams, both input and output, can be in different encodings, one of
UTF-8, UTF-16 little-endian, or UTF-16 big-endian. Most, but not all, Unicode
code points are supported - notably, control characters are not supported.</p>
<p>Events in libyaml are a linear representation of the logical structure of a
document, so higher level than parser tokens, but lower level than mappings,
sequences, and scalar values. Events are things like &#34;begin mapping&#34;, &#34;begin
mapping key&#34;, &#34;scalar&#34;, etc.</p>
<p>Libyaml also contains a high-level abstraction, <code>yaml_document_t</code>, which can
represent any YAML document. The parser can load a stream of events into a
document, and the emitter can produce a stream of events from a document.</p>
<h2 id="eldritch-horrors-or-just-c">Eldritch Horrors, or just C</h2>
<p><a href="https://pyyaml.org/wiki/LibYAML">libyaml</a> is squarely a C library, and reading it from the point of view of a
Rust programmer, there is a beautiful insanity to it all. It hails from a
simpler time, where concepts like ownership, mutability, and the fabric of
reality were up for debate.</p>
<p>It isn&#39;t &#34;wrong&#34;, just different. Unnecessarily difficult in many ways, but in
other ways refreshingly straightforward, so long as you can keep the cosmic
horror only just barely out of sight.</p>
<h3 id="string-theory">String Theory</h3>
<p>YAML is a human-readable format, and any parser for it must deal with a <em>lot</em> of
strings. Thankfully, libyaml does the sane thing and defines its own string type
- which almost every single C library in existence does, and even many larger
C++ libraries - and sometimes they don&#39;t even contain very many bugs. I swear
the history of the world would have looked very, very different if our venerable
forebears had extended their otherwise infinite benevolence to the inclusion of
a sane string type with the standard C library, but again I digress.</p>
<p>This is the string abstraction in <a href="https://pyyaml.org/wiki/LibYAML">libyaml</a>:</p>
<pre data-lang="c"><code data-lang="c"><span>struct </span><span>yaml_string_t {
</span><span>    </span><span>char</span><span>*</span><span> start;
</span><span>    </span><span>char</span><span>*</span><span> end;
</span><span>    </span><span>char</span><span>*</span><span> pointer; </span><span>// &lt;-- ???
</span><span>};
</span></code></pre>
<p>The <code>start</code> and <code>end</code> fields seem straightforward: A pointer to the beginning of
the string and a pointer to one-past-the-end of the string. So far so good. But
what about <code>pointer</code>? Some places in the code it is used as the actual end of
the string (so <code>end</code> is actually the end of the allocated capacity of the
string), and in others it is used as the actual start of the string, so <code>start</code>
is the beginning of the underlying allocation, and <code>pointer</code> is used to iterate
over bytes or substrings of the string.</p>
<p>What&#39;s going on here?</p>
<p>It turns out that this data structure serves multiple different purposes
simultaneously: It is both <code>&amp;str</code>, <code>String</code>, and <code>std::str::Iter</code>, all in one.
Sometimes it is even the <code>std::str::Chars</code> iterator, which is used to iterate
over full UTF-8 codepoints within the string. The only way to determine which
abstraction it is currently emulating is to look at the context.</p>
<p>Thankfully - libyaml being a well-structured C project - there are plenty of
context clues. When the <code>STRING_DEL()</code> macro is being used, the caller assumes
ownership. When the <code>STRING_ASSIGN()</code> macro is being used, the string is being
borrowed and/or used as an iterator.</p>
<p>The interesting takeaway is this: For all of the different roles that
<code>yaml_string_t</code> takes on, it turns out there is an abstraction in the Rust
standard library that matches each use case precisely. At all points in the
libyaml source code where strings are used, the use case maps directly to one of
the <em>several</em> many ways of dealing with strings in Rust. Phew!</p>
<p><em>Joyful aside:</em> There is a similar type in libyaml, called <code>yaml_buffer_t</code>. It
is slightly more complicated than strings, because it acts essentially as a ring
buffer, and it turned out to be almost very close to a <code>VecDeque</code> from the
standard library. Hooray!</p>
<h2 id="self-referential-types-oh-my">Self-referential types - Oh my!</h2>
<p>YAML syntax can represent the same thing in multiple ways. For example,
sequences and mappings can be represented in both &#34;flow style&#34; and &#34;block
style&#34;, and strings can be single-quoted, double-quoted, unquoted, block-quoted,
etc.</p>
<pre data-lang="yaml"><code data-lang="yaml"><span>flow_style_mapping</span><span>: { </span><span>a</span><span>: </span><span>&#34;Hello&#34;</span><span>, </span><span>b</span><span>: </span><span>&#34;World&#34; </span><span>},
</span><span>block_style_mapping</span><span>:
</span><span>  </span><span>a</span><span>: </span><span>Hello
</span><span>  </span><span>b</span><span>: </span><span>World
</span><span>flow_style_sequence</span><span>: [</span><span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>]
</span><span>block_style_sequence</span><span>:
</span><span>- </span><span>1
</span><span>- </span><span>2
</span><span>- </span><span>3
</span></code></pre>
<p>The libyaml emitter wants to choose both nice and correct formatting for the
output. Not just for the aesthetic, but also because some things actually
require specific styles - for example, escape sequences are only supported in
double-quoted strings, and some Unicode characters need to be represented as
escape sequences.</p>
<p>The emitter works by pushing &#34;events&#34; to a queue. Events are things like &#34;begin
mapping&#34;, &#34;begin mapping key&#34;, &#34;begin mapping value&#34;, &#34;end mapping&#34;, and so on,
and the emitter writes to the output when it has enough information to determine
the appropriate style.</p>
<p>This is implemented in libyaml as an &#34;analysis&#34; step that happens for each event
before the corresponding YAML is written to the output.</p>
<pre data-linenos="" data-lang="c"><code data-lang="c"><table><tbody><tr><td>1700</td><td><span>static int
</span></td></tr><tr><td>1701</td><td><span>yaml_emitter_analyze_event</span><span>(yaml_emitter_t </span><span>*</span><span>emitter</span><span>,
</span></td></tr><tr><td>1702</td><td><span>        yaml_event_t </span><span>*</span><span>event</span><span>)
</span></td></tr><tr><td>1703</td><td><span>{
</span></td></tr><tr><td>1704</td><td><span>    emitter-&gt;anchor_data.</span><span>anchor </span><span>= </span><span>NULL</span><span>;
</span></td></tr><tr><td>1705</td><td><span>    emitter-&gt;anchor_data.</span><span>anchor_length </span><span>= </span><span>0</span><span>;
</span></td></tr><tr><td>1706</td><td><span>    emitter-&gt;tag_data.</span><span>handle </span><span>= </span><span>NULL</span><span>;
</span></td></tr><tr><td>1707</td><td><span>    emitter-&gt;tag_data.</span><span>handle_length </span><span>= </span><span>0</span><span>;
</span></td></tr><tr><td>1708</td><td><span>    emitter-&gt;tag_data.</span><span>suffix </span><span>= </span><span>NULL</span><span>;
</span></td></tr><tr><td>1709</td><td><span>    emitter-&gt;tag_data.</span><span>suffix_length </span><span>= </span><span>0</span><span>;
</span></td></tr><tr><td>1710</td><td><span>    emitter-&gt;scalar_data.</span><span>value </span><span>= </span><span>NULL</span><span>;
</span></td></tr><tr><td>1711</td><td><span>    emitter-&gt;scalar_data.</span><span>length </span><span>= </span><span>0</span><span>;
</span></td></tr><tr><td>1712</td><td><span>
</span></td></tr><tr><td>1713</td><td><span>    </span><span>switch </span><span>(event-&gt;type)
</span></td></tr><tr><td>1714</td><td><span>    {
</span></td></tr><tr><td>1715</td><td><span>        </span><span>// ...
</span></td></tr><tr><td>1716</td><td><span>    }
</span></td></tr><tr><td>1717</td><td><span>    </span><span>// ...
</span></td></tr><tr><td>1718</td><td><span>}
</span></td></tr></tbody></table></code></pre>
<p>The analysis step populates the <code>emitter-&gt;anchor_data</code>, <code>emitter-&gt;tag_data</code>, and
<code>emitter-&gt;scalar_data</code> fields depending on the event type. Those fields that can
be <code>NULL</code> are C strings, and they refer to the strings contained within the
<code>event</code>. But the <code>event</code> comes from a queue owned by <code>yaml_emitter_t</code>. This is
great design in the C library, because it makes the analysis step extremely
cheap - no strings are duplicated, only &#34;borrowed&#34;.</p>
<p>So how do we express the analysis fields in safe Rust? Blindly porting the C
approach to Rust would result in <code>yaml_emitter_t</code> becoming self-referential,
since the analysis pointers would either point into the event queue or into an
event that was just popped from the queue, making it impossible to represent
that lifetime on <code>yaml_emitter_t</code> itself.</p>
<p><strong>Key Insight:</strong> Every time <code>yaml_emitter_analyze_event()</code> is called, it resets
any previous analysis results. It is called exactly once per event. Aha! What if
the results of the analysis was a return value from
<code>yaml_emitter_analyze_event()</code>, instead of modifying fields on the emitter?</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>derive</span><span>(Default)]
</span><span>struct </span><span>Analysis&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>pub </span><span>anchor</span><span>: Option&lt;AnchorAnalysis&lt;</span><span>&#39;a</span><span>&gt;&gt;,
</span><span>    </span><span>pub </span><span>tag</span><span>: Option&lt;TagAnalysis&lt;</span><span>&#39;a</span><span>&gt;&gt;,
</span><span>    </span><span>pub </span><span>scalar</span><span>: Option&lt;ScalarAnalysis&lt;</span><span>&#39;a</span><span>&gt;&gt;,
</span><span>}
</span><span>
</span><span>struct </span><span>AnchorAnalysis&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>pub </span><span>anchor</span><span>: </span><span>&amp;</span><span>&#39;a str</span><span>,
</span><span>    </span><span>pub </span><span>alias</span><span>: </span><span>bool</span><span>,
</span><span>}
</span><span>
</span><span>struct </span><span>TagAnalysis&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>pub </span><span>handle</span><span>: </span><span>&amp;</span><span>&#39;a str</span><span>,
</span><span>    </span><span>pub </span><span>suffix</span><span>: </span><span>&amp;</span><span>&#39;a str</span><span>,
</span><span>}
</span><span>
</span><span>struct </span><span>ScalarAnalysis&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>/// The scalar value.
</span><span>    </span><span>pub </span><span>value</span><span>: </span><span>&amp;</span><span>&#39;a str</span><span>,
</span><span>    </span><span>/// Does the scalar contain line breaks?
</span><span>    </span><span>pub </span><span>multiline</span><span>: </span><span>bool</span><span>,
</span><span>    </span><span>/// Can the scalar be expessed in the flow plain style?
</span><span>    </span><span>pub </span><span>flow_plain_allowed</span><span>: </span><span>bool</span><span>,
</span><span>    </span><span>/// Can the scalar be expressed in the block plain style?
</span><span>    </span><span>pub </span><span>block_plain_allowed</span><span>: </span><span>bool</span><span>,
</span><span>    </span><span>/// Can the scalar be expressed in the single quoted style?
</span><span>    </span><span>pub </span><span>single_quoted_allowed</span><span>: </span><span>bool</span><span>,
</span><span>    </span><span>/// Can the scalar be expressed in the literal or folded styles?
</span><span>    </span><span>pub </span><span>block_allowed</span><span>: </span><span>bool</span><span>,
</span><span>    </span><span>/// The output style.
</span><span>    </span><span>pub </span><span>style</span><span>: ScalarStyle,
</span><span>}
</span><span>
</span><span>fn </span><span>yaml_emitter_analyze_event</span><span>&lt;</span><span>&#39;a</span><span>&gt;(
</span><span>    </span><span>emitter</span><span>: </span><span>&amp;</span><span>yaml_emitter_t,
</span><span>    </span><span>event</span><span>: </span><span>&amp;</span><span>&#39;a</span><span> yaml_event_t,
</span><span>) -&gt; Analysis&lt;</span><span>&#39;a</span><span>&gt; {
</span><span>    </span><span>match</span><span> event.type_ {
</span><span>        </span><span>// ...
</span><span>    }
</span><span>}
</span></code></pre>
<p>Wonderful! Now the <code>Analysis&lt;&#39;a&gt;</code> struct just needs to be passed into any
emitter function that needs the analysis as an extra parameter. Thankfully no
public API function on the emitter relies on analysis having happened
previously, so threading that argument through the emitter code is fairly
trivial, and guaranteed bug-free due to lifetime annotations, in the sense that
it is not possible for any part of the emitter to use the analysis of one event
during the emission of another event.</p>
<p>On the one hand, this change is something that we&#39;re forced to do by Rust,
because it would not be possible to make the borrow checker happy without it. On
the other hand, the Rust compiler actually nudges us to choose a better design
than the original.</p>
<p>Why is this beneficial? Why do we accept such blatant tyranny by the cruel and
cold-hearted borrow checker?</p>
<p>Well, see, reading the original source code for libyaml was hard. Upon seeing
the <code>anchor_data</code>, <code>tag_data</code>, and <code>scalar_data</code> fields of <code>yaml_emitter_t</code>, the
first thing any reader or maintainer has to do is figure out how those pointers
are used and when they are valid. This required a whole bunch of forensics,
which would have to happen again and again every time someone new looked at the
code, and &#34;someone new&#34; also includes &#34;future you&#34;.</p>
<p>The original design from the C code could have been ported verbatim to Rust. But
it would require a lot of unsafe code, which would have made it very obvious
that some cognitive overhead was being incurred. By choosing a design that works
in safe Rust, that cognitive overhead has been moved to a statically verified
invariant that is plainly visible in the source code. The new signature of
<code>yaml_emitter_analyze_event</code> plainly documents that <code>Analysis&lt;&#39;a&gt;</code> contains
references that are coming from a <code>yaml_event_t</code> with lifetime <code>&#39;a</code>.</p>
<h2 id="error-handling">Error handling</h2>
<p>One of my goals with libyaml-safer was to provide near perfect error fidelity
compared with libyaml.</p>
<p>Mercifully, C does not have exceptions. They are easily among the top 20 of
humanity&#39;s mistakes, and don&#39;t even come for me because I will die on this hill.</p>
<p>Instead, C code usually reports errors by returning an error code, and this is
already a primitive version of what Rust does. The flow around error handling is
surprisingly similar between well-structured C code and idiomatic Rust code.
Rust has the &#34;try&#34; operator <code>?</code> to make things easier, and one of the important
affordances of <a href="https://github.com/dtolnay/unsafe-libyaml">unsafe-libyaml</a> (Rust) over <a href="https://pyyaml.org/wiki/LibYAML">libyaml</a> (C) is that integer return
codes are replaced with a bespoke <code>Success</code> struct. Replacing this with
<a href="https://doc.rust-lang.org/stable/std/result/enum.Result.html"><code>Result</code></a> turned out to be <a href="https://github.com/simonask/libyaml-safer/commit/dc639b92b5754f58e8e8f7979449ba6aca54c3a6">pretty
trivial</a>.</p>
<p>But wait a minute... We can&#39;t just use the <code>?</code> straight away. It checks if an
error occurred and returns early from the function if it did, but C does not
have RAII, so resources need to be released as well before returning. This is
the one remaining valid use case of <code>goto</code> in the C language, and it is often
actually the most sustainable way to deal with errors. More civilized languages
(such as Rust) don&#39;t even have this misfeature.</p>
<pre data-lang="c"><code data-lang="c"><span>void</span><span>* </span><span>stupid_c</span><span>() {
</span><span>    </span><span>void</span><span>*</span><span> some_memory </span><span>= </span><span>malloc</span><span>(</span><span>1024</span><span>);
</span><span>    </span><span>if </span><span>(</span><span>some_function</span><span>(some_memory) </span><span>!=</span><span> ERROR) {
</span><span>      </span><span>// ...
</span><span>    } </span><span>else </span><span>{
</span><span>      </span><span>goto</span><span> cleanup;
</span><span>    }
</span><span>
</span><span>    </span><span>if </span><span>(</span><span>some_other_function</span><span>(some_memory) </span><span>!=</span><span> ERROR) {
</span><span>      </span><span>return</span><span> some_memory;
</span><span>    }
</span><span>
</span><span>cleanup:
</span><span>    </span><span>// We&#39;re returning an error, so we need to free what we allocated.
</span><span>    </span><span>free</span><span>(some_memory);
</span><span>    </span><span>return </span><span>NULL</span><span>;
</span><span>}
</span></code></pre>
<p>Thus, in order to start leveraging the error handling features of Rust, all
things that own memory must first be converted to RAII objects, such as
<code>String</code>, <code>Vec</code>, <code>VecDeque</code>, etc.</p>
<p>After that, there is the problem of actually reporting the error.</p>
<p>Rust <code>Result</code>s are rich: They can contain an error value of your choice, so you
can provide the best possible message for the users, giving them all the context
they need. C does not have this option built in, and most libraries opt for
simply returning an error code, and then sometimes allowing the programmer to
obtain more information about the error after the fact.</p>
<p>In libyaml, this looks like so:</p>
<pre data-lang="c"><code data-lang="c"><span>struct </span><span>yaml_parser_t {
</span><span>    yaml_error_type_t error;
</span><span>    </span><span>const char</span><span>*</span><span> problem;
</span><span>    yaml_mark_t problem_mark;
</span><span>    </span><span>const char</span><span>*</span><span> context;
</span><span>    yaml_mark_t context_mark;
</span><span>    </span><span>// ...
</span><span>}
</span></code></pre>
<p>When an error occurs, the relevant function (such as <code>yaml_parser_parse()</code>) sets
the error fields (<code>yaml_set_parser_error()</code>), and returns an integer indicating
that an error occurred. The user is then expected to access these fields to
determine what the error was and where in the input it occurred.</p>
<p>In Rust, we don&#39;t want a special &#34;error&#34; state for the parser. Ideally, we want
to be able to return a self-contained error instead, which can then have all the
usual niceties, like an implementation of <code>std::fmt::Display</code>.</p>
<p>Note also that the reported error is not necessarily a &#34;parse error&#34;. Lots of
errors can occur that aren&#39;t typically considered syntax errors: I/O read
errors, invalid Unicode, tokenization errors, etc.</p>
<p>Let&#39;s try with some enums:</p>
<pre data-lang="rust"><code data-lang="rust"><span>enum </span><span>ParserError {
</span><span>    Problem {
</span><span>        problem: </span><span>&amp;</span><span>&#39;static str</span><span>,
</span><span>        problem_mark: Mark,
</span><span>        context: </span><span>&amp;</span><span>&#39;static str</span><span>,
</span><span>        context_mark: Mark,
</span><span>    }
</span><span>    Scanner(ScannerError),
</span><span>}
</span><span>
</span><span>enum </span><span>ScannerError {
</span><span>    Problem {
</span><span>        problem: </span><span>&amp;</span><span>&#39;static str</span><span>,
</span><span>        problem_mark: Mark,
</span><span>        context: </span><span>&amp;</span><span>&#39;static str</span><span>,
</span><span>        context_mark: Mark,
</span><span>    },
</span><span>    Reader(ReaderError),
</span><span>}
</span><span>
</span><span>enum </span><span>ReaderError {
</span><span>    Problem {
</span><span>        problem: </span><span>&amp;</span><span>&#39;static str</span><span>,
</span><span>        offset: </span><span>usize</span><span>,
</span><span>        value: </span><span>i32</span><span>,
</span><span>    },
</span><span>    Io(std::io::Error),
</span><span>}
</span></code></pre>
<p>So nice, perfect fidelity and high-quality error reporting. Except... On a
64-bit architecture, the size of the top-level <code>ParserError</code> enum is 88 bytes,
mostly due to the <code>Mark</code> type, which indicates a location in the input, and
which looks like this:</p>
<pre data-lang="rust"><code data-lang="rust"><span>struct </span><span>Mark {
</span><span>    </span><span>pub </span><span>line</span><span>: </span><span>u64</span><span>,
</span><span>    </span><span>pub </span><span>column</span><span>: </span><span>u64</span><span>,
</span><span>    </span><span>pub </span><span>index</span><span>: </span><span>u64</span><span>,
</span><span>}
</span></code></pre>
<p>24 bytes, and each error typically needs 2 marks.</p>
<p>Why is the size a problem?</p>
<ol>
<li>Even the minimal <code>Result&lt;(), ParserError&gt;</code> can never be returned in a register.</li>
<li>Every function that encounters a <code>Result&lt;T, ParserError&gt;</code> and wants to return
<code>Result&lt;U, ParserError&gt;</code> needs to re-wrap the return value, no matter if an
error occurred or not, leading to a lot of copying of large structs in stack
memory.</li>
<li>While LLVM will <a href="https://github.com/rust-lang/rust/pull/64302#issuecomment-529840404">inline calls to <code>memcpy()</code> below 128
bytes</a>,
instructions to copy these values are still generated.</li>
</ol>
<p>The parser makes a huge number of tiny calls, and each of them can fail. Every
time it needs a new token, it might also need a new character, meaning it might
also need another byte from the input buffer, meaning it might also need to
perform a <code>read()</code> operation from the input, which can fail with
<code>std::io::Error</code>, or with a Unicode decoding error, or with a tokenization
error, and finally a parser error.</p>
<p>All in all, a very large error type like this is... not great.</p>
<p>There are a couple of options for moving forward:</p>
<ol>
<li>Mimic the libyaml style of errors, and set error codes on the parser object
itself. This gives a much less ergonomic API, or would introduce a lifetime
parameter on all return values that isn&#39;t very nice.</li>
<li>Codegolfing the above enums to reduce the size. Not much can be won without
losing fidelity, but it could probably get down to about 64 bytes.</li>
<li>Wrap the error in a <code>Box</code>, reducing the size to only 8 bytes on 64-bit
platforms. The heap allocation isn&#39;t great, but it would only happen in error
scenarios, so it&#39;s trading some efficiency in the error path for a faster
&#34;happy&#34; path.</li>
<li>Accept that this is our life now and move on.</li>
</ol>
<p>All compromises, either in usability or performance.</p>
<p>I benchmarked options (3) and (4) against each other in the happy path, and
there wasn&#39;t much difference. But it still <em>feels wrong</em>, and committing to an
&#34;inefficient&#34; public API where the user can see the inner workings of the error
enums is a semver hazard, so for now I&#39;ve chosen an API that supports both
implementations, and boxed (3) under the hood.</p>
<p>Zooming out, it&#39;s worth noting that
<a href="https://docs.rs/serde_yaml/latest/src/serde_yaml/error.rs.html#12"><code>serde_yaml::Error</code></a>
has actually chosen (3), a boxed error, which is an indication that I am not the
only person in the world in considering this an acceptable tradeoff.</p>
<h2 id="freebies">Freebies</h2>
<p>Rust, being a younger language, has a much richer standard library. This means
that several things that are implemented manually in libyaml can be replaced
with standard facilities.</p>
<ul>
<li>UTF-8 and UTF-16 encoding/decoding. These aren&#39;t particularly complicated, but
the Rust standard library is likely to be better optimized (for example, using
SIMD when available).</li>
<li>Rather than user-provided unsafe callbacks, input and output can be handled by
the <code>std::io::Read</code> and <code>std::io::Write</code> traits. This gives users the ability
to plug anything in there, such as tty streams, network streams, etc., with no
extra effort.</li>
<li>The parser requires some input buffering to perform correct decoding, but
libyaml is practically forced to do this by itself, even when the input is
already buffered by the user. By using the <code>std::io::BufRead</code> trait, an entire
intermediate buffer was eliminated from the parser, meaning that if the data
is already coming from an in-memory buffer, the unnecessary copy is elided.</li>
</ul>
<h2 id="testing">Testing</h2>
<p><code>unsafe-libyaml</code> is automatically tested against <a href="https://github.com/yaml/yaml-test-suite">the official YAML test
suite</a>. Having this comprehensive test
suite was an absolute necessity when porting to safe Rust, and I would not have
dared to embark on this endeavor without it.</p>
<p>For every change to the code, I was able to run the full test suite and verify
that everything was as it should be. And even though the code was ported with a
true dedication to matching the original semantics, and even the general &#34;shape&#34;
of the API, many things could go wrong - particularly around flow control and
errors. See, the use of <code>goto</code>s is emulated by c2rust using complicated
loop/match/break constructs, all of which went away completely, replaced by
Rust&#39;s &#34;try&#34; operator, <code>?</code>. Even trivial changes are an opportunity for bugs to
sneak in, and even moreso when there are hundreds.</p>
<p>Even though it is much easier to write correct code in safe Rust than in C,
logic bugs are obviously just as possible, particularly when performing very
large scale refactoring.</p>
<h2 id="performance">Performance</h2>
<p>In order to compare the performance of unsafe-libyaml and the safe Rust port, I
found a relatively large YAML document (~700 KiB) and built a very simple
benchmark using <a href="https://docs.rs/criterion/latest/criterion/">Criterion</a>.</p>
<p>In short:</p>
<table><thead><tr><th></th><th>unsafe-libyaml</th><th>libyaml-safer</th></tr></thead><tbody>
<tr><td>Parse 700 KiB document</td><td>38.258 ms</td><td>37.447 ms</td></tr>
<tr><td>Emit 700 KiB document</td><td>18.491 ms</td><td>17.549 ms</td></tr>
</tbody></table>
<p><em>Hold for applause.</em></p>
<p>These benchmarks were run on an AMD Ryzen 9 3950X 16-Core CPU (3.5 GHz) running
Windows 11.</p>
<h3 id="analysis">Analysis</h3>
<ul>
<li><strong>Important:</strong> While I do consistently get slightly faster times for
libyaml-safer, I don&#39;t consider this benchmark to be conclusive in any way.</li>
<li>What these numbers <em>do</em> indicate is that the port to safe, idiomatic Rust does
not produce meaningfully slower code.
<ul>
<li>The justification for &#34;unsafe&#34; C and C++ libraries is often that some
performance is left on the table with safe Rust, primarily due to bounds
checking. On modern hardware this justification has always seemed a bit
suspicious to me, and I think this is another piece of (circumstantial)
evidence that it often just doesn&#39;t matter in practice.</li>
<li>It&#39;s certainly possible to build things where bounds checking makes a
difference. This just isn&#39;t that.</li>
</ul>
</li>
<li><em>If</em> libyaml-safer is consistently faster for all workloads, here are some
possible explanations:
<ul>
<li>C libyaml needs to assert on a couple of invariants (such as pointers not
being NULL), and unsafe-libyaml performs these assertions even in release
mode. Some of these invariants are statically checked in safe Rust, where
<code>&amp;T</code> can never be &#34;NULL&#34;.</li>
<li>Due to the use of <code>std::io::BufRead</code> in the parser, the parser performs
fewer in-memory copies.</li>
</ul>
</li>
<li><em>Even if</em> this benchmark is completely bogus, the performance of libyaml-safer
is still well within tolerance for what is acceptable, considering the massive
increase in maintainability and safety</li>
<li>Zero effort was made to optimize things, other than just not choosing
obviously slower safe alternatives.
<ul>
<li>One optimization that might make sense is to implement more efficient
lookahead in the parser. Currently, there are many places where the scanner
and parser perform many redundant bounds checks on the input buffer.</li>
</ul>
</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>This was a lot of fun.</p>
<p>I think, to me, and to a lot of software engineers who came from a C++
background, using Rust is not just about nebulous promises of safety and
correctness.</p>
<p>It&#39;s about bringing the joy back into programming.</p>
<p>We all like to design pretty, user-friendly APIs, we all like to produce things
that just feel high quality. Many of us don&#39;t get to do that, because the
realities of our industry often do not permit it. And so, does it spark joy?</p>
<p>Coding in Rust feels like having your cake and eating it too. When people are
productive in Rust, it is because it makes many things that used to be hard -
things that cause tears, blood, and burnout - are no longer as hard. The result
is not just safer and easier, it is also just as performant. So please - join
us.</p>

<ul>
<li>In this post I have preserved type names and function names from
<code>unsafe-libyaml</code>, but as part of porting to <em>idiomatic</em> Rust, I also did
rename all types and enums following idiomatic Rust conventions.</li>
</ul>




      </div></div>
  </body>
</html>
