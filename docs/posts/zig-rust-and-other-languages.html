<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://notes.eatonphil.com/2024-03-15-zig-rust-and-other-languages.html">Original</a>
    <h1>Zig, Rust, and Other Languages</h1>
    
    <div id="readability-page-1" class="page"><div>
          <p>Having worked a bit in Zig, Rust, Go and now C, I think there are a
few common topics worth having a fresh conversation on: automatic
memory management, the standard library, and explicit allocation.</p>
<p>Zig is not a mature language. But it has made enough useful choices
for a number of companies to invest in it and run it in
production. The useful choices make Zig worth talking about.</p>
<p>Go and Rust are mature languages. But they have both made questionable
choices that seem worth talking about.</p>
<p>All of these languages are developed by highly intelligent folks I
personally look up to. And your choice to use any one of these is
certainly fine, whichever it is.</p>
<p>The positive and negative choices particular languages made, though, are
worth talking about as we consider what a systems programming language
10 years from now would look like. Or how these languages themselves
might evolve in the next 10 years.</p>
<p>My perspective is mostly building distributed databases. So the points
that I bring up may have no relevance to the kind of work you do, and
that&#39;s alright. Moreover, I&#39;m already aware most of these opinions are
not shared by the language maintainers, and that&#39;s ok too. I am not
writing to convince anyone.</p>
<h3 id="automatic-memory-management">Automatic memory management</h3><p>One of my bigger issues with Zig is that it doesn&#39;t support RAII. You
can defer cleanup to the end of a block; and this is half of the
problem. But only RAII will allow for smart pointers and automatic
(not manual) reference counting. RAII is an excellent option to
default to, but in Zig you aren&#39;t allowed to. In contrast, even C
&#34;supports&#34; automatic cleanup (via compiler extensions).</p>
<p>But most of the time, arenas are fine. Postgres is written in C and
memory is almost entirely managed through nested arenas (called
&#34;memory contexts&#34;) that get cleaned up when some subset of a task
finishes, recursively. Zig has builtin support for arenas, which is
great.</p>
<h3 id="standard-library">Standard library</h3><p>It seems regrettable that some languages have been shipping smaller
standard libraries. Smaller standard libraries seem to encourage users
of the language to install more transitively-unvetted third-party
libraries, which increases build time and build flakiness, and which
increases bitrot over time as unnecessary breaking changes occur.</p>
<p>People have been making jokes about <code>node_modules</code> for a decade now, but
this problem is just as bad in Rust codebases I&#39;ve seen. And to a
degree it happens in Java and Go as well, though their larger standard
libraries allow you to get further without dependencies.</p>
<p>Zig has a good standard library, which may be Go and Java tier in a
few years. But one goal of their package manager seemed to be
to allow the standard library to be broken up; made smaller. For
example, JSON support moving out of the standard library into a
package. I don&#39;t know if that is actually the planned direction. I
hope not.</p>
<p>Having a large standard library doesn&#39;t mean that the programmer
shouldn&#39;t be able to swap out implementations easily as needed. But
all that is required is for the standard library to define an
<strong>interface</strong> along with the standard library implementation.</p>
<p>The small size of the standard library doesn&#39;t just affect developers
using the language, it even encourages developers of the language
itself to depend on libraries owned by individuals.</p>
<p>Take a look at the transitive dependencies of an official Node.js
package like
<a href="https://github.com/nodejs/node-gyp/blob/main/package.json#L25">node-gyp</a>. Is
it really the ideal outcome of a small standard library to encourage
dependence in official libraries on libraries owned by individuals,
like <a href="https://github.com/sindresorhus/env-paths">env-paths</a>, that
haven&#39;t been modified in 3 years? 68 lines of code. Is it not safer at
this point to vendor that code? i.e. copy the <code>env-paths</code> code into
<code>node-gyp</code>.</p>
<p>Similarly, if you go looking for compression support in Rust, there&#39;s
none in the standard library. But you may notice the
<a href="https://github.com/rust-lang/flate2-rs">flate2-rs</a> repo under the
official <a href="https://github.com/rust-lang">rust-lang</a> GitHub
namespace. If you look at its transitive dependencies:
<a href="https://github.com/rust-lang/flate2-rs/blob/main/Cargo.toml#L23">flate2-rs</a>
depends on (an individual&#39;s)
<a href="https://github.com/Frommi/miniz_oxide/blob/master/miniz_oxide/Cargo.toml#L20">miniz_oxide</a>
which depends on (an individual&#39;s)
<a href="https://github.com/jonas-schievink/adler">adler</a> that hasn&#39;t been
updated in 4 years. 300 lines of code including tests. Why not vendor
this code? It&#39;s the habits a small standard library builds that seem
to encourage everyone not to.</p>
<p>I don&#39;t mean these necessarily constitute a supply-chain risk. I&#39;m not
talking about
<a href="https://www.theregister.com/2016/03/23/npm_left_pad_chaos/">left-pad</a>. But
the pattern is sort of clear. Even official packages may end up
depending on external party packages, because the commitment to a
small standard library meant omitting stuff like compression,
checksums, and common OS paths.</p>
<p>It&#39;s a tradeoff and maybe makes the job of the standard library
maintainer easier. But I don&#39;t think this is the ideal
situation. Dependencies are useful but should be kept to a reasonable
minimum.</p>
<p>Hopefully languages end up more like Go than like Rust in
this regard.</p>
<h3 id="explicit-allocation">Explicit allocation</h3><p>When folk discuss the Zig standard library&#39;s pattern of requiring an
allocator argument for every method that allocates, they often talk
about the benefit of swapping out allocators or the benefit of being
able to handle OOM failures.</p>
<p>Both of these seem pretty niche to me. For example, in Zig tests you
are encouraged to pass around a debug allocator that tells you about
memory leaks. But this doesn&#39;t seem too different from compiling a C
project with a debug allocator or compiling with different sanitizers
on and running tests against the binary produced. In both cases you
mostly deal with allocators at a global level depending on the
environment you&#39;re running the code in (production or tests).</p>
<p>The real benefit of explicit allocations to me is much more
trivial. You basically can&#39;t code a method in Zig without
acknowledging allocations.</p>
<p>This is particularly useful for hotpath code. Take an iterator for
example. It has a <code>new()</code> method, a <code>next()</code> method, and a <code>done()</code>
method. In most languages, it&#39;s basically impossible at the syntax or
compiler-level to know if you are allocating in the <code>next()</code> method. You
may know because you know the behavior of all the code in <code>next()</code> by
heart. But that won&#39;t happen all the time.</p>
<p>Zig is practically alone in that if you write the <code>next()</code> method and
and don&#39;t pass an allocator to any method in the <code>next()</code> body,
nothing in that <code>next()</code> method will allocate.</p>
<p>In any other language it might not be until you run a profiler that
you notice an allocation that should have been done once in <code>new()</code>
accidentally ended up in <code>next()</code> instead.</p>
<p>On the other hand, for all the same reasons, writing Zig is kind of a
pain because everything takes an allocator!</p>
<p>Explicit allocation is not intrinsic to Zig, the language. It is a
convention that is prevalent in the standard library. There is still a
global allocator and any user of Zig could decide to use the global
allocator. At which point you&#39;ve got implicit allocation. So explicit
allocation as a convention isn&#39;t a perfect solution.</p>
<p>But it, by default, gives you a level of awareness of allocations you
just can&#39;t get from typical Go or Rust or C code, depending on the
project&#39;s practices. Perhaps it&#39;s possible to switch off the Go, Rust
and C standard library and use one where all functions that allocate
do require an allocator.</p>
<p>But explicitly passing allocators is still sort of a visual hack.</p>
<p>I think the ideal situation in the future will be that every language
supports annotating blocks of code as <code>must-not-allocate</code> or something
along those lines. Either the compiler will enforce this and fail if
you seem to allocate in a block marked <code>must-not-allocate</code>, or it will
panic during runtime so you can catch this in tests.</p>
<p>This would be useful beyond static programming languages. It would be
as interesting to annotate blocks in JavaScript or Python as
<code>must-not-allocate</code> too.</p>
<p>Otherwise the current state of things is that you&#39;d normally configure
this sort of thing at the global level. Saying &#34;there must not be
any allocations in this entire program&#34; just doesn&#39;t seem as useful in
general as being able to say &#34;there must not be any allocations in
this one block&#34;.</p>
<h4 id="optional,-not-required,-allocator-arguments">Optional, not required, allocator arguments</h4><p>Rust has nascent support for passing an allocator to methods that
allocate. But it&#39;s optional. From what I understand, C++ STL is like
this too.</p>
<p>These are both super useful for programming extensions. And it&#39;s one
of the reasons I think Zig makes a ton of sense for Postgres
extensions specifically. Because it was only and always ever built for
running in an environment with someone else&#39;s allocator.</p>
<h3 id="praise-for-zig,-rust,-and-go-tooling">Praise for Zig, Rust, and Go tooling</h3><p>All three of these have really great first-party tooling including
build system, package management, test runners and formatters. The
idea that the language should provide a great environment to code in
(end-to-end) makes things simpler and nicer for programmers.</p>
<h3 id="meandering-non-conclusion">Meandering non-conclusion</h3><p>Use the language you want to use. Zig and Rust are both nice
alternatives to writing vanilla C.</p>
<p>On the other hand, I&#39;ve been pleasantly surprised writing Postgres C.
How high level it is. It&#39;s almost a separate language since you&#39;re
often dealing with user-facing constructs, like Postgres&#39;s Datum
objects which represent what you might think of as a cell in a
Postgres database. And you can use all the same functions provided for
Postgres SQL for working with Datums, but from C.</p>
<p>I&#39;ve also been able work a bit on Postgres extensions in Rust with
<a href="https://github.com/pgcentralfoundation/pgrx">pgrx</a> lately, which I
hope to write about soon. And when I saw
<a href="https://github.com/xataio/pgzx">pgzx</a> for writing Postgres extensions in Zig
I was excited to spend some time with that too.</p>
<blockquote><p lang="en" dir="ltr">Wrote a post on my wishlist for Zig and Rust. Focused on automatic memory management, the standard library, and explicit allocation.<a href="https://t.co/dvynizU9V2">https://t.co/dvynizU9V2</a> <a href="https://t.co/iTXp5QVxj0">pic.twitter.com/iTXp5QVxj0</a></p>— Phil Eaton (@eatonphil) <a href="https://twitter.com/eatonphil/status/1768725864923931033?ref_src=twsrc%5Etfw">March 15, 2024</a></blockquote> 

	</div></div>
  </body>
</html>
