<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.adacore.com/introduction-to-ada-a-project-based-exploration-with-rosettas">Original</a>
    <h1>Introduction to Ada: a project-based exploration with rosettas</h1>
    
    <div id="readability-page-1" class="page"><div><div><h2 dir="ltr"><strong>Context</strong></h2><p dir="ltr">This practical walkthrough, designed as a short tutorial, was created upon joining AdaCore as a Field Engineer. In this new role, I’ll be working directly with customers to help them succeed with Ada. Although I was first introduced to the language nearly two decades ago, this new position inspired me to revisit its fundamentals, and I used the excellent <a href="https://learn.adacore.com">https://learn.adacore.com</a> portal as a quick refresher.</p><p dir="ltr">While that platform takes a concept-based approach, I chose to complement it with a project-based method by developing a small, end-to-end Ada program that generates animated rosettas in the form of SVG files. These are technically hypotrochoid curves, producing patterns that many will recognize from the classic <em>Spirograph™ </em>toy.</p><p dir="ltr">In this walkthrough, we’ll show that Ada can be fun and easy to learn. Although the language is famous for <a href="https://www.adacore.com/about-ada">safety-critical systems</a>, we will use it as a modern, general-purpose programming language and try out some new features from Ada 2022 along the way.</p><p dir="ltr">Let&#39;s dive in!</p><h2 dir="ltr"><strong>A brief note on Ada</strong></h2><p dir="ltr">This section leans a bit more into background context, with a slightly encyclopedic flavor that&#39;s especially useful for readers new to Ada. If you&#39;re already familiar with Ada’s history and principles, feel free to joyfully skip ahead to the next section!</p><p dir="ltr">Ada was created in the late 1970s after a call from the U.S. Department of Defense to unify its fragmented software landscape. The winning proposal became Ada, a language that&#39;s been literally battle-tested (!) and built on a deeply thought-out design that continues to evolve today.</p><p dir="ltr">While Ada is absolutely a general-purpose programming language, it has carved out a strong niche in fields where software correctness and reliability are mission-critical:</p><ul><li dir="ltr"><p dir="ltr">Embedded and real-time systems</p></li><li dir="ltr"><p dir="ltr">Aerospace and defense</p></li><li dir="ltr"><p dir="ltr">Rail, automotive, and aviation</p></li><li dir="ltr"><p dir="ltr">Any system where failure is not just a bug, but a risk</p></li></ul><p dir="ltr">Its strict compile-time checks, safety features, and clear structure make it particularly appealing when you need your software to be dependable from day one and still maintainable ten years later.</p><p dir="ltr">Ada&#39;s design is grounded in a strong and principled philosophy:</p><ul><li dir="ltr"><p dir="ltr"><strong>Readability over conciseness</strong>: Ada favors clarity. It avoids symbols and abbreviations in favor of full keywords, making the language more accessible and less error-prone.</p></li><li dir="ltr"><p dir="ltr"><strong>Strong and explicit typing</strong>: It is extremely easy to declare new types in Ada, with precise constraints, which makes it much harder to accidentally misuse data. While some functional languages share this strong typing discipline, Ada stands out by requiring the programmer to be very explicit. It uses little to no type inference.</p></li><li dir="ltr"><p dir="ltr"><strong>Explicit is better than implicit</strong>: Unlike many modern languages that prioritize convenience, Ada leans heavily toward precision. Most types must be explicitly named and matched.</p></li><li dir="ltr"><p dir="ltr"><strong>Defined semantics and minimal undefined behavior</strong>: Ada offers a level of predictability and safety unmatched in many languages. This makes it a strong choice not only for safety-critical systems, but also for codebases where long-term maintenance, verifiability, and correctness are essential.</p></li><li dir="ltr"><p dir="ltr"><strong>Compiler as a partner</strong>: Ada compilers are strict by design, not to frustrate, but to help the programmer write clearer, more correct code. This philosophy encourages the developer to communicate intent clearly, both to the compiler and to future readers.</p></li></ul><h2 dir="ltr"><strong>How the program works</strong></h2><p dir="ltr">Sometimes the best way to figure out how something works is to start at the end. Let&#39;s do that!</p><p dir="ltr">./bin/rosetta</p><p dir="ltr">The idea was to create something visual: learning is more fun when there&#39;s an immediate, satisfying result and generating rosettas fits that goal perfectly.</p><h2 dir="ltr"><strong>Tooling &amp; setup</strong></h2><p dir="ltr">To build and run the project, I used Alire, the Ada package manager. It plays a similar role in the Ada ecosystem as Cargo does for Rust or npm for JavaScript. It&#39;s well-documented, and while we won&#39;t dive deep into it here, it&#39;s a solid and accessible way to manage Ada projects. I encourage anyone curious to get it from <a href="https://alire.ada.dev/">https://alire.ada.dev</a>. Interestingly, &#34;Alire&#34; is also the French expression for &#34;à lire&#34; — which means &#34;for reading.&#34; A fitting name for a tool that supports a language so focused on clarity and readability!</p><p dir="ltr">Once Alire is set up, the natural next step is choosing where to write the code. You have two excellent options for your development environment. For a dedicated experience, you can download the latest release of <a href="https://github.com/AdaCore/gnatstudio/releases/">GNAT Studio</a> from its GitHub repository. If you prefer a more general-purpose editor, you can install the official <a href="https://marketplace.visualstudio.com/items?itemName=AdaCore.ada">Ada &amp; SPARK for Visual Studio Code</a> extension from AdaCore.</p><p dir="ltr">As a new learner, I also kept <a href="https://learn.adacore.com/">https://learn.adacore.com</a> close at hand. It’s a particularly clear and comprehensive resource — and I especially appreciated being able to download the ebook version and read through it on my phone.</p><h2 dir="ltr"><strong>Entry point</strong></h2></div><pre><code>with Rosetta_Renderer;

procedure Main is
begin
   Rosetta_Renderer.Put_SVG_Rosettas;
end Main;</code></pre><div><p dir="ltr">There are several interesting things to notice right away:</p><ul><li dir="ltr"><p dir="ltr">The <code>with </code>clause is not a preprocessor directive like in C or C++. It’s a compiled, checked reference to another package — a reliable and explicit way to express a dependency. This eliminates entire classes of bugs related to fragile <code>#include</code> chains, macro collisions, or dependency order issues.</p></li><li dir="ltr"><p dir="ltr">This <code>procedure</code> is not a <code>function</code>: it does not return a value. In Ada, procedures are used to perform actions (like printing or modifying state), and functions are used to compute and query values.</p></li><li dir="ltr"><p dir="ltr">The syntax is designed for readability. You’ll find <code>begin</code> and <code>end</code> here instead of <var><code>{}</code></var> as in C/C++, reinforcing Ada’s philosophy that clarity matters more than brevity.</p></li><li dir="ltr"><p dir="ltr"><code>Put_SVG_Rosettas</code> uses the idiomatic Pascal_Snake_Case naming style. This reflects a common Ada convention and avoids acronyms or compressed identifiers in favor of more descriptive names.</p></li><li dir="ltr"><p dir="ltr">The entry point is minimal but meaningful: it simply calls a procedure which generates the output we&#39;ll explore in the next sections.</p></li></ul><h2 dir="ltr"><strong>Geometry and computation (package </strong><strong>Rosetta</strong><strong>)</strong></h2><p dir="ltr">In Ada, a <strong>package </strong>is a modular unit that groups related types, procedures, and functions. Following the convention from GNAT (the Ada compiler, part of the GNU Compiler Collection, fondly known as GCC), each package has a <strong>specification file</strong> (with the<code> .ads</code> extension — short for <em>Ada Specification</em>) and an <strong>implementation file</strong> (with the <code>.adb</code> extension — short for <em>Ada Body</em>). This clear and enforced split means you always know where to find interface definitions versus their implementation.</p><p dir="ltr">The following code is the package specification for Rosetta. It defines the data types for the rosetta shapes and declares the public interface of operations available to manipulate them.</p></div><pre><code>with Ada.Strings.Text_Buffers;

package Rosetta is

   --  A mathematical description of a rosetta (specifically, a hypotrochoid).
   --  formed by tracing a point attached to a circle rolling inside another circle.
   type Hypotrochoid is record
      Outer_Radius : Float;     --  Radius of the fixed outer circle.
      Inner_Radius : Float;     --  Radius of the rolling inner circle.
      Pen_Offset   : Float;     --  From the center of the inner circle to the drawing point.
      Steps        : Positive;  --  Number of steps (points) used to approximate the curve.
   end record;

   --  A 2D coordinate in Cartesian space.
   type Coordinate is record
      X_Coord, Y_Coord : Float;
   end record
     with Put_Image =&gt; Put_Image_Coordinate;
   
   --  Redefines the &#39;Image attribute for Coordinate.
   procedure Put_Image_Coordinate 
     (Output : in out Ada.Strings.Text_Buffers.Root_Buffer_Type&#39;Class; 
      Value  : Coordinate);

   --  A type for an unconstrained array of 2D points forming a curve.
   --  The actual bounds are set when an array object of this type is declared.
   type Coordinate_Array is array (Natural range &lt;&gt;) of Coordinate;

   --  Computes the coordinates of the rosetta curve defined by Curve (a hypotrochoid).
   --  Returns a centered array of coordinates.
   function Compute_Points (Curve : Hypotrochoid) return Coordinate_Array;

end Rosetta;</code></pre><div><p dir="ltr">The <code>Rosetta</code> package is responsible for all the math and curve computation. It defines:</p><ul><li dir="ltr"><p dir="ltr"><code>Hypotrochoid</code>, type describing the geometry of the rosetta</p></li><li dir="ltr"><p dir="ltr"><code>Coordinate</code>, type representing points in 2D space</p></li><li dir="ltr"><p dir="ltr"><code>Coordinate_Array</code>, type holding a series of such points</p></li><li dir="ltr"><p dir="ltr"><code>Compute_Points</code>, function which calculates all the points of the curve based on the <code>Hypotrochoid</code> parameters and recenters them around the origin</p></li></ul><p dir="ltr">This package is focused solely on computation. It doesn’t concern itself with how the result is rendered.</p><p dir="ltr"><em>Fun fact for the curious: when the rolling circle rolls </em><strong><em>outside</em></strong><em> the fixed circle rather than inside, the resulting curve is called an epitrochoid.</em></p><p dir="ltr">In Ada, a <code>record</code> is similar to a <code>struct</code> in C or a class with only data members in other languages. It&#39;s a user-defined type composed of named components, making it ideal for modeling structured data.</p><p dir="ltr">Using a record for <code>Hypotrochoid</code> was particularly appropriate: it allows grouping all geometric parameters (outer radius, inner radius, pen offset, and steps) into a single, cohesive unit. This improves readability and maintainability. The compiler enforces correctness by ensuring all required values are present and of the expected type — reinforcing Ada’s philosophy of clarity and safety.</p><p dir="ltr">The type <code>Coordinate_Array</code> is an unconstrained array type that holds a range of <code>Coordinate</code> records. In this context, ‘unconstrained’ simply means that we don’t define the array’s size when we declare the type. Instead, the size is defined when we declare an object of that type. This gives us the flexibility to use this type for a variety of shapes.</p><p dir="ltr">You may also notice the use of <code>Natural range &lt;&gt;. Natural</code> is a predefined subtype of Integer that only allows non-negative values. And yes, I mean subtype: Ada’s powerful type system allows you to take an existing type and create a more specific, constrained version of it.</p><h3 dir="ltr"><strong>Highlights from the .adb file</strong></h3><p dir="ltr">Here are a few notable aspects from the implementation (<code>rosetta.adb</code>) that illustrate Ada’s strengths for writing safe, clear, and structured code:</p><ul><li dir="ltr"><p dir="ltr"><strong>Declarative and modular design</strong>: Both <code>Generate_Point </code>and <code>Compute_Points</code> are pure functions that operate only on their inputs. Their behavior is fully deterministic and encapsulated.</p></li><li dir="ltr"><p dir="ltr"><strong>Safe bounds and array handling</strong>: The <code>Points</code> array is statically bounded using <code>(0 .. Curve.Steps)</code>, and its access is strictly safe. The compiler ensures that any index outside this range would raise an error at runtime. This immediate error is a feature, not a bug. It stops silent memory corruption and security flaws by ensuring the program fails predictably and safely at the source of the problem.</p></li><li dir="ltr"><p dir="ltr"><strong>Use of constants for robustness</strong>: Variables such as <code>Pi</code>, <code>R_Diff</code>, and Ratio are declared as constant, enforcing immutability. This helps ensure clarity of intent and prevents accidental reassignment, a common source of subtle bugs in more permissive languages. Ada encourages this explicit declaration style, promoting safer code.</p></li></ul></div><pre><code>with Ada.Numerics;
with Ada.Numerics.Elementary_Functions;

use Ada.Numerics;
use Ada.Numerics.Elementary_Functions;

package body Rosetta is

   --  Computes a single point on the hypotrochoid curve for a given angle Theta.
   --  Uses the standard parametric equation of a hypotrochoid.
   function Generate_Point (Curve : Hypotrochoid; Theta : Float) return Coordinate is
      R_Diff : constant Float := Curve.Outer_Radius - Curve.Inner_Radius;
      Ratio  : constant Float := R_Diff / Curve.Inner_Radius;
   begin
      return (
              X_Coord =&gt; R_Diff * Cos (Theta) + Curve.Pen_Offset * Cos (Ratio * Theta),
              Y_Coord =&gt; R_Diff * Sin (Theta) - Curve.Pen_Offset * Sin (Ratio * Theta)
             );
   end Generate_Point;

   --  Computes all the points of the hypotrochoid curve and recenters them.
   --  The result is an array of coordinates centered around the origin.
   function Compute_Points (Curve : Hypotrochoid) return Coordinate_Array is
      Points : Coordinate_Array (0 .. Curve.Steps);
      Max_X  : Float := Float&#39;First;
      Min_X  : Float := Float&#39;Last;
      Max_Y  : Float := Float&#39;First;
      Min_Y  : Float := Float&#39;Last;
      Offset : Coordinate;
   begin
      --  Computes raw points and updates the bounding box extents.
      for J in 0 .. Curve.Steps loop
         declare
            Theta : constant Float := 2.0 * Pi * Float (J) / Float (Curve.Steps) * 50.0;
            P     : constant Coordinate := Generate_Point (Curve, Theta);
         begin
            Points (J) := P;
            Max_X := Float&#39;Max (Max_X, P.X_Coord);
            Min_X := Float&#39;Min (Min_X, P.X_Coord);
            Max_Y := Float&#39;Max (Max_Y, P.Y_Coord);
            Min_Y := Float&#39;Min (Min_Y, P.Y_Coord);
         end;
      end loop;

      --  Computes the center offset based on the bounding box.
      Offset := (
                 X_Coord =&gt; (Max_X + Min_X) / 2.0,
                 Y_Coord =&gt; (Max_Y + Min_Y) / 2.0
                );

      --  Recenters all points by subtracting the center offset.
      for J in Points&#39;Range loop
         Points (J).X_Coord := @ - Offset.X_Coord;
         Points (J).Y_Coord := @ - Offset.Y_Coord;
      end loop;

      return Points;
   end Compute_Points;
   
   --  Redefines the &#39;Image attribute for Coordinate.
   procedure Put_Image_Coordinate
     (Output : in out Ada.Strings.Text_Buffers.Root_Buffer_Type&#39;Class;
      Value  : Coordinate)
   is   
      X_Text : constant String := Float&#39;Image (Value.X_Coord);
      Y_Text : constant String := Float&#39;Image (Value.Y_Coord);
   begin
      Output.Put (X_Text &amp; &#34;,&#34; &amp; Y_Text);
   end Put_Image_Coordinate;

end Rosetta;</code></pre><div><h2 dir="ltr"><strong>On style: strict and predictable (and satisfying!)</strong></h2><p dir="ltr">Ada is one of those rare languages that not only compiles your code but asks you to write it <em>properly</em>. With the compiler switch <a href="https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/building_executable_programs_with_gnat.html#style-checking">-gnaty</a>, you can enforce a comprehensive set of style rules, many of which are stricter than what you&#39;d see in most languages.</p><p dir="ltr">This includes things like:</p><ul><li dir="ltr"><p dir="ltr">No trailing whitespace at the end of lines</p></li><li dir="ltr"><p dir="ltr">No consecutive blank lines</p></li><li dir="ltr"><p dir="ltr">Proper indentation and alignment of keywords and parameters</p></li><li dir="ltr"><p dir="ltr">A space before “(“ when calling a procedure or function</p></li><li dir="ltr"><p dir="ltr">Consistent casing</p></li></ul><p dir="ltr">At first, this can feel surprisingly strict. But once you get used to it, the benefits are clear: it helps enforce a consistent and clean coding style across a codebase. That in turn improves readability, reduces ambiguity, and leads to more maintainable programs.</p><p dir="ltr">Rather than leaving formatting up to personal taste or optional linter tools, Ada integrates this attention to detail into the compilation process itself. The result is not only more elegant: it&#39;s genuinely satisfying. And you can do even more with GNATcheck and GNATformat but it’s outside of the scope of this post.</p><p dir="ltr"><strong>Outputting to SVG (package </strong><strong><code>Rosetta_Renderer</code></strong><strong>)</strong></p><p dir="ltr">The Rosetta_Renderer package is responsible for producing the SVG output. It defines a single high-level procedure:<br/></p></div><pre><code>package Rosetta_Renderer is

   --  Renders a predefined set of rosettas into an SVG output.
   procedure Put_SVG_Rosettas;

end Rosetta_Renderer;</code></pre><div><p dir="ltr">This procedure generates an SVG file directly. It takes care of formatting the SVG structure (header, shapes, animations, and footer) and calls into the math logic defined in the <code>Rosetta </code>package to generate point data.</p><p dir="ltr">This separation of concerns is deliberate and beneficial: the math logic doesn’t need to know anything about SVG, and the renderer doesn’t care how the coordinates were generated.</p><p dir="ltr">Now let&#39;s talk about the body of the package... but not for long. We&#39;re keeping it brief because its core is essentially the SVG plumbing required to draw and animate the curves, so we&#39;ll skip the fine details. And for those who enjoy seeing how the sausage is made, I&#39;ve made the fully commented source code available for you <a href="https://github.com/romain-at-adacore/rosettas">right here</a>.</p></div><pre><code>--  Puts coordinates to a single SVG path string (&#34;d&#34; attribute).
   procedure Put_Path (Stream : File_Type; Points : Coordinate_Array) is
   begin
      Put (Stream, &#34;M &#34;); -- Moves the pen without drawing.
      for J in Points&#39;Range loop
         declare 
            Coord_Text : constant String := Coordinate&#39;Image (Points (J));
         begin   
            Put (Stream, Coord_Text);
            if J &lt; Points&#39;Last then
               Put (Stream, &#34; L &#34;); --  Draws a line.
            end if;
         end;
      end loop;
   end Put_Path;</code></pre><div><h2 dir="ltr"><strong>Afterword</strong></h2><p dir="ltr">This small project was an enjoyable and useful way to get back into Ada. It helped me reconnect with the language’s main strengths and refamiliarize myself with its tools and design. It was a great reminder of how fun, easy to learn, and remarkably modern Ada can be, especially for developers focused on building robust, maintainable, and efficient software.</p><p dir="ltr">I hope this short walkthrough gives a good idea of that feeling, whether you&#39;re already into Ada or just starting to explore it.</p></div></div></div>
  </body>
</html>
