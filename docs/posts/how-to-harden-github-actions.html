<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.wiz.io/blog/github-actions-security-guide">Original</a>
    <h1>How to harden GitHub Actions</h1>
    
    <div id="readability-page-1" class="page"><div><p>Over <a rel="noreferrer noopener" target="_blank" href="https://github.com/advisories?query=type%3Areviewed+ecosystem%3Aactions"><u>the past three years</u></a>, researchers have highlighted the risks associated with GitHub Actions. These threats became manifest with two recent incidents. </p><p>First, <a rel="noreferrer noopener" target="_blank" href="https://www.wiz.io/blog/ultralytics-ai-library-hacked-via-github-for-cryptomining"><u>last December brought a supply chain attack</u></a> where attackers exploited a vulnerable GitHub Actions workflow to introduce an XMRig cryptominer to deployment versions of the Ultralytics Python package. Then, in March, we had the “tj-actions&#34; incident. The attacker in this incident took advantage of multiple common anti-patterns associated with GitHub Actions and clearly leveraged the existing research literature to inform their tactics. An in-depth analysis of that incident is available in our blog posts: </p><ul><li><p><a rel="noreferrer noopener" target="_blank" href="https://www.wiz.io/blog/github-action-tj-actions-changed-files-supply-chain-attack-cve-2025-30066"><u>GitHub Action tj-actions/changed-files supply chain attack: everything you need to know</u></a> </p></li><li><p><a rel="noreferrer noopener" target="_blank" href="https://www.wiz.io/blog/new-github-action-supply-chain-attack-reviewdog-action-setup"><u>New GitHub Action supply chain attack: reviewdog/action-setup</u></a> </p></li></ul><p>As a short recap: </p><ul><li><p>A vulnerability in <code>spotbugs/sonar-findbugs</code> allowed an attacker to compromise the Personal Access Token (PAT) of a Spotbugs contributor </p></li><li><p>That compromised PAT was used to grant a temporary, malicious user <code>spotbugs/spotbugs</code> repository access </p></li><li><p>The write access to <code>spotbugs/spotbugs</code> was used to push a malicious workflow to a branch, leaking the Github secrets – including the PAT of a mutual <code>spotbugs</code> and <code>reviewdog</code> contributor </p></li><li><p>The <code>reviewdog</code> access was then used to briefly poison <code>reviewdog/action-setup@v1</code>, which allowed the attacker to further compromise a <code>tj-actions</code> PAT </p></li><li><p>The <code>tj-actions</code> access was used first to target Coinbase (unsuccessfully), and was then burned with a broad attack that changed all tj-actions versions to include malicious code </p></li></ul><p>In the follow up to this incident, we know many organizations are investing in reviewing and hardening their GitHub Actions posture. We hope this guide serves as a cheat sheet for this complicated landscape, complementing <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions"><u>Github’s first party guidance</u></a>.  </p><h2><a id="github-actions-essential-terminology-6"></a><strong>GitHub Actions: Essential Terminology</strong> </h2><figure><figcaption>Based on data from Cardoen, G., Mens, T., &amp; Decan, A. (2024). A dataset of GitHub Actions workflow histories</figcaption></figure><p>It’s important to establish the key terms relevant to this domain: </p><ol><li><p><strong>GitHub Actions</strong>: A suite of automation features within GitHub that lets you automate tasks in your software development lifecycle. Actions can be used to build, test, and deploy code, among other things. </p></li><li><p><strong>Workflow</strong>: A collection of automated tasks, defined in a YAML file, that runs in response to specific events within your GitHub repository. Think of it as a script that automates a series of Actions. Workflows can be triggered by events like pushing code, creating a pull request, on a schedule, or on demand. </p></li><li><p><strong>Action</strong>: A reusable unit of automation that can be referenced and executed within Workflows. These can be created by you or pulled from the Marketplace and are essentially optional building blocks of Workflows. You can think of Actions like functions in a programming language—small, self-contained tasks that are reusable across Workflows. </p></li><li><p><strong>Event</strong>: The trigger that starts a Workflow. Common events include code pushes, pull request creations, or manual triggers. </p></li><li><p><strong>Job</strong>: A unit of work within a Workflow. Workflows can contain multiple Jobs, and each Job can run tasks (Actions). Jobs in a Workflow can run in parallel or sequentially, depending on how they&#39;re configured. Job is the minimal unit of execution schedulable on a runner. </p></li></ol><p>Basically, <strong>Workflows</strong> are your automation scripts, which are built from the embedded <strong>Job</strong> code and referenced <strong>Actions</strong>.  </p><figure><figcaption>Based on data from Cardoen, G., Mens, T., &amp; Decan, A. (2024). A dataset of GitHub Actions workflow histories</figcaption></figure><h2><a id="configuring-github-for-safer-github-actions-12"></a><strong>Configuring GitHub for Safer GitHub Actions</strong> </h2><p>Securing GitHub Actions starts with hardening your GitHub environment. First, secure GitHub Actions through organization-level administrative settings. </p><p><strong>1. Set Read-Only Default Workflow Permissions</strong> </p><p>By default, the Workflow Token Permissions were set to <strong>read-write</strong> <a rel="noreferrer noopener" target="_blank" href="https://github.blog/changelog/2023-02-02-github-actions-updating-the-default-github_token-permissions-to-read-only/"><u>prior to February 2023</u></a>. For security reasons, it&#39;s crucial to set this to <strong>read-only</strong>. Write permissions allow Workflows to inadvertently or maliciously modify your repository and its data, making least-privilege crucial.  </p><p>Double-check to ensure this permission is set correctly to <strong>read-only</strong> in your repository settings. </p><figure><a href="https://www.wiz.io/blog/state-of-code-security-report-2025"></a><figcaption>Source: Wiz&#39;s 2025 State of Code Security Report</figcaption></figure><p><strong>2. Limit Actions to Verified Actions and an Allowlist</strong> </p><p>One of the key security measures is to <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization#managing-github-actions-permissions-for-your-organization"><u>control which Actions can run within your Workflows</u></a>. You can restrict Workflows to only use <strong>verified Actions</strong> from trusted sources. This includes: </p><ul><li><p><strong>Actions created by GitHub</strong>: These are Actions maintained and supported by GitHub itself. </p></li><li><p><strong>Actions from Marketplace-verified creators</strong>: Actions from verified creators in the GitHub Marketplace are more trustworthy, as they have undergone some level of review. </p></li></ul><p>You can then use an allowlist of specific other trusted or reviewed Actions to extend permitted sources.  </p><p><strong>3. Govern Workflow Adoption and Restrict Runners to Specific Repositories</strong> </p><p>To tighten security, <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/organizations/managing-organization-settings/disabling-or-limiting-github-actions-for-your-organization"><u>use a </u><strong><u>repository allowlist</u></strong></a> to control where Workflows can be adopted, and <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups"><strong><u>restrict self-hosted runners</u></strong><u> to specific repositories</u></a>.  </p><figure><a href="https://www.wiz.io/blog/state-of-code-security-report-2025"></a><figcaption>Source: Wiz&#39;s 2025 State of Code Security Report</figcaption></figure><p>This ensures only trusted Workflows and runners are executed, reducing the risk of unauthorized access and execution. </p><p><strong>4. Avoid ‘Allow GitHub Actions to Create and Approve Pull Requests’</strong> </p><p><a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#preventing-github-actions-from-creating-or-approving-pull-requests"><u>Enabling this setting</u></a> grants Workflows the ability to create and approve pull requests, which can be risky. Ensure this setting is deactivated, to prevent Workflows from making changes to pull request approvals or creating pull requests without manual oversight. </p><h3><a id="branch-protection-28"></a>Branch Protection </h3><p>In addition to organization-level settings, there are also <strong>repository-level controls</strong> that help secure your Workflows. Most importantly, <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule"><u>Branch Protection</u></a> and <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/about-rulesets"><u>rulesets</u></a> enforce rules before code can be merged, ensuring only trusted code makes it into your main and release branches. This is important because attackers often target these branches to exploit vulnerabilities in your CI/CD pipeline, where automated Workflows like deployments or tests could be manipulated.  </p><p>However, branch protection <a rel="noreferrer noopener" target="_blank" href="https://engineering.mercari.com/en/blog/entry/20241217-github-branch-protection/"><u>has limitations</u></a>. <strong>Malicious commits post-approval</strong> is an attack that occurs when an attacker injects malicious changes after a pull request is approved but before it’s merged. <strong>Pull request hijacking</strong> can happen when attackers add harmful changes to someone else&#39;s pull request, then approve it themselves. GitHub offers <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/available-rules-for-rulesets#require-a-pull-request-before-merging"><u>configuration options</u></a> to close off these attack paths: “Dismiss stale pull request approvals when new commits are pushed” for the former, and “requiring an approval from someone other than the last person to push” for the latter. </p><p>However, it can be unreasonable to enable those options in agile environments, where rapid merging and flexibility are prioritized. Implementing <a rel="noreferrer noopener" target="_blank" href="https://www.figma.com/blog/how-we-enforce-device-trust-on-code-changes/"><u>commit signing and out-of-band detection</u></a> can provide an additional layer of security. </p><h3><a id="secrets-management-for-github-actions-32"></a>Secrets Management for GitHub Actions </h3><p><a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions"><u>Secrets</u></a> play a role in most attacks on Github Actions. They offer opportunities for pivoting, persistence, and privilege escalation. There are three types of secrets in GitHub: repository, organization, and environment.  </p><p>Repository-level secrets are specific to a single repository and should be the default choice.  </p><p>Organization-level secrets are useful when you want to share secrets across multiple repositories, reducing duplication and ensuring updates or rotation propagate automatically. They work well for credentials used by general CI infrastructure, like shared build tools or third-party service tokens.  </p><p>Environment-level secrets offer granular control. These secrets are only available to Jobs that reference the environment, and additional protection can be enforced with required approvals from reviewers, ensuring they are only accessible for approved Workflows. This can be ideal for sensitive actions like deployment, where you might want to restrict access from non-reviewed or unmerged pull requests. </p><p>By default, secrets (except GITHUB_TOKEN) are not passed to the runner when a Workflow is triggered from a fork and are not passed to GitHub Actions unless explicitly passed as an input or environment variable in your Workflow file. </p><p>However, beware: <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions#using-secrets"><u>Any user with write access to your repository has read access to all secrets configured in your repository</u></a>. So, make sure any credentials used in Workflows are safe to be exposed to that group. </p><h2><a id="safely-writing-github-workflows-39"></a>Safely Writing GitHub Workflows </h2><p>Now that we’ve covered your GitHub Organization and Actions’ configuration, let’s talk about the risks to avoid when constructing your own GitHub Workflows. </p><h3><a id="permissions-41"></a>Permissions </h3><p>When writing GitHub Workflows, it&#39;s essential to manage permissions carefully.  Organizations created <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/enterprise-server@3.15/admin/enforcing-policies/enforcing-policies-for-your-enterprise/enforcing-policies-for-github-actions-in-your-enterprise#workflow-permissions"><u>before February 2023</u></a> are particularly vulnerable to misconfigurations due to legacy settings that grant Workflows excessive (read-write) access by default.  </p><p>You can <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token#defining-access-for-the-github_token-permissions"><u>explicitly set `permissions: {}`</u></a> at the Workflow level, which forces Job-level specification of any necessary permissions. This can be a powerful tool for encouraging least-privilege Workflows, while reducing the exposure of GITHUB_TOKEN, or risk associated with it, to unnecessary Steps. </p><h3><a id="using-third-party-github-actions-44"></a>Using Third-Party GitHub Actions </h3><p>Using third-party GitHub Actions introduces risks, especially considering incidents like the tj-actions compromise. When <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions#using-third-party-actions"><u>referencing third-party actions in your Workflows</u></a>, you can either hash pin or use tag-based versioning. However, only hash pinning ensures the same code runs every time. It is important to consider <strong>transitive risk</strong>: even if you hash pin an Action, if it relies on another Action with weaker pinning, you&#39;re still exposed. To reduce risk, prioritize <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/apps/github-marketplace/github-marketplace-overview/about-marketplace-badges"><u>Verified</u></a> and GitHub-created (<code>action/</code> and <code>github/</code>) Actions over random third-party Actions.  </p><figure><figcaption>Based on data from Cardoen, G., Mens, T., &amp; Decan, A. (2024). A dataset of GitHub Actions workflow histories</figcaption></figure><p>Outside of verified and GitHub-created Actions, there are several heuristics you can use to assess the risk of a third-party Action. First, consider the number of contributors; a higher number brings expanded attack surface. Next, evaluate the code complexity. Overly complicated Actions may be harder to audit for vulnerabilities and harder to trust. Popularity is another useful indicator, as more widely used Actions tend to have a larger community checking for issues. Finally, ensure that the Action follows best practices, such as proper version pinning and other safeguards we&#39;ve outlined, to mitigate risks associated with supply chain vulnerabilities. </p><p>Ultimately, minimize the use of third-party Actions, as securing the supply chain comprehensively remains challenging. </p><h3><a id="secrets-49"></a>Secrets </h3><p>When working with secrets, they should be passed into the Step level <code>env</code>, only where needed. <a rel="noreferrer noopener" target="_blank" href="https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets#about-secrets"><u>GitHub Actions can only read a secret if you explicitly include the secret in a workflow.</u></a></p><p>Avoid accessing the entire secrets context, such as: </p><p>This antipattern exposes all secrets to the runner—even if only one is required. Instead, secrets should be accessed individually by name to limit exposure. </p><p>Along the same lines, avoid using <code>secrets: inherit</code> in reusable Workflows. Instead, explicitly define the secrets required by the reusable Workflow, ensuring only the necessary ones are passed along. </p><h3><a id="common-workflow-vulnerabilities-55"></a>Common Workflow Vulnerabilities </h3><p>A number of security issues in GitHub Actions Workflows fall under the broader category of <strong>Poisoned Pipeline Execution (PPE)</strong>. PPE refers to any situation where attacker-controlled input reaches trusted execution paths in the CI pipeline. In GitHub Actions, this typically happens when untrusted users can influence the code, configuration, or runtime behavior of Workflows that have elevated privileges—such as access to secrets or write permissions. </p><h4><a id="pwn-request-57"></a><strong>Pwn Request </strong></h4><p>One of the most common PPE scenarios in GitHub Actions is the misuse of high-privilege triggers like <code>pull_request_target </code>and <code>workflow_run</code>. </p><p>These triggers run Workflows in the context of the base repository, not the fork. This means they have access to repository secrets. </p><p>If a workflow triggered by <code>pull_request_target</code> checks out and executes code from the forked branch—using <code>actions/checkout</code> or similar—the attacker can influence execution while the workflow has access to secrets or privileged Actions. This creates a high-risk scenario. </p><h4><a id="living-off-the-pipeline-61"></a><strong>Living Off The Pipeline </strong></h4><p>Many <a rel="noreferrer noopener" target="_blank" href="https://boostsecurityio.github.io/lotp/"><u>common CI/CD tools</u></a>—linters, test runners, build systems, and security scanners—process files from the repository. Some of these tools include features that can execute code during configuration or initialization. This creates an opportunity for attackers to abuse legitimate tools to gain code execution in the pipeline. </p><h4><a id="github_env-and-github_path-63"></a><strong>GITHUB_ENV and GITHUB_PATH </strong></h4><p>Workflows should also avoid writing to GITHUB_ENV and GITHUB_PATH in any Step where attacker-controlled content might be used. These files influence subsequent Steps: </p><ul><li><p>GITHUB_ENV allows setting environment variables </p></li><li><p>GITHUB_PATH modifies the system path </p></li></ul><p>An attacker could use them to introduce malicious binaries or influence execution via environment variables like LD_PRELOAD. These mechanisms are powerful and should only be used in trusted contexts. </p><h4><a id="command-injection-via-attacker-controlled-workflow-elements-67"></a>Command Injection via Attacker-Controlled Workflow Elements </h4><p>Not all PPE involves misuse of triggers. In some cases, Workflows include logic that uses <a rel="noreferrer noopener" target="_blank" href="https://github.com/synacktiv/octoscan"><u>attacker-controlled inputs,</u></a> generally through interpolated values in the run: Steps, dynamically evaluated parameters, or CLI arguments sourced from PR comments or issue metadata. This can lead to command injection. </p><p>Examples: </p><ul><li><p>Using <code>run: some-command ${{ github.event.issue.title }}</code> where issue titles are user-controlled </p></li><li><p>Interpolating branch names, file contents, or labels directly into shell scripts </p></li></ul><p>If Workflows use this type of dynamic behavior, inputs should be validated or sanitized. In many cases, it&#39;s safer to avoid interpolation entirely and pass values through well-defined interfaces (e.g., reusable Workflows with explicit inputs). </p><h4><a id="artifact-and-credential-handling-72"></a>Artifact and Credential Handling </h4><p>Workflows often use artifacts to share data between Jobs or Workflows. These artifacts can pose a security risk if they contain sensitive data (e.g., credentials, config files with secrets). <code>actions/checkout</code> persists a credential by default in <code>.git/config</code>. Later Steps have been known to accidentally publish that credential in an artifact, for example via <code>actions/upload-artifact</code>. Set <code>persist-credentials: false</code> to opt-out, unless necessary. </p><h2><a id="safely-running-github-workflows-74"></a>Safely Running GitHub Workflows </h2><p>Safely running Workflows requires consideration of the underlying runner infrastructure. GitHub-hosted runners are ephemeral by default and tightly sandboxed, suitable for most use cases. However, teams often turn to self-hosted runners when they need faster execution, custom environments, or for cost optimization. </p><p>Self-hosted runners execute Jobs directly on machines you manage and control. While this flexibility is useful, it introduces significant security risks, as <a rel="noreferrer noopener" target="_blank" href="https://safely%20running%20workflows%20requires%20careful%20consideration%20of%20the%20underlying%20runner%20infrastructure.%20By%20default,%20GitHub-hosted%20runners%20are%20ephemeral%20and%20tightly%20sandboxed,%20offering%20a%20secure,%20managed%20option%20for%20most%20use%20cases.%20However,%20teams%20often%20turn%20to%20self-hosted%20runners%20when%20they%20need%20faster%20execution,%20custom%20environments,%20or%20access%20to%20internal%20resources.%20%20Self-hosted%20runners%20execute%20jobs%20directly%20on%20machines%20you%20manage%20and%20control.%20While%20this%20flexibility%20is%20useful,%20it%20introduces%20significant%20security%20risks%E2%80%94risks%20that%20GitHub%20explicitly%20warns%20about%20in%20their%20documentation.%20Runners%20are%20non-ephemeral%20by%20default,%20meaning%20the%20environment%20persists%20between%20jobs.%20If%20a%20workflow%20is%20compromised,%20attackers%20may%20install%20background%20processes,%20tamper%20with%20the%20environment,%20or%20leave%20behind%20persistent%20malware.%20For%20example,%20if%20the%20runner%20has%20Docker%20installed%20and%20the%20runner%20process%20is%20part%20of%20the%20docker%20group,%20a%20job%20could%20launch%20a%20container%20with%20elevated%20privileges%E2%80%94effectively%20granting%20root%20access%20to%20the%20host%20system%20and%20enabling%20evasion%20from%20host-based%20security%20controls.%20%20To%20reduce%20the%20attack%20surface,%20organizations%20should%20isolate%20runners%20by%20trust%20level,%20using%20runner%20groups%20to%20prevent%20public%20repositories%20from%20sharing%20infrastructure%20with%20private%20ones.%20Network%20egress%20should%20be%20tightly%20controlled,%20with%20allowlists%20in%20place%20to%20block%20outbound%20connections%20to%20unknown%20or%20untrusted%20destinations.%20Runners%20should%20also%20be%20instrumented%20like%20production%20infrastructure%E2%80%94monitor%20processes,%20log%20activity,%20and%20inspect%20behavior%20for%20signs%20of%20compromise.%20Wherever%20possible,%20use%20ephemeral%20infrastructure%20that%20tears%20down%20after%20each%20job%20to%20minimize%20persistence%20opportunities.%20%20Finally,%20when%20workflows%20connect%20to%20downstream%20systems,%20avoid%20long-lived%20secrets.%20GitHub%20supports%20OpenID%20Connect%20(OIDC),%20which%20allows%20workflows%20to%20authenticate%20with%20cloud%20providers%20using%20short-lived,%20identity-bound%20tokens.%20This%20reduces%20credential%20risk%20and%20helps%20enforce%20fine-grained%20access%20control%20across%20your%20CI/CD%20pipeline."><u>GitHub explicitly warns in their documentation</u></a>. Runners are non-ephemeral by default, meaning the environment persists between Jobs. If a workflow is compromised, attackers may install background processes, tamper with the environment, or leave behind persistent malware. </p><p>To reduce the attack surface, organizations should isolate runners by trust level, using runner groups to prevent public repositories from sharing infrastructure with private ones. <strong>Self-hosted runners should never be used with public repositories</strong>. Doing so exposes the runner to untrusted code, including Workflows from forks or pull requests. An attacker could submit a malicious workflow that executes arbitrary code on your infrastructure.  </p><p>When self-hosted runners are used, they should be instrumented as sensitive production infrastructure: monitor processes, log activity, and inspect behavior for signs of compromise. Wherever possible, use ephemeral infrastructure that tears down after each Job to minimize persistence opportunities. Consider limiting network egress, only allowing outbound connections to known and trusted destinations. </p><p>Finally, when Workflows connect to downstream systems, <a rel="noreferrer noopener" target="_blank" href="https://wellarchitected.github.com/library/application-security/recommendations/actions-security/"><u>avoid long-lived secrets</u></a>. GitHub supports OpenID Connect (OIDC), which allows Workflows to authenticate with cloud providers using short-lived, identity-bound tokens. This reduces credential risk and helps enforce fine-grained access control across your CI/CD pipeline. </p><h2><a id="takeaways-80"></a>Takeaways </h2><p>This might seem overwhelming.  </p><p>To start, focus on a few core tips to safely use Github Actions: </p><ol><li><p><strong>Minimize third-party attack surface </strong>through limiting third-party Actions, and hash pinning the Actions you use.  </p></li><li><p><strong>Minimize permissions and secrets </strong>granted to Workflows and used with third-party Actions, favoring OIDC where supported for integrations. </p></li><li><p><strong>Avoid Poisoned Pipeline Execution</strong> through careful audits of high-privilege triggers and attacker-controlled workflow elements. </p></li></ol><p>There are also open source tools available to help: </p><ul><li><p><a rel="noreferrer noopener" target="_blank" href="https://github.com/woodruffw/zizmor"><u>zizmor</u></a>: a static analysis tool for GitHub Actions, with coverage for most of the common misconfigurations  </p></li><li><p><a rel="noreferrer noopener" target="_blank" href="https://github.com/praetorian-inc/gato"><u>gato</u></a> and <a rel="noreferrer noopener" target="_blank" href="https://github.com/AdnaneKhan/Gato-X"><u>Gato-X</u></a>: two variants of an enumeration and attack tool, each with unique features </p></li><li><p><a rel="noreferrer noopener" target="_blank" href="https://github.com/ossf/allstar"><u>allstar</u></a>: a GitHub App to set and enforce security policies on GitHub organizations or repositories, from <a rel="noreferrer noopener" target="_blank" href="https://openssf.org/"><u>OpenSSF</u></a> </p></li></ul><p>Want the whole picture on risks in code and version control systems? Check out Wiz&#39;s <a target="_blank" href="https://www.wiz.io/blog/state-of-code-security-report-2025">2025 State of Code Security Report</a></p></div></div>
  </body>
</html>
