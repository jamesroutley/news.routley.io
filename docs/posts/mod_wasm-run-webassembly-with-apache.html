<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://wasmlabs.dev/articles/apache-mod-wasm/">Original</a>
    <h1>mod_wasm: Run WebAssembly with Apache</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><a href="https://httpd.apache.org/">Apache httpd</a> is a modular web server that <strong>powers <a href="https://w3techs.com/technologies/overview/web_server">31% of all websites</a> you access every day</strong>. One of its most compelling features is the ability to extend it with new modules. Developers can choose among different modules to add or remove features like CGI, TLS, PHP, and many others.</p>
<p>Today, we announce <strong>a new Apache module to run WebAssembly modules: <a href="https://github.com/vmware-labs/mod_wasm">mod_wasm</a></strong>. This module opens a new set of possibilities as many languages and projects can run securely in Apache.</p>
<h2>What is WebAssembly?</h2>
<p><a href="https://webassembly.org/">WebAssembly</a> (Wasm) is a binary instruction format designed for a lightweight virtual machine, typically called runtime. <strong>Different languages can be compiled into Wasm and run in any place where a runtime is available</strong>. This makes Wasm a polyglot format that can run applications from a wide variety of languages such as C, C++, Rust, Go, etc.</p>
<p>You may notice that all languages we mentioned are compiled languages. Fortunately, Wasm is not limited to that. Most existing interpreters for dynamic languages are developed in one of those compiled languages, so <strong>you can compile both the interpreter and the source code into a Wasm module</strong>. This approach allowed us to run <a href="https://wordpress.wasmlabs.dev">WordPress and PHP in the browser</a> several months ago.</p>
<p>Wasm was created to bring new languages into web browsers and the adoption was incredible. After that, people started to think on the capabilities of Wasm on the server side. We strongly agree with this mindset and today, <strong>we helped to bring Wasm to one of the most popular web servers in the world</strong>: <a href="https://httpd.apache.org/">Apache httpd</a>.</p>
<p>If you want to know more about Wasm, we recommend this <a href="https://thenewstack.io/what-is-webassembly/">great article from TheNewStack</a>.</p>
<h2>Introducing mod_wasm</h2>
<p><a href="https://github.com/vmware-labs/mod_wasm">mod_wasm</a> is an Apache httpd module to run Wasm modules. <strong>It allows you to reply to HTTP requests with applications compiled to Wasm</strong>. Internally, it uses the <a href="https://wasmtime.dev/">wasmtime</a> runtime to configure, initialize, and run the Wasm modules. The rest of this section explains how it works internally. If you are just interested in using it, you can skip to the next one.</p>
<p>The module is composed of two libraries:</p>
<ul>
<li><strong>mod_wasm.so</strong>: this is the interface between the Apache C API and the Rust library that manages the Wasm runtime. It is responsible for the Apache configuration options and the bindings to connect the rust library with Apache.</li>
<li><strong>libwasm_runtime.so</strong>: it receives HTTP requests from Apache, configures the Wasm module and runs it. Then, it parses the response and returns the control to mod_wasm.so.</li>
</ul>
<p><img src="https://wasmlabs.dev/static/images/articles/apache-mod-wasm/diagram.webp" alt="A diagram showing how Apache HTTP server initiates mod_wasm.so. Then, mod_wasm.so talks with libwasm_runtime.so dinamically. Wasmtime is instantited from the libwasm_runtime.so"/></p>
<p>When you run an Apache httpd server with mod_wasm enabled, it preloads the Wasm module in memory. During the Apache initialization phase, <code>mod_wasm.so</code> reads the configuration and sends it to <code>libwasm_runtime.so</code>. Then, the module is read from the filesystem and preloaded in memory with wasmtime. This approach speeds up the request handling by not loading the Wasm module from scratch every time it receives a request.</p>
<p><strong>The server is now ready to start processing requests</strong>. <code>mod_wasm.so</code> evaluates every request to process the ones that belongs to the configured path. Then, the request is processed and passed to the <code>libwasm_runtime.so</code>. This library <strong>configures a new wasmtime context with the HTTP headers and the request body and runs the module</strong>.</p>
<p>To pass this information, we use the WebAssembly System Interface (<a href="https://wasi.dev/">WASI</a>), a modular system interface for WebAssembly. <strong>WASI allows you to configure common system interfaces</strong> such as environment variables, filesystem, and standard input / output (stdio). <code>libwasm_runtime.so</code> takes advantage of these features to configure HTTP headers as environment variables and pass the request body through the standard input (stdin).</p>
<p>Finally, the Wasm module returns all the data through the standard output (stdout). There, we process the response as with CGI by looking for the HTTP response headers at the top and the content right after.</p>
<p><strong>This approach provides the ability to use multiple compiled and interpreted languages to serve content through Apache httpd</strong>. And now, let&#39;s jump right to the demo!</p>
<h2>Try mod_wasm</h2>
<p>To run mod_wasm you need to compile the module and configure it in Apache httpd. To skip these steps, <strong>we created a container image you can run directly</strong>. So, to try mod_wasm you only need a container image runtime such as <a href="https://docs.docker.com/get-docker/">docker</a> or <a href="https://podman.io/getting-started/">podman</a>, and then run the following command:</p>
<pre><code><span>docker</span> run -p <span>8080</span>:8080 <span>\</span> </code></pre>
<p>Now, open your browser at <a href="http://localhost:8080/wasm-module-endpoint">http://localhost:8080/wasm-module-endpoint</a> and see the result.</p>
<p>In case you prefer to watch it, here you can find a video of the demo:</p>
<p><a href="https://www.youtube.com/watch?v=-u1UG2XJFeM"><img src="https://wasmlabs.dev/static/images/articles/apache-mod-wasm/video.webp" alt="Image with Video thumbail. This will link you to a youtube video"/></a></p>
<p>Though your browser is rendering a regular HTML page, <strong>it has been created dynamically using Python</strong>. What makes it special is that the <strong>Python script was executed inside a WebAssembly runtime</strong>. In the default example, you are running a Wasm module that includes the <a href="https://github.com/python/cpython">CPython</a> interpreter. The current configuration mounts a <a href="https://github.com/vmware-labs/mod_wasm/blob/main/examples/wasm_modules/python-scripts/cgi_prettify.py">Python script</a> to reply to the request.</p>
<p>The Python interpreter was compiled using the amazing work from the <a href="https://www.fermyon.com/">Fermyon team</a>. You can find the source code in the <a href="https://github.com/fermyon/wagi-python">fermyon/wagi-python</a> repository.</p>
<h3>Run your own application</h3>
<p>We included more <a href="https://github.com/vmware-labs/mod_wasm/tree/main/examples">Python examples and some written in Rust</a>. You can <a href="https://github.com/vmware-labs/mod_wasm#running-the-different-examples">find all the instructions in the README</a> to run them. We included the compiled Wasm module for running them, but you can also check the source code of <a href="https://github.com/vmware-labs/mod_wasm/tree/main/examples">all the examples</a>.</p>
<p>To run an application in mod_wasm, you need to consider:</p>
<ul>
<li>The final output is a Wasm module with WASI interfaces enabled</li>
<li>The HTTP headers are available as <code>HTTP_X</code> environment variables</li>
<li>The module should print its result on the standard output. The result HTTP headers should be printed at the beginning in a <code>key = value</code> format, one per line, followed by two break lines before the response body</li>
</ul>
<p>This means that any application that be configured with these constraints can work without any modification. <strong>This includes from fully featured applications to small scripts</strong>. This means you can run the same applications in the same Apache httpd environment, in a more secure way.</p>
<p>To get a taste for the source code, you have <a href="https://github.com/vmware-labs/mod_wasm/tree/main/examples/rust-src">two Rust examples in the repository</a>. We will include more soon!</p>
<h2>Isolation and security</h2>
<p>One of the questions you may ask yourself is why is this approach better than running the application directly as a service. It is a fair question. The key point here is security and how WebAssembly isolates the running application from the host service.</p>
<p>From the <a href="https://webassembly.org/">WebAssembly</a> documentation:</p>
<blockquote>
<p>WebAssembly describes a memory-safe, sandboxed execution environment [...]</p>
</blockquote>
<p>To illustrate this WebAssembly statement, let&#39;s describe two different scenarios here:</p>
<ul>
<li>On every request, we run a Python script using a local, native Python interpreter</li>
<li>On every request, we set the WASI context and run the same script inside the Wasm runtime</li>
</ul>
<p><strong>On the local Python interpreter scenario, the script has the same permissions as the Python interpreter</strong>. A bug in the code may allow an attacker to read or alter the filesystem in an unexpected way or in the worst case, <a href="https://en.wikipedia.org/wiki/Arbitrary_code_execution">run arbitrary code on the machine</a>.</p>
<p>On the WebAssembly scenario, even when we run the same vulnerable script, it will not be able to access the host filesystem or run arbitrary code. Wasm capability-based security design ensures that by default, <strong>Wasm modules do not have access to host machine resources. Permissions are fine-grained and must be granted manually</strong>.</p>
<p>For example, to read a file inside a Wasm module with WASI, you still need to give permissions to read the file when running the module. This strong isolation design reduces the attack surface and mitigates common and dangerous vulnerabilities.</p>
<h3>Accessing an arbitrary file demo</h3>
<p>We also included a demo to showcase the Wasm capability-based security model. In this example, we reproduce the behaviour we described in the previous section. The server is configured with two different endpoints:</p>
<ul>
<li>A CGI endpoint that runs a Python script with the local Python interpreter</li>
<li>A mod_wasm endpoint that runs the same Python script in Wasm</li>
</ul>
<p>The Python script has a vulnerable query parameter that allows an attacker to read arbitrary files from the filesystem. You can also run this example by following the instructions <a href="https://github.com/vmware-labs/mod_wasm#demonstrating-security-capabilities">in the repository</a>.</p>
<h2>Apache ❤️ WebAssembly</h2>
<p><strong>WebAssembly brings new capabilities to many different environments</strong>. The ability to run many languages in different environments with a variety of restrictions, and mitigate common security issues, is one of the capabilities we are most excited about.</p>
<blockquote>
<p>Run the same applications and the same Apache httpd environment, in a more secure way</p>
</blockquote>
<p>WebAssembly is a huge step forward in securing server side applications. <strong>It brings many new benefits not only to cutting edge technologies and frameworks, but also to already existing applications and services</strong>. In this article we talk about Python, but Ruby, PHP, Rust, Go, C, C++, and many others are part of it.</p>
<p><strong>We are delighted to bring WebAssembly to a huge community like Apache</strong>. This mod_wasm release is our initial one. As such, it is still simple and can be improved in a variety of ways, hopefully with your help!</p>
<p>We have many more features planned, including support for other popular server-side languages as well as additional Wasm runtimes. We welcome your feedback and ideas for improvement as well as your code and documentation contributions.</p>
<p>If you are interested in our work, do not forget to <a href="https://twitter.com/intent/user?screen_name=vmwwasm">follow us on @vmwwasm</a> to get updates on our projects.</p>
</div></div>
  </body>
</html>
