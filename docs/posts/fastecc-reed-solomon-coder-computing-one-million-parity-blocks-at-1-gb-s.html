<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/Bulat-Ziganshin/FastECC">Original</a>
    <h1>FastECC â€“ Reed-Solomon coder computing one million parity blocks at 1 GB/s</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><p dir="auto">FastECC implements FFT-based O(N*log(N)) <a href="https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction" rel="nofollow">Reed-Solomon coder</a>, running at <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md#reed-solomon-encoding">1.2 GB/s</a>
on <a href="https://ark.intel.com/products/75122/Intel-Core-i7-4770-Processor-8M-Cache-up-to-3_90-GHz" rel="nofollow">i7-4770</a> for (n,k)=(2^20,2^19), i.e. calculating 524288 parity blocks from 524288 data blocks.</p>
<p dir="auto">It&#39;s also <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md#small-ntt">pretty fast for small orders</a>, outperforming previously fastest Reed-Solomon library, Intel <a href="https://github.com/01org/isa-l">ISA-L</a> for 64+ parity blocks.</p>
<p dir="auto">The encoding and decoding algorithms going to be implemented by FastECC were described in the paper
<a href="https://pdfs.semanticscholar.org/141d/c4ee4cca45b4ed1c07f890f758e427597db8.pdf" rel="nofollow">An Efficient (n,k) Information Dispersal Algorithm based on Fermat Number Transforms</a>
by Sian-Jheng Lin and Wei-Ho Chung. FastECC v0.1 implements only encoding, so it isn&#39;t yet ready for real use.</p>
<a name="user-content-what">
</a><h2 dir="auto"><a name="user-content-what"></a><a id="user-content-what" aria-hidden="true" href="#what"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>What</h2>
<p dir="auto"><a name="user-content-what">Almost all existing Reed-Solomon </a><a href="https://en.wikipedia.org/wiki/Error_detection_and_correction#Error-correcting_codes" rel="nofollow">ECC</a> implementations employ matrix multiplication and thus have O(N^2) speed behavior,
i.e. they can produce N parity blocks in O(N^2) time, thus spending O(N) time per block.
F.e. the fastest implementation I know, <a href="https://www.livebusinesschat.com/smf/index.php?board=396.0" rel="nofollow">MultiPar</a>, can compute 1000 parity blocks at the speed ~50MB/s,
but only at ~2 MB/s in its maximum configuration, 32000 parity blocks.
And computations in GF(2^32), implemented in the same way, will build one million parity blocks at 50 KB/s.</p>
<p dir="auto">One of few exceptions is closed-source <a href="https://www.livebusinesschat.com/smf/index.php?board=399.0" rel="nofollow">RSC32 by persicum</a> with O(N*log(N)) speed, i.e. it spends O(log(N)) time per parity block.
Its speed with million parity blocks is 100 MB/s, i.e. it computes one million of 4 KB parity blocks
from one million of data blocks (processing 8 GB overall) in just 80 seconds.
Note that all speeds mentioned here are measured on <a href="https://ark.intel.com/products/75122/Intel-Core-i7-4770-Processor-8M-Cache-up-to-3_90-GHz" rel="nofollow">i7-4770</a>, employing all features available in a particular program -
including multi-threading, SIMD and x64 support.</p>
<p dir="auto">FastECC is open-source library implementing O(N*log(N)) encoding algorithm.
It computes million parity blocks at [1.2 GB/s].
Future versions will implement decoding that&#39;s also <code>O(N*log(N))</code>, although 1.5-3 times slower than encoding.
Current implementation is limited to 2^20 blocks, removing this limit is the main priority for future work
aside of decoder implementation.
And if you are interested in smaller configs, look at <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md#small-ntt">small NTT benchmarks</a> -
FastECC outperforms quadratic algorithms (<a href="https://github.com/01org/isa-l">ISA-L</a>, <a href="https://github.com/catid/cm256">CM256</a> and <a href="https://www.livebusinesschat.com/smf/index.php?board=396.0" rel="nofollow">MultiPar</a>) starting from 32-64 parity blocks.</p>
<p dir="auto"><a href="https://github.com/catid/leopard">Leopard</a> is a new library, <a href="https://github.com/catid/leopard/blob/master/Benchmarks.md">faster</a> than <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md#reed-solomon-encoding">FastECC</a>, especially for small orders.
It implements similar algorithm, described in newer paper by the same authors:
<a href="https://github.com/SianJhengLin/Fast-algorithms-of-Reed-Solomon-erasure-codes">Lin, Han and Chung &#34;Novel Polynomial Basis and Its Application to Reed-Solomon Erasure Codes&#34;</a>.</p>
<p dir="auto">You can also find a few <a href="https://www.livebusinesschat.com/smf/index.php?topic=5888.msg42216#msg42216" rel="nofollow">research-grade libraries</a> with O(N*log(N)) speed.</p>
<p dir="auto">For comparison - <a href="https://github.com/catid/wirehair">Wirehair</a>, the best open-source LDPC codec I know, is O(N) and
<a href="https://github.com/catid/wirehair#benchmarks">already as fast</a> as <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md#reed-solomon-encoding">FastECC</a>,
but can be made <a href="https://github.com/catid/wirehair/issues/2" data-hovercard-type="issue" data-hovercard-url="/catid/wirehair/issues/2/hovercard">several times faster using SSE1</a>.
It&#39;s limited to 64000 source blocks, but amount of parity blocks can be arbitrary.
It&#39;s an LDPC codec, so not <a href="https://en.wikipedia.org/wiki/Singleton_bound#MDS_codes" rel="nofollow">MDS</a>,
but chances that it needs even a single extra block to recover is <a href="https://github.com/catid/wirehair#discussion-overhead-reductions-with-gf216">as low as 0.1%</a>.
Moreover, it works with binary data, so no need for <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/GF.md#data-packing">recoding</a> and no need for extra space to store &#34;overflow&#34; bits.</p>
<a name="user-content-how">
</a><h2 dir="auto"><a name="user-content-how"></a><a id="user-content-how" aria-hidden="true" href="#how"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>How</h2>
<p dir="auto">All O(N*log(N)) Reed-Solomon implementations I&#39;m aware of, use fast transforms like FFT or FWT.
FastECC employs fast Number-Theoretic Transform that is just an FFT over integer field or ring.
Let&#39;s see how it works. Note that below by <code>length-N polynomial</code> I mean any polynomial with order &lt; N.</p>
<p dir="auto">For any given set of N points, only one length-N polynomial may go through all these points.
Let&#39;s consider N input words as values of some length-N polynomial at N fixed points,
only one such polynomial may exist.</p>
<p dir="auto"><a name="user-content-how">Typical Reed-Solomon encoding computes coefficients of this unique polynomial (so-called </a><a href="https://en.wikipedia.org/wiki/Polynomial_interpolation" rel="nofollow">polynomial interpolation</a>),
evaluates the polynomial at M another fixed points (the <code>polynomial evaluation</code>)
and outputs these M words as the resulting parity data.</p>
<p dir="auto">At the decoding stage, we may receive any subset of N values out of those N source data words and M computed parity words.
But since they all belong to the original length-N polynomial, we may recover this polynomial from N known points
and then compute its values at other points, in particular those N points assigned to original data, thus restoring them.</p>
<a name="user-content-fast">
</a><h2 dir="auto"><a name="user-content-fast"></a><a id="user-content-fast" aria-hidden="true" href="#fast"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Fast</h2>
<p dir="auto"><a name="user-content-fast">Usually, Reed-Solomon libraries implement encoding by multiplication with </a><a href="https://en.wikipedia.org/wiki/Vandermonde_matrix" rel="nofollow">Vandermonde matrix</a> (O(N^2) algo)
and decoding by multiplication with the matrix inverse.</p>
<p dir="auto">But with special choice of fixed points we can perform polynomial interpolation and evaluation at these points
in O(N*log(N)) time, using NTT for evaluation and inverse NTT for interpolation. So, <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/bed3a3f4c228ee7ab61cee1b7c28b6d4d76df02d/RS.cpp#L37">the fast encoding</a> is as simple as:</p>
<ul dir="auto">
<li>consider N input words as values of length-N polynomial at N special points</li>
<li>compute the polynomial coefficients in O(N*log(N)) time using inverse NTT</li>
<li>evaluate the polynomial at another M special points in O(M*log(M)) time using NTT</li>
</ul>
<p dir="auto">Decoding is more involved. We have N words representing values of length-N polynomial at <strong>some</strong> N points.
Since we can&#39;t choose these points, we can&#39;t just use iNTT to compute the polynomial coefficients.
So it&#39;s a generic <a href="https://en.wikipedia.org/wiki/Polynomial_interpolation" rel="nofollow">polynomial interpolation</a> problem that can be solved in <a href="https://www.google.com/search?q=fast+polynomial+interpolation" title="fast polynomial interpolation" rel="nofollow">O(N*log(N)^2) time</a>.</p>
<a name="user-content-faster">
</a><h2 dir="auto"><a name="user-content-faster"></a><a id="user-content-faster" aria-hidden="true" href="#faster"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Faster</h2>
<p dir="auto">But this specific polynomial interpolation problem has faster solution.
Indeed, decoder knows values of length-N polynomial f(x) at N points a[i], but lost its values at M erasure points e[i].
Let&#39;s build &#34;erasure locator&#34; polynomial <code>l(x) = (x-e[1])*...*(x-e[M])</code> and compute polynomial product <code>p(x)=f(x)*l(x)</code>.
We have <code>order(p) = order(f)+order(l) &lt; N+M</code> and l(e[i])=0, so by computing values l(a[i]) and then multiplying f(x) and l(x) in the value space
we can build polynomial p(x) with order&lt;N+M described by its values at N+M points <code>p(a[i]) = f(a[i])*l(a[i]),  p(e[i]) = f(e[i])*l(e[i]) = 0</code>,
i.e. we have fully defined p(x).</p>
<p dir="auto"><a name="user-content-faster">Now we just need to perform </a><a href="https://en.wikipedia.org/wiki/Polynomial_long_division" rel="nofollow">polynomial long division</a> f(x)=p(x)/l(x), that is <a href="https://www.google.com/search?q=fast+polynomial+division" title="fast polynomial division" rel="nofollow">O(N*log(N)) operation</a>.</p>
<a name="user-content-fastest">
</a><h2 dir="auto"><a name="user-content-fastest"></a><a id="user-content-fastest" aria-hidden="true" href="#fastest"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Fastest</h2>
<p dir="auto">But there is even faster algorithm! Let&#39;s build formal derivative <code>p&#39;(x) = f&#39;(x)*l(x) + f(x)*l&#39;(x)</code>
and evaluate it at each e[i]: <code>p&#39;(e[i]) = f&#39;(e[i])*l(e[i]) + f(e[i])*l&#39;(e[i]) = f(e[i])*l&#39;(e[i])</code> since l(e[i])=0.
Moreover, l&#39;(e[i])!=0, so we can recover all the lost f(e[i]) values by simple scalar divisions: <code>f(e[i]) = p&#39;(e[i]) / l&#39;(e[i])</code>!!!</p>
<p dir="auto">So, the entire algorithm is:</p>
<ul dir="auto">
<li>transform polynomials p and l into coefficient space</li>
<li>compute their formal derivatives p&#39; and l&#39;</li>
<li>transform p&#39; and l&#39; into value space</li>
<li>evaluate each <code>f(e[i]) = p&#39;(e[i]) / l&#39;(e[i])</code></li>
</ul>
<p dir="auto">When M&lt;=N, first operation on p is iNTT(2N),
third operation on p&#39; is NTT(N) since we need to compute p&#39;(x) values only at N points corresponding to original data,
and rest is either O(N) or operations on l(x) that is performed only once,
so overall decoding is 1.5-3 times slower than iNTT(N)+NTT(M) operations required for encoding.</p>
<a name="user-content-why-not">
</a><h2 dir="auto"><a name="user-content-why-not"></a><a id="user-content-why-not" aria-hidden="true" href="#why-not"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Why not</h2>
<p dir="auto"><a name="user-content-why-not">FastECC is absolutely useless for RAID storage (such as hadoop). With RAID, when one sector is overwritten,
RAID software should read all other data sectors in the same shard in order to recompute parity sectors of the shard,
and then overwrite all these parity sectors. So, RAID software developers are looking for solutions that will allow them
to read/write less sectors on each operation (such as </a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/Pyramid-Codes.pdf" rel="nofollow">pyramid codes</a>),
rather than opposite.</p>
<p dir="auto">FastECC is probably useless for any hardware controllers (SSD, Ethernet, LTE, DVB...).
These controllers work with analog signals and tend to use <strong>soft</strong> decoders to extract as much data as possible
(soft decoders understand that data received as 7 have more chances to be decoded as 8 rather than to be decoded as 2,
and can deal even with something like 7.4 which is more probably 8 rather than 6). Soft decoders are absolutely out of my Math skills,
so if someone will build soft decoder, it will be not FastECC, but other great lib (and most probably not free).</p>
<p dir="auto">Also, FastECC implements only erasure decoding. I have no idea how to implement error decoding nor plan to learn it.</p>
<p dir="auto">There are some applications still. PAR3 is one of them - it&#39;s still interesting for some people, although not many.
Various communication applications and P2P data storage are also frequently mentioned in <a href="#discussion">discussions</a>.</p>
<hr/>
<p dir="auto">I made a quick speed comparison and found that FastECC is faster than 16-bit RS codec in MultiPar starting from ~32 parity blocks.
8-bit RS codecs such as ISA-L should be even faster than 16-bit ones. And with 20% redundancy 32 parity blocks means 160 data blocks,
close to the maximum possible for 8-bit RS. So, it seems that FastECC territory starts right where 8-bit codecs territory ends -
if you need more than 256 data+parity blocks, FastECC should be faster than any 16-bit RS coders, otherwise 8-bit <a href="https://github.com/01org/isa-l">ISA-L</a> or <a href="https://github.com/catid/cm256">CM256</a> is preferable.</p>
<p dir="auto">Moreover, FastECC is free from patent restrictions that has any fast RS codec employing PSHUFB (i.e. SSSE3) including <a href="https://github.com/catid/leopard">Leopard</a>.
And slow codecs are several times slower than MultiPar, so they have even less chances.</p>
<p dir="auto">There is a great alternative to FastECC - <a href="https://github.com/catid/wirehair">Wirehair</a> library, but afair it also may be covered with patents.
It&#39;s <a href="https://github.com/catid/wirehair#benchmarks">already as fast</a> as <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md#reed-solomon-encoding">FastECC</a>,
but can be made <a href="https://github.com/catid/wirehair/issues/2" data-hovercard-type="issue" data-hovercard-url="/catid/wirehair/issues/2/hovercard">several times faster using SSE1</a>.
It&#39;s limited to 64000 source blocks, but amount of parity blocks can be arbitrary.
It&#39;s an LDPC codec, so not <a href="https://en.wikipedia.org/wiki/Singleton_bound#MDS_codes" rel="nofollow">MDS</a>,
but chances that it needs even single extra block to recover is <a href="https://github.com/catid/wirehair#discussion-overhead-reductions-with-gf216">as low as 0.1%</a>.</p>
<p dir="auto">Unlike Wirehair and MultiPar, FastECC doesn&#39;t work directly with arbitrary binary data - it works in GF(p) or GF(p^2), default is GF(0xFFF00001).
This means that input data <a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/GF.md#efficient-data-packing">should be converted</a> into 0..0xFFF00000 range,
that further means that parity sectors are slightly longer that input ones (f.e. 4096 byte data sectors and 4100 byte parity sectors).
This also limits its applications.</p>
<p dir="auto">So, overall, FastECC should replace any use of 16-bit RS codecs, while LDPC and 8-bit RS codecs will keep their niches.</p>
<a name="user-content-roadmap">
</a><h2 dir="auto"><a name="user-content-roadmap"></a><a id="user-content-roadmap" aria-hidden="true" href="#roadmap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Roadmap</h2>
<ul>
<li> Encoder (version 0.1)</li>
<li> Decoder (version 0.2)</li>
<li> Public API (see issue #1)</li>
<li> SSE2/AVX2/NEON-intrinsics with runtime selection of scalar/sse2/avx2/neon code path</li>
<li> NTT of sizes!=2^n: NTT5/NTT7/NTT13, PFA and MFA+PFA combined algo</li>
<li> Optimizations for asymmetric cases (n!=2k)</li>
<li> Optimized code for GF(2^31-1), GF(2^61-1) and GF(p^2)</li>
</ul>
<a name="user-content-more">
</a><h2 dir="auto"><a name="user-content-more"></a><a id="user-content-want-to-know-more" aria-hidden="true" href="#want-to-know-more"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Want to know more?</h2>
<ul dir="auto"><a name="user-content-more">
</a><li><a name="user-content-more"></a><a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Overview.md">NTT: Number-theoretic transform</a>: what one needs to know in order to implement O(N*log(N)) Reed-Solomon error-correcting codes</li>
<li><a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/GF.md">GF(p).cpp: fast computations in finite fields and rings</a></li>
<li><a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/NTT.md">NTT.cpp: NTT implementation</a></li>
<li><a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/RS.md">RS.cpp: Reed-Solomon coder</a></li>
<li><a href="https://github.com/Bulat-Ziganshin/FastECC/blob/master/Benchmarks.md">Benchmarks</a></li>
</ul>
<a name="user-content-discussion">
</a><h2 dir="auto"><a name="user-content-discussion"></a><a id="user-content-discussion" aria-hidden="true" href="#discussion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Discussion</h2>
<ul dir="auto"><a name="user-content-discussion">
</a><li><a name="user-content-discussion"></a><a href="https://encode.ru/threads/2750-FastECC-fastest-Reed-Solomon-codec-ever?p=52622" rel="nofollow">Encode.ru forum</a></li>
<li><a href="https://www.livebusinesschat.com/smf/index.php?topic=6154.0" rel="nofollow">MultiPar forum</a></li>
<li><a href="https://news.ycombinator.com/item?id=14290617" rel="nofollow">Hacker News story</a></li>
</ul>
</article>
          </div></div>
  </body>
</html>
