<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/sdzx-1/polystate">Original</a>
    <h1>Polystate: Composable Finite State Machines</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text"><p dir="auto">Polystate: Composable Finite State Machines</p>

<p dir="auto">Download and add polystate as a dependency by running the following command in your project root:</p>
<div dir="auto" data-snippet-clipboard-copy-content="zig fetch --save git+https://github.com/sdzx-1/polystate.git"><pre>zig fetch --save git+https://github.com/sdzx-1/polystate.git</pre></div>
<p dir="auto">Then add polystate as a dependency and import its modules and artifact in your build.zig:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    const polystate = b.dependency(&#34;polystate&#34;, .{
        .target = target,
        .optimize = optimize,
    });
"><pre>    <span>const</span> <span>polystate</span> <span>=</span> <span>b</span>.<span>dependency</span>(<span>&#34;polystate&#34;</span>, .{
        .<span>target</span> <span>=</span> <span>target</span>,
        .<span>optimize</span> <span>=</span> <span>optimize</span>,
    });
</pre></div>
<p dir="auto">Now add the modules to your module as you would normally:</p>
<div dir="auto" data-snippet-clipboard-copy-content="    exe_mod.addImport(&#34;polystate&#34;, typed_fsm.module(&#34;root&#34;));"><pre>    <span>exe_mod</span>.<span>addImport</span>(<span>&#34;polystate&#34;</span>, <span>typed_fsm</span>.<span>module</span>(<span>&#34;root&#34;</span>));</pre></div>

<p dir="auto"><a href="https://github.com/sdzx-1/polystate-examples">polystate-examples</a></p>
<p dir="auto"><a href="https://github.com/sdzx-1/ray-game">ray-game</a></p>

<p dir="auto"><a href="https://discord.gg/zUK2Zk9m" rel="nofollow">https://discord.gg/zUK2Zk9m</a></p>

<p dir="auto">Writing this document was more difficult than I anticipated. Although I have been writing and using this library for a while, it&#39;s not easy to explain it clearly to others. If you have any questions after reading this document, please don&#39;t hesitate to ask. I&#39;d be happy to clear up any confusion!</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Polystate&#39;s Core Design Philosophy</h2><a id="user-content-polystates-core-design-philosophy" aria-label="Permalink: Polystate&#39;s Core Design Philosophy" href="#polystates-core-design-philosophy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li>Record the state machine&#39;s status at the type level.</li>
<li>Achieve composable state machines through type composition.</li>
</ol>
<p dir="auto">Finite State Machines (FSMs) are a powerful programming pattern. When combined with composability and type safety, they become an even more ideal programming paradigm.</p>
<p dir="auto">The <code>polystate</code> library is designed precisely for this purpose. To achieve this, you need to follow a few simple programming conventions. These conventions are very straightforward, and the benefits they bring are entirely worth it.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Practical Effects of Polystate</h2><a id="user-content-practical-effects-of-polystate" aria-label="Permalink: Practical Effects of Polystate" href="#practical-effects-of-polystate"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<ol dir="auto">
<li><strong>Define the program&#39;s overall behavior through compositional declarations.</strong> This means we gain the ability to specify the program&#39;s overall behavior at the type level. This significantly improves the correctness of imperative program structures. This programming style also encourages us to redesign the program&#39;s state from the perspective of types and composition, thereby enhancing code composability.</li>
<li><strong>Build complex state machines by composing simple states.</strong> For the first time, we can achieve semantic-level code reuse through type composition. In other words, we have found a way to express semantic-level code reuse at the type level. This approach achieves three effects simultaneously: conciseness, correctness, and safety.</li>
<li><strong>Automatically generate state diagrams.</strong> Since the program&#39;s overall behavior is determined by declarations, <code>polystate</code> can automatically generate state diagrams. Users can intuitively understand the program&#39;s overall behavior through these diagrams.</li>
</ol>
<p dir="auto">I believe all of this represents a great step forward for imperative programming!</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">Detailed Explanation of Design Philosophy and Practical Effects</h2><a id="user-content-detailed-explanation-of-design-philosophy-and-practical-effects" aria-label="Permalink: Detailed Explanation of Design Philosophy and Practical Effects" href="#detailed-explanation-of-design-philosophy-and-practical-effects"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Let&#39;s start with a concrete example of a simple state machine. I will explain the core design philosophy of this library in detail through comments in the code.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const std = @import(&#34;std&#34;);
const polystate = @import(&#34;polystate&#34;);

pub fn main() !void {
    var st: GST = .{};
    /// Determine an initial state
    const wa = Example.Wit(Example.a){};
    /// Start executing the state machine with the message handler of this initial state
    /// The reason for using handler_normal here is related to tail-call optimization, which I will explain in detail later.
    wa.handler_normal(&amp;st);
}

pub const GST = struct {
    counter_a: i64 = 0,
    counter_b: i64 = 0,
};

/// `polystate` has two core state types: FST (FSM Type) and GST (Global State Type).
/// FST must be an enum type. In this example, the FST is `Example`, which defines all the states of our state machine. In other words, it defines the set of states we will track at the type level.
/// GST is the global data. In this example, the GST is defined above with two fields, `counter_a` and `counter_b`, representing the data needed for state `a` and state `b`, respectively.
/// When we compose states, what we really want is to compose state handler functions, which implies a requirement for global data.
/// Therefore, the first programming convention is: the handler function for any state has access to the GST (i.e., global data), but users should try to use only the data corresponding to the current state.
/// For example, in the handler function for state `a`, you should try to use only the data `counter_a`.
/// This can be easily achieved through some naming conventions, and it&#39;s easy to create corresponding generic functions through metaprogramming, but the specific implementation is outside the scope of `polystate`.
const Example = enum {
    /// Three concrete states are defined here
    exit,
    a,
    b,

    /// `Wit` is a core concept in `polystate`, short for Witness. The term comes from [Haskell](https://serokell.io/blog/haskell-type-level-witness), where it&#39;s called a &#39;type witness&#39; or &#39;runtime evidence&#39;.
    /// The core concepts of a finite state machine include four parts: state, message, message handler function, and message generator function. I will detail these parts in the example below.
    /// The purpose of the `Wit` function is to specify the state information contained in a message.
    pub fn Wit(val: anytype) type {
        return polystate.Witness(@This(), GST, null, polystate.val_to_sdzx(@This(), val));
    }

    /// This is the second programming convention: The FST needs a public declaration that contains the specific content of the state. By adding `ST` after the state name, we implicitly associate the state with its specific content.
    /// In this example, this corresponds to the public declarations below:
    /// exit ~ exitST
    /// a    ~ aST
    /// b    ~ bST
    /// Here, `exitST` describes the four parts for the `exit` state: state, message, message handler function, and message generator function.
    /// Since the `exit` state has no messages, it also has no message generator function.
    /// This is the third programming convention: The implementation of a state&#39;s specific content must contain a function: `pub fn handler(*GST) void` or `pub fn conthandler(*GST) ContR`.
    /// They represent the message handler function. The former means the state machine has full control of the control flow. The latter means a continuation function is returned, leaving the external caller to invoke the continuation function and take control of the flow.
    pub const exitST = union(enum) {
        pub fn handler(ist: *GST) void {
            std.debug.print(&#34;exit\n&#34;, .{});
            std.debug.print(&#34;st: {any}\n&#34;, .{ist.*});
        }
    };
    pub const aST = a_st;
    pub const bST = b_st;
};

/// This describes the four parts for state `a`: state, message, message handler function, and message generator function.
/// 1. State
/// The state here is `a`.
pub const a_st = union(enum) {
    /// 2. Message
    /// A tagged union is used here to describe the messages, and `Wit` is used to describe the state we are about to transition to.
    AddOneThenToB: Example.Wit(Example.b),
    Exit: Example.Wit(Example.exit),

    /// 3. Message Handler Function
    /// Handles all messages generated by `genMsg`.
    pub fn handler(ist: *GST) void {
        switch (genMsg(ist)) {
            .AddOneThenToB =&gt; |wit| {
                ist.counter_a += 1;
                /// This is the fourth programming convention: At the end of the message handling block, you must call `wit.handler(ist)` or similar code.
                /// This indicates that the message handler function of the new state will be executed. The new state is controlled by the `Wit` function of the message.
                wit.handler(ist);
            },
            .Exit =&gt; |wit| wit.handler(ist),
        }
    }

    /// 4. Message Generator Function
    /// If the value of `counter_a` is greater than 3, return `.Exit`.
    /// Otherwise, return `.AddOneThenToB`.
    /// The messages generated and handled here are defined in part 2 above.
    fn genMsg(ist: *GST) @This() {
        if (ist.counter_a &gt; 3) return .Exit;
        return .AddOneThenToB;
    }
};

pub const b_st = union(enum) {
    AddOneThenToA: Example.Wit(Example.a),

    pub fn handler(ist: *GST) void {
        switch (genMsg()) {
            .AddOneThenToA =&gt; |wit| {
                ist.counter_b += 1;
                wit.handler(ist);
            },
        }
    }

    fn genMsg() @This() {
        return .AddOneThenToA;
    }
};
"><pre><span>const</span> <span>std</span> <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
<span>const</span> <span>polystate</span> <span>=</span> <span>@import</span>(<span>&#34;polystate&#34;</span>);

<span>pub</span> <span>fn</span> <span>main</span>() <span>!</span><span>void</span> {
    <span>var</span> <span>st</span>: <span>GST</span> <span>=</span> .{};
    <span>/// Determine an initial state</span>
    <span>const</span> <span>wa</span> <span>=</span> <span>Example</span>.<span>Wit</span>(<span>Example</span>.<span>a</span>){};
    <span>/// Start executing the state machine with the message handler of this initial state</span>
    <span>/// The reason for using handler_normal here is related to tail-call optimization, which I will explain in detail later.</span>
    <span>wa</span>.<span>handler_normal</span>(<span>&amp;</span><span>st</span>);
}

<span>pub</span> <span>const</span> <span>GST</span> <span>=</span> <span>struct</span> {
    <span>counter_a</span>: <span>i64</span> <span>=</span> <span>0</span>,
    <span>counter_b</span>: <span>i64</span> <span>=</span> <span>0</span>,
};

<span>/// `polystate` has two core state types: FST (FSM Type) and GST (Global State Type).</span>
<span>/// FST must be an enum type. In this example, the FST is `Example`, which defines all the states of our state machine. In other words, it defines the set of states we will track at the type level.</span>
<span>/// GST is the global data. In this example, the GST is defined above with two fields, `counter_a` and `counter_b`, representing the data needed for state `a` and state `b`, respectively.</span>
<span>/// When we compose states, what we really want is to compose state handler functions, which implies a requirement for global data.</span>
<span>/// Therefore, the first programming convention is: the handler function for any state has access to the GST (i.e., global data), but users should try to use only the data corresponding to the current state.</span>
<span>/// For example, in the handler function for state `a`, you should try to use only the data `counter_a`.</span>
<span>/// This can be easily achieved through some naming conventions, and it&#39;s easy to create corresponding generic functions through metaprogramming, but the specific implementation is outside the scope of `polystate`.</span>
<span>const</span> <span>Example</span> <span>=</span> <span>enum</span> {
    <span>/// Three concrete states are defined here</span>
    <span>exit</span>,
    <span>a</span>,
    <span>b</span>,

    <span>/// `Wit` is a core concept in `polystate`, short for Witness. The term comes from [Haskell](https://serokell.io/blog/haskell-type-level-witness), where it&#39;s called a &#39;type witness&#39; or &#39;runtime evidence&#39;.</span>
    <span>/// The core concepts of a finite state machine include four parts: state, message, message handler function, and message generator function. I will detail these parts in the example below.</span>
    <span>/// The purpose of the `Wit` function is to specify the state information contained in a message.</span>
    <span>pub</span> <span>fn</span> <span>Wit</span>(<span>val</span>: <span>anytype</span>) <span>type</span> {
        <span>return</span> <span>polystate</span>.<span>Witness</span>(<span>@This</span>(), <span>GST</span>, <span>null</span>, <span>polystate</span>.<span>val_to_sdzx</span>(<span>@This</span>(), <span>val</span>));
    }

    <span>/// This is the second programming convention: The FST needs a public declaration that contains the specific content of the state. By adding `ST` after the state name, we implicitly associate the state with its specific content.</span>
    <span>/// In this example, this corresponds to the public declarations below:</span>
    <span>/// exit ~ exitST</span>
    <span>/// a    ~ aST</span>
    <span>/// b    ~ bST</span>
    <span>/// Here, `exitST` describes the four parts for the `exit` state: state, message, message handler function, and message generator function.</span>
    <span>/// Since the `exit` state has no messages, it also has no message generator function.</span>
    <span>/// This is the third programming convention: The implementation of a state&#39;s specific content must contain a function: `pub fn handler(*GST) void` or `pub fn conthandler(*GST) ContR`.</span>
    <span>/// They represent the message handler function. The former means the state machine has full control of the control flow. The latter means a continuation function is returned, leaving the external caller to invoke the continuation function and take control of the flow.</span>
    <span>pub</span> <span>const</span> <span>exitST</span> <span>=</span> <span>union</span>(<span>enum</span>) {
        <span>pub</span> <span>fn</span> <span>handler</span>(<span>ist</span>: <span>*</span><span>GST</span>) <span>void</span> {
            <span>std</span>.<span>debug</span>.<span>print</span>(<span>&#34;exit<span>\n</span>&#34;</span>, .{});
            <span>std</span>.<span>debug</span>.<span>print</span>(<span>&#34;st: {any}<span>\n</span>&#34;</span>, .{<span>ist</span><span>.*</span>});
        }
    };
    <span>pub</span> <span>const</span> <span>aST</span> <span>=</span> <span>a_st</span>;
    <span>pub</span> <span>const</span> <span>bST</span> <span>=</span> <span>b_st</span>;
};

<span>/// This describes the four parts for state `a`: state, message, message handler function, and message generator function.</span>
<span>/// 1. State</span>
<span>/// The state here is `a`.</span>
<span>pub</span> <span>const</span> <span>a_st</span> <span>=</span> <span>union</span>(<span>enum</span>) {
    <span>/// 2. Message</span>
    <span>/// A tagged union is used here to describe the messages, and `Wit` is used to describe the state we are about to transition to.</span>
    <span>AddOneThenToB</span>: <span>Example</span>.<span>Wit</span>(<span>Example</span>.<span>b</span>),
    <span>Exit</span>: <span>Example</span>.<span>Wit</span>(<span>Example</span>.<span>exit</span>),

    <span>/// 3. Message Handler Function</span>
    <span>/// Handles all messages generated by `genMsg`.</span>
    <span>pub</span> <span>fn</span> <span>handler</span>(<span>ist</span>: <span>*</span><span>GST</span>) <span>void</span> {
        <span>switch</span> (<span>genMsg</span>(<span>ist</span>)) {
            <span>.AddOneThenToB</span> <span>=</span><span>&gt;</span> <span>|</span><span>wit</span><span>|</span> {
                <span>ist</span>.<span>counter_a</span> <span>+=</span> <span>1</span>;
                <span>/// This is the fourth programming convention: At the end of the message handling block, you must call `wit.handler(ist)` or similar code.</span>
                <span>/// This indicates that the message handler function of the new state will be executed. The new state is controlled by the `Wit` function of the message.</span>
                <span>wit</span>.<span>handler</span>(<span>ist</span>);
            },
            <span>.Exit</span> <span>=</span><span>&gt;</span> <span>|</span><span>wit</span><span>|</span> <span>wit</span>.<span>handler</span>(<span>ist</span>),
        }
    }

    <span>/// 4. Message Generator Function</span>
    <span>/// If the value of `counter_a` is greater than 3, return `.Exit`.</span>
    <span>/// Otherwise, return `.AddOneThenToB`.</span>
    <span>/// The messages generated and handled here are defined in part 2 above.</span>
    <span>fn</span> <span>genMsg</span>(<span>ist</span>: <span>*</span><span>GST</span>) <span>@This</span>() {
        <span>if</span> (<span>ist</span>.<span>counter_a</span> <span>&gt;</span> <span>3</span>) <span>return</span> <span>.Exit</span>;
        <span>return</span> <span>.AddOneThenToB</span>;
    }
};

<span>pub</span> <span>const</span> <span>b_st</span> <span>=</span> <span>union</span>(<span>enum</span>) {
    <span>AddOneThenToA</span>: <span>Example</span>.<span>Wit</span>(<span>Example</span>.<span>a</span>),

    <span>pub</span> <span>fn</span> <span>handler</span>(<span>ist</span>: <span>*</span><span>GST</span>) <span>void</span> {
        <span>switch</span> (<span>genMsg</span>()) {
            <span>.AddOneThenToA</span> <span>=</span><span>&gt;</span> <span>|</span><span>wit</span><span>|</span> {
                <span>ist</span>.<span>counter_b</span> <span>+=</span> <span>1</span>;
                <span>wit</span>.<span>handler</span>(<span>ist</span>);
            },
        }
    }

    <span>fn</span> <span>genMsg</span>() <span>@This</span>() {
        <span>return</span> <span>.AddOneThenToA</span>;
    }
};
</pre></div>
<p dir="auto">The above is a simple example showing how to build a simple state machine with <code>polystate</code>.
This example does not demonstrate <code>polystate</code>&#39;s most powerful feature: <strong>composability</strong>.</p>

<p dir="auto">Let me modify the above example by adding a new state, <code>yes_or_no</code>, to demonstrate composability.
I will omit some of the code that is identical to the above. The complete code for this example can be found <a href="https://github.com/sdzx-1/polystate-examples/blob/main/src/exe-counter.zig">here</a>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const std = @import(&#34;std&#34;);
const polystate = @import(&#34;polystate&#34;);

pub fn main() !void {
   ...
}

pub const GST = struct {
  ...
  buf: [10] u8 = @splat(0),
};

///Example
const Example = enum {
    exit,
    a,
    b,
    /// A new state `yes_or_no` is defined here
    yes_or_no,



    pub fn Wit(val: anytype) type {
        ...
    }

    pub const exitST = union(enum) {
      ...
    };
    pub const aST = a_st;
    pub const bST = b_st;
    
    /// The specific implementation of the new state is a function that depends on two state parameters: `yes` and `no`.
    /// Its semantic is to provide an interactive choice for the user: if the user chooses &#39;yes&#39;, it transitions to the state corresponding to `yes`; if the user chooses &#39;no&#39;, it transitions to the state corresponding to `no`.
    /// The `sdzx` function here turns a regular enum type into a new, composable type.
    /// For example, I can use `polystate.sdzx(Example).C(.yes_or_no, &amp;.{ .a, .b })` to represent the state `(yes_or_no, a, b)`.
    /// I usually write this type as `yes_or_no(a, b)`, which indicates that `yes_or_no` is a special state that requires two concrete state parameters.
    /// Semantically, `yes_or_no(exit, a)` means: user confirmation is required before exiting. If the user chooses &#39;yes&#39;, it will transition to the `exit` state; if the user chooses &#39;no&#39;, it will transition to the `a` state.
    /// Similarly, `yes_or_no(yes_or_no(exit, a), a)` means: user confirmation is required twice before exiting. The user must choose &#39;yes&#39; both times to exit.
    /// This is what composability means. Please make sure you understand this.
    pub fn yes_or_noST(yes: polystate.sdzx(@This()), no: polystate.sdzx(@This())) type {
        return yes_or_no_st(@This(), yes, no, GST);
    }
};

pub const a_st = union(enum) {
    AddOneThenToB: Example.Wit(Example.b),
    /// This shows how to build and use a composite message in code.
    /// For a composite message, it needs to be placed in a tuple. The first state is the function, and the rest are its state parameters.
    /// Here, `.{ Example.yes_or_no, Example.exit, Example.a }` represents the state: `yes_or_no(exit, a)`.
    Exit: Example.Wit(.{ Example.yes_or_no, Example.exit, Example.a }),
    /// Similarly, `.{ Example.yes_or_no, .{Example.yes_or_no, Example.exit, Example.a}, Example.a }` can be used to represent the state: `yes_or_no(yes_or_no(exit, a), a)`.
    ...
};

pub const b_st = union(enum) {
  ...
};

/// Specific implementation of the `yes_or_no` state.
/// First, it&#39;s a function that takes four parameters: `FST`, `GST1`, `yes`, and `no`. Note that its implementation is independent of `Example` itself.
/// This is a generic implementation, independent of any specific state machine. You can use this code in any state machine.
/// I will explain this code again from four aspects: state, message, message handler function, and message generator function.
pub fn yes_or_no_st(
    FST: type,
    GST1: type,
    yes: polystate.sdzx(FST),
    no: polystate.sdzx(FST),
) type {
    /// 1. State
    /// Its specific state is: `polystate.sdzx(FST).C(FST.yes_or_no, &amp;.{ yes, no })`.
    /// It requires two parameters, `yes` and `no`, and also needs to ensure that `FST` definitely has a `yes_or_no` state.
    return union(enum) {
        /// 2. Message
        /// There are three messages here. Special attention should be paid to `Retry`, which represents the semantic of re-entering due to an input error.
        Yes: Wit(yes),
        No: Wit(no),
        /// Note the state being constructed here; it points to itself.
        Retry: Wit(polystate.sdzx(FST).C(FST.yes_or_no, &amp;.{ yes, no })),

        fn Wit(val: polystate.sdzx(FST)) type {
            return polystate.Witness(FST, GST1, null, val);
        }

        /// 3. Message Handler Function
        pub fn handler(gst: *GST1) void {
            switch (genMsg(gst)) {
                .Yes =&gt; |wit| wit.handler(gst),
                .No =&gt; |wit| wit.handler(gst),
                .Retry =&gt; |wit| wit.handler(gst),
            }
        }

        const stdIn = std.io.getStdIn().reader();
        
        /// 4. Message Generator Function
        /// Reads a string from `stdIn`. If the string is &#34;y&#34;, it returns the message `.Yes`. If the string is &#34;n&#34;, it returns the message `.No`.
        /// In other cases, it returns `.Retry`.
        fn genMsg(gst: *GST) @This() {
            std.debug.print(
                \\Yes Or No:
                \\y={}, n={}
                \\
            ,
                .{ yes, no },
            );

            const st = stdIn.readUntilDelimiter(&amp;gst.buf, &#39;\n&#39;) catch |err| {
                std.debug.print(&#34;Input error: {any}, retry\n&#34;, .{err});
                return .Retry;
            };

            if (std.mem.eql(u8, st, &#34;y&#34;)) {
                return .Yes;
            } else if (std.mem.eql(u8, st, &#34;n&#34;)) {
                return .No;
            } else {
                std.debug.print(&#34;Error input: {s}\n&#34;, .{st});
                return .Retry;
            }
        }
    };
}"><pre><span>const</span> <span>std</span> <span>=</span> <span>@import</span>(<span>&#34;std&#34;</span>);
<span>const</span> <span>polystate</span> <span>=</span> <span>@import</span>(<span>&#34;polystate&#34;</span>);

<span>pub</span> <span>fn</span> <span>main</span>() <span>!</span><span>void</span> {
   <span>...</span>
}

<span>pub</span> <span>const</span> <span>GST</span> <span>=</span> <span>struct</span> {
  <span>...</span>
  <span>buf</span>: [<span>10</span>] <span>u8</span> <span>=</span> <span>@splat</span>(<span>0</span>),
};

<span>///Example</span>
<span>const</span> <span>Example</span> <span>=</span> <span>enum</span> {
    <span>exit</span>,
    <span>a</span>,
    <span>b</span>,
    <span>/// A new state `yes_or_no` is defined here</span>
    <span>yes_or_no</span>,



    <span>pub</span> <span>fn</span> <span>Wit</span>(<span>val</span>: <span>anytype</span>) <span>type</span> {
        <span>...</span>
    }

    <span>pub</span> <span>const</span> <span>exitST</span> <span>=</span> <span>union</span>(<span>enum</span>) {
      <span>...</span>
    };
    <span>pub</span> <span>const</span> <span>aST</span> <span>=</span> <span>a_st</span>;
    <span>pub</span> <span>const</span> <span>bST</span> <span>=</span> <span>b_st</span>;
    
    <span>/// The specific implementation of the new state is a function that depends on two state parameters: `yes` and `no`.</span>
    <span>/// Its semantic is to provide an interactive choice for the user: if the user chooses &#39;yes&#39;, it transitions to the state corresponding to `yes`; if the user chooses &#39;no&#39;, it transitions to the state corresponding to `no`.</span>
    <span>/// The `sdzx` function here turns a regular enum type into a new, composable type.</span>
    <span>/// For example, I can use `polystate.sdzx(Example).C(.yes_or_no, &amp;.{ .a, .b })` to represent the state `(yes_or_no, a, b)`.</span>
    <span>/// I usually write this type as `yes_or_no(a, b)`, which indicates that `yes_or_no` is a special state that requires two concrete state parameters.</span>
    <span>/// Semantically, `yes_or_no(exit, a)` means: user confirmation is required before exiting. If the user chooses &#39;yes&#39;, it will transition to the `exit` state; if the user chooses &#39;no&#39;, it will transition to the `a` state.</span>
    <span>/// Similarly, `yes_or_no(yes_or_no(exit, a), a)` means: user confirmation is required twice before exiting. The user must choose &#39;yes&#39; both times to exit.</span>
    <span>/// This is what composability means. Please make sure you understand this.</span>
    <span>pub</span> <span>fn</span> <span>yes_or_noST</span>(<span>yes</span>: <span>polystate</span>.<span>sdzx</span>(<span>@This</span>()), <span>no</span>: <span>polystate</span>.<span>sdzx</span>(<span>@This</span>())) <span>type</span> {
        <span>return</span> <span>yes_or_no_st</span>(<span>@This</span>(), <span>yes</span>, <span>no</span>, <span>GST</span>);
    }
};

<span>pub</span> <span>const</span> <span>a_st</span> <span>=</span> <span>union</span>(<span>enum</span>) {
    <span>AddOneThenToB</span>: <span>Example</span>.<span>Wit</span>(<span>Example</span>.<span>b</span>),
    <span>/// This shows how to build and use a composite message in code.</span>
    <span>/// For a composite message, it needs to be placed in a tuple. The first state is the function, and the rest are its state parameters.</span>
    <span>/// Here, `.{ Example.yes_or_no, Example.exit, Example.a }` represents the state: `yes_or_no(exit, a)`.</span>
    <span>Exit</span>: <span>Example</span>.<span>Wit</span>(.{ <span>Example</span>.<span>yes_or_no</span>, <span>Example</span>.<span>exit</span>, <span>Example</span>.<span>a</span> }),
    <span>/// Similarly, `.{ Example.yes_or_no, .{Example.yes_or_no, Example.exit, Example.a}, Example.a }` can be used to represent the state: `yes_or_no(yes_or_no(exit, a), a)`.</span>
    <span>...</span>
};

<span>pub</span> <span>const</span> <span>b_st</span> <span>=</span> <span>union</span>(<span>enum</span>) {
  <span>...</span>
};

<span>/// Specific implementation of the `yes_or_no` state.</span>
<span>/// First, it&#39;s a function that takes four parameters: `FST`, `GST1`, `yes`, and `no`. Note that its implementation is independent of `Example` itself.</span>
<span>/// This is a generic implementation, independent of any specific state machine. You can use this code in any state machine.</span>
<span>/// I will explain this code again from four aspects: state, message, message handler function, and message generator function.</span>
<span>pub</span> <span>fn</span> <span>yes_or_no_st</span>(
    <span>FST</span>: <span>type</span>,
    <span>GST1</span>: <span>type</span>,
    <span>yes</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
    <span>no</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
) <span>type</span> {
    <span>/// 1. State</span>
    <span>/// Its specific state is: `polystate.sdzx(FST).C(FST.yes_or_no, &amp;.{ yes, no })`.</span>
    <span>/// It requires two parameters, `yes` and `no`, and also needs to ensure that `FST` definitely has a `yes_or_no` state.</span>
    <span>return</span> <span>union</span>(<span>enum</span>) {
        <span>/// 2. Message</span>
        <span>/// There are three messages here. Special attention should be paid to `Retry`, which represents the semantic of re-entering due to an input error.</span>
        <span>Yes</span>: <span>Wit</span>(<span>yes</span>),
        <span>No</span>: <span>Wit</span>(<span>no</span>),
        <span>/// Note the state being constructed here; it points to itself.</span>
        <span>Retry</span>: <span>Wit</span>(<span>polystate</span>.<span>sdzx</span>(<span>FST</span>).<span>C</span>(<span>FST.yes_or_no</span>, &amp;.{ <span>yes</span>, <span>no</span> })),

        <span>fn</span> <span>Wit</span>(<span>val</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>)) <span>type</span> {
            <span>return</span> <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST1</span>, <span>null</span>, <span>val</span>);
        }

        <span>/// 3. Message Handler Function</span>
        <span>pub</span> <span>fn</span> <span>handler</span>(<span>gst</span>: <span>*</span><span>GST1</span>) <span>void</span> {
            <span>switch</span> (<span>genMsg</span>(<span>gst</span>)) {
                <span>.Yes</span> <span>=</span><span>&gt;</span> <span>|</span><span>wit</span><span>|</span> <span>wit</span>.<span>handler</span>(<span>gst</span>),
                <span>.No</span> <span>=</span><span>&gt;</span> <span>|</span><span>wit</span><span>|</span> <span>wit</span>.<span>handler</span>(<span>gst</span>),
                <span>.Retry</span> <span>=</span><span>&gt;</span> <span>|</span><span>wit</span><span>|</span> <span>wit</span>.<span>handler</span>(<span>gst</span>),
            }
        }

        <span>const</span> <span>stdIn</span> <span>=</span> <span>std</span>.<span>io</span>.<span>getStdIn</span>().<span>reader</span>();
        
        <span>/// 4. Message Generator Function</span>
        <span>/// Reads a string from `stdIn`. If the string is &#34;y&#34;, it returns the message `.Yes`. If the string is &#34;n&#34;, it returns the message `.No`.</span>
        <span>/// In other cases, it returns `.Retry`.</span>
        <span>fn</span> <span>genMsg</span>(<span>gst</span>: <span>*</span><span>GST</span>) <span>@This</span>() {
            <span>std</span>.<span>debug</span>.<span>print</span>(
                <span>\\Yes Or No:</span>
                <span>\\y={}, n={}</span>
                <span>\\</span>
            ,
                .{ <span>yes</span>, <span>no</span> },
            );

            <span>const</span> <span>st</span> <span>=</span> <span>stdIn</span>.<span>readUntilDelimiter</span>(<span>&amp;</span><span>gst</span>.<span>buf</span>, <span>&#39;<span>\n</span>&#39;</span>) <span>catch</span> <span>|</span><span>err</span><span>|</span> {
                <span>std</span>.<span>debug</span>.<span>print</span>(<span>&#34;Input error: {any}, retry<span>\n</span>&#34;</span>, .{<span>err</span>});
                <span>return</span> <span>.Retry</span>;
            };

            <span>if</span> (<span>std</span>.<span>mem</span>.<span>eql</span>(<span>u8</span>, <span>st</span>, <span>&#34;y&#34;</span>)) {
                <span>return</span> <span>.Yes</span>;
            } <span>else</span> <span>if</span> (<span>std</span>.<span>mem</span>.<span>eql</span>(<span>u8</span>, <span>st</span>, <span>&#34;n&#34;</span>)) {
                <span>return</span> <span>.No</span>;
            } <span>else</span> {
                <span>std</span>.<span>debug</span>.<span>print</span>(<span>&#34;Error input: {s}<span>\n</span>&#34;</span>, .{<span>st</span>});
                <span>return</span> <span>.Retry</span>;
            }
        }
    };
}</pre></div>
<p dir="auto">This example clearly demonstrates how to achieve a composable state machine through type composition.</p>


<p dir="auto">Imagine an ATM. When we are in the <code>checkPin</code> state, the user is required to enter a PIN from an external source. If the PIN is correct, it sends a <code>Successed</code> message and transitions to the state specified by the <code>success</code> parameter. If it&#39;s incorrect, it sends a <code>Failed</code> message and transitions to the state specified by the <code>failed</code> parameter.</p>
<p dir="auto">A common requirement is: the user can try to enter the PIN a maximum of three times. If all three attempts fail, the card should be ejected, and the machine should return to the initial screen.</p>
<p dir="auto">&#34;A maximum of three times&#34; here is an extremely important security requirement that should not be easily changed.</p>
<p dir="auto">By composing states, we can naturally implement this effect. We design <code>checkPin</code> as a generic state, and then in the declaration of state transitions, we precisely describe this business logic by composing <code>checkPin</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="  pub fn checkPinST(success: polystate.sdzx(Atm), failed: polystate.sdzx(Atm)) type {
        return union(enum) {
            Successed: polystate.Witness(Atm, GST, null, success),
            Failed: polystate.Witness(Atm, GST, null, failed),

            ...
            ...
        }
  }

    pub const readyST = union(enum) {
        /// By nesting the declaration of `checkPin` three times, we ensure that the PIN check happens at most three times. This precisely describes the behavior we need.
        /// This demonstrates how to determine the program&#39;s overall behavior through compositional declarations.
        InsertCard: Wit(.{ Atm.checkPin, Atm.session, .{ Atm.checkPin, Atm.session, .{ Atm.checkPin, Atm.session, Atm.ready } } }),
        Exit: Wit(.{ Atm.are_you_sure, Atm.exit, Atm.ready }),

        ...
    }
"><pre>  <span>pub</span> <span>fn</span> <span>checkPinST</span>(<span>success</span>: <span>polystate</span>.<span>sdzx</span>(<span>Atm</span>), <span>failed</span>: <span>polystate</span>.<span>sdzx</span>(<span>Atm</span>)) <span>type</span> {
        <span>return</span> <span>union</span>(<span>enum</span>) {
            <span>Successed</span>: <span>polystate</span>.<span>Witness</span>(<span>Atm</span>, <span>GST</span>, <span>null</span>, <span>success</span>),
            <span>Failed</span>: <span>polystate</span>.<span>Witness</span>(<span>Atm</span>, <span>GST</span>, <span>null</span>, <span>failed</span>),

            <span>...</span>
            <span>...</span>
        }
  }

    <span>pub</span> <span>const</span> <span>readyST</span> <span>=</span> <span>union</span>(<span>enum</span>) {
        <span>/// By nesting the declaration of `checkPin` three times, we ensure that the PIN check happens at most three times. This precisely describes the behavior we need.</span>
        <span>/// This demonstrates how to determine the program&#39;s overall behavior through compositional declarations.</span>
        <span>InsertCard</span>: <span>Wit</span>(.{ <span>Atm</span>.<span>checkPin</span>, <span>Atm</span>.<span>session</span>, .{ <span>Atm</span>.<span>checkPin</span>, <span>Atm</span>.<span>session</span>, .{ <span>Atm</span>.<span>checkPin</span>, <span>Atm</span>.<span>session</span>, <span>Atm</span>.<span>ready</span> } } }),
        <span>Exit</span>: <span>Wit</span>(.{ <span>Atm</span>.<span>are_you_sure</span>, <span>Atm</span>.<span>exit</span>, <span>Atm</span>.<span>ready</span> }),

        <span>...</span>
    }
</pre></div>
<p dir="auto">We can directly see its overall logic through the state diagram, and <a href="https://github.com/sdzx-1/polystate-examples/blob/fecaffb5b7f5eba09c9428c18f1cd97e7ee09e71/src/exe-atm.zig#L19"><code>polystate</code> can automatically generate all of this</a>.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/sdzx-1/polystate-examples/raw/main/data/atm_graph.svg"><img src="https://github.com/sdzx-1/polystate-examples/raw/main/data/atm_graph.svg" alt="atm-graph"/></a></p>

<p dir="auto">I used <code>raylib</code> to implement a generic &#34;selection&#34; semantic: interactive selection via the mouse.</p>
<p dir="auto">The specific behavior of selection is composed of three generic states (<code>select</code>, <code>inside</code>, <code>hover</code>) and their associated messages.</p>
<p dir="auto">These states and messages implement: selecting an element with the mouse and how to respond when the mouse hovers over it.</p>
<div dir="auto" data-snippet-clipboard-copy-content="
pub fn selectST(
    FST: type,
    GST: type,
    enter_fn: ?fn (polystate.sdzx(FST), *GST) void,
    back: polystate.sdzx(FST),
    selected: polystate.sdzx(FST),
) type {
    const cst = polystate.sdzx_to_cst(FST, selected);
    const SDZX = polystate.sdzx(FST);

    return union(enum) {
        // zig fmt: off
        ToBack  : polystate.Witness(FST, GST, enter_fn, back),
        ToInside: polystate.Witness(FST, GST, enter_fn, SDZX.C(FST.inside, &amp;.{ back, selected })),
        // zig fmt: on
       ...
    };
}

pub fn insideST(
    FST: type,
    GST: type,
    enter_fn: ?fn (polystate.sdzx(FST), *GST) void,
    back: polystate.sdzx(FST),
    selected: polystate.sdzx(FST),
) type {
    const cst = polystate.sdzx_to_cst(FST, selected);
    const SDZX = polystate.sdzx(FST);

    return union(enum) {
        // zig fmt: off
        ToBack    : polystate.Witness(FST, GST, enter_fn, back),
        ToOutside : polystate.Witness(FST, GST, enter_fn, SDZX.C(FST.select, &amp;.{ back, selected })),
        ToHover   : polystate.Witness(FST, GST, enter_fn, SDZX.C(FST.hover, &amp;.{ back, selected })),
        ToSelected: polystate.Witness(FST, GST, enter_fn, selected),
        // zig fmt: on
       ...
    };
}

pub fn hoverST(
    FST: type,
    GST: type,
    enter_fn: ?fn (polystate.sdzx(FST), *GST) void,
    back: polystate.sdzx(FST),
    selected: polystate.sdzx(FST),
) type {
    const cst = polystate.sdzx_to_cst(FST, selected);
    const SDZX = polystate.sdzx(FST);

    return union(enum) {
        // zig fmt: off
        ToBack    : polystate.Witness(FST, GST, enter_fn, back),
        ToOutside : polystate.Witness(FST, GST, enter_fn, SDZX.C(FST.select, &amp;.{ back, selected })),
        ToInside  : polystate.Witness(FST, GST, enter_fn, SDZX.C(FST.inside, &amp;.{ back, selected })),
        ToSelected: polystate.Witness(FST, GST, enter_fn, selected),
        // zig fmt: on

       ...
    };
}
"><pre><span>pub</span> <span>fn</span> <span>selectST</span>(
    <span>FST</span>: <span>type</span>,
    <span>GST</span>: <span>type</span>,
    <span>enter_fn</span>: <span>?</span><span>fn</span> (<span>polystate.sdzx</span>(<span>FST</span>), <span>*</span><span>GST</span>) <span>void</span>,
    <span>back</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
    <span>selected</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
) <span>type</span> {
    <span>const</span> <span>cst</span> <span>=</span> <span>polystate</span>.<span>sdzx_to_cst</span>(<span>FST</span>, <span>selected</span>);
    <span>const</span> <span>SDZX</span> <span>=</span> <span>polystate</span>.<span>sdzx</span>(<span>FST</span>);

    <span>return</span> <span>union</span>(<span>enum</span>) {
        <span>// zig fmt: off</span>
        <span>ToBack</span>  : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>back</span>),
        <span>ToInside</span>: <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>SDZX</span>.<span>C</span>(<span>FST</span>.<span>inside</span>, &amp;.{ <span>back</span>, <span>selected</span> })),
        <span>// zig fmt: on</span>
       <span>...</span>
    };
}

<span>pub</span> <span>fn</span> <span>insideST</span>(
    <span>FST</span>: <span>type</span>,
    <span>GST</span>: <span>type</span>,
    <span>enter_fn</span>: <span>?</span><span>fn</span> (<span>polystate.sdzx</span>(<span>FST</span>), <span>*</span><span>GST</span>) <span>void</span>,
    <span>back</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
    <span>selected</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
) <span>type</span> {
    <span>const</span> <span>cst</span> <span>=</span> <span>polystate</span>.<span>sdzx_to_cst</span>(<span>FST</span>, <span>selected</span>);
    <span>const</span> <span>SDZX</span> <span>=</span> <span>polystate</span>.<span>sdzx</span>(<span>FST</span>);

    <span>return</span> <span>union</span>(<span>enum</span>) {
        <span>// zig fmt: off</span>
        <span>ToBack</span>    : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>back</span>),
        <span>ToOutside</span> : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>SDZX</span>.<span>C</span>(<span>FST</span>.<span>select</span>, &amp;.{ <span>back</span>, <span>selected</span> })),
        <span>ToHover</span>   : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>SDZX</span>.<span>C</span>(<span>FST</span>.<span>hover</span>, &amp;.{ <span>back</span>, <span>selected</span> })),
        <span>ToSelected</span>: <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>selected</span>),
        <span>// zig fmt: on</span>
       <span>...</span>
    };
}

<span>pub</span> <span>fn</span> <span>hoverST</span>(
    <span>FST</span>: <span>type</span>,
    <span>GST</span>: <span>type</span>,
    <span>enter_fn</span>: <span>?</span><span>fn</span> (<span>polystate.sdzx</span>(<span>FST</span>), <span>*</span><span>GST</span>) <span>void</span>,
    <span>back</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
    <span>selected</span>: <span>polystate</span>.<span>sdzx</span>(<span>FST</span>),
) <span>type</span> {
    <span>const</span> <span>cst</span> <span>=</span> <span>polystate</span>.<span>sdzx_to_cst</span>(<span>FST</span>, <span>selected</span>);
    <span>const</span> <span>SDZX</span> <span>=</span> <span>polystate</span>.<span>sdzx</span>(<span>FST</span>);

    <span>return</span> <span>union</span>(<span>enum</span>) {
        <span>// zig fmt: off</span>
        <span>ToBack</span>    : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>back</span>),
        <span>ToOutside</span> : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>SDZX</span>.<span>C</span>(<span>FST</span>.<span>select</span>, &amp;.{ <span>back</span>, <span>selected</span> })),
        <span>ToInside</span>  : <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>SDZX</span>.<span>C</span>(<span>FST</span>.<span>inside</span>, &amp;.{ <span>back</span>, <span>selected</span> })),
        <span>ToSelected</span>: <span>polystate</span>.<span>Witness</span>(<span>FST</span>, <span>GST</span>, <span>enter_fn</span>, <span>selected</span>),
        <span>// zig fmt: on</span>

       <span>...</span>
    };
}
</pre></div>
<p dir="auto">In the <a href="https://github.com/sdzx-1/ray-game"><code>ray-game</code></a> project, the &#34;selection&#34; semantic was reused at least eight times, which greatly reduced code and improved correctness.</p>
<p dir="auto">An interesting example in this project is &#34;two-stage selection&#34;: you first need to select a building, then select a grid location to place it. The choice of building also constrains the choice of location. <a target="_blank" rel="noopener noreferrer" href="https://github.com/sdzx-1/polystate/blob/master/data/select_twice.gif"><img src="https://github.com/sdzx-1/polystate/raw/master/data/select_twice.gif" alt="select_twict" data-animated-image=""/></a></p>
<p dir="auto">Such semantics can be concisely expressed as:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pub const placeST = union(enum) {
    ToPlay: Wit(.{ Example.select, Example.play, .{ Example.select, Example.play, Example.place } }),
    ...
};
"><pre><span>pub</span> <span>const</span> <span>placeST</span> <span>=</span> <span>union</span>(<span>enum</span>) {
    <span>ToPlay</span>: <span>Wit</span>(.{ <span>Example</span>.<span>select</span>, <span>Example</span>.<span>play</span>, .{ <span>Example</span>.<span>select</span>, <span>Example</span>.<span>play</span>, <span>Example</span>.<span>place</span> } }),
    <span>...</span>
};
</pre></div>
<p dir="auto">This code describes our intent with extreme conciseness. But if you look at the state diagram, you will find that the actual state transitions it corresponds to are quite complex.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/sdzx-1/polystate/blob/master/data/graph.png"><img src="https://github.com/sdzx-1/polystate/raw/master/data/graph.png" alt="graph"/></a></p>
<p dir="auto">Through simple declarations, we have nestedly reused complex &#34;selection&#34; semantics. This is a huge victory!</p>
<p dir="auto"><a href="https://github.com/sdzx-1/ray-game/blob/587f1698cb717c393c3680060a057ac8b02d89c2/src/play.zig#L33">The complete code for all of this is right here</a>, in about 130 lines of code.</p>
</article></div></div>
  </body>
</html>
