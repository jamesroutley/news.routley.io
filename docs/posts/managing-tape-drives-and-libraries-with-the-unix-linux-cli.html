<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blogs.intellique.com/cgi-bin/tech/2022/01/27">Original</a>
    <h1>Managing tape drives and libraries with the Unix/Linux CLI</h1>
    
    <div id="readability-page-1" class="page"><div><hr/>

<p><strong>Summary</strong></p>

<pre><code>    1. tools
    2. identifying devices
    3. handling tape cartridges in a library
    4. handling tape in a drive
        Drive information
        Density code
        Reading from the cartridge&#39;s RFID tag
        mt commands
    5. Identifying an unknown tape
    6. Basic use of gnu tar
    7. Using LTFS
    Appendix: other useful commands
</code></pre>

<p><img src="http://blogs.intellique.com/images/LTO.jpg" alt="LTO" title="bande LTO"/></p>

<h2><strong>1. tools</strong></h2>

<p>Tools used in this article are: mt (from <em>mt-st</em> package), <em>mtx</em>, <em>tar</em> and <em>ltfs</em>. We’ll optionnally need <em>lsscsi</em>, <em>dd</em> and <em>sg3-utils</em>.</p>

<p><em>mt</em> is used to control the tape drive (tape movements, ejection, and drive settings). <em>mtx</em> is used to control tape libraries (moving cartridges from slots to drives, etc). We’ll use mostly <em>tar</em> to read and write, and <em>dd</em> to identify unknown tapes</p>

<p>During the initial configuration, we’ll use <em>lsscsi</em> to identify tape devices.</p>

<h2><strong>2.identifying devices</strong></h2>

<p>Let’s identify our devices using <em>lsscsi</em>.</p>

<pre>~# lsscsi
[6:0:0:0]    disk    AMCC     9650SE-16M DISK  3.08  /dev/sda
[7:0:0:0]    tape    HP       Ultrium 5-SCSI   Z21U  /dev/st0
[7:0:0:1]    mediumx TANDBERG StorageLoader    0346  /dev/sch0
</pre>

<p>Our tape drives appears as <em>/dev/st0</em>. Unfortunately, by default the device listed for the tape library is useless, we’ll have to resort to <em>lsscsi- g</em> to get the corresponding generic SCSI device:</p>

<pre>~# lsscsi -g
[6:0:0:0]    disk    AMCC     9650SE-16M DISK  3.08  /dev/sda  /dev/sg0
[7:0:0:0]    tape    HP       Ultrium 5-SCSI   Z21U  /dev/st0  /dev/sg1
[7:0:0:1]    mediumx TANDBERG StorageLoader    0346  /dev/sch0  /dev/sg2
</pre>

<p><em>mt</em> can use either <em>/dev/stXX</em> or <em>/dev/nstXX</em> devices. the difference is as follows: <em>/dev/stXX</em> rewind the tape before any operation. /<em>dev/nstXX</em> doesn’t move the tape. Therefore we’ll generally use <em>/dev/nstXX</em>.
<em>tar</em> (or in some cases <em>dd</em>) also uses the tape device <em>/dev/nstXX</em> (or <em>/dev/stXX</em>).
<em>mtx</em> on the other hand, works with the generic SCSI device <em>/dev/sgXX</em>. Know the difference.</p>

<h2><strong>3. handling tape cartridges in a library</strong></h2>

<p>First, let’s check what’s in our tape library:</p>

<pre>~# mtx -f /dev/sg2 status
  Storage Changer /dev/sg2:1 Drives, 8 Slots ( 0 Import/Export )
Data Transfer Element 0:Empty
      Storage Element 1:Full :VolumeTag=AAA013L4                        
      Storage Element 2:Empty
      Storage Element 3:Empty
      Storage Element 4:Empty
      Storage Element 5:Empty
      Storage Element 6:Empty
      Storage Element 7:Empty
      Storage Element 8:Empty
</pre>

<p>The “Data Transfer Element” lines represent tape drives (only one present in this example). “Storage Element” lines represent the cartridge slots. Depending upon your hardware, you may also have  “Input Output Element” lines, which are “mail slots” that allow moving tapes in and out the library without interrupting normal operations.</p>

<p>If the cartridges carry barcode labels and your library supports these, <em>mtx</em> also display that label value, as shown in the example above.</p>

<p>We can see that our “Data Transfer Element 0” is empty; let’s load it with a tape:</p>

<pre>~# mtx -f /dev/sg2 load 1 0
~#
</pre>

<p>As a proper Unix program, <em>mtx</em> is quiet if nothing’s wrong. Let’s check the status again; we’ll see that <em>mtx</em> remembers from which slot comes the tape now in our drive:</p>

<pre>~# mtx -f /dev/sg2 status
  Storage Changer /dev/sg2:1 Drives, 8 Slots ( 0 Import/Export )
Data Transfer Element 0:Full (Storage Element 1 Loaded):VolumeTag=AAA013L4
      Storage Element 1:Empty
      Storage Element 2:Empty
      Storage Element 3:Empty
      Storage Element 4:Empty
      Storage Element 5:Empty
      Storage Element 6:Empty
      Storage Element 7:Empty
      Storage Element 8:Empty
</pre>

<p>Using the command <em>mtx -f /dev/sg2 unload</em> without source nor destination will unload the tape from the first drive into its original location. Of course you could alternatively unload the tape to any empty slot instead.</p>

<pre>~# mtx -f /dev/sg2 unload 4 0 
Unloading Data Transfer Element into Storage Element 4...done
</pre>

<p>Notice that <em>mtx</em> emit a message in that case. So it’s not that conforming to the Unix way after all :)</p>

<p><strong>Nota Bene:</strong> with some libraries or drives (but generally not LTO drives), it may be necessary to first ask for the drive to eject the tape before asking for the library to move out the tape from the drive. So you may want to run <em>mt offline</em> with the appropriate options before any <em>mtx unload</em> command, just to be sure.</p>

<p>Last, <em>mtx</em> can also move tapes from slot to slot, which is particularly useful when using a IO slot (or mail slot):</p>

<pre>~# mtx -f /dev/sg2 transfer 4 2
</pre>

<h2><strong>4. handling tape in a drive</strong></h2>

<p><em>mt</em> can move the tape ( forward, rewinf, eject), erase, enable or disable compression, define the block size to use, etc.</p>

<p>First let’s check drive status:</p>

<pre> ~# mt -f /dev/nst0 status
drive type = Generic SCSI-2 tape
drive status = 1476395008
sense key error = 0
residue count = 0
file number = 0
block number = 0
Tape block size 0 bytes. Density code 0x58 (unknown).
Soft error count since last status=0
General status bits on (41010000):
 BOT ONLINE IM_REP_EN
</pre>

<p><strong>Drive informations</strong></p>

<p>Drive status is read line by line :</p>

<table>
<tbody><tr><th> statut </th><th> signification </th></tr>
<tr><td>drive type </td><td>    attachment type (normally always SCSI)</td></tr>
<tr><td>drive status </td><td>  some code I don’t know much about… </td></tr>
<tr><td>sense key error </td><td>   communication error status</td></tr>
<tr><td>residue count </td><td> ?</td></tr>
<tr><td>file number </td><td>   record number (file) on which the tape is currently positioned</td></tr>
<tr><td>block number </td><td>  block number on which the tape is currently positioned</td></tr>
<tr><td>Tape block size X bytes </td><td>   current hardware block size, it’s generally advised to let it at zero (soft block size)</td></tr>
<tr><td>Density code </td><td>  Tape type and density, see table below</td></tr>
<tr><td>Soft error count </td><td>  number of errors in the current session</td></tr>
</tbody></table>

<p><strong>Status Codes</strong></p>

<p>The two last lines of output display “status bits”, listed below:</p>

<table>
<tbody><tr><th> Status Bit </th><th>   Description </th></tr>
<tr><td>BOT </td><td>Beginning Of tape (Beginning of First File)</td></tr>
<tr><td>EOT </td><td>   End Of Tape (either physical End of Tape, or End of Data area)</td></tr>
<tr><td>EOF </td><td>   At the End Of some File</td></tr>
<tr><td>WR_PROT </td><td>   Write Protected. Either the drive or tape is in write-protected mode; or the current drive only supports this tape type in read-only mode.</td></tr>
<tr><td>ONLINE </td><td>    Drive loaded and ready to work.</td></tr>
<tr><td>DR_OPEN </td><td>   Drive Open. The drive is empty, or the tape has been ejected and hangs at the door (in that case, you can use *mt load* to load the tape).</td></tr>
<tr><td>IM_REP_EN </td><td> Immediate Response Mode. the drive buffers data and acknowledge read and write operations before data has hit the tape.</td></tr>
<tr><td>SM </td><td>    Tape is on a Marker (Set Mark). May work only on DDS drives(?)</td></tr>
<tr><td>EOD </td><td>   End Of Data. The tape is at the end of recorded area. Depending upon drives, may be the same thing as EOT</td></tr>
</tbody></table>

<p><strong>density codes</strong></p>

<p>Here is a list of density codes compiled along the years from various sources (Internet, our own drives, etc):</p>

<table>
<tbody><tr><th>code </th><th>  description</th></tr>
<tr><td>0x00 </td><td> default</td></tr>
<tr><td>0x01 </td><td> NRZI (800 bpi)</td></tr>
<tr><td>0x02 </td><td> PE (1600 bpi)</td></tr>
<tr><td>0x03 </td><td> GCR (6250 bpi)</td></tr>
<tr><td>0x04 </td><td> QIC-11</td></tr>
<tr><td>0x05 </td><td> QIC-45/60 (GCR, 8000 bpi)</td></tr>
<tr><td>0x06 </td><td> PE (3200 bpi)</td></tr>
<tr><td>0x07 </td><td> IMFM (6400 bpi)</td></tr>
<tr><td>0x08 </td><td> GCR (8000 bpi)</td></tr>
<tr><td>0x09 </td><td> GCR (37871 bpi)</td></tr>
<tr><td>0x0a </td><td> MFM (6667 bpi)</td></tr>
<tr><td>0x0b </td><td> PE (1600 bpi)</td></tr>
<tr><td>0x0c </td><td> GCR (12960 bpi)</td></tr>
<tr><td>0x0d </td><td> GCR (25380 bpi)</td></tr>
<tr><td>0x0f </td><td> QIC-120 (GCR 10000 bpi)</td></tr>
<tr><td>0x10 </td><td> QIC-150/250 (GCR 10000 bpi)</td></tr>
<tr><td>0x11 </td><td> QIC-320/525 (GCR 16000 bpi)</td></tr>
<tr><td>0x12 </td><td> QIC-1350 (RLL 51667 bpi)</td></tr>
<tr><td>0x13 </td><td> DDS (61000 bpi)</td></tr>
<tr><td>0x14 </td><td> EXB-8200 (RLL 43245 bpi)</td></tr>
<tr><td>0x15 </td><td> EXB-8500 or QIC-1000</td></tr>
<tr><td>0x16 </td><td> MFM 10000 bpi</td></tr>
<tr><td>0x17 </td><td> MFM 42500 bpi</td></tr>
<tr><td>0x18 </td><td> TZ86</td></tr>
<tr><td>0x19 </td><td> DLT 10GB</td></tr>
<tr><td>0x1a </td><td> DLT 20GB</td></tr>
<tr><td>0x1b </td><td> DLT 35GB</td></tr>
<tr><td>0x1c </td><td> QIC-385M</td></tr>
<tr><td>0x1d </td><td> QIC-410M</td></tr>
<tr><td>0x1e </td><td> QIC-1000C</td></tr>
<tr><td>0x1f </td><td> QIC-2100C</td></tr>
<tr><td>0x20 </td><td> QIC-6GB</td></tr>
<tr><td>0x21 </td><td> QIC-20GB</td></tr>
<tr><td>0x22 </td><td> QIC-2GB</td></tr>
<tr><td>0x23 </td><td> QIC-875</td></tr>
<tr><td>0x24 </td><td> DDS-2</td></tr>
<tr><td>0x25 </td><td> DDS-3</td></tr>
<tr><td>0x26 </td><td> DDS-4 or QIC-4GB</td></tr>
<tr><td>0x27 </td><td> Exabyte Mammoth</td></tr>
<tr><td>0x28 </td><td> Exabyte Mammoth-2</td></tr>
<tr><td>0x29 </td><td> QIC-3080MC</td></tr>
<tr><td>0x30 </td><td> AIT-1 or MLR3</td></tr>
<tr><td>0x31 </td><td> AIT-2</td></tr>
<tr><td>0x32 </td><td> AIT-3 / SLR7</td></tr>
<tr><td>0x33 </td><td> SLR6</td></tr>
<tr><td>0x34 </td><td> SLR100</td></tr>
<tr><td>0x40 </td><td> DLT1 40 GB, or Ultrium</td></tr>
<tr><td>0x41 </td><td> DLT 40GB, or Ultrium2</td></tr>
<tr><td>0x42 </td><td> LTO-2</td></tr>
<tr><td>0x44 </td><td> LTO-3</td></tr>
<tr><td>0x45 </td><td> QIC-3095-MC (TR-4)</td></tr>
<tr><td>0x46 </td><td> LTO-4</td></tr>
<tr><td>0x47 </td><td> TR-5 / DDS-5</td></tr>
<tr><td>0x48 </td><td> Quantum SDLT220</td></tr>
<tr><td>0x49 </td><td> Quantum SDLT320</td></tr>
<tr><td>0x51 </td><td> IBM 3592 J1A</td></tr>
<tr><td>0x52 </td><td> IBM 3592 E05</td></tr>
<tr><td>0x58 </td><td> LTO-5</td></tr>
<tr><td>0x5a </td><td> LTO-6</td></tr>
<tr><td>0x5c </td><td> LTO-7</td></tr>
<tr><td>0x5d </td><td> LTO-M8</td></tr>
<tr><td>0x5e </td><td> LTO-8</td></tr>
<tr><td>0x80 </td><td> DLT 15GB uncomp. or Ecrix / VXA-1</td></tr>
<tr><td>0x81 </td><td> DLT 15GB compressed / VXA-2</td></tr>
<tr><td>0x82 </td><td> DLT 20GB uncompressed / VXA-3 / VXA-320</td></tr>
<tr><td>0x83 </td><td> DLT 20GB compressed</td></tr>
<tr><td>0x84 </td><td> DLT 35GB uncompressed</td></tr>
<tr><td>0x85 </td><td> DLT 35GB compressed</td></tr>
<tr><td>0x86 </td><td> DLT1 40 GB uncompressed</td></tr>
<tr><td>0x87 </td><td> DLT1 40 GB compressed</td></tr>
<tr><td>0x88 </td><td> DLT 40GB uncompressed</td></tr>
<tr><td>0x89 </td><td> DLT 40GB compressed</td></tr>
<tr><td>0x8c </td><td> EXB-8505 compressed</td></tr>
<tr><td>0x90 </td><td> SDLT110 uncompr/EXB-8205 compr</td></tr>
<tr><td>0x91 </td><td> SDLT110 compressed</td></tr>
<tr><td>0x92 </td><td> SDLT160 uncompressed</td></tr>
<tr><td>0x93 </td><td> SDLT160 compressed</td></tr>
</tbody></table>

<p><strong>Reading from the cartridge’s RFID tag</strong></p>

<p>LTO cartridges carry an RFID chip that stores all sorts of information. To read this chip using the tape drive, you’ll need the <em>sg_logs</em> command from <em>sg3-utils</em> package. The first line of output is drive information, and everything else is about the tape:</p>

<pre> ~# sg_logs -p 0x17 /dev/sg2 
    TANDBERG  LTO-5 HH          Z629
Volume statistics page (ssc-4), subpage=0
  Page valid: 1
  Thread count: 40
  Total data sets written: 1429926
  Total write retries: 2
  Total unrecovered write errors: 0
  Total suspended writes: 43
  Total fatal suspended writes: 0
  Total data sets read: 4186
  Total read retries: 1
  Total unrecovered read errors: 0
  Last mount unrecovered write errors: 0
  Last mount unrecovered read errors: 0
  Last mount megabytes written: 0
  Last mount megabytes read: 0
  Lifetime megabytes written: 3534834
  Lifetime megabytes read: 10347
  Last load write compression ratio: 0
  Last load read compression ratio: 8391
  Medium mount time: 73309203
  Medium ready time: 73309203
  Total native capacity [MB]: 1529930
  Total used native capacity [MB]: 7250
  Volume serial number: MG1NVN224A
  Tape lot identifier: G5ABP25R
  Volume barcode: ST1008                          
  Volume manufacturer: FUJIFILM
  Volume license code: U107
  Volume personality: Ultrium-5
  Write protect: 0
  WORM: 0
  Maximum recommended tape path temperature exceeded: 0
  Beginning of medium passes: 267
  Middle of medium passes: 203
  Logical position of first encrypted logical object:
    partition number: 0, partition record data counter: 0xffffffffffff
  Logical position of first unencrypted logical object after first
  encrypted logical object:
    partition number: 0, partition record data counter: 0xffffffffffff
  Native capacity partition(s) [MB]:
    partition number: 0, partition record data counter: 1529930
  Used native capacity partition(s) [MB]:
    partition number: 0, partition record data counter: 7250
  Vendor specific parameter code (0xf000), payload in hex
 00     00 01                                               ..
</pre>

<p><strong>mt Command</strong></p>

<p>Most common options of <em>mt</em> are listed below:</p>

<table>
<tbody><tr><th>commande </th><th> description</th></tr>
<tr><th colspan="2"> Information    </th></tr>
<tr><td>status </td><td> displays tape and drive information</td></tr>
<tr><th colspan="2"> Drive parameters</th></tr>
<tr><td>setdensity X </td><td> Set Density Code. Used to enable or disable hardware compression.</td></tr>
<tr><td>setblk X </td><td> Define hardware block size. Normally always at 0 (“dynamic” or “soft blocks”)</td></tr>
<tr><td>drvbuffer X </td><td> enable (1) or disable (0)drive buffering. Other values may apply to some types of drives.</td></tr>
<tr><td>stoptions X </td><td> Set options for the *st* tape driver. Usual values are: 1 to enable write buffering, 2 to enable asynchronous writes, and 8 for debugging.</td></tr>
<tr><th colspan="2"> Movement </th></tr>
<tr><td>rewind </td><td> rewind tape.</td></tr>
<tr><td>retension </td><td> rewind tape, then fast forward to the end of tape, then rewind again.</td></tr>
<tr><td>offline </td><td> rewind then eject tape.</td></tr>
<tr><td>fsf X   </td><td> Forward X files. tape is positioned on the first block of the next file.</td></tr>
<tr><td>fsfm X  </td><td>Forward X files. tape is positioned on the last block of the previous file. Same effect as fsf X + bsf 1</td></tr>
<tr><td>bsf X   </td><td> Backward X files. Tape is positioned on the last block of the previous file</td></tr>
<tr><td>bsfm X  </td><td> Backward X files. Tape is positioned on the first block of the next file, same effect as bsf X + fsf 1</td></tr>
<tr><td>asf X </td><td> Position to the Xth file on tape: rewind then forward X files ( like fsf ).</td></tr>
<tr><td>eod,seod </td><td> Forward to the end of data. Obsolete and equivalent : eom.</td></tr>
<tr><td>fsr X </td><td> Forward X records.</td></tr>
<tr><td>bsr X </td><td> Backward X records</td></tr>
<tr><td>fss X </td><td> Forward X markers (setmarks).</td></tr>
<tr><td>bss X </td><td> Backward X markers </td></tr>
<tr><td>seek X </td><td> Move tape to block X.</td></tr>
<tr><td>tell </td><td> Display the current block</td></tr>
<tr><th colspan="2"> Writing to tape    </th></tr>
<tr><td>eof, weof X </td><td> Write X “End of file” markers at current position.</td></tr>
<tr><td>wset X </td><td> Write X “Set mark” markers at current position.</td></tr>
<tr><td>erase </td><td> Erase the tape from the beginning. Caution: the drive will remain in use until the whole tape has been zeroed out, typically for several hours</td></tr>
</tbody></table>

<p>Each writing operaion on tape with a tool like <em>tar</em>, <em>cpio</em>, etc creates a “file”, identified with an “EOF” (End of file) marker. After writing 3 files on tape, you may move from one file to the other using <em>mt fsf/bsf</em>.</p>

<h2><strong>5. Identifying an unknown tape</strong></h2>

<p>To identify an unknown tape, we’ll first try to determine the block size used to write it. We’ll set up our drive to zero block size (dynamic block size):</p>

<pre>mt -f /dev/nst0 setblk 0
</pre>

<p>Then we’ll read a full block using <em>dd</em>. We’ll suppose that the bloc probably won’t be bigger than 512KiB and write the output into a file <em>/tmp/TESTTAPE</em> :</p>

<pre>~# dd if=/dev/nst0 bs=512k of=/tmp/TESTTAPE count=1
1+0 records in
1+0 records out
32768 bytes (33 kB, 32 KiB) copied, 3,76924 s, 8,7 kB/s
</pre>

<p>In our example we see that our block is 32KiB. Now what sort of file is this? Let’s use the <em>file</em> command :</p>

<pre> ~# file /tmp/TESTTAPE 
/tmp/TESTTAPE2: ASCII cpio archive (SVR4 with no CRC)
</pre>

<p>If <em>file</em> can’t name our data, we can try <em>strings</em> :</p>

<pre>:~# file /tmp/TESTTAPE
/tmp/TESTTAPE: data
~# strings /tmp/TESTTAPE 
-**#( NetVault Header )#**-
rcserveur 22 sept. 04:29-1
rcpartages
</pre>

<h2><strong>6. Basic use of gnu tar</strong></h2>

<p>We’ll list the most common parameters for <em>tar</em> :</p>

<pre><code>-c  write to the target device
-t  list content of target device
-x  restore from target device
-f  target device ( for example */dev/nst0* )
-v  verbose mode (list current operation)
-b  block size to use in units of 512 bytes. Common values: 64, 128; 256 (default value is a paltry 20)
</code></pre>

<p>Writing to tape:</p>

<pre>tar -c -v -f /dev/nst0 -b 128 /un/dossier/à/archiver/
</pre>

<p>Write to <em>/dev/nst0</em> in 64 KiB ( 128 * 512 bytes) blocks. Overwrite whatever was at this position and to the end of tape.</p>

<h2><strong>7. Using LTFS</strong></h2>

<p>LTFS (Long Term File System) is a multi-platform industry standard that provides wide compatibility of LTO-5 (and higher) cartridges between operating systems and software solutions. An LTFS-formatted LTO tape appears as a file system similar to a USB disk drive. Free utilities are available from tape drive providers (IBM, Quantum, HP, etc) for Windows, MacOS and Linux.</p>

<p>As LTFS for Debian is generally unavailable, here is a version I’ve built <a href="https://update.intellique.com/pub/ltfs_2.5.0dev-1_amd64.deb">here</a> (Debian 10 or 11). Dependancies aren’t defined, so you may need to manually install <em>fuse</em> tools.</p>

<p>The Linux LTFS tools are quite simple. The main one is the <em>ltfs</em> command that mounts (using <em>fuse</em>) the tape for reading and writing.
Caution : just like <em>mtx</em> and other tools, <em>ltfs</em> uses the generic SCSI device <em>/dev/sgXX</em> instead of the tape device <em>/dev/stXX</em>.</p>

<p>Using <em>ltfs</em> is very easy. The program is very verbose, so I’ll omit some of its output in the example below:</p>

<pre> ~# ltfs -o devname=/dev/sg2 /mnt/ltfs

6127 LTFS14000I LTFS starting, LTFS version 2.5.0.0 (Prelim), log level 2.                  
6127 LTFS14058I LTFS Format Specification version 2.4.0.                        
6127 LTFS14104I Launched by &#34;ltfs -o devname=/dev/sg2 /mnt/ltfs&#34;.                     
6127 LTFS14105I This binary is built for Linux (x86_64).
6127 LTFS14106I GCC version is 8.3.0.
6127 LTFS17087I Kernel version: Linux version 4.19.0-16-amd64 
    (debian-kernel@lists.debian.org) (gcc version 8.3.0 (Debian 8.3.0-6)) 
    #1 SMP Debian 4.19.181-1 (2021-03-19) i386.
6127 LTFS17089I Distribution: PRETTY_NAME=&#34;Debian GNU/Linux 10 (buster)&#34;.

[...]

6127 LTFS14111I Initial setup completed successfully.
6127 LTFS14112I Invoke &#39;mount&#39; command to check the result of final setup.
6127 LTFS14113I Specified mount point is listed if succeeded.
</pre>

<p>Following the advice from the last line of output, you should use <em>mount</em> to check that the tape is mounted:</p>

<pre> ~# mount -t ltfs
 ltfs:/dev/sg2 on /mnt/ltfs type fuse (rw,nosuid,nodev,relatime,user_id=0,group_id=0,default_permissions,allow_other)
</pre>

<p>You can then read and write to the tape like on any filesystem, but with very high latency. Tape positioning can take several minutes. Simply unmount the tape with <em>umount</em> when done (it can be pretty long, too).</p>

<h2><strong>Appendix: other useful commands</strong></h2>

<p>Sometimes your tape library may be locked, for instance because a software using it crashed, or it was unplugged during operations. You can unlock it with the following command (replace <em>/dev/sg2</em> with the appropriate device):</p>

<pre>sg_prevent -av /dev/sg2
</pre>
</div></div>
  </body>
</html>
