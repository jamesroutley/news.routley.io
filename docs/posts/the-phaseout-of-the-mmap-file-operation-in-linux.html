<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1038715/e4a2f8f50c244545/">Original</a>
    <h1>The phaseout of the mmap() file operation in Linux</h1>
    
    <div id="readability-page-1" class="page"><div>
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>
<p>
The </p><a href="https://elixir.bootlin.com/linux/v6.16.7/source/include/linux/fs.h#L2151"><tt>file_operations</tt></a><p>
structure in the kernel is a set of function pointers implementing, as the
name would suggest, operations on files.  A subsystem that manages objects
which can be represented by a file descriptor will provide a
</p><tt>file_operations</tt><p> structure providing implementations of the various
operations that a user of the file descriptor may want to carry out.  The
</p><tt>mmap()</tt><p> method, in particular, is invoked when user space calls the
</p><a href="https://man7.org/linux/man-pages/man2/mmap.2.html"><tt>mmap()</tt></a><p>
system call to map the object behind a file descriptor into its address
space.  That method, though, is currently on its way out in a multi-release
process that started in 6.17.
</p><p>
The <tt>file_operations</tt> structure was introduced in the 0.95 release
in March 1992; at that point it supported the basic <tt>read()</tt> and
<tt>write()</tt> operations and not much else.  Support for <tt>mmap()</tt>
first appeared in 0.98.2 later that year, though it took a while before it
actually worked as expected.  The interface has evolved a bit over time, of
course; in current kernels, its prototype is:
</p><pre>    int (*mmap) (struct file *, struct vm_area_struct *);
</pre>
<p>
The <a href="https://elixir.bootlin.com/linux/v6.16.7/source/include/linux/mm_types.h#L799"><tt>vm_area_struct</tt></a>
structure (usually referred to as a VMA) describes a range of a process&#39;s
address space; in this case, it provides <tt>mmap()</tt> with information
about the offset within the <tt>file</tt> that is to be mapped, how much is
to be mapped, the intended page protections, and the address range where
the mapping will be.  The driver implementing <tt>mmap()</tt> is expected
to do whatever setup is necessary to make the right thing happen when user
space accesses memory within that range.  There are hundreds of
<tt>mmap()</tt> implementations within the kernel, some of which are quite
complex.
</p><p>
As described in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c84bf6dd2b83">this
6.17 commit</a> by Lorenzo Stoakes, though, there are some significant
problems with this API.  The <tt>mmap()</tt> method is invoked after the
memory-management layer has done much of its setup for the new mapping.  If
the operation fails at the driver layer, all of that setup must be unwound,
which can be a complicated task.  The real problem, though, is that
<tt>mmap()</tt> gives the driver direct access to the VMA, which is one of
the core memory-management data structures.  The driver can make changes to
the VMA, and many do with gusto.  Those changes can force the
memory-management layer to redo some of its setup; worse, they can
introduce bugs or create other types of unpleasant surprises.
</p><p>
Over the years, a number of important memory-management structures have
been globally exposed in this way; more recently, developers have been
working to make more of those structures private to the memory-management
code.  One step in that direction is to retire the <tt>mmap()</tt> method
in favor of a new API that more clearly constrains what code outside of the
memory-management layer can do.
</p><h4>Replacing <tt>mmap()</tt></h4>
<p>
This work began with the introduction of the new <tt>mmap_prepare()</tt>
callback in 6.17:
</p><pre>    int (*mmap_prepare)(struct vm_area_desc *);
</pre>
<p>
That method receives a pointer to the new <tt>vm_area_desc</tt> structure:
</p><pre>    struct vm_area_desc {
	/* Immutable state. */
	struct mm_struct *mm;
	unsigned long start;
	unsigned long end;

	/* Mutable fields. Populated with initial state. */
	pgoff_t pgoff;
	struct file *file;
	vm_flags_t vm_flags;
	pgprot_t page_prot;

	/* Write-only fields. */
	const struct vm_operations_struct *vm_ops;
	void *private_data;
    };
</pre>
<p>
This new method is intended to eventually replace <tt>mmap()</tt>; a driver
cannot provide both <tt>mmap_prepare()</tt> and <tt>mmap()</tt> in the same
<tt>file_operations</tt> structure.  <tt>mmap_prepare()</tt> is called much
earlier in the mapping process, before the VMA itself is set up.  If it
returns a failure status, there is a lot less work to clean up within the
memory-management code.  The <tt>vm_area_desc</tt> structure is intended to
provide the driver with only the information it needs to set up the
mapping, and to allow it to specify specific VMA changes to be made once
the VMA itself is set up.
</p><p>
Thus, for example, the driver can modify <tt>pgoff</tt> (the offset within
the file where the mapping starts) if needed to meet alignment or other
constraints.  Various flags and the page protections can be changed, and
the driver can provide a <a href="https://elixir.bootlin.com/linux/v6.16.7/source/include/linux/mm.h#L579"><tt>vm_operations_struct</tt></a>
pointer with callbacks to handle page faults, protection changes, and other
operations on the mapping.  If the mapping succeeds, the memory-management
layer will copy information from this structure into the VMA while keeping
a grip on the overall contents of that VMA.
</p><h4>The next step</h4>
<p>
That was the state of the API as merged for the 6.17 release; it was enough
to support the conversion of a number of drivers over from <tt>mmap()</tt>
and begin the long process of deprecating that interface.  As noted above,
though, some drivers do complex things in their <tt>mmap()</tt>
implementations, and this API is not sufficient for their needs.  Thus,
Stoakes has been working on <a href="https://lwn.net/ml/all/cover.1758135681.git.lorenzo.stoakes@oracle.com">an expansion
of <tt>mmap_prepare()</tt></a> for a wider range of use cases.
</p><p>
The new capabilities are based around yet another new structure, which is
added to <tt>struct vm_area_desc</tt> (as a field named <tt>action</tt>):
</p><pre>    struct mmap_action {
	union {
	    /* Remap range. */
	    struct {
		unsigned long start;
		unsigned long start_pfn;
		unsigned long size;
		pgprot_t pgprot;
	    } remap;
	};
	enum mmap_action_type type;
	int (*success_hook)(const struct vm_area_struct *vma);
	int (*error_hook)(int err);
    };
</pre>
<p>
This structure tells the memory-management core what the driver would like
to see happen <i>after</i> the VMA has been set up and is valid.  The
actions defined in this patch set are <tt>MMAP_NOTHING</tt> (do nothing),
<tt>MMAP_REMAP_PFN</tt>, which causes the address space covered by the VMA
to be mapped to a range of page-frame numbers beginning at
<tt>start_pfn</tt>, and <tt>MMAP_IO_REMAP_PFN</tt>, which performs a
similar remapping into device-hosted memory.  The driver could perform this
remapping itself, one page at a time, in its <tt>fault()</tt>
<tt>vm_operations_struct</tt> method, but it is much more efficient to just
do the whole range at once.
</p><p>
There are also two callbacks in that structure.  The
<tt>success_hook()</tt> callback will be called upon the successful
completion of the requested action.  That callback is passed a pointer to
the VMA, but it is a pointer to a <tt>const</tt> structure, so the callback
should not be able to make any changes there.  This callback is <a href="https://lwn.net/ml/all/14cdf181c4145a298a2249946b753276bdc11167.1758135681.git.lorenzo.stoakes@oracle.com">used
in the <tt>/dev/zero</tt> driver</a> to perform a &#34;<q>very unique and
rather concerning</q>&#34; (according to Stoakes) change that driver makes to
the mapping.  The <tt>error_hook()</tt> is called if things go wrong; it
can provide a different error code to be returned as a way of filtering
errors that should not make it back to user space.
</p><p>
This series is in its fourth revision as of this writing; it still seems to
be going through a relatively high rate of change in response to review
comments.  Whether it will settle in time for the 6.18 merge window is
unclear at this point, so the work to remove the <tt>mmap()</tt> callback
may have to wait another cycle before proceeding.  Even after that, though,
there will still be those hundreds of <tt>mmap()</tt> implementations to
convert, so this task will not be complete for some time yet.<br clear="all"/></p><table>
           <tbody><tr><th colspan="2">Index entries for this article</th></tr>
           <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#struct_file_operations">struct file_operations</a></td></tr>
            <tr><td><a href="https://lwn.net/Kernel/Index">Kernel</a></td><td><a href="https://lwn.net/Kernel/Index#System_calls-mmap">System calls/mmap()</a></td></tr>
            </tbody></table></div></div>
  </body>
</html>
