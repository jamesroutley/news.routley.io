<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://blog.pkh.me/p/36-figuring-out-round%2C-floor-and-ceil-with-integer-division.html">Original</a>
    <h1>Figuring out round, floor and ceil with integer division</h1>
    
    <div id="readability-page-1" class="page"><article><p>Lately I&#39;ve been transforming a float based algorithm to integers in order to
make it bit-exact. Preserving the precision as best as possible was way more
challenging than I initially though, which forced me to go deep down the rabbit
hole. During the process I realized I had many wrong assumptions about integer
divisions, and also discovered some remarkably useful mathematical properties.</p>
<p>This story is about a journey into figuring out equivalent functions to
<code>round(a/b)</code>, <code>floor(a/b)</code> and <code>ceil(a/b)</code> with <code>a</code> and <code>b</code> integers, while
staying in the integer domain (no intermediate <code>float</code> transformation allowed).</p>
<p><strong>Note</strong>: for the sake of conciseness (and to make a bridge with the
mathematics world), <code>floor(x)</code> and <code>ceil(x)</code> will sometimes respectively be
written <code>⌊x⌋</code> and <code>⌈x⌉</code>.</p>
<h2>Clarifying the mission</h2>
<p>Better than explained with words, here is how the functions we&#39;re looking for
behave with a real as input:</p>
<p><img src="http://blog.pkh.me/img/intdiv/round-floor-ceil.png" alt="centerimg"/></p>
<p>The dots indicate on which lines the stitching applies; for example <code>round(½)</code>
is <code>1</code>, not <code>0</code>.</p>
<h2>Language specificities (important!)</h2>
<p>Here are the corresponding prototypes, in C:</p>
<pre><code>int div_round(int a, int b); // round(a/b)
int div_floor(int a, int b); // floor(a/b)
int div_ceil(int a, int b);  // ceil(a/b)
</code></pre>
<p>We&#39;re going to work in C99 (or more recent), and this is actually the first
warning I have here. If you&#39;re working with a different language, you must
absolutely look into how its integer division works. In C, the integer division
is <strong>toward zero</strong>, for <strong>both positive and negative integers</strong>, and only
defined as such <strong>starting C99</strong> (it is implementation defined before that). Be
mindful about it if your codebase is in C89 or C90.</p>
<p>This means that in C:</p>
<pre><code>printf(&#34;%d %d %d\n&#34;, 10/30, 15/30, 20/30);
printf(&#34;%d %d %d\n&#34;, -10/30, -15/30, -20/30);
</code></pre>
<p>We get:</p>
<pre><code>0 0 0
0 0 0
</code></pre>
<p>This is typically different in Python:</p>
<pre><code>&gt;&gt;&gt; 10//30, 15//30, 20//30
(0, 0, 0)
&gt;&gt;&gt; -10//30, -15//30, -20//30
(-1, -1, -1)
</code></pre>
<p>In Python 2 and 3, the integer division is toward -∞, which means it is
directly equivalent to how the <code>floor()</code> function behaves.</p>
<p>In C, the integer division is equivalent to <code>floor()</code> <strong>only for positive
numbers</strong>, otherwise it behaves the same as <code>ceil()</code>. This is the division
behavior we will assume in this article:</p>
<p><img src="http://blog.pkh.me/img/intdiv/c-div.png" alt="centerimg"/></p>
<p>And again, I can&#39;t stress that enough: make sure you understand how the integer
division of your language works.</p>
<p>Similarly, you may have noticed we picked the <code>round</code> function as defined by
POSIX, meaning rounding half away from <code>0</code>. Again, in Python a different method
was selected:</p>
<pre><code>&gt;&gt;&gt; [round(x) for x in (0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5)]
[0, 2, 2, 4, 4, 6, 6]
</code></pre>
<p>Python is following the round toward even choice rule. This is not what we are
implementing here. There are <a href="https://en.wikipedia.org/wiki/Rounding">many ways of rounding</a>, so make sure
you&#39;ve clarified what method your language picked.</p>
<h2>Ceiling and flooring</h2>
<p>The integer division is symmetrical around <code>0</code> but <code>ceil</code> and <code>floor</code> aren&#39;t,
so we need a way get the sign in order to branch in one direction or another.
If <code>a</code> and <code>b</code> have the same sign, then <code>a/b</code> is positive, otherwise it&#39;s
negative. This is well expressed with a <code>xor</code> operator, so we will be using the
sign of <code>a^b</code> (where <code>^</code> is a <code>xor</code> operator). Of course we only need to <code>xor</code>
the sign bit, but that would make the expression unnecessarily complex.</p>
<p>Looking at the graphics, we observe the following symmetries:</p>
<ul>
<li><code>floor(x)</code>:
<ul>
<li>For positive <code>x</code>, the C division works the same</li>
<li>For negative <code>x</code>, the C division is one step too high (with the exception
of the stitching point)</li>
</ul>
</li>
<li><code>ceil(x)</code>
<ul>
<li>For negative <code>x</code>, the C division works the same</li>
<li>For positive <code>x</code>, the C division is one step too low (with the exception
of the stitching point)</li>
</ul>
</li>
</ul>
<p>We can trivially translate these observations into code using a modulo trick
(which purpose is to <strong>not</strong> offset the stitching point when the division is
round):</p>
<pre><code>int div_floor(int a, int b) { return (a^b) &lt; 0 ? a/b - (a%b!=0) : a/b; }
int div_ceil(int a, int b)  { return (a^b) &gt; 0 ? a/b + (a%b!=0) : a/b; }
</code></pre>
<p>One may wonder about the double division (<code>a/b</code> and <code>a%b</code>), but fortunately CPU
architectures usually offer a division instruction that computes both at once
so this is not as expensive as it would seem in the first place.</p>
<p>Now you also have an alternative without the modulo, but it generates less
effective code (at least here on <code>x86-64</code> with a modern CPU according to my
benchmarks):</p>
<pre><code>int div_floor(int a, int b) { return (a^b) &lt; 0 &amp;&amp; a ? (1-abs(a))/abs(b)-1 : a/b; }
int div_ceil(int a, int b)  { return (a^b) &gt; 0 &amp;&amp; a ? (abs(a)-1)/abs(b)+1 : a/b; }
</code></pre>
<p>I have no hard proof to provide for these right now, so this is left as an
exercise to the reader, but some tools can be found in in <em>Concrete Mathematics
(2nd ed)</em> by Ronald L. Graham, Donald E. Knuth and Oren Patashnik. In
particular:</p>
<ul>
<li>the reflection properties: <code>⌊-x⌋ = -⌈x⌉</code> and <code>⌈-x⌉ = -⌊x⌋</code></li>
<li><code>⌈n/m⌉ = ⌊(n-1)/m⌋+1</code> and <code>⌊n/m⌋ = ⌈(n+1)/m⌉-1</code></li>
</ul>
<h2>Rounding</h2>
<p>The <code>round()</code> function is the most useful one when trying to approximate floats
operations with integers (typically what I was looking for initially:
converting an algorithm into a bit-exact one).</p>
<p>We are going to study the positive ones only at first, and try to define it
according to the integer C division (just like we did for <code>floor</code> and <code>ceil</code>).
Since we are on the positive side, the division is equivalent to a <code>floor()</code>,
which simplifies a bunch of things.</p>
<p>I initially used a <code>round</code> function defined as <code>round(a,b) = (a+b/2)/b</code> and
thought to myself &#34;if we are improving the accuracy of the division by <code>b</code>
using a <code>b/2</code> offset, why shouldn&#39;t we also improve the accuracy of <code>b/2</code> by
doing <code>(b+1)/2</code> instead?&#34; Very proud of my deep insight I went on with this,
until I realized it was causing more off by ones (with a bias always in the
same direction). So <strong>don&#39;t do that</strong>, it&#39;s wrong, we will instead try to find
the appropriate formula.</p>
<p>Looking at the <code>round</code> function we can make the observation that it&#39;s pretty
much the <code>floor()</code> function with the <code>x</code> offset by <code>½</code>: <code>round(x) = floor(x+½)</code></p>
<p>So we have:</p>
<pre><code>round(a/b) = ⌊a/b + ½⌋
           = ⌊(2a+b)/(2b)⌋
</code></pre>
<p>We could stop right here but this suffers from overflow limitations if
translated into C. We are lucky though, because we&#39;re about to discover the
most mind blowing property of integers division:</p>
<p><img src="http://blog.pkh.me/img/intdiv/nested-division.png" alt="centerimg"/></p>
<p>This again comes from <em>Concrete Mathematics (2nd ed)</em>, page 72.</p>
<p>You may not immediately realize how insane and great this is, so let me
elaborate: it basically means <code>N</code> successive truncating divisions can be merged
into one <strong>without loss of precision</strong> (and the other way around).</p>
<p>Here is a concrete example:</p>
<pre><code>&gt;&gt;&gt; n = 5647817612937
&gt;&gt;&gt; d = 712
&gt;&gt;&gt; n//d//d//d == n//(d*d*d)
True
</code></pre>
<p>That&#39;s great but how does that help us? Well, we can do this now:</p>
<pre><code>round(a/b) = ⌊a/b + ½⌋
           = ⌊(2a+b)/(2b)⌋
           = ⌊⌊(2a+b)/2⌋/b⌋   &lt;--- applying the nested division property to split in 2 floor expressions
           = ⌊⌊a+b/2⌋/b⌋
           = ⌊(a+⌊b/2⌋)/b⌋
</code></pre>
<p>How cute is that, we&#39;re back to the original formula I was using: <code>round(a,b) = (a+b/2)/b</code> (because again the C division is equivalent to <code>floor()</code> for
positive values).</p>
<p>Now how about the negative version, that is when <code>a/b &lt; 0</code>? We can make the
similar observation that for a negative <code>x</code>, <code>round(x) = ceil(x-½)</code>, so we
have:</p>
<pre><code>round(a/b) = ⌈a/b - ½⌉
           = ⌈(2a-b)/(2b)⌉
           = ⌈⌈(2a-b)/2⌉/b⌉
           = ⌈⌈a-b/2⌉/b⌉
           = ⌈(a-⌈b/2⌉)/b⌉
</code></pre>
<p>And since <code>a/b</code> is negative, the C division is equivalent to <code>ceil()</code>. So in
the end we simply have:</p>
<pre><code>int div_round(int a, int b) { return (a^b) &lt; 0 ? (a-b/2)/b : (a+b/2)/b; }
</code></pre>
<p>This is the generic version, but of course in many cases we can (and probably
should) simplify the expression appropriately.</p>
<p>Let&#39;s say for example we want to remap an <code>u16</code> to an <code>u8</code>:
<code>remap(x,0,0xff,0,0xffff) = x*0xff/0xffff = x/257</code>. The appropriate way to
round this division is simply: <code>(x+257/2)/257</code>, or just: <code>(x+128)/257</code>.</p>
<h2>Verification</h2>
<p>Since you should definitely not trust my math nor my understanding of
computers, here is a test code to demonstrate the exactitude of the formulas:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

static int div_floor(int a, int b) { return (a^b) &lt; 0 ? a/b - (a%b!=0) : a/b; }
static int div_ceil(int a, int b)  { return (a^b) &gt; 0 ? a/b + (a%b!=0) : a/b; }
static int div_round(int a, int b) { return (a^b) &lt; 0 ? (a-b/2)/b : (a+b/2)/b; }

#define N 3000

int main()
{
    for (int a = -N; a &lt;= N; a++) {
        for (int b = -N; b &lt;= N; b++) {
            if (!b)
                continue;

            const float f = a / (float)b;

            const int ef = (int)floorf(f);
            const int er = (int)roundf(f);
            const int ec = (int)ceilf(f);

            const int of = div_floor(a, b);
            const int or = div_round(a, b);
            const int oc = div_ceil(a, b);

            const int df = ef != of;
            const int dr = er != or;
            const int dc = ec != oc;

            if (df || dr || dc) {
                fprintf(stderr, &#34;%d/%d=%g%s\n&#34;, a, b, f, (a ^ b) &lt; 0 ? &#34; (diff sign)&#34; : &#34;&#34;);
                if (df) fprintf(stderr, &#34;floor: %d ≠ %d\n&#34;, of, ef);
                if (dr) fprintf(stderr, &#34;round: %d ≠ %d\n&#34;, or, er);
                if (dc) fprintf(stderr, &#34;ceil: %d ≠ %d\n&#34;, oc, ec);
            }
        }
    }
    return 0;
}
</code></pre>
<h2>Conclusion</h2>
<p>These trivial code snippets have proven to be extremely useful to me so far,
and I have the hope that it will benefit others as well. I spent an
unreasonable amount of time on this issue, and given the amount of mistakes (or
at the very least non optimal code) I&#39;ve observed in the wild, I&#39;m most
certainly not the only one being confused about all of this.</p>
</article><p>
 For updates and more frequent content you can follow me on <a href="https://twitter.com/insouris">Twitter</a> or <a href="https://fosstodon.org/@bug">Mastodon</a>. Feel also free to
 subscribe to the <a href="http://blog.pkh.me/rss.xml">RSS</a> in order to be notified
 of new write-ups. It is also usually possible to reach me through
 other means (check the footer below). Finally, discussions on some of
 the articles can sometimes be found on HackerNews, Lobste.rs and
 Reddit.
</p></div>
  </body>
</html>
