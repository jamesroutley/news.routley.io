<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://laplab.me/posts/databases-are-frameworks-for-distributed-systems/">Original</a>
    <h1>Databases = Frameworks for Distributed Systems</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p><img src="https://laplab.me/img/ship.jpeg" alt="Title image"/></p>
<blockquote>
<p>This article was originally <a href="https://dev.to/laplab/databases-frameworks-for-distributed-systems-29bo">posted on dev.to</a>, but it turns out that HackerNews banned this website, so I decided to create my own.</p>
</blockquote>
<blockquote>
<p>Feel free to join the <a href="https://news.ycombinator.com/item?id=31459745">discussion on HackerNews</a>.</p>
</blockquote>
<h2 id="lego-of-the-database-world">Lego of the database world</h2>
<p>It is quite common for a distributed database to have the following components:</p>
<ul>
<li>
<p><strong>Distributed Storage</strong> Usually, this component has an interface of a key-value store: <code>Get(key)</code> and <code>Set(key, value)</code>, where <code>key</code> and <code>value</code> are some binary strings. This component knows nothing about the data - it can be rows from the table, JSON documents or something else entirely. Usually, this component provides guarantee of “durability”, meaning that data will not be lost in some failure scenario. A common example of such scenario is “less than half of the servers are down”.</p>
</li>
<li>
<p><strong>Communication between cluster nodes</strong> This component implements some kind of communication protocol to send and receive messages from one node to another.</p>
</li>
<li>
<p><strong>Computation model</strong> This component executes result to the user’s query. For instance, set of rows requested using SQL.</p>
</li>
</ul>
<p>In classical databases (such as PostreSQL), all of these components are implemented in one single application. Such application manages everything on its own: controls storage, talks with other nodes in the cluster and computes results to SQL queries.</p>
<p>In MapReduce systems (such as Hadoop) and some other databases (such as Google BigQuery), various database components are physically separated. Some of the cluster nodes are reserved exclusively for storage. Other nodes are used only to compute results to SQL queries. If SQL query needs some data, it is transferred from the storage node to the compute node over the network.</p>
<h2 id="lego-of-distributed-systems">Lego of distributed systems</h2>
<p>Now let us imagine we want to create a new distributed system - a service to monitor various metrics (like <a href="https://prometheus.io/">Prometheus</a>). Depending on the specific requirements to this system, we are likely to need the following:</p>
<ul>
<li>
<p><strong>Distributed storage with “durability” guarantee</strong> We need to store user’s metrics somewhere and we do not want to loose valuable data because of the datacenter downtime.</p>
</li>
<li>
<p><strong>Communication between cluster nodes</strong> Monitoring system can be deployed in multiple datacenters to reduce latency and improve fault tolerance. Various instances of our system will need to coordinate with each other.</p>
</li>
<li>
<p><strong>Computation model</strong> Firstly, our system must accept requests to store new metrics. Secondly, it should respond to requests to read time-series data and generate reports for monitoring graphs.</p>
</li>
</ul>
<p>Writing each of these components is a non-trivial task. Not only we need to write code and tests, but we also need to harden the system in production. The latter often leads to discovery of unexpected bugs and inefficiencies in design.</p>
<p>Now let us go back to the databases. They have all the components we need to build our distributed system. These components are already implemented, tested and hardened by thousands of various workloads. What is more, each of these components could be separated from the database itself and used on its own.</p>
<p>This basically means that databases could be used as frameworks to build new distributed systems.</p>
<p><strong>Disclaimer:</strong> This is a generalization to demonstrate a point. Some databases have a design which does not support using their components on its own or were not designed to be used in a distributed setup. Some distributed systems may not fit into the model described above. As always with Software Engineering, common sense and understanding of system requirements at hand should go first.</p>
<h2 id="examples">Examples</h2>
<h3 id="ydb">YDB</h3>
<p><img src="https://laplab.me/img/ydb-architecture.png" alt="YDB architecture"/></p>
<p><em>Image source: <a href="https://ydb.tech/">https://ydb.tech/</a></em></p>
<p><a href="https://ydb.tech/">YDB</a> is a distributed database developed in <a href="https://en.wikipedia.org/wiki/Yandex">Yandex</a>. It provides horizontal scalability and strong consistency guarantees.</p>
<p>Under the hood, YDB uses <a href="https://en.wikipedia.org/wiki/Actor_model">actor model</a>. Actor is a unit of concurrency which is able to:</p>
<ol>
<li>Receive messages from other actors</li>
<li>Send messages to other actors</li>
<li>Launch new actors</li>
</ol>
<p>Actor is always single-threaded and can only change its internal state. Actors have no concept of shared state, which means that all synchronization is done through message passing. On one hand, there are no more mutexes in the code. On the other hand, you can no longer just write to memory for the other actor to see it.</p>
<p>YDB has a special name for actor - tablet. Tablets are building blocks of YDB. SQL queries execution, transaction coordination, creation of new tablets - each of these tasks is executed by one or more tablets. To use this post terminology, tablets are the <strong>computation model</strong>.</p>
<p>As actors, tablets need to send and receive messages. There is a special system in YDB created just for that - it is called interconnect. Each tablet is given an ID and tablets can send messages to each other using this ID as their postal address. Interconnect is a system for <strong>communication between cluster nodes</strong>.</p>
<p>Lastly, tablets need to store their state somewhere. For instance, tablets representing a shard of SQL table need to store range of table rows assigned to them. YDB has a <strong>distributed storage</strong>, which can store arbitrary binary blobs with “durability” guarantee.</p>
<p>Having all these components makes YDB not only a database, but also a generic distributed computations platform. Distributed system developer can write their own app logic by creating a new kind of tablet and reuse the rest of the system for their own purposes.</p>
<p><strong>Disclaimer:</strong> YDB is advertised as a database solution. No public documentation was announced about using it as a platform for distributed systems.</p>
<h3 id="tarantool">Tarantool</h3>
<p><img src="https://laplab.me/img/tarantool.png" alt="Tarantool"/></p>
<p><em>Image source: <a href="https://www.tarantool.io/">https://www.tarantool.io/</a></em></p>
<p><strong>Disclaimer:</strong> I did not contribute to Tarantool, neither did I use it in production.</p>
<p><a href="https://www.tarantool.io/en/">Tarantool</a> is an application server for distributed systems written in Lua. Lua applications launched in Tarantool have API access to the following components:</p>
<ul>
<li>
<p>Distributed transactional database. This database supports 2 modes of operation - in-memory and with commits to disk. Second mode makes this component <strong>distributed storage</strong> in this post’s terms.</p>
</li>
<li>
<p>Communication protocol called SWIM. It allows to send and receive <strong>messages between cluster nodes</strong>.</p>
</li>
</ul>
<p>Since the application server itself makes the <strong>computation model</strong>, we have all components necessary to call Tarantool a generic distributed computations platform.</p>
<p>This does not really sound impressive. It looks like Tarantool was initially created to be such a platform, so no surprise it fits all the criteria. The thing is, Tarantool initially was created as a database, which then quickly developed into a full-grown computational platform. The fact that it only took 2-3 years for that is outstanding, but it also shows how a database solution has evolved into “framework” to build distributed systems.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As serverless market grows larger, more database solutions start to consider modular architecture, where various components of the system are separated. This allows to allocate one instance of such component per serverless tenant, providing clear separation between users. Making database solution modular is also the first step to make various parts of it reusable by non-database application. It is interesting for me to see if in 5-10 years term “database” will slowly evolve into “distributed computations platform”.</p>
<p>Thank you for reading!</p>

</div></div>
  </body>
</html>
