<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://baturin.org/docs/ocaml-faq/">Original</a>
    <h1>What I wish I knew when learning OCaml (2018)</h1>
    
    <div id="readability-page-1" class="page"><p>
      This is a poorly structured list of common questions and answers about OCaml
   I had to ask myself or have been asked often.
     </p><div>
      
      <h2 id="the-language">
       <a href="#the-language">→ </a>The language
      </h2>
      <h3 id="the-double-semicolon">
       <a href="#the-double-semicolon">→ </a>The double semicolon
      </h3>
      <p>
       The answer to the question “When do I need the <strong>;;</strong> within
   OCaml source code?” is <strong>never</strong>.
      </p>
      <p>
       It&#39;s not a part of the language and is only used by the interpreter as an end of input mark.
      </p>
      <p>
       If you want to execute something for its side effects and don&#39;t care about its return value,
   you should wrap it in a let-expression and match it against the wildcard pattern:
      </p>
      <pre>let _ = print_endline &#34;hello world&#34;

let _ = exit 0
</pre>
      <p>
       If you call a function that returns unit, you can also match the result against the unit value,
       <tt>
        ()
       </tt>
       .
      </p>
      <pre>let () = print_endline &#34;hello world&#34;
</pre>
      <p>
       The advantage over wildcard is that if you accidentally write an expression that has type other than
   unit (e.g. forget the argument), the compiler will throw a type error.
      </p>
      <p>
       <strong>Note:</strong> If you use ocaml as a non-interactive script interpreter  (i.e.
       <tt>
        ocaml /path/to/file.ml
       </tt>
       ),
   you do need the ;; after directives, as in
       <tt>
        #use &#34;topfind&#34;;;
       </tt>
       . But the directives are not part
   of the language either.
      </p>
      <p>
       <strong>Historical note:</strong> In CAML Light, the predecessor of OCaml, double semicolons were mandatory.
   For this reason they are quite common in old code originally written in CAML Light or written in the early days
   of OCaml. These days they are considered a bad style.
      </p>
      <h3 id="semicolons-and-expression-sequences">
       <a href="#semicolons-and-expression-sequences">→ </a>Semicolons and expression sequences
      </h3>
      <p>
       Semicolon is an expression separator, not a statement terminator.
      </p>
      <p>
       This code
      </p>
      <pre>let foo x y =
    print_endline &#34;Now I&#39;ll add up two numbers&#34;;
    print_endline &#34;Yes, seriously&#34;;
    x + y
</pre>
      <p>
       is semantically equivalent to
      </p>
      <pre>let foo x y =
    let _ = print_endline &#34;Now I&#39;ll add up two numbers&#34; in
    let _ = print_endline &#34;Yes, seriously&#34; in
    x + y
</pre>
      <p>
       Therefore, if you end a sequence of expressions with a semicolon, whatever comes next will
   be treated as the last expression of the sequence, and will likely cause a syntax error
   (e.g. if the next thing is a let binding) or, worse, incorrect behaviour.
      </p>
      <h3 id="shadowing-is-not-mutation">
       <a href="#shadowing-is-not-mutation">→ </a>Shadowing is not mutation
      </h3>
      <p>
       Some uses of top level let bindings may look like mutation, but they actually aren&#39;t.
      </p>
      <pre>let x = 10
let x = x + 10
let () = Printf.printf &#34;%d\n&#34; x
</pre>
      <p>
       In this example, the <em>x</em> in the printf expression is 20. Did we redefine <em>x</em> for the <em>whole program</em>?
      </p>
      <p>
       The answer is no. Every let binding opens a new scope. In case of top level bindings, the scope they open continues until the
   end of the file. So “let x = x + 10” takes the value of <em>x</em> from the outer scope, adds 10 to it,
   and opens a new scope where <em>x</em> is bound to 20.
      </p>
      <p>
       However, it has no effect on the outer scope. We can demonstrate it by creating some closures that use the old <em>x</em>.
      </p>
      <pre>let x = 10
let print_old_x () = Printf.printf &#34;%d\n&#34; x

let x = x + 10
let () = Printf.printf &#34;%d\n&#34; x  (* prints 20 *)
let () = print_old_x ()          (* prints 10 *)
</pre>
      <h3 id="functions-and-currying">
       <a href="#functions-and-currying">→ </a>Functions and currying
      </h3>
      <p>
       The good thing about currying in OCaml and other ML-style languages is that you don&#39;t need to know what
   currying is to use it. Every time you create a function of “multiple arguments”,
   you really create a curried function. Which means that
      </p>
      <pre>let add x y = x + y
</pre>
      <p>
       is a sugar for
      </p>
      <pre>let add =
  fun x -&gt;
    fun y -&gt; x + y
</pre>
      <p>
       This makes partial application very easy: just omit some of the arguments 
   and what you get is a new function.
      </p>
      <pre># let add1 = add 1 ;;
val add1 : int -&gt; int = &lt;fun&gt;
</pre>
      <p>
       To be precise, what you get is a closure: a function plus an environment
   where name <em>x</em> is bound to 1, but you don&#39;t need to think about it
   to use it.
      </p>
      <p>
       <strong>Note:</strong> this is also the reason OCaml never gives you
   “too few arguments” errors if you forget an argument. Only when you try to use
   that value, it tells you that your value has type <em>foo → bar</em> but was expected
   to have type <em>bar</em>. If you see an error like that, check for
   missing arguments. Example:
      </p>
      <pre># (add 1) + 9 ;;
Error: This expression has type int -&gt; int but an expression was expected of type int 
</pre>
      <h3 id="mutable-record-fields-vs--references">
       <a href="#mutable-record-fields-vs--references">→ </a>Mutable record fields vs. references
      </h3>
      <p>
       They are the same thing. A reference is a record with the sole mutable field called “contents”,
   as you can see from the Pervasives source code.
      </p>
      <pre>type &#39;a ref = { mutable contents : &#39;a }

let (:=) r v = r.contents &lt;- v
let (!) r = r.contents
</pre>
      <p>
       Therefore the choice between references and mutable fields is mostly aesthetic. However, if you store
   references in record fields, converting them to mutable records may make the code slightly faster.
      </p>
      <h3 id="is-there-any-difference-between-begin-end-and-parentheses-">
       <a href="#is-there-any-difference-between-begin-end-and-parentheses-">→ </a>Is there any difference between begin/end and parentheses?
      </h3>
      <p>
       Not really. The real difference between begin/end in OCaml and identical looking construct in Pascal (or curly braces in C)
is that in Pascal, they create a <em>compound statement</em>, while in OCaml they work as expression delimiters.
In other words, it&#39;s just a more readable alternative to parentheses.
      </p>
      <p>
       Consider these examples:
      </p>
      <pre>let foo () =
  (for i = 1 to 3 do
     print_endline &#34;I&#39;ll return 0, I tell you!&#34;
   done);
  0

let x = 3 + begin 2 end 
</pre>
      <h3 id="type-definitions">
       <a href="#type-definitions">→ </a>Type definitions
      </h3>
      <p>
       The ML term for a tuple is <em>product type</em>. A natural example of a product type
   is a point on a plane that has X and Y coordinates.
      </p>
      <pre>type point = float * float
</pre>
      <p>
       Product types are rarely named, and the compiler will not start calling everything that
   is float * float a point after you declare this type. They are usually implicit or
   incorporated into definitions of sum types and records.
      </p>
      <p>
       Another kind of types that has no direct analogy in most other languages is
   <em>sum type</em> (variant records in Pascal and Ada are pretty close). Easier to show than
   to explain. An example: in color printing, dot color is either the key color (usually black)
   or a combination of cyan, yellow, and magenta. We can represent colors with this type:
      </p>
      <pre>type color = Key | Color of int * int * int
</pre>
      <p>
       Sum and product types are referred to as <em>algebraic data types</em>.
      </p>
      </div></div>
  </body>
</html>
