<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://words.filippo.io/dispatches/go-1-20-cryptography/">Original</a>
    <h1>Go 1.20 Cryptography</h1>
    
    <div id="readability-page-1" class="page"><article>
        <span>
            <time datetime="2023-01-04">04 Jan 2023</time>
        </span>
        
        
        <section>
            <!--kg-card-begin: markdown--><p><a href="https://groups.google.com/g/golang-dev/c/MtxdaVmTgQk/m/xm6rLPFHAQAJ">The <s>first</s> second release candidate of Go 1.20 is out</a>! This is the first release I participated in as an independent maintainer, after <a href="https://twitter.com/FiloSottile/status/1522671407636877315">leaving Google</a> to become a professional Open Source maintainer. (By the way, that’s going great, and I’m going to write more about it here soon!)</p>
<p>I’m pretty happy with the work that’s landing in it. There are both exciting new APIs, and invisible deep backend improvements that are going to make code more maintainable and secure in the long run. All the main work mentioned in the <a href="https://words.filippo.io/dispatches/go1-20/">planning post</a> got done, and then some (but not the “stretch goals”). The whole release is pretty exciting, too, and you should check out the <a href="https://tip.golang.org/doc/go1.20">release notes</a> (although <a href="https://go.dev/cl/459978">the cryptography parts might not be complete yet</a>).</p>
<h2 id="cryptoecdh">crypto/ecdh</h2>
<p>The standard library is gaining a new package: <a href="https://pkg.go.dev/crypto/ecdh@go1.20rc1"><code>crypto/ecdh</code></a>. Here’s what I said about it in <a href="https://words.filippo.io/dispatches/go1-20/">the Go 1.20 planning post</a>.</p>
<blockquote>
<p>The most visible change will be the landing the new <a href="https://pkg.go.dev/crypto/ecdh@master"><code>crypto/ecdh</code> package</a> I <a href="https://github.com/golang/go/issues/52221">proposed</a> and <a href="https://go.dev/cl/398914">implemented</a> earlier this year. The package provides a safe, <code>[]byte</code>-based, easy to use API for Elliptic Curve Diffie-Hellman over Curve25519 and NIST curves (P-256 and company, but no P-224 if we can get away with it).</p>
<p><code>crypto/ecdh</code> was made possible by a long-running refactor of the elliptic curve implementations in the standard library. Between Go 1.17 and Go 1.19, most critical code was moved to safer low-level APIs under <code>crypto/internal/nistec</code> and <code>crypto/internal/edwards25519</code>, large pieces were replaced with code generated from <a href="https://github.com/mit-plv/fiat-crypto">fiat-crypto</a>&#39;s formally verified models, making every curve constant time, most group logic was replaced with modern complete formulas, and even <a href="https://go-review.googlesource.com/c/go/+/396255">the assembly was massaged to implement the same functions on all architectures</a> and fit the nistec API. <a href="https://go-review.googlesource.com/c/crypto/+/315269">Some assembly is gone</a>, actually!</p>
<p>(<a href="https://go-review.googlesource.com/q/hashtag:crypto-elliptic-refactor">Here are all the changes.</a> <a href="https://cs.opensource.google/go/go/+/master:src/crypto/ecdh/nist.go;l=16-29;drc=d88d91e32e1440307369d50ba17ce622399a8bc1">A couple nifty uses of generics in there if you&#39;re curious.</a>)</p>
<p>The goal of the package is to replace the major use case for the <strong>now-deprecated</strong> <code>crypto/elliptic</code> API, which has a hardcoded dependency on the variable-time, large, and complex <code>math/big</code> package. <code>crypto/elliptic</code> is now no more than a compatibility wrapper. Any more advanced uses of <code>crypto/elliptic</code> can switch to <a href="https://filippo.io/nistec">filippo.io/nistec</a> which is an exported version of <code>crypto/internal/nistec</code>, or <a href="https://filippo.io/edwards25519">filippo.io/edwards25519</a> which is an exported version of <code>crypto/internal/edwards25519</code>.</p>
<p>What&#39;s left to do in Go 1.20 then?</p>
<p>First, actually landing the new package, <a href="https://go.dev/cl/398914">which is already submitted</a>! Then, adding and reviewing new tests (including <a href="https://go-review.googlesource.com/c/crypto/+/424274">Wycheproof integration</a> by Roland), which actually revealed there are <a href="https://go-review.googlesource.com/c/go/+/425463">fewer (!!) edge cases than I had originally documented</a>. Finally, reviewing <a href="https://go-review.googlesource.com/c/go/+/423363">the BoringCrypto integration by Russ</a>.</p>
</blockquote>
<p>The package landed successfully, and all the mentioned Go 1.20 work got done. The full <code>crypto/elliptic</code> deprecation will actually have to wait until Go 1.22, because of the <a href="https://go.dev/wiki/Deprecated">deprecation policy</a>:</p>
<blockquote>
<p>If function F1 is being replaced by function F2 and the first release in which F2 is available is Go 1.N, then an official deprecation notice for F1 should not be added until Go 1.N+2. This ensures that Go developers only see F1 as deprecated when all supported Go versions include F2 and they can easily switch.</p>
</blockquote>
<p>The idea is making sure projects don’t have to support both APIs at the same time to keep supporting Go 1.20 while not getting deprecation warnings. I still have <a href="https://go.dev/cl/459977">an outstanding CL</a> to deprecate the very low-level operations (point addition, and custom curves) that are not being replaced by anything in the standard library. (Instead, they should migrate to third-party modules like <code>filippo.io/nistec</code> or <code>filippo.io/edwards25519</code>.)</p>
<p>There was one last-minute API change: we got a <a href="https://go.dev/issue/56052">request on the issue tracker</a> for a <code>PrivateKey</code> interface, to allow using private keys stored on hardware or remote modules, like the popular <a href="https://pkg.go.dev/crypto@go1.19.4#Signer"><code>crypto.Signer</code></a>. We went back and forth a bit on it and discussed it with Russ Cox and concluded that PrivateKey doesn’t need to be an interface, but rather needs to implement one, like <code>ecdsa.PrivateKey</code> implements <code>crypto.Signer</code>. This led to moving the <code>ECDH</code> method from <a href="https://pkg.go.dev/crypto/ecdh@go1.20rc1#Curve">the <code>Curve</code> interface</a> to the <code>PrivateKey</code> type. We don’t define the interface ourselves because we don’t consume it anywhere, but an application that wishes to accept both <code>crypto/ecdh</code>-implemented keys and hardware-backed ones can define something like</p>
<pre><code>type ecdhPrivateKey interface {
	Curve() ecdh.Curve
	ECDH(remote *ecdh.PublicKey) ([]byte, error)
	Equal(x crypto.PrivateKey) bool
	Public() crypto.PublicKey
	PublicKey() *ecdh.PublicKey
}
</code></pre>
<p>thanks to the magic of Go’s implicitly implemented interfaces. This still uses the <code>ecdh.PublicKey</code> concrete type, but values of that type can be easily constructed for hardware keys with <code>Curve.NewPublicKey</code>. What it does not support is other curves, which I am ok with.</p>
<p>Also, this makes the <code>Curve</code> interface solely an abstraction to produce keys on a certain curve, while the ECDH operation itself is a method of the private key, which feels more correct and elegant. Concretely, to implement this we added a private method to <code>Curve</code> which the private types returned by <code>P256()</code>, <code>X25519()</code>, etc. implement, and <code>PrivateKey.ECDH</code> calls. The reason for this is making it clear to the linker and to <a href="https://pkg.go.dev/golang.org/x/vuln/vulncheck">vulncheck</a> that if you only ever call <code>X25519()</code>, the P-256 code is not reachable, so it doesn’t have to be linked into the binary and you don’t need to be notified of any vulnerabilities. <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20rc1:src/crypto/ecdh/ecdh_test.go;l=423-489">We have a test for this.</a> (Yes I love static analysis tests.)</p>
<p>Finally, we implemented support for parsing and marshaling public and private keys in PKIX and PKCS #8 format, respectively. NIST keys don’t have different OIDs to distinguish ECDH keys from ECDSA keys, so they always parse into <code>crypto/ecdsa</code> keys, which then have a new <code>ECDH()</code> method to return the equivalent <code>crypto/ecdh</code> key.</p>
<p>Since it also implements X25519 alongside ECDH over NIST curves, <code>crypto/ecdh</code> will in due time replace <code>golang.org/x/crypto/curve25519</code>, too, finally bringing down the number of 25519 implementations in <code>crypto/...</code> and <code>x/crypto</code> to one!</p>
<p>(<a href="https://go.dev/cl/450816">CL 450816</a>, <a href="https://go.dev/cl/450815">CL 450815</a>, <a href="https://go.dev/cl/450335">CL 450335</a>, <a href="https://go.dev/cl/425463">CL 425463</a>, <a href="https://go.dev/cl/402555">CL 402555</a>, <a href="https://go.dev/cl/398914">CL 398914</a>, <a href="https://go.dev/cl/423363">CL 423363</a>, <a href="https://go.dev/cl/451115">CL 451115</a>)</p>
<h2 id="bigmod-replaces-mathbig">bigmod replaces math/big</h2>
<p><em>happy dance</em></p>
<p><code>math/big</code> is not exposed to attacker-controlled inputs anymore, nor is it used in any repetitive operations that can leak information through timing side-channels. As I explained in the <a href="https://words.filippo.io/dispatches/go1-20/">planning post</a>, this was a major ongoing goal:</p>
<blockquote>
<p><code>math/big</code> is a general-purpose big integer library, it&#39;s not constant time, and it&#39;s full of complex code that while unnecessary for cryptography has <strong>repeatedly led to security vulnerabilities in crypto packages</strong>. While it was a convenient way to bootstrap the Go crypto standard library, <code>math/big</code> does not belong in crypto code in 2022.</p>
</blockquote>
<p>Two packages needed to be ported: <code>crypto/rsa</code> and <code>crypto/ecdsa</code>.</p>
<p>For <code>crypto/rsa</code> we needed a new library to operate on large integers. By declaring key generation out of scope we can focus on implementing a handful of operations modulo a prime number, where essentially only multiplication is performance sensitive.</p>
<p>We had two implementations to choose from, both based on Montgomery multiplication, one from Lúcás Meier and one from Thomas Pornin. I spent some time reading both, and benchmarked them, and Meier’s turned out simpler and a quite a bit faster, despite Pornin’s having <a href="https://www.bearssl.org/bigint.html">amazing documentation</a>. This was probably because Pornin’s was derived from BearSSL’s C implementation, and it tackled key generation, too.</p>
<p>I ended up <a href="https://go-review.googlesource.com/c/go/+/326012/4..30">rewriting a lot of the implementation</a>. I got it to be faster by <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20rc1:src/crypto/internal/bigmod/nat.go;l=431-435">removing bounds checks inside loops</a>, and removed a lot of complexity by dropping a reduction optimization that involved divisions and heuristics. Those two pretty much offset each other in terms of performance. (<a href="https://go.dev/cl/326012">CL 326012</a>)</p>
<p>I also attempted to <a href="https://go.dev/cl/445018">wrap the whole thing in a safer API</a> where each integer has an associated modulus, but that ended up making the code more unwieldy and slower, so I dropped it. (<a href="https://go.dev/cl/445018">CL 445018</a>)</p>
<p>A major concern was what we should do with the <code>big.Int</code>s exposed as part of the <code>rsa.PrivateKey</code> structure. I managed to convince myself that it’s ok to leak the precise bit size of all these values, as they only leak the key size (which is not secret). We then made a short list of <code>big.Int</code> methods that are allowed to be used in cryptographic operations because they are simple, safe, fast, and leak only the bit size of the integer: <code>Bits</code>, <code>SetBits</code>, <code>Bytes</code>, <code>Sign</code>, and <code>BitLen</code>. They now all have a scary comment requiring a security team review to any changes, which are unlikely anyway, and there’s an upcoming static analysis test that ensures only those methods are reachable from relevant cryptography functions. (<a href="https://go.dev/cl/402554">CL 402554</a>)</p>
<p><code>BitLen</code> was actually leaking more than the bit length on platforms that don’t use a hardware instruction, because <code>bits.Len</code> uses a lookup table. I changed that first to a simple loop, which <a href="https://go.dev/issue/57014">turned out to be a performance regression</a>, and then to <a href="https://go.dev/cl/454617">setting all bits after the first set one</a> before calling <code>bits.Len</code>, on Russ Cox’s suggestion. (<a href="https://go.dev/cl/454617">CL 454617</a>)</p>
<p>We expected the performance of this code to be worse than <code>math/big</code>, since the latter has optimized assembly cores. Indeed, it was quite a bit slower. I set a target of &lt; 20% slowdown on amd64 for RSA-2048, since I know of wide-scale deployments out there that depend on its performance. We got under that threshold with three changes:</p>
<ol>
<li>Montgomery multiplications are performed in the “Montgomery domain” which means we operate on <code>x * 2^k mod N</code> instead of <code>x</code>. One way to get there is to shift x left by k (either with the complex code I mentioned removing above, or by doubling k times). Another way is by multiplying by <code>2^k mod N</code>. The latter is faster, but requires computing <code>2^k mod N</code> which is slow. We switched to the latter, and store the precomputed value in a private field of <code>PrivateKey.Precomputed</code>. Here I wished all <code>PrecomputedValues</code> fields were private from the start, by the way, but we made it work. (<a href="https://go.dev/cl/445019">CL 445019</a>, <a href="https://go.dev/cl/445020">CL 445020</a>)</li>
<li>Big integers have variable length, so they have to be allocated at runtime on the heap, and handled by the garbage collector. However, we know the size needed to do RSA-2048 operations! I added a constructor which returns a zero-length backing slice with a fixed pre-allocated capacity, which ends up inlined and allocated on the caller’s stack. In the general case <code>append()</code> will reallocate the backing array, but if the number stays small enough it will use the stack-allocated space, and save a GC allocation. This dropped allocations by 97.5% and I like how it didn’t change any of the semantics of the surrounding code. (<a href="https://go.dev/cl/445021">CL 445021</a>)</li>
<li>Finally, I dropped in an <a href="https://github.com/mmcloughlin/avo">Avo</a>-generated assembly core for amd64 to get across the finish line. (<a href="https://go.dev/cl/452095">CL 452095</a>)</li>
</ol>
<p>Surprisingly enough, even with the assembly core we didn’t match the performance of <code>math/big</code>. I would have expected to exceed it, in fact, because despite operating in constant time, we did not have to waste time for blinding, and could pre-allocate space based on the knowledge of the common RSA key sizes. My theory is that on today’s CPUs with add-with-carry instructions, the lore about 63-bit limbs making Montgomery multiplication faster by making carry handling easier is actually outdated. Even pure Go, unlike C, can do addition chains where the carry is stored in CPU flags thanks to compiler support for <code>bits.Add</code>. I will test this by switching to 64-bit limbs in Go 1.21, which might even make it possible to reuse the <code>math/big</code> assembly cores.</p>
<p>I am pretty happy with the resulting code, and I think it’s pretty robust. Amazinlgy, <strong>it clocks in at just 400 lines of Go</strong>, plus 100 lines of Avo generator. All bugs I introduced while developing were edge cases triggered by certain key sizes, rather than values (which is common in constant-time code), so I wrote a test that tests every operation at every key size up to 4096 bits. It takes fifteen minutes. (<a href="https://go.dev/cl/443195">CL 443195</a>, <a href="https://go.dev/cl/450796">CL 450796</a>)</p>
<p>I am optimistic the code will land at this point, but at the time of the freeze it was not clear whether the performance hit would be tolerable, so I have a revert CL ready to make the life of the Release team easier. The only complaint we got was about a very dramatic slowdown in <code>-race</code> mode, which is curious but we decided not a blocker. (<a href="https://go.dev/cl/452255">CL 452255</a>)</p>
<p>While at it, I deprecated and de-optimized multi-prime keys. These are keys made of more than two primes. They make private key operations a little faster, because they can operate modulo smaller primes, but they require their own <a href="https://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese Remainder Theorem</a> path, you can compromise the security of a key by picking too many primes for the key size, and exactly two projects across GitHub were using them. (<a href="https://go.dev/cl/445017">CL 445017</a>, <a href="https://go.dev/cl/453257">CL 453257</a>, <a href="https://go.dev/cl/459976">CL 459976</a>)</p>
<p>Throughout the process, I used <a href="https://github.com/WillAbides/benchdiff"><code>benchdiff</code></a> against a separate early commit that improved the benchmarks, to have a stable base reference. (<a href="https://go.dev/cl/433476">CL 433476</a>, <a href="https://go.dev/cl/451196">CL 451196</a>)</p>
<p>With <code>crypto/rsa</code> out of the way, the last missing piece was <code>crypto/ecdsa</code>. It turned out to be pretty much a full rewrite, but not a particularly interesting one. The new code uses generics over <code>crypto/internal/nistec</code> types for elliptic curve group operations, and the new RSA backend (extracted into <code>crypto/internal/bigmod</code>) for scalar operations. The unfortunate <code>math/big</code>-based APIs <code>Sign</code> and <code>Verify</code> are now wrappers around the <code>[]byte</code>-based <code>SignASN1</code> and <code>VerifyASN1</code>, which use <a href="https://pkg.go.dev/golang.org/x/crypto/cryptobyte"><code>cryptobyte</code></a>. The <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20rc1:src/crypto/ecdsa/ecdsa.go;l=196-234">scariest part of ECDSA, nonce generation</a> has extensive tests. The old <code>math/big</code> code is technically still there, but only reachable for custom curves, that were never a good idea and are now deprecated. (<a href="https://go.dev/cl/450055">CL 450055</a>, <a href="https://go.dev/cl/353849">CL 353849</a>, <a href="https://go.dev/cl/453256">CL 453256</a>, <a href="https://go.dev/cl/459977">CL 459977</a>)</p>
<p>Now that <code>big.Int</code> is not reachable from (non-deprecated) cryptography anymore, the team is unlikely to consider <code>math/big</code> bugs security vulnerabilities. If you’re using it for cryptography, it’s a good time to consider a rewrite. There’s a warning in that sense in the docs now. (<a href="https://go.dev/cl/455135">CL 455135</a>)</p>
<h2 id="more-elliptic-curves">More elliptic curves</h2>
<p><code>crypto/ed25519</code> now implements Ed25519ctx and Ed25519ph, through <a href="https://pkg.go.dev/crypto/ed25519@go1.20rc1#Options">an <code>Options</code> struct</a> that can be passed to <code>PrivateKey.Sign</code> or the new <code>VerifyWithOptions</code>. Using context strings to domain-separate signatures is very good hygiene, and Ed25519ctx is criminally underused. It doesn’t help that the RFC doesn’t have a test vector for Ed25519ph with a context string, which we should really fix in <a href="https://c2sp.org/CCTV">CCTV</a>. (<a href="https://go.dev/cl/373076">CL 373076</a>, <a href="https://go.dev/cl/404274">CL 404274</a>, <a href="https://go.dev/cl/459975">CL 459975</a>)</p>
<p>The <a href="https://go.dev/cl/420454">rewrite of the edwards25519 scalar field</a> landed and replaced the last bits of unreadable ref10 code with fiat-crypto generated code. As mentioned in the planning post, you can read more on <a href="https://words.filippo.io/dispatches/wide-reduction/">a previous Cryptography Dispatches issue</a>, and there&#39;s an overview of the overall edwards25519 rewrite in <a href="https://go-review.googlesource.com/c/go/+/276272">the CL that landed it after years out-of-tree</a>. (<a href="https://go.dev/cl/420454">CL 420454</a>)</p>
<h2 id="tls-and-x509">TLS and X.509</h2>
<p>I didn’t get to do the pass of TLS work that I called a stretch goal in the planning post, in part because the significant complexity of the bigmod work, but I got to review and participate in some nice work by others, primarily Roland Shoemaker.</p>
<p>First, the new certificate cache shares in-memory representations of certificates amongst TLS connections. <a href="https://words.filippo.io/dispatches/certificate-interning/">We talked about it on Cryptography Dispatches</a>, because it’s really neat. (<a href="https://go.dev/cl/426455">CL 426455</a>, <a href="https://go.dev/cl/426454">CL 426454</a>, <a href="https://go.dev/cl/427155">CL 427155</a>)</p>
<p>A <a href="https://go.dev/issue/43958">very long-running proposal</a> to make TLS clients work in environments like scratch containers that don’t have a root store finally landed on a nice solution. The new <a href="https://pkg.go.dev/crypto/x509@go1.20rc1#SetFallbackRoots">SetFallbackRoots</a> API makes it possible to supply a <code>CertPool</code> to use as a fallback if the system doesn’t have a viable one (or a platform verifier). I am pretty happy with the fallback semantics, as they are less likely to get used a global kludge to override the default verification process. We plan to provide a package in its own x/crypto submodule that calls it automatically, so most users will never use the API directly but will just import that package and keep it up to date. There’s already <a href="https://go.dev/issue/57178">a follow-up conversation</a> about how to express constraints like those imposed by the Mozilla root program on TrustCor in a <code>CertPool</code>. Root stores and how Go handles them are a deep topic that might deserve a dedicated issue soon. (<a href="https://go.dev/cl/449235">CL 449235</a>)</p>
<p>TLS handshakes now return a <code>CertificateVerificationError</code> if they fail because of, well, certificate verification. The nice thing about Go errors being values is that you can add fields to them. Here the error carries the certificates that didn’t verify, that we named loudly <code>UnverifiedCertificates</code> so no one ends up trusting them by mistake. 🤞 (<a href="https://go.dev/cl/449336">CL 449336</a>)</p>
<p>RFC 8422, Section 5.1.2, makes the Supported Point Formats optional, and a missing extension means uncompressed points are supported, which are the only allowed option in these TLS 1.3 days. Since everyone sends the extension for backwards compatibility, we didn’t notice we were actually requiring it. My bad. Fixed and backported to be a nice ecosystem player and not force everyone else to keep sending the extension to make Go happy. This would maybe have been caught by BoGo, a reminder of prioritizing <a href="https://go.dev/issue/51434">integrating it</a>. It might also be the second interoperability issue in the TLS 1.3 implementation since its inception, which is a stat I am pretty happy about. (<a href="https://go.dev/cl/425295">CL 425295</a>)</p>
<p><code>crypto/x509</code> got a couple follow-up changes to previous work. First, <code>pkix.Name</code> is a pretty unfortunate type, because <a href="https://go.dev/issue/40876">it’s at best an approximation of an X.509 distinguished name</a>. This caused us pain before. The new <code>CreateRevocationList</code> function was using the issuer’s Subject field, which is a <code>pkix.Name</code>, causing the CRL not to match up against some issuers that have weird DNs. It now uses <code>RawSubject</code>, which we have all over the place specifically because of this. The whole <code>crypto/x509/pkix</code> package is a bit unfortunate, to be honest. Second, <a href="https://go.dev/cl/428636">CL 428636</a> made Go reject duplicate extensions in certificates and CSRs, but mistakenly also disallowed duplicate CSRs <em>attributes</em>. Now fixed. This probably should have been backported and wasn’t, maybe because it was fixed without opening an issue, which is how we keep track of these things, so <a href="https://go.dev/issue/57556">I’m opening a backport now</a>. (<a href="https://go.dev/cl/418834">CL 418834</a>, <a href="https://go.dev/cl/428636">CL 428636</a>, <a href="https://go.dev/cl/460236">CL 460236</a>)</p>
<p>Speaking of <code>crypto/x509</code>, we have now formalized in the package docs what was already informal policy: of the monstrous sprawl that is X.509, <code>crypto/x509</code> targets a profile that’s compatible with the WebPKI. That is, if it’s not needed to correctly and securely interpret publicly trusted certificates, we are likely not to implement it. This makes some folks sad, like those cursed to deal with <a href="https://en.wikipedia.org/wiki/Trusted_Platform_Module">TPMs</a> or <a href="https://en.wikipedia.org/wiki/S/MIME">S/MIME</a>, and I feel for them, but regrettably it’s the only way to <a href="https://words.filippo.io/dispatches/openssl-punycode/">keep the implementation sane</a>. (<a href="https://go.dev/cl/266541">CL 266541</a>)</p>
<h2 id="flashes">Flashes</h2>
<p>Some more interesting stuff that happened around Go and cryptography, mostly not by me.</p>
<p>Nothing uses the global <code>math/rand.Seed</code> anymore. This is related to <a href="https://go.dev/issue/54880">work to make it possible to improve <code>math/rand</code></a>, which I am hoping to nudge towards using a cryptographically secure PRNG by default. I got ChaCha8 to take less than double the current insecure PRNG. Probably writing an issue about this at some point. (<a href="https://go.dev/cl/445395">CL 445395</a>)</p>
<p>As GODEBUG flags (those we used to allow opt-in and opt-out of various cryptography changes) are getting <a href="https://go.dev/issue/56986">formalized into an official backwards-compatibility</a>, Russ made an efficient API to make it affordable to check them in hot code paths. Case in point, <code>GODEBUG=x509sha1=1</code> is now checked at verification time, rather than at startup, so applications can drop a <code>os.Setenv</code> in <code>main()</code>. Disabling verification of SHA-1 certificates is definitely the change that got the most pushback of all the ones I’ve done, mostly from Kubernetes. (<a href="https://go.dev/cl/449504">CL 449504</a>, <a href="https://go.dev/cl/445496">CL 445496</a>)</p>
<p>The RSA-OAEP encryption algorithm uses a hash for two things: to hash the domain-separation label, and to generate an XOR mask. For <em>some reason</em> those two can be different hashes. No, I don’t know why. Anyway some systems actually do use different hashes for those things. No, <em>I don’t know why</em>. I pushed back some on supporting this in Go, but eventually caved on adding decryption-side support, so Go programs can decrypt ciphertexts generated by other systems. The nice thing about doing it decryption-only is that we could just sneak a field into <code>OAEPOptions</code> which is passed to the <code>PrivateKey.Decrypt</code> method (for <code>crypto.Decrypter</code> support), and didn’t have to make new <code>DecryptOAEP</code>/<code>EncryptOAEP</code> functions. So now there’s <code>OAEPOptions.Hash</code> and <code>OAEPOptions.MGF1Hash</code>. Sure, why not. (<a href="https://go.dev/cl/418874">CL 418874</a>)</p>
<p>Something we do a lot in cryptography is XOR a pair of byte slices (like a key stream and a plaintext). The optimized implementation is now exposed in <code>crypto/subtle</code>, and should be reusable across a number of packages. This might go well with the cycle of work on symmetric ciphers I have planned. (<a href="https://go.dev/cl/421435">CL 421435</a>)</p>
<p>Speaking of subtle, Russ renamed the package with the functions to enforce aliasing rules around crypto packages from <code>crypto/internal/subtle</code> to <code>crypto/internal/alias</code>. Not sure why I called it <code>subtle</code> in the first place. Probably lack of imagination. (<a href="https://go.dev/cl/424194">CL 424194</a>)</p>
<p>There’s an internal package called <code>internal/testenv</code> which is very useful to restrict tests based on the environment, for example if a builder doesn’t have network. It now has a <code>SkipIfOptimizationOff</code> function, which is great for <a href="https://cs.opensource.google/go/go/+/refs/tags/go1.20rc1:src/crypto/internal/nistec/nistec_test.go;l=17">the inlining tests</a> I scattered around since I figured out <a href="https://words.filippo.io/efficient-go-apis-with-the-inliner/">how to use the inliner to save allocations</a>. (<a href="https://go.dev/cl/422038">CL 422038</a>)</p>
<p><code>crypto/sha512</code> uses the hardware ARM64 SHA-512 instructions when available now, making it 3-4x faster. Given there’s no <a href="https://github.com/mmcloughlin/avo">Avo</a> for ARM64 assembly, this CL’s use of macros and comments was as close as it gets to <a href="https://go.dev/wiki/AssemblyPolicy">AssemblyPolicy</a> compliance. (<a href="https://go.dev/cl/180257">CL 180257</a>)</p>
<p>Speaking of <code>crypto/sha512</code>, all the SHA-1 and SHA-2 packages are now a little faster for small messages, because they make one <code>Write</code> call instead of two. The change being identical for all three packages reminds me that we might want to refactor all <a href="https://en.wikipedia.org/wiki/Merkle%E2%80%93Damg%C3%A5rd_construction">Merkle–Damgård hashes</a> to use shared code. (<a href="https://go.dev/cl/436917">CL 436917</a>)</p>
<p>Since Go 1.19, Go+BoringCrypto is behind a (permanent) <code>GOEXPERIMENT</code> flag rather than a fork, for ease of maintenance reasons. (It was tedious to resolve conflicts every time we touched anything.) In Go 1.20, the module was updated, and it now supports arm64 and 4096-bit RSA keys. RSA PSS signature salt handling was fixed, too, and the clever <code>crypto/internal/boring/bcache</code> package, which works with the GC to keep around the C counter-parts of some Go key values, is now type-safe thanks to generics. (<a href="https://go.dev/cl/423357">CL 423357</a>, <a href="https://go.dev/cl/423362">CL 423362</a>, <a href="https://go.dev/cl/426659">CL 426659</a>, <a href="https://go.dev/cl/447655">CL 447655</a>, <a href="https://go.dev/cl/451656">CL 451656</a>)</p>
<p>The crypto packages use a lot of new stuff added elsewhere, like <code>sync/atomic</code> types (<a href="https://go.dev/cl/428477">CL 428477</a>, <a href="https://go.dev/cl/426088">CL 426088</a>, <a href="https://go.dev/cl/426087">CL 426087</a>, <a href="https://go.dev/cl/422296">CL 422296</a>), <code>fmt.Appendf</code> (<a href="https://go.dev/cl/435696">CL 435696</a>), <code>bytes.Clone</code> (<a href="https://go.dev/cl/435279">CL 435279</a>), <code>unsafe.{Slice,SliceData,StringData}</code> (<a href="https://go.dev/cl/435285">CL 435285</a>, <a href="https://go.dev/cl/428154">CL 428154</a>), and <code>encoding/binary</code> append functions (<a href="https://go.dev/cl/431035">CL 431035</a>).</p>
<p>Finally, <code>go vet</code> just got better at catching <a href="https://go.dev/doc/faq#closures_and_goroutines">the common mistake of reusing the loop variable</a> which has <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1619047">caused a Let’s Encrypt incident</a>, in preparation for <a href="https://github.com/golang/go/discussions/56010">the exceptional language change</a> that should solve this problem once and for all. I mention it amongst crypto stuff because it caught a mistake in one of my new RSA tests. Yay for static analysis! (<a href="https://go.dev/cl/450738">CL 450738</a>)</p>
<h2 id="the-picture">The picture</h2>
<p>Happy new year! Rome goes hard with fireworks.</p>
<p><img src="https://words.filippo.io/content/images/2023/01/IMG_9975.jpeg" alt="Fireworks exploding low in the sky, against a smoky background, with a tree barely visible in the mist." loading="lazy"/></p>
<p>It was an exciting cycle. If you’re interested in this work, look out for a Go 1.21 planning email in the next month or so, and if your company would like to support me, while getting unlimited access to advice and the <a href="https://words.filippo.io/dispatches/reciprocal/">reciprocal value of talking to maintainers</a>, reply to this email and let’s talk about a retainer contract. You can also <a href="https://abyssdomain.expert/@filippo">follow me on Mastodon</a>, or reply with any feedback. _o/</p>


<!--kg-card-end: markdown-->
        </section>
    </article></div>
  </body>
</html>
