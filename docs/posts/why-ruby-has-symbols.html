<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dmitrytsepelev.dev/why-has-ruby-symbols">Original</a>
    <h1>Why Ruby Has Symbols</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Many people who come to Ruby start using symbols on their first day. Come on, <a href="https://guides.rubyonrails.org/getting_started.html#database-migrations">Getting Started with Rails</a> shows you symbols in the first migration you generate! From the first glance, symbols look like strings (<code>:hi</code> versus <code>&#34;hi&#34;</code>) and can be converted back and forth. The naive explanation of their difference is that strings are used to represent some data (e.g., constant or variable values), while symbols usually appear as a part of the code (e.g., arguments of method calls). However, why do we have both? Let‚Äôs figure that out!</p>

<h2 id="how-strings-and-symbols-are-used-in-ruby">How strings and symbols are used in Ruby?</h2>

<p>Imagine that you work on a Rails application and want to add users to your data model. Here is the migration:</p>

<div><div><pre><code><span>class</span> <span>CreateUsers</span> <span>&lt;</span> <span>ActiveRecord</span><span>::</span><span>Migration</span><span>[</span><span>7.0</span><span>]</span>
  <span>def</span> <span>change</span>
    <span>create_table</span> <span>:users</span> <span>do</span> <span>|</span><span>t</span><span>|</span>
      <span>t</span><span>.</span><span>string</span> <span>:email</span>
      <span>t</span><span>.</span><span>text</span> <span>:password</span>

      <span>t</span><span>.</span><span>timestamps</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>When table schema is in place, we need to create the corresponding model:</p>

<div><div><pre><code><span>class</span> <span>Article</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span>validates</span> <span>:email</span><span>,</span> <span>:password</span><span>,</span> <span>presence: </span><span>true</span>
  <span>encrypts</span> <span>:password</span>
<span>end</span>
</code></pre></div></div>

<p>Later we will create a new controller and write specs (right? üôÇ), but let‚Äôs take a break from coding here. How many times <code>:email</code> and <code>:password</code> were used already? Two times <code>:email</code> and three times <code>:password</code>, and there will be more in the real application!</p>

<p>However, let‚Äôs think about the values that are going to be stored in the <code>email</code> column. Each user has a unique email and these emails <em>never appear</em> in the codebase, they can only be initialized in memory when either submitted by user or read from the database.</p>

<p>Looks like both Ruby interpreter and virtual machine can get some use of the fact that symbols and strings are used for different purposes. Let‚Äôs find out how our code is executed and figure it out!</p>

<h2 id="how-ruby-executes-our-code">How Ruby executes our code</h2>

<p>When Ruby program is run, it should be compiled to the bytecode first. <em>Virtual machine</em> (usually referred as <em>VM</em>) knows how to execute the bytecode on the concrete operating system.</p>

<blockquote>
  <p>Compilation step was added in Ruby 1.9</p>
</blockquote>

<p>First of all, interpreter <em>parses</em> your program and gets an Abstract Syntax Tree (usually referred as AST) containing tokens that appear in the source code. I‚Äôm going to use a gem called <a href="https://github.com/whitequark/parser">parser</a> to examine an AST of the <code>Article</code> class along with it‚Äôs usage:</p>

<div><div><pre><code><span>require</span> <span>&#39;parser/current&#39;</span>

<span>Parser</span><span>::</span><span>CurrentRuby</span><span>.</span><span>parse</span> <span>&lt;&lt;~</span><span>RUBY</span><span>
  class Article &lt; ApplicationRecord
    validates :email, :password, presence: true
    encrypts :password
  end

  Article.find(id).password
</span><span>RUBY</span>
</code></pre></div></div>

<p>Here is an AST we get:</p>

<div><div><pre><code><span>s</span><span>(</span><span>:begin</span><span>,</span>
  <span>s</span><span>(</span><span>:class</span><span>,</span>
    <span>s</span><span>(</span><span>:const</span><span>,</span> <span>nil</span><span>,</span> <span>:Article</span><span>),</span>
    <span>s</span><span>(</span><span>:const</span><span>,</span> <span>nil</span><span>,</span> <span>:ApplicationRecord</span><span>),</span>
    <span>s</span><span>(</span><span>:begin</span><span>,</span>
      <span>s</span><span>(</span><span>:send</span><span>,</span> <span>nil</span><span>,</span> <span>:validates</span><span>,</span>
        <span>s</span><span>(</span><span>:sym</span><span>,</span> <span>:email</span><span>),</span>
        <span>s</span><span>(</span><span>:sym</span><span>,</span> <span>:password</span><span>),</span>
        <span>s</span><span>(</span><span>:hash</span><span>,</span>
          <span>s</span><span>(</span><span>:pair</span><span>,</span>
            <span>s</span><span>(</span><span>:sym</span><span>,</span> <span>:presence</span><span>),</span>
            <span>s</span><span>(</span><span>:true</span><span>)))),</span>
      <span>s</span><span>(</span><span>:send</span><span>,</span> <span>nil</span><span>,</span> <span>:encrypts</span><span>,</span>
        <span>s</span><span>(</span><span>:sym</span><span>,</span> <span>:password</span><span>)))),</span>
  <span>s</span><span>(</span><span>:send</span><span>,</span>
    <span>s</span><span>(</span><span>:send</span><span>,</span>
      <span>s</span><span>(</span><span>:const</span><span>,</span> <span>nil</span><span>,</span> <span>:Article</span><span>),</span> <span>:find</span><span>,</span>
      <span>s</span><span>(</span><span>:send</span><span>,</span> <span>nil</span><span>,</span> <span>:id</span><span>)),</span> <span>:password</span><span>))</span>
</code></pre></div></div>

<p>Please note, that token <code>:password</code> is used in different contexts: as an argument for two methods (<code>validates</code> and <code>encrypts</code>) and as a method name (<code>.password</code>).</p>

<blockquote>
  <p>According to <a href="https://en.wikipedia.org/wiki/Lexical_analysis#Token">Wiki</a>, token is a ‚Äúlexical token or simply token is a string with an assigned and thus identified meaning. It is structured as a pair consisting of a token name and an optional token value‚Äù</p>
</blockquote>

<p>When AST is built, it is validated to make sure it makes sense and converted it to the bytecode. Bytecode is a language that can be executed by the Virtual Machine on any hardware you want.</p>

<p>This is how we can see the bytecode representation for the Ruby source:</p>

<div><div><pre><code><span>code</span> <span>=</span> <span>&lt;&lt;~</span><span>RUBY</span><span>
  class Article &lt; ApplicationRecord
    validates :email, :password, presence: true
    encrypts :password
  end

  Article.find(id).password
</span><span>RUBY</span>

<span>RubyVM</span><span>::</span><span>InstructionSequence</span><span>.</span><span>disasm</span><span>(</span><span>RubyVM</span><span>::</span><span>InstructionSequence</span><span>.</span><span>compile</span><span>(</span><span>code</span><span>))</span>
</code></pre></div></div>

<p>‚Ä¶and here is the bytecode itself:</p>

<div><div><pre><code><span>==</span> <span>disasm: </span><span>#&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(6,25)&gt; (catch: FALSE)</span>
<span>0000</span> <span>putspecialobject</span>                       <span>3</span>                         <span>(</span>   <span>1</span><span>)[</span><span>Li</span><span>]</span>
<span>0002</span> <span>opt_getinlinecache</span>                     <span>11</span><span>,</span> <span>&lt;</span><span>is</span><span>:</span><span>0</span><span>&gt;</span>
<span>0005</span> <span>putobject</span>                              <span>true</span>
<span>0007</span> <span>getconstant</span>                            <span>:ApplicationRecord</span>
<span>000</span><span>9</span> <span>opt_setinlinecache</span>                     <span>&lt;</span><span>is</span><span>:</span><span>0</span><span>&gt;</span>
<span>0011</span> <span>defineclass</span>                            <span>:Article</span><span>,</span> <span>&lt;</span><span>class</span><span>:Article</span><span>&gt;</span><span>,</span> <span>16</span>
<span>0015</span> <span>pop</span>
<span>0016</span> <span>opt_getinlinecache</span>                     <span>25</span><span>,</span> <span>&lt;</span><span>is</span><span>:</span><span>1</span><span>&gt;</span>                <span>(</span>   <span>6</span><span>)[</span><span>Li</span><span>]</span>
<span>001</span><span>9</span> <span>putobject</span>                              <span>true</span>
<span>0021</span> <span>getconstant</span>                            <span>:Article</span>
<span>0023</span> <span>opt_setinlinecache</span>                     <span>&lt;</span><span>is</span><span>:</span><span>1</span><span>&gt;</span>
<span>0025</span> <span>putself</span>
<span>0026</span> <span>opt_send_without_block</span>                 <span>&lt;</span><span>calldata!mid</span><span>:id</span><span>,</span> <span>argc</span><span>:</span><span>0</span><span>,</span> <span>FCALL</span><span>|</span><span>VCALL</span><span>|</span><span>ARGS_SIMPLE</span><span>&gt;</span>
<span>002</span><span>8</span> <span>opt_send_without_block</span>                 <span>&lt;</span><span>calldata!mid</span><span>:find</span><span>,</span> <span>argc</span><span>:</span><span>1</span><span>,</span> <span>ARGS_SIMPLE</span><span>&gt;</span>
<span>0030</span> <span>opt_send_without_block</span>                 <span>&lt;</span><span>calldata!mid</span><span>:password</span><span>,</span> <span>argc</span><span>:</span><span>0</span><span>,</span> <span>ARGS_SIMPLE</span><span>&gt;</span>
<span>0032</span> <span>leave</span>

<span>==</span> <span>disasm: </span><span>#&lt;ISeq:&lt;class:Article&gt;@&lt;compiled&gt;:1 (1,0)-(4,3)&gt; (catch: FALSE)</span>
<span>0000</span> <span>putself</span>                                                          <span>(</span>   <span>2</span><span>)[</span><span>LiCl</span><span>]</span>
<span>0001</span> <span>putobject</span>                              <span>:email</span>
<span>0003</span> <span>putobject</span>                              <span>:password</span>
<span>0005</span> <span>putobject</span>                              <span>true</span>
<span>0007</span> <span>opt_send_without_block</span>                 <span>&lt;</span><span>calldata!mid</span><span>:validates</span><span>,</span> <span>argc</span><span>:</span><span>3</span><span>,</span> <span>kw</span><span>:[</span><span>presence</span><span>],</span> <span>FCALL</span><span>|</span><span>KWARG</span><span>&gt;</span>
<span>000</span><span>9</span> <span>pop</span>
<span>0010</span> <span>putself</span>                                                          <span>(</span>   <span>3</span><span>)[</span><span>Li</span><span>]</span>
<span>0011</span> <span>putobject</span>                              <span>:password</span>
<span>0013</span> <span>opt_send_without_block</span>                 <span>&lt;</span><span>calldata!mid</span><span>:encrypts</span><span>,</span> <span>argc</span><span>:</span><span>1</span><span>,</span> <span>FCALL</span><span>|</span><span>ARGS_SIMPLE</span><span>&gt;</span>
<span>0015</span> <span>leave</span>                                                            <span>(</span>   <span>4</span><span>)[</span><span>En</span><span>]</span>
</code></pre></div></div>

<p>There are two sections starting with <code>== disasm</code>. Each section represents a single <em>lexical scope</em>: one for the top‚Äìlevel code and one for the code inside class. Each line is a single bytecode instruction. For instance <code>putobject</code> adds it‚Äôs argument to the <em>stack</em>, <code>opt_send_without_block</code> handles sending a message to another object, <code>putself</code> changes the <code>self</code> value, etc.</p>

<blockquote>
  <p>Technically bytecode (or, more precisely, ‚Äúcode that VM executes‚Äù) instruction can take more than one byte but that‚Äôs one of the popular formats.</p>
</blockquote>

<p>Why not use the AST itself to execute the program? It is possible, but will perform worse: interpreter would have to keep the huge object graph in the memory and navigate through it each time it needs to execute something. In opposite, bytecode consists of simple instructions that are so small that can even be kept in the processor cache.</p>

<h2 id="how-ruby-vm-stores-symbols">How Ruby VM stores symbols</h2>

<p>We know that some tokens are used many times and never change, can we somehow avoid storing all of them in the memory? This is exactly what Ruby does: each token is stored in the hash table and represented as an ID, which takes <em>way less memory</em> to store.</p>

<blockquote>
  <p>Hash table is the most important data structure for building programming languages</p>
</blockquote>

<p>When symbol is used, Ruby looks for that symbol in the hash table (the read operation has O(1) complexity), and adds it to the table if needed. Let‚Äôs see if symbols consume less memory using <a href="https://github.com/michaelherold/benchmark-memory">benchmark/memory</a> gem:</p>

<div><div><pre><code><span>require</span> <span>&#34;benchmark/memory&#34;</span>

<span>Benchmark</span><span>.</span><span>memory</span> <span>do</span> <span>|</span><span>x</span><span>|</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;strings&#34;</span><span>)</span> <span>do</span>
    <span>100_000</span><span>.</span><span>times</span> <span>{</span> <span>&#34;string&#34;</span> <span>}</span>
  <span>end</span>

  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;symbols&#34;</span><span>)</span> <span>do</span>
    <span>100_000</span><span>.</span><span>times</span> <span>{</span> <span>:symbol</span> <span>}</span>
  <span>end</span>

  <span>x</span><span>.</span><span>compare!</span>
<span>end</span>
</code></pre></div></div>

<p>The plan was to initiate the same string and the same symbol 100 000 times and count allocations. Turns out that symbol benchmark allocated nothing, because <code>:symbol</code> was allocated during the interpretation as we expected:</p>

<div><div><pre><code>Calculating <span>-------------------------------------</span>
             strings     4.000M memsize <span>(</span>     0.000  retained<span>)</span>
                       100.000k objects <span>(</span>     0.000  retained<span>)</span>
                         1.000  strings <span>(</span>     0.000  retained<span>)</span>
             symbols     0.000  memsize <span>(</span>     0.000  retained<span>)</span>
                         0.000  objects <span>(</span>     0.000  retained<span>)</span>
                         0.000  strings <span>(</span>     0.000  retained<span>)</span>

Comparison:
             symbols:          0 allocated
             strings:    4000000 allocated
</code></pre></div></div>

<p>It‚Äôs easy to make sure that the symbol was allocated only once, while we got a new string during the each iteration. Let‚Äôs compare <code>object_id</code>:</p>

<div><div><pre><code><span>5</span><span>.</span><span>times</span><span>.</span><span>map</span> <span>{</span> <span>&#34;string&#34;</span><span>.</span><span>object_id</span> <span>}</span>
<span># =&gt; [13700, 13720, 13740, 13760, 13780]</span>

<span>5</span><span>.</span><span>times</span><span>.</span><span>map</span> <span>{</span> <span>:symbol</span><span>.</span><span>object_id</span> <span>}</span>
<span># =&gt; [921948, 921948, 921948, 921948, 921948]</span>
</code></pre></div></div>

<p>Unfortunately it‚Äôs impossible to access the symbols table from the Ruby code (because Ruby does not expose such API). However, we can see a <a href="https://github.com/ruby/ruby/blob/d92f09a5eea009fa28cd046e9d0eb698e3d94c5c/string.c#L11512">list representation</a> of symbols (I‚Äôm taking only 10 because the list is rather huge):</p>

<div><div><pre><code><span>Symbol</span><span>.</span><span>all_symbols</span><span>.</span><span>sample</span><span>(</span><span>10</span><span>)</span>

<span># =&gt;</span>
<span>#   [:binding_irb,</span>
<span>#   :@errors,</span>
<span>#   :backtrace_locations,</span>
<span>#   :on_string_embexpr,</span>
<span>#   :details_for_unwind,</span>
<span>#   :build_details_for_unwind,</span>
<span>#   :_enumerable_filter_map,</span>
<span>#   :on_const_path_ref,</span>
<span>#   :confirm_multiline_termination,</span>
<span>#   :conflicting]</span>
</code></pre></div></div>

<p>Symbols can be added to the table in the runtime:</p>

<div><div><pre><code><span>Symbol</span><span>.</span><span>all_symbols</span><span>.</span><span>last</span> <span># =&gt; :las</span>
<span>:my_new_symbol</span>
<span>Symbol</span><span>.</span><span>all_symbols</span><span>.</span><span>last</span> <span># =&gt; :my_new_symbol</span>
</code></pre></div></div>

<p>Why I didn‚Äôt do something like <code>Symbol.all_symbols.include?(:my_new_symbol)</code>? The reason is that such a call will always return <code>true</code>: <code>:my_new_symbol</code> will be initialized and added to the table <em>before</em> the <code>.include?</code> call. At this moment experienced functional programmers should feel disgusted because this sounds like something not pure at all üôÇ</p>

<blockquote>
  <p>For more details read ‚ÄúUnderstanding how symbols differ from strings‚Äù chapter in <a href="https://www.amazon.com/Polished-Ruby-Programming-maintainable-high-performance-ebook/dp/B093TH9P7C">Polished Ruby Programming</a> by Jeremy Evans</p>
</blockquote>

<p>Let‚Äôs think why the list of symbols was not empty when we accessed it for first time. Firstly, Ruby standard library contains some symbols which are already loaded. Secondly, if we look at the symbol list closer we might see some old friends like <code>:sort</code>, which is the name of the method for sorting enumerables. Turns out that tokens representing constants, variable names, method names, class names and so on are stored <em>in the same table</em>!</p>

<p>When we called <code>Symbol.all_symbols.last</code> for the first time, it returned <code>:las</code>. If we look at the last symbols in the list we‚Äôll notice <code>:la</code> and <code>:las</code>. What is it? Looks like it is the way how hash tables are implemented: Ruby builds a tree using chars as nodes (starting from two first nodes, because otherwise the tree will have 27 nodes on the first level), and symbols become are leafs.</p>

<blockquote>
  <p>Garbage collection removes unused data from memory, so we should not worry about it. When trees were high and computers were huge, people did it manually. Well, some people still do it manually when dealing with languages like C.</p>
</blockquote>

<p><em>Garbage Collector</em> (usually referred as <em>GC</em>) can collect unused strings, but what about symbols? <a href="https://bugs.ruby-lang.org/issues/9634">Ruby 2.2.0</a> introduced two types of symbols: ones that are used to create dynamic methods/instance variables/constants are <em>immortal</em> and never collected; all others are <em>mortal</em> and available for the collection.</p>

<p><img src="https://dmitrytsepelev.dev/assets/kids.jpg" alt="a story about manual GC"/></p>

<h2 id="interning-strings">Interning strings</h2>

<p>The approach when strings are stored in the hash table and referred as integer IDs is called <em>string interning</em>. When VM needs to compare two different string objects in the memory, it has to do it byte by byte, which is not very performanct. String interning is a technique when some (or all) strings are stored in the hash table and string IDs are used instead of them. Of course, there is a guarantee that all table values are unique. Comparsion becomes dead simple: we just need to compare two integers.</p>

<blockquote>
  <p>This section is heavily inspired by ‚ÄúInterning strings‚Äù chapter from <a href="https://craftinginterpreters.com">Crafting Interpreters</a> by Robert Nystrom, check it out if you want to dig into language implementation details. Well, I‚Äôd say check it out anyway‚Äîit‚Äôs just awesome.</p>
</blockquote>

<p>Different languages use string interning in different proportions: e.g., Lua interns all strings, Java interns constants, Ruby, as we know, has symbols. By the way, Ruby can <em>freeze</em> strings which makes them immutable, but it does not make them interned to make GC able to collect them.</p>

<p>Is there a special bytecode operator that makes string interned? No, because it‚Äôs just one of possible optimizations which happens <em>as a part</em> of other higher‚Äìlevel operations. For instance, <code># 0001 putobject :email</code> is likely going to add <code>:email</code> to the symbols table if it‚Äôs not there yet.</p>

<p>Let‚Äôs open up the source code of Ruby itself and check out how it works. Symbol allocation is happenning in the <code>rb_id_attrset</code> function of <a href="https://github.com/ruby/ruby/blob/master/symbol.c#L113">symbol.c</a>, which can called both from compilation and interpretation stages:</p>

<div><div><pre><code><span>ID</span>
<span>rb_id_attrset</span><span>(</span><span>ID</span> <span>id</span><span>)</span>
<span>{</span>
    <span>VALUE</span> <span>str</span><span>,</span> <span>sym</span><span>;</span>
    <span>int</span> <span>scope</span><span>;</span>

    <span>if</span> <span>(</span><span>!</span><span>is_notop_id</span><span>(</span><span>id</span><span>))</span> <span>{</span>
	<span>switch</span> <span>(</span><span>id</span><span>)</span> <span>{</span>
	  <span>case</span> <span>tAREF</span><span>:</span> <span>case</span> <span>tASET</span><span>:</span>
	    <span>return</span> <span>tASET</span><span>;</span>	<span>/* only exception */</span>
	<span>}</span>
	<span>rb_name_error</span><span>(</span><span>id</span><span>,</span> <span>&#34;cannot make operator ID :%&#34;</span><span>PRIsVALUE</span><span>&#34; attrset&#34;</span><span>,</span>
		      <span>rb_id2str</span><span>(</span><span>id</span><span>));</span>
    <span>}</span>
    <span>else</span> <span>{</span>
	<span>scope</span> <span>=</span> <span>id_type</span><span>(</span><span>id</span><span>);</span>
	<span>switch</span> <span>(</span><span>scope</span><span>)</span> <span>{</span>
	  <span>case</span> <span>ID_LOCAL</span><span>:</span> <span>case</span> <span>ID_INSTANCE</span><span>:</span> <span>case</span> <span>ID_GLOBAL</span><span>:</span>
	  <span>case</span> <span>ID_CONST</span><span>:</span> <span>case</span> <span>ID_CLASS</span><span>:</span> <span>case</span> <span>ID_JUNK</span><span>:</span>
	    <span>break</span><span>;</span>
	  <span>case</span> <span>ID_ATTRSET</span><span>:</span>
	    <span>return</span> <span>id</span><span>;</span>
	  <span>default:</span>
	    <span>{</span>
		<span>if</span> <span>((</span><span>str</span> <span>=</span> <span>lookup_id_str</span><span>(</span><span>id</span><span>))</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
		    <span>rb_name_error</span><span>(</span><span>id</span><span>,</span> <span>&#34;cannot make unknown type ID %d:%&#34;</span><span>PRIsVALUE</span><span>&#34; attrset&#34;</span><span>,</span>
				  <span>scope</span><span>,</span> <span>str</span><span>);</span>
		<span>}</span>
		<span>else</span> <span>{</span>
		    <span>rb_name_error_str</span><span>(</span><span>Qnil</span><span>,</span> <span>&#34;cannot make unknown type anonymous ID %d:%&#34;</span><span>PRIxVALUE</span><span>&#34; attrset&#34;</span><span>,</span>
				      <span>scope</span><span>,</span> <span>(</span><span>VALUE</span><span>)</span><span>id</span><span>);</span>
		<span>}</span>
	    <span>}</span>
	<span>}</span>
    <span>}</span>

    <span>/* make new symbol and ID */</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>str</span> <span>=</span> <span>lookup_id_str</span><span>(</span><span>id</span><span>)))</span> <span>{</span>
	<span>static</span> <span>const</span> <span>char</span> <span>id_types</span><span>[][</span><span>8</span><span>]</span> <span>=</span> <span>{</span>
	    <span>&#34;local&#34;</span><span>,</span>
	    <span>&#34;instance&#34;</span><span>,</span>
	    <span>&#34;invalid&#34;</span><span>,</span>
	    <span>&#34;global&#34;</span><span>,</span>
	    <span>&#34;attrset&#34;</span><span>,</span>
	    <span>&#34;const&#34;</span><span>,</span>
	    <span>&#34;class&#34;</span><span>,</span>
	    <span>&#34;junk&#34;</span><span>,</span>
	<span>};</span>
	<span>rb_name_error</span><span>(</span><span>id</span><span>,</span> <span>&#34;cannot make anonymous %.*s ID %&#34;</span><span>PRIxVALUE</span><span>&#34; attrset&#34;</span><span>,</span>
		      <span>(</span><span>int</span><span>)</span><span>sizeof</span><span>(</span><span>id_types</span><span>[</span><span>0</span><span>]),</span> <span>id_types</span><span>[</span><span>scope</span><span>],</span> <span>(</span><span>VALUE</span><span>)</span><span>id</span><span>);</span>
    <span>}</span>
    <span>str</span> <span>=</span> <span>rb_str_dup</span><span>(</span><span>str</span><span>);</span>
    <span>rb_str_cat</span><span>(</span><span>str</span><span>,</span> <span>&#34;=&#34;</span><span>,</span> <span>1</span><span>);</span>
    <span>sym</span> <span>=</span> <span>lookup_str_sym</span><span>(</span><span>str</span><span>);</span>
    <span>id</span> <span>=</span> <span>sym</span> <span>?</span> <span>rb_sym2id</span><span>(</span><span>sym</span><span>)</span> <span>:</span> <span>intern_str</span><span>(</span><span>str</span><span>,</span> <span>1</span><span>);</span>
    <span>return</span> <span>id</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<hr/>

<p>That‚Äôs all for today, let‚Äôs summarize what we found here.</p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th>String</th>
      <th>Symbol</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Allocation</td>
      <td>allocate memory for each *</td>
      <td>never duplicated</td>
    </tr>
    <tr>
      <td>Comparsion</td>
      <td>byte by byte, slow</td>
      <td>integers in the runtime, fast</td>
    </tr>
    <tr>
      <td>GC</td>
      <td>can be collected</td>
      <td>only mortal</td>
    </tr>
  </tbody>
</table>

<p><sup>*</sup> There is another optimization for strings that makes a copy of a string only when it‚Äôs modified (it is called Copy on Write or CoW):</p>

<p>Here‚Äôs the great example of how CoW works by <a href="https://www.reddit.com/user/Kernigh/">Kernigh</a> (see the whole <a href="https://www.reddit.com/r/ruby/comments/twqz89/why_ruby_has_symbols/i3piyiv/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3">response</a>):</p>

<div><div><pre><code><span>require</span> <span>&#39;objspace&#39;</span>
<span>GC</span><span>.</span><span>disable</span>

<span># Initialize strings and their tails. Tails share storage.</span>
<span>strings</span> <span>=</span> <span>(</span><span>&#39;a&#39;</span><span>..</span><span>&#39;j&#39;</span><span>).</span><span>map</span> <span>{</span> <span>|</span><span>char</span><span>|</span> <span>char</span> <span>*</span> <span>2_000_000</span> <span>}</span>
<span>tails</span> <span>=</span> <span>strings</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>s</span><span>|</span> <span>s</span><span>[</span><span>1_000_000</span><span>,</span> <span>1_000_000</span><span>]</span> <span>}</span>
<span>GC</span><span>.</span><span>start</span>
<span>size0</span> <span>=</span> <span>ObjectSpace</span><span>.</span><span>memsize_of_all</span>

<span># Trigger CoW by modifying tails:</span>
<span>tails</span><span>.</span><span>each</span> <span>{</span> <span>|</span><span>s</span><span>|</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>=</span> <span>&#39;m&#39;</span> <span>}</span>
<span>GC</span><span>.</span><span>start</span>
<span>size1</span> <span>=</span> <span>ObjectSpace</span><span>.</span><span>memsize_of_all</span>

<span>printf</span> <span>&#34;before CoW: %s bytes</span><span>\n</span><span>&#34;</span><span>,</span> <span>size0</span>
<span>printf</span> <span>&#34; after CoW: %s bytes</span><span>\n</span><span>&#34;</span><span>,</span> <span>size1</span>
</code></pre></div></div>

<p>This script makes 20 million bytes of strings and 10 million bytes of tails, which are sharing storage with previously initialized strings. Then it remembers the memory size and modifies tails, which makes it impossible to share storage with strings (i.e., we trigger a copy operation). Then we take new a memory size and compare:</p>

<p><code>bash
before CoW: 23531454 bytes
 after CoW: 33538113 bytes
</code>`</p>

<p>What‚Äôs the most important thing to remember? Strings and symbols are easy to convert back and forth (<code>to_s</code>/<code>to_sym</code>) but remember that each string allocation takes memory, while symbols are deduplicated and faster to compare.</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
