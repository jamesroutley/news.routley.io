<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.vuejs.org/posts/vue-3-5">Original</a>
    <h1>Vue 3.5 – The Vue Point</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>Today we are excited to announce the release of Vue 3.5 &#34;Tengen Toppa Gurren Lagann&#34;!</p><p>This minor release contains no breaking changes and includes both internal improvements and useful new features. We will cover some highlights in this blog post - for a full list of changes and new features, please consult <a href="https://github.com/vuejs/core/blob/main/CHANGELOG.md" target="_blank" rel="noreferrer">the full changelog on GitHub</a>.</p><hr/><nav><ul><li><a href="#reactivity-system-optimizations">Reactivity System Optimizations</a></li><li><a href="#reactive-props-destructure">Reactive Props Destructure</a></li><li><a href="#ssr-improvements">SSR Improvements</a><ul><li><a href="#lazy-hydration">Lazy Hydration</a></li><li><a href="#useid">useId()</a></li><li><a href="#data-allow-mismatch">data-allow-mismatch</a></li></ul></li><li><a href="#custom-elements-improvements">Custom Elements Improvements</a></li><li><a href="#other-notable-features">Other Notable Features</a><ul><li><a href="#usetemplateref">useTemplateRef()</a></li><li><a href="#deferred-teleport">Deferred Teleport</a></li><li><a href="#onwatchercleanup">onWatcherCleanup()</a></li></ul></li></ul></nav><h2 id="reactivity-system-optimizations" tabindex="-1">Reactivity System Optimizations <a href="#reactivity-system-optimizations" aria-label="Permalink to &#34;Reactivity System Optimizations&#34;">​</a></h2><p>In 3.5, Vue&#39;s reactivity system has undergone another major refactor that achieves better performance and significantly improved memory usage (<strong>-56%</strong>) with no behavior changes. The refactor also resolves stale computed values and memory issues caused by hanging computeds during SSR.</p><p>In addition, 3.5 also optimizes reactivity tracking for large, deeply reactive arrays, making such operations up to 10x faster in some cases.</p><p><strong>Details: <a href="https://github.com/vuejs/core/pull/10397" target="_blank" rel="noreferrer">PR#10397</a>, <a href="https://github.com/vuejs/core/pull/9511" target="_blank" rel="noreferrer">PR#9511</a></strong></p><h2 id="reactive-props-destructure" tabindex="-1">Reactive Props Destructure <a href="#reactive-props-destructure" aria-label="Permalink to &#34;Reactive Props Destructure&#34;">​</a></h2><p><strong>Reactive Props Destructure</strong> has been stabilized in 3.5. With the feature now enabled by default, variables destructured from a <code>defineProps</code> call in <code>&lt;script setup&gt;</code> are now reactive. Notably, this feature significantly simplifies declaring props with default values by leveraging JavaScript&#39;s native default value syntax:</p><p><strong>Before</strong></p><div><p><span>ts</span></p><pre tabindex="0"><code><span><span>const</span><span> props</span><span> =</span><span> withDefaults</span><span>(</span></span>
<span><span>  defineProps</span><span>&lt;{</span></span>
<span><span>    count</span><span>?:</span><span> number</span></span>
<span><span>    msg</span><span>?:</span><span> string</span></span>
<span><span>  }&gt;(),</span></span>
<span><span>  {</span></span>
<span><span>    count: </span><span>0</span><span>,</span></span>
<span><span>    msg: </span><span>&#39;hello&#39;</span></span>
<span><span>  }</span></span>
<span><span>)</span></span></code></pre></div><p><strong>After</strong></p><div><p><span>ts</span></p><pre tabindex="0"><code><span><span>const</span><span> { </span><span>count</span><span> =</span><span> 0</span><span>, </span><span>msg</span><span> =</span><span> &#39;hello&#39;</span><span> } </span><span>=</span><span> defineProps</span><span>&lt;{</span></span>
<span><span>  count</span><span>?:</span><span> number</span></span>
<span><span>  message</span><span>?:</span><span> string</span></span>
<span><span>}&gt;()</span></span></code></pre></div><p>Access to a destructured variable, e.g. <code>count</code>, is automatically compiled into <code>props.count</code> by the compiler, so they are tracked on access. Similar to <code>props.count</code>, watching the destructured prop variable or passing it into a composable while retaining reactivity requires wrapping it in a getter:</p><div><p><span>js</span></p><pre tabindex="0"><code><span><span>watch</span><span>(count </span><span>/* ... */</span><span>)</span></span>
<span><span>//    ^ results in compile-time error</span></span>
<span></span>
<span><span>watch</span><span>(() </span><span>=&gt;</span><span> count </span><span>/* ... */</span><span>)</span></span>
<span><span>//    ^ wrap in a getter, works as expected</span></span>
<span></span>
<span><span>// composables should normalize the input with `toValue()`</span></span>
<span><span>useDynamicCount</span><span>(() </span><span>=&gt;</span><span> count)</span></span></code></pre></div><p>For those who prefer to better distinguish destructured props from normal variables, <code>@vue/language-tools</code> 2.1 has shipped an opt-in setting to enable inlay hints for them:</p><p><img alt="inlay hints for destructured props" src="https://blog.vuejs.org/assets/props-destructure-inlay-hint.s6REBWmB.png"/></p><p>Details:</p><ul><li>See <a href="https://vuejs.org/guide/components/props.html#reactive-props-destructure" target="_blank" rel="noreferrer">docs</a> for usage and caveats.</li><li>See <a href="https://github.com/vuejs/rfcs/discussions/502" target="_blank" rel="noreferrer">RFC#502</a> for the history and design rationale behind this feature.</li></ul><h2 id="ssr-improvements" tabindex="-1">SSR Improvements <a href="#ssr-improvements" aria-label="Permalink to &#34;SSR Improvements&#34;">​</a></h2><p>3.5 brings a few long-requested improvements to server-side rendering (SSR).</p><h3 id="lazy-hydration" tabindex="-1">Lazy Hydration <a href="#lazy-hydration" aria-label="Permalink to &#34;Lazy Hydration&#34;">​</a></h3><p>Async components can now control when they should be hydrated by specifying a strategy via the <code>hydrate</code> option of the <code>defineAsyncComponent()</code> API. For example, to only hydrate a component when it becomes visible:</p><div><p><span>js</span></p><pre tabindex="0"><code><span><span>import</span><span> { defineAsyncComponent, hydrateOnVisible } </span><span>from</span><span> &#39;vue&#39;</span></span>
<span></span>
<span><span>const</span><span> AsyncComp</span><span> =</span><span> defineAsyncComponent</span><span>({</span></span>
<span><span>  loader</span><span>: () </span><span>=&gt;</span><span> import</span><span>(</span><span>&#39;./Comp.vue&#39;</span><span>),</span></span>
<span><span>  hydrate: </span><span>hydrateOnVisible</span><span>()</span></span>
<span><span>})</span></span></code></pre></div><p>The core API is intentionally lower level and the Nuxt team is already building higher-level syntax sugar on top of this feature.</p><p><strong>Details: <a href="https://github.com/vuejs/core/pull/11458" target="_blank" rel="noreferrer">PR#11458</a></strong></p><h3 id="useid" tabindex="-1"><code>useId()</code> <a href="#useid" aria-label="Permalink to &#34;`useId()`&#34;">​</a></h3><p><code>useId()</code> is an API that can be used to generate unique-per-application IDs that are guaranteed to be stable across the server and client renders. They can be used to generate IDs for form elements and accessibility attributes, and can be used in SSR applications without leading to hydration mismatches:</p><div><p><span>vue</span></p><pre tabindex="0"><code><span><span>&lt;</span><span>script</span><span> setup</span><span>&gt;</span></span>
<span><span>import</span><span> { useId } </span><span>from</span><span> &#39;vue&#39;</span></span>
<span></span>
<span><span>const</span><span> id</span><span> =</span><span> useId</span><span>()</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span>
<span></span>
<span><span>&lt;</span><span>template</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>form</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>label</span><span> :</span><span>for</span><span>=</span><span>&#34;</span><span>id</span><span>&#34;</span><span>&gt;Name:&lt;/</span><span>label</span><span>&gt;</span></span>
<span><span>    &lt;</span><span>input</span><span> :</span><span>id</span><span>=</span><span>&#34;</span><span>id</span><span>&#34;</span><span> type</span><span>=</span><span>&#34;text&#34;</span><span> /&gt;</span></span>
<span><span>  &lt;/</span><span>form</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre></div><p><strong>Details: <a href="https://github.com/vuejs/core/pull/11404" target="_blank" rel="noreferrer">PR#11404</a></strong></p><h3 id="data-allow-mismatch" tabindex="-1"><code>data-allow-mismatch</code> <a href="#data-allow-mismatch" aria-label="Permalink to &#34;`data-allow-mismatch`&#34;">​</a></h3><p>In cases where a client value will be inevitably different from its server counterpart (e.g. dates), we can now suppress the resulting hydration mismatch warnings with <code>data-allow-mismatch</code> attributes:</p><div><p><span>vue</span></p><pre tabindex="0"><code><span><span>&lt;</span><span>span</span><span> data-allow-mismatch</span><span>&gt;{{ data.toLocaleString() }}&lt;/</span><span>span</span><span>&gt;</span></span></code></pre></div><p>You can also limit what types of mismatches are allowed by providing a value to the attribute, where the possible values are <code>text</code>, <code>children</code>, <code>class</code>, <code>style</code>, and <code>attribute</code>.</p><h2 id="custom-elements-improvements" tabindex="-1">Custom Elements Improvements <a href="#custom-elements-improvements" aria-label="Permalink to &#34;Custom Elements Improvements&#34;">​</a></h2><p>3.5 fixes many long-standing issues related to the <code>defineCustomElement()</code> API, and adds a number of new capabilities for authoring custom elements with Vue:</p><ul><li>Support app configurations for custom elements via the <code>configureApp</code> option.</li><li>Add <code>useHost()</code>, <code>useShadowRoot()</code>, and <code>this.$host</code> APIs for accessing the host element and shadow root of a custom element.</li><li>Support mounting custom elements without Shadow DOM by passing <code>shadowRoot: false</code>.</li><li>Support providing a <code>nonce</code> option, which will be attached to <code>&lt;style&gt;</code> tags injected by custom elements.</li></ul><p>These new custom-element-only options can be passed to <code>defineCustomElement</code> via a second argument:</p><div><p><span>js</span></p><pre tabindex="0"><code><span><span>import</span><span> MyElement </span><span>from</span><span> &#39;./MyElement.ce.vue&#39;</span></span>
<span></span>
<span><span>defineCustomElements</span><span>(MyElement, {</span></span>
<span><span>  shadowRoot: </span><span>false</span><span>,</span></span>
<span><span>  nonce: </span><span>&#39;xxx&#39;</span><span>,</span></span>
<span><span>  configureApp</span><span>(</span><span>app</span><span>) {</span></span>
<span><span>    app.config.errorHandler </span><span>=</span><span> ...</span></span>
<span><span>  }</span></span>
<span><span>})</span></span></code></pre></div><h2 id="other-notable-features" tabindex="-1">Other Notable Features <a href="#other-notable-features" aria-label="Permalink to &#34;Other Notable Features&#34;">​</a></h2><h3 id="usetemplateref" tabindex="-1"><code>useTemplateRef()</code> <a href="#usetemplateref" aria-label="Permalink to &#34;`useTemplateRef()`&#34;">​</a></h3><p>3.5 introduces a new way of obtaining <a href="https://vuejs.org/guide/essentials/template-refs.html" target="_blank" rel="noreferrer">Template Refs</a> via the <code>useTemplateRef()</code> API:</p><div><p><span>vue</span></p><pre tabindex="0"><code><span><span>&lt;</span><span>script</span><span> setup</span><span>&gt;</span></span>
<span><span>import</span><span> { useTemplateRef } </span><span>from</span><span> &#39;vue&#39;</span></span>
<span></span>
<span><span>const</span><span> inputRef</span><span> =</span><span> useTemplateRef</span><span>(</span><span>&#39;input&#39;</span><span>)</span></span>
<span><span>&lt;/</span><span>script</span><span>&gt;</span></span>
<span></span>
<span><span>&lt;</span><span>template</span><span>&gt;</span></span>
<span><span>  &lt;</span><span>input</span><span> ref</span><span>=</span><span>&#34;input&#34;</span><span>&gt;</span></span>
<span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre></div><p>Prior to 3.5, we recommended using plain refs with variable names matching static <code>ref</code> attributes. The old approach required the <code>ref</code> attributes to be analyzable by the compiler and thus was limited to static <code>ref</code> attributes. In comparison, <code>useTemplateRef()</code> matches the refs via runtime string IDs, therefore supporting dynamic ref bindings to changing IDs.</p><p><code>@vue/language-tools</code> 2.1 has also implemented <a href="https://github.com/vuejs/language-tools/pull/4644" target="_blank" rel="noreferrer">special support for the new syntax</a>, so you will get auto-completion and warnings when using <code>useTemplateRef()</code> based on presence of <code>ref</code> attributes in your template:</p><p><img alt="inlay hints for destructured props" src="https://blog.vuejs.org/assets/template-ref.CUSlB3JH.png"/></p><h3 id="deferred-teleport" tabindex="-1">Deferred Teleport <a href="#deferred-teleport" aria-label="Permalink to &#34;Deferred Teleport&#34;">​</a></h3><p>A known constraint of the built-in <code>&lt;Teleport&gt;</code> component is that its target element must exist at the time the teleport component is mounted. This prevented users from teleporting content to other elements rendered by Vue after the teleport.</p><p>In 3.5, we have introduced a <code>defer</code> prop for <code>&lt;Teleport&gt;</code> which mounts it after the current render cycle, so this will now work:</p><div><p><span>html</span></p><pre tabindex="0"><code><span><span>&lt;</span><span>Teleport</span><span> defer</span><span> target</span><span>=</span><span>&#34;#container&#34;</span><span>&gt;...&lt;/</span><span>Teleport</span><span>&gt;</span></span>
<span><span>&lt;</span><span>div</span><span> id</span><span>=</span><span>&#34;container&#34;</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span></span></code></pre></div><p>This behavior requires the <code>defer</code> prop because the default behavior needs to be backwards compatible.</p><p><strong>Details: <a href="https://github.com/vuejs/core/issues/11387" target="_blank" rel="noreferrer">PR#11387</a></strong></p><h3 id="onwatchercleanup" tabindex="-1"><code>onWatcherCleanup()</code> <a href="#onwatchercleanup" aria-label="Permalink to &#34;`onWatcherCleanup()`&#34;">​</a></h3><p>3.5 introduces a globally imported API, <a href="https://vuejs.org/api/reactivity-core#onwatchercleanup" target="_blank" rel="noreferrer"><code>onWatcherCleanup()</code></a>, for registering cleanup callbacks in watchers:</p><div><p><span>js</span></p><pre tabindex="0"><code><span><span>import</span><span> { watch, onWatcherCleanup } </span><span>from</span><span> &#39;vue&#39;</span></span>
<span></span>
<span><span>watch</span><span>(id, (</span><span>newId</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  const</span><span> controller</span><span> =</span><span> new</span><span> AbortController</span><span>()</span></span>
<span></span>
<span><span>  fetch</span><span>(</span><span>`/api/${</span><span>newId</span><span>}`</span><span>, { signal: controller.signal }).</span><span>then</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>    // callback logic</span></span>
<span><span>  })</span></span>
<span></span>
<span><span>  onWatcherCleanup</span><span>(() </span><span>=&gt;</span><span> {</span></span>
<span><span>    // abort stale request</span></span>
<span><span>    controller.</span><span>abort</span><span>()</span></span>
<span><span>  })</span></span>
<span><span>})</span></span></code></pre></div><ul><li>Related: new docs section on <a href="https://vuejs.org/guide/essentials/watchers.html#side-effect-cleanup" target="_blank" rel="noreferrer">Side Effect Cleanup</a></li></ul><hr/><p>For a comprehensive list of changes and features in 3.5, check out of the <a href="https://github.com/vuejs/core/blob/main/CHANGELOG.md" target="_blank" rel="noreferrer">the full changelog on GitHub</a>. Happy hacking!</p></div></div></div></div>
  </body>
</html>
