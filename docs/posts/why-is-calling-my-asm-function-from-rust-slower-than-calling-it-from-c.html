<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ohadravid.github.io/posts/2025-12-rav1d-faster-asm/">Original</a>
    <h1>Why is calling my asm function from Rust slower than calling it from C?</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>This is a follow-up to <a href="https://ohadravid.github.io/posts/2025-05-rav1d-faster/">making the rav1d video decoder 1% faster</a>,
where we compared profiler snapshots of <code>rav1d</code> (the Rust implementation) and <code>dav1d</code> (the C baseline)
to find specific functions that were slower in the Rust implementation<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>.</p><p>Today, we are going to pay off a small debt from that post: since <code>dav1d</code> and <code>rav1d</code> share the same hand-written assembly functions,
we used them as <strong>anchors</strong> to navigate the different implementations - <em>they</em>, at least, should match exactly!
And they did. Well, <em>almost</em> all of them did.</p><p>This, dear reader, is the story of the one function that <em>didn‚Äôt</em>.</p><h2 id="an-overview">An Overview</h2><p>We‚Äôll need to ask - and answer! - <a href="https://en.wikipedia.org/wiki/Five_whys">three ‚ÄòWhys‚Äô</a> today:</p><ol><li>But why? ‚û°Ô∏è Because <strong>loading data</strong> in the Rust version is slower, which we discover using <code>samply</code>‚Äôs special asm view. <a href="#looking-at-the-opcodes">1</a></li><li>But why? ‚û°Ô∏è Because the Rust version stores much <strong>more data on the stack</strong>, which we find by playing with some arguments and looking at the generated LLVM IR. <a href="#a-good-guess">2</a></li><li>But why? ‚û°Ô∏è Because <strong>the compiler cannot optimize</strong> away a specific Rust abstraction across function pointers! <a href="#from-top-to-bottom">3</a></li></ol><p>Which we fix by switching to a more compiler-friendly version (<a href="https://github.com/memorysafety/rav1d/pull/1418">PR</a>). <a href="#switch-it-up">4</a></p><p><i>Side note: again, we‚Äôll be running all these benchmarks on a MacBook, so our tools are a tad limited
and we‚Äôll have to resort to some guesswork. Leave a comment if you know more - or, even better, write an article about profiling on macOS üçéüí®.</i></p><p>Discuss on <a href="https://www.reddit.com/r/rust/comments/1pwzti4/why_is_calling_my_asm_function_from_rust_slower/">r/rust</a>, <a href="https://lobste.rs/s/byxxmk/why_is_calling_my_asm_function_from_rust">lobsters</a>, <a href="https://news.ycombinator.com/item?id=46401982">HN</a>! üëã</p><p><img src="https://ohadravid.github.io/2025-12-rav1d-faster-asm/instruments.webp" alt="Instruments quit unexpectedly after running a few recordings" loading="lazy" width="66%" width="1458px" height="622px"/></p><h2 id="filter4_pri_edged_8bpc"><code>filter4_pri_edged_8bpc</code></h2><p>Let‚Äôs rerun the benchmark after the previous post‚Äôs changes:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>./rav1d $ git checkout cfd3f59 <span>&amp;&amp;</span> cargo build --release
</span></span><span><span>./rav1d $ sudo samply record ./target/release/dav1d -q -i Chimera-AV1-8bit-1920x1080-6736kbps.ivf -o /dev/null --threads <span>1</span>
</span></span></code></pre></div><p>We‚Äôll switch to the inverted call stack view and filter for the <code>cdef_</code> functions, resulting in the following clippings<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.
The assembly functions are the ones with the <code>_neon</code> suffix.</p><p>On the left is <code>dav1d</code> (C), and on the right <code>rav1d</code> (Rust):</p><p>On the top is <code>dav1d</code> (C), and on the bottom <code>rav1d</code> (Rust):</p><p>Looking at the sample count, most of the functions match (to within ~10%)<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, except the highlighted <code>cdef_filter4_pri_edged_8bpc_neon</code> which is <strong>30% slower</strong>.
We see a difference of 350 samples. Sampling at 1000 Hz, this corresponds to 0.35 seconds, or ~0.5% of the total runtime.</p><p>This is <em>very sus</em>: obviously this is the exact same function, and barring a logical bug in the implementation,
it must process the exact same data.</p><p>So how can this be?</p><h2 id="looking-at-the-opcodes">Looking at the Opcodes</h2><p>Luckily for us, <code>samply</code> has <em>exactly</em> what we need here: we can get into the <code>asm</code> view by double-clicking on the function,
which shows <strong>a per-instruction sample count</strong>.</p><p>And it seems that fortune favors the bold,
because we find the entire difference in <em>a single instruction</em> less than 25 lines into the call.</p><p>Let‚Äôs look at the <code>ld1 {v0.s}[2], [x13]</code> line, highlighted below in yellow.</p><p>At this point, you might be wondering: what is <code>ld1</code>? What‚Äôs that <code>{v0.s}[2]</code> syntax?
And‚Ä¶ why is <code>x13</code> <em>that</em> different from <code>x2</code>, <code>x12</code>, or <code>x14</code>?</p><h3 id="ld1"><code>ld1</code></h3><p>Let‚Äôs try to decode what <code>ld1 {v0.s}[2], [x13]</code> means.</p><p>A quick search leads us to the <a href="https://developer.arm.com/documentation/ddi0602/2025-09/SIMD-FP-Instructions/LD1--single-structure---Load-one-single-element-structure-to-one-lane-of-one-register-?lang=en">LD1 page in the Arm A-profile A64 Instruction Set Architecture documentation</a>, which helpfully says the following:</p><blockquote><p><strong>LD1</strong> - Load one single-element structure to one lane of one register</p><p>This instruction loads a single-element structure from memory and writes the result to the specified lane of the SIMD&amp;FP register</p></blockquote><p>It also explains that <code>v0</code> is a SIMD register, and <code>.s</code> is the 32-bit variant of this instruction.</p><p>So, TL;DR: this instruction loads data from the address in the <code>x13</code> register into lane 2 of the <code>v0</code> SIMD register.</p><p>Which means that the three adjacent instructions <em>also</em> do almost the exact same thing.</p><h2 id="a-good-guess">A Good Guess</h2><p>Ignoring the start of the function, let‚Äôs look at the lines that appear right before the load instructions:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>add</span> <span>x12</span><span>,</span> <span>x2</span><span>,</span> <span>#0x8
</span></span></span><span><span><span></span><span>add</span> <span>x13</span><span>,</span> <span>x2</span><span>,</span> <span>#0x10
</span></span></span><span><span><span></span><span>add</span> <span>x14</span><span>,</span> <span>x2</span><span>,</span> <span>#0x18
</span></span></span><span><span><span></span><span>ld1</span> <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>0</span><span>],</span> <span>[</span><span>x2</span><span>]</span>  <span>; Fast - 20 samples.
</span></span></span><span><span><span></span><span>ld1</span> <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>1</span><span>],</span> <span>[</span><span>x12</span><span>]</span> <span>; Fast - 16 samples.
</span></span></span><span><span><span></span><span>ld1</span> <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>2</span><span>],</span> <span>[</span><span>x13</span><span>]</span> <span>; Slow - 441 samples.
</span></span></span><span><span><span></span><span>ld1</span> <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>3</span><span>],</span> <span>[</span><span>x14</span><span>]</span> <span>; Fast as well!
</span></span></span></code></pre></div><p><em>PSA: if you don‚Äôt see syntax highlighting, <a href="https://www.1password.community/discussions/developers/1password-chrome-extension-is-incorrectly-manipulating--blocks/165639">disable the 1Password extension</a>.</em></p><p>Seems simple enough - we load 32-bit values from the addresses at <code>x2 + {0,8,16,24}</code> into <code>v0</code>. But what address is stored in <code>x2</code>?</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>filter</span><span>(</span>
</span></span><span><span>    dst: <span>*</span><span>mut</span> DynPixel<span>,</span>           <span>// x0
</span></span></span><span><span><span></span>    dst_stride: <span>ptrdiff_t</span><span>,</span>        <span>// x1
</span></span></span><span><span><span></span>    tmp: <span>*</span><span>const</span> MaybeUninit<span>&lt;</span><span>u16</span><span>&gt;</span><span>,</span> <span>// x2
</span></span></span><span><span><span></span>    <span>// ...
</span></span></span><span><span><span></span><span>)</span> -&gt; <span>()</span>
</span></span></code></pre></div><p>Our old friend <code>tmp</code>! We <a href="https://ohadravid.github.io/posts/2025-05-rav1d-faster/#cdef_filter_neon_erased">saw</a> in the previous post that these assembly functions are dispatched from a function called <code>cdef_filter_neon_erased</code>.
This function defines <code>tmp</code> on the stack as a buffer of (uninitialized) <code>u16</code>s, and <em>partially</em> fills it using a padding function which is also written in assembly.</p><p>So, why would reading from a contiguous smallish buffer be slow for one particular part of that buffer?</p><p><strong>At this point, we are going to take a guess</strong> (leave a comment if you know more!):
there‚Äôs likely a caching issue somewhere that causes the CPU to stall for that particular load.</p><p>But why? Maybe it‚Äôs something in the way data is <em>written</em> to the buffer?
Time to take a closer look. In particular, there‚Äôs something a bit unexpected in the <em>arguments</em> of the <code>cdef_filter_neon_erased</code> function:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>cdef_filter_neon_erased</span><span>&lt;</span><span>BD</span>: <span>BitDepth</span><span>,</span> <span>..&gt;</span><span>(</span>
</span></span><span><span>    dst: <span>*</span><span>mut</span> DynPixel<span>,</span>
</span></span><span><span>    stride: <span>ptrdiff_t</span><span>,</span>
</span></span><span><span>    left: <span>*</span><span>const</span> <span>[</span>LeftPixelRow2px<span>&lt;</span>DynPixel<span>&gt;</span><span>;</span> <span>8</span><span>],</span>
</span></span><span><span>    top: <span>*</span><span>const</span> DynPixel<span>,</span>
</span></span><span><span>    bottom: <span>*</span><span>const</span> DynPixel<span>,</span>
</span></span><span><span>    <span>..</span><span>,</span>
</span></span><span><span>    _dst: <span>*</span><span>const</span> FFISafe<span>&lt;</span>Rav1dPictureDataComponentOffset<span>&gt;</span><span>,</span>
</span></span><span><span>    _top: <span>*</span><span>const</span> FFISafe<span>&lt;</span>CdefTop<span>&gt;</span><span>,</span>
</span></span><span><span>    _bottom: <span>*</span><span>const</span> FFISafe<span>&lt;</span>CdefBottom<span>&gt;</span><span>,</span>
</span></span><span><span><span>)</span> <span>{</span>
</span></span><span><span>    <span>let</span> <span>mut</span> tmp_buf <span>=</span> Align16<span>([</span>MaybeUninit::uninit<span>();</span> <span>TMP_LEN</span><span>]);</span>
</span></span><span><span>    <span>let</span> tmp <span>=</span> <span>&amp;</span><span>mut</span> tmp_buf<span>.</span><span>0</span><span>[</span><span>..</span><span>];</span>
</span></span><span><span>
</span></span><span><span>    padding::<span>Fn</span>::neon::<span>&lt;</span><span>BD</span><span>,</span> W<span>&gt;</span><span>().</span>call::<span>&lt;</span><span>BD</span><span>&gt;</span><span>(</span>  <span>//
</span></span></span><span><span><span></span>        tmp<span>,</span>                                  <span>// &lt;--- Fills tmp by calling a `cdef_padding_XYZ_neon` function. 
</span></span></span><span><span><span></span>        dst<span>,</span> stride<span>,</span> left<span>,</span> top<span>,</span> bottom<span>,</span> <span>..</span>    <span>// 
</span></span></span><span><span><span></span>    <span>);</span>
</span></span><span><span>    filter::<span>Fn</span>::neon::<span>&lt;</span><span>BD</span><span>,</span> W<span>&gt;</span><span>().</span>call<span>(</span>         <span>// &lt;--- Calls the specific `cdef_filter_XYZ_neon` function.
</span></span></span><span><span><span></span>        dst<span>,</span>
</span></span><span><span>        stride<span>,</span>
</span></span><span><span>        tmp<span>,</span>
</span></span><span><span>        <span>..</span>
</span></span><span><span>    <span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>This is‚Ä¶ a bit much, but as you can imagine, <code>dav1d</code> <em>doesn‚Äôt</em> have the last 3 arguments (an <code>_</code> in Rust denotes an unused variable).
Looking around some more, they are only used in a function called <code>cdef_filter_<strong>block_c</strong>_erased</code>, which is - despite the name - a pure-Rust fallback in case the asm functions are unavailable.</p><p>I wonder what will happen if we‚Ä¶ if we just remove them?</p><picture><source media="(max-width: 820px)" srcset="/2025-12-rav1d-faster-asm/why_shouldnt_i.webp" width="484" height="484" loading="lazy"/><img src="https://ohadravid.github.io/2025-12-rav1d-faster-asm/why_shouldnt_i_lg.webp" width="968" height="242" loading="lazy" alt="Bilbo - Why shouldn‚Äôt I keep it? Meme"/></picture><h3 id="a-fix">A ‚ÄúFix‚Äù</h3><p>If we do remove them:</p><div><pre tabindex="0"><code data-lang="diff"><span><span><span>-    _dst: *const FFISafe&lt;Rav1dPictureDataComponentOffset&gt;,
</span></span></span><span><span><span>-    _top: *const FFISafe&lt;CdefTop&gt;,
</span></span></span><span><span><span>-    _bottom: *const FFISafe&lt;CdefBottom&gt;,
</span></span></span><span><span><span></span><span>+    // _dst: *const FFISafe&lt;Rav1dPictureDataComponentOffset&gt;,
</span></span></span><span><span><span>+    // _top: *const FFISafe&lt;CdefTop&gt;,
</span></span></span><span><span><span>+    // _bottom: *const FFISafe&lt;CdefBottom&gt;,
</span></span></span></code></pre></div><p>and (temporarily) replace <code>cdef_filter_<strong>block_c</strong>_erased</code> with a stub:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>cdef_filter_block_c_erased</span><span>&lt;</span><span>BD</span>: <span>BitDepth</span><span>,</span> <span>const</span> W: <span>usize</span><span>,</span> <span>const</span> H: <span>usize</span><span>&gt;</span><span>(</span>
</span></span><span><span>    _dst_ptr: <span>*</span><span>mut</span> DynPixel<span>,</span>
</span></span><span><span>    <span>..</span><span>.</span>
</span></span><span><span>    edges: <span>CdefEdgeFlags</span><span>,</span>
</span></span><span><span>    bitdepth_max: <span>c_int</span><span>,</span>
</span></span><span><span>    <span>// dst: *const FFISafe&lt;Rav1dPictureDataComponentOffset&gt;,
</span></span></span><span><span><span></span>    <span>// top: *const FFISafe&lt;CdefTop&gt;,
</span></span></span><span><span><span></span>    <span>// bottom: *const FFISafe&lt;CdefBottom&gt;,
</span></span></span><span><span><span></span><span>)</span> <span>{</span>
</span></span><span><span>    <span>todo!</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>When we re-run our benchmark, we see something cool:</p><p>Our dear <code>cdef_filter4_pri_edged_8bpc_neon</code>, which accounted for 1,562 samples before, is now <strong>down to 1,268 samples</strong> (now within 5% of <code>dav1d</code>‚Äôs 1,199),
and all our <code>ld1</code> (memory load) instructions are down to <code>dav1d</code> levels! No more stalling.</p><p>Huzzah! Or‚Ä¶ Huzzah?</p><p><img src="https://ohadravid.github.io/2025-12-rav1d-faster-asm/guy_stopping_friend_from_a_girl_meme_small.webp" alt="Guy putting hand on other guy chasing a girl meme" loading="lazy" width="50%" width="627px" height="472px"/></p><h2 id="an-elegant-weapon-for-a-more-civilized-age">An Elegant Weapon for a More Civilized Age</h2><p>Let‚Äôs recap: On the one hand, we found a meaningful slowdown between the Rust and the C versions,
and we even managed to create a ‚Äúfixed‚Äù version that doesn‚Äôt exhibit the same problem.</p><p>On the other hand, we only have <em>vibes</em> about what the problem is (memory is haunted?), nothing about the fix makes sense (removing unused stuff helps how?), <em>and</em> we can‚Äôt use this code because we removed an important fallback.</p><p>The only silver lining is that because we have a faster version, we can try to compare it to the original and find out what changed,
and that might lead us to the real fix.</p><p>Which is where <code>cargo asm</code> comes into play.</p><p>Our theory is that <em>something</em> is different in the way the memory is laid out between the versions.</p><p>So what can <code>cargo asm</code> tell us?</p><h3 id="peeking-under-the-hood">Peeking Under the Hood</h3><p>We can compare <code>cdef_filter_neon_erased</code>, using either <code>--asm</code> or <code>--llvm</code> modes<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>, but long story short, there doesn‚Äôt seem to be any differences between the baseline and the faster version. Which at least makes sense - we didn‚Äôt change anything about this function because it wasn‚Äôt using those arguments in the first place!</p><p>But what if we go one level up? <code>_erased</code> is called from a function named <code>rav1d_cdef_brow</code> (which we also <a href="https://ohadravid.github.io/posts/2025-05-rav1d-faster/##avoid-needlessly-zeroing-buffers-with-maybeuninit">briefly saw</a> in the last post),
which is a very complex, 300-line behemoth.
However, it seems like this function receives its data via a few nice structs, which means that either one of them is messed up - which is relatively easy to check - or that the problem is somewhere <strong>inside</strong> this function.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>rav1d_cdef_brow</span><span>&lt;</span><span>BD</span>: <span>BitDepth</span><span>&gt;</span><span>(</span>
</span></span><span><span>    c: <span>&amp;</span><span>Rav1dContext</span><span>,</span>
</span></span><span><span>    tc: <span>&amp;</span><span>mut</span> Rav1dTaskContext<span>,</span>
</span></span><span><span>    f: <span>&amp;</span><span>Rav1dFrameData</span><span>,</span>
</span></span><span><span>    p: <span>[</span>Rav1dPictureDataComponentOffset<span>;</span> <span>3</span><span>],</span>
</span></span><span><span>    <span>// .. a few simple arguments ..
</span></span></span><span><span><span></span><span>)</span> <span>{</span> <span>..</span><span>.</span> <span>}</span>
</span></span></code></pre></div><p>And this time, <code>cargo asm</code><sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup> lights up like a Christmas tree üéÑ.</p><div><pre tabindex="0"><code data-lang="llvm"><span><span><span>; rav1d::cdef_apply::rav1d_cdef_brow
</span></span></span><span><span><span>; Function Attrs: nounwind
</span></span></span><span><span><span></span><span>define</span> <span>internal</span> <span>fastcc</span> <span>void</span> @rav1d<span>::</span><span>cdef_apply:</span><span>:rav</span><span>1</span><span>d_cdef_brow</span><span>(...)</span> <span>{</span>
</span></span><span><span><span>start:</span>
</span></span><span><span>  %dst.i <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %variance <span>=</span> <span>alloca</span> <span>[</span><span>4</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>4</span>
</span></span><span><span>  %lr_bak <span>=</span> <span>alloca</span> <span>[</span><span>96</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>16</span>
</span></span><span><span>  %_17 <span>=</span> <span>icmp</span> <span>sgt</span> <span>i32</span> %by_start<span>,</span> <span>0</span>
</span></span><span><span>  %. <span>=</span> <span>select</span> <span>i1</span> %_17<span>,</span> <span>i32</span> <span>12</span><span>,</span> <span>i32</span> <span>8</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>And here‚Äôs the baseline version:</p><div><pre tabindex="0"><code data-lang="llvm"><span><span><span>; rav1d::cdef_apply::rav1d_cdef_brow
</span></span></span><span><span><span>; Function Attrs: nounwind
</span></span></span><span><span><span></span><span>define</span> <span>internal</span> <span>fastcc</span> <span>void</span> @rav1d<span>::</span><span>cdef_apply:</span><span>:rav</span><span>1</span><span>d_cdef_brow</span><span>(...)</span> <span>{</span>
</span></span><span><span><span>start:</span>
</span></span><span><span>  %top.i400 <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %dst.i401 <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %top.i329 <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %dst.i330 <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %top.i <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %dst.i317 <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %dst.i <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %bot5 <span>=</span> <span>alloca</span> <span>[</span><span>24</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %bot <span>=</span> <span>alloca</span> <span>[</span><span>24</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %variance <span>=</span> <span>alloca</span> <span>[</span><span>4</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>4</span>
</span></span><span><span>  %lr_bak <span>=</span> <span>alloca</span> <span>[</span><span>96</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>16</span>
</span></span><span><span>  %_17 <span>=</span> <span>icmp</span> <span>sgt</span> <span>i32</span> %by_start<span>,</span> <span>0</span>
</span></span><span><span>  %. <span>=</span> <span>select</span> <span>i1</span> %_17<span>,</span> <span>i32</span> <span>12</span><span>,</span> <span>i32</span> <span>8</span>
</span></span><span><span>  <span>...</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Which means that somehow, the baseline version allocates on the stack - using <code>alloca</code> - 144 bytes more than the faster version!
It would also seem that all these extra allocations are for multiple instances of <code>dst</code>, <code>top</code>, and <code>bot</code> (i.e., <code>bottom</code>),
which matches the arguments we removed in the faster version.</p><p>So now we only need to‚Ä¶ not do that, I guess?</p><h2 id="from-top-to-bottom">From Top to Bottom</h2><p>Our revised but incomplete theory is thus:</p><p>(1) <code>cdef_filter4_pri_edged_8bpc_neon</code> reads data from or via <code>dst</code>, <code>top</code> and/or <code>bot</code>, which ends up affecting the third <code>ld1</code> line.</p><details><summary>More</summary><p>The calls to the <code>filter</code> functions are defined like this:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>filter</span><span>(</span>
</span></span><span><span>    dst: <span>*</span><span>mut</span> DynPixel<span>,</span>
</span></span><span><span>    dst_stride: <span>ptrdiff_t</span><span>,</span>
</span></span><span><span>    tmp: <span>*</span><span>const</span> MaybeUninit<span>&lt;</span><span>u16</span><span>&gt;</span><span>,</span>
</span></span><span><span>    <span>// ..
</span></span></span><span><span><span></span><span>)</span> -&gt; <span>{</span> <span>..</span> <span>}</span>
</span></span></code></pre></div><p>and the assembly function <em>template</em> is located in <code>src/arm/64/cdef.S</code>:</p><div><pre tabindex="0"><code data-lang="asm"><span><span><span>// void cdef_filterX_edged_8bpc_neon(pixel *dst, ptrdiff_t dst_stride,
</span></span></span><span><span><span>//                                   const uint8_t *tmp, int pri_strength,
</span></span></span><span><span><span>//                                   int sec_strength, int dir, int damping,
</span></span></span><span><span><span>//                                   int h);
</span></span></span><span><span><span></span><span>.macro</span> <span>filter_func_8</span> <span>w</span><span>,</span> <span>pri</span><span>,</span> <span>sec</span><span>,</span> <span>min</span><span>,</span> <span>suffix</span>
</span></span><span><span><span>function</span> <span>cdef_filter</span><span>\</span><span>w</span><span>\</span><span>suffix</span><span>\</span><span>()</span><span>_edged_8bpc_neon</span>
</span></span><span><span>    <span>// ..
</span></span></span><span><span><span></span>    <span>ld1</span>             <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>0</span><span>],</span> <span>[</span><span>x2</span><span>]</span>             <span>// px
</span></span></span><span><span><span></span>    <span>ld1</span>             <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>1</span><span>],</span> <span>[</span><span>x12</span><span>]</span>            <span>// px
</span></span></span><span><span><span></span>    <span>ld1</span>             <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>2</span><span>],</span> <span>[</span><span>x13</span><span>]</span>            <span>// px
</span></span></span><span><span><span></span>    <span>ld1</span>             <span>{</span><span>v0.s</span><span>}</span><span>[</span><span>3</span><span>],</span> <span>[</span><span>x14</span><span>]</span>            <span>// px
</span></span></span></code></pre></div></details><p>(2) <code>cdef_filter_neon_erased</code> accepts <strong>two</strong> sets of these, one as raw pointers for the asm version and one as these <code>*FFISafe</code> pointers that are only used in the pure-Rust version.</p><details><summary>More</summary><p>The assembly dispatch function (<code>_erased</code>) only uses the <code>*mut DynPixel</code> versions:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>pub</span> <span>unsafe</span> <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span> <span>cdef_filter_neon_erased</span><span>&lt;</span><span>BD</span>: <span>BitDepth</span><span>,</span> <span>const</span> W: <span>usize</span><span>,</span> <span>const</span> H: <span>usize</span><span>,</span> <span>..</span> <span>&gt;</span><span>(</span>
</span></span><span><span>    dst: <span>*</span><span>mut</span> DynPixel<span>,</span>
</span></span><span><span>    stride: <span>ptrdiff_t</span><span>,</span>
</span></span><span><span>    left: <span>*</span><span>const</span> <span>[</span>LeftPixelRow2px<span>&lt;</span>DynPixel<span>&gt;</span><span>;</span> <span>8</span><span>],</span>
</span></span><span><span>    top: <span>*</span><span>const</span> DynPixel<span>,</span>
</span></span><span><span>    bottom: <span>*</span><span>const</span> DynPixel<span>,</span>
</span></span><span><span>    <span>// ..
</span></span></span><span><span><span></span>    _dst: <span>*</span><span>const</span> FFISafe<span>&lt;</span>Rav1dPictureDataComponentOffset<span>&gt;</span><span>,</span>
</span></span><span><span>    _top: <span>*</span><span>const</span> FFISafe<span>&lt;</span>CdefTop<span>&gt;</span><span>,</span>
</span></span><span><span>    _bottom: <span>*</span><span>const</span> FFISafe<span>&lt;</span>CdefBottom<span>&gt;</span><span>,</span>
</span></span><span><span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    padding::<span>Fn</span>::neon::<span>&lt;</span><span>BD</span><span>,</span> W<span>&gt;</span><span>().</span>call::<span>&lt;</span><span>BD</span><span>&gt;</span><span>(</span>tmp<span>,</span> dst<span>,</span> stride<span>,</span> left<span>,</span> top<span>,</span> bottom<span>,</span> H<span>,</span> edges<span>);</span>
</span></span><span><span>    filter::<span>Fn</span>::neon::<span>&lt;</span><span>BD</span><span>,</span> W<span>&gt;</span><span>().</span>call<span>(</span>dst<span>,</span> stride<span>,</span> tmp<span>,</span> pri_strength<span>,</span> sec_strength<span>,</span> dir<span>,</span> damping<span>,</span> H<span>,</span> edges<span>,</span> bd<span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>While the pure Rust version uses only the fully typed and safe <code>[BD::Pixel]</code> versions:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>fn</span> <span>cdef_filter_block_rust</span><span>&lt;</span><span>BD</span>: <span>BitDepth</span><span>&gt;</span><span>(</span>
</span></span><span><span>    dst: <span>Rav1dPictureDataComponentOffset</span><span>,</span>
</span></span><span><span>    dst: <span>Rav1dPictureDataComponentOffset</span><span>,</span>
</span></span><span><span>    left: <span>&amp;</span><span>[</span>LeftPixelRow2px<span>&lt;</span><span>BD</span>::Pixel<span>&gt;</span><span>;</span> <span>8</span><span>],</span>
</span></span><span><span>    top: <span>CdefTop</span><span>,</span>
</span></span><span><span>    bottom: <span>CdefBottom</span><span>,</span>
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span><span>)</span> <span>{</span> <span>..</span> <span>}</span>
</span></span></code></pre></div></details><p>(3) <code>rav1d_cdef_brow</code> sets up all of these in a few different ways, probably for the different variations of <code>cdef_filter4_{pri_edged,pri_sec_edge,sec_edge,sec,pri}_8bpc_neon</code>.</p><details><summary>More</summary><p>For example, this is a small unedited part of <code>rav1d_cdef_brow</code>. See how <code>top</code> and <code>bot</code> have a non-trivial setup:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> <span>(</span>top<span>,</span> bot<span>)</span> <span>=</span> top_bot<span>.</span>unwrap_or_else<span>(</span><span>||</span> <span>{</span>
</span></span><span><span>    <span>let</span> top <span>=</span> WithOffset <span>{</span>
</span></span><span><span>        data: <span>&amp;</span><span>f</span><span>.</span>lf<span>.</span>cdef_line_buf<span>,</span>
</span></span><span><span>        offset: <span>f</span><span>.</span>lf<span>.</span>cdef_line<span>[</span>tf <span>as</span> <span>usize</span><span>][</span><span>0</span><span>],</span>
</span></span><span><span>    <span>}</span> <span>+</span> have_tt <span>as</span> <span>isize</span> <span>*</span> <span>(</span>sby <span>*</span> <span>4</span><span>)</span> <span>as</span> <span>isize</span> <span>*</span> y_stride
</span></span><span><span>        <span>+</span> <span>(</span>bx <span>*</span> <span>4</span><span>)</span> <span>as</span> <span>isize</span><span>;</span>
</span></span><span><span>    <span>let</span> bottom <span>=</span> bptrs<span>[</span><span>0</span><span>]</span> <span>+</span> <span>(</span><span>8</span> <span>*</span> y_stride<span>);</span>
</span></span><span><span>    <span>(</span>top<span>,</span> WithOffset::pic<span>(</span>bottom<span>))</span>
</span></span><span><span><span>});</span>
</span></span><span><span>
</span></span><span><span><span>if</span> y_pri_lvl <span>!=</span> <span>0</span> <span>{</span>
</span></span><span><span>    <span>let</span> adj_y_pri_lvl <span>=</span> adjust_strength<span>(</span>y_pri_lvl<span>,</span> variance<span>);</span>
</span></span><span><span>    <span>if</span> adj_y_pri_lvl <span>!=</span> <span>0</span> <span>||</span> y_sec_lvl <span>!=</span> <span>0</span> <span>{</span>
</span></span><span><span>        f<span>.</span>dsp<span>.</span>cdef<span>.</span>fb<span>[</span><span>0</span><span>].</span>call::<span>&lt;</span><span>BD</span><span>&gt;</span><span>(</span>
</span></span><span><span>            bptrs<span>[</span><span>0</span><span>],</span>
</span></span><span><span>            <span>&amp;</span>lr_bak<span>[</span>bit <span>as</span> <span>usize</span><span>][</span><span>0</span><span>],</span>
</span></span><span><span>            top<span>,</span>
</span></span><span><span>            bot<span>,</span>
</span></span><span><span>            adj_y_pri_lvl<span>,</span>
</span></span><span><span>            y_sec_lvl<span>,</span>
</span></span><span><span>            dir<span>,</span>
</span></span><span><span>            damping<span>,</span>
</span></span><span><span>            edges<span>,</span>
</span></span><span><span>            bd<span>,</span>
</span></span><span><span>        <span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></details><p>Having the two sets of pointers prevents the compiler from performing some optimizations,
and it just so happens that this results in a layout that causes the CPU to stall.</p><p>There‚Äôs <em>so much more</em> going on here, but let‚Äôs keep our focus and try to actually fix the issue at hand.</p><h3 id="why-is-it-ffisafe-ed">Why is it <code>FFISafe</code>-ed?</h3><p>Simplified, <code>rav1d_cdef_brow</code> sets up <code>top</code> like so:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> cdef_line_buf: <span>AlignedVec64</span><span>&lt;</span><span>u8</span><span>&gt;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>let</span> top <span>=</span> WithOffset <span>{</span>
</span></span><span><span>    data: <span>&amp;</span><span>cdef_line_buf</span><span>,</span>
</span></span><span><span>    offset<span>,</span>
</span></span><span><span><span>}</span> <span>+</span> <span>..</span><span>.</span> <span>as</span> <span>isize</span><span>;</span>
</span></span></code></pre></div><p>with <code>dst</code> and <code>bottom</code> following similar patterns.</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(Clone, Copy)]</span>
</span></span><span><span><span>pub</span> <span>struct</span> <span>WithOffset</span><span>&lt;</span>T<span>&gt;</span> <span>{</span>
</span></span><span><span>    <span>pub</span> data: <span>T</span><span>,</span>
</span></span><span><span>    <span>pub</span> offset: <span>usize</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>impl</span><span>&lt;</span>T<span>&gt;</span> AddAssign<span>&lt;</span><span>usize</span><span>&gt;</span> <span>for</span> WithOffset<span>&lt;</span>T<span>&gt;</span> <span>{</span> <span>..</span> <span>}</span>
</span></span><span><span><span>impl</span><span>&lt;</span>T<span>&gt;</span> SubAssign<span>&lt;</span><span>usize</span><span>&gt;</span> <span>for</span> WithOffset<span>&lt;</span>T<span>&gt;</span> <span>{</span> <span>..</span> <span>}</span>
</span></span><span><span><span>// A few more impl like this.
</span></span></span><span><span><span></span>
</span></span><span><span><span>impl</span><span>&lt;</span>P: <span>Pixels</span><span>&gt;</span> WithOffset<span>&lt;</span>P<span>&gt;</span> <span>{</span>
</span></span><span><span>    <span>pub</span> <span>fn</span> <span>as_ptr</span><span>&lt;</span><span>BD</span>: <span>BitDepth</span><span>&gt;</span><span>(</span><span>&amp;</span><span>self</span><span>)</span> -&gt; <span>*</span><span>const</span> <span>BD</span>::Pixel <span>{</span>
</span></span><span><span>        <span>self</span><span>.</span>data<span>.</span>as_ptr_at::<span>&lt;</span><span>BD</span><span>&gt;</span><span>(</span><span>self</span><span>.</span>offset<span>)</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span> 
</span></span><span><span>    <span>// A few more of these as well.
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><p>Looking at this struct, we start to see what‚Äôs going on: <code>WithOffset</code> is, on a 64-bit architecture, the size of <code>T</code> plus 8 bytes, which matches the <code>alloca</code> calls of 16 and 24 bytes we saw before.</p><p>It is also not ‚ÄúFFI-safe‚Äù, which means that passing it as an argument in an <code>extern &#34;C&#34;</code> function - such as our asm functions - is <a href="https://github.com/rust-lang/rust/issues/116963">somewhat controversial</a>,
and <code>rav1d</code> gets around that by having this special <code>FFISafe</code> struct that makes this problem magically<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> go away.</p><p>Because <code>WithOffset</code> is a buffer-access utility, it can be used to create raw pointers into the underlying buffer.
But because the safe Rust fallback doesn‚Äôt want raw pointers, we end up having both versions when we <a href="https://github.com/memorysafety/rav1d/blob/25e5574/src/cdef.rs#L70"><code>call</code></a>
either the asm or the Rust version of the function:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> top_ptr: <span>*</span><span>mut</span> DynPixel <span>=</span> top<span>.</span>as_ptr::<span>&lt;</span><span>BD</span><span>&gt;</span><span>().</span>cast<span>();</span>
</span></span><span><span><span>let</span> bottom_ptr: <span>*</span><span>mut</span> DynPixel <span>=</span> bottom<span>.</span>wrapping_as_ptr::<span>&lt;</span><span>BD</span><span>&gt;</span><span>().</span>cast<span>();</span>
</span></span><span><span><span>let</span> top <span>=</span> FFISafe::new<span>(</span><span>&amp;</span>top<span>);</span>
</span></span><span><span><span>let</span> bottom <span>=</span> FFISafe::new<span>(</span><span>&amp;</span>bottom<span>);</span>
</span></span><span><span>
</span></span><span><span><span>// We&#39;re simplifying here, and we also ignore the differences between u8, DynPixel and BD::Pixel.
</span></span></span><span><span><span></span><span>pub</span> <span>type</span> <span>CdefTop</span><span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>=</span> WithOffset<span>&lt;&amp;</span><span>&#39;a</span> <span>u8</span><span>&gt;</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>// A function pointer to the best available impl...
</span></span></span><span><span><span></span><span>let</span> callback: <span>extern</span> <span>&#34;C&#34;</span> <span>fn</span><span>(</span>
</span></span><span><span>    <span>..</span><span>,</span> 
</span></span><span><span>    top_ptr: <span>*</span><span>mut</span> DynPixel<span>,</span> 
</span></span><span><span>    <span>..</span><span>,</span> 
</span></span><span><span>    top: <span>*</span><span>const</span> FFISafe<span>&lt;</span>CdefTop<span>&gt;</span><span>,</span>
</span></span><span><span><span>)</span> <span>=</span> <span>/* ... selected at runtime */</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>// Maybe end up in Rust, maybe in assembly, who knows!
</span></span></span><span><span><span></span>callback<span>(</span><span>..</span><span>,</span> top_ptr<span>,</span> bottom_ptr<span>,</span> <span>..</span><span>,</span> top<span>,</span> bottom<span>);</span>
</span></span></code></pre></div><p>OK! Phew! Wow! This is great (or, sorry that happened to you), but what can we do about this?</p><h3 id="switch-it-up">Switch It Up</h3><blockquote><p>Move it up, down, left, right, oh - Switch it up like Nintendo ~ S. A. Carpenter</p></blockquote><p>Because we have this <code>*const FFISafe&lt;WithOffset&lt;..&gt;&gt;</code> at an <code>extern &#34;C&#34;</code> function boundary,
the compiler is more limited in what it can do with the values of <code>top</code>, <code>bottom</code>, and <code>dst</code>.</p><p>What if we switched it up?</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>#[derive(Clone, Copy)]</span>
</span></span><span><span><span>#[repr(C)]</span> <span>// &lt;- New!
</span></span></span><span><span><span></span><span>pub</span> <span>struct</span> <span>WithOffset</span><span>&lt;</span>T<span>&gt;</span> <span>{</span>
</span></span><span><span>    <span>pub</span> data: <span>T</span><span>,</span>
</span></span><span><span>    <span>pub</span> offset: <span>usize</span><span>,</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Then, we can change each variable from <code>*const FFISafe&lt;WithOffset&lt;?&gt;&gt;</code> to</p><p>For example, before we had something like:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>top: <span>*</span><span>const</span> FFISafe<span>&lt;</span>WithOffset<span>&lt;&amp;</span><span>&#39;a</span> <span>u8</span><span>&gt;&gt;</span>
</span></span></code></pre></div><p>We can change that to:</p><div><pre tabindex="0"><code data-lang="rust"><span><span>top: <span>WithOffset</span><span>&lt;*</span><span>const</span> FFISafe<span>&lt;&amp;</span><span>&#39;a</span> <span>u8</span><span>&gt;&gt;</span>
</span></span></code></pre></div><p>The key difference is that now, instead of creating an FFI-safe pointer to our arguments,
we actually destructure them and create new instances of <code>WithOffset</code>:</p><div><pre tabindex="0"><code data-lang="rust"><span><span><span>let</span> top: <span>WithOffset</span><span>&lt;&amp;</span><span>&#39;a</span> <span>u8</span><span>&gt;</span> <span>=</span> <span>/* an argument */</span><span>;</span>
</span></span><span><span>
</span></span><span><span><span>// Used to be `let top = FFISafe::new(&amp;top)`.
</span></span></span><span><span><span></span><span>let</span> top <span>=</span> WithOffset <span>{</span>
</span></span><span><span>    data: <span>FFISafe</span>::new<span>(</span><span>&amp;</span>top<span>.</span>data<span>),</span>
</span></span><span><span>    offset: <span>top</span><span>.</span>offset<span>,</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div><p>This should - in theory - let the compiler see we only use a single instance of each parameter at any given time.</p><p>But does it?</p><h2 id="will-it-blend">Will It Blend?</h2><p>We can use the same shtick for <code>dst</code> and <code>bot</code>,
and the final diff turns out shorter than this article ü´†.</p><details><summary>Click to see the full diff</summary><div><pre tabindex="0"><code data-lang="patch"><span><span>Avoid using `FFISafe&lt;WithOffset&lt;..&gt;&gt;` across FFI boundary
</span></span><span><span><span>---
</span></span></span><span><span><span></span>src/cdef.rs        | 61 ++++++++++++++++++++++++++++++++--------------
</span></span><span><span>src/with_offset.rs |  1 +
</span></span><span><span>2 files changed, 44 insertions(+), 18 deletions(-)
</span></span><span><span>
</span></span><span><span><span>diff --git a/src/cdef.rs b/src/cdef.rs
</span></span></span><span><span><span>index 3b58d2e6..46302f73 100644
</span></span></span><span><span><span></span><span>--- a/src/cdef.rs
</span></span></span><span><span><span></span><span>+++ b/src/cdef.rs
</span></span></span><span><span><span></span><span>@@ -19,6 +19,7 @@ use crate::include::common::bitdepth::LeftPixelRow2px;
</span></span></span><span><span><span></span>use crate::include::common::bitdepth::BPC;
</span></span><span><span>use crate::include::common::intops::apply_sign;
</span></span><span><span>use crate::include::common::intops::iclip;
</span></span><span><span><span>+use crate::include::dav1d::picture::Rav1dPictureDataComponent;
</span></span></span><span><span><span></span>use crate::include::dav1d::picture::Rav1dPictureDataComponentOffset;
</span></span><span><span>use crate::pic_or_buf::PicOrBuf;
</span></span><span><span>use crate::strided::Strided as _;
</span></span><span><span><span>@@ -55,9 +56,9 @@ wrap_fn_ptr!(pub unsafe extern &#34;C&#34; fn cdef(
</span></span></span><span><span><span></span>   damping: c_int,
</span></span><span><span>   edges: CdefEdgeFlags,
</span></span><span><span>   bitdepth_max: c_int,
</span></span><span><span><span>-    _dst: *const FFISafe&lt;Rav1dPictureDataComponentOffset&gt;,
</span></span></span><span><span><span>-    _top: *const FFISafe&lt;CdefTop&gt;,
</span></span></span><span><span><span>-    _bottom: *const FFISafe&lt;CdefBottom&gt;,
</span></span></span><span><span><span></span><span>+    _dst: WithOffset&lt;*const FFISafe&lt;Rav1dPictureDataComponent&gt;&gt;,
</span></span></span><span><span><span>+    _top: WithOffset&lt;*const FFISafe&lt;DisjointMut&lt;AlignedVec64&lt;u8&gt;&gt;&gt;&gt;,
</span></span></span><span><span><span>+    _bottom: WithOffset&lt;*const FFISafe&lt;PicOrBuf&lt;&#39;_, AlignedVec64&lt;u8&gt;&gt;&gt;&gt;,
</span></span></span><span><span><span></span>) -&gt; ());
</span></span><span><span> 
</span></span><span><span>pub type CdefTop&lt;&#39;a&gt; = WithOffset&lt;&amp;&#39;a DisjointMut&lt;AlignedVec64&lt;u8&gt;&gt;&gt;;
</span></span><span><span><span>@@ -87,12 +88,23 @@ impl cdef::Fn {
</span></span></span><span><span><span></span>       let left = ptr::from_ref(left).cast();
</span></span><span><span>       let top_ptr = top.as_ptr::&lt;BD&gt;().cast();
</span></span><span><span>       let bottom_ptr = bottom.wrapping_as_ptr::&lt;BD&gt;().cast();
</span></span><span><span><span>-        let top = FFISafe::new(&amp;top);
</span></span></span><span><span><span>-        let bottom = FFISafe::new(&amp;bottom);
</span></span></span><span><span><span></span>       let sec_strength = sec_strength as c_int;
</span></span><span><span>       let damping = damping as c_int;
</span></span><span><span>       let bd = bd.into_c();
</span></span><span><span><span>-        let dst = FFISafe::new(&amp;dst);
</span></span></span><span><span><span></span><span>+
</span></span></span><span><span><span>+        let dst = WithOffset {
</span></span></span><span><span><span>+            data: FFISafe::new(dst.data),
</span></span></span><span><span><span>+            offset: dst.offset,
</span></span></span><span><span><span>+        };
</span></span></span><span><span><span>+        let top = WithOffset {
</span></span></span><span><span><span>+            data: FFISafe::new(top.data),
</span></span></span><span><span><span>+            offset: top.offset,
</span></span></span><span><span><span>+        };
</span></span></span><span><span><span>+        let bottom = WithOffset {
</span></span></span><span><span><span>+            data: FFISafe::new(&amp;bottom.data),
</span></span></span><span><span><span>+            offset: bottom.offset,
</span></span></span><span><span><span>+        };
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>       // SAFETY: Rust fallback is safe, asm is assumed to do the same.
</span></span><span><span>       unsafe {
</span></span><span><span>           self.get()(
</span></span><span><span><span>@@ -385,18 +397,31 @@ unsafe extern &#34;C&#34; fn cdef_filter_block_c_erased&lt;BD: BitDepth, const W: usize, co
</span></span></span><span><span><span></span>   damping: c_int,
</span></span><span><span>   edges: CdefEdgeFlags,
</span></span><span><span>   bitdepth_max: c_int,
</span></span><span><span><span>-    dst: *const FFISafe&lt;Rav1dPictureDataComponentOffset&gt;,
</span></span></span><span><span><span>-    top: *const FFISafe&lt;CdefTop&gt;,
</span></span></span><span><span><span>-    bottom: *const FFISafe&lt;CdefBottom&gt;,
</span></span></span><span><span><span></span><span>+    dst: WithOffset&lt;*const FFISafe&lt;Rav1dPictureDataComponent&gt;&gt;,
</span></span></span><span><span><span>+    top: WithOffset&lt;*const FFISafe&lt;DisjointMut&lt;AlignedVec64&lt;u8&gt;&gt;&gt;&gt;,
</span></span></span><span><span><span>+    bottom: WithOffset&lt;*const FFISafe&lt;PicOrBuf&lt;&#39;_, AlignedVec64&lt;u8&gt;&gt;&gt;&gt;,
</span></span></span><span><span><span></span>) {
</span></span><span><span><span>-    // SAFETY: Was passed as `FFISafe::new(_)` in `cdef_dir::Fn::call`.
</span></span></span><span><span><span>-    let dst = *unsafe { FFISafe::get(dst) };
</span></span></span><span><span><span></span><span>+    let dst = WithOffset {
</span></span></span><span><span><span>+        // SAFETY: Was passed as `FFISafe::new(_)` in `cdef::Fn::call`.
</span></span></span><span><span><span>+        data: unsafe { FFISafe::get(dst.data) },
</span></span></span><span><span><span>+        offset: dst.offset,
</span></span></span><span><span><span>+    };
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>   // SAFETY: Reverse of cast in `cdef::Fn::call`.
</span></span><span><span>   let left = unsafe { &amp;*left.cast() };
</span></span><span><span><span>-    // SAFETY: Was passed as `FFISafe::new(_)` in `cdef::Fn::call`.
</span></span></span><span><span><span>-    let top = *unsafe { FFISafe::get(top) };
</span></span></span><span><span><span>-    // SAFETY: Was passed as `FFISafe::new(_)` in `cdef::Fn::call`.
</span></span></span><span><span><span>-    let bottom = *unsafe { FFISafe::get(bottom) };
</span></span></span><span><span><span></span><span>+
</span></span></span><span><span><span>+    let top = WithOffset {
</span></span></span><span><span><span>+        // SAFETY: Was passed as `FFISafe::new(_)` in `cdef::Fn::call`.
</span></span></span><span><span><span>+        data: unsafe { FFISafe::get(top.data) },
</span></span></span><span><span><span>+        offset: top.offset,
</span></span></span><span><span><span>+    };
</span></span></span><span><span><span>+
</span></span></span><span><span><span>+    let bottom = WithOffset {
</span></span></span><span><span><span>+        // SAFETY: Was passed as `FFISafe::new(_)` in `cdef::Fn::call`.
</span></span></span><span><span><span>+        data: *unsafe { FFISafe::get(bottom.data) },
</span></span></span><span><span><span>+        offset: bottom.offset,
</span></span></span><span><span><span>+    };
</span></span></span><span><span><span>+
</span></span></span><span><span><span></span>   let bd = BD::from_c(bitdepth_max);
</span></span><span><span>   cdef_filter_block_rust(
</span></span><span><span>       dst,
</span></span><span><span><span>@@ -632,9 +657,9 @@ mod neon {
</span></span></span><span><span><span></span>       damping: c_int,
</span></span><span><span>       edges: CdefEdgeFlags,
</span></span><span><span>       bitdepth_max: c_int,
</span></span><span><span><span>-        _dst: *const FFISafe&lt;Rav1dPictureDataComponentOffset&gt;,
</span></span></span><span><span><span>-        _top: *const FFISafe&lt;CdefTop&gt;,
</span></span></span><span><span><span>-        _bottom: *const FFISafe&lt;CdefBottom&gt;,
</span></span></span><span><span><span></span><span>+        _dst: WithOffset&lt;*const FFISafe&lt;Rav1dPictureDataComponent&gt;&gt;,
</span></span></span><span><span><span>+        _top: WithOffset&lt;*const FFISafe&lt;DisjointMut&lt;AlignedVec64&lt;u8&gt;&gt;&gt;&gt;,
</span></span></span><span><span><span>+        _bottom: WithOffset&lt;*const FFISafe&lt;PicOrBuf&lt;&#39;_, AlignedVec64&lt;u8&gt;&gt;&gt;&gt;,
</span></span></span><span><span><span></span>   ) {
</span></span><span><span>       use crate::align::Align16;
</span></span><span><span> 
</span></span><span><span><span>diff --git a/src/with_offset.rs b/src/with_offset.rs
</span></span></span><span><span><span>index b84c4bd2..06c8bc69 100644
</span></span></span><span><span><span></span><span>--- a/src/with_offset.rs
</span></span></span><span><span><span></span><span>+++ b/src/with_offset.rs
</span></span></span><span><span><span></span><span>@@ -7,6 +7,7 @@ use std::ops::Sub;
</span></span></span><span><span><span></span>use std::ops::SubAssign;
</span></span><span><span> 
</span></span><span><span>#[derive(Clone, Copy)]
</span></span><span><span><span>+#[repr(C)]
</span></span></span><span><span><span></span>pub struct WithOffset&lt;T&gt; {
</span></span><span><span>   pub data: T,
</span></span><span><span>   pub offset: usize,
</span></span><span><span><span>-- 
</span></span></span></code></pre></div></details><p>Now we can run <code>cargo asm</code> again:</p><div><pre tabindex="0"><code data-lang="llvm"><span><span><span>; rav1d::cdef_apply::rav1d_cdef_brow
</span></span></span><span><span><span>; Function Attrs: nounwind
</span></span></span><span><span><span></span><span>define</span> <span>internal</span> <span>fastcc</span> <span>void</span> @rav1d<span>::</span><span>cdef_apply:</span><span>:rav</span><span>1</span><span>d_cdef_brow</span><span>(...)</span> <span>{</span>
</span></span><span><span><span>start:</span>
</span></span><span><span>  %dst.i <span>=</span> <span>alloca</span> <span>[</span><span>16</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %bot5 <span>=</span> <span>alloca</span> <span>[</span><span>24</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %bot <span>=</span> <span>alloca</span> <span>[</span><span>24</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>8</span>
</span></span><span><span>  %variance <span>=</span> <span>alloca</span> <span>[</span><span>4</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>4</span>
</span></span><span><span>  %lr_bak <span>=</span> <span>alloca</span> <span>[</span><span>96</span> <span>x</span> <span>i8</span><span>],</span> <span>align</span> <span>16</span>
</span></span><span><span>  %_17 <span>=</span> <span>icmp</span> <span>sgt</span> <span>i32</span> %by_start<span>,</span> <span>0</span>
</span></span><span><span>  %. <span>=</span> <span>select</span> <span>i1</span> %_17<span>,</span> <span>i32</span> <span>12</span><span>,</span> <span>i32</span> <span>8</span>
</span></span></code></pre></div><p>It‚Äôs not <em>perfect</em> - we didn‚Äôt have these extra <code>bot</code> and <code>bot5</code> in our <a href="#peeking-under-the-hood">original fix</a> - but it‚Äôs much better! Let‚Äôs run the profiler üé∂ <em>one last time</em> üé∂.</p><p>Remember: <code>cdef_filter4_pri_edged_8bpc_neon</code> had 1,562 samples in the slow Rust baseline, vs. 1,199 in <code>dav1d</code>.</p><p>Yes! We are down from 1,562 <strong>to 1,260!</strong> samples (which is within 5% of <code>dav1d</code>),</p><p>Huzzah!</p></div></div></div>
  </body>
</html>
