<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.infoq.com/news/2023/07/linkedin-protocol-buffers-restli/">Original</a>
    <h1>LinkedIn adopts protocol buffers and reduces latency up to 60%</h1>
    
    <div id="readability-page-1" class="page"><div>
								<p>LinkedIn <a href="https://engineering.linkedin.com/blog/2023/linkedin-integrates-protocol-buffers-with-rest-li-for-improved-m">adopted Protocol Buffers for exchanging data between microservices</a> more efficiently across its platform and integrated it with <a href="https://linkedin.github.io/rest.li/">Rest.li</a>, their open-source REST framework. After the company-wide rollout, they reduced the latency by up to 60% and improved resource utilization at the same time.</p>

<p>The LinkedIn platform employs a microservices architecture, and for years now, <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> has been used as the serialization format for over 50 thousand API endpoints exposed by microservices at LinkedIn. To help their teams build consistent interactions between services, the company created a Java framework called Rest.li, which became open-sourced.</p>

<p>The framework helps create servers and clients that use the <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> style of communication and abstracts away many aspects of data exchange, including networking, serialization, or service discovery. It primarily supports Java and Python but can also work with Scala, Kotlin, JavaScript, Go, etc.</p>

<p><img alt="" data-src="news/2023/07/linkedin-protocol-buffers-restli/en/resources/1RestLiClientServerFlow-1689612288438.jpeg" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2023/07/linkedin-protocol-buffers-restli/en/resources/1RestLiClientServerFlow-1689612288438.jpeg" rel="share"/></p>

<p><em>Data and Control Flow Between a Rest.li Server and Client (Source: <a href="https://linkedin.github.io/rest.li/user_guide/server_architecture">Rest.li Documentation</a>)</em></p>

<p>JSON is the default serialization format in Rest.li and has been selected due to its wide language support and being human-readable. The last property, however beneficial, introduces problems from the performance (and particularly latency) point of view.</p>

<p><a href="https://www.linkedin.com/in/karthikrg/">Karthik Ramgopal</a> and <a href="https://www.linkedin.com/in/aman1309/">Aman Gupta</a>, engineers at LinkedIn, share challenges with using JSON for inter-service communication:</p>

<blockquote>
<p>The first challenge is that JSON is a textual format, which tends to be verbose. This results in increased network bandwidth usage and higher latencies, which is less than ideal. [...] The second challenge we faced was that due to the textual nature of JSON, serialization and deserialization latency and throughput were suboptimal.</p>
</blockquote>

<p>The team has been considering alternatives to JSON, looking for a compact payload size and high serialization efficiency to reduce latency and increase throughput. They also didn’t want to limit the number of supported language stacks and enable gradual migration by integrating the new serialization mechanism into Rest.li. Finally, after a comprehensive review, they decided to go with <a href="https://protobuf.dev/">Protocol Buffers (Protobuf)</a>, which scored the highest, based on the defined criteria.</p>

<p>The main difficulty around integrating Protocol Buffers into Rest.li was the dynamic schema generation based on the framework&#39;s custom schema definition system, <a href="https://linkedin.github.io/rest.li/pdl_schema">PDL</a>. The solution involved generating a symbol table that is used to generate Protobuf schema definition dynamically, but the method for delivering symbol tables varied depending on the type of client. Backend clients fetch and cache symbol tables on-demand, while for web/mobile apps, symbol tables are generated at build-time and included as versioned dependencies.</p>

<p>After changes to the framework were rolled out, the team gradually reconfigured the clients to enable Protobuf instead of JSON using HTTP headers. The result of Protocol Buffers adoption was an average increase in throughput by 6.25% for responses and 1.77% for requests. The team also observed up to 60% latency reduction for large payloads.</p>

<p><img alt="" data-src="news/2023/07/linkedin-protocol-buffers-restli/en/resources/1linkedin-restli-protobuf-1689612288438.jpeg" src="https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/news/2023/07/linkedin-protocol-buffers-restli/en/resources/1linkedin-restli-protobuf-1689612288438.jpeg" rel="share"/></p>

<p><em>Latency comparison between JSON and Protobuf (Source: <a href="https://engineering.linkedin.com/blog/2023/linkedin-integrates-protocol-buffers-with-rest-li-for-improved-m">LinkedIn Integrates Protocol Buffers With Rest.li for Improved Microservices Performance</a>)</em></p>

<p>Based on the learnings from the Protocol Buffers rollout, the team is planning to follow up with migration from Rest.li to <a href="https://grpc.io/">gRPC</a>, which also uses Protocol Buffers but additionally supports streaming and has a large community behind it.</p>

<p>See also the InfoQ Podcast: <a href="https://www.infoq.com/podcasts/api-showdown-rest-graphql-grpc/">API Showdown: REST vs. GraphQL vs. gRPC – Which Should You Use?</a></p>

								









  
    

							</div></div>
  </body>
</html>
