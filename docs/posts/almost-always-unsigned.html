<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://graphitemaster.github.io/aau/">Original</a>
    <h1>Almost Always Unsigned</h1>
    
    <div id="readability-page-1" class="page"><article>
<p>Written by Dale Weiler</p>
<ul>
<li>
  <a href="https://twitter.com/actualGraphite">Twitter</a></li>
<li>
  <a href="https://github.com/graphitemaster">GitHub</a></li>
</ul>
<p>Last updated Saturday, January 1, 2022</p>
<p>The need for signed integer arithmetic is often misplaced as most integers
never represent negative values within a program. The indexing of arrays and
iteration count of a loop reflects this concept as well. There should be a
propensity to use unsigned integers more often than signed, yet despite this,
most code incorrectly choses to use signed integers almost exclusively.</p>
<p>Most of the motivation of this article applies to C and C++, but examples for
other languages such as Go, Rust and 
  <a href="https://odin-lang.org/">Odin</a> will also be
presented in an attempt to establish that this concept applies to all
languages, regardless of their choices (for instance C and C++ leave signed
integer wrap undefined), but rather is intrinsic to the arithmetic itself.</p>
<h2 id="the-arguments-against-unsigned">
  The arguments against unsigned
  <a href="#the-arguments-against-unsigned">#</a>
</h2>
<p>There are a lot of arguments against the use of unsigned integers. Let me
explain why I think they’re mostly incorrect.</p>
<h3 id="the-safety-argument">
  The safety argument
  <a href="#the-safety-argument">#</a>
</h3>
<p>The most typical argument against the use of unsigned integers is that it’s
more error prone since it’s far easier for an expression to underflow than it
is to overflow. This advice is so common that the official

  <a href="https://google.github.io/styleguide/cppguide.html#Integer_Types">Google C++ Style Guide</a>
outright discourages the use of unsigned types.</p>
<p>We’ll see in the following arguments where these safety issues come from and how
to easily avoid them with trivial idioms that are easier to understand than
using signed everywhere. We’ll also see that these arguments are incorrect most
of the time as they encourage continuing to write and use unsafe code.</p>
<h3 id="the-loop-in-reverse-argument">
  The loop in reverse argument
  <a href="#the-loop-in-reverse-argument">#</a>
</h3>
<p>When the counter of a for loop needs to count in reverse and the body of
the loop needs to execute when the counter is also zero, most programmers will
find unsigned difficult to use because <code>i &gt;= 0</code> will always evaluate <code>true</code>.</p>
<p>The temptation is to cast the unsigned value to a signed one, e.g:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>for</span> (<span>int64_t</span> i <span>=</span> <span>int64_t</span>(size) <span>-</span> <span>1</span>; i <span>&gt;=</span> <span>0</span>; i<span>--</span>) {
    <span>// ...
</span><span></span>}
</code></pre></div><p>Of course this is dangerous as it’s a narrowing conversion, with a cast which
silences a legitimate warning. In C and C++ it invokes undefined behavior when
given specific large values and most certainly is exploitable. Most applications
would just crash on inputs <code>&gt;= 0x7ffffffffffffffff</code>. The typical argument is
that such a value would be “pathological”. Not only is this argument incorrect,
it’s even more dangerous which we will see later.</p>
<p>This danger is one of the supporting arguments behind always using signed
integer arithmetic. The argument is incorrect though, because <code>int64_t</code> would
never permit a value <code>&gt;= 0x7ffffffffffffffff</code>. It’s only avoiding the issue in
that the specific problematic numeric range above that limit is no longer allowed.
Tough luck if you needed a value that large and if you followed the sage advice
of Google to always used signed and had that large value, well now you have a
significantly worse problem, as you now invoked signed overflow unconditionally.
Which for languages like C and C++, invoke undefined behavior. While languages
like Go and Odin will wrap and have the wrong numeric ranges in the loop
as a result of that wrap behavior.</p>
<p>The correct approach here is that unsigned underflow is well-defined in C and
C++ and we should be teaching the behavior of wrapping arithmetic as it’s
useful in general, but it also makes reverse iteration as easy as forward.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>for</span> (size_t i <span>=</span> size <span>-</span> <span>1</span>; i <span>&lt;</span> size; i<span>--</span>) {
    <span>// ...
</span><span></span>}
</code></pre></div><p>The approach here is to begin from <code>size - 1</code> and count down on each iteration.
When the counter reaches zero, the decrement causes the counter to underflow and
wrap around to the max possible value of the unsigned type. This value is far
larger than <code>size</code>, so the condition <code>i &lt; size</code> evaluates false and the loop
stops.</p>
<p>Languages like Rust chose to make even unsigned underflow a trap representation
in Debug builds, but specific features like <code>Range</code> will let you safely achieve
the same efficient wrapping behavior on underflow with much cleaner syntax.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>for</span> i <span>in</span> (<span>0</span><span>..</span>size).rev() {
    <span>// ...
</span><span></span>}
</code></pre></div><p>With this approach, no casts are needed, no silent bugs are introduced, and
the “pathological” input still works correctly. In fact, this form permits every
possible value from <code>[0, 0xffffffffffffffff)</code>, covering the entire range.</p>
<p>It should be noted that if <code>size == 0</code> these loops still work because <code>0 - 1</code>
produces the largest possible value of the unsigned type which is larger than
<code>size</code> (still <code>0</code>) and so the loop never enters.</p>
<h3 id="the-difference-of-two-numbers-can-become-negative">
  The difference of two numbers can become negative
  <a href="#the-difference-of-two-numbers-can-become-negative">#</a>
</h3>
<p>When you want to compute the difference (or delta) between two numbers, it’s
often the case to want to express that as:</p>
<p>Although most of the time the sign isn’t needed so you tend to write and see:</p>
<p>The argument is that unsigned is dangerous here because if <code>y &gt; x</code> then you get
underflow. The problem with this argument is it’s not valid because the code
itself is simply incorrect regardless of the signedness of <code>x</code> and <code>y</code>. There
are values for both <code>x</code> and <code>y</code> which will lead to signed integer underflow.
So like before, in languages like C and C++, you just unconditionally invoked
undefined behavior since signed integer underflow is undefined.</p>
<p>It turns out that computing differences safely is actually quite hard for
signed integers because of underflow, even in languages which support wrapping
behavior for them, e.g <code>INT_MAX - INT_MIN</code> is still going to be incorrect even.
There just isn’t a trivial way to do this safely; this is the best technique
I currently know of.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>if</span> ((y <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> x <span>&lt;</span> INT_MIN <span>+</span> y) <span>||</span> (y <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> x <span>&gt;</span> INT_MAX <span>+</span> y)) {
    <span>// error
</span><span></span>} <span>else</span> {
    delta <span>=</span> abs(x <span>-</span> y);
}
</code></pre></div><p>For unsigned integers however, it’s much easier to just write</p>
<div><pre tabindex="0"><code data-lang="cpp">delta <span>=</span> max(x, y) <span>-</span> min(x, y);
</code></pre></div><p>This will always give the absolute difference safely. It might be personal
preference, but I find this easier to read too. The name <code>delta</code> is no longer
necessary as the expression is self-documenting.</p>
<h3 id="computing-indices-with-signed-arithmetic-is-safer">
  Computing indices with signed arithmetic is safer
  <a href="#computing-indices-with-signed-arithmetic-is-safer">#</a>
</h3>
<p>An extension to the above argument is that if you have a more complicated
expression to compute an index it’s just safer to express that with signed.
I think this argument primarily comes from an invalid intuition of underflow
and overflow, yet it manifests for signed in significantly worse ways.</p>
<p>Lets take the most trivial “slightly more complicated” expression to compute an
index as an example: the middle of interval.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>int</span> mid <span>=</span> (low <span>+</span> high) <span>/</span> <span>2</span>;
</code></pre></div><blockquote>
<p>I picked this as a real-world, non-contrived example. You can expect to find
this in binary searches, merge sort, and pretty much any other divide-and-conquer
algorithm.</p>
</blockquote>
<p>This is how most people would write it. The average of low and high, truncated
to the nearest integer. When the sum of <code>low</code> and <code>high</code> exceeds <code>2^31-1</code> the
sum overflows to a negative value and the negative stays negative when divided.
Using a larger signed integer type here does not save you either because it’s
easy for the sum to exceed <code>2^63-1</code> too.</p>
<p>Like the previous example, this code is just not ideal.</p>
<p>In fact, computing the mid-point of two variables safely is pretty much
impossible in any language without the help of a library function because
with wrapping or otherwise, there are specific inputs that fail.</p>
<p>One common solution for signed is to rewrite it to this idiom, which still fails
for <code>high = INT_MAX</code> and <code>low = INT_MIN</code>.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>int</span> mid <span>=</span> low <span>+</span> (high <span>-</span> low) <span>/</span> <span>2</span>;
</code></pre></div><p>Sticking with unsigned integers, you might think you can write it the obvious
way you originally intended to precisely because underflow is well-defined
but we’ll see that this has problems too.</p>
<div><pre tabindex="0"><code data-lang="cpp">size_t mid <span>=</span> (low <span>+</span> high) <span>/</span> <span>2</span>;
</code></pre></div><p>This doesn’t actually work for e.g: <code>low = 0x80000000</code> and <code>high = 0x80000002</code>,
which would underflow and produce <code>2</code> which divided by <code>2</code> produces <code>1</code>, when
the correct value is actually <code>0x80000001</code>.</p>
<p>Where unsigned does benefit here is when these are used as indices into an array.
The signed behavior will almost certainly produce invalid indices which leads to
memory unsafety issues. The unsigned way will never do that, it’ll stay bounded,
even if the index it produces is actually wrong. This is a much less-severe
logic bug, but can still be used maliciously depending on context.</p>
<p>The correct safe way to do this regardless of signedness is to convert
everything to unsigned and account for the wrapping with masked addition.</p>
<div><pre tabindex="0"><code data-lang="cpp">T <span>midpoint</span>(T x, T y) {
    <span>// U is the unsigned version of your type T, or same as T if T already unsigned
</span><span></span>    <span>// digits is the number of numeric digits (not including sign) in your type T.
</span><span></span>    <span>// std::numeric_limits&lt;T&gt;::digits in C++ is helpful here.
</span><span></span>    U shift <span>=</span> digits <span>-</span> <span>1</span>;
    U difference <span>=</span> (U)x <span>-</span> (U)y;
    U sign <span>=</span> y <span>&lt;</span> x;
    U half <span>=</span> (difference <span>/</span> <span>2</span>) <span>+</span> (sign <span>&lt;&lt;</span> shift) <span>+</span> (sign <span>&amp;</span> difference);
    T mid <span>=</span> (T)(x <span>+</span> half);
    <span>return</span> mid;
}
</code></pre></div><blockquote>
<p>C++ actually has <code>std::midpoint</code> which does precisely this.</p>
</blockquote>
<h3 id="unsigned-multiplication-can-overflow">
  Unsigned multiplication can overflow
  <a href="#unsigned-multiplication-can-overflow">#</a>
</h3>
<p>When multiplying unsigned variables it’s a concern that such expressions will
easily overflow and produce a value far smaller than the correct value. This is
a very common complaint for memory safety specifically because unsigned
multiplication is most often seen when allocating arrays. It’s tempting to write
the following in C.</p>
<div><pre tabindex="0"><code data-lang="c">malloc(<span>sizeof</span>(Object) <span>*</span> n)
</code></pre></div><p>If such an expression were to overflow then <code>malloc</code> will allocate and return
a pointer for memory not actually sufficiently large for all <code>n</code> <code>Object</code>. Again,
signed here does not save us, in practice this will silently avoid the memory
safety issue by over-allocating around 4 GiB of memory had you used <code>int</code> since
a negative casted to <code>size_t</code> becomes about that large. Random resource
exhaustion is not exactly a better situation to be in either.</p>
<p>There are a couple better ways to write this. The first obvious one is just
use <code>calloc</code>. That does have a zeroing cost though and doesn’t help if you need
to <code>realloc</code>.</p>
<p>Languages like C++ and Go noticed this problem and solved them in cleaner ways,
eliminating the need for the dangerous multiply.</p>
<ul>
<li>C++
</li>
<li>Go
<div><pre tabindex="0"><code data-lang="go">make([]<span>Object</span>, <span>n</span>);

<span>// But it also even has an explicit n * m form as well.
</span><span></span>make([]<span>Object</span>, <span>n</span>, <span>m</span>);
</code></pre></div></li>
</ul>
<p>Those don’t apply generally though. It’s very trivial to check if <code>x * y</code> would
overflow though and you should just learn the extremely simple and obvious test.</p>
<blockquote>
<p>Where <code>(T)-1</code> here is your unsigned type and casting <code>-1</code> just gives you the max
value, i.e every bit set. You can also use <code>~((T)0)</code>, <code>UINT{8,16,32,64}?_MAX</code>,
or <code>numeric_limits&lt;T&gt;::max()</code> in C++, there’s a lot of ways to compute this value.</p>
</blockquote>
<h3 id="sentinel-values">
  Sentinel values
  <a href="#sentinel-values">#</a>
</h3>
<p>One extremely common use of signed integers is using the negative range to encode
an error code or some 
  <a href="https://en.wikipedia.org/wiki/Sentinel_value">sentinel value</a>.
This is a terrible programming practice and a literal category error. It’s pretty
unavoidable when working with existing or legacy code that is designed around it,
but it’s not a strong argument of signed integers for continuing this practice.
You can still have sentinels with unsigned too, not that you should.</p>
<p>We should not be encouraging this and using it as an argument in favor of signed.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>int</span> result <span>=</span> connect();
<span>if</span> (result <span>&gt;=</span> <span>0</span>) <span>// ...
</span></code></pre></div><p>Where anything but a positive value is an error.</p>
<blockquote>
<p>This is typical of early C.</p>
</blockquote>
<p>There are multiple better and safer ways to express this, for instance.</p>
<ul>
<li>
<p>An out parameter for the result. Not exactly clean looking though.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>if</span> (uint result; connect(<span>&amp;</span>result)) {
    <span>// ...
</span><span></span>}
</code></pre></div></li>
<li>
<p>A return of a tuple or pair. Little nicer looking.</p>
<div><pre tabindex="0"><code data-lang="cpp">tuple<span>&lt;</span><span>bool</span>, uint<span>&gt;</span> result <span>=</span> connect();
pair<span>&lt;</span><span>bool</span>, uint<span>&gt;</span> result <span>=</span> connect();
<span>if</span> (get<span>&lt;</span><span>0</span><span>&gt;</span>(result)) {
    <span>// ...
</span><span></span>}
</code></pre></div></li>
<li>
<p>We could use an option type. Quite common in Rust.</p>
<div><pre tabindex="0"><code data-lang="rust"><span>// connect returns Option&lt;u32&gt;
</span><span></span><span>match</span> connect() {
Some(<span>u32</span>) <span>=&gt;</span> <span>// ...
</span><span></span>None      <span>=&gt;</span> <span>// error
</span><span></span>}
</code></pre></div></li>
<li>
<p>However, if the numeric range is well-defined to begin with, just define
the entire domain and avoid using full-range integers to represent a subset
of all the possible values.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>enum</span> <span>class</span> <span>ConnectionStatus</span> <span>:</span> <span>unsigned</span> {
    Connected,
    NoRouteToHost,
    Disconnected,
    TimedOut,
};

ConnectionStatus status <span>=</span> connect();
<span>if</span> (status <span>==</span> ConnectionStatus<span>::</span>Connected) {
    <span>// ...
</span><span></span>}
</code></pre></div></li>
<li>
<p>Some languages like Odin and Go have multiple return and the preferred
idiomatic way is the following.</p>
<div><pre tabindex="0"><code data-lang="go">    <span>status</span>, <span>err</span> <span>:=</span> <span>connect</span>();
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> {
        <span>// ...
</span><span></span>    }
</code></pre></div></li>
</ul>
<p>These are all superior methods which eliminate the need to encoding error states
in the negative portion of a signed integer and are all representable in almost
any language.</p>
<h3 id="its-the-default">
  It’s the default
  <a href="#its-the-default">#</a>
</h3>
<p>This is a weak argument, but it’s at least the only one that is hard to refute.
C and C++ default <code>int</code> to signed and that’s a legacy choice that has persisted
in many languages that are descendants of C. It’s generally agreed upon now that
a lot of defaults in C were bad, maybe we should consider this too?</p>
<h2 id="what-if-signed-was-defined-to-wrap">
  What if signed was defined to wrap?
  <a href="#what-if-signed-was-defined-to-wrap">#</a>
</h2>
<p>Some languages like Go and 
  <a href="https://odin-lang.org/">Odin</a> claim to avoid these
problems because signed integer arithmetic is defined to wrap on underflow and
overflow. The safety arguments there are incorrect as well. In all the previous
examples, if the signed integers wrapped, they would almost always produce
negative values which would either introduce silent logic bugs, or worse,
memory safety issues if used as indices into arrays as an example.</p>
<blockquote>
<p>The only way to ever make safe use of signed integers in this manner is to
bounds check all array accesses, which has a appreciable, non-negligible runtime
cost. Bounds checking is also quite error prone if not automated as it’s easy
to forget to check and often unmaintained under code refactoring.</p>
</blockquote>
<p>Unfortunately, for languages based on LLVM, no amount of hand-waving and wanting
signed wrapping to be defined will work no matter how hard you try, so such
statements about safety are factually incorrect. Here’s a somewhat non-exhaustive
list of all the undefined behavior of signed integer arithmetic in LLVM which
applies to all languages which use LLVM:</p>
<ul>
<li><code>x / 0</code></li>
<li><code>INT_MIN / -1</code></li>
<li><code>INT_MAX % -1</code></li>
<li><code>INT_MAX - INT_MIN</code></li>
</ul>
<blockquote>
<p>These are certain to produce invalid results in languages like Go, Rust, and Odin.</p>
</blockquote>
<h2 id="what-about-trapping">
  What about trapping?
  <a href="#what-about-trapping">#</a>
</h2>
<p>Some languages such as Rust take a different approach where any integer underflow
or overflow in debug builds will lead to a trap representation where your program
will panic. Sanitizers for C and C++ also exist to help detect these problems and
because C and C++ define unsigned underflow to wrap, it’s actually the case that
the use of signed integers is better as it’s the only way you can get trap
behavior for integers, as using it on unsigned would trigger trap representations
for valid code that relies on that behavior.</p>
<p>Trap representations are actually quite insufficient as they can only trigger at
runtime when those paths are successfully executed with the correct trap-producing
inputs. This coverage is impossible to expect in any non-trivial program even
with exhaustive unit testing. The idea is also incompatible in many contexts such
as library code where you almost never want the library to panic, but rather all
errors be recoverable by the calling application code, or in service-availability
sensitive code which must not be susceptible to denial of service attacks,
where a panic is pretty much not acceptable.</p>
<h2 id="your-counter-arguments-are-about-pathological-inputs">
  Your counter arguments are about pathological inputs
  <a href="#your-counter-arguments-are-about-pathological-inputs">#</a>
</h2>
<p>It’s been my experience that our intuition of what is and isn’t a pathological
or malicious input is about as accurate as time estimates. Requirements change
and any and all attack vectors will be found and exploited. The mental burden
of remembering the assumptions made to correctly check for pathological or
malicious inputs in all cases and keep them updated during refactoring is far
too enormous to successfully maintain.</p>
<p>One of the most famous cases of this stubborn attitude is the 
  <a href="https://www.guninski.com/where_do_you_want_billg_to_go_today_4.html">infamous qmail
64-bit remote code execution exploit</a> which Daniel J. Bernstein denied a bounty
for and can still be 
  <a href="https://www.qualys.com/2020/05/19/cve-2005-1513/">exploited as of 2020</a></p>
<p>These are:</p>
<blockquote>
<p>“classical <strong>signed</strong> integer overflow, pointer with <strong>signed</strong>
index and <strong>signedness</strong> problems”</p>
</blockquote>
<p>Writes the very exploit author.</p>
<p>The use of unsigned integer arithmetic not only prevents these bugs, it forces
you to think about pathological and malicious inputs more directly because it
becomes more evident.</p>
<h2 id="the-arguments-for-unsigned">
  The arguments for unsigned
  <a href="#the-arguments-for-unsigned">#</a>
</h2>
<h3 id="most-integers-in-a-program-never-represent-negative-values">
  Most integers in a program never represent negative values
  <a href="#most-integers-in-a-program-never-represent-negative-values">#</a>
</h3>
<p>The use of unsigned is a good type indication of the numeric range of the
integer, in much the same way sized integer types are too. The immediate
ability to disregard negative quantities is one of the largest benefits to
actually using unsigned variables. It’s a simple observation to make that most
values in a program never actually are negative and never can become negative,
we should be encoding that intent and behavior within the type system for the
added safety and benefits it provides.</p>
<p>I cannot find a research paper I once read from Intel which claimed from their
observations that <strong>only 3% of the integers</strong> in an entire desktop x86 Windows
system <strong>ever represented negative values</strong>. Regardless, if that 3% figure is
correct, then given the above opinion, I would expect to see ~97% of integer
types in a codebase being unsigned.</p>
<h3 id="compiler-diagnostics-are-better-for-unsigned-but-thats-worse-overall">
  Compiler diagnostics are better for unsigned but that’s worse overall
  <a href="#compiler-diagnostics-are-better-for-unsigned-but-thats-worse-overall">#</a>
</h3>
<p>If safety is one of the primary motivations behind the use of signed integer
arithmetic, yet signed integers don’t seem to actually avoid the very bugs
it is claimed they do, you might be wondering where the idea came from in the
first place.</p>
<p>If you’ve ever <em>mixed</em> the use of signed and unsigned in a codebase you’ll
likely be familiar with the amount of warning diagnostics they emit. These
diagnostics are unfortunately provided with the intent of being helpful, but
in practice are actively malicious because they encourage silencing in the form
of unsafe type casting.</p>
<p>The reality is that the use of signed and unsigned paints all your integers red
or blue, respectively. 
  <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">What color is Your Function</a>. The more of one you use, the more likely it is
everything will also share the same signedness regardless of if it’s appropriate.
Since most integers never require representing negative values, I personally
think it’s more appropriate to paint everything blue in this case. The exception
is negative integer values. The rule is mostly positive integer values. The
default of any programming language should align with the rule, rather than the
exception.</p>
<h3 id="checking-for-overflow-and-underflow-is-easier-and-safer">
  Checking for overflow and underflow is easier and safer
  <a href="#checking-for-overflow-and-underflow-is-easier-and-safer">#</a>
</h3>
<p>Since C and C++ make signed integer overflow and underflow undefined, it’s
almost impossible to write safe, correct, and obvious code to check for it.</p>
<p>So simple, obvious tests like the following:</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>if</span> (x <span>+</span> y <span>&lt;</span> x) <span>// addition overflows
</span><span></span><span>if</span> (x <span>-</span> y <span>&gt;</span> x) <span>// subtraction underflows
</span></code></pre></div><p>Will either get compiled away, or miscompiled as it invokes undefined behavior.</p>
<blockquote>
<p>This is perfectly fine and safe for unsigned integers.</p>
</blockquote>
<blockquote>
<p>In languages which have defined signed wrap such as Odin, this should work as well except for <code>INT_MIN</code> and <code>INT_MAX</code> as previously mentioned due to LLVM.</p>
</blockquote>
<p>For a fun laugh, this is the only correct way (that I know of) to detect for
signed integer overflow and underflow in standard C or C++.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span>if</span> ((b <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> a <span>&gt;</span> INT_MAX <span>-</span> b) <span>||</span> (b <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> a <span>&lt;</span> INT_MIN <span>-</span> b)) <span>// addition overflows
</span><span></span><span>if</span> ((b <span>&gt;</span> <span>0</span> <span>&amp;&amp;</span> a <span>&lt;</span> INT_MIN <span>+</span> b) <span>||</span> (b <span>&lt;</span> <span>0</span> <span>&amp;&amp;</span> a <span>&gt;</span> INT_MAX <span>+</span> b)) <span>// subtraction underflows
</span></code></pre></div><blockquote>
<p>Good luck remembering and typing these monstrosities when you need it.</p>
</blockquote>
<h3 id="your-code-will-be-simpler-and-faster">
  Your code will be simpler and faster
  <a href="#your-code-will-be-simpler-and-faster">#</a>
</h3>
<p>In addition to all the examples I’ve already shown where unsigned just does the
right thing, almost all code that uses signed integers to represent values that
will never be negative, tends to have a cacophony of range assertions and other
tests which are just as error-prone as bounds checking to remembering to write,
but also maintain when refactoring. It’s truly underappreciated how much those
tests can be eliminated if your integer can never actually become negative due
to the type system itself. It’s extremely similar to not having raw pointers, in
that you never have to check for null pointers. In many ways signed integers are
the null pointers of integers.</p>
<p>There are some optimizations compilers can make assuming signed integers cannot
underflow or overflow that unsigned does not get to participate in. What is less
known is that 
  <a href="https://en.wikipedia.org/wiki/Value_range_analysis">value range analysis</a>
is an optimization that can apply to any numeric type of any numeric range in
modern 
  <a href="https://developers.redhat.com/blog/2021/04/28/value-range-propagation-in-gcc-with-project-ranger">optimizing compilers</a>. The <code>enum</code> example from
earlier is something where this would apply, despite that being an unsigned type.
You can define numeric ranges as compiler hints with simple guiding branches,
e.g: the expression <code>b = a + 2</code> immediately establishes that <code>b &gt; a</code>, which the
compiler can use to optimize later.</p>
<h3 id="it-actually-works">
  It actually works
  <a href="#it-actually-works">#</a>
</h3>
<p>You might be wondering how possible it is to actually use unsigned almost always
as this title suggests. It’s been my personal preference for half a decade now
and I haven’t actually missed signed integers since switching to it. It’s made
my code much easier, cleaner, and more robust contrary to popular wisdom.</p>
<p>I would not suggest trying to use it in an existing codebase that is mostly
signed integers, in such contexts you’re more likely to introduce silent bugs
and issues as a result of unsafe type casts. But consider trying it next time
you start a new project, you might be pleasantly surprised.</p>
</article></div>
  </body>
</html>
