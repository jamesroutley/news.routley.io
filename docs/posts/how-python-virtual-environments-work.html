<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://snarky.ca/how-virtual-environments-work/">Original</a>
    <h1>How Python virtual environments work</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>After needing to do a deep dive on the <a href="https://docs.python.org/3/library/venv.html#module-venv"><code>venv</code> module</a> (which I will explain later in this blog post as to why), I thought I would explain how virtual environments work to help demystify them.</p><h2 id="why-do-virtual-environments-exist">Why do virtual environments exist?</h2><p>Back in <s>my</s> the day, there was no concept of <em>environments</em> in Python: all you had was your Python installation and the current directory. That meant when you installed something you either installed it globally into your Python interpreter or you just dumped it into the current directory. Both of these approaches had their drawbacks.</p><p>Installing globally meant you didn&#39;t have any isolation between your projects. This led to issues like version conflicts between what one of your projects might need compared to another one. It also meant you had no idea what requirements your project actually had since you had no way of actually testing your assumptions of what you needed. This was an issue if you needed to share you code with someone else as you didn&#39;t have a way to test that you weren&#39;t accidentally wrong about what your dependencies were.</p><p>Installing into your local directory didn&#39;t isolate your installs based on Python version or interpreter version (or even interpreter build type, back when you had to compile your extension modules differently for debug and release builds of Python). So while you could install everything into the same directory as your own code (which you did, and thus didn&#39;t use <code>src</code> directory layouts for simplicity), there wasn&#39;t a way to install different wheels for each Python interpreter you had on your machine so you could have multiple environments per project (I&#39;m glossing over the fact that back in <s>my</s> the day you also didn&#39;t have wheels or editable installs).</p><p>Enter <em>virtual environments</em>. Suddenly you had a way to install projects as a group that was tied to a specific Python interpreter. That got us the isolation/separation of only installing things you depend on (and being able to verify that through your testing), as well has having as many environments as you want to go with your projects (e.g. an environment for each version of Python that you support). So all sorts of wins! It&#39;s an important feature to have while doing development (which is why it can be rather frustrating for users when Python distributors leave <code>venv</code> out).</p><h2 id="how-do-virtual-environments-work">How do virtual environments work?</h2><div><p>üí°</p><p>Virtual environments are different than <em>conda environments</em> (in my opinion; some people disagree with me on this view). The key difference is that conda environments allow projects to install arbitrary shell scripts which are run when you activate a conda environment (which is done implicitly when you use <code>conda run</code>). This is why you are always expected to activate a conda environment, as some conda packages require those those shell scripts run. I won&#39;t be covering conda environments in this post.</p></div><h2 id="their-structure">Their structure</h2><p>There are two parts to virtual environments: their directories and their configuration file. As a running example, I&#39;m going to assume you ran the command <code>py -m venv --without-pip .venv</code> in some directory on a Unix-based OS (you can substitute <code>py</code> with whatever Python interpreter you want, including the <a href="https://python-launcher.app/">Python Launcher for Unix</a>).</p><div><p>‚ùó</p><p>For simplicity I&#39;m going to focus on the Unix case and not cover Windows in depth.</p></div><p>A virtual environment has 3 directories and potentially a symlink in the virtual environment directory (i.e. within <code>.venv</code>):</p><ol><li><code>bin</code> ( <code>Scripts</code> on Windows)</li><li><code>include</code> ( <code>Include</code> on Windows)</li><li><code>lib/pythonX.Y/site-packages</code> where <code>X.Y</code> is the Python version (<code>Lib/site-packages</code> on Windows)</li><li><code>lib64</code> symlinked to <code>lib</code> if you&#39;re using a 64-bit build of Python that&#39;s on a POSIX-based OS that&#39;s not macOS</li></ol><p>The Python executable for the virtual environment ends up in <code>bin</code> as various symlinks back to the original interpreter (e.g. <code>.venv/bin/python</code> is a symlink; Windows has a different story). The <code>site-packages</code> directory is where projects get installed into the virtual environment (including <code>pip</code> if you choose to have it installed into the virtual environment). The <code>include</code> directory is for any header files that might get installed for some reason from a project. The <code>lib64</code> symlink is for consistency on those Unix OSs where they have such directories.</p><p>The configuration file is <code>pyvenv.cfg</code> and it lives at the top of your virtual environment directory (e.v. <code>.venv/pyvenv.cfg</code>). As of Python 3.11, it contains a few entries:</p><ol><li><code>home</code> (the directory where the executable used to create the virtual environment lives; <code>os.path.dirname(<a href="https://docs.python.org/3/c-api/init_config.html?highlight=base_executable#c.PyConfig.base_executable">sys._base_executable</a>)</code>)</li><li><code>include-system-packages</code> (should the global <code>site-packages</code> be included, effectively turning off isolation?)</li><li><code>version</code> (the Python version down to the micro version, but not with the release level, e.g. <code>3.12.0</code>, but not <code>3.12.0a6</code>)</li><li><code>executable</code> (the executable used to create the virtual environment; <code>os.path.realpath(<a href="https://docs.python.org/3/c-api/init_config.html?highlight=base_executable#c.PyConfig.base_executable">sys._base_executable</a>)</code>)</li><li><code>command</code> (the CLI command that could have recreated the virtual environment)</li></ol><p>On my machine, the <code>pyvenv.cfg</code> contents are:</p><figure><pre><code>home = /home/linuxbrew/.linuxbrew/opt/python@3.11/bin
include-system-site-packages = false
version = 3.11.2
executable = /home/linuxbrew/.linuxbrew/Cellar/python@3.11/3.11.2_1/bin/python3.11
command = /home/linuxbrew/.linuxbrew/opt/python@3.11/bin/python3.11 -m venv --without-pip /tmp/.venv</code></pre><figcaption>Example <code>pyvenv.cfg</code></figcaption></figure><p>One interesting thing to note is <code>pyvenv.cfg</code> is <strong>not</strong> a valid INI file according to the <a href="https://docs.python.org/3/library/configparser.html#module-configparser"><code>configparser</code> module</a> due to lacking any sections. To read fields in the file you are expected to use <code>line.partition(&#34;=&#34;)</code> and to strip the resulting key and value.</p><p>And that&#39;s all there is to a virtual environment! When you don&#39;t install <code>pip</code> they are extremely fast to create: 3 files, a symlink, and a single file. And they are simple enough you can probably create one manually.</p><p>One point I would like to make is how virtual environments are designed to be disposable and not relocatable. Because of their simplicity, virtual environments are viewed as something you can throw away and recreate quickly (if it takes your OS a long time to create 3 directories, a symlink, and a file consisting of 292 bytes like on my machine, you have bigger problems to worry about than virtual environment relocation üòâ). Unfortunately, people tend to conflate <em>environment creation</em> with <em>package installation,</em> when they are in fact two separate things. What projects you choose to install with which installer is actually separate from environment creation and probably influences your &#34;getting started&#34; time the most.</p><h3 id="how-python-uses-a-virtual-environment">How Python uses a virtual environment</h3><p>During start-up, Python automatically calls the <a href="https://docs.python.org/3/library/site.html#site.main"><code>site.main()</code> function</a> (unless you specify the <code>-S</code> flag). That function calls <code><a href="https://github.com/python/cpython/blob/90f1d777177e28b6c7b8d9ba751550e373d61b0a/Lib/site.py#L487">site.venv()</a></code> which handles setting up your Python executable to use the virtual environment appropriately. Specifically, the <code>site</code> module:</p><ol><li>Looks for <code>pyvenv.cfg</code> in either the same or parent directory as the running executable (which is <strong>not</strong> resolved, so the location of the symlink is used)</li><li>Looks for <code>include-system-site-packages</code> in <code>pyvenv.cfg</code> to decide whether the system <code>site-packages</code> ends up on <code>sys.path</code></li><li>Sets <code>sys._home</code> if <code>home</code> is found in <code>pyvenv.cfg</code> (<code>sys._home</code> is used by <code>sysconfig</code>)</li></ol><p>That&#39;s it! It&#39;s a surprisingly simple mechanism for what it accomplishes.</p><p>One thing to notice here about how all of this works is virtual environment activation is <strong>optional</strong>. Because the <code>site</code> module works off of the symlink to the executable in the virtual environment to resolve everything, activation is just a convenience. Honestly, all the activation scripts do are:</p><ol><li>Puts the <code>bin/</code> (or <code>Scripts/</code>) directory at the front of your <code>PATH</code> environment variable</li><li>Sets <code>VIRTUAL_ENV</code> to the directory containing your virtual environment</li><li>Tweaks your shell prompt to let you know your <code>PATH</code> has been changed</li><li>Registers a <code>deactivate</code> shell function which undoes the other steps</li></ol><p>In the end, whether you type <code>python</code> after activation or <code>.venv/bin/python</code> makes no difference to Python. Some tooling like the Python extension for VS Code or the Python Launcher for Unix may check for <code>VIRTUAL_ENV</code> to pick up on your intent to use a virtual environment, but it doesn&#39;t influence Python itself.</p><h2 id="introducing-microvenv">Introducing microvenv</h2><p>In the <a href="https://marketplace.visualstudio.com/items?itemName=ms-python.python">Python extension for VS Code</a>, we have an issue where Python beginners end up on <a href="https://www.debian.org/">Debian</a> or a <a href="https://en.wikipedia.org/wiki/Category:Debian-based_distributions">Debian-based distro</a> like <a href="https://ubuntu.com/">Ubuntu</a> and want to create a virtual environment. Due to Debian removing <code>venv</code> from the default Python install and beginners not realizing there was more to install than <code><a href="https://packages.debian.org/bullseye/python3">python3</a></code>, they often end up failing at creating a virtual environment ¬†(at least initially as you can install <code>python3-venv</code> separately; in the next version of Debian there will be a <a href="https://packages.debian.org/bookworm/python3-full"><code>python3-full</code> package</a> you can install which will include <code>venv</code> and <code>pip</code>, but it will probably take a while for all the instructions online to be updated to suggest that over <code>python3</code>). We believe the lack of <code>venv</code> is a problem as beginners should be using environments, but asking them to install yet more software can be a barrier to getting started (I&#39;m also ignoring the fact pip isn&#39;t installed by default on Debian either which also complicates the getting started experience for beginners).</p><p>But <code>venv</code> is not shipped as a separate part of Python&#39;s stdlib, so we can&#39;t simply install it from PyPI somehow or easily ship it as part of the Python extension to work around this. Since <code>venv</code> is in the stdlib, it&#39;s developed along with the version of Python it ships with, so there&#39;s no single copy which is fully compatible with all <a href="https://devguide.python.org/versions/">maintained versions of Python</a> (e.g. Python 3.11 added support to use <code>sysconfig</code> to get the directories to create for a virtual environment, various fields in <code>pyvenv.cfg</code> have been added over time, use new language features may be used, etc.). While we could ship a copy of <code>venv</code> for every maintained version of Python, we potentially would have to ship for every <strong>micro</strong> release to guarantee we always had a working copy, and that&#39;s a lot of upstream tracking to do. And even if we only shipped copies from minor release of Python, we would still have to track every micro release in case a bug in <code>venv</code> was fixed.</p><p>Hence I have created <a href="https://pypi.org/project/microvenv/">microvenv</a>. It is a project which provides a single <code>.py</code> file which you use to create a minimal virtual environment. You can either execute it as a script or call its <code>create()</code> function that is analogous to <code>venv.create()</code>. It&#39;s also compatible with all maintained versions of Python. As I (hopefully) showed above, creating a virtual environment is actually straight-forward, so I was able to replicate the necessary bits in less than 100 lines of Python code (specifically <a href="https://github.com/brettcannon/microvenv/blob/b194e556a718b08aea59f28f2aeb59686405180b/microvenv.py">87 lines</a> in the 2023.1.1 release). That actually makes it small enough to pass in via <code>python -c</code>, which means it could be embedded in a binary as a string constant and passed as an argument when executing a Python executable as a subprocess if you wanted to (directly executing <code>microvenv.py</code> works). Hopefully that means a tool could guarantee it can always construct a virtual environment <em>somehow</em>.</p><p>To keep <code>microvenv</code> simple, small, and maintainable, it does not contain any activation scripts. I personally don&#39;t want to be a shell script expert for multiple shells, nor do I want to track the upstream activation scripts (and they do change in case you were thinking &#34;it shouldn&#39;t be <em>that</em> hard to track&#34;). Also, in VS Code we are actually working towards implicitly activating virtual environments by updating your environment variables directly instead of executing any activation shell scripts, so the shell scripts aren&#39;t needed for our use case (we are actively moving away from using any activation scripts where we can as we have run into race condition problems with them when sending the command to the shell; thank goodness of <code>conda run</code>, but we also know people still want an activated terminal).</p><p>I&#39;m also skipping Windows support because we have found the lack of <code>venv</code> to be a unique problem for Linux in general, and Debian-based distros specifically.</p><p>I honestly don&#39;t expect anyone except tool providers to use <code>microvenv</code>, but since it could be useful to others beyond VS Code, I decided it was worth releasing on its own. I also expect anyone using the project to only use it as a fallback when <code>venv</code> is not available (which you can deduce by running <code>py -c &#34;from importlib.util import find_spec; print(find_spec(&#39;venv&#39;) is not None)&#34;</code>). And before anyone asks why we don&#39;t just use <a href="https://pypi.org/project/virtualenv/"><code>virtualenv</code></a>, its <a href="https://pypi.org/project/virtualenv/#files">wheel is 8.7MB</a> compared to <code>microvenv</code> at <a href="https://pypi.org/project/microvenv/#files">3.9KB</a>; 0.05% the size, or 2175x smaller. Granted, a good chunk of what makes up <code>virtualenv</code>&#39;s wheel is probably from shipping <code>pip</code> and <code>setuptools</code> in the wheel for fast installation of those projects after virtual environment creation, but we also acknowledge our need for a small, portable, single-file virtual environment creator is rather niche and something <code>virtualenv</code> currently doesn&#39;t support (for good reason).</p><p>Our <a href="https://github.com/microsoft/vscode-python/issues/20820">plan</a> for the Python extension for VS Code is to use <code>microvenv</code> as a fallback mechanism for our <a href="https://code.visualstudio.com/docs/python/environments#_using-the-create-environment-command"><strong>Python: Create Environment</strong> command</a> (FYI we also plan to bootstrap <code>pip</code> via its <a href="https://bootstrap.pypa.io/pip/"><code>pip.pyz</code> file from bootstrap.pypa.io</a> by downloading it on-demand, which is luckily less than 2MB). That way we can start suggesting to users in various UX flows to create and use an environment when one isn&#39;t already being used (as appropriate, of course). We want beginners to learn about environments if they don&#39;t already know about them and also remind experienced users when they may have accidentally forgotten to create an environment for their workspace. That way people get the benefit of (virtual) environments with as little friction as possible.</p>
        </div></div>
  </body>
</html>
