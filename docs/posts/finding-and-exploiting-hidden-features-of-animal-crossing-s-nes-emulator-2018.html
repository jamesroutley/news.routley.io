<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jamchamb.net/2018/07/11/animal-crossing-nes-emulator-hacks.html">Original</a>
    <h1>Finding and exploiting hidden features of Animal Crossing&#39;s NES emulator (2018)</h1>
    
    <div id="readability-page-1" class="page"><section>
  
      <p>While looking for ways to activate the developer menus left over in Animal Crossing,
including the NES emulator game selection menu, I found an interesting feature that exists
in the original game that was always active, but never used by Nintendo.
In addition to the NES/Famicom games that can be obtained in-game, it was possible to
load new NES games from the memory card.
I was also able to find a way to exploit this ROM loader to patch custom code and data into
the game, allowing for code execution via the memory card.</p>

<h2 id="introduction---the-nes-console-items">Introduction - The NES console items</h2>

<p>The normal NES games that you could obtain in Animal Crossing each came as an individual
furniture piece that appeared as an NES console with a single game box on top of it.
When you placed the item in your house and interacted with it, it would only play that one game.
Pictured below are the Excitebike and Golf items.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/single_game_consoles.png" alt="Single-game consoles"/></p>

<p>There was also a generic “NES Console” item that did not feature any of the built-in games.
You could buy this item from Redd, or sometimes obtain it through random events such as
town bulletin-board message stating that one has been buried in a random location in town.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/nes_buried.png" alt="Random NES spawn"/></p>

<p>This item appeared as the NES console with no game boxes on top of it.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/generic_console.png" alt="Single-game consoles"/></p>

<p>The problem with this item is that it was thought to be unplayable. Every time you
interacted with it, you would just see a message indicating that you didn’t have any
software to play.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/nes_no_software.png" alt="&#34;No software&#34; message"/></p>

<p>It turns out that this generic console item actually attempts to scan the memory card for
specially constructed files that contain NES ROM images! The NES emulator used to play
the built-in games is apparently a complete, generic NES emulator for the GameCube, and
it’s capable of playing most games thrown at it.</p>

<p>Before demonstrating these features, I’ll explain the process of reverse engineering them.</p>

<h2 id="finding-the-memory-card-rom-loader">Finding the memory card ROM loader</h2>



<p>My original intention was to find code that activates the various developer menus, such
as the map select menu or NES emulator game select menu. The
<a href="https://tcrf.net/Animal_Crossing#Map_Select">“Forest Map Select” menu</a>,
which makes it easy to instantly load directly into different locations in the game,
was easy enough to locate just by searching for the “FOREST MAP SELECT” string that
appears at the top of the screen (as seen in various videos and screenshots online).</p>

<p>The “FOREST MAP SELECT” had a data cross-reference to a function called <code>select_print_wait</code>,
which lead to a bunch of other functions that also had the <code>select_*</code> prefix,
including one called <code>select_init</code>. These happen to be the functions that handle
the map select menu.</p>

<p>The <code>select_init</code> function lead to another interesting function called
<code>game_get_next_game_dlftbl</code>. This one ties together all the other menus and “scenes”
that can run: the Nintendo logo screen, the title screen, the map select menu,
the NES (Famicom) emulator menu, and so on. It runs early in the main procedure
of the game, looks up which scene initialization function it should run, and finds its
entry in a table data structure called <code>game_dlftbls</code>. This table holds references to
the different scene handling functions, as well as some other data.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/game_init.png" alt="game_get_next_game_dlftbl"/></p>

<p>A close up of the first block of the function shows that it loads the “next game init”
function, and then starts comparing it to a series of known init functions:</p>

<ul>
  <li><code>first_game_init</code></li>
  <li><code>select_init</code></li>
  <li><code>play_init</code></li>
  <li><code>second_game_init</code></li>
  <li><code>trademark_init</code></li>
  <li><code>player_select_init</code></li>
  <li><code>save_menu_init</code></li>
  <li><code>famicom_emu_init</code></li>
  <li><code>prenmi_init</code></li>
</ul>

<p><img src="https://olu.online/assets/img/nes-emulator/game_init_begin.png" alt="game_get_next_game_dlftbl first block"/></p>

<p>One of the function pointers it checks for is <code>famicom_emu_init</code>, which is responsible for
starting up the NES/Famicom emulator. By forcing the result of <code>game_get_next_game_init</code>
to be <code>famicom_emu_init</code> or <code>select_init</code> in the Dolphin debugger, I can get the special
menus to display. The next step is to figure out how these pointers would normally be
set during runtime. All the <code>game_get_next_game_init</code> function does is load a value
at offset <code>0xC</code> of the first argument to <code>game_get_next_game_dlftbl</code>.</p>

<p>Tracking how these values got set across various data structures was a bit tedious,
so I’ll just cut to the chase. The main things I found were:</p>

<ul>
  <li>When the game starts up normally, it goes through this sequence:
    <ul>
      <li><code>first_game_init</code></li>
      <li><code>second_game_init</code></li>
      <li><code>trademark_init</code></li>
      <li><code>play_init</code></li>
    </ul>
  </li>
  <li><code>player_select_init</code> will set the next init to <code>select_init</code>. This screen is supposed to
allow for player selection just before map selection, but didn’t seem to be working correctly.</li>
</ul>

<p>There was also one unnamed function that would set the emulator init function, but nothing
appeared to set the init function to the player or map select inits.</p>

<p>At this point I realized I had another silly issue with how I loaded function names
into IDA, where I was missing any function names that began with a capital letter
due to the regular expression I used to cut out lines in the debug symbol file.
The function that would set up <code>famicom_emu_init</code> looked related to scene transitions,
and indeed its name turned out to be <code>Game_play_fbdemo_wipe_proc</code>.</p>

<p><code>Game_play_fbdemo_wipe_proc</code> handles scene transitions such as screen wipes and fades.
Under certain conditions, the screen transition leads from normal gameplay into the
emulator display. That’s what will set the emulator init function.</p>

<h3 id="console-furniture-handling">Console furniture handling</h3>

<p>What causes the screen transition handler to switch over to the emulator  is
actually the furniture item handler functions for the NES consoles.
<code>aMR_FamicomEmuCommonMove</code> is called when a player interacts with
one of the consoles.</p>

<p>When this function is called, <code>r6</code> holds an index value corresponding to the numbers seen
in the filenames of the NES games in <code>famicom.arc</code>:</p>

<ul>
  <li><code>01_nes_cluclu3.bin.szs</code></li>
  <li><code>02_usa_balloon.nes.szs</code></li>
  <li><code>03_nes_donkey1_3.bin.szs</code></li>
  <li><code>04_usa_jr_math.nes.szs</code></li>
  <li><code>05_pinball_1.nes.szs</code></li>
  <li><code>06_nes_tennis3.bin.szs</code></li>
  <li><code>07_usa_golf.nes.szs</code></li>
  <li><code>08_punch_wh.nes.szs</code></li>
  <li><code>09_usa_baseball_1.nes.szs</code></li>
  <li><code>10_cluclu_1.qd.szs</code></li>
  <li><code>11_usa_donkey3.nes.szs</code></li>
  <li><code>12_donkeyjr_1.nes.szs</code></li>
  <li><code>13_soccer.nes.szs</code></li>
  <li><code>14_exbike.nes.szs</code></li>
  <li><code>15_usa_wario.nes.szs</code></li>
  <li><code>16_usa_icecl.nes.szs</code></li>
  <li><code>17_nes_mario1_2.bin.szs</code></li>
  <li><code>18_smario_0.nes.szs</code></li>
  <li><code>19_usa_zelda1_1.nes.szs</code></li>
</ul>

<p>(<code>.arc</code> is a proprietary file archive format.)</p>

<p>When <code>r6</code> is non-zero, it’s passed along in a call to <code>aMR_RequestStartEmu</code>.
This eventually triggers the emulator transition.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/nes_furniture_move.png" alt="aMR_FamicomEmuCommonMove"/></p>

<p>However, if <code>r6</code> is zero, a function named <code>aMR_RequestStartEmu_MemoryC</code> is called instead.
Setting the value to zero in the debugger, I got the “I don’t have any software” message.
I didn’t recall the generic “NES Console” item right away to see if that’s what would
cause <code>r6</code> to be zero, but it is - index zero is used for the generic console item.</p>

<p>While <code>aMR_RequestStartEmu</code> just stores the index value to some data structure,
<code>aMR_RequestStartEmu_MemoryC</code> does something much more complex…</p>

<p><img src="https://olu.online/assets/img/nes-emulator/request_emu_mc.png" alt="aMR_RequestStartEmu_MemoryC"/></p>

<p>That third code block calls <code>aMR_GetCardFamicomCount</code> and checks for a non-zero result,
or else it will short-circuit past most of the interesting stuff on the left side of
the function graph.</p>

<p><code>aMR_GetCardFamicomCount</code> calls into <code>famicom_get_disksystem_titles</code>, which then calls
into <code>memcard_game_list</code>, which is where things start to get really interesting.</p>

<p><code>memcard_game_list</code> will mount the memory card and start looping through its file entries,
checking some values on each one. By tracing through it in the debugger, I could see what
it was comparing the values to on each of my memory card files.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/memcard_game_list_filenames.png" alt="aMR_RequestStartEmu_MemoryC"/></p>

<p>Whether or not the function decides to load in a file depends on a few string comparison checks.
First, it checks for the presence of the strings “GAFE” and “01”, which are the game ID
and company ID, respectively. The 01 refers to Nintendo, “GAFE” refers to Animal Crossing.
My guess is that it’s short for “GameCube Animal Forest English”.</p>

<p>Then it checks for the strings “DobutsunomoriP_F_” and “SAVE”. In this case,
the first string should match, but not the second. “DobutsunomoriP_F_SAVE” happens to be
the name of the file that stores save data for the built-in NES games.
So, any file besides that with the “DobutsunomoriP_F_” prefix will be loaded.</p>

<p>By using the Dolphin debugger to skip over the “SAVE” string comparison and trick
the game into thinking my “SAVE” file was OK to load, I got this menu to show up when
I used the NES console:</p>

<p><img src="https://olu.online/assets/img/nes-emulator/load_save_trick.png" alt="Force loading the SAV file"/></p>

<p>I answered yes and attempted to load the save file up as a game, and got the built-in
crash screen for the first time:</p>

<p><img src="https://olu.online/assets/img/nes-emulator/crash_screen.png" alt="Crash screen"/></p>

<p>Cool! Now that I know it is in fact trying to load games from the memory card,
I can start figuring out the format for the save files to see how to load up a real
ROM.</p>

<p>One of the first things I tried to do was find out where the game name was being
read from in the memory card file. By searching for the string “FEFSC” that appears in
the “Would you like to play &lt;name&gt;?” message, I found the offset where it was being read
from in the file: <code>0x642</code>. By copying the save file, changing the filename to
“DobutsunomoriP_F_TEST”, setting the bytes at offset <code>0x642</code> to “TESTING”, and re-importing
the edited save, I could get the desired title name to display in the menu.</p>

<p>Adding multiple files in this format resulted in more options being added to the menu,
as seen here:</p>

<p><img src="https://olu.online/assets/img/nes-emulator/multiple_games.png" alt="Game menu options"/></p>

<h3 id="booting-a-rom-file">Booting a ROM file</h3>

<p>If <code>aMR_GetCardFamicomCount</code> returned non-zero, some memory is allocated on the heap,
<code>famicom_get_disksystem_titles</code> is called again directly, and then a bunch of random
offsets in a data structure get set. Instead of deciphering where all these values
were going to be read, I started looking at the list of <code>famicom</code> functions.</p>

<p><code>famicom_rom_load</code> turned out to be the right place to look. It handles ROM loading,
whether from a memory card or the internal game resources.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/famicom_rom_load_notes.png" alt="famicom_rom_load"/></p>

<p>The most significant thing in the “memory card load” block is that it calls
<code>memcard_game_load</code>. This mounts the file on the memory card once again, reads it in,
and parses it. The most important features of the file format become apparent here.</p>

<h4 id="checksum-value">Checksum value</h4>

<p>The first thing that happens after the file is loaded is a checksum calculation.
The <code>calcSum</code> function is called, which is a very simple algorithm that sums up
the values of all the bytes in the memory card data. The low eight bits of the
result must be zero. So, to pass this check, you have to sum up the values of all
the bytes in your original file, figure out what value to add to that sum to
cause the low eight bits to be zero, and then set a checksum byte in your file
to that value.</p>

<p>If the check fails, you get a message stating that the memory card couldn’t
be read correctly, and nothing happens.
During the debugging process, all I have to do is skip over this check.</p>

<h4 id="copying-the-rom">Copying the ROM</h4>

<p>Down near the end of <code>memcard_game_load</code>, another interesting thing happens.
There are some more interesting code blocks between this and the checksum, but none of
them will result in a branch that skips over this behavior.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/memcard_game_load_rom.png" alt="memcard_game_load ROM copying"/></p>

<p>If a certain 16-bit integer read from the card is non-zero, a function will be called to check for
a compression header on a buffer. It checks for some proprietary Nintendo compression formats by
looking for “Yay0” or “Yaz0” at the beginning of the buffer. If one of these is found,
a decompression function is called. Otherwise, a simple memory copy function is performed.
Either way, a variable called <code>nesinfo_data_size</code> is updated afterwards.</p>

<p>Another context clue here is that the ROM files for the built-in NES games use “Yaz0” compression,
and have that string in their file header.</p>

<p>By observing the value that’s checked for zero and the buffer that’s passed to the compression
check functions, I can quickly identify where in the memory card file the game is reading from.
The zero-check is performed against part of a 32 byte buffer that’s copied from offset <code>0x640</code>
in the file, which is likely a header for the ROM. Other parts of it are also checked throughout
this function, and it’s where the game title is located (starting from the third byte of the header).</p>

<p>With the specific code path I hit, the ROM buffer is located immediately after this 32 byte
header buffer.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/memcard_game_load_notes.png" alt="memcard_game_load annotated"/></p>

<p>This is enough information to attempt to construct a valid ROM file. I simply took one of the other
Animal Crossing save files and edited it with a hex editor to change the name of the file to
<code>DobutsunomoriP_F_TEST</code> and clear out the areas where I needed to insert data.</p>

<p>I used the Pinball ROM that’s already present in the game for this test run, and copied its content
in after the 32 byte header for a test. Instead of calculating the checksum value, I also set some
breakpoints so that I could just skip over <code>calcSum</code>, as well as observe the results of other checks
that might cause a branch that skips past loading the ROM.</p>

<p>Finally, I imported the new file through the Dolphin memory card manager, restarted the game,
and went to try it out on the console.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/pinball_working.png" alt="Pinball menu option"/></p>

<p><img src="https://olu.online/assets/img/nes-emulator/boot_pinball.png" alt="Pinball booting"/></p>

<p>It worked! There were some graphical quirks caused by Dolphin settings that affect the
graphics mode used by the NES emulator, but the game played just fine.
(In newer Dolphin builds it should work by default.)</p>

<p>To be sure that other games would work, I tried out some more ROMs that weren’t already present
in the game. Battletoads would start up, but not continue past the intro text (with some more
tweaking later on, it did become playable).
Mega Man, on the other hand, worked perfectly:</p>

<p><img src="https://olu.online/assets/img/nes-emulator/megaman.png" alt="Playing Mega Man in Animal Crossing"/></p>

<p>To be able to generate more ROM files that could load without any debugger intervention
I’d have to start writing code and dig into the file format parsing some more.</p>

<h3 id="the-external-rom-file-format">The external ROM file format</h3>

<p>Most of the critical file parsing happens in <code>memcard_game_load</code>. There are six main sections
to the parsing code blocks in this function:</p>

<ul>
  <li>Checksum</li>
  <li>Save file name</li>
  <li>ROM file header</li>
  <li>Unknown buffer that’s copied without any processing</li>
  <li>Text comment, icon, and banner loader (for new save file creation)</li>
  <li>ROM loader</li>
</ul>

<p><img src="https://olu.online/assets/img/nes-emulator/memcard_game_load_sections_notes.png" alt="memcard_game_load sections"/></p>

<h4 id="checksum">Checksum</h4>

<p>The low eight bits of the sum of all the byte values in the save file must be zero.
Here’s some simple Python code that generates a checksum byte that can achieve that:</p>

<figure><pre><code data-lang="python"><span>checksum</span> <span>=</span> <span>0</span>
<span>for</span> <span>byte_val</span> <span>in</span> <span>new_data_tmp</span><span>:</span>
    <span>checksum</span> <span>+=</span> <span>byte_val</span>
    <span>checksum</span> <span>=</span> <span>checksum</span> <span>%</span> <span>(</span><span>2</span><span>**</span><span>32</span><span>)</span>  <span># keep it 32 bit
</span>
<span>checkbyte</span> <span>=</span> <span>(</span><span>256</span> <span>-</span> <span>(</span><span>checksum</span> <span>%</span> <span>256</span><span>))</span> <span>%</span> <span>256</span>
<span>new_data_tmp</span><span>[</span><span>-</span><span>1</span><span>]</span> <span>=</span> <span>checkbyte</span></code></pre></figure>

<p>There’s probably a designated location to store the checksum byte, but just
placing it in empty padding space at the very end of the save file works fine.</p>

<h4 id="file-name">File name</h4>

<p>Just to reiterate, the save file name must begin with “DobutsunomoriP_F_” and end
with something other than “SAVE”. This filename is copied a couple of times,
and in one case the letter “F” is replaced with “S”. This will be the name of
save files for the given NES game (“DobutsunomoriP_S_NAME”).</p>



<p>A direct copy of the 32 byte header is loaded into memory. A few of the values
in this header are used to determine how to handle the upcoming sections.
It mainly includes some 16-bit size values and packed setting bits.</p>

<p>If you trace the pointer that the header is copied to
all the way to the beginning of the function and figure out its argument position,
the function signature below reveals that its type is in fact <code>MemcardGameHeader_t*</code>.</p>

<div><div><pre><code>memcard_game_load(unsigned char *, int, unsigned char **, char *, char *, MemcardGameHeader_t *, unsigned char *, unsigned long, unsigned char *, unsigned long)
</code></pre></div></div>

<h4 id="unknown-buffer">Unknown buffer</h4>

<p>A 16-bit size value from the header is checked. If it’s non-zero, that number
of bytes will be directly copied from the file buffer into a new block of allocated
memory. This advances a data
pointer in the file buffer so that copying can resume from the next section
later on.</p>

<h4 id="banner-icon-and-comment">Banner, icon, and comment</h4>

<p>Another size value is checked in the header, and if it’s non-zero the compression check
function is called. If necessary the decompression algorithm will run, and then <code>SetupExternCommentImage</code>
is called.</p>

<p>This function handles three things: a “comment”, a banner image, and an icon. For each one there’s a code
in the ROM header that indicates how it should be handled. The options are:</p>

<ol>
  <li>Use a default value</li>
  <li>Copy from the ROM file banner/icon/comment section</li>
  <li>Copy from an alternate buffer</li>
</ol>

<p>The default value code will cause the icon or banner to be loaded from an on-disk resource,
and the save file name and comment (a text description of the file) to be set to
“Animal Crossing” and “NES Cassette Save Data” respectively. This is how it would look:</p>

<p><img src="https://olu.online/assets/img/nes-emulator/default_banner_icon.png" alt="Default banner, icon, and file description"/></p>

<p>The second code value will just copy the game name from the ROM file (some alternative to
“Animal Crossing”), and then attempt to find the string “] ROM” in the file comment and replace it
with “] SAVE”. Presumably, the files Nintendo intended to release would have a name format like
“Game Name [NES] ROM”, or something similar.</p>

<p>For the icon and banner it would attempt to figure out the format of the image, get a fixed size value
according to that format, and then copy the image over.</p>

<p>For the last code value, the file name and description would be copied from another buffer without
any changes, and the icon and banner would be loaded from the alternate buffer as well.</p>

<h4 id="rom">ROM</h4>

<p>If you look carefully at the <code>memcard_game_load</code> screenshot of the ROM copying,
the 16-bit value that’s checked for zero is left shifted by 4 bits (multiplied by 16)
and then used as the size for the <code>memcpy</code> function when no compression is detected. This is
another size value present in the header.</p>

<p>If the size is non-zero, the ROM data is checked for compression and then copied over.</p>

<h3 id="the-unknown-buffer-and-the-search-for-bugs">The unknown buffer and the search for bugs</h3>

<p>While getting new ROMs to load up was pretty cool, one of the most interesting things about this ROM loader to me
was that it’s virtually the only thing in the game that accepts variable-size user input and copies it to different
places in memory. Almost everything else uses fix-sized buffers. Things like names and letter text might seem like
they’re variable in size, but the empty space is basically filled with space characters. Null-terminated strings are
not used often, preventing some common memory corruption bugs such as using <code>strcpy</code> on a buffer that’s too small
for the string being copied over to it.</p>

<p>I was really interested in finding a save file based exploit in the game, and this seemed like the best bet.</p>

<p>Most of the ROM file handling described above also used fixed-size copies, except for the unknown buffer and ROM data.
Unfortunately, the code that handles this buffer allocates just as much space as is needed to copy it, so there’s no overflow,
and setting really large ROM file sizes wasn’t very useful.</p>

<p>Still, I wanted to know what was going on with that buffer that would be directly copied without any handling.</p>

<h4 id="the-nes-info-tag-processors">The NES Info Tag processors</h4>

<p>Revisiting <code>famicom_rom_load</code>, a few functions are called after a ROM gets loaded from the memory card or disk:</p>

<ul>
  <li><code>nesinfo_tag_process1</code></li>
  <li><code>nesinfo_tag_process2</code></li>
  <li><code>nesinfo_tag_process3</code></li>
</ul>

<p>By tracing where the unknown buffer was copied to, I verified that it was being operated on by these functions.
These start by calling <code>nesinfo_next_tag</code>, which goes through a simple algorithm:</p>

<ul>
  <li>Check if the given pointer matches the pointer in <code>nesinfo_tags_end</code>. If it’s less than <code>nesinfo_tags_end</code>, or <code>nesinfo_tags_end</code>
is zero, it checks if the string “END” is present at the head of the pointer.
    <ul>
      <li>If “END” has been reached, or the pointer has advanced up to or past <code>nesinfo_tags_end</code>, the function returns zero (null).</li>
      <li>Otherwise, the byte at offset <code>0x3</code> of the pointer is added to 4 and the current pointer, and that value is returned.</li>
    </ul>
  </li>
</ul>

<p>This suggests a tag format of some three letter name, a data size value, and data. The result is a pointer to the next tag,
as the current tag will be skipped over (<code>cur_ptr + 4</code> skips the three byte name and one byte size, and <code>size_byte</code> skips over the data).</p>

<p>If the result is non-zero, the tag processing function then goes through a series of string comparisons to figure out
what tag to handle. Some of the tag names checked for in <code>nesinfo_tag_process1</code>  are VEQ, VNE, GID, GNO, BBR, and QDS.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/nesinfo_tag_process1_notes.png" alt="nesinfo_tag_process1"/></p>

<p>If a tag is matched, some handler code is executed. Some of the handlers do nothing but print the tag to a debug message.
Others have more complex handlers. After a tag is processed, the function attempts to get the next tag and continue
processing.</p>

<p>Luckily, there are a bunch of descriptive debug messages that get printed out
when these tags are found. They’re all in Japanese, so they have to be Shift-JIS decoded and translated first.
The messages for QDS, for example, can say “Load Disk Save Area” or “Since it is the first play, keep the disk save area”.
The messages for BBR say “battery backup load” or “because it is the first play, clear”.</p>

<p>Both of these codes also load some values from their tag data section and use them to calculate an offset into the ROM data
and then perform copy operations.
It’s apparent that they’re responsible for designating parts of the ROM memory that are related to saving state.</p>

<p>There’s also an “HSC” tag that has a debug message indicating that this handles high scores. It takes an offset
into the ROM from its tag data, as well as an initial high score value. These tags can be used to mark where high score
values are kept in the NES game’s memory, probably so that it can be saved and restored later.</p>

<p>These tags provide a fairly complex system for loading metadata about the ROMs. Even better, many of them result
in <code>memcpy</code> calls based on values provided in the tag data.</p>

<h4 id="bug-hunting">Bug hunting</h4>

<p>Most of the tags that caused memory manipulation weren’t going to be very useful for exploits, because they all
had maximum offset and size values represented by 16-bit integers. This is all that would be needed to handle
the 16-bit address space of the NES, but doesn’t provide much range for writing over useful targets such
as function pointers or return addresses on the stack in the 32-bit address space of the GameCube.</p>

<p>However, there were a few cases where offsets or size values passed to <code>memcpy</code> could exceed <code>0xFFFF</code>.</p>

<h5 id="qds">QDS</h5>

<p>QDS actually loads a 24-bit offset from its tag data, as well as a 16-bit size value.</p>

<p>The good thing is that the offset is used to calculate the destination of a copy operation.
The base address for the offset is the beginning of the loaded ROM data, the source of the copy
is in the memory card ROM file, and the size is the given 16-bit size value from the tag.</p>

<p>A 24-bit offset has a maximum value of <code>0xFFFFFF</code>, which is well above what’s needed to write
outside the boundary of the loaded ROM data. There are some problems, though…</p>

<p>The first is that even though the maximum size value is <code>0xFFFF</code>, it’s initially used to zero
out a section of memory. If the size value is too high (not much more than <code>0x1000</code>), this will
actually zero out the “QDS” tag in the game’s code.</p>

<p>This is a problem because <code>nesinfo_tag_process1</code> actually gets called twice. The first time, it will
collect some information about space it needs to set up for save data. The QDS and BBR tags are not
fully processed on the first run. After the first run, some space is set up for save data, and
the function is called again. This time the QDS and BBR tags would be fully processed,
but it’s impossible to match the tags again if the tag name strings have all been cleared out of
memory!</p>

<p>So, setting a smaller size value can avoid that. The other problem is that the offset value
can only go forwards in memory, and the NES rom data is located on the heap fairly close
to the end of usable memory.</p>

<p>There are only a few heap entries that come after it, none of which had anything super useful
like obvious function pointers.</p>

<p>Normally it might be possible to use this for a heap overflow exploit, but the <code>malloc</code> implemenation
used for this heap actually adds a load of sanity check bytes into the <code>malloc</code> blocks. It’s possible
to write over pointer values in the subsequent heap blocks. Without the sanity checking, this could be
used to write an arbitrary value to an arbitrary location in memory when <code>free</code> is called on the
affected heap block.</p>

<p>However, the <code>malloc</code> implementation used here will check for a specific byte pattern (<code>0x7373</code>) at the beginning of the
next and previous blocks it’s going to manipulate upon the call to <code>free</code>. If it doesn’t find those bytes,
it calls <code>OSPanic</code> and the game stops.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/get_block_next.png" alt="get_block_next calling OSPanic if it doesn&#39;t find 0x7373"/></p>

<p>Without being able to influence those bytes to be present at
some target location, it’s not possible to write there. In other words, you can’t write something to
an arbitrary location without already being able to write something right next to that location.
There could be some way to get the value <code>0x73730000</code> to be stored on the stack right before a return address,
<em>and</em> the location referenced by the value you want to write to the destination address (it will also be checked
as if it’s a pointer to a heap block), but it’d be difficult to find and exploit.</p>

<h5 id="nesinfo_update_highscore"><code>nesinfo_update_highscore</code></h5>

<p>Another function involving the QDS, BBR, and HSC tags is <code>nesinfo_update_highscore</code>.
The QDS, BBR, and OFS (offset) tag size values are used to calculate an offset to write to, and an
HSC tag triggers a write to that location. This function runs for every frame processed
by the NES emulator.</p>

<p>The maximum offset value per tag in this case, even for QDS, is <code>0xFFFF</code>.
However, during the tag processing loop, size
values from BBR and QDS tags actually get <em>accumulated</em>. This means that multiple tags
can be used to calculate just about any offset value. The limit is the number of tags
that can be fit in the ROM tag data section of the memory card file,
which has a maximum size of <code>0xFFFF</code> as well.</p>

<p>The base address that the offset gets added to is <code>0x800C3180</code>, the save data buffer.
This is at a much lower address than the ROM data, providing more freedom in choosing
where to write to. Writing over the function’s return address on the stack at <code>0x812F95DC</code>,
for example, would be fairly easy.</p>

<p>Unfortunately, this doesn’t work either. <code>nesinfo_tag_process1</code> happens to also figure out
the accumulated size of the offsets from these tags, and uses that size to initialize
some space like this:</p>

<figure><pre><code data-lang="c"><span>bzero</span><span>(</span><span>nintendo_hi_0</span><span>,</span> <span>((</span><span>offset_sum</span> <span>+</span> <span>0xB</span><span>)</span> <span>*</span> <span>4</span><span>)</span> <span>+</span> <span>0x40</span><span>)</span></code></pre></figure>

<p><img src="https://olu.online/assets/img/nes-emulator/bzero.png" alt="The culprit"/></p>

<p>With the offset value I tried to calculate, this resulted in <code>0x48D91EC</code> (76,386,796)
bytes of  memory getting wiped out, causing the game to crash spectacularly.</p>

<h3 id="the-pat-tag">The PAT tag</h3>

<p>It was starting to look hopeless, as all of the tags that made unsafe calls to <code>memcpy</code> would
end up causing a crash before they could be useful.
I decided to switch over to just documenting the purpose of each tag, and eventually reached the
tags in <code>nesinfo_tag_process2</code>.</p>

<p>Most of the tag handlers in <code>nesinfo_tag_process2</code> will never run because they only work
when the pointer <code>nesinfo_rom_start</code> is not null. Nothing in the code ever sets that pointer
to be non-null. It gets initialized to zero, and never gets used again.
Only <code>nesinfo_data_start</code> is set when a ROM gets loaded, so this looks like a piece of dead code.</p>

<p>There is one tag that can still operate when <code>nesinfo_rom_start</code> is null, though: PAT.
This is the most complex tag in the <code>nesinfo_tag_process2</code> function.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/pat_tag_handler.png" alt="PAT tag handler"/></p>

<p>It still uses <code>nesinfo_rom_start</code> as a pointer, but never performs a null check on it.
The PAT tag will read through its own tag data buffer, processing codes that calculate offsets.
Those offsets are added to the <code>nesinfo_rom_start</code> pointer to calculate a destination address,
and then bytes are copied from the patch buffer into that location. This copy is performed with
load and store byte instructions, rather than <code>memcpy</code>, which is why I hadn’t noticed it
sooner.</p>

<p>Each PAT tag data buffer has an 8-bit type code, 8-bit patch size, and 16-bit offset value,
followed by the patch data.</p>

<ul>
  <li>If the code is 2, the offset value is added to the current offset sum.</li>
  <li>If the code is 9, the offset is shifted up 4 bits and added to the current offset sum.</li>
  <li>If the code is 3, the offset sum is reset to 0.</li>
</ul>

<p>The largest size an NES info tag can have is 255, so the largest possible PAT entry patch
size is 251 bytes. Multiple PAT tags are allowed, though, so it’s possible to patch more
than 251 bytes, as well as patch non-contiguous locations.</p>

<p>So long as there’s a series of code 2 or code 9 PAT sub-tags, the destination pointer offset continues to accumulate.
It will be reset to zero when patch data gets copied, but using a patch size of zero avoids this.
Writing this now, it’s clear that this could be used to calculate some arbitrary offset
against the null pointer in <code>nesinfo_rom_start</code> by using lots of PAT tags.</p>

<p>However, there are two more code value checks…</p>

<ul>
  <li>If the code is between <code>0x80</code> and <code>0xFF</code>, it gets added to <code>0x7F80</code> and then shifted
up 16 bits. Finally, this is added to the 16-bit offset value and used as the destination
address to patch.</li>
</ul>

<p>This allows setting any address in the range <code>0x80000000</code> to <code>0x807FFFFF</code> as the destination
for the patch! That’s where a bunch of the code for Animal Crossing lives in memory.
This means its possible to patch Animal Crossing’s code itself using the ROM metadata
tags from a file on the memory card.</p>

<p>With a small loader patch, it’d be possible to easily load even larger patches to any address
from the memory card.</p>

<p>For a quick test, I set up a patch that would turn on “zuru mode 2” (the game’s developer mode, described
in my last blog post) when the user loads a ROM from the game card. It turns out that
the button cheat combo only activates “zuru mode 1”, which doesn’t have access to all the
same features that mode 2 has. With this patcher, it’s now possible to get full access
to developer mode on real hardware using a memory card.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/patch_z2_1.png" alt="Patcher ROM step 1"/></p>

<p>The patch tags will be processed as the ROM is loaded up.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/patch_z2_2.png" alt="Patcher ROM step 2"/></p>

<p>After the ROM loads, exit the NES emulator to see the result.</p>

<p><img src="https://olu.online/assets/img/nes-emulator/patch_z2_3.png" alt="Patcher ROM step 3"/></p>

<p>It works!</p>

<h4 id="patcher-info-tag-format">Patcher info tag format</h4>

<p>The info tags in the save file that performs this patch look like this:</p>

<div><div><pre><code>000000 5a 5a 5a 00 50 41 54 08 a0 04 6f 9c 00 00 00 7d  &gt;ZZZ.PAT...o....}&lt;
000010 45 4e 44 00                                      &gt;END.&lt;
</code></pre></div></div>

<ul>
  <li><code>ZZZ \x00</code>: An ignored beginning tag. <code>0x00</code> is the size of its data buffer: zero.</li>
  <li><code>PAT \x08 \xA0 \x04 \x6F\x9C \x00\x00\x00\x7D</code>: Patches <code>0x80206F9C</code> to <code>0x0000007D</code>.
    <ul>
      <li><code>0x08</code> is the size of the tag buffer.</li>
      <li><code>0xA0</code>, when added to <code>0x7F80</code>, is <code>0x8020</code>, the upper 16 bits of the destination address.</li>
      <li><code>0x04</code> is the size of the patch data (<code>0x0000007D</code>).</li>
      <li><code>0x6F9C</code> is the lower 16-bits of the destination address.</li>
      <li><code>0x0000007D</code> is the patch data.</li>
    </ul>
  </li>
  <li><code>END \x00</code>: The end marker tag.</li>
</ul>

<p>If you want to experiment with creating patcher or ROM save files yourself, I have some simple
code at <a href="https://github.com/jamchamb/ac-nesrom-save-generator">https://github.com/jamchamb/ac-nesrom-save-generator</a> for generating the files.
A patch like the one above can be generated with the following command:</p>

<div><div><pre><code>$ ./patcher.py Patcher /dev/null zuru_mode_2.gci -p 80206F9c 0000007D
</code></pre></div></div>

<h3 id="arbitrary-code-execution">Arbitrary code execution</h3>

<p>With this tag it’s possible to gain arbitrary code execution in Animal Crossing.</p>

<p>There’s one last hurdle: using patches against data works fine, but something’s wrong
with patching code instructions.</p>

<p>While the patches do get written, the game continues to execute the old instructions that
were there before. It seems like a caching issue, and in fact it is.
The GameCube CPU had instruction caches, as seen in <a href="https://en.wikipedia.org/wiki/Nintendo_GameCube_technical_specifications">https://en.wikipedia.org/wiki/Nintendo_GameCube_technical_specifications</a>.</p>

<p>To figure out how the cache could be cleared, I started looking up cache related functions
in the GameCube SDK documentation, and found <code>ICInvalidateRange</code>. This function
will invalidate cached blocks of instructions at a given memory address, allowing modified instruction
memory to execute with the updated code.</p>

<p>Without a way to get initial code to run, it’d still be impossible to call <code>ICInvalidateRange</code>,
though. Getting successful code execution will require one more trick.</p>

<p>While looking over the <code>malloc</code> implementation to figure out if a heap overflow exploit was possible,
I learned that the <code>malloc</code> implementation functions could be switched out dynamically through a data structure
and function named <code>my_malloc</code>. <code>my_malloc</code> would load a pointer to the current  <code>malloc</code> or <code>free</code> implementation
function from a static location in memory, and then call that function while passing along whatever arguments were
given to <code>my_malloc</code>.</p>

<p>The NES emulator used <code>my_malloc</code> heavily to allocate and free memory for NES ROM-related data, so I
knew it would be triggered multiple times around the same time that the PAT tags get processed.</p>

<p>Because <code>my_malloc</code> would load a pointer from memory and then branch to it, I could alter the control flow
of the program just by overwriting the pointer for the current <code>malloc</code> or <code>free</code> functions. Instruction caching
would not prevent this from running, as none of the instructions in <code>my_malloc</code> need to be changed.</p>

<p>Cuyler, the developer of the Dōbutsu no Mori e+ fan translation project, <a href="https://cuyler36.github.io/2018/07/14/creating-a-nes-patch-loader.html">implemented a loader in PowerPC assembly</a>
and demonstrates using it to inject new code in this video: <a href="https://www.youtube.com/watch?v=BdxN7gP6WIc">https://www.youtube.com/watch?v=BdxN7gP6WIc</a>.
(Dōbutsu no Mori e+ was the last iteration of Animal Crossing on GameCube, which has the most updates and was
only released in Japan.)
After being injected with PAT tags, the loader can read much larger patches from the memory card,
bypassing the size restrictions of the tag info section in ROM files.
In the demonstration video it loads in some code that allows the player to spawn any object by typing its ID into
a letter and then pressing the Z button.</p>

<p>With that, it will be possible to load mods, cheats, and homebrew using a regular copy of Animal
Crossing on a real GameCube.</p>

<p><strong>Update</strong>: The previous video has been taken down, so here’s another example of injecting custom code
that prints text to the screen and in-game debug console:</p>

<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/eF-baqLpt_0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

    
  </section></div>
  </body>
</html>
