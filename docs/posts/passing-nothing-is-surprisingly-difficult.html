<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://davidben.net/2024/01/15/empty-slices.html">Original</a>
    <h1>Passing nothing is surprisingly difficult</h1>
    
    <div id="readability-page-1" class="page">





<p>
My day job is in <a href="https://www.chromium.org/">browsers</a> and <a href="https://boringssl.googlesource.com/boringssl/">cryptography</a>, not compilers, yet I often find that I need to spend more of my time working through the semantics of programming languages than using them. This post discusses a thorny cross-language issue between C, C++, and Rust. In short:
</p>
<ul>

<li>C’s rules around pointers and <code>memcpy</code> leave no good ways to represent an empty slice of memory.

</li><li>C++’s pointer rules are fine, but <code>memcpy</code> in C++ inherits the C behavior.

</li><li>Rust FFI is not <a href="https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html">zero-cost</a>. Rust picked a C/C++-incompatible slice representation, requiring a conversion in each direction. Forgetting the conversion is an easy mistake and unsound.

</li><li>Rust slices appear to <em>also</em> be incompatible with Rust pointer arithmetic, to the point that the standard library’s slice iterator is unsound. <span>(Update 2024-01-16: It sounds like this is <a href="https://github.com/rust-lang/rust/issues/117945">in the process of being fixed</a>!)</span>
</li>
</ul>

<p>As FFI challenges inherently span multiple languages, I wrote this mostly to have one common reference that describes the mismatch.</p>

<h2 id="slices">Slices</h2>

<p>
All three languages allow working with <em>slices</em>, or contiguous sequences of objects in memory. (Also called <a href="https://en.cppreference.com/w/cpp/container/span">spans</a>, but we’ll use “slices” here.) A slice is typically a pointer and a length, <code>(start, count)</code>, giving <code>count</code> objects from <code>start</code>, of some type <code>T</code>.
</p>
<p>
A slice can also be specified by two pointers, <code>(start, end)</code>, giving the objects from <code>start</code> (inclusive) to <code>end</code> (exclusive). This is better for iteration because only one value needs to be adjusted to advance, but the length is less available. C++ iterator pairs are a generalization of this form, and Rust slice iterators use this internally. The two forms can be converted with <code>end = start + count</code> and <code>count = end - start</code>, using C-style pointer arithmetic where everything is scaled by the object size. We’ll primarily discuss <code>(start, count)</code>, but this duality means slices are closely related to pointer arithmetic.
</p>
<p>
In C and C++, slices are, at best, library types built out of pointers and lengths. Sometimes functions just take or return pointer and length separately, but still use it to represent a slice of memory. In Rust, slices are language primitives, but the underlying components are exposed for unsafe code and FFIs. To work with each of these, we must understand what combinations of pointers and lengths are valid.
</p>
<p>
This is straightforward for a positive-length slice: <code>start</code> must point within an allocation where there are at least <code>count</code> objects of type <code>T</code>. But suppose we want an empty (length zero) slice. <strong>What are the valid representations of an empty slice?</strong>
</p>
<p>
Certainly we can point <code>start</code> within (or just past) some array of <code>T</code>s and set <code>count</code> to zero. But we may want to make an empty slice without an existing array. For example, a default-constructed <code>std::span&lt;T&gt;()</code> in C++ or <code>&amp;[]</code> in Rust. What are our options then? In particular:
</p>
<ol>

<li>Can an empty slice be <code>(nullptr, 0)</code>?

</li><li>Can an empty slice be <code>(alignof(T), 0)</code>, or some other aligned address that doesn’t correspond to an allocation?
</li>
</ol>
<p>
The second question may seem odd to C and C++ folks, but Rust folks may recognize it as <code><a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling">std::ptr::NonNull::dangling</a></code>.

</p><h2 id="c++-slices">C++</h2>

<p>
C++ is the easiest to discuss, as it has a formal specification and is (almost) self-consistent.
</p>
<p>
First, <code>(nullptr, 0)</code> is a valid empty slice in C++. The STL’s types <a href="https://eel.is/c++draft/span.cons#2">routinely return it</a>, and the language is compatible with it:
</p>
<ul>

<li><code>nullptr + 0</code> is <a href="https://eel.is/c++draft/expr.add#4.1">defined</a> to be <code>nullptr</code>

</li><li><code>nullptr - nullptr</code> is <a href="https://eel.is/c++draft/expr.add#5.1">defined</a> to be <code>0</code>
</li>
</ul>
<p>
C++ defines APIs like <code>std::span</code> in terms of <a href="https://eel.is/c++draft/span.cons#4.1">pointer addition</a> for the <code>(start, count)</code> form, and iterator pairs in terms of <a href="https://eel.is/c++draft/iterator.operations#5">pointer subtraction</a> for the <code>(start, end)</code> form, so this is both necessary and sufficient.
</p>
<p>
Moreover, it would be impractical for C++ to forbid <code>(nullptr, 0)</code>. C++ code routinely needs to interact with APIs that specify slices as individual components. Given such an API, <em>no one</em> writes code like this:
</p>

<pre>void takes_a_slice(const uint8_t *in, size_t len);

uint8_t placeholder;
takes_a_slice(&amp;placeholder, 0);
</pre>

<p>
It is much more natural to use <code>nullptr</code>:
</p>

<pre>void takes_a_slice(const uint8_t *in, size_t len);

takes_a_slice(nullptr, 0);
</pre>

<p>
This means, to be practical, functions like <code>takes_a_slice</code> must accept <code>(nullptr, 0)</code>. For implementing such functions to be practical, the underlying language primitives must then also accept <code>(nullptr, 0)</code>.
</p>

<p>
As for the <code>(alignof(T), 0)</code> question, pointer <a href="https://eel.is/c++draft/expr.add#4.2">addition</a> and <a href="https://eel.is/c++draft/expr.add#5.2">subtraction</a> require the pointers point to some object and that the operation stays within the bounds of that object (or one past the end). C++ does not define there to be an object at <code>alignof(T)</code>, so this is not allowed, instead producing Undefined Behavior. This has no immediate usability concern (no one is going to write <code>reinterpret_cast&lt;uint8_t*&gt;(1)</code> to call <code>takes_a_slice</code>), but we’ll see later that it has some consequences for Rust FFIs.
</p>

<p>(Update 2024-01-16: Added the following paragraph, as this shorthand seems to have been unclear.)</p>

<p>
Of course, <em>in principle</em>, nothing stops <code>takes_a_slice</code> from defining its own unique rules for these corner cases. Beyond what the type system naturally provides, user code will rarely formally define semantics, and we must instead look to fuzzier conventions and expectations. Sadly, in C and C++, these fuzzier aspects often include well-definedness, but, when the underlying slice-adjacent language primitives are all consistent, a naively written function will match. This is then a reasonable default interpretation for <code>takes_a_slice</code>. When this post discusses “the” rules for slices for C++ or C, it is in part a shorthand for this emergent convention.
</p>

<p>
However, C++ is merely <em>almost</em> self-consistent. C++ picks up <code>memcpy</code> and other functions from C’s standard library, complete with C’s semantics…
</p>

<h2 id="c-slices">C</h2>

<p>
C is messier. As in C++, it is impractical to reject <code>(nullptr, 0)</code>. However, C does not have C++’s special cases for <code>nullptr + 0</code> and <code>nullptr - nullptr</code>. See clauses 8 and 9 of section 6.5.6 of <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf">N2310</a>. <code>memcpy</code> and the rest of the C standard library similarly <a href="https://www.imperialviolet.org/2016/06/26/nonnull.html">forbid</a> <code>(nullptr, 0)</code>.
</p>
<p>
I think <strong>this should be considered a bug in the C specification</strong>, and compilers should not <a href="https://gcc.gnu.org/gcc-4.9/porting_to.html">optimize based on it</a>. In <a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a>, we found the C rules so unusable that we resorted to <a href="https://boringssl.googlesource.com/boringssl/+/17cf2cb1d226b0ba2401304242df7ddd3b6f1ff2%5E%21/">wrapping the standard library</a> with <code>n != 0</code> checks. The pointer arithmetic rules are similarly a <a href="https://boringssl.googlesource.com/boringssl/+/6be491b7bb57c3950d4fbb97fdd4a141e3fa4d63%5E%21/">tax</a> <a href="https://boringssl.googlesource.com/boringssl/+/4984e4a6325e9c6302f846c7bf2b75e8ea3fd9dd%5E%21/">on</a> <a href="https://boringssl.googlesource.com/boringssl/+/3c6085b6ae982a80633bf5369c274036702c6848%5E%21/">development</a>. Moreover, C++ inherits C’s standard library (but not its pointer rules), including this behavior. In Chromium’s C++ code, <code>memcpy</code> has been the single biggest blocker to <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1394755">enabling UBSan</a>.
</p>
<p>
Fortunately, there is hope. <a href="https://www.npopov.com/2024/01/01/This-year-in-LLVM-2023.html#zero-length-operations-on-null">Nikita Popov</a> and Aaron Ballman have written a <a href="https://docs.google.com/document/d/1guH_HgibKrX7t9JfKGfWX2UCPyZOTLsnRfR6UleD1F8/edit">proposal</a> to fix this in C. (Thank you!) While it won’t make C and C++ safe by any stretch of imagination, this is an easy step to fix an unforced error.
</p>
<p>
Note that, apart from contrived examples with deleted null checks, the current rules do not actually help the compiler meaningfully optimize code. A <code>memcpy</code> implementation cannot rely on pointer validity to speculatively read because, even though <code>memcpy(NULL, NULL, 0)</code> is undefined, slices at the end of a buffer are fine:
</p>

<pre>char buf[16];
memcpy(dst, buf + 16, 0);
</pre>

<p>
If <code>buf</code> were at the end of a page with nothing allocated afterwards, a speculative read from <code>memcpy</code> would break.
</p>

<h2 id="rust-slices">Rust</h2>

<p>
Rust does <em>not</em> allow <code>(nullptr, 0)</code>. Functions like <code>std::slice_from_raw_parts</code> <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html">require the pointer to be non-null</a>. This comes from Rust treating types like <code>&amp;[T]</code> and <code>*[T]</code> as analogous to <code>&amp;T</code> and <code>*T</code>. They are “references” and “pointers” that are represented as <code>(start, count)</code> pairs. Rust requires every pointer type to have a “null” value outside its reference type. This is used in <code>enum</code> layout optimizations. For example, <code>Option::&lt;&amp;[T]&gt;</code> has the same size as <code>&amp;[T]</code> because <code>None</code> uses this null value.
</p>
<p>
Unfortunately, Rust chose <code>(nullptr, 0)</code> for the null slice pointer, which means the empty slice, <code>&amp;[]</code>, cannot use it. That left Rust having to invent an unusual convention: some non-null, aligned, but otherwise dangling pointer, usually <code>(alignof(T), 0)</code>.
</p>
<p>
Is pointer arithmetic defined for this slice? From what I can tell, the answer appears to be no! <span>(Update 2024-01-16: It sounds like this is <a href="https://github.com/rust-lang/rust/issues/117945">in the process of being defined</a>!)</span>
</p>
<p>
Pointer arithmetic in Rust is spelled with the methods <code><a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.add">add</a></code>, <code><a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.sub_ptr">sub_ptr</a></code>, and <code><a href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset_from">offset_from</a></code>, which the standard library defines in terms of <a href="https://doc.rust-lang.org/std/ptr/index.html#allocated-object">allocated objects</a>. That means, for pointer arithmetic to work with <code>alignof(T)</code>, there must be zero-size slices allocated at every non-zero address. Moreover, <code>offset_from</code> requires the two dangling pointers derived from the same slice to point to the “same” of these objects. While the third bullet <a href="https://doc.rust-lang.org/std/ptr/index.html#safety">here</a>, second sentence, says casting literals gives a pointer that is “valid for zero-sized accesses”, it says nothing about allocated objects or pointer arithmetic.

</p><p>
Ultimately, these semantics come from LLVM. The Rustonomicon has <a href="https://doc.rust-lang.org/nomicon/vec/vec-alloc.html#:~:text=The%20other%20corner%2Dcase%20we%20need%20to%20worry%20about%20is%20empty%20allocations">more to say on this</a> (beginning “The other corner-case…”). It concludes that, while there are infinitely many <em>zero-size</em> types at <code>0x01</code>, Rust conservatively assumes alias analysis does <em>not</em> allow offsetting <code>alignof(T)</code> with zero for <em>positive-sized</em> types. This means <strong>Rust pointer arithmetic rules are incompatible with Rust empty slices.</strong> But recall that slice iteration and pointer arithmetic are deeply related. The Rustonomicon’s <a href="https://doc.rust-lang.org/nomicon/vec/vec-into-iter.html">sample iterator</a> uses pointer arithmetic, but needs to guard addition with <code>cap == 0</code> in <code>into_iter</code> and cast to <code>usize</code> in <code>size_hint</code>.
</p>
<p>
This is too easy for programmers to forget. Indeed the real Rust slice iterator does pointer arithmetic unconditionally (<a href="https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter.rs#L94">pointer addition</a>, <a href="https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter/macros.rs#L57">pointer subtraction</a>, behind <a href="https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter/macros.rs#L141">some</a> <a href="https://github.com/rust-lang/rust/blob/76101eecbe9aa80753664bbe637ad06d1925f315/library/core/src/slice/iter.rs#L132">macros</a>). This suggests <strong>Rust slice iterators are unsound.</strong>
</p>

<h2 id="ffis">FFIs</h2>

<p>
Beyond self-consistency concerns, all this means Rust and C++ slices are incompatible. Not all Rust <code>(start, count)</code> pairs can be passed into C++ and vice versa. C’s issues make its situation less clear, but the natural fix is to bring it in line with C++.
</p>
<p>
This means Rust FFI is not <a href="https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html">“zero-cost”</a>. <strong>Passing slices between C/C++ and Rust requires conversions in both directions to avoid Undefined Behavior.</strong>
</p>
<p>
More important (to me) than performance, this is a safety and ergonomics problem. Programmers cannot be expected to memorize language specifications. If given a <code>&amp;[T]</code> and trying to call a C API, the natural option is to use <code><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr">as_ptr</a></code>, but that will return a C/C++-incompatible output. Most Rust crates I’ve seen which wrap C/C++ APIs do not convert and are unsound as a result.

</p><p>
This is particularly an issue because C and C++’s (more serious) safety problems cause <a href="https://security.googleblog.com/2021/09/an-update-on-memory-safety-in-chrome.html">real user harm</a> and need addressing. But there is half a century of existing C and C++ code. We cannot realistically address this with a new language without good FFI. What makes for good FFI? At a bare minimum, I think <strong>calling a C or C++ function from Rust should not be dramatically less safe than calling that function from C or C++.</strong>
</p>

<h2 id="wishlist">Wishlist</h2>

<p>
Empty lists should not be so complicated. We could change C, C++, and Rust in a few ways to improve things: 
</p>

<h3 id="make-c-accept-nullptr">Make C accept <code>nullptr</code></h3>

<p>
See Nikita Popov and Aaron Ballman’s <a href="https://docs.google.com/document/d/1guH_HgibKrX7t9JfKGfWX2UCPyZOTLsnRfR6UleD1F8/edit">proposal</a>.
</p>

<h3 id="fix-rust-slices">Fix Rust’s slice representation</h3>

<p>
All the <code>alignof(T)</code> problems ultimately come from Rust’s unusual empty slice representation. This falls out of Rust’s need for a “null” <code>*[T]</code> value that is not a <code>&amp;[T]</code> value. Rust could have chosen any of a number of unambiguously unused representations, such as <code>(nullptr, 1)</code>, <code>(nullptr, -1)</code>, or <code>(-1, -1)</code>.
</p>
<p>
While this would be a significant change now, with compatibility implications to work through, I think it is worth seriously considering. It would address the root cause of this mess, fixing a soundness hazard in not just Rust FFI, but Rust on its own. This hazard is real enough that Rust’s standard library hits it.
</p>
<p>
This is also the only option I see that fully meets Rust’s “zero-cost” FFI <a href="https://blog.rust-lang.org/2015/04/24/Rust-Once-Run-Everywhere.html">goals</a>. Even if we make C and C++ accept <code>(alignof(T), 0)</code> from Rust (see below), any slices passed from C/C++ to Rust may still be <code>(nullptr, 0)</code>.
</p>

<h3 id="define-invalid-pointers">Define pointer arithmetic for invalid pointers</h3>

<p>
If Rust leaves its slice representation as is, we instead should define pointer arithmetic for <code>NonNull::dangling()</code>. Expecting low-level Rust code to guard all pointer offsets is impractical.
</p>

<p>Update 2024-01-16: Happily, it sounds like this is already <a href="https://github.com/rust-lang/rust/issues/117945">in the process of being defined</a>!</p>

<p>
Where <code>nullptr</code> is a single value which could just be special-cased, there are many <code>alignof(T)</code> values. It seems one would need to define it in terms of the actual allocated objects. This is well beyond my expertise, so I’ve likely gotten all the details and terminology wrong, but one possibility is, in the vein of <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2364.pdf">PNVI-ae-udi</a>:
</p>
<ul>

<li><code>cast_ival_to_ptrval</code> returns a special <code>@empty</code> provenance when casting garbage values (unchanged from PNVI-ae-udi)

</li><li>Adding zero to a pointer with the <code>@empty</code> provenance is valid and gives back the original pointer

</li><li>Two pointers with <code>@empty</code> provenance can be subtracted to give zero if they have the same address
</li>
</ul>
<p>
One subtlety, however, is that <code>cast_ival_to_ptrval</code> might not give back <code>@empty</code> if there is an object at that address. Giving back a concrete provenance means picking up <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2443.pdf">pointer-zapping</a> semantics, which would be undesirable here. For <code>alignof(T)</code>, that shouldn’t happen if the maximum alignment is under a page and the bottom page is never allocated. But Rust allows not just <code>alignof(T)</code> but <a href="https://doc.rust-lang.org/std/ptr/index.html#safety">any non-zero integer literal</a>, <em>even if some allocation happens to exist at that address</em>. (Perhaps we could use the “user-disambiguation” aspect and say all integer-to-pointer casts may additionally disambiguate to <code>@empty</code>? Would that impact the compiler’s aliasing analysis?)
</p>
<p>
I think this complexity demonstrates why <code>nullptr</code> is a much better choice for an empty slice than a dangling pointer. Pointer arithmetic with <code>nullptr</code> is easy to define, and <code>nullptr</code> cannot alias a real allocation.
</p>
<p>
If Rust (and LLVM) accepted invalid pointers, it would fix the soundness issues within Rust, but not with FFIs. If the C and C++ standards <em>also</em> picked this up, it would <em>partially</em> fix FFIs. We could then directly pass Rust slices into C and C++, but not in the other direction. Directly passing C and C++ slices into Rust can only be fixed by changing Rust to accept <code>(nullptr, 0)</code> form.</p>

<p><s>(Outside of Rust FFI, there’s no reason to use <code>alignof(T)</code> as a pointer in C/C++, so I do not know how plausible it would be for C/C++ to accept it.)</s> <span>Update 2024-01-16: Nelson Elhage reminded me that non-null sentinel pointers are sometimes used to <a href="https://github.com/torvalds/linux/blob/ffc253263a1375a65fa6c9f62a893e9767fbebfa/include/linux/slab.h#L167-L178">allocate zero bytes</a>. While C forbids <code>malloc</code> from doing this (<code>malloc(0)</code> must return either <code>nullptr</code> or a <em>unique</em> non-null pointer), other allocators might reasonably pick this option. It makes error checks more uniform without actually reserving address space. So there is a non-Rust reason to allow these pointers in C and C++.
</span></p>

<h3 id="ffi-helpers">FFI helpers in Rust standard library</h3>

<p>
If the languages’ slice representations cannot be made compatible, we’re still left with safety hazards in Rust FFI. In that case, Rust’s standard library should do more to help programmers pick the right operations: Add analogs of <code>slice::from_raw_parts</code>, <code>slice::as_ptr</code>, etc., that use the C and C++ representation, converting internally as needed. Document existing functions very clear warnings that they cannot be used for FFI. Finally, audit all existing calls in crates.io, as the majority of existing calls are likely for FFI.
</p>
<p>
For <code>slice::from_raw_parts</code>, we could go further and fix the existing function itself. This would be backwards-compatible, but adds unnecessary conversions to non-FFI uses. That said, if the crates.io audit reveals mostly FFI uses, that conversion may be warranted. For non-FFI uses, a type signature incorporating <code><a href="https://doc.rust-lang.org/std/ptr/struct.NonNull.html">std::ptr::NonNull</a></code> would have been more appropriate anyway.

</p><p>
This would improve things, but it’s an imperfect solution. We’d still sacrifice zero-cost FFI, and we’d still rely on programmers to read the warnings and realize the natural options are incorrect.
</p>

<h2 id="acknowledgements">Acknowledgements</h2>

<p>
Thanks to Alex Chernyakhovsky, Alex Gaynor, Dana Jansens, Adam Langley, and Miguel Young de la Sota for reviewing early iterations of this post. Any mistakes in here are my own.
</p>


</div>
  </body>
</html>
