<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arathunku.com/b/2024/shell-scripting-with-elixir/">Original</a>
    <h1>Shell scripting with Elixir</h1>
    
    <div id="readability-page-1" class="page"><section id="wrapper"><article><header><h2>Feb 11, 2024</h2></header><section id="post-body"><p>When simple bash scripts start to become unwieldy, you may consider reaching out for something “higher” level, like Perl, Ruby or Python. I’m reaching out for Elixir. Maybe the startup times are not perfect for every use case, but Elixir is extremely versatile. It’s easy to add dependencies, debug, iterate and even write tests, all in a single file! I believe, due to <a href="https://arathunku.com/b/2024/shell-scripting-with-elixir/livebook.dev">LiveBook</a>, it really hits its stride in recent years; the ecosystem leans heavily into ergonomic developer experience and great out-of-the-box defaults (<a href="https://github.com/wojtekmach/req">Req</a> is amazing!). In few lines of code, you can connect to Postgres, send HTTP requests or start HTTP server.</p><p>For my own use cases I’ve written scripts for displaying weather(focus only on rain, v. important for dog walks when your dog hates rain) in <a href="https://github.com/greshake/i3status-rust"><code>i3status-rust</code></a>, transforming various CSV files from bank exports into <a href="https://beancount.github.io/"><code>beancount</code></a> format, or creating <a href="https://github.com/visciang/telegram">Telegram bots</a>.</p><p>A simple script may be just:</p><div><pre tabindex="0"><code data-lang="elixir"><span><span><span>#!/usr/bin/env elixir</span>
</span></span><span><span><span>IO</span><span>.</span>puts(<span>&#34;Hello world&#34;</span>)
</span></span></code></pre></div><p>Well, if it were that simple, I’d just do <code>echo &#34;Hello world&#34;</code> and skip Elixir, but then there’d be no point in writing this blog post, right? So, I have another, a bit more involved and what may seem like over-complicated template. It’s a starting point for more complex scripts, and I can either remove some of the parts I don’t need or start extending it.</p><h2 id="the-template">The template</h2><div><pre tabindex="0"><code data-lang="elixir"><span><span><span>#!/usr/bin/env -S ERL_FLAGS=+B elixir</span>
</span></span><span><span><span>Mix</span><span>.</span>install([])
</span></span><span><span>
</span></span><span><span><span>if</span> <span>System</span><span>.</span>get_env(<span>&#34;DEPS_ONLY&#34;</span>) <span>==</span> <span>&#34;true&#34;</span> <span>do</span>
</span></span><span><span>  <span>System</span><span>.</span>halt(<span>0</span>)
</span></span><span><span>  <span>Process</span><span>.</span>sleep(<span>:infinity</span>)
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>defmodule</span> <span>Hello</span> <span>do</span>
</span></span><span><span>  <span>@moduledoc</span> <span>&#34;&#34;&#34;
</span></span></span><span><span><span>  &lt;!-- TODO --&gt;
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>##</span><span> Usage
</span></span></span><span><span><span>    
</span></span></span><span><span><span>      $ bin/hello --help
</span></span></span><span><span><span>    
</span></span></span><span><span><span>  &#34;&#34;&#34;</span>
</span></span><span><span>
</span></span><span><span>  <span>@args</span> [<span>help</span>: <span>:boolean</span>]
</span></span><span><span>  <span>def</span> main(args) <span>do</span>
</span></span><span><span>    {parsed, args} <span>=</span> <span>OptionParser</span><span>.</span>parse!(args, <span>strict</span>: <span>@args</span>)
</span></span><span><span>    cmd(parsed, args)
</span></span><span><span>  <span>end</span>
</span></span><span><span>
</span></span><span><span>  <span>defp</span> cmd([<span>help</span>: <span>true</span>], _), <span>do</span>: <span>IO</span><span>.</span>puts(<span>@moduledoc</span>)
</span></span><span><span>  <span>defp</span> cmd(_parsed, _args) <span>do</span>
</span></span><span><span>    <span>IO</span><span>.</span>puts(<span>@moduledoc</span>)
</span></span><span><span>    <span>System</span><span>.</span>stop(<span>1</span>)
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span><span><span>
</span></span><span><span><span>Hello</span><span>.</span>main(<span>System</span><span>.</span>argv())
</span></span></code></pre></div><p>First of all, the shebang is not the usual thing you’d expect. It configures an additional flag for <a href="https://www.erlang.org/doc/man/erl.html"><code>erl</code></a>. This flag, per <a href="https://erlang.org/documentation/doc-4.9.1/erts-4.9.1/doc/html/erl.html">docs</a>, “De-activates the break handler for (SIGINT) ^C and ^\ “. I’ll expand on it in <a href="#signals-some-are-not-like-the-others">Signals</a> section.</p><p>Now, we’re executing, and there’s a ready-to-go <a href="https://hexdocs.pm/mix/Mix.html#install/2"><code>Mix.install/2</code></a> statement where we can add additional dependencies. To make HTTP requests, we can add battries-included HTTP client like <code>{:req, &#34;~&gt; 0.4&#34;}</code>. Processing JSON? <code>{:jason, &#34;~&gt; 1.4&#34;}</code>. We can search for packages with <code>mix hex.search [package-name]</code> or lookup the latest version <code>mix hex.info [package-name]</code></p><div><pre tabindex="0"><code data-lang="console"><span><span>$ mix hex.info req
</span></span><span><span>Req is a batteries-included HTTP client for Elixir.
</span></span><span><span><span>
</span></span></span><span><span><span></span>Config: {:req, &#34;~&gt; 0.4.8&#34;}
</span></span><span><span>Releases: 0.4.8, 0.4.7, 0.4.6, 0.4.5, 0.4.4, 0.4.3, 0.4.2, 0.4.1, ...
</span></span><span><span><span>
</span></span></span><span><span><span></span>Licenses: Apache-2.0
</span></span><span><span>Links:
</span></span><span><span>  Changelog: https://hexdocs.pm/req/changelog.html
</span></span><span><span>  GitHub: https://github.com/wojtekmach/req
</span></span></code></pre></div><p>Another unusual block is <code>if System.get_env(&#34;DEPS_ONLY&#34;) do ... end</code>. If the script doesn’t have any dependencies, I’d just delete it or let it be. It’s useful in cases when the script has dependencies. We can use this block to cache dependencies and compilation of the script, skipping the execution of the rest of the script. This is handy for CI setups or when building container images. For CI, I’d also define a directory where the dependencies should be cached. for GitLab CI, a job may looks like this:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span>print-hello</span>:
</span></span><span><span>  <span># https://hub.docker.com/r/hexpm/elixir/tags?page=1</span>
</span></span><span><span>  <span>image</span>: <span>hexpm/elixir:1.16.1-erlang-26.2.2-debian-bookworm-20240130-slim</span>
</span></span><span><span>  <span>variables</span>:
</span></span><span><span>    <span>MIX_INSTALL_DIR</span>: <span>&#34;$CI_PROJECT_DIR/.cache/mix&#34;</span>
</span></span><span><span>  <span>cache</span>:
</span></span><span><span>    - <span>key</span>: <span>elixir-cache</span>
</span></span><span><span>      <span>paths</span>:
</span></span><span><span>        - <span>.cache</span>
</span></span><span><span>  <span>script</span>:
</span></span><span><span>    - <span>DEPS_ONLY=true bin/hello</span>
</span></span><span><span>    - <span>bin/hello</span>
</span></span></code></pre></div><p>After that, there’s a module where we’ll be documenting what the script is about, defining options for parsing arguments and failing gracefully when invalid options are passed, ensuring proper error exit code. That’s also where we’d extend the script, before last <code>cmd/2</code>. CLI argument parsing is done with built-in <a href="https://hexdocs.pm/elixir/OptionParser.html">OptionParser</a>.</p><p>This structure may seem a bit verbose and may look like a lot of boilerplate, but again, if it were simple, we’d have just stayed with the bash in the first place. Here, this structure can easily grow with the script.</p><p>I used to define inline functions like <code>print_help = fn -&gt; ... end</code> or <code>process_args = fn (args) -&gt; .. end</code> but in the end, working within a module is cleaner, and no need to look if given function is anonymous function (<code>.()</code> call) or module’s function.</p><p>With the template in place, we’re ready to add some logic to it. Elixir can do quite a bit just with the standard library, but there are also some gotchas. Let’s go through some common needs.</p><h3 id="output"><strong>Output</strong></h3><p><a href="https://hexdocs.pm/elixir/IO.html"><code>IO</code></a> will probably be the most often used module. It can be used to write stdout with functions like <code>IO.write/1</code>, <code>IO.puts/1</code>, or to <code>stderr</code> with their equivalent 2-argument calls like <code>IO.puts(:stderr, &#34;Error&#34;)</code>. We can also read inputs with <code>IO.read/2</code>. Any writing or reading can be also handled as a stream with <a href="https://hexdocs.pm/elixir/IO.html#stream/2"><code>IO.stream/2</code></a>.</p><div><pre tabindex="0"><code data-lang="elixir"><span><span><span>IO</span><span>.</span>puts(<span>&#34;Hello&#34;</span>)
</span></span><span><span><span>IO</span><span>.</span>puts(<span>:stderr</span>, <span>&#34;Invalid argument&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>IO</span><span>.</span>stream(<span>:stdin</span>, <span>:line</span>) <span># that&#39;s the default</span>
</span></span><span><span><span>|&gt;</span> <span>Enum</span><span>.</span>map(<span>&amp;</span><span>String</span><span>.</span>trim_trailing(&amp;1, <span>&#34;</span><span>\n</span><span>&#34;</span>))
</span></span><span><span><span>|&gt;</span> <span>Enum</span><span>.</span>map(<span>&amp;</span><span>String</span><span>.</span>reverse<span>/</span><span>1</span>)
</span></span><span><span><span>|&gt;</span> <span>Enum</span><span>.</span>map(<span>&amp;</span><span>IO</span><span>.</span>puts<span>/</span><span>1</span>)
</span></span></code></pre></div><h3 id="colors"><strong>Colors</strong></h3><p>There’s no need to define color codes manually. With <a href="https://hexdocs.pm/elixir/IO.ANSI.html">IO.ANSI</a>, we can add text and background colors easily.</p><div><pre tabindex="0"><code data-lang="elixir"><span><span>iex(<span>1</span>)<span>&gt;</span> <span>IO.ANSI</span><span>.</span>blue_background()
</span></span><span><span><span>&#34;</span><span>\e</span><span>[44m&#34;</span>
</span></span><span><span>iex(<span>2</span>)<span>&gt;</span> v <span>&lt;&gt;</span> <span>&#34;Example&#34;</span> <span>&lt;&gt;</span> <span>IO.ANSI</span><span>.</span>reset()
</span></span><span><span><span>&#34;</span><span>\e</span><span>[44mExample</span><span>\e</span><span>[0m&#34;</span>
</span></span><span><span>iex(<span>3</span>)<span>&gt;</span> v <span>|&gt;</span> <span>IO</span><span>.</span>puts()
</span></span><span><span><span>Example</span>
</span></span><span><span><span>:ok</span>
</span></span></code></pre></div><p><img src="https://arathunku.com/b/2024/shell-scripting-with-elixir/Pasted_image_20240211121425.png" alt="Pasted_image_20240211121425.png"/></p><h3 id="exit-code"><strong>Exit code</strong></h3><p>Another quick one, there’s <a href="https://hexdocs.pm/elixir/1.12/System.html#stop/1"><code>System.stop(exit_code)</code></a> to gently shutdown VM, what may not be obvious is that it’s async process. Make sure to call <code>Process.sleep(:infinity)</code> after it to block the execution. This ensures that all the applications are taken down gently. There’s alternative of <a href="https://hexdocs.pm/elixir/1.12/System.html#halt/1"><code>System.halt/1</code></a> and it forces immediate shutdown of Erlang runtime system.</p><h3 id="subprocesses"><strong>Subprocesses</strong></h3><p>For one-off commands, <a href="https://hexdocs.pm/elixir/main/System.html#cmd/3"><code>System.cmd/3</code></a> is enough.</p><div><pre tabindex="0"><code data-lang="elixir"><span><span>iex(<span>1</span>)<span>&gt;</span> {output, <span>0</span>} <span>=</span> <span>System</span><span>.</span>cmd(<span>&#34;git&#34;</span>, [<span>&#34;rev-parse&#34;</span>, <span>&#34;--show-toplevel&#34;</span>])
</span></span><span><span>{<span>&#34;/home/arathunku/code/github.com/arathunku/elixir-cli-template-example</span><span>\n</span><span>&#34;</span>, <span>0</span>}
</span></span></code></pre></div><p>With pattern matching we ensure immediate exit if there’s any other exit code than the successful one, and we can process the output.</p><p>It gets more tricky if you want to create another BEAM process while continuing with the rest of the execution. If something goes wrong or Erlang system crashes, OS process might get left behind. In these cases, instead of reinveting a wheel of managing OS processes, it’s good occasion to make a use of this <code>Mix.install/2</code> at the beginning and add <a href="https://github.com/fhunleth/muontrap">MuonTrap</a>. It will ensure the processes are, as described in README, well-behaved.</p><pre tabindex="0"><code>Mix.install([{:muontrap, &#34;~&gt; 1.0&#34;}])

defmodule Hello do
  ...
  
  defp cmd([], []) do
    _pid = spawn_link(fn -&gt;
      MuonTrap.cmd(&#34;ping&#34;, [&#34;-i&#34;, &#34;5&#34;, &#34;localhost&#34;], into: IO.stream(:stdio, :line))
      System.stop()
    end)
    Process.sleep(:infinity)
  end
end
</code></pre><h3 id="signals-some-are-not-like-the-others">Signals, some are not like the others</h3><p>It’s tricky and it will probably not behave as you’d expect based on your experience in other languages. Some signals are handled by default by Erlang system, for more details check <a href="https://github.com/erlang/otp/pull/1315">nice documentation in PR</a>. For scripting… usually signals don’t matter that much, at least in my case. If you spawn a GenServer, it’ll receive <a href="https://hexdocs.pm/elixir/GenServer.html#c:terminate/2"><code>terminate/2</code></a> for cleanup, assuming gentle shutdown.</p><p>We can still skip <code>BREAK</code> menu(^C) and exit immediately if we start with <code>ERL_FLAGS=+B elixir</code>. This is why it’s in the template at the beginning. Some other signals can be cough by swapping default <code>erl_signal_server</code>, but not all of them*. In the example above we’ll do just that, handle what we’re interested it and defer rest to the default handler.</p><blockquote><p>*At this moment, <code>INT</code> cannot be trapped, <a href="https://github.com/erlang/otp/issues/4583">see this issue</a></p></blockquote><div><pre tabindex="0"><code data-lang="elixir"><span><span><span>defmodule</span> <span>Signals</span> <span>do</span>
</span></span><span><span>  <span>@behaviour</span> <span>:gen_event</span>
</span></span><span><span>  <span>def</span> init(_), <span>do</span>: {<span>:ok</span>, <span>nil</span>}
</span></span><span><span>
</span></span><span><span>  <span>def</span> handle_event(<span>:sigusr1</span>, state) <span>do</span>
</span></span><span><span>    <span>IO</span><span>.</span>puts(<span>&#34;USR1, continue...&#34;</span>)
</span></span><span><span>    {<span>:ok</span>, state}
</span></span><span><span>  <span>end</span>
</span></span><span><span>
</span></span><span><span>  <span>def</span> handle_event(<span>:sigterm</span>, _state) <span>do</span>
</span></span><span><span>    <span>IO</span><span>.</span>puts(<span>&#34;Ok, ok, let me take a moment and exit...&#34;</span>)
</span></span><span><span>    <span>Process</span><span>.</span>sleep(<span>3</span>)
</span></span><span><span>    <span>System</span><span>.</span>stop()
</span></span><span><span>  <span>end</span>
</span></span><span><span>  
</span></span><span><span>  <span>def</span> handle_event(signal, state), <span>do</span>: <span>:erl_signal_handler</span><span>.</span>handle_event(signal, state)
</span></span><span><span>
</span></span><span><span>  <span>def</span> handle_call(_, state), <span>do</span>: {<span>:ok</span>, <span>:ok</span>, state}
</span></span><span><span>
</span></span><span><span>  <span>def</span> terminate(reason, _state) <span>do</span>
</span></span><span><span>    <span>IO</span><span>.</span>puts(<span>&#34;Goodbye! </span><span>#{</span>inspect(reason)<span>}</span><span>&#34;</span>)
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>end</span>
</span></span><span><span>with <span>:ok</span> <span>&lt;-</span> <span>:gen_event</span><span>.</span>swap_handler(
</span></span><span><span>  <span>:erl_signal_server</span>, {<span>:erl_signal_handler</span>, []}, {__MODULE__, []}
</span></span><span><span>) <span>do</span>
</span></span><span><span>  <span>IO</span><span>.</span>puts(<span>&#34;I&#39;ll wait for signals!&#34;</span>)
</span></span><span><span>  <span>Process</span><span>.</span>sleep(<span>:infinity</span>)
</span></span><span><span><span>else</span>
</span></span><span><span>  err <span>-&gt;</span>
</span></span><span><span>    <span>IO</span><span>.</span>warn(<span>&#34;Something went wrong. err=</span><span>#{</span>inspect(err)<span>}</span><span>&#34;</span>)
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h3 id="testing"><strong>Testing</strong></h3><p>In Rust, we can write tests next to the code with <code>#[cfg(test)]</code>, and these will run when <code>cargo test</code> is executed. Did you know you can do kind of a similar thing in Elixir scripts? There’s no magic here, we need to create a test module and trigger <a href="https://hexdocs.pm/ex_unit/ExUnit.html"><code>ExUnit</code></a></p><div><pre tabindex="0"><code data-lang="elixir"><span><span><span>if</span> <span>System</span><span>.</span>get_env(<span>&#34;MIX_ENV&#34;</span>) <span>==</span> <span>&#34;test&#34;</span> <span>do</span>
</span></span><span><span>  <span>ExUnit</span><span>.</span>start()
</span></span><span><span>
</span></span><span><span>  <span>defmodule</span> <span>HelloTest</span> <span>do</span>
</span></span><span><span>    <span>use</span> <span>ExUnit.Case</span>, <span>async</span>: <span>true</span>
</span></span><span><span>    <span>import</span> <span>ExUnit.CaptureIO</span>
</span></span><span><span>
</span></span><span><span>    test <span>&#34;prints a message when no arguments are passed&#34;</span> <span>do</span>
</span></span><span><span>      assert capture_io(<span>fn</span> <span>-&gt;</span> <span>Tests</span><span>.</span>main([]) <span>end</span>) <span>==</span> <span>&#34;Hello World</span><span>\n</span><span>&#34;</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span>    
</span></span><span><span>    test <span>&#34;prints help for unknown arguments&#34;</span> <span>do</span>
</span></span><span><span>      assert capture_io(<span>fn</span> <span>-&gt;</span> <span>Tests</span><span>.</span>main([<span>&#34;--help&#34;</span>]) <span>end</span>) <span>=~</span> <span>&#34;Example of adding ExUnit&#34;</span>
</span></span><span><span>    <span>end</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span><span>else</span>
</span></span><span><span>  <span>Hello</span><span>.</span>main(<span>System</span><span>.</span>argv())
</span></span><span><span><span>end</span>
</span></span></code></pre></div><h2 id="going-beyond-scripts">Going beyond scripts</h2><p><a href="https://hexdocs.pm/elixir/OptionParser.html"><code>OptionParser</code></a> is good. Maybe it doesn’t do all the stuff that something like <a href="https://docs.rs/clap/latest/clap/">Rust clap</a> does but it’s absolutely getting the job done.</p><p>You can go beyond simple CLI scripts and build full TUI apps. Progress bars? Charts? Text editor? Here, <code>Ratatouille</code> comes to the rescue. <a href="https://github.com/arathunku/elixir-cli-template-example/blob/main/bin/tui-counter">Simple TUI counter example</a> or more advanced ones - <a href="https://github.com/ndreynolds/ratatouille/tree/cc7b6a37e0b1757cd89cc5084343814a79dd86dc?tab=readme-ov-file#example-applications">more advanced examples</a>.</p><p>If you’d like to see even more examples with <a href="https://hexdocs.pm/mix/Mix.html#install/2"><code>Mix.install/2</code></a>, make sure to check <a href="https://github.com/wojtekmach/mix_install_examples">mix_install_examples</a>! There’re examples of HTTP servers, CSV parsing, web scraping, machine learning or <a href="https://github.com/wojtekmach/mix_install_examples/blob/main/phoenix_live_view_upload_image.exs">full Phoenix LiveView file uploader</a>(!!!), but at this point you may consider just using <code>mix new ...</code> and setting up a proper Mix project. After that, you can use <a href="https://github.com/burrito-elixir/burrito">burrito</a> to ship a single Elixir CLI binary for end-users.</p><p>Is Elixir more complicated than Ruby od Python as a bash replacement? It depends, of course it depends. If you already know Python or Ruby well, you’ll probably prefer them but Elixir can absolutely be used too! It’s a bit on the slow side to start up, may not be a best choice to implement PS1, but if the startup speed doesn’t matter that much and you want go have very ergonomic language for scripting at your hand - it’s great.</p><h2 id="closing-note">Closing note</h2><p>Writing this article was kind of a strange experience. You may think it’s a bit light on examples and details, and it is done on purpose. There’s strong focus on documentation within the community and I didn’t want to repeat what’s already out there in official docs and libraries. Just look at this beautiful <a href="https://hexdocs.pm/elixir/main/System.html#cmd/3"><code>System.cmd/3</code></a> documentation or <a href="https://hexdocs.pm/elixir/main/IO.ANSI.html"><code>IO.ANSI</code></a> docs, and it’s all available in <a href="https://hexdocs.pm/iex/IEx.html"><code>iex</code></a> with <a href="https://hexdocs.pm/iex/IEx.Helpers.html#h/1"><code>h/1</code></a>.</p><p>When writing the article, I’ve dumped all my scripts and tests into <a href="">this repository</a>. Thanks for reading!</p></section></article></section></div>
  </body>
</html>
