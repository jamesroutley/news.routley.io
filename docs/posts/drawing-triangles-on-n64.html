<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alinacierdem.com/drawing-triangles-on-n64/">Original</a>
    <h1>Drawing Triangles on N64</h1>
    
    <div id="readability-page-1" class="page"><article id="post-577" itemscope="itemscope" itemtype="http://schema.org/BlogPosting" itemprop="blogPost"><div>
			<!-- .entry-header -->		
	<div itemprop="articleBody">

<p>When developing my Nintendo 64 game <a href="https://alinacierdem.com/voidblade-a-n64-postmortem/" target="_blank" rel="noreferrer noopener">Voidblade</a>, an important step was rendering the triangles. The basic building block of any modern 3D pipeline is a triangle, even to this day (according to Brian Karis’s latest SIGGRAPH <a href="https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf" target="_blank" rel="noreferrer noopener">talk</a>, it will probably take “many years” until we start using different representations like voxels). Thus, it is generally the first step whenever you pick up a new rendering API to start learning it. Drawing a triangle, sounds easy right? Wasn’t so easy for me on this particular system and I will try to explain my high level understanding of the underlying hardware in this blog post. It took about 2 weeks for me to come up with the proper commands to feed to the rasterizer for rendering transparent triangles due to the lack of proper documentation and hardware quirks. It still has a few issues for a few edge cases (even causing random and unpredictable crashes that I still need to investigate) but works ok in general.</p>



<p>First for a little bit of context; on the console, there is a main MIPS CPU which generally runs the overall logic of the game and orchestrates other processors, namely the RSP (reality signal processor – a SIMD style vector processing unit) and RDP (reality display processor – a command based hardware rasterizer). Nintendo 64 was one of the systems of the time that provided a specialized hardware rasterizer, that I need to tame. Basically, the RSP reads 64bit commands from the provided buffer (which can be either on the main ram of the system (RDRAM) or provided by the RSP via XBUS) and executes them. In my implementation I have used Rasky’s RDRAM <a href="https://github.com/rasky/mvs64/blob/main/lib/rdl.h" target="_blank" rel="noreferrer noopener">library</a> to build a basic CPU implementation to generate rasterization commands without spending too much time on the cpu reading/writing to the display buffer. In an ideal rendering engine, RSP will constitute an important part of the process to save CPU cycles but currently <a href="https://github.com/DragonMinded/libdragon" target="_blank" rel="noreferrer noopener">libdragon</a> – my primary choice of N64 development library – does not have a ready to use solution to build it easily until this <a href="https://github.com/DragonMinded/libdragon/pull/253" target="_blank" rel="noreferrer noopener">PR</a> is merged, so I went for a simpler CPU implementation.</p>



<p>The gist of rendering a basic triangle is providing the rasterizer with an X and Y start position (in fixed point). Then it starts writing to the screen buffer line by line. To decide on moving to the next line and where to start on the next line, it uses the slopes of the various edges as illustrated on this diagram at a very high level;</p>



<div><figure><img src="https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.6-1-edited.png" alt="" width="659" height="494" srcset="https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.6-1-edited.png 2008w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.6-1-edited-300x225.png 300w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.6-1-edited-1024x768.png 1024w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.6-1-edited-768x576.png 768w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.6-1-edited-1536x1152.png 1536w" sizes="(max-width: 659px) 100vw, 659px"/></figure></div>



<p>RDP starts writing pixels from the top and proceeds line by line moving to the next one when the x position reaches a threshold. Then it increases y position by one and updates the starting x position with respect to the previous start position. For the above illustration, threshold value is increased by the slope of the <strong>M</strong> edge and starting x position is increased by the slope of the <strong>H</strong> edge. Once the y position moves past the inflection point, it starts using the slope of the <strong>L</strong> edge, effectively decreasing the threshold this time (the slope is always added). In reality the things are a little bit more complicated because the actual rasterization starts from the previous pixel if the starting point is <em>inside</em> the pixel (there are 4 vertical subpixels). Also the deflection starts at the next subpixel so there are a few edge cases where additional adjustments are necessary. Additionally, there is another variant where the inflection point is on the left and the triangle should be rendered in a different order. For a more in depth explanation see Snacchus’s <a href="https://docs.google.com/document/d/17ddEo61V0suXbSkKP5mY97QxgUnB-QfAjuBIsPiLWko/edit" target="_blank" rel="noreferrer noopener">guide</a> (also see the full source <a href="https://github.com/anacierdem/n64brew-jam/blob/master/src/geometry.c" target="_blank" rel="noreferrer noopener">here</a>).</p>



<p>Then there is the question of telling the rasterizer what to render while going through this sequence. That is primarily configured using the <em>set other modes</em> command. In my case I was using flat coloured triangles with transparency for which I need to enable blending and read enable bits so that RDP will read from the buffer and mix it with the primitive color that we are newly rasterizing. The whole thing executes on the RDRAM which makes the console heavily fill-rate limited. Another important thing that I should mention, and was probably the most difficult to figure out, is the seam between triangles. As a matter of the fact it is very sensitive on color combiner settings, which I used only to try it at some point but it ended up costing many hours of debugging. Once the color combiner glitch was fixed, I was configuring the coverage unit such that it properly mixes those edges.</p>



<p>The hardware provides a coverage unit capable of calculating a <em>coverage </em>value of 3 bits per pixel, which is written to the target buffer. Consider this pixel with its 8 subpixels;</p>



<div><figure><img loading="lazy" src="https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.7-1-edited.png" alt="" width="449" height="336" srcset="https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.7-1-edited.png 1366w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.7-1-edited-300x225.png 300w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.7-1-edited-1024x768.png 1024w, https://alinacierdem.com/wp-content/uploads/2022/01/Paper.Journal.7-1-edited-768x576.png 768w" sizes="(max-width: 449px) 100vw, 449px"/></figure></div>



<p>Here the blue subpixels represent where the edge is covering in the subpixel array. To save hardware cost only the half of the subpixels are used in the calculation and the above dithering mask is used to decide on which ones to keep. For this example, 5 pixels are covered. The alpha channel’s least significant 3 bits are used to store these coverage values. This means that it can create a 3-bit value for every pixel on an edge, such that it can mix colors from different primitives on these boundary pixels. The coverage value is always updated to the sum of the existing value and the one from the newly rendering primitive and starts at 0. The mix equation is;</p>



<p><em>(p x a + m x b) / (a + b)</em></p>



<p>Here, <em>p</em> is the new pixel’s colour, <em>m</em> is the colour at target buffer location and <em>a</em> and <em>b</em> are the coverage values of the new pixel and memory respectively. As an example if the coverage value is 4, when the other part of the seam is rendered on the same pixel (again with a coverage of 4, where having complementary values is a design requirement) the color from the first primitive will be written as-is increasing the target coverage to 4 causing the next primitive to get mixed in a 1:1 ratio.</p>



<p>On the outer edges of the primitives, this coverage value is also used to blend the pixel color with the nearby fully covered pixels in the video filter (at a later stage) and those outer edges are thus anti-aliased in the final image. Effectively, the coverage value represents the “transparency” of that edge and assuming the background color behind this edge pixel is the same as the average of its neighbours, the hardware <em>approximates</em> a super sampling operation. Because this process is actually averaging over pixel values in the image to decide on the final color, it is one of the reasons why N64 images are known to be <em>blurry</em>.</p>



<p>With this coverage mechanism in place, if you think about transparent primitives on a triangle seam, there is a problem in contrast to the example with solid colors above. When rendering both primitives by mixing the target color using the coverage values, we would end up mixing the transparent color with the already mixed color from the other primitive. This would result in an incorrect color, for example consider when the primitive transparency is 50% and coverage is 50% and we are rendering white on black. The first primitive writes gray at 50% brightness, being the first one to update target coverage but the second primitive will mix this color 1:1 with its 50% gray resulting in a 75% gray. In reality, the brightness should be the same on the seam as well. Instead, the hardware uses a special coverage mode where it starts with an alpha channel of all 1s in the buffer.</p>



<p>When the first edge pixel is rasterized, the coverage is added to the value in the buffer, initially wrapping around. Because the value wraps and there is this special <em>color on wrap</em> mode which only writes the pixel color if the value wraps, the pixel is mixed with the existing value and is written to the buffer forming the final color. When the other triangle on the same seam is rendered, it should now have a coverage value that can make the total all 1s again (remember the coverages are complementary) and when it is added to the existing buffer it does not wrap preventing a re-render on that pixel. The same mechanism still works if the buffer was last written a value other than all 1s due to an outer edge as only one of the two triangles sharing the seam will cause a wrap. I think this is a really good use of very limited hardware resources for a specific problem.</p>



<p>This was my rather high level understanding of the rasterizer hardware summarized. It primarily represents my own thought process when thinking about it, and not necessarily how the underlying hardware formally works. In the end, I haven’t actually utilized the color combiner or transparency but still left these as is in the code for future reference. I hope I can fully utilize transparent primitives in the future for a project! Hope this was an interesting introduction to the N64 hardware rendering for you! Also, it may become useful to someone working on the console as well. Do not forget to drop a comment or reach me out in case you have something to tell!</p>
	
	</div>
		</div></article></div>
  </body>
</html>
