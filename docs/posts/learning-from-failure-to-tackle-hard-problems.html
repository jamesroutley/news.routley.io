<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.ml.cmu.edu/2025/10/27/learning-from-failure-to-tackle-extremely-hard-problems/">Original</a>
    <h1>Learning from failure to tackle hard problems</h1>
    
    <div id="readability-page-1" class="page"><div>
            




<figure><img loading="lazy" width="794" height="497" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-3.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-3.png 794w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-3-300x188.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-3-320x200.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-3-80x50.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-3-300x188@2x.png 600w" sizes="(max-width: 794px) 100vw, 794px"/></figure>



<p>This blog post is based on the work <a href="https://arxiv.org/abs/2510.09596" data-type="URL">BaNEL: Exploration Posteriors for Generative Modeling Using Only Negative Rewards</a>.</p>



<h2>Tackling Very Hard Problems</h2>



<p>The ultimate aim of machine learning research is to push machines beyond human limits in critical applications, including the next generation of theorem proving, algorithmic problem solving, and drug discovery. A standard recipe involves: (1) pre-training models on existing data to obtain base models, and then (2) post-training them using scalar reward signals that measure the quality or correctness of the generated samples.</p>



<p>However, for the hardest instances of these problems, we encounter two challenges:</p>



<ol><li><strong>Sparsity: </strong>the base generative model attains a near-zero reward signal. The probability of producing a positive-reward sample can be so low that the model may go through most of the training without ever encountering a positive reward.</li><li><strong>Costly reward evaluation:</strong> Calls to the reward oracle can be expensive or risky, requiring costly simulations, computations, or even physical experiments.</li></ol>



<div><figure><img loading="lazy" width="821" height="230" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/gpt.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/gpt.png 821w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/gpt-300x84.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/gpt-320x90.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/gpt-80x22.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/gpt-300x84@2x.png 600w" sizes="(max-width: 821px) 100vw, 821px"/><figcaption>GPT-5 receives zero reward in this example query.</figcaption></figure></div>



<p>For example, when asked to design a cure for cancer, GPT-5 fails. If asked again, will it succeed? Probably not. How many attempts would it take? We expect the success probability to be nonzero (since GPT-5, being an autoregressive generative model, never assigns exactly zero probability to any finite sequence), but at best, it’s vanishingly small. Worse still, evaluating the solution is expensive and risky, since it requires conducting actual clinical trials.</p>



<p>A more general example hard problem-solving is designing molecules with specific properties (e.g., <a href="https://www.nature.com/articles/s42004-022-00733-0#Sec5">high activity against a specific protein target</a>), which also suffers from the aforementioned two issues: (1) a base generative model is unlikely to generate highly potent molecules against a specific protein target, and (2) the ground-truth verification of the potency requires actual wet-lab experiments.</p>



<p>These illustrate a broader issue: the hardest and most important problems are those with <em>near-zero success rates</em> — and no positive examples available during learning. To handle these scenarios, we introduce BaNEL (Bayesian Negative Evidence Learning), an algorithm that post-trains the generative model using failed attempts only, while minimizing the <em>number of reward evaluations</em> (NREs).</p>



<p>Under such extreme reward sparsity, standard post-training methods like policy gradients (including GRPO) collapse into brute-force random search, since zero rewards produce zero gradients. Novelty-bonus methods, such as <a rel="noreferrer noopener" href="https://arxiv.org/abs/1703.01310" target="_blank">count-based exploration</a> or <a rel="noreferrer noopener" href="https://arxiv.org/abs/1810.12894" target="_blank">random network distillation</a>, can provide learning signals under sparsity, but they require large NREs and fall short in performance. The following table summarizes our assessment of these methods.</p>



<figure><img loading="lazy" width="794" height="211" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-11.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-11.png 794w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-11-300x80.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-11-320x85.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-11-80x21.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-11-300x80@2x.png 600w" sizes="(max-width: 794px) 100vw, 794px"/><figcaption>Comparison of desired properties–functionality and low number of reward evaluations (NREs)–for key categories of learning methods. An empty circle ○ means the property is not satisfied, a filled circle ● means satisfied, and a half-filled circle ◐ means partially satisfied (e.g., a method is functional, but the success rate does not increase much).</figcaption></figure>







<h2>Learning from Negative Rewards</h2>



<p>The zero-reward problem has historically been addressed using positive transfer from other tasks or domains, hand-designing curricula, and/or engineering more informative and dense reward functions. However, we argue that there will always be tasks and settings where the base model attains an extremely sparse reward. If we cannot address this fundamental obstacle, post-training will be limited to distribution sharpening rather than unlocking genuinely new capabilities beyond training data.</p>



<p>To tackle the zero-reward problem, algorithms should be able to learn from failures alone—using only negative reward samples—while minimizing the number of reward evaluations (NREs). There is a simple (if impractical) way to see that learning from negative samples alone is at least theoretically doable. </p>



<p><strong>Do not make the same mistake twice!</strong> If our budget for evaluating \(r\) was unlimited, and assuming the solution has bounded length, we could trivially achieve a perfect success rate by collecting every possible mistake \(R:=\{\mathbf{x} \mid r(\mathbf{x})=0\}\) and avoiding all elements of \(R\) :</p>



<p>$$p_{\boldsymbol{\theta} \mid R^C}(\mathbf{x}) \propto p_{\boldsymbol{\theta}}(\mathbf{x}) \mathbf{1}[\mathbf{x} \notin R],$$</p>



<p>where \(p_{\boldsymbol{\theta}}\) is the pre-trained generative model (e.g., GPT-5). \(p_{\boldsymbol{\theta} \mid R^C}(\mathbf{x})\) means we condition the model on the complement of \(R\) by multiplying the indicator function. In plain terms, this formulation says: once you’ve seen all possible failures, you’ll never make a new one.</p>



<p><strong>Exploiting the structure underlying failures.</strong> Of course, this approach is infeasible because the space of failures is combinatorial, and we want to minimize NREs. But crucially,<span> in most tasks where success requires intelligence, failures are not arbitrary.</span> They contain patterns that distinguish the failed attempts from successes. If we can learn these patterns, we can approximate \(R\) using a small number of samples. This failure-based approach parallels how human scientists reason: they generalize from failures, avoiding past mistakes without discarding promising directions. To minimize NREs, the algorithm must extract as much information as possible from failures before making new attempts.</p>



<div><figure><img loading="lazy" width="1024" height="208" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-1024x208.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-1024x208.png 1024w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-300x61.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-970x197.png 970w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-320x65.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-80x16.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2.png 1079w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-2-300x61@2x.png 600w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>Minimizing NREs requires heavy computation to fully exploit past failures before costly new attempts (e.g., clinical trials).</figcaption></figure></div>



<h2>Learning a Generative Model of Failures</h2>



<p>Our core idea is to model regularities underlying failures using a separate generative model \(p_\phi\) trained only on failed attempts. Generative modeling is a powerful unsupervised way for learning structure from data — and it scales extremely well! Specifically, we train a separate generative model \(p_\phi\) (parameterized by \(\phi\) ) on \(m\) negative examples with the standard maximum likelihood objective:</p>



<p>$$\max _{\boldsymbol{\phi}} \frac{1}{m} \sum_{i=1}^m \log p_{\boldsymbol{\phi}}(\mathbf{x}_i) .$$</p>



<p>Once well-trained, \(p_\phi(\mathbf{x})\) can be used to assess whether a given input resembles previously observed failures; specifically, we use \(p_\phi\) to define a rejection region \(\tilde{R}\) approximating \(R\):</p>



<p>$$\tilde{R}:=\lbrace \mathbf{x}: \frac{p_{\boldsymbol{\theta}}(\mathbf{x})}{p_{\boldsymbol{\phi}}(\mathbf{x})}&lt;\tau \rbrace$$</p>



<p>where \(\tau\) is a threshold value. Note that this requires \(p_{\boldsymbol{\theta}}\) and \(p_\phi\) to be likelihood-based generative models under which we can compute the likelihood (e.g., autoregressive models). Using the rejection region \(\tilde{R}\), we form a Bayesian posterior \(\tilde{p}_{\boldsymbol{\theta}}\) to approximate \(p_{\boldsymbol{\theta} \mid R^C}\) :</p>



<p>$$p_{\boldsymbol{\theta} \mid \tilde{R}^C}(\mathbf{x}) \propto p_{\boldsymbol{\theta}}(\mathbf{x}) \mathbf{1}[\mathbf{x} \notin \tilde{R}],$$</p>



<p>This posterior filters out data points that are similar to prior failures according to \(\tilde{R}\); equivalently, we direct the model to sample only from \(\tilde{R}^C\).</p>



<h2>Online Recursive Update</h2>



<p>Once we improve the generative model using the Bayesian update as described above, we can use it to gather another batch of \(m\) samples. Here, rejection regions from earlier rounds can be accumulated by taking their union (i.e., \(\tilde R \gets \tilde R \cup \tilde R_{\text{new}}\) where \(R_{\text{new}}\) is the new rejection region). This can be repeated multiple times, as illustrated in the figure below. We call this method BaNEL: Bayesian Negative Evidence Learning, an approach that uses Bayesian updates to learn from negative samples only.</p>



<div><figure><img loading="lazy" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-252x1024.png" alt="" width="362" height="1469" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-252x1024.png 252w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-74x300.png 74w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-505x2048.png 505w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-154x625.png 154w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-57x230.png 57w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-54x220.png 54w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-20x80.png 20w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-252x1024@2x.png 504w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/algo_tall-74x300@2x.png 148w" sizes="(max-width: 362px) 100vw, 362px"/><figcaption>Illustration of BaNEL on a 1D toy example. The procedure begins with a pre-trained proposal distribution (topmost). Two reward-one samples (red bars) are located at -2 and 2. At each iteration, the proposal distribution generates samples, which are very likely to be 0-reward. These are used to train a negative model (red dashed curves). The proposal and negative models are combined to form the Bayesian posterior (black curves). As iterations progress, the posterior increasingly concentrates on the reward-one regions, until convergence (bottommost).</figcaption></figure></div>



<h2>Experiment: Adversarial Attack On Toy Language Model</h2>



<div><figure><img loading="lazy" width="710" height="424" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-8.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-8.png 710w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-8-300x179.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-8-320x191.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-8-80x48.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-8-300x179@2x.png 600w" sizes="(max-width: 710px) 100vw, 710px"/></figure></div>



<p>We first evaluate BaNEL on a toy but informative setting where high-reward samples are rare, and hand-engineering dense rewards is hard. In this task, the goal is to attack the <em>target model</em>, an autoregressive transformer trained to answer digit-addition queries (e.g., it receives “`10+23=”` and must generate “`33”`). The goal of the <em>attacker model</em>, also an autoregressive transformer pre-trained on the same dataset to generate questions such as “`10+23=”`, is to propose syntactically valid addition queries on which the target model produces an incorrect sum.</p>



<p>That is, the reward is defined as:</p>



<ul><li>\(r(\mathbf{x}) = 1\) if \(\mathbf{x}\) is a syntactically valid arithmetic expression and the target’s output is incorrect,</li><li>\(r(\mathbf{x}) = 0\) otherwise.</li></ul>



<p>Since the target is trained well, the pre-trained attacker’s empirical success rate is roughly 0.0004. We set a hard limit on NREs: \(r\) can only be evaluated 7500 times at most. All reward-1 samples are filtered out during training — forcing the model to learn only from failures.</p>



<figure><img loading="lazy" width="755" height="190" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-12.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-12.png 755w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-12-300x75.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-12-320x81.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-12-80x20.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-12-300x75@2x.png 600w" sizes="(max-width: 755px) 100vw, 755px"/><figcaption>Best mean, median, standard deviation, and relative improvement over the Pretrained baseline of the empirical success rates on the adversarial attack task over 5 random seeds. Success rates are measured using 60,000 samples.</figcaption></figure>



<p>As shown in this table, BaNEL improves the success rate by 278x on average, outperforming baselines by several orders of magnitude.</p>



<div><figure><img loading="lazy" width="408" height="293" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-1.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-1.png 408w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-1-300x215.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-1-320x230.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-1-80x57.png 80w" sizes="(max-width: 408px) 100vw, 408px"/><figcaption>Successful attacks generated by BaNEL.</figcaption></figure></div>



<p>BaNEL identifies two failure modes of the target:</p>



<ol><li><strong>Leading zeros</strong>: when at least one of the input digits starts with at least one zero, the output result tends to be incorrect. This is likely because the training data (shared by both the target and the attacker) does not contain any examples with leading zeros.</li><li><strong>Carry-chain stressors: </strong>examples that need to carry a digit during summation.</li></ol>



<p>Based on these identified patterns, we designed a rule-based attack and observed that it achieves a near-perfect success rate. This suggests that BaNEL can be used not only to increase a numeric success rate, but also to guide human intuition on hard problems to extract qualitative insights.</p>



<figure><img loading="lazy" width="716" height="404" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-13.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-13.png 716w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-13-300x169.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-13-320x181.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-13-80x45.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-13-300x169@2x.png 600w" sizes="(max-width: 716px) 100vw, 716px"/><figcaption>Compute scaling for the adversarial attack scenario (leading zeros are not allowed): Improvement factor in success rate of BaNEL over the base model as a function of the number of epochs used to train \(p_\phi\) at each stage, averaged over 5 random seeds. The average success rates of RND and count-based methods are shown as horizontal reference lines.</figcaption></figure>



<p>We also study compute scaling (here, we don’t allow leading zero attacks to make the problem even more challenging). When the negative generative model \(p_\phi\) is under-trained (few epochs), BaNEL performs on par with simpler novelty-bonus baselines (RND and pseudo-count methods). However, as we spend more compute on \(p_\phi\) (without additional NREs), BaNEL outperforms these methods by a large margin. </p>



<p>This highlights a key property: <strong>BaNEL trades compute for reward efficiency.</strong> It is suboptimal under strict compute limits but excels when additional offline computation is available. </p>



<h2>Experiment: Language Model Reasoning</h2>



<p>We further evaluate BaNEL on reasoning tasks using GSM8K subsets, where the pre-trained Qwen 2.5 0.5B model (further fine-tuned on GSM8K using PPO) performs poorly. Again, all reward-1 samples are filtered out during training.</p>



<figure><img loading="lazy" width="911" height="595" src="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-14.png" alt="" srcset="https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-14.png 911w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-14-300x196.png 300w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-14-320x209.png 320w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-14-80x52.png 80w, https://blog.ml.cmu.edu/wp-content/uploads/2025/10/image-14-300x196@2x.png 600w" sizes="(max-width: 911px) 100vw, 911px"/><figcaption>Cumulative best success rate of BaNEL and RND on GSM8K-Hard questions. The shaded area represents confidence intervals (Clopper-Pearson, \(\alpha=0.05\), sample_size=10000).</figcaption></figure>



<p>For most problems, BaNEL substantially improves success rates over the pre-trained baseline, outperforming RND with fewer reward evaluations.</p>



<h2>Closing Remarks</h2>



<p>By modeling failures with a generative model, BaNEL turns negative evidence into a learning signal, enabling exploration in settings where reward = 1 samples are nearly nonexistent. We view BaNEL as an important direction for the generative modeling field: to truly push the frontier of generative model capabilities, we must learn from failures! </p>



<p>Check out <a href="https://arxiv.org/abs/2510.09596">our paper</a> for more results and details!</p>

                    </div></div>
  </body>
</html>
