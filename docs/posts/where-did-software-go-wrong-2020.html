<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jse.li/posts/software/">Original</a>
    <h1>Where did software go wrong? (2020)</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    

    

    <section>
      <p>This post has a <a href="https://traduagindo.wordpress.com/2020/09/03/onde-que-o-software-deu-errado-a-relacao-entre-programacao-e-capitalismo/">Portuguese translation</a>, as well as a <a href="https://pngflare.com/ru-software">Russian translation</a> provided by Leonid Popov, who runs <a href="https://pngflare.com/">pngflare</a>.</p>
<p>Computers were supposed to be “<a href="https://youtu.be/ob_GX50Za6c?t=25">a bicycle for our minds</a>”, machines that operated faster than the speed of thought. And if the computer was a bicycle for the mind, then the plural form of computer, Internet, was a “<a href="https://www.eff.org/cyberspace-independence">new home of Mind</a>.” The Internet was a fantastic assemblage of all the world’s knowledge, and it was a bastion of freedom that would make time, space, and geopolitics irrelevant. Ignorance, authoritarianism, and scarcity would be relics of the meatspace past.</p>
<p>Things didn’t quite turn out that way. The magic disappeared and our optimism has since faded. Our websites are slow and insecure; our startups are creepy and unprofitable; our president Tweets hate speech; we don’t trust our social media apps, webcams, or voting machines. And in the era of coronavirus quarantining, we’re realizing just how inadequate the Internet turned out to be as a home of Mind. Where did it all go wrong?</p>
<figure><a href="https://blog.jse.li/software/bicycles-2000.jpg"><img srcset="/software/bicycles-2000.jpg 2000w, /software/bicycles-1000.jpg 1000w, /software/bicycles-800.jpg 800w" alt="hundreds of bicycles lie broken, heaped in rows"/></a><figcaption><span>SnvvSnvvSnvv/Shutterstock.com</span></figcaption></figure>
<h2 id="software-is-for-people">Software is for people</h2>
<p>Software is at once a field of study, an industry, a career, a process of production, and a process of consumption—and only then a body of computer code. It is impossible to separate software from the human and historical context that it is situated in. Code is always <em>addressed</em> to someone. As <em>Structure and Interpretation of Computer Programs</em> puts it, “programs must be written for people to read, and only incidentally for machines to execute” (Abelson et al. 1996). <strong>We do not write code for our computers</strong>, but rather we write it for humans to read and use. And even the purest, most theoretical and impractical computer science research has as its aim to provoke new patterns of thought in <em>human</em> readers and scholars—and these are formulated using the human-constructed tools of mathematics, language, and code.</p>
<p>As software engineers, we pride ourselves in writing “readable” or “clean” code, or code that “solves business problems”—synonyms for this property of <em>addressivity</em> that software seems to have. Perhaps the malware author knows this property best. Like any software, malware is addressed to people, and only incidentally for machines to execute. Whether a sample of malware steals money, hijacks social media accounts, or destabilizes governments, it operates in the human domain. The computer does not care about money, social media accounts, or governments; humans do. And when the malware author obfuscates their code, they do so with a human reader in mind. The computer does not care whether the code it executes is obfuscated; it only knows opcodes, clocks, and interrupts, and churns through them faithfully. Therefore, even malware—<em>especially</em> malware—whose code is deliberately made unreadable, is written with the intention of being read.</p>
<img src="https://blog.jse.li/software/obfuscated.png" alt="a screenshot of obfuscated javascript"/>
<h2 id="code-is-multivoiced">Code is multivoiced</h2>
<p>Soviet philosopher Mikhail Bakhtin wrote that “the single utterance, with all its individuality and creativity, can in no way be regarded as a <em>completely free combination</em> of forms of language … the word in language is half someone else’s” (Wertsch 1991, 58-59). Any code that we write, no matter how experimental or novel, owes a piece of its existence to someone else, and participates as a link in a <strong>chain of dialogue</strong>, one in reply to another. The malware author is in dialogue with the malware analyst. The software engineer is in dialogue with their teammates. The user of a piece of software is in dialogue with its creator. A web application is in dialogue with the language and framework it is written in, and its structure is mediated by the characteristics of TCP/IP and HTTP. And in the physical act of writing code, we are in dialogue with our computer and development environment.</p>

<p>Wertsch formulated Bakhtin’s notion of dialogues in terms of voices: “Who is doing the talking?,” he asks—“At least two voices” (1991, 63). While Wertsch and Bakhtin were concerned with human language, we can just as readily apply their insights to software: “the ambiguity of human language is present in code, which never fully escapes its status as human writing, even when machine-generated. We bring to code our excesses of language, and an ambiguity of semantics, as discerned by the human reader” (Temkin 2017). Whose voices do we hear when we experience code?</p>
<p>At the syntactic level, every keyword and language feature we use is <em>rented</em> from the creators of the language. These keywords and grammars are themselves often rented from a human language like English, and these voices too are present in our code. The JavaScript <code>if</code> rents meaning from the English “if,” which is itself rented from German, and in any case, the word does not belong to us, not fully—<em>the word in language is half someone else’s</em>. When we call programming languages, libraries, and frameworks “opinionated” or “<a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/">pits of despair/success</a>,” we really mean “how loud is the voice of the language in our code?” A <a href="https://news.ycombinator.com/item?id=13575322">comment</a> on the Go programming language by matt_wulfeck on Hacker News illuminates the intentional imbalance between the voice of the programmer and the voice of the language:</p>
<blockquote>
<p>Go takes away so much “individuality” of code. On most teams I’ve been on with Python and Java I can open up a file and immediate tell who wrote the library based on various style and other such. It’s a <em>lot</em> harder with Go and that’s a very good thing.</p>
</blockquote>
<p>Here we see how voices mediate our action—how does Go <strong>mediate</strong> the way we write and think about code? Jussi Pakkanen, creator of the Meson build system, called the mediating aspect of voices <em>shepherding:</em> “It’s not what programming languages do, it’s what they shepherd you to.” Shepherding is “an invisible property of a programming language and its ecosystem that drives people into solving problems in ways that are natural for the programming language itself rather than ways that are considered ‘better’ in some sense” (Pakkanen 2020). We internalize the voices of our social relations, and these voices mediate our action. Every time we dive into a codebase, speak with a mentor, take a course, or watch a conference talk, we are deliberately adding new voices to the little bag of voices in our mind. This is not purely a process of consumption: in internalizing voices, we form counter-words, mentally argue with them, and ventriloquize them through our own work—in a word, we engage in a dialogue.</p>
<p>Next time you settle down to read some code, listen carefully for the voices inside the code and the voices inside your mind, however faint they sound. I can hear the voice of a senior engineer from my last job every time I write a type definition.</p>
<h2 id="abstraction-and-labor">Abstraction and labor</h2>
<p>At a higher level, the patterns and strategies we use to structure our code, which we think of as independent of programming languages, such as algorithms, design patterns, architectures, and paradigms, are rented too. Some algorithms are named after famous computer scientists like Dijkstra, Kruskal, and Prim, and these clue us into the rich ensemble of voices speaking in our code. But at the same time, <strong>the process of naming obscures the multitude of <em>other</em> voices speaking through these algorithms</strong>. Dijkstra’s algorithm is a weighted breadth-first search that uses a priority queue—but the name alone would not tell you this, and in fact, the names “breadth-first search” and “priority queue” obscure still more voices. By attributing the entire history, the chains of dialogue, and the chorus of voices that speak in the algorithm, all to that single name <em>Dijkstra</em>—by seeing one where there are many—they are killed, and the signifier <em>Dijkstra</em> takes their place. This is the process of abstraction.</p>
<p>These obscured chains of dialogue are present in everything, from supply chains, to APIs, source code, and package managers. Run <code>git log</code> in a repository from work, or browse the commits of an open source project—try <a href="https://github.com/postgres/postgres/commits/master">Postgres</a> if you don’t have one handy. Read the commit messages, puzzle over the diffs, and marvel at the layers of sedimented history. Postgres has nearly 50,000 commits, one in reply to another, each representing hours or days of labor, and lifetimes of accumulated knowledge and experience. It is a recording surface for these dialogues, in which each commit is inscribed; and it is at the level of commits, changelists, and releases that we tame the continuous flow of development by cutting into, segmenting, and abstracting it into units that we can comprehend. <em>One voice at a time, please.</em> One spokesman <em>Dijkstra</em>, one mascot <em>Postgres</em> to hide the complexity.</p>
<p>Every piece of software that we interact with, every company, every project, every product—from your computer’s operating system, to the SaaS vendors your company relies on, the libraries you use, and the routines running on the microcontroller in your refrigerator, hides just as delightfully complicated of a history of production, and this is what brings all of software development together. Marx described this common substance “a mere congelation of homogeneous human labour, of labour power expended without regard to the mode of its expenditure. All that these things now tell us is, that human labour power has been expended in their production, that human labour is embodied in them. When looked at as crystals of this social substance, common to them all, they are—Values” (1867, 48).</p>
<h2 id="npm-is-not-the-problem">NPM is not the problem</h2>
<p>In 2016, a JavaScript package called left-pad <a href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">broke the Internet</a> for a day. The package consisted of eleven lines of code that padded strings to a specified length, turning strings like “5” into strings like “005.” Out of protest over a trademark dispute, left-pad’s creator Azer Koçulu deleted it from the NPM registry, wreaking havoc on an entire ecosystem of packages that depended on it, whether directly or indirectly through transitive dependencies to the <em>n<sup>th</sup></em> degree—and these were packages that powered thousands of websites around the world (Williams 2016).</p>
<figure>
  
    <a href="https://blog.jse.li/software/graph.png">
      <img src="https://blog.jse.li/software/graph.png"/>
    </a>
  
  
  <figcaption>
    <h4>A visualization of the dependency graph for the react-scripts NPM package. Each dot represents a package, and lines connect packages that depend on one another. One of the dots is left-pad; I don’t know which.</h4>
    
  </figcaption>
  
</figure>

<p>According to the discourse at the time, this was a lesson on the fragility of the webs of dependencies and abstractions that we had created, and it was a sign that the NPM ecosystem was fundamentally broken. We had built houses of cards—long chains of dialogue whose links could simply vanish—and all it took was a single developer and his eleven lines of code to tear them down. David Haney, meditating on the left-pad incident, asked in a <a href="https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/">blog post</a></p>
<blockquote>
<p>Have We Forgotten How To Program? […] I get the impression that the NPM ecosystem participants have created a penchant for micro-packages. Rather than write any functions or code, it seems that they prefer to depend on something that someone else has written</p>
</blockquote>
<p>But we know by now that we have <em>not</em> forgotten how to program: this is how we have always programmed. Everything we write is something that someone else has written; nothing belongs to us; all code is multi-voiced. These webs of dependencies have always existed, but perhaps no system had made the fact quite so obvious as NPM did. Where we see <em>one</em>—one app, one script, one package—the breakages of NPM remind us that there are many.</p>
<h2 id="software-is-not-creative">Software is not creative</h2>
<p><iframe width="1268" height="480" src="https://www.youtube.com/embed/V1eYniJ0Rnk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></p>
<p>Watch as a neural network, initialized from random chaos, trains itself to play Atari Breakout. Watch the tiny machines—the nodes of the network, their connections and conjunctions, break-flows and back-propagations—and watch them converge: at first random contingencies that, in a feedback loop, crystallize into structure. These are machines reproducing machines. These are tiny capitalists. “Universal history is the history of contingencies, and not the history of necessity. Ruptures and limits, and not continuity” (Deleuze &amp; Guattari 1983, 140).</p>
<p>But neural networks, and software in general, do not create <em>new</em> reality—they ingest data and reflect back a reality that is a regurgitation and reconfiguration of what they have already consumed. And this reality that these machines reflect back is <em>slightly wrong</em>. Recall the statistician’s aphorism “all models are wrong, but some are useful.” What happens when we rely on these models to produce new realities, and feed those slightly-wrong realities back into the machines again? What happens when we listen to Spotify’s <em>Discover Weekly</em> playlist week after week, “like” the posts that Facebook recommends to us, and scroll through TikTok after TikTok? I am guilty of all of these, and it would not be wrong to claim that my taste in music and sense of humor are mediated by this mutual recursion between the algorithms and the real world.</p>
<p>And that is exactly it: in the modern world, our social interactions, our devices, governments, and markets, are circulations and flows of the same realities under the same rules. Our software creates new problems—problems that we’ve never had before, like fake news, cyberbullying, and security vulnerabilities—and we patch them over with yet more layers of code. Software becomes quasi-cause of software. These are <strong>echoes of the same voices in a positive feedback loop</strong>, growing louder and less coherent with each cycle—garbage in, garbage out, a thousand times over.</p>


<h2 id="who-does-software-benefit">Who does software benefit?</h2>
<p>For many of us fortunate enough to stay home during the coronavirus outbreak, our only interface with the world outside our families and homes—the relays of connection between us, our families, communities and societies—have been filtered through our screens and earbuds. It is apparent now more than ever exactly what software does for us, and what kinds of inequalities it reinforces.</p>
<p>Through Instacart, Amazon Fresh, and other grocery delivery services, we can use an app to purchase a delivery driver’s body for an hour to expose themself to the virus on our behalf. Unsatisfied with even this, some developers have written scripts to instantly reserve the scarce delivery slots on these services.</p>
<p>One developer wrote to Vice’s <em>Motherboard</em> “I designed the bot for those who find it extremely inconvenient in these times to step out, or find it not safe for themselves to be outside. It is my contribution to help flatten the curve, I really hope this’ll help reduce the number of people going out” (Cox 2020). Is that right? Does a bot really reduce the number of people going out, or does it merely change the demographics of who gets to stay home, favoring those with the resources and technical skills to run a Python script and Selenium WebDriver? With a constant and limited number of delivery slots, Joseph Cox points out that these bots create “a tech divide between those who can use a bot to order their food and those who just have to keep trying during the pandemic” (2020).</p>
<p>Instacart bots are just the most recent reincarnation of a long tradition of using the speed of software to gain an edge against humans. In the 2000’s, when concert tickets first started to sell over the Internet, scalpers built bots to automatically purchase tickets to resell them at a higher price. And capitalism, in its infinite flexibility, adapted and welcomed this development with open arms and invisible hands, spawning companies like TicketMaster, which institutionalized and legitimized the practice. But Instacart and TicketMaster are mere symptoms of the problem. We saw the same patterns in the arms race of high-frequency trading. At first, the robots beat the humans. Next, <strong>the robots became part of the game</strong>, and the robots played against each other. The profits from high-frequency trading dried up, and yet using it became a necessity just to keep up.</p>
<p>These examples give us a decent idea of what software is good for. On its own, it never enables anything truly new, but rather changes the constant factors of speed and marginal cost, and raises the barrier for participation arbitrarily high. Once the software train begins to leave the station, we have no choice but to jump and hang on, lest we get run over or left behind—and we are not sure which is worse. Max Weber, studying the development of capitalism, identified this secularizing, spiralling effect:</p>
<blockquote>
<p>The Puritan <em>wanted</em> to be a person with a vocational calling; we <em>must</em> be. For to the extent that asceticism moved out of the monastic cell and was carried over into the life of work in a vocational calling, and then commenced to rule over this-worldly morality, it helped to do its part to build the mighty cosmos of the modern economic order. This economy is bound to the technical and economic conditions of mechanized, machine-based production.</p>
</blockquote>
<h2 id="a-false-start-startups">A false start: startups</h2>
<p>Startups love to save the world, but look at the state of the world now—is this what it’s like to be saved? Is the world even a <em>little bit</em> better because of startups like Instagram, Uber, and Peloton? Startups are spaces of remarkable innovation, and they are experts at channeling the multivoicedness of code—just look at the network of voices that GitLab channels (visualized below). But under capitalism, these voices are distorted and constrained, and they cry “growth, growth!” as venture capitalists and founders demand user acquisition, market share, and revenue—in a word, they demand access to capitalist accumulation.</p>
<figure>
  
    <a href="https://blog.jse.li/software/gitlab.png">
      <img src="https://blog.jse.li/software/gitlab.png"/>
    </a>
  
  
  <figcaption>
    <h4>Systems diagram published by GitLab</h4>
    
  </figcaption>
  
</figure>

<p>The startup founder, no matter how much they claim to love code, love humanity, or love the thrill of the hustle (and they may even believe themself when they say it), loves the growth of capital most of all. The tech founder is a capitalist proper, but capital does not love them back; capital cannot love at all, and the odds are stacked against our hero capitalist. “The larger capitals beat the smaller … It always ends in the ruin of many small capitalists, whose capitals partly pass into the hands of their conquerors, partly vanish” (Marx 1867, 621). Capital accumulates and concentrates, and in the midst of frothy competition, the startup either dies or gets acquired by Facebook or Google, leaving nothing behind but a bullet point on LinkedIn and a blog post signifying an <a href="https://ourincrediblejourney.tumblr.com/">incredible journey</a>. So much for changing the world.</p>
<h2 id="what-is-to-be-done">What is to be done?</h2>
<p>To revisit that ambitious question we set out to answer, <em>where did it all go wrong</em>? What got us into this mess, this tool-assisted speedrun of accumulation and exploitation? The trick is that we have not been studying software on its own—we’ve established that computers and computer code are veritably <em>saturated</em> with human touch, human voices, and human thought. Software cannot be divorced from the human structures that create it, and for us, that structure is capitalism. To quote Godfrey Reggio, director of <em>Koyaanisqatsi</em> (1982), “it’s not the effect <em>of</em>, it’s that everything exists <em>within</em>. It’s not that we <em>use</em> technology, we <em>live</em> technology. Technology has become as ubiquitous as the air we breathe, so we are no longer conscious of its presence” (<em>Essence of Life</em> 2002).</p>
<p><em>Where did it all go wrong?</em> At some point, capital became the answer to every question—what to produce, how to produce, for whom to produce, and <em>why</em>. When software, that ultimate solution in search of a problem, found the questions answered only by <em>capital</em>, we lost our way, caught in capital’s snare.</p>
<p><strong>Q</strong>: What does software do?</p>
<p><strong>A</strong>: It produces and reproduces capital.</p>
<p><strong>Q</strong>: Who does software benefit?</p>
<p><strong>A</strong>: People who own capital.</p>
<p><strong>Q</strong>: What is software?</p>
<p><strong>A</strong>: Capital.</p>
<p><strong>A</strong>: Capital.</p>
<p><strong>A</strong>: Capital.</p>
<p><strong>A</strong>: Capital.</p>
<p>But we can break this pattern; we can find our own answers to those questions, and if it’s up to us, the answer does not need to be that answer we’ve been taught, <em>capital</em>. Software is a tool with revolutionary potential, but that is the extent of what it can give us. “Science demonstrates by its very method that the <em>means</em> that it constantly elaborates do no more than reproduce, on the outside, an interplay of forces by themselves <em>without aim or end</em> whose combinations obtain such and such a result” (Deleuze &amp; Guattari 1983, 368).</p>
<p>So, what are the aims and ends that we should direct our software toward? What are the answers to those economic questions, if not capital—or better yet, what questions should we be asking, if not economic?</p>
<p>I don’t know :)</p>



<h2 id="references">References</h2>
<p>Abelson, Harold, Gerald Jay. Sussman, and Julie Sussman. <em>Structure and Interpretation of Computer Programs</em>. Cambridge, MA: MIT Press, 1996.</p>
<p>Cox, Joseph. “People Are Making Bots to Snatch Whole Foods Delivery Order Time Slots.” Vice. Vice Media Group, April 21, 2020. <a href="https://www.vice.com/en_us/article/n7jaw7/amazon-fresh-whole-foods-delivery-time-slot-bots">https://www.vice.com/en_us/article/n7jaw7/amazon-fresh-whole-foods-delivery-time-slot-bots</a>.</p>
<p>Deleuze, Gilles, and Félix Guattari. <em>Anti-Oedipus: Capitalism and Schizophrenia</em>. Translated by Mark Seem, Robert Hurley, and Helen R. Lane, 1983.</p>
<p><em>Essence of Life</em>. MGM Home Entertainment Inc., 2002. <a href="https://www.youtube.com/watch?v=8oiK4vPLtVw&amp;t=581">https://www.youtube.com/watch?v=8oiK4vPLtVw&amp;t=581</a>.</p>
<p>Haney, David. “NPM &amp; Left-Pad: Have We Forgotten How To Program?” David Haney, March 23, 2016. <a href="https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/">https://www.davidhaney.io/npm-left-pad-have-we-forgotten-how-to-program/</a>.</p>
<p>Marx, Karl. <em>Capital: a Critique of Political Economy</em>. Translated by Ben Fowkes, 1867.</p>
<p>Pakkanen, Jussi. “It’s Not What Programming Languages Do, It’s What They Shepherd You To.” Nibble Stew, March 6, 2020. <a href="https://nibblestew.blogspot.com/2020/03/its-not-what-programming-languages-do.html">https://nibblestew.blogspot.com/2020/03/its-not-what-programming-languages-do.html</a>.</p>
<p>Temkin, Daniel. “Sentences on Code Art.” esoteric.codes, December 27, 2017. <a href="https://esoteric.codes/blog/sentences-on-code-art">https://esoteric.codes/blog/sentences-on-code-art</a>.</p>
<p>Weber, Max. <em>The Protestant Ethic and the Spirit of Capitalism</em>. Translated by Stephen Kalberg, 1920.</p>
<p>Wertsch, James V. <em>Voices of the Mind: A Sociocultural Approach to Mediated Action</em>. Cambridge University Press, 1991.</p>
<p>Williams, Chris. “How One Developer Just Broke Node, Babel and Thousands of Projects in 11 Lines of JavaScript.” The Register. Situation Publishing, March 23, 2016. <a href="https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/">https://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/</a>.</p>



    </section>
  </article>
</div></div>
  </body>
</html>
