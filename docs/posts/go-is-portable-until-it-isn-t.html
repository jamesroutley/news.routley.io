<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simpleobservability.com/blog/go-portable-until-isnt">Original</a>
    <h1>Go is portable, until it isn&#39;t</h1>
    
    <div id="readability-page-1" class="page"><div><article id="post-content"><p>We thought Go would give us a single, portable agent binary for every Linux distro. Turns out… not exactly. But also, kind of yes.</p><p>This post kicks off a series about the traps we fell into while building a cross-platform server monitoring agent.</p><p>First, some <a href="https://pages.cs.wisc.edu/~remzi/Naur.pdf" rel="nofollow noopener noreferrer external" target="_blank">theory</a>. <code>simob</code> is our open source server monitoring agent that powers the Simple Observability platform. We like to think of it as a passive sensor, not a long running program or daemon. Because in the real world a passive sensor does not come with a long list of requirements. It’s small, self contained and can fit inside the existing system. That is the same goal we have for simob: a lightweight standalone binary with no requisites or external dependencies.</p><p>The same idea also applies to how we wanted to ship it. We wanted a project that you can compile from source on your development machine and run anywhere across your infrastructure. No complicated pipelines. No third party build services. Just a simple build that produces a portable binary.</p><h2>Why we chose Go</h2><p>In the observability world, if you&#39;re building an agent for metrics and logs, you&#39;re probably writing it in Go. <a href="https://github.com/grafana/loki" rel="nofollow noopener noreferrer external" target="_blank">Promtail</a>, <a href="https://github.com/influxdata/telegraf" rel="nofollow noopener noreferrer external" target="_blank">Telegraf</a>, <a href="https://github.com/grafana/alloy" rel="nofollow noopener noreferrer external" target="_blank">Grafana Alloy</a> and many others are all written in Go.</p><p>And there are good reasons for that. First it’s compiled. A whole class of runtime errors gets caught before you even run the binary.</p><p>Then there is the garbage collector. For something that’s constantly ingesting and forwarding data, not having to manage memory is a massive advantage.</p><p>The Goroutines are also an excellent abstraction. We knew our agent would need to manage a lot of parallel task: tailing log files, reading from input plugins, and sending data upstream. We could write clear, sequential-looking code for each task and let the runtime handle the concurrency</p><p>And of course, because we thought we could compile it for any platform. &#34;Just set <code>GOOS</code> and <code>GOARCH</code> at compile time and you&#39;re done&#34;</p><h2>The simple stuff</h2><p>Most of the early work was simple. The Go ecosystem is more than a decade old and very rich. For core metrics collection we relied on <a href="https://pkg.go.dev/github.com/shirou/gopsutil/v4" rel="nofollow noopener noreferrer external" target="_blank">gopsutil,</a> a Go port of Python’s <a href="https://github.com/giampaolo/psutil" rel="nofollow noopener noreferrer external" target="_blank">psutil</a>. It gives you CPU, memory, network and disk metrics with a pretty clean API. It supports a wide range of operating systems and CPU architectures, removing the need for system specific code that we would otherwise have to write ourselves.</p><h2>When it starts getting hard, the case of journal collector</h2><p>Things became more complex once users asked for systemd journal log support. Journal logs are not stored in plain text. They use a binary format and live in <code>/var/log/journal</code> or <code>/run/log/journal</code> (depending on whether persistent logging is enabled). The format is structured, indexed and can include inline compression.</p><p>We had two options. The first was to write our own parser. The file format is <a href="https://systemd.io/JOURNAL_FILE_FORMAT/" rel="nofollow noopener noreferrer external" target="_blank">documented</a> and the systemd source is <a href="https://github.com/systemd/systemd/tree/main/src/libsystemd/sd-journal" rel="nofollow noopener noreferrer external" target="_blank">available</a></p><p>Tools like <a href="https://kaitai.io/" rel="nofollow noopener noreferrer external" target="_blank">Kaitai Struct</a> could help us generate the parser code. It was not impossible. But it required time and careful reading of both the spec and the real implementation.</p><div><p>&#34;Note that the actual implementation in the systemd codebase is the only ultimately authoritative description of the format, so if this document and the code disagree, the code is right&#34;</p><p>— A comforting note from the systemd journal documentation. Nothing says &#34;stable, well-documented binary format&#34; like the docs telling you they might be wrong.</p></div><p>Our real concern was compatibility. We wanted a binary that works everywhere. That means support for past, current and future version of the journal format. We did not want to spend time maintaining a backward compatible parser or doing code archaeology. So this option was discarded.</p><p>The second option was to use the <a href="https://www.freedesktop.org/software/systemd/man/latest/sd-journal.html" rel="nofollow noopener noreferrer external" target="_blank">C API</a> provided by systemd for reading the journal. A <a href="https://pkg.go.dev/github.com/coreos/go-systemd/v22" rel="nofollow noopener noreferrer external" target="_blank">Go wrapper</a> already exists. It exposes the journald C API directly. On paper this looked like the right solution, so this is what we chose.</p><p>Once we started using it, Go added some constraints. Because the wrapper calls the C API directly, the systemd library is dynamically linked. It must be present on the target machine at runtime. That part is fine. A machine without systemd has no journal logs to collect anyway. It does, however, introduce new build problems.</p><p>The first problem is that the build breaks on non systemd systems such as macOS. Since libsystemd is not available, you cannot build from or cross compile to Linux. You must build from a Linux system.</p><p>This affects both release builds and development builds. You cannot even run go run locally on a non systemd machine because the compiler cannot find the systemd library. Thankfully Go has build tags to tell the compiler what to include on each platform.</p><div><p>This line instructs the Go compiler to only build this file on Linux systems</p></div><p>It does add some code bloat, since a stub file is required for other systems so the package still compiles.</p><div><div><pre><code>
    // myfunc_linux.go
    //go:build linux

    package mypkg

    func MyFunc() string {
      // real Linux implementation
    }

    // myfunc_stub.go
    //go:build !linux

    package mypkg

    func MyFunc() string {
      // &#34;stub for other systems&#34;
    }
            </code></pre></div><p>Separate files with build tags let you provide a real implementation for Linux while keeping a stub so the package still compiles elsewhere.</p></div><p>The second problem is that libsystemd differs between architectures. You need an amd64 version to build an amd64 binary and an arm64 version to build an arm64 binary. You cannot simply set <code>GOARCH</code> to produce every target from one worker. Each architecture build must run on a worker that has the matching libsystemd.</p><h2>The glibc problem</h2><p>There is another issue that shows up and is much harder to spot at first.</p><p>Go has a build flag called <code>CGO_ENABLED</code>. When it is enabled, the Go compiler links any C dependencies dynamically. This includes explicit C wrappers, like the <code>sdjournal</code> package, but also indirect calls inside the Go standard library. A common example is DNS resolution, which relies on glibc on Linux systems. With <code>CGO_ENABLED</code> set to 1, the final binary links to libc at runtime.</p><p>The default value depends on the environment. It is enabled by default when building natively on a system that supports cgo. It is disabled when cross compiling or when the C compiler is not available on the <code>PATH</code>. These defaults usually make sense. You generally do not want to enable cgo for cross compilation or for targets where glibc does not exist, such as Windows.</p><p>The problem is that a dynamically linked libc does not work on all Linux systems. Some Linux distributions do not use glibc. Mainly Alpine Linux, that uses musl. This means a binary built for a Linux system with <code>CGO_ENABLED</code> will work on Ubuntu or Debian but will fail at runtime on Alpine.</p><div><div><pre><code>
  /bin/sh: ./simob: Permission denied
            </code></pre></div><p>Don&#39;t get fooled by the &#34;Permission denied&#34;. On Alpine and other musl systems, this error, when permissions are clearly set, almost always means the kernel can&#39;t find the required glibc dynamic linker.</p></div><p>This forces you to build a separate version of the agent for non glibc systems.</p><h2>So, is Go the problem?</h2><p>Not really. Go behaved exactly as documented. We were the ones assuming that &#34;portable&#34; meant &#34;effortless&#34;. Once we pulled in low-level C libraries and tarted targeting a mix of glibc and non-glibc systems, the simple story fell apart. None of it is dramatic, just a set of constraints you only notice once you trip over them.</p><p>Our initial idea of building everything on a laptop and shipping the same binary everywhere did not survive for long. We now rely on GitHub Actions with the right runners for each architecture. It is more moving parts than we wanted, but it works and it stays out of the critical path.</p><p>Local builds are still possible with containers or emulation, although a bit more clunky than we hoped.</p><p>In the end the build pipeline is more complicated than we imagined, but the binaries we ship remain small and self-contained. That was the original goal, and we managed to keep that part intact.</p></article></div></div>
  </body>
</html>
