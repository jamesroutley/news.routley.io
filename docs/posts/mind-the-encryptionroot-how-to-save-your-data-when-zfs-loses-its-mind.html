<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sambowman.tech/blog/posts/mind-the-encryptionroot-how-to-save-your-data-when-zfs-loses-its-mind/">Original</a>
    <h1>Mind the encryptionroot: How to save your data when ZFS loses its mind</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        <p>
While <a href="https://en.wikipedia.org/wiki/ZFS">ZFS</a> has a well-earned reputation for data integrity and reliability, OpenZFS native encryption has some <em>incredibly</em> <a href="https://github.com/openzfs/openzfs-docs/issues/494">sharp edges</a> that will cut you if you don&#39;t know where to be careful. Unfortunately, I learned this the hard way, standing in a pool of my own blood and tears after thoroughly lacerating myself. I very nearly permanently lost 8.5 TiB of data after performing what should&#39;ve been a series of simple, routine ZFS operations but resulted in an undecryptable dataset. Time has healed the wound enough that I am no longer filled with anguish just thinking about it, so I will now share my experience in the hope that you may learn from my mistakes. Together, we&#39;ll go over the unfortunate series of events that led to this happening and how it could&#39;ve been avoided, learn how ZFS actually works under the hood, use our newfound knowledge to debug and reproduce the issue at hand, and finally compile a modified version of ZFS to repair the corrupted state and rescue our precious data. This is the postmortem of that terrible, horrible, no good, very bad week…</p>
<hr/>


<hr/>
<p>
<strong>Note:</strong> The issue covered in this postmortem only applies to OpenZFS native encryption. Oracle ZFS has its own encryption scheme which is different and, as far as I can tell, should not be vulnerable to this particular failure mode, though I have not personally tested it. Thank you to <a href="https://old.reddit.com/r/zfs/comments/1ntwrjx/mind_the_encryptionroot_how_to_save_your_data/ngyp0wx/">u/HobartTasmania</a> for pointing this out!</p>
<div id="outline-container-headline-1">
<h2 id="headline-1">
Part 1: An unfortunate series of events
</h2>
<div id="outline-text-headline-1">
<div id="outline-container-headline-2">
<h3 id="headline-2">
The status quo
</h3>
<div id="outline-text-headline-2">
<p>
In the beginning, there were two ZFS pools: <code>old</code> and <code>new</code> (names changed for clarity). Each pool was hosted on an instance of TrueNAS CORE 13.0-U5.1 located at two different sites about an hour&#39;s drive apart with poor Internet connectivity between them. For this reason, a third pool <a href="https://en.wikipedia.org/wiki/Sneakernet"><code>sneakernet</code></a> was periodically moved between the two sites and used to exchange snapshots of <code>old</code> and <code>new</code> datasets for backup purposes. ZFS dataset <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-snapshot.8.html">snapshots</a> would be indirectly relayed from <code>old</code> to <code>new</code> (and vice versa) using <code>sneakernet</code> as an intermediate ZFS <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-send.8.html">send</a>/<a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-recv.8.html">recv</a> source/destination (e.g. <code>old/foo@2023-06-01</code> -&gt; <code>sneakernet/old/foo@2023-06-01</code> -&gt; <code>new/old/foo@2023-06-01</code>).</p>
<p>
The <code>new</code> pool was natively encrypted from the very beginning. When ZFS snapshots were sent from <code>new</code> to <code>sneakernet/new</code> to <code>old/new</code>, they were sent <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-send.8.html#w">raw</a>, meaning that blocks were copied unmodified in their encrypted form. To decrypt and mount them on <code>sneakernet</code> or <code>old</code>, you would need to first load <code>new</code>&#39;s <a href="https://openzfs.github.io/openzfs-docs/man/master/7/zfsprops.7.html#keyformat">hex</a> encryption key, which is stored in TrueNAS&#39;s SQLite database.</p>
<p>
The <code>old</code> pool, on the other hand, was created before the advent of native encryption and was unencrypted for the first part of its life. Because it&#39;s desirable to encrypt data at rest, an encrypted dataset <code>sneakernet/old</code> was created for <code>old</code> using a <a href="https://openzfs.github.io/openzfs-docs/man/master/7/zfsprops.7.html#keyformat">passphrase</a> encryption key when <code>sneakernet</code> was set up. Unencrypted snapshots were sent non-raw from <code>old</code> to <code>sneakernet/old</code>, where they were encrypted, and then sent raw from <code>sneakernet/old</code> to <code>new/old</code>. To decrypt and mount them on <code>sneakernet</code> or <code>new</code>, you would need to first load <code>sneakernet</code>&#39;s passphrase encryption key.</p>
<p>
This was all tested thoroughly and snapshots were proven to be readable at each point on every pool.</p>
</div>
</div>
<div id="outline-container-headline-3">
<h3 id="headline-3">
Encrypting the old pool
</h3>
<div id="outline-text-headline-3">
<p>
Now that we had encrypted snapshots of <code>old</code> on <code>sneakernet/old</code>, we wanted to encrypt <code>old</code> itself. To do this, I simply took <code>old</code> offline during a maintenance window to prevent new writes, took snapshots of all datasets, sent them to <code>sneakernet/old</code>, and then sent the raw encrypted snapshots from <code>sneakernet/old</code> back to <code>old/encrypted</code>. Once I verified each dataset had been encrypted successfully, I destroyed the unencrypted dataset, updated the mount point of the encrypted dataset to that of the late unencrypted dataset, and then moved on to the next dataset. After all datasets were migrated, I used <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-change-key.8.html"><code>zfs change-key -i</code></a> to make all child datasets inherit from the new <code>old/encrypted</code> encryption root, and then changed the key of the encryption root from a passphrase to a hex key, since TrueNAS only supported automatically unlocking datasets with hex encryption keys. Finally, I issued a <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zpool-initialize.8.html"><code>zpool initialize</code></a> to overwrite all the unencrypted blocks which were now in unallocated space.</p>
<p>
<strong>Spoiler Alert:</strong> It may not be immediately obvious why, but changing the encryption key on <code>old/encryption</code> silently broke backups of <code>old</code> datasets. Snapshots would still send and recv successfully, but were no longer decryptable or mountable. Since the encryption key is not normally loaded, and we only load it when periodically testing the backups, we would not realize until it was too late.</p>
<p>
<strong>Lesson: Test backups continuously so you get immediate feedback when they break.</strong></p>
</div>
</div>
<div id="outline-container-headline-4">
<h3 id="headline-4">
Decommissioning the old pool
</h3>
<div id="outline-text-headline-4">
<p>
Later, the <code>old</code> pool was moved to the same site as the <code>new</code> pool, so we wanted to fully decommission <code>old</code> and migrate all its datasets to <code>new</code>. I began going about this in a similar way. I took <code>old</code> offline to prevent new writes, sent snapshots to <code>sneakernet/old</code>, and then to <code>new/old</code>. It was at this point that I made a very unfortunate mistake: I accidentally destroyed one dataset <code>old/encrypted/foo</code> <em>before</em> verifying the files were readable on <code>new/old/foo</code>, and I would soon realize that they were not.</p>
<p>
<strong>Lesson: Wait to make all destructive changes together at the very end instead of interspersed where they could accidentally be performed in the wrong order.</strong></p>
</div>
</div>
<div id="outline-container-headline-5">
<h3 id="headline-5">
The realization
</h3>
<div id="outline-text-headline-5">
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>[</span>sam@newnas ~<span>]</span>$ <span>DATASET</span><span>=</span>foo<span>;</span> <span>[[</span> <span>$(</span>ssh sam@oldnas zfs list -H -o guid old/encrypted/<span>${</span><span>DATASET</span><span>}</span>@decomm<span>)</span> <span>=</span> <span>$(</span>zfs list -H -o guid sneakernet/old/<span>${</span><span>DATASET</span><span>}</span>@decomm<span>)</span> <span>]]</span> <span>&amp;&amp;</span> <span>echo</span> <span>&#34;GUIDs match&#34;</span> <span>||</span> <span>echo</span> <span>&#34;GUIDs DO NOT MATCH&#34;</span>
</span></span><span><span>GUIDs match
</span></span><span><span><span>[</span>sam@newnas ~<span>]</span>$ <span>DATASET</span><span>=</span>foo<span>;</span> <span>[[</span> <span>$(</span>zfs list -H -o guid sneakernet/old/<span>${</span><span>DATASET</span><span>}</span>@decomm<span>)</span> <span>=</span> <span>$(</span>zfs list -H -o guid new/old/<span>${</span><span>DATASET</span><span>}</span>@decomm<span>)</span> <span>]]</span> <span>&amp;&amp;</span> <span>echo</span> <span>&#34;GUIDs match&#34;</span> <span>||</span> <span>echo</span> <span>&#34;GUIDs DO NOT MATCH&#34;</span>
</span></span><span><span>GUIDs match
</span></span><span><span>
</span></span><span><span><span>[</span>sam@oldnas ~<span>]</span>$ sudo zfs destroy -r old/encrypted/foo
</span></span><span><span>
</span></span><span><span><span>[</span>sam@newnas ~<span>]</span>$ ls /mnt/new/old/foo
</span></span><span><span><span>[</span>sam@newnas ~<span>]</span>$ ls -a /mnt/new/old/foo
</span></span><span><span>. ..
</span></span><span><span><span>[</span>sam@newnas ~<span>]</span>$ zfs list -o name,mounted new/old/foo
</span></span><span><span>NAME         MOUNTED
</span></span><span><span>new/old/foo  no
</span></span><span><span><span>[</span>sam@newnas ~<span>]</span>$ sudo zfs mount new/old/foo
</span></span><span><span>cannot mount <span>&#39;new/old/foo&#39;</span>: Permission denied</span></span></code></pre></div>
</div>
<p>
What do you mean, permission denied? I am root!</p>
<p>
Crap, I already destroyed <code>old/encrypted/foo</code>. This is not good, but I can still restore it from the remaining copy on <code>sneakernet/old/foo</code>.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span><span>[</span>sam@newnas ~<span>]</span>$ sudo zfs load-key sneakernet/old
</span></span><span><span>Enter passphrase <span>for</span> <span>&#39;sneakernet/old&#39;</span>:
</span></span><span><span><span>[</span>sam@newnas ~<span>]</span>$ sudo zfs mount sneakernet/old/foo
</span></span><span><span>cannot mount <span>&#39;sneakernet/old/foo&#39;</span>: Permission denied</span></span></code></pre></div>
</div>
<p>
Oh no, <code>sneakernet/old</code> is broken too. This is <em>very not good</em>!</p>
<p>
In an act of desperation, I tried rebooting the machine, but it didn&#39;t change a thing.</p>
<p>
It is at this point that I realized:</p>
<ol>
<li>Something has gone terribly wrong to prevent datasets on both <code>sneakernet/old</code> and <code>new/old</code> from mounting.</li>
<li>Whatever it is, it&#39;s not likely going to be easy to diagnose or fix.</li>
<li>There&#39;s a very real possibility the data might be gone forever.</li>
</ol>
<p>I found myself in a hole and I wanted to stop digging. Fortunately, uptime was no longer critical for the <code>old</code> datasets after the relocation, so I could afford to step away from the keyboard, collect my thoughts, and avoid making the situation any worse that it already was.</p>
<hr/>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6">
<h2 id="headline-6">
Part 2: Debugging the issue
</h2>
<div id="outline-text-headline-6">
<p>
Once the worst of the overwhelming, visceral feelings that come with the realization that you may have just caused permanent data loss had subsided, I started to work the incident and try to figure out why the backups aren&#39;t mounting.</p>
<p>
As a precaution, I first <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zpool-export.8.html">exported</a> the <code>old</code> pool and took a forensic image of every disk in the pool. ZFS is a copy-on-write filesystem, so even though the dataset had been destroyed, most of the data was probably still on disk, just completely inaccessible with the normal ZFS tooling. In the worst case scenario, I may have had to try to forensically reconstruct the dataset from what was left on disk, and I didn&#39;t want to risk causing any more damage than I already had. Fortunately, I never had to use the disk images, but they still served as a valuable safety net while debugging and repairing.</p>
<p>
Next, I realized that if we are to have any chance of debugging and fixing this issue, I need to learn how ZFS actually works.</p>
<div id="outline-container-headline-7">
<h3 id="headline-7">
Learning how ZFS actually works
</h3>
<div id="outline-text-headline-7">
<p>
I unfortunately did not keep track of every resource I consumed, but in addition to reading the <a href="https://github.com/openzfs/zfs">source</a> and <a href="https://openzfs.github.io/openzfs-docs/">docs</a>, I found these talks by Jeff Bonwick, Bill Moore, and Matt Ahrens (the original creators of ZFS) to be particularly helpful in understanding the design and implementation of ZFS:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=NRoUC9P1PmA">ZFS: The Last Word in File Systems Part 1</a></li>
<li><a href="https://www.youtube.com/watch?v=TwCXVp_u86o">ZFS: The Last Word in File Systems Part 2</a></li>
<li><a href="https://www.youtube.com/watch?v=ybjdAEUfXzw">ZFS: The Last Word in File Systems Part 3</a></li>
<li><a href="https://www.youtube.com/watch?v=NXg86uBDSqI">How ZFS Snapshots Really Work</a></li>
</ul>
<p>I <em>highly</em> recommend watching them all despite their age and somewhat poor recording quality, but will summarize the relevant information for those who don&#39;t have 3 hours to spare.</p>
<p>
ZFS is a <a href="https://en.wikipedia.org/wiki/Copy-on-write#In_computer_storage">copy-on-write</a> filesystem, which means that it does not overwrite blocks in place when a write is requested. Instead, the updated contents are written to a newly allocated block, and the old block is freed, which keeps the filesystem consistent if a write is interrupted. All blocks of both data and metadata are arranged in a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle tree</a> structure where each block pointer contains a checksum of the child block, which allows ZFS to detect both block corruption and misdirected/phantom reads/writes. This means that any write will cause the block&#39;s checksum to change, which will then cause the parent block&#39;s checksum to change (since the parent block includes the block pointer which includes checksum of the child block that changed), and so on, all the way up to the root of the tree which ZFS calls an uberblock.</p>
<p>
<img src="https://blog.veitheller.de/zfs_1.png" alt="zfs_1.png" title="zfs_1.png"/></p>
<p>
Uberblocks are written atomically, and because of the Merkle tree structure, they always represent a consistent snapshot of the entire filesystem at a point in time. Writes are batched together into <a href="https://ahl.dtrace.org/2012/12/13/zfs-fundamentals-transaction-groups/">transaction groups</a> identified by a monotonically increasing counter, and each transaction group when synced to disk produces a new uberblock and associated filesystem tree. Taking a snapshot is then as simple as saving an uberblock and not freeing any of the blocks it points to.</p>
<p>
<img src="https://blog.veitheller.de/zfs_2.png" alt="zfs_2.png" title="zfs_2.png"/></p>
<p>
In addition to the checksum, each block pointer also contains the transaction group id in which the child block was written, which is called the block&#39;s birth time or creation time. ZFS uses birth times to determine which blocks have been written before or after a snapshot. Any blocks with a birth time less than or equal to the snapshot&#39;s birth time, must have been written before the snapshot was taken, and conversely, any blocks with a birth time greater than the snapshot&#39;s birth time must have been written after the snapshot was taken.</p>
<p>
<img src="https://blog.veitheller.de/zfs_3.png" alt="zfs_3.png" title="zfs_3.png"/></p>
<p>
One application of birth times is to generate incremental send streams between two snapshots. ZFS walks the tree but only needs to include blocks where the birth time is both greater than the first snapshot and less than or equal to the second snapshot. In fact, you don&#39;t even need to keep the data of the first snapshot around—you can create a <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-bookmark.8.html">bookmark</a> which saves the snapshot&#39;s transaction id (but none of the data blocks), delete the snapshot to free its data, and then use the bookmark as the source to generate the same incremental send stream.</p>
<p>
<strong>Spoiler Alert:</strong> <a href="https://en.wikipedia.org/wiki/Chekhov%27s_gun">Chekhov&#39;s</a> bookmark will become relevant later.</p>
</div>
</div>
<div id="outline-container-headline-8">
<h3 id="headline-8">
Learning how ZFS native encryption actually works
</h3>
<div id="outline-text-headline-8">
<p>
ZFS native encryption is a relatively new feature, which was first released in <a href="https://github.com/openzfs/zfs/releases/tag/zfs-0.8.0">OpenZFS 0.8.0</a> (2019) and subsequently made it into <a href="https://www.freebsd.org/releases/13.0R/relnotes/">FreeBSD 13.0</a> (2021) when OpenZFS was adopted.</p>
<p>
In addition to the <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-load-key.8.html#Encryption">docs</a>, I found this 2016 talk on <a href="https://www.youtube.com/watch?v=frnLiXclAMo">ZFS Native Encryption</a> by Tom Caputi (the original author of native encryption) to be helpful in understanding its design and implementation. Again, I will summarize the relevant information.</p>
<p>
ZFS native encryption works by encrypting dataset blocks with an symmetric authenticated encryption cipher suite (AES-256-GCM by default). To use native encryption, you must create a new dataset with <code>-o encryption=on</code> which generates a unique master key for the dataset. The dataset&#39;s master key is then used to derive block data encryption keys with a salted HKDF.</p>
<p>
<img src="https://blog.veitheller.de/zfs_4.png" alt="zfs_4.png" title="zfs_4.png"/></p>
<p>
The master key can&#39;t be changed, so it is encrypted with a wrapping key which can be changed. The wrapping key is provided by the user with <code>zfs load-key</code> and can be changed with <code>zfs change-key</code> which re-encrypts the same master key with a new wrapping key.</p>
<p>
<img src="https://blog.veitheller.de/zfs_5.png" alt="zfs_5.png" title="zfs_5.png"/></p>
<p>
The encrypted master keys are stored in each dataset since each dataset has its own master key, but the wrapping key parameters are stored on what is called the encryption root dataset. The encryption root may be the same encrypted dataset, or it may be a parent of the encrypted dataset. When a child encrypted dataset inherits from a parent encryption root, the encryption root&#39;s wrapping key is used to decrypt the child dataset&#39;s master key. This is how one key can be used to unlock a parent encryption root dataset and all child encrypted datasets that inherit from it at the same time instead of having to load a key for every single encrypted dataset.</p>
<p>
In our case, <code>new</code>, <code>sneakernet/new</code>, <code>sneakernet/old</code>, and <code>old/encrypted</code> are the encryption roots, and all child encrypted datasets inherit from them.</p>
</div>
</div>
<div id="outline-container-headline-9">
<h3 id="headline-9">
Forming a hypothesis
</h3>
<div id="outline-text-headline-9">
<p>
At this point, we now know enough to form a hypothesis as to what may have happened. Feel free to pause here and try to figure it out on your own.</p>
<p>
Recall that <code>sneakernet/old</code> was created using a passphrase encryption key, and <code>old/encrypted</code> was created by raw sending <code>sneakernet/old</code>, so it initially used the same passphrase derived wrapping encryption key. When the <code>old/encrypted</code> encryption key was changed from a passphrase to a hex key, ZFS must have changed the wrapping key parameters on the <code>old/encrypted</code> encryption root and re-encrypted all child encrypted dataset master keys with the new hex wrapping key. Crucially, a new snapshot of <code>old/encrypted</code> was never taken and sent to <code>sneakernet/old</code> because it ostensibly didn&#39;t contain any data and was just a container for the child datasets.</p>
<p>
<strong>Hypothesis:</strong> When subsequent snapshots were sent from <code>old</code> to <code>sneakernet</code>, the master keys of the child encrypted datasets were updated to be encrypted with the new hex wrapping key, but the <code>sneakernet/old</code> encryption root was never updated with the new hex wrapping key parameters because a new snapshot was never sent. Therefore, when we load the key for <code>sneakernet/old</code>, ZFS asks for the old passphrase, not a hex key, and when we try to mount <code>sneakernet/old/foo</code>, it tries and fails to decrypt its master key with the old passphrase wrapping key instead of the new hex wrapping key.</p>
<p>
If correct, this would explain the behavior we&#39;re seeing. To test this hypothesis, let&#39;s try to reproduce the issue in a test environment.</p>
</div>
</div>
<div id="outline-container-headline-10">
<h3 id="headline-10">
Creating a test environment
</h3>
<div id="outline-text-headline-10">
<p>
TrueNAS CORE 13.0-U5.1 is based on FreeBSD 13.1, despite the different minor version numbers, so we&#39;ll create a FreeBSD 13.1 VM to test in. Make sure to include the system source tree and install on UFS so that we can build OpenZFS and reload the ZFS kernel module without rebooting.</p>
<p>
TrueNAS CORE 13.0-U5.1 uses ZFS 2.1.11, so we&#39;ll want to build the same version from source for consistency. I started by reading the <a href="https://openzfs.github.io/openzfs-docs/Developer%20Resources/Building%20ZFS.html">Building ZFS</a> guide and following the steps documented there with some small modifications for FreeBSD since the page was clearly written with Linux in mind.</p>
<p>
First, install the dependencies we&#39;ll need.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo pkg install autoconf automake autotools git gmake python devel/py-sysctl sudo</span></span></code></pre></div>
</div>
<p>
Then, clone ZFS and check out tag zfs-2.1.11.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ git clone https://github.com/openzfs/zfs
</span></span><span><span>sam@zfshax:~ $ <span>cd</span> zfs
</span></span><span><span>sam@zfshax:~/zfs $ git checkout zfs-2.1.11
</span></span><span><span>sam@zfshax:~/zfs $ git show --summary
</span></span><span><span>commit e25f9131d679692704c11dc0c1df6d4585b70c35 <span>(</span>HEAD, tag: zfs-2.1.11<span>)</span>
</span></span><span><span>Author: Tony Hutter &lt;hutter2@llnl.gov&gt;
</span></span><span><span>Date:   Tue Apr <span>18</span> 11:44:34 <span>2023</span> -0700
</span></span><span><span>
</span></span><span><span>    Tag zfs-2.1.11
</span></span><span><span>
</span></span><span><span>    META file and changelog updated.
</span></span><span><span>
</span></span><span><span>    Signed-off-by: Tony Hutter &lt;hutter2@llnl.gov&gt;</span></span></code></pre></div>
</div>
<p>
Now, configure, build, and install ZFS.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~/zfs $ sh autogen.sh
</span></span><span><span>sam@zfshax:~/zfs $ ./configure
</span></span><span><span>sam@zfshax:~/zfs $ gmake -s -j<span>$(</span>sysctl -n hw.ncpu<span>)</span>    <span># &lt;-- modified for FreeBSD</span>
</span></span><span><span>sam@zfshax:~/zfs $ sudo gmake install<span>;</span> sudo ldconfig  <span># &lt;-- modified for FreeBSD</span></span></span></code></pre></div>
</div>
<p>
Then, replace the FreeBSD&#39;s ZFS kernel module with the one we just built.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~/zfs $ sudo kldunload zfs.ko  <span># Needed because zfs.sh only unloads openzfs.ko</span>
</span></span><span><span>sam@zfshax:~/zfs $ sudo ./scripts/zfs.sh</span></span></code></pre></div>
</div>
<p>
Finally, verify we&#39;re running version 2.1.11 as desired.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~/zfs $ sudo zfs version
</span></span><span><span>zfs-2.1.11-1
</span></span><span><span>zfs-kmod-2.1.11-1</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-11">
<h3 id="headline-11">
Reproducing the issue
</h3>
<div id="outline-text-headline-11">
<p>
Now we&#39;re ready to try reproducing the issue. This took some iteration to get right, so I wrote a bash script that starts from scratch on each invocation and then runs the commands needed to reproduce the corrupt state. After quite a bit of trial and error, I eventually produced a <a href="https://blog.veitheller.de/reproduce.sh">reproducer script</a> which does the following:</p>
<ol>
<li>Create 2 pools: <code>src</code> and <code>dst</code>.</li>
<li>Create <code>src/encryptionroot</code> using a passphrase encryption key.</li>
<li>Create <code>src/encryptionroot/child</code> which inherits <code>src/encryptionroot</code> as its encryption root.</li>
<li>Create files and take snapshots <code>src/encryptionroot@111</code> and <code>src/encryptionroot/child@111</code>.</li>
<li>Send raw snapshots <code>src/encryptionroot@111</code> and <code>src/encryptionroot/child@111</code> to <code>dst/encryptionroot</code> and <code>dst/encryptionroot/child</code> respectively.</li>
<li>Load encryption key for <code>dst/encryptionroot</code> using passphrase and mount encrypted datasets <code>dst/encryptionroot</code> and <code>dst/encryptionroot/child</code>. At this point, <code>src</code> and <code>dst</code> pools are in sync.</li>
<li>Change the <code>src/encryptionroot</code> encryption key from passphrase to hex.</li>
<li>Update files and take snapshots <code>src/encryptionroot@222</code> and <code>src/encryptionroot/child@222</code>.</li>
<li>Send a raw incremental snapshot of <code>src/encryptionroot/child@222</code> to <code>dst/encryptionroot/child</code>, but do <em>not</em> send <code>src/encryptionroot@222</code> which contains the key change!</li>
<li>Unmount <code>dst/encryptionroot</code> and <code>dst/encryptionroot/child</code> and unload the cached encryption key for <code>dst/encryptionroot</code>.</li>
<li>Load the encryption key for <code>dst/encryptionroot</code> using the passphrase since we didn&#39;t send the updated encryption root after changing the key.</li>
<li>Try to remount <code>dst/encryptionroot</code> and <code>dst/encryptionroot/child</code>.</li>
</ol>
<p>When we run the reproducer, the root encrypted dataset <code>dst/encryptionroot</code> mounts successfully and we can read the old file from the first snapshot, but the child encrypted dataset <code>dst/encryptionroot/child</code> fails to mount with <code>cannot mount &#39;dst/encryptionroot/child: Permission denied</code> just as we expected.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo ./reproduce &gt; /dev/null 2&gt;<span>&amp;</span><span>1</span>
</span></span><span><span>sam@zfshax:~ $ sudo zfs mount dst/encryptionroot/child
</span></span><span><span>cannot mount <span>&#39;dst/encryptionroot/child&#39;</span>: Permission denied</span></span></code></pre></div>
</div>



<details>
    <summary title="Click to interact"><span>Full reproducer script output (long!)</span></summary>
    <div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo ./reproduce
</span></span><span><span>
</span></span><span><span>Destroy pools and backing files <span>if</span> they exist.
</span></span><span><span>+ zpool destroy src
</span></span><span><span>+ zpool destroy dst
</span></span><span><span>+ rm -f /src.img
</span></span><span><span>+ rm -f /dst.img
</span></span><span><span>
</span></span><span><span>Create pools using sparse files.
</span></span><span><span>+ truncate -s 100M /src.img
</span></span><span><span>+ truncate -s 100M /dst.img
</span></span><span><span>+ zpool create -o <span>ashift</span><span>=</span><span>12</span> -m /src src /src.img
</span></span><span><span>+ zpool create -o <span>ashift</span><span>=</span><span>12</span> -m /dst dst /dst.img
</span></span><span><span>
</span></span><span><span>Create root encrypted dataset using a passphrase encryption key.
</span></span><span><span>+ <span>echo</span> <span>&#39;hunter2!&#39;</span>
</span></span><span><span>+ zfs create -o <span>encryption</span><span>=</span>on -o <span>keyformat</span><span>=</span>passphrase -o <span>keylocation</span><span>=</span>prompt src/encryptionroot
</span></span><span><span>
</span></span><span><span>Create child encrypted dataset which inherits src/encryptionroot as its encryption root.
</span></span><span><span>+ zfs create src/encryptionroot/child
</span></span><span><span>
</span></span><span><span>Create files in the root and child encrypted datasets and snapshot both.
</span></span><span><span>+ touch /src/encryptionroot/111
</span></span><span><span>+ touch /src/encryptionroot/child/111
</span></span><span><span>+ zfs snapshot -r src/encryptionroot@111
</span></span><span><span>
</span></span><span><span><span>[</span> Checkpoint <span>1</span> <span>]</span> Files and snapshots are on the src pool but not the dst pool yet.
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>1354282934008960312</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  passphrase  available    yes      <span>12828913232342655944</span>
</span></span><span><span>src/encryptionroot@111        src/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  passphrase  available    yes      <span>10447093816713688124</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>NAME  ENCROOT  KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst   -        none        -            yes      <span>5247064584420489120</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>111</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>111</span>
</span></span><span><span>/dst
</span></span><span><span>
</span></span><span><span>Send a raw replication stream of the src snapshots to the dst pool.
</span></span><span><span>+ zfs send --replicate --raw src/encryptionroot@111
</span></span><span><span>+ zfs recv dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Load encryption key <span>for</span> the dst encryption root using passphrase and mount the encrypted datasets.
</span></span><span><span>+ <span>echo</span> <span>&#39;hunter2!&#39;</span>
</span></span><span><span>+ zfs load-key dst/encryptionroot
</span></span><span><span>+ zfs mount dst/encryptionroot
</span></span><span><span>+ zfs mount dst/encryptionroot/child
</span></span><span><span>
</span></span><span><span><span>[</span> Checkpoint <span>2</span> <span>]</span> Files and snapshots are on both pools and in sync.
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>1354282934008960312</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  passphrase  available    yes      <span>12828913232342655944</span>
</span></span><span><span>src/encryptionroot@111        src/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  passphrase  available    yes      <span>10447093816713688124</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>5247064584420489120</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  passphrase  available    yes      <span>3076413147413645477</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  passphrase  available    yes      <span>18246034838646533510</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>111</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>111</span>
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>111</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>111</span>
</span></span><span><span>
</span></span><span><span>Change the src encryption root key from passphrase to hex.
</span></span><span><span>+ <span>echo</span> 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
</span></span><span><span>+ zfs change-key -o <span>keyformat</span><span>=</span>hex src/encryptionroot
</span></span><span><span>
</span></span><span><span>Update the files in the root and child encrypted datasets and snapshot both.
</span></span><span><span>+ mv /src/encryptionroot/111 /src/encryptionroot/222
</span></span><span><span>+ mv /src/encryptionroot/child/111 /src/encryptionroot/child/222
</span></span><span><span>+ zfs snapshot -r src/encryptionroot@222
</span></span><span><span>
</span></span><span><span><span>[</span> Checkpoint <span>3</span> <span>]</span> Updated files and snapshots are on the src pool but not the dst pool yet.
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>1354282934008960312</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  hex         available    yes      <span>12828913232342655944</span>
</span></span><span><span>src/encryptionroot@111        src/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>src/encryptionroot@222        src/encryptionroot  -           available    -        <span>929742392566496732</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  hex         available    yes      <span>10447093816713688124</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>src/encryptionroot/child@222  src/encryptionroot  -           available    -        <span>8161419639883744346</span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>5247064584420489120</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  passphrase  available    yes      <span>3076413147413645477</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  passphrase  available    yes      <span>18246034838646533510</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span>
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>111</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>111</span>
</span></span><span><span>
</span></span><span><span>Send a raw incremental snapshot of the child encrypted dataset to the dst pool.
</span></span><span><span>+ zfs send --raw -i src/encryptionroot/child@111 src/encryptionroot/child@222
</span></span><span><span>+ zfs recv -F dst/encryptionroot/child
</span></span><span><span>
</span></span><span><span>NOTE: The encryption key change on the src encryption root has not been sent to dst!
</span></span><span><span>
</span></span><span><span><span>[</span> Checkpoint <span>4</span> <span>]</span> File is updated in the dst child encrypted dataset but not the dst root encrypted dataset.
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>1354282934008960312</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  hex         available    yes      <span>12828913232342655944</span>
</span></span><span><span>src/encryptionroot@111        src/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>src/encryptionroot@222        src/encryptionroot  -           available    -        <span>929742392566496732</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  hex         available    yes      <span>10447093816713688124</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>src/encryptionroot/child@222  src/encryptionroot  -           available    -        <span>8161419639883744346</span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>5247064584420489120</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  passphrase  available    yes      <span>3076413147413645477</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  hex         available    yes      <span>18246034838646533510</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>dst/encryptionroot/child@222  dst/encryptionroot  -           available    -        <span>8161419639883744346</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span>
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>111</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span>
</span></span><span><span>
</span></span><span><span>NOTE: The updated file in the dst child encrypted dataset is only still readable because the encryption key is still loaded from before sending the snapshot taken after the key change.
</span></span><span><span>
</span></span><span><span>Unmount the dst encrypted datasets and and unload the cached encryption key.
</span></span><span><span>+ zfs unmount dst/encryptionroot
</span></span><span><span>+ zfs unload-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Load the encryption key <span>for</span> the dst encryption root using the passphrase since we did not send the updated encryption root after changing the key.
</span></span><span><span>+ <span>echo</span> <span>&#39;hunter2!&#39;</span>
</span></span><span><span>+ zfs load-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Try to remount dst encrypted datasets.
</span></span><span><span>+ zfs mount dst/encryptionroot
</span></span><span><span>+ zfs mount dst/encryptionroot/child
</span></span><span><span>cannot mount <span>&#39;dst/encryptionroot/child&#39;</span>: Permission denied
</span></span><span><span>+ <span>true</span>
</span></span><span><span>
</span></span><span><span><span>[</span> Checkpoint <span>5</span> <span>]</span> Mounting dst child encrypted dataset failed even though encryption key is ostensibly available. Hypothesis confirmed!
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>1354282934008960312</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  hex         available    yes      <span>12828913232342655944</span>
</span></span><span><span>src/encryptionroot@111        src/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>src/encryptionroot@222        src/encryptionroot  -           available    -        <span>929742392566496732</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  hex         available    yes      <span>10447093816713688124</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>src/encryptionroot/child@222  src/encryptionroot  -           available    -        <span>8161419639883744346</span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>5247064584420489120</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  passphrase  available    yes      <span>3076413147413645477</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>14453618123048176778</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  hex         available    no       <span>18246034838646533510</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>10173467213034806911</span>
</span></span><span><span>dst/encryptionroot/child@222  dst/encryptionroot  -           available    -        <span>8161419639883744346</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span>
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>111</span>
</span></span><span><span>    └── child</span></span></code></pre></div></details>

<p>
Now that we understand and can reliably reproduce the issue, we&#39;re a big step closer to fixing it!</p>
<hr/>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-12">
<h2 id="headline-12">
Part 3: Recovering our data
</h2>
<div id="outline-text-headline-12">
<div id="outline-container-headline-13">
<h3 id="headline-13">
Theoretically easy to fix
</h3>
<div id="outline-text-headline-13">
<p>
We know now that a child encrypted dataset will become unmountable if the following conditions are met:</p>
<ol>
<li>The wrapping encryption key on the encryption root is changed.</li>
<li>A snapshot of the child encrypted dataset that was taken after the key change is sent.</li>
<li>A snapshot of the encryption root that was taken after the key change is <em>not</em> sent.</li>
</ol>
<p><strong>Lesson: Always send a snapshot of the encryption root after changing the encryption key.</strong></p>
<p>
In theory, all we should have to do to fix it is send the latest snapshot of the encryption root.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo ./reproduce &gt; /dev/null 2&gt;<span>&amp;</span><span>1</span>
</span></span><span><span>sam@zfshax:~ $ sudo ./repair_snapshot
</span></span><span><span>
</span></span><span><span>HYPOTHESIS: The child encrypted dataset should become decryptable again <span>if</span> a snapshot containing the key change on the root encrypted dataset is sent.
</span></span><span><span>
</span></span><span><span>Send a raw incremental snapshot of the root encrypted dataset to the dst pool.
</span></span><span><span>+ zfs send --raw -i src/encryptionroot@111 src/encryptionroot@222
</span></span><span><span>+ zfs recv -F dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Unmount the dst encrypted datasets and and unload the cached encryption key.
</span></span><span><span>+ zfs unmount dst/encryptionroot
</span></span><span><span>+ zfs unload-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Load the encryption key <span>for</span> the dst encryption root using the hex key since we have now sent the updated encryption root after changing the key.
</span></span><span><span>+ <span>echo</span> 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
</span></span><span><span>+ zfs load-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Try to remount dst encrypted datasets.
</span></span><span><span>+ zfs mount dst/encryptionroot
</span></span><span><span>+ zfs mount dst/encryptionroot/child
</span></span><span><span>
</span></span><span><span>RESULT: Child encrypted dataset is decryptable again. Hypothesis confirmed!
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>3822096046979704342</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  hex         available    yes      <span>10687499872806328230</span>
</span></span><span><span>src/encryptionroot@111        src/encryptionroot  -           available    -        <span>16650389156603898046</span>
</span></span><span><span>src/encryptionroot@222        src/encryptionroot  -           available    -        <span>157927145464667221</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  hex         available    yes      <span>15788284772663365294</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>8879828033920251704</span>
</span></span><span><span>src/encryptionroot/child@222  src/encryptionroot  -           available    -        <span>6286619359795670820</span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>1835983340793043086</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  hex         available    yes      <span>6911130245015256647</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>16650389156603898046</span>
</span></span><span><span>dst/encryptionroot@222        dst/encryptionroot  -           available    -        <span>157927145464667221</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  hex         available    yes      <span>15804809318195285947</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>8879828033920251704</span>
</span></span><span><span>dst/encryptionroot/child@222  dst/encryptionroot  -           available    -        <span>6286619359795670820</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span>
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-14">
<h3 id="headline-14">
Not so easy in practice
</h3>
<div id="outline-text-headline-14">
<p>
Unfortunately, this isn&#39;t enough to fix <code>new</code> and <code>sneakernet</code>; there are no remaining snapshots or bookmarks left on the <code>old</code> encryption root from before the key change, and we can&#39;t generate an incremental send stream without one. Mapped to our reproduced example, this means that <code>src/encryptionroot@111</code> does not exist.</p>
<p>
You might think we could forcibly send the entire encryption root, but <code>zfs recv</code> will reject it no matter what you do.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo zfs send --raw src/encryptionroot@222 <span>|</span> sudo zfs recv dst/encryptionroot
</span></span><span><span>cannot receive new filesystem stream: destination <span>&#39;dst/encryptionroot&#39;</span> exists
</span></span><span><span>must specify -F to overwrite it
</span></span><span><span>
</span></span><span><span>sam@zfshax:~ $ sudo zfs send --raw src/encryptionroot@222 <span>|</span> sudo zfs recv -F dst/encryptionroot
</span></span><span><span>cannot receive new filesystem stream: destination has snapshots <span>(</span>eg. dst/encryptionroot@111<span>)</span>
</span></span><span><span>must destroy them to overwrite it
</span></span><span><span>
</span></span><span><span>sam@zfshax:~ $ sudo zfs destroy dst/encryptionroot@111
</span></span><span><span>sam@zfshax:~ $ sudo zfs send --raw src/encryptionroot@222 <span>|</span> sudo zfs recv -F dst/encryptionroot
</span></span><span><span>cannot receive new filesystem stream: zfs receive -F cannot be used to destroy an encrypted filesystem or overwrite an unencrypted one with an encrypted one</span></span></code></pre></div>
</div>
<p>
<strong>Lesson: Create bookmarks before destroying snapshots.</strong></p>
<p>
We need to find a way to create an incremental send stream that contains the key change, but how?. We could try to manually craft a send stream containing the new key, but that sounds tricky. There&#39;s got to be a better way!</p>
</div>
</div>
<div id="outline-container-headline-15">
<h3 id="headline-15">
Idea for a hack
</h3>
<div id="outline-text-headline-15">
<p>
Recall that a snapshot is not the only valid source for generating an incremental send stream. What if we had a bookmark?</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo ./reproduce &gt; /dev/null 2&gt;<span>&amp;</span><span>1</span>
</span></span><span><span>sam@zfshax:~ $ sudo ./repair_bookmark
</span></span><span><span>
</span></span><span><span>Replace the initial parent encrypted dataset snapshot with a bookmark.
</span></span><span><span>+ zfs bookmark src/encryptionroot@111 src/encryptionroot#111
</span></span><span><span>+ zfs destroy src/encryptionroot@111
</span></span><span><span>
</span></span><span><span>HYPOTHESIS: The child encrypted dataset should become decryptable again <span>if</span> a snapshot containing the key change on the root encrypted dataset is sent.
</span></span><span><span>
</span></span><span><span>Send a raw incremental snapshot of the root encrypted dataset to the dst pool using the bookmark.
</span></span><span><span>+ zfs send --raw -i src/encryptionroot#111 src/encryptionroot@222
</span></span><span><span>+ zfs recv -F dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Unmount the dst encrypted datasets and and unload the cached encryption key.
</span></span><span><span>+ zfs unmount dst/encryptionroot
</span></span><span><span>+ zfs unload-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Load the encryption key <span>for</span> the dst encryption root using the hex key since we have now sent the updated encryption root after changing the key.
</span></span><span><span>+ <span>echo</span> 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
</span></span><span><span>+ zfs load-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>Try to remount dst encrypted datasets.
</span></span><span><span>+ zfs mount dst/encryptionroot
</span></span><span><span>+ zfs mount dst/encryptionroot/child
</span></span><span><span>
</span></span><span><span>RESULT: Child encrypted dataset is decryptable again. Hypothesis confirmed!
</span></span><span><span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>src                           -                   none        -            yes      <span>1018261135296547862</span>
</span></span><span><span>src/encryptionroot            src/encryptionroot  hex         available    yes      <span>1985286651877572312</span>
</span></span><span><span>src/encryptionroot@222        src/encryptionroot  -           available    -        <span>4582898506955533479</span>
</span></span><span><span>src/encryptionroot#111        -                   -           -            -        <span>4964628655505655411</span>
</span></span><span><span>src/encryptionroot/child      src/encryptionroot  hex         available    yes      <span>12927592016081051429</span>
</span></span><span><span>src/encryptionroot/child@111  src/encryptionroot  -           available    -        <span>15551239789901400488</span>
</span></span><span><span>src/encryptionroot/child@222  src/encryptionroot  -           available    -        <span>11729357375613972731</span>
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>15258247229701443799</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  hex         available    yes      <span>17755083343181277380</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>4964628655505655411</span>
</span></span><span><span>dst/encryptionroot@222        dst/encryptionroot  -           available    -        <span>4582898506955533479</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  hex         available    yes      <span>364333975888407846</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>15551239789901400488</span>
</span></span><span><span>dst/encryptionroot/child@222  dst/encryptionroot  -           available    -        <span>11729357375613972731</span>
</span></span><span><span>/src
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span>
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span></span></span></code></pre></div>
</div>
<p>
A bookmark works just as well as a snapshot for generating an incremental send stream, but we don&#39;t have a bookmark on <code>old</code> either. How is this any better?</p>
<p>
Unlike a snapshot, which is effectively an entire dataset tree frozen in time (very complex), a bookmark is a very simple object on disk which consists of:</p>
<ol>
<li>The GUID of the snapshot.</li>
<li>The transaction group the snapshot was created in.</li>
<li>The Unix timestamp when the snapshot was created.</li>
</ol>
<p>For example, this is what our bookmark looks like in <code>zdb</code>:</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo zdb src/encryptionroot#111
</span></span><span><span>	<span>#111: {guid: 44e5e7755d23c673 creation_txg: 12 creation_time: 1756699200 redaction_obj: 0}</span></span></span></code></pre></div>
</div>
<p>
Note that <code>zdb</code> shows the GUID in hexadecimal versus <code>zfs get guid</code> which shows it in decimal, consistency be damned. The <code>redaction_obj</code> is optional and only used for <a href="https://openzfs.github.io/openzfs-docs/man/master/8/zfs-redact.8.html#redaction">redaction bookmarks</a>, so we can ignore it.</p>
<p>
A bookmark is simple enough that we could feasibly hack ZFS into manually writing one for us, provided that we can figure out the right values to use. The GUID and Unix timestamp don&#39;t really matter for generating an incremental send stream, so we could choose them arbitrarily if we had to, but the transaction group id really matters because that is what ZFS uses to determine which blocks to include.</p>
<p>
But how can we figure out what transaction group the snapshot was created in if neither the snapshot nor a bookmark of the snapshot still exist? I initially considered walking the dataset trees on each pool, diffing them to find the newest block present on both datasets, and using its transaction group id, but I found a much easier way with one of ZFS&#39;s lesser known features.</p>
</div>
</div>
<div id="outline-container-headline-16">
<h3 id="headline-16">
A brief detour into pool histories
</h3>
<div id="outline-text-headline-16">
<p>
I didn&#39;t know about <a href="https://docs.freebsd.org/en/books/handbook/zfs/#zfs-zpool-history">pool histories</a> before embarking on this unplanned journey, but they are now yet another thing I love about ZFS. Every pool allocates <a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/spa_history.c#L108-L111">0.1% of its space (128 KiB minimum, 1 GiB maximum)</a> to a ring buffer which is used to log every command that is executed on the pool. This can be used to forensically reconstruct the state of the pool over time.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo zpool <span>history</span>
</span></span><span><span>History <span>for</span> <span>&#39;dst&#39;</span>:
</span></span><span><span>2025-09-01.00:00:00 zpool create -o <span>ashift</span><span>=</span><span>12</span> -m /dst dst /dst.img
</span></span><span><span>2025-09-01.00:00:00 zfs recv dst/encryptionroot
</span></span><span><span>2025-09-01.00:00:00 zfs load-key dst/encryptionroot
</span></span><span><span>2025-09-01.00:00:00 zfs recv -F dst/encryptionroot/child
</span></span><span><span>2025-09-01.00:00:00 zfs unload-key dst/encryptionroot
</span></span><span><span>2025-09-01.00:00:00 zfs load-key dst/encryptionroot
</span></span><span><span>
</span></span><span><span>History <span>for</span> <span>&#39;src&#39;</span>:
</span></span><span><span>2025-09-01.00:00:00 zpool create -o <span>ashift</span><span>=</span><span>12</span> -m /src src /src.img
</span></span><span><span>2025-09-01.00:00:00 zfs create -o <span>encryption</span><span>=</span>on -o <span>keyformat</span><span>=</span>passphrase -o <span>keylocation</span><span>=</span>prompt src/encryptionroot
</span></span><span><span>2025-09-01.00:00:00 zfs create src/encryptionroot/child
</span></span><span><span>2025-09-01.00:00:00 zfs snapshot -r src/encryptionroot@111
</span></span><span><span>2025-09-01.00:00:00 zfs send --replicate --raw src/encryptionroot@111
</span></span><span><span>2025-09-01.00:00:00 zfs change-key -o <span>keyformat</span><span>=</span>hex src/encryptionroot
</span></span><span><span>2025-09-01.00:00:00 zfs snapshot -r src/encryptionroot@222</span></span></code></pre></div>
</div>
<p>
ZFS also logs many internal operations in the pool history (search for <code>spa_history_log</code> in the source code) which can be viewed with the <code>-i</code> flag. For snapshots, this includes the transaction group (txg) id when the snapshot was created, which is exactly what we&#39;re looking for!</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo zpool <span>history</span> -i src
</span></span><span><span>History <span>for</span> <span>&#39;src&#39;</span>:
</span></span><span><span>...
</span></span><span><span>2025-09-01.00:00:00 <span>[</span>txg:12<span>]</span> snapshot src/encryptionroot@111 <span>(</span>768<span>)</span>
</span></span><span><span>2025-09-01.00:00:00 <span>[</span>txg:12<span>]</span> snapshot src/encryptionroot/child@111 <span>(</span>770<span>)</span>
</span></span><span><span>2025-09-01.00:00:00 <span>(</span>3ms<span>)</span> ioctl snapshot
</span></span><span><span>    input:
</span></span><span><span>        snaps:
</span></span><span><span>            src/encryptionroot@111
</span></span><span><span>            src/encryptionroot/child@111
</span></span><span><span>        props:
</span></span><span><span>
</span></span><span><span>2025-09-01.00:00:00 zfs snapshot -r src/encryptionroot@111
</span></span><span><span>...</span></span></code></pre></div>
</div>
<p>
The GUID and creation timestamp we can easily get from the snapshot on <code>dst</code>.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo zfs list -o name,guid,creation -p dst/encryptionroot@111
</span></span><span><span>NAME                                   GUID  CREATION
</span></span><span><span>dst/encryptionroot@111  <span>4964628655505655411</span>  <span>1756699200</span></span></span></code></pre></div>
</div>
<p>
Now that we know everything we need to create the bookmark, we just need to figure out a way to manually create a bookmark with arbitrary data.</p>
</div>
</div>
<div id="outline-container-headline-17">
<h3 id="headline-17">
Hacking ZFS to manually create a bookmark
</h3>
<div id="outline-text-headline-17">
<p>
To understand how ZFS creates a bookmark, we can trace the code path from <code>zfs bookmark</code> all the way down to <code>dsl_bookmark_add</code> which actually adds the bookmark node to the tree.</p>
<ul>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/cmd/zfs/zfs_main.c#L215">command_table</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/cmd/zfs/zfs_main.c#L7806">zfs_do_bookmark</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/lib/libzfs_core/libzfs_core.c#L1128">lzc_bookmark</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/lib/libzfs_core/libzfs_core.c#L172">lzc_ioctl</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/lib/libzutil/os/freebsd/zutil_compat.c#L95">zfs_ioctl_fd</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/lib/libzutil/os/freebsd/zutil_compat.c#L48">zcmd_ioctl_compat</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/zfs_ioctl.c#L7028">zfs_ioctl_register bookmark</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/zfs_ioctl.c#L3721">zfs_ioc_bookmark</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/dsl_bookmark.c#L613">dsl_bookmark_create</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/dsl_bookmark.c#L584">dsl_bookmark_create_sync</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/dsl_bookmark.c#L516">dsl_bookmark_create_sync_impl_book</a></li>
<li><a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/module/zfs/dsl_bookmark.c#L393">dsl_bookmark_node_add</a></li>
</ul>
<p>This is the bookmark structure physically written to disk:</p>
<p>
<a href="https://github.com/openzfs/zfs/blob/zfs-2.1.11/include/sys/dsl_bookmark.h#L31-L57">zfs/include/sys/dsl_bookmark.h</a></p>
<div>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>/*
</span></span></span><span><span><span> * On disk zap object.
</span></span></span><span><span><span> */</span>
</span></span><span><span><span>typedef</span> <span>struct</span> <span>zfs_bookmark_phys</span> <span>{</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_guid</span><span>;</span>		<span>/* guid of bookmarked dataset */</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_creation_txg</span><span>;</span>	<span>/* birth transaction group */</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_creation_time</span><span>;</span>	<span>/* bookmark creation time */</span>
</span></span><span><span>
</span></span><span><span>	<span>/* fields used for redacted send / recv */</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_redaction_obj</span><span>;</span>	<span>/* redaction list object */</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_flags</span><span>;</span>		<span>/* ZBM_FLAG_* */</span>
</span></span><span><span>
</span></span><span><span>	<span>/* fields used for bookmark written size */</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_referenced_bytes_refd</span><span>;</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_compressed_bytes_refd</span><span>;</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_uncompressed_bytes_refd</span><span>;</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_referenced_freed_before_next_snap</span><span>;</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_compressed_freed_before_next_snap</span><span>;</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_uncompressed_freed_before_next_snap</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>/* fields used for raw sends */</span>
</span></span><span><span>	<span>uint64_t</span> <span>zbm_ivset_guid</span><span>;</span>
</span></span><span><span><span>}</span> <span>zfs_bookmark_phys_t</span><span>;</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>#define	BOOKMARK_PHYS_SIZE_V1	(3 * sizeof (uint64_t))
</span></span></span><span><span><span>#define	BOOKMARK_PHYS_SIZE_V2	(12 * sizeof (uint64_t))</span></span></span></code></pre></div>
</div>
<p>
Only the first 3 fields are required for v1 bookmarks, while v2 bookmarks contain all 12 fields. <code>dsl_bookmark_node_add</code> only writes a v2 bookmark if one of the 9 v2 fields are non-zero, so we can leave them all zero to write a v1 bookmark.</p>
<p>
After a few iterations, I had a patch which hijacks the normal <code>zfs bookmark pool/dataset#src pool/dataset#dst</code> code path to create a bookmark with arbitrary data when the source bookmark name is <code>missing</code>.</p>
<div>
<div><pre tabindex="0"><code data-lang="diff"><span><span>sam@zfshax:~/zfs $ git --no-pager diff
</span></span><span><span>sam@zfshax:~/zfs $ git --no-pager diff
</span></span><span><span><span>diff --git a/cmd/zfs/zfs_main.c b/cmd/zfs/zfs_main.c
</span></span></span><span><span><span>index 2d81ef31c..73b5d7e70 100644
</span></span></span><span><span><span></span><span>--- a/cmd/zfs/zfs_main.c
</span></span></span><span><span><span></span><span>+++ b/cmd/zfs/zfs_main.c
</span></span></span><span><span><span></span><span>@@ -7892,12 +7892,15 @@ zfs_do_bookmark(int argc, char **argv)
</span></span></span><span><span><span></span> 		default: abort();
</span></span><span><span> 	}
</span></span><span><span>
</span></span><span><span><span>+// Skip testing for #missing because it does not exist.
</span></span></span><span><span><span>+if (strstr(source, &#34;#missing&#34;) == NULL) {
</span></span></span><span><span><span></span> 	/* test the source exists */
</span></span><span><span> 	zfs_handle_t *zhp;
</span></span><span><span> 	zhp = zfs_open(g_zfs, source, source_type);
</span></span><span><span> 	if (zhp == NULL)
</span></span><span><span> 		goto usage;
</span></span><span><span> 	zfs_close(zhp);
</span></span><span><span><span>+}
</span></span></span><span><span><span></span>
</span></span><span><span> 	nvl = fnvlist_alloc();
</span></span><span><span> 	fnvlist_add_string(nvl, bookname, source);
</span></span><span><span><span>diff --git a/module/zfs/dsl_bookmark.c b/module/zfs/dsl_bookmark.c
</span></span></span><span><span><span>index 861dd9239..fae882f45 100644
</span></span></span><span><span><span></span><span>--- a/module/zfs/dsl_bookmark.c
</span></span></span><span><span><span></span><span>+++ b/module/zfs/dsl_bookmark.c
</span></span></span><span><span><span></span><span>@@ -263,7 +263,12 @@ dsl_bookmark_create_check_impl(dsl_pool_t *dp,
</span></span></span><span><span><span></span> 		 * Source must exists and be an earlier point in newbm_ds&#39;s
</span></span><span><span> 		 * timeline (newbm_ds&#39;s origin may be a snap of source&#39;s ds)
</span></span><span><span> 		 */
</span></span><span><span><span>+// Skip looking up #missing because it does not exist.
</span></span></span><span><span><span>+if (strstr(source, &#34;#missing&#34;) == NULL) {
</span></span></span><span><span><span></span> 		error = dsl_bookmark_lookup(dp, source, newbm_ds, &amp;source_phys);
</span></span><span><span><span>+} else {
</span></span></span><span><span><span>+		error = 0;
</span></span></span><span><span><span>+}
</span></span></span><span><span><span></span> 		switch (error) {
</span></span><span><span> 		case 0:
</span></span><span><span> 			break; /* happy path */
</span></span><span><span><span>@@ -545,12 +550,34 @@ dsl_bookmark_create_sync_impl_book(
</span></span></span><span><span><span></span> 	 *   because the redaction object might be too large
</span></span><span><span> 	 */
</span></span><span><span>
</span></span><span><span><span>+// Skip looking up #missing because it does not exist.
</span></span></span><span><span><span>+if (strstr(source_name, &#34;#missing&#34;) == NULL) {
</span></span></span><span><span><span></span> 	VERIFY0(dsl_bookmark_lookup_impl(bmark_fs_source, source_shortname,
</span></span><span><span> 	    &amp;source_phys));
</span></span><span><span><span>+}
</span></span></span><span><span><span></span> 	dsl_bookmark_node_t *new_dbn = dsl_bookmark_node_alloc(new_shortname);
</span></span><span><span>
</span></span><span><span><span>+// Skip copying from #missing because it does not exist.
</span></span></span><span><span><span>+if (strstr(source_name, &#34;#missing&#34;) == NULL) {
</span></span></span><span><span><span></span> 	memcpy(&amp;new_dbn-&gt;dbn_phys, &amp;source_phys, sizeof (source_phys));
</span></span><span><span> 	new_dbn-&gt;dbn_phys.zbm_redaction_obj = 0;
</span></span><span><span><span>+} else {
</span></span></span><span><span><span>+	// Manually set the bookmark parameters.
</span></span></span><span><span><span>+	new_dbn-&gt;dbn_phys = (zfs_bookmark_phys_t){
</span></span></span><span><span><span>+		.zbm_guid = 4964628655505655411,
</span></span></span><span><span><span>+		.zbm_creation_txg = 12,
</span></span></span><span><span><span>+		.zbm_creation_time = 1756699200,
</span></span></span><span><span><span>+		.zbm_redaction_obj = 0,
</span></span></span><span><span><span>+		.zbm_flags = 0,
</span></span></span><span><span><span>+		.zbm_referenced_bytes_refd = 0,
</span></span></span><span><span><span>+		.zbm_compressed_bytes_refd = 0,
</span></span></span><span><span><span>+		.zbm_uncompressed_bytes_refd = 0,
</span></span></span><span><span><span>+		.zbm_referenced_freed_before_next_snap = 0,
</span></span></span><span><span><span>+		.zbm_compressed_freed_before_next_snap = 0,
</span></span></span><span><span><span>+		.zbm_uncompressed_freed_before_next_snap = 0,
</span></span></span><span><span><span>+		.zbm_ivset_guid = 0,
</span></span></span><span><span><span>+	};
</span></span></span><span><span><span>+}
</span></span></span><span><span><span></span>
</span></span><span><span> 	/* update feature counters */
</span></span><span><span> 	if (new_dbn-&gt;dbn_phys.zbm_flags &amp; ZBM_FLAG_HAS_FBN) {
</span></span></code></pre></div>
</div>
<p>
To test, we recompile ZFS, reload the kernel module, and reimport the pools.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~/zfs $ gmake -s -j<span>$(</span>sysctl -n hw.ncpu<span>)</span>
</span></span><span><span>sam@zfshax:~/zfs $ sudo gmake install <span>&amp;&amp;</span> sudo ldconfig
</span></span><span><span>sam@zfshax:~/zfs $ sudo zpool <span>export</span> src <span>&amp;&amp;</span> sudo zpool <span>export</span> dst
</span></span><span><span>sam@zfshax:~/zfs $ sudo ./scripts/zfs.sh -r
</span></span><span><span>sam@zfshax:~/zfs $ sudo zpool import src -d / <span>&amp;&amp;</span> sudo zpool import dst -d /</span></span></code></pre></div>
</div>
<p>
Then, we create the bookmark ex nihilo using the magic bookmark name <code>missing</code>.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~/zfs $ sudo zfs bookmark src/encryptionroot#missing src/encryptionroot#111
</span></span><span><span>sam@zfshax:~/zfs $ sudo zdb src/encryptionroot#111
</span></span><span><span>	<span>#111: {guid: 44e5e7755d23c673 creation_txg: 12 creation_time: 1756699200 redaction_obj: 0}</span></span></span></code></pre></div>
</div>
<p>
Success! We can now use the bookmark to generate an incremental send stream containing the new hex wrapping key parameters.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~/zfs $ sudo zfs send --raw -i src/encryptionroot#111 src/encryptionroot@222 <span>|</span> zstreamdump
</span></span><span><span>BEGIN record
</span></span><span><span>	<span>hdrtype</span> <span>=</span> <span>1</span>
</span></span><span><span>	<span>features</span> <span>=</span> <span>1420004</span>
</span></span><span><span>	<span>magic</span> <span>=</span> 2f5bacbac
</span></span><span><span>	<span>creation_time</span> <span>=</span> 68d3d93f
</span></span><span><span>	<span>type</span> <span>=</span> <span>2</span>
</span></span><span><span>	<span>flags</span> <span>=</span> 0xc
</span></span><span><span>	<span>toguid</span> <span>=</span> 3f99b9e92cc0aca7
</span></span><span><span>	<span>fromguid</span> <span>=</span> 44e5e7755d23c673
</span></span><span><span>	<span>toname</span> <span>=</span> src/encryptionroot@222
</span></span><span><span>	<span>payloadlen</span> <span>=</span> <span>1028</span>
</span></span><span><span>nvlist version: <span>0</span>
</span></span><span><span>	<span>crypt_keydata</span> <span>=</span> <span>(</span>embedded nvlist<span>)</span>
</span></span><span><span>	nvlist version: <span>0</span>
</span></span><span><span>		<span>DSL_CRYPTO_SUITE</span> <span>=</span> 0x8
</span></span><span><span>		<span>DSL_CRYPTO_GUID</span> <span>=</span> 0x6196311f2622e30
</span></span><span><span>		<span>DSL_CRYPTO_VERSION</span> <span>=</span> 0x1
</span></span><span><span>		<span>DSL_CRYPTO_MASTER_KEY_1</span> <span>=</span> 0x6c 0x55 0x13 0x78 0x8c 0x2d 0x42 0xb5 0x9e 0x33 0x2 0x7e 0x73 0x3a 0x46 0x20 0xd2 0xf7 0x23 0x7d 0x7c 0x5d 0x5f 0x76 0x63 0x90 0xd2 0x43 0x6a 0xdd 0x63 0x2b
</span></span><span><span>		<span>DSL_CRYPTO_HMAC_KEY_1</span> <span>=</span> 0x85 0xd1 0xf3 0xba 0xed 0xec 0x6 0x28 0x36 0xd6 0x60 0x28 0x8d 0x2f 0x6f 0x14 0xc9 0x2b 0x6f 0xf4 0x19 0x23 0x2d 0xf 0x3d 0xe 0xc4 0x88 0x4 0x6d 0xca 0xb5 0x2d 0x4d 0x8 0x75 0x17 0x1c 0xe3 0xe7 0xe6 0x23 0x7 0x53 0x94 0xba 0xc7 0x4b 0xf5 0xde 0x8c 0x29 0xa3 0x27 0xdf 0x82 0x64 0x9d 0x92 0xb4 0xc1 0x26 0x5b 0x32
</span></span><span><span>		<span>DSL_CRYPTO_IV</span> <span>=</span> 0xdf 0x52 0x77 0xe8 0xf 0xfd 0xc2 0x42 0x66 0x88 0xb9 0xf0
</span></span><span><span>		<span>DSL_CRYPTO_MAC</span> <span>=</span> 0x54 0x54 0x15 0xa4 0x21 0x55 0x6b 0x4e 0x99 0xe7 0xf 0xef 0x9f 0x90 0x42 0x54
</span></span><span><span>		<span>portable_mac</span> <span>=</span> 0x3a 0xd6 0x30 0xc4 0x6a 0x2d 0x60 0x24 0x95 0xfc 0x99 0xbb 0xfa 0x10 0xa0 0x6b 0xc6 0x1 0xdd 0x1d 0x9 0xcd 0xa8 0x19 0xdf 0x57 0xb9 0x90 0x4f 0x2e 0x33 0xc1
</span></span><span><span>		<span>keyformat</span> <span>=</span> 0x2
</span></span><span><span>		<span>pbkdf2iters</span> <span>=</span> 0x0
</span></span><span><span>		<span>pbkdf2salt</span> <span>=</span> 0x0
</span></span><span><span>		<span>mdn_checksum</span> <span>=</span> 0x0
</span></span><span><span>		<span>mdn_compress</span> <span>=</span> 0x0
</span></span><span><span>		<span>mdn_nlevels</span> <span>=</span> 0x6
</span></span><span><span>		<span>mdn_blksz</span> <span>=</span> 0x4000
</span></span><span><span>		<span>mdn_indblkshift</span> <span>=</span> 0x11
</span></span><span><span>		<span>mdn_nblkptr</span> <span>=</span> 0x3
</span></span><span><span>		<span>mdn_maxblkid</span> <span>=</span> 0x4
</span></span><span><span>		<span>to_ivset_guid</span> <span>=</span> 0x957edeaa7123a7
</span></span><span><span>		<span>from_ivset_guid</span> <span>=</span> 0x0
</span></span><span><span>	<span>(</span>end crypt_keydata<span>)</span>
</span></span><span><span>
</span></span><span><span>END <span>checksum</span> <span>=</span> 14046201258/62f53166ccc36/14023a70758c3195/1e906f4670783cd
</span></span><span><span>SUMMARY:
</span></span><span><span>	Total DRR_BEGIN <span>records</span> <span>=</span> <span>1</span> <span>(</span><span>1028</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_END <span>records</span> <span>=</span> <span>1</span> <span>(</span><span>0</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_OBJECT <span>records</span> <span>=</span> <span>7</span> <span>(</span><span>960</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_FREEOBJECTS <span>records</span> <span>=</span> <span>2</span> <span>(</span><span>0</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_WRITE <span>records</span> <span>=</span> <span>1</span> <span>(</span><span>512</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_WRITE_BYREF <span>records</span> <span>=</span> <span>0</span> <span>(</span><span>0</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_WRITE_EMBEDDED <span>records</span> <span>=</span> <span>0</span> <span>(</span><span>0</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_FREE <span>records</span> <span>=</span> <span>12</span> <span>(</span><span>0</span> bytes<span>)</span>
</span></span><span><span>	Total DRR_SPILL <span>records</span> <span>=</span> <span>0</span> <span>(</span><span>0</span> bytes<span>)</span>
</span></span><span><span>	Total <span>records</span> <span>=</span> <span>26</span>
</span></span><span><span>	Total payload <span>size</span> <span>=</span> <span>2500</span> <span>(</span>0x9c4<span>)</span>
</span></span><span><span>	Total header <span>overhead</span> <span>=</span> <span>8112</span> <span>(</span>0x1fb0<span>)</span>
</span></span><span><span>	Total stream <span>length</span> <span>=</span> <span>10612</span> <span>(</span>0x2974<span>)</span></span></span></code></pre></div>
</div>
<p>
But we can&#39;t receive the send stream.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo zfs send --raw -i src/encryptionroot#111 src/encryptionroot@222 <span>|</span> sudo zfs recv -F dst/encryptionroot
</span></span><span><span>cannot receive incremental stream: IV <span>set</span> guid missing. See errata <span>4</span> at https://openzfs.github.io/openzfs-docs/msg/ZFS-8000-ER.</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-18">
<h3 id="headline-18">
The final obstacle
</h3>
<div id="outline-text-headline-18">
<p>
ZFS refuses the stream because it is missing a source IV set GUID (see <code>from_ivset_guid = 0x0</code> in the <code>zstreamdump</code> above). This is because we created a v1 bookmark which does not contain the IV set GUID like a v2 bookmark would.</p>
<p>
Since we know that the send stream is created using the right snapshots, we can temporarily disable checking IV set GUIDs to allow the snapshot to be received as described in <a href="https://openzfs.github.io/openzfs-docs/msg/ZFS-8000-ER/index.html#zfs-errata-4">errata 4</a>.</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ sudo sysctl vfs.zfs.disable_ivset_guid_check<span>=</span><span>1</span>
</span></span><span><span>vfs.zfs.disable_ivset_guid_check: <span>0</span> -&gt; <span>1</span>
</span></span><span><span>sam@zfshax:~ $ sudo zfs send --raw -i src/encryptionroot#111 src/encryptionroot@222 <span>|</span> sudo zfs recv -F dst/encryptionroot
</span></span><span><span>sam@zfshax:~ $ sudo sysctl vfs.zfs.disable_ivset_guid_check<span>=</span><span>0</span>
</span></span><span><span>vfs.zfs.disable_ivset_guid_check: <span>1</span> -&gt; <span>0</span>
</span></span><span><span>sam@zfshax:~ $ sudo zpool <span>export</span> dst
</span></span><span><span>sam@zfshax:~ $ sudo zpool import dst -d /
</span></span><span><span>sam@zfshax:~ $ sudo zpool scrub dst
</span></span><span><span>sam@zfshax:~ $ sudo zpool status -x
</span></span><span><span>all pools are healthy</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-19">
<h3 id="headline-19">
The moment of truth
</h3>
<div id="outline-text-headline-19">
<p>
And now for the moment of truth…</p>
<div>
<div><pre tabindex="0"><code data-lang="bash"><span><span>sam@zfshax:~ $ <span>echo</span> <span>&#34;0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef&#34;</span> <span>|</span> sudo zfs load-key dst/encryptionroot
</span></span><span><span>sam@zfshax:~ $ sudo zfs mount -a
</span></span><span><span>sam@zfshax:~ $ sudo zfs list -t all -o name,encryptionroot,keyformat,keystatus,mounted,guid -r dst
</span></span><span><span>NAME                          ENCROOT             KEYFORMAT   KEYSTATUS    MOUNTED   GUID
</span></span><span><span>dst                           -                   none        -            yes      <span>15258247229701443799</span>
</span></span><span><span>dst/encryptionroot            dst/encryptionroot  hex         available    yes      <span>17755083343181277380</span>
</span></span><span><span>dst/encryptionroot@111        dst/encryptionroot  -           available    -        <span>4964628655505655411</span>
</span></span><span><span>dst/encryptionroot@222        dst/encryptionroot  -           available    -        <span>4582898506955533479</span>
</span></span><span><span>dst/encryptionroot/child      dst/encryptionroot  hex         available    yes      <span>364333975888407846</span>
</span></span><span><span>dst/encryptionroot/child@111  dst/encryptionroot  -           available    -        <span>15551239789901400488</span>
</span></span><span><span>dst/encryptionroot/child@222  dst/encryptionroot  -           available    -        <span>11729357375613972731</span>
</span></span><span><span>sam@zfshax:~ $ tree --noreport --noreport /dst
</span></span><span><span>/dst
</span></span><span><span>└── encryptionroot
</span></span><span><span>    ├── <span>222</span>
</span></span><span><span>    └── child
</span></span><span><span>        └── <span>222</span></span></span></code></pre></div>
</div>
<p>
<a href="https://www.youtube.com/watch?v=30jNsCVLpAE&amp;t=931s">WE&#39;RE GONNA LIVE!!!</a></p>
<p>
At this point, we can now reliably fix the issue in our test environment. All we need to do now is use our hacked ZFS build to create the bookmark on <code>old</code>, send an incremental snapshot of the encryption root with the new key to <code>sneakernet</code>, and then send that snapshot from <code>sneakernet</code> to <code>new</code>. I rebuilt ZFS again with the correct transaction group, GUID, and creation timestamp for <code>old</code>, repeated the same steps with the names changed, and thanks to our thorough testing, it worked on the first try!</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-20">
<h2 id="headline-20">
Conclusion
</h2>
<div id="outline-text-headline-20">
<p>
After a week of intense research and debugging, I had rescued our data back from the brink and could again sleep soundly at night. While I appreciated the opportunity to learn more about ZFS, I can&#39;t help but think about how this entire incident <a href="https://how.complexsystems.fail/#3">could have been avoided at several key points</a> which translate directly into lessons learned:</p>
<ol>
<li>Test backups continuously so you get immediate feedback when they break.</li>
<li>Wait to make all destructive changes together at the very end instead of interspersed where they could accidentally be performed in the wrong order.</li>
<li>Always send a snapshot of the encryption root after changing the encryption key.</li>
<li>Create bookmarks before destroying snapshots.</li>
</ol>
<p>I hope that you may learn from my mistakes and avoid a similar incident. If you do happen to find yourself in a similar predicament, I&#39;d love to hear from you regardless of whether this postmortem was helpful or not. My contact details can be found <a href="https://sambowman.tech/">here</a>.</p>
<p>
Knowing what I now know about ZFS native encryption, I find it difficult to recommend until the <a href="https://github.com/openzfs/openzfs-docs/issues/494">sharp edges</a> have all been filed down. In most cases, I&#39;d prefer to encrypt the entire pool at the block device level and encrypt send streams with <a href="https://age-encryption.org/">age</a>. But if you really do need the flexibility offered by native encryption, always remember to mind the encryptionroot!</p>
</div>
</div>
      </div></div></div>
  </body>
</html>
