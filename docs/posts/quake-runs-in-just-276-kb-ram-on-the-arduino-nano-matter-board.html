<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://community.silabs.com/s/share/a5UVm000000Vi1ZMAS/quake-ported-to-arduino-nano-matter-and-sparkfun-thing-plus-matter-boards?language=en_US">Original</a>
    <h1>Quake runs in just 276 kB RAM on the Arduino Nano Matter board</h1>
    
    <div id="readability-page-1" class="page"><div data-aura-rendered-by="255:0" data-aura-class="cX7S_Theme"><header data-aura-rendered-by="257:0"><!--render facet: 258:0--><!--render facet: 352:0--></header><section data-aura-rendered-by="353:0"><!--render facet: 3:106;a--><section data-aura-rendered-by="143:106;a" data-aura-class="cX7S_Theme_Layout_Full1_1_21 siteforceContentArea"></section><section data-aura-rendered-by="146:106;a" data-aura-class="cX7S_Theme_Layout_Full1_1_21 siteforceContentArea"></section><section data-aura-rendered-by="157:106;a" data-aura-class="cX7S_Theme_Layout_Full1_1_21 siteforceContentArea"><div data-aura-rendered-by="158:106;a"><div data-aura-rendered-by="171:106;a"><div data-aura-rendered-by="163:106;a"><div data-region-name="leftColumn" data-item-id="9b0494ba-79a6-4207-8154-b0147fbd8d47" data-aura-rendered-by="65:106;a"><div data-priority="0" data-item-id="c6b6ed51-8fb4-44de-9b32-21c122c14221" data-aura-rendered-by="37:106;a"><c-x7s-news-detail data-data-rendering-service-uid="132" data-aura-rendered-by="34:106;a"><div role="region" aria-label="Quake ported to Arduino Nano Matter and Sparkfun Thing Plus Matter Boards"><c-x7s-shr-component-wrapper aria-label="main wrapper" c-x7sshrcomponentwrapper_x7sshrcomponentwrapper-host=""><div c-x7sshrcomponentwrapper_x7sshrcomponentwrapper=""><slot c-x7sshrcomponentwrapper_x7sshrcomponentwrapper="" name="header"></slot><div c-x7sshrcomponentwrapper_x7sshrcomponentwrapper=""><slot c-x7sshrcomponentwrapper_x7sshrcomponentwrapper=""><c-x7s-shr-card><c-x7s-shr-card-vertical c-x7sshrcardvertical_x7sshrcardvertical-host=""><div c-x7sshrcardvertical_x7sshrcardvertical=""><div c-x7sshrcardvertical_x7sshrcardvertical=""><div c-x7sshrcardvertical_x7sshrcardvertical=""><c-x7s-shr-card-body c-x7sshrcardvertical_x7sshrcardvertical="" c-x7sshrcardbody_x7sshrcardbody-host=""></c-x7s-shr-card-body><slot c-x7sshrcardvertical_x7sshrcardvertical=""><slot><slot><lightning-formatted-rich-text lwc-4nfn2rc40ch-host=""><span lwc-4nfn2rc40ch="" part="formatted-rich-text"><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Quake ported to EFR32MG24-based Arduino Nano Matter and Sparkfun Thing Plus Matter boards </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Introduction </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Last year, in celebration of its 30</span><span lwc-4nfn2rc40ch="">th</span><span lwc-4nfn2rc40ch=""> anniversary, we showcased the Doom port to the Sparkfun Thing Plus Matter MGM240P Board. This year we’re porting Quake to the Arduino Nano Matter Board. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">This is a great example of a project that you could make as part of our Matter Challenge! If this kind of project sounds like fun, follow the competition or submit your own entry by October 31st. The Matter Challenge sponsored by Mouser Electronics, Silicon Labs and Arduino, and is open to all skill levels. Take the opportunity to inspire others, by creating an incredible project with the Arduino Nano Matter board. Check how to enter on our community </span><a target="_blank" href="https://community.silabs.com/s/share/a5UVm000000NYDtMAO/feeling-competitive-enter-the-matter-challenge-" lwc-4nfn2rc40ch="">blog</a>.</p><p lwc-4nfn2rc40ch=""><img alt="Main Pic.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008klSM" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The port not only included all the original Doom’s features like sound and music, but it also featured BLE-based multiplayer and ran at 35 fps at the improved resolution on 320 x 240 pixels (the original resolution is 320x200 pixels).</span></p><p lwc-4nfn2rc40ch=""><img alt="Figure 1.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kjX0" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 1. Multiplayer Doom on the Sparkfun Thing Plus Matter MGM240P board </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">As its name suggests, the core of the Sparkfun Thing Plus Matter MGM240P board is the Silicon Labs MGM240P module, which is based on the EFR32MG24 System on a Chip (SoC). Besides its 2.4GHz radio, the EFR32MG24 SoC features an 80 MHz Cortex M33 core, with 1.5 MB flash and 256 kB RAM, making it an ideal choice for Matter-based applications. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Despite Doom originally required 4MB of RAM, the port showed that 256 kB of RAM were enough, not only to run the full engine, but also to handle the BLE stack and a 20% larger resolution. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">So far, Doom has been ported to a wide range of devices and microcontrollers, so we thought it was time to move on to something more challenging. We wanted to find a more complex game, requiring more RAM, featuring more impressive graphics and sound, and port it.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">After Doom, many other first-person-shooters came out, but they did not provide enough technical improvements to be called the “true successor of Doom”, despite some of them being very fun to play. Only three years after Doom, Quake came out, representing a truly technical major leap, at least as much as Doom was against Wolfstein 3D.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Quake offered a full 3D environment, allowing arbitrary map geometries, with bridges, floors over floors, sloped surfaces, and dynamic point lighting effects, for a very immersive experience. Moreover, enemies, weapons and bonuses were now 3D textured polygonal objects, in contrast to Doom, where they were just 2D sprites. Such 3D objects also featured dynamic Gouraud lighting, for more realism. On top of that, a particle engine was added for smoke trails, explosions, etc. </span></p><p lwc-4nfn2rc40ch=""><img alt="Figure 2.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kfzf" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 2. In Quake, bonuses, weapon and enemies were 3D textured objects. In Doom were 2D sprites.</em></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch=""> </em><img alt="Figure 3.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kXfX" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch=""> Figure 3. Quake featured dynamic and static lighting. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch=""> </span><img alt="Figure 4.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008ki4h" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 4. A bridge where you can walk above and below it. In Doom, that was not possible. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Unlike Doom, Quake had a scripting engine, which allowed modders to define the behavior of monsters, weapon and the world. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">These improvements did not come for free.  </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">For instance, Doom ran decently on a 486DX @33 MHz with 4 MB RAM (reaching a time-demo score of 18 fps for demo 3, according to </span><a target="_blank" href="https://thandor.net/benchmark/32" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://thandor.net/benchmark/32" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://thandor.net/benchmark/32</a></u><span lwc-4nfn2rc40ch=""> and https://www.complang.tuwien.ac.at/misc/doombench.html). </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">On the same configuration, Quake just did not run.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">By upgrading the RAM to 8MB, on the same machine Quake was running like a slide show, at 3.7 fps (see </span><a target="_blank" href="https://thandor.net/benchmark/33" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://thandor.net/benchmark/33" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://thandor.net/benchmark/33</a></u><span lwc-4nfn2rc40ch="">). To run Quake at the same average 18-fps figure and resolution a Pentium-class CPU was required.  </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">A new challenge </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">8 MB RAM? Pentium class CPU? Sounds challenging enough, especially considering we will have about 1/30 of the RAM! </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Let us summarize the goals of this new challenge: </span></p><ol lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The main goal is to run the full shareware version of Quake, i.e. supporting all the levels, including the start map for episode/skill selection. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">No additional RAM shall be externally added beside to what is provided by the microcontroller. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Since last year, a new dev board has been released, using the same MGM240 series as the Sparkfun MGM240 Matter board: the Arduino Nano Matter, which uses a MGM240S system on a package. It goes without saying we want to support both the Sparkfun and Arduino Nano Matter boards.  </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The port shall run at the original 320x200 pixel resolution with the default status bar settings (48-pixel tall).  </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Audio shall be supported, at 11025 Hz, 8 bit per sample, including static, dynamic and ambient sounds. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Graphics details of maps (i.e. geometry, number of nodes/ faces/etc etc.) and enemies shall not be reduced. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Player control shall support jump, look-up/down as well. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Enemy behavior and game logic shall be 100% implemented (monster behavior, triggers, messages, level switching, etc.). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">No additional circuitry, which offload the CPU for graphics or sound generation shall be added.  </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">All the effects such as particles, under-water warp, and moving sky with parallax shall be supported. </span></li></ol><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The following are not mandatory requirements, but “nice to have” features. </span></p><ol lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The console shall not be removed, at least to show messages from the system. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Cheats shall be available somehow. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Full demo playback support. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Save-games shall be supported, including the exact world, enemy and player states. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Settings including control remapping. </span></li></ol><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The following features, instead, are completely outside the scope of the work: </span></p><ol lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Multiplayer is outside the scope, as it would increase a lot the memory consumption. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">No music, as we are missing the CD player 😊. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">No demo recording. </span></li></ol><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Here is what is allowed in the challenge: </span></p><ol lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Any amount of external flash can be added to store the pak0.pak file (this is the Quake equivalent to Doom’s DOOM1.WAD). As the original file is 18 MB, this means we need 32 MB flash. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Any external modules, or IC which perform non-computational tasks, such as battery chargers, audio power amplifiers can be used, or keyboard support. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The pak0.pak can be modified so that the data is arranged in a way that is easier to digest or faster to load. However, in this case, no changes in graphics details are admitted. There is no limit to the final size of the pak0.pak file provided it fits in 32 MB. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The sounds effects inside pak0.pak can be resampled to 8 bits, 11025 Hz. This is actually a reduction of quality, because some samples are at 16 bits or with a rate different from 11025 Hz. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Quake is extremely CPU intensive, so any amount of overclocking is admitted. After all, during late 90’s gamers started to overclock their PCs to get better performances! </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Since we will not implement multiplayer, the radio subsystem will not be used. This leaves the sequencer and frame-rate controller 20-kB radio RAM available as general purpose RAM, as suggested in the EFR32xG24 reference manual at page 42. (</span><a target="_blank" href="https://www.silabs.com/documents/public/reference-manuals/efr32xg24-rm.pdf" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://www.silabs.com/documents/public/reference-manuals/efr32xg24-rm.pdf" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://www.silabs.com/documents/public/reference-manuals/efr32xg24-rm.pdf</a></u><span lwc-4nfn2rc40ch="">). Therefore, we have 276kB RAM instead of 256kB! </span></li></ol><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Hardware </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Two pieces of hardware are supported. The first one is last year’s board, running Doom on the Sparkfun Thing Plus Matter MGM240P board. The only change here is the flash modules: we have replaced them with 2 ICs of 16 MB each, for a total of 32 MB. </span></p><p lwc-4nfn2rc40ch=""><img alt="Figure 5.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kRJz" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 5. One of the boards we used to for Doom. After changing the flash ICs to 16 MB ones, it can now run Quake! </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The second hardware is brand new, and it is built around the Arduino Nano Matter board. With a lot of fantasy, we called named this board “The Gamepad”. In this post we will focus on this one. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">It enhances the previous design by adding 8 more pushbuttons (for a total of 16), two analog joysticks, and two Class-D audio amplifiers. </span></p><p lwc-4nfn2rc40ch=""><img alt="Figure 6.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kkxh" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 6. The Gamepad, the new board, with more pushbuttons, 2 analog thumbsticks and a gamepad-shaped size, during demo playback</em></p><p lwc-4nfn2rc40ch=""><img alt="Figure 7.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kko2" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 7. Backside of the board. All the components are either through holes, or modules which are mounted using headers. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Both boards were designed using through-hole only components, so that even beginners can easily replicate the project. The drawback is higher cost, with respect to using SMD components. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The circuit diagram of “The Gamepad” is shown below: </span></p><p lwc-4nfn2rc40ch=""><img alt="The GamePad Scheme.jpg" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008keh1" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The full KiCAD design files are available on the Github repository: </span><a target="_blank" href="https://github.com/next-hack/TheGamepadDesignFiles" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://github.com/next-hack/TheGamepadDesignFiles" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://github.com/next-hack/TheGamepadDesignFiles</a></u><span lwc-4nfn2rc40ch=""> </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Software  </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We based our port on the SDLQuake1.09 codebase (https://www.libsdl.org/projects/quake/), which is the port of WinQuake to the Simple Direct-media Layer Library: the only difference with original source are few additional files for SDL video and audio support.  </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We used this codebase so that we could easily develop, optimize and test it on a modern Windows machine. Once memory usage was down to our goal, we started porting to our hardware targets. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Challenges - Memory </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We must admit that, by comparison, porting Doom to the MG240 was child&#39;s play.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Here is a partial list of issues we faced. For a more comprehensive list, and to see how these issues were solved, you might refer to the full article on </span><a target="_blank" href="https://next-hack.com/index.php/2024/09/22/quake-port-to-sparkfun-and-arduino-nano-matter-boards-using-only-276-kb-ram/" lwc-4nfn2rc40ch="">next-hack.com</a>:</p><ul lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Quake heavily relies on stack. In particular, it uses about 64kB for underwater warping effect and about 180 kB for drawing the world model, for a total of more than 240 kB of stack. This does not even count stack usage from other functions. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">As previously mentioned, Quake introduced a C-like scripting language, QuakeC, to model the behavior of enemies, world, and weapons. These script files are compiled using the QuakeC Compiler, to produce a bytecode that runs in a virtual machine implemented in Quake. This uses more than 410 kB RAM, plus some few kB more for the virtual machine itself. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Each entity (enemies, bonuses, triggers, doors, markers, etc.) used about 800 bytes of RAM. Quake statically allocates 600 of them, for a total of 480kB RAM. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Quake used a server-client architecture, where both the server and the client are running at the same time, even during a single player game. This means that not only many additional buffers are required for server-client communication, but also the client-side must store some rendering data for each entity (180 bytes each). This means that each object in a local single player game would require just a little bit less than 1kB RAM (800+180). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">To determine whether a pixel to be drawn is on top (i.e. visible) or behind (invisible) of an already drawn one, the z-buffer is used, storing the 16-bit (reciprocal) depth of each pixel drawn on-screen. This means that you need a buffer twice as large as the number of 3D pixels. In our case, the resolution is 320x200, and the status bar is 48-pixel tall. Therefore, we need 95 kB (97280 bytes) just for this buffer. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The frame buffer required additional 64000 bytes for 320x200 resolution. 128000 bytes if one used double buffered (this time we did not). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">A 600kB buffer is used for surface cache, where recently drawn surfaces are stored. This allows skipping static+dynamic lighting calculation of every surface each frame, greatly improving speed. Cache miss is relatively rare, because player’s movements are relatively small, the cache size is large, and dynamic lights are not so frequent. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Skies are implemented as 2 layers of 128x128 pixels, moving one on top of a partially transparent one. For this, Quake uses 48 kB of RAM (the two single layers plus the rendered one). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">3D models are loaded into RAM. Unfortunately, their data is not used as is (that would allow to use flash for them, without modifications), and some sort of elaboration is required. Furthermore, even after such elaboration, part of the model data is still not constant, e.g. for dynamic lighting or to keep track if a surface/node/leaf was “visited” by the rendering engine. </span></li></ul><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">This meant that a lot of RAM was required, even if we put/kept everything which is constant in internal/external Flash. In fact, just be summing the memory amounts cited above, one gets around 1.4 MB. This figure does not even consider everything else such as sound channel data and buffers, server-client buffers, console buffer, key buffers, console variables, console commands, particle data, and, above all, model data, which might increase total usage by some more MBs.  </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">“Simple” memory optimizations as we did in Doom were not enough, and we describe with more details what we have done in the article in </span><a target="_blank" href="https://next-hack.com/index.php/2024/09/22/quake-port-to-sparkfun-and-arduino-nano-matter-boards-using-only-276-kb-ram/" lwc-4nfn2rc40ch="">next-hack.com</a><span lwc-4nfn2rc40ch="">. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Challenges – Speed </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">In a PC or in other Quake ports, all the data is available from RAM (if not even from the CPU data cache), which had a relatively high bandwidth and low latency even back to 1996. In fact, the bandwidth for sequential reads varied a lot but with a 40 MHz EDO 64-bit DRAM (already available on 1996) one could get a maximum throughput of 320 MB/s. The latency for random-reads was in the </span><a target="_blank" href="https://community.silabs.com/s/(https://www.alldatasheet.com/view.jsp?Searchword=MT4C4007-6S&amp;q=MT4C4007-6)." lwc-4nfn2rc40ch="">110 - 130ns range</a><span lwc-4nfn2rc40ch="">.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">In our case, we have only 276 kB RAM and 1.5 MB flash. Our chip features a relatively large instruction cache, but no data cache. Data read from internal flash always incurs into at least one wait-state penalty. This penalty might increase in case of unaligned access. The top speed for sequential data read is around 181 MB/s with overclocking, and only a limited amount of data can be stored on the internal flash, so we had to privilege geometry data (vertex coordinates, BSP tree, etc.). Everything else, including textures and sound, is loaded externally from the two SPI flash ICs, which have a reduced bandwidth (17 MB/s peak, combined) and above all, very high latency (in the low microseconds range). </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Furthermore, in this port, we cannot use double buffering (like we did for Doom instead) because it would take too much memory. This reduces performance, because we have to wait the for the DMA to have sent the n-th row, before we can modify it. Also, we had not RAM for the surface cache, so we had to compute texture lighting on the fly. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">To partially solve these issues, we overclocked the MCU. We found the MGM240 runs fine at over 136 MHz (it can go even faster, but we kept some safety margin to account for sample-sample variation). Overclocking is of course discouraged by Silicon labs (generally by all IC manufacturers), but this is not a security or life-support application, it is just a game. MCU overclocking is also quite common in hobby or hacking projects (for instance, in the RP2040 Doom port, Kilograham overclocked the dual-core Cortex M0+ from 133 to 270 MHz).</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Overclocking gave us 1.7x performance increase, but we were very far from getting a playable game: the frame rate was between 7 and 10 fps.   </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We needed some optimization strategies. Among them we cite: </span></p><ul lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Reducing external flash accesses by implementing a texture cache buffer, after sorting surfaces by texture. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Implementing asynchronous DMA load of the next texture, while the CPU is rendering the current surface with the previously loaded one (we used a similar approach in the past Doom port, but in that case was column-based. The performance increase in Quake is much more dramatic). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">When rendering enemies/weapons, we used sequential SPI reads when a large amount of data is expected to be used (close objects), and random data read when few pixels will be drawn (far objects). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Implementation in assembly of some functions (e.g. bilinear interpolation for surface drawing).  </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Partial screen refresh: when the status bar does not need to be refreshed, we skip rendering and sending it to the display. Noticeably, this feature has also been backported to our Doom port, which can now reach 35 fps even at 320x240 pixels. </span></li></ul><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">With such improvements, the frame rate jumped by a factor of 2.5-4.5 (4.25 - 7.7 if we consider the non-overclocked solution). In fact, the frame rate is now between 17.7 and 45.6 fps (the timedemo for demo3 has a score of 28.0 fps, with audio). </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Additional tools </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">For this port, we had to develop 4 more tools, with different functions: </span></p><ul lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Constant tables generation (e.g. sine, and other data). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Conversion between Quake C and standard C. This was implemented by modifying the Quake C compiler from Id Software. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Generation of getters-setters for entities, so that each one uses much less RAM. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Quake Pak converter, that optimizes quake data for rendering.  </span></li></ul><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">All of the four are implemented as Windows console applications, using Code::Blocks. We have included the source of all of them in the Github repo, but a serious cleanup is necessary. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Among the four of them, to play Quake you MUST use Quake Pak converter, to convert the shareware pak0.pak file. The converted file must be renamed to pak0.pak and put into a micro-SD card, to be uploaded to the external flash, following the on-screen instructions. The other 3 tools are included just for reference. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The port in action! </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">You can see the port running with our full video on </span><a target="_blank" href="https://get.silabs.com/youtube-quake-arduino" lwc-4nfn2rc40ch="">YouTube</a><span lwc-4nfn2rc40ch="">! </span></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 8.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kX1F" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 8. The first frames of the demo 3. Demo playback is fully implemented. </em></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 9.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kkhZ" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 9. The console is implemented and can be activated from the options menu. Here we inserted “showfps 1” as a cheat, to enable printing the instantaneous frame rate on the bottom left part of the screen.</em></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 10.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kSWB" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 10. Start map, this is the episode selection room. Only the first episode is supported. </em></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 11.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kgm2" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 11. First level. The framerate varies a lot, but the initial value is 27. </em></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 12.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kUbD" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 12. In small rooms, the frame rate exceeds 30 fps. </em></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 13.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kdHw" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 13. In open areas, the frame rate drops (in this case to 20.8 fps). </em></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 14.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kkb7" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 14. The frame rate again exceeds 30 fps in some cases. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Previous ports and Performance Comparison </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Beside the plethora of ports/enhancements of Quake to PC/MAC, there are a few previous ports on Quake on microcontrollers. For instance: </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">1) Port to RISC-V: </span><a target="_blank" href="https://www.elektormagazine.com/articles/start-playfully-with-riscv" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://www.elektormagazine.com/articles/start-playfully-with-riscv" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://www.elektormagazine.com/articles/start-playfully-with-riscv</a></u><span lwc-4nfn2rc40ch=""> </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">2) Port to a Cortex M7 MCU: </span><a target="_blank" href="https://github.com/FantomJAC/quakembd" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://github.com/FantomJAC/quakembd" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://github.com/FantomJAC/quakembd</a></u><span lwc-4nfn2rc40ch=""> </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">In these systems, however, the available RAM was at least 8MB, and the CPUs was extremely powerful (a dual-core 400 MHz RISC-V and a 480 MHz superscalar Cortex M7), so the effort was probably just focused on the hardware abstraction layer, without having to radically modify the source. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">By looking at the videos of these ports, we see Quake running very fast. This is expected, due to the large amount of RAM and availability of computing power. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Instead, a much more impressive work was done on the GBA: </span><a target="_blank" href="https://www.xda-developers.com/how-quake-ported-game-boy-advance/" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://www.xda-developers.com/how-quake-ported-game-boy-advance/" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://www.xda-developers.com/how-quake-ported-game-boy-advance/</a></u><span lwc-4nfn2rc40ch=""> by Randy Linden.  </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Despite running much slower, and with a resolution of only 120x160 pixels (GBA’s original resolution is 240x160, but in the port each 3D pixel is made of 2 horizontal pixels), the programmer was able to partially run Quake with only 384 kB of RAM and a mere 16.7 MHz ARM 7TDMI. The performance Randy was able to achieve by writing hundreds of thousands of line of optimized assembly code is simply astonishing. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">From the article and video embedded therein, we understand that the Quake port still lacks the following: (note that we are referring to the Quake port, and not on the derivative Cyboid, which is also shown in the article and video, and features some improvements) </span></p><ul lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Enemy AI: they will react only if you shoot at them. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Audio seems to be missing, even though the article mentions about sound and music. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Level switching is manual. This is confirmed also by looking when the player enters the level teleport of E1M1, and the map does not change. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">By looking at the video and still images, it seems to us that bilinear interpolation for static lighting is not present. It looks like that the feature was added in Cyboid. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">It is unclear if all the game logic is there (we see some text popping up, and the elevators working, though). </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Console is not shown, as well as demos, so we think these were probably not implemented. </span></li></ul><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 15.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008khv0" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 15. Frame from Modern Vintage Gamer&#39;s </em><a target="_blank" href="https://community.silabs.com/s/(https://www.youtube.com/watch?v=R43k-p9XdIk)" lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">video</em></a><em lwc-4nfn2rc40ch="">, showing the initial frame rate of 9.5 fps (the frame rate is multiplied by 10 and plotted next to the armor). The resolution is only 120x160 because each pixel is doubled horizontally, and the lighting is lacking bilinear interpolation, however despite these limitation, achieving such speed on a 16.7 MHz ARM7TDMI is very impressive. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">An apple-by-apple comparison is hard. With respect to the GBA port, ours runs faster, but the latter runs on a much slower system. Still the GBA port has a much smaller resolution, has about 40% more RAM, and does not implement all the Quake features.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">On the other hand, the RISC-V port cited above runs much faster than ours (the </span><a target="_blank" href="https://www.youtube.com/watch?v=poBBrIWt_HE," lwc-4nfn2rc40ch="">video</a><span lwc-4nfn2rc40ch=""> shows between 30 and 75 fps), but the device has 8MB RAM and a dual core 400 MHz RISC-V (we suppose only one core is used, though). Having such large memory means that surface cache can be implemented, and probably a 400 MHz RISC-V is between 2 and 3 times faster than our overclocked MCU. The same applies to the Cortex M7 port.</span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">What about a regular PC? Our timedemo score is 28.0 fps, which is faster than a 100-MHz Pentium (26.7 fps), and still better than a 6x86MX PR200 (27.4 fps). However, our score was achieved with sound, whereas the benchmarks reported in </span><a target="_blank" href="https://thandor.net/benchmark/33" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://thandor.net/benchmark/33" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://thandor.net/benchmark/33</a></u><span lwc-4nfn2rc40ch=""> are taken with the -nosound switch.</span></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 16.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kiZK" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 16. Part of the benchmark result table reported in </em><a target="_blank" href="https://thandor.net/benchmark/33" lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></em></a><em lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""><a href="https://thandor.net/benchmark/33" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://thandor.net/benchmark/33</a></u></em><em lwc-4nfn2rc40ch="">. Our 28.0 fps score is better than a Pentium 100 and 6x86MX PR200, but we are still far from a Pentium 120 or a 6x86MX PR233. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">As you might see from the linked video, during the gameplay the frame rate sometimes falls below 20 fps, but for the majority of the time it is well above this threshold, reaching also very high peaks exceeding 30 fps. The actual frame rate you get depends on many factors, such as the level and scene complexity (i.e. number of drawn surfaces), the number of visible objects, particles, and even the number of concurrent active audio channels. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We think that the lack of enough RAM memory, which does not allow us from using the original surface caching system, as well as forces us to load all the graphics from external flash every frame, is what is preventing us from reaching even higher framerate. Furthermore, the benchmarks in </span><a target="_blank" href="https://thandor.net/benchmark/33" lwc-4nfn2rc40ch=""><u lwc-4nfn2rc40ch=""></u></a><u lwc-4nfn2rc40ch=""><a href="https://thandor.net/benchmark/33" target="_blank" rel="noopener" lwc-4nfn2rc40ch="">https://thandor.net/benchmark/33</a></u><span lwc-4nfn2rc40ch=""> are probably taken with the code featuring assembly routines, which are, according to John Carmack, twice as fast as the C code (https://github.com/id-Software/Quake). </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Conclusions </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We think we have met and exceeded all the requirements, including “nice-to-have” ones: </span></p><ul lwc-4nfn2rc40ch=""><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The full graphics engine is implemented: static/dynamic lighting, enemy/weapon Gouraud shading, mip mapping, turbulent surfaces, moving skies, underwater warp effect, particles, etc. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Sounds are supported as well, including static, dynamic and ambient sounds effects with position dependence. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">All the shareware levels are supported, with the full game logic and enemy behavior, including the final episode 1 monster Chthon. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">The console was kept. You can enter it through the options menu. Yes, we removed the huge 16-screen history, which makes little sense for regular gameplay. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Even cheats are supported, and they can be entered using the console and pressing up / down buttons and then fire.  </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Save games are supported as well, and the exact state can be saved and loaded back. </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Demo playback is supported too.  </span></li><li lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Controls can be remapped and settings are automatically saved.  </span></li></ul><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 17.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kmZh" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 17. The menu system is implemented, and settings are saved to the external flash. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">To our knowledge, this is the Quake port that uses the smallest amount of RAM so far. Quake is running at an enjoyable speed (we benchmarked about 27 fps on average, even though the actual average depends on the scene complexity and might be higher or lower on a match-by-match basis) using only 276kB RAM, in a system costing just a fraction of what you needed back in 1996. </span></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 18.png" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008kmQ1" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><em lwc-4nfn2rc40ch="">Figure 18. On average, the framerate allows for a very enjoyable gameplay. </em></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">We think that there is still room for more optimization, to increase speed and probably, with larger flash, to support the full retail version of the game. </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Does it run Doom? </span></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch="">Ah, yes, the Arduino Nano Matter board does also run Doom. With multiplayer over BLE, at full speed! </span></p><p lwc-4nfn2rc40ch=""><img title="next-hack.com" alt="Figure 19.jpg" src="https://community.silabs.com/servlet/rtaImage?eid=a5UVm000000Vi1Z&amp;feoid=00N1M00000FHepX&amp;refid=0EMVm000008keVl" lwc-4nfn2rc40ch=""/></p><p lwc-4nfn2rc40ch=""><span lwc-4nfn2rc40ch=""> </span><em lwc-4nfn2rc40ch="">Figure 19. Two samples running Doom. The right one is battery powered. </em></p></span></lightning-formatted-rich-text></slot></slot></slot></div></div></div></c-x7s-shr-card-vertical></c-x7s-shr-card></slot></div></div></c-x7s-shr-component-wrapper></div></c-x7s-news-detail></div><div data-priority="0" data-item-id="3877c1fc-5696-46ba-b410-6d0158f69d48" data-aura-rendered-by="62:106;a"><div data-aura-rendered-by="57:106;a" data-aura-class="forceCommunityForceCommunityFeed"><!--render facet: 58:106;a--><!--render facet: 3:139;a--><!--render facet: 5:139;a--><div role="region" aria-label="Feed" data-aura-rendered-by="7:139;a" data-aura-class="forceChatterFeed"><div data-aura-rendered-by="81:204;a" data-aura-class="forceChatterStyle--default forceChatterStyle"><!--render facet: 4:204;a--><!--render facet: 7:204;a--><!--render facet: 9:204;a--><!--render facet: 11:204;a--><div data-aura-rendered-by="13:204;a" data-aura-class="forceChatterFeedInner" id="5:204;a"><!--render facet: 70:204;a--><div data-aura-rendered-by="71:204;a" data-aura-class="forceChatterScroller"><!--render facet: 21:204;a--><!--render facet: 68:204;a--><div data-aura-rendered-by="75:204;a"><!--render facet: 23:204;a--><!--render facet: 40:204;a--><!--render facet: 41:204;a--><div data-aura-rendered-by="42:204;a"><p>Skip Feed</p><!--render facet: 49:204;a--><p><span data-aura-rendered-by="54:204;a"><feeds_placeholding-empty-feed data-data-rendering-service-uid="169" data-aura-rendered-by="56:204;a" lwc-8pb6retlrl-host=""><figure lwc-8pb6retlrl=""><img alt="" lwc-8pb6retlrl="" src="https://community.silabs.com/img/chatter/OpenRoad.svg"/><figcaption lwc-8pb6retlrl="" role="status"><h3 lwc-8pb6retlrl="">Nothing here yet?</h3><p lwc-8pb6retlrl="">Log in to post to this feed.</p></figcaption></figure></feeds_placeholding-empty-feed></span></p><p>End of Feed</p></div><div role="status" data-aura-rendered-by="60:204;a"><p>Nothing here yet?Log in to post to this feed.</p></div><!--render facet: 77:204;a--></div><!--render facet: 78:204;a--><!--render facet: 79:204;a--></div></div></div></div></div></div></div></div></div></div></section><section data-aura-rendered-by="173:106;a" data-aura-class="cX7S_Theme_Layout_Full1_1_21 siteforceContentArea"></section></section></div></div>
  </body>
</html>
