<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fasterthanli.me/articles/profiling-linkers">Original</a>
    <h1>Profiling Linkers</h1>
    
    <div id="readability-page-1" class="page"><div>
  

  <p>In the wake of <a href="https://fasterthanli.me/articles/why-is-my-rust-build-so-slow">Why is my Rust build so
slow?</a>, developers from the <code>mold</code> and
<code>lld</code> linkers <a href="https://www.reddit.com/r/fasterthanlime/comments/rserc5/why_is_my_rust_build_so_slow/">reached
out</a>,
wondering why using their linker didn&#39;t make a big difference.</p>
<p>Of course the answer was &#34;there&#39;s just not that much linking to do&#34;, and so any
difference between <code>mold</code> and <code>lld</code> was within a second. GNU ld was lagging way
behind, at four seconds or so.</p>
<p>But in their quest for linker performance (I love that this is a thing, by the
way), they told me how to profile them!</p>
<h2>Profiling mold</h2>
<p>The way I usually run mold is simply by wrapping the <code>cargo</code> invocation with
<code>mold -run</code>:</p>
<pre><p>Shell session</p><p><code>$ mold -run cargo build
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished dev [unoptimized + debuginfo] target(s) in 1.74s
</code></p></pre>
<p>I can then verify that it&#39;s actually been built with <code>mold</code> by reading ELF
comment sections with <code>readelf</code>:</p>
<pre><p>Shell session</p><p><code>$ readelf -p .comment target/debug/salvage 

String dump of section &#39;.comment&#39;:
  [     0]  GCC: (GNU) 11.2.1 20211203 (Red Hat 11.2.1-7)
  [    2e]  mold 1.0.0 (ed9924895d9b9584106791247596677db8113528; compatible with GNU ld and GNU gold)
  [    89]  GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0
  [    b3]  clang version 12.0.1
</code></p></pre>
<p><code>mold</code>&#39;s profiling option is <code>-perf</code>, but I couldn&#39;t find a way to use it in
conjunction with <code>-run</code>, so, I did the next best thing: a wrapper script.</p>
<p>In <code>~/mold-wrapper</code>, I put:</p>
<pre><p>Bash</p><p><code><i>#!/bin/bash</i>
<i>mold</i> <i>-perf</i> <i>&#34;<i>$</i>@&#34;</i> 2&gt;&amp;1 <i>&gt;&gt;</i> /tmp/mold-log.txt
</code></p></pre>
<p>Here, <code>&#34;$@&#34;</code> forwards all arguments from our script to mold. <code>2&gt;&amp;1</code> redirects
input from standard error (<code>stderr</code>, file descriptor 2), to standard output
(<code>stdout</code>, file descriptor 1), and then we append (<code>&gt;&gt;</code>) to a file at
<code>/tmp/mold-log.txt</code>.</p>
<p>Since it didn&#39;t make a big difference for <code>futile</code>, I&#39;ll try it on another
project of mine, salvage. Let&#39;s also try release builds instead of debug builds!</p>
<p>First with GNU ld:</p>
<pre><p>TOML markup</p><p><code><i># in `.cargo/config.toml`</i>

<i>[</i><i>target</i><i>.</i><i>x86_64-unknown-linux-gnu</i><i>]</i>
<i># use the default linker: here it&#39;s GNU ld</i>
<i>rustflags</i> <i>=</i> <i>[</i><i>]</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo build --release
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 6.99s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 7.04s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 6.91s
</code></p></pre>
<p>Okay, so 7 seconds is our baseline.</p>
<p>Now with mold-wrapper:</p>
<pre><p>TOML markup</p><p><code><i># in `.cargo/config.toml`</i>

<i>[</i><i>target</i><i>.</i><i>x86_64-unknown-linux-gnu</i><i>]</i>
<i>rustflags</i> <i>=</i> <i>[</i>
    <i>&#34;-C&#34;</i><i>,</i> <i>&#34;link-arg=-fuse-ld=/home/amos/mold-wrapper&#34;</i><i>,</i>
<i>]</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo build
(cut)
  = note: cc: error: unrecognized command-line option &#39;-fuse-ld=/home/amos/mold-wrapper&#39;
</code></p></pre>
<p>Ah. Well... &#34;linker&#34; can mean many things. When running executables, a dynamic
linker is involved, like we discussed in <a href="https://fasterthanli.me/series/making-our-own-executable-packer">making our own executable
packer</a>.</p>
<p>Here it&#39;s definitely a &#34;build-time linker&#34;, but really there&#39;s, I think: a
linker driver, and the actual linker. The linker driver, by default here, is
<code>cc</code>, which is provided by GCC. It accepts the <code>-fuse-ld=flabazorp</code> option to
use the <code>flabazorp</code> linker.</p>
<p>Except GCC has an allowlist of values it&#39;ll accept for <code>-fuse-ld</code>. If we use
<code>clang</code> as a linker driver, however, we can specify a path to whichever linker
we want, even our wrapper script:</p>
<pre><p>TOML markup</p><p><code><i># in `.cargo/config.toml`</i>

<i>[</i><i>target</i><i>.</i><i>x86_64-unknown-linux-gnu</i><i>]</i>
<i>linker</i> <i>=</i> <i>&#34;clang&#34;</i>
<i>rustflags</i> <i>=</i> <i>[</i>
    <i>&#34;-C&#34;</i><i>,</i> <i>&#34;link-arg=-fuse-ld=/home/amos/mold-wrapper&#34;</i><i>,</i>
<i>]</i>
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo build --release
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 5.17s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 5.12s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 5.10s
</code></p></pre>
<p>Okay, we&#39;re closer to 5 seconds - almost 2 seconds faster!</p>
<p>Let&#39;s look at what we have in <code>/tmp/mold-log.txt</code>:</p>
<pre><p><code>     User   System     Real  Name
    0.800    5.360    0.392  all
    0.171    0.515    0.177    read_input_files
    0.068    2.334    0.101    register_section_pieces
    0.564    2.512    0.114    total
    0.380    0.102    0.021      before_copy
    0.000    0.000    0.000        apply_exclude_libs
    0.062    0.000    0.002        resolve_obj_symbols
    0.000    0.000    0.000        eliminate_comdats
    0.003    0.002    0.000        convert_common_symbols
    0.000    0.000    0.000        apply_version_script
    0.000    0.000    0.000        compute_import_export
    0.113    0.050    0.006        gc
    0.005    0.015    0.001          mark_nonalloc_fragments
    0.037    0.028    0.002          collect_root_set
    0.066    0.000    0.002          mark
    0.005    0.007    0.001          sweep
    0.103    0.003    0.004        compute_merged_section_sizes
    0.098    0.003    0.004          MergedSection assign_offsets
    0.002    0.015    0.001        bin_sections
    0.000    0.002    0.001        claim_unresolved_symbols
    0.003    0.020    0.000        check_dup_syms
    0.000    0.000    0.000        sort_init_fini
    0.002    0.004    0.001        compute_section_sizes
    0.064    0.002    0.003        scan_rels
    0.000    0.000    0.000        DynsymSection::finalize
    0.000    0.000    0.000        fill_verdef
    0.000    0.001    0.000        fill_verneed
    0.022    0.000    0.001        compute_symtab
    0.005    0.001    0.001        eh_frame
    0.000    0.000    0.000        osec_offset
    0.000    0.001    0.001      open_file
    0.184    2.407    0.091      copy
    0.102    2.400    0.084        copy_buf
    0.000    0.000    0.000          (header)
    0.000    0.000    0.000          .fini_array
    0.000    0.000    0.000          (header)
    0.000    0.000    0.000          .interp
    0.000    0.000    0.000          .note.gnu.build-id
    0.088    2.073    0.070          .debug_line
    0.000    0.000    0.000          .note.ABI-tag
    0.000    0.000    0.000          .rela.dyn
    0.000    0.002    0.000          .init_array
    0.000    0.000    0.000          .strtab
    0.006    0.125    0.004          .data
    0.000    0.000    0.000          .shstrtab
    0.100    2.399    0.082          .debug_str
    0.000    0.000    0.000          .got.plt
    0.000    0.000    0.000          .rela.plt
    0.007    0.145    0.005          .debug_abbrev
    0.064    1.271    0.044          .symtab
    0.000    0.000    0.000          .debug_frame
    0.089    2.291    0.076          .debug_info
    0.000    0.000    0.000          .gnu.build.attributes.startup
    0.000    0.001    0.000          .gnu.build.attributes.exit
    0.102    2.399    0.084          .debug_pubnames
    0.000    0.001    0.000          .dynsym
    0.000    0.000    0.000          .bss
    0.000    0.000    0.000          .comment
    0.055    1.133    0.038          .debug_aranges
    0.000    0.000    0.000          .common
    0.014    0.423    0.015          .gcc_except_table
    0.000    0.000    0.000          .gnu.build.attributes
    0.000    0.000    0.000          .tm_clone_table
    0.097    2.394    0.080          .debug_ranges
    0.000    0.002    0.000          .fini
    0.000    0.001    0.000          .rodata.str
    0.000    0.000    0.000          .tbss
    0.006    0.125    0.005          .debug_rnglists
    0.002    0.089    0.003          .got
    0.000    0.000    0.000          .note.stapsdt
    0.000    0.001    0.000          .gnu.hash
    0.000    0.000    0.000          .gnu.build.attributes.unlikely
    0.000    0.000    0.000          (header)
    0.000    0.001    0.000          .debug_loc
    0.084    1.893    0.063          .debug_loclists
    0.000    0.002    0.000          .debug_line_str
    0.000    0.000    0.000          .gnu.build.attributes.hot
    0.000    0.001    0.000          .dynstr
    0.000    0.001    0.000          .gnu.version
    0.015    0.519    0.017          .rodata.str
    0.000    0.000    0.000          .dynamic
    0.035    0.847    0.028          .eh_frame
    0.064    1.271    0.044          .data.rel.ro
    0.000    0.000    0.000          .gnu.version_r
    0.000    0.000    0.000          .debug_gdb_scripts
    0.000    0.000    0.000          .init
    0.096    2.390    0.080          .text
    0.000    0.000    0.000          .tdata
    0.001    0.023    0.002          .debug_pubtypes
    0.000    0.000    0.000          .plt
    0.000    0.000    0.000          .plt.got
    0.086    1.972    0.066          .rodata
    0.015    0.188    0.006          .eh_frame_hdr
    0.000    0.004    0.000          .rodata
    0.000    0.021    0.001          .rodata.cst
    0.002    0.007    0.001        sort_dynamic_relocs
    0.000    0.000    0.000        clear_padding
    0.080    0.001    0.007        build_id
    0.000    0.001    0.001      close_file
</code></p></pre>
<p><code>mold</code> is self-reporting a &#34;real&#34; run-time of 392 milliseconds here. That&#39;s
pretty fast! Nothing particular jumps out to me — but if there was some pass
that seemed slow, I&#39;d know where to <a href="https://github.com/rui314/mold/issues">file an issue</a>.</p>
<h2>Profiling lld</h2>
<p>Now let&#39;s try <code>lld</code>!</p>
<p>I made another wrapper script, in <code>/home/amos/ld.lld-wrapper</code>:</p>
<pre><p>Bash</p><p><code><i>#!/bin/bash</i>
<i>ld.lld</i> <i>--time-trace</i> <i>--time-trace-file=/tmp/lld.time-trace.json</i> <i>&#34;<i>$</i>@&#34;</i>
</code></p></pre>
<p>Let&#39;s do a few hot builds:</p>
<pre><p>Shell session</p><p><code>$ cargo build --release
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 5.27s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 5.26s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 5.19s
</code></p></pre>
<p>Not too bad! Here&#39;s how different linkers compared:</p>
<p><img src="https://fasterthanli.me/content/articles/profiling-linkers/assets/salvage-build-times.0d965e2d13c360a4.svg" alt="" loading="lazy"/></p><p>(Note that this is <em>full build time</em>, not just link-time).</p>
<p>The lld maintainers suggested using <a href="https://stedolan.github.io/jq/">jq</a> to
report those metrics:</p>
<pre><p>Shell session</p><p><code>$ cat /tmp/lld.time-trace.json | jq -r &#39;.traceEvents[] | select(.name|contains(&#34;Total&#34;)) | &#34;\(.dur/1000000) \(.name)&#34;&#39;
0.449559 Total ExecuteLinker
0.445119 Total Link
0.193442 Total Write output file
0.074866 Total Parse input files
0.061933 Total Merge/finalize input sections
0.028164 Total Split sections
0.023066 Total markLive
0.022392 Total Scan relocations
0.009324 Total Assign sections
0.007581 Total Add local symbols
0.005941 Total Finalize synthetic sections
0.004179 Total Load input files
0.004127 Total Finalize .eh_frame
0.003314 Total Process symbol versions
0.003111 Total Add symbols to symtabs
0.00283 Total LTO
0.002436 Total Finalize address dependent content
0.001592 Total Aggregate sections
0.001035 Total Combine EH sections
0.000874 Total Locate library
0.000826 Total Strip sections
0.000807 Total Redirect symbols
0.000448 Total Demote shared symbols
0.00033 Total Replace common symbols
0.00031 Total Sort sections
0.000134 Total Create output files
0.000124 Total Read linker script
0 Total Resolve SHF_LINK_ORDER
0 Total Diagnose orphan sections
</code></p></pre>
<p>And:</p>
<pre><p>Shell session</p><p><code>$ cat /tmp/lld.time-trace.json | jq -r &#39;.traceEvents[] | select(.name|contains(&#34;Write&#34;)) | &#34;\(.dur/1000000) \(.name)&#34;&#39;
0.193442 Write output file
0.193442 Total Write output file
</code></p></pre><div>

<p>Hey that&#39;s a useless use of cat!</p>
</div>
<div>

<p>It is! Gotta let redditors comment <em>something</em> about our otherwise perfect articles.</p>
</div>
<p>Here nothing jumps out either: lld self-reports 449 milliseconds, about 60
milliseconds more than mold.</p>
<h2>What about LTO?</h2>
<p>Let&#39;s profile link-time optimization too! We&#39;ll omit <code>mold</code> from these
measurements, since it <a href="https://github.com/rui314/mold/issues/181">doesn&#39;t support
LTO</a> at the time of this writing.</p>
<pre><p>TOML markup</p><p><code><i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>lto</i> <i>=</i> <i>&#34;fat&#34;</i>
<i>debug</i> <i>=</i> 1
</code></p></pre>
<p>Let&#39;s try with GNU ld:</p>
<pre><p>Shell session</p><p><code>$ cargo build --release
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 1m10s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 1m10s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 1m10s
</code></p></pre>

<p>Now &#34;fat&#34; LTO with <code>lld</code>:</p>
<pre><p>Shell session</p><p><code>$ cargo build --release
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 1m10s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 1m09s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 1m10s
</code></p></pre><div>

<p>I&#39;m starting to think maybe GNU ld wasn&#39;t involved at all there...</p>
</div>
<div>

<p>Yeah, me too. Rust LTO seems LLVM-specific, so I wonder if it&#39;s even using GNU
ld at all.</p>
</div>
<p>Let&#39;s look at the timings:</p>
<pre><p>Shell session</p><p><code>$ cat /tmp/lld.time-trace.json | jq -r &#39;.traceEvents[] | select(.name|contains(&#34;Total&#34;)) | &#34;\(.dur/1000000) \(.name)&#34;&#39;
0.242555 Total ExecuteLinker
0.239797 Total Link
0.131408 Total Write output file
0.037888 Total Merge/finalize input sections
0.021132 Total Parse input files
0.016607 Total Scan relocations
0.01026 Total markLive
0.007482 Total Split sections
0.004815 Total Add local symbols
0.003422 Total Assign sections
0.002502 Total Load input files
0.002039 Total Finalize synthetic sections
0.001379 Total Finalize .eh_frame
0.001058 Total Finalize address dependent content
0.000891 Total Locate library
0.000878 Total Add symbols to symtabs
0.000505 Total Aggregate sections
0.000359 Total LTO
0.000336 Total Process symbol versions
0.000221 Total Strip sections
0.000212 Total Combine EH sections
0.000203 Total Redirect symbols
0.000188 Total Sort sections
0.000125 Total Create output files
0.000121 Total Read linker script
9.5e-05 Total Demote shared symbols
5.7e-05 Total Replace common symbols
0 Total Resolve SHF_LINK_ORDER
0 Total Diagnose orphan sections
</code></p></pre><div>

<p>Well that can&#39;t be right.</p>
</div>
<div>

<p>Mhh no, it doesn&#39;t look right at all. I would expect some of those values
to be much higher.</p>
</div>
<div>

<p>I&#39;m sure someone will point out what we&#39;re doing wrong!</p>
</div>
<p>Finally, let&#39;s try thin LTO:</p>
<pre><p>TOML markup</p><p><code>
<i>[</i><i>profile</i><i>.</i><i>release</i><i>]</i>
<i>lto</i> <i>=</i> <i>&#34;thin&#34;</i>
<i>debug</i> <i>=</i> 1
</code></p></pre><pre><p>Shell session</p><p><code>$ cargo build --release
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 14.55s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 14.73s
$ # (change main.rs)
$ cargo build --release
   Compiling salvage v1.4.0 (/home/amos/bearcove/salvage)
    Finished release [optimized + debuginfo] target(s) in 14.95
</code></p></pre>
<p>And here&#39;s the timings:</p>
<pre><p>Shell session</p><p><code>$ cat /tmp/lld.time-trace.json | jq -r &#39;.traceEvents[] | select(.name|contains(&#34;Total&#34;)) | &#34;\(.dur/1000000) \(.name)&#34;&#39;
0.388797 Total ExecuteLinker
0.369694 Total Link
0.175247 Total Write output file
0.059522 Total Merge/finalize input sections
0.043918 Total Parse input files
0.02205 Total Split sections
0.020696 Total Scan relocations
0.018724 Total Load input files
0.017484 Total markLive
0.007214 Total Assign sections
0.006661 Total Add local symbols
0.004376 Total Finalize synthetic sections
0.002845 Total Finalize .eh_frame
0.002703 Total Add symbols to symtabs
0.001943 Total Finalize address dependent content
0.001889 Total Process symbol versions
0.001439 Total LTO
0.001075 Total Aggregate sections
0.001072 Total Locate library
0.00069 Total Combine EH sections
0.000504 Total Strip sections
0.000459 Total Redirect symbols
0.000282 Total Sort sections
0.000273 Total Demote shared symbols
0.000162 Total Replace common symbols
0.000145 Total Read linker script
0.000111 Total Create output files
0 Total Resolve SHF_LINK_ORDER
0 Total Diagnose orphan sections
</code></p></pre>
<p>Again, those are fishy. I&#39;m either not measuring the right thing, or the work is
being done elsewhere.</p>
<p>Finally, here&#39;s the comparison:</p>
<p><img src="https://fasterthanli.me/content/articles/profiling-linkers/assets/salvage-build-times-lto.65b9c7c4b2695960.svg" alt="" loading="lazy"/></p><p>Happy profiling!</p>

</div><div>
  
    
    
      <p>
    This article was made possible thanks to my patrons:
    Alexander Payne, Fredrik Østrem, David Barsky, Yufan Lou, Stephen Molyneaux,
Barret Rennie, Thomas Corbin, MW, Jacob Cheriathundam, Michael Watzko, Embark
Studios, Eugene Bulkin, Marcus Griep, Petar Radosevic, Tool Army, Tully,
Santiago Lema, Spencer Gilbert, Jörn Huxhorn, Garrett Ward, DEX, Christian
Oudard, Ronen Cohen, Thor Kamphefner, Kamran Khan, Cole Kurkowski, Arjen
Laarhoven, Vicente Bosch, Chirag Jain, Ville Mattila, Marie Janssen, Vladyslav
Batyrenko, Cameron Clausen, spike grobstein, Jon Gjengset, Paul Marques Mota,
Jakub Fijałkowski, Mitchell Hamilton, Brad Luyster, Max von Forell, Jake S,
Dimitri Merejkowsky, Chris Biscardi, René Ribaud, Alex Doroshenko, Vincent,
Steven McGuire, Chad Birch, Chris Emery, Bob Ippolito, John Van Enk, metabaron,
Isak Sunde Singh, Philipp Gniewosz, Mads Johansen, lukvol, Ives van Hoorne, Jan
De Landtsheer, Daniel Strittmatter, Evgeniy Dubovskoy, Alex Rudy, Shane Lillie,
Romet Tagobert, Douglas Creager, Corey Alexander, Molly Howell, knutwalker,
Zachary Dremann, Sebastian Ziebell, Julien Roncaglia, Amber Kowalski, T,
queenfartbutt, Paul Kline, Kristoffer Ström, Astrid Bek, Yoh Deadfall, Justin
Ossevoort, Tomáš Duda, Jeremy Banks, Rasmus Larsen, Torben Clasen, C J Silverio,
Walther, Pete Bevin, Shane Sveller, Clara Schultz, jer, Wonwoo Choi, Hawken
Rives, João Veiga, Richard Pringle, Adam Perry, Benjamin Röjder Delnavaz, Matt
Jadczak, Jonathan Knapp, Maximilian, Seth Stadick, brianloveswords, Sean Bryant,
Ember, Sebastian Zimmer, Makoto Nakashima, Geoff Cant, Geoffroy Couprie, Michael
Alyn Miller, o0Ignition0o, Zaki, Raphael Gaschignard, Romain Ruetschi, Ignacio
Vergara, Pascal, Jane Lusby, Nicolas Goy, Ted Mielczarek, Aurora.

</p>
    
  

  

  

  <div>
  
    <p>If you liked this article, please support my work on Patreon!</p>
    <p>
      <a href="https://www.patreon.com/bePatron?u=47556">
        <img src="https://fasterthanli.me/img/patreon/mark-white.png"/>
        <span>Become a Patron</span>
      </a>
    </p>
  
</div>


  

  
</div></div>
  </body>
</html>
