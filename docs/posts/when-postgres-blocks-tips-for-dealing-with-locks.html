<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.citusdata.com/blog/2018/02/22/seven-tips-for-dealing-with-postgres-locks/">Original</a>
    <h1>When Postgres blocks: tips for dealing with locks</h1>
    
    <div id="readability-page-1" class="page"><div data-sticky-container="">  <div>  <section> <div> <p>Last week I wrote about <a href="https://www.citusdata.com/blog/2018/02/15/when-postgresql-blocks/">locking behaviour in Postgres</a>, which commands block each other, and how you can diagnose blocked commands. Of course, after the diagnosis you may also want a cure. With Postgres it is possible to shoot yourself in the foot, but Postgres also offers you a way to stay on target. These are some of the important do’s and don’ts that we’ve seen as helpful when working with users to migrate from their single node Postgres database to <a href="https://www.citusdata.com/download/">Citus</a> or when building new <a href="https://www.citusdata.com/use-cases/real-time-analytics">real-time analytics</a> apps on Citus. </p> <h2>1: Never add a column with a default value</h2> <p>A golden rule of PostgreSQL is: When you add a column to a table in production, <em>never specify a default</em>.</p> <p>Adding a column takes a very aggressive lock on the table, which blocks read and write. If you add a column with a default, PostgreSQL will rewrite the whole table to fill in the default for every row, which can take hours on large tables. In the meantime, all queries will block, so your database will be unavailable.</p> <p>Don’t do this:</p> <div><pre><code><span>-- reads and writes block until it is fully rewritten (hours?)</span>
<span>ALTER</span> <span>TABLE</span> <span>items</span> <span>ADD</span> <span>COLUMN</span> <span>last_update</span> <span>timestamptz</span> <span>DEFAULT</span> <span>now</span><span>();</span>
</code></pre></div> <p>Do this instead:</p> <div><pre><code><span>-- select, update, insert, and delete block until the catalog is update (milliseconds)</span>
<span>ALTER</span> <span>TABLE</span> <span>items</span> <span>ADD</span> <span>COLUMN</span> <span>last_update</span> <span>timestamptz</span><span>;</span>
<span>-- select and insert go through, some updates and deletes block while the table is rewritten</span>
<span>UPDATE</span> <span>items</span> <span>SET</span> <span>last_update</span> <span>=</span> <span>now</span><span>();</span>
</code></pre></div> <p>Or better yet, avoid blocking updates and delete for a long time by updating in small batches, e.g.:</p> <div><pre><code><span>do</span> <span>{</span>
  <span>numRowsUpdated</span> <span>=</span> <span>executeUpdate</span><span>(</span>
    <span>&#34;UPDATE items SET last_update = ? &#34;</span> <span>+</span>
    <span>&#34;WHERE ctid IN (SELECT ctid FROM items WHERE last_update IS NULL LIMIT 5000)&#34;</span><span>,</span>
    <span>now</span><span>);</span>
<span>}</span> <span>while</span> <span>(</span><span>numRowsUpdate</span> <span>&gt;</span> <span>0</span><span>);</span>
</code></pre></div> <p>This way, you can add and populate a new column with minimal interruption to your users.</p> <h2>2: Beware of lock queues, use lock timeouts</h2> <p>Every lock in PostgreSQL has a queue. If a transaction B tries to acquire a lock that is already held by transaction A with a conflicting lock level, then transaction B will wait in the lock queue. Now something interesting happens: if another transaction C comes in, then it will not only have to check for conflict with A, but also with transaction B, and any other transaction in the lock queue.</p> <p>This means that even if your DDL command can run very quickly, it might be in a queue for a long time waiting for queries to finish, and <em>queries that start after it will be blocked behind it</em>.</p> <p>When you can have long-running SELECT queries on a table, don’t do this:</p> <div><pre><code><span>ALTER</span> <span>TABLE</span> <span>items</span> <span>ADD</span> <span>COLUMN</span> <span>last_update</span> <span>timestamptz</span><span>;</span>
</code></pre></div> <p>Instead, do this:</p> <div><pre><code><span>SET</span> <span>lock_timeout</span> <span>TO</span> <span>&#39;2s&#39;</span>
<span>ALTER</span> <span>TABLE</span> <span>items</span> <span>ADD</span> <span>COLUMN</span> <span>last_update</span> <span>timestamptz</span><span>;</span>
</code></pre></div> <p>By setting <code>lock_timeout</code>, the DDL command will fail if it ends up waiting for a lock, and thus blocking queries for more than 2 seconds. The downside is that your <code>ALTER TABLE</code> might not succeed, but you can try again later. You may want to query <a href="https://www.postgresql.org/docs/current/static/monitoring-stats.html#PG-STAT-ACTIVITY-VIEW"><code>pg_stat_activity</code></a> to see if there are long-running queries before starting the DDL command.</p> <h2>3: Create indexes CONCURRENTLY</h2> <p>Another golden rule of PostgreSQL is: Always create your indexes concurrently. </p> <p>Creating an index on a large dataset can take hours or even days, and the regular <code>CREATE INDEX</code> command blocks all writes for the duration of the command. While it doesn’t block <code>SELECT</code>s, this is still pretty bad and there’s a better way: <code>CREATE INDEX CONCURRENTLY</code>.</p> <p>Don’t do this:</p> <div><pre><code><span>-- blocks all writes</span>
<span>CREATE</span> <span>INDEX</span> <span>items_value_idx</span> <span>ON</span> <span>items</span> <span>USING</span> <span>GIN</span> <span>(</span><span>value</span> <span>jsonb_path_ops</span><span>);</span>
</code></pre></div> <p>Instead, do this:</p> <div><pre><code><span>-- only blocks other DDL</span>
<span>CREATE</span> <span>INDEX</span> <span>CONCURRENTLY</span> <span>items_value_idx</span> <span>ON</span> <span>items</span> <span>USING</span> <span>GIN</span> <span>(</span><span>value</span> <span>jsonb_path_ops</span><span>);</span>
</code></pre></div> <p>Creating an index concurrently does have a downside. If something goes wrong it does not roll back and leaves an unfinished (“invalid”) index behind. If that happens, don’t worry, simply run <code>DROP INDEX CONCURRENTLY items_value_idx</code> and try to create it again.</p> <h2>4: Take aggressive locks as late as possible</h2> <p>When you need to run a command that acquires aggressive locks on a table, try to do it as late in the transaction as possible to allow queries to continue for as long as possible.</p> <p>For example, if you want to completely replace the contents of a table. Don’t do this:</p> <div><pre><code><span>BEGIN</span><span>;</span>
<span>-- reads and writes blocked from here:</span>
<span>TRUNCATE</span> <span>items</span><span>;</span>
<span>-- long-running operation:</span>
<span>\</span><span>COPY</span> <span>items</span> <span>FROM</span> <span>&#39;newdata.csv&#39;</span> <span>WITH</span> <span>CSV</span> 
<span>COMMIT</span><span>;</span> 
</code></pre></div> <p>Instead, load the data into a new table and then replace the old table:</p> <div><pre><code><span>BEGIN</span><span>;</span>
<span>CREATE</span> <span>TABLE</span> <span>items_new</span> <span>(</span><span>LIKE</span> <span>items</span> <span>INCLUDING</span> <span>ALL</span><span>);</span>
<span>-- long-running operation:</span>
<span>\</span><span>COPY</span> <span>items_new</span> <span>FROM</span> <span>&#39;newdata.csv&#39;</span> <span>WITH</span> <span>CSV</span>
<span>-- reads and writes blocked from here:</span>
<span>DROP</span> <span>TABLE</span> <span>items</span><span>;</span>
<span>ALTER</span> <span>TABLE</span> <span>items_new</span> <span>RENAME</span> <span>TO</span> <span>items</span><span>;</span>
<span>COMMIT</span><span>;</span> 
</code></pre></div> <p>There is one problem, we didn’t block writes from the start, and the old <code>items</code> table might have changed by the time we drop it. To prevent that, we can explicitly take a lock the table that blocks writes, but not reads:</p> <div><pre><code><span>BEGIN</span><span>;</span>
<span>LOCK</span> <span>items</span> <span>IN</span> <span>EXCLUSIVE</span> <span>MODE</span><span>;</span>
<span>...</span>
</code></pre></div> <p>Sometimes it’s better to take locking into your own hands.</p> <h2>5: Adding a primary key with minimal locking</h2> <p>It’s often a good idea to add a primary key to your tables. For example, when you want to use logical replication or migrate your database using Citus Warp.</p> <p>Postgres makes it very easy to create a primary key using <code>ALTER TABLE</code>, but while the index for the primary key is being built, which can take a long time if the table is large, all queries will be blocked.</p> <div><pre><code><span>ALTER</span> <span>TABLE</span> <span>items</span> <span>ADD</span> <span>PRIMARY</span> <span>KEY</span> <span>(</span><span>id</span><span>);</span> <span>-- blocks queries for a long time</span>
</code></pre></div> <p>Fortunately, you can first do all the heavy lifting using <code>CREATE UNIQUE INDEX CONCURRENTLY</code>, and then use the unique index as a primary key, which is a fast operation.</p> <div><pre><code><span>CREATE</span> <span>UNIQUE</span> <span>INDEX</span> <span>CONCURRENTLY</span> <span>items_pk</span> <span>ON</span> <span>items</span> <span>(</span><span>id</span><span>);</span> <span>-- takes a long time, but doesn’t block queries</span>
<span>ALTER</span> <span>TABLE</span> <span>items</span> <span>ADD</span> <span>CONSTRAINT</span> <span>items_pk</span> <span>PRIMARY</span> <span>KEY</span> <span>USING</span> <span>INDEX</span> <span>items_pk</span><span>;</span>  <span>-- blocks queries, but only very briefly</span>
</code></pre></div> <p>By breaking down primary key creation into two steps, it has almost not impact on the user.</p> <h2>6: Never VACUUM FULL</h2> <p>The postgres user experience can be a little surprising sometimes. While <code>VACUUM FULL</code> sounds like something you want to do clear the dust of your database, a more appropriate command would have been:</p> <div><pre><code><span>PLEASE</span> <span>FREEZE</span> <span>MY</span> <span>DATABASE</span> <span>FOR</span> <span>HOURS</span><span>;</span>
</code></pre></div> <p><code>VACUUM FULL</code> rewrites the entire table to disk, which can take hours or days, and blocks all queries while doing it. While there some valid use cases for <code>VACUUM FULL</code>, such as a table that used to be big, but is now small and still takes up a lot of space, it is probably not your use case.</p> <p>While you should aim to tune your autovacuum settings and use indexes to make your queries fast, you may occasionally want to run <code>VACUUM</code>, but <em>NOT</em> <code>VACUUM FULL</code>.</p> <h2>7: Avoid deadlocks by ordering commands</h2> <p>If you’ve been using PostgreSQL for a while, chances are you’ve seen errors like:</p> <div><pre><code><span>ERROR</span><span>:</span>  <span>deadlock</span> <span>detected</span>
<span>DETAIL</span><span>:</span>  <span>Process</span> <span>13661</span> <span>waits</span> <span>for</span> <span>ShareLock</span> <span>on</span> <span>transaction</span> <span>45942</span><span>;</span> <span>blocked</span> <span>by</span> <span>process</span> <span>13483</span><span>.</span>
<span>Process</span> <span>13483</span> <span>waits</span> <span>for</span> <span>ShareLock</span> <span>on</span> <span>transaction</span> <span>45937</span><span>;</span> <span>blocked</span> <span>by</span> <span>process</span> <span>13661</span><span>.</span>
</code></pre></div> <p>This happens when concurrent transactions take the same locks in a different order. For example, one transaction issues the following commands.</p> <div><pre><code><span>BEGIN</span><span>;</span>
<span>UPDATE</span> <span>items</span> <span>SET</span> <span>counter</span> <span>=</span> <span>counter</span> <span>+</span> <span>1</span> <span>WHERE</span> <span>key</span> <span>=</span> <span>&#39;hello&#39;</span><span>;</span> <span>-- grabs lock on hello</span>
<span>UPDATE</span> <span>items</span> <span>SET</span> <span>counter</span> <span>=</span> <span>counter</span> <span>+</span> <span>1</span> <span>WHERE</span> <span>key</span> <span>=</span> <span>&#39;world&#39;</span><span>;</span> <span>-- blocks waiting for world</span>
<span>END</span><span>;</span>
</code></pre></div> <p>Simultaneously, another transaction might be issuing the same commands, but in a different order.</p> <div><pre><code><span>BEGIN</span>
<span>UPDATE</span> <span>items</span> <span>SET</span> <span>counter</span> <span>=</span> <span>counter</span> <span>+</span> <span>1</span> <span>WHERE</span> <span>key</span> <span>=</span> <span>&#39;world&#39;</span><span>;</span> <span>-- grabs lock on world</span>
<span>UPDATE</span> <span>items</span> <span>SET</span> <span>counter</span> <span>=</span> <span>counter</span> <span>+</span> <span>1</span> <span>WHERE</span> <span>key</span> <span>=</span> <span>&#39;hello&#39;</span><span>;</span>  <span>-- blocks waiting for hello</span>
<span>END</span><span>;</span> 
</code></pre></div> <p>If these transaction blocks run simultaneously, chances are that they get stuck waiting for each other and would never finish. Postgres will recognise this situation after a second or so and will cancel one of the transactions to let the other one finish. When this happen, you should take a look at your application to see if you can make your transactions always follow the same order. If both transactions first modify <code>hello</code>, then <code>world</code>, then the first transaction will block the second one on the <code>hello</code> lock before it can grab any other locks.</p> <h2>Share your tips!</h2> <p>We hope you found these tips helpful. If you have some other tips, feel free to tweet them <a href="https://www.twitter.com/citusdata">@citusdata</a> or on our active community of Citus users on <a href="https://slack.citusdata.com">Slack</a>.</p>  <div> <h3> Enjoy what you’re reading? </h3> <p>If you’re interested in reading more posts from our team, sign up for our monthly newsletter and get the latest content delivered straight to your inbox.</p>    </div>     </div> </section>  </div> </div></div>
  </body>
</html>
