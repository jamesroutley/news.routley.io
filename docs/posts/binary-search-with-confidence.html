<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.tylerhou.io/posts/binary-search-with-confidence/">Original</a>
    <h1>Binary search with confidence</h1>
    
    <div id="readability-page-1" class="page"><div><p>I’ve never intuitively understood binary search—–at least, I’ve never
understood its usual presentation. For example, take a quick glance at
Wikipedia’s binary search code:</p><div><div><table><tbody><tr><td><pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span></code></pre></td><td><pre><code data-lang="javascript"><span>function</span> <span>binary_search</span><span>(</span><span>A</span><span>,</span> <span>n</span><span>,</span> <span>T</span><span>)</span><span>:</span>
  <span>L</span> <span>:=</span> <span>0</span>
  <span>R</span> <span>:=</span> <span>n</span> <span>−</span> <span>1</span>
  <span>while</span> <span>L</span> <span>&lt;=</span> <span>R</span><span>:</span>
    <span>m</span> <span>:=</span> <span>floor</span><span>((</span><span>L</span> <span>+</span> <span>R</span><span>)</span> <span>/</span> <span>2</span><span>)</span>
    <span>if</span> <span>A</span><span>[</span><span>m</span><span>]</span> <span>&lt;</span> <span>T</span><span>:</span>
      <span>L</span> <span>:=</span> <span>m</span> <span>+</span> <span>1</span>
    <span>else</span> <span>if</span> <span>A</span><span>[</span><span>m</span><span>]</span> <span>&gt;</span> <span>T</span><span>:</span>
      <span>R</span> <span>:=</span> <span>m</span> <span>-</span> <span>1</span>
    <span>else</span><span>:</span>
      <span>return</span> <span>m</span>
  <span>return</span> <span>unsuccessful</span>
</code></pre></td></tr></tbody></table></div></div><p>I can’t understand why this code is correct without spending many minutes
considering:</p><ol><li>Why do we have to add/subtract 1 in the loop?</li><li>What happens on small arrays?</li><li>What happens if the element isn’t in the array?</li></ol><p>There’s another way to write binary search that not only do I find easier to
understand and prove correct, but also is more flexible.</p><h2 id="an-outline">An outline</h2><h3 id="loop-invariants">Loop invariants</h3><p>Before we dive into the binary search algorithm, I want to go over <em>loop
invariants</em>—background that will help us later when we try to prove the
algorithm’s correctness.</p><p>Informally, loop invariants are properties of a loop that remain unchanged as
the loop executes. For example, consider the following loop:</p><div><div><table><tbody><tr><td><pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span></code></pre></td><td><pre><code data-lang="java"><span>int</span> <span>f</span><span>()</span> <span>{</span>
    <span>int</span> <span>num</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>int</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>100</span><span>;</span> <span>++</span><span>i</span><span>)</span> <span>{</span>
        <span>num</span> <span>+=</span> <span>2</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>num</span><span>;</span>
<span>}</span>
</code></pre></td></tr></tbody></table></div></div><p>One invariant that remains true during the loop is that <code>num</code> is even
(<em>Statement <span>\(A\)</span></em>). Here’s the argument:</p><ol><li><em>Statement 1:</em> <span></span><code>num</code> starts off even (as 0 is even).</li><li><em>Statement 2:</em> <span></span>If <code>num</code> is even at the beginning of a loop iteration, the loop will add two
to it; hence <code>num</code> will be even at the end of that loop iteration.</li></ol><p>From these two statements, we can deduce that <code>num</code> must be even after the
<span>\(n\)</span>th loop iteration for any arbitrarily large <span>\(n\)</span>: simply start from Statement
1, and repeatedly apply Statement 2 <span>\(n\)</span> times:</p><ol><li>(After <span>\(0\)</span> loop iterations,) <code>num</code> is even. <span>(Statement 1)</span></li><li>After <span>\(1\)</span> loop iteration, <code>num</code> is even. <span>(Apply Statement 2)</span></li><li>After <span>\(2\)</span> loop iterations, <code>num</code> is even. <span>(Apply Statement 2)</span></li><li>After <span>\(3\)</span> loop iterations, <code>num</code> is even. <span>(Apply Statement 2)</span></li><li>…</li><li>After <span>\(n\)</span> loop iterations, <code>num</code> is even. <span>(Apply Statement 2)</span></li><li><em>Ad infinitum…</em></li></ol><p>The two combined complete our argument, and thus prove <span>\(A\)</span> holds over all loop
interations. In other words, <span>\(A\)</span> is <em>invariant.</em></p><p>The above argument is an argument by <a href="https://en.wikipedia.org/wiki/Mathematical_induction"><em>mathematical
induction.</em></a> To make an
argument by mathematical induction, one has to prove two things: the <em>base
case</em> and the <em>inductive step</em>. To prove that Statement <span>\(A\)</span> was invariant,
Statement 1 was the base case, and Statement 2 was the inductive step.</p><p>To make a correct argument by induction, you must prove both the base case and
the inductive step. Otherwise, the argument is not valid. For exmaple, if <code>num</code>
was initially odd, then our base case would be different, and that would change
our invariant: <code>num</code> would always be odd, not even, as a odd number would stay
odd every iteration.</p><p>Similarly, if we had added a different constant to <code>num</code> every loop iteration,
then the <a href="https://en.wikipedia.org/wiki/Parity_(mathematics)">parity</a> of
<code>num</code> would might not stay the same at the end of each iteration. Depending on
the constant, that would also mean that our invariant would no longer hold.</p><h3 id="reframing-binary-search">Reframing binary search</h3><p>Returning back to binary search, suppose we want to find the index of 6 in the
following sorted array:</p><p>Let’s consider the same array, except we label each element with a color—red
or green. Color elements with value strictly less than 6 green, and elements
with value greater than or equal to 6 red.</p><p>Since this array is sorted, the color produces a clear structure: a contiguous
region of green elements, followed by a contiguous region of red elements.
(Convince yourself that all sorted arrays have a similar structure.)</p><p>Notice that 6 is the first red element. The previous element, 3, is a green
element.</p><p>Here is the insight: <strong>Instead of looking for 6 directly, we could instead look
for the boundary between the green and red regions.</strong> Once we find the
boundary, we can use it to locate the element we are searching for.</p><h3 id="the-algorithm">The algorithm</h3><p>We start with two indexes, <code>left</code> and <code>right</code>. <code>left</code> points to the first
element and <code>right</code> points to the last element:</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td><code>left</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>right</code></td></tr></tbody></table></div><p>This motivates our loop invariant: we want <code>left</code> to always point to a green
element, and <code>right</code> to always point to a red element. If we can keep moving
the <code>left</code> and <code>right</code> pointers closer to each other while maintaining the
invariant, then we will eventually find the boundary.</p><p>Let’s consider the middle element:</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td><code>left</code></td><td></td><td></td><td></td><td><code>middle</code></td><td></td><td></td><td></td><td><code>right</code></td></tr></tbody></table></div><p>We have to choose a pointer—either <code>left</code> or <code>right</code>—to move to <code>middle</code>.
Which poitner should we choose?</p><p>Well, based on our loop invariant, it’s clear: since the <code>middle</code> element is a
red element, we want to move <code>right</code> to <code>middle</code>. That would maintain the
invariant that <code>right</code> always points to red. (Moving <code>left</code> to <code>middle</code> would
break an invariant: that <code>left</code> always points to green!)</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td><code>left</code></td><td></td><td></td><td></td><td><code>right</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>We pick the new middle element halfway between <code>left</code> and <code>right</code>:</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td><code>left</code></td><td></td><td><code>middle</code></td><td></td><td><code>right</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>Since this new middle element is green, we move <code>left</code> to <code>middle</code>. Notice how
little we have to think: just look at the color of the middle element, and move
the same-color pointer.</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td></td><td></td><td><code>left</code></td><td></td><td><code>right</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>We then repeat this process until <code>left</code> and <code>right</code> are adjacent. Here’s the
next <code>middle</code>:</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td></td><td></td><td><code>left</code></td><td><code>middle</code></td><td><code>right</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>And it’s red, so we move <code>right</code>:</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>6</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td></td><td></td><td><code>left</code></td><td><code>right</code></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>Now <code>left</code> and <code>right</code> are right next to each other. Since <code>right</code> is red, we
know that it points to the first element greater than or equal to 6. We thus
can return its index, 3.</p><h2 id="the-code">The code</h2><p>Our binary search function will take an array and a function <code>is_green</code>, which
tells us whether an element is green or not. (If it’s not green, it must be
red.)</p><div><div><table><tbody><tr><td><pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span></code></pre></td><td><pre><code data-lang="python"><span>is_green</span><span>(</span><span>0</span><span>)</span>  <span># True, because array[0] == 0  and 0 &lt; 6</span>
<span>is_green</span><span>(</span><span>2</span><span>)</span>  <span># True, because array[2] == 3  and 3 &lt; 6</span>
<span>is_green</span><span>(</span><span>3</span><span>)</span>  <span># False,  because array[3] == 6  and 6 &gt;= 6</span>
<span>is_green</span><span>(</span><span>7</span><span>)</span>  <span># False,  because array[7] == 58 and 58 &gt;= 6</span>
</code></pre></td></tr></tbody></table></div></div><p>Here is the function. Think about what the main loop is doing: during every
iteration, we check whether the middle element is green or not. If it’s green,
we move the left pointer; if it’s not green, it’s red, so we move the right
pointer.</p><div><div><table><tbody><tr><td><pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span></code></pre></td><td><pre><code data-lang="python"><span>def</span> <span>binary_search</span><span>(</span><span>array</span><span>,</span> <span>is_green</span><span>):</span>
    <span>left</span><span>,</span> <span>right</span> <span>=</span> <span>0</span><span>,</span> <span>len</span><span>(</span><span>array</span><span>)</span> <span>-</span> <span>1</span>
    <span># Main loop which narrows our search range.</span>
    <span>while</span> <span>left</span> <span>+</span> <span>1</span> <span>&lt;</span> <span>right</span><span>:</span>
        <span>middle</span> <span>=</span> <span>(</span><span>left</span> <span>+</span> <span>right</span><span>)</span> <span>//</span> <span>2</span>
        <span>if</span> <span>is_green</span><span>(</span><span>array</span><span>[</span><span>middle</span><span>]):</span>
            <span>left</span> <span>=</span> <span>middle</span>
        <span>else</span><span>:</span>
            <span>right</span> <span>=</span> <span>middle</span>

    <span>return</span> <span>right</span>

<span># Call as such:</span>
<span>binary_search</span><span>(</span><span>array</span><span>,</span> <span>lambda</span> <span>x</span><span>:</span> <span>x</span> <span>&lt;</span> <span>6</span><span>);</span>
</code></pre></td></tr></tbody></table></div></div><p>Recall our two desired invariants:</p><ol><li>The left pointer points to a green element.</li><li>The right pointer points to a red element.</li></ol><p>It should be clear that the above loop body would preserve those invariants;
convince yourself. Then, admire how the loop body writes itself. There is no
equality check, no <code>+1</code>/<code>-1</code> arithmetic: just move the correct-color pointer.</p><p>The <code>while</code> condition states that this loop only terminates when <code>left</code> is
adjacent to <code>right</code>. Combined with our invariants, that means if the loop
terminates, then left will point to the last green element and right will point
to the first red element.</p><p>So how do we know the loop terminates? We just need to show that on every
iteration, <code>middle</code> will be strictly in-between <code>left</code> and <code>right</code>; hence the
gap between the two must continually shrink.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> We leave this as an exercise to
the reader.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup></p><p>Finally, when we exit the loop, we return the index of the first red element,
which we know <code>right</code> stores.</p><h3 id="the-base-case-strikes-back">The base case strikes back</h3><p>Are we done? Not so fast!</p><p>In the previous section we showed that the loop body <em>maintains</em> our desired
invariants. In other words, we proved the inductive step: that <em>if</em> <code>left</code>
(<code>right</code>) pointed to a green (red) element at the beginning of a loop
iteration, it would continue to point to a green (red) element at the end.</p><p>But that’s a big <em>if</em>, since we never established that the invariants were true
in the first place! If the entire array was green, for instance, we would only
<span>move</span> <code>left</code>. Then <code>right</code> would point to a green element after the
loop ended.</p><p>Stepping back, to prove that our loop is correct, we must prove that our
desired statements are invariant. We’ve already proved the inductive step
above. But to complete our argument, we <strong>must</strong> also “prove” the base case.</p><p>To prove the base case, we must ensure that before we enter the loop the
statements that we want to be invariant are indeed true. So we check that
<code>left</code> points to green and <code>right</code> points to red. If either isn’t true, we can
return early.</p><div><div><table><tbody><tr><td><pre><code><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span></code></pre></td><td><pre><code data-lang="python">    <span>left</span><span>,</span> <span>right</span> <span>=</span> <span>0</span><span>,</span> <span>len</span><span>(</span><span>array</span><span>)</span> <span>-</span> <span>1</span>
    <span>if</span> <span>not</span> <span>array</span><span>:</span>
        <span>return</span> <span>?</span>
    <span>if</span> <span>not</span> <span>is_green</span><span>(</span><span>array</span><span>[</span><span>left</span><span>]):</span>
        <span>return</span> <span>?</span>
    <span>if</span> <span>is_green</span><span>(</span><span>array</span><span>[</span><span>right</span><span>]):</span>
        <span>return</span> <span>?</span>

    <span># Loop...</span>
</code></pre></td></tr></tbody></table></div></div><p>What values should we return? There are three cases. First, if the array is all
red, it’s clear: the first red element would be at index 0, so we can directly
return 0.</p><p>Second, if the array is all green, then what we should return is not as clear.
In practice, it’s useful to return an index one past the end of the array. One
could imagine that the first red element would be there:</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>-2</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>3</td><td>4</td><td>4</td><td><span>one past end</span></td></tr><tr><td>G</td><td>G</td><td>G</td><td>G</td><td>G</td><td>G</td><td>G</td><td>G</td><td>R</td></tr></tbody></table><p>Last, what if the array was empty? The same logic would apply: return one past
the end, which is the 0th element.</p></div><p>Here’s the final code:</p><div><div><table><tbody><tr><td><pre><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span></code></pre></td><td><pre><code data-lang="python"><span>def</span> <span>binary_search</span><span>(</span><span>array</span><span>,</span> <span>is_green</span><span>):</span>
    <span>left</span><span>,</span> <span>right</span> <span>=</span> <span>0</span><span>,</span> <span>len</span><span>(</span><span>array</span><span>)</span> <span>-</span> <span>1</span>
    <span>if</span> <span>not</span> <span>array</span><span>:</span>
        <span>return</span> <span>0</span>
    <span>if</span> <span>not</span> <span>is_green</span><span>(</span><span>array</span><span>[</span><span>left</span><span>]):</span>
        <span>return</span> <span>0</span>
    <span>if</span> <span>is_green</span><span>(</span><span>array</span><span>[</span><span>right</span><span>]):</span>
        <span>return</span> <span>len</span><span>(</span><span>array</span><span>)</span>

    <span># Main loop which narrows our search range.</span>
    <span>while</span> <span>left</span> <span>+</span> <span>1</span> <span>&lt;</span> <span>right</span><span>:</span>
        <span>middle</span> <span>=</span> <span>(</span><span>left</span> <span>+</span> <span>right</span><span>)</span> <span>//</span> <span>2</span>
        <span>if</span> <span>is_green</span><span>(</span><span>array</span><span>[</span><span>middle</span><span>]):</span>
            <span>left</span> <span>=</span> <span>middle</span>
        <span>else</span><span>:</span>
            <span>right</span> <span>=</span> <span>middle</span>

    <span>return</span> <span>right</span>

<span># Call as such:</span>
<span>binary_search</span><span>(</span><span>array</span><span>,</span> <span>lambda</span> <span>x</span><span>:</span> <span>x</span> <span>&lt;</span> <span>6</span><span>);</span>
</code></pre></td></tr></tbody></table></div></div><h3 id="what-happens-if-the-target-element-is-missing">What happens if the target element is missing?</h3><p>Consider the same array, except with 6 changed to 7. Let’s repeat our
algorithm, searching for 6. I’ll omit the middle steps for brevity.</p><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>7</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td><code>left</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><code>right</code></td></tr></tbody></table></div><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>7</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td><code>left</code></td><td></td><td></td><td></td><td><code>right</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>7</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td></td><td></td><td><code>left</code></td><td></td><td><code>right</code></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><div><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>2</td><td>3</td><td>7</td><td>9</td><td>10</td><td>20</td><td>58</td><td>60</td></tr><tr><td>G</td><td>G</td><td>G</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td><td>R</td></tr><tr><td></td><td></td><td><code>left</code></td><td><code>right</code></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p>We end up with the same return value. This is because our algorithm doesn’t
actually find the index of 6—it finds the leftmost index at which you could
insert 6 to keep the array sorted. That is, we could run the pseudocode:</p><div><div><table><tbody><tr><td><pre><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td><td><pre><code data-lang="python"><span># True.</span>
<span>assert</span> <span>is_sorted</span><span>(</span><span>array</span><span>)</span>

<span>index</span> <span>=</span> <span>binary_search</span><span>(</span><span>array</span><span>,</span> <span>lambda</span> <span>i</span><span>:</span> <span>array</span><span>[</span><span>i</span><span>]</span> <span>&lt;</span> <span>6</span><span>)</span>
<span>array</span><span>.</span><span>insert</span><span>(</span><span>index</span><span>,</span> <span>6</span><span>)</span>

<span># Always still True.</span>
<span>assert</span> <span>is_sorted</span><span>(</span><span>array</span><span>)</span>
</code></pre></td></tr></tbody></table></div></div><p>This is a feature–—in some cases we only need to insert into a sorted array,
so we don’t need to check if the returned index has a certain element in the
binary search procedure. It’s better to leave that up to the caller.</p><p>Other binary search implementations, including <a href="https://docs.python.org/3/library/bisect.html#bisect.bisect_left"><code>bisect_left</code> in Python’s
bisect
library,</a>
also return the first valid insertion point.</p><p>This is also why we return one past the end if the array is entirely green or
when the array is empty. In both cases, the correct place to insert the new
element is at the end of the array.</p></div></div>
  </body>
</html>
