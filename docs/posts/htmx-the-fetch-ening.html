<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://htmx.org/essays/the-fetchening/">Original</a>
    <h1>&lt;/&gt; Htmx – The Fetch()ening</h1>
    
    <div id="readability-page-1" class="page"><div>
    

  
  
    <address>Carson Gross</address>
    <p><time>November 01, 2025</time></p><p><img src="https://htmx.org/img/fetch.png" alt="Stop trying to make fetch() happen"/></p>
<p>OK, I said there would never be a version three of htmx.</p>
<p>But, <em>technically</em>, I never said anything about a version <em>four</em>…</p>
<h2 id="htmx-4-the-fetch-ening"><a href="#htmx-4-the-fetch-ening" aria-label="Anchor link for: htmx-4-the-fetch-ening">htmx 4: The fetch()ening</a></h2>
<p>In <a href="https://htmx.org/essays/hypermedia-driven-applications/">The Future of htmx</a> I said the following:</p>
<blockquote>
<p>We are going to work to ensure that htmx is extremely stable in both API &amp; implementation. This means accepting and
documenting the <a rel="noopener" target="_blank" href="https://htmx.org/quirks/">quirks</a> of the current implementation.</p>
</blockquote>
<p>Earlier this year, on a whim, I created <a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/fixi">fixi.js</a>, a hyperminimalist implementation
of the ideas in htmx.  That work gave me a chance to get a lot more familiar  with the <code>fetch()</code> and, especially, the
<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async</a> infrastructure
available in JavaScript.</p>
<p>In doing that work I began to wonder if that, while the htmx <a rel="noopener" target="_blank" href="https://htmx.org/reference/#attributes">API</a>
is (at least reasonably) correct, maybe there was room for a more dramatic change of the implementation that took
advantage of these features in order to simplify the library.</p>
<p>Further, changing from ye olde <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a>
(a legacy of htmx 1.0 IE support) to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch"><code>fetch()</code></a> would
be a pretty violent change, guaranteed to break at least <em>some</em> stuff.</p>
<p>So I began thinking: if we are going to consider moving to fetch, then maybe we should <em>also</em> that this update as a
chance address at least <em>some</em> of the <a rel="noopener" target="_blank" href="https://htmx.org/quirks/">quirks</a> that htmx has acquired over its lifetime.</p>
<p>So, eventually &amp; reluctantly, I have changed my mind: there <em>will</em> be another major version of htmx.</p>
<p>However, in order to keep my word that there will not be a htmx 3.0, the next release will instead be htmx 4.0.</p>
<h2 id="project-goals"><a href="#project-goals" aria-label="Anchor link for: project-goals">Project Goals</a></h2>
<p>With htmx 4.0 we are rebuilding the internals of htmx, based on the lessons learned from
fixi.js and <a rel="noopener" target="_blank" href="https://www.npmjs.com/package/htmx.org/v/0.0.1">five+ years</a> of supporting htmx.</p>
<p>There are three major simplifying changes:</p>
<h3 id="the-fetch-ening"><a href="#the-fetch-ening" aria-label="Anchor link for: the-fetch-ening">The fetch()ening</a></h3>
<p>The biggest internal change is that <code>fetch()</code> will replace <code>XMLHttpRequest</code> as the core ajax infrastructure.  This
won’t actually have a huge effect on most usages of htmx <em>except</em> that the events model will necessarily change due
to the differences between <code>fetch()</code> and <code>XMLHttpRequest</code>.</p>
<h3 id="the-long-national-nightmare-of-implicit-attribute-inheritance-ends"><a href="#the-long-national-nightmare-of-implicit-attribute-inheritance-ends" aria-label="Anchor link for: the-long-national-nightmare-of-implicit-attribute-inheritance-ends">The Long National Nightmare of Implicit Attribute Inheritance Ends</a></h3>
<p>I feel that my biggest mistake in htmx 1.0 &amp; 2.0 was making attribute inheritance <em>implicit</em>.  I was inspired by CSS in
doing this, and the results have been roughly the same as CSS: powerful &amp; maddening.</p>
<p>In htmx 4.0, attribute inheritance will be <em>explicit</em> rather than <em>implicit</em>, via the <code>:inherited</code> modifier:</p>
<pre data-lang="html"><code data-lang="html"><span>  &lt;</span><span>div </span><span>hx-target:inherited</span><span>=</span><span>&#34;#output&#34;</span><span>&gt;
</span><span>    &lt;</span><span>button </span><span>hx-post</span><span>=</span><span>&#34;/up&#34;</span><span>&gt;Like&lt;/</span><span>button</span><span>&gt;
</span><span>    &lt;</span><span>button </span><span>hx-post</span><span>=</span><span>&#34;/down&#34;</span><span>&gt;Dislike&lt;/</span><span>button</span><span>&gt;
</span><span>  &lt;/</span><span>div</span><span>&gt;
</span><span>  &lt;</span><span>output </span><span>id</span><span>=</span><span>&#34;output&#34;</span><span>&gt;Pick a button...&lt;/</span><span>output</span><span>&gt;
</span></code></pre>
<p>Here the <code>hx-target</code> attribute is explicitly declared as <code>inherited</code> on the enclosing <code>div</code> and, if it wasn’t, the
<code>button</code> elements would not inherit the target from it.</p>
<p>This will be the most significant upgrade change to deal with for most htmx users.</p>
<h3 id="the-tyranny-of-locally-cached-history-ends"><a href="#the-tyranny-of-locally-cached-history-ends" aria-label="Anchor link for: the-tyranny-of-locally-cached-history-ends">The Tyranny Of Locally Cached History Ends</a></h3>
<p>Another constant source of pain for both us and for htmx users is history support.  htmx 2.0 stores history in local
cache to make navigation faster.  Unfortunately, snapshotting the DOM is often brittle because of third-party
modifications, hidden state, etc.  There is a terrible simplicity to the web 1.0 model of blowing everything away and
starting over.  There are also security concerns storing history information in session storage.</p>
<p>In htmx 2.0, we often end up recommending that people facing history-related issues simply disable the cache entirely,
and that usually fixes the problems.</p>
<p>In htmx 4.0, history support will no longer snapshot the DOM and keep it locally.  It will, rather, issue a network
request for the restored content.  This is the behavior of 2.0 on a history cache-miss, and it works reliably with
little effort on behalf of htmx users.</p>
<p>We will offer an extension that enables history caching like in htmx 2.0, but it will be opt-in, rather than the default.</p>
<p>This tremendously simplifies the htmx codebase and should make the out-of-the-box behavior much more plug-and-play.</p>
<h2 id="what-stays-the-same"><a href="#what-stays-the-same" aria-label="Anchor link for: what-stays-the-same">What Stays The Same?</a></h2>
<p>Most things.</p>
<p>The <a rel="noopener" target="_blank" href="https://dl.acm.org/doi/10.1145/3648188.3675127">core</a> functionality of htmx will remain the same, <code>hx-get</code>, <code>hx-post</code>,
<code>hx-target</code>, <code>hx-boost</code>, <code>hx-swap</code>, <code>hx-trigger</code>, etc.</p>
<p>Except for adding an <code>:inherited</code> modifier on a few attributes, many htmx projects will “just work” with htmx 4.</p>
<p>These changes will make the long term maintenance &amp; sustainability of the project much stronger.  It will also take
pressure off the 2.0 releases, which can now focus on stability rather than contemplating new features.</p>
<h2 id="upgrading"><a href="#upgrading" aria-label="Anchor link for: upgrading">Upgrading</a></h2>
<p>That said, htmx 2.0 users <em>will</em> face an upgrade project when moving to 4.0 in a way that they did not have to in moving
from 1.0 to 2.0.</p>
<p>I am sorry about that, and want to offer three things to address it:</p>
<ul>
<li>htmx 2.0 (like htmx 1.0 &amp; intercooler.js 1.0) will be supported <em>in perpetuity</em>, so there is absolutely <em>no</em> pressure to
upgrade your application: if htmx 2.0 is satisfying your hypermedia needs, you can stick with it.</li>
<li>We will create extensions that revert htmx 4 to htmx 2 behaviors as much as is feasible (e.g. Supporting the old implicit
attribute inheritance model, at least)</li>
<li>We will roll htmx 4.0 out slowly, over a multi-year period.  As with the htmx 1.0 -&gt; 2.0 upgrade, there will be a long
period where htmx 2.x is <code>latest</code> and htmx 3.x is <code>next</code></li>
</ul>
<h2 id="new-features"><a href="#new-features" aria-label="Anchor link for: new-features">New Features</a></h2>
<p>Of course, it isn’t all bad.  Beyond simplifying the implementation of htmx significantly, switching to fetch also gives
us the opportunity to add some nice new features to htmx</p>
<h3 id="streaming-responses-sse-in-core"><a href="#streaming-responses-sse-in-core" aria-label="Anchor link for: streaming-responses-sse-in-core">Streaming Responses &amp; SSE in Core</a></h3>
<p>By switching to <code>fetch()</code>, we can take advantage of its support for
<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams">readable streams</a>, which
allow for a stream of content to be swapped into the DOM, rather than a single response.</p>
<p>htmx 1.0 had Server Sent Event support integrated into the library.  In htmx 2.0 we pulled this functionality out as an
extension.  It turns out that SSE is just a specialized version of a streaming response, so in adding streaming
support, it’s an almost-free free two-fer to add that back into core as well.</p>
<p>This will make incremental response swapping much cleaner and well-supported in htmx.</p>
<h3 id="morphing-swap-in-core"><a href="#morphing-swap-in-core" aria-label="Anchor link for: morphing-swap-in-core">Morphing Swap in Core</a></h3>
<p><a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/idiomorph/commit/7760e89d9f198b43aa7d39cc4f940f606771f47b">Three years ago</a> I had
an idea for a DOM morphing algorithm that improved on the initial algorithm pioneered by <a rel="noopener" target="_blank" href="https://github.com/patrick-steele-idem/morphdom">morphdom</a>.</p>
<p>The idea was to use “id sets” to make smarter decisions regarding which nodes to preserve and which nodes to delete when
merging changes into the DOM, and I called this idea “idiomorph”.  Idiomorph has gone on to be adopted by many other
web project such as <a rel="noopener" target="_blank" href="https://hotwired.dev/">Hotwire</a>.</p>
<p>We strongly considered including it in htmx 2.0, but I decided not too because it worked well as an extension and
htmx 2.0 had already grown larger than I wanted.</p>
<p>In 4.0, with the complexity savings we achieved by moving to <code>fetch()</code>, we can now comfortably fit a <code>morphInner</code> and
<code>morphOuter</code> swap into core, thanks to the excellent work of Michael West.</p>
<h3 id="explicit-tag-support"><a href="#explicit-tag-support" aria-label="Anchor link for: explicit-tag-support">Explicit <partial> Tag Support</partial></a></h3>
<p>htmx has, since very early on, supported a concept of “Out-of-band” swaps: content that is removed from the main HTML
response and swapped into the DOM elsewhere.  I have always been a bit ambivalent about them, because they move away
from <a rel="noopener" target="_blank" href="https://htmx.org/essays/locality-of-behaviour/">Locality of Behavior</a>, but there is no doubt that they are useful
and often crucial for achieving certain UI patterns.</p>
<p>Out-of-band swaps started off very simply: if you marked an element as <code>hx-swap-oob=&#39;true&#39;</code>, htmx would swap the element
as the outer HTML of any existing element already in the DOM with that id.  Easy-peasy.</p>
<p>However, over time, people started asking for different functionality around Out-of-band swaps: prepending, appending,
etc. and the feature began acquiring some fairly baroque syntax to handle all these needs.</p>
<p>We have come to the conclusion that the problem is that there are really <em>two</em> use cases, both currently trying to be
filled by Out-of-band swaps:</p>
<ul>
<li>A simple, id-based replacement</li>
<li>A more elaborate swap of partial content</li>
</ul>
<p>Therefore, we are introducing the notion of <code>&lt;partial&gt;</code>s in htmx 4.0</p>
<p>A partial element is, under the covers, a template element and, thus, can contain any sort of content you like.  It
specifies on itself all the standard htmx options regarding swapping, <code>hx-target</code> and <code>hx-swap</code> in particular, allowing
you full access to all the standard swapping behavior of htmx without using a specialized syntax.  This tremendously
simplifies the mental model for these sorts of needs, and dovetails well with the streaming support we intend to offer.</p>
<p>Out-of-band swaps will be retained in htmx 4.0, but will go back to their initial, simple focus of simply replacing
an existing element by id.</p>
<h3 id="improved-view-transitions-support"><a href="#improved-view-transitions-support" aria-label="Anchor link for: improved-view-transitions-support">Improved View Transitions Support</a></h3>
<p>htmx 2.0 has have <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API">View Transition</a> support since
<a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/htmx/blob/master/CHANGELOG.md#190---2023-04-11">April of 2023</a>.  In the interceding
two years, support for the feature has grown across browsers (c’mon, safari, you can do it) and we’ve gain experience
with the feature.</p>
<p>One thing that has become apparent to us while using them is that, to use them in a stable manner, it is important
to establish a queue of transitions, so each can complete before the other begins.  If you don’t do this, you can get
visually ugly transition cancellations.</p>
<p>So, in htmx 4.0 we have added this queue which will ensure that all view transitions complete smoothly.</p>
<p>CSS transitions will continue to work as before as well, although the swapping model is again made much simpler by the
async runtime.</p>
<p>We may enable View Transitions by default, the jury is still out on that.</p>
<h3 id="stabilized-event-ordering"><a href="#stabilized-event-ordering" aria-label="Anchor link for: stabilized-event-ordering">Stabilized Event Ordering</a></h3>
<p>A wonderful thing about <code>fetch()</code> and the async support in general is that it is <em>much</em> easier to guarantee a stable
order of events.  By linearizing asynchronous code and allowing us to use standard language features like try/catch,
the event model of htmx should be much more predictable and comprehensible.</p>
<p>We are going to adopt a new standard for event naming to make things even clearer:</p>
<p><code>htmx:&lt;phase&gt;:&lt;system&gt;[:&lt;optional-sub-action&gt;]</code></p>
<p>So, for example, <code>htmx:before:request</code> will be triggered before a request is made.</p>
<h3 id="improved-extension-support"><a href="#improved-extension-support" aria-label="Anchor link for: improved-extension-support">Improved Extension Support</a></h3>
<p>Another opportunity we have is to take advantage of the <code>async</code> behavior of <code>fetch()</code> for much better performance in our
preload extension (where we issue a speculative (<code>GET</code> only!) request in anticipation of an actual trigger).  We have
also added an optimistic update extension to the core extensions, again made easy by the new async features.</p>
<p>In general, we have opened up the internals of the htmx request/response/swap cycle much more fully to extension developers,
up to and including allowing them to replace the <code>fetch()</code> implementation used by htmx for a particular request.  There
should not be a need for any hacks to get the behavior you want out of htmx now: the events and the open “context” object
should provide the ability to do almost anything.</p>
<h3 id="improved-hx-on-support"><a href="#improved-hx-on-support" aria-label="Anchor link for: improved-hx-on-support">Improved <code>hx-on</code> Support</a></h3>
<p>In htmx 2.0, I somewhat reluctantly added the <a rel="noopener" target="_blank" href="https://htmx.org/attributes/hx-on/"><code>hx-on</code></a> attributes to support light
scripting inline on elements.  I added this because HTML does not allow you to listen for arbitrary events via <code>on</code>
attributes: only standard DOM events like <code>onclick</code> can be responded to.</p>
<p>We hemmed and hawed about the syntax and so, unfortunately, there are a few different ways to do it.</p>
<p>In htmx 4.0 we will adopt a single standard for the <code>hx-on</code> attributes: <code>hx-on:&lt;event name&gt;</code>.  Additionally, we are
working to improve the htmx JavaScript API (especially around async operation support) and will make those features
available in <code>hx-on</code>:</p>
<pre data-lang="html"><code data-lang="html"><span>&lt;</span><span>button </span><span>hx-post</span><span>=</span><span>&#34;/like&#34;
</span><span>        </span><span>hx-on:htmx:after:swap</span><span>=</span><span>&#34;await timeout(&#39;3s&#39;); ctx.newContent[0].remove()&#34;</span><span>&gt;
</span><span>    Get A Response Then Remove It 3 Seconds Later
</span><span>&lt;/</span><span>button</span><span>&gt;
</span></code></pre>
<p>htmx will never support a fully featured scripting mechanism in core, we recommend something like
<a rel="noopener" target="_blank" href="https://alpinejs.dev/">Alpine.js</a> for that, but our hope is that we can provide a relatively minimalist API that
allows for easy, light async scripting of the DOM.</p>
<p>I should note that htmx 4.0 will continue to work with <code>eval()</code> disabled, but you will need to forego a few features like
<code>hx-on</code> if you choose to do so.</p>
<h3 id="a-better-but-familiar-htmx"><a href="#a-better-but-familiar-htmx" aria-label="Anchor link for: a-better-but-familiar-htmx">A Better But Familiar htmx</a></h3>
<p>All in all, our hope is that htmx 4.0 will feel an awful lot like 2.0, but with better features and, we hope, with fewer bugs.</p>
<h2 id="timeline"><a href="#timeline" aria-label="Anchor link for: timeline">Timeline</a></h2>
<p>As always, software takes as long as it takes.</p>
<p>However, our current planned timeline is:</p>
<ul>
<li>An alpha release is available <em>today</em>:  <code>htmx@4.0.0-alpha1</code></li>
<li>A 4.0.0 release should be available in early-to-mid 2026</li>
<li>4.0 will be marked <code>latest</code> in early-2027ish</li>
</ul>
<p>You can track our progress (and see quite a bit of dust flying around) in the <code>four</code> branch on
<a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/htmx/tree/four">github</a> and at:</p>
<p><a rel="noopener" target="_blank" href="https://four.htmx.org">https://four.htmx.org</a></p>
<p>Thank you for your patience and pardon our dust!</p>
<blockquote>
<p>“Well, when events change, I change my mind. What do you do?” –Paul Samuelson or John Maynard Keynes</p>
</blockquote>

  <p>
    &lt;/&gt;
  </p>
</div></div>
  </body>
</html>
