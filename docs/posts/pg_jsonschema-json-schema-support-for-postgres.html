<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/pg-jsonschema-a-postgres-extension-for-json-validation">Original</a>
    <h1>Pg_jsonschema – JSON Schema Support for Postgres</h1>
    
    <div id="readability-page-1" class="page"><article><div><p><span><img alt="pg_jsonschema: JSON Schema support for Postgres" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></p><p>Released on the Supabase platform today, <a href="https://github.com/supabase/pg_jsonschema">pg_jsonschema</a> is a Postgres extension
which adds <a href="https://json-schema.org/">JSON Schema</a> validation support for <code>json</code> and <code>jsonb</code> data types.</p>
<h2 id="the-use-case-for-json-validation">The use-case for JSON validation</h2>
<p>Despite Supabase being an SQL shop, even our most zealous relational data model advocates (begrudgingly) recognize some advantages to the document data model.
Mainly, if some complex data will always be consumed together, a document data type can be a good fit.</p>
<p><strong>For Example</strong>:</p>
<p>If our application receives data via a webhook:</p>

<p>A reasonable swing at normalizing that data into tables might look like this:</p>
<p><span><span><img alt="pg_jsonschema_erd.png" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>That&#39;s a lot of architecting! Moreover, the query to recover the original input requires 5 joins!</p>
<p>A solution that aligns better with our intent would be to persist whatever we receive from the external service so long as it meets a minimum set of requirements.
With Postgres&#39; <code>json</code> data type we can achieve half of that goal.</p>
<p><span><span><img alt="pg_jsonschema_erd2.png" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Treating the webhook contents as a <code>json</code> document simplifies our data model. It is also robust to changing payloads and more efficient to query, update, and delete.</p>
<p>Now what about this part?</p>
<blockquote>
<p>so long as it meets a minimum set of requirements</p>
</blockquote>
<h2 id="challenges">Challenges</h2>
<p>The flexibility of document types also comes with some downsides.</p>
<p>The schema of the json payload from the previous example is a little intense for a blog post, so let&#39;s instead say we intend for a table&#39;s <code>json</code> column to hold objects with a <code>string</code> attribute named <code>foo</code> and no additional attributes.</p>
<p>Without constraints, the setup would be:</p>

<p>But the resulting schema is much more permissive than our intent. When inserting a mix of correct and incorrect values:</p>
<p><span><span><img alt="Check constraints" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Only 2 of our 8 test cases were handled appropriately by our data model.</p>
<p>A core strength of SQL databases is their ability to constrain data&#39;s <a href="https://www.postgresql.org/docs/current/datatype.html">types</a>, nullability,
<a href="https://www.postgresql.org/docs/current/tutorial-fk.html">referential integrity</a>, <a href="https://www.postgresql.org/docs/current/ddl-constraints.html">uniqueness</a>,
and even <a href="https://www.postgresql.org/docs/current/sql-createtrigger.html">arbitrary developer-defined rules</a>.
Those constraints are a lot to sacrifice to gain the convenience of document types.</p>
<p>Fortunately, the challenge of validating <code>json</code> documents isn&#39;t specific to SQL databases. NoSQL/Document databases, like MongoDB,
<a href="https://www.mongodb.com/docs/atlas/app-services/schemas/">optionally enforce data constraints</a> so there&#39;s plenty of prior art for us to draw from.</p>
<h2 id="json-schema">JSON Schema</h2>
<p><a href="https://json-schema.org/">JSON Schema</a> is a specification for validating the shape and contents of <code>json</code> documents.
It can describe constraints for documents similar to those applied by relational databases.</p>
<p>Translating our constraints from the previous example into a JSON Schema we get:</p>

<p>Which is a formal and human-readable description of our intent. A tutorial on the JSON Schema language is out-of-scope
for this article but you can find a full introduction in <a href="https://json-schema.org/understanding-json-schema/index.html">their guide</a>.</p>
<p>So now we have:</p>
<p>✅ flexible document data type → <code>json</code></p>
<p>✅ a language to describe constraints on <code>json</code> documents → JSON Schema</p>
<p>❌ a way to enforce JSON Schema constraints on <code>json</code> documents in Postgres</p>
<h2 id="pg_jsonschema">pg_jsonschema</h2>
<p><a href="https://github.com/supabase/pg_jsonschema">pg_jsonschema</a> is a Postgres extension that can validate <code>json</code> and <code>jsonb</code> data types
against a <a href="https://json-schema.org/">JSON Schema</a>. The extension offers two functions:</p>

<p>We can use those functions in combination with a <a href="https://www.postgresql.org/docs/current/ddl-constraints.html">check constraint</a> to more completely describe our data model.</p>

<p>With that check constraint in place, we re-run the same test cases:</p>
<p><span><span><img alt="Check constraints 2" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="fill"/></span></span></p>
<p>Now all 8 tests are handled correctly. In cases where records failed to insert, Postgres throws an error referencing the failing constraint.</p>
<blockquote>
<p>ERROR: new row for relation &#34;some_table&#34; violates check constraint &#34;some_table_metadata_check&#34;</p>
<p>DETAIL: Failing row contains (1, null).</p>
<p>SQL state: 23514</p>
</blockquote>
<p>With these tools you can wield the flexibility of <code>json</code>/<code>jsonb</code> data types without sacrificing the guarantees of a well specified data model!</p>
<p>To get started with <code>pg_jsonschema</code>, fire up a new supabase project and enable the extension with</p>

<p>or follow the <a href="https://github.com/supabase/pg_jsonschema#try-it-out">Docker Compose instructions</a> in the <a href="https://github.com/supabase/pg_jsonschema/blob/master/README.md">repo&#39;s README</a>.</p></div></article></div>
  </body>
</html>
