<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.qemu.org/docs/master/system/replay.html">Original</a>
    <h1>Deterministic Replay of QEMU Emulation</h1>
    
    <div id="readability-page-1" class="page"><div role="main" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="record-replay">

<p>Record/replay functions are used for the deterministic replay of qemu execution.
Execution recording writes a non-deterministic events log, which can be later
used for replaying the execution anywhere and for unlimited number of times.
It also supports checkpointing for faster rewind to the specific replay moment.
Execution replaying reads the log and replays all non-deterministic events
including external input, hardware clocks, and interrupts.</p>
<p>Deterministic replay has the following features:</p>
<blockquote>
<div><ul>
<li><p>Deterministically replays whole system execution and all contents of
the memory, state of the hardware devices, clocks, and screen of the VM.</p></li>
<li><p>Writes execution log into the file for later replaying for multiple times
on different machines.</p></li>
<li><p>Supports i386, x86_64, ARM, AArch64, Risc-V, MIPS, MIPS64, S390X, Alpha,
PowerPC, PowerPC64, M68000, Microblaze, OpenRISC, SPARC,
and Xtensa hardware platforms.</p></li>
<li><p>Performs deterministic replay of all operations with keyboard and mouse
input devices, serial ports, and network.</p></li>
</ul>
</div></blockquote>
<p>Usage of the record/replay:</p>
<blockquote>
<div><ul>
<li><p>First, record the execution with the following command line:</p>
<blockquote>
<div><pre>qemu-system-x86_64 \
-icount shift=auto,rr=record,rrfile=replay.bin \
-drive file=disk.qcow2,if=none,snapshot,id=img-direct \
-drive driver=blkreplay,if=none,image=img-direct,id=img-blkreplay \
-device ide-hd,drive=img-blkreplay \
-netdev user,id=net1 -device rtl8139,netdev=net1 \
-object filter-replay,id=replay,netdev=net1</pre>
</div></blockquote>
</li>
<li><p>After recording, you can replay it by using another command line:</p>
<blockquote>
<div><pre>qemu-system-x86_64 \
-icount shift=auto,rr=replay,rrfile=replay.bin \
-drive file=disk.qcow2,if=none,snapshot,id=img-direct \
-drive driver=blkreplay,if=none,image=img-direct,id=img-blkreplay \
-device ide-hd,drive=img-blkreplay \
-netdev user,id=net1 -device rtl8139,netdev=net1 \
-object filter-replay,id=replay,netdev=net1</pre>
</div></blockquote>
<p>The only difference with recording is changing the rr option
from record to replay.</p>
</li>
<li><p>Block device images are not actually changed in the recording mode,
because all of the changes are written to the temporary overlay file.
This behavior is enabled by using blkreplay driver. It should be used
for every enabled block device, as described in <a href="#block-label"><span>Block devices</span></a> section.</p></li>
<li><p><code><span>-net</span> <span>none</span></code> option should be specified when network is not used,
because QEMU adds network card by default. When network is needed,
it should be configured explicitly with replay filter, as described
in <a href="#network-label"><span>Network devices</span></a> section.</p></li>
<li><p>Interaction with audio devices and serial ports are recorded and replayed
automatically when such devices are enabled.</p></li>
</ul>
</div></blockquote>
<section id="core-idea">
<h2>Core idea<a href="#core-idea" title="Permalink to this heading"></a></h2>
<p>Record/replay system is based on saving and replaying non-deterministic
events (e.g. keyboard input) and simulating deterministic ones (e.g. reading
from HDD or memory of the VM). Saving only non-deterministic events makes
log file smaller and simulation faster.</p>
<p>The following non-deterministic data from peripheral devices is saved into
the log: mouse and keyboard input, network packets, audio controller input,
serial port input, and hardware clocks (they are non-deterministic
too, because their values are taken from the host machine). Inputs from
simulated hardware, memory of VM, software interrupts, and execution of
instructions are not saved into the log, because they are deterministic and
can be replayed by simulating the behavior of virtual machine starting from
initial state.</p>
</section>
<section id="instruction-counting">
<h2>Instruction counting<a href="#instruction-counting" title="Permalink to this heading"></a></h2>
<p>QEMU should work in icount mode to use record/replay feature. icount was
designed to allow deterministic execution in absence of external inputs
of the virtual machine. Record/replay feature is enabled through <code><span>-icount</span></code>
command-line option, making possible deterministic execution of the machine,
interacting with user or network.</p>
</section>
<section id="block-devices">
<span id="block-label"></span><h2>Block devices<a href="#block-devices" title="Permalink to this heading"></a></h2>
<p>Block devices record/replay module intercepts calls of
bdrv coroutine functions at the top of block drivers stack.
To record and replay block operations the drive must be configured
as following:</p>
<div><div><pre><span></span><span>-</span><span>drive</span> <span>file</span><span>=</span><span>disk</span><span>.</span><span>qcow2</span><span>,</span><span>if</span><span>=</span><span>none</span><span>,</span><span>snapshot</span><span>,</span><span>id</span><span>=</span><span>img</span><span>-</span><span>direct</span>
<span>-</span><span>drive</span> <span>driver</span><span>=</span><span>blkreplay</span><span>,</span><span>if</span><span>=</span><span>none</span><span>,</span><span>image</span><span>=</span><span>img</span><span>-</span><span>direct</span><span>,</span><span>id</span><span>=</span><span>img</span><span>-</span><span>blkreplay</span>
<span>-</span><span>device</span> <span>ide</span><span>-</span><span>hd</span><span>,</span><span>drive</span><span>=</span><span>img</span><span>-</span><span>blkreplay</span>
</pre></div>
</div>
<p>blkreplay driver should be inserted between disk image and virtual driver
controller. Therefore all disk requests may be recorded and replayed.</p>
</section>
<section id="snapshotting">
<span id="snapshotting-label"></span><h2>Snapshotting<a href="#snapshotting" title="Permalink to this heading"></a></h2>
<p>New VM snapshots may be created in replay mode. They can be used later
to recover the desired VM state. All VM states created in replay mode
are associated with the moment of time in the replay scenario.
After recovering the VM state replay will start from that position.</p>
<p>Default starting snapshot name may be specified with icount field
rrsnapshot as follows:</p>
<div><div><pre><span></span><span>-</span><span>icount</span> <span>shift</span><span>=</span><span>auto</span><span>,</span><span>rr</span><span>=</span><span>record</span><span>,</span><span>rrfile</span><span>=</span><span>replay</span><span>.</span><span>bin</span><span>,</span><span>rrsnapshot</span><span>=</span><span>snapshot_name</span>
</pre></div>
</div>
<p>This snapshot is created at start of recording and restored at start
of replaying. It also can be loaded while replaying to roll back
the execution.</p>
<p><code><span>snapshot</span></code> flag of the disk image must be removed to save the snapshots
in the overlay (or original image) instead of using the temporary overlay.</p>
<div><div><pre><span></span><span>-</span><span>drive</span> <span>file</span><span>=</span><span>disk</span><span>.</span><span>ovl</span><span>,</span><span>if</span><span>=</span><span>none</span><span>,</span><span>id</span><span>=</span><span>img</span><span>-</span><span>direct</span>
<span>-</span><span>drive</span> <span>driver</span><span>=</span><span>blkreplay</span><span>,</span><span>if</span><span>=</span><span>none</span><span>,</span><span>image</span><span>=</span><span>img</span><span>-</span><span>direct</span><span>,</span><span>id</span><span>=</span><span>img</span><span>-</span><span>blkreplay</span>
<span>-</span><span>device</span> <span>ide</span><span>-</span><span>hd</span><span>,</span><span>drive</span><span>=</span><span>img</span><span>-</span><span>blkreplay</span>
</pre></div>
</div>
<p>Use QEMU monitor to create additional snapshots. <code><span>savevm</span> <span>&lt;name&gt;</span></code> command
created the snapshot and <code><span>loadvm</span> <span>&lt;name&gt;</span></code> restores it. To prevent corruption
of the original disk image, use overlay files linked to the original images.
Therefore all new snapshots (including the starting one) will be saved in
overlays and the original image remains unchanged.</p>
<p>When you need to use snapshots with diskless virtual machine,
it must be started with “orphan” qcow2 image. This image will be used
for storing VM snapshots. Here is the example of the command line for this:</p>
<pre>qemu-system-x86_64 \
  -icount shift=auto,rr=replay,rrfile=record.bin,rrsnapshot=init \
  -net none -drive file=empty.qcow2,if=none,id=rr</pre>
<p><code><span>empty.qcow2</span></code> drive does not connected to any virtual block device and used
for VM snapshots only.</p>
</section>
<section id="network-devices">
<span id="network-label"></span><h2>Network devices<a href="#network-devices" title="Permalink to this heading"></a></h2>
<p>Record and replay for network interactions is performed with the network filter.
Each backend must have its own instance of the replay filter as follows:</p>
<div><div><pre><span></span><span>-</span><span>netdev</span> <span>user</span><span>,</span><span>id</span><span>=</span><span>net1</span> <span>-</span><span>device</span> <span>rtl8139</span><span>,</span><span>netdev</span><span>=</span><span>net1</span>
<span>-</span><span>object</span> <span>filter</span><span>-</span><span>replay</span><span>,</span><span>id</span><span>=</span><span>replay</span><span>,</span><span>netdev</span><span>=</span><span>net1</span>
</pre></div>
</div>
<p>Replay network filter is used to record and replay network packets. While
recording the virtual machine this filter puts all packets coming from
the outer world into the log. In replay mode packets from the log are
injected into the network device. All interactions with network backend
in replay mode are disabled.</p>
</section>
<section id="audio-devices">
<h2>Audio devices<a href="#audio-devices" title="Permalink to this heading"></a></h2>
<p>Audio data is recorded and replay automatically. The command line for recording
and replaying must contain identical specifications of audio hardware, e.g.:</p>

</section>
<section id="serial-ports">
<h2>Serial ports<a href="#serial-ports" title="Permalink to this heading"></a></h2>
<p>Serial ports input is recorded and replay automatically. The command lines
for recording and replaying must contain identical number of ports in record
and replay modes, but their backends may differ.
E.g., <code><span>-serial</span> <span>stdio</span></code> in record mode, and <code><span>-serial</span> <span>null</span></code> in replay mode.</p>
</section>
<section id="reverse-debugging">
<h2>Reverse debugging<a href="#reverse-debugging" title="Permalink to this heading"></a></h2>
<p>Reverse debugging allows “executing” the program in reverse direction.
GDB remote protocol supports “reverse step” and “reverse continue”
commands. The first one steps single instruction backwards in time,
and the second one finds the last breakpoint in the past.</p>
<p>Recorded executions may be used to enable reverse debugging. QEMU can’t
execute the code in backwards direction, but can load a snapshot and
replay forward to find the desired position or breakpoint.</p>
<p>The following GDB commands are supported:</p>
<blockquote>
<div><ul>
<li><p><code><span>reverse-stepi</span></code> (or <code><span>rsi</span></code>) - step one instruction backwards</p></li>
<li><p><code><span>reverse-continue</span></code> (or <code><span>rc</span></code>) - find last breakpoint in the past</p></li>
</ul>
</div></blockquote>
<p>Reverse step loads the nearest snapshot and replays the execution until
the required instruction is met.</p>
<p>Reverse continue may include several passes of examining the execution
between the snapshots. Each of the passes include the following steps:</p>
<blockquote>
<div><ol>
<li><p>loading the snapshot</p></li>
<li><p>replaying to examine the breakpoints</p></li>
<li><p>if breakpoint or watchpoint was met</p>
<ul>
<li><p>loading the snapshot again</p></li>
<li><p>replaying to the required breakpoint</p></li>
</ul>
</li>
<li><p>else</p>
<ul>
<li><p>proceeding to the p.1 with the earlier snapshot</p></li>
</ul>
</li>
</ol>
</div></blockquote>
<p>Therefore usage of the reverse debugging requires at least one snapshot
created. This can be done by omitting <code><span>snapshot</span></code> option
for the block drives and adding <code><span>rrsnapshot</span></code> for both record and replay
command lines.
See the <a href="#snapshotting-label"><span>Snapshotting</span></a> section to learn more about running record/replay
and creating the snapshot in these modes.</p>
<p>When <code><span>rrsnapshot</span></code> is not used, then snapshot named <code><span>start_debugging</span></code>
created in temporary overlay. This allows using reverse debugging, but with
temporary snapshots (existing within the session).</p>
</section>
</section>


           </div>
          </div></div>
  </body>
</html>
