<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yoyo-code.com/programming-breakthroughs-we-need/">Original</a>
    <h1>Programming breakthroughs we need</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>I feel like we need a few breakthroughs to drastically change how we develop software. And when I say breakthrough, I mean huge breakthrough. Something like a &#34;structured programming&#34; breakthrough, which completely changed how we think about programming. Here are some observations and ideas about that.</p>
<h2 id="writing-glue-code-and-boilerplate-is-a-waste">Writing glue code and boilerplate is a waste<span>
<a href="#writing-glue-code-and-boilerplate-is-a-waste" aria-label="Anchor link for: writing-glue-code-and-boilerplate-is-a-waste">ðŸ”—</a>
</span>
</h2>
<p>Most code I write doesn&#39;t do anything interesting, it&#39;s either some boilerplate or glue for connecting subsystems together. It feels like this kind of code was already written many times before and will be written many times in the future. So why should I even write it again?</p>
<p>Well, the problem is that the code is different enough, that usually I can&#39;t use the existing code as it is, I have to modify it. And this comes with a lot of additional baggage in the form of the whole software lifecycle - now I can&#39;t just use the code, I have to write it, test it, build some automation, deploy...</p>
<p>To be more specific - for most web projects I work on, I have a very similar <code>yaml</code> file for CI, <code>Dockerfile</code>, some script to compress images, some script to run migrations, some boilerplate for routing, authentication, some language/framework setup like <code>package.json</code> or <code>Cargo.toml</code>, deployment config, 3rd party integrations and so on.</p>
<p>And then, usually the biggest problem is an enormous amount of CRUD boilerplate that looks very similar in each project, but it&#39;s nevertheless different in important details. This is typical for web projects, but other kinds of software have a similar thing going on.</p>
<h3 id="why-not-use-a-framework">Why not use a framework?<span>
<a href="#why-not-use-a-framework" aria-label="Anchor link for: why-not-use-a-framework">ðŸ”—</a>
</span>
</h3>
<p>Some projects try to package this into a single framework, but this approach doesn&#39;t always work either, because it necessarily introduces new generic mechanisms and complexity, often hiding important details you care about. Because these things require a good amount of customization, such framework often introduces its own kind of glue and boilerplate.</p>
<p>It feels like there&#39;s an unexplored dimension of abstraction here. Something where generics, interfaces and higher order functions are too static and low level primitives. Something where it&#39;s really difficult to pinpoint what exactly is the repeated pattern here and how to exploit it. Instead of generic framework that can do everything, I&#39;d like an efficient way do something specific.</p>
<p>A good hint is the recent GitHub Copilot development. It can easily generate a lot of common boilerplate code which has these &#34;same, but different&#34; properties I describe. Nevertheless, I think we need something more powerful, which brings me to the next topic.</p>
<h2 id="editing-code-in-general-doesn-t-work-well">Editing code in general doesn&#39;t work well<span>
<a href="#editing-code-in-general-doesn-t-work-well" aria-label="Anchor link for: editing-code-in-general-doesn-t-work-well">ðŸ”—</a>
</span>
</h2>
<p>It feels like the way we program is just not optimal. Changing the program is the most common thing we need to do in our work, it&#39;s the reason our job even exist. And yet, most of programmer&#39;s time is spent reading or planning how to change the code.</p>
<p>Not only that - many activities we do are done only to avoid changing the code prematurely or making the change less risky. That&#39;s why we read code so much, we need to understand it really well to change it correctly. That&#39;s why we do grooming, code review and automated testing.</p>
<h3 id="program-is-not-a-text">Program is not a text<span>
<a href="#program-is-not-a-text" aria-label="Anchor link for: program-is-not-a-text">ðŸ”—</a>
</span>
</h3>
<p>The question is - if most of the work we want to do is about changing existing code, then why is the system not optimized for change by default? The code we write is optimized for reading the source text and its storage. </p>
<p>We spend endless amounts of time bikeshedding the right syntax, indentation level, tabs vs spaces, or where to put code in the structure of files, but this all feels just pointless - these are all properties of text, but the text is just a tool to manipulate some abstract model of the program.</p>
<h3 id="program-is-a-model">Program is a model<span>
<a href="#program-is-a-model" aria-label="Anchor link for: program-is-a-model">ðŸ”—</a>
</span>
</h3>
<p>I imagine this model as a relational database - you have tables like <code>structs</code>, <code>fields</code>, <code>functions</code>, <code>arguments</code> and relationships between them. When you think about it this way, it becomes clear that using a textual source code is really inefficient way to manipulate this model. It&#39;s very error-prone and requires tons of additional processing.</p>
<p>I first started thinking about this when refactoring <a rel="noopener" target="_blank" href="https://github.com/panstromek/zebra-rs">Zebra</a>, transforming <a rel="noopener" target="_blank" href="https://github.com/immunant/c2rust">C2Rust</a> output to safe Rust. I like using IntelliJ, because it helps a lot with editing code by automated refactoring, but for this one, it wasn&#39;t enough. I needed something much more powerful.</p>
<p>IntelliJ helps you with things like &#34;extract parameter&#34; or &#34;inline function&#34;, but I wanted to do stuff like - for each function that touches this global variable, I want to extract it to a parameter that is <code>&amp;mut</code> if it needs to be mutated or <code>&amp;</code> if it&#39;s immutable and move the global into main function as a local variable - and also, do it for all globals in this file.</p>
<p>Or even better, I want to specify a goal like &#34;I want this function to not take this parameter&#34; and let the system figure out how to transform the program to achieve this goal. I can imagine a system that can combine small transforms into larger ones and use some AI magic to figure out how to compose them to achieve the specified goal.</p>
<h3 id="do-we-need-a-language">Do we need a language?<span>
<a href="#do-we-need-a-language" aria-label="Anchor link for: do-we-need-a-language">ðŸ”—</a>
</span>
</h3>
<p>Notice that none of the things I want are related to a specific programming language. I don&#39;t even care about how the text looks like, where the files are located, how imports work, what is the order of parameters, where to put braces or if braces even exist. None of that is important, so why do we even bother? Why not jump right into the meat of the matter?</p>
<p>Also notice how writing the refactoring as a query over the model is actually not that difficult. I can imagine how I would write an SQL query like that in a few lines. On the other hand, writing an automated refactoring system in IntelliJ or VSCode sounds like a lifetime problem, <a rel="noopener" target="_blank" href="https://rust-analyzer.github.io/blog/2020/03/30/macros-vs-rename.html">and it&#39;s kinda unsolvable</a>.</p>
<p>Why? Well, because we treat programs as text, so we inherit a lot of complexity connected to that. We have to worry about importing, formatting, filesystem, type inference, macros and more. All of this is accidental complexity, related to how the input text is mapped to the program model.</p>
<p>If we instead focused on building the right model, we could better optimize that model for editing and the text could be just a view of that model. If the text is just a view, it doesn&#39;t matter how it&#39;s written. Let everybody customize it the way they want. I don&#39;t care if you put opening brace on a new line, I don&#39;t even want to care.</p>
<p>As far as I understand, this is what <a rel="noopener" target="_blank" href="https://dion.systems/">Dion project</a> tries to explore. I&#39;m pretty excited for what comes out of that.</p>
<h2 id="testing-and-correctness">Testing and Correctness<span>
<a href="#testing-and-correctness" aria-label="Anchor link for: testing-and-correctness">ðŸ”—</a>
</span>
</h2>
<p>Testing is related to all of this. Here&#39;s a bold statement:</p>
<p><strong>Software testing doesn&#39;t work</strong></p>
<p>No matter how hard we try, it just sucks. Writing tests is time-consuming, usually doesn&#39;t scale, and it easily creates tight coupling with implementation, which makes change difficult. Tests also frequently don&#39;t test what we care about and require a lot of tooling and process to make them useful. <strong>The only thing worse than testing is not testing, but testing is not much better.</strong></p>
<p>Programmers can&#39;t even agree on basic things like when to test, how to test, if unit tests are any good or if TDD is the only true way to build software. This is a good hint that we haven&#39;t found the right way, yet. I think we need a breakthrough that will just end this nonsense debate for good.</p>
<p>Whenever someone points out a problem with unit/integration/e2e testing, there&#39;s always an army of people who respond with &#34;you just don&#39;t do it right&#34;. Same with TDD - every complaint on TDD is accompanied by &#34;if done right&#34; comment. If that&#39;s the case, and testing really requires so much experience and careful work to &#34;be done right&#34;, then is it even worth it? Why don&#39;t we find out some better way to test?</p>
<h2 id="i-want-simpler-testing">I want simpler testing<span>
<a href="#i-want-simpler-testing" aria-label="Anchor link for: i-want-simpler-testing">ðŸ”—</a>
</span>
</h2>
<p>We have some promising ideas. Some examples include strong type system, fuzzing, snapshot tests and sanitizers. Those all seem on the right track, because they allow us to cover a whole dimension of tests by a single tool.</p>
<p>What I miss is some generic mechanism to make testing super cheap and effective. That&#39;s why I don&#39;t think unit testing or any kind of system where you write tests manually is on the right track. Those approaches work and there&#39;s something to them, but they just fundamentally don&#39;t scale. This week I reviewed a code that had 90 lines of test code to test a one-liner with 2 test cases. That&#39;s not very effective.</p>
<p>Notice that if we change our programming model the way I described in the chapter above, we could find some completely new approaches to testing. Maybe you could write tests as queries that would test a whole set of possible programs, not only the current version of your program at the moment. But I don&#39;t think that&#39;s necessary. Some approaches already work well today, and it&#39;s only a matter of better integration, which comes with time.</p>
<h2 id="what-is-the-vision">What is the vision?<span>
<a href="#what-is-the-vision" aria-label="Anchor link for: what-is-the-vision">ðŸ”—</a>
</span>
</h2>
<p>There&#39;s a common thread in all the points above. All major breakthroughs require a shift in perspective. Structured programming completely changed how we write code. I think we need that. Structured programming was a shift in how we look at program structure. Here, the shift is related to program change over time.</p>
<p>The whole agile revolution pushes us in this direction - our process is based on feedback and fast iteration. We need to change things all the time and experiment with them. That&#39;s why we need tools that allow us to change stuff all the time. We have some - we have git, database migrations, terraform, CI systems, cloud... But many of our practices are still holding us back. We are limited by size of our changes.</p>
<p>If you imagine all the breakthroughs above combined, what world do you see? I see a world where we can develop programs fast, changing requirements is even more welcome than in <a rel="noopener" target="_blank" href="https://agilemanifesto.org/">Agile Manifesto</a> and programming is  based on change even more than before.</p>
<p>Refactoring doesn&#39;t even need to exist as a separate concept or activity - programming itself is that. We regularly change the whole program every day. Migrating to new database? Payment provider? Frontend framework? You can just do that, without designing an interface abstraction for it, ever. You don&#39;t need UI mockups and prototypes - you just program the real thing, because it&#39;s that simple. If the user doesn&#39;t like it, you can completely restructure it easily.</p>
<p>Taking this even further, what if the whole concept of a programming language doesn&#39;t even make sense anymore? You just have the program model, and it doesn&#39;t matter how you render it. Maybe even semantics doesn&#39;t matter - you can write custom rules as queries for the model. What if the &#34;programming language&#34; is just a set of tables and queries you pick however you want?</p>
<h2 id="closing-thoughts">Closing thoughts<span>
<a href="#closing-thoughts" aria-label="Anchor link for: closing-thoughts">ðŸ”—</a>
</span>
</h2>
<p>Will this vision pan out? I don&#39;t know... maybe. But I think we&#39;re heading in this direction already. It won&#39;t be overnight revolution, even structured programming wasn&#39;t. Many of these ideas are not explored enough yet, and some of them might even be impossible to implement, who knows. Testing is the most developed out of these, I&#39;d say. Even though it&#39;s still far behind what I want, I think most of the building blocks are there.</p>
<p>For some ideas, I don&#39;t even know where to start. I can imagine the model based programming quite easily, but tackling the boilerplate/glue problem seems more difficult. Do we need something like a common protocol? Or do we just generate the boilerplate with AI? Do we have some tests and use AI to generate code until the test pass? And if we use model based programming, how does glue code for it even look like? Is it still the same issue?</p>
<p>Let&#39;s see if this wishlist materializes in next few decades.</p>
<hr/>
<p>Discuss on <a rel="noopener" target="_blank" href="https://www.reddit.com/r/programming/comments/wnczdv/programming_breakthroughs_we_need/">Reddit</a></p>

    </div></div>
  </body>
</html>
