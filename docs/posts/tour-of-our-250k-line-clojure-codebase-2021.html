<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.redplanetlabs.com/2021/06/03/tour-of-our-250k-line-clojure-codebase/">Original</a>
    <h1>Tour of our 250k line Clojure codebase (2021)</h1>
    
    <div id="readability-page-1" class="page"><article id="post-478">
	<!-- .entry-header -->

	<div>
		




<div><p>At <a href="https://redplanetlabs.com">Red Planet Labs</a> we’ve been quietly developing a new kind of developer tool for many years. Our tool reduces the cost of building large-scale end-to-end applications by multiple orders of magnitude, and Clojure is a big reason why we’ve been able to tackle such an ambitious project with a small team.</p>
<p>Our codebase consists of 250k lines of Clojure split evenly between source and test code. It’s one of the largest Clojure codebases in the world. In this post I’ll give a tour of how we organize our code so a project of this size can be understood amongst a team, the development and testing techniques we use that leverage the unique qualities of Clojure, and an overview of the key libraries we use.</p>
</div>







<h2 id="custom-language">Custom language within a language</h2>



<div><p>One of the coolest parts of our codebase is the new general purpose language at its foundation. Though the semantics of the language are substantially different than Clojure, it’s defined entirely within Clojure using macros to express the differing behavior. It compiles directly to bytecode using the <a href="https://asm.ow2.io/">ASM library</a>. The rest of our system is built using both this language and vanilla Clojure, interoperating seamlessly.</p>
<p>One of the striking capabilities our language has that vanilla Clojure does not is <a href="https://en.wikipedia.org/wiki/Continuation">first-class continuations</a>. The way in which our language expresses continuations makes it extremely good at async, parallel, and reactive programming. All of these are foundational to the large-scale distributed infrastructure we’re building.</p>
<p>That you can build an entirely new language with radically different semantics within Clojure demonstrates how powerful Clojure is. There’s a lot you get &#34;for free&#34; when building a language this way: lexing, parsing, datatypes, namespaces, immutable data structures, and the entire library ecosystem of Clojure and the JVM. Ultimately our new language <em>is</em> Clojure since it’s defined within Clojure, so it benefits from seamless interoperability with both Clojure and the JVM.</p>
<p>The vast majority of applications are not going to need to develop a full language like we have. But there are plenty of use cases where a focused DSL is appropriate, and we have examples of that too. The ability when using Clojure to customize how code itself is interpreted, via macros and meta-programming, is an incredibly powerful capability.</p>
</div>



<h2 id="schema">Type/schema checking</h2>



<div><p>Central to any codebase is the data that is created, managed, and manipulated. We find it’s imperative to carefully and clearly document the data flying around the system. At the same time, type or schema annotations add overhead so it’s important to be thoughtful and not overdo it.</p>
<p>We use the <a href="https://github.com/plumatic/schema">Schema</a> library for defining datatypes within our codebase. It’s easy to use and we like the flexibility to define schema constraints beyond just types: e.g. arbitrary predicates, enums, and unions. Our codebase contains about 600 type definitions, most of which are annotated using Schema.</p>
<p>Around Schema we have a helper called &#34;defrecord+&#34; which defines constructor functions which also perform validation (e.g. for type Foo it generates &#34;-&gt;valid-Foo&#34; and &#34;map-&gt;valid-Foo&#34;). These functions throw a descriptive exception if the schema check fails.</p>
<p>There’s no static type checking in Clojure, and static type checks wouldn’t be able to check all the kinds of constraints we define using Schema anyway (e.g. the value of a number being within a certain range). We’ve found we only need to insert schema checking on either:</p>
<ul>
<li>Construction of types, for which our auto-generated &#34;valid&#34; constructor functions remove all the ceremony. Detecting an error when creating a record is much better than when using it later on, as during creation you have the context needed to debug the problem.</li>
<li>A few strategic spots throughout the codebase where lots of different types flow.</li>
</ul>
<p>We only occasionally annotate the types of function args and return values. We find instead that being consistent about how we name things is good enough for understanding the code. We do have about 500 assertions throughout our codebase, though these are generally about higher-level properties rather than simple type checks.</p>
<p>The approach we’ve taken for schema definition and enforcement is lightweight, comprehensive, and doesn’t get in our way. The lack of static typing in Clojure scares a lot of programmers who have never used Clojure, and all we can say is that with a little bit of thought in how you organize your code it’s not an issue at all. And doing things dynamically means we can enforce stronger constraints than possible with static type systems.</p>
</div>



<h2 id="repo">Multi-module repository setup</h2>



<div><p>Our codebase exists in a single git repo with four modules to split up the implementation:</p>
<ul>
<li>&#34;core&#34;, which contains the definition of our compiler and the corresponding abstractions for parallel programming</li>
<li>&#34;distributed&#34;, which implements those parallel programming abstractions as a distributed cluster</li>
<li>&#34;rpl-specter&#34;, an internal fork of <a href="https://github.com/redplanetlabs/specter">Specter</a> which adds a ton of functionality</li>
<li>&#34;webui&#34;, which implements the front end of our product</li>
</ul>
<p>We use <a href="https://github.com/technomancy/leiningen">Leiningen</a> and <a href="https://clojure.org/guides/deps_and_cli">deps.edn</a> for our build. The ability to specify local targets as dependencies in deps.edn files is key to our multi-module setup, and the basic organization of our source tree looks like:</p>
</div>









<p>Here’s an excerpt from our deps.edn file for &#34;distributed&#34;:</p>




<div><table><tbody><tr><td></td><td><div><p><span>{</span>:<span>deps</span> <span>{</span>rpl<span>/</span>core <span>{</span>:<span>local</span><span>/</span>root <span>&#34;../core&#34;</span></p></div></td></tr></tbody></table></div>




<p>This setup lets us develop within any one of the modules and automatically see any source changes in the other modules without having to make explicit Maven dependencies.</p>



<p>Loading the entire codebase for running tests or loading a REPL is pretty slow (largely from compilation of code using our custom language), so we use AOT compilation heavily to speed up development. Since we spend most of our time developing in “distributed”, we AOT compile “core” to speed things up.</p>



<h2 id="poly-specter">Polymorphic data with Specter</h2>



<p><a href="https://github.com/redplanetlabs/specter">Specter</a> is a library we developed for supercharging our ability to work with data structures, especially nested and recursive data. Specter is based around the concept of “paths” into data structures, where a path can “navigate” to any number of values starting from the root of a data structure. The path can include traversals, views, and filters, and they’re deeply composable.</p>



<p>Our compiler compiles code into an abstract representation with a distinct record type for each kind of operation possible in our language. There are a variety of attributes every operation type must expose in a uniform way. For example, one of these attributes is “needed fields”, the fields in the closure of that operation that it requires to do its work. A typical way to express this polymorphic behavior would be to use an interface or protocol, like so:</p>




<div><table><tbody><tr><td></td><td><div><p><span>(</span>defprotocol NeededFields</p></div></td></tr></tbody></table></div>




<div><p>The problem with this approach is it only covers querying. Some phases of our compiler must rewrite the fields throughout the abstract representation (e.g. uniquing vars to remove shadowing) and this protocol doesn’t support that. A (set-needed-fields [this fields] ) method could be added to this protocol, but that doesn’t cleanly fit data types which have a fixed number of input fields. It also doesn’t compose well for nested manipulation.</p>
<p>Instead, we use Specter’s &#34;protocol paths&#34; feature to organize the common attributes of our varying compiler types. Here’s an excerpt from our compiler:</p>
</div>




<div><table><tbody><tr><td></td><td><div><p><span>(</span>defprotocolpath NeededFields <span>[</span><span>]</span><span>)</span></p></div></td></tr></tbody></table></div>




<div><p>&#34;Invoke&#34;, for instance, is the type that represents calling another function. The :op field could be a static function or a var reference to a function in the closure. The other path navigates to all the fields used as arguments to the function invocation.</p>
<p>This structure is extremely flexible and allows for modifications to be expressed just as easily as queries by integrating directly with Specter. For instance, we can append a &#34;-foo&#34; suffix to all the needed fields in a sequence of operations like so:</p>
</div>




<div><table><tbody><tr><td><p>1<br/></p></td><td><p><span>(</span>setval <span>[</span>ALL NeededFields NAME END<span>]</span> <span>&#34;-foo&#34;</span> ops<span>)</span></p></td></tr></tbody></table></div>




<p>If we want the unique set of fields used in a sequence of ops, the code is:</p>




<div><table><tbody><tr><td><p>1<br/></p></td><td><p><span>(</span><span>set</span> <span>(</span>select <span>[</span>ALL NeededFields<span>]</span> ops<span>)</span><span>)</span></p></td></tr></tbody></table></div>




<p>Protocol paths are a way to make the data itself polymorphic and able to integrate with the supercharged abilities of Specter. They greatly reduce the number of manipulation helper functions that would be required otherwise and make the codebase far more comprehensible.</p>



<h2 id="component">Organizing complex subsystems with Component</h2>



<div><p>The daemons comprising the distributed system we’re building are comprised of dozens of subsystems that build on top of one another and depend on each other. The subsystems need to be started in a particular order, and in tests they must be torn down in a particular order. Additionally, within tests we need the ability to inject mocks for some subsystems or disable some subsystems altogether.</p>
<p>We use the <a href="https://github.com/stuartsierra/component">Component</a> library to organize our subsystems in a way that manages lifecycle and gives us the flexibility to inject alternate dependencies or disable subsystems. Internally, we built a &#34;defrcomponent&#34; helper to unify field and dependency declarations. For example, from our codebase:</p>
</div>




<div><table><tbody><tr><td></td><td><div><p><span>(</span>defrcomponent AdminUiWebserver</p></div></td></tr></tbody></table></div>




<div><p>This automatically retrieves fields &#34;metastore&#34;, &#34;service-handler&#34;, and &#34;cluster-retriever&#34; from the system map it’s started in and makes them available in the closure of the component’s implementation. It expects one field &#34;port&#34; in the constructor of the component, and it generates another field &#34;jetty-instance&#34; on startup into its internal closure.</p>
<p>We also extended the component lifecycle paradigm with &#34;start-async&#34; and &#34;stop-async&#34; protocol methods. Some components do part of their initialization/teardown on other threads, and it was important for the rest of our system (especially deterministic simulation, described below) for those to be doable in a non-blocking way.</p>
<p>Our test infrastructure builds upon Component for doing dependency injection. For instance, from our test code:</p>
</div>




<div><table><tbody><tr><td></td><td><div><p><span>(</span>sc<span>/</span>with<span>-</span>simulated<span>-</span>cluster</p></div></td></tr></tbody></table></div>




<p>That first map is a dependency injection map, and this code disables the “ticker” component. The “ticker” causes simulation tests to advance time occasionally, and since this test wants to control time explicitly it disables it. That dependency injection map can be used to override or disable any component in the system, providing the flexibility necessary for writing tests.</p>



<h2 id="redefs">Using with-redefs for testing</h2>



<div><p>Clojure provides the macro &#34;with-redefs&#34; that can redefine any function executed within the scope of that form, including on other threads. We have found this to be an invaluable feature for writing tests.</p>
<p>Sometimes we use with-redefs to mock specific behavior in the dependencies of what we’re testing so we can test that functionality in isolation. Other times we use it to inject failures to test fault-tolerance.</p>
<p>The most interesting usage of with-redefs in our codebase, and one of our most common, is using it alongside no-op functions we insert into our source code. These functions effectively provide a structured event log that can be dynamically tapped in an à la carte way depending on what a test is interested in.</p>
<p>Here’s one example (out of hundreds in our codebase) of how we use this pattern. One part of our system executes user-specified work in a distributed way and needs to: 1) retry the work if it fails, and 2) checkpoint its progress to a durable, replicated store after a threshold amount of work has succeeded. One of the tests for this injects a failure the first time work is attempted and then verifies the system retries the work.</p>
<p>The source function that executes the work is called &#34;process-data!&#34;, and here is an excerpt from that function:</p>
</div>




<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>when</span> <span>(</span><span>and</span> success? retry?<span>)</span></p></div></td></tr></tbody></table></div>




<div><p>&#34;retry-succeeded&#34; is a no-op function defined as (defn retry-succeeded [] ).</p>
<p>In a totally separate function called &#34;checkpoint-state!&#34;, the no-op function &#34;durable-state-checkpointed&#34; is called after it finishes replicating and writing to disk the progress information. In our test code, we have:</p>
</div>




<div><table><tbody><tr><td></td><td><div><p><span>(</span><span>deftest</span> retry<span>-</span>user<span>-</span>work<span>-</span>simulated<span>-</span>integration<span>-</span>test</p></div></td></tr></tbody></table></div>




<div><p>Then in the body of the test, we check the correct internal events happen at the correct moments.</p>
<p>Best of all, since this à la carte event log approach is based on no-op functions, it adds basically no overhead when the code runs in production. We have found this approach to be an incredibly powerful testing technique that utilizes Clojure’s design in a unique way.</p>
</div>



<h2 id="macros">Macro usage</h2>



<div><p>We have about 400 macros defined through our codebase, 70% of which are part of source code and 30% of which are for test code only. We have found the common advice for macros, like don’t use a macro when you can use a function, to be wise guidance. That we have 400 macros doing things you can’t do with regular functions demonstrates the extent to which we make abstractions that go far beyond what you can do with a typical language that doesn’t have a powerful macro system.</p>
<p>About 100 of our macros are simple &#34;with-&#34; style macros which open a resource at the start and ensure the resource is cleaned up when the form exits. We use these macros for things like managing file lifecycles, managing log levels, scoping configurations, and managing complex system lifecycles.</p>
<p>About 60 of our macros define abstractions of our custom language. In all of these the interpretation of the forms within is different than vanilla Clojure.</p>
<p>Many of our macros are utility macros, like &#34;letlocals&#34; which lets us more easily mix variable binding with side effects. We use it heavily in test code like so:</p>
</div>









<p>This code expands to:</p>









<div><p>The rest of the macros are a mix of internal abstractions, like a state machine DSL we built, and various idiosyncratic implementation details where the macro removes code duplication that can’t be removed otherwise.</p>
<p>Macros are a language feature that can be abused to produce terribly confusing code, or they can be leveraged to produce fantastically elegant code. Like anything else in software development, the result you end up with is determined by the skill of those using it. At Red Planet Labs we can’t imagine building software systems without macros in our toolbox.</p>
</div>



<h2 id="simulation">Deterministic simulation</h2>



<div><p>As <a href="https://blog.redplanetlabs.com/2021/03/17/where-were-going-we-dont-need-threads-simulating-distributed-systems/">we wrote about previously</a>, we have the ability to write 100% reproducible distributed systems tests by running our whole system on a single thread and randomizing the order in which entities execute events starting from a random seed. Simulation is a major, codebase-spanning capability that heavily utilizes the aforementioned techniques of dependency injection and redefs. For example:</p>
<ul>
<li>Any part of the system that in production would be a unique thread is coded in terms of <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html">executor services</a>. To get an executor service for that particular part of the system, it requests one from an &#34;executor service factory&#34;. In production, this returns new threads. In simulation, however, we override that component to provide executor services from our single-threaded, globally managed source.</li>
<li>Much of our system relies on time (e.g. timeouts), so time is abstracted away from our implementation. Any part of the system that is interested in time consults a &#34;time source&#34; dependency. In production this is the system clock, but in simulation the component is overridden with a &#34;simulated time source&#34; that can be explicitly controlled within our simulation tests.</li>
<li><a href="https://clojuredocs.org/clojure.core/promise">Promises</a> are used quite a bit throughout the codebase to manage asynchronous, non-blocking behavior. Simulation uses with-redefs to layer in additionally functionality into promises useful for stepping through simulation.</li>
</ul>
</div>



<h2 id="front-end">Front end</h2>



<div><p>Our product provides a UI to let users see what they have running on a cluster, the current status of operations like scaling, and telemetry showing what’s going on in their applications.</p>
<p>The front end is a web-based single page app coded in ClojureScript. The ClojureScript ecosystem has many mature, well-designed libraries that make development efficient and fun.</p>
<p>Reviewing the libraries and their advantages could be a blog post in itself, but briefly: we use <a href="https://github.com/day8/re-frame">re-frame</a> because its data-oriented state management and event handling models are easy to reason about and inspect. We use <a href="https://github.com/metosin/reitit">reitit</a> for frontend routing; we like how its data-oriented design allows us to associate arbitrary data with each route, which in turn lets us do neat things like dispatch re-frame events on route changes. We use <a href="https://github.com/thheller/shadow-cljs">shadow-cljs</a> to compile the project, in part because it dramatically simplifies the process of using JavaScript libraries and dealing with externs.</p>
<p>We use <a href="https://github.com/leeoniya/uPlot">uPlot</a> for displaying time-series data. Our API backend is served using a <a href="https://www.eclipse.org/jetty/">Jetty</a> server, and we use <a href="https://github.com/weavejester/compojure">Compojure</a> to define backend routes.</p>
<p>Defining our front end in the same language as the rest of our codebase is a huge win, especially the ease of shuttling data back and forth between Clojure and ClojureScript. The immutable style emphasized by Clojure is just as beneficial in front-end code as back-end code, so being able to leverage that consistently benefits our productivity and the robustness of our product greatly.</p>
</div>



<h2 id="libraries">Libraries</h2>



<div><p>Here are many of the external libraries we use in our codebase, a mixture of Clojure, ClojureScript, Java, and Javascript libraries:</p>
<ul>
<li><a href="https://asm.ow2.io/">ASM</a>: used for bytecode generation</li>
<li><a href="https://github.com/weavejester/compojure">Compojure</a>: used for defining routes in web server</li>
<li><a href="https://github.com/stuartsierra/component">Component</a>: used for defining subsystems with well-defined lifecycles</li>
<li><a href="https://www.eclipse.org/jetty/">Jetty</a>: used to serve data to our front end</li>
<li><a href="https://github.com/aysylu/loom">Loom</a>: used for representing graph data structures, especially within our compiler.</li>
<li><a href="https://netty.io/">Netty</a>: used for asynchronous network communication</li>
<li><a href="https://github.com/ptaoussanis/nippy">Nippy</a>: used for serialization</li>
<li><a href="https://github.com/clj-commons/potemkin">Potemkin</a>: used for a few utilities, especially &#34;import-namespace&#34;, &#34;import-vars&#34;, and &#34;def-map-type&#34;</li>
<li><a href="https://github.com/metosin/reitit">reitit</a>: used for front-end routing</li>
<li><a href="https://github.com/day8/re-frame">re-frame</a>: used to build our web code</li>
<li><a href="https://rocksdb.org/">RocksDB</a>: used for some durable indexing tasks</li>
<li><a href="https://github.com/plumatic/schema">Schema</a>: used for defining types with rich schemas</li>
<li><a href="https://github.com/thheller/shadow-cljs">shadow-cljs</a>: used for compiling front-end code</li>
<li><a href="https://github.com/asomov/snakeyaml">SnakeYAML</a>: used for parsing YAML</li>
<li><a href="https://thrift.apache.org/">Thrift</a>: used to help power some of the CLI of our product</li>
<li><a href="https://github.com/leeoniya/uPlot">uPlot</a>: used to display time series graphs in our front end</li>
</ul>
</div>



<h2 id="conclusion">Conclusion</h2>



<div><p>Clojure has been fantastic for developing our product. It’s enabled us to build powerful abstractions not possible in other languages, remove all ceremony whatsoever, and utilize powerful testing techniques. Plus we’ve had multiple members on our team start with no Clojure or functional programming experience and they were able to get up to speed quickly.</p>
<p>If you’re interested in working with us to help define the future of software development, <a href="https://redplanetlabs.com/careers">we’re hiring</a>! We work on hard problems pushing what’s possible with compilers, databases, and distributed systems. Our team is <a href="https://medium.com/red-planet-labs/why-fully-distributed-is-by-far-the-best-way-to-run-a-software-team-d99abfc0c700">fully distributed</a> and we’re open to hiring anywhere in the world.</p>
</div>
			</div><!-- .entry-content -->

	<!-- .entry-footer -->

	</article></div>
  </body>
</html>
