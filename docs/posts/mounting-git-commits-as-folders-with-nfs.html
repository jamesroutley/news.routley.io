<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jvns.ca/blog/2023/12/04/mounting-git-commits-as-folders-with-nfs/">Original</a>
    <h1>Mounting git commits as folders with NFS</h1>
    
    

<p>Hello! The other day, I started wondering &ndash; has anyone ever made a FUSE
filesystem for a git repository where all every commit is a folder? It turns
out the answer is yes! There&rsquo;s <a href="https://github.com/fanzeyi/giblefs">giblefs</a>,
<a href="https://belkadan.com/blog/2023/11/GitMounter/">GitMounter</a>, and <a href="https://orib.dev/git9.html">git9</a> for Plan 9.</p>

<p>But FUSE is pretty annoying to use on Mac &ndash; you need to install a kernel
extension, and Mac OS seems to be making it harder and harder to install kernel
extensions for security reasons. Also I had a few ideas for how to organize the
filesystem differently than those projects.</p>

<p>So I thought it would be fun to experiment with ways to mount filesystems on
Mac OS other than FUSE, so I built a project that does that called
<a href="https://github.com/jvns/git-commit-folders">git-commit-folders</a>. It works (at least on my computer) with both FUSE and NFS, and there&rsquo;s a broken WebDav
implementation too.</p>

<p>It&rsquo;s pretty experimental (I&rsquo;m not sure if this is actually a useful piece of
software to have or just a fun toy to think about how git works) but it was fun
to write and I&rsquo;ve enjoyed using it myself on small repositories so here are
some of the problems I ran into while writing it.</p>

<h3 id="goal-show-how-commits-are-like-folders">goal: show how commits are like folders</h3>

<p>The main reason I wanted to make this was to give folks some intuition for how
git works under the hood. After all, git commits really <em>are</em> very similar to
folders &ndash; every Git commit <a href="https://jvns.ca/blog/2023/09/14/in-a-git-repository--where-do-your-files-live-/#commit-step-2-look-at-the-tree">contains a directory listing</a> of the files in it,
and that directory can have subdirectories, etc.</p>

<p>It&rsquo;s just that git commits aren&rsquo;t <em>actually</em> implemented as folders to save
disk space.</p>

<p>So in <code>git-commit-folders</code>, every commit is actually a folder, and if you want
to explore your old commits, you can do it just by exploring the filesystem!
For example, if I look at the initial commit for my blog, it looks like this:</p>

<pre><code>$ ls commits/8d/8dc0/8dc0cb0b4b0de3c6f40674198cb2bd44aeee9b86/
README
</code></pre>

<p>and a few commits later, it looks like this:</p>

<pre><code>$ ls /tmp/git-homepage/commits/c9/c94e/c94e6f531d02e658d96a3b6255bbf424367765e9/
_config.yml  config.rb  Rakefile  rubypants.rb  source
</code></pre>

<h3 id="branches-are-symlinks">branches are symlinks</h3>

<p>In the filesystem mounted by <code>git-commit-folders</code>, commits are the only real folders &ndash; everything
else (branches, tags, etc) is a symlink to a commit. This mirrors how git works under the hood.</p>

<pre><code>$ ls -l branches/
lr-xr-xr-x 59 bork bazil-fuse -&gt; ../commits/ff/ff56/ff563b089f9d952cd21ac4d68d8f13c94183dcd8
lr-xr-xr-x 59 bork follow-symlink -&gt; ../commits/7f/7f73/7f73779a8ff79a2a1e21553c6c9cd5d195f33030
lr-xr-xr-x 59 bork go-mod-branch -&gt; ../commits/91/912d/912da3150d9cfa74523b42fae028bbb320b6804f
lr-xr-xr-x 59 bork mac-version -&gt; ../commits/30/3008/30082dcd702b59435f71969cf453828f60753e67
lr-xr-xr-x 59 bork mac-version-debugging -&gt; ../commits/18/18c0/18c0db074ec9b70cb7a28ad9d3f9850082129ce0
lr-xr-xr-x 59 bork main -&gt; ../commits/04/043e/043e90debbeb0fc6b4e28cf8776e874aa5b6e673
$ ls -l tags/
lr-xr-xr-x - bork 31 Dec  1969 test-tag -&gt; ../commits/16/16a3/16a3d776dc163aa8286fb89fde51183ed90c71d0
</code></pre>

<p>This definitely doesn&rsquo;t completely explain how git works (there&rsquo;s a lot more to
it than just &ldquo;a commit is like a folder!&rdquo;), but my hope is that it makes thie
idea that every commit is like a folder with an old version of your code&rdquo; feel
a little more concrete.</p>

<h3 id="why-might-this-be-useful">why might this be useful?</h3>

<p>Before I get into the implementation, I want to talk about why having a filesystem
with a folder for every git commit in it might be useful. A lot of my projects
I end up never really using at all (like <a href="https://github.com/jvns/dnspeep">dnspeep</a>) but I did find myself using this
project a little bit while I was working on it.</p>

<p>The main uses I&rsquo;ve found so far are:</p>

<ul>
<li>searching for a function I deleted &ndash; I can run <code>grep someFunction branch_histories/main/*/commit.go</code> to find an old version of it</li>
<li>quickly looking at a file on another branch to copy a line from it, like <code>vim branches/other-branch/go.mod</code></li>
<li>searching every branch for a function, like <code>grep someFunction branches/*/commit.go</code></li>
</ul>

<p>All of these are through symlinks to commits instead of referencing commits
directly.</p>

<p>None of these are the most efficient way to do this (you can use <code>git show</code> and
<code>git log -S</code> or maybe <code>git grep</code> to accomplish something similar), but
personally I always forget the syntax and navigating a filesystem feels easier
to me. <code>git worktree</code> also lets you have multiple branches checked out at the same
time, but to me it feels weird to set up an entire worktree just to look at 1
file.</p>

<p>Next I want to talk about some problems I ran into.</p>

<h3 id="problem-1-webdav-or-nfs">problem 1: webdav or NFS?</h3>

<p>The two filesystems I could that were natively supported by Mac OS were WebDav
and NFS. I couldn&rsquo;t tell which would be easier to implement so I just
tried both.</p>

<p>At first webdav seemed easier and it turns out that golang.org/x/net has a
<a href="https://pkg.go.dev/golang.org/x/net/webdav">webdav implementation</a>, which  was
pretty easy to set up.</p>

<p>But that implementation doesn&rsquo;t support symlinks, I think because it uses the <code>io/fs</code> interface
and <code>io/fs</code> doesn&rsquo;t <a href="https://github.com/golang/go/issues/49580">support symlinks yet</a>. Looks like that&rsquo;s in progress
though. So I gave up on webdav and decided to focus on the NFS implementation, using this <a href="https://github.com/willscott/go-nfs/">go-nfs</a> NFSv3 library.</p>

<p>Someone also mentioned that there&rsquo;s
<a href="https://developer.apple.com/documentation/fileprovider/">FileProvider</a> on Mac
but I didn&rsquo;t look into that.</p>

<h3 id="problem-2-how-to-keep-all-the-implementations-in-sync">problem 2: how to keep all the implementations in sync?</h3>

<p>I was implementing 3 different filesystems (FUSE, NFS, and WebDav), and it
wasn&rsquo;t clear to me how to avoid a lot of duplicated code.</p>

<p>My friend Dave suggested writing one core implementation and then writing
adapters (like <code>fuse2nfs</code> and <code>fuse2dav</code>) to translate it into the NFS and
WebDav verions. What this looked like in practice is that I needed to implement
3 filesystem interfaces:</p>

<ul>
<li><code>fs.FS</code> for FUSE</li>
<li><code>billy.Filesystem</code> for NFS</li>
<li><code>webdav.Filesystem</code> for webdav</li>
</ul>

<p>So I put all the core logic in the <code>fs.FS</code> interface, and then wrote two functions:</p>

<ul>
<li><code>func Fuse2Dav(fs fs.FS) webdav.FileSystem</code></li>
<li><code>func Fuse2NFS(fs fs.FS) billy.Filesystem</code></li>
</ul>

<p>All of the filesystems were kind of similar so the translation wasn&rsquo;t too hard,
there were just 1 million annoying bugs to fix.</p>

<h3 id="problem-3-i-didn-t-want-to-list-every-commit">problem 3: I didn&rsquo;t want to list every commit</h3>

<p>Some git repositories have thousands or millions of commits. My first idea for how to address this was to make <code>commits/</code> appear empty, so that it works like this:</p>

<pre><code>$ ls commits/
$ ls commits/80210c25a86f75440110e4bc280e388b2c098fbd/
fuse  fuse2nfs  go.mod  go.sum  main.go  README.md
</code></pre>

<p>So every commit would be available if you reference it directly, but you can&rsquo;t
list them. This is a weird thing for a filesystem to do but it actually works
fine in FUSE. I couldn&rsquo;t get it to work in NFS though. I assume what&rsquo;s going on
here is that if you tell NFS that a directory is empty, it&rsquo;ll interpret that
the directory is actually empty, which is fair.</p>

<p>I ended up handling this by:</p>

<ul>
<li>organizing the commits by their 2-character prefix the way <code>.git/objects</code>
does (so that <code>ls commits</code> shows <code>0b 03 05 06 07 09 1b 1e 3e 4a</code>), but doing
2 levels of this so that a <code>18d46e76d7c2eedd8577fae67e3f1d4db25018b0</code> is at <code>commits/18/18df/18d46e76d7c2eedd8577fae67e3f1d4db25018b0</code></li>
<li>listing all the packed commits hashes only once at the beginning, caching
them in memory, and then only updating the loose objects afterwards. The idea
is that almost all of the commits in the repo should be packed and git
doesn&rsquo;t repack its commits very often.</li>
</ul>

<p>This seems to work okay on the Linux kernel which has ~1 million commits. It
takes maybe a minute to do the initial load on my machine and then after that
it just needs to do fast incremental updates.</p>

<p>Each commit hash is only 20 bytes so caching 1 million commit hashes isn&rsquo;t a
big deal, it&rsquo;s just 20MB.</p>

<p>I think a smarter way to do this would be to load the commit listings lazily &ndash;
Git sorts its packfiles by commit ID, so you can pretty easily do a binary
search to find all commits starting with <code>1b</code> or <code>1b8c</code>. The <a href="https://github.com/go-git/go-git">git library</a> I was using
doesn&rsquo;t have great support for this though, because listing all commits in a
Git repository is a really weird thing to do. I spent maybe a couple of days
<a href="https://github.com/jvns/git-commit-folders/tree/fast-commits">trying to implement it</a> but I didn&rsquo;t manage to get the performance I wanted so I
gave up.</p>

<h3 id="problem-4-not-a-directory">problem 4: &ldquo;not a directory&rdquo;</h3>

<p>I kept getting this error:</p>

<pre><code>&quot;/tmp/mnt2/commits/59/59167d7d09fd7a1d64aa1d5be73bc484f6621894/&quot;: Not a directory (os error 20)
</code></pre>

<p>This really threw me off at first but it turns out that this just means that
there was an error while listing the directory, and the way the NFS library
handles that error is with &ldquo;Not a directory&rdquo;. This happened a bunch of times
and I just needed to track the bug down every time.</p>

<p>There were a lot of weird errors like this. I also got <code>cd: system call
interrupted</code> which was pretty upsetting but ultimately was just some other bug
in my program.</p>

<p>Eventually I realized that I could use Wireshark to look at all the NFS
packets being sent back and forth, which made some of this stuff easier to debug.</p>

<h3 id="problem-5-inode-numbers">problem 5: inode numbers</h3>

<p>At first I was accidentally setting all my directory inode numbers to 0. This
was bad because if if you run <code>find</code> on a directory where the inode number of
every directory is 0, it&rsquo;ll complain about filesystem loops and give up, which
is very fair.</p>

<p>I fixed this by defining an <code>inode(string)</code> function which hashed a string to
get the inode number, and using the tree ID / blob ID as the string to hash.</p>

<h3 id="problem-6-stale-file-handles">problem 6: stale file handles</h3>

<p>I kept getting this &ldquo;Stale NFS file handle&rdquo; error. The problem is that I need
to be able to take an opaque 64-byte NFS &ldquo;file handle&rdquo; and map it to the right
directory.</p>

<p>The way the NFS library I&rsquo;m using works is that it generates a file handle for
every file and caches those references with a fixed size cache. This works fine
for small repositories, but if there are too many files then it&rsquo;ll overflow the
cache and you&rsquo;ll start getting stale file handle errors.</p>

<p>This is still a problem and I&rsquo;m not sure how to fix it. I don&rsquo;t understand how
real NFS servers do this, maybe they just have a really big cache?</p>

<p>The NFS file handle is 64 bytes (64 bytes! not bits!) which is pretty big, so
it does seem like you could just encode the entire file path in the handle a
lot of the time and not cache it at all. Maybe I&rsquo;ll try to implement that at
some point.</p>

<h3 id="problem-7-branch-histories">problem 7: branch histories</h3>

<p>The <code>branch_histories/</code> directory only lists the latest 100 commits for each
branch right now. Not sure what the right move is there &ndash; it would be nice to
be able to list the full history of the branch somehow. Maybe I could use a
similar subfolder trick to the <code>commits/</code> directory.</p>

<h3 id="problem-8-submodules">problem 8: submodules</h3>

<p>Git repositories sometimes have submodules. I don&rsquo;t understand anything about
submodules so right now I&rsquo;m just ignoring them. So that&rsquo;s a bug.</p>

<h3 id="problem-9-is-nfsv4-better">problem 9: is NFSv4 better?</h3>

<p>I built this with NFSv3 because the only Go library I could find at the time
was an NFSv3 library. After I was done I discovered that the buildbarn project
has an <a href="https://github.com/buildbarn/bb-adrs/blob/master/0009-nfsv4.md">NFSv4 server</a> in it. Would it be better to use that?</p>

<p>I don&rsquo;t know if this is actually a problem or how big of an advantage it would
be to use NFSv4. I&rsquo;m also a little unsure about using the buildbarn NFS library
because it&rsquo;s not clear if they expect other people to use it or not.</p>

<h3 id="that-s-all">that&rsquo;s all!</h3>

<p>There are probably more problems I forgot but that&rsquo;s all I can think of for
now. I may or may not fix the NFS stale file handle problem or the &ldquo;it takes 1
minute to start up on the linux kernel&rdquo; problem, who knows!</p>

<p>Thanks to my friend <a href="https://github.com/vasi">vasi</a> who explained one million things about filesystems to me.</p>

  </body>
</html>
