<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://larstofus.com/2025/04/05/how-deleting-multiplayer-from-the-engine-can-save-memory/">Original</a>
    <h1>Deleting multiplayer from the Unreal engine can save memory</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Although the title of this article might suggest otherwise, I don’t  dislike Unreal’s multiplayer features. As someone who has worked on two different multiplayer games in Unreal, I enjoy Unreal’s seamless multiplayer integration. It’s built deep into the engine instead of being moved to an optional plugin like so many other features. You can test any project in multiplayer mode without writing a single line of code. Of course, it will not work properly without many corresponding changes to the structure of your game, but still: Multiplayer is in the DNA of the engine.</p>



<p>This has many advantages and makes multiplayer development much easier compared to Unity  where you have to install and activate additional plugins and libraries before you can start working on multiplayer features.</p>



<p>But there must be some drawbacks to this approach, right? What if you were working on a single-player game? Is there a disadvantage from having all these features?</p>



<p>For the most part, no. Unused code/features don’t affect the performance of your game (at least not in a measurable way). But there are some small exceptions. One of them is the required data that needs to be stored in Unreal’s base classes for multiplayer to work. Mostly simple variables like “bReplicates” in the AActor class, which defines if an actor should be replicated over the network or not.</p>



<figure><img loading="lazy" data-attachment-id="573" data-permalink="https://larstofus.com/2025/04/05/how-deleting-multiplayer-from-the-engine-can-save-memory/image-86/" data-orig-file="https://larstofus.com/wp-content/uploads/2025/03/image-9.png" data-orig-size="1053,217" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=300" data-large-file="https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=1024" width="1024" height="211" src="https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=1024" alt="" srcset="https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=1024 1024w, https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=150 150w, https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=300 300w, https://larstofus.com/wp-content/uploads/2025/03/image-9.png?w=768 768w, https://larstofus.com/wp-content/uploads/2025/03/image-9.png 1053w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Even when developing a singleplayer game, this data still needs to be stored in every instance of the class, it remains unused. But so far, this mostly seems a theoretical optimization, not very worthwhile to do in a real project. This variable is even implemented as part of a bitmask, so we wouldn’t even save a single byte, it’s just a single bit of unused data. Doing any change to a working codebase to save a few bytes in memory? No thanks.</p>



<p>At least that was my opinion until I happened to show some students Visual Studio’s Memory Layout Visualizer, using the AActor class as an example. This tool displays the memory layout of any class, like this:</p>



<figure><img loading="lazy" data-attachment-id="575" data-permalink="https://larstofus.com/2025/04/05/how-deleting-multiplayer-from-the-engine-can-save-memory/image-87/" data-orig-file="https://larstofus.com/wp-content/uploads/2025/03/image-10.png" data-orig-size="733,549" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://larstofus.com/wp-content/uploads/2025/03/image-10.png?w=300" data-large-file="https://larstofus.com/wp-content/uploads/2025/03/image-10.png?w=733" width="733" height="549" src="https://larstofus.com/wp-content/uploads/2025/03/image-10.png?w=733" alt="" srcset="https://larstofus.com/wp-content/uploads/2025/03/image-10.png 733w, https://larstofus.com/wp-content/uploads/2025/03/image-10.png?w=150 150w, https://larstofus.com/wp-content/uploads/2025/03/image-10.png?w=300 300w" sizes="(max-width: 733px) 100vw, 733px"/></figure>



<p>And only now did I stumble over the actual size of some multiplayer-only data:</p>



<figure><img loading="lazy" data-attachment-id="577" data-permalink="https://larstofus.com/2025/04/05/how-deleting-multiplayer-from-the-engine-can-save-memory/image-88/" data-orig-file="https://larstofus.com/wp-content/uploads/2025/03/image-11.png" data-orig-size="654,920" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://larstofus.com/wp-content/uploads/2025/03/image-11.png?w=213" data-large-file="https://larstofus.com/wp-content/uploads/2025/03/image-11.png?w=654" width="654" height="920" src="https://larstofus.com/wp-content/uploads/2025/03/image-11.png?w=654" alt="" srcset="https://larstofus.com/wp-content/uploads/2025/03/image-11.png 654w, https://larstofus.com/wp-content/uploads/2025/03/image-11.png?w=107 107w, https://larstofus.com/wp-content/uploads/2025/03/image-11.png?w=213 213w" sizes="(max-width: 654px) 100vw, 654px"/></figure>



<p>Yes, to replicate the component attachments and the actor’s movement over the network, Unreal uses some custom structs that are 120 and 216 bytes respectively. Suddenly the idea of removing some multiplayer features from the engine to save memory didn’t seem bad anymore. If I could find some more data like this, it might actually make a measurable difference.</p>



<p>Going through all the data in the class, I found more and more variables that would be completely unused in singleplayer games. Things like the NetUpdateFrequency and MinNetUpdateFrequency (4 bytes each), the PhysicsReplicationMode (1 byte) or the list of “ReplicatedComponents” (16 bytes). After going through the whole list and doing the math, I got a potential memory reduction of 328 bytes. This would reduce the size of an actor from 1088 to 760 bytes (editor build)/from 840 to 528 bytes (standalone build). And yes, the difference is not exactly the same between the two build configurations because of alignment shifts, but I didn’t want to start moving things around on top of all the changes.</p>



<p>And now we are getting to the downside of all those memory savings: It’s not easy to do it in a clean way. My first idea was to exclude all these members via a preprocessor macro, so that I could switch back and forth between a multiplayer and singleplayer build configuration:</p>



<figure><img data-attachment-id="581" data-permalink="https://larstofus.com/2025/04/05/how-deleting-multiplayer-from-the-engine-can-save-memory/image-89/" data-orig-file="https://larstofus.com/wp-content/uploads/2025/04/image.png" data-orig-size="789,170" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://larstofus.com/wp-content/uploads/2025/04/image.png?w=300" data-large-file="https://larstofus.com/wp-content/uploads/2025/04/image.png?w=789" loading="lazy" width="789" height="170" src="https://larstofus.com/wp-content/uploads/2025/04/image.png?w=789" alt="" srcset="https://larstofus.com/wp-content/uploads/2025/04/image.png 789w, https://larstofus.com/wp-content/uploads/2025/04/image.png?w=150 150w, https://larstofus.com/wp-content/uploads/2025/04/image.png?w=300 300w, https://larstofus.com/wp-content/uploads/2025/04/image.png?w=768 768w" sizes="(max-width: 789px) 100vw, 789px"/></figure>



<p>I really liked this approach when I tried it, especially since it was consistent to similar Macros like UE_SERVER that Unreal already uses to compile UI stuff out of dedicated server builds.</p>



<figure><img data-attachment-id="583" data-permalink="https://larstofus.com/2025/04/05/how-deleting-multiplayer-from-the-engine-can-save-memory/image-90/" data-orig-file="https://larstofus.com/wp-content/uploads/2025/04/image-1.png" data-orig-size="730,177" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image" data-image-description="" data-image-caption="" data-medium-file="https://larstofus.com/wp-content/uploads/2025/04/image-1.png?w=300" data-large-file="https://larstofus.com/wp-content/uploads/2025/04/image-1.png?w=730" loading="lazy" width="730" height="177" src="https://larstofus.com/wp-content/uploads/2025/04/image-1.png?w=730" alt="" srcset="https://larstofus.com/wp-content/uploads/2025/04/image-1.png 730w, https://larstofus.com/wp-content/uploads/2025/04/image-1.png?w=150 150w, https://larstofus.com/wp-content/uploads/2025/04/image-1.png?w=300 300w" sizes="(max-width: 730px) 100vw, 730px"/></figure>



<p>The problem: The Unreal Header Tool (UHT), that parses the code to handle all the reflection for UPROPERTYs doesn’t like it if you exclude or include UPROPERTYs based on some preprocessor macros and will abort  it’s work when you try to do so. It’s definitely not impossible, for example the WITH_EDITORONLY_DATA macro does exactly that, but I would probably need to modify the UHT for it – something that I felt was out of scope for my experiment. </p>



<p>(If you by any chance are more familiar with the UHT and know how to handle such preprocessor macros, feel free to message me or leave me a comment. I would love to do a follow-up on this idea.)</p>



<p>So I resorted to commenting out the variables in question and all the code that used them.  A mind-numbing but simple task. If you plan to try this optimization I would recommend to get a BIG coffee before starting this phase, it will take a while. Double that, if you do it in an actual production environment and have to document all your engine changes. </p>



<p>After modifying 58 engine files, my editor finally booted again and to my great relieve everything worked as intended.</p>



<h2> How much did it save?</h2>



<p>I’ve already told you that this method saves 328 bytes per actor, which is not too much at first glance. You can apply the same trick for SceneComponents and save another 32 bytes per SceneComponent. Assuming an average of two SceneComponents per actor, you get up to 392 bytes per actor. Still not an impressive number unless you deal with a lot of actors. A hypothetical example level with 25 000 actors (which is a lot, but not unreasonable) will save about 10 MB.</p>



<h2>Is it worth it?</h2>



<p>For most projects, I would say the answer is no. There are many, many other ways to save more significant amounts of memory that you should pursue first. But like with many other possible optimizations it’s better to have this option available to you than not.</p>



<p>If this experiment was interesting to you, consider following me on other platforms like <a href="https://mastodon.gamedev.place/@LarsThiessen">Mastodon</a>, <a href="https://bsky.app/profile/larstofus.bsky.social">Bluesky</a> or <a href="https://www.linkedin.com/in/lars-thie%C3%9Fen-a640ba141/">LinkedIn</a> for more articles about Unreal, game optimization or other gamedev topics 🙂 You can also subscribe to this blog directly below this article to stay informed about future posts.</p>
</div></div>
  </body>
</html>
