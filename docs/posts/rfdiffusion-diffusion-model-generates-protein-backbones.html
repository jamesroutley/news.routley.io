<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/RosettaCommons/RFdiffusion">Original</a>
    <h1>RFdiffusion: Diffusion model generates protein backbones</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">

<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/diffusion_protein_gradient_2.jpg"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/diffusion_protein_gradient_2.jpg" alt="alt text" width="1100px"/></a>
</p>
<p dir="auto"><em>Image: Ian C. Haydon / UW Institute for Protein Design</em></p>
<h2 tabindex="-1" dir="auto"><a id="user-content-description" aria-hidden="true" href="#description"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Description</h2>
<p dir="auto">RFdiffusion is an open source method for structure generation, with or without conditional information (a motif, target etc). It can perform a whole range of protein design challenges as we have outlined in <a href="https://www.biorxiv.org/content/10.1101/2022.12.09.519842v1" rel="nofollow">the RFdiffusion paper</a>.</p>
<p dir="auto"><strong>Things Diffusion can do</strong></p>
<ul dir="auto">
<li>Motif Scaffolding</li>
<li>Unconditional protein generation</li>
<li>Symmetric unconditional generation (cyclic, dihedral and tetrahedral symmetries currently implemented, more coming!)</li>
<li>Symmetric motif scaffolding</li>
<li>Binder design</li>
<li>Design diversification (&#34;partial diffusion&#34;, sampling around a design)</li>
</ul>
<hr/>
<h2 tabindex="-1" dir="auto"><a id="user-content-getting-started--installation" aria-hidden="true" href="#getting-started--installation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Getting started / installation</h2>
<p dir="auto">Thanks to Sergey Ovchinnikov, RFdiffusion is available as a <a href="https://colab.research.google.com/github/sokrypton/ColabDesign/blob/v1.1.1/rf/examples/diffusion.ipynb" rel="nofollow">Google Colab Notebook</a> if you would like to run it there!</p>
<p dir="auto">We strongly recommend reading this README carefully before getting started with RFdiffusion, and working through some of the examples in the Colab Notebook.</p>
<p dir="auto">If you want to set up RFdiffusion locally, follow the steps below:</p>
<p dir="auto">To get started using RFdiffusion, clone the repo:</p>
<div data-snippet-clipboard-copy-content="git clone https://github.com/RosettaCommons/RFdiffusion.git"><pre><code>git clone https://github.com/RosettaCommons/RFdiffusion.git
</code></pre></div>
<p dir="auto">You&#39;ll then need to download the model weights:</p>
<div data-snippet-clipboard-copy-content="mkdir models &amp;&amp; cd models
wget http://files.ipd.uw.edu/pub/RFdiffusion/6f5902ac237024bdd0c176cb93063dc4/Base_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/e29311f6f1bf1af907f9ef9f44b8328b/Complex_base_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/60f09a193fb5e5ccdc4980417708dbab/Complex_Fold_base_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/74f51cfb8b440f50d70878e05361d8f0/InpaintSeq_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/76d00716416567174cdb7ca96e208296/InpaintSeq_Fold_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/5532d2e1f3a4738decd58b19d633b3c3/ActiveSite_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/12fc204edeae5b57713c5ad7dcb97d39/Base_epoch8_ckpt.pt

Optional:
wget http://files.ipd.uw.edu/pub/RFdiffusion/f572d396fae9206628714fb2ce00f72e/Complex_beta_ckpt.pt"><pre><code>mkdir models &amp;&amp; cd models
wget http://files.ipd.uw.edu/pub/RFdiffusion/6f5902ac237024bdd0c176cb93063dc4/Base_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/e29311f6f1bf1af907f9ef9f44b8328b/Complex_base_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/60f09a193fb5e5ccdc4980417708dbab/Complex_Fold_base_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/74f51cfb8b440f50d70878e05361d8f0/InpaintSeq_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/76d00716416567174cdb7ca96e208296/InpaintSeq_Fold_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/5532d2e1f3a4738decd58b19d633b3c3/ActiveSite_ckpt.pt
wget http://files.ipd.uw.edu/pub/RFdiffusion/12fc204edeae5b57713c5ad7dcb97d39/Base_epoch8_ckpt.pt

Optional:
wget http://files.ipd.uw.edu/pub/RFdiffusion/f572d396fae9206628714fb2ce00f72e/Complex_beta_ckpt.pt
</code></pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-conda-install-se3-transformer" aria-hidden="true" href="#conda-install-se3-transformer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conda Install SE3-Transformer</h3>
<p dir="auto">Ensure that you have either <a href="https://conda.io/projects/conda/en/latest/user-guide/install/index.html" rel="nofollow">Anaconda or Miniconda</a> installed.</p>
<p dir="auto">You also need to install <a href="https://developer.nvidia.com/blog/accelerating-se3-transformers-training-using-an-nvidia-open-source-model-implementation/" rel="nofollow">NVIDIA&#39;s implementation of SE(3)-Transformers</a> Here is how to install the NVIDIA SE(3)-Transformer code:</p>
<div data-snippet-clipboard-copy-content="conda env create -f env/SE3nv.yml

conda activate SE3nv
cd env/SE3Transformer
pip install --no-cache-dir -r requirements.txt
python setup.py install"><pre><code>conda env create -f env/SE3nv.yml

conda activate SE3nv
cd env/SE3Transformer
pip install --no-cache-dir -r requirements.txt
python setup.py install
</code></pre></div>
<p dir="auto">Anytime you run diffusion you should be sure to activate this conda environment by running the following command:</p>

<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-get-ppi-scaffold-examples" aria-hidden="true" href="#get-ppi-scaffold-examples"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Get PPI Scaffold Examples</h3>
<p dir="auto">To run the scaffolded protein binder design (PPI) examples, we have provided some example scaffold files (<code>examples/ppi_scaffolds_subset.tar.gz</code>).
You&#39;ll need to untar this:</p>
<div data-snippet-clipboard-copy-content="tar -xvf examples/ppi_scaffolds_subset.tar.gz -C examples/"><pre><code>tar -xvf examples/ppi_scaffolds_subset.tar.gz -C examples/
</code></pre></div>
<p dir="auto">We will explain what these files are and how to use them in the Fold Conditioning section.</p>
<hr/>

<p dir="auto">In this section we will demonstrate how to run diffusion.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/main.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/main.png" alt="alt text" width="1100px"/></a>
</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-running-the-diffusion-script" aria-hidden="true" href="#running-the-diffusion-script"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Running the diffusion script</h3>
<p dir="auto">The actual script you will execute is called <code>run_inference.py</code>. There are many ways to run it, governed by hydra configs.
<a href="https://hydra.cc/docs/configure_hydra/intro/" rel="nofollow">Hydra configs</a> are a nice way of being able to specify many different options, with sensible defaults drawn <em>directly</em> from the model checkpoint, so inference should always, by default, match training.
What this means is that the default values in <code>config/inference/base.yml</code> might not match the actual values used during inference, with a specific checkpoint. This is all handled under the hood.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-basic-execution---an-unconditional-monomer" aria-hidden="true" href="#basic-execution---an-unconditional-monomer"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Basic execution - an unconditional monomer</h3>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/cropped_uncond.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/cropped_uncond.png" alt="alt text" width="400px"/></a></p>
<p dir="auto">Let&#39;s first look at how you would do unconditional design of a protein of length 150aa.
For this, we just need to specify three things:</p>
<ol dir="auto">
<li>The length of the protein</li>
<li>The location where we want to write files to</li>
<li>The number of designs we want</li>
</ol>
<div data-snippet-clipboard-copy-content="./run_inference.py &#39;contigmap.contigs=[150-150]&#39; inference.output_prefix=test_outputs/test inference.num_designs=10"><pre><code>./run_inference.py &#39;contigmap.contigs=[150-150]&#39; inference.output_prefix=test_outputs/test inference.num_designs=10
</code></pre></div>
<p dir="auto">Let&#39;s look at this in detail.
Firstly, what is <code>contigmap.contigs</code>?
Hydra configs tell the inference script how it should be run. To keep things organised, the config has different sub-configs, one of them being <code>contigmap</code>, which pertains to everything related to the contig string (that defines the protein being built).
Take a look at the config file if this isn&#39;t clear: <code>configs/inference/base.yml</code>
Anything in the config can be overwritten manually from the command line. You could, for example, change how the diffuser works:</p>

<p dir="auto">... but don&#39;t do this unless you really know what you&#39;re doing!!</p>
<p dir="auto">Now, what does <code>&#39;contigmap.contigs=[150-150]&#39;</code> mean?
To those who have used RFjoint inpainting, this might look familiar, but a little bit different. Diffusion, in fact, uses the identical &#39;contig mapper&#39; as inpainting, except that, because we&#39;re using hydra, we have to give this to the model in a different way. The contig string has to be passed as a single-item in a list, rather than as a string, for hydra reasons and the entire argument MUST be enclosed in <code>&#39;&#39;</code> so that the commandline does not attempt to parse any of the special characters.</p>
<p dir="auto">The contig string allows you to specify a length range, but here, we just want a protein of 150aa in length, so you just specify [150-150]
This will then run 10 diffusion trajectories, saving the outputs to your specified output folder.</p>
<p dir="auto">NB the first time you run RFdiffusion, it will take a while &#39;Calculating IGSO3&#39;. Once it has done this, it&#39;ll be cached for future reference though! For an additional example of unconditional monomer generation, take a look at <code>./examples/design_unconditional.sh</code> in the repo!</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-motif-scaffolding" aria-hidden="true" href="#motif-scaffolding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Motif Scaffolding</h3>

<p dir="auto">RFdiffusion can be used to scaffold motifs, in a manner akin to <a href="https://www.science.org/doi/10.1126/science.abn2100#:~:text=The%20binding%20and%20catalytic%20functions%20of%20proteins%20are,the%20fold%20or%20secondary%20structure%20of%20the%20scaffold." rel="nofollow">Constrained Hallucination and RFjoint Inpainting</a>. In general, RFdiffusion significantly outperforms both Constrained Hallucination and RFjoint Inpainting.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/motif.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/motif.png" alt="alt text" width="700px"/></a>
</p>
<p dir="auto">When scaffolding protein motifs, we need a way of specifying that we want to scaffold some particular protein input (one or more segments from a <code>.pdb</code> file), and to be able to specify how we want these connected, and by how many residues, in the new scaffolded protein. What&#39;s more, we want to be able to sample different lengths of connecting protein, as we generally don&#39;t know <em>a priori</em> precisely how many residues we&#39;ll need to best scaffold a motif. This job of specifying inputs is handled by contigs, governed by the contigmap config in the hydra config. For those familiar with Constrained Hallucination or RFjoint Inpainting, the logic is very similar.
Briefly:</p>
<ul dir="auto">
<li>Anything prefixed by a letter indicates that this is a motif, with the letter corresponding to the chain letter in the input pdb files. E.g. A10-25 pertains to residues (&#39;A&#39;,1),(&#39;A&#39;,2)...(&#39;A&#39;,10) in the corresponding input pdb</li>
<li>Anything not prefixed by a letter indicates protein <em>to be built</em>. This can be input as a length range. These length ranges are randomly sampled each iteration of RFdiffusion inference.</li>
<li>To specify chain breaks, we use <code>/0 </code>.</li>
</ul>
<p dir="auto">In more detail, if we want to scaffold a motif, the input is just like RFjoint Inpainting, except needing to navigate the hydra config input. If we want to scaffold residues 10-25 on chain A a pdb, this would be done with <code>&#39;contigmap.contigs=[5-15/A10-25/30-40]&#39;</code>. This asks RFdiffusion to build 5-15 residues (randomly sampled at each inference cycle) N-terminally of A10-25 from the input pdb, followed by 30-40 residues (again, randomly sampled) to its C-terminus. If we wanted to ensure the length was always e.g. 55 residues, this can be specified with <code>contigmap.length=55-55</code>. You need to obviously also provide a path to your pdb file: <code>inference.input_pdb=path/to/file.pdb</code>. It doesn&#39;t matter if your input pdb has residues you <em>don&#39;t</em> want to scaffold - the contig map defines which residues in the pdb are actually used as the &#34;motif&#34;. In other words, even if your pdb files has a B chain, and other residues on the A chain, <em>only</em> A10-25 will be provided to RFdiffusion.</p>
<p dir="auto">To specify that we want to inpaint in the presence of a separate chain, this can be done as follows:</p>
<div data-snippet-clipboard-copy-content="&#39;contigmap.contigs=[5-15/A10-25/30-40/0 B1-100]&#39;"><pre><code>&#39;contigmap.contigs=[5-15/A10-25/30-40/0 B1-100]&#39;
</code></pre></div>
<p dir="auto">Look at this carefully. <code>/0 </code> is the indicator that we want a chain break. NOTE, the space is important here. This tells the diffusion model to add a big residue jump (200aa) to the input, so that the model sees the first chain as being on a separate chain to the second.</p>
<p dir="auto">An example of motif scaffolding can be found in <code>./examples/design_motifscaffolding.sh</code>.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-the-active-site-model-holds-very-small-motifs-in-place" aria-hidden="true" href="#the-active-site-model-holds-very-small-motifs-in-place"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The &#34;active site&#34; model holds very small motifs in place</h3>
<p dir="auto">In the RFdiffusion preprint we noted that for very small motifs, RFdiffusion has the tendency to not keep them perfectly fixed in the output. Therefore, for scaffolding minimalist sites such as enzyme active sites, we fine-tuned RFdiffusion on examples similar to these tasks, allowing it to hold smaller motifs better in place, and better generate <em>in silico</em> successes. If your input functional motif is very small, we reccomend using this model, which can easily be specified using the following syntax:
<code>inference.ckpt_override_path=models/ActiveSite_ckpt.pt</code></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-the-inpaint_seq-flag" aria-hidden="true" href="#the-inpaint_seq-flag"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>inpaint_seq</code> flag</h3>
<p dir="auto">For those familiar with RFjoint Inpainting, the contigmap.inpaint_seq input is equivalent. The idea is that often, when, for example, fusing two proteins, residues that were on the surface of a protein (and are therefore likely polar), now need to be packed into the &#39;core&#39; of the protein. We therefore want them to become hydrophobic residues. What we can do, rather than directly mutating them to hydrophobics, is to mask their sequence identity, and allow RFdiffusion to implicitly reason over their sequence, and better pack against them. This requires a different model than the &#39;base&#39; diffusion model, that has been trained to understand this paradigm, but this is automatically handled by the inference script (you don&#39;t need to do anything).</p>
<p dir="auto">To specify amino acids whose sequence should be hidden, use the following syntax:</p>
<div data-snippet-clipboard-copy-content="&#39;contigmap.inpaint_seq=[A1/A30-40]&#39;"><pre><code>&#39;contigmap.inpaint_seq=[A1/A30-40]&#39;
</code></pre></div>
<p dir="auto">Here, we&#39;re masking the residue identity of residue A1, and all residues between A30 and A40 (inclusive).</p>
<p dir="auto">An example of executing motif scaffolding with the <code>contigmap.inpaint_seq</code> flag is located in <code>./examples/design_motifscaffolding_inpaintseq.sh</code></p>
<h3 tabindex="-1" dir="auto"><a id="user-content-a-note-on-diffusert" aria-hidden="true" href="#a-note-on-diffusert"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A note on <code>diffuser.T</code></h3>
<p dir="auto">RFdiffusion was originally trained with 200 discrete timesteps. However, recent improvements have allowed us to reduce the number of timesteps we need to use at inference time. In many cases, running with as few as approximately 20 steps provides outputs of equivalent <em>in silico</em> quality to running with 200 steps (providing a 10X speedup). The default is now set to 50 steps. Noting this is important for understanding the partial diffusion, described below.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-partial-diffusion" aria-hidden="true" href="#partial-diffusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Partial diffusion</h3>
<p dir="auto">Something we can do with diffusion is to partially noise and de-noise a structure, to get some diversity around a general fold. This can work really nicely (see <a href="https://www.biorxiv.org/content/10.1101/2022.12.10.519862v4.abstract" rel="nofollow">Vazquez-Torres et al., BioRxiv 2022</a>).
This is specified by using the diffuser.parial_T input, and setting a timestep to &#39;noise&#39; to.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/partial.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/partial.png" alt="alt text" width="800px"/></a>
</p>
More noise == more diversity. In Vazquez-Torres et al., 2022, we typically used `diffuser.partial_T` of approximately 80, but this was with respect to the 200 timesteps we were using. Now that the default `diffuser.T` is 50, you will need to adjust diffuser.partial_T accordingly. E.g. now that `diffuser.T=50`, the equivalent of 80 noising steps is `diffuser.partial_T=20`. We strongly recommend sampling different values for `partial_T` however, to find the best parameters for your specific problem.
<p dir="auto">When doing partial diffusion, because we are now diffusing from a known structure, this creates certain constraints. You can still use the contig input, but <em>this has to yield a contig string exactly the same length as the input protein</em>. E.g. if you have a binder:target complex, and you want to diversify the binder (length 100, chain A), you would need to input something like this:</p>
<div data-snippet-clipboard-copy-content="&#39;contigmap.contigs=[100-100/0 B1-150]&#39; diffuser.partial_T=20"><pre><code>&#39;contigmap.contigs=[100-100/0 B1-150]&#39; diffuser.partial_T=20
</code></pre></div>
<p dir="auto">The reason for this is that, if your input protein was only 80 amino acids, but you&#39;ve specified a desired length of 100, we don&#39;t know where to diffuse those extra 20 amino acids from, and hence, they will not lie in the distribution that RFdiffusion has learned to denoise from.</p>
<p dir="auto">An example of partial diffusion can be found in <code>./examples/design_partialdiffusion.sh</code>!</p>
<p dir="auto">You can also keep parts of the sequence of the diffused chain fixed, if you want. An example of why you might want to do this is in the context of helical peptide binding. If you&#39;ve threaded a helical peptide sequence onto an ideal helix, and now want to diversify the complex, allowing the helix to be predicted now not as an ideal helix, you might do something like:</p>
<div data-snippet-clipboard-copy-content="&#39;contigmap.contigs=[100-100/0 20-20]&#39; &#39;contigmap.provide_seq=[100-119]&#39; diffuser.partial_T=10"><pre><code>&#39;contigmap.contigs=[100-100/0 20-20]&#39; &#39;contigmap.provide_seq=[100-119]&#39; diffuser.partial_T=10
</code></pre></div>
<p dir="auto">In this case, the 20aa chain is the helical peptide. The <code>contigmap.provide_seq</code> input is zero-indexed, and you can provide a range (so 100-119 is an inclusive range, unmasking the whole sequence of the peptide).</p>
<p dir="auto">Note that the provide_seq option requires using a different model checkpoint, but this is automatically handled by the inference script.</p>
<p dir="auto">An example of partial diffusion with providing sequence in diffused regions can be found in <code>./examples/design_partialdiffusion_withseq.sh</code>.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-binder-design" aria-hidden="true" href="#binder-design"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Binder Design</h3>
<p dir="auto">Hopefully, it&#39;s now obvious how you might make a binder with diffusion! Indeed, RFdiffusion shows excellent <em>in silico</em> and experimental ability to design <em>de novo</em> binders.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/binder.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/binder.png" alt="alt text" width="950px"/></a>
</p>
<p dir="auto">If chain B is your target, then you could do it like this:</p>
<div data-snippet-clipboard-copy-content="./run_inference.py &#39;contigmap.contigs=[B1-100/0 100-100]&#39; inference.output_prefix=test_outputs/binder_test inference.num_designs=10"><pre><code>./run_inference.py &#39;contigmap.contigs=[B1-100/0 100-100]&#39; inference.output_prefix=test_outputs/binder_test inference.num_designs=10
</code></pre></div>
<p dir="auto">This will generate 100 residue long binders to residues 1-100 of chain B. You can find another example of</p>
<p dir="auto">However, this probably isn&#39;t the best way of making binders. Because diffusion is somewhat computationally-intensive, we need to try and make it as fast as possible. Providing the whole of your target, uncropped, is going to make diffusion very slow if your target is big (and most targets-of-interest, such as cell-surface receptors tend to be <em>very</em> big). One tried-and-true method to speed up binder design is to crop the target protein around the desired interface location. BUT! This creates a problem: if you crop your target and potentially expose hydrophobic core residues which were buried before the crop, how can you guarantee the binder will go to the intended interface site on the surface of the target, and not target the tantalizing hydrophobic patch you have just artificially created?</p>
<p dir="auto">We solve this issue by providing the model with what we call &#34;hotspot residues&#34;. The complex models we refer to earlier in this README file have all been trained with hotspot residues, in this training regime, during each example, the model is told (some of) the residues on the target protein which contact the target (i.e., resides that are part of the interface). The model readily learns that it should be making an interface which involved these hotspot residues. At inference time then, we can provide our own hotspot residues to define a region which the binder must contact. These are specfied like this: <code>&#39;ppi.hotspots=[A30,A33,A34]&#39;</code>, where <code>A</code> is the chain ID in the input pdb file of the hotspot residue and the number is the residue index in the input pdb file of the hotspot residue.</p>
<p dir="auto">Finally, it has been observed that the default RFdiffusion model often generates mostly helical binders. These have high computational and experimental success rates. However, there may be cases where other kinds of topologies may be desired. For this, we include a &#34;beta&#34; model, which generates a greater diversity of topologies, but has not been extensively experimentally validated. Try this at your own risk:</p>
<div data-snippet-clipboard-copy-content="inference.ckpt_override_path=models/Complex_beta_ckpt.pt"><pre><code>inference.ckpt_override_path=models/Complex_beta_ckpt.pt
</code></pre></div>
<p dir="auto">An example of binder design with RFdiffusion can be found in <code>./examples/design_ppi.sh</code>.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-fold-conditioning" aria-hidden="true" href="#fold-conditioning"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Fold Conditioning</h3>
<p dir="auto">Something that works really well is conditioning binder design (or monomer generation) on particular topologies. This is achieved by providing (partial) secondary structure and block adjacency information (to a model that has been trained to condition on this).</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/fold_cond.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/fold_cond.png" alt="alt text" width="950px"/></a>
</p>
We are still working out the best way to actually generate this input at inference time, but for now, we have settled upon generating inputs directly from pdb structures. This permits &#39;low resolution&#39; specification of output topology (i.e., I want a TIM barrel but I don&#39;t care precisely where resides are). In `helper_scripts/`, there&#39;s a script called `make_secstruc_adj.py`, which can be used as follows:
<p dir="auto">e.g. 1:</p>
<div data-snippet-clipboard-copy-content="./make_secstruc_adj.py --input_pdb ./2KL8.pdb --out_dir /my/dir/for/adj_secstruct"><pre><code>./make_secstruc_adj.py --input_pdb ./2KL8.pdb --out_dir /my/dir/for/adj_secstruct
</code></pre></div>
<p dir="auto">or e.g. 2:</p>
<div data-snippet-clipboard-copy-content="./make_secstruc_adj.py --pdb_dir ./pdbs/ --out_dir /my/dir/for/adj_secstruct"><pre><code>./make_secstruc_adj.py --pdb_dir ./pdbs/ --out_dir /my/dir/for/adj_secstruct
</code></pre></div>
<p dir="auto">This will process either a single pdb, or a folder of pdbs, and output a secondary structure and adjacency pytorch file, ready to go into the model. For now (although this might not be necessary), you should also generate these files for the target protein (if you&#39;re doing PPI), and provide this to the model. You can then use these at inference as follows:</p>
<div data-snippet-clipboard-copy-content="./run_inference.py inference.output_prefix=./scaffold_conditioned_test/test scaffoldguided.scaffoldguided=True scaffoldguided.target_pdb=False scaffoldguided.scaffold_dir=./examples/ppi_scaffolds_subset"><pre><code>./run_inference.py inference.output_prefix=./scaffold_conditioned_test/test scaffoldguided.scaffoldguided=True scaffoldguided.target_pdb=False scaffoldguided.scaffold_dir=./examples/ppi_scaffolds_subset
</code></pre></div>
<p dir="auto">A few exra things:</p>
<ol dir="auto">
<li>As mentioned above, for PPI, you will want to provide a target protein, along with its secondary structure and block adjacency. This can be done by adding:</li>
</ol>
<div data-snippet-clipboard-copy-content="scaffoldguided.target_pdb=True scaffoldguided.target_path=input_pdbs/insulin_target.pdb inference.output_prefix=insulin_binder/jordi_ss_insulin_noise0_job0 &#39;ppi.hotspot_res=[A59,A83,A91]&#39; scaffoldguided.target_ss=target_folds/insulin_target_ss.pt scaffoldguided.target_adj=target_folds/insulin_target_adj.pt"><pre><code>scaffoldguided.target_pdb=True scaffoldguided.target_path=input_pdbs/insulin_target.pdb inference.output_prefix=insulin_binder/jordi_ss_insulin_noise0_job0 &#39;ppi.hotspot_res=[A59,A83,A91]&#39; scaffoldguided.target_ss=target_folds/insulin_target_ss.pt scaffoldguided.target_adj=target_folds/insulin_target_adj.pt
</code></pre></div>
<p dir="auto">To generate these block adjacency and secondary structure inputs, you can use the helper script.</p>
<p dir="auto">This will now generate 3-helix bundles to the insulin target.</p>
<p dir="auto">For ppi, it&#39;s probably also worth adding this flag:</p>
<div data-snippet-clipboard-copy-content="scaffoldguided.mask_loops=False"><pre><code>scaffoldguided.mask_loops=False
</code></pre></div>
<p dir="auto">This is quite important to understand. During training, we mask some of the secondary structure and block adjacency. This is convenient, because it allows us to, at inference, easily add extra residues without having to specify precise secondary structure for every residue. E.g. if you want to make a long 3 helix bundle, you could mask the loops, and add e.g. 20 more &#39;mask&#39; tokens to that loop. The model will then (presumbly) choose to make e.g. 15 of these residues into helices (to extend the 3HB), and then make a 5aa loop. But, you didn&#39;t have to specify that, which is nice. The way this would be done would be like this:</p>
<div data-snippet-clipboard-copy-content="scaffoldguided.mask_loops=True scaffoldguided.sampled_insertion=15 scaffoldguided.sampled_N=5 scaffoldguided.sampled_C=5"><pre><code>scaffoldguided.mask_loops=True scaffoldguided.sampled_insertion=15 scaffoldguided.sampled_N=5 scaffoldguided.sampled_C=5
</code></pre></div>
<p dir="auto">This will, at each run of inference, sample up to 15 residues to insert into loops in your 3HB input, and up to 5 additional residues at N and C terminus.
This strategy is very useful if you don&#39;t have a large set of pdbs to make block adjacencies for. For example, we showed that we could generate loads of lengthened TIM barrels from a single starting pdb with this strategy. However, for PPI, if you&#39;re using the provided scaffold sets, it shouldn&#39;t be necessary (because there are so many scaffolds to start from, generating extra diversity isn&#39;t especially necessary).</p>
<p dir="auto">Finally, if you have a big directory of block adjacency/secondary structure files, but don&#39;t want to use all of them, you can make a <code>.txt</code> file of the ones you want to use, and pass:</p>
<div data-snippet-clipboard-copy-content="scaffoldguided.scaffold_list=path/to/list"><pre><code>scaffoldguided.scaffold_list=path/to/list
</code></pre></div>
<p dir="auto">For PPI, we&#39;ve consistently seen that reducing the noise added at inference improves designs. This comes at the expense of diversity, but, given that the scaffold sets are huge, this probably doesn&#39;t matter too much. We therefore recommend lowering the noise. 0.5 is probably a good compromise:</p>
<div data-snippet-clipboard-copy-content="denoiser.noise_scale_ca=0.5 denoiser.noise_scale_frame=0.5"><pre><code>denoiser.noise_scale_ca=0.5 denoiser.noise_scale_frame=0.5
</code></pre></div>
<p dir="auto">This just scales the amount of noise we add to the translations (<code>noise_scale_ca</code>) and rotations (<code>noise_scale_frame</code>) by, in this case, 0.5.</p>
<p dir="auto">An additional example of PPI with fold conditioning is available here: <code>./examples/design_ppi_scaffolded.sh</code></p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-generation-of-symmetric-oligomers" aria-hidden="true" href="#generation-of-symmetric-oligomers"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Generation of Symmetric Oligomers</h3>
<p dir="auto">We&#39;re going to switch gears from discussing PPI and look at another task at which RFdiffusion performs well on: symmetric oligomer design. This is done by symmetrising the noise we sample at t=T, and symmetrising the input at every timestep. We have currently implemented the following for use (with the others coming soon!):</p>
<ul dir="auto">
<li>Cyclic symmetry</li>
<li>Dihedral symmetry</li>
<li>Tetrahedral symmetry</li>
</ul>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/olig2.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/olig2.png" alt="alt text" width="1000px"/></a>
</p>
<p dir="auto">Here&#39;s an example:</p>
<div data-snippet-clipboard-copy-content="./run_inference.py --config-name symmetry  inference.symmetry=tetrahedral &#39;contigmap.contigs=[360]&#39; inference.output_prefix=test_sample/tetrahedral inference.num_designs=1"><pre><code>./run_inference.py --config-name symmetry  inference.symmetry=tetrahedral &#39;contigmap.contigs=[360]&#39; inference.output_prefix=test_sample/tetrahedral inference.num_designs=1
</code></pre></div>
<p dir="auto">Here, we&#39;ve specified a different <code>config</code> file (with <code>--config-name symmetry</code>). Because symmetric diffusion is quite different from the diffusion described above, we packaged a whole load of symmetry-related configs into a new file (see <code>configs/inference/symmetry.yml</code>). Using this config file now puts diffusion in <code>symmetry-mode</code>.</p>
<p dir="auto">The symmetry type is then specified with <code>inference.symmetry=</code>. Here, we&#39;re specifying tetrahedral symmetry, but you could also choose cyclic (e.g. <code>c4</code>) or dihedral (e.g. <code>d2</code>).</p>
<p dir="auto">The configmap.contigs length refers to the <em>total</em> length of your oligomer. Therefore, it <em>must</em> be divisible by <em>n</em> chains.</p>
<p dir="auto">More examples of designing oligomers can be found here: <code>./examples/design_cyclic_oligos.sh</code>, <code>./examples/design_dihedral_oligos.sh</code>, <code>./examples/design_tetrahedral_oligos.sh</code>.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-using-auxiliary-potentials" aria-hidden="true" href="#using-auxiliary-potentials"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Using Auxiliary Potentials</h3>
<p dir="auto">Performing diffusion with symmetrized noise may give you the idea that we could use other external interventions during the denoising process to guide diffusion. One such intervention that we have implemented is auxiliary potentials. Auxiliary potentials can be very useful for guiding the inference process. E.g. whereas in RFjoint inpainting, we have little/no control over the final shape of an output, in diffusion we can readily force the network to make, for example, a well-packed protein.
This is achieved in the updates we make at each step.</p>
<p dir="auto">Let&#39;s go a little deeper into how the diffusion process works:
At timestep T (the first step of the reverse-diffusion inference process), we sample noise from a known <em>prior</em> distribution. The model then makes a prediction of what the final structure should be, and we use these two states (noise at time T, prediction of the structure at time 0) to back-calculate where t=T-1 would have been. We therefore have a vector pointing from each coordinate at time T, to their corresponding, back-calculated position at time T-1.
But, we want to be able to bias this update, to <em>push</em> the trajectory towards some desired state. This can be done by biasing that vector with another vector, which points towards a position where that residue would <em>reduce</em> the &#39;loss&#39; as defined by your potential. E.g. if we want to use the <code>monomer_ROG</code> potential, which seeks to minimise the radius of gyration of the final protein, if the models prediction of t=0 is very elongated, each of those distant residues will have a larger gradient when we differentiate the <code>monomer_ROG</code> potential w.r.t. their positions. These gradients, along with the corresponding scale, can be combined into a vector, which is then combined with the original update vector to make a &#34;biased update&#34; at that timestep.</p>
<p dir="auto">The exact parameters used when applying these potentials matter. If you weight them too strongly, you&#39;re not going to end up with a good protein. Too weak, and they&#39;ll have little effect. We&#39;ve explored these potentials in a few different scenarios, and have set sensible defaults, if you want to use them. But, if you feel like they&#39;re too weak/strong, or you just fancy exploring, do play with the parameters (in the <code>potentials</code> part of the config file).</p>
<p dir="auto">Potentials are specified as a list of strings with each string corresponding to a potential. The argument for potentials is <code>potentials.guiding_potentials</code>. Within the string per-potential arguments may be specified in the following syntax: <code>arg_name1:arg_value1,arg_name2:arg_value2,...,arg_nameN:arg_valueN</code>. The only argument that is required for each potential is the name of the potential that you wish to apply, the name of this argument is <code>type</code> as-in the type of potential you wish to use. Some potentials such as <code>olig_contacts</code> and <code>substrate_contacts</code> take global options such as <code>potentials.substrate</code>, see <code>config/inference/base.yml</code> for all the global arguments associated with potentials. Additionally, it is useful to have the effect of the potential &#34;decay&#34; throughout the trajectory, such that in the beginning the effect of the potential is 1x strength, and by the end is much weaker. These decays (<code>constant</code>,<code>linear</code>,<code>quadratic</code>,<code>cubic</code>) can be set with the <code>potentials.guide_decay</code> argument.</p>
<p dir="auto">Here&#39;s an example of how to specify a potential:</p>
<div data-snippet-clipboard-copy-content="potentials.guiding_potentials=[\&#34;type:olig_contacts,weight_intra:1,weight_inter:0.1\&#34;] potentials.olig_intra_all=True potentials.olig_inter_all=True potentials.guide_scale=2 potentials.guide_decay=&#39;quadratic&#39;"><pre><code>potentials.guiding_potentials=[\&#34;type:olig_contacts,weight_intra:1,weight_inter:0.1\&#34;] potentials.olig_intra_all=True potentials.olig_inter_all=True potentials.guide_scale=2 potentials.guide_decay=&#39;quadratic&#39;
</code></pre></div>
<p dir="auto">We are still fully characterising how/when to use potentials, and we strongly recommend exploring different parameters yourself, as they are clearly somewhat case-dependent. So far, it is clear that they can be helpful for motif scaffolding and symmetric oligomer generation. However, they seem to interact weirdly with hotspot residues in PPI. We think we know why this is, and will work in the coming months to write better potentials for PPI. And please note, it is often good practice to start with <em>no potentials</em> as a baseline, then slowly increase their strength. For the oligomer contacts potentials, start with the ones provided in the examples, and note that the <code>intra</code> chain potential often should be higher than the <code>inter</code> chain potential.</p>
<p dir="auto">We have already implemented several potentials but it is relatively straightforward to add more, if you want to push your designs towards some specified goal. The <em>only</em> condition is that, whatever potential you write, it is differentiable. Take a look at <code>potentials.potentials.py</code> for examples of the potentials we have implemented so far.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-symmetric-motif-scaffolding" aria-hidden="true" href="#symmetric-motif-scaffolding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Symmetric Motif Scaffolding.</h3>
<p dir="auto">We can also combine symmetric diffusion with motif scaffolding to scaffold motifs symmetrically.
Currently, we have one way for performing symmetric motif scaffolding. That is by specifying the position of the motif specified w.r.t. the symmetry axes.</p>
<p dir="auto">
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/RosettaCommons/RFdiffusion/blob/main/img/sym_motif.png"><img src="https://github.com/RosettaCommons/RFdiffusion/raw/main/img/sym_motif.png" alt="alt text" width="1000px"/></a>
</p>
<p dir="auto"><strong>Special input .pdb and contigs requirements</strong></p>
<p dir="auto">For now, we require that a user have a symmetrized version of their motif in their input pdb for symmetric motif scaffolding. There are two main reasons for this. First, the model is trained by centering any motif at the origin, and thus the code also centers motifs at the origin automatically. Therefore, if your motif is not symmetrized, this centering action will result in an asymmetric unit that now has the origin and axes of symmetry running right through it (bad). Secondly, the diffusion code uses a canonical set of symmetry axes (rotation matrices) to propogate the asymmetric unit of a motif. In order to prevent accidentally running diffusion trajectories which are propogating your motif in ways you don&#39;t intend, we require that a user symmetrize an input using the RFdiffusion canonical symmetry axes.</p>
<p dir="auto"><strong>RFdiffusion canonical symmetry axes</strong></p>
<table>
<thead>
<tr>
<th>Group</th>
<th>Axis</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cyclic</td>
<td>Z</td>
</tr>
<tr>
<td>Dihedral (cyclic)</td>
<td>Z</td>
</tr>
<tr>
<td>Dihedral (flip/reflection)</td>
<td>X</td>
</tr>
</tbody>
</table>
<p dir="auto"><strong>Example: Inputs for symmetric motif scaffolding with motif position specified w.r.t the symetry axes.</strong></p>
<p dir="auto">This example script <code>examples/design_nickel.sh</code> can be used to scaffold the C4 symmetric Nickel binding domains shown in the RFdiffusion paper. It combines many concepts discussed earlier, including symmetric oligomer generation, motif scaffolding, and use of guiding potentials.</p>
<p dir="auto">Note that the contigs should specify something that is precisely symmetric. Things will break if this is not the case.</p>
<hr/>
<h3 tabindex="-1" dir="auto"><a id="user-content-a-note-on-model-weights" aria-hidden="true" href="#a-note-on-model-weights"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>A Note on Model Weights</h3>
<p dir="auto">Because of everything we want diffusion to be able to do, there is not <em>One Model To Rule Them All</em>. E.g., if you want to run with secondary structure conditioning, this requires a different model than if you don&#39;t. Under the hood, we take care of most of this by default - we parse your input and work out the most appropriate checkpoint.
This is where the config setup is really useful. The exact model checkpoint used at inference contains in it all of the parameters is was trained with, so we can just populate the config file with those values, such that inference runs as designed.
If you do want to specify a different checkpoint (if, for example, we train a new model and you want to test it), you just have to make sure it&#39;s compatible with what you&#39;re doing. E.g. if you try and give secondary structure features to a model that wasn&#39;t trained with them, it&#39;ll crash.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-things-you-might-want-to-play-with-at-inference-time" aria-hidden="true" href="#things-you-might-want-to-play-with-at-inference-time"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Things you might want to play with at inference time</h3>
<p dir="auto">Occasionally, it might good to try an alternative model (for example the active site model, or the beta binder model). These can be specified with <code>inference.ckpt_override_path</code>. We do not recommend using these outside of the described use cases, however, as there is not a guarantee they will understand other kinds of inputs.</p>
<p dir="auto">For a full list of things that are implemented at inference, see the config file (<code>configs/inference/base.yml</code> or <code>configs/inference/symmetry.yml</code>). Although you can modify everything, this is not recommended unless you know what you&#39;re doing.
Generally, don&#39;t change the <code>model</code>, <code>preprocess</code> or <code>diffuser</code> configs. These pertain to how the model was trained, so it&#39;s unwise to change how you use the model at inference time.
However, the parameters below are definitely worth exploring:
-inference.final_step: This is when we stop the trajectory. We have seen that you can stop early, and the model is already making a good prediction of the final structure. This speeds up inference.
-denoiser.noise_scale_ca and denoiser.noise_scale_frame: These can be used to reduce the noise used during sampling (as discussed for PPI above). The default is 1 (the same noise added at training), but this can be reduced to e.g. 0.5, or even 0. This actually improves the quality of models coming out of diffusion, but at the expense of diversity. If you&#39;re not getting any good outputs, or if your problem is very constrained, you could try reducing the noise. While these parameters can be changed independently (for translations and rotations), we recommend keeping them tied.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-understanding-the-output-files" aria-hidden="true" href="#understanding-the-output-files"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Understanding the output files</h3>
<p dir="auto">We output several different files.</p>
<ol dir="auto">
<li>The <code>.pdb</code> file. This is the final prediction out of the model. Note that every designed residue is output as a glycine (as we only designed the backbone), and no sidechains are output. This is because, even though RFdiffusion conditions on sidechains in an input motif, there is no loss applied to these predictions, so they can&#39;t strictly be trusted.</li>
<li>The <code>.trb</code> file. This contains useful metadata associated with that specific run, including the specific contig used (if length ranges were sampled), as well as the full config used by RFdiffusion. There are also a few other convenient items in this file:
<ul dir="auto">
<li>details about mapping (i.e. how residues in the input map to residues in the output)
<ul dir="auto">
<li><code>con_ref_pdb_idx</code>/<code>con_hal_pdb_idx</code> - These are two arrays including the input pdb indices (in con_ref_pdb_idx), and where they are in the output pdb (in con_hal_pdb_idx). This only contains the chains where inpainting took place (i.e. not any fixed receptor/target chains)</li>
<li><code>con_ref_idx0</code>/<code>con_hal_idx0</code> - These are the same as above, but 0 indexed, and without chain information. This is useful for splicing coordinates out (to assess alignment etc).</li>
<li><code>inpaint_seq</code> - This details any residues that were masked during inference.</li>
</ul>
</li>
</ul>
</li>
<li>Trajectory files. By default, we output the full trajectories into the <code>/traj/</code> folder. These files can be opened in pymol, as multi-step pdbs. Note that these are ordered in reverse, so the first pdb is technically the last (t=1) prediction made by RFdiffusion during inference. We include both the <code>pX0</code> predictions (what the model predicted at each timestep) and the <code>Xt-1</code> trajectories (what went into the model at each timestep).</li>
</ol>
<h3 tabindex="-1" dir="auto"><a id="user-content-conclusion" aria-hidden="true" href="#conclusion"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conclusion</h3>
<p dir="auto">We are extremely excited to share RFdiffusion with the wider scientific community. We expect to push some updates as and when we make sizeable improvements in the coming months, so do stay tuned. We realize it may take some time to get used to executing RFdiffusion with perfect syntax (sometimes Hydra is hard), so please don&#39;t hesitate to create GitHub issues if you need help, we will respond as often as we can.</p>
<p dir="auto">Now, let&#39;s go make some proteins. Have fun!</p>
<p dir="auto">- Joe, David, Nate, Brian, Jason, and the RFdiffusion team.</p>
<hr/>
<p dir="auto">RFdiffusion builds directly on the architecture and trained parameters of RoseTTAFold. We therefore thank Frank DiMaio and Minkyung Baek, who developed RoseTTAFold.
RFdiffusion is released under an open source BSD License (see LICENSE file). It is free for both non-profit and for-profit use.</p>
</article>
          </div></div>
  </body>
</html>
