<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kmaliszewski9.github.io/scala/2025/12/07/scala3-slowdown.html">Original</a>
    <h1>Scala 3 slowed us down?</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>Is this clickbait? Not really. </p>

<p>I was refreshing one of our services. Part of this process was to migrate codebase from Scala 2.13 to Scala 3. Iâ€™ve done this a few times before and overall had a positive experience. Well, at least until we talk about projects with macro wizardry.</p>

<p>The service in question had no macros at all, but it was at the heart of data ingestion, so performance was not an afterthought.</p>

<p>I did it as usual - updating dependencies, compiler options and some type/syntax changes.</p>

<p>Then after resolving few tricky implicit resolutions and config derivations, project compiled on Scala 3.7.3 ðŸŽ‰</p>

<p>All tests passed, end-to-end flow locally works perfectly fine, so I decided to roll out the changes in a testing environment. Similarly, no issues at all. No concerning logs, all metrics ranging from infrastructure, through JVM up to application level look healthy.</p>

<p>With that in mind, I began a staged rollout. Again, all seem good. I kept observing the service but it looked like my job is done.</p>

<p>Well, as you probably can guess, it wasnâ€™t.</p>

<h2 id="the-mysterious-slowdown">The mysterious slowdown</h2>

<p>After 5-6 hours, Kafka lag started increasing on a few environments. Of course, this wasnâ€™t something new. Most often it is caused by a spike of data. We have pretty advanced machinery to deal with that. Usually the lag resolves by itself without any manual action.</p>

<p>However, this time <em>something</em> was off. Upstream load turned out to be relatively modest, yet we needed much more instances of the service - meaning the processing rate per instance dropped. I was confused to say the least. Why would it decrease the processing rate just on these environments?</p>

<p>Anyway, we decided to rollback the changes - this brought the rate back.</p>

<h2 id="digging-deeper">Digging deeper</h2>

<p>I came back to testing. In particular, load testing. However similarly as on production environments I did not notice regression. So I played around with different payloads and granularity of messages. To my surprise, for more fine-grained, heterogeneous workloads, the processing rate significantly dropped.</p>

<p>Still, I had no idea why it would happen, but my bet was in the dependencies. Therefore, I tried one-by-one, reverting the serialization library, database SDK, base Docker image and even config libraries. None of these made any changes.</p>

<p>This made me pull out the big guns. I profiled the service using <a href="https://github.com/async-profiler/async-profiler/tree/master">async-profiler</a> and indeed</p>

<p>CPU profile looked vastly different on Scala 3 than on 2.13.</p>

<p><img src="https://kmaliszewski9.github.io/assets/s213low.png" alt="scala2_13_flamegraph"/></p>

<p><img src="https://kmaliszewski9.github.io/assets/s3low.png" alt="scala3_flamegraph"/></p>

<p>JVM-level CPU time was now dominated by JIT compiler while application-level by decoding.</p>

<p>Looking at the top of Scala 3 flamegraph I noticed a long quicklens call.</p>

<p><img src="https://kmaliszewski9.github.io/assets/quicklens-flamegraph.png" alt="quicklens_flamegraph"/></p>

<p>What used to be transparent (frankly, I didnâ€™t even realize we used the library), now took almost half of the total CPU time. I compared how it looks on Scala 2.13 and it was barely noticeable with around 0.5% samples.</p>

<p>Turns out there was indeed <a href="https://github.com/softwaremill/quicklens/pull/115">a subtle bug</a> making chained evaluations inefficient in Scala 3. This also explained why the JVM spent so much time compiling.</p>

<p>After upgrading the library, performance and CPU characteristics on Scala 3 became indistinguishable from Scala 2.13.</p>

<h2 id="takeaways">Takeaways</h2>

<p>While the details of the bug are pretty interesting(hats off to the SoftwareMill team for catching it!), thatâ€™s not my point here. I want to emphasize that <strong>libraries can behave very differently between Scala versions</strong>, especially when they rely on meta-programming.</p>

<p>Even if your migration is seamless and the service runs fine on Scala 3 - when performance is not just a nice-to-have, do not assume. Know your hotspots and benchmark them. Otherwise, your code will benchmark you, revealing bottlenecks in places you didnâ€™t even know existed.</p>


  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
