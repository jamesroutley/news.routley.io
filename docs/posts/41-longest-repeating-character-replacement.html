<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/41---Longest-Repeating-Character-Replacement">Original</a>
    <h1>41 - Longest Repeating Character Replacement</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p><strong>LeetCode challenge:</strong> <a href="https://leetcode.com/problems/longest-repeating-character-replacement/description/"> Longest Repeating Character Replacement<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<p>Shoutout to Shenai for pairing on this with me! We had just done <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/">Longest Substring Without Repeating Characters<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> so this seemed like a logical next step.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> characterReplacement</span><span>(</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    // If string is empty or k is negative, return 0</span></span>
<span data-line=""><span>    if</span><span> (</span><span>!</span><span>s </span><span>||</span><span> k </span><span>&lt;</span><span> 0</span><span>) </span><span>return</span><span> 0</span><span>;</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Create a frequency map for characters in the current window</span></span>
<span data-line=""><span>    const</span><span> freq</span><span>:</span><span> Map</span><span>&lt;</span><span>string</span><span>, </span><span>number</span><span>&gt; </span><span>=</span><span> new</span><span> Map</span><span>();</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    let</span><span> maxLength </span><span>=</span><span> 0</span><span>;        </span><span>// Track the max valid window length</span></span>
<span data-line=""><span>    let</span><span> maxFreq </span><span>=</span><span> 0</span><span>;         </span><span>// Track the highest frequency in current window</span></span>
<span data-line=""><span>    let</span><span> windowStart </span><span>=</span><span> 0</span><span>;     </span><span>// Left pointer of the window</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    // Iterate through the string with right pointer</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> windowEnd </span><span>=</span><span> 0</span><span>; windowEnd </span><span>&lt;</span><span> s.</span><span>length</span><span>; windowEnd</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        // Update frequency of current character</span></span>
<span data-line=""><span>        const</span><span> currentChar</span><span> =</span><span> s[windowEnd];</span></span>
<span data-line=""><span>        freq.</span><span>set</span><span>(currentChar, (freq.</span><span>get</span><span>(currentChar) </span><span>||</span><span> 0</span><span>) </span><span>+</span><span> 1</span><span>);</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        // Update maxFreq if current char frequency is higher</span></span>
<span data-line=""><span>        maxFreq </span><span>=</span><span> Math.</span><span>max</span><span>(maxFreq, freq.</span><span>get</span><span>(currentChar)</span><span>!</span><span>);</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        // Calculate number of characters to be replaced in current window</span></span>
<span data-line=""><span>        const</span><span> windowLength</span><span> =</span><span> windowEnd </span><span>-</span><span> windowStart </span><span>+</span><span> 1</span><span>;</span></span>
<span data-line=""><span>        const</span><span> charsToReplace</span><span> =</span><span> windowLength </span><span>-</span><span> maxFreq;</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        // If we need more replacements than k allows, shrink window</span></span>
<span data-line=""><span>        if</span><span> (charsToReplace </span><span>&gt;</span><span> k) {</span></span>
<span data-line=""><span>            // Decrease frequency of char at windowStart</span></span>
<span data-line=""><span>            const</span><span> startChar</span><span> =</span><span> s[windowStart];</span></span>
<span data-line=""><span>            freq.</span><span>set</span><span>(startChar, freq.</span><span>get</span><span>(startChar)</span><span>!</span><span> -</span><span> 1</span><span>);</span></span>
<span data-line=""><span>            windowStart</span><span>++</span><span>;</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        // Update maxLength with current valid window length</span></span>
<span data-line=""><span>        maxLength </span><span>=</span><span> Math.</span><span>max</span><span>(maxLength, windowEnd </span><span>-</span><span> windowStart </span><span>+</span><span> 1</span><span>);</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>    return</span><span> maxLength;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Shenai showed me this cool thing where, when starting a leetcode problem, she diagrammed it out first so I tried a little of that. I tried doing that here, on <a href="https://excalidraw.com/">excalidraw<svg aria-hidden="true" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, which was really helpful.
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/1b8d0c74a691069f0d78406926b3b9e8.png" alt="image"/>But this didn’t quite do justice to the <em>motion</em> of it. So I made an animation:
<img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/f3947a790205ea11b0e551db0a5bb822.gif" alt="image"/>
It was super fun, so I made another one…I imagined that instead of being a rigid thing, the window was just this flexible, expanding and contracting worm-like organism that was able to extract nutrients out of these continuous ranges of same-characters, with maybe some sort of metabolic budget of being able to withstand some level of interruption (<code>k</code>):</p>
<p><img src="https://thornberry-obsidian-general.s3.us-east-2.amazonaws.com/attachments/19f24cc3e4275375ba032053b5aeaa8b.gif" alt="image"/></p>
<p>P.S. It actually looks like I have tried tackling this one before at <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/30)-Longest-Repeating-Character-Replacement" data-slug="devnotes/LeetCode-Journal/30)-Longest-Repeating-Character-Replacement">30) Longest Repeating Character Replacement</a>. It looks like tried writing out a short story to understand it, but I don’t think it helped as much as this more motion-based understanding.</p>
<p>That was fun too though! Funny how this problem consistently inspires/forces me to find more creative ways of grokking when others haven’t.</p>

<p>A lot of my work before paid off - a lot of these concepts are fresh in my brain. Diving back in and this time reflecting on the <code>O(n * 26)</code> (which is yes, still technically <code>O(n))</code>) approach since I hadn’t really considered it before and it has some cool quirks in syntax.</p>
<p>This is what I got this time in <code>8:39</code></p>
<p><strong>A few stumbles:</strong></p>
<ul>
<li>I forget that although I don’t need to decrement <code>maxFreq</code> I do need to decrement my hashmap</li>
<li>I briefly forgot to get the max of <code>res</code>, and just overwrote <code>res</code> without thinking</li>
</ul>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>function</span><span> characterReplacement</span><span>(</span><span>s</span><span>:</span><span> string</span><span>, </span><span>k</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> l </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> count </span><span>=</span><span> {}</span></span>
<span data-line=""><span>    let</span><span> maxFreq </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    let</span><span> res </span><span>=</span><span> 0</span></span>
<span data-line=""> </span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> r </span><span>=</span><span> 0</span><span>; r </span><span>&lt;</span><span> s.</span><span>length</span><span>; r</span><span>++</span><span>){</span></span>
<span data-line=""><span>        count[s[r]] </span><span>=</span><span> (count[s[r]] </span><span>??</span><span> 0</span><span>) </span><span>+</span><span> 1</span></span>
<span data-line=""> </span>
<span data-line=""><span>        maxFreq </span><span>=</span><span> Math.</span><span>max</span><span>(maxFreq, count[s[r]])</span></span>
<span data-line=""><span>        while</span><span> (r </span><span>-</span><span> l </span><span>+</span><span> 1</span><span> -</span><span> maxFreq </span><span>&gt;</span><span> k ){</span></span>
<span data-line=""><span>            count[s[l]] </span><span>=</span><span> (count[s[l]]) </span><span>-</span><span> 1</span></span>
<span data-line=""><span>            l</span><span>++</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>        </span></span>
<span data-line=""><span>        res </span><span>=</span><span> Math.</span><span>max</span><span>(res, r </span><span>-</span><span> l </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> res</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Okay got it in <code>1:55</code> now. That’s the power of spaced repition.</p></article><hr/></div></div></div>
  </body>
</html>
