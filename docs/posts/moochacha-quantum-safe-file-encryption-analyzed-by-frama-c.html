<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codeberg.org/markdascher/moochacha">Original</a>
    <h1>Show HN: Moochacha, quantum-safe file encryption (analyzed by Frama-C)</h1>
    
    <div id="readability-page-1" class="page"><p><span id="count_prompt">You can not select more than 25 topics</span>
			<span id="format_prompt">Topics must start with a letter or number, can include dashes (&#39;-&#39;) and can be up to 35 characters long.</span>
		</p><div>
	
	<div>
		
		<div>
			
				
<p><strong>WARNING: This is a personal project, unsafe for real data. Don&#39;t use it.</strong></p>
<p>Encrypt files using a random keyfile, like <a href="https://github.com/skeeto/enchive" rel="nofollow">enchive</a> without public keys. Plain
256-bit encryption satisfies even the most paranoid quantum computing fears.</p>
<p>Each file&#39;s encryption key derives from a common keyfile plus a 256-bit random
seed. Keep the keyfile secret. Its passphrase discourages only casual snooping,
given that passphrases can be discovered by brute-force or hidden camera.</p>
<p>Currently uses Argon2id, BLAKE2b, and ChaCha20-Poly1305 from <a href="https://github.com/jedisct1/libsodium" rel="nofollow">libsodium</a>.</p>
<h2 id="user-content-license">License</h2>
<p>Copyright 2022-2023 Mark Dascher</p>
<h2 id="user-content-specification">Specification</h2>
<p><strong>WARNING: All details are still subject to change.</strong></p>
<p>Argon2id makes two passes of 1 GiB by default. The memory limit is adjustable
between 1 MiB and 512 GiB, but only in even powers of two. Therefore, there are
only 20 possibilities to try when the correct value is inevitably forgotten.</p>
<p>ChaCha20-Poly1305 refers to the IETF/TLS variant, having a 96-bit nonce. Here
the nonce is treated as a single little-endian integer consisting of 12 bytes.</p>
<pre><code>salt = 16 random bytes
keyP = Argon2id(salt, &#34;ADIOS MOOCHACHA&#34; || 0 || password)
keyW = 32 random bytes
wrap = ChaCha20-Poly1305(keyP, nonce=0, msg=keyW)
keyfile = (salt, wrap)
</code></pre>
<p>After creating or unlocking the keyfile, encryption of plaintext can begin. The
maximum file size is 2^108 + 8191 = 324,518,553,658,426,726,783,156,020,584,447
bytes which...ought to be enough for anybody?</p>
<p>A sequential 96-bit ChaCha20 nonce is exactly as safe as a random 192-bit
XChaCha20 nonce, even without overflow checking. Still, go ahead and check for
nonce overflow if you want, since it&#39;s mathematically the weakest point.</p>
<pre><code>plaintext = (p0, p1, ..., pN); where p0 is 12288 bytes,
                               each inner p is 4096 bytes,
                               and pN is 0-4095 bytes.
         or (p0); where p0 is 0-12287 bytes.

seed = 32 random bytes
keyF = BLAKE2b-256(keyW, msg=seed)

c0 = ChaCha20-Poly1305(keyF, nonce=0, msg=p0)
c1 = ChaCha20-Poly1305(keyF, nonce=1, msg=p1)
...
cN = ChaCha20-Poly1305(keyF, nonce=N, msg=pN)

ciphertext = (seed, c0, c1, ..., cN); where c0 is 12304 bytes,
                                      each inner c is 4112 bytes,
                                      and cN is 16-4111 bytes.
          or (seed, c0); where c0 is 16-12303 bytes.
</code></pre>
<p>When decrypting, the sequential nonce protects against reordering. To protect
against truncation, confirm that pN &lt; 4096 bytes or p0 &lt; 12288 bytes.</p>
<h3 id="user-content-threat-model">Threat model</h3>
<p>Suppose a cloud provider, criminal organization, or government quietly retains
encrypted files for decades, waiting until decryption is feasible. Can we
encrypt uploads safely enough to resist theoretical quantum attacks?</p>
<p>Of course, a government has plenty of old-fashioned tools to capture the common
keyfile from your computer, but those require actual effort and target specific
individuals. The goal is merely to protect against automated mass surveillance.
The main exception involves malware, which can efficiently steal data and keys.</p>
<p>The 128-bit Poly1305 MAC might not resist future attacks, but that&#39;s not fatal
as long as those attacks don&#39;t reveal or weaken the encryption key. If Poly1305
is broken, simply delete this program and never use it again.</p>
<h3 id="user-content-weaknesses">Weaknesses</h3>
<p>An adversary who manages to unlock the keyfile can decrypt every file ever
encrypted. That&#39;s unavoidable for offline storage. An online protocol should
rather exchange keys interactively, to achieve backward and forward secrecy.</p>
<p>Avoiding public-key cryptography is a tradeoff, since there&#39;s no way to take a
private key offline. On the other hand, that&#39;s not always as useful as it
sounds. For example, encrypted backups should be tested periodically to make
sure the decryption key works. If there&#39;s a dedicated machine to validate
backups, then why not encrypt the backups on that same machine?</p>
<p>Still, definitely consider that there may be a better tool for the job.</p>
<h2 id="user-content-static-analysis-and-testing">Static analysis and testing</h2>
<p>All C code passes analysis using Cppcheck, Frama-C&#39;s Eva plugin, and Infer.
There&#39;s also a custom test suite with full branch coverage. For details, see
<a href="https://codeberg.org/markdascher/moochacha/src/branch/main/checker.sh" rel="nofollow">checker.sh</a>, <a href="https://codeberg.org/markdascher/moochacha/src/branch/main/frama.log" rel="nofollow">frama.log</a>, and the <a href="https://codeberg.org/markdascher/moochacha/src/branch/main/Makefile" rel="nofollow">Makefile</a>.</p>
<h2 id="user-content-todo">TODO</h2>
<p>This tool is incomplete and unsafe. A partial list of what&#39;s still needed:</p>
<ul>
<li>Add password change feature.</li>
<li>Add typical command-line arguments.</li>
<li>Finish tweaking file format. Future revisions won&#39;t be backward-compatible.</li>
<li>Revisit obsolete or unusual techniques.</li>
<li>Windows handles CTRL+C inconsistently until <a href="https://github.com/microsoft/terminal/issues/334" rel="nofollow">bug 334</a> is fixed.</li>
<li>Windows only supports ASCII passwords until <a href="https://github.com/microsoft/terminal/issues/4551" rel="nofollow">bug 4551</a> is fixed.</li>
</ul>
<p>The code is full of global variables and other anti-patterns, just for fun.</p>
<h2 id="user-content-usage">Usage</h2>
<h3 id="user-content-build-moochacha">Build moochacha</h3>
<p>The Makefile supports GCC and MSVC directly. To use Clang instead, delete
<code>-fanalyzer</code> and <code>-flto-partition=none</code> from CFLAGS.</p>
<p>Before building on Linux, install <code>libsodium-dev</code> (Debian/Ubuntu),
<code>libsodium-devel</code> (Fedora/RHEL), or a similar package.</p>
<pre><code><span>## Linux</span>
make lint
make
make check
</code></pre><p>Before building on Windows, download and extract the libsodium MSVC
<a href="https://doc.libsodium.org/installation#pre-built-libraries" rel="nofollow">pre-built library</a>.
Place the extracted <code>include</code> folder and dynamic <code>libsodium.lib</code> for your MSVC
version into this project&#39;s root folder, along with <code>libsodium.dll</code>.</p>
<pre><code><span>:</span><span>: Windows</span>
nmake
</code></pre><h3 id="user-content-encrypt-a-file">Encrypt a file</h3>
<p>Encrypting uses an existing keyfile if available. Provide the passphrase when
prompted. The default keyfile is <code>moochacha.key</code>.</p>
<p>Otherwise it creates a new keyfile and prompts for a passphrase. Every future
encryption and decryption will ask for the same passphrase.</p>
<pre><code><span>## Linux</span>
moochacha &lt;secret.txt &gt;secret.txt.moo <span>&amp;&amp;</span> rm secret.txt
</code></pre><pre><code><span>:</span><span>: Windows</span>
moochacha <span>&lt;</span>secret.txt <span>&gt;</span>secret.txt.moo <span>&amp;&amp;</span> <span>del</span> secret.txt
</code></pre><h3 id="user-content-decrypt-a-file">Decrypt a file</h3>
<p>Decrypting requires the same keyfile used during encryption. Provide the
passphrase when prompted.</p>
<pre><code><span>## Linux</span>
moochacha -d &lt;secret.txt.moo &gt;secret.txt <span>&amp;&amp;</span> rm secret.txt.moo
</code></pre><pre><code><span>:</span><span>: Windows</span>
moochacha -d <span>&lt;</span>secret.txt.moo <span>&gt;</span>secret.txt <span>&amp;&amp;</span> <span>del</span> secret.txt.moo
</code></pre><h3 id="user-content-options">Options</h3>
<p>The <code>-k</code> option selects a keyfile other than the default <code>moochacha.key</code>.</p>
<pre><code><span>## Linux</span>
moochacha -k ~/moochacha.key &gt;secret.txt.moo
moochacha -dk ~/moochacha.key &lt;secret.txt.moo
</code></pre><pre><code><span>:</span><span>: Windows</span>
moochacha -k <span>&#34;</span><span>%USERPROFILE%</span><span>\moochacha.key&#34;</span> <span>&gt;</span>secret.txt.moo
moochacha -dk <span>&#34;</span><span>%USERPROFILE%</span><span>\moochacha.key&#34;</span> <span>&lt;</span>secret.txt.moo
</code></pre><p>The <code>-m</code> option adjusts the Argon2 memory limit, 1 GiB by default. Stick with
the default unless it needs to run on less RAM. A longer passphrase does more
for security than any Argon2 settings. There are 20 possibilities:</p>
<pre><code>1M 2M 4M 8M 16M 32M 64M 128M 256M 512M
1G 2G 4G 8G 16G 32G 64G 128G 256G 512G
</code></pre>
<h3 id="user-content-padding">Padding</h3>
<p>No padding is added by default. To conceal file sizes, add padding first. The
included <a href="https://codeberg.org/markdascher/moochacha/src/branch/main/padmoo.c" rel="nofollow">padmoo</a> proof-of-concept adds a specific amount of padding
to a plaintext file. Then, when that padded file is encrypted, the encrypted
output matches one of the legal <a href="https://lbarman.ch/blog/padme/" rel="nofollow">Padmé</a> sizes.</p>
<p>This could be built into moochacha itself, but keeping it separate may protect
against timing attacks. Besides, Padmé is just one possible padding scheme.</p>
<pre><code><span># Run padmoo before encrypting.</span>
padmoo secret.txt
moochacha &lt;secret.txt &gt;secret.txt.moo <span>&amp;&amp;</span> rm secret.txt

<span># Run padmoo after successfully decrypting, to remove the padding.</span>
moochacha -d &lt;secret.txt.moo &gt;secret.txt <span>&amp;&amp;</span> rm secret.txt.moo
padmoo secret.txt
</code></pre>
			
		</div>
	</div>
</div></div>
  </body>
</html>
