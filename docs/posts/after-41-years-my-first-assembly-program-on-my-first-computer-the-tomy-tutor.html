<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://oldvcr.blogspot.com/2024/03/after-41-years-my-first-assembly.html">Original</a>
    <h1>After 41 years, my first assembly program on my first computer, the Tomy Tutor</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7597842423603032498" itemprop="description articleBody"><p>
We got it in 1983, I think, so it only took me about 41 years to get around to it. This Tomy Tutor isn&#39;t a replacement system I secondarily acquired, nor is it a Ship of Theseus Frankenstein rebuild. This is my <em>actual</em> first computer, in its original case, on its original components, with the Federated Group sticker still on the original box. And it still works.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjQ9LAGVCfrBn9_Z9yd6t7kAwVbOM-W9wqL1piD8_IM2iqNqqcC33qajRNf7PkWXeMnUZboV7IU2_7mDwoAi7gTY-g_q5VhnlmrAWMeEtJ5O7oj76rNVl6nADng7TQeqdXAR45cpSfzgCiHo6cskJ0U1C-dSLvNA6EVZzSUBJE29Y7DTsNNCwzUIL1TKKs/s3648/PXL_20240309_211811231.jpg"><img alt="" data-original-height="2736" data-original-width="3648" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjQ9LAGVCfrBn9_Z9yd6t7kAwVbOM-W9wqL1piD8_IM2iqNqqcC33qajRNf7PkWXeMnUZboV7IU2_7mDwoAi7gTY-g_q5VhnlmrAWMeEtJ5O7oj76rNVl6nADng7TQeqdXAR45cpSfzgCiHo6cskJ0U1C-dSLvNA6EVZzSUBJE29Y7DTsNNCwzUIL1TKKs/s320/PXL_20240309_211811231.jpg" width="320"/></a></p><p>

Now, why so long? Well, for one thing, it was only supposed to be a training wheels computer because a full Commodore 64 system would have cost too much, but my folks wanted to see whether we&#39;d take to a home computer and <a href="https://www.youtube.com/watch?v=9N8AzoDzQhM">His High Holy Munificence Fred R. Rated</a> was blowing these babies out for a song by then. The receipt has long since disappeared, though $99 sounds about right plus maybe around $40 or so for a joystick, cassette deck and some cartridges, compared to somewhere between $200 and $300 for the recently discounted 64 — which didn&#39;t include anything else. (It tells you something about our family finances at the time when a C64 was too <em>expensive</em>.) I immediately started writing my own BASIC programs on it in its perverse little BASIC dialect and when my folks indeed saved up and bought us a C64 system the next year (complete with 1702 monitor and 1541 disk drive), I refused to use it. In </p><s>retaliation</s><p> my best interests, my parents forcibly relocated the Tomy to storage and I went on to do even bigger things on the Commodore, making it, not the Tutor, the defining computer of my childhood. That&#39;s why there&#39;s still <a href="http://oldvcr.blogspot.com/2023/05/refurb-weekend-commodore-128dcr.html">a Commodore 128DCR on my desk</a>.
</p><p>
The other reason is that there was never really a simple way to do it. Even when I found out what CPU was actually inside (incredibly a 16-bit TMS 9995, an evolved version of the TMS 9900 in the Texas Instruments 99/4 and 99/4A), there was never a Tomy assembler, and other than its small amount of scratchpad RAM (256 bytes) the entirety of the Tutor&#39;s 16K of memory is tied up in the 9918ANL VDP video chip. That sort of architecture was typical for the family, but that also means that almost everything is stored in non-executable VDP RAM, so short of burning your own cartridge EPROMs there&#39;s no way to actually create and run a machine language program on the Tutor. The first flashcart for the Tutor didn&#39;t exist until around 2016 and it was still all ROM; furthermore, while the 99/4A could have its CPU-addressable RAM expanded (as well as the 99/8, its unreleased successor to which the Tomy Tutor is closely related), there wasn&#39;t ever a Tutor RAM expansion cartridge either until very recently. But now there are multiple homebrew options even for obscure home computers like this one, and at last I&#39;ve got my own assembly language program finally running on it.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj3oqNRuTTZQRkO62eUK_dbqlmAzZCEz9-CVt8CuhUHZgIFnPFNxElBe6SoBsbSFChROZumsbdi1MWXYp_OsCtfEk9jeKW5XPdXyCLxwT14rRBPunzSYfpRdQRdLtYBSorcX4sdqDj8ZRV5dTcW31Sih-UHHONKAjcJtJG3-LtqNQTcofKseu3W6dWl67I/s4080/PXL_20240309_070122354.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj3oqNRuTTZQRkO62eUK_dbqlmAzZCEz9-CVt8CuhUHZgIFnPFNxElBe6SoBsbSFChROZumsbdi1MWXYp_OsCtfEk9jeKW5XPdXyCLxwT14rRBPunzSYfpRdQRdLtYBSorcX4sdqDj8ZRV5dTcW31Sih-UHHONKAjcJtJG3-LtqNQTcofKseu3W6dWl67I/s320/PXL_20240309_070122354.jpg" width="320"/></a></p><p>

And it&#39;s all done with its own, better I/O routines (if I do say my own better self) as a basis for bigger projects. But first, a little tour of the Tutor itself, and then we&#39;ll dig in.
</p><p>
<a name="more"></a>

Texas Instruments&#39; home computer series, including the famous TI 99/4A, was the logical consequence of TI&#39;s &#34;one company, one computer architecture&#34; policy. Indeed, the 1976 TMS 9900 CPU was basically their 16-bit 990 minicomputer architecture in an ungainly 64-pin DIP chip package and quite possibly (the only alternative is the General Instrument CP1600) the first single chip 16-bit microprocessor commercially available. It was fabbed in NMOS on a 4.5 micron process with about 8,000 transistors and initially topped out at a respectable 3MHz, though its pervasively microcoded architecture required sometimes large cycle counts per instruction. The 9918 video display processor in the original 99/4 evolved with a new bitmap mode to become the 9918A in the 99/4A, and, outlasting its originator, was one of the most common video chips of the early home computer era (Sord, MSX, CreatiVision/Dick Smith Wizzard, ColecoVision/Coleco ADAM, and many, many more). The original 99/4 was the winning design of three internal home system efforts in 1979, but was derided for its &#34;calculator&#34; keyboard, lack of lower case and a high MSRP; the upgraded 99/4A débuted in 1981 with an improved keyboard, better video, more expansion options and a lower price.
</p><p>
But TI was first and foremost in the chip business, and at the time was the largest semiconductor manufacturer on the planet. TI realized that the physical size of the CPU was harming its commercial viability — though TI&#39;s dubious management decisions were just as big a factor — and developed more conventional 40-pin versions, first as microcontrollers with on-board RAM and ROM, then with more typical 8-bit data buses. The most advanced of these was the TMS 9995 which had a few extra opcodes, a primitive pre-fetch facility, 256 bytes of on-chip RAM (we&#39;ll get to why this is notable when we discuss assembly language programming) and an internal decrementer for timing and event counting. It was noticeably faster than the 9900 and TI planned to implement it in its next generation of home computers, the low-end black and white 99/2 intended to compete against systems like the ZX-81 and Timex Sinclair 1000, and the high-end 99/8 with more memory, built-in peripherals and a larger keyboard.
</p><p>
Before that could happen, however, TI got deep in the weeds against their old nemesis Commodore under Jack Tramiel and ended up cancelling both the 99/2 and 99/8 in 1983 (exiting the home computer market completely in 1984), though not before there were spinoffs. It&#39;s not clear how Japanese toy manufacturer Tomy got involved but in 1982 Tomy adapted the in-development 99/8 architecture using the same 9995 CPU and 9918A VDP into their own home computer in Japan, manufactured by Matsushita (Panasonic) under contract. This computer was called the Tomy Pyuuta (ぴゅう太, also variously romanized as the Tomy Pyuta or Tomy Pyūta). 

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhGvEIAVlkDauCf5HnZ3-1wWKnE_3cGL9YC1EpY5vBfdVIjs-7Elkgzc9f-9V6qXBhKOa4Y9vJa_ZaD6fg3-ScWULzrb6iQpnvNnK_vOtjr0u2jPX7VGvHxz_RDOte9IZBFPHKrkCkGzVRJ6ElQx4vsFbLW0TL9wy5dQ6ZZToosgi4URSpffGkUL7vl0aM/s2048/IMG_20200606_142136.jpg"><img alt="" data-original-height="1536" data-original-width="2048" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhGvEIAVlkDauCf5HnZ3-1wWKnE_3cGL9YC1EpY5vBfdVIjs-7Elkgzc9f-9V6qXBhKOa4Y9vJa_ZaD6fg3-ScWULzrb6iQpnvNnK_vOtjr0u2jPX7VGvHxz_RDOte9IZBFPHKrkCkGzVRJ6ElQx4vsFbLW0TL9wy5dQ6ZZToosgi4URSpffGkUL7vl0aM/s320/IMG_20200606_142136.jpg" width="320"/></a></p><p>

The Pyuuta wasn&#39;t, and wasn&#39;t intended as, a 99/8 clone. Unlike the 99/8&#39;s higher-end aspirations, the Pyuuta was targeted explicitly at younger children, using a friendly yet durable large plastic case and spill-resistant rubber Chiclet keys. For cartridges Tomy licensed some of Konami&#39;s arcade games like Frogger and Scramble and created a few of their own, and for peripherals they provided game controllers (included) and a cassette recorder (optional) for saving your work. Eventually <a href="http://oldvcr.blogspot.com/2020/06/tfw-you-find-last-cartridge.html">they planned to release</a> a modem, floppy disk, printer and speech synthesizer, all presumably using TI&#39;s reference designs except the printer which was a modified Astor MCP-40 plotter.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhvPinNkNDr6aW6zzqYKCwGARokJenammCZinAaR88KMt68BTvyNJpyuPbG4Z5AOF5hkhG2GaVgeZO2k5qoi7QKD8hOQTELA5h204cRFg_oY4LpRnIRfQ6K0O4mmfV-inKVz8HkHyL5dvalL2jSzXyXXrtbcJrce6MNsvOggI0uSEM3MlWodkPOJes1Qy4/s720/vlcsnap-2020-06-06-16h42m05s668.png"><img alt="" data-original-height="540" data-original-width="720" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhvPinNkNDr6aW6zzqYKCwGARokJenammCZinAaR88KMt68BTvyNJpyuPbG4Z5AOF5hkhG2GaVgeZO2k5qoi7QKD8hOQTELA5h204cRFg_oY4LpRnIRfQ6K0O4mmfV-inKVz8HkHyL5dvalL2jSzXyXXrtbcJrce6MNsvOggI0uSEM3MlWodkPOJes1Qy4/s320/vlcsnap-2020-06-06-16h42m05s668.png" width="320"/></a></p><p>

Although the basic BIOS was based on the TI&#39;s and the title screen in particular <a href="https://4apedia.com/index.php?title=File:Main_TI_Startup_Screen.png">is very similar</a>, Tomy prominently advertised it was a 16-bit system, yet focused more on games and graphics than programming. Like the unexpanded 99/4 and 99/4A, all of the included 16K RAM in the Pyuuta is dedicated to the VDP, for which Tomy created a built-in paint program and a highly constrained dialect of BASIC (&#34;G-BASIC&#34;) to manipulate screen elements and sprites with katakana keywords. It ran using a 10.738635MHz 945/88 crystal divided by three for video (standard NTSC 315/88 3.579545MHz) and four for the CPU (945/352, 2.68465875MHz). The processor clock speed was slower on paper than the 3MHz 9900 in the 99/4A which came off a 12MHz crystal, but the Pyuuta was nevertheless faster because of the 9995&#39;s efficiencies and a critical architectural difference I&#39;ll discuss shortly.
</p><p>
The Pyuuta was a reasonable success in Japan and Tomy decided to export it to other markets by translating the OS and G-BASIC to English. However, British importer Adam Imports sent this first prototype back, finding G-BASIC too limited to be commercially viable. As an upgrade TI must have provided (unwittingly or otherwise) the code for TI Extended BASIC to Tomy to port, since Tomy BASIC has similar to nearly identical tokens, memory usage and syntax. This updated version was imported more or less directly by Adam Imports as the Grandstand Tutor, and its dual-BASIC system was released as an add-on device for the Pyuuta and then built-in as well to the next generation system Tomy themselves intended to sell in the United States. This was the Tomy Tutor in 1983.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgrg6HiLlKzvZYmt0UqqVjIPZQO2VwkPlCcKGhOiuhlUZhtOcEjXrgrrn19EdvIxYF3_thoFC__XrxfxwHLmgjWW4tYyAyZSZWGJBa6FTyHjyvpmYLoOA1hVMjZT8TvWYA4D3KPLus3_yFu4GQ7KARNQPy13QLAA-uILIVw4r6N19kfBFJGgv2NBlX07qs/s1256/tomy-purcell-1a.jpg"><img alt="" data-original-height="1256" data-original-width="1100" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgrg6HiLlKzvZYmt0UqqVjIPZQO2VwkPlCcKGhOiuhlUZhtOcEjXrgrrn19EdvIxYF3_thoFC__XrxfxwHLmgjWW4tYyAyZSZWGJBa6FTyHjyvpmYLoOA1hVMjZT8TvWYA4D3KPLus3_yFu4GQ7KARNQPy13QLAA-uILIVw4r6N19kfBFJGgv2NBlX07qs/s320/tomy-purcell-1a.jpg"/></a></p><p>

Tomy USA hired <i>Real People</i> host Sarah Purcell as their spokeperson, who touted the computer as a system so easy to use that kids could teach themselves how to use it (it&#39;s true: I did!). She wasn&#39;t as high-profile as TI&#39;s Bill Cosby, but she was hardly unknown to the target demographic(&#39;s parents), and she hadn&#39;t committed any criminal offenses either. Unfortunately their otherwise promising marketing campaign was most notable for the most frequent use of the word &#34;real&#34; in a single pamphlet, as well as a five-day kick-the-tires-for-free deal which was about as successful as Apple&#39;s later &#34;Test Drive a Macintosh&#34; promotion. (NARRATOR: By which he means it wasn&#39;t.)
</p><p>
Like the Pyuuta, Tomy prominently touted the Tutor&#39;s 16-bit processor, but provided no way to directly access it. A couple years earlier the Tutor might have been a compelling system and one of the &#34;real&#34; kids on the box even wrote me a few years back to mention he rather enjoyed the games, but the video game crash was in full swing by then and Tomy&#39;s intentional toy aesthetic quickly became the kiss of death. No wonder Fred R. Rated was trying to get rid of them.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhKUgrA66KPHkwuvb85aZ1A9is588VtYCRXETRBLgwi7hPuRGpKRhp9ry69UGLXcI4Y1fi3SeeYcqfLljFR5k9ffr8UWkjonwgO0XO-AZAIIbIaQePdtY3Pjbz7JImw1gIq1q5gxNZXPpQvkhrZiL2E98gmyx7jJhlMg3CCFJlb2mDyX0VyeaXy-DNdOSk/s2048/DSCN6996.JPG"><img alt="" data-original-height="1536" data-original-width="2048" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhKUgrA66KPHkwuvb85aZ1A9is588VtYCRXETRBLgwi7hPuRGpKRhp9ry69UGLXcI4Y1fi3SeeYcqfLljFR5k9ffr8UWkjonwgO0XO-AZAIIbIaQePdtY3Pjbz7JImw1gIq1q5gxNZXPpQvkhrZiL2E98gmyx7jJhlMg3CCFJlb2mDyX0VyeaXy-DNdOSk/s320/DSCN6996.JPG" width="320"/></a></p><p>

Tomy apparently lost so much money on the Tutor that they ended up producing very few peripherals for the system in either the United States or Japan. This picture shows the complete setup in the United States, namely a tape recorder with custom electronics, an Anglicized version of those disc-based joy controllers which made the Intellivision seem like a paragon of ergonomics, and a tough-as-nails single joystick sold as the Joy Stick (insert joke here). And that was it. The floppy disk drive, printer and speech synthesizer promised in both countries never appeared as other than a single picture in the Purcell pamphlet, the printer interface sold in Japan as part of the BASIC-1 add-on was never sold abroad, and most critically the &#34;TI Adaptor&#34; — nothing less than a Tomy rebadge of the <a href="http://unige.ch/medecine/nouspikel/ti99/pebox.htm">TI Peripheral Expansion Box</a> — that would have included additional memory and storage options was vapourware too.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgVGlKWNYRy7BcQX5O-mZZci-wxRlhXuY6L8bHJUx75aJ7OOtuXeAV43JW__o8eSgePK7eKu-c2lxNZJo39F8_9uNF1sz1g99mMUk30cs_BbsN7NxCn4CF1ATfFvFiI95F2fdrEqD5Z3XBOPmfDxdy78s4w2bJUM8oZWerhR1gGdLEc1IElZ7gP-8GPXKw/s2048/DSCN6980.JPG"><img alt="" data-original-height="1536" data-original-width="2048" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgVGlKWNYRy7BcQX5O-mZZci-wxRlhXuY6L8bHJUx75aJ7OOtuXeAV43JW__o8eSgePK7eKu-c2lxNZJo39F8_9uNF1sz1g99mMUk30cs_BbsN7NxCn4CF1ATfFvFiI95F2fdrEqD5Z3XBOPmfDxdy78s4w2bJUM8oZWerhR1gGdLEc1IElZ7gP-8GPXKw/s320/DSCN6980.JPG" width="320"/></a></p><p>

The Tutor was also not an exact copy of the Pyuuta either, although the core silicon (the 9995 CPU, 9918A VDP video chip [9929A for PAL] and SN76489 DCSG sound chip) is the same, primarily differing in the BIOS ROM, the absence of a Japanese character set, the presence of Tomy BASIC, and slightly different memory banking logic. The systems are otherwise nearly totally compatible such that Japanese Pyuuta cartridges will generally run on American or PAL Tutors and vice versa, language support notwithstanding, with only one of the American cartridges — its sole explicitly educational title — being specific to the United States.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEinlUi6GbeIMaDwf3tczUSNVzj_5nipleTMMe_SsasJT4WreMUW3AGgBcnEHGg-6XTWs1Qris8EEa-hh_6X1dFVv8ipA9aFMSq0cOn4_Kkchn8GUsJMLgnN5KoIsM8Mzo7ZFC3j_QuX39uU-9O25d6zMEI5iuI64ACKIlMKqi4O4QFdQIgotYYkhh8Bs9g/s640/vlcsnap-2024-03-08-22h09m39s005.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEinlUi6GbeIMaDwf3tczUSNVzj_5nipleTMMe_SsasJT4WreMUW3AGgBcnEHGg-6XTWs1Qris8EEa-hh_6X1dFVv8ipA9aFMSq0cOn4_Kkchn8GUsJMLgnN5KoIsM8Mzo7ZFC3j_QuX39uU-9O25d6zMEI5iuI64ACKIlMKqi4O4QFdQIgotYYkhh8Bs9g/s320/vlcsnap-2024-03-08-22h09m39s005.png" width="320"/></a></p><p>

The Tutor, as with the Pyuuta before it, started with the TI 99/4A&#39;s title screen but with animation, scrolling the colour bars vertically. It felt like a friendly computer from the moment you turned it on and the larger 32x24 text cells actually reinforced that somewhat (plus making it much easier to read on our little Panasonic colour TV).

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjfH146lk5ibMVqFtD2PZ2JsoFRCj2MOSbcUNjqcu5icNOfG_92gfnubhhmGz6ALnkX2nQHaTYxHPq9sykmhx5t96jauuWk3WJcMD9xP6bLQ4HWjH4WB70VkcvfunG5xbfqNt-Lw8E29pu60my5pNY6PrRbZoWTdyjQozI99w1SD2JS_Jam66vQmryrpAA/s640/vlcsnap-2024-03-08-22h09m52s550.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjfH146lk5ibMVqFtD2PZ2JsoFRCj2MOSbcUNjqcu5icNOfG_92gfnubhhmGz6ALnkX2nQHaTYxHPq9sykmhx5t96jauuWk3WJcMD9xP6bLQ4HWjH4WB70VkcvfunG5xbfqNt-Lw8E29pu60my5pNY6PrRbZoWTdyjQozI99w1SD2JS_Jam66vQmryrpAA/s320/vlcsnap-2024-03-08-22h09m52s550.png" width="320"/></a></p><p>

The Tutor menu, directly translated from the Japanese menu in the Pyuuta, was also inspired by the TI&#39;s menu, but instead uses a &#34;pointer&#34; rather than selecting items by number. It was likewise very easy for a child to grasp. On the Tutor, the GRAPHIC and BASIC modes are always available as part of its sizeable 48K of built-in ROM. The CARTRIDGE option only appears if a cartridge is detected, which we&#39;ll talk about in a moment.
</p><p>
Unlike the TI 99/4A which used serially addressed &#34;GROMs&#34; for BASIC and much other software (which on top of that can&#39;t contain native code and are necessarily written in an interpreted bytecode called GPL), all of the Tutor ROMs and cartridges are directly connected to the bus and therefore tremendously faster. Although Tomy BASIC is also based on GPL, Tomy&#39;s GPL dialect is a stripped-down variant specialized for this task, and the program text is directly accessible like any other data in ROM. All of this, plus the 9995&#39;s prefetch, are why the Tutor&#39;s (and Pyuuta&#39;s) slightly slower clocked CPU runs so much more swiftly in practice than the 99/4A&#39;s.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjM-GhMCBVPKpQuRyLt6piPlv2qiSaslnBd7JvGaOxmrpOA2L9NPOFpB9jxxNjvjuLBZLEv0GPrVf4cAG_Ho4WEzulMtRzIepHlk3fx4v3Jf7yBaGs8Enb1uGoSF1rfS-5EbO3h323QGnoqk1ycc7T3yjSbFp4AafngkrVo5lKNlMNbE2ngSyf9KTHZHwM/s640/vlcsnap-2024-03-08-23h03m38s747.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjM-GhMCBVPKpQuRyLt6piPlv2qiSaslnBd7JvGaOxmrpOA2L9NPOFpB9jxxNjvjuLBZLEv0GPrVf4cAG_Ho4WEzulMtRzIepHlk3fx4v3Jf7yBaGs8Enb1uGoSF1rfS-5EbO3h323QGnoqk1ycc7T3yjSbFp4AafngkrVo5lKNlMNbE2ngSyf9KTHZHwM/s320/vlcsnap-2024-03-08-23h03m38s747.png" width="320"/></a></p>

<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFncYmij7Yd-YAWLqGVu_UqKmnh21bo5ScY1Z2Jwh6tZLh65VvRWLn6f6diOZvtVq3HurP-1JFqsnToyrrJnhyMoaTgAOqy-Unbt5fe-xqx8W4KcSnClrSqoF_82KwmBe2GoNqzH8jEolLv9gOulJFuQvVko9gXuw49H0y6BYqUSTQltpPFnznyYumQY4/s640/vlcsnap-2024-03-08-23h04m30s526.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiFncYmij7Yd-YAWLqGVu_UqKmnh21bo5ScY1Z2Jwh6tZLh65VvRWLn6f6diOZvtVq3HurP-1JFqsnToyrrJnhyMoaTgAOqy-Unbt5fe-xqx8W4KcSnClrSqoF_82KwmBe2GoNqzH8jEolLv9gOulJFuQvVko9gXuw49H0y6BYqUSTQltpPFnznyYumQY4/s320/vlcsnap-2024-03-08-23h04m30s526.png" width="320"/></a></p><p>

The Tutor&#39;s GRAPHIC mode is a simple built-in paint program that takes full advantage of the 9918A&#39;s 256x192 bitmap mode, offering two colours per line in each 8x8 cell — substantially better than systems like the C64 or ZX Spectrum with two colours per <em>cell</em>. A little rocket cursor moved with the arrow keys indicated the current location, and when you were at the desired cell, you could then edit it using the palette and the editing square on the lower right. GRAPHIC mode also supported four large 16x16 sprites — to hide the 9918&#39;s limitation of no more than four sprites per scan line — which could be crudely moved or animated by GBASIC programs (no hyphen in the English name).

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhneCVuucKO4LIZ_gC_fYgyrtXFBX4Pj8s8D_vFS_fmg3IR8P3Xyv6DLh3n3uqlxz43TdOyqm2leb4MgxpuQi1SinWsTituvEv44GQJHhYaFMENJJYK-3zf6002ytBbizl2Yqg7QVeNniDO_x51AvO4qr_uOSq6cTIYtisfjyRZIYBCLRUjqxod7Y2VtR4/s640/vlcsnap-2024-03-08-23h05m24s256.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhneCVuucKO4LIZ_gC_fYgyrtXFBX4Pj8s8D_vFS_fmg3IR8P3Xyv6DLh3n3uqlxz43TdOyqm2leb4MgxpuQi1SinWsTituvEv44GQJHhYaFMENJJYK-3zf6002ytBbizl2Yqg7QVeNniDO_x51AvO4qr_uOSq6cTIYtisfjyRZIYBCLRUjqxod7Y2VtR4/s320/vlcsnap-2024-03-08-23h05m24s256.png" width="320"/></a></p><p>

GBASIC, however, was so limited — barely any string support, small program space, terse syntax and a couple severe bugs — that I spent most of my early elementary life in Tomy BASIC. I wrote some games and some simple utilities and saved them to tape, and I still have one of these tapes, though I carelessly overwrote most of its contents later. Yet despite its lineage as a descendant of TI Extended BASIC, Tomy BASIC intentionally supported less than its ancestor, likely to keep inquisitive kids like me in a memory-safe &#34;sandbox.&#34; There were commands for sound, character graphics and some custom character shapes, but most of these features were poorly documented (if at all), and there wasn&#39;t any supported facility for directly accessing bitmapped graphics or sprites — let alone arbitrary reads and writes to VDP memory.
</p><p>
Still, the &#34;sandbox&#34; concept ended up being unsuccessful because a number of Tomy BASIC commands don&#39;t bounds-check properly, and I remember very clearly crashing it multiple times one day trying to figure out how the <tt>COLOR</tt> keyword worked. (Alas, I was too young at the time to realize the significance of what I&#39;d done.) Such bugs even facilitated a clever hack to enable sprites, though this hack unsurprisingly has notable limitations, and there was no way to directly access VDP registers for other features like high resolution or 40-column mode. BASIC was as much as you could do on a stock Tutor and other than a small user group in the Los Angeles area I didn&#39;t know anyone else who had one. It wasn&#39;t until several years later that I got the Tutor back, and by then I was knee-deep in Commodore programming, including handcoding 6502 machine language opcodes in the Epyx FastLoad monitor. The Tutor had been fun but I could do more with the Commodore 64 and the 128 we got after that.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiBeEZlV-lQ4x-ncVfMYQ7SQEOquv7EvSvZ38M2rUjLlme9e8YeaAF9_-Gxpw7b4QcB4vN5f_0QdSogkjoQXIfUIz043w8Tni__0kP9yvoTqgAkVZ6nADI9NycgRJ-qeWD1B3xx-sSGQkOJ-ylFPyh1AVGBvIOY1O1i2g5A6XzR1IZsLQ7Zfj_xHagK9TM/s743/tutti.png"><img alt="" data-original-height="743" data-original-width="728" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiBeEZlV-lQ4x-ncVfMYQ7SQEOquv7EvSvZ38M2rUjLlme9e8YeaAF9_-Gxpw7b4QcB4vN5f_0QdSogkjoQXIfUIz043w8Tni__0kP9yvoTqgAkVZ6nADI9NycgRJ-qeWD1B3xx-sSGQkOJ-ylFPyh1AVGBvIOY1O1i2g5A6XzR1IZsLQ7Zfj_xHagK9TM/s320/tutti.png"/></a></p><p>

Emulation came late to the Tutor both due to its obscurity and a profound lack of hardware documentation. In 1998 yours truly wrote the first Tutor &#34;simulator,&#34; which I christened Tutti, ironically for the Commodore 64 so that it could be run anywhere a C64 emulator was supported (back then I used C64S and later Frodo). It was designed to mimic the Tutor&#39;s look and feel using a character set I labouriously drew by eye, a custom keyboard driver, raster interrupts for the 9918A&#39;s split screen modes, simple tone audio, and colour approximations with the VIC-II&#39;s palette. It had a fully functional title screen and menu plus reasonably accurate looking but very primitive GRAPHIC, GBASIC and BASIC modes. For its behaviour I manually figured out how fast things ran and added delays and tweaks, and reverse-engineered the BASIC and GBASIC editors. Surprisingly, a portion of Tutti is actually part of the project we&#39;ll do today, so hang onto it in the back of your head.
</p><p>
It took five more years for the first true Tomy Tutor emulator, namely Ian Gledhill&#39;s 2003 TutorEm with functional 9995 and 9918A emulation; it was very slow, very buggy, incomplete and Windows-only, but it really did work and finally opened the floodgates. Later that year MESS added a driver written by Raphael Nabet in 0.70 that I helped beta-test and it is still part of modern MAME. While I have since updated TutorEm and made many fixes for my tape-enabled Tutti II emulator, we&#39;ll use MAME for debugging this entry because it is currently the only Tutor emulator that handles cartridge ROMs.
</p><p>
Tutti didn&#39;t emulate the CPU because I didn&#39;t know how its I/O worked and it would have been impossible to execute code in any performant fashion on the C64; even the relatively lightweight 6502-on-6502 emulator I maintain for <a href="http://oldvcr.blogspot.com/2023/02/instruction-fusion-and-real-serial-port.html">the KIM-1 KIMplement emulator</a> runs about 30 times slower or so than actual. I had done a little playing around with TMS9900 assembly on the 99/4A using the Editor/Assembler cartridge (&#34;module&#34;) on a friend&#39;s machine, and I even had a basic 9900 programming book, so the 9995 wasn&#39;t really an alien architecture to me — which makes a good transition into talking about the CPU itself.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgu5-937vaMQloo_RolMe7WoNEOsNITOtReCsf1I9RNixosUeqv7kS_tARyA7gtdVBxyWVGUP8K2Zf98N9N9-V82zAOGrHWE0mFlPujPPXbN64FbZLdxDmUf-lrj4wV2R1IxFXgqsg_4nKt-gWi7MM0JngJNYhoRVaTULP6DdMCu7Huup0agMe9df8vlqM/s2846/ti990.jpg"><img alt="" data-original-height="2030" data-original-width="2846" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgu5-937vaMQloo_RolMe7WoNEOsNITOtReCsf1I9RNixosUeqv7kS_tARyA7gtdVBxyWVGUP8K2Zf98N9N9-V82zAOGrHWE0mFlPujPPXbN64FbZLdxDmUf-lrj4wV2R1IxFXgqsg_4nKt-gWi7MM0JngJNYhoRVaTULP6DdMCu7Huup0agMe9df8vlqM/s320/ti990.jpg" width="320"/></a></p><p>

The original TI-990 minicomputers supported multiprogramming in a then-innovative fashion: most of their registers were actually stored in RAM. The only CPU-internal registers are the program counter (PC), a Workspace Pointer (WP) that indicated where in RAM the 16 registers (32 bytes) reside, and a Status (ST) register for flags. This meant that a context switch could be as simple as merely changing the PC, WP and ST registers to those of the new task. Though zero or direct pages on CPUs like the 6502 or 6809 is a related concept, the 990 WP was more versatile and indeed absolutely intrinsic to how the 990 operated. It has a generally orthogonal instruction set for the time (<i>ceteris paribus</i>), and aside from R0 not being valid as an index the registers can be used for any general purpose, though certain instructions are fixed to specific registers like R11 as a link register for subroutine calls or R12 as the address for bit-serial I/O over the Communications Register Unit bus. Byte operations exist but all word accesses are aligned to even addresses.
</p><p>
For the TI 99/4 in 1979 (and later the 99/4A), TI determined that designing a full 16-bit system around the 9900 would have required new chips for its exclusively 16-bit bus, making the effort too expensive for a home computer. TI solved this problem by devising <a href="http://www.unige.ch/medecine/nouspikel/ti99/architec.htm">two buses</a>. The most directly connected 16-bit bus hosted the lowest level system ROM with the GPL interpreter plus 256 bytes of &#34;scratchpad RAM&#34; which could store eight complete sets of registers, composed of two 128-byte 8-bit static RAMs wired as low and high bytes (the 9900 is big-endian) which the CPU could access in parallel. SRAM was expensive, however, so the remainder of the machine&#39;s RAM was 16K of dynamic RAM given to the VDP, which has its own DRAM refresh circuitry. Unfortunately, although the VDP was on this 16-bit bus also, the VDP only supported byte accesses and ignores the lower half of the word, slowing DRAM reads further. Worse, everything else was behind the second &#34;multiplexed&#34; 8-bit bus, where a small circuit stalled out the CPU on reads until two 8-bit fetches could assemble the full 16 bits. While this meant less expensive 8-bit parts could be used, the cost reduction also cost a significant amount of performance.
</p><p>
The use of SRAM suggests that the 99/4 was originally intended to use a different chip that had RAM on-die, where refresh circuitry wouldn&#39;t have been needed, but cost and market considerations apparently prevailed. The intended CPU may have been something like the 1979 TMS9940 with an on-chip CRU, 2K of ROM, a decrementer and 128 bytes of SRAM, or the later TMS9985 with 8K of ROM and 256 bytes of scratchpad, though neither would have been ready in time for the 99/4. As mentioned earlier, after the disadvantages of the 9900&#39;s strict 16-bit data bus became more acute TI moved the multiplex circuitry on-chip and exposed only an 8-bit bus starting with the TMS9980 — but this also doubled access time to its external scratchpad RAM, condemning it to lower-performance applications <a href="http://oldvcr.blogspot.com/2022/09/what-kim-1-really-needs-is-bubble.html">like TI&#39;s Silent 700 teletypes</a>. TI&#39;s first attempt was to turn the 9940 into the 9985 by adding the same multiplexer and bumping up the ROM and scratchpad RAM, which were both internal and thus avoided the bus problem. There was reportedly no market appetite for the 9985, so TI removed the ROM and reduced instruction latency further by using prefetch steps in the microcode which could be parallel with a preceding ALU operation. This is the 9995, released in 1981.
</p><p>
(A digression: how do you use the 9900 to implement a language like C? The simplest method is to just implement a stack, which is facilitated on the 990/9900 by its support for post-increment addressing. This is in fact the approach taken by <a href="https://forums.atariage.com/topic/164295-gcc-for-the-ti/">the GCC port for the TMS9900</a>, which treats the CPU more or less like a modern CPU with a link register [usually R11], defines an ABI for arguments and volatile/non-volatile registers, and reserves one of the registers as the stack pointer, in this case R10. R10 is a 16-bit register like all the others, so the stack can be as large as the addressing space, a significant improvement over C-hostile architectures like the 6502. Another way is to go &#34;full Berkeley&#34; and treat the WP as a means to implement register windows, a la SPARC: the WP can be moved to any word-aligned address, so a caller can move the WP down a few notches, set up its arguments, call the routine, capture the return value and set it back. However, the 9995 — and for that matter the stock 99/4(A) — doesn&#39;t have CPU-addressable RAM other than the scratchpad, so in the base configuration neither system would have much capacity for function calls no matter how they were implemented. The Tomy BIOS gets around this by simply moving the WP or individual registers around by hand, which is space efficient, but also makes some individual routines or subsections more difficult to use because there is no standard calling convention.)
</p><p>
For our purposes, although the 9995 has a few extra instructions, we can treat it in practical terms as a faster 9900. The main difference at the assembly level is where the scratchpad RAM lives: since it&#39;s external to the 9900, its location is wherever it gets decoded (e.g., in the $8000 range in the 99/4A), but in the 9995 the internal RAM always occupies $f000-$f0fb (for compatibility with the 9900 the last four bytes are seen at $fffc to $ffff and serve as the NMI vector). The 9995 also has an internal decrementer at $fffa but we won&#39;t need to deal with that right now for this particular project. The only other concern is that the prefetch in the 9995 will affect self-modifying code if it changes the very next instruction which our example doesn&#39;t do either. Otherwise, programming it is almost completely the same.
</p><p>
The Tomy BIOS obviously has support routines for displaying text and reading the keyboard, but we&#39;re not going to use them for several reasons: first, I&#39;m not particularly conversant in them, second, we can probably do it faster and more flexibly ourselves, third, it&#39;s good education, and fourth, they kind of suck. For input, while we can&#39;t do anything about the Tutor&#39;s mushy Chiclets or its single SHIFT key, we certainly can improve upon the BIOS&#39; terrible key rollover. Additionally, the Tutor&#39;s default character set is inconveniently organized for modern applications: wile you can apparently use the <tt>SCELL()</tt> (the Tomy equivalent of TI <tt>CALL HCHAR</tt>) command to store characters by their ASCII value directly into VDP screen memory, this is in fact an artifact of BASIC and not actually how the glyphs are laid out in VDP RAM. We would like to organize our character set to be <em>exactly</em> the same as true ASCII so that no translation is needed, as well as support the 9918A&#39;s 40 column text mode which the Tutor BIOS never did. To do all of these things, we&#39;ll devise our own library.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgGrhdpabw63j0O2Mdhz4PEqJXoElkcbtC0HheH-Ubfc_mIemumqNXCLhVgV7Ge9HDIoRX0FDkvl977NxVj3NI9d4B5FCK_uJkrHR4NbYxPAh82M7OYq7k-cf62oo7_1xOW4qm0seXuO6lV7fzrgmBL0Ehaf8Zw5kEz3ep5EA7YCpfkqeq93Aeq3wlHiC4/s4080/PXL_20240309_062046613.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgGrhdpabw63j0O2Mdhz4PEqJXoElkcbtC0HheH-Ubfc_mIemumqNXCLhVgV7Ge9HDIoRX0FDkvl977NxVj3NI9d4B5FCK_uJkrHR4NbYxPAh82M7OYq7k-cf62oo7_1xOW4qm0seXuO6lV7fzrgmBL0Ehaf8Zw5kEz3ep5EA7YCpfkqeq93Aeq3wlHiC4/s320/PXL_20240309_062046613.jpg" width="320"/></a></p><p>

The homebrew hardware we&#39;ll use is all from TeamEurope (hi Klaus!), who made one of the earliest Tutor flash multicarts. This is <a href="https://team-europe.blogspot.com/2023/12/tomy-tutorpyuta-ram-cartridge-updated.html">his newest unit</a> which is the only currently available CPU RAM expansion for the Tomy Tutor and Pyuuta, providing 16K of CPU-accessible RAM in two 8K ranges as well as multiple 32K ROMs accessible by DIP switch from a 512K flash ROM. (This cartridge was actually conceived of first by <a href="https://tms9918.hatenablog.com/entry/2018/01/18/211846">tanam</a>, but this unit is an expansion of that design.) We&#39;ll explore this device more in <a href="http://oldvcr.blogspot.com/search/label/tomy%20tutor">a future entry</a>. However, we don&#39;t need the RAM nor the extra ROM capacity today and the device additionally requires a passive I/O port adapter for those extra addressing lines, so we&#39;ll use one of his simpler items.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj7tOBwn6hATigqw5kzvfd3nGIGywU43gr7EhRwkAM3yyL20-8aLAzFlIR5UUCug8P9JFCVQSPAmB1E3EgjQTCYJxgsIUwOT951qarJABDve9W7Nz_-Ef642OOcpHZNTavEQp-gsF-4WgTL10vZpnU9Wx1g1qGzenk-TtzGO8YFfkLBIk3nI_j0nw-wZlU/s4080/PXL_20240309_041416783.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj7tOBwn6hATigqw5kzvfd3nGIGywU43gr7EhRwkAM3yyL20-8aLAzFlIR5UUCug8P9JFCVQSPAmB1E3EgjQTCYJxgsIUwOT951qarJABDve9W7Nz_-Ef642OOcpHZNTavEQp-gsF-4WgTL10vZpnU9Wx1g1qGzenk-TtzGO8YFfkLBIk3nI_j0nw-wZlU/s320/PXL_20240309_041416783.jpg" width="320"/></a></p><p>

That simpler item is <a href="https://team-europe.blogspot.com/2019/05/flashcartsmulticarts-for-tomy.html">this one, his first</a>. It has every USA and Japanese cartridge ROM except the very rare USA and Japanese Demonstration cartridges — with a little luck I&#39;m hoping to rectify that soon. It also lacks the later &#34;3-D&#34; series (a misnomer, they weren&#39;t 3D with the possible exception of <i>Rescue Copter</i>) which require the extra addressing line for 32K ROMs and are provided on a separate multicart. 

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgF3tyhvlj-82eizllcz_qMSov3PPOTRp7F-2UEfGhF67ygoSrNV9KRvJnnrc-t7ThnWWsZ9q6fbTbyJe9DYDNaNGBRQcsgTDXf8_0949oPzsNFJIzdaMKU9UmnPTR_MojBVb0i-7EMTFw_Xs__DzS8WZ_Be3xPSCmDfVmBa7uwZ8GsEgIo0-_ju0rgPgU/s4080/PXL_20240309_041344629.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgF3tyhvlj-82eizllcz_qMSov3PPOTRp7F-2UEfGhF67ygoSrNV9KRvJnnrc-t7ThnWWsZ9q6fbTbyJe9DYDNaNGBRQcsgTDXf8_0949oPzsNFJIzdaMKU9UmnPTR_MojBVb0i-7EMTFw_Xs__DzS8WZ_Be3xPSCmDfVmBa7uwZ8GsEgIo0-_ju0rgPgU/s320/PXL_20240309_041344629.jpg" width="320"/></a></p><p>

The flash ROM itself is a socketed off-the-shelf 512K Microchip Technology SST39SF040. These chips are end-of-life but they&#39;re still inexpensive and easy to find as DIPs or PLCCs, and by using Klaus&#39; board I don&#39;t need to make one of my own. For this I started with another DIP 39SF040 that I got cheaply since we won&#39;t need to do too many insertion cycles on the socket to get this simple program working. There is free space in the default cartridge loadout for four more 16K ROM images and we&#39;ll use two of them.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgkYqTAm_5fhqueXig4l8tzemqMWNbPG_dQ68W07363wsgiTL8h0AbBJicYi3dDAoDLkshN_h0QJe22eK84xwZx3d64srikCnO4gWoDlz2lM-3Q09OC0Qb07SiQhLsin3Zvtvb8WJHM6nIWRHresMiM67_qiYditZIOdWNA3aI7r40UPr9zVRn-KQeo5Tg/s4080/PXL_20240309_071547288.jpg"><img alt="" data-original-height="3072" data-original-width="4080" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgkYqTAm_5fhqueXig4l8tzemqMWNbPG_dQ68W07363wsgiTL8h0AbBJicYi3dDAoDLkshN_h0QJe22eK84xwZx3d64srikCnO4gWoDlz2lM-3Q09OC0Qb07SiQhLsin3Zvtvb8WJHM6nIWRHresMiM67_qiYditZIOdWNA3aI7r40UPr9zVRn-KQeo5Tg/s320/PXL_20240309_071547288.jpg" width="320"/></a></p><p>

Pretty much any programmer will work for this. Since my daily driver is a POWER9 Linux workstation, I use the open-source <a href="https://gitlab.com/DavidGriffith/minipro">minipro</a> and this older XGecu TL866-II+ (minipro has experimental support for the newer T48 but the TL866-II+ is well-tested with it; unfortunately you can&#39;t trust many of the eBay and Amazon sellers to get you the older model). 
</p><p>
For the cross-assembler, we&#39;ll use <a href="http://john.ccac.rwth-aachen.de:8000/as/">the AS macroassembler</a>, which is multi-architecture, cross-platform, open-source and has specific support for the 9995. It builds just fine on any modern OS, including Linux and macOS. The macroassembler will create an intermediate object which we then link with an included tool into the final executable.
</p><p>
The Tomy machines place their VDP ports at $e000 and $e002 in the 9995&#39;s regular addressing space, while the keyboard and joy controllers (which share keyboard lines) are on the CRU bus at $ec00 through $ec70 with each group of eight lines separated by 16. The &#34;little&#34; 8K and &#34;medium&#34; 16K cartridges both are mapped to $8000-$bfff, where the Tutor expects to see two $55 bytes at $8000. If these two $55 bytes are present, the CARTRIDGE option is enabled in the menu, which triggers a jump to $8002. (There are other ways to signal its presence, but this method is the simplest and the one used by the majority of official Tomy cartridges.) So we&#39;ll start off with this:
</p><div><pre>        padding off

        ; vdp ports on the tutor
vdpwd   equ 0e000h
vdpwr   equ 0e002h
        ; CRU address for reading the keyboard
keycru  equ 0ec00h

        org 08000h

        ; cartridge signature word
        word 05555h
</pre></div>
<p>
The leading zeroes for these particular 16-bit values are a required quirk of AS. Since we&#39;re using all our own routines, we don&#39;t want any interference from the BIOS, so we&#39;ll turn off all interrupts by setting the interrupt mask to zero and load the WP with the lowest address of the 9995&#39;s built-in scratchpad RAM. (We&#39;ll have more to say about interrupts later.)
</p><div><pre>        limi 0
        lwpi 0f000h     ; don&#39;t even trust the Tomy OS here
</pre></div>
<p>
The Tomy Tutor BIOS gives us literally nothing to work with anyway: before the cartridge is started, the registers are set to default values and the entire VDP RAM is cleared. That means there&#39;s no screen matrix nor a character set, and we&#39;ll have to write them to VDP RAM ourselves. (The expectation is that you&#39;d call the BIOS&#39; own utility routines to set those up, and that&#39;s indeed what regular Tomy cartridges do, but we&#39;re not going to do that here.) To make working with the VDP a bit more convenient, we&#39;ll construct a little utility subroutine.
</p><div><pre>vdpr    ; write to VDP registers
        ; MSB of r0: command nybble + value (8r = register,
        ; 4x = MSB VDP RAM for write, 0x = for read)
        ; LSB of r0: new register value (xx) or LSB of VDP RAM address
        ; the swapping around gives enough time for the VDP to operate,
        ; and we have no IRQs on, so nothing will interfere
        swpb r0
        movb r0, @vdpwr
        swpb r0
        movb r0, @vdpwr
        b *r11
</pre></div>
<p>
Recall that the 9918A only has an eight-bit data bus, so we must communicate with it through byte-sized operations. This subroutine takes a single 16-bit argument in r0 that either encodes an absolute VDP RAM address for reading or writing, or encodes one of the eight VDP registers and the byte to store in it. (Because of the way these addresses are represented, i.e., either $4xxx to write or $0xxx to read, a &#34;super 9918A&#34; would need to implement some sort of bankswitching register to handle more than 16K. The only other supported RAM size for the 9918A is 4K.) The LSB goes out on the bus first and the 9995 is big-endian, so for each byte we swap them before sending it to the 9918A&#39;s control register, exiting back to the caller through r11 as our link register. As a happy convenience the swap operation takes just long enough for the 9918A to handle the bus transaction and be ready for the next. With that, we can set the following:
</p><div><pre>        ; register 0 turn off bitmap and external video
        li r0,08000h
        bl @vdpr
        ; register 1
        ; - 16K mode
        ; screen off
        ; no IRQs
        ; no 40 column text mode (except if we asked for it?)
        ; no multicolour
        ; no bit 5
        ; normal 8x8 sprites
        ; normal sized sprites
        li r0,08180h
        bl @vdpr
        ; register 2: put screen table at 0800h
        li r0,08202h
        bl @vdpr
        ; register 3: put colour table at 0c00h
        li r0,08330h
        bl @vdpr
        ; register 4: put character set at 0000h
        li r0,08400h
        bl @vdpr
        ; register 5: put sprite attributes at 0000h
        li r0,08500h
        bl @vdpr
        ; register 6: put sprite pattern table at 1000h
        li r0,08602h
        bl @vdpr
        ; register 7: white text on green background
        ; (the only colours available for 40-column)
        li r0,087f2h
        bl @vdpr
</pre></div>
<p>
The locations for the screen table, colour table, character set, sprites and so forth are encoded as <a href="http://www.unige.ch/medecine/nouspikel/ti99/tms9918a.htm#Registers">multiples of particular alignments</a>. For our character set, we&#39;ll reorganize the Tutti one to match ASCII order (I told you we&#39;d be coming back to that), add that to our binary and copy it in. We&#39;re only using positions 32-127, so there is plenty of space for expansion if we want to add graphics characters or an alternate font weight (for this purpose I just added a reverse/inverse set). Once we set the VDP memory address, we can just keep sending data to the data port as the VDP&#39;s address internally autoincrements with each write or read.
</p><div><pre>        ; load our font to &gt;0000
        li r0,04000h
        bl @vdpr
        li r1,fontt
lup     movb *r1+,@vdpwd
        ci r1,fontt+00800h
        jne lup
</pre></div>
<p>
We go on to clear our screen in the same way (by storing the appropriate number of space characters starting from the top left of screen memory), then set the colour matrix (if 32 columns), print our character set and display a welcome message in similar fashion.
</p><p>
Next, we want to accept keyboard input and echo it to the user. Despite the rubbery nature of the keycaps themselves and their non-standard layout, the keyboard matrix proper is actually pretty good quality: each key independently sets a particular bit in the matrix and some quick tests show there&#39;s little to no shorting or ghosting. Reading it is a simple matter of requesting every key bit in groups of eight from the CRU at their specific addresses. However, like any keyboard handler, we&#39;ll need to properly debounce the keys, and this is where the Tomy BIOS is particularly bad: if you type too quickly and multiple keys are down as you transition from one keys to the next, the keyscan routine will fail to make a match and the new key will be dropped. This makes the Tutor&#39;s already somewhat mushy keyboard even worse to type on, an absolutely needless situation since the Tomy keyboard has all the <em>hardware</em> requirements to implement N-key rollover and is only let down by its <em>software</em>. The solution is to track each individual key bit using the debounce matrix to filter out key bits we already know were previously down. This is made a bit easier by the fact there&#39;s only one modifier key to watch (i.e., SHIFT), but the principles are the same.
</p><div><pre>        ; scan keyboard
        ; needs 16 bytes of scratchpad RAM
keyzone equ 0f020h
keezc   clr r0                  ; clear debounce
        mov r0,@keyzone+8
        mov r0,@keyzone+10
        mov r0,@keyzone+12
        mov r0,@keyzone+14
keez    clr r9                  ; clear test
        li r2,keyzone
        li r12,keycru-16
keezl   ai r12,00010h
        clr r0
        stcr r0,8
        movb r0,*r2+
        socb r0,r9              ; bitwise or
        ci r2,keyzone+8
        jne keezl
        ci r9,0
        jeq keezc               ; clear debounce if nothing pressed
</pre></div>
<p>
The &#34;keyzone&#34; block is our current matrix followed by the debounce matrix we&#39;ll use to filter it. This section can be entered either from <tt>keezc</tt> to blank the debounce matrix, falling through to <tt>keez</tt> to read it. Reading from the CRU requires placing the CRU address (a parallel addressing space) into R12 and asking for the needed number of bits. We fetch in groups of eight bits which are in eight locations stored 16 CRU bytes apart, keeping a running logical-OR (which the 9900/9995 atypically calls <tt>soc</tt>/<tt>socb</tt> &#34;Set Ones Corresponding&#34; for non-immediate arguments). If the value of the running logical-OR was zero, then no key was pressed, we branch back to clear the debounce, and go scan the matrix again.
</p><p>
The simplest case is where the current state of the matrix exactly equals the last time (modulo the state of the SHIFT key). This can be checked for by exclusive-ORing with the debounce matrix, masking off the SHIFT bit. We then logical-OR all the resulting bits together and if it&#39;s zero again, we go back to scanning — but leave the debounce matrix alone.
</p><div><pre>        mov @keyzone,r2
        mov @keyzone+2,r3
        mov @keyzone+4,r4
        mov @keyzone+6,r5
        xor @keyzone+8,r2       ; xor current bits with last set
        xor @keyzone+10,r3
        xor @keyzone+12,r4
        ; clear shift bit (prevent &#34;eeking&#34; characters when releasing)
        andi r5,0fbffh
        xor @keyzone+14,r5
        ; if exactly equal (i.e., all zeroes), go back
        soc r3,r2
        soc r4,r2
        soc r5,r2
        jeq keez        ; don&#39;t clear debounce
</pre></div>
<p>
This is the block of code we&#39;d use to set up key repeat, which as currently written this routine doesn&#39;t support yet (an exercise for the future). Otherwise, we need to filter the debounce to remove any keys that are now <em>up</em>, filter the new matrix to remove any keys already present in the debounce (which may give us another zero matrix again, but our keyscan table doesn&#39;t match an all zeroes matrix, so it&#39;s &#34;fine&#34;), and update the debounce matrix with the new bits that are down while clearing the SHIFT flag. This heavily uses the oddball <tt>szc</tt> instruction, which is an inverted logical-AND (though, like <tt>soc</tt> and <tt>ori</tt>, there is a regular immediate <tt>andi</tt> that is <em>not</em> inverted, a curious non-orthogonality in the instruction set). I won&#39;t show every store here but I&#39;ll give the overall flavour — there&#39;s probably a more efficient way to do it than I&#39;ve done, but this is also pretty easy to follow conceptually:
</p><div><pre>        ; remove any bits in the debounce that aren&#39;t set currently
        mov @keyzone,r0
        inv r0
        szc r0,@keyzone+8       ; inverted and
        mov @keyzone+2,r0
        inv r0
        szc r0,@keyzone+10
[...]
        ; remove any bits in the new keyscan that were still set in debounce
        ; if we end up with a cleared keyscan, it doesn&#39;t matter since we
        ; won&#39;t be able to decode it anyway
        mov @keyzone,r0
        szc @keyzone+8,r0       ; inverted and
        mov r0,@keyzone
        mov @keyzone+2,r0
        szc @keyzone+10,r0
        mov r0,@keyzone+2
[...]
        ; update debounce, clearing shift
        ; add any new bits to debounce so they get masked off too
[...]
        mov @keyzone+4,r0
        soc @keyzone+12,r0
        mov r0,@keyzone+12
        mov @keyzone+6,r0
        soc @keyzone+14,r0
        andi r0,0fbffh
        mov r0,@keyzone+14
</pre></div>
<p>
Now with a clean set of keybits, we need to match them against a table. I organized a table of four words representing the eight matrix bytes in ASCII order so once you&#39;ve found a matching set, the index into the table is the result. This table is stored at label <tt>keytab</tt> and looks like this:
</p><div><pre>[...]
        ; symbols and numbers, 32-64
        ; SPACE
        word 00000h, 00000h, 00000h, 08000h
        ; !
        word 00100h, 00000h, 00000h, 00400h
        ; &#34;
        word 00200h, 00000h, 00000h, 00400h
        ; #
        word 00001h, 00000h, 00000h, 00400h
        ; $
        word 00002h, 00000h, 00000h, 00400h
[...]
</pre></div>
<p>
The Tutor does not have CONTROL or ALT keys, just SHIFT, nor does it have a backspace or delete. This lets us redefine our special keys (the cursor keys, MON and MOD) to generate indices in the control character range. Our table turns MOD into ^C (consistent with its use in Tomy BASIC as break), LEFT/UP/DOWN/RIGHT as ^H ^K ^M/CR ^L, RT (RETURN) as ^J/LF, and MOD as ^[/ESC. To round out other common ASCII points the default keyboard doesn&#39;t generate, ^I/TAB is encoded as SHIFT-SPACE, backtick as SHIFT-UP, tilde as SHIFT-DOWN and ^?/DEL as SHIFT-LEFT. The pipe and backslash characters remain represented by flat and degree/handaku, which have the same ASCII value. The only key our matrix table does not handle is LOCK, which would be <tt>word 00000h, 00000h, 00000h, 00200h</tt>. I&#39;d probably implement this as a conventional CAPS LOCK defaulting to up but we&#39;ll exclude that from the logic for now. Anything not matched in the table gets a result of 0.
</p><div><pre>        ; decode key
        ; each table entry corresponds to CRUs &gt;EC00-EC70
        ; use a custom table to generate a standard ASCII value
        clr r6
        li r1,keytab
dekodl  mov *r1+,r2
        mov *r1+,r3
        mov *r1+,r4
        mov *r1+,r5
        ci r2,0ffffh            ; no key here
        jeq dekodn
        ; if the key matrix is an exact match, should be all zeroes
        xor @keyzone,r2
        xor @keyzone+2,r3
        xor @keyzone+4,r4
        xor @keyzone+6,r5
        soc r3,r2
        soc r4,r2
        soc r5,r2
        jeq dekodo
dekodn  inc r6
        ci r6,128
        jne dekodl
        b @keez
dekodo  mov r6,r0               ; got a good key
</pre></div>
<p>
Like the debounce comparator, this code XORs the current matrix value against the current table entry; if it gets all zeroes, we have a match. At the end the resulting character code is in R6 and R0. Parenthetically, the 9900 has a <tt>inct</tt> instruction that increments by two instead of just one with regular <tt>inc</tt>, useful for skipping words (you can also use an instruction like <tt>c *r1+,*r1+</tt> to increment by four in one word).
</p><p>
Because we left the VDP memory pointer at the end of our &#34;hello world&#34; blurb, to print the character to the screen we could simply do <tt>swpb r0</tt> to get it in the upper byte followed by <tt>movb r0,@vdpwd</tt>. This doesn&#39;t scroll at the end as there&#39;s no bounds-checking, and remember the Tutor doesn&#39;t have a backspace (control characters are simply printed as blanks anyway), but it&#39;s really really fast. However, we also want to display a cursor for we&#39;ll use our reversed space character, so we&#39;ll keep a rolling screen pointer in R7. We&#39;ll additionally have RT clear the screen and as a convenience use MON to bail out to the Tomy title.
</p><div><pre>        ; check for mon - implemented as escape
        ci r0,001bh
        jeq bye

        ; check for RT - implemented as line feed
        ci r0,000ah
        jne putc
        bl @clrscr
        b @cursor

        ; otherwise print character using a cursor
        ; overwrite previous cursor character with new character
putc    swpb r7
        movb r7, @vdpwr
        swpb r7
        movb r7, @vdpwr
        swpb r0
        ; MAME will actually allow a mov here but not the real machine
        movb r0, @vdpwd
        inc r7
        ; and print cursor
cursor  li r0,0a000h
        movb r0, @vdpwd
        b @keez
</pre></div>
<p>
The simplest way to go back to the title screen is to call the Tutor&#39;s reset vector, but paradoxically the 9900&#39;s built-in <tt>rset</tt> instruction is <em>not</em> what we want for this. There are a handful of TI-990 holdovers called <a href="https://www.unige.ch/medecine/nouspikel/ti99/tms9900.htm#External"><i>external instructions</i></a> which were used for special context switching operations, such as <tt>lrex</tt> to jump into front panel code. However, on the 9900/9995, most of the instructions with the possible exception of <tt>idle</tt> do nothing useful and in some cases could be potentially harmful depending on what&#39;s listening on the bus.
</p><p>
Instead, we&#39;ll use the low memory vectors. 9900 vectors consist of a pair of WP and PC words, with interrupt vectors starting at $0000. When an interrupt is triggered, or a vector is branched to using the <tt>blwp</tt> instruction, the WP and PC are loaded in order from those words (instantly saving the previous code&#39;s registers, assuming there is no conflict) and the previous values of WP, PC and ST are placed in the new R13, R14 and R15 respectively. The <tt>rtwp</tt> instruction then reverses everything using those registers and thus returns to the prior execution context. Theoretically the TMS9900 can support up to 16 levels of interrupt, starting at $0000 with level 0 for resets through $003c for level 15, though the 99/4 and 99/4A just wire everything to interrupt level 1. In the 9900 memory map these vectors are followed by XOP vectors for up to 16 software-defined opcodes via the <tt>xop</tt> family of instructions.
</p><p>
However, the 9995 only implements seven distinct interrupt levels, two of which are actually software interrupts (and one of those doesn&#39;t even work properly according to the manual errata). The highest level is level 0, connected to the reset pin, followed by the <tt>mid</tt> interrupt used for software opcodes, then NMIs, and then four numbered interrupts consisting of an external interrupt (1) on the INT1 pin, a not-reliably-functional arithmetic overflow interrupt (2), the on-chip decrementer (3) and another external interrupt (4) on INT2. These have their own vectors except for the MID interrupt and interrupt level 2 which share the same vector, and other than the NMI vector at $fffc all the rest come from low memory as well.
</p><p>
In this particular regard, the Tutor is no different from the 99/4A: a <tt>blwp 0</tt> will jump into the reset vector at $0000, just as if you&#39;d powered the machine on and allowing you to go back to the menu. While the Tutor also uses the same reset vector values for levels 1 and 2, level 3 (the decrementer) runs normally to service its regular tasks and the level 4 (external INT2 triggered) interrupt is used for triggering on tape reads. On the other hand, the Tutor uses the entire XOP vector range as part of a jump table, so it isn&#39;t possible to use any XOP instructions on the Tutor with the standard ROMs (the 99/4A at least has <a href="http://www.unige.ch/medecine/nouspikel/ti99/tms9900.htm#XOP">a couple useful values there</a>). Anyway, all this is to say that a simple <tt>blwp 0</tt> will be sufficient.
</p><p>
That&#39;s pretty much it, and we&#39;re ready to assemble our first draft. I&#39;ll get to the code in a minute, but let&#39;s test it in MAME with <tt>mame tutor -skip_gameinfo -cart tello.rom</tt>. Our character set and welcome message appear beautifully though typing is a bit ... messy.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgVLyQPcgPH6ZXZ9ZFDym7RWkMe848NRoMs3r5VJ0KP3kBEfzZBYNVG2Brkv9l0kRYN03QhMsbrQhSpUVR8ITZQru19OMAX0UwT9vbtpBhPqniGTK_e60yppj8v6n8rlGz-x2ltkM4RNNvlwfvtpb6f97TKX13gaprTnMk6bY35iJ0TGJDQf_PhblGGgk4/s792/mame-joy.png"><img alt="" data-original-height="630" data-original-width="792" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgVLyQPcgPH6ZXZ9ZFDym7RWkMe848NRoMs3r5VJ0KP3kBEfzZBYNVG2Brkv9l0kRYN03QhMsbrQhSpUVR8ITZQru19OMAX0UwT9vbtpBhPqniGTK_e60yppj8v6n8rlGz-x2ltkM4RNNvlwfvtpb6f97TKX13gaprTnMk6bY35iJ0TGJDQf_PhblGGgk4/s320/mame-joy.png" width="320"/></a></p><p>

The problem isn&#39;t our code, it&#39;s MAME&#39;s default settings. You&#39;ll find the same mojibake occurs while typing in regular BASIC as well. I mentioned that the keyboard matrix is shared with the joy controller lines (though that&#39;s actually useful because it allows you to read some keys from GBASIC which wouldn&#39;t ordinarily permit this), and because MAME defines some keys for the controller, you can&#39;t type normally with the default keyboard settings. In my case, I have a Hyperkin Trooper 2 USB joystick I use for Tutor games because it has two buttons for SL and SR, so I removed the key equivalents for the joy controllers and set it to exclusively use the joystick. Now we can type normally.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD_pri3erbef3eNg855yPlK1RenlRvirK2xW7vB0Njp5YQLbcdhVHdrs9eeEOQYkEhu3GxAvaMVHUVLX7EZLDoePUnoHstU3cmxMku0XWsVT5CPWk80T3-h9LgOiWemgOgadyxF3U2Bk-BIH_pmFhRvqYWUUaP0f5Kr4Z-JLliJz2pOpdkTTU30sQV95g/s792/mame32.png"><img alt="" data-original-height="630" data-original-width="792" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjD_pri3erbef3eNg855yPlK1RenlRvirK2xW7vB0Njp5YQLbcdhVHdrs9eeEOQYkEhu3GxAvaMVHUVLX7EZLDoePUnoHstU3cmxMku0XWsVT5CPWk80T3-h9LgOiWemgOgadyxF3U2Bk-BIH_pmFhRvqYWUUaP0f5Kr4Z-JLliJz2pOpdkTTU30sQV95g/s320/mame32.png" width="320"/></a></p><p>

And as hoped for, typing now flows beautifully. There is one more issue we need to solve, though:

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjO6ve2aurIKxK0yia2DJVsAsG0_-kAoD-JHj6ABaTZTD1nLgI58-huJw-zFymd14LlvtguZgJSqjc3amEkG2sf4dUvXPL_KYYksUJqbYazvRem-J73uBhbL9DhmyUk_N3nk0TGDi9ziLk1kQ1x8kYRXxscBJtLjh4PyNYbcGq0MBXOcQpPx5Cz-nT6Oko/s792/mame40-1.png"><img alt="" data-original-height="630" data-original-width="792" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjO6ve2aurIKxK0yia2DJVsAsG0_-kAoD-JHj6ABaTZTD1nLgI58-huJw-zFymd14LlvtguZgJSqjc3amEkG2sf4dUvXPL_KYYksUJqbYazvRem-J73uBhbL9DhmyUk_N3nk0TGDi9ziLk1kQ1x8kYRXxscBJtLjh4PyNYbcGq0MBXOcQpPx5Cz-nT6Oko/s320/mame40-1.png" width="320"/></a></p><p>

I mentioned we would like this to also support the 9918A&#39;s 40 column mode, something the Tutor BIOS doesn&#39;t but would be very useful for productivity applications (the Tutor has a lot of great games but it&#39;s time it achieved its potential, darn it). With a little tweaking we can turn on the 40 column bit in VDP register 1 and adjust our message and screen layout so everything ends up in the right place. However, the 9918A can&#39;t display a 320-pixel-wide screen, so instead it displays a 240-pixel-wide screen using only the leftmost six columns of each character cell. The cells are still eight bits wide in memory; the rightmost two are simply not displayed. This sort of works for some of the characters — lowercase in particular, which makes me wonder if this was a consideration during the Tutor&#39;s development — but clearly doesn&#39;t for others.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh9Dx99AZy6ioIU-yIIt8TpypSiS3gz91djNdAJcjSQ8GoW6bjk_GvAOvjjMfV70J7VlvhlYx1s5y_ampInfslL-nFgF-sqdU35uluexLcOkTHB4u2ymSVd1K2U1xe0WpNyA5yo3u4lCF6GiyF5kg5OI6vWNGVvpdHKDgq5nFSnSLpMc_g9JhKVkZESxFA/s743/ultrafont.png"><img alt="" data-original-height="743" data-original-width="728" height="320" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh9Dx99AZy6ioIU-yIIt8TpypSiS3gz91djNdAJcjSQ8GoW6bjk_GvAOvjjMfV70J7VlvhlYx1s5y_ampInfslL-nFgF-sqdU35uluexLcOkTHB4u2ymSVd1K2U1xe0WpNyA5yo3u4lCF6GiyF5kg5OI6vWNGVvpdHKDgq5nFSnSLpMc_g9JhKVkZESxFA/s320/ultrafont.png"/></a></p><p>

Since the font started as a Commodore 64 character set, after all, we&#39;ll go back into <a href="https://commodore.software/downloads/download/40-font-character-editors/2897-ultrafont-v-2">Ultrafont+</a> and start shrinking them down, leaving a bit of gutter space.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixfFQg0-d89t22RWlsLWsgrtF3LMORUHPSv22PxwkIll05fdFP28T4xJDEx97YTWQJnc8zYtCnnhKtQnST-A9gyMEv8vFeE0GIK1Su_PpyBX-jhgFXJSHss9fapD7UqymekT_yTeQteOAGty7TOHxmqjxMUqlrfnwoAzhxOFZ6dJyTefN4yondeRSKkEQ/s792/mame40-2.png"><img alt="" data-original-height="630" data-original-width="792" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixfFQg0-d89t22RWlsLWsgrtF3LMORUHPSv22PxwkIll05fdFP28T4xJDEx97YTWQJnc8zYtCnnhKtQnST-A9gyMEv8vFeE0GIK1Su_PpyBX-jhgFXJSHss9fapD7UqymekT_yTeQteOAGty7TOHxmqjxMUqlrfnwoAzhxOFZ6dJyTefN4yondeRSKkEQ/s320/mame40-2.png" width="320"/></a></p><p>

I think we&#39;re ready to try it on the real thing!
</p><p>
I used minipro to dump the current contents of the multicart ROM and wrote up a little Perl script to do an inplace overwrite on the resulting file with our new binaries. We generate two ROM files called <tt>tello.rom</tt> (32 column) and <tt>tello40.rom</tt> (40 column), which we splice in at locations 0x70000 and 0x74000 and then burn it to flash.
</p><div><pre>% make burn
perl splice /home/censored/tutor.bin 0x70000 tello.rom 0x2000
successfully replaced 8192 bytes at offset 458752 in /home/censored/tutor.bin with tello.rom
perl splice /home/censored/tutor.bin 0x74000 tello40.rom 0x2000
successfully replaced 8192 bytes at offset 475136 in /home/censored/tutor.bin with tello40.rom
minipro -p SST39SF040 -z
Found TL866II+ 04.2.131 (0x283)
Pin test passed.
minipro -p SST39SF040 -w /home/censored/tutor.bin
Found TL866II+ 04.2.131 (0x283)
Chip ID OK: 0xBFB7
Erasing... 0.40Sec OK
Writing Code...  30.12Sec  OK
Reading Code...  4.30Sec  OK
Verification OK
</pre></div>
<p>
The multicart DIP settings for the 32-column version are (1=on) 00011 if you use those addresses. The first time I tried, the hello message appeared but typing generated no output. This was because I had a <tt>mov r0,@vdpwd</tt> instead of <tt>movb r0,@vdpwd</tt>; MAME will accept either instruction but not a real Tutor. With that corrected, we&#39;re in business!

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhKniWgHE_hqJGJMj5MwUZyxKWTuowEU8KKqbv6Bn1ol8eFpLkLZJJFNRgQoSQaAAgJkuAsQtwq8ha-3kXIOrBv5MUIgmB7DhYBCNasghACSxtHViKduIxTjAAaq9KiNjiZc2RDvRH9g-6cua-Dvx2UoA0lvAWcACmBf5ikjZrl3sEh5ftjoQSIPcETYLw/s640/vlcsnap-2024-03-08-22h11m17s070.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhKniWgHE_hqJGJMj5MwUZyxKWTuowEU8KKqbv6Bn1ol8eFpLkLZJJFNRgQoSQaAAgJkuAsQtwq8ha-3kXIOrBv5MUIgmB7DhYBCNasghACSxtHViKduIxTjAAaq9KiNjiZc2RDvRH9g-6cua-Dvx2UoA0lvAWcACmBf5ikjZrl3sEh5ftjoQSIPcETYLw/s320/vlcsnap-2024-03-08-22h11m17s070.png" width="320"/></a></p><p>

For the 40-column version, set the DIP switches to 00010.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgkm6sk62iiO8ZwUcIQ9LMU8yk3zTrhnPjdH0i0I8K1z_7080DK9MuT0nzF1tHnaxRujUTnOuyX903qnbC9U80YoFA766EOC99QZpygZFlG1nFXXnFQZym-j42ors_K1kMER2lCeTptg6krCOx05Xep9w33vbgOqNBBdl1WVAMkPldS_8Yt1q2Wsibvd4o/s640/vlcsnap-2024-03-08-22h18m41s523.png"><img alt="" data-original-height="480" data-original-width="640" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgkm6sk62iiO8ZwUcIQ9LMU8yk3zTrhnPjdH0i0I8K1z_7080DK9MuT0nzF1tHnaxRujUTnOuyX903qnbC9U80YoFA766EOC99QZpygZFlG1nFXXnFQZym-j42ors_K1kMER2lCeTptg6krCOx05Xep9w33vbgOqNBBdl1WVAMkPldS_8Yt1q2Wsibvd4o/s320/vlcsnap-2024-03-08-22h18m41s523.png" width="320"/></a></p><p>

These are real composite video captures from my real Tutor. Hurray! We did it!
</p><p>
Now, what things could you do with better keyboard support, true ASCII and fast character display? Well, obviously this whole proof of concept is the start of doing something more practical with the Tutor. <a href="http://oldvcr.blogspot.com/search/label/tomy%20tutor">I&#39;ll answer that question in a couple months</a> once all the parts arrive. The first order of business will be installing a PLCC adapter in the multicart so I don&#39;t have to pull the flash chip out repeatedly for testing.

</p><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjJKmoRaWSEhlk_RTiLGJA5P8238SBtHHY4TyZwK9_w5idE2YE7jKH7ea7WVo6Q7HmHljb6t_g6WpIc-1UOR5M7nmq0yvPnp4gdES2xsZ4nxygJp455pcGrrNumX1WnZGTtlNFanqewltrfqQTsOUhKUJVLhJ4O2a2BytwfcwKjG0RPDjPwfjAjxw__E-c/s2048/DSCN7059.JPG"><img alt="" data-original-height="1536" data-original-width="2048" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjJKmoRaWSEhlk_RTiLGJA5P8238SBtHHY4TyZwK9_w5idE2YE7jKH7ea7WVo6Q7HmHljb6t_g6WpIc-1UOR5M7nmq0yvPnp4gdES2xsZ4nxygJp455pcGrrNumX1WnZGTtlNFanqewltrfqQTsOUhKUJVLhJ4O2a2BytwfcwKjG0RPDjPwfjAjxw__E-c/s320/DSCN7059.JPG" width="320"/></a></p><p>

Let&#39;s briefly finish our Tutor story. There are in fact two other members of the Tutor/Pyuuta family, both domestic to Japan: the Pyuuta Jr., a game console that came out between the Pyuuta and Tutor that implemented GRAPHIC mode (but no GBASIC) and could play most cartridges — but was entirely in English with no katakana support at all — and this, the last and final Tutor, the Pyuuta Mark II (variously Pyuuta mk II and Mark II). The mk II had proper keycaps with a rearranged layout and used the American Tutor BIOS instead of the Pyuuta&#39;s, with Tomy BASIC (also the same as the American Tutor&#39;s version) available as an add-on cartridge. Notably, neither system supported a composite monitor, only RF TV output, though they&#39;re pretty easy to comp-mod. Both systems have slight hardware differences from the Pyuuta and Tutor but both will run all the same cartridge games, and they also don&#39;t require special hardware for 32K cartridges. Unfortunately, their English-only nature probably didn&#39;t endear them to their home markets and the mk II can&#39;t load Pyuuta tapes either (only US Tutor ones). Likely as a result, both sold poorly, and Tomy exited the home computer market as well in 1984.
</p><p>
As for the 9995, in the end it was only ever implemented in three systems: the Tutor/Pyuuta family, a PEB upgrade called the Myarc Geneve 9640 which was basically a new TI-compatible computer on a card, and the <a href="http://powertrancortex.com/">Powertran Cortex</a>, a home and business computer first built at TI in the United Kingdom that never got released due to internal squabbles. Instead, its plans were published in the Electronics Today International magazine and a company called Powertran Cybernetics sold kits and fully assembled machines. The Cortex ran at a full 3MHz, had 64K of chip RAM (with a memory mapper supporting up to 1MB) and used a 16K PAL equivalent 9928/29 VDP for graphics, though the more advanced Yamaha/Maplin V9938 could also be substituted with up to 128K of VRAM. Floppy, serial and DMA were all supported along with a built-in BASIC and multiple operating system options, even a small <a href="http://www.stuartconner.me.uk/mini_cortex/mini_cortex.htm#using_unix">v6 UNIX port called LSX</a>. Although popular with enthusiasts, it was an obscure system then and now, and relatively few examples remain in operation.
</p><p>
While the 9995 was a much more tractable chip than its ancestors, the reliance of the 9900 series on RAM was what eventually stunted its technological evolution. In the days when it was taped out, CPU die space was expensive, so shifting register space onto cheaper RAM which often ran at a similar speed was a logical alternative. Indeed, tricks like 6502/6800 zero page are the same basic idea, using a special expanse of memory with faster access and special addressing as if it were CPU registers itself. As CPUs became substantially faster than memory, however, this architectural quirk became more of a liability and contemporary 16-bit CPUs like the Motorola 68000 and the Intel 8086 and 80286 eclipsed it. A chip like the 6502 only got away with it for as long as it did because it was incredibly cheap and incredibly common and even today still sells in quantity, neither advantage being one the 9900 or 9995 ever possessed. Today, modern CPUs have comparatively massive register files and caches as proof that the 9900 idea was a dead end. After the 99000 family, an upgraded 9900 with segmented memory only used in TI&#39;s last range of minicomputers, TI abandoned further development of the architecture in 1983 for the TMS320 DSP series and the exceptionally swift TMS32010, a much more popular (and, especially for a DSP, more conventional) processor.
</p><p>
The source code for our demonstration project along with a <tt>Makefile</tt>, the character set binaries and the keyscan table <a href="https://github.com/classilla/tello">are available on Github</a> under a 3-clause BSD license.
</p>
</div></div>
  </body>
</html>
