<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brainonfire.net/blog/2022/04/11/what-is-parser-mismatch/">Original</a>
    <h1>What is a parser mismatch vulnerability? (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>There&#39;s a class of security vulnerabilities that has gotten very
little attention until recently but shows up everywhere. In the past I
called these <dfn>dueling parser</dfn> vulnerabilities, but recently
there has been more recognition of this vulnerability class, and the
terms <dfn>parser confusion</dfn> and <dfn>parser mismatch</dfn> have
come into use. In this post I&#39;ll be using &#34;parser mismatch&#34; because it
is the clearest and most descriptive.</p>
<figure>
  <img src="https://www.brainonfire.net/blog/2022/04/11/what-is-parser-mismatch/attach/Kaninchen_und_Ente.svg" width="300" height="194" alt="Optical illusion, a drawing that can be seen as either a rabbit or a duck"/>
  <figcaption>Parser mismatches: Optical illusions for software</figcaption>
</figure>

<h2>Broadly defined</h2>
<p>A parser mismatch occurs when you have:</p>
<ul>
<li>Two code locations</li>
<li>...each of which tries to parse the same thing</li>
<li>...but where the parsers disagree on what some inputs mean.</li>
</ul>
<p>In general, you&#39;ll see two kinds of behavior:</p>
<ul>
<li>For &#34;normal&#34; inputs they&#39;ll almost always agree</li>
<li>For malformed inputs, they&#39;ll often disagree, creating the
  possibility of a vulnerability</li>
</ul>
<p>Kinda abstract. Let&#39;s get more concrete.</p>
<h2>Example: Almost nobody agrees on URLs</h2>
<p>I&#39;ll start with an apparently low-stakes scenario that turns out to be
quite serious.</p>
<p>Imagine you have a support forum for a website and you want to allow
people to post comments. Before the site accepts a comment, it
checks any links it contains and rejects it if any of the URLs
aren&#39;t on an allowlist (perhaps out of concern of the risk of
spam or off-topic discussions.) The comment is then later displayed
in a browser.</p>
<p>Someone tries to post a link to <code>http://example.net\@github.com</code>. To
our eyes this is clearly a malformed URL; <code>\</code>
<a href="https://datatracker.ietf.org/doc/html/rfc3986#section-2.2">isn&#39;t allowed in URLs according to RFC 3986</a>.
Ignoring that, you would expect the parser to break off the scheme at
the <code>:</code>, recognize <code>//</code> as starting a &#34;hosted authority&#34; and the next
<code>/</code> as terminating it, and then split the authority at the <code>@</code> to find
the userinfo and host. So, you&#39;d expect a host of <code>github.com</code> and a
userinfo section of <code>example.net\</code>.</p>
<p>But what actually happens?</p>
<p>Maybe you&#39;re using Java&#39;s oldest URL parser on your backend,
<code>java.net.URL</code>, and its <code>getHost</code> method. It returns <code>github.com</code> as
you might expect. GitHub happens to be on your allowlist, so you let
it through. But watch what happens in your browser:
<a href="http://example.net\@github.com" title="This really does have a backslash in it, but it will display with a forward slash in your status bar on hover!">http://example.net\@github.com</a>.
If you use Firefox, Chrome, or certain other browsers, you&#39;ll end up on
<code>example.net</code> instead of <code>github.com</code>.
The result is that an &#34;attacker&#34; can post a link that looks OK to the
server (<code>domain == &#34;github.com&#34;</code>) but that will go to a disallowed
domain (<code>example.net</code>) in some major browsers.</p>
<p>Why?</p>
<p>Well, these browsers &#34;helpfully&#34; fix the URL to change backslashes
into regular forward slashes, I suppose because people sometimes
type in URLs and get their forward and back slashes confused.
With the resulting value of <code>http://example.net/@github.com</code>,
the backslash becomes a path separator and the host is <code>example.net</code>.</p>
<p>(You might wonder how such a blatant difference can exist. You can read
up on the <a href="https://daniel.haxx.se/blog/2016/05/11/my-url-isnt-your-url/">background of WHATWG and its alternative browser-centric
URL spec</a>,
but for the purposes of understanding this vulnerability it doesn&#39;t matter; essentially all
URL libraries have <em>some</em> kind of spec non-compliance. <code>java.net.URL</code>
has some truly bizarre behaviors of its own. The newer <code>java.net.URI</code>
is better and will just throw an exception if given this backslash
URL, but still has some issues. And the same kinds of issues are
present in all standard libraries I&#39;m aware of, not just in Java. Go
read <a href="https://security.claroty.com/URLparserconfusion">Claroty&#39;s report on URL parser
mismatches</a> if you
want to see more. The state of the industry here is an absolute train
wreck.)</p>
<p>So: We have two code locations (one in the server, one in the
browser) that use two different parsers, and which will understand
some inputs differently. This is a classic parser mismatch.</p>
<p>Now, I mentioned that this turned out to be quite serious in
practice. In fact, this exact parser mismatch made David Schütz over
$12,000 in bug bounties with Google
[<a href="https://bugs.xdavidhu.me/google/2020/03/08/the-unexpected-google-wide-domain-check-bypass/">1</a>,
<a href="https://bugs.xdavidhu.me/google/2021/12/31/fixing-the-unfixable-story-of-a-google-cloud-ssrf/">2</a>]
when one end of the mismatch was in a gatekeeper that had the power to
grant access to all sorts of Google internal systems.</p>
<p>Note, also, that Google&#39;s solution was to try to make their server try
to behave more like a browser, even though browsers vary in their
behavior and could change at any time. Their solution was also incomplete
and David managed to bypass it repeatedly, which added up to a rather
large bounty in total. (In fact, after his second post, someone <em>else</em>
<a href="https://twitter.com/xdavidhu/status/1477664931877163010">bypassed the latest
fix</a>.) In an
upcoming post, I&#39;ll give some safer, more robust solutions.</p>
<h2>Example: Sloppy header splitting</h2>
<p>In a previous post I described a <a href="https://www.brainonfire.net/blog/2017/07/06/imzy-security-assessment-part-1/">vulnerability in Imzy&#39;s image
proxy</a>,
an endpoint which was supposed to allow users to embed external images
in their posts without leaking their IP address to the hosting
server. The proxy would fetch the indicated URL and relay the body and
headers back to the browser. There were a number of vulnerabilities
here, but at one point an Imzy developer tried to secure the endpoint
by failing the response if the <code>Content-Type</code> response header did not
match <code>image/.*</code>.</p>
<p>My approach to evasion was to have my proof-of-concept exploit page
send a response header of <code>Content-Type: image/foo, text/html</code>.</p>
<p>Now, in HTTP, there are a number of headers that are considered
<dfn>multivalued</dfn>, meaning they can be present multiple times in
the response and can be squashed together into a single header field
by comma-separating their values. <code>Content-Type</code> is <em>not</em> supposed to
be multi-valued, and is only supposed to <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-3.1.1.5">contain a single
media-type</a>;
splitting on commas is not only a violation of the spec but would
mangle any quoted-string parameter that happened to contain a
comma. (And an unquoted comma would never be present in a well-formed <code>Content-Type</code>.)</p>
<ul>
<li>The first code location, Imzy&#39;s proxy server, understood the header
  value of <code>image/foo, text/html</code> to be a <em>single value</em> and checked
  that it started with <code>image/</code>. Since it did, the server allowed the
  response through.</li>
<li>The second code location, my browser, apparently treated the comma
  as a value separator for a multivalued header, and it took the last
  &#34;value&#34;. This would be as if the server had first sent
  <code>Content-Type: image/foo</code> and then <code>Content-Type: text/html</code>. My
  proxied response was therefore treated as <code>Content-Type: text/html</code>,
  as the later value took priority, and the exploit ran.</li>
</ul>
<p>Again, we have an input that failed to meet the spec, and two
different parsers that handled it differently. The first piece OK&#39;d
the input, the second acted on it, but with a different understanding.</p>
<p>(It&#39;s also possible that Imzy&#39;s server instead split on commas and
took the <em>first</em> value, <code>image/foo</code>. Some server software mishandles
multivalued headers in this way. Same effect, though.)</p>
<p>Also note that just as with the URL examples, the first code location
was acting as a guard to prevent abuse of the second code location. By
sending in a malformed input, the attacker can slip an invalid or
malicious input past the guard. This guard/actor pattern is very
common with parser mismatch.</p>
<h2>Example: HTTP Request Smuggling</h2>
<p>HTTP requests can either be sent with a <code>Content-Length</code> header
indicating up-front the exact number of bytes to read after the
headers, or can specify <code>Transfer-Encoding</code> in order to indicate that
there will be a stream of pieces, each preceeded by a
length. Specifying <em>both</em> in a single request is invalid, and it can
cause a proxy and its origin server to disagree on the <em>boundaries</em>
within a stream of HTTP requests that are all sent over the same
kept-alive connection.  Because of this disagreement, a chunk of one
request can end up becoming part of another unrelated one, allowing
hijacking of credentials if that other request was
authenticated. Caches can be hijacked. Malicious requests can bypass
<abbr title="Web Application Firewalls">WAFs</abbr>. In short,
arbitrarily bad things can happen in handling those requests.</p>
<p>Giving a worked example or a thorough explanation
is beyond the scope of this blog post, so I&#39;ll
refer you to <a href="https://portswigger.net/web-security/request-smuggling">Portswigger&#39;s article on the
subject</a> as
well as the <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf">original 2005 report from
Watchfire</a>.</p>
<p>What I find interesting here is that the cache poisoning and auth
hijacking fall outside of what I think of as the usual &#34;guard/actor
pair&#34; pattern of parser mismatch exploits. But the cause is still
the same: A disagreement on how to parse an unusual input leads to
a vulnerability.</p>
<p>This also highlights that HTTP is something that is <em>parsed</em>, despite
being what people would call a &#34;protocol&#34; rather than a
&#34;format&#34;. Don&#39;t be distracted by these categorizations. Handling HTTP
requires parsing, both of the header format in general and the values
of specific headers. And even once the headers are all processed into
data structures (e.g. a multi-valued map), anything that consumes
those parsed headers still needs to understand them in relation to
each other.</p>
<p>More recently, <a href="https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/">SMTP smuggling was
described</a>
as well.</p>
<h2>Example: JSON is not a subset of Javascript</h2>
<p>Originally, JSON was conceived of as a subset of Javascript that did
not allow code execution, just data construction: Strings, numbers,
arrays, maps, etc. It&#39;s in the name &#34;JavaScript Object
Notation&#34;. Before <code>JSON.parse</code> was a part of the Javascript language,
this meant that developers would sometimes &#34;parse&#34; JSON by checking if
it was well-formed and then passing it to <code>eval</code>.</p>
<p>Except... it wasn&#39;t <em>entirely</em> a subset of Javascript. There were some
odd quirks around Unicode characters U+2028 &#39;LINE SEPARATOR&#39; and
U+2029 &#39;PARAGRAPH SEPARATOR&#39; that I ran up against, resulting in
exceptions. (Those are allowed in JSON, but not JS, or at least that
was the case in 2010.) But I only recently learned about a major
security issue stemming from this mismatch, <a href="https://dev.to/mikesamuel/2008-silently-securing-jsonparse-5cbb">fixed quietly in
2008</a>.</p>
<p>That post is well worth a read, but it comes down to a situation where
a certain whitespace character is in the middle of what would
otherwise be an escape sequence like <code>\&#34;</code>. In by-the-book JSON parsing
the character is preserved; in Javscript, the character is stripped,
and the quote now actually terminates a string. Code execution is then
trivial.</p>
<p>Where is the guard/actor pair, here? You have to squint a bit, as it&#39;s
actually &#34;inside the parser&#34;; json2.js presented itself as a parser,
but it delegated most of the work to a different parser entirely: It
ran a regular expression first to check if the JSON looked valid (the
guard), and then eval&#39;d the JSON as JS (the actor). The mismatch,
here, was between the regex&#39;s assumptions about JS and what JS
actually does.</p>
<h2>Conclusions</h2>
<p>Drawing on these examples, what can we say about the general
properties of parser mismatch?</p>
<ul>
<li>The vulnerability requires two parsers that are intended to follow
  the same spec, or at least two very similar specs, but differ in
  practice. The &#34;spec&#34; may or may not be well-defined, in practice,
  but if the two parsers are identical then it does not matter how
  badly they deviate from the spec, or how they fill in the gaps.  But
  even with generally well-written parsers, even a single deviation
  from spec in one that is not shared by the other may be enough to
  produce a vulnerability.</li>
<li>The definition of &#34;parser&#34; here is looser than one might normally
  use. If two systems understand two data structures differently, it&#39;s
  still a parser mismatch in my book, just as much as if the inputs
  were strings.</li>
<li>Exploitation is more likely with an input that violates the spec,
  but is accepted by both parsers anyway. Or, it may be an input that
  the spec does not sufficiently define the behavior for—some kind of
  edge case. (None of the examples provided here involve
  spec-conformant inputs, and though an exploit using one might be
  possible in some situation, it doesn&#39;t seem to be the common case.)
  In a sense, these are ambiguous inputs—optical illusions for software.</li>
<li>The two code locations are often a guard/actor pair, where the
  first location controls whether the second location is executed, or
  more generally is &#34;upstream&#34; in the control flow.</li>
</ul>
<p>Some implications:</p>
<ul>
<li>Following the spec, while quite important, is no guarantee.</li>
<li>A parser mismatch vulnerability may sometimes be more properly
  described as a vulnerability in an <em>integration</em> rather than any
  particular well-defined package of code. The two locations may be in
  the same software package, or may be in different programming
  languages and maintained by different people.</li>
<li>Consequently, looking at any <em>one</em> piece of code will not
  definitively reveal a parser mismatch vulnerability, and can at best
  suggest the possibility of one.</li>
<li>Exploiting a parser mismatch is a bit like programming a <a href="https://en.wikipedia.org/wiki/Weird_machine">weird
  machine</a>, as the
  attacker needs to reverse engineer the parsers to find out what
  they &#34;implement&#34; in practice, rather than what they were intended to
  implement.</li>
<li>Following the &#34;be liberal in what you accept&#34; part of <a href="https://en.wikipedia.org/wiki/Robustness_principle">Postel&#39;s
  Law</a>
  dramatically increases the likelihood of a parser mismatch
  vulnerability, since it encourages parsers to widen what they accept
  in an uncontrolled and uncoordinated fashion.</li>
<li>Any standard that introduces a grammar should be combed for
  underspecified edge cases. Grammars should be made as simple and
  composable as possible in order to reduce the chances of
  disagreement between implementations. I&#39;ve seen a few RFCs with a
  &#34;Security Considerations&#34; section that simply says &#34;no security
  implications&#34; after having introduced a grammar, and I feel like at
  this point we should regard those as being in conflict.</li>
</ul>
<h2>Relationship to other vulnerability classes</h2>
<p>A quick note on two other vulnerability classes that I feel have some
kinship to parser mismatches, despite being very different in other
ways:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">Time-of-check to
  time-of-use</a>
  (TOC/TOU) is another &#34;two locations&#34; class of vulnerability where
  the relationship of a guard and an actor is poorly controlled. But
  instead of being exploitable by an ambiguous input, the issue is
  that something in an external context is mutable and actually
  <em>changes</em> between the times the two code locations run. I don&#39;t have
  a lot of familiarity with these, but I believe the code locations in
  TOC/TOU are usually quite close together, which is another important
  distinction.</li>
<li>Injection attacks of various sorts (SQLi, XSS, etc.) are only
  related insofar as they center on parsing; they&#39;re possible when the
  <em>shape</em> of the parse tree can be controlled or altered by the
  attacker. Sometimes there is synergy, though, such as when parser
  mismatch allows bypass of the XSS auditor or some other attempted
  mitigation.</li>
</ul>
<p>You might also see some subclasses of parser mismatch with their own
name, just like injection vulnerabilities are broken out into XSS,
SQLi, HTTP header splitting, and so on. The only named subclass of
parser mismatch I&#39;ve seen so far is &#34;URL parser confusion&#34;, but we&#39;ll likely see
others soon. I predict that sooner or later we&#39;ll also have a name
for bad handling of multi-valued HTTP headers, too, but I haven&#39;t seen
one yet.</p>
<h2>Next up: What to do about it</h2>
<p>I hope by now you have a solid understanding of what a parser mismatch
is and will be more prepared to recognize one while reviewing code or
trying to decide how to patch a vulnerability.</p>
<p>But recognition is only half the battle—how will you prevent them, or
even fix ones that you discover? These mismatches are slippery and
involve multiple systems, and digging into parser internals and spec
edge cases can be brutal work.</p>
<p>That topic deserves a post of its own, so continue on to part 2:
<a href="https://www.brainonfire.net/blog/2022/04/29/preventing-parser-mismatch/">Preventing (and fixing) parser mismatch vulnerabilities</a>.</p>
<h2>Updates</h2>
<ul>
<li>2022-04-16: Added optical illusion comparison, and discussion of
  protocols vs formats.</li>
<li>2022-04-29: Linked to followup post.</li>
<li>2023-07-29: Added example about <code>JSON.parse</code>.</li>
<li>2023-12-21: Added link to SMTP smuggling article.</li>
</ul>
          </div></div>
  </body>
</html>
