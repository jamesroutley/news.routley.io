<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ssno.cc/posts/reversing-tac-1-4-2025/">Original</a>
    <h1>Reverse engineering Call of Duty anti-cheat</h1>
    
    <div id="readability-page-1" class="page"><div>
      
  <article>
    
    <div>
      <p><strong>I’ve been reversing Black Ops Cold War for a while now, and I’ve finally decided to share my research regarding the user-mode anti-cheat inside the game. It’s not my intention to shame or promote cheating/bypassing of the anti-cheat, so I’ve redacted a few things.</strong></p>
<p><img src="https://vinayak.io/coldwar.png" alt="image info"/></p>
<p>To clear up any confusion, Black Ops Cold War does not have the kernel-mode component of Ricochet that Modern Warfare (2019) and later titles have. I’ll be referring to the anti-cheat as TAC (Treyarch Anti-Cheat) as the game I reversed is a Treyarch game. Also, whenever I provide function pseudocode, it will be the best I can do since the actual decompilation is super cluttered with a lot of junk/resolving code. The biggest difference between the newer games is the kernel-mode driver, while the majority of anti-cheat code is user-mode and very similar to TAC.</p>
<p>Let’s look at how the anti-cheat and the game is protected before we dig too deep.</p>
<h2 id="arxan">Arxan</h2>
<ul>
<li>
<p>Arxan is an obfuscation/protection tool that’s used on many Call of Duty games, most of which are anything past Black Ops 3. Which includes many features, that make cheaters/reverse engineers’ life a lot harder.</p>
<h2 id="runtime-executable-decryption">Runtime Executable Decryption</h2>
<ul>
<li>The game executable is packed and encrypted; Arxan inserts code during the startup process to unpack and decrypt the game executable.</li>
</ul>
<h2 id="executable-checksums">Executable Checksums</h2>
<ul>
<li>Arxan is constantly monitoring the game executable for any patches.</li>
<li>If you want to learn more about these, momo5502 has a great blog post which can be found <a href="https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/">here</a></li>
<li>Whenever Arxan detects a debugger or a checksum mismatch, it will terminate the process.</li>
</ul>
<h2 id="jmp-obfuscation">Jmp Obfuscation</h2>
<ul>
<li>Arxan can take a function and all of its instructions and separate them with a jmp.</li>
<li>This is also useful to hide where a function is called from, it breaks IDA and requires an external tool to sift through the instructions.
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>push</span>    <span>rbp</span>
</span></span><span><span><span>mov</span>     <span>rbp</span><span>,</span> <span>offset</span> <span>unk_7FF60ECD1310</span>
</span></span><span><span><span>xchg</span>    <span>rbp</span><span>,</span> <span>[</span><span>rsp</span><span>]</span>
</span></span><span><span><span>push</span>    <span>rbx</span>
</span></span><span><span><span>jmp</span>     <span>loc_7FF62B2050A6</span>
</span></span><span><span>
</span></span><span><span><span>loc_7FF62B2050A6:</span>
</span></span><span><span><span>push</span>    <span>rax</span>
</span></span><span><span><span>mov</span>     <span>rbx</span><span>,</span> <span>[</span><span>rsp</span><span>+</span><span>10</span><span>h</span><span>]</span>
</span></span><span><span><span>mov</span>     <span>rax</span><span>,</span> <span>offset</span> <span>loc_7FF60ECD1622</span>
</span></span><span><span><span>cmovbe</span>  <span>rbx</span><span>,</span> <span>rax</span>
</span></span><span><span><span>jmp</span>     <span>loc_7FF62BD590D3</span>
</span></span><span><span>
</span></span><span><span><span>loc_7FF62BD590D3:</span>   
</span></span><span><span><span>mov</span>     <span>[</span><span>rsp</span><span>+</span><span>10</span><span>h</span><span>],</span> <span>rbx</span>
</span></span><span><span><span>pop</span>     <span>rax</span>
</span></span><span><span><span>pop</span>     <span>rbx</span>
</span></span><span><span><span>retn</span>
</span></span><span><span>
</span></span><span><span><span>loc_7FF60ECD1622:</span>   
</span></span><span><span><span>jmp</span>     <span>loc_7FF629D04404</span>
</span></span><span><span>
</span></span><span><span><span>; etc
</span></span></span></code></pre></div></li>
<li>This is difficult to analyze statically, especially whenever it’s a giant function that’s been planted with hundreds of jumps.</li>
</ul>
<h2 id="entrypoint-obfuscation">Entrypoint Obfuscation</h2>
<ul>
<li>It’s really difficult to follow the entry point on Arxan-protected games; first, you have the protected Arxan code that unpacks and executes the game’s real entry point, which jmp obfuscation can also be planted in here, making it extremely difficult to understand what’s going on.</li>
</ul>
<h2 id="pointer-encryption">Pointer Encryption</h2>
<ul>
<li>This was actually thought to be Arxan for the longest time, but with recent information, it’s pretty certain this is just something Treyarch has developed and shared with IW for their games, or maybe it’s the other way around.</li>
<li>Important pointers such as the current game glob, entity array, object pointers, etc., are encrypted and decrypted every time before use.</li>
<li>There are 16 variations of the same encryption method; the current PEB address is actually what decides which encryption method to use.
<ul>
<li>This is pretty effective and does make your life harder for a little bit.
<ul>
<li>Forces you to get the decrypted pointer.</li>
<li>Prevents cheat engine pointer scanning (when scanning for the memory address of something that is encrypted, the actual global value will be holding the encrypted value, and this value is never set with the decrypted value; the decrypted value is always on  the stack.)</li>
<li>There are a couple of ways to retrieve these decrypted pointers (these are not all of them):
<ul>
<li>Using a tool to trace the decryption instructions.</li>
<li>Creating a hook on spots where the memory has already been decrypted by the game for use.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>int</span> <span>get_encryption_method</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>// this is actually how it is in the exe
</span></span></span><span><span><span></span>    <span>// the result of this ROL is 0x60 which is gs[PEB]
</span></span></span><span><span><span></span>    <span>// these values are generated and will not always be the same
</span></span></span><span><span><span></span>    <span>const</span> <span>auto</span> value <span>=</span> <span>(</span><span>unsigned</span> <span>__int8</span><span>)</span>__ROL1__<span>(</span><span>-</span><span>127</span><span>,</span> <span>230</span><span>);</span>
</span></span><span><span>    <span>auto</span> peb <span>=</span> __readgsqword<span>(</span>value<span>);</span>
</span></span><span><span>    <span>return</span> _byteswap_uint64<span>(</span>peb <span>&lt;&lt;</span> <span>33</span><span>)</span> <span>&amp;</span> <span>0xF</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
<li>Here’s just a small portion of the operations done in the game exe for the encryption.
<img src="https://vinayak.io/ptr_enc.png" alt="image info"/></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Now we that understand how the game and anti-cheat are protected we can dig deeper.
TAC is planted directly into the game executable, uses no kernel components, and will also terminate the process if debug artifacts are found.</p>
<h3 id="how-does-tac-detect-monitoring">How does TAC detect monitoring?</h3>
<ul>
<li><strong>API Hook Detection</strong>
<ul>
<li>TAC is designed for Windows; this means it’s going to be using Windows-specific APIs for the anti-cheat.</li>
</ul>
<ul>
<li>
<p>The hook detection used here is pretty basic, and it’s currently only checking for 7 patterns. It looks like they have just taken previous cheats’ hook stubs and put them in.</p>
</li>
<li>
<p>NOTE: Each time I provide example code, every API called in that example code is what TAC is using, is being checked for hooks, and is being resolved by their runtime hash lookup. Also, most of TAC is heavily inlined.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; First stub
</span></span></span><span><span><span></span><span>push</span>   <span>rax</span>
</span></span><span><span><span>movabs</span> <span>rax</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rax</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Second Stub
</span></span></span><span><span><span></span><span>push</span>   <span>rbx</span>
</span></span><span><span><span>movabs</span> <span>rbx</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rbx</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Third Stub
</span></span></span><span><span><span></span><span>push</span>   <span>rcx</span>
</span></span><span><span><span>movabs</span> <span>rcx</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rcx</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Fourth Stub
</span></span></span><span><span><span></span><span>push</span>   <span>rdx</span>
</span></span><span><span><span>movabs</span> <span>rdx</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rdx</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Fifth Stub
</span></span></span><span><span><span></span><span>push</span>   <span>0x0</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>; Sixth Stub (this is any call, 0xE8, 0x0, 0x0, 0x0, 0x0)
</span></span></span><span><span><span></span><span>call</span> <span>0x00000</span>
</span></span><span><span>
</span></span><span><span><span>; Seventh Stub (this is any jmp [rip+x], 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00)
</span></span></span><span><span><span></span><span>jmp</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rip</span><span>+</span><span>0</span><span>]</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<ul>
<li>Here’s how these checks are implemented. Those 0x0 spots in the assembly are 8 bytes because this is x64.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>void</span> <span>ac_check_hook</span><span>(</span><span>unsigned</span> <span>__int64</span> address<span>,</span> callback cb<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>unsigned</span> <span>__int8</span><span>*</span> current_pos <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>  <span>bool</span> hook_detected <span>=</span> <span>false</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>for</span> <span>(</span>current_pos <span>=</span> <span>(</span><span>unsigned</span> <span>__int8</span> <span>*</span><span>)</span>address<span>;</span> <span>*</span>current_pos <span>==</span> <span>144</span><span>;</span> <span>++</span>current_pos<span>)</span>
</span></span><span><span>          <span>;</span>
</span></span><span><span>  <span>switch</span> <span>(</span><span>*</span>current_pos<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    <span>case</span> <span>0x50u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>184</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>4</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x53u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>187</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>28</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x51u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>185</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>12</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x52u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>186</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>20</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x68u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>5</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0xE9u</span><span>:</span>
</span></span><span><span>      hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>default</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span><span>*</span>current_pos <span>==</span> <span>255</span> <span>&amp;&amp;</span> current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>37</span><span>)</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>if</span> <span>(</span>hook_detected<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>      cb<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// example usage
</span></span></span><span><span><span></span>ac_check_hook<span>((</span><span>unsigned</span> <span>__int64</span><span>)</span><span>&amp;</span>Thread32First<span>,</span> callback<span>);</span>
</span></span></code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<h2 id="runtime-api-export-lookup">Runtime API Export Lookup</h2>
<ul>
<li>TAC has an inlined API lookup function; it takes the module hash and the API name hash, iterates the current list of loaded modules, hashes the name, then goes through each exported function from that module and compares it to the compile-time hash of the API they want.</li>
</ul>
<p>This is what the decomp looks like.
<img src="https://vinayak.io/runtime_lookup.PNG" alt="image info"/></p>
<p>Here’s a recreation of their runtime lookup.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span>  <span>void</span><span>*</span> <span>get_module_base</span><span>(</span>size_t base<span>,</span> size_t hash<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>  	ac_setbase<span>(</span>base<span>);</span>
</span></span><span><span>
</span></span><span><span>  	<span>auto</span> peb <span>=</span> <span>static_cast</span><span>&lt;</span>PPEB<span>&gt;</span><span>(</span>NtCurrentPeb<span>());</span>
</span></span><span><span>  	<span>auto</span> head <span>=</span> <span>&amp;</span>peb<span>-&gt;</span>Ldr<span>-&gt;</span>InMemoryOrderModuleList<span>;</span>
</span></span><span><span>
</span></span><span><span>  	<span>int</span> mc <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  	<span>auto</span> entry <span>=</span> head<span>-&gt;</span>Flink<span>;</span>
</span></span><span><span>  	<span>while</span> <span>(</span>entry <span>!=</span> head<span>)</span>
</span></span><span><span>  	<span>{</span>
</span></span><span><span>  		<span>auto</span> table_entry <span>=</span> CONTAINING_RECORD<span>(</span>entry<span>,</span> LDR_DATA_TABLE_ENTRY<span>,</span> InMemoryOrderLinks<span>);</span>
</span></span><span><span>  		<span>auto</span> n <span>=</span> <span>static_cast</span><span>&lt;</span><span>int</span><span>&gt;</span><span>(</span>offsetof<span>(</span>LDR_DATA_TABLE_ENTRY<span>,</span> DllBase<span>));</span>
</span></span><span><span>
</span></span><span><span>  		<span>char</span> buf<span>[</span><span>255</span><span>];</span>
</span></span><span><span>  		size_t count <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  		wcstombs_s<span>(</span><span>&amp;</span>count<span>,</span> buf<span>,</span> table_entry<span>-&gt;</span>FullDllName<span>.</span>Buffer<span>,</span> table_entry<span>-&gt;</span>FullDllName<span>.</span>Length<span>);</span>
</span></span><span><span>
</span></span><span><span>        <span>// this is just from my hash tool; +20 skips past C:\Windows\System32
</span></span></span><span><span><span></span>  		<span>auto</span> h <span>=</span> ac_mod64<span>(</span>buf <span>+</span> <span>20</span><span>);</span>
</span></span><span><span>  		<span>if</span> <span>(</span>h <span>==</span> hash<span>)</span>
</span></span><span><span>  		<span>{</span>
</span></span><span><span>            <span>return</span> table_entry<span>-&gt;</span>DllBase<span>;</span>
</span></span><span><span>  			<span>break</span><span>;</span>
</span></span><span><span>  		<span>}</span>
</span></span><span><span>
</span></span><span><span>  		entry <span>=</span> entry<span>-&gt;</span>Flink<span>;</span>
</span></span><span><span>  	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>nullptr</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span></code></pre></div><h2 id="how-can-we-figure-out-what-these-hashes-are">How can we figure out what these hashes are?</h2>
<p>The answer is super simple; I grabbed a list of all the loaded modules in my game process and copied over the game’s hashing function (note: dll names are hashed a little bit differently), which can be seen here.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// this is used for dll names
</span></span></span><span><span><span></span>size_t <span>ac_mod64</span><span>(</span><span>const</span> <span>char</span><span>*</span> str<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>auto</span> base <span>=</span> ac_getbase<span>();</span>
</span></span><span><span>	<span>while</span> <span>(</span><span>*</span>str<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>auto</span> v203 <span>=</span> <span>*</span>str<span>++</span><span>;</span>
</span></span><span><span>		<span>auto</span> v39 <span>=</span> v203<span>;</span>
</span></span><span><span>
</span></span><span><span>		<span>if</span> <span>(</span>v203 <span>&gt;=</span> <span>0x41u</span> <span>&amp;&amp;</span> v39 <span>&lt;=</span> <span>0x5Au</span><span>)</span>
</span></span><span><span>			v39 <span>+=</span> <span>32</span><span>;</span>
</span></span><span><span>		base <span>=</span> <span>0x100000001B3</span>i64 <span>*</span> <span>(((</span>v39 <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>&gt;&gt;</span> <span>8</span><span>)</span> <span>^</span> <span>(</span><span>0x100000001B3</span>i64 <span>*</span> <span>(</span><span>static_cast</span><span>&lt;</span><span>unsigned</span> <span>__int8</span><span>&gt;</span><span>(</span>v39<span>)</span> <span>^</span>
</span></span><span><span>			base<span>)));</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> base<span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// this is used for exported function names
</span></span></span><span><span><span></span>size_t <span>ac_fnv64</span><span>(</span><span>const</span> <span>char</span><span>*</span> str<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>auto</span> base <span>=</span> ac_getbase<span>();</span>
</span></span><span><span>    <span>while</span> <span>(</span><span>*</span>str<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>auto</span> s <span>=</span> <span>*</span>str<span>++</span><span>;</span>
</span></span><span><span>        <span>auto</span> v12 <span>=</span> s<span>;</span>
</span></span><span><span>        <span>if</span> <span>(</span>s <span>&gt;=</span> <span>65</span> <span>&amp;&amp;</span> v12 <span>&lt;=</span> <span>90</span><span>)</span>
</span></span><span><span>            v12 <span>+=</span> <span>32</span><span>;</span>
</span></span><span><span>
</span></span><span><span>        base <span>=</span> ac_prime <span>*</span> <span>(</span>v12 <span>^</span> base<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> base<span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>I took that function and calculated the hash of all the module names and exports from the module list that I grabbed, then created a function to look up these API names by using the FNV hash base and the inlined hash of the API name.</p>
<p>Here’s how I managed to cache and resolve all of the exports.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>cache_exports</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>for</span> <span>(</span><span>auto</span> <span>dll</span> <span>:</span> loadedDlls<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        HMODULE mod <span>=</span> GetModuleHandleA<span>(</span>dll<span>.</span>c_str<span>());</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>!</span>mod<span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>continue</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        IMAGE_DOS_HEADER<span>*</span> mz <span>=</span> <span>(</span>PIMAGE_DOS_HEADER<span>)</span>mod<span>;</span>
</span></span><span><span>        IMAGE_NT_HEADERS<span>*</span> nt <span>=</span> RVA2PTR<span>(</span>PIMAGE_NT_HEADERS<span>,</span> mz<span>,</span> mz<span>-&gt;</span>e_lfanew<span>);</span>
</span></span><span><span>
</span></span><span><span>        IMAGE_DATA_DIRECTORY<span>*</span> edirp <span>=</span> <span>&amp;</span>nt<span>-&gt;</span>OptionalHeader<span>.</span>DataDirectory<span>[</span>IMAGE_DIRECTORY_ENTRY_EXPORT<span>];</span>
</span></span><span><span>        IMAGE_DATA_DIRECTORY edir <span>=</span> <span>*</span>edirp<span>;</span>
</span></span><span><span>
</span></span><span><span>        IMAGE_EXPORT_DIRECTORY<span>*</span> exports <span>=</span> RVA2PTR<span>(</span>PIMAGE_EXPORT_DIRECTORY<span>,</span> mz<span>,</span> edir<span>.</span>VirtualAddress<span>);</span>
</span></span><span><span>
</span></span><span><span>        DWORD<span>*</span> addrs <span>=</span> RVA2PTR<span>(</span>DWORD<span>*</span><span>,</span> mz<span>,</span> exports<span>-&gt;</span>AddressOfFunctions<span>);</span>
</span></span><span><span>        DWORD<span>*</span> names <span>=</span> RVA2PTR<span>(</span>DWORD<span>*</span><span>,</span> mz<span>,</span> exports<span>-&gt;</span>AddressOfNames<span>);</span>
</span></span><span><span>        <span>for</span> <span>(</span><span>unsigned</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> exports<span>-&gt;</span>NumberOfFunctions<span>;</span> i<span>++</span><span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>char</span><span>*</span> name <span>=</span> RVA2PTR<span>(</span><span>char</span><span>*</span><span>,</span> mz<span>,</span> names<span>[</span>i<span>]);</span>
</span></span><span><span>            <span>void</span><span>*</span> addr <span>=</span> RVA2PTR<span>(</span><span>void</span><span>*</span><span>,</span> mz<span>,</span> addrs<span>[</span>i<span>]);</span>
</span></span><span><span>
</span></span><span><span>            MEMORY_BASIC_INFORMATION mbi<span>;</span>
</span></span><span><span>            <span>if</span> <span>(</span>ssno<span>::</span>bypass<span>::</span>VirtualQuery<span>((</span><span>void</span><span>*</span><span>)</span>name<span>,</span> <span>&amp;</span>mbi<span>,</span> <span>sizeof</span><span>(</span>mbi<span>)))</span>
</span></span><span><span>            <span>{</span>
</span></span><span><span>                <span>if</span> <span>(</span>mbi<span>.</span>AllocationBase <span>==</span> mod<span>)</span>
</span></span><span><span>                <span>{</span>
</span></span><span><span>                    hashes<span>[</span>ac_fnv64<span>(</span>name<span>)]</span> <span>=</span> std<span>::</span>string<span>(</span>name<span>);</span>
</span></span><span><span>                <span>}</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>lookup_hash</span><span>(</span>size_t base<span>,</span> size_t hash<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	ac_setbase<span>(</span>base<span>);</span>
</span></span><span><span>
</span></span><span><span>	hashes<span>.</span>clear<span>();</span>
</span></span><span><span>	cache_exports<span>();</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>(</span>hashes<span>.</span>find<span>(</span>hash<span>)</span> <span>==</span> hashes<span>.</span>end<span>())</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		printf<span>(</span><span>&#34;Failed to find hash: 0x%p</span><span>\n</span><span>&#34;</span><span>,</span> hash<span>);</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	printf<span>(</span><span>&#34;0x%p, 0x%p = %s</span><span>\n</span><span>&#34;</span><span>,</span> base<span>,</span> hash<span>,</span> hashes<span>[</span>hash<span>].</span>c_str<span>());</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><ul>
<li>After all of this, it was time to do some manual work.
<ul>
<li>I went in by hand and grabbed the base hashes and function hashes from the decompilation then put those into my program.</li>
<li>Now I was able to tell exactly which APIs the anti-cheat was calling.</li>
</ul>
</li>
</ul>
<p>Here’s how my tool ended up working.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// (lookup_pebhash is the get_module_base function I wrote about further up)
</span></span></span><span><span><span></span>lookup_pebhash<span>(</span><span>0xB8BC6A966753F382u</span><span>,</span> <span>0x7380E62B9E1CA6D6</span><span>);</span> <span>// ntdll
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x6B9D7FEE4A7D71CEu</span>i64<span>,</span> <span>0xE5FAB4B4E649C7A4u</span>i64<span>);</span> <span>// VirtualProtect
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x1592DD0A71569429</span>i64<span>,</span> <span>0xB5902EE75629AA6Cu</span>i64<span>);</span> <span>//NtAllocateVirtualMemory
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x3E4D681B236AE0A0</span>i64<span>,</span> <span>0x3AB0D0D1450DE52D</span>i64<span>);</span> <span>//GetWindowLongA
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x77EF6ADABFA1098F</span>i64<span>,</span> <span>0x94CA321842195A88u</span>i64<span>);</span> <span>//OpenProcess
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0xA3439F4AFAAB52AEu</span>i64<span>,</span> <span>0xE48550DEAB23A8C9u</span>i64<span>);</span> <span>//K32EnumProcessModules
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x2004CA9BE823B79A</span>i64<span>,</span> <span>0x828CC84F9E74E1A0u</span>i64<span>);</span> <span>//CloseHandle
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x423E363D6FEF8CEA</span>i64<span>,</span> <span>0x5B3E9BDB215405F3</span>i64<span>);</span> <span>//K32GetModuleFileNameExW
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x52D5BB326B1FC6B2</span>i64<span>,</span> <span>0x1C2D0172D09B7286</span>i64<span>);</span> <span>//GetWindowThreadProcessId
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x13FA4A203570A0A2</span>i64<span>,</span> <span>0xB8DA7EDECE20A5DCu</span>i64<span>);</span> <span>//GetWindowDisplayAffinity
</span></span></span></code></pre></div><p><img src="https://vinayak.io/example_lookup.png" alt="image info"/></p>
<p>I do want to mention that these hashes aren’t going to be the same in different versions of the game.
Also, this isn’t the only way of beating this hashing technique; these function pointers are stored in global variables; you can simply inspect them and match the virtual address of the function to one of the exported functions from all of the DLLs loaded.</p>
<p>Ok, now we have established that TAC detects API hooking <em>(It only checks functions that it uses, not actually checking all important APIs for hooks, just the ones it’s using)</em>. These are only here to monitor API hooking attempts that would hurt or prevent the anti-cheat from doing its job.</p>
<p>What if there was a hooking method that bypassed their hooking detections?</p>
<h2 id="debug-registers">Debug Registers</h2>
<p>For actual cheaters trying to hook into the game, Arxan has got the code patching covered; cheaters must use non-code patching hooking methods while Arxan is present.
There are a couple of these hooking methods, and I’ll list a few here:</p>
<ul>
<li>Exception hooking - Forcefully triggering an exception and handling it.
<ul>
<li>Exceptions can be triggered in multiple ways.</li>
<li>Modify a global pointer to be a nullptr or invalid memory address.</li>
<li>Modify page access protections to trigger an access exception (Example: PAGE_NOACCESS or PAGE_GUARD).</li>
</ul>
</li>
<li>Debug registers - telling the CPU to break (throw a STATUS_SINGLE_STEP exception) on a specific instruction.
<ul>
<li>These are very powerful; the CPU can break on any or all of these conditions for a given instruction address.
<ul>
<li>Read</li>
<li>Write</li>
<li>Execute</li>
</ul>
</li>
<li>Debug registers are the easiest to use, the most popular, and the easiest to detect!</li>
</ul>
</li>
</ul>
<p>Since debug registers are so popular and powerful, and completely bypass Arxan’s .text patch monitoring, this makes them the perfect hooking technique for Call of Duty games.</p>
<h2 id="heres-how-tac-checks-for-debug-registers">Here’s how TAC checks for debug registers.</h2>
<div><pre tabindex="0"><code data-lang="c++"><span><span>    <span>__forceinline</span> <span>void</span> <span>ac_check_debug_registers</span><span>(</span>HANDLE thread_handle<span>,</span> fn callback<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        CONTEXT context<span>;</span>
</span></span><span><span>        context<span>.</span>ContextFlags <span>=</span> CONTEXT_FULL<span>;</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> <span>(</span><span>!</span>GetThreadContext<span>(</span>thread_handle<span>,</span> <span>&amp;</span>context<span>))</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>return</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> <span>(</span>context<span>.</span>Dr0 <span>||</span> context<span>.</span>Dr1 <span>||</span> context<span>.</span>Dr2 <span>||</span> context<span>.</span>Dr3<span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>          <span>if</span> <span>(</span>GetProcessIdOfThread<span>(</span>thread_handle<span>)</span> <span>!=</span> GetCurrentProcessId<span>())</span>
</span></span><span><span>          <span>{</span>
</span></span><span><span>            callback<span>(</span><span>&#34;debug registers found, but not in our process&#34;</span><span>);</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>          <span>else</span>
</span></span><span><span>          <span>{</span>
</span></span><span><span>            callback<span>(</span><span>&#34;debug registers found inside current process&#34;</span><span>);</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>// the anti-cheat would then jump to the quit functions that I wrote about a little bit further down
</span></span></span><span><span><span></span>          <span>// default will call ac_terminate_process_clear_registers
</span></span></span><span><span><span></span>          <span>// if ZwTerminateProcess was hooked it will jump to ac_close_game2_crash_zeroxzero
</span></span></span><span><span><span></span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// access rights that are requested
</span></span></span><span><span><span></span>    <span>__forceinline</span> HANDLE <span>ac_open_thread</span><span>(</span><span>int</span> pid<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>      <span>return</span> OpenThread<span>(</span>THREAD_QUERY_INFORMATION <span>|</span> THREAD_GET_CONTEXT<span>,</span> <span>0</span><span>,</span> pid<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span></code></pre></div><ul>
<li>Since debug registers are in the DR0-DR3 registers, you can’t just write some custom assembly to directly read them because these registers are privileged and must be fetched by the Windows kernel or sent to the process by Windows whenever an exception occurs.</li>
</ul>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; This will throw a STATUS_PRIVILEGED_INSTRUCTION exception
</span></span></span><span><span><span></span><span>mov</span> <span>rax</span><span>,</span> <span>dr0</span>
</span></span><span><span><span>ret</span>
</span></span></code></pre></div><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="driver-signing-enforcement">Driver Signing Enforcement</h2>
<ul>
<li>Windows has a test mode, which is designed for driver development.</li>
<li>This will allow you to bypass the normal Windows restriction on kernel-mode drivers not having valid digital signatures.</li>
<li><em>This is a protection mechanism in place to prevent bad actors from running kernel mode drivers on your system without the proper authorization.</em></li>
<li>TAC will know if you have test mode enabled on Windows, via <strong><em>ntdll!NtQuerySystemInformation</em></strong>. This isn’t going to ban you directly, but this will have your account flagged.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>bool</span> <span>is_test_signing_on</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	SYSTEM_CODEINTEGRITY_INFORMATION sys_cii<span>;</span>
</span></span><span><span>	sys_cii<span>.</span>Length <span>=</span> <span>sizeof</span><span>(</span>sys_cii<span>);</span>
</span></span><span><span>	NTSTATUS status <span>=</span> NtQuerySystemInformation<span>(</span><span>103</span><span>,</span> <span>&amp;</span>sys_cii<span>,</span> <span>static_cast</span><span>&lt;</span>ULONG<span>&gt;</span><span>(</span><span>sizeof</span><span>(</span>sys_cii<span>)),</span> <span>static_cast</span><span>&lt;</span>PULONG<span>&gt;</span><span>(</span><span>NULL</span><span>));</span>
</span></span><span><span>	<span>if</span> <span>(</span>NT_SUCCESS<span>(</span>status<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span> <span>!!</span><span>(</span>sys_cii<span>.</span>CodeIntegrityOptions <span>&amp;</span> <span>/*CODEINTEGRITY_OPTION_TESTSIGN*/</span> <span>0x2</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>__forceinline</span> <span>void</span> <span>ac_check_test_signing</span><span>(</span>callback cb<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>if</span> <span>(</span>is_test_signing_on<span>())</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    cb<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now we understand some of TAC’s anti-static analysis and debug register detection tactics. We’re going to move on to the more advanced detections implemented into TAC.</p>
<h2 id="how-does-tac-exit-the-process">How does TAC exit the process?</h2>
<ul>
<li>TAC uses two ways of exiting the process; both of them clear the registers, and these are written in inline shellcode.
<ul>
<li>
<p>The first method sets RCX to -1 as it calls NtTerminateProcess.</p>
</li>
<li>
<p>TAC will not use this method if NtTerminateProcess is detected to be hooked.</p>
</li>
<li>
<p>If NtTerminateProcess is hooked, it’ll go to the second one, which jumps to 0x0.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>xor</span>         <span>rax</span><span>,</span> <span>rax</span>  
</span></span><span><span><span>xor</span>         <span>rbx</span><span>,</span> <span>rbx</span>  
</span></span><span><span><span>xor</span>         <span>rcx</span><span>,</span> <span>rcx</span>  
</span></span><span><span><span>dec</span>         <span>rcx</span>  
</span></span><span><span><span>xor</span>         <span>rdx</span><span>,</span> <span>rdx</span>  
</span></span><span><span><span>xor</span>         <span>rsi</span><span>,</span> <span>rsi</span>  
</span></span><span><span><span>xor</span>         <span>rdi</span><span>,</span> <span>rdi</span>  
</span></span><span><span><span>xor</span>         <span>r8</span><span>,</span> <span>r8</span>  
</span></span><span><span><span>xor</span>         <span>r9</span><span>,</span> <span>r9</span>  
</span></span><span><span><span>xor</span>         <span>r10</span><span>,</span> <span>r10</span>  
</span></span><span><span><span>xor</span>         <span>r11</span><span>,</span> <span>r11</span>  
</span></span><span><span><span>xor</span>         <span>r12</span><span>,</span> <span>r12</span>  
</span></span><span><span><span>xor</span>         <span>r13</span><span>,</span> <span>r13</span>  
</span></span><span><span><span>xor</span>         <span>r14</span><span>,</span> <span>r14</span>  
</span></span><span><span><span>xor</span>         <span>r15</span><span>,</span> <span>r15</span>  
</span></span><span><span><span>mov</span>         <span>rsp</span><span>,</span> <span>0x0F8</span>  
</span></span><span><span><span>jmp</span>         <span>qword</span> <span>ptr</span> <span>[</span><span>0x1B607DC7FF0</span><span>]</span>  
</span></span><span><span>
</span></span><span><span><span>; This is not a custom syscall setup; this is a jump to ntdll!NtTerminateProcess.
</span></span></span><span><span><span></span><span>spot_1B607DC7FF0:</span>
</span></span><span><span><span>mov</span>         <span>r10</span><span>,</span> <span>rcx</span>  
</span></span><span><span><span>mov</span>         <span>eax</span><span>,</span> <span>0x2C</span>  
</span></span><span><span><span>test</span>        <span>byte</span> <span>ptr</span> <span>[</span><span>0x7FFE0308</span><span>],</span> <span>1</span>  
</span></span><span><span><span>jne</span>         <span>NtTerminateProcess</span> <span>+</span> <span>0x15</span> <span>(</span><span>0x07FFA7A3CDA75</span><span>)</span>  
</span></span><span><span><span>syscall</span>  
</span></span><span><span><span>ret</span>  
</span></span></code></pre></div><p>Here’s the second method; we can see the same register clearing, and we see a jmp. This jump goes to 0x0, which will crash the process.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>xor</span>         <span>rax</span><span>,</span> <span>rax</span>  
</span></span><span><span><span>xor</span>         <span>rbx</span><span>,</span> <span>rbx</span>  
</span></span><span><span><span>xor</span>         <span>rcx</span><span>,</span> <span>rcx</span>  
</span></span><span><span><span>xor</span>         <span>rdx</span><span>,</span> <span>rdx</span>  
</span></span><span><span><span>xor</span>         <span>rsi</span><span>,</span> <span>rsi</span>  
</span></span><span><span><span>xor</span>         <span>rdi</span><span>,</span> <span>rdi</span>  
</span></span><span><span><span>xor</span>         <span>r8</span><span>,</span> <span>r8</span>  
</span></span><span><span><span>xor</span>         <span>r9</span><span>,</span> <span>r9</span>  
</span></span><span><span><span>xor</span>         <span>r10</span><span>,</span> <span>r10</span>  
</span></span><span><span><span>xor</span>         <span>r11</span><span>,</span> <span>r11</span>  
</span></span><span><span><span>xor</span>         <span>r12</span><span>,</span> <span>r12</span>  
</span></span><span><span><span>xor</span>         <span>r13</span><span>,</span> <span>r13</span>  
</span></span><span><span><span>xor</span>         <span>r14</span><span>,</span> <span>r14</span>  
</span></span><span><span><span>xor</span>         <span>r15</span><span>,</span> <span>r15</span>  
</span></span><span><span><span>xor</span>         <span>rsp</span><span>,</span> <span>rsp</span>  
</span></span><span><span><span>xor</span>         <span>rbp</span><span>,</span> <span>rbp</span>  
</span></span><span><span><span>jmp</span>         <span>qword</span> <span>ptr</span> <span>[</span><span>0x27E45550036</span><span>]</span> 
</span></span><span><span>
</span></span><span><span><span>; value of 0x27E45550036 = 0x000000000000
</span></span></span></code></pre></div><p>These are hard to recover from since all of the important registers are cleared.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// these are reconstructed to make it readable
</span></span></span><span><span><span></span><span>void</span> <span>ac_terminate_process_clear_registers</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>const</span> <span>auto</span> memory <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>VirtualAlloc<span>(</span>
</span></span><span><span>      <span>nullptr</span><span>,</span> 
</span></span><span><span>      <span>0x8000uLL</span><span>,</span> 
</span></span><span><span>      MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> 
</span></span><span><span>      PAGE_EXECUTE_READWRITE
</span></span><span><span>    <span>));</span>
</span></span><span><span>
</span></span><span><span>	<span>const</span> <span>auto</span> proc_addr <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>GetProcAddress<span>(</span>
</span></span><span><span>      LoadLibraryA<span>(</span><span>&#34;ntdll.dll&#34;</span><span>),</span> 
</span></span><span><span>      <span>&#34;ZwTerminateProcess&#34;</span>
</span></span><span><span>    <span>));</span>
</span></span><span><span>
</span></span><span><span>	<span>unsigned</span> <span>char</span> terminate_process_shellcode<span>[]</span> <span>=</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor rax, rax
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor rbx, rbx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor rcx, rcx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0xFF</span><span>,</span> <span>0xC9</span><span>,</span> <span>// dec rcx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor rdx, rdx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor rsi, rsi
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor rdi, rdi
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor r8, r8
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor r9, r9
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor r10, r10
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor r11, r11
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xE4</span><span>,</span> <span>// xor r12, r12
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xED</span><span>,</span> <span>// xor r13, r13
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor r14, r14
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor r15, r15
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0xC7</span><span>,</span> <span>0xC4</span><span>,</span> <span>0xF8</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>// mov rsp, 0x0F8
</span></span></span><span><span><span></span>		<span>0xFF</span><span>,</span> <span>0x25</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span>  <span>// jmp QWORD PTR [rip + 0x0]
</span></span></span><span><span><span></span>	<span>};</span>
</span></span><span><span>
</span></span><span><span>	<span>const</span> <span>auto</span> zw_terminate_process_spot <span>=</span> <span>0x320</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>// write the address of ZwTerminateProcess somewhere
</span></span></span><span><span><span></span>	<span>*</span><span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>*&gt;</span><span>(</span>memory <span>+</span> zw_terminate_process_spot<span>)</span> <span>=</span> proc_addr<span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>// calculate the memory offset of where ZwTerminateProcess was written (needs to be   RVA from RIP)
</span></span></span><span><span><span></span>	<span>const</span> <span>auto</span> rva_addy <span>=</span> zw_terminate_process_spot <span>-</span> <span>sizeof</span><span>(</span>terminate_process_shellcode<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>*</span><span>reinterpret_cast</span><span>&lt;</span>DWORD<span>*&gt;</span><span>(</span><span>&amp;</span>terminate_process_shellcode<span>[</span><span>sizeof</span> <span>(</span>terminate_process_shellcode<span>)</span> <span>-</span> <span>4</span><span>])</span> <span>=</span> rva_addy<span>;</span>
</span></span><span><span>	memcpy<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>memory<span>),</span> terminate_process_shellcode<span>,</span> <span>sizeof</span> <span>(</span>terminate_process_shellcode<span>));</span>
</span></span><span><span>	<span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>(</span><span>*</span><span>)()</span><span>&gt;</span><span>(</span>memory<span>)();</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>void</span> <span>ac_close_game2_crash_zeroxzero</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  	<span>const</span> <span>auto</span> memory <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>&gt;</span><span>(</span>VirtualAlloc<span>(</span>
</span></span><span><span>      <span>nullptr</span><span>,</span> 
</span></span><span><span>      <span>0x40uLL</span><span>,</span> 
</span></span><span><span>      MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> 
</span></span><span><span>      PAGE_EXECUTE_READWRITE
</span></span><span><span>    <span>));</span>
</span></span><span><span>
</span></span><span><span>    memset<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>memory<span>),</span> <span>0</span><span>,</span> <span>0x40</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>unsigned</span> <span>char</span> zero_zero_shellcode<span>[]</span> <span>=</span> 
</span></span><span><span>    <span>{</span>
</span></span><span><span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor rax, rax
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor rbx, rbx
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor rcx, rcx
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor rdx, rdx
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor rsi, rsi
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor rdi, rdi
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor r8, r8
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor r9, r9
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor r10, r10
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor r11, r11
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xE4</span><span>,</span> <span>// xor r12, r12
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xED</span><span>,</span> <span>// xor r13, r13
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor r14, r14
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor r15, r15
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xE4</span><span>,</span> <span>// xor rsp, rsp
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xED</span><span>,</span> <span>// xor rbp, rbp
</span></span></span><span><span><span></span>    	<span>0xFF</span><span>,</span> <span>0x25</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span> <span>// jmp  qword ptr[rip + 0]
</span></span></span><span><span><span></span>    <span>};</span>
</span></span><span><span>
</span></span><span><span>    <span>// this offset will just be to memory thats already 0x00000000
</span></span></span><span><span><span></span>    <span>*</span><span>reinterpret_cast</span><span>&lt;</span>DWORD<span>*&gt;</span><span>(</span><span>&amp;</span>zero_zero_shellcode<span>[</span><span>sizeof</span><span>(</span>zero_zero_shellcode<span>)</span> <span>-</span> <span>4</span><span>])</span> <span>=</span> <span>4</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    memcpy<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>memory<span>),</span> zero_zero_shellcode<span>,</span> <span>sizeof</span> <span>(</span>zero_zero_shellcode<span>));</span>
</span></span><span><span>    <span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>(</span><span>*</span><span>)()</span><span>&gt;</span><span>(</span>memory<span>)();</span>
</span></span><span><span><span>}</span> 
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="detecting-cheat-logging">Detecting Cheat Logging</h2>
<ul>
<li>Oftentimes, internal cheaters will allocate a console using <a href="https://learn.microsoft.com/en-us/windows/console/allocconsole">AllocConsole</a> to print their debug logs to, or even make their menu in it using print statements.
<ul>
<li>The PEB (Process Environment Block) contains information regarding the allocation of a console.
<ul>
<li>The PEB contains a ton of useful information regarding the process. If you want to read more about this <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">click here</a>; most of this structure is undocumented, but that’ll take you to the MSDN page.</li>
</ul>
</li>
<li>The game knows that there shouldn’t ever be a console window allocated; checking for one is super simple and will catch some people who use this method of logging. Here’s the implementation.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>void</span> <span>ac_detect_allocated_console</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>if</span> <span>(</span>GetConsoleWindow<span>()</span> <span>!=</span> <span>0</span> <span>||</span> NtCurrentPeb<span>()</span> <span>-&gt;</span>ProcessParameters<span>-&gt;</span>ConsoleHandle <span>!=</span> <span>0</span><span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    callback<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="detecting-visuals">Detecting Visuals</h2>
<ul>
<li>
<p>Cheaters need to draw on the screen if they want a working <strong>ESP</strong> or even a <strong>Menu/User Interface</strong>.</p>
<ul>
<li>How do they do this?
<ul>
<li>There are a few ways of drawing on the screen; the most common method for internal cheats is to hook whichever graphics API the game is using and draw their information in there.</li>
<li>Modern Call of Duty games are made with <strong>DirectX 12</strong>.</li>
<li>A common function to hook when wanting to draw things on <strong>DirectX</strong> is <a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present">IDXGISwapChain::Present</a>.</li>
<li>The present function is what presents the rendered game image to the user. The idea is you add your custom data to the image before it’s presented to the user, update the image then present it to the user.</li>
</ul>
</li>
<li>How is this detected?
<ul>
<li>First, we need to understand how these functions are hooked.
<ul>
<li>The <strong>DirectX</strong> functions are inside of the <strong>dxgi</strong> DLL on your computer.</li>
<li>DirectX interfaces hold vtables which will point to the functions inside of dxgi, these vtable indexes will be the same across the versions of windows.</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain">IDXGISwapChain</a> vtable holds the present function.</li>
<li>This can either be directly hooked, or pointer swapped.</li>
</ul>
</li>
<li>Detecting these hooks.
<ul>
<li>Something that can be done is to scan the DXGI present function, but TAC doesn’t currently do this.</li>
<li>TAC checks the present pointer in the vtable.</li>
<li><strong>DirectX 12</strong> introduced command queues; whenever the game is drawing something, it’s from the command queue, a list of draw commands. This is something cheaters will also need if they want to draw.
<ul>
<li>How do cheaters get this command queue?
<ul>
<li>The most common method of grabbing the game’s command queue is to hook another function from the command queue interface, <a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists">ID3D12CommandQueue::ExecuteCommandLists</a>.</li>
<li>Since this is an interface, the methods will have a <strong><em>this</em></strong> pointer passed as the first parameter; in this case, that pointer is the command queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Cool information:
<ul>
<li>Many things such as OBS Studio/Streamlabs OBS/Discords game overlay/Steams game overlay actually all do this, while Steam and Discord draw here, things like OBS studio are just here to capture the rendered image (capture the frames) and save them into your recording. This only happens if you use game capture on recording software.</li>
<li>Cheaters can ignore the game, and simply hook into Discord/steam and draw things there if they want to.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="what-about-external-cheats">What about External Cheats?</h2>
<ul>
<li>
<p>External cheats are most likely going to create an overlapped window that covers the width and height of the game window. There are a few ways to detect this; the detection methods heavily rely on Windows APIs and require more effort to implement.</p>
</li>
<li>
<p>TAC loops through all of the windows, checking their <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles">window style</a> for <strong>WS_EX_LAYERED</strong>  using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlonga">GetWindowLongA</a>; once it finds that, it then compares that window’s rect with the game rect using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowrect">GetWindowRect</a>.</p>
</li>
<li>
<p>After all of that, if the window is over the game’s rect and it is a layered window, the hwnd to that window will be cached, which will later be used for many string checks. This stores a bunch of information and uploads it to their servers.</p>
<p>Here we can see how that works.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span>GetWindowRect<span>(</span>hwnd<span>,</span> <span>&amp;</span>output_rect<span>);</span>
</span></span><span><span><span>if</span> <span>(</span>output_rect<span>.</span>right <span>&gt;=</span> game_rect_7FF61BBA2F50<span>.</span>left <span>&amp;&amp;</span>
</span></span><span><span>    output_rect<span>.</span>left <span>&lt;=</span> game_rect_7FF61BBA2F50<span>.</span>right <span>&amp;&amp;</span>
</span></span><span><span>    output_rect<span>.</span>bottom <span>&gt;=</span> game_rect_7FF61BBA2F50<span>.</span>top <span>&amp;&amp;</span>
</span></span><span><span>    output_rect<span>.</span>top <span>&lt;=</span> game_rect_7FF61BBA2F50<span>.</span>bottom<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  min_value <span>=</span> get_min_value<span>(</span>output_rect<span>.</span>left<span>,</span> game_rect_7FF61BBA2F50<span>.</span>left<span>);</span>
</span></span><span><span>  greater_value <span>=</span> get_greater_value<span>(</span>output_rect<span>.</span>right<span>,</span> game_rect_7FF61BBA2F50<span>.</span>right<span>);</span>
</span></span><span><span>  v193 <span>=</span> get_min_value<span>(</span>output_rect<span>.</span>top<span>,</span> game_rect_7FF61BBA2F50<span>.</span>top<span>);</span>
</span></span><span><span>  v195 <span>=</span> get_greater_value<span>(</span>output_rect<span>.</span>bottom<span>,</span> game_rect_7FF61BBA2F50<span>.</span>bottom<span>);</span>
</span></span><span><span>  v76 <span>=</span> <span>(</span><span>float</span><span>)((</span>v193 <span>-</span> v195<span>)</span> <span>*</span> <span>(</span>greater_value <span>-</span> min_value<span>))</span>
</span></span><span><span>      <span>/</span> <span>(</span><span>float</span><span>)((</span>game_rect_7FF61BBA2F50<span>.</span>top <span>-</span> game_rect_7FF61BBA2F50<span>.</span>bottom<span>)</span>
</span></span><span><span>              <span>*</span> <span>(</span>game_rect_7FF61BBA2F50<span>.</span>right <span>-</span> game_rect_7FF61BBA2F50<span>.</span>left<span>));</span>
</span></span><span><span>  <span>if</span> <span>(</span>v76 <span>&gt;=</span> <span>0.5</span> <span>&amp;&amp;</span> cached_window_count <span>&lt;</span> <span>8</span><span>)</span>
</span></span><span><span>    cached_windows<span>[</span>cached_window_count<span>++</span><span>]</span> <span>=</span> hwnd<span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="c++"><span><span>RECT game_rect_7FF61BBA2F50<span>;</span>
</span></span><span><span>game_rect_7FF61BBA2F50 RECT <span>&lt;</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>780</span>h<span>,</span> <span>438</span>h<span>&gt;</span><span>;</span>
</span></span></code></pre></div><ul>
<li>
<p>We can see 0x780 and 0x438, which represent 1920 by 1080, which was my screen size.
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
Okay, so we know the windows are cached. Now what?</p>
</li>
<li>
<p>The cached list is handled in another function that checks the window text and its class names.</p>
</li>
<li>
<p>TAC queries the window text using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw">GetWindowTextW</a>.</p>
</li>
<li>
<p>TAC queries the window class name using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclassnamea">GetClassNameA</a>.</p>
</li>
<li>
<p>Cheat developers can hide their overlapping windows from recording software, and screenshot tools using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowdisplayaffinity">SetWindowDisplayAffinity</a> with <strong>WDA_EXCLUDEFROMCAPTURE</strong>.</p>
<ul>
<li>This is checked by TAC, and it’s saved into the buffer that will be uploaded to their servers later.
<div><pre tabindex="0"><code data-lang="c++"><span><span>ac_fmt_sprint<span>(</span>v1035<span>,</span> <span>32LL</span><span>,</span> <span>&#34;%lu&#34;</span><span>,</span> display_affinity<span>);</span>
</span></span></code></pre></div></li>
<li>There are a couple more things related to the window that are uploaded as well.
<ul>
<li>The normal window style is also checked; you can find more <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles">here</a>.</li>
<li>TAC checks that the window is visible first before any more processing happens on it.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TAC also stores the list of modules, including the exe name of the overlapping window.</p>
<ul>
<li>When you do anything in Windows to another process, you need to have permission; Windows has an API that will let you request permission from the system. <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a>
<div><pre tabindex="0"><code data-lang="c++"><span><span>HANDLE process_handle <span>=</span> OpenProcess<span>(</span><span>0x410</span><span>,</span> <span>0LL</span><span>,</span> pid<span>);</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>The first parameter in OpenProcess is the access desired, since this is a bitmask our reversing software will just show us 0x410 by default, but that doesn’t do us any good!</p>
<ul>
<li>This can be figured out with some IDA magic.</li>
<li>Creating a <a href="https://docs.hex-rays.com/user-guide/disassembler/bitfields/bitfields-tutorial">bitmask structure</a> in IDA Pro and setting that as the function declaration’s first parameter helps us out.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// these are taken from https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights
</span></span></span><span><span><span></span><span>enum</span> <span>__bitmask</span> process_access_flags
</span></span><span><span><span>{</span>
</span></span><span><span>  PROCESS_TERMINATE <span>=</span> <span>0x1</span><span>,</span>
</span></span><span><span>  PROCESS_CREATE_THREAD <span>=</span> <span>0x2</span><span>,</span>
</span></span><span><span>  PROCESS_SET_SESSIONID <span>=</span> <span>0x4</span><span>,</span>
</span></span><span><span>  PROCESS_VM_OPERATION <span>=</span> <span>0x8</span><span>,</span>
</span></span><span><span>  PROCESS_VM_READ <span>=</span> <span>0x10</span><span>,</span>
</span></span><span><span>  PROCESS_VM_WRITE <span>=</span> <span>0x20</span><span>,</span>
</span></span><span><span>  PROCESS_DUP_HANDLE <span>=</span> <span>0x40</span><span>,</span>
</span></span><span><span>  PROCESS_CREATE_PROCESS <span>=</span> <span>0x80</span><span>,</span>
</span></span><span><span>  PROCESS_SET_QUOTA <span>=</span> <span>0x100</span><span>,</span>
</span></span><span><span>  PROCESS_SET_INFORMATION <span>=</span> <span>0x200</span><span>,</span>
</span></span><span><span>  PROCESS_QUERY_INFORMATION <span>=</span> <span>0x400</span><span>,</span>
</span></span><span><span>  PROCESS_SUSPEND_RESUME <span>=</span> <span>0x800</span><span>,</span>
</span></span><span><span>  PROCESS_QUERY_LIMITED_INFORMATION <span>=</span> <span>0x1000</span><span>,</span>
</span></span><span><span>  PROCESS_SET_LIMITED_INFORMATION <span>=</span> <span>0x2000</span><span>,</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div></li>
<li>Here’s the resulting code we get from IDA.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span>HANDLE handle <span>=</span> OpenProcess<span>(</span>PROCESS_VM_READ <span>|</span> PROCESS_QUERY_INFORMATION<span>,</span> <span>0LL</span><span>,</span> pid<span>);</span>
</span></span></code></pre></div><ul>
<li>As you can see, TAC wants to read the overlapping process’ virtual memory, and it wants to query information about the process.</li>
<li>This is the access level you would expect for enumerating process modules. <a href="https://learn.microsoft.com/en-us/windows/win32/psapi/enumerating-all-processes">example</a>.</li>
</ul>
<ul>
<li>The first thing TAC does with this handle is call <a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules">K32EnumProcessModules</a>.</li>
<li>After that, TAC loops through the process modules and gathers the name of each using <a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa">K32GetModuleFileNameExW</a>.</li>
<li>Then the strings are encrypted and stored into the encryption buffer.</li>
</ul>
</li>
<li>
<p>Here’s what the majority of the code looks like.</p>
</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>ac_cached_window</span><span>(</span>HWND hwnd<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>if</span> <span>(</span>hwnd <span>==</span> game_hwnd<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	<span>const</span> <span>auto</span> is_visible <span>=</span> <span>(</span>GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_STYLE<span>)</span> <span>&amp;</span> WS_VISIBLE<span>)</span> <span>!=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>if</span> <span>(</span><span>!</span>is_visible<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	<span>const</span> <span>auto</span> window_style <span>=</span> GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_EXSTYLE<span>);</span>
</span></span><span><span>	<span>const</span> <span>auto</span> is_top_most <span>=</span> <span>(</span>window_style <span>&amp;</span> WS_EX_TOPMOST<span>)</span> <span>!=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>const</span> <span>auto</span> is_layered_window <span>=</span> <span>(</span>window_style <span>&amp;</span> WS_EX_LAYERED<span>)</span> <span>!=</span> <span>0</span><span>;</span> 
</span></span><span><span>	<span>if</span> <span>(</span><span>!</span>is_top_most <span>&amp;&amp;</span> <span>!</span>is_layered_window<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	RECT output_rect<span>;</span>
</span></span><span><span>	GetWindowRect<span>(</span>hwnd<span>,</span> <span>&amp;</span>output_rect<span>);</span>  
</span></span><span><span>	<span>if</span> <span>(</span>output_rect<span>.</span>right <span>&gt;=</span> game_rect<span>.</span>left
</span></span><span><span>	  <span>&amp;&amp;</span> output_rect<span>.</span>left <span>&lt;=</span> game_rect<span>.</span>right
</span></span><span><span>	  <span>&amp;&amp;</span> output_rect<span>.</span>bottom <span>&gt;=</span> game_rect<span>.</span>top
</span></span><span><span>	  <span>&amp;&amp;</span> output_rect<span>.</span>top <span>&lt;=</span> game_rect<span>.</span>bottom<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> min_value_x1 <span>=</span> min<span>(</span>output_rect<span>.</span>left<span>,</span> game_rect<span>.</span>left<span>);</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> max_value_x2 <span>=</span> max<span>(</span>output_rect<span>.</span>right<span>,</span> game_rect<span>.</span>right<span>);</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> min_value_y1 <span>=</span> min<span>(</span>output_rect<span>.</span>top<span>,</span> game_rect<span>.</span>top<span>);</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> max_value_y2 <span>=</span> max<span>(</span>output_rect<span>.</span>bottom<span>,</span> game_rect<span>.</span>bottom<span>);</span>  
</span></span><span><span>	    <span>const</span> <span>auto</span> difference_center <span>=</span> 
</span></span><span><span>	      <span>static_cast</span><span>&lt;</span><span>float</span><span>&gt;</span><span>((</span>min_value_y1 <span>-</span> max_value_y2<span>)</span> <span>*</span> <span>(</span>max_value_x2 <span>-</span> min_value_x1<span>))</span>
</span></span><span><span>	      <span>/</span> <span>static_cast</span><span>&lt;</span><span>float</span><span>&gt;</span><span>((</span>game_rect<span>.</span>top <span>-</span> game_rect<span>.</span>bottom<span>)</span>
</span></span><span><span>	            <span>*</span> <span>(</span>game_rect<span>.</span>right <span>-</span> game_rect<span>.</span>left<span>));</span>  
</span></span><span><span>		<span>if</span> <span>(</span>difference_center <span>&gt;=</span> <span>0.5</span> <span>&amp;&amp;</span> cached_window_count <span>&lt;</span> <span>8</span><span>)</span>
</span></span><span><span>		<span>{</span>    
</span></span><span><span>			cached_windows<span>[</span>cached_window_count<span>++</span><span>]</span> <span>=</span> hwnd<span>;</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span> 
</span></span><span><span><span>void</span> <span>ac_log_cached_window_process</span><span>(</span><span>unsigned</span> <span>int</span> pid<span>,</span> <span>char</span><span>*</span> encrypted_string_buffer<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>const</span> HANDLE process_handle <span>=</span> OpenProcess<span>(</span>PROCESS_VM_READ <span>|</span> PROCESS_QUERY_INFORMATION<span>,</span> <span>0LL</span><span>,</span> pid<span>);</span>
</span></span><span><span>	<span>if</span> <span>(</span>process_handle <span>==</span> INVALID_HANDLE_VALUE<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	DWORD lpcbNeeded <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	HMODULE modules<span>[</span><span>1024</span><span>];</span>
</span></span><span><span>	<span>if</span> <span>(</span>K32EnumProcessModules<span>(</span>process_handle<span>,</span> modules<span>,</span> <span>0x2000LL</span><span>,</span> <span>&amp;</span>lpcbNeeded<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>for</span> <span>(</span><span>auto</span> current_module_index <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>current_module_index<span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>if</span> <span>(</span>current_module_index <span>&gt;=</span> lpcbNeeded <span>/</span> <span>8uLL</span><span>)</span>
</span></span><span><span>				<span>break</span><span>;</span>  
</span></span><span><span>			<span>const</span> <span>auto</span> current_module <span>=</span> modules<span>[</span>current_module_index<span>];</span>
</span></span><span><span>			WCHAR wide_module_name<span>[</span><span>260</span><span>];</span>  
</span></span><span><span>			<span>if</span> <span>(</span>K32GetModuleFileNameExW<span>(</span>process_handle<span>,</span> current_module<span>,</span> wide_module_name<span>,</span> <span>260LL</span><span>))</span>
</span></span><span><span>			<span>{</span>
</span></span><span><span>				<span>char</span> ascii_module_name<span>[</span><span>1568</span><span>];</span>
</span></span><span><span>				WideCharToMultiByte<span>(</span><span>65001LL</span><span>,</span> <span>0LL</span><span>,</span> wide_module_name<span>,</span> <span>0xFFFFFFFFLL</span><span>,</span> ascii_module_name<span>,</span> <span>1560</span><span>,</span> <span>0LL</span><span>,</span> <span>0LL</span><span>);</span> 
</span></span><span><span>				ac_string_encrypt<span>(</span>encrypted_string_buffer<span>,</span> ascii_module_name<span>);</span>
</span></span><span><span>			<span>}</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	CloseHandle<span>(</span>process_handle<span>);</span>
</span></span><span><span><span>}</span> 
</span></span><span><span><span>void</span> <span>ac_handle_window</span><span>(</span>HWND hwnd<span>,</span> <span>char</span><span>*</span> encrypted_string_thing<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// tons of string encryption stuff all over here  
</span></span></span><span><span><span></span>	<span>wchar_t</span> window_text_WIDE<span>[</span><span>512</span><span>]{</span><span>0</span><span>};</span>
</span></span><span><span>	GetWindowTextW<span>(</span>hwnd<span>,</span> window_text_WIDE<span>,</span> <span>512LL</span><span>);</span>  
</span></span><span><span>	<span>char</span> window_text_asci<span>[</span><span>3072</span><span>]{</span><span>0</span><span>};</span>
</span></span><span><span>	WideCharToMultiByte<span>(</span><span>65001LL</span><span>,</span> <span>0LL</span><span>,</span> window_text_WIDE<span>,</span> <span>0xFFFFFFFFLL</span><span>,</span> window_text_asci<span>,</span> <span>3072</span><span>,</span> <span>0LL</span><span>);</span> 
</span></span><span><span>	<span>char</span> window_class_name<span>[</span><span>256</span><span>]{</span><span>0</span><span>};</span>
</span></span><span><span>	GetClassNameA<span>(</span>hwnd<span>,</span> window_class_name<span>,</span> <span>256LL</span><span>);</span>  
</span></span><span><span>	RECT window_rect<span>;</span>
</span></span><span><span>	GetWindowRect<span>(</span>hwnd<span>,</span> <span>&amp;</span>window_rect<span>);</span>  
</span></span><span><span>	<span>const</span> <span>auto</span> window_gwl_style <span>=</span> GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_STYLE<span>);</span>
</span></span><span><span>	<span>const</span> <span>auto</span> window_gwl_ex_style <span>=</span> GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_EXSTYLE<span>);</span> 
</span></span><span><span>	DWORD display_affinity <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	GetWindowDisplayAffinity<span>(</span>hwnd<span>,</span> <span>&amp;</span>display_affinity<span>);</span>  
</span></span><span><span>	<span>// adds these strings to the buffer directly
</span></span></span><span><span><span></span>	ac_string_encrypt<span>(</span>encrypted_string_thing<span>,</span> window_text_asci<span>);</span>
</span></span><span><span>	ac_string_encrypt<span>(</span>encrypted_string_thing<span>,</span> window_class_name<span>);</span> 
</span></span><span><span>	<span>// store info
</span></span></span><span><span><span></span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>left<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>top<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>right<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>bottom<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_gwl_style<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_gwl_ex_style<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%lu&#34;</span><span>,</span> display_affinity<span>);</span> 
</span></span><span><span>	DWORD pid <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>if</span> <span>(</span>GetWindowThreadProcessId<span>(</span>hwnd<span>,</span> <span>&amp;</span>pid<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		ac_log_cached_window_process<span>(</span>pid<span>,</span> encrypted_string_thing<span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>else</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// assuming encrypted failure message, logs the current process id instead.
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span><span>}</span> 
</span></span><span><span><span>void</span> <span>ac_process_cached_windows</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// lots of encryption stuff here
</span></span></span><span><span><span></span>	<span>char</span><span>*</span> encrypted_string_thing <span>=</span> <span>(</span><span>char</span><span>*</span><span>)</span>malloc<span>(</span><span>0x40000</span><span>);</span>
</span></span><span><span>	<span>for</span> <span>(</span><span>unsigned</span> <span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cached_window_count<span>;</span> <span>++</span>i<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// lots of encryption stuff here, and ptr modifications
</span></span></span><span><span><span></span>		ac_handle_window<span>(</span>cached_windows<span>[</span>i<span>],</span> encrypted_string_thing<span>);</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	<span>// lots of encryption stuff here, and ptr modifications
</span></span></span><span><span><span></span>	ac_send_data_to_server<span>(</span>encrypted_string_thing<span>);</span>
</span></span><span><span>	free<span>(</span>encrypted_string_thing<span>);</span>
</span></span><span><span>	<span>// lots of encryption stuff here
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div></li>
</ul>
<ul>
<li>Example data. TAC will format in json with modules hashed.
<div><pre tabindex="0"><code data-lang="cpp"><span><span>NVIDIA GeForce Overlay <span>-</span> Window Text 
</span></span><span><span>CEF<span>-</span>OSC<span>-</span>WIDGET <span>-</span> Window Class
</span></span><span><span><span>0</span> <span>-</span> Left
</span></span><span><span><span>0</span> <span>-</span> Top
</span></span><span><span><span>2560</span> <span>-</span> Right
</span></span><span><span><span>1440</span> <span>-</span> Bottom
</span></span><span><span><span>-</span><span>1811939328</span> <span>-</span> window_gwl_style
</span></span><span><span><span>134742184</span> <span>-</span> window_gwl_ex_style
</span></span><span><span><span>0</span> <span>-</span> display_affinity  
</span></span><span><span>Loaded <span>Modules</span><span>:</span> 
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>NVIDIA Share<span>.</span>exe
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>ntdll<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>KERNEL32<span>.</span>DLL
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>KERNELBASE<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>SHLWAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>msvcrt<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>WS2_32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>urlmon<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>RPCRT4<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>CRYPT32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>ucrtbase<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>USER32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>win32u<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>iertutil<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>GDI32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>srvcli<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>combase<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>gdi32full<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>msvcp_win<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>sechost<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>netutils<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>advapi32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>SHELL32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>shcore<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>ole32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>OLEAUT32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>libcef<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>WINTRUST<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>wlanapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>COMDLG32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dxgi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>IPHLPAPI<span>.</span>DLL
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>IMM32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>UxTheme<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>CRYPTUI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>MSIMG32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>WINMM<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>d3d11<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>Secur32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>NETAPI32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>d3d9<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>bcrypt<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>OLEACC<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dwmapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>WTSAPI32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>ShadowPlay<span>\</span>nvspapi64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>ntmarta<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NvContainer<span>\</span>libprotobuf<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>MSVCP140<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>VCRUNTIME140<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>VCRUNTIME140_1<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>ShadowPlay<span>\</span>IpcCommon64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NvContainer<span>\</span>MessageBus<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>NSI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>MSCTF<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>NLAapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dhcpcsvc6<span>.</span>DLL
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>DNSAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>WINSTA<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>clbcatq<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>MMDevApi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>mscms<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>ColorAdapterClient<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>Windows<span>.</span>UI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>WindowManagementAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>TextInputFramework<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>InputHost<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>wintypes<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>twinapi<span>.</span>appcore<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>CoreMessaging<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>CoreUIComponents<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>twinapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>apphelp<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>cef<span>\</span>common<span>\</span>OverClocking<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>dependencies<span>\</span>CrimsonUtil<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>POWRPROF<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>UMPDC<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>cef<span>\</span>share<span>\</span>MessageBusRouter<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>nvapi64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>SETUPAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>FvSDK_x64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>mswsock<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>rasadhlp<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>fwpuclnt<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>xinput1_4<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dxcore<span>.</span>dll
</span></span></code></pre></div></li>
</ul>
<!-- raw HTML omitted -->

<ul>
<li>Cheat Engine is one of the easiest programs to detect, and it’s really because of how virtual memory works in Windows.</li>
<li>Whenever a program wants to allocate virtual memory, they’re going to call the Windows API <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>.
<ul>
<li>This memory is allocated, but it’s not backed by any physical memory yet because it hasn’t been accessed, this is a feature in the Windows kernel.</li>
<li>This allows the game to allocate virtual memory with that function and never use it.</li>
<li>After Cheat Engine scans the process, it will hit this virtual memory, which will then make that memory valid, because now it has been accessed by Cheat Engine.
<ul>
<li>Here’s how that detection would look, and this is for any memory scanner, not just Cheat Engine. This will also include the Process Hacker memory tab.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>run_honey_pot_violation</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>// the protection won&#39;t matter
</span></span></span><span><span><span></span>  <span>const</span> <span>auto</span> allocated_virtual_memory <span>=</span> VirtualAlloc<span>(</span><span>nullptr</span><span>,</span> <span>0x1000</span><span>,</span> MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> PAGE_READWRITE<span>);</span>
</span></span><span><span>
</span></span><span><span>  PSAPI_WORKING_SET_EX_INFORMATION working_set_information<span>;</span>
</span></span><span><span>  memset<span>(</span><span>&amp;</span>working_set_information<span>,</span> <span>0</span><span>,</span> <span>sizeof</span><span>(</span>working_set_information<span>));</span>
</span></span><span><span>
</span></span><span><span>  working_set_information<span>.</span>VirtualAddress <span>=</span> allocated_virtual_memory<span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>while</span> <span>(</span><span>true</span><span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    <span>// query about the current process
</span></span></span><span><span><span></span>    <span>const</span> <span>auto</span> did_it_work <span>=</span> K32QueryWorkingSetEx<span>((</span>HANDLE<span>)</span><span>-</span><span>1</span><span>,</span> <span>&amp;</span>working_set_information<span>,</span> <span>sizeof</span><span>(</span>working_set_information<span>));</span>
</span></span><span><span>    <span>if</span> <span>(</span>did_it_work <span>&amp;&amp;</span> <span>(</span>working_set_information<span>.</span>VirtualAttributes<span>.</span>Flags <span>&amp;</span> <span>1</span><span>)</span> <span>!=</span> <span>0</span> <span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>      printf<span>(</span><span>&#34;XD CHEAT ENGINE DETECTED HAHAHAH</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>      callback<span>();</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// just an example timer, not what the game does
</span></span></span><span><span><span></span>    Sleep<span>(</span><span>1000</span><span>);</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="anti-sig-scanning">Anti-Sig Scanning</h2>
<ul>
<li>Game hackers love signatures; whenever the game updates, no problem the cheat will automatically update.
<ul>
<li>
<p>Treyarch had a pretty interesting idea.</p>
<ul>
<li>Their idea is to create a function that’ll never be called again; this function will call another function that protects the return address with PAGE_NOACCESS. Since this will never be reached again by the program, this isn’t an issue.</li>
<li>The way sig scanners work is they attempt to match a signature by reading bytes in the executable. It’s extremely slow to query each byte you are going to be reading, which is why this is such a good method. You can read more about VirtualProtect <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">here</a>.
<ul>
<li>It’s not undefeatable, but it’s something that’s there and will probably give most a hard time.</li>
</ul>
</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>enable_anti_sig_scanning</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  DWORD old <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>const</span> <span>auto</span> cpu_stamp <span>=</span> __rdtsc<span>();</span>
</span></span><span><span>  <span>unsigned</span> <span>__int64</span> protect_location <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>_ReturnAddress<span>());</span>
</span></span><span><span>
</span></span><span><span>  <span>if</span> <span>(</span> <span>(</span>protect_location <span>&amp;</span> cpu_stamp<span>)</span> <span>+</span> <span>(</span>protect_location <span>|</span> cpu_stamp<span>)</span> <span>-</span> <span>(</span>protect_location <span>+</span> cpu_stamp<span>)</span> <span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span> <span>(</span>cpu_stamp <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>  	  protect_location <span>=</span> <span>(</span>protect_location <span>+</span> <span>5120</span><span>)</span> <span>&amp;</span> <span>0xFFFFFFFFFFFFF000uLL</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>!</span>VirtualProtect<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>protect_location<span>),</span> <span>1</span><span>,</span> PAGE_NOACCESS<span>,</span> <span>&amp;</span>old<span>)</span> <span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>      <span>// this is here just to detect someone hooking VirtualProtect and returning false on PAGE_NOACCESS
</span></span></span><span><span><span></span>      callback<span>();</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><ul>
<li>Here’s a good example of code that’ll never be reached again. (The program will never reach the top of the main function again.)</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>const</span> <span>char</span><span>**</span> argv<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  enable_anti_sig_scanning<span>();</span>
</span></span><span><span>  scan_pattern<span>(</span>GetModuleHandleA<span>(</span><span>nullptr</span><span>),</span> <span>&#34;xxsaj3&#34;</span><span>);</span> <span>// pretend this is a signature that&#39;s far into the executable
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div><ul>
<li>The scan pattern function will start at the base of the executable and continue to the end until it finds the pattern it wants, ultimately hitting the PAGE_NOACCESS memory, and crashing the process.</li>
</ul>
<p><img src="https://vinayak.io/anti_sig_scan.png" alt="image info"/></p>
</li>
</ul>
</li>
</ul>
<h2 id="anti-debugging">Anti-Debugging</h2>
<ul>
<li>
<p>TAC has a simple anti-debug check; but remember, Arxan is still running, so they still have all of those anti-debugging tricks.</p>
<ul>
<li>How does TAC prevent debugging?
<ul>
<li>TAC loops through all threads in the current process by using <a href="https://learn.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolHelpSnapshot32</a> with SnapThread passed and checks the thread for a DebugObject, which is going to be present if a debugger is running.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>ac_loop_threads_debug</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	HANDLE snapshot <span>=</span> CreateToolhelp32Snapshot<span>(</span>TH32CS_SNAPTHREAD<span>,</span> GetCurrentProcessId<span>());</span>
</span></span><span><span>
</span></span><span><span>	THREADENTRY32 te32<span>{};</span>
</span></span><span><span>	te32<span>.</span>dwSize <span>=</span> <span>sizeof</span><span>(</span>te32<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>do</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>if</span> <span>(</span>te32<span>.</span>th32OwnerProcessID <span>!=</span> GetCurrentProcessId<span>())</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>continue</span><span>;</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>const</span> HANDLE thread_handle <span>=</span> OpenThread<span>(</span>THREAD_ALL_ACCESS<span>,</span> FALSE<span>,</span> te32<span>.</span>th32ThreadID<span>);</span>
</span></span><span><span>		<span>if</span> <span>(</span>thread_handle<span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			HANDLE debug_object_handle <span>=</span> INVALID_HANDLE_VALUE<span>;</span>
</span></span><span><span>
</span></span><span><span>			ULONG ret_length <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>			THREAD_BASIC_INFORMATION thread_basic_information<span>;</span>
</span></span><span><span>
</span></span><span><span>			<span>if</span> <span>(</span><span>!</span>NtQueryInformationThread<span>(</span>thread_handle<span>,</span> <span>0</span><span>,</span> <span>&amp;</span>thread_basic_information<span>,</span> <span>sizeof</span><span>(</span>thread_basic_information<span>),</span> <span>&amp;</span>ret_length<span>))</span>
</span></span><span><span>			<span>{</span>
</span></span><span><span>              <span>if</span> <span>(</span>thread_basic_information<span>.</span>TebBaseAddress<span>)</span>
</span></span><span><span>              <span>{</span>
</span></span><span><span>                <span>if</span> <span>(</span>thread_basic_information<span>.</span>TebBaseAddress<span>-&gt;</span>DbgSsReserved<span>[</span><span>1</span><span>])</span>
</span></span><span><span>                <span>{</span>
</span></span><span><span>                  debug_object_handle <span>=</span> HANDLE<span>(</span>thread_basic_information<span>.</span>TebBaseAddress<span>-&gt;</span>DbgSsReserved<span>[</span><span>1</span><span>]);</span>
</span></span><span><span>                <span>}</span>
</span></span><span><span>              <span>}</span>
</span></span><span><span>			<span>}</span>
</span></span><span><span>
</span></span><span><span>			<span>if</span> <span>(</span>debug_object_handle <span>!=</span> INVALID_HANDLE_VALUE<span>)</span>
</span></span><span><span>			<span>{</span>
</span></span><span><span>				callback<span>();</span>
</span></span><span><span>			<span>}</span>
</span></span><span><span>
</span></span><span><span>			CloseHandle<span>(</span>thread_handle<span>);</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>while</span> <span>(</span>Thread32Next<span>(</span>snapshot<span>,</span> <span>&amp;</span>te32<span>));</span>
</span></span><span><span>	CloseHandle<span>(</span>snapshot<span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
<li>A weird anti-debug trick.
<ul>
<li>It throws an access violation by writing to invalid memory; if the code ever gets past the exception, a debugger got past it or handled the exception properly.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>ac_exception_anti_debug</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>// this is writing to invalid memory and will throw an access violation
</span></span></span><span><span><span></span>  __sidt<span>((</span><span>void</span> <span>*</span><span>)</span><span>0xFFFFFF8000000900LL</span><span>);</span>
</span></span><span><span>  callback<span>();</span> <span>// this should never be reached
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div></li>
</ul>
<ul>
<li>Standard API check
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>void</span> <span>ac_check_remote_debugger</span><span>(</span>callback cb<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  BOOL dbg <span>=</span> <span>false</span><span>;</span>
</span></span><span><span>  <span>if</span> <span>(</span>CheckRemoteDebuggerPresent<span>((</span>HANDLE<span>)</span><span>-</span><span>1</span><span>,</span> <span>&amp;</span>dbg<span>))</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    <span>if</span> <span>(</span>dbg<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>      cb<span>();</span>
</span></span><span><span>      <span>// the process will close
</span></span></span><span><span><span></span>    <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>ThreadHideFromDebugger sends exceptions to the process instead of the debugger which means
</span></span><span><span>whenever the debugger attempts to pause the process<span>,</span> a STATUS_BREAKPOINT exception will go off which will close the process<span>.</span>
</span></span><span><span>The best part about <span>this</span> is you can not unset the ThreadHideFromDebugger flag once its been set from user mode<span>,</span> <span>this</span> tactic runs in their tls callback which is before the entry point of the exe<span>.</span>
</span></span><span><span><span>```</span>c<span>++</span>
</span></span><span><span><span>__forceinline</span> <span>void</span> ac_hide_current_thread<span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>char</span> use_ThreadHideFromDebugger <span>=</span> <span>1</span><span>;</span>
</span></span><span><span>    nt_set_information_thread<span>((</span>HANDLE<span>)</span><span>-</span><span>2</span><span>,</span> ThreadHideFromDebugger<span>,</span> <span>(</span><span>void</span><span>**</span><span>)</span><span>&amp;</span>use_ThreadHideFromDebugger<span>,</span> <span>0</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="monitoring-network-traffic">Monitoring Network Traffic</h2>
<ul>
<li>This is a super cool detection method used for some cheats, and don’t be alarmed by this; they do not store any of your active connections; they are only looking for a very specific check.
<ul>
<li>A cheater can write shellcode into the game process that starts a network server inside of the game process on the local network, then the cheater can have their external application send and receive information to this local server, kind of like a local command and control center.
<ul>
<li>Here’s how it’s implemented.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// custom tac struct
</span></span></span><span><span><span></span><span>struct</span> <span>tcp_entry</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  DWORD OwningPid<span>;</span>
</span></span><span><span>  DWORD LocalAddr<span>;</span>
</span></span><span><span>  DWORD RemoteAddr<span>;</span>
</span></span><span><span>  DWORD LocalPort<span>;</span>
</span></span><span><span>  DWORD RemotePort<span>;</span>
</span></span><span><span><span>};</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>ac_detect_local_command_center</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>// WSA must be the first call before any other Windows socket functions can be called successfully 
</span></span></span><span><span><span></span>	WSAData data<span>;</span>
</span></span><span><span>	WSAStartup<span>(</span>MAKEWORD<span>(</span><span>2</span><span>,</span> <span>2</span><span>),</span> <span>&amp;</span>data<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>bool</span> successfully_looped_tcp_table <span>=</span> <span>false</span><span>;</span>
</span></span><span><span>	<span>__int64</span> tcp_table_container<span>[</span><span>3</span><span>]{};</span>
</span></span><span><span>
</span></span><span><span>    <span>// allocate the table
</span></span></span><span><span><span></span>	<span>auto</span> table <span>=</span> <span>static_cast</span><span>&lt;</span>PMIB_TCPTABLE2<span>&gt;</span><span>(</span>malloc<span>(</span><span>sizeof</span><span>(</span>MIB_TCPTABLE2<span>)));</span>
</span></span><span><span>
</span></span><span><span>    <span>// get the tcp table size, the first call is expected to fail
</span></span></span><span><span><span></span>	ULONG size<span>;</span>
</span></span><span><span>	<span>auto</span> result <span>=</span> GetTcpTable2<span>(</span>table<span>,</span> <span>&amp;</span>size<span>,</span> <span>1</span><span>);</span>
</span></span><span><span>	<span>if</span> <span>(</span>result <span>==</span> ERROR_INSUFFICIENT_BUFFER<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		free<span>(</span>table<span>);</span>
</span></span><span><span>		table <span>=</span> <span>static_cast</span><span>&lt;</span>PMIB_TCPTABLE2<span>&gt;</span><span>(</span>malloc<span>(</span>size<span>));</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// store the tcp table into our newly allocated buffer 
</span></span></span><span><span><span></span>	result <span>=</span> GetTcpTable2<span>(</span>table<span>,</span> <span>&amp;</span>size<span>,</span> <span>1</span><span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>(</span><span>!</span>result<span>)</span> <span>// it returns NO_ERROR which is 0x0 on success
</span></span></span><span><span><span></span>	<span>{</span>
</span></span><span><span>		<span>for</span> <span>(</span><span>auto</span> i64 <span>=</span> <span>0</span><span>;</span> i64 <span>&lt;</span> <span>static_cast</span><span>&lt;</span><span>signed</span> <span>int</span><span>&gt;</span><span>(</span>table<span>-&gt;</span>dwNumEntries<span>);</span> <span>++</span>i64<span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>            <span>// store each entry
</span></span></span><span><span><span></span>			PMIB_TCPROW2 tableptr <span>=</span> <span>&amp;</span>table<span>-&gt;</span>table<span>[</span>i64<span>];</span>
</span></span><span><span>			<span>if</span> <span>(</span><span>!</span><span>static_cast</span><span>&lt;</span><span>unsigned</span> <span>__int8</span><span>&gt;</span><span>(</span>add_tcp_entry<span>(</span>tableptr<span>,</span> tcp_table_container<span>)))</span>
</span></span><span><span>				<span>break</span><span>;</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		successfully_looped_tcp_table <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// memory is no longer needed
</span></span></span><span><span><span></span>	free<span>(</span>table<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>(</span>successfully_looped_tcp_table<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>        <span>// get the current process id
</span></span></span><span><span><span></span>		<span>const</span> <span>auto</span> current_process_id <span>=</span> GetCurrentProcessId<span>();</span>
</span></span><span><span>		tcp_entry<span>*</span> tcp_table<span>;</span>
</span></span><span><span>		init_tcp_table_entry<span>(</span><span>&amp;</span>tcp_table<span>);</span>
</span></span><span><span>
</span></span><span><span>		tcp_entry<span>*</span> dummy<span>;</span>
</span></span><span><span>        <span>// loop the tcp table
</span></span></span><span><span><span></span>		<span>for</span> <span>(</span>tcp_table <span>=</span> <span>*</span>get_tcp_table_entry<span>(</span>tcp_table_container<span>,</span> <span>&amp;</span>dummy<span>);;</span> increment_tcp_table_entry<span>(</span><span>&amp;</span>tcp_table<span>))</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>
</span></span><span><span>			<span>auto</span> next_tcp_entry <span>=</span> get_next_tcp_entry<span>(</span>tcp_table_container<span>,</span> <span>&amp;</span>dummy<span>);</span>
</span></span><span><span>            <span>// break if we are just comparing the same entry
</span></span></span><span><span><span></span>			<span>if</span> <span>(</span><span>!</span>tcp_entires_different<span>(</span><span>&amp;</span>tcp_table<span>,</span> next_tcp_entry<span>))</span>
</span></span><span><span>				<span>break</span><span>;</span>
</span></span><span><span>
</span></span><span><span>			<span>auto</span> tcp_ptr <span>=</span> get_tcp_ptr<span>(</span><span>&amp;</span>tcp_table<span>);</span>
</span></span><span><span>            <span>// verify the entry was created by the current process
</span></span></span><span><span><span></span>			<span>if</span> <span>(</span>tcp_ptr<span>-&gt;</span>OwningPid <span>==</span> current_process_id<span>)</span>
</span></span><span><span>			<span>{</span>
</span></span><span><span>                <span>// get the other entries
</span></span></span><span><span><span></span>				tcp_entry<span>*</span> entry2<span>;</span>
</span></span><span><span>				init_tcp_table_entry<span>(</span><span>&amp;</span>entry2<span>);</span>
</span></span><span><span>				<span>for</span> <span>(</span>entry2 <span>=</span> <span>*</span>get_tcp_table_entry<span>(</span>tcp_table_container<span>,</span> <span>&amp;</span>dummy<span>);</span> <span>;</span> increment_tcp_table_entry<span>(</span><span>&amp;</span>entry2<span>))</span>
</span></span><span><span>				<span>{</span>
</span></span><span><span>					<span>auto</span> next_entry2 <span>=</span> get_next_tcp_entry<span>(</span>tcp_table_container<span>,</span> <span>&amp;</span>dummy<span>);</span>
</span></span><span><span>                    <span>// we have relooped back to the start, break
</span></span></span><span><span><span></span>					<span>if</span> <span>(</span><span>!</span>tcp_entires_different<span>(</span><span>&amp;</span>entry2<span>,</span> next_entry2<span>))</span>
</span></span><span><span>						<span>break</span><span>;</span>
</span></span><span><span>
</span></span><span><span>					<span>auto</span> entry2_tcp_ptr <span>=</span> get_tcp_ptr<span>(</span><span>&amp;</span>entry2<span>);</span>
</span></span><span><span>                    <span>/*
</span></span></span><span><span><span>                    if the entrys port and the one found inside the current process match
</span></span></span><span><span><span>                    and they aren&#39;t owned by the same process 
</span></span></span><span><span><span>                    */</span>
</span></span><span><span>					<span>if</span> <span>(</span>entry2_tcp_ptr<span>-&gt;</span>LocalPort <span>==</span> tcp_ptr<span>-&gt;</span>RemotePort <span>&amp;&amp;</span> 
</span></span><span><span>                        entry2_tcp_ptr<span>-&gt;</span>OwningPid <span>!=</span> tcp_ptr<span>-&gt;</span>OwningPid<span>)</span>
</span></span><span><span>					<span>{</span>
</span></span><span><span>                        <span>// flagged
</span></span></span><span><span><span></span>						callback<span>();</span>
</span></span><span><span>					<span>}</span>
</span></span><span><span>				<span>}</span>
</span></span><span><span>			<span>}</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="encrypted-custom-syscalls">Encrypted Custom Syscalls</h2>
<ul>
<li>Whenever you look at exported APIs in ntdll, you’ll notice most of them do a syscall.</li>
<li>A syscall is what moves over into the kernel, where the actual implementation of the function is.</li>
<li>This is what a syscall stub looks like.</li>
<li>IMO this is the coolest feature TAC has!</li>
</ul>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; rcx is used by the kernel as a jump back location for the syscall instruction.
</span></span></span><span><span><span>; rcx needs to be stored so the kernel can use it.    
</span></span></span><span><span><span></span><span>mov</span> <span>r10</span><span>,</span> <span>rcx</span>                                                             
</span></span><span><span><span>mov</span> <span>eax</span><span>,</span> <span>0x11B</span>  <span>; eax holds the syscall index which the kernel looks up in the table of system calls                                                                                                               
</span></span></span><span><span><span></span><span>syscall</span>                                                                    
</span></span><span><span><span>ret</span>                                                                                                                                               
</span></span></code></pre></div><ul>
<li>Writing your own syscall stub has a purpose. Whenever a user-mode cheat hooks those ntdll functions that syscall, it’ll work, but their hooks can be bypassed very easily if the anti-cheat just calls the syscall instruction with eax set to the same syscall index as the normal function.</li>
<li>Syscalls are vulnerable to instrumentation callbacks; these are callbacks coded into Windows, and they will work on every single user-mode process.</li>
<li>These callbacks will catch every syscall instruction and every exception.
<ul>
<li>Just an FYI, instrumentation callbacks are called AFTER the syscall; their return address will be right after the syscall instruction.</li>
<li>This would normally allow cheaters to easily see where every syscall is coming from since all of the functions using it are just exported in ntdll.</li>
<li>It fails because the cheater will see a syscall from a random ntdll function, rather than the anti-cheat code.</li>
</ul>
</li>
</ul>
<ul>
<li>If you want to see instrumentations in action, you can do so <a href="https://github.com/Deputation/instrumentation_callbacks">here</a>.</li>
</ul>
<p><strong>Let’s take a look at TAC’s custom syscall stub.</strong>
<img src="https://vinayak.io/syscall_stub.png" alt="image info"/></p>
<ul>
<li>At a quick glance, this is very confusing and hard to figure out statically.</li>
<li>They even make it confusing to see what memory is being written to.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c"><span><span>some_random_text_encrypted_func<span>[</span><span>0</span><span>]</span> <span>=</span> <span>((</span><span>unsigned</span> <span>__int64</span><span>)</span><span>&amp;</span>loc_7FF60E12D0B0 <span>+</span> <span>4095</span><span>)</span> <span>&amp;</span> <span>0xFFFFFFFFFFFFF000uLL</span><span>;</span>
</span></span></code></pre></div><ul>
<li>It turned out to be pretty simple to figure this out and understand exactly how it works.</li>
<li>That memory being written to is actually a large chunk allocated in the .text section that they just virtual protect for write/execute rights.</li>
<li>Now we could spend all day in our XOR calculator and try to build the byte array of these XOR encrypted instructions ourselves.</li>
<li>Or we could just let the computer do it….</li>
</ul>
<p>This was pretty much just copy and paste from IDA Pro, all I did was allocate my own memory here.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>	<span>auto</span> v3867 <span>=</span> <span>12288LL</span><span>;</span>
</span></span><span><span>	<span>LABEL_1798</span><span>:</span>
</span></span><span><span>	<span>auto</span> v2168 <span>=</span> __rdtsc<span>()</span> <span>%</span> <span>(</span>v3867 <span>-</span> <span>3</span><span>);</span>
</span></span><span><span>	<span>auto</span> v1328 <span>=</span> v2168<span>;</span>
</span></span><span><span>	<span>auto</span> ac_NtReadFile_1 <span>=</span> <span>(</span><span>char</span><span>*</span><span>)</span>GetProcAddress<span>(</span>GetModuleHandleA<span>(</span><span>&#34;ntdll&#34;</span><span>),</span> <span>&#34;NtReadFile&#34;</span><span>);</span>
</span></span><span><span>	<span>__int64</span> i67 <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>for</span> <span>(</span>i67 <span>=</span> <span>0LL</span><span>;</span> <span>;</span> <span>++</span>i67<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>if</span> <span>(</span>v1328 <span>+</span> i67 <span>&gt;=</span> v3867<span>)</span>
</span></span><span><span>			<span>goto</span> LABEL_1798<span>;</span>
</span></span><span><span>		<span>if</span> <span>(</span>ac_NtReadFile_1<span>[</span>i67 <span>+</span> <span>1</span> <span>+</span> v1328<span>]</span> <span>==</span> <span>5</span>
</span></span><span><span>			<span>&amp;&amp;</span> <span>(</span><span>unsigned</span> <span>__int8</span><span>)</span>ac_NtReadFile_1<span>[</span>i67 <span>+</span> <span>2</span> <span>+</span> v1328<span>]</span> <span>==</span> <span>195</span>
</span></span><span><span>			<span>&amp;&amp;</span> ac_NtReadFile_1<span>[</span>i67 <span>+</span> v1328<span>]</span> <span>==</span> <span>15</span><span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>break</span><span>;</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>auto</span> nt_read_file_syscall_instruction <span>=</span> <span>&amp;</span>ac_NtReadFile_1<span>[</span>i67 <span>+</span> v1328<span>];</span>
</span></span><span><span>	<span>volatile</span> <span>__int64</span> syscall_stub_memory <span>=</span> <span>(</span><span>__int64</span><span>)</span>VirtualAlloc<span>(</span><span>nullptr</span><span>,</span> <span>0x4096</span><span>,</span> MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> PAGE_EXECUTE_READWRITE<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>__int64</span> syscall_index <span>=</span> <span>0</span><span>;</span> <span>// this is going to be the syscall index; it&#39;s 0 here just while I&#39;m explaining
</span></span></span><span><span><span></span>	<span>auto</span> offset_that_doesnt_matter <span>=</span> <span>0x50</span><span>;</span> <span>// it&#39;s just here to add to the confusion; this can be any number above 4
</span></span></span><span><span><span></span>
</span></span><span><span>	<span>*</span><span>(</span>_QWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>28LL</span><span>)</span> <span>=</span> <span>(</span><span>__int64</span><span>)</span>nt_read_file_syscall_instruction<span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_QWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>20LL</span><span>)</span> <span>=</span> <span>0x63B4B73DD1E509A9LL</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_QWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>20LL</span><span>)</span> <span>^=</span> <span>0x7FA6B73DD1E72C56uLL</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>12LL</span><span>)</span> <span>=</span> syscall_index<span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>8LL</span><span>)</span> <span>=</span> <span>-</span><span>997864955</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>8LL</span><span>)</span> <span>^=</span> <span>0x7CEB6A07u</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter<span>)</span> <span>=</span> <span>-</span><span>1006268688</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter<span>)</span> <span>^=</span> <span>0x62ADC0BFu</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>4LL</span><span>)</span> <span>=</span> <span>-</span><span>1637542171</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>4LL</span><span>)</span> <span>^=</span> <span>0x75B49DA9u</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>16LL</span><span>)</span> <span>=</span> <span>109211239</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>16LL</span><span>)</span> <span>^=</span> <span>0xBBCA6C8C</span><span>;</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span>	<span>auto</span> syscall_stub_ptr <span>=</span> <span>(</span><span>__int64</span><span>(</span><span>__fastcall</span><span>*</span><span>)(</span>_QWORD<span>,</span> _QWORD<span>,</span> _QWORD<span>,</span> _QWORD<span>))(</span>syscall_stub_memory <span>+</span> offset_that_doesnt_matter <span>+</span> <span>4LL</span><span>);</span>
</span></span><span><span>    printf<span>(</span><span>&#34;memory allocated: %p</span><span>\n</span><span>&#34;</span><span>,</span> syscall_stub_ptr<span>);</span>
</span></span><span><span>    getchar<span>();</span>
</span></span></code></pre></div><p>Inspecting this memory address reveals the unencrypted shellcode and we can see the standard syscall stub here.
<!-- raw HTML omitted --></p>
<p>Starting with the “mov r10, rcx” instruction.<br/>
<!-- raw HTML omitted --></p>
<p><img src="https://vinayak.io/spoof_stub1.png" alt="image info"/>
<!-- raw HTML omitted --></p>
<p>Following that jmp after the mov, 0x2C is the NtTerminateProcess syscall index for my Windows version, and we can see that being moved into eax.
<!-- raw HTML omitted --></p>
<p><img src="https://vinayak.io/spoof_stub2.png" alt="image info"/>
<!-- raw HTML omitted --></p>
<p>Following the jump after mov eax, this is where the address of the syscall instruction comes in; it’s just a jump to it.
<!-- raw HTML omitted -->
<!-- raw HTML omitted --></p>
<p><strong>Syscall instruction.</strong>
<img src="https://vinayak.io/spoof_stub3.png" alt="image info"/>
<!-- raw HTML omitted -->
<img src="https://vinayak.io/spoof_stub4.png" alt="image info"/>
<!-- raw HTML omitted --></p>
<p>We can take a look at where this syscall instruction is located, just to verify that it’s a bit random.
<img src="https://vinayak.io/spoof_stub5.png" alt="image info"/>
<!-- raw HTML omitted --></p>
<p>And just to double-check, if we run the code again, our syscall instruction location will change!
<img src="https://vinayak.io/spoof_stub6.png" alt="image info"/></p>
<ul>
<li>
<p>This is a lot, so let’s recap quickly.</p>
</li>
<li>
<p>Why would you use a custom syscall stub?</p>
<ul>
<li>This will completely bypass cheaters hooking ntdll functions.</li>
</ul>
</li>
<li>
<p>What’s going on with the NtReadFile stuff?</p>
<ul>
<li>TAC is actually searching for the syscall instruction; their encrypted syscall stub is designed to actually fake where syscalls are coming from, the CPU time is the RNG factor.</li>
<li>Example: Someone monitoring the process will see that a syscall happened from NtReadFile, so they’ll do some inspecting and try to cover up anything NtReadFile would expose of theirs, but the syscall wasn’t even NtReadFile. The actual syscall could have been anything; the cheater will never know unless they’re able to inspect the eax register after the syscall (which should be cleared out and replaced with the NTSTATUS code). This is really cool; an attacker won’t have any way of knowing what syscall instruction to monitor.</li>
</ul>
</li>
<li>
<p>A good way to monitor these would be preventing page execute protections, and looking at the exception, this is what the stub looks like in Ida Pro.
<img src="https://vinayak.io/syscall_ida.png" alt="image info"/></p>
</li>
</ul>
<p>Just for bonus points, I’ve recreated their syscalling method.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>__forceinline</span> <span>int</span> <span>get_syscall_index</span><span>(</span><span>unsigned</span> <span>__int64</span> address<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>return</span> <span>*</span><span>(</span><span>int</span><span>*</span><span>)</span><span>&amp;</span><span>reinterpret_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span>address<span>)[</span><span>4</span><span>];</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>__forceinline</span> <span>__int64</span> <span>get_syscall_instruction_address</span><span>(</span><span>unsigned</span> <span>__int64</span> func<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>const</span> <span>auto</span> distance <span>=</span> <span>12288LL</span><span>;</span>
</span></span><span><span><span>LABEL_1798</span><span>:</span>
</span></span><span><span>	<span>const</span> <span>auto</span> starting_distance <span>=</span> __rdtsc<span>()</span> <span>%</span> <span>(</span>distance <span>-</span> <span>3</span><span>);</span>
</span></span><span><span>	<span>auto</span> ntdll_exported_func <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>char</span><span>*&gt;</span><span>(</span>func<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>__int64</span> syscall_instruction_spot <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>for</span> <span>(</span>syscall_instruction_spot <span>=</span> <span>0LL</span><span>;</span> <span>;</span> <span>++</span>syscall_instruction_spot<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>if</span> <span>(</span>starting_distance <span>+</span> syscall_instruction_spot <span>&gt;=</span> distance<span>)</span>
</span></span><span><span>			<span>goto</span> LABEL_1798<span>;</span>
</span></span><span><span>		<span>if</span> <span>(</span>ntdll_exported_func<span>[</span>syscall_instruction_spot <span>+</span> <span>1</span> <span>+</span> starting_distance<span>]</span> <span>==</span> <span>5</span>
</span></span><span><span>			<span>&amp;&amp;</span> <span>(</span><span>unsigned</span> <span>__int8</span><span>)</span>ntdll_exported_func<span>[</span>syscall_instruction_spot <span>+</span> <span>2</span> <span>+</span> starting_distance<span>]</span> <span>==</span> <span>195</span>
</span></span><span><span>			<span>&amp;&amp;</span> ntdll_exported_func<span>[</span>syscall_instruction_spot <span>+</span> starting_distance<span>]</span> <span>==</span> <span>15</span><span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>break</span><span>;</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span><span>&amp;</span>ntdll_exported_func<span>[</span>syscall_instruction_spot <span>+</span> starting_distance<span>]);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>__forceinline</span> <span>void</span><span>*</span> <span>generate_syscall_stub</span><span>(</span><span>unsigned</span> <span>__int64</span> syscall_instruction<span>,</span> <span>const</span> <span>int</span> syscall_index<span>,</span> <span>void</span><span>**</span> base<span>,</span> <span>int</span><span>*</span> size<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>if</span> <span>(</span>base <span>==</span> <span>nullptr</span> <span>||</span> size <span>==</span> <span>nullptr</span><span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span> <span>nullptr</span><span>;</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>*</span>size <span>=</span> <span>0x4096</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>auto</span> offset <span>=</span> rand<span>()</span> <span>%</span> <span>(</span><span>*</span>size <span>-</span> <span>0x40</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>// using virtual allocated memory just for the example, game has a .text blob allocated for this
</span></span></span><span><span><span></span>	<span>volatile</span> <span>__int64</span> syscall_stub_memory <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>&gt;</span><span>(</span>VirtualAlloc<span>(</span><span>nullptr</span><span>,</span> <span>*</span>size<span>,</span> MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> PAGE_EXECUTE_READWRITE<span>));</span>
</span></span><span><span>	<span>*</span><span>(</span>_QWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>28LL</span><span>)</span> <span>=</span> <span>(</span><span>__int64</span><span>)</span>syscall_instruction<span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_QWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>20LL</span><span>)</span> <span>=</span> <span>0x63B4B73DD1E509A9LL</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_QWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>20LL</span><span>)</span> <span>^=</span> <span>0x7FA6B73DD1E72C56uLL</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>12LL</span><span>)</span> <span>=</span> syscall_index<span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>8LL</span><span>)</span> <span>=</span> <span>-</span><span>997864955</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>8LL</span><span>)</span> <span>^=</span> <span>0x7CEB6A07u</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset<span>)</span> <span>=</span> <span>-</span><span>1006268688</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset<span>)</span> <span>^=</span> <span>0x62ADC0BFu</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>4LL</span><span>)</span> <span>=</span> <span>-</span><span>1637542171</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>4LL</span><span>)</span> <span>^=</span> <span>0x75B49DA9u</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>16LL</span><span>)</span> <span>=</span> <span>109211239</span><span>;</span>
</span></span><span><span>	<span>*</span><span>(</span>_DWORD<span>*</span><span>)(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>16LL</span><span>)</span> <span>^=</span> <span>0xBBCA6C8C</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>*</span>base <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>syscall_stub_memory<span>);</span>
</span></span><span><span>	<span>return</span> <span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>syscall_stub_memory <span>+</span> offset <span>+</span> <span>4LL</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>__forceinline</span> <span>void</span> <span>free_syscall_stub</span><span>(</span><span>void</span><span>*</span> base<span>,</span> <span>int</span> size<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	memset<span>(</span>base<span>,</span> <span>0</span><span>,</span> size<span>);</span>
</span></span><span><span>	VirtualFree<span>(</span>base<span>,</span> <span>0</span><span>,</span> MEM_RELEASE<span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>template</span><span>&lt;</span><span>typename</span><span>...</span> Params<span>&gt;</span>
</span></span><span><span><span>__forceinline</span> NTSTATUS spoof_syscall<span>(</span><span>unsigned</span> <span>__int64</span> exported_ntdll_function<span>,</span> <span>unsigned</span> <span>__int64</span> function_to_call<span>,</span> Params<span>...</span> params<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>void</span><span>*</span> base_address_of_stub <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>	<span>int</span> stub_size <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>const</span> <span>auto</span> nt_syscall_instruction <span>=</span> get_syscall_instruction_address<span>(</span>exported_ntdll_function<span>);</span>
</span></span><span><span>	<span>const</span> <span>auto</span> syscall_index <span>=</span> get_syscall_index<span>(</span>function_to_call<span>);</span>
</span></span><span><span>	<span>void</span><span>*</span> stub <span>=</span> generate_syscall_stub<span>(</span>nt_syscall_instruction<span>,</span> syscall_index<span>,</span> <span>&amp;</span>base_address_of_stub<span>,</span> <span>&amp;</span>stub_size<span>);</span>
</span></span><span><span>
</span></span><span><span>	NTSTATUS result <span>=</span> <span>reinterpret_cast</span><span>&lt;</span>NTSTATUS<span>(</span><span>__fastcall</span><span>*</span><span>)(</span>Params<span>...)</span><span>&gt;</span><span>(</span>stub<span>)(</span>params<span>...);</span>
</span></span><span><span>
</span></span><span><span>	free_syscall_stub<span>(</span>base_address_of_stub<span>,</span> stub_size<span>);</span>
</span></span><span><span>	<span>return</span> result<span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>__forceinline</span> <span>void</span> <span>terminate_process</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>const</span> <span>auto</span> syassasd <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>GetProcAddress<span>(</span>LoadLibraryA<span>(</span><span>&#34;ntdll&#34;</span><span>),</span> <span>&#34;NtTerminateProcess&#34;</span><span>));</span>
</span></span><span><span>	<span>const</span> <span>auto</span> spoof_start <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>GetProcAddress<span>(</span>LoadLibraryA<span>(</span><span>&#34;ntdll&#34;</span><span>),</span> <span>&#34;NtOpenFile&#34;</span><span>));</span>
</span></span><span><span>	spoof_syscall<span>(</span>spoof_start<span>,</span> syassasd<span>,</span> <span>static_cast</span><span>&lt;</span>HANDLE<span>&gt;</span><span>(</span><span>-</span><span>1</span><span>),</span> <span>1337</span><span>);</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>main</span><span>(</span><span>int</span> argc<span>,</span> <span>const</span> <span>char</span><span>**</span> argv<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	terminate_process<span>();</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Let’s test this just to make sure.</p>
<p><img src="https://vinayak.io/poc_syscall.png" alt="image info"/></p>
<ul>
<li>We can see this is working exactly how it should! Again, this is clever and even more effective; cheaters will have no clue which syscall instruction to watch out for.</li>
</ul>
<h2 id="detecting-anti-debugger-hiding-attempts">Detecting Anti-Debugger-Hiding Attempts</h2>
<ul>
<li>
<p>It’s common for anti-debugging or anti-cheat threads to set <code>ThreadHideFromDebugger</code> to true.</p>
<ul>
<li>Whenever a thread has <code>ThreadHideFromDebugger</code> set, any exceptions thrown from that thread will skip past a debugger and crash the process or be handled in the process’s structured exception handling.</li>
<li>Which means this flag is pretty important, and you want to make sure someone isn’t spying on your activity.</li>
<li>TAC has a pretty interesting approach to detecting hooks for this.
<ul>
<li>To set <code>ThreadHideFromDebugger</code>, the API <code>NtSetInformationThread</code> must be called.</li>
<li>Cheaters can hook this and just return TRUE whenever <code>ThreadHideFromDebugger</code> is being requested. This will make the anti-cheat think it has been successfully hidden even though nothing happened.</li>
<li>This method detects poorly made hooks.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c"><span><span><span>#define ThreadHideFromDebugger 17
</span></span></span><span><span><span>#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) &gt;= 0)
</span></span></span><span><span><span></span>
</span></span><span><span><span>__forceinline</span> <span>void</span> <span>ac_detect_hidden_thread</span><span>(</span>callback cb<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	HANDLE current_thread_handle <span>=</span> <span>(</span>HANDLE<span>)</span><span>-</span><span>2</span><span>;</span>
</span></span><span><span>	<span>char</span> use_ThreadHideFromDebugger <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>// this call will fail because NtSetInformationThread returns  
</span></span></span><span><span><span></span>    <span>// STATUS_INFO_LENGTH_MISMATCH if the length parameter is set
</span></span></span><span><span><span></span>	<span>// if it doesn&#39;t fail, then this function has been poorly hooked
</span></span></span><span><span><span></span>	NTSTATUS query_result_1 <span>=</span> <span>nt_set_information_thread</span><span>(</span>
</span></span><span><span>                              current_thread_handle<span>,</span>
</span></span><span><span>                              ThreadHideFromDebugger<span>,</span> 
</span></span><span><span>                              <span>(</span><span>void</span><span>**</span><span>)</span><span>&amp;</span>use_ThreadHideFromDebugger<span>,</span> 
</span></span><span><span>                              <span>1</span><span>);</span>
</span></span><span><span>	<span>if</span> <span>(</span><span>NT_SUCCESS</span><span>(</span>query_result_1<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>printf</span><span>(</span><span>&#34;fake call passed</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>		<span>cb</span><span>();</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// this should return 0 always 
</span></span></span><span><span><span></span>    <span>// when running under a debugger with ScyllaHide, this returns 0xC000005.
</span></span></span><span><span><span></span>	NTSTATUS query_result_2 <span>=</span> <span>nt_set_information_thread</span><span>(</span>current_thread_handle<span>,</span> ThreadHideFromDebugger<span>,</span> <span>0LL</span><span>,</span> <span>0LL</span><span>);</span>
</span></span><span><span>	<span>if</span> <span>(</span>query_result_2 <span>&lt;</span> <span>0</span><span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>printf</span><span>(</span><span>&#34;second call failed</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>		<span>cb</span><span>();</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// this will catch hooks that do not check the size properly
</span></span></span><span><span><span></span>	<span>// NtQueryInformationThread expects the size to be 1, not 4.
</span></span></span><span><span><span></span>	<span>// 4 is sizeof(BOOL) vs sizeof(bool), which is 1.
</span></span></span><span><span><span></span>    NTSTATUS query_result_3 <span>=</span> <span>nt_query_information_thread</span><span>(</span>
</span></span><span><span>                              current_thread_handle<span>,</span> 
</span></span><span><span>                              ThreadHideFromDebugger<span>,</span> 
</span></span><span><span>                              <span>(</span><span>void</span><span>**</span><span>)</span><span>&amp;</span>use_ThreadHideFromDebugger<span>,</span> 
</span></span><span><span>                              <span>4LL</span><span>,</span> 
</span></span><span><span>                              <span>NULL</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> <span>(</span><span>NT_SUCCESS</span><span>(</span>query_result_3<span>))</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>    	<span>printf</span><span>(</span><span>&#34;third call succeeded</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>    	<span>cb</span><span>();</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// this call just passes a fake handle to check
</span></span></span><span><span><span></span>    <span>// for a hook returning success whenever ThreadHideFromDebugger is passed
</span></span></span><span><span><span></span>    HANDLE fake_handle <span>=</span> <span>(</span>HANDLE<span>)</span><span>__rdtsc</span><span>();</span>
</span></span><span><span>    NTSTATUS query_result_4 <span>=</span> <span>nt_set_information_thread</span><span>(</span>fake_handle<span>,</span> ThreadHideFromDebugger<span>,</span> <span>0LL</span><span>,</span> <span>0LL</span><span>);</span>
</span></span><span><span>    <span>if</span> <span>(</span><span>NT_SUCCESS</span><span>(</span>query_result_3<span>))</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>    	<span>printf</span><span>(</span><span>&#34;fourth call succeeded</span><span>\n</span><span>&#34;</span><span>);</span>
</span></span><span><span>    	<span>cb</span><span>();</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
<p>This is the result when running under x64dbg with ScyllaHide.
<!-- raw HTML omitted --></p>
<p><img src="https://vinayak.io/scyllahide.png" alt="image info"/></p>
<p>And this is the result without a debugger and without ScyllaHide.
<!-- raw HTML omitted --></p>
<p><img src="https://vinayak.io/no_scyllahide.png" alt="image info"/></p>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="create-remote-thread-blocking">Create Remote Thread Blocking</h2>
<ul>
<li>
<p>TAC installs an exception handler that just calls <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread">TerminateThread</a> on the <code>STATUS_PRIVILEGED_INSTRUCTION</code> exception code.</p>
</li>
<li>
<p>There’s a good reason for this; when cheaters manually map their DLL, they need a way to get the remote process to actually run the shellcode they wrote. One of the most common ways of doing this is <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a>, which just allows the cheater to have a newly created thread that immediately executes their shellcode.</p>
<ul>
<li>How is it detected?:
<ul>
<li>TLS callbacks are callbacks that can be planted inside of a Windows PE file; these callbacks are called before the thread’s entry point whenever a thread is created.</li>
</ul>
</li>
</ul>
<p>Here’s how that works; keep in mind that we are running in the current thread context of the newly created thread.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; this isn&#39;t exactly how the game does this 
</span></span></span><span><span><span>; anyways, this will still raise the STATUS_PRIVILEGED_INSTRUCTION exception.
</span></span></span><span><span><span></span><span>PUBLIC</span> <span>_priv_ins_exx</span> 
</span></span><span><span>
</span></span><span><span><span>.code</span>
</span></span><span><span>
</span></span><span><span><span>_priv_ins_exx</span> <span>PROC</span>
</span></span><span><span>	<span>mov</span> <span>rax</span><span>,</span> <span>dr0</span> <span>; dr0 is privileged and we do not have access
</span></span></span><span><span><span></span><span>_priv_ins_exx</span> <span>ENDP</span>
</span></span><span><span>
</span></span><span><span><span>END</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="c++"><span><span>LONG WINAPI <span>ac_vectored_handler</span><span>(</span>EXCEPTION_POINTERS<span>*</span> exptrs<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>// this code is running in the same thread as the TLS callback
</span></span></span><span><span><span></span>    <span>if</span> <span>(</span>exptrs<span>-&gt;</span>ExceptionRecord<span>-&gt;</span>ExceptionCode <span>==</span> STATUS_PRIVILEGED_INSTRUCTION<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>// terminate the current thread
</span></span></span><span><span><span></span>        TerminateThread<span>(</span>NtCurrentThread<span>(),</span> <span>1</span><span>);</span>
</span></span><span><span>        <span>return</span> <span>0</span><span>;</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span>VOID WINAPI <span>tls_callback</span><span>(</span>PVOID DllHandle<span>,</span> DWORD Reason<span>,</span> PVOID Reserved<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>if</span> <span>(</span>Reason <span>==</span> DLL_THREAD_ATTACH<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>      <span>// collect the threads start address
</span></span></span><span><span><span></span>      <span>__int64</span> start_address <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>      NtQueryInformationThread<span>(</span>NtCurrentThread<span>(),</span> ThreadQuerySetWin32StartAddress<span>,</span> <span>&amp;</span>start_address<span>,</span> <span>sizeof</span><span>(</span>start_address<span>),</span> <span>nullptr</span><span>);</span>
</span></span><span><span>
</span></span><span><span>      <span>// assume the address is invalid until proven otherwise
</span></span></span><span><span><span></span>      <span>bool</span> outside_of_valid_module <span>=</span> <span>true</span><span>;</span> 
</span></span><span><span>
</span></span><span><span>      <span>// loop the current loaded modules list
</span></span></span><span><span><span></span>      <span>const</span> <span>auto</span> memory_module_list <span>=</span> <span>&amp;</span><span>reinterpret_cast</span><span>&lt;</span>nt<span>::</span>PTEB<span>&gt;</span><span>(</span>NtCurrentTeb<span>())</span><span>-&gt;</span>ProcessEnvironmentBlock<span>-&gt;</span>Ldr<span>-&gt;</span>InMemoryOrderModuleList<span>;</span>
</span></span><span><span>      <span>for</span> <span>(</span>PLIST_ENTRY p_list_entry <span>=</span> memory_module_list<span>-&gt;</span>Flink<span>;</span> p_list_entry <span>!=</span> memory_module_list<span>;</span> p_list_entry <span>=</span> p_list_entry<span>-&gt;</span>Flink<span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          <span>auto</span> p_entry <span>=</span> CONTAINING_RECORD<span>(</span>p_list_entry<span>,</span> nt<span>::</span>LDR_DATA_TABLE_ENTRY<span>,</span> InMemoryOrderLinks<span>);</span>
</span></span><span><span>
</span></span><span><span>          <span>// this condition will be true as long as the start address is within a loaded dlls range.
</span></span></span><span><span><span></span>          <span>// example: memory such as 0x1E000000000 will not exist in any module (any memory from the result of a virtual alloc call will not be valid.)
</span></span></span><span><span><span></span>          <span>// while something like 0x7FFF12397591 could be inside of ntdll.dll
</span></span></span><span><span><span></span>          <span>if</span> <span>(</span>start_address <span>&gt;</span> <span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>&gt;</span><span>(</span>p_entry<span>-&gt;</span>DllBase<span>)</span> <span>&amp;&amp;</span> start_address <span>&lt;</span> <span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>&gt;</span><span>(</span>p_entry<span>-&gt;</span>DllBase<span>)</span> <span>+</span> p_entry<span>-&gt;</span>SizeOfImage<span>)</span>
</span></span><span><span>          <span>{</span>
</span></span><span><span>              outside_of_valid_module <span>=</span> <span>false</span><span>;</span>
</span></span><span><span>              <span>break</span><span>;</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>
</span></span><span><span>      <span>// if we failed to prove the address is valid
</span></span></span><span><span><span></span>      <span>if</span> <span>(</span>outside_of_valid_module<span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          callback<span>();</span> <span>// detection is stored and uploaded later
</span></span></span><span><span><span></span>          _priv_ins_exx<span>();</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
<h2 id="dumping-exception-handlers">Dumping Exception Handlers</h2>
<p>For those interested in how I dumped the exception handlers, I’ve provided the code.
You’ll need to update these offsets if you want to use this.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>dump_exception_handlers</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>// 75 ? 4C 8D 9C 24 ? ? ? ? 48 8B C3 : mov xxx, rsi
</span></span></span><span><span><span></span>  <span>__int64</span> exception_filter <span>=</span> <span>(</span><span>__int64</span><span>)</span>GetModuleHandleA<span>(</span><span>&#34;kernelbase.dll&#34;</span><span>)</span> <span>+</span> <span>0x28CC60</span><span>;</span>
</span></span><span><span>  <span>auto</span> rtl_decode_pointer <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>(</span><span>__fastcall</span><span>*</span><span>)(</span><span>__int64</span><span>)</span><span>&gt;</span><span>(</span>get_address<span>(</span><span>&#34;ntdll.dll&#34;</span><span>,</span> <span>&#34;RtlDecodePointer&#34;</span><span>));</span>
</span></span><span><span>
</span></span><span><span>  <span>// F0 0F AB 48 : lea rcx 
</span></span></span><span><span><span></span>  PLDRP_VECTOR_HANDLER_LIST vector_list <span>=</span> <span>(</span>PLDRP_VECTOR_HANDLER_LIST<span>)((</span><span>__int64</span><span>)</span>GetModuleHandleA<span>(</span><span>&#34;ntdll.dll&#34;</span><span>)</span> <span>+</span> <span>0x17F3E8</span><span>);</span>
</span></span><span><span>  LIST_ENTRY<span>*</span> list_head <span>=</span> <span>&amp;</span>vector_list<span>-&gt;</span>LdrpVehList<span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>// this will be the function passed into SetUnhandledExceptionFilter 
</span></span></span><span><span><span></span>  log<span>(</span><span>&#34;UnhandledExceptionFilter: 0x%p</span><span>\n</span><span>&#34;</span><span>,</span> rtl_decode_pointer<span>(</span><span>*</span><span>(</span><span>__int64</span><span>*</span><span>)</span>exception_filter<span>));</span>
</span></span><span><span>
</span></span><span><span>  <span>// dump out the vectored handler list
</span></span></span><span><span><span></span>  <span>for</span> <span>(</span>LIST_ENTRY<span>*</span> list_entry <span>=</span> list_head<span>-&gt;</span>Flink<span>;</span> list_entry <span>!=</span> list_head<span>;</span> list_entry <span>=</span> list_entry<span>-&gt;</span>Flink<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>  	PVECTOR_HANDLER_ENTRY pEntry <span>=</span> CONTAINING_RECORD<span>(</span>list_entry<span>,</span> VECTOR_HANDLER_ENTRY<span>,</span> ListEntry<span>);</span>
</span></span><span><span>  	<span>__int64</span> pExceptionHandler <span>=</span> rtl_decode_pointer<span>((</span><span>__int64</span><span>)</span>pEntry<span>-&gt;</span>EncodedHandler<span>);</span>
</span></span><span><span>  	TCHAR modname<span>[</span>MAX_PATH<span>];</span>
</span></span><span><span>  	GetModuleBaseNameW<span>(</span>GetCurrentProcess<span>(),</span> GetModuleHandle<span>(</span><span>NULL</span><span>),</span> modname<span>,</span> MAX_PATH<span>);</span>
</span></span><span><span>  	log<span>(</span><span>&#34;VEH: 0x%p (%ws) [0x%p]</span><span>\n</span><span>&#34;</span><span>,</span> pExceptionHandler<span>,</span> modname<span>,</span> pExceptionHandler <span>-</span> <span>(</span><span>__int64</span><span>)</span>GetModuleHandleW<span>(</span>modname<span>));</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>// dump out the continued handler list
</span></span></span><span><span><span></span>  list_head <span>=</span> <span>&amp;</span>vector_list<span>-&gt;</span>LdrpVchList<span>;</span>
</span></span><span><span>  <span>for</span> <span>(</span>LIST_ENTRY<span>*</span> list_entry <span>=</span> list_head<span>-&gt;</span>Flink<span>;</span> list_entry <span>!=</span> list_head<span>;</span> list_entry <span>=</span> list_entry<span>-&gt;</span>Flink<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>  	PVECTOR_HANDLER_ENTRY pEntry <span>=</span> CONTAINING_RECORD<span>(</span>list_entry<span>,</span> VECTOR_HANDLER_ENTRY<span>,</span> ListEntry<span>);</span>
</span></span><span><span>  	<span>__int64</span> pExceptionHandler <span>=</span> rtl_decode_pointer<span>((</span><span>__int64</span><span>)</span>pEntry<span>-&gt;</span>EncodedHandler<span>);</span>
</span></span><span><span>  	TCHAR modname<span>[</span>MAX_PATH<span>];</span>
</span></span><span><span>  	GetModuleBaseNameW<span>(</span>GetCurrentProcess<span>(),</span> GetModuleHandle<span>(</span><span>NULL</span><span>),</span> modname<span>,</span> MAX_PATH<span>);</span>
</span></span><span><span>  	log<span>(</span><span>&#34;VCH: 0x%p (%ws) [0x%p]</span><span>\n</span><span>&#34;</span><span>,</span> pExceptionHandler<span>,</span> modname<span>,</span> pExceptionHandler <span>-</span> <span>(</span><span>__int64</span><span>)</span>GetModuleHandleW<span>(</span>modname<span>));</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h2 id="mystery-tech">Mystery Tech?</h2>
<p>I’m not sure what this is, but it looks like something that would flag virtual machines or custom versions of Windows.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>ac_check_allocation_grad</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  SYSTEM_BASIC_INFORMATION sbi<span>;</span>
</span></span><span><span>  NtQuerySystemInformation<span>(</span><span>0</span><span>,</span> <span>&amp;</span>sbi<span>,</span> <span>sizeof</span><span>(</span>sbi<span>),</span> <span>nullptr</span><span>);</span>
</span></span><span><span>
</span></span><span><span>  <span>if</span> <span>(</span>sbi<span>.</span>AllocationGranularity <span>!=</span> <span>0x10000</span><span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    callback<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Since TAC is so reliant on the linked module list, they have a check that prevents someone from setting it to an empty list. Setting this to an empty list will probably break the process anyway.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>ac_detect_invalidated_module_list</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>const</span> <span>auto</span> memory_module_list <span>=</span> <span>&amp;</span>NtCurrentPeb<span>()</span><span>-&gt;</span>Ldr<span>-&gt;</span>InMemoryOrderModuleList<span>;</span>
</span></span><span><span>  <span>if</span> <span>(</span>memory_module_list<span>-&gt;</span>Flink <span>==</span> memory_module_list<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    callback<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><h2 id="the-end">The End</h2>
<p>TAC is a pretty cool user-mode anti-cheat, with features such as runtime API lookups, detecting poorly made hooks by passing clever invalid parameters, external overlay detection, internal DirectX hook detection, checking APIs that it uses for hooks, checking for debuggers and debugging artifacts, AllocConsole detection, CreateRemoteThread detection, and the coolest of all, spoofed and encrypted syscall stubs. Arxan really helps out TAC; it has powerful obfuscation, anti-static analysis methods, and a couple of features that break IDA Pro, all while monitoring the executable for .text modifications. It even has its own anti-debug techniques built-in. Similar code from TAC is being used in modern Call of Duty games. Overall, this was a huge learning experience, and a great challenge, and pretty unreal to see all the things that caught me! I hope you found my research interesting. I’m still not 100% done reversing the anti-cheat, so you can expect to see new information posted here sometime in the future! :)</p>
<hr/>
<p><strong>References</strong></p>
<ul>
<li><a href="https://www.lodsb.com/ntsetinformationthread-disabling-threadhidefromdebugger">https://www.lodsb.com/ntsetinformationthread-disabling-threadhidefromdebugger</a> [#1]</li>
<li><a href="https://github.com/ayoubfaouzi/al-khaser/blob/master/al-khaser/AntiDebug/NtSetInformationThread_ThreadHideFromDebugger.cpp">https://github.com/ayoubfaouzi/al-khaser/blob/master/al-khaser/AntiDebug/NtSetInformationThread_ThreadHideFromDebugger.cpp</a>  [#2]</li>
<li><a href="https://www.unknowncheats.me/forum/c-and-c-/567151-vectored-exception-handlers-x64-windows.html">https://www.unknowncheats.me/forum/c-and-c-/567151-vectored-exception-handlers-x64-windows.html</a> [#3]</li>
<li><a href="https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/">https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/</a> [#4]</li>
</ul>
<hr/>

    </div>
    
  </article>

    </div></div>
  </body>
</html>
