<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ssno.cc/posts/reversing-tac-1-4-2025/">Original</a>
    <h1>Reverse engineering Call of Duty anti-cheat</h1>
    
    <div id="readability-page-1" class="page"><div>
      
  <article>
    
    <div>
      <p><strong>I’ve been reversing Black Ops Cold War for a while now, and I’ve finally decided to share my research regarding the user-mode anti-cheat inside the game. It’s not my intention to shame or promote cheating/bypassing of the anti-cheat, so I’ve redacted a few things.</strong></p>
<meta property="og:image" content="https://ssno.cc/coldwar.png"/>
<p><img src="https://ssno.cc/coldwar.png" alt="image info"/></p>
<p>To clear up any confusion, Black Ops Cold War does not have the kernel-mode component of Ricochet that Modern Warfare (2019) and later titles have. I’ll be referring to the anti-cheat as TAC (Treyarch Anti-Cheat) as the game I reversed is a Treyarch game. Also, whenever I provide function pseudocode, it will be the best I can do since the actual decompilation is super cluttered with a lot of junk/resolving code. The biggest difference between the newer games is the kernel-mode driver, while the majority of anti-cheat code is user-mode and very similar to TAC.</p>
<p>Let’s look at how the anti-cheat and the game is protected before we dig too deep.</p>
<h2 id="arxan">Arxan</h2>
<ul>
<li>
<p>Arxan is an obfuscation/protection tool that’s used on many Call of Duty games, most of which are anything past Black Ops 3. Which includes many features, that make cheaters/reverse engineers’ life a lot harder.</p>
<h2 id="runtime-executable-decryption">Runtime Executable Decryption</h2>
<ul>
<li>The game executable is packed and encrypted; Arxan inserts code during the startup process to unpack and decrypt the game executable.</li>
</ul>
<h2 id="executable-checksums">Executable Checksums</h2>
<ul>
<li>Arxan is constantly monitoring the game executable for any patches.</li>
<li>If you want to learn more about these, momo5502 has a great blog post which can be found <a href="https://momo5502.com/posts/2022-11-17-reverse-engineering-integrity-checks-in-black-ops-3/">here</a></li>
<li>Whenever Arxan detects a debugger or a checksum mismatch, it will terminate the process.</li>
</ul>
<h2 id="jmp-obfuscation">Jmp Obfuscation</h2>
<ul>
<li>Arxan can take a function and all of its instructions and separate them with a jmp.</li>
<li>This is also useful to hide where a function is called from, it breaks IDA and requires an external tool to sift through the instructions.
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>push</span>    <span>rbp</span>
</span></span><span><span><span>mov</span>     <span>rbp</span><span>,</span> <span>offset</span> <span>unk_7FF60ECD1310</span>
</span></span><span><span><span>xchg</span>    <span>rbp</span><span>,</span> <span>[</span><span>rsp</span><span>]</span>
</span></span><span><span><span>push</span>    <span>rbx</span>
</span></span><span><span><span>jmp</span>     <span>loc_7FF62B2050A6</span>
</span></span><span><span>
</span></span><span><span><span>loc_7FF62B2050A6:</span>
</span></span><span><span><span>push</span>    <span>rax</span>
</span></span><span><span><span>mov</span>     <span>rbx</span><span>,</span> <span>[</span><span>rsp</span><span>+</span><span>10</span><span>h</span><span>]</span>
</span></span><span><span><span>mov</span>     <span>rax</span><span>,</span> <span>offset</span> <span>loc_7FF60ECD1622</span>
</span></span><span><span><span>cmovbe</span>  <span>rbx</span><span>,</span> <span>rax</span>
</span></span><span><span><span>jmp</span>     <span>loc_7FF62BD590D3</span>
</span></span><span><span>
</span></span><span><span><span>loc_7FF62BD590D3:</span>   
</span></span><span><span><span>mov</span>     <span>[</span><span>rsp</span><span>+</span><span>10</span><span>h</span><span>],</span> <span>rbx</span>
</span></span><span><span><span>pop</span>     <span>rax</span>
</span></span><span><span><span>pop</span>     <span>rbx</span>
</span></span><span><span><span>retn</span>
</span></span><span><span>
</span></span><span><span><span>loc_7FF60ECD1622:</span>   
</span></span><span><span><span>jmp</span>     <span>loc_7FF629D04404</span>
</span></span><span><span>
</span></span><span><span><span>; etc
</span></span></span></code></pre></div></li>
<li>This is difficult to analyze statically, especially whenever it’s a giant function that’s been planted with hundreds of jumps.</li>
</ul>
<h2 id="entrypoint-obfuscation">Entrypoint Obfuscation</h2>
<ul>
<li>It’s really difficult to follow the entry point on Arxan-protected games; first, you have the protected Arxan code that unpacks and executes the game’s real entry point, which jmp obfuscation can also be planted in here, making it extremely difficult to understand what’s going on.</li>
</ul>
<h2 id="pointer-encryption">Pointer Encryption</h2>
<ul>
<li>This was actually thought to be Arxan for the longest time, but with recent information, it’s pretty certain this is just something Treyarch has developed and shared with IW for their games, or maybe it’s the other way around.</li>
<li>Important pointers such as the current game glob, entity array, object pointers, etc., are encrypted and decrypted every time before use.</li>
<li>There are 16 variations of the same encryption method; the current PEB address is actually what decides which encryption method to use.
<ul>
<li>This is pretty effective and does make your life harder for a little bit.
<ul>
<li>Forces you to get the decrypted pointer.</li>
<li>Prevents cheat engine pointer scanning (when scanning for the memory address of something that is encrypted, the actual global value will be holding the encrypted value, and this value is never set with the decrypted value; the decrypted value is always on  the stack.)</li>
<li>There are a couple of ways to retrieve these decrypted pointers (these are not all of them):
<ul>
<li>Using a tool to trace the decryption instructions.</li>
<li>Creating a hook on spots where the memory has already been decrypted by the game for use.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>int</span> <span>get_encryption_method</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>// this is actually how it is in the exe
</span></span></span><span><span><span></span>    <span>// the result of this ROL is 0x60 which is gs[PEB]
</span></span></span><span><span><span></span>    <span>// these values are generated and will not always be the same
</span></span></span><span><span><span></span>    <span>const</span> <span>auto</span> value <span>=</span> <span>(</span><span>unsigned</span> <span>__int8</span><span>)</span>__ROL1__<span>(</span><span>-</span><span>127</span><span>,</span> <span>230</span><span>);</span>
</span></span><span><span>    <span>auto</span> peb <span>=</span> __readgsqword<span>(</span>value<span>);</span>
</span></span><span><span>    <span>return</span> _byteswap_uint64<span>(</span>peb <span>&lt;&lt;</span> <span>33</span><span>)</span> <span>&amp;</span> <span>0xF</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
<li>Here’s just a small portion of the operations done in the game exe for the encryption.
<img src="https://ssno.cc/ptr_enc.png" alt="image info"/></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Now we that understand how the game and anti-cheat are protected we can dig deeper.
TAC is planted directly into the game executable, uses no kernel components, and will also terminate the process if debug artifacts are found.</p>
<h3 id="how-does-tac-detect-monitoring">How does TAC detect monitoring?</h3>
<ul>
<li><strong>API Hook Detection</strong>
<ul>
<li>TAC is designed for Windows; this means it’s going to be using Windows-specific APIs for the anti-cheat.</li>
</ul>
<ul>
<li>
<p>The hook detection used here is pretty basic, and it’s currently only checking for 7 patterns. It looks like they have just taken previous cheats’ hook stubs and put them in.</p>
</li>
<li>
<p>NOTE: Each time I provide example code, every API called in that example code is what TAC is using, is being checked for hooks, and is being resolved by their runtime hash lookup. Also, most of TAC is heavily inlined.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; First stub
</span></span></span><span><span><span></span><span>push</span>   <span>rax</span>
</span></span><span><span><span>movabs</span> <span>rax</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rax</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Second Stub
</span></span></span><span><span><span></span><span>push</span>   <span>rbx</span>
</span></span><span><span><span>movabs</span> <span>rbx</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rbx</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Third Stub
</span></span></span><span><span><span></span><span>push</span>   <span>rcx</span>
</span></span><span><span><span>movabs</span> <span>rcx</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rcx</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Fourth Stub
</span></span></span><span><span><span></span><span>push</span>   <span>rdx</span>
</span></span><span><span><span>movabs</span> <span>rdx</span><span>,</span><span>0x0</span>
</span></span><span><span>
</span></span><span><span><span>xchg</span>   <span>QWORD</span> <span>PTR</span> <span>[</span><span>rsp</span><span>],</span><span>rdx</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span><span>; Fifth Stub
</span></span></span><span><span><span></span><span>push</span>   <span>0x0</span>
</span></span><span><span><span>ret</span>
</span></span><span><span>
</span></span><span><span>
</span></span><span><span><span>; Sixth Stub (this is any call, 0xE8, 0x0, 0x0, 0x0, 0x0)
</span></span></span><span><span><span></span><span>call</span> <span>0x00000</span>
</span></span><span><span>
</span></span><span><span><span>; Seventh Stub (this is any jmp [rip+x], 0xFF, 0x25, 0x00, 0x00, 0x00, 0x00)
</span></span></span><span><span><span></span><span>jmp</span> <span>QWORD</span> <span>PTR</span> <span>[</span><span>rip</span><span>+</span><span>0</span><span>]</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<ul>
<li>Here’s how these checks are implemented. Those 0x0 spots in the assembly are 8 bytes because this is x64.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>void</span> <span>ac_check_hook</span><span>(</span><span>unsigned</span> <span>__int64</span> address<span>,</span> callback cb<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>unsigned</span> <span>__int8</span><span>*</span> current_pos <span>=</span> <span>nullptr</span><span>;</span>
</span></span><span><span>  <span>bool</span> hook_detected <span>=</span> <span>false</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>for</span> <span>(</span>current_pos <span>=</span> <span>(</span><span>unsigned</span> <span>__int8</span> <span>*</span><span>)</span>address<span>;</span> <span>*</span>current_pos <span>==</span> <span>144</span><span>;</span> <span>++</span>current_pos<span>)</span>
</span></span><span><span>          <span>;</span>
</span></span><span><span>  <span>switch</span> <span>(</span><span>*</span>current_pos<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    <span>case</span> <span>0x50u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>184</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>4</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x53u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>187</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>28</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x51u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>185</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>12</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x52u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>2</span><span>]</span> <span>==</span> <span>186</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>11</span><span>]</span> <span>==</span> <span>72</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>12</span><span>]</span> <span>==</span> <span>135</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>13</span><span>]</span> <span>==</span> <span>20</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>14</span><span>]</span> <span>==</span> <span>36</span>
</span></span><span><span>          <span>&amp;&amp;</span> current_pos<span>[</span><span>15</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>      <span>{</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>}</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0x68u</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span>current_pos<span>[</span><span>5</span><span>]</span> <span>==</span> <span>195</span><span>)</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>case</span> <span>0xE9u</span><span>:</span>
</span></span><span><span>      hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>    <span>default</span><span>:</span>
</span></span><span><span>      <span>if</span> <span>(</span><span>*</span>current_pos <span>==</span> <span>255</span> <span>&amp;&amp;</span> current_pos<span>[</span><span>1</span><span>]</span> <span>==</span> <span>37</span><span>)</span>
</span></span><span><span>          hook_detected <span>=</span> <span>true</span><span>;</span>
</span></span><span><span>      <span>break</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>if</span> <span>(</span>hook_detected<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>      cb<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// example usage
</span></span></span><span><span><span></span>ac_check_hook<span>((</span><span>unsigned</span> <span>__int64</span><span>)</span><span>&amp;</span>Thread32First<span>,</span> callback<span>);</span>
</span></span></code></pre></div></li>
</ul>

</div>

<h2 id="runtime-api-export-lookup">Runtime API Export Lookup</h2>
<ul>
<li>TAC has an inlined API lookup function; it takes the module hash and the API name hash, iterates the current list of loaded modules, hashes the name, then goes through each exported function from that module and compares it to the compile-time hash of the API they want.</li>
</ul>
<p>This is what the decomp looks like.
<img src="https://ssno.cc/runtime_lookup.PNG" alt="image info"/></p>
<p>Here’s a recreation of their runtime lookup.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span>  <span>void</span><span>*</span> <span>get_module_base</span><span>(</span>size_t base<span>,</span> size_t hash<span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>  	ac_setbase<span>(</span>base<span>);</span>
</span></span><span><span>
</span></span><span><span>  	<span>auto</span> peb <span>=</span> <span>static_cast</span><span>&lt;</span>PPEB<span>&gt;</span><span>(</span>NtCurrentPeb<span>());</span>
</span></span><span><span>  	<span>auto</span> head <span>=</span> <span>&amp;</span>peb<span>-&gt;</span>Ldr<span>-&gt;</span>InMemoryOrderModuleList<span>;</span>
</span></span><span><span>
</span></span><span><span>  	<span>int</span> mc <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  	<span>auto</span> entry <span>=</span> head<span>-&gt;</span>Flink<span>;</span>
</span></span><span><span>  	<span>while</span> <span>(</span>entry <span>!=</span> head<span>)</span>
</span></span><span><span>  	<span>{</span>
</span></span><span><span>  		<span>auto</span> table_entry <span>=</span> CONTAINING_RECORD<span>(</span>entry<span>,</span> LDR_DATA_TABLE_ENTRY<span>,</span> InMemoryOrderLinks<span>);</span>
</span></span><span><span>  		<span>auto</span> n <span>=</span> <span>static_cast</span><span>&lt;</span><span>int</span><span>&gt;</span><span>(</span>offsetof<span>(</span>LDR_DATA_TABLE_ENTRY<span>,</span> DllBase<span>));</span>
</span></span><span><span>
</span></span><span><span>  		<span>char</span> buf<span>[</span><span>255</span><span>];</span>
</span></span><span><span>  		size_t count <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>  		wcstombs_s<span>(</span><span>&amp;</span>count<span>,</span> buf<span>,</span> table_entry<span>-&gt;</span>FullDllName<span>.</span>Buffer<span>,</span> table_entry<span>-&gt;</span>FullDllName<span>.</span>Length<span>);</span>
</span></span><span><span>
</span></span><span><span>        <span>// this is just from my hash tool; +20 skips past C:\Windows\System32
</span></span></span><span><span><span></span>  		<span>auto</span> h <span>=</span> ac_mod64<span>(</span>buf <span>+</span> <span>20</span><span>);</span>
</span></span><span><span>  		<span>if</span> <span>(</span>h <span>==</span> hash<span>)</span>
</span></span><span><span>  		<span>{</span>
</span></span><span><span>            <span>return</span> table_entry<span>-&gt;</span>DllBase<span>;</span>
</span></span><span><span>  			<span>break</span><span>;</span>
</span></span><span><span>  		<span>}</span>
</span></span><span><span>
</span></span><span><span>  		entry <span>=</span> entry<span>-&gt;</span>Flink<span>;</span>
</span></span><span><span>  	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>nullptr</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span></code></pre></div><h2 id="how-can-we-figure-out-what-these-hashes-are">How can we figure out what these hashes are?</h2>
<p>The answer is super simple; I grabbed a list of all the loaded modules in my game process and copied over the game’s hashing function (note: dll names are hashed a little bit differently), which can be seen here.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// this is used for dll names
</span></span></span><span><span><span></span>size_t <span>ac_mod64</span><span>(</span><span>const</span> <span>char</span><span>*</span> str<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>auto</span> base <span>=</span> ac_getbase<span>();</span>
</span></span><span><span>	<span>while</span> <span>(</span><span>*</span>str<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>auto</span> v203 <span>=</span> <span>*</span>str<span>++</span><span>;</span>
</span></span><span><span>		<span>auto</span> v39 <span>=</span> v203<span>;</span>
</span></span><span><span>
</span></span><span><span>		<span>if</span> <span>(</span>v203 <span>&gt;=</span> <span>0x41u</span> <span>&amp;&amp;</span> v39 <span>&lt;=</span> <span>0x5Au</span><span>)</span>
</span></span><span><span>			v39 <span>+=</span> <span>32</span><span>;</span>
</span></span><span><span>		base <span>=</span> <span>0x100000001B3</span>i64 <span>*</span> <span>(((</span>v39 <span>&amp;</span> <span>0xFF00</span><span>)</span> <span>&gt;&gt;</span> <span>8</span><span>)</span> <span>^</span> <span>(</span><span>0x100000001B3</span>i64 <span>*</span> <span>(</span><span>static_cast</span><span>&lt;</span><span>unsigned</span> <span>__int8</span><span>&gt;</span><span>(</span>v39<span>)</span> <span>^</span>
</span></span><span><span>			base<span>)));</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> base<span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// this is used for exported function names
</span></span></span><span><span><span></span>size_t <span>ac_fnv64</span><span>(</span><span>const</span> <span>char</span><span>*</span> str<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>auto</span> base <span>=</span> ac_getbase<span>();</span>
</span></span><span><span>    <span>while</span> <span>(</span><span>*</span>str<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        <span>auto</span> s <span>=</span> <span>*</span>str<span>++</span><span>;</span>
</span></span><span><span>        <span>auto</span> v12 <span>=</span> s<span>;</span>
</span></span><span><span>        <span>if</span> <span>(</span>s <span>&gt;=</span> <span>65</span> <span>&amp;&amp;</span> v12 <span>&lt;=</span> <span>90</span><span>)</span>
</span></span><span><span>            v12 <span>+=</span> <span>32</span><span>;</span>
</span></span><span><span>
</span></span><span><span>        base <span>=</span> ac_prime <span>*</span> <span>(</span>v12 <span>^</span> base<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>    <span>return</span> base<span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>I took that function and calculated the hash of all the module names and exports from the module list that I grabbed, then created a function to look up these API names by using the FNV hash base and the inlined hash of the API name.</p>
<p>Here’s how I managed to cache and resolve all of the exports.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>cache_exports</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>for</span> <span>(</span><span>auto</span> <span>dll</span> <span>:</span> loadedDlls<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        HMODULE mod <span>=</span> GetModuleHandleA<span>(</span>dll<span>.</span>c_str<span>());</span>
</span></span><span><span>        <span>if</span> <span>(</span><span>!</span>mod<span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>continue</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        IMAGE_DOS_HEADER<span>*</span> mz <span>=</span> <span>(</span>PIMAGE_DOS_HEADER<span>)</span>mod<span>;</span>
</span></span><span><span>        IMAGE_NT_HEADERS<span>*</span> nt <span>=</span> RVA2PTR<span>(</span>PIMAGE_NT_HEADERS<span>,</span> mz<span>,</span> mz<span>-&gt;</span>e_lfanew<span>);</span>
</span></span><span><span>
</span></span><span><span>        IMAGE_DATA_DIRECTORY<span>*</span> edirp <span>=</span> <span>&amp;</span>nt<span>-&gt;</span>OptionalHeader<span>.</span>DataDirectory<span>[</span>IMAGE_DIRECTORY_ENTRY_EXPORT<span>];</span>
</span></span><span><span>        IMAGE_DATA_DIRECTORY edir <span>=</span> <span>*</span>edirp<span>;</span>
</span></span><span><span>
</span></span><span><span>        IMAGE_EXPORT_DIRECTORY<span>*</span> exports <span>=</span> RVA2PTR<span>(</span>PIMAGE_EXPORT_DIRECTORY<span>,</span> mz<span>,</span> edir<span>.</span>VirtualAddress<span>);</span>
</span></span><span><span>
</span></span><span><span>        DWORD<span>*</span> addrs <span>=</span> RVA2PTR<span>(</span>DWORD<span>*</span><span>,</span> mz<span>,</span> exports<span>-&gt;</span>AddressOfFunctions<span>);</span>
</span></span><span><span>        DWORD<span>*</span> names <span>=</span> RVA2PTR<span>(</span>DWORD<span>*</span><span>,</span> mz<span>,</span> exports<span>-&gt;</span>AddressOfNames<span>);</span>
</span></span><span><span>        <span>for</span> <span>(</span><span>unsigned</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> exports<span>-&gt;</span>NumberOfFunctions<span>;</span> i<span>++</span><span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>char</span><span>*</span> name <span>=</span> RVA2PTR<span>(</span><span>char</span><span>*</span><span>,</span> mz<span>,</span> names<span>[</span>i<span>]);</span>
</span></span><span><span>            <span>void</span><span>*</span> addr <span>=</span> RVA2PTR<span>(</span><span>void</span><span>*</span><span>,</span> mz<span>,</span> addrs<span>[</span>i<span>]);</span>
</span></span><span><span>
</span></span><span><span>            MEMORY_BASIC_INFORMATION mbi<span>;</span>
</span></span><span><span>            <span>if</span> <span>(</span>ssno<span>::</span>bypass<span>::</span>VirtualQuery<span>((</span><span>void</span><span>*</span><span>)</span>name<span>,</span> <span>&amp;</span>mbi<span>,</span> <span>sizeof</span><span>(</span>mbi<span>)))</span>
</span></span><span><span>            <span>{</span>
</span></span><span><span>                <span>if</span> <span>(</span>mbi<span>.</span>AllocationBase <span>==</span> mod<span>)</span>
</span></span><span><span>                <span>{</span>
</span></span><span><span>                    hashes<span>[</span>ac_fnv64<span>(</span>name<span>)]</span> <span>=</span> std<span>::</span>string<span>(</span>name<span>);</span>
</span></span><span><span>                <span>}</span>
</span></span><span><span>            <span>}</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>void</span> <span>lookup_hash</span><span>(</span>size_t base<span>,</span> size_t hash<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	ac_setbase<span>(</span>base<span>);</span>
</span></span><span><span>
</span></span><span><span>	hashes<span>.</span>clear<span>();</span>
</span></span><span><span>	cache_exports<span>();</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>(</span>hashes<span>.</span>find<span>(</span>hash<span>)</span> <span>==</span> hashes<span>.</span>end<span>())</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		printf<span>(</span><span>&#34;Failed to find hash: 0x%p</span><span>\n</span><span>&#34;</span><span>,</span> hash<span>);</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	printf<span>(</span><span>&#34;0x%p, 0x%p = %s</span><span>\n</span><span>&#34;</span><span>,</span> base<span>,</span> hash<span>,</span> hashes<span>[</span>hash<span>].</span>c_str<span>());</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><ul>
<li>After all of this, it was time to do some manual work.
<ul>
<li>I went in by hand and grabbed the base hashes and function hashes from the decompilation then put those into my program.</li>
<li>Now I was able to tell exactly which APIs the anti-cheat was calling.</li>
</ul>
</li>
</ul>
<p>Here’s how my tool ended up working.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// (lookup_pebhash is the get_module_base function I wrote about further up)
</span></span></span><span><span><span></span>lookup_pebhash<span>(</span><span>0xB8BC6A966753F382u</span><span>,</span> <span>0x7380E62B9E1CA6D6</span><span>);</span> <span>// ntdll
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x6B9D7FEE4A7D71CEu</span>i64<span>,</span> <span>0xE5FAB4B4E649C7A4u</span>i64<span>);</span> <span>// VirtualProtect
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x1592DD0A71569429</span>i64<span>,</span> <span>0xB5902EE75629AA6Cu</span>i64<span>);</span> <span>//NtAllocateVirtualMemory
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x3E4D681B236AE0A0</span>i64<span>,</span> <span>0x3AB0D0D1450DE52D</span>i64<span>);</span> <span>//GetWindowLongA
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x77EF6ADABFA1098F</span>i64<span>,</span> <span>0x94CA321842195A88u</span>i64<span>);</span> <span>//OpenProcess
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0xA3439F4AFAAB52AEu</span>i64<span>,</span> <span>0xE48550DEAB23A8C9u</span>i64<span>);</span> <span>//K32EnumProcessModules
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x2004CA9BE823B79A</span>i64<span>,</span> <span>0x828CC84F9E74E1A0u</span>i64<span>);</span> <span>//CloseHandle
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x423E363D6FEF8CEA</span>i64<span>,</span> <span>0x5B3E9BDB215405F3</span>i64<span>);</span> <span>//K32GetModuleFileNameExW
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x52D5BB326B1FC6B2</span>i64<span>,</span> <span>0x1C2D0172D09B7286</span>i64<span>);</span> <span>//GetWindowThreadProcessId
</span></span></span><span><span><span></span>lookup_hash<span>(</span><span>0x13FA4A203570A0A2</span>i64<span>,</span> <span>0xB8DA7EDECE20A5DCu</span>i64<span>);</span> <span>//GetWindowDisplayAffinity
</span></span></span></code></pre></div><p><img src="https://ssno.cc/example_lookup.png" alt="image info"/></p>
<p>I do want to mention that these hashes aren’t going to be the same in different versions of the game.
Also, this isn’t the only way of beating this hashing technique; these function pointers are stored in global variables; you can simply inspect them and match the virtual address of the function to one of the exported functions from all of the DLLs loaded.</p>
<p>Ok, now we have established that TAC detects API hooking <em>(It only checks functions that it uses, not actually checking all important APIs for hooks, just the ones it’s using)</em>. These are only here to monitor API hooking attempts that would hurt or prevent the anti-cheat from doing its job.</p>
<p>What if there was a hooking method that bypassed their hooking detections?</p>
<h2 id="debug-registers">Debug Registers</h2>
<p>For actual cheaters trying to hook into the game, Arxan has got the code patching covered; cheaters must use non-code patching hooking methods while Arxan is present.
There are a couple of these hooking methods, and I’ll list a few here:</p>
<ul>
<li>Exception hooking - Forcefully triggering an exception and handling it.
<ul>
<li>Exceptions can be triggered in multiple ways.</li>
<li>Modify a global pointer to be a nullptr or invalid memory address.</li>
<li>Modify page access protections to trigger an access exception (Example: PAGE_NOACCESS or PAGE_GUARD).</li>
</ul>
</li>
<li>Debug registers - telling the CPU to break (throw a STATUS_SINGLE_STEP exception) on a specific instruction.
<ul>
<li>These are very powerful; the CPU can break on any or all of these conditions for a given instruction address.
<ul>
<li>Read</li>
<li>Write</li>
<li>Execute</li>
</ul>
</li>
<li>Debug registers are the easiest to use, the most popular, and the easiest to detect!</li>
</ul>
</li>
</ul>
<p>Since debug registers are so popular and powerful, and completely bypass Arxan’s .text patch monitoring, this makes them the perfect hooking technique for Call of Duty games.</p>
<h2 id="heres-how-tac-checks-for-debug-registers">Here’s how TAC checks for debug registers.</h2>
<div><pre tabindex="0"><code data-lang="c++"><span><span>    <span>__forceinline</span> <span>void</span> <span>ac_check_debug_registers</span><span>(</span>HANDLE thread_handle<span>,</span> fn callback<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>        CONTEXT context<span>;</span>
</span></span><span><span>        context<span>.</span>ContextFlags <span>=</span> CONTEXT_FULL<span>;</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> <span>(</span><span>!</span>GetThreadContext<span>(</span>thread_handle<span>,</span> <span>&amp;</span>context<span>))</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>return</span><span>;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>
</span></span><span><span>        <span>if</span> <span>(</span>context<span>.</span>Dr0 <span>||</span> context<span>.</span>Dr1 <span>||</span> context<span>.</span>Dr2 <span>||</span> context<span>.</span>Dr3<span>)</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>          <span>if</span> <span>(</span>GetProcessIdOfThread<span>(</span>thread_handle<span>)</span> <span>!=</span> GetCurrentProcessId<span>())</span>
</span></span><span><span>          <span>{</span>
</span></span><span><span>            callback<span>(</span><span>&#34;debug registers found, but not in our process&#34;</span><span>);</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>          <span>else</span>
</span></span><span><span>          <span>{</span>
</span></span><span><span>            callback<span>(</span><span>&#34;debug registers found inside current process&#34;</span><span>);</span>
</span></span><span><span>          <span>}</span>
</span></span><span><span>
</span></span><span><span>          <span>// the anti-cheat would then jump to the quit functions that I wrote about a little bit further down
</span></span></span><span><span><span></span>          <span>// default will call ac_terminate_process_clear_registers
</span></span></span><span><span><span></span>          <span>// if ZwTerminateProcess was hooked it will jump to ac_close_game2_crash_zeroxzero
</span></span></span><span><span><span></span>        <span>}</span>
</span></span><span><span>    <span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>// access rights that are requested
</span></span></span><span><span><span></span>    <span>__forceinline</span> HANDLE <span>ac_open_thread</span><span>(</span><span>int</span> pid<span>)</span>
</span></span><span><span>    <span>{</span>
</span></span><span><span>      <span>return</span> OpenThread<span>(</span>THREAD_QUERY_INFORMATION <span>|</span> THREAD_GET_CONTEXT<span>,</span> <span>0</span><span>,</span> pid<span>);</span>
</span></span><span><span>    <span>}</span>
</span></span></code></pre></div><ul>
<li>Since debug registers are in the DR0-DR3 registers, you can’t just write some custom assembly to directly read them because these registers are privileged and must be fetched by the Windows kernel or sent to the process by Windows whenever an exception occurs.</li>
</ul>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>; This will throw a STATUS_PRIVILEGED_INSTRUCTION exception
</span></span></span><span><span><span></span><span>mov</span> <span>rax</span><span>,</span> <span>dr0</span>
</span></span><span><span><span>ret</span>
</span></span></code></pre></div><!---
Threads executing in kernel memory detection (broken??)
---

  - Each thread has its own thread context; this context contains many things like the debug registers that I talked about earlier, but it also contains the instruction pointer; this is the current instruction that the thread is executing.
    * TAC has implemented a check to see if any threads are executing in the kernel-reserved memory range on Windows. (I could be wrong about the purpose of this.)
      - I'm not sure how this works, as in all of my testing I was unable to read the kernel thread context from user mode; nonetheless, this is something TAC still attempts to do.

```c++
    __forceinline void ac_loop_threads_find_kernel_thread(callback cb)
    {
    	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);

    	THREADENTRY32 te32{};
    	te32.dwSize = sizeof(te32);

    	do
    	{
    		HANDLE thread_handle = OpenThread(THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION, FALSE, te32.th32ThreadID);

    		if (thread_handle == INVALID_HANDLE_VALUE)
    		{
    			continue;
    		}

    		bool current_proc = te32.th32OwnerProcessID == GetCurrentProcessId();

    		if (!current_proc)
    		{
    			continue;
    		}

    		CONTEXT context;
    		context.ContextFlags = 1048603;

    		if (!GetThreadContext(thread_handle, &context))
    		{
    			continue;
    		}

    		if (context.Rip >= 0x8000000000000000uLL)
    		{
    			cb();
    		}

    		CloseHandle(thread_handle);

    	} while (Thread32Next(snapshot, &te32));
    	CloseHandle(snapshot);
    }
```
-->
<h2 id="driver-signing-enforcement">Driver Signing Enforcement</h2>
<ul>
<li>Windows has a test mode, which is designed for driver development.</li>
<li>This will allow you to bypass the normal Windows restriction on kernel-mode drivers not having valid digital signatures.</li>
<li><em>This is a protection mechanism in place to prevent bad actors from running kernel mode drivers on your system without the proper authorization.</em></li>
<li>TAC will know if you have test mode enabled on Windows, via <strong><em>ntdll!NtQuerySystemInformation</em></strong>. This isn’t going to ban you directly, but this will have your account flagged.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>bool</span> <span>is_test_signing_on</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	SYSTEM_CODEINTEGRITY_INFORMATION sys_cii<span>;</span>
</span></span><span><span>	sys_cii<span>.</span>Length <span>=</span> <span>sizeof</span><span>(</span>sys_cii<span>);</span>
</span></span><span><span>	NTSTATUS status <span>=</span> NtQuerySystemInformation<span>(</span><span>103</span><span>,</span> <span>&amp;</span>sys_cii<span>,</span> <span>static_cast</span><span>&lt;</span>ULONG<span>&gt;</span><span>(</span><span>sizeof</span><span>(</span>sys_cii<span>)),</span> <span>static_cast</span><span>&lt;</span>PULONG<span>&gt;</span><span>(</span><span>NULL</span><span>));</span>
</span></span><span><span>	<span>if</span> <span>(</span>NT_SUCCESS<span>(</span>status<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span> <span>!!</span><span>(</span>sys_cii<span>.</span>CodeIntegrityOptions <span>&amp;</span> <span>/*CODEINTEGRITY_OPTION_TESTSIGN*/</span> <span>0x2</span><span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> <span>false</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>__forceinline</span> <span>void</span> <span>ac_check_test_signing</span><span>(</span>callback cb<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>if</span> <span>(</span>is_test_signing_on<span>())</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    cb<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now we understand some of TAC’s anti-static analysis and debug register detection tactics. We’re going to move on to the more advanced detections implemented into TAC.</p>
<h2 id="how-does-tac-exit-the-process">How does TAC exit the process?</h2>
<ul>
<li>TAC uses two ways of exiting the process; both of them clear the registers, and these are written in inline shellcode.
<ul>
<li>
<p>The first method sets RCX to -1 as it calls NtTerminateProcess.</p>
</li>
<li>
<p>TAC will not use this method if NtTerminateProcess is detected to be hooked.</p>
</li>
<li>
<p>If NtTerminateProcess is hooked, it’ll go to the second one, which jumps to 0x0.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>xor</span>         <span>rax</span><span>,</span> <span>rax</span>  
</span></span><span><span><span>xor</span>         <span>rbx</span><span>,</span> <span>rbx</span>  
</span></span><span><span><span>xor</span>         <span>rcx</span><span>,</span> <span>rcx</span>  
</span></span><span><span><span>dec</span>         <span>rcx</span>  
</span></span><span><span><span>xor</span>         <span>rdx</span><span>,</span> <span>rdx</span>  
</span></span><span><span><span>xor</span>         <span>rsi</span><span>,</span> <span>rsi</span>  
</span></span><span><span><span>xor</span>         <span>rdi</span><span>,</span> <span>rdi</span>  
</span></span><span><span><span>xor</span>         <span>r8</span><span>,</span> <span>r8</span>  
</span></span><span><span><span>xor</span>         <span>r9</span><span>,</span> <span>r9</span>  
</span></span><span><span><span>xor</span>         <span>r10</span><span>,</span> <span>r10</span>  
</span></span><span><span><span>xor</span>         <span>r11</span><span>,</span> <span>r11</span>  
</span></span><span><span><span>xor</span>         <span>r12</span><span>,</span> <span>r12</span>  
</span></span><span><span><span>xor</span>         <span>r13</span><span>,</span> <span>r13</span>  
</span></span><span><span><span>xor</span>         <span>r14</span><span>,</span> <span>r14</span>  
</span></span><span><span><span>xor</span>         <span>r15</span><span>,</span> <span>r15</span>  
</span></span><span><span><span>mov</span>         <span>rsp</span><span>,</span> <span>0x0F8</span>  
</span></span><span><span><span>jmp</span>         <span>qword</span> <span>ptr</span> <span>[</span><span>0x1B607DC7FF0</span><span>]</span>  
</span></span><span><span>
</span></span><span><span><span>; This is not a custom syscall setup; this is a jump to ntdll!NtTerminateProcess.
</span></span></span><span><span><span></span><span>spot_1B607DC7FF0:</span>
</span></span><span><span><span>mov</span>         <span>r10</span><span>,</span> <span>rcx</span>  
</span></span><span><span><span>mov</span>         <span>eax</span><span>,</span> <span>0x2C</span>  
</span></span><span><span><span>test</span>        <span>byte</span> <span>ptr</span> <span>[</span><span>0x7FFE0308</span><span>],</span> <span>1</span>  
</span></span><span><span><span>jne</span>         <span>NtTerminateProcess</span> <span>+</span> <span>0x15</span> <span>(</span><span>0x07FFA7A3CDA75</span><span>)</span>  
</span></span><span><span><span>syscall</span>  
</span></span><span><span><span>ret</span>  
</span></span></code></pre></div><p>Here’s the second method; we can see the same register clearing, and we see a jmp. This jump goes to 0x0, which will crash the process.</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>xor</span>         <span>rax</span><span>,</span> <span>rax</span>  
</span></span><span><span><span>xor</span>         <span>rbx</span><span>,</span> <span>rbx</span>  
</span></span><span><span><span>xor</span>         <span>rcx</span><span>,</span> <span>rcx</span>  
</span></span><span><span><span>xor</span>         <span>rdx</span><span>,</span> <span>rdx</span>  
</span></span><span><span><span>xor</span>         <span>rsi</span><span>,</span> <span>rsi</span>  
</span></span><span><span><span>xor</span>         <span>rdi</span><span>,</span> <span>rdi</span>  
</span></span><span><span><span>xor</span>         <span>r8</span><span>,</span> <span>r8</span>  
</span></span><span><span><span>xor</span>         <span>r9</span><span>,</span> <span>r9</span>  
</span></span><span><span><span>xor</span>         <span>r10</span><span>,</span> <span>r10</span>  
</span></span><span><span><span>xor</span>         <span>r11</span><span>,</span> <span>r11</span>  
</span></span><span><span><span>xor</span>         <span>r12</span><span>,</span> <span>r12</span>  
</span></span><span><span><span>xor</span>         <span>r13</span><span>,</span> <span>r13</span>  
</span></span><span><span><span>xor</span>         <span>r14</span><span>,</span> <span>r14</span>  
</span></span><span><span><span>xor</span>         <span>r15</span><span>,</span> <span>r15</span>  
</span></span><span><span><span>xor</span>         <span>rsp</span><span>,</span> <span>rsp</span>  
</span></span><span><span><span>xor</span>         <span>rbp</span><span>,</span> <span>rbp</span>  
</span></span><span><span><span>jmp</span>         <span>qword</span> <span>ptr</span> <span>[</span><span>0x27E45550036</span><span>]</span> 
</span></span><span><span>
</span></span><span><span><span>; value of 0x27E45550036 = 0x000000000000
</span></span></span></code></pre></div><p>These are hard to recover from since all of the important registers are cleared.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// these are reconstructed to make it readable
</span></span></span><span><span><span></span><span>void</span> <span>ac_terminate_process_clear_registers</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>const</span> <span>auto</span> memory <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>VirtualAlloc<span>(</span>
</span></span><span><span>      <span>nullptr</span><span>,</span> 
</span></span><span><span>      <span>0x8000uLL</span><span>,</span> 
</span></span><span><span>      MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> 
</span></span><span><span>      PAGE_EXECUTE_READWRITE
</span></span><span><span>    <span>));</span>
</span></span><span><span>
</span></span><span><span>	<span>const</span> <span>auto</span> proc_addr <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>unsigned</span> <span>__int64</span><span>&gt;</span><span>(</span>GetProcAddress<span>(</span>
</span></span><span><span>      LoadLibraryA<span>(</span><span>&#34;ntdll.dll&#34;</span><span>),</span> 
</span></span><span><span>      <span>&#34;ZwTerminateProcess&#34;</span>
</span></span><span><span>    <span>));</span>
</span></span><span><span>
</span></span><span><span>	<span>unsigned</span> <span>char</span> terminate_process_shellcode<span>[]</span> <span>=</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor rax, rax
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor rbx, rbx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor rcx, rcx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0xFF</span><span>,</span> <span>0xC9</span><span>,</span> <span>// dec rcx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor rdx, rdx
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor rsi, rsi
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor rdi, rdi
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor r8, r8
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor r9, r9
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor r10, r10
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor r11, r11
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xE4</span><span>,</span> <span>// xor r12, r12
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xED</span><span>,</span> <span>// xor r13, r13
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor r14, r14
</span></span></span><span><span><span></span>		<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor r15, r15
</span></span></span><span><span><span></span>		<span>0x48</span><span>,</span> <span>0xC7</span><span>,</span> <span>0xC4</span><span>,</span> <span>0xF8</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>// mov rsp, 0x0F8
</span></span></span><span><span><span></span>		<span>0xFF</span><span>,</span> <span>0x25</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span>  <span>// jmp QWORD PTR [rip + 0x0]
</span></span></span><span><span><span></span>	<span>};</span>
</span></span><span><span>
</span></span><span><span>	<span>const</span> <span>auto</span> zw_terminate_process_spot <span>=</span> <span>0x320</span><span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>// write the address of ZwTerminateProcess somewhere
</span></span></span><span><span><span></span>	<span>*</span><span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>*&gt;</span><span>(</span>memory <span>+</span> zw_terminate_process_spot<span>)</span> <span>=</span> proc_addr<span>;</span>
</span></span><span><span>
</span></span><span><span>	<span>// calculate the memory offset of where ZwTerminateProcess was written (needs to be   RVA from RIP)
</span></span></span><span><span><span></span>	<span>const</span> <span>auto</span> rva_addy <span>=</span> zw_terminate_process_spot <span>-</span> <span>sizeof</span><span>(</span>terminate_process_shellcode<span>);</span>
</span></span><span><span>
</span></span><span><span>	<span>*</span><span>reinterpret_cast</span><span>&lt;</span>DWORD<span>*&gt;</span><span>(</span><span>&amp;</span>terminate_process_shellcode<span>[</span><span>sizeof</span> <span>(</span>terminate_process_shellcode<span>)</span> <span>-</span> <span>4</span><span>])</span> <span>=</span> rva_addy<span>;</span>
</span></span><span><span>	memcpy<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>memory<span>),</span> terminate_process_shellcode<span>,</span> <span>sizeof</span> <span>(</span>terminate_process_shellcode<span>));</span>
</span></span><span><span>	<span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>(</span><span>*</span><span>)()</span><span>&gt;</span><span>(</span>memory<span>)();</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="cpp"><span><span><span>void</span> <span>ac_close_game2_crash_zeroxzero</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  	<span>const</span> <span>auto</span> memory <span>=</span> <span>reinterpret_cast</span><span>&lt;</span><span>__int64</span><span>&gt;</span><span>(</span>VirtualAlloc<span>(</span>
</span></span><span><span>      <span>nullptr</span><span>,</span> 
</span></span><span><span>      <span>0x40uLL</span><span>,</span> 
</span></span><span><span>      MEM_COMMIT <span>|</span> MEM_RESERVE<span>,</span> 
</span></span><span><span>      PAGE_EXECUTE_READWRITE
</span></span><span><span>    <span>));</span>
</span></span><span><span>
</span></span><span><span>    memset<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>memory<span>),</span> <span>0</span><span>,</span> <span>0x40</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>unsigned</span> <span>char</span> zero_zero_shellcode<span>[]</span> <span>=</span> 
</span></span><span><span>    <span>{</span>
</span></span><span><span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor rax, rax
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor rbx, rbx
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor rcx, rcx
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor rdx, rdx
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor rsi, rsi
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor rdi, rdi
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC0</span><span>,</span> <span>// xor r8, r8
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xC9</span><span>,</span> <span>// xor r9, r9
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xD2</span><span>,</span> <span>// xor r10, r10
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xDB</span><span>,</span> <span>// xor r11, r11
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xE4</span><span>,</span> <span>// xor r12, r12
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xED</span><span>,</span> <span>// xor r13, r13
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xF6</span><span>,</span> <span>// xor r14, r14
</span></span></span><span><span><span></span>    	<span>0x4D</span><span>,</span> <span>0x31</span><span>,</span> <span>0xFF</span><span>,</span> <span>// xor r15, r15
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xE4</span><span>,</span> <span>// xor rsp, rsp
</span></span></span><span><span><span></span>    	<span>0x48</span><span>,</span> <span>0x31</span><span>,</span> <span>0xED</span><span>,</span> <span>// xor rbp, rbp
</span></span></span><span><span><span></span>    	<span>0xFF</span><span>,</span> <span>0x25</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span><span>,</span> <span>0x00</span> <span>// jmp  qword ptr[rip + 0]
</span></span></span><span><span><span></span>    <span>};</span>
</span></span><span><span>
</span></span><span><span>    <span>// this offset will just be to memory thats already 0x00000000
</span></span></span><span><span><span></span>    <span>*</span><span>reinterpret_cast</span><span>&lt;</span>DWORD<span>*&gt;</span><span>(</span><span>&amp;</span>zero_zero_shellcode<span>[</span><span>sizeof</span><span>(</span>zero_zero_shellcode<span>)</span> <span>-</span> <span>4</span><span>])</span> <span>=</span> <span>4</span><span>;</span>
</span></span><span><span>
</span></span><span><span>    memcpy<span>(</span><span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>*&gt;</span><span>(</span>memory<span>),</span> zero_zero_shellcode<span>,</span> <span>sizeof</span> <span>(</span>zero_zero_shellcode<span>));</span>
</span></span><span><span>    <span>reinterpret_cast</span><span>&lt;</span><span>void</span><span>(</span><span>*</span><span>)()</span><span>&gt;</span><span>(</span>memory<span>)();</span>
</span></span><span><span><span>}</span> 
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="detecting-cheat-logging">Detecting Cheat Logging</h2>
<ul>
<li>Oftentimes, internal cheaters will allocate a console using <a href="https://learn.microsoft.com/en-us/windows/console/allocconsole">AllocConsole</a> to print their debug logs to, or even make their menu in it using print statements.
<ul>
<li>The PEB (Process Environment Block) contains information regarding the allocation of a console.
<ul>
<li>The PEB contains a ton of useful information regarding the process. If you want to read more about this <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb">click here</a>; most of this structure is undocumented, but that’ll take you to the MSDN page.</li>
</ul>
</li>
<li>The game knows that there shouldn’t ever be a console window allocated; checking for one is super simple and will catch some people who use this method of logging. Here’s the implementation.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>__forceinline</span> <span>void</span> <span>ac_detect_allocated_console</span><span>(</span>fn callback<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  <span>if</span> <span>(</span>GetConsoleWindow<span>()</span> <span>!=</span> <span>0</span> <span>||</span> NtCurrentPeb<span>()</span> <span>-&gt;</span>ProcessParameters<span>-&gt;</span>ConsoleHandle <span>!=</span> <span>0</span><span>)</span>
</span></span><span><span>  <span>{</span>
</span></span><span><span>    callback<span>();</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
<h2 id="detecting-visuals">Detecting Visuals</h2>
<ul>
<li>
<p>Cheaters need to draw on the screen if they want a working <strong>ESP</strong> or even a <strong>Menu/User Interface</strong>.</p>
<ul>
<li>How do they do this?
<ul>
<li>There are a few ways of drawing on the screen; the most common method for internal cheats is to hook whichever graphics API the game is using and draw their information in there.</li>
<li>Modern Call of Duty games are made with <strong>DirectX 12</strong>.</li>
<li>A common function to hook when wanting to draw things on <strong>DirectX</strong> is <a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present">IDXGISwapChain::Present</a>.</li>
<li>The present function is what presents the rendered game image to the user. The idea is you add your custom data to the image before it’s presented to the user, update the image then present it to the user.</li>
</ul>
</li>
<li>How is this detected?
<ul>
<li>First, we need to understand how these functions are hooked.
<ul>
<li>The <strong>DirectX</strong> functions are inside of the <strong>dxgi</strong> DLL on your computer.</li>
<li>DirectX interfaces hold vtables which will point to the functions inside of dxgi, these vtable indexes will be the same across the versions of windows.</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/dxgi/nn-dxgi-idxgiswapchain">IDXGISwapChain</a> vtable holds the present function.</li>
<li>This can either be directly hooked, or pointer swapped.</li>
</ul>
</li>
<li>Detecting these hooks.
<ul>
<li>Something that can be done is to scan the DXGI present function, but TAC doesn’t currently do this.</li>
<li>TAC checks the present pointer in the vtable.</li>
<li><strong>DirectX 12</strong> introduced command queues; whenever the game is drawing something, it’s from the command queue, a list of draw commands. This is something cheaters will also need if they want to draw.
<ul>
<li>How do cheaters get this command queue?
<ul>
<li>The most common method of grabbing the game’s command queue is to hook another function from the command queue interface, <a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12commandqueue-executecommandlists">ID3D12CommandQueue::ExecuteCommandLists</a>.</li>
<li>Since this is an interface, the methods will have a <strong><em>this</em></strong> pointer passed as the first parameter; in this case, that pointer is the command queue.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Cool information:
<ul>
<li>Many things such as OBS Studio/Streamlabs OBS/Discords game overlay/Steams game overlay actually all do this, while Steam and Discord draw here, things like OBS studio are just here to capture the rendered image (capture the frames) and save them into your recording. This only happens if you use game capture on recording software.</li>
<li>Cheaters can ignore the game, and simply hook into Discord/steam and draw things there if they want to.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="what-about-external-cheats">What about External Cheats?</h2>
<ul>
<li>
<p>External cheats are most likely going to create an overlapped window that covers the width and height of the game window. There are a few ways to detect this; the detection methods heavily rely on Windows APIs and require more effort to implement.</p>
</li>
<li>
<p>TAC loops through all of the windows, checking their <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/extended-window-styles">window style</a> for <strong>WS_EX_LAYERED</strong>  using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlonga">GetWindowLongA</a>; once it finds that, it then compares that window’s rect with the game rect using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowrect">GetWindowRect</a>.</p>
</li>
<li>
<p>After all of that, if the window is over the game’s rect and it is a layered window, the hwnd to that window will be cached, which will later be used for many string checks. This stores a bunch of information and uploads it to their servers.</p>
<p>Here we can see how that works.</p>
<div><pre tabindex="0"><code data-lang="c++"><span><span>GetWindowRect<span>(</span>hwnd<span>,</span> <span>&amp;</span>output_rect<span>);</span>
</span></span><span><span><span>if</span> <span>(</span>output_rect<span>.</span>right <span>&gt;=</span> game_rect_7FF61BBA2F50<span>.</span>left <span>&amp;&amp;</span>
</span></span><span><span>    output_rect<span>.</span>left <span>&lt;=</span> game_rect_7FF61BBA2F50<span>.</span>right <span>&amp;&amp;</span>
</span></span><span><span>    output_rect<span>.</span>bottom <span>&gt;=</span> game_rect_7FF61BBA2F50<span>.</span>top <span>&amp;&amp;</span>
</span></span><span><span>    output_rect<span>.</span>top <span>&lt;=</span> game_rect_7FF61BBA2F50<span>.</span>bottom<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>  min_value <span>=</span> get_min_value<span>(</span>output_rect<span>.</span>left<span>,</span> game_rect_7FF61BBA2F50<span>.</span>left<span>);</span>
</span></span><span><span>  greater_value <span>=</span> get_greater_value<span>(</span>output_rect<span>.</span>right<span>,</span> game_rect_7FF61BBA2F50<span>.</span>right<span>);</span>
</span></span><span><span>  v193 <span>=</span> get_min_value<span>(</span>output_rect<span>.</span>top<span>,</span> game_rect_7FF61BBA2F50<span>.</span>top<span>);</span>
</span></span><span><span>  v195 <span>=</span> get_greater_value<span>(</span>output_rect<span>.</span>bottom<span>,</span> game_rect_7FF61BBA2F50<span>.</span>bottom<span>);</span>
</span></span><span><span>  v76 <span>=</span> <span>(</span><span>float</span><span>)((</span>v193 <span>-</span> v195<span>)</span> <span>*</span> <span>(</span>greater_value <span>-</span> min_value<span>))</span>
</span></span><span><span>      <span>/</span> <span>(</span><span>float</span><span>)((</span>game_rect_7FF61BBA2F50<span>.</span>top <span>-</span> game_rect_7FF61BBA2F50<span>.</span>bottom<span>)</span>
</span></span><span><span>              <span>*</span> <span>(</span>game_rect_7FF61BBA2F50<span>.</span>right <span>-</span> game_rect_7FF61BBA2F50<span>.</span>left<span>));</span>
</span></span><span><span>  <span>if</span> <span>(</span>v76 <span>&gt;=</span> <span>0.5</span> <span>&amp;&amp;</span> cached_window_count <span>&lt;</span> <span>8</span><span>)</span>
</span></span><span><span>    cached_windows<span>[</span>cached_window_count<span>++</span><span>]</span> <span>=</span> hwnd<span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="c++"><span><span>RECT game_rect_7FF61BBA2F50<span>;</span>
</span></span><span><span>game_rect_7FF61BBA2F50 RECT <span>&lt;</span><span>0</span><span>,</span> <span>0</span><span>,</span> <span>780</span>h<span>,</span> <span>438</span>h<span>&gt;</span><span>;</span>
</span></span></code></pre></div><ul>
<li>
<p>We can see 0x780 and 0x438, which represent 1920 by 1080, which was my screen size.
</p>
</li>
<li>
<p>The cached list is handled in another function that checks the window text and its class names.</p>
</li>
<li>
<p>TAC queries the window text using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowtextw">GetWindowTextW</a>.</p>
</li>
<li>
<p>TAC queries the window class name using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getclassnamea">GetClassNameA</a>.</p>
</li>
<li>
<p>Cheat developers can hide their overlapping windows from recording software, and screenshot tools using <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowdisplayaffinity">SetWindowDisplayAffinity</a> with <strong>WDA_EXCLUDEFROMCAPTURE</strong>.</p>
<ul>
<li>This is checked by TAC, and it’s saved into the buffer that will be uploaded to their servers later.
<div><pre tabindex="0"><code data-lang="c++"><span><span>ac_fmt_sprint<span>(</span>v1035<span>,</span> <span>32LL</span><span>,</span> <span>&#34;%lu&#34;</span><span>,</span> display_affinity<span>);</span>
</span></span></code></pre></div></li>
<li>There are a couple more things related to the window that are uploaded as well.
<ul>
<li>The normal window style is also checked; you can find more <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles">here</a>.</li>
<li>TAC checks that the window is visible first before any more processing happens on it.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>TAC also stores the list of modules, including the exe name of the overlapping window.</p>
<ul>
<li>When you do anything in Windows to another process, you need to have permission; Windows has an API that will let you request permission from the system. <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess">OpenProcess</a>
<div><pre tabindex="0"><code data-lang="c++"><span><span>HANDLE process_handle <span>=</span> OpenProcess<span>(</span><span>0x410</span><span>,</span> <span>0LL</span><span>,</span> pid<span>);</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>The first parameter in OpenProcess is the access desired, since this is a bitmask our reversing software will just show us 0x410 by default, but that doesn’t do us any good!</p>
<ul>
<li>This can be figured out with some IDA magic.</li>
<li>Creating a <a href="https://docs.hex-rays.com/user-guide/disassembler/bitfields/bitfields-tutorial">bitmask structure</a> in IDA Pro and setting that as the function declaration’s first parameter helps us out.
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>// these are taken from https://learn.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights
</span></span></span><span><span><span></span><span>enum</span> <span>__bitmask</span> process_access_flags
</span></span><span><span><span>{</span>
</span></span><span><span>  PROCESS_TERMINATE <span>=</span> <span>0x1</span><span>,</span>
</span></span><span><span>  PROCESS_CREATE_THREAD <span>=</span> <span>0x2</span><span>,</span>
</span></span><span><span>  PROCESS_SET_SESSIONID <span>=</span> <span>0x4</span><span>,</span>
</span></span><span><span>  PROCESS_VM_OPERATION <span>=</span> <span>0x8</span><span>,</span>
</span></span><span><span>  PROCESS_VM_READ <span>=</span> <span>0x10</span><span>,</span>
</span></span><span><span>  PROCESS_VM_WRITE <span>=</span> <span>0x20</span><span>,</span>
</span></span><span><span>  PROCESS_DUP_HANDLE <span>=</span> <span>0x40</span><span>,</span>
</span></span><span><span>  PROCESS_CREATE_PROCESS <span>=</span> <span>0x80</span><span>,</span>
</span></span><span><span>  PROCESS_SET_QUOTA <span>=</span> <span>0x100</span><span>,</span>
</span></span><span><span>  PROCESS_SET_INFORMATION <span>=</span> <span>0x200</span><span>,</span>
</span></span><span><span>  PROCESS_QUERY_INFORMATION <span>=</span> <span>0x400</span><span>,</span>
</span></span><span><span>  PROCESS_SUSPEND_RESUME <span>=</span> <span>0x800</span><span>,</span>
</span></span><span><span>  PROCESS_QUERY_LIMITED_INFORMATION <span>=</span> <span>0x1000</span><span>,</span>
</span></span><span><span>  PROCESS_SET_LIMITED_INFORMATION <span>=</span> <span>0x2000</span><span>,</span>
</span></span><span><span><span>};</span>
</span></span></code></pre></div></li>
<li>Here’s the resulting code we get from IDA.</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span>HANDLE handle <span>=</span> OpenProcess<span>(</span>PROCESS_VM_READ <span>|</span> PROCESS_QUERY_INFORMATION<span>,</span> <span>0LL</span><span>,</span> pid<span>);</span>
</span></span></code></pre></div><ul>
<li>As you can see, TAC wants to read the overlapping process’ virtual memory, and it wants to query information about the process.</li>
<li>This is the access level you would expect for enumerating process modules. <a href="https://learn.microsoft.com/en-us/windows/win32/psapi/enumerating-all-processes">example</a>.</li>
</ul>
<ul>
<li>The first thing TAC does with this handle is call <a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-enumprocessmodules">K32EnumProcessModules</a>.</li>
<li>After that, TAC loops through the process modules and gathers the name of each using <a href="https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getmodulefilenameexa">K32GetModuleFileNameExW</a>.</li>
<li>Then the strings are encrypted and stored into the encryption buffer.</li>
</ul>
</li>
<li>
<p>Here’s what the majority of the code looks like.</p>
</li>
</ul>
<div><pre tabindex="0"><code data-lang="c++"><span><span><span>void</span> <span>ac_cached_window</span><span>(</span>HWND hwnd<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>if</span> <span>(</span>hwnd <span>==</span> game_hwnd<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	<span>const</span> <span>auto</span> is_visible <span>=</span> <span>(</span>GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_STYLE<span>)</span> <span>&amp;</span> WS_VISIBLE<span>)</span> <span>!=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>if</span> <span>(</span><span>!</span>is_visible<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	<span>const</span> <span>auto</span> window_style <span>=</span> GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_EXSTYLE<span>);</span>
</span></span><span><span>	<span>const</span> <span>auto</span> is_top_most <span>=</span> <span>(</span>window_style <span>&amp;</span> WS_EX_TOPMOST<span>)</span> <span>!=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>const</span> <span>auto</span> is_layered_window <span>=</span> <span>(</span>window_style <span>&amp;</span> WS_EX_LAYERED<span>)</span> <span>!=</span> <span>0</span><span>;</span> 
</span></span><span><span>	<span>if</span> <span>(</span><span>!</span>is_top_most <span>&amp;&amp;</span> <span>!</span>is_layered_window<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	RECT output_rect<span>;</span>
</span></span><span><span>	GetWindowRect<span>(</span>hwnd<span>,</span> <span>&amp;</span>output_rect<span>);</span>  
</span></span><span><span>	<span>if</span> <span>(</span>output_rect<span>.</span>right <span>&gt;=</span> game_rect<span>.</span>left
</span></span><span><span>	  <span>&amp;&amp;</span> output_rect<span>.</span>left <span>&lt;=</span> game_rect<span>.</span>right
</span></span><span><span>	  <span>&amp;&amp;</span> output_rect<span>.</span>bottom <span>&gt;=</span> game_rect<span>.</span>top
</span></span><span><span>	  <span>&amp;&amp;</span> output_rect<span>.</span>top <span>&lt;=</span> game_rect<span>.</span>bottom<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> min_value_x1 <span>=</span> min<span>(</span>output_rect<span>.</span>left<span>,</span> game_rect<span>.</span>left<span>);</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> max_value_x2 <span>=</span> max<span>(</span>output_rect<span>.</span>right<span>,</span> game_rect<span>.</span>right<span>);</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> min_value_y1 <span>=</span> min<span>(</span>output_rect<span>.</span>top<span>,</span> game_rect<span>.</span>top<span>);</span>
</span></span><span><span>	    <span>const</span> <span>auto</span> max_value_y2 <span>=</span> max<span>(</span>output_rect<span>.</span>bottom<span>,</span> game_rect<span>.</span>bottom<span>);</span>  
</span></span><span><span>	    <span>const</span> <span>auto</span> difference_center <span>=</span> 
</span></span><span><span>	      <span>static_cast</span><span>&lt;</span><span>float</span><span>&gt;</span><span>((</span>min_value_y1 <span>-</span> max_value_y2<span>)</span> <span>*</span> <span>(</span>max_value_x2 <span>-</span> min_value_x1<span>))</span>
</span></span><span><span>	      <span>/</span> <span>static_cast</span><span>&lt;</span><span>float</span><span>&gt;</span><span>((</span>game_rect<span>.</span>top <span>-</span> game_rect<span>.</span>bottom<span>)</span>
</span></span><span><span>	            <span>*</span> <span>(</span>game_rect<span>.</span>right <span>-</span> game_rect<span>.</span>left<span>));</span>  
</span></span><span><span>		<span>if</span> <span>(</span>difference_center <span>&gt;=</span> <span>0.5</span> <span>&amp;&amp;</span> cached_window_count <span>&lt;</span> <span>8</span><span>)</span>
</span></span><span><span>		<span>{</span>    
</span></span><span><span>			cached_windows<span>[</span>cached_window_count<span>++</span><span>]</span> <span>=</span> hwnd<span>;</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span> 
</span></span><span><span><span>void</span> <span>ac_log_cached_window_process</span><span>(</span><span>unsigned</span> <span>int</span> pid<span>,</span> <span>char</span><span>*</span> encrypted_string_buffer<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>const</span> HANDLE process_handle <span>=</span> OpenProcess<span>(</span>PROCESS_VM_READ <span>|</span> PROCESS_QUERY_INFORMATION<span>,</span> <span>0LL</span><span>,</span> pid<span>);</span>
</span></span><span><span>	<span>if</span> <span>(</span>process_handle <span>==</span> INVALID_HANDLE_VALUE<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>return</span><span>;</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	DWORD lpcbNeeded <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	HMODULE modules<span>[</span><span>1024</span><span>];</span>
</span></span><span><span>	<span>if</span> <span>(</span>K32EnumProcessModules<span>(</span>process_handle<span>,</span> modules<span>,</span> <span>0x2000LL</span><span>,</span> <span>&amp;</span>lpcbNeeded<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>for</span> <span>(</span><span>auto</span> current_module_index <span>=</span> <span>0</span><span>;</span> <span>;</span> <span>++</span>current_module_index<span>)</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>if</span> <span>(</span>current_module_index <span>&gt;=</span> lpcbNeeded <span>/</span> <span>8uLL</span><span>)</span>
</span></span><span><span>				<span>break</span><span>;</span>  
</span></span><span><span>			<span>const</span> <span>auto</span> current_module <span>=</span> modules<span>[</span>current_module_index<span>];</span>
</span></span><span><span>			WCHAR wide_module_name<span>[</span><span>260</span><span>];</span>  
</span></span><span><span>			<span>if</span> <span>(</span>K32GetModuleFileNameExW<span>(</span>process_handle<span>,</span> current_module<span>,</span> wide_module_name<span>,</span> <span>260LL</span><span>))</span>
</span></span><span><span>			<span>{</span>
</span></span><span><span>				<span>char</span> ascii_module_name<span>[</span><span>1568</span><span>];</span>
</span></span><span><span>				WideCharToMultiByte<span>(</span><span>65001LL</span><span>,</span> <span>0LL</span><span>,</span> wide_module_name<span>,</span> <span>0xFFFFFFFFLL</span><span>,</span> ascii_module_name<span>,</span> <span>1560</span><span>,</span> <span>0LL</span><span>,</span> <span>0LL</span><span>);</span> 
</span></span><span><span>				ac_string_encrypt<span>(</span>encrypted_string_buffer<span>,</span> ascii_module_name<span>);</span>
</span></span><span><span>			<span>}</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	CloseHandle<span>(</span>process_handle<span>);</span>
</span></span><span><span><span>}</span> 
</span></span><span><span><span>void</span> <span>ac_handle_window</span><span>(</span>HWND hwnd<span>,</span> <span>char</span><span>*</span> encrypted_string_thing<span>)</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// tons of string encryption stuff all over here  
</span></span></span><span><span><span></span>	<span>wchar_t</span> window_text_WIDE<span>[</span><span>512</span><span>]{</span><span>0</span><span>};</span>
</span></span><span><span>	GetWindowTextW<span>(</span>hwnd<span>,</span> window_text_WIDE<span>,</span> <span>512LL</span><span>);</span>  
</span></span><span><span>	<span>char</span> window_text_asci<span>[</span><span>3072</span><span>]{</span><span>0</span><span>};</span>
</span></span><span><span>	WideCharToMultiByte<span>(</span><span>65001LL</span><span>,</span> <span>0LL</span><span>,</span> window_text_WIDE<span>,</span> <span>0xFFFFFFFFLL</span><span>,</span> window_text_asci<span>,</span> <span>3072</span><span>,</span> <span>0LL</span><span>);</span> 
</span></span><span><span>	<span>char</span> window_class_name<span>[</span><span>256</span><span>]{</span><span>0</span><span>};</span>
</span></span><span><span>	GetClassNameA<span>(</span>hwnd<span>,</span> window_class_name<span>,</span> <span>256LL</span><span>);</span>  
</span></span><span><span>	RECT window_rect<span>;</span>
</span></span><span><span>	GetWindowRect<span>(</span>hwnd<span>,</span> <span>&amp;</span>window_rect<span>);</span>  
</span></span><span><span>	<span>const</span> <span>auto</span> window_gwl_style <span>=</span> GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_STYLE<span>);</span>
</span></span><span><span>	<span>const</span> <span>auto</span> window_gwl_ex_style <span>=</span> GetWindowLongA<span>(</span>hwnd<span>,</span> GWL_EXSTYLE<span>);</span> 
</span></span><span><span>	DWORD display_affinity <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	GetWindowDisplayAffinity<span>(</span>hwnd<span>,</span> <span>&amp;</span>display_affinity<span>);</span>  
</span></span><span><span>	<span>// adds these strings to the buffer directly
</span></span></span><span><span><span></span>	ac_string_encrypt<span>(</span>encrypted_string_thing<span>,</span> window_text_asci<span>);</span>
</span></span><span><span>	ac_string_encrypt<span>(</span>encrypted_string_thing<span>,</span> window_class_name<span>);</span> 
</span></span><span><span>	<span>// store info
</span></span></span><span><span><span></span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>left<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>top<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>right<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_rect<span>.</span>bottom<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_gwl_style<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%li&#34;</span><span>,</span> window_gwl_ex_style<span>);</span>
</span></span><span><span>	ac_fmt_sprint_encrypt<span>(</span>encrypted_string_thing<span>,</span> <span>32</span><span>,</span> <span>&#34;%lu&#34;</span><span>,</span> display_affinity<span>);</span> 
</span></span><span><span>	DWORD pid <span>=</span> <span>0</span><span>;</span>
</span></span><span><span>	<span>if</span> <span>(</span>GetWindowThreadProcessId<span>(</span>hwnd<span>,</span> <span>&amp;</span>pid<span>))</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		ac_log_cached_window_process<span>(</span>pid<span>,</span> encrypted_string_thing<span>);</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>else</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// assuming encrypted failure message, logs the current process id instead.
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span><span>}</span> 
</span></span><span><span><span>void</span> <span>ac_process_cached_windows</span><span>()</span>
</span></span><span><span><span>{</span>
</span></span><span><span>	<span>// lots of encryption stuff here
</span></span></span><span><span><span></span>	<span>char</span><span>*</span> encrypted_string_thing <span>=</span> <span>(</span><span>char</span><span>*</span><span>)</span>malloc<span>(</span><span>0x40000</span><span>);</span>
</span></span><span><span>	<span>for</span> <span>(</span><span>unsigned</span> <span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cached_window_count<span>;</span> <span>++</span>i<span>)</span>
</span></span><span><span>	<span>{</span>
</span></span><span><span>		<span>// lots of encryption stuff here, and ptr modifications
</span></span></span><span><span><span></span>		ac_handle_window<span>(</span>cached_windows<span>[</span>i<span>],</span> encrypted_string_thing<span>);</span>
</span></span><span><span>	<span>}</span> 
</span></span><span><span>	<span>// lots of encryption stuff here, and ptr modifications
</span></span></span><span><span><span></span>	ac_send_data_to_server<span>(</span>encrypted_string_thing<span>);</span>
</span></span><span><span>	free<span>(</span>encrypted_string_thing<span>);</span>
</span></span><span><span>	<span>// lots of encryption stuff here
</span></span></span><span><span><span></span><span>}</span>
</span></span></code></pre></div></li>
</ul>
<ul>
<li>Example data. TAC will format in json with modules hashed.
<div><pre tabindex="0"><code data-lang="cpp"><span><span>NVIDIA GeForce Overlay <span>-</span> Window Text 
</span></span><span><span>CEF<span>-</span>OSC<span>-</span>WIDGET <span>-</span> Window Class
</span></span><span><span><span>0</span> <span>-</span> Left
</span></span><span><span><span>0</span> <span>-</span> Top
</span></span><span><span><span>2560</span> <span>-</span> Right
</span></span><span><span><span>1440</span> <span>-</span> Bottom
</span></span><span><span><span>-</span><span>1811939328</span> <span>-</span> window_gwl_style
</span></span><span><span><span>134742184</span> <span>-</span> window_gwl_ex_style
</span></span><span><span><span>0</span> <span>-</span> display_affinity  
</span></span><span><span>Loaded <span>Modules</span><span>:</span> 
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>NVIDIA Share<span>.</span>exe
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>ntdll<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>KERNEL32<span>.</span>DLL
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>KERNELBASE<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>SHLWAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>msvcrt<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>WS2_32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>urlmon<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>RPCRT4<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>CRYPT32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>ucrtbase<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>USER32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>win32u<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>iertutil<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>GDI32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>srvcli<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>combase<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>gdi32full<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>msvcp_win<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>sechost<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>netutils<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>advapi32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>SHELL32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>shcore<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>ole32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>OLEAUT32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>libcef<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>WINTRUST<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>wlanapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>COMDLG32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dxgi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>IPHLPAPI<span>.</span>DLL
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>IMM32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>UxTheme<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>CRYPTUI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>MSIMG32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>WINMM<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>d3d11<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>Secur32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>NETAPI32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>d3d9<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>bcrypt<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>OLEACC<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dwmapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>WTSAPI32<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>ShadowPlay<span>\</span>nvspapi64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>ntmarta<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NvContainer<span>\</span>libprotobuf<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>MSVCP140<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>VCRUNTIME140<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>VCRUNTIME140_1<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>ShadowPlay<span>\</span>IpcCommon64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NvContainer<span>\</span>MessageBus<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>NSI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>MSCTF<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>NLAapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dhcpcsvc6<span>.</span>DLL
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>DNSAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>WINSTA<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>clbcatq<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>MMDevApi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>mscms<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>ColorAdapterClient<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>Windows<span>.</span>UI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>WindowManagementAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>TextInputFramework<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>InputHost<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>wintypes<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>twinapi<span>.</span>appcore<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>CoreMessaging<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>CoreUIComponents<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>twinapi<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>apphelp<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>cef<span>\</span>common<span>\</span>OverClocking<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>dependencies<span>\</span>CrimsonUtil<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>POWRPROF<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>UMPDC<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Program Files<span>\</span>NVIDIA Corporation<span>\</span>NVIDIA GeForce Experience<span>\</span>cef<span>\</span>share<span>\</span>MessageBusRouter<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>nvapi64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>SETUPAPI<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>FvSDK_x64<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>system32<span>\</span>mswsock<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>rasadhlp<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>System32<span>\</span>fwpuclnt<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>xinput1_4<span>.</span>dll
</span></span><span><span><span>C</span><span>:</span><span>\</span>Windows<span>\</span>SYSTEM32<span>\</span>dxcore<span>.</span>dll
</span></span></code></pre></div></li>
</ul>
<!---
Dvar Modification Detection
---

- Call of Duty has developer variables that control many things in the game such as gravity, speed, and enabling cheat mode to use developer commands (it looks like those developer commands don't exist in the latest version).
- It looks like this is checking for expected values for the current session mode, possibly checking the values the Dvar was initialized with, as most Dvars generally aren't expected to change during runtime. Anyway, I'm not exactly 100% sure on this, but whatever this is, it's being checked by TAC. 
```c++
void ac_detect_modified_dvar_bool(__int64 dvar, fn callback)
{
  // dvar does not have an encrypted value
  if (*(DWORD*)(dvar + 24) != 1)
  {
    return;
  }

  DWORD current_mode_index = 0;

  const auto dvar_flag = *(DWORD*)(dvar + 28);
  if ((dvar_flag & 0x800) == 0 || (current_mode_index = LobbyBase_GetMainMode(), current_mode_index == 4))
    current_mode_index = 0;

  const auto dvar_mode_indirect_ptrs = *(__int64*)(dvar + 16);
  const auto current_dvar_for_mode = dvar_mode_indirect_ptrs + 96LL * current_mode_index;
  const auto encrypted_dvar_value = *(__int64*)(current_dvar_for_mode + 24);

  const auto decrypted = (bool)dvar_decrypt_value(encrypted_dvar_value);
  if (decrypted != *(_BYTE *)current_dvar_for_mode)
  {
    callback();
  }
}
```
-->














    
    
  </article>

    </div></div>
  </body>
</html>
