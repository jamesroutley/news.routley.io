<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prose.nsood.in/linux-from-windows-installer">Original</a>
    <h1>How to install Linux from a Windows installer</h1>
    
    <div id="readability-page-1" class="page"><section>
		<p>A few days ago, I made this relatively-popular post on my Fediverse account, which had a picture of a Windows installer offering to install Alpine Linux:</p>

<p>And a day or two after that, I posted a YouTube video showing the entire install process from start to finish:</p>
<iframe src="https://www.youtube.com/embed/mJwueWvZRG8?si=ykHkDfNNBdYmpSzm" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe>
<p>Countless<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> people have suggested that I should write a blog post about how I did this, so here we go.</p>
<h3>Step 1: Install Linux on an NTFS partition</h3>
<p>This is actually pretty easy these days! You want to pick a Linux distribution that will let you mount partitions by hand and then uncritically install to those mountpoints without questioning your decisions. Two Linux distributions that I’m aware of that will let you do this are Arch Linux and Alpine Linux.</p>
<h4>The partition scheme</h4>
<p>This is approximately what the partitioning scheme looks like:</p>
<ol>
<li>
<p>We are using UEFI/GPT. Presumably you could make this work with legacy boot/MBR, but that would require you to somehow install the grub boot sector from Windows. I don’t know how to do that.</p>
</li>
<li>
<p>The first partition is an EFI partition, about 100MB in size. Your Linux distributions may want you to create bigger partitions, but the Windows installer will only create a 100MB partition so you’re stuck with this size anyway. This is formatted as FAT32, and mounted at <code>/boot</code> the usual way.</p>
</li>
<li>
<p>The second partition is a 16MB partition that we don’t need to use, but need to correctly offset the partition numbers, since the Windows installer will create a 16MB partition between the EFI partition and the system partition for some reason.</p>
</li>
<li>
<p>The third partition is your root filesystem, filling up the rest of the disk. This is formatted as NTFS, mounted at <code>/</code> using the <code>ntfs3</code> partition type and the <code>acl</code> and <code>windows_names</code> mount options. The <code>acl</code> flag enables the driver to use POSIX ACLs (think: file permissions), and the <code>windows_names</code> flag prevents the creation of files that would not work on a Windows computer (say, anything that contains a <code>:</code> or is named <code>con</code>).</p>
</li>
</ol>
<h4>Making the partitions and installing</h4>
<p>Using the <a href="https://docs.alpinelinux.org/user-handbook/0.1a/Installing/manual.html">Alpine semi-automatic installation guide</a> as a reference, you might create your partitions like so:</p>
<pre><code>// ntfs-3g-progs is required for mkfs.ntfs, which does not ship on 
// the alpine live iso for some reason
# apk add ntfs-3g-progs parted
# alias p=&#34;parted -sa optimal /dev/sda&#34;
# p mklabel gpt
# p mkpart p 0M 100M
# p mkpart p 100M 116M
# p mkpart p 116M 100%
# p set 1 esp
// required so Windows will detect this as a valid NTFS partition
// later
# p set 3 msftdata
# mkfs.vfat -F32 /dev/sda1
# mkfs.ntfs -Q /dev/sda3
# mount -t ntfs3 -o acl,windows_names /dev/sda3 /mnt
# mkdir /mnt/boot
# mount /dev/sda1 /mnt/boot
</code></pre>
<p>After that, you simply proceed with the installation as normal. At this point, if you’re using Arch Linux, your <code>pacstrap</code> command will fail, because <code>pacman</code> expects to be able to create files with <code>:</code>s in the name, and as we discussed, that’s illegal. So, uh, try not to use a Linux distro that relies on the ability to do that. The rest of this guide will assume you’re installing Alpine.</p>
<h4>Getting the system to boot</h4>
<p>While Alpine correctly adds <code>rootfstype=ntfs3</code> to your kernel cmdline, for some reason, as of writing, the initramfs it generates does not include the <code>ntfs3</code> kernel module. Also, the Alpine installer will generate an <code>fstab</code> that uses UUIDs to identify partitions. Since we’ll be relying on the partitions created by the Windows installer, which will have fresh UUIDs, we need to change the <code>fstab</code> to use the ol&#39; unreliable drive names instead.</p>
<p>So after you’re done installing, open <code>/mnt/etc/fstab</code> and change the first column of the EFI partition to say <code>/dev/sda1</code>, and the first column of the root partition to say <code>/dev/sda3</code>.</p>
<p>Next, we need to add <code>ntfs3</code> to the initramfs. For that, install the <code>mkinitfs</code> package on the live environment, create a file <code>/mnt/etc/mkinitfs/features.d/ntfs3.modules</code> that contains the text <code>kernel/fs/ntfs3</code>, and make sure that <code>/mnt/etc/mkinitfs/mkinitfs.conf</code>’s <code>features</code> line contains the <code>ntfs3</code> feature.</p>
<blockquote>
<p>Side note: At the time of writing, you need to open <code>/sbin/mkinitfs</code> in a text editor and prefix the <code>sysconfdir</code> variable at the top of the file with <code>/mnt</code>, since <code>mkinitfs</code>’s <code>-b</code> flag doesn’t apply to that variable for some reason. <a href="https://gitlab.alpinelinux.org/alpine/mkinitfs/-/issues/60">I’ve filed a bug report for this</a> so hopefully that can be fixed and we can all start installing Alpine Linux to NTFS partitions as <del>God</del> Gates intended.</p>
</blockquote>
<p>After that, running <code>mkinitfs -b /mnt -f /mnt/etc/fstab 6.6.28-0-lts</code> should regenerate your initramfs in a way that works with our shenanigans. Replace the kernel version string with whatever’s there in <code>/mnt/lib/modules</code>.</p>
<p>Finally, we need to tell grub to stop using UUIDs as well. Open <code>/mnt/boot/grub/grub.cfg</code>, find the Alpine Linux menu entry, replace the line <code>search ... --set root &lt;UUID of the EFI partition&gt;</code> with <code>set root=&#39;hd0,gpt1&#39;</code> (that line may already exist, so let it be if so), and change the <code>linux ... root=UUID=&lt;UUID of root partition&gt; ...</code> line to say <code>root=/dev/sda3</code> instead.</p>
<p>There’s probably a better way to do this by changing <code>/mnt/etc/default/grub</code> and regenerating the config using <code>grub-mkconfig</code> but I don’t understand how that works and so this is what I did.</p>
<h4>Behold the monster</h4>
<p>Now, unmount <code>/mnt/boot</code> and <code>/mnt</code>, and you should be ready to reboot into your new Alpine installation! Unmounting is very important since if the dirty bit is set on an NTFS partition (which it is while it is mounted), <code>ntfs3</code> will refuse to mount it read-write until you run <code>chkdsk</code> on it from a Windows system or <code>ntfsfix</code> on it from a Linux system with <code>ntfs-3g-progs</code>. You do not want your root partition to be mounted read-only, it makes life hard.</p>
<p>After verifying that it does boot, we can move on to the hard part.</p>
<h3>Step 2: Stuff Linux into a WIM file</h3>
<p>This section (and transitively, the rest of this article) was motivated by the following exchange on Discord about the Windows installer:</p>
<figure>
<img src="https://prose.nsood.in/img/linux-from-windows-installer/discord-exchange.png" alt="A screenshot of a Discord conversation. chompxchg asks if you could shove a Linux distro into a WIM. Luna laughs. tendstofortytwo wonders if the USB boot stage of the installer does anything other than extracting the WIM, and if you could install Linux on an NTFS partition. chompxchg points out that at the very least the WIM could contain a Linux squashfs, and that nothing since the 2000s has used the Rock Ridge extensions. Luna notes that the Windows installer UI basically just runs DISM to extract the WIM file and bcdboot to make the partition bootable, on top of the actual disk partitioning."/>
</figure>
<p>For context, a WIM (Windows Image) file is a compressed storage format used by Microsoft in the Windows installer. Think of it as a fancy ZIP file that the installer extracts onto your hard drive. A single WIM file can contain multiple images, and the Windows installer can pick which image it wants to install, either based on your product key, or what edition you choose during setup.</p>
<p>Our goal, then, is to add an image to the Windows installer’s WIM file (<code>sources\install.wim</code> in your Windows ISO/USB) whose contents are our Linux installation.</p>
<h4>Laying out the plan</h4>
<p>Creating a WIM file with our Linux installation is easy — Microsoft themselves provide tools for you to create your own WIM files, using a tool called DISM<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> (Deployment Image Service and Management tool). I’ve been using a convenient GUI frontend for DISM called <a href="https://www.autoitconsulting.com/site/software/gimagex/">GImageX</a>, but if you’re a Microsoft purist you could just use DISM directly for the same effect.</p>
<p>The hard part is making Linux bootable. <code>bcdboot</code> does not know what a Linux is. It only knows how to make Windows bootable. I thought of solving this problem by replacing <code>bcdboot</code> in the Windows setup with something that installs GRUB, but that felt against the spirit of the whole thing and also kinda hard. Instead, I came up with the following strategy:</p>
<ol>
<li>Install a copy of the Windows Preinstallation Environment (WinPE) on the same rootfs as Linux, putting them both in the same WIM image</li>
<li>Have the Windows installer make WinPE bootable and the computer reboot into WinPE after the first phase of Windows setup</li>
<li>Have WinPE make the necessary adjustments to make Linux bootable, and reboot into Linux</li>
</ol>
<h4>Meet the Windows Preinstallation Environment</h4>
<p>WinPE is made freely available by Microsoft as part of the Windows Assessment and Deployment Kit, and <a href="https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/winpe-intro?view=windows-11">Microsoft even provides instructions</a> on how to download WinPE, customize it for your purposes, and use it in your custom applications. The only thing they disallow you from doing is using it as a general-purpose OS, but that’s fine, since we’re not doing that.</p>
<blockquote>
<p>Side note: You will need to use Windows to follow the steps below, since the Windows ADK is not available for other platforms. You may have luck with obtaining a copy of WinPE through some other means and using <code>wimlib-imagex</code> to capture and apply your WIM files from within Linux, but I found that that tool would happily generate files from partitions that cause Windows to choke — which are useless since we’ll be using them in the Windows setup or in WinPE, both of which would also choke on them.</p>
</blockquote>
<p>After installing the Windows ADK and the WinPE addons, open the Deployment and Imaging Tools Environment from the Start menu as an administrator, and run the following command to get a working copy of WinPE.</p>
<pre><code>&gt; copype amd64 c:\pe_amd64
</code></pre>
<p>This will dump a copy of a WIM file containing Windows PE in <code>C:\pe_amd64\media\sources\boot.wim</code>. Apply this image to the drive containing your Linux rootfs, either using the <a href="https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/dism-image-management-command-line-options-s14?view=windows-11#apply-image"><code>Dism /Apply-Image</code></a> command or using the Apply tab in GImageX. The Linux rootfs drive is <code>E:\</code> in this screenshot:</p>
<figure>
<img src="https://prose.nsood.in/img/linux-from-windows-installer/gimagex-apply-winpe.png" alt="GImageX open at the Apply tab, with the source pointing to the WinPE boot.wim and the destination as the E: drive"/>
</figure>
<p>Now that we have WinPE, we can make it do our bidding.</p>
<h4>Making Linux bootable</h4>
<p>The great thing about UEFI boot is that there doesn’t need to be any magic bootcode in the first 512 bytes of the hard drive. You <em>can</em> inject magic UEFI boot entries into the firmware (Windows will inject one called “Windows Boot Manager”, and grub will inject one with whatever name you pass in the <code>--bootloader-id</code> flag while running <code>grub-install</code>), but you don’t have to. If you boot from a hard drive directly, without the help of any magic boot entry, the UEFI will simply read <code>efi\boot\bootx64.efi</code> from the EFI partition in that drive and run it.</p>
<p><code>bcdboot</code> will put a file there that will load Windows, in addition to creating the UEFI entry. And if you specify <code>--removable</code> while running <code>grub-install</code>, grub will also put a file there that will load grub and read <code>grub/grub.cfg</code> from the EFI partition. Conveniently, Alpine specifies <code>--removable</code>, so no magic UEFI entries to worry about creating.</p>
<p>Recall that when we installed Linux, we made <code>/boot</code> our EFI partition. So all we need to do to make Linux bootable from WinPE is to drop into the EFI partition the files that Alpine put in <code>/boot</code>. It’ll drop the <code>efi\boot\bootx64.efi</code> in place, and that will make it so that booting from the hard drive will boot grub, which will load Alpine.</p>
<p>To do this, first, we need to save a copy of the Linux EFI partition. In Windows, run the <code>diskpart</code> command<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, and run the following commands in the <code>diskpart</code> prompt:</p>
<pre><code>&gt; list disk
// note N, the disk number of your Linux drive
&gt; select disk N
&gt; select partition 1
&gt; assign letter=S
</code></pre>
<p>This will make the Linux EFI partition available as <code>S:\</code> on Windows. Once that’s done, you can use the <a href="https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/dism-image-management-command-line-options-s14?view=windows-11#capture-image"><code>Dism /Capture-Image</code></a> command or the “Capture” tab in GImageX to capture the <code>S:\</code> drive as <code>efi.wim</code> on your Linux rootfs.</p>
<figure>
<img src="https://prose.nsood.in/img/linux-from-windows-installer/gimagex-capture-efi.png" alt="GImageX open at the Capture tab, with the source pointing to the S: drive and the destination as efi.wim in the E: drive"/>
<figcaption>The Name and Description fields are not important, for now.</figcaption>
</figure>
<p>Now that we have the contents of the EFI partition, we just need to get WinPE to apply them. Conveniently, the default build of WinPE simply executes <code>\Windows\System32\startnet.cmd</code> on startup, so we can make that file do what we want.</p>
<p>Open <code>E:\Windows\System32\startnet.cmd</code> in Notepad as administrator. It should already have a line that says <code>wpeinit</code> in it — as the name suggests, that initializes a WinPE environment. I have no idea if it’s necessary, but it doesn’t hurt so I just left it in there. Add the following lines:</p>
<pre><code>diskpart /s mount-efi.txt
dism /Apply-Image /ImageFile:&#34;C:\efi.wim&#34; /Index:1 /ApplyDir:S:\
bcdedit /delete {bootmgr} /f
exit
</code></pre>
<p>The second line should be fairly self-explanatory — we’re applying the EFI image we captured to the <code>S:\</code> drive, which presumably is where our EFI partition is. The first line is what we use to put it there. By default, EFI partitions are not assigned a drive letter, but as we did above, you can use <code>diskpart</code> to give them one. The <code>/s</code> flag allows you to give a script to execute to <code>diskpart</code> rather than it reading commands from the terminal. Create a file called <code>mount-efi.txt</code> in the <code>System32</code> folder, and give it the following contents to mount the EFI partition:</p>
<pre><code>select disk 0
select partition 1
assign letter=S
exit
</code></pre>
<p>The third line we added in <code>startnet.cmd</code> deletes the magic UEFI boot entry that the Windows installer creates to boot Windows. This entry has a higher precedence than booting directly from the hard drive, so we want to delete it to boot into grub like we want.</p>
<p>And that should be it! Now, booting into our Linux rootfs will start a copy of WinPE, which will render itself unbootable and make Linux bootable in its stead, then reboot.</p>
<h4>One more thing</h4>
<p>This took me three days of headbanging, trial and error, giving up, retrying, and more, to figure out. You could capture the Linux rootfs into a WIM file at this point, and put it into a Windows ISO and boot from it. The installer will appear to run successfully, until the installer asks you for a product key and you say you don’t have one. Then you’ll see this screen:</p>
<figure>
<img src="https://prose.nsood.in/img/linux-from-windows-installer/windows-setup-eula-error.png" alt="The Windows installer, running in a virtual machine titled, &#39;Can a Windows ISO and a Linux Installation Really&#39;. It&#39;s displaying an error message: &#39;Windows cannot find the Microsoft Software License terms. Make sure the installation sources are valid and restart the installation.&#39;"/>
<figcaption>Typical Microsoft behavior.</figcaption>
</figure>
<p>It turns out that the Windows installer will read the EULA out from within the WIM file, and from within the specific image you chose. It will look for this EULA in <code>\Windows\System32\[Locale]\Licenses\[Channel]\[Edition]\license.rtf</code>. The locale is the language and country code, like <code>en-US</code>, the channel is one of <code>_Default</code>, <code>OEM</code>, or <code>Volume</code>, and the <code>Edition</code> is set for the image by the software that captured your WIM file. I <em>thought</em> that this corresponded to the SKU dropdown in GImageX, but that seems to not be the case, it seems to instead be auto-detected by DISM. The channel for WinPE is, well, <code>WindowsPE</code>.</p>
<p>So download a copy of the <a href="https://www.gnu.org/licenses/old-licenses/gpl-2.0.rtf">GNU General Public License v2.0 in RTF format</a>, open it in WordPad to set the font to Segoe UI so that it renders properly, and then save it as <code>E:\Windows\System32\en-US\Licenses\WindowsPE\_Default\license.rtf</code>, where <code>E:</code> is your Linux rootfs. You may also have to populate the <code>OEM</code> and <code>Volume</code> directories — I’m not sure which one the installer read, since I populated all three in my testing.</p>
<h4>The capture</h4>
<p>Now, we can use <code>Dism /Capture-Image</code> or GImageX’s Capture tab to capture the Linux rootfs into your Windows setup. Copy the contents of a Windows ISO into a convenient folder (I used <code>C:\win10</code> since I was using a Windows 10 ISO), and capture your Linux rootfs drive into the <code>sources\install.wim</code> in that folder. Use the “append” mode if you want to keep the existing Windows images in the WIM file, or “create” mode if you want to overwrite the file entirely and only be able to install Linux.</p>
<figure>
<img src="https://prose.nsood.in/img/linux-from-windows-installer/gimagex-capture-efi.png" alt="GImageX open at the Capture tab, with the source pointing to the E: drive and the destination as install.wim in the Windows installer directory. The name and description fields are all set to &#39;Alpine Linux&#39;."/>
<figcaption>This is where the Name and Description fields become important.</figcaption>
</figure>
<p>And that’s it! The Windows installer in that directory will now be able to install Alpine Linux. Or rather, it will be able to install a copy of Windows PE that incidentally has an entire installation of Alpine Linux embedded in it, and whose only job is to make that copy of Alpine Linux bootable. Same thing.</p>
<p>You can turn this folder into a bootable ISO using the <code>oscdimg.exe</code> command provided in the Windows ADK. Instructions for doing that are in <a href="https://www.elevenforum.com/t/create-custom-windows-11-iso-file.443/">this wonderful ElevenForum post</a>. I’m so glad I found that post, because I have no idea how anyone would be expected to figure out those magic value in that command. In case the forum post goes down, there’s an archive of that URL in the Wayback Machine.</p>
<h3>Step 3: Profit?</h3>
<p>At this point, you should be able to boot the ISO and install Alpine Linux using the Windows installer onto a blank hard drive. Note that I do not recommend using this installer for anything important, for various reasons:</p>
<ul>
<li>The installer is <em>incredibly</em> fragile. I basically hardcoded the disk and partition layouts into the Linux installation, as well as the <code>diskpart</code> commands that WinPE runs. This will only work for installing to the first hard drive in a computer when it is completely blank before the Windows installer touches it. And if the installer changes the partition layout it creates on a blank hard drive, it’s over. For the record, the installer I used was the Windows 10 22H2 ISO from the Microsoft website.</li>
<li>The WIM capture does not preserve UNIX file permissions, so while the installed copy of Linux boots, you will need to fix permissions for the entire installation afterwards somehow.</li>
<li>The grub changes are very hacky and I don’t know if they’ll survive an update.</li>
<li>Using NTFS for your Linux rootfs is honestly just a really bad time. As I mentioned before, if the dirty bit is set that will make your entire rootfs read-only, making normal use of the computer impossible until you boot from a live CD to clear it. Also, while the base Alpine install works, there’s no guarantee that any software you install won’t expect to be able to create files with names prohibited by Windows.</li>
<li>You literally already installed Alpine the normal way as a sub-procedure of this. Just do that. Please.</li>
</ul>
<p>But you have to admit, it’s quite funny.</p>
<p>Please redirect any hate mail to <code>&#34;spam\x40tends\x2eto&#34;</code>. :)</p>


	</section></div>
  </body>
</html>
