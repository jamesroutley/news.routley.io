<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://matthewsinclair.com/blog/0181-why-elixir">Original</a>
    <h1>Why Elixir? Common misconceptions</h1>
    
    <div id="readability-page-1" class="page"><div data-mdx-content="true">
                <p>
  <img src="https://blog.divyendusingh.com/images/blog/ms/2025/07-08-0181-why-elixir/hero.png" alt="hero.png"/>

Source: OpenAI</p>
<p>
  <img src="https://blog.divyendusingh.com/images/blog/4-out-of-5-hats.png" alt="4-out-of-5-hats.png"/>

<em>[ED: I am sick and tired of having to justify “Why Elixir?” so I decided to write down all of the reasons why in one spot!]</em></p>
<h3>
Braingasm</h3>
<p>
<strong>Why Elixir? A Rebuttal to Common Misconceptions</strong></p>
<p>
I’m all-in on the <a href="https://elixir-lang.org/" target="_blank">Elixir</a> programming ecosystem. Seriously. I love the idea of a single codebase that works <strong>glass-to-tin</strong> — and while other platforms have made similar promises, I’ve never seen it truly delivered until I started working with Elixir.</p>
<p>
It’s often dismissed by teams unfamiliar with its capabilities, usually because it sits outside the mainstream stacks. But in a world where AI-assisted development is changing how we build software, popularity and fitness-for-purpose aren’t the same thing. Elixir isn’t just a sound choice — it’s often the best choice for building scalable, maintainable, high-performance applications.</p>
<p>
Over the last eight months, I’ve grown increasingly tired of having to explain <em>why</em> Elixir is such a strong — if not the best — platform for modern, AI-powered, LLM-assisted web and mobile development. I found myself repeating the same arguments so often that I decided to write them down once, properly. A blog post to summarise the case. And a deeply researched <em>[ED: thanks, GPT Deep Research!]</em> paper with all the details and references. Now, instead of arguing, I can just send a link.</p>
<p>
Enjoy!</p>
<p>
<strong>1. Built for Scalability, Concurrency, and Resilience</strong></p>
<p>
Elixir runs on the <a href="https://www.erlang.org/" target="_blank">Erlang</a> VM (BEAM), which was purpose-built for distributed, concurrent, fault-tolerant systems. This makes it a natural fit for modern SaaS applications, real-time features, APIs, messaging backends, marketplaces, and transactional systems. You get:</p>
<ul>
  <li>
Lightweight, isolated processes (millions of them)  </li>
  <li>
Preemptive scheduling  </li>
  <li>
Supervisors and fault tolerance are baked into the runtime  </li>
  <li>
Hot code upgrades with no downtime  </li>
</ul>
<p>
These capabilities aren’t optional extras — they’re the default behaviour. You don’t need to orchestrate this with extra tooling. It’s just how the platform works.</p>
<p>
<strong>2. A Mature, Production-Grade Ecosystem</strong></p>
<p>
Elixir isn’t just a functional curiosity — it’s a production-grade platform with companies like <a href="https://www.cometchat.com/blog/whatsapps-architecture-and-system-design" target="_blank">WhatsApp</a>, <a href="https://discord.com/blog/how-discord-scaled-elixir-to-5-000-000-concurrent-users" target="_blank">Discord</a>, <a href="https://paraxial.io/blog/elixir-savings" target="_blank">Pinterest</a>, <a href="https://www.pagerduty.com/blog/insights/elixir-at-pagerduty/" target="_blank">PagerDuty</a>, and <a href="https://medium.com/brexeng/why-brex-chose-elixir-fe1a4f313195" target="_blank">Brex</a> using it to handle real-world scale and complexity. <em>[ED: These are not small apps; WhatsApp famously handled billions of daily messages with a tiny team by leveraging the BEAM, and Discord’s chat infrastructure scaled to millions of concurrent users.]</em> The open-source ecosystem includes industrial-strength libraries for:</p>
<ul>
  <li>
Web development (<a href="https://www.phoenixframework.org/" target="_blank">Phoenix</a>, <a href="https://github.com/phoenixframework/phoenix_live_view" target="_blank">LiveView</a>)  </li>
  <li>
Background processing (<a href="https://oban.pro/" target="_blank">Oban</a>)  </li>
  <li>
Event-driven data pipelines (<a href="https://elixir-broadway.org/" target="_blank">Broadway</a>, <a href="https://elixirschool.com/en/lessons/data_processing/genstage" target="_blank">GenStage</a>)  </li>
  <li>
Observability (<a href="https://hexdocs.pm/telemetry/readme.html" target="_blank">Telemetry</a>, <a href="https://hexdocs.pm/phoenix_live_dashboard/Phoenix.LiveDashboard.html" target="_blank">LiveDashboard</a>)  </li>
  <li>
ML workloads (<a href="https://github.com/elixir-nx" target="_blank">Nx</a>, <a href="https://github.com/elixir-nx/axon" target="_blank">Axon</a>, <a href="https://hexdocs.pm/exla/EXLA.html" target="_blank">EXLA</a>)  </li>
  <li>
Distributed clustering (<a href="https://github.com/bitwalker/libcluster" target="_blank">libcluster</a>, <a href="https://github.com/derekkraan/horde" target="_blank">Horde</a>)  </li>
</ul>
<p>
Elixir is opinionated in favour of correctness, concurrency, and stability, and the ecosystem follows suit.</p>
<p>
<strong>3. Phoenix: The Best Glass-to-Tin Web Framework</strong> *</p>
<p>
<a href="https://www.phoenixframework.org/" target="_blank">Phoenix</a> is more than just a web framework — it’s a fully integrated, batteries-included platform that covers the entire web stack from HTTP to WebSocket, from templating to APIs, from forms to real-time interactions. With <a href="https://github.com/phoenixframework/phoenix_live_view" target="_blank">LiveView</a>, Phoenix eliminates the need for a bloated client-side SPA stack in many applications. This drastically reduces complexity, fragility, and duplicated state.</p>
<p>
You don’t need to maintain three separate frontends, coordinate across React/Vue teams, or run an API spec treadmill. Phoenix collapses the stack — and that leads to better coherence, less surface area, and smaller, more effective teams.</p>
<p>
<em>[ED: * See UPDATE 20250708]</em></p>
<p>
<strong>4. Ash Framework: Declarative Backends with Extreme Leverage</strong></p>
<p>
<a href="https://ash-hq.org/" target="_blank">Ash</a> takes the productivity of Elixir to another level. It introduces a fully declarative, DSL-driven paradigm for building APIs, resources, actions, policies, and data models. Instead of writing boilerplate controller, context, and schema code, you define the shape of your domain — and Ash generates the plumbing, lifecycle logic, and persistence.</p>
<p>
Ash is particularly strong for:</p>
<ul>
  <li>
API-centric products  </li>
  <li>
Admin and internal tools  </li>
  <li>
CRUD-heavy backends  </li>
  <li>
Policy and authorisation enforcement  </li>
  <li>
Event-driven systems (via Ash Notifiers)  </li>
</ul>
<p>
It’s not “low-code.” It’s high-leverage code.</p>
<p>
Ash drastically reduces the amount of code required to build and maintain complex backends, and gives you better introspection, consistency, and validation along the way.</p>
<p>
<strong>5. NX: Numerical Elixir and the ML Future</strong></p>
<p>
Elixir isn’t just a backend framework — it’s becoming a serious contender in numerical computing. The <a href="https://hexdocs.pm/nx/Nx.html" target="_blank">Nx</a> project, led by José Valim (creator of Elixir), brings:</p>
<ul>
  <li>
Tensor-based numerical computing  </li>
  <li>
GPU acceleration via EXLA  </li>
  <li>
Model training and inference with Axon  </li>
  <li>
Tight integration with Phoenix and LiveView for deploying ML in production  </li>
</ul>
<p>
You can now run and serve machine learning models natively in Elixir, co-located with your application logic, without bridging out to Python or maintaining fragile polyglot wrappers.</p>
<p>
This opens the door to real-time inference, model serving, and continuous learning at the edge — directly in your web app or API.</p>
<p>
<strong>6. Exceptional Developer Productivity</strong></p>
<p>
Elixir promotes clarity, maintainability, and simplicity. Its syntax is expressive and approachable, drawing inspiration from Ruby, but with the power of functional programming. The developer experience is fast, pleasant, and deeply integrated. Builds are fast. Tooling is consistent. No need for layers of boilerplate.</p>
<p>
<strong>7. High-Signal Talent Pool and Retention Advantage</strong></p>
<p>
Yes, the Elixir community is smaller. But that is a strength. Developers who choose Elixir tend to be:</p>
<ul>
  <li>
Highly experienced  </li>
  <li>
Motivated by correctness and maintainability  </li>
  <li>
Comfortable with distributed systems and functional thinking  </li>
</ul>
<p>
Importantly, they tend to <strong>stay</strong>. Elixir teams report higher retention, stronger alignment, and less churn. In a hiring environment where replacing talent is expensive and time-consuming, this represents a significant competitive advantage.</p>
<p>
In addition to the clear advantages of the Elixir ecosystem, I have noticed something else fundamental about software engineers who adopt functional programming: they tend to be well above average. I have yet to determine whether this is a cause or an effect of functional programming. It may have something to do with the necessary simplicity of pure functions and the freedom that stateless/immutable data unlocks. I’m not sure <em>why</em>, but it is <em>real</em>.</p>
<p>
<strong>8. AI-Native Language Model Compatibility</strong></p>
<p>
Elixir’s foundations in functional programming — with pure functions, immutable data, and clear separation of concerns — make it easier for large language models to reason about, generate, and test code. LLMs struggle with imperative codebases full of side effects, hidden state, and indirection. Elixir code is composable, declarative, and inspectable. It struggles a bit with macros, but when shown what good looks like, it can and does manage without too much difficulty.</p>
<p>
If your future includes AI-assisted development, Elixir gives you a strategic advantage by being <strong>inherently easier to automate</strong>.</p>
<p>
<strong>9. What You Don’t Need to Worry About with Elixir</strong></p>
<p>
As well as having a bunch of stuff that is better, Elixir comes with a huge amount of stuff out of the box as a standard part of the ecosystem, which means you do not need to worry about it. Here’s a non-exhaustive list of infrastructure or complexity you can often <strong>skip entirely</strong>,  because Elixir handles it for you:</p>
<ul>
  <li>
    <p>
<strong>Kubernetes</strong>    </p>
    <p>
BEAM handles orchestration, fault-tolerance, clustering, and self-healing without the need for container orchestration platforms. Tools like <a href="https://hexdocs.pm/libcluster/readme.html" target="_blank">libcluster</a> and <a href="https://hexdocs.pm/horde/readme.html" target="_blank">Horde</a> make clustering trivial.    </p>
  </li>
  <li>
    <p>
<strong>External Job Queues (e.g. Sidekiq, Celery, Kafka)</strong>    </p>
    <p>
Use <a href="https://oban.pro/" target="_blank">Oban</a> — native, reliable, PostgreSQL-backed background jobs, retries, and scheduling with observability built in.    </p>
  </li>
  <li>
    <p>
<strong>Rate Limiting / Queuing / Backpressure</strong>    </p>
    <p>
Elixir’s GenStage, Broadway, and built-in concurrency primitives make it easy to build systems that absorb and control throughput without bolted-on queues.    </p>
  </li>
  <li>
    <p>
<strong>WebSockets or Real-time Layers</strong>    </p>
    <p>
<a href="https://github.com/phoenixframework/phoenix_live_view" target="_blank">Phoenix LiveView</a> gives you real-time, interactive interfaces without needing React/Redux frontends, GraphQL, or client-side state complexity.    </p>
  </li>
  <li>
    <p>
<strong>Monitoring/Instrumentation Boilerplate</strong>    </p>
    <p>
The Erlang VM comes with <a href="https://erlang.org/doc/apps/observer/observer_ug.html" target="_blank">:observer</a> and introspection tooling out of the box. Libraries like <a href="https://hexdocs.pm/telemetry/readme.html" target="_blank">Telemetry</a> and <a href="https://hexdocs.pm/phoenix_live_dashboard/Phoenix.LiveDashboard.html" target="_blank">LiveDashboard</a> make operational insights native.    </p>
  </li>
  <li>
    <p>
<strong>Async/Thread Management</strong>    </p>
    <p>
No need for managing threads, promises, or goroutines. Concurrency is the default model in Elixir.    </p>
  </li>
  <li>
    <p>
<strong>Hot Code Upgrades or Zero-Downtime Deploys</strong>    </p>
    <p>
Built into the VM. No complex rollout orchestration needed.    </p>
  </li>
  <li>
    <p>
<strong>Excessive DevOps Tooling</strong>    </p>
    <p>
Fewer moving parts, tighter integration, and sane defaults. Less need for glue code, CI/CD hacks, or runtime patching.    </p>
  </li>
  <li>
    <p>
<strong>Build Tools / Dependency Hell</strong>    </p>
    <p>
The Elixir toolchain (<a href="https://hexdocs.pm/mix/Mix.html" target="_blank">mix</a>, <a href="https://hex.pm/" target="_blank">hex</a>, <a href="https://hexdocs.pm/ex_unit/ExUnit.html" target="_blank">ex_unit</a>) is fast, clean, and consistent. No need for Webpack, Maven, or NPM-style complexity.    </p>
  </li>
  <li>
    <p>
<strong>Testing / Mocks / Fixtures</strong>    </p>
    <p>
Elixir’s standard library includes test tooling that makes mocking, faking, and property testing simple and first-class.    </p>
  </li>
</ul>
<p>
<strong>10. Go Deeper on Why Elixir?</strong></p>
<p>
This summary provides a concise and informative introduction to why Elixir is not just a good platform for modern development, but a great one. But I figured, with access to the deep research capabilities of a nearby LLM, why not have it write a detailed paper on the topic? That paper is <a href="https://blog.divyendusingh.com/content/why_elixir_(gpt_deep_research_and_matthew_sinclair).pdf" target="_blank">here</a>. Note that this was generated almost entirely by GPT, but notwithstanding that warning, GPT doesn’t do too bad a job at making the case for <strong>Why Elixir</strong>?</p>
<p>
<strong>Summary</strong></p>
<p>
Elixir isn’t a niche tool for weird problems — it’s a modern, reliable, elegant stack for building robust, scalable, and maintainable systems with a small, high-quality team. It avoids accidental complexity and removes whole categories of infrastructure concerns.</p>
<p>
It enables full-stack delivery with far less code, fewer moving parts, and better leverage — from the front-end (Phoenix) to real-time interactions (LiveView), to declarative backends (Ash), to on-platform ML (Nx). It is one of the most future-proof and AI-aligned languages in the ecosystem.</p>
<p>
The result, Elixir is: <strong>Faster to build. Cheaper to run. Easier to operate. Longer to last. Easier to automate.</strong></p>
<p>
Regards,</p>
<p>
<strong>UPDATE20250708:</strong> I had some feedback that the phrase “<em>glass-to-tin</em>“ is not necessarily a well known phrase (thanks <a href="https://bsky.app/profile/brainlid.bsky.social">Mark Ericksen</a> for the tip). For those I managed to confuse, “glass-to-tin” just means “front-to-back” or “from the screen to the back end”. Apologies.</p>
<hr/>
<p>
<em>[ED: If you’d like to sign up for this content as an email, <a href="https://eepurl.com/duaiov" target="_blank">click here</a> to join the mailing list.]</em></p>
<p>
First published on <a href="https://matthewsinclair.com/blog/0181-why-elixir" target="_blank">matthewsinclair.com</a> and cross-posted on <a href="https://matthewsinclair.medium.com/39dad4bfd7a3?source=friends_link&amp;sk=b515de0269f683f11c8f8872156d4966" target="_blank">Medium</a>.</p>
<p>
<a href="mailto:hello@matthewsinclair.com">hello@matthewsinclair.com</a> |
<a href="https://matthewsinclair.com" target="_blank">matthewsinclair.com</a> |
<a href="https://bsky.app/profile/matthewsinclair.com" target="_blank">bsky.app/@matthewsinclair.com</a> |
<a href="https://masto.ai/@matthewsinclair" target="_blank">masto.ai/@matthewsinclair</a> |
<a href="https://medium.com/@matthewsinclair" target="_blank">medium.com/@matthewsinclair</a> |
<a href="https://twitter.com/@matthewsinclair" target="_blank">xitter/@matthewsinclair</a></p>

              </div></div>
  </body>
</html>
