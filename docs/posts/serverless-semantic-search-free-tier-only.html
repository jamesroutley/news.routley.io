<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://qdrant.tech/articles/serverless/">Original</a>
    <h1>Serverless Semantic Search, Free tier only</h1>
    
    <div id="readability-page-1" class="page"><div>
<div>
<section>
<article>
<div>
<picture>
<source srcset="https://qdrant.tech/articles_data/serverless/preview/title.webp" type="image/webp"/>
<img src="https://qdrant.tech/articles_data/serverless/preview/title.jpg"/>
</picture>
</div><p>Do you want to insert a semantic search function into your website or online app? Now you can do so - without spending any money! In this example, you will learn how to create a free prototype search engine for your own non-commercial purposes.</p><p>You may find all of the assets for this tutorial on <a href="https://github.com/qdrant/examples/tree/master/lambda-search">GitHub</a>.</p><h2 id="ingredients"><a aria-label="Anchor" data-anchorjs-icon="" href="#ingredients"></a>Ingredients</h2><ul>
<li>A <a href="https://rust-lang.org">Rust</a> toolchain</li><li><a href="https://qdrant.tech/articles/serverless/cargo-lambda.info">cargo lambda</a> (install via package manager, <a href="https://github.com/cargo-lambda/cargo-lambda/releases">download</a> binary or <code>cargo install cargo-lambda</code>)</li><li>The <a href="https://aws.amazon.com/cli">AWS CLI</a></li><li>Qdrant instance (<a href="https://cloud.qdrant.tech">free tier</a> available)</li><li>An embedding provider service of your choice (see our <a href="https://qdrant.tech/documentation/integrations">integration docs</a>. You may be able to get credits from <a href="https://aigrant.org">AI Grant</a>, also Cohere has a <a href="https://cohere.com/pricing">rate-limited non-commercial free tier</a>)</li><li>AWS Lambda account (12-month free tier available)</li></ul><h2 id="what-youre-going-to-build"><a aria-label="Anchor" data-anchorjs-icon="" href="#what-youre-going-to-build"></a>What you’re going to build</h2><p>You’ll combine the embedding provider and the Qdrant instance to a neat semantic search, calling both services from a small Lambda function.</p><p><img src="https://qdrant.tech/articles_data/serverless/lambda_integration.png" alt="lambda integration diagram"/></p><p>Now lets look at how to work with each ingredient before connecting them.</p><h2 id="rust-and-cargo-lambda"><a aria-label="Anchor" data-anchorjs-icon="" href="#rust-and-cargo-lambda"></a>Rust and cargo-lambda</h2><p>You want your function to be quick, lean and safe, so using Rust is a no-brainer. To compile Rust code for use within Lambda functions, the <code>cargo-lambda</code> subcommand has been built. <code>cargo-lambda</code> can put your Rust code in a zip file that AWS Lambda can then deploy on a no-frills <code>provided.al2</code> runtime.</p><p>To interface with AWS Lambda, you will need a Rust project with the following dependencies in your <code>Cargo.toml</code>:</p><div><pre tabindex="0"><code data-lang="toml" id="IxNDQ"><span><span>[dependencies]
</span></span><span><span>tokio = { version = <span>&#34;1&#34;</span>, features = [<span>&#34;macros&#34;</span>] }
</span></span><span><span>lambda_http = { version = <span>&#34;0.8&#34;</span>, default-features = <span>false</span>, features = [<span>&#34;apigw_http&#34;</span>] }
</span></span><span><span>lambda_runtime = <span>&#34;0.8&#34;</span>
</span></span></code><span id="copy-popover-IxNDQ" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>This gives you an interface consisting of an entry point to start the Lambda runtime and a way to register your handler for HTTP calls. Put the following snippet into <code>src/helloworld.rs</code>:</p><div><pre tabindex="0"><code data-lang="rust" id="g0Mjc"><span><span><span>use</span><span> </span>lambda_http::{run,<span> </span>service_fn,<span> </span>Body,<span> </span>Error,<span> </span>Request,<span> </span>RequestExt,<span> </span>Response};<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>/// This is your callback function for responding to requests at your URL
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>function_handler</span>(_req: <span>Request</span>)<span> </span>-&gt; <span>Result</span><span>&lt;</span>Response<span>&lt;</span>Body<span>&gt;</span>,<span> </span>Error<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span>Response::from_text(<span>&#34;Hello, Lambda!&#34;</span>)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[tokio::main]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>main</span>()<span> </span>{<span>
</span></span></span><span><span><span>    </span>run(service_fn(function_handler)).<span>await</span><span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code><span id="copy-popover-g0Mjc" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>You can also use a closure to bind other arguments to your function handler (the <code>service_fn</code> call then becomes <code>service_fn(|req| function_handler(req, ...))</code>). Also if you want to extract parameters from the request, you can do so using the <a href="https://docs.rs/lambda_http/latest/lambda_http/type.Request.html">Request</a> methods (e.g. <code>query_string_parameters</code> or <code>query_string_parameters_ref</code>).</p><p>Add the following to your <code>Cargo.toml</code> to define the binary:</p><div><pre tabindex="0"><code data-lang="toml" id="I4Nzg"><span><span>[[bin]]
</span></span><span><span>name = <span>&#34;helloworld&#34;</span>
</span></span><span><span>path = <span>&#34;src/helloworld.rs&#34;</span>
</span></span></code><span id="copy-popover-I4Nzg" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>On the AWS side, you need to setup a Lambda and IAM role to use with your function.</p><p><img src="https://qdrant.tech/articles_data/serverless/create_lambda.png" alt="create lambda web page"/></p><p>Choose your function name, select “Provide your own bootstrap on Amazon Linux 2”. As architecture, use <code>arm64</code>. You will also activate a function URL. Here it is up to you if you want to protect it via IAM or leave it open, but be aware that open end points can be accessed by anyone, potentially costing money if there is too much traffic.</p><p>By default, this will also create a basic role. To look up the role, you can go into the Function overview:</p><p><img src="https://qdrant.tech/articles_data/serverless/lambda_overview.png" alt="function overview"/></p><p>Click on the “Info” link near the “▸ Function overview” heading, and select the “Permissions” tab on the left.</p><p>You will find the “Role name” directly under <em>Execution role</em>. Note it down for later.</p><p><img src="https://qdrant.tech/articles_data/serverless/lambda_role.png" alt="function overview"/></p><p>To test that your “Hello, Lambda” service works, you can compile and upload the function:</p><div><pre tabindex="0"><code data-lang="bash" id="UwNDA"><span><span>$ <span>export</span> <span>LAMBDA_FUNCTION_NAME</span><span>=</span>hello
</span></span><span><span>$ <span>export</span> <span>LAMBDA_ROLE</span><span>=</span>&lt;role name from lambda web ui&gt;
</span></span><span><span>$ <span>export</span> <span>LAMBDA_REGION</span><span>=</span>us-east-1
</span></span><span><span>$ cargo lambda build --release --arm --bin helloworld --output-format zip
</span></span><span><span>  Downloaded libc v0.2.137
</span></span><span><span><span># [..] output omitted for brevity</span>
</span></span><span><span>    Finished release <span>[</span>optimized<span>]</span> target<span>(</span>s<span>)</span> in 1m 27s
</span></span><span><span>$ <span># Delete the old empty definition</span>
</span></span><span><span>$ aws lambda delete-function-url-config --region <span>$LAMBDA_REGION</span> --function-name <span>$LAMBDA_FUNCTION_NAME</span>
</span></span><span><span>$ aws lambda delete-function --region <span>$LAMBDA_REGION</span> --function-name <span>$LAMBDA_FUNCTION_NAME</span>
</span></span><span><span>$ <span># Upload the function</span>
</span></span><span><span>$ aws lambda create-function --function-name <span>$LAMBDA_FUNCTION_NAME</span> <span>\
</span></span></span><span><span><span></span>    --handler bootstrap <span>\
</span></span></span><span><span><span></span>    --architectures arm64 <span>\
</span></span></span><span><span><span></span>    --zip-file fileb://./target/lambda/helloworld/bootstrap.zip <span>\
</span></span></span><span><span><span></span>    --runtime provided.al2 <span>\
</span></span></span><span><span><span></span>    --region <span>$LAMBDA_REGION</span> <span>\
</span></span></span><span><span><span></span>    --role <span>$LAMBDA_ROLE</span> <span>\
</span></span></span><span><span><span></span>    --tracing-config <span>Mode</span><span>=</span>Active
</span></span><span><span>$ <span># Add the function URL</span>
</span></span><span><span>$ aws lambda add-permission <span>\
</span></span></span><span><span><span></span>    --function-name <span>$LAMBDA_FUNCTION_NAME</span> <span>\
</span></span></span><span><span><span></span>    --action lambda:InvokeFunctionUrl <span>\
</span></span></span><span><span><span></span>    --principal <span>&#34;*&#34;</span> <span>\
</span></span></span><span><span><span></span>    --function-url-auth-type <span>&#34;NONE&#34;</span> <span>\
</span></span></span><span><span><span></span>    --region <span>$LAMBDA_REGION</span> <span>\
</span></span></span><span><span><span></span>    --statement-id url
</span></span><span><span>$ <span># Here for simplicity unauthenticated URL access. Beware!</span>
</span></span><span><span>$ aws lambda create-function-url-config <span>\
</span></span></span><span><span><span></span>    --function-name <span>$LAMBDA_FUNCTION_NAME</span> <span>\
</span></span></span><span><span><span></span>    --region <span>$LAMBDA_REGION</span> <span>\
</span></span></span><span><span><span></span>    --cors <span>&#34;AllowOrigins=*,AllowMethods=*,AllowHeaders=*&#34;</span> <span>\
</span></span></span><span><span><span></span>    --auth-type NONE
</span></span></code><span id="copy-popover-UwNDA" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>Now you can go to your <em>Function Overview</em> and click on the Function URL. You should see something like this:</p><p>Bearer ! You have set up a Lambda function in Rust. On to the next ingredient:</p><h2 id="embedding"><a aria-label="Anchor" data-anchorjs-icon="" href="#embedding"></a>Embedding</h2><p>Most providers supply a simple https GET or POST interface you can use with an API key, which you have to supply in an authentication header. If you are using this for non-commercial purposes, the rate limited trial key from Cohere is just a few clicks away. Go to <a href="https://dashboard.cohere.ai/welcome/register">their welcome page</a>, register and you’ll be able to get to the dashboard, which has an “API keys” menu entry which will bring you to the following page:
<a href="https://qdrant.tech/articles_data/serverless/cohere-dashboard.png">cohere dashboard</a></p><p>From there you can click on the ⎘ symbol next to your API key to copy it to the clipboard. <em>Don’t put your API key in the code!</em> Instead read it from an env variable you can set in the lambda environment. This avoids accidentally putting your key into a public repo. Now all you need to get embeddings is a bit of code. First you need to extend your dependencies with <code>reqwest</code> and also add <code>anyhow</code> for easier error handling:</p><div><pre tabindex="0"><code data-lang="toml" id="I1MDk"><span><span>anyhow = <span>&#34;1.0&#34;</span>
</span></span><span><span>reqwest =  { version = <span>&#34;0.11.18&#34;</span>, default-features = <span>false</span>, features = [<span>&#34;json&#34;</span>, <span>&#34;rustls-tls&#34;</span>] }
</span></span><span><span>serde = <span>&#34;1.0&#34;</span>
</span></span></code><span id="copy-popover-I1MDk" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>Now given the API key from above, you can make a call to get the embedding vectors:</p><div><pre tabindex="0"><code data-lang="rust" id="g0NTc"><span><span><span>use</span><span> </span>anyhow::<span>Result</span>;<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>serde::Deserialize;<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>reqwest::Client;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>#[derive(Deserialize)]</span><span>
</span></span></span><span><span><span></span><span>struct</span> <span>CohereResponse</span><span> </span>{<span> </span>outputs: <span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>f32</span><span>&gt;&gt;</span><span> </span>}<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>embed</span>(client: <span>&amp;</span><span>Client</span>,<span> </span>text: <span>&amp;</span><span>str</span>,<span> </span>api_key: <span>&amp;</span><span>str</span>)<span> </span>-&gt; <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>f32</span><span>&gt;&gt;&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>CohereResponse<span> </span>{<span> </span>outputs<span> </span>}<span> </span><span>=</span><span> </span>client<span>
</span></span></span><span><span><span>        </span>.post(<span>&#34;https://api.cohere.ai/embed&#34;</span>)<span>
</span></span></span><span><span><span>        </span>.header(<span>&#34;Authorization&#34;</span>,<span> </span><span>&amp;</span>format!(<span>&#34;Bearer {api_key}&#34;</span>))<span>
</span></span></span><span><span><span>        </span>.header(<span>&#34;Content-Type&#34;</span>,<span> </span><span>&#34;application/json&#34;</span>)<span>
</span></span></span><span><span><span>        </span>.header(<span>&#34;Cohere-Version&#34;</span>,<span> </span><span>&#34;2021-11-08&#34;</span>)<span>
</span></span></span><span><span><span>        </span>.body(format!(<span>&#34;{{\&#34;text\&#34;:[\&#34;{text}\&#34;],\&#34;model\&#34;:\&#34;small\&#34;}}&#34;</span>))<span>
</span></span></span><span><span><span>        </span>.send()<span>
</span></span></span><span><span><span>        </span>.<span>await</span><span>?</span><span>
</span></span></span><span><span><span>        </span>.json()<span>
</span></span></span><span><span><span>        </span>.<span>await</span><span>?</span>;<span>
</span></span></span><span><span><span>    </span><span>Ok</span>(outputs)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code><span id="copy-popover-g0NTc" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>Note that this may return multiple vectors if the text overflows the input dimensions.
Cohere’s <code>small</code> model has 1024 output dimensions.</p><p>Other providers have similar interfaces. Consult our <a href="https://qdrant.tech/documentation/integrations">integration docs</a> for further information. See how little code it took to get the embedding?</p><p>While you’re at it, it’s a good idea to write a small test to check if embedding works and the vectors are of the expected size:</p><div><pre tabindex="0"><code data-lang="rust" id="c3NTY"><span><span><span>#[tokio::test]</span><span>
</span></span></span><span><span><span></span><span>async</span><span> </span><span>fn</span> <span>check_embedding</span>()<span> </span>{<span>
</span></span></span><span><span><span>    </span><span>// ignore this test if API_KEY isn&#39;t set
</span></span></span><span><span><span></span><span>    </span><span>let</span><span> </span><span>Ok</span>(api_key)<span> </span><span>=</span><span> </span><span>&amp;</span>std::env::var(<span>&#34;API_KEY&#34;</span>)<span> </span><span>else</span><span> </span>{<span> </span><span>return</span>;<span> </span>}<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>embedding<span> </span><span>=</span><span> </span><span>crate</span>::embed(<span>&#34;What is semantic search?&#34;</span>,<span> </span>api_key).unwrap()[<span>0</span>];<span>
</span></span></span><span><span><span>    </span><span>// Cohere&#39;s `small` model has 1024 output dimensions.
</span></span></span><span><span><span></span><span>    </span>assert_eq!(<span>1024</span>,<span> </span>embedding.len());<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code><span id="copy-popover-c3NTY" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>Run this while setting the <code>API_KEY</code> environment variable to check if the embedding works.</p><h2 id="qdrant-search"><a aria-label="Anchor" data-anchorjs-icon="" href="#qdrant-search"></a>Qdrant search</h2><p>Now that you have embeddings, it’s time to put them into your Qdrant. You could of course use <code>curl</code> or <code>python</code> to set up your collection and upload the points, but as you already have Rust including some code to obtain the embeddings, you can stay in Rust, adding <code>qdrant-client</code> to the mix.</p><div><pre tabindex="0"><code data-lang="rust" id="g1ODk"><span><span><span>use</span><span> </span>anyhow::<span>Result</span>;<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>qdrant_client::prelude::<span>*</span>;<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>qdrant_client::qdrant::{VectorsConfig,<span> </span>VectorParams};<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>qdrant_client::qdrant::vectors_config::Config;<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>std::collections::HashMap;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>fn</span> <span>setup</span><span>&lt;&#39;</span><span>i</span><span>&gt;</span>(<span>
</span></span></span><span><span><span>    </span>embed_client: <span>&amp;</span><span>reqwest</span>::Client,<span>
</span></span></span><span><span><span>    </span>embed_api_key: <span>&amp;</span><span>str</span>,<span>
</span></span></span><span><span><span>    </span>qdrant_url: <span>&amp;</span><span>str</span>,<span>
</span></span></span><span><span><span>    </span>api_key: <span>Option</span><span>&lt;&amp;</span><span>str</span><span>&gt;</span>,<span>
</span></span></span><span><span><span>    </span>collection_name: <span>&amp;</span><span>str</span>,<span>
</span></span></span><span><span><span>    </span>data: <span>impl</span><span> </span><span>Iterator</span><span>&lt;</span>Item<span> </span><span>=</span><span> </span>(<span>&amp;&#39;</span><span>i</span><span> </span><span>str</span>,<span> </span>HashMap<span>&lt;</span><span>String</span>,<span> </span>Value<span>&gt;</span>)<span>&gt;</span>,<span>
</span></span></span><span><span><span></span>)<span> </span>-&gt; <span>Result</span><span>&lt;</span>()<span>&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>config<span> </span><span>=</span><span> </span>QdrantClientConfig::from_url(qdrant_url);<span>
</span></span></span><span><span><span>    </span>config.api_key<span> </span><span>=</span><span> </span>api_key;<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>client<span> </span><span>=</span><span> </span>QdrantClient::new(<span>Some</span>(config))<span>?</span>;<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    </span><span>// create the collections
</span></span></span><span><span><span></span><span>    </span><span>if</span><span> </span><span>!</span>client.has_collection(collection_name).<span>await</span><span>?</span><span> </span>{<span>
</span></span></span><span><span><span>        </span>client<span>
</span></span></span><span><span><span>            </span>.create_collection(<span>&amp;</span>CreateCollection<span> </span>{<span>
</span></span></span><span><span><span>                </span>collection_name: <span>collection_name</span>.into(),<span>
</span></span></span><span><span><span>                </span>vectors_config: <span>Some</span>(VectorsConfig<span> </span>{<span>
</span></span></span><span><span><span>                    </span>config: <span>Some</span>(Config::Params(VectorParams<span> </span>{<span>
</span></span></span><span><span><span>                        </span>size: <span>1024</span>,<span> </span><span>// output dimensions from above
</span></span></span><span><span><span></span><span>                        </span>distance: <span>Distance</span>::Cosine<span> </span><span>as</span><span> </span><span>i32</span>,<span>
</span></span></span><span><span><span>                        </span><span>..</span><span>Default</span>::default()<span>
</span></span></span><span><span><span>                    </span>})),<span>
</span></span></span><span><span><span>                </span>}),<span>
</span></span></span><span><span><span>                </span><span>..</span><span>Default</span>::default()<span>
</span></span></span><span><span><span>            </span>})<span>
</span></span></span><span><span><span>            </span>.<span>await</span><span>?</span>;<span>
</span></span></span><span><span><span>    </span>}<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span><span>mut</span><span> </span>id_counter<span> </span><span>=</span><span> </span><span>0_</span><span>u64</span>;<span>
</span></span></span><span><span><span>    </span><span>let</span><span> </span>points<span> </span><span>=</span><span> </span>data.map(<span>|</span>(text,<span> </span>payload)<span>|</span><span> </span>{<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span>id<span> </span><span>=</span><span> </span>std::mem::replace(<span>&amp;</span><span>mut</span><span> </span>id_counter,<span> </span><span>*</span>id_counter<span> </span><span>+</span><span> </span><span>1</span>);<span>
</span></span></span><span><span><span>        </span><span>let</span><span> </span>vectors<span> </span><span>=</span><span> </span><span>Some</span>(embed(embed_client,<span> </span>text,<span> </span>embed_api_key).unwrap());<span>
</span></span></span><span><span><span>        </span>PointStruct<span> </span>{<span> </span>id,<span> </span>vectors,<span> </span>payload<span> </span>}<span>
</span></span></span><span><span><span>    </span>}).collect();<span>
</span></span></span><span><span><span>    </span>client.upsert_points(collection_name,<span> </span>points,<span> </span><span>None</span>).<span>await</span><span>?</span>;<span>
</span></span></span><span><span><span>    </span><span>Ok</span>(())<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code><span id="copy-popover-g1ODk" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>Depending on whether you want to efficiently filter the data, you can also add some indexes. I’m leaving this out for brevity, but you can look at the <a href="https://github.com/qdrant/examples/tree/master/lambda-search">example code</a> containing this operation. Also this does not implement chunking (splitting the data to upsert in multiple requests, which avoids timeout errors).</p><p>Add a suitable <code>main</code> method and you can run this code to insert the points (or just use the binary from the example). Be sure to include the port in the <code>qdrant_url</code>.</p><p>Now that you have the points inserted, you can search them by embedding:</p><div><pre tabindex="0"><code data-lang="rust" id="E3Njk"><span><span><span>use</span><span> </span>anyhow::<span>Result</span>;<span>
</span></span></span><span><span><span></span><span>use</span><span> </span>qdrant_client::prelude::<span>*</span>;<span>
</span></span></span><span><span><span></span><span>pub</span><span> </span><span>async</span><span> </span><span>fn</span> <span>search</span>(<span>
</span></span></span><span><span><span>    </span>text: <span>&amp;</span><span>str</span>,<span>
</span></span></span><span><span><span>    </span>collection_name: <span>String</span>,<span>
</span></span></span><span><span><span>    </span>client: <span>&amp;</span><span>Client</span>,<span>
</span></span></span><span><span><span>    </span>api_key: <span>&amp;</span><span>str</span>,<span>
</span></span></span><span><span><span>    </span>qdrant: <span>&amp;</span><span>QdrantClient</span>,<span>
</span></span></span><span><span><span></span>)<span> </span>-&gt; <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span>ScoredPoint<span>&gt;&gt;</span><span> </span>{<span>
</span></span></span><span><span><span>    </span><span>Ok</span>(qdrant.search_points(<span>&amp;</span>SearchPoints<span> </span>{<span>
</span></span></span><span><span><span>        </span>collection_name,<span>
</span></span></span><span><span><span>        </span>limit: <span>5</span>,<span> </span><span>// use what fits your use case here
</span></span></span><span><span><span></span><span>        </span>with_payload: <span>Some</span>(<span>true</span>.into()),<span>
</span></span></span><span><span><span>        </span>vector: <span>embed</span>(client,<span> </span>text,<span> </span>api_key)<span>?</span>,<span>
</span></span></span><span><span><span>        </span><span>..</span><span>Default</span>::default()<span>
</span></span></span><span><span><span>    </span>}).<span>await</span><span>?</span>.result)<span>
</span></span></span><span><span><span></span>}<span>
</span></span></span></code><span id="copy-popover-E3Njk" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>You can also filter by adding a <code>filter: ...</code> field to the <code>SearchPoints</code>, and you will likely want to process the result further, but the example code already does that, so feel free to start from there in case you need this functionality.</p><h2 id="putting-it-all-together"><a aria-label="Anchor" data-anchorjs-icon="" href="#putting-it-all-together"></a>Putting it all together</h2><p>Now that you have all the parts, it’s time to join them up. Now copying and wiring up the snippets above is left as an exercise to the reader. Impatient minds can peruse the <a href="https://github.com/qdrant/examples/tree/master/lambda-search">example repo</a> instead.</p><p>You’ll want to extend the <code>main</code> method a bit to connect with the Client once at the start, also get API keys from the environment so you don’t need to compile them into the code. To do that, you can get them with <code>std::env::var(_)</code> from the rust code and set the environment from the AWS console.</p><div><pre tabindex="0"><code data-lang="bash" id="QyNDg"><span><span>$ <span>export</span> <span>QDRANT_URI</span><span>=</span>&lt;qour Qdrant instance URI including port&gt;
</span></span><span><span>$ <span>export</span> <span>QDRANT_API_KEY</span><span>=</span>&lt;your Qdrant API key&gt;
</span></span><span><span>$ <span>export</span> <span>COHERE_API_KEY</span><span>=</span>&lt;your Cohere API key&gt;
</span></span><span><span>$ <span>export</span> <span>COLLECTION_NAME</span><span>=</span>site-cohere
</span></span><span><span>$ aws lambda update-function-configuration <span>\
</span></span></span><span><span><span></span>    --function-name <span>$LAMBDA_FUNCTION_NAME</span> <span>\
</span></span></span><span><span><span></span>    --environment <span>&#34;Variables={QDRANT_URI=</span><span>$QDRANT_URI</span><span>,\
</span></span></span><span><span><span>        QDRANT_API_KEY=</span><span>$QDRANT_API_KEY</span><span>,COHERE_API_KEY=</span><span>${</span><span>COHERE_API_KEY</span><span>}</span><span>,\
</span></span></span><span><span><span>        COLLECTION_NAME=</span><span>${</span><span>COLLECTION_NAME</span><span>}</span><span>&#34;</span><span>`</span>
</span></span></code><span id="copy-popover-QyNDg" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><p>In any event, you will arrive at one command line program to insert your data and one Lambda function. The former can just be <code>cargo run</code> to set up the collection. For the latter, you can again call <code>cargo lambda</code> and the AWS console:</p><div><pre tabindex="0"><code data-lang="bash" id="c0NzA"><span><span>$ <span>export</span> <span>LAMBDA_FUNCTION_NAME</span><span>=</span>search
</span></span><span><span>$ <span>export</span> <span>LAMBDA_REGION</span><span>=</span>us-east-1
</span></span><span><span>$ cargo lambda build --release --arm --output-format zip
</span></span><span><span>  Downloaded libc v0.2.137
</span></span><span><span><span># [..] output omitted for brevity</span>
</span></span><span><span>    Finished release <span>[</span>optimized<span>]</span> target<span>(</span>s<span>)</span> in 1m 27s
</span></span><span><span>$ <span># Update the function</span>
</span></span><span><span>$ aws lambda update-function-code --function-name <span>$LAMBDA_FUNCTION_NAME</span> <span>\
</span></span></span><span><span><span></span>     --zip-file fileb://./target/lambda/page-search/bootstrap.zip <span>\
</span></span></span><span><span><span></span>     --region <span>$LAMBDA_REGION</span>
</span></span></code><span id="copy-popover-c0NzA" data-toggle="popover" data-content="Text copied!" data-original-title="" title=""></span></pre></div><h2 id="discussion"><a aria-label="Anchor" data-anchorjs-icon="" href="#discussion"></a>Discussion</h2><p>Lambda works by spinning up your function once the URL is called, so they don’t need to keep the compute on hand unless it is actually used. This means that the first call will be burdened by some 1-2 seconds of latency for loading the function, later calls will resolve faster. Of course, there is also the latency for calling the embeddings provider and Qdrant. On the other hand, the free tier doesn’t cost a thing, so you certainly get what you pay for. And for many use cases, a result within one or two seconds is acceptable.</p><p>Rust minimizes the overhead for the function, both in terms of file size and runtime. Using an embedding service means you don’t need to care about the details. Knowing the URL, API key and embedding size is sufficient. Finally, with free tiers for both Lambda and Qdrant as well as free credits for the embedding provider, the only cost is your time to set everything up. Who could argue with free?</p></article></section></div></div></div>
  </body>
</html>
