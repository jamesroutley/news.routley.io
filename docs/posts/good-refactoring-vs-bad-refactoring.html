<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.builder.io/blog/good-vs-bad-refactoring">Original</a>
    <h1>Good refactoring vs. bad refactoring</h1>
    
    <div id="readability-page-1" class="page"><div><div data-name="blog-article" data-source="Rendered by Builder.io"><div builder-content-id="0006245b60b64290aceebe2ea1e4db95" builder-model="blog-article"><div data-builder-component="blog-article" data-builder-content-id="0006245b60b64290aceebe2ea1e4db95"><div builder-type="blocks"><p><span><p>I&#39;ve hired a lot of developers over the years. More than a few of them have come in with a strong belief that our code needed heavy refactoring. But here&#39;s the thing: in almost every case, their newly refactored code was found by the other developers to be harder to understand and maintain. It also was generally slower and buggier too.</p>
<p>Now, don&#39;t get me wrong. Refactoring isn&#39;t inherently bad. It&#39;s a crucial part of keeping a codebase healthy. The problem is that bad refactoring is, well, bad. And it&#39;s surprisingly easy to fall into the trap of making things worse while trying to make them better.</p>
<p>So, let&#39;s get into what makes a good refactor versus a bad one, and how to avoid being that developer everyone dreads seeing near the codebase</p>
</span></p><div builder-id="builder-200d4e3d53604a9082f9ae45c98fef2b"><picture><source srcset="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=100 100w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=200 200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=400 400w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=1200 1200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=1600 1600w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=2000 2000w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?format=webp&amp;width=800 800w" type="image/webp"/><img alt="Comic of a beaver that is a little too obsessed with refactoring code" loading="lazy" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=800" srcset="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=100 100w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=200 200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=400 400w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=1200 1200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=1600 1600w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=2000 2000w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fe857bc9a29f8428a95d0b0233a6f3f8e?width=800 800w" sizes="(max-width: 638px) 86vw,  (max-width: 998px) 81vw, 58vw"/></picture></div><p><span><p>Abstractions can be good. Abstractions can be bad. The key is knowing when and how to apply them. Let&#39;s look at some common pitfalls and how to avoid them.</p></span></p><p><span><p>One of the most common mistakes I&#39;ve seen is when developers completely change the coding style during a refactor. This often happens when someone comes from a different background or has strong opinions about a particular programming paradigm.</p><p>Let&#39;s look at an example. Imagine we have a piece of code that needs some cleanup:</p><p><b>Before</b>:</p></span></p><div builder-id="builder-f74ead720f11405296e5bd2986f8d039"><div><div aria-label=""><pre><code>// ðŸ«¤ this code could be cleaner
function processUsers(users: User[]) {
  const result = [];
  for (let i = 0; i &lt; users.length; i++) {
    if (users[i].age &gt;= 18) {
      const formattedUser = {
        name: users[i].name.toUpperCase(),
        age: users[i].age,
        isAdult: true
      };
      result.push(formattedUser);
    }
  }
  return result;
}
</code></pre></div></div></div><p><span><p><b>Bad refactor</b>:</p></span></p><div builder-id="builder-ea8cf1dc30aa4128bb9bd7e31e9f34be"><div><div aria-label=""><pre><code>import * as R from &#39;ramda&#39;;

// ðŸš© adopted a completely different style + library
const processUsers = R.pipe(
  R.filter(R.propSatisfies(R.gte(R.__, 18), &#39;age&#39;)),
  R.map(R.applySpec({
    name: R.pipe(R.prop(&#39;name&#39;), R.toUpper),
    age: R.prop(&#39;age&#39;),
    isAdult: R.always(true)
  }))
);
</code></pre></div></div></div><p><span><p>While this refactored version might appeal to functional programming enthusiasts, it introduces a new library (Ramda) and a completely different coding style. For a team not familiar with this approach, it could be a nightmare to maintain.</p><p><b>Good refactor</b>:</p></span></p><div builder-id="builder-c2df8c4a5ca64741bb3836d1be7f3491"><div><div aria-label=""><pre><code>// âœ… cleaner and more conventional 
function processUsers(users: User[]): FormattedUser[] {
  return users
    .filter(user =&gt; user.age &gt;= 18)
    .map(user =&gt; ({
      name: user.name.toUpperCase(),
      age: user.age,
      isAdult: true
    }));
}</code></pre></div></div></div><p><span><p>This version improves the original code by using more idiomatic JavaScript methods like <code>filter</code> and <code>map</code>. It&#39;s more concise and easier to read, but it doesn&#39;t introduce a completely new paradigm or external dependencies.</p></span></p><p><span><p>I once hired someone who added tons of new abstractions without understanding the underlying code. They began grouping things that should not be grouped and were in the process of (intentionally) diverging over time. They consolidated some configurations that shouldn&#39;t have been (different APIs needed different configurations).</p><p><b>Before</b>:</p></span></p><div builder-id="builder-b913a521c594486bb7bda4e096934365"><div><div aria-label=""><pre><code>// ðŸ«¤ this code could be cleaner
function processUsers(users: User[]) {
  const result = [];
  for (let i = 0; i &lt; users.length; i++) {
    if (users[i].age &gt;= 18) {
      const formattedUser = {
        name: users[i].name.toUpperCase(),
        age: users[i].age,
        isAdult: true
      };
      result.push(formattedUser);
    }
  }
  return result;
}
</code></pre></div></div></div><p><span><p><b>Bad refactor</b>:</p></span></p><div builder-id="builder-9ee5a96f09bd4d3e8837e99321d48577"><div><div aria-label=""><pre><code>// ðŸš© there are way more layers and abstractions here than necessary
class UserProcessor {
  private users: User[];

  constructor(users: User[]) {
    this.users = users;
  }

  public process(): FormattedUser[] {
    return this.filterAdults().formatUsers();
  }

  private filterAdults(): UserProcessor {
    this.users = this.users.filter(user =&gt; user.age &gt;= 18);
    return this;
  }

  private formatUsers(): FormattedUser[] {
    return this.users.map(user =&gt; ({
      name: this.formatName(user.name),
      age: user.age,
      isAdult: true
    }));
  }

  private formatName(name: string): string {
    return name.toUpperCase();
  }
}

const processUsers = (users: User[]): FormattedUser[] =&gt; {
  return new UserProcessor(users).process();
};
</code></pre></div></div></div><p><span><p>This refactor introduces a class with multiple methods, which might seem more &#34;object-oriented&#34;, but it&#39;s actually more complex and harder to understand at a glance.</p><p><b>Good refactor</b>:</p></span></p><div builder-id="builder-e4c18e2eac7e4c9cb9add872f53016ac"><div><div aria-label=""><pre><code>// âœ… cleaner and more conventional 
const isAdult = (user: User): boolean =&gt; user.age &gt;= 18;

const formatUser = (user: User): FormattedUser =&gt; ({
  name: user.name.toUpperCase(),
  age: user.age,
  isAdult: true
});

function processUsers(users: User[]): FormattedUser[] {
  return users.filter(isAdult).map(formatUser);
}
</code></pre></div></div></div><p><span><p>This version breaks down the logic into small, reusable functions without introducing unnecessary complexity.</p></span></p><p><span><p>I&#39;ve seen cases where developers update one part of the codebase to work completely differently from the rest, in an attempt to make it &#34;better&#34;. This often leads to confusion and frustration for other developers who have to context-switch between different styles.</p><p>Let&#39;s say we have a React application where we consistently use React Query for data fetching:</p></span></p><div builder-id="builder-c0a30c199a214567899bae1500fc88ee"><div><div aria-label=""><pre><code>// Throughout the app
import { useQuery } from &#39;react-query&#39;;

function UserProfile({ userId }) {
  const { data: user, isLoading } = useQuery([&#39;user&#39;, userId], fetchUser);

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}
</code></pre></div></div></div><p><span><p>Now, imagine a developer decides to use Redux Toolkit for just one component:</p></span></p><div builder-id="builder-3598424a851c414ebe5b2199d154c490"><div><div aria-label=""><pre><code>// One-off component
import { useEffect } from &#39;react&#39;;
import { useDispatch, useSelector } from &#39;react-redux&#39;;
import { fetchPosts } from &#39;./postsSlice&#39;;

function PostList() {
  const dispatch = useDispatch();
  const { posts, status } = useSelector((state) =&gt; state.posts);

  useEffect(() =&gt; {
    dispatch(fetchPosts());
  }, [dispatch]);

  if (status === &#39;loading&#39;) return &lt;div&gt;Loading...&lt;/div&gt;;
  return &lt;div&gt;{posts.map(post =&gt; &lt;div key={post.id}&gt;{post.title}&lt;/div&gt;)}&lt;/div&gt;;
}
</code></pre></div></div></div><p><span><p>This inconsistency is frustrating because it introduces a completely different state management pattern for just one component.</p><p>A better approach would be to stick with React Query:</p></span></p><div builder-id="builder-cff6ac05404847aa88954b4278940227"><div><div aria-label=""><pre><code>// Consistent approach
import { useQuery } from &#39;react-query&#39;;

function PostList() {
  const { data: posts, isLoading } = useQuery(&#39;posts&#39;, fetchPosts);

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  return &lt;div&gt;{posts.map(post =&gt; &lt;div key={post.id}&gt;{post.title}&lt;/div&gt;)}&lt;/div&gt;;
}</code></pre></div></div></div><p><span><p>This version maintains consistency, using React Query for data fetching across the entire application. It&#39;s simpler and doesn&#39;t require other developers to learn a new pattern for just one component.</p><p>Remember, consistency in your codebase is important. If you need to introduce a new pattern, consider how you can get buy-in from your team first, rather than creating one-off inconsistencies.</p></span></p><p><span><p>One of the biggest problems I&#39;ve seen is refactoring code <i>while</i> learning it, in order <i>to</i> learn it. This is a terrible idea. I&#39;ve seen comments that you should work with a given piece of code for 6-9 months. Otherwise, you are likely to create bugs, hurt performance, etc.</p><p><b>Before</b>:</p></span></p><div builder-id="builder-367682bc23dd47568c7583c83f0bbbd0"><div><div aria-label=""><pre><code>// ðŸ«¤ a bit too much hard coded stuff here
function fetchUserData(userId: string) {
  const cachedData = localStorage.getItem(`user_${userId}`);
  if (cachedData) {
    return JSON.parse(cachedData);
  }

  return api.fetchUser(userId).then(userData =&gt; {
    localStorage.setItem(`user_${userId}`, JSON.stringify(userData));
    return userData;
  });
}
</code></pre></div></div></div><p><span><p><b>Bad refactor</b>:</p></span></p><div builder-id="builder-6d114c3c8fdb44069ac3668ef8056240"><div><div aria-label=""><pre><code>// ðŸš© where did the caching go?
function fetchUserData(userId: string) {
  return api.fetchUser(userId);
}
</code></pre></div></div></div><p><span><p>The refactorer might think they&#39;re simplifying the code, but they&#39;ve actually removed an important caching mechanism that was in place to reduce API calls and improve performance.</p><p><b>Good refactor</b>:</p></span></p><div builder-id="builder-8d519824612f4a00a5b275151ec9e2cf"><div><div aria-label=""><pre><code>// âœ… cleaner code preserving the existing behavior
async function fetchUserData(userId: string) {
  const cachedData = await cacheManager.get(`user_${userId}`);
  if (cachedData) {
    return cachedData;
  }

  const userData = await api.fetchUser(userId);
  await cacheManager.set(`user_${userId}`, userData, { expiresIn: &#39;1h&#39; });
  return userData;
}
</code></pre></div></div></div><p><span><p>This refactor maintains the caching behavior while potentially improving it by using a more sophisticated cache manager with expiration.</p></span></p><p><span><p>I joined a company once with horrible legacy code baggage. I led a project to migrate an ecommerce company to a new, modern, faster, better tech... angular.js</p><p>It turns out, this business was heavily dependent on SEO, and we built a slow and bloated single page app.</p><p>We shipped nothing for 2 years besides a  slower, buggier, and less maintainable carbon copy of the website. Why? The people leading this (me - I am the asshole of this scenario) hadn&#39;t worked on this site before. I was young and dumb.</p><p>Let&#39;s look at a modern example of this mistake:</p><p><b>Bad refactor</b>:</p></span></p><div builder-id="builder-75e0dfbb9dae40de8098701154ec454d"><div><div aria-label=""><pre><code>// ðŸš© a single page app for an SEO-focused site is a bad idea
function App() {
  return (
    &lt;Router&gt;
      &lt;Switch&gt;
        &lt;Route path=&#34;/product/:id&#34; component={ProductDetails} /&gt;
      &lt;/Switch&gt;
    &lt;/Router&gt;
  );
}</code></pre></div></div></div><p><span><p>This approach might seem modern and clean, but it&#39;s entirely client-side rendered. For an e-commerce site that depends heavily on SEO, this could be disastrous.</p><p><b>Good refactor</b>:</p></span></p><div builder-id="builder-2269bab9e7ae4de5ad357ebc5515d75e"><div><div aria-label=""><pre><code>// âœ… server render an SEO-focused site
export const getStaticProps: GetStaticProps = async () =&gt; {
  const products = await getProducts();
  return { props: { products } };
};

export default function ProductList({ products }) {
  return (
    &lt;div&gt;
      ...
    &lt;/div&gt;
  );
}</code></pre></div></div></div><p><span><p>This Next.js-based approach provides server-side rendering out of the box, which is crucial for SEO. It also offers a better user experience with faster initial page loads and improved performance for users with slower connections. Remix would be equally good for this purpose, offering similar benefits for server-side rendering and SEO optimization.</p></span></p><p><span><p>I once hired someone who, on their first day working on our backend, immediately started refactoring code. We had a bunch of Firebase functions, some with different settings than others - like timeout and memory allocation.</p><p>Here&#39;s what our original setup looked like.</p><p><strong>Before:</strong></p></span></p><div builder-id="builder-f342d62718854069896702c73271db5a"><div><div aria-label=""><pre><code>// ðŸ˜• we had this same code 40+ times in the codebase, we could perhaps consolidate
export const quickFunction = functions
  .runWith({ timeoutSeconds: 60, memory: &#39;256MB&#39; })
  .https.onRequest(...);

export const longRunningFunction = functions
  .runWith({ timeoutSeconds: 540, memory: &#39;1GB&#39; })
  .https.onRequest(...);</code></pre></div></div></div><p><span><p>This person decided to wrap all these functions in one <code>createApi</code> function.</p><p><strong>Bad refactor:</strong></p></span></p><div builder-id="builder-fce3cc02c50544db9e5abcacb0b1db52"><div><div aria-label=""><pre><code>// ðŸš© blindly consolidating settings that should not be
const createApi = (handler: RequestHandler) =&gt; {
  return functions
    .runWith({ timeoutSeconds: 300, memory: &#39;512MB&#39; })
    .https.onRequest((req, res) =&gt; handler(req, res));
};

export const quickFunction = createApi(handleQuickRequest);
export const longRunningFunction = createApi(handleLongRunningRequest);</code></pre></div></div></div><p><span><p>This refactor set all APIs to have the same settings, with no way to override per API. It&#39;s a problem because sometimes we need different settings for different functions.</p><p>A better approach would&#39;ve been to allow the Firebase options to pass through per API</p><p><strong>Good refactor:</strong></p></span></p><div builder-id="builder-b1b65a7b27564aa3a16fac7b9ac7294b"><div><div aria-label=""><pre><code>// âœ… setting good defaults, but letting anyone override
const createApi = (handler: RequestHandler, options: ApiOptions = {}) =&gt; {
  return functions
    .runWith({ timeoutSeconds: 300, memory: &#39;512MB&#39;, ...options })
    .https.onRequest((req, res) =&gt; handler(req, res));
};

export const quickFunction = createApi(handleQuickRequest, { timeoutSeconds: 60, memory: &#39;256MB&#39; });
export const longRunningFunction = createApi(handleLongRunningRequest, { timeoutSeconds: 540, memory: &#39;1GB&#39; });</code></pre></div></div></div><p><span><p>This way, we keep the benefits of the abstraction while preserving the flexibility we need. When consolidating or abstracting, always think about the use cases you&#39;re serving. Don&#39;t sacrifice flexibility for the sake of &#34;cleaner&#34; code. Make sure your abstractions allow for the full range of functionality that the original implementation provided.</p><p>And seriously, understand the code before you start &#34;improving&#34; it. We had issues the next time we deployed some APIs that could&#39;ve been avoided without this blind refactoring.</p></span></p><p><span><p>It&#39;s worth noting that you do need to refactor code. But do it right. Our code is not perfect, our code needs cleanup, but keep consistent with the codebase, be familiar with the code, be choosy about abstractions.</p><p>Here are some tips for successful refactoring:</p><ol><li>Be incremental: Make small, manageable changes rather than sweeping rewrites.</li>
<li>Deeply understand code before doing significant refactors or new abstractions.</li>
<li>Match the existing code style: Consistency is key for maintainability.</li>
<li>Avoid too many new abstractions: Keep it simple unless complexity is truly warranted.</li>
<li>Avoid adding new libraries, especially of a very different programming style, without buy-in from the team.</li>
<li>Write tests before refactoring and update them as you go. This ensures you&#39;re maintaining the original functionality.</li>
<li>Hold your coworkers accountable to these principles.</li></ol></span></p><div builder-id="builder-0edd5b73283742269c28bc47fb3fb06b"><picture><source srcset="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=100 100w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=200 200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=400 400w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=1200 1200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=1600 1600w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=2000 2000w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?format=webp&amp;width=800 800w" type="image/webp"/><img alt="A flow chart about understanding code, making small changes, getting feedback, repeating" loading="lazy" src="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=800" srcset="https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=100 100w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=200 200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=400 400w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=1200 1200w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=1600 1600w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=2000 2000w, https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2Fd9793fb2c0b14962b88ee123f35f11d6?width=800 800w" sizes="(max-width: 638px) 86vw,  (max-width: 998px) 81vw, 58vw"/></picture></div><p><span><p>To help ensure your refactors are beneficial rather than harmful, consider the following techniques and tools:</p></span></p><p><span><p>Use linting tools to enforce consistent code style and catch potential issues. <a href="https://prettier.io/">Prettier</a> can help auto-format to a consistent style, while <a href="https://eslint.org/">Eslint</a> can help with more nuanced consistency checks that you can easily customize with your own plugins.</p></span></p><p><span><p>Implement thorough code reviews to get feedback from your peers before merging refactored code. This helps catch potential issues early and ensures the refactored code aligns with team standards and expectations.</p></span></p><p><span><p>Write and run tests to ensure your refactored code doesn&#39;t break existing functionality. <a href="https://vitest.dev/">Vitest</a> is a particularly fast, solid, and easy-to-use test runner that requires zero configuration by default. For visual testing, consider using <a href="https://storybook.js.org/">Storybook</a>. <a href="https://github.com/testing-library/react-testing-library">React Testing Library</a> is a great set of utilities for testing React components (there are <a href="https://github.com/testing-library/angular-testing-library">Angular</a> and <a href="https://github.com/testing-library">more</a> variants as well).</p></span></p><p><span><p>Let AI help you with your refactoring efforts, at least those that are able to match your existing coding style and conventions.</p><p>One tool that&#39;s particularly useful for maintaining consistency while coding frontends is <a href="https://www.builder.io/m/design-to-code" rel="noopener noreferrer" target="_blank">Visual Copilot</a>. This AI-powered tool can help you turn designs into code while matching your existing coding style and correctly leveraging your design system components and tokens.</p></span></p><p><span><p>Refactoring is a necessary part of software development, but it needs to be done thoughtfully and with respect for the existing codebase and team dynamics. The goal of refactoring is to improve the internal structure of the code without changing its external behavior.</p><p>Remember, the best refactors are often invisible to the end-user but make life significantly easier for developers. They improve readability, maintainability, and efficiency without disrupting the overall system.</p><p>The next time you feel the urge to make &#34;big plans&#34; for a piece of code, take a step back. Understand it thoroughly, consider the impact of your changes, and make incremental improvements that your team will thank you for. </p><p>Your future self (and your colleagues) will appreciate the thoughtful approach to keeping the codebase clean and maintainable.</p><p>Oh also do you like YouTube vids? Theres a video on this too from yours truly:</p></span></p><div builder-id="builder-60f40f51baeb49928c388bd3def5728d"><div><p><iframe src="https://www.youtube.com/embed/N-BqaCIS92k?rel=0" allowfullscreen="" scrolling="no" allow="accelerometer; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share;"></iframe></p></div></div><div data-model="symbol" builder-id="builder-3acb48f1a85944768349f7b15b69e5ca"><div data-name="symbol" data-source="Rendered by Builder.io"><div builder-content-id="02714711c4b647959d015e34679ca6ee" builder-model="symbol"><div data-builder-component="symbol" data-builder-content-id="02714711c4b647959d015e34679ca6ee"><div builder-type="blocks"><div builder-id="builder-c21fdea7f4994fa78093de6ea2ea8c21"><div builder-id="builder-595e9f030686490283583d5940058827"><div><div><div builder-type="blocks" builder-parent-id="builder-595e9f030686490283583d5940058827"><div builder-id="builder-5c5dae78d59143a696f7b6d283770a3c"><p><span><p><strong>Introducing Visual Copilot</strong>: convert Figma designs to high quality code in a single click.</p></span></p><p><a role="button" href="https://builder.io/signup" target="_blank" builder-id="builder-60b8c05c22a34d5b809db1f2064d5ab2">Try Visual Copilot</a></p></div></div></div></div></div></div><p><img src="https://cdn.builder.io/api/v1/pixel?apiKey=YJIGb4i01jvw0SRdL5Bt" aria-hidden="true" alt="" role="presentation" width="0" height="0" builder-id="builder-pixel-me7cmtikm5"/></p></div></div></div></div></div><p><img src="https://cdn.builder.io/api/v1/pixel?apiKey=YJIGb4i01jvw0SRdL5Bt" aria-hidden="true" alt="" role="presentation" width="0" height="0" builder-id="builder-pixel-iuyl9tydr7p"/></p></div></div></div></div></div></div>
  </body>
</html>
