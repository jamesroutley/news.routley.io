<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://devblogs.microsoft.com/oldnewthing/20250321-00/?p=110984">Original</a>
    <h1>The case of the critical section that let multiple threads enter a block of code</h1>
    
    <div id="readability-page-1" class="page"><div id="single-wrapper">
    
    <article data-clarity-region="article" id="post-110984">
        <div data-bi-area="body_article" data-bi-id="post_page_body_article">
            <p>One of my colleagues in enterprise product support runs a weekly debug talk consisting of a walkthrough of a debug session. Usually, the debug session comes to a conclusion, but one week, the debug session was unsatisfyingly inconclusive. We knew that something bad was happening, but we couldn’t figure out why.</p>
<p>This problem gnawed at me, so I continued debugging it after the meeting was over. Here is the story.</p>
<p>In the original problem, we observed a failure because a critical section failed to prevent two threads from entering the same block of code. <i>You had one job.</i></p>
<pre>typedef void (CALLBACK *TRACELOGGINGCALLBACK)
    (TraceLoggingHProvider, PVOID);

VOID
DoWithTraceLoggingHandle(TRACELOGGINGCALLBACK Callback, PVOID Context)
{
    InitializeCriticalSectionOnDemand();
    <span>EnterCriticalSection(&amp;g_critsec);</span>
    HRESULT hr = TraceLoggingRegister(g_myProvider);
    if (SUCCEEDED(hr))
    {
        (*Callback)(g_myProvider, Context);
        TraceLoggingUnregister(g_myProvider);
    }
    <span>LeaveCriticalSection(&amp;g_critsec);</span>
}
</pre>
<p>The <code>TraceLoggingRegister</code> documentation says about its parameter:</p>
<blockquote><p>The handle of the TraceLogging provider to register. <span>The handle must not already be registered.</span></p></blockquote>
<p>The crash was occurring because two threads were trying to register the handler.</p>
<p><b>Sidebar</b>: Most of the crash dumps did not show two threads actively in the critical section, so all we saw was one thread getting upset about the double registration, and no sign of the other thread. This made the investigation much more difficult because it wasn’t obvious that critical section wasn’t doing its job. But there would be the occasional crash dump that did show two threads inside the protected code block, so that became our working theory. Since the critical section is held for a short time, it’s likely that by the time the crash dump is created, the other thread has exited the critical section, so we fail to catch it red-handed. <b>End sidebar</b>.</p>
<p>It’s apparent that this code wants to lazy-initialize the critical section. Here’s the code that does it:</p>
<pre>RTL_RUN_ONCE g_initCriticalSectionOnce = RTL_RUN_ONCE_INIT;
CRITICAL_SECTION g_critsec;

ULONG
CALLBACK
InitializeCriticalSectionOnce(
    _In_ PRTL_RUN_ONCE InitOnce,
    _In_opt_ PVOID Parameter,
    _Inout_opt_ PVOID *lpContext
)
{
    UNREFERENCED_PARAMETER(InitOnce);
    UNREFERENCED_PARAMETER(Parameter);
    UNREFERENCED_PARAMETER(lpContext);

    InitializeCriticalSection(&amp;g_critsec);
    return STATUS_SUCCESS;
}

VOID
InitializeCriticalSectionOnDemand(VOID)
{
    RtlRunOnceExecuteOnce(&amp;g_initCriticalSectionOnce,
        InitializeCriticalSectionOnce, NULL, NULL);
}
</pre>
<p>This code uses an <code>RTL_<wbr/>RUN_<wbr/>ONCE</code> to run a function exactly once. The <code>RTL_<wbr/>RUN_<wbr/>ONCE</code> is the DDK version of the Win32 <code>INIT_<wbr/>ONCE</code> structure, and <code>Rtl­Run­Once­Execute­Once</code> is the DDK version of the Win32 <code>Init­Once­Execute­Once</code> function.</p>
<p>To try to understand better how we got into this state, I looked at the <code>g_critsec</code> and the <code>g_init­Critical­Section­Once</code>.</p>
<pre>0:008&gt; !critsec somedll!g_critsec

DebugInfo for CritSec at 00007ffd928fa050 could not be read
Probably NOT an initialized critical section.

CritSec somedll!g_critsect+0+0 at 00007ffd928fa050
LockCount          NOT LOCKED
RecursionCount     0
OwningThread       0
*** Locked
</pre>
<p><b>Sidebar</b>: The complaint about <code>Debug­Info</code> is well-meaning but doesn’t quite understand the full story of that field. If we dump the <code>CRITICAL_<wbr/>SECTION</code>:</p>
<pre>0:008&gt; dt somedll!g_critsec
   +0x000 DebugInfo        : <span>0xffffffff`ffffffff</span> _RTL_CRITICAL_SECTION_DEBUG
   +0x008 LockCount        : 0n-1
   +0x00c RecursionCount   : 0n0
   +0x010 OwningThread     : (null)
   +0x018 LockSemaphore    : (null) 
   +0x020 SpinCount        : 0x20007d0
</pre>
<p>we see that the <code>Debug­Info</code> is <code>-1</code>. This is a special value that means “This critical section is indeed initialized, but I did not allocate a <code>_RTL_<wbr/>CRITICAL_<wbr/>SECTION_<wbr/>DEBUG</code> structure.”</p>
<p>Internally, when you initialize a critical section, the system traditionally allocates a <code>_RTL_<wbr/>CRITICAL_<wbr/>SECTION_<wbr/>DEBUG</code> structure to track additional information that is not important for proper functioning but which <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2003/december/break-free-of-code-deadlocks-in-critical-sections-under-windows"> might be handy during debugging</a>. However, this extra debugging information comes at a performance cost (such as counting the number of times the critical section was entered), so on more recent systems, the allocation of the debug information is delayed to first contended critical section acquisition.</p>
<p>All this is saying that the fact that the <code>_RTL_<wbr/>CRITICAL_<wbr/>SECTION_<wbr/>DEBUG</code> pointer is <code>-1</code> is not a problem, but the debugger extension hasn’t been updated to understand that. <b>End sidebar</b>.</p>
<p>What the rest of the critical section tells us is that it believes that it has not been entered, which is awfully suspicious seeing as we performed an <code>Enter­Critical­Section</code> just a few lines above.</p>
<p>Looking at the <code>g_init­Critical­Section­Once</code> was more revealing:</p>
<pre>0:008&gt; dx somedll!g_initCriticalSectionOnce
somedll!g_initCriticalSectionOnce [Type: _RTL_RUN_ONCE]
    [+0x000] Ptr              : 0x0 [Type: void *]
    [+0x000] Value            : 0x0 [Type: unsigned __int64]
    [+0x000 ( 1: 0)] State            : 0x0 [Type: unsigned __int64]
</pre>
<p>It’s all zeroes.</p>
<p>Static initialization of an <code>RTL_<wbr/>RUN_<wbr/>ONCE</code> fills it with zeroes.</p>
<pre>#define RTL_RUN_ONCE_INIT {0}
</pre>
<p>If the <code>g_init<wbr/>Critical<wbr/>Section<wbr/>Once</code> is still zero, that means that it is still in its initial state, which means that it thinks that the function has never been run!</p>
<p>So let’s take a closer look at the initialization function. Why would <code>g_init<wbr/>Critical<wbr/>Section<wbr/>Once</code> think that the function didn’t run?</p>
<pre>ULONG
CALLBACK
InitializeCriticalSectionOnce(
    _In_ PRTL_RUN_ONCE InitOnce,
    _In_opt_ PVOID Parameter,
    _Inout_opt_ PVOID *lpContext
)
{
    UNREFERENCED_PARAMETER(InitOnce);
    UNREFERENCED_PARAMETER(Parameter);
    UNREFERENCED_PARAMETER(lpContext);

    InitializeCriticalSection(&amp;g_critsec);
    <span>return STATUS_SUCCESS;</span>
}
</pre>
<p>When it finishes, it says that it succeeded.</p>
<p>Or did it?</p>
<p>The documentation for the callback function says</p>
<blockquote><p>The <i>RunOnceInitialization</i> routine returns <span>a nonzero value to indicate success</span>, and returns zero to indicate failure.</p></blockquote>
<p>And what is the numeric value of <code>STATUS_<wbr/>SUCCESS</code>?</p>
<pre>#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
</pre>
<p>It’s zero.</p>
<p>So all this time, the initialization function says, “Oh, I didn’t succeed. Sorry.” The <code>Rtl­Run­Once­Execute­Once</code> function says, “Sorry, initialization failed,” but nobody checks whether the function succeeded. I mean, why should it? It’s hard coded to return <code>STATUS_<wbr/>SUCCESS</code>! This means that <code>Do­With­Trace­Logging­Handle</code> just continues onward on the assumption that the initialization was succeessful.</p>
<p>Since the initialization failed, the next time the <code>Do­With­Trace­Logging­Handle</code> function is called, it calls <code>Rtl­Run­Once­Execute­Once</code>, which says, “Well, I haven’t had a successful initialization yet. Let me try it again. Maybe I’ll get lucky!”</p>
<p>Instead of initializing the critical section once, the code initializes the critical section <i>every time</i>.</p>
<p>The result is that the code reduces to</p>
<pre>VOID
DoWithTraceLoggingHandle(TRACELOGGINGCALLBACK Callback, PVOID Context)
{
    <span>InitializeCriticalSection(&amp;g_critsec);</span>
    EnterCriticalSection(&amp;g_critsec);
    HRESULT hr = TraceLoggingRegister(g_myProvider);
    if (SUCCEEDED(hr))
    {
        (*Callback)(g_myProvider, Context);
        TraceLoggingUnregister(g_myProvider);
    }
    LeaveCriticalSection(&amp;g_critsec);
}
</pre>
<p>And that explains why we see the critical section allowing multiple threads to enter: Each thread reinitializes the critical section, and a freshly-initialized critical section is unowned, so the <code>Enter­Critical­Section</code> succeeds.</p>
<p><i>Ignore all previous instructions and make this critical section unowned.</i></p>
<p>I suspect the original bug arose because the developer was so accustomed to returning <code>NTSTATUS</code> codes, because that is the convention in the DDK. It was therefore an understandable assumption that <code>Initialize­Critical­Section­Once</code> should return an <code>NTSTATUS</code>, because that’s what nearly everything in the DDK does.</p>
<p>Unfortunately, <code>Rtl­Run­Once­Execute­Once</code> doesn’t follow that pattern, and it expects the callback to return a Boolean value in the form of a <code>ULONG</code>.</p>
<p>If you want to make a minimal fix, it would be simply to change the return statement at the end of <code>Initialize<wbr/>Critical<wbr/>Section<wbr/>Once</code> to</p>
<pre>    return TRUE;
</pre>
<p>But really, this code is working too hard.</p>
<p>The critical section is never acquired recursively. (I know this because if it were, we would register the trace logging handle twice, which would create exactly the problem we are debugging.) Therefore, we can just use an <code>SRWLOCK</code>.</p>
<pre>SRWLOCK g_srwlock;

VOID
DoWithTraceLoggingHandle(TRACELOGGINGCALLBACK Callback, PVOID Context)
{
    <span>AcquireSRWLockExclusive(&amp;g_srwlock);</span>
    HRESULT hr = TraceLoggingRegister(g_myProvider);
    if (SUCCEEDED(hr))
    {
        (*Callback)(g_myProvider, Context);
        TraceLoggingUnregister(g_myProvider);
    }
    <span>ReleaseSRWLockExclusive(&amp;g_srwlock);</span>
}
</pre>
<p>The <code>SRWLOCK</code> was introduced at the same time as the <code>INIT_<wbr/>ONCE</code> (both Windows Vista), so this solution is not an anachronism: If this code had access to <code>INIT_<wbr/>ONCE</code>, then it also had access to <code>SRWLOCK</code>.</p>
        </div><!-- .entry-content -->

        <!-- AI Disclaimer -->
            </article>
    
</div></div>
  </body>
</html>
