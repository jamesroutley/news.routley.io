<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pencil.toast.cafe/bunker-labs/simply-parse-in-c">Original</a>
    <h1>Simply Parse in C</h1>
    
    <div id="readability-page-1" class="page"><div><p>by Chloe Kudryavtsev</p>

<p>People are terrified of parsers and parsing. To the point of using magical libraries with custom syntaxes to learn just to get started. In the hopes of completely shattering this preconception, I will write a parser for the “ini” file format in about 150 lines of pure and readable ISO C99. Furthermore, this parser will be something that&#39;s nice to use and has error correcting features, such that it is actually useful and usable outside this example setting.</p>

<h2 id="design">Design</h2>

<p>There&#39;s no standard for the ini format, and all the existing implementations disagree, so let&#39;s take some liberties, XKCD 927 style.
No newlines in keys, values, or section names. Empty values are not allowed. Comments only on their own lines (minus whitespace). Whitespace-insensitive (whitespace at the start of line, end of line, around the “=”, is all ignored). No need for a terminating newline either.
Oh that&#39;s more than most C ini parsers do? Isn&#39;t that convenient.</p>

<p>To get the jargon out of the way, the parser will be recursive-descent LL(1).</p>

<p>The API will have a single entry point. You call <code>parse_ini</code> against a <code>FILE*</code>, with optional userdata (just any context the API user wants to have available in their callback), and a required callback. The callback will be called for every key-value pair, and it will receive the section, key, and value, alongside the userdata.
All of the strings in question will be temporary private data, and must be copied over (for simplicity). If a given terminal does not fit inside the private data, the given value is truncated, but the parsing continues without error.</p>

<h2 id="implementing">Implementing</h2>

<p>Let&#39;s start by writing the top-level function. We macro-define the max length. This is done firstly so that it can be changed (by surrounding it with ifdefs later), and secondly because we&#39;re allocating temporary memory. Typical parsers already operate in quadratic time, adding countless allocations and reallocations for a use-case where all values are typically small isn&#39;t reasonable.</p>

<pre><code>#define INI_SEC_MAXLEN 64
#define INI_KEY_MAXLEN INI_SEC_MAXLEN
#define INI_VAL_MAXLEN INI_KEY_MAXLEN * 16
</code></pre>

<p>Now we can write the top-level <code>parse_ini</code> function. The effective <a href="https://bford.info/pub/lang/peg/" rel="nofollow">PEG</a> for it is <code>ini &lt;- expr*</code>. We start from the top-level because we have a specific idea for the UX, so we need to write the rest of the functions in a way as to ensure we can deliver on it.</p>

<pre><code>// if the callback returns non-zero, parsing will stop
typedef int (*callback)(const char*, const char*, const char*, void*);
// we return the number of bytes handled, sort of, you&#39;ll see
int parse_ini(FILE *src, void *userdata, callback cb) {
    char section[INI_SEC_MAXLEN] = {0};
    char key[INI_KEY_MAXLEN] = {0};
    char value[INI_VAL_MAXLEN] = {0};
    int status, out = 0;
    // we stop going whenever we fail to consume any data, explicitly error,
    // the stream errors, or the stream ends
    while ((status = parse_expr(src, userdata, section, key, value, cb) &gt;= 0) {
        out += status;
        if (feof(src) || ferror(src)) break;
    }
    return ferror(src) ? -out : out;
}
</code></pre>

<p>Nothing too complicated here, you just iterate the stream until something makes us stop. We return negative values in the case of an irrecoverable stream error that isn&#39;t EOF. We get into the real meat in <code>parse_expr</code>.</p>

<p>Note that all the future functions and definitions are <code>static</code>, but I&#39;m omitting that keyword (as well as the occasional <code>inline</code> for brevity – you don&#39;t need to see it in this case).</p>

<p>In <code>parse_expr</code>, we want to parse an expression. In an ini file, you have comments, section declarations, and key-value pairs. We also want to skip whitespace. So let&#39;s do exactly that. The effective PEG is <code>expr &lt;- ws* (section / comment / kv)</code>.</p>

<pre><code>int parse_expr(FILE *src, void *userdata, char *section, char *key, char *value, callback cb) {
    int len = parse_skipws(src);
    if (len) return len; // to avoid confusing byte counts, we&#39;re in a loop anyway

    int c;
    // figure out the next expression
    switch ((c = fgetc(src))) {
        case EOF:
            return 0; // let the outer loop figure out if this was an error or not
        case &#39;[&#39;: // a section
            return parse_section(src, section);
        case &#39;#&#39;:
        case &#39;;&#39;:
            return parse_skipuntil(src, &#34;\n&#34;);
        default: // key-value pair
            ungetc(c, src); // we need to conserve this one
            return parse_kv(src, userdata, section, key, value, cb);
    }
}
</code></pre>

<p>Note: we don&#39;t need to <code>ungetc</code> in sections or comments, since the only real use of the character is to identify the type of expression. Before we get into the implementations of <code>parse_section</code> and <code>parse_kv</code>, let&#39;s write the utility functions we&#39;ll need, such as <code>parse_skipuntil</code>.</p>

<p>Let&#39;s start with <code>parse_skipwhile</code> and <code>parse_skipuntil</code>, which will skip characters while a condition holds, or until a condition occurs. We&#39;ll define a condition as the next character being in a secondary argument (a string), a check we can perform using <code>strchr</code>. Neither of these have direct PEG alternatives, since this approach is closer to a lexer technique, which we can utilize precisely because we&#39;re writing a hand parser.</p>

<pre><code>int parse_skipuntil(FILE *src, const char *s) {
    int out = 0;
    for (int c; (c = fgetc(src)) != EOF; out++) {
        if (strchr(s, c)) return out;
    }
    return ferror(src) ? -out : out;
}
int parse_skipwhile(FILE *src, const char *s) {
    int out = 0;
    for (int c; (c = fgetc(src)) != EOF; out++) {
        if (!strchr(s, c)) {
            ungetc(c, s);
            return out;
        }
    }
    return ferror(src) ? -out : out;
}
</code></pre>

<p>Note that they&#39;re almost the same. The primary notable difference is the negation of the <code>strchr</code> call, and that <code>skipwhile</code> does an <code>ungetc</code> (<code>skipuntil</code> consumes the terminator).</p>

<p>We can now define <code>parse_skipws</code>. It&#39;s actually quite simple.</p>

<pre><code>// the characters we consider to be whitespace
const char wss[] = &#34; \t\r\n&#34;;
#define parse_skipws(src) parse_skipwhile(src, wss)
</code></pre>

<p>Before we move on to the juicy stuff, we&#39;ll implement one more thing: <code>parse_until</code>. Semantically, it&#39;s the same as <code>parse_skipuntil</code>, but it will actually write what it reads into a string pointer, up to its maximum length. Then it just becomes <code>parse_skipuntil</code>. You could do the same thing with <code>parse_skipwhile</code> too.</p>

<pre><code>int parse_until(FILE *src, char *ptr, ssize_t maxlen, const char *s) {
    int out = 0;
    while (out &lt; maxlen) {
        *ptr = fgetc(src);
        if (*ptr == EOF) { // hit error while scanning
            *ptr = 0;
            return ferror(src) ? -out : out;
        } else if (strchr(s, *ptr)) {
            *ptr = 0;
            return out;
        }
        ptr++; out++;
    }
    // we only make it here if we hit maxlen
    (*--ptr) = 0;
    int skipped = parse_skipwhile(src, s);
    if (skipped &gt; 0) {
        return out + skipped; // errors are negative, eof is ok
    }
    return ferror(src) ? (skipped - out) : (out - skipped);
}
</code></pre>

<p>We can now write <code>parse_section</code> and such!</p>

<pre><code>#define parse_section(src, section) parse_until(src, section, INI_SEC_MAXLEN, &#34;]\n&#34;)
</code></pre>

<p>Yeah, that&#39;s all there is to it.
Note that we also allow terminating with a newline. This way, if someone forgot a “]”, we can still parse it. Though it does break comments on the same line.</p>

<p>Let&#39;s also write <code>parse_key</code> and <code>parse_value</code>, since we&#39;ll need them in <code>parse_kv</code> in a second.</p>

<pre><code>int parse_key(FILE *src, char *key) {
    int out = parse_until(src, key, INI_KEY_MAXLEN, &#34;=\n&#34;);
    return stripright(key, wss);
}
int parse_value(FILE *src, char *value) {
    int out = parse_until(src, value, INI_VAL_MAXLEN, &#34;\n&#34;);
    return stripright(value, wss);
}
</code></pre>

<p>First of all, we do the same thing with the key that we did with the section: if a key is not terminated by an “=”, presume the newline is the “=”. This way, in the absolute worst-case scenario, two key-value pairs get corrupted, and the rest parses fine, though it may be a good idea to check the value of “out” too.</p>

<p>Secondly, you&#39;ll note the “stripright”. We already discard leading whitespace in <code>parse_expr</code>, but to strip trailing whitespace after the key (so before the “=”) and the value (so before the “\n”), we&#39;ll need to perform string brain surgery.</p>

<p>It&#39;s not too bad though, look:</p>

<pre><code>// returns the number of output bytes
int stripright(char *c, const char *s) {
    ssize_t len = strlen(s);
    if (!len) return len; // already empty
    while ((--len) &gt;= 0 &amp;&amp; strchr(s, c[len])) {}
    // either strchr failed or len is now -1
    if (len &lt; 0) {
        *c = 0;
        return 0;
    }
    c[++len] = 0;
    return len;
}
</code></pre>

<p>We can now finish the parser out with the most complex function in it: <code>parse_kv</code> with an incredible 12 lines of code, including a callback. The closest PEG analogue is <code>kv &lt;- key ws* value</code> (where&#39;s the “=”? <code>parse_kv</code> takes care of it, and the whitespace before it for us).</p>

<pre><code>int parse_kv(FILE *src, void *userdata, const char *section, char *key, char *value, callback cb) {
    int len = 0, tmp;

    tmp = parse_key(src, key); // consumes the =
    // if the key doesn&#39;t have a value or errored, we can&#39;t continue
    if (tmp &lt;= 0 || feof(src)) return 0;
    len += tmp;

    tmp = parse_skipws(src); // the whitespace after the &#34;=&#34;
    // if the value would have been empty, it ends up using the next line as the value
    // it may not error or eof, but it may be empty
    if (tmp &lt; 0 || feof(src)) return 0;
    len += tmp;

    tmp = parse_value(src, value);
    // any errors are fine, since we&#39;ve finished parsing now
    len += tmp &gt; 0 ? tmp : -tmp;

    // let callback request terminating the parse by returning non-zero
    if (cb(section, key, value, userdata)) len *= -1;
    return len;
}
</code></pre>

<p>And that&#39;s it, you have a functioning parser.</p>

<h2 id="discussion">Discussion</h2>

<p>To explain what&#39;s going on here on a less “here&#39;s the code, enjoy” level, we need to explain some of the jargon.</p>

<p>A grammar is the definition of the language being parsed. One may intuitively presume that the grammar for a given language or format is merely itself, i.e. that the BNF form is canonical. However, this is not the case. A grammar is actually dependent upon the parser in use. To discuss the platonic ideal of the language being recognized, we use the term “language”.</p>

<p>Any given language can have an arbitrary number of grammars describing it. These grammars are considered functionally equivalent. Since the language rarely if ever specifies expected resolutions to edge-conditions (if it did, it would be a “deterministic” language), grammars can be functionally equivalent while exhibiting different behaviors.</p>

<p>For example, let&#39;s consider the Lua language. The Lua language includes the following rules:</p>

<pre><code>prefixexp &lt;- var | functioncall | &#39;(&#39; exp &#39;)&#39;
functioncall &lt;- prefixexp args | prefixexp &#39;:&#39; Name args
var &lt;- Name | prefixexp &#39;[&#39; exp &#39;]&#39; | prefixexp &#39;.&#39; Name
</code></pre>

<p>This grammar is left-recursive. This means that a category of parsing algorithms cannot parse it! There are a number of reformulations that you can apply to achieve a different grammar that does not have the left-recursion problem, which will then recognize the Lua language successfully, but may have different edge-case behaviors (that are nowhere in the spec).</p>

<p>In short, there are a few reasons that parsing is a mess, and none of those reasons are actually resolvable by parser generators. For example, you <em>will</em> need to modify your grammar to get it to run on, say, tree-sitter, or antlr4, or Janet&#39;s PEGs.</p>

<p>A lot of the problem and solution space actually exists in the grammar definition, language design, and implementation flexibility. In this project, I set out to demonstrate all three.</p>

<p>For instance, you may notice that there is essentially zero error-reporting in the entire library. This is because I built the grammar in such a way that most inputs that are likely to actually occur are valid! Those that aren&#39;t will typically occur at the end of the file, and thus not affect the overall utility. Similarly, LL(1) is typically lexed, but I built the grammar in such a way as to be able to do LL(1) scannerless.</p>

<p>To summarize, to be good at parsing, you do not need to be an academic wizard, or to know all parsing theory. You need to be aware of the typical failure modes and make your own job easier by building in the flexibility you will then immediately use. The only exception is when you&#39;re implementing a strict specification that does specify what the edge-conditions do. Thankfully, those virtually do not exist, since specification writers <em>often</em> are aware of this. This is why the BNF forms of formal languages are so seemingly useless – it&#39;s there for your benefit, like undefined behavior in C, except it&#39;s <em>actually</em> beneficial.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Write your parsers, it can be fun and easy if you don&#39;t make it hard for yourself. The “true” (not edited for the article) sources of this tiny ini parsing library are available <a href="https://github.com/CosmicToast/bread.h/blob/main/ini.h" rel="nofollow">here</a> in single-header form. It also contains an implementation of <code>parse_while</code>, just for you, in case you happen to be building a parser that can take advantage of the same things I did (i.e. that is an LL(1)-compatible grammar that doesn&#39;t need a lexing phase; though you&#39;ll likely want to pass around a context struct instead of three bare pointers). It can also do heap allocation, so you know.</p>

<p>Hopefully, this has taught you something, and you&#39;ll reach for parser generators less.
I do find it amusing how I ended up publishing this one before irex (a from scratch “irregular” expression educational library). It may or may not be the next article, presuming I actually finish it.</p>

<p>P.S. This blog will eventually move to the bunkerlabs.net domain... somewhere. There&#39;s currently an OIDC identity provider in the works that should be trivial to self-host that will be used to authenticate various services. Long story short, hopefully sometime in the next year, this blog will be ported over to there. The front page will likely mention the new location once that&#39;s a thing (there is no front page currently).</p>
</div></div>
  </body>
</html>
