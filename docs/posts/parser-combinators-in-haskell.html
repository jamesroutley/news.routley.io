<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://serokell.io/blog/parser-combinators-in-haskell">Original</a>
    <h1>Parser Combinators in Haskell</h1>
    
    <div id="readability-page-1" class="page"><div>
<p>Welcome! If you are reading this, you likely have decided to take on the journey of learning parser combinators. We hope this article will make your adventure smoother and hopefully give you a strong foundation for writing your grammars.</p>
<p>This article is composed of three major parts. In the first part, we will implement a small parser combinator library from scratch, which should hopefully help to give a feeling of how industrial-strength parsing combinators work. In the second part, we will learn how to use the Megaparsec library to implement a parser for S-expressions. Finally, as a bonus, we will use the power of Template Haskell to implement a quasi-quoter for our parser.</p>
<h2 id="what-is-a-parser-combinator-and-why-use-them%3F"><p>What is a parser combinator and why use them?</p></h2>

<p>In 2001, Daan Leijen and Erik Meijer published a paper titled <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">Parsec: Direct Style Monadic Parser Combinators For The Real World</a>, describing the <a href="https://hackage.haskell.org/package/parsec"><code>parsec</code></a> library, whose design consequently influenced various others, such as <a href="https://hackage.haskell.org/package/megaparsec"><code>megaparsec</code></a>, <a href="https://hackage.haskell.org/package/attoparsec"><code>attoparsec</code></a>, <a href="https://hackage.haskell.org/package/trifecta"><code>trifecta</code></a>, and even libraries outside the Haskell ecosystem, such as <a href="https://hexdocs.pm/nimble_parsec/NimbleParsec.html"><code>NimbleParsec</code></a> for Elixir, <a href="https://pythonhosted.org/parsec/"><code>parsec</code></a> for Python, <a href="https://www.quanttec.com/fparsec/"><code>FParsec</code></a> for F#, among others.</p>
<p>Parser combinators are known to be simple to use without requiring external tools or too many concepts to learn. That is, they are ordinary Haskell constructors that can easily be combined and returned with other parsers because of their nature as functions. This, in turn, makes them idiomatic to use, and being a popular choice among Haskellers, their ecosystem is pretty developed. You should have no trouble finding tutorials and documentation on how to use them.</p>
<p>It’s important to notice that parser combinators also have their flaws. Parser combinators may be implemented as either LL(1) or LL(∞) parsers, which, elaborating on the points described in Kirill Andreev’s <a href="https://serokell.io/blog/how-to-implement-lr1-parser">How to Implement an LR(1) Parser</a>:</p>
<ol>
<li>Don’t support left recursion. That is to say, if there is a rule <code>foo = foo *&gt; bar</code>, you might need to refactor your grammar otherwise it will loop forever.</li>
<li>Don’t resolve conflicts, which we will see as an example later in this article. This means the ordering of rules can influence the output, and you need to be careful when defining rules that can consume the same input.
<ul>
<li>In an LL(1) implementation, it will pick the first alternative that maches the input.</li>
<li>In an LL(∞) implementation, it will try the longest possible match, which may be very inneficient.</li>
</ul>
</li>
<li>Many parser combinator libraries will backtrack, which will also be exemplified later, meaning that you might need to be careful to avoid performance penalties.</li>
<li>The backtracking mechanism may, in turn, lead to exponential time complexities.</li>
</ol>
<p>This shouldn’t, however, discourage you from their use, as their benefits outweigh the drawbacks. Ultimately, the parsing library of your choice should be chosen based on your needs, and parser combinators are a good fit for most use cases.</p>
<h2 id="implementing-a-simple-parser-combinator-from-scratch"><p>Implementing a simple parser combinator from scratch</p></h2>

<p>Before we delve into <code>megaparsec</code>, it may be interesting to implement our parser combinator from scratch. We will make a simple one that should hopefully help you understand how parser combinators work.</p>
<p>If you instead prefer to jump right into the action, then skip to the <a href="#megaparsec-tutorial">Megaparsec tutorial</a>.</p>
<h3 id="implementation"><p>Implementation</p></h3>
<p>We will begin by importing the appropriate definitions in a new file called <code>Parser.hs</code>:</p>
<pre><code><span>module</span> Parser <span>where</span>

<span>import</span> Control.Applicative (<span>Alternative</span> (..))
<span>import</span> Data.List (<span>nub</span>)
</code></pre>
<p>We will create two data structures that represent our parser.</p>
<p>The first of them represents some error that may happen while parsing. For now, let’s have three errors: one that is raised when we are expecting input but there is nothing to consume (<code>EndOfInput</code>), one when we find an unexpected character (<code>Unexpected</code>), and one for any error messages that the user might want to raise (<code>CustomError</code>).</p>
<p>Our second structure is the actual parser. It’s represented as a function that takes some input and either returns a list of errors, if <code>Left</code>, or the result of parsing the input together with the rest of the input (that was not parsed), if <code>Right</code>.</p>
<pre><code><span><span>data</span> <span>Error</span> i e</span>
  = <span>EndOfInput</span>  
  | <span>Unexpected</span> i  
  | <span>CustomError</span> e  
  | <span>Empty</span>  
  <span>deriving</span> (<span>Eq</span>, <span>Show</span>)

<span><span>newtype</span> <span>Parser</span> i e a = <span>Parser</span></span>
  { runParser :: [i] -&gt; <span>Either</span> [<span>Error</span> i e] (a, [i])
  }
</code></pre>
<p>This is the meaning of each of the type variables:</p>
<ul>
<li><code>i</code>: The input stream. For most cases, we will use <code>Char</code>, as <code>[Char]</code> is the same as <code>String</code>. It’s interesting to notice that keeping this as a type variable allows us to parse things that are not strings as well.</li>
<li><code>e</code>: The type of custom error messages. If we don’t have those, we may use <code>Void</code> instead.</li>
<li><code>a</code>: The result of our parsing function. It represents the structure parsed from our consumed input.</li>
</ul>
<p>Let’s begin by creating the most primitive function: <code>satisfy</code>. It tests the current character with a predicate, and if it succeeds, it will advance the parser and return the consumed character.</p>
<p>We must take care that we are not at the end of the input, however, in which case we should fail.</p>
<pre><code><span>satisfy</span> :: (i -&gt; <span>Bool</span>) -&gt; <span>Parser</span> i e i
<span>satisfy</span> predicate = <span>Parser</span> $ \input -&gt;
  <span>case</span> input <span>of</span>
    [] -&gt; <span>Left</span> [<span>EndOfInput</span>]
    hd : rest
      | predicate hd -&gt; <span>Right</span> (hd, rest)
      | otherwise    -&gt; <span>Left</span> [<span>Unexpected</span> hd]
</code></pre>
<p>It’s also common to define a function that only succeeds if the input strictly matches some given element.</p>
<pre><code><span>char</span> :: <span>Eq</span> i =&gt; i -&gt; <span>Parser</span> i e i
<span>char</span> i = satisfy (== i)
</code></pre>
<p>If you load this in GHCi, you should now be able to test it:</p>
<pre><code>&gt;&gt;&gt; :l <span>Parser</span>

&gt;&gt;&gt; runParser (char &#39;h&#39;) <span>&#34;hello&#34;</span>
<span>Right</span> (&#39;h&#39;, <span>&#34;ello&#34;</span>)

&gt;&gt;&gt; runParser (char &#39;h&#39;) <span>&#34;greetings&#34;</span>
<span>Left</span> [<span>Unexpected</span> &#39;g&#39;]

&gt;&gt;&gt; runParser (char &#39;h&#39;) <span>&#34;&#34;</span>
<span>Left</span> [<span>EndOfInput</span>]
</code></pre>
<p>Let’s now create <code>Monad</code> and <code>Alternative</code> instances for our parser. For educative purposes, we will also explicitly implement <code>Functor</code> and <code>Applicative</code> instead of <code>fmap = liftM</code> and <code>(&lt;*&gt;) = ap</code>.</p>
<p>We start with <code>Functor</code>. Since we map over the <code>a</code> type variable obtained in the case of a successful parse, we can only apply <code>f</code> in case of <code>Right</code>.</p>
<pre><code><span><span>instance</span> <span>Functor</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  fmap f (<span>Parser</span> p) = <span>Parser</span> $ \input -&gt;
    <span>case</span> p input <span>of</span>
      <span>Left</span> err -&gt; <span>Left</span> err
      <span>Right</span> (output, rest) -&gt; <span>Right</span> (f output, rest)
</code></pre>
<p>Since <code>Either</code> is a monad, we can use do-notation. Here’s an implementation that’s a little shorter:</p>
<pre><code><span><span>instance</span> <span>Functor</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  fmap f (<span>Parser</span> p) = <span>Parser</span> $ \input -&gt; <span>do</span>
    (output, rest) &lt;- p input
    pure (f output, rest)
</code></pre>
<p>Next up is <code>Applicative</code>. A good intuition behind <code>Applicative</code>s is that <code>pure</code> represents an identity element, while <code>&lt;*&gt;</code> distributes one argument over the other. Think of this like a multiplication, where <code>0 * a = a * 0 = 0</code>, while <code>1 * a = a * 1 = a</code>.</p>
<p>To illustrate this, observe this table:</p>
<table>
<thead>
<tr>
<th></th>
<th>Left parser failed</th>
<th>Left parser succeeded</th>
</tr>
</thead>
<tbody>
<tr>
<td>Right parser failed</td>
<td>Error from left parser</td>
<td>Error from right parser</td>
</tr>
<tr>
<td>Right parser succeeded</td>
<td>Error from left parser</td>
<td>Success</td>
</tr>
</tbody>
</table>
<p>Note that even if both parsers fail, we only want the error from the first one, as we execute the second one only if the first one succeeded.</p>
<p>This is due to the <code>Either</code> part of the parser, where <code>Left</code> is like <code>0</code> and <code>Right</code> is like 1. <code>pure</code> represents our <code>1</code>, so it should create a parser that always succeeds without consuming any input.</p>
<p>And similarly to <code>Either</code>, we want <code>&lt;*&gt;</code> to fail in case any of the operands result in a failed parse given some input. This implementation tries to run the left operand, which consumes some input and produces a function as well as the unconsumed input. The rest of the input is given to the right operand, and in case of success, it applies the function to the argument.</p>
<pre><code><span><span>instance</span> <span>Applicative</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  pure a = <span>Parser</span> $ \input -&gt; <span>Right</span> (a, input)

  <span>Parser</span> f &lt;*&gt; <span>Parser</span> p = <span>Parser</span> $ \input -&gt;
    <span>case</span> f input <span>of</span>
      <span>Left</span> err -&gt; <span>Left</span> err
      <span>Right</span> (f&#39;, rest) -&gt;
        <span>case</span> p rest <span>of</span>
          <span>Left</span> err -&gt; <span>Left</span> err
          <span>Right</span> (output, rest&#39;) -&gt; <span>Right</span> (f&#39; output, rest&#39;)
</code></pre>
<p>Or with <code>Either</code>’s monad instance:</p>
<pre><code><span><span>instance</span> <span>Applicative</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  pure a = <span>Parser</span> $ \input -&gt; <span>Right</span> (a, input)

  <span>Parser</span> f &lt;*&gt; <span>Parser</span> p = <span>Parser</span> $ \input -&gt; <span>do</span>
    (f&#39;, rest) &lt;- f input
    (output, rest&#39;) &lt;- p rest
    pure (f&#39; output, rest&#39;)
</code></pre>
<p>In our <code>Monad</code> instance, we set <code>return = pure</code> as usual. Our bind is more interesting: we try to run the given parser with the input, and if it succeeds, we give the produced output (of type <code>a</code>) to our continuation <code>k</code>, which produces a parser that is executed with the remainder of the output.</p>
<pre><code><span><span>instance</span> <span>Monad</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  return = pure

  <span>Parser</span> p &gt;&gt;= k = <span>Parser</span> $ \input -&gt;
    <span>case</span> p input <span>of</span>
      <span>Left</span> err -&gt; <span>Left</span> err
      <span>Right</span> (output, rest) -&gt;
        <span>let</span>
          <span>Parser</span> p&#39; = k output
        <span>in</span>
        p&#39; rest
</code></pre>
<p>Again, using the fact that <code>Either</code> is a monad, we can simplify this implementation:</p>
<pre><code><span><span>instance</span> <span>Monad</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  return = pure

  <span>Parser</span> p &gt;&gt;= k = <span>Parser</span> $ \input -&gt; <span>do</span>
    (output, rest) &lt;- p input
    runParser (k output) rest
</code></pre>
<p>With our <code>Applicative</code> and <code>Monad</code> instances, we are now able to <strong>parse sequentially</strong>. For example, we defined <code>char</code> above to let us parse a single character, but what if we wanted to parse many of them?</p>
<pre><code><span>string</span> :: <span>Eq</span> i =&gt; [i] -&gt; <span>Parser</span> i e [i]
<span>string</span> = traverse char
</code></pre>
<p>If <code>traverse</code> is new to you, it’s also equivalent to these definitions:</p>
<pre><code><span>string</span> :: <span>Eq</span> i =&gt; [i] -&gt; <span>Parser</span> i e [i]
<span>string</span> [] = pure []
<span>string</span> (x : xs) = (:) &lt;$&gt; char x &lt;*&gt; string xs
</code></pre>
<p>Or even in terms of <code>Monad</code>:</p>
<pre><code><span>string</span> [] = return []
<span>string</span> (x : xs) = <span>do</span>
  y &lt;- char x
  ys &lt;- string xs
  return (y : ys)
</code></pre>
<p>Let’s try it in GHCi:</p>
<pre><code>&gt;&gt;&gt; runParser (string <span>&#34;Haskell&#34;</span>) <span>&#34;Haskell&#34;</span>
<span>Right</span> (<span>&#34;Haskell&#34;</span>,<span>&#34;&#34;</span>)

&gt;&gt;&gt; runParser (string <span>&#34;Haskell&#34;</span>) <span>&#34;Halloween&#34;</span>
<span>Left</span> [<span>Unexpected</span> &#39;l&#39;]
</code></pre>
<p>Finally, our last instance: <code>Alternative</code>. This may be new for you, so I will explain. First, take a look at its definition, which can be found in <code>Control.Applicative</code>:</p>
<pre><code><span><span>class</span> <span>Applicative</span> f =&gt; <span>Alternative</span> f <span>where</span></span>
  empty :: f a
  (&lt;|&gt;) :: f a -&gt; f a -&gt; f a
</code></pre>
<p>I mentioned that <code>pure</code> acts as <code>1</code>, which is a parser that always succeeds without consuming input. <code>empty</code> works like the converse (or <code>0</code>), that is a parser that always fails without consuming input.</p>
<p>For <code>(&lt;|&gt;)</code>, we want to implement it such that <strong>the first parser to succeed is used</strong>. That is, we first try the left operand, and failing that, we try the second one. The table below shall guide you:</p>
<table>
<thead>
<tr>
<th></th>
<th>Left parser failed</th>
<th>Left parser succeeded</th>
</tr>
</thead>
<tbody>
<tr>
<td>Right parser failed</td>
<td>Errors from both parsers</td>
<td>Left parser</td>
</tr>
<tr>
<td>Right parser succeeded</td>
<td>Right parser</td>
<td>Left parser</td>
</tr>
</tbody>
</table>
<p>Here is an implementation of <code>Alternative</code>. We constrain <code>i</code> and <code>e</code> with <code>Eq</code> so we can use <code>nub</code> to remove duplicated errors. Note that this is not the best or most efficient way to merge errors, but for our purposes, it’s good enough.</p>
<pre><code><span><span>instance</span> (<span>Eq</span> <span>i</span>, <span>Eq</span> <span>e</span>) =&gt; <span>Alternative</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  empty = <span>Parser</span> $ \_ -&gt; <span>Left</span> [<span>Empty</span>]

  <span>Parser</span> l &lt;|&gt; <span>Parser</span> r = <span>Parser</span> $ \input -&gt;
    <span>case</span> l input <span>of</span>
      <span>Left</span> err -&gt;
        <span>case</span> r input <span>of</span>
          <span>Left</span> err&#39; -&gt; <span>Left</span> $ nub $ err &lt;&gt; err&#39;
          <span>Right</span> (output, rest) -&gt; <span>Right</span> (output, rest)
      <span>Right</span> (output, rest) -&gt; <span>Right</span> (output, rest)
</code></pre>
<p>Finally, let’s test it!</p>
<pre><code>&gt;&gt;&gt; runParser (string <span>&#34;hello&#34;</span> &lt;|&gt; string <span>&#34;greetings&#34;</span>) <span>&#34;hello, world&#34;</span>
<span>Right</span> (<span>&#34;hello&#34;</span>,<span>&#34;, world&#34;</span>)

&gt;&gt;&gt; runParser (string <span>&#34;hello&#34;</span> &lt;|&gt; string <span>&#34;greetings&#34;</span>) <span>&#34;greetings, world&#34;</span>
<span>Right</span> (<span>&#34;greetings&#34;</span>,<span>&#34;, world&#34;</span>)

&gt;&gt;&gt; runParser (string <span>&#34;hello&#34;</span> &lt;|&gt; string <span>&#34;greetings&#34;</span>) <span>&#34;bye, world&#34;</span>
<span>Left</span> [<span>Unexpected</span> &#39;b&#39;]

&gt;&gt;&gt; runParser (empty &lt;|&gt; pure ()) <span>&#34;&#34;</span>
<span>Right</span> ()

&gt;&gt;&gt; runParser (pure () &lt;|&gt; empty) <span>&#34;&#34;</span>
<span>Right</span> ()
</code></pre>
<p>We can see our errors composing with a more complicated expression:</p>
<pre><code>&gt;&gt;&gt; runParser ((string <span>&#34;hello&#34;</span> *&gt; string <span>&#34;, globe&#34;</span>) &lt;|&gt; string <span>&#34;greetings&#34;</span>) <span>&#34;hello, world&#34;</span>
<span>Left</span> [<span>Unexpected</span> &#39;w&#39;,<span>Unexpected</span> &#39;h&#39;]
</code></pre>
<p>Hopefully, this should give you an intuition of how parser combinators work. Popular parser combinator libraries are more complex than this, as they tend to keep track of extra state for better error messages, optimization, information about line and column, etc., but the overall operations between them are similar.</p>
<p>The complete code for this section with solutions to the exercises below can be found <a href="https://gist.github.com/heitor-lassarote/3e7314956e86b8227f6f6040e69aca9d">here</a>.</p>
<h3 id="exercises"><p>Exercises</p></h3>
<ol>
<li>Change <code>char</code> so that it returns errors such as <code>Left [Expected &#39;h&#39; &#39;g&#39;]</code> (“Expected ‘h’, but got ‘g’”).</li>
</ol>
<details>
  <summary>Solution</summary>
Begin by creating a new error:
<pre><code><span><span>data</span> <span>Error</span> i e</span>
  = ...
  | <span>Expected</span> i i
</code></pre>
<p>Next, we will refactor the code originally in <code>satisfy</code> into <code>token</code>, just so we avoid duplicating code. Then, rewrite <code>satisfy</code> to use this new function, and rewrite <code>char</code> to make use of it as well.</p>
<p>The important part is simply that we change the error message.</p>
<pre><code><span>token</span> :: (i -&gt; <span>Error</span> i e) -&gt; (i -&gt; <span>Bool</span>) -&gt; <span>Parser</span> i e i
<span>token</span> mkErr predicate = <span>Parser</span> $ \input -&gt;
  <span>case</span> input <span>of</span>
    [] -&gt; <span>Left</span> [<span>EndOfInput</span>]
    hd : rest
      | predicate hd -&gt; <span>Right</span> (hd, rest)
      | otherwise    -&gt; <span>Left</span> [mkErr hd]

<span>satisfy</span> :: (i -&gt; <span>Bool</span>) -&gt; <span>Parser</span> i e i
<span>satisfy</span> = token <span>Unexpected</span>

<span>char</span> :: <span>Eq</span> i =&gt; i -&gt; <span>Parser</span> i e i
<span>char</span> i = token (<span>Expected</span> i) (== i)
</code></pre>
<p>In GHCi you should see:</p>
<pre><code>&gt;&gt;&gt; parse (char &#39;h&#39;) <span>&#34;bye&#34;</span>
<span>Left</span> [<span>Expected</span> &#39;h&#39; &#39;b&#39;]
</code></pre>
  <hr/>
</details>
<ol start="2">
<li>Create an <code>eof :: Parser i e ()</code> function which succeeds only if we have arrived at the end of the input.
<ul>
<li><code>runParser (string &#34;hello&#34; &lt;* eof) &#34;hello&#34;</code> should return <code>Right (&#34;hello&#34;, &#34;&#34;)</code></li>
<li><code>runParser (strung &#34;hello, world&#34; &lt;* eof) &#34;&#34;</code> should return <code>Left [ExpectedEndOfFile &#39;,&#39;]</code> (“Expected EOF, but got ‘,’”)</li>
</ul>
</li>
</ol>
<details>
  <summary>Solution</summary>
First, create a new error:
<pre><code><span><span>data</span> <span>Error</span> i e</span>
  = ...
  | <span>ExpectedEndOfFile</span> i
</code></pre>
<p>Now create a function that returns <code>Right</code> only if there is no more input, and an error otherwise.</p>
<pre><code><span>eof</span> :: <span>Parser</span> i e ()
<span>eof</span> = <span>Parser</span> $ \input -&gt;
  <span>case</span> input <span>of</span>
    []     -&gt; <span>Right</span> ((), [])
    hd : _ -&gt; <span>Left</span> [<span>ExpectedEndOfFile</span> hd]
</code></pre>
<p>Trying it out in GHCi:</p>
<pre><code>&gt;&gt;&gt; parse (string <span>&#34;bye&#34;</span> &lt;* eof) <span>&#34;bye&#34;</span>
<span>Right</span> (<span>&#34;bye&#34;</span>,<span>&#34;&#34;</span>)

&gt;&gt;&gt; parse (string <span>&#34;bye&#34;</span> &lt;* eof) <span>&#34;byebye&#34;</span>
<span>Left</span> [<span>ExpectedEndOfFile</span> &#39;b&#39;]
</code></pre>
  <hr/>
</details>
<ol start="3">
<li>Change the definition of <code>Parser</code> so it contains a <code>[i] -&gt; Offset -&gt; (Either [Error i e] (Offset, a, [i]))</code>, where <code>type Offset = Int</code>. The offset indicates how many positions we have parsed.
<ul>
<li>You may also change <code>Error</code> to store an offset so that you can indicate where an error occurred.</li>
<li><code>runParser (string &#34;hey&#34;) 0 &#34;hi&#34;</code> should return <code>Left [Error {erOffset = 1, erError = Expected &#39;e&#39; &#39;i&#39;}]</code> (“Unexpected ‘e’, but got ‘i’, at position 1”)</li>
</ul>
</li>
</ol>
<details>
  <summary>Solution</summary>
The solution is mostly mechanically replacing definitions where errors occurred.
<p>First, we rename <code>Error</code> to <code>ErrorType</code>, and create a new <code>Error</code> type:</p>
<pre><code><span><span>data</span> <span>Error</span> i e = <span>Error</span></span>
  { erOffset :: <span>Offset</span>
  , erError :: <span>ErrorType</span> i e
  } <span>deriving</span> (<span>Eq</span>, <span>Show</span>)

<span><span>data</span> <span>ErrorType</span> i e</span>
  = ...
</code></pre>
<p>If you’ve done the previous exercises, then <code>token</code> may be changed now to take <code>offset</code> as input to the parser’s function, and return <code>offset + 1</code> on success. If an error occurred instead, we now construct <code>Error</code> with the given input. Our <code>mkErr</code> function should not take an <code>ErrorType</code> instead of <code>Error</code>.</p>
<pre><code><span>token</span> :: (i -&gt; <span>ErrorType</span> i e) -&gt; (i -&gt; <span>Bool</span>) -&gt; <span>Parser</span> i e i
<span>token</span> mkErr predicate = <span>Parser</span> $ \input offset -&gt;
  <span>case</span> input <span>of</span>
    [] -&gt; <span>Left</span> [<span>Error</span> offset <span>EndOfInput</span>]
    hd : rest
      | predicate hd -&gt; <span>Right</span> (offset + <span>1</span>, hd, rest)
      | otherwise    -&gt; <span>Left</span> [<span>Error</span> offset $ mkErr hd]
</code></pre>
<p>If you haven’t done the previous exercises, then change <code>satisfy</code> in a similar manner, taking <code>offset</code> as input and returning <code>offset + 1</code>, and error <code>Error offset $ Unexpected hd</code> on the error.</p>
<p>For the remainder of the functions, change the parser function to also take <code>offset</code> as an argument, and just return it unaffected. Take care to chain these offsets as required. For example, this is the new definition of <code>Applicative</code>:</p>
<pre><code><span><span>instance</span> <span>Applicative</span> (<span>Parser</span> <span>i</span> <span>e</span>) <span>where</span></span>
  pure a = <span>Parser</span> $ \input offset -&gt; <span>Right</span> (offset, a, input)

  <span>Parser</span> f &lt;*&gt; <span>Parser</span> p = <span>Parser</span> $ \input offset -&gt;
    <span>case</span> f input offset <span>of</span>
      <span>Left</span> err -&gt; <span>Left</span> err
      <span>Right</span> (offset&#39;, f&#39;, rest) -&gt;
        <span>case</span> p rest offset&#39; <span>of</span>
          <span>Left</span> err -&gt; <span>Left</span> err
          <span>Right</span> (offset&#39;&#39;, output, rest&#39;) -&gt; <span>Right</span> (offset&#39;&#39;, f&#39; output, rest&#39;)
</code></pre>
<p>Finally, in <code>parse</code>, use <code>0</code> as the initial offset.</p>
<p>Keep in mind it’s also possible to operate with line and column when you know you have a function operating in characters.</p>
<pre><code>&gt;&gt;&gt; parse (string <span>&#34;hey&#34;</span>) <span>&#34;hi&#34;</span>
<span>Left</span> [<span>Error</span> {erOffset = <span>1</span>, erError = <span>Expected</span> &#39;e&#39; &#39;i&#39;}]
</code></pre>
<p>The reader may also choose to instead refactor the parser type to use a custom-defined <code>State</code> type that contains the input stream and offset. Many improvements are possible, but we choose to keep it simple for educational purposes.</p>
  <hr/>
</details>
</div></div>
  </body>
</html>
