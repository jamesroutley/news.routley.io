<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hillelwayne.com/post/what-comments/">Original</a>
    <h1>Maybe comments should explain &#39;what&#39; (2017)</h1>
    
    <div id="readability-page-1" class="page"><article lang="en">
    

    
    

    <div>
  <p>People say “Comments should explain why, not what.” I feel like starting a flame war today so I’m going to argue that comments should explain ‘what’ too. Please don’t use this as justification to write bad code, okay? Okay.</p>

<p>First of all, why <em>shouldn’t</em> comments explain ‘what’? If you need comments to explain what’s going on, it suggests your code is unclear. If I write</p>

<pre><code>//weight, radius, price
w = 10, r = 9, p = 1
</code></pre>

<p>That’s not as clear as saying</p>

<pre><code>weight = 10, radius = 9, price = 3
</code></pre>

<p>“But it’s obvious that <code>w</code> is <code>weight</code>!” Sure, if you’re seeing those lines back-to-back. But presumably you’re initializing the variable to use it, which means that it’s going to appear later. When you see <code>w</code> later in the body, you need to go back and check what it is. That’s a frustrating context switch and you may skip it, possibly assuming that <code>w</code> is… width. Then bad things happen. So comments are not a substitute for clean code.</p>

<p>Okay,  so why <em>should</em> comments explain why? Some people argue that we should instead store the ‘why’ in <a href="http://mentalized.net/journal/2014/09/01/commit-messages-deserve-care-and-tenderness/">commit messages</a> or <a href="https://twitter.com/sarahmei/status/937881294788108288">tests</a>. Most people feel icky about this, though. Given:</p>

<pre><code>// Clear twice to deal with bug ABC in library XYZ, see [link]
XYZ.clear(); XYZ.clear();
</code></pre>

<p>Would you prefer that comment be removed and placed in the commit message? Then if you want to learn why <code>XYZ.clear()</code> is repeated twice, you have to dig up the commit. That can be a difficult and tedious job, especially if the line was reformatted, moved between files, anything that makes <code>git blame</code> not work. Searching all that is a context switch and you may skip it, possibly assuming that it’s a bug you can remove. Then bad things happen.</p>

<p>Both of these cases share the same problem: looking things up is hard. Best case it’s a context switch that takes time away from understanding the problem. Worst case you don’t look it up and make a potentially-dangerous assumption. It’s better to keep the information in the exact same place that you need it, whether that’s via descriptive code or comments over commits.</p>

<p>Now for the weird part. What if your descriptive code forces a context switch? Let’s take the code from Bob Martin’s <a href="https://sites.google.com/site/unclebobconsultingllc/one-thing-extract-till-you-drop">Extract Till You Drop</a>.</p>
<div><pre><code data-lang="java"><span></span><span>    String </span><span>replace</span><span>() {</span>
<span>      Pattern symbolPattern </span><span>=</span><span> Pattern.</span><span>compile</span><span>(</span><span>&#34;\\$([a-zA-Z]\\w*)&#34;</span><span>);</span>
<span>      Matcher symbolMatcher </span><span>=</span><span> symbolPattern.</span><span>matcher</span><span>(stringToReplace);</span>
<span>      </span><span>while</span><span> (symbolMatcher.</span><span>find</span><span>()) {</span>
<span>        String symbolName </span><span>=</span><span> symbolMatcher.</span><span>group</span><span>(</span><span>1</span><span>);</span>
<span>        </span><span>if</span><span> (getSymbol(symbolName) </span><span>!=</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>alreadyReplaced.</span><span>contains</span><span>(symbolName)) {</span>
<span>          alreadyReplaced.</span><span>add</span><span>(symbolName);</span>
<span>          stringToReplace </span><span>=</span><span> stringToReplace.</span><span>replace</span><span>(</span><span>&#34;$&#34;</span><span> </span><span>+</span><span> symbolName, translate(symbolName));</span>
<span>        }</span>
<span>      }</span>
<span>      </span><span>return</span><span> stringToReplace;</span>
</code></pre></div>

<p>To make it more understandable, he replaces it with this:</p>
<div><pre><code data-lang="java"><span></span><span>  String </span><span>replace</span><span>() {</span>
<span>      replaceAllSymbols();</span>
<span>      </span><span>return</span><span> stringToReplace;</span>
<span>    }</span>

<span>    </span><span>private</span><span> </span><span>void</span><span> </span><span>replaceAllSymbols</span><span>() {</span>
<span>      </span><span>for</span><span> (String symbolName </span><span>=</span><span> nextSymbol(); symbolName </span><span>!=</span><span> </span><span>null</span><span>; symbolName </span><span>=</span><span> nextSymbol())</span>
<span>        replaceAllInstances(symbolName);</span>
<span>    }</span>

<span>    </span><span>private</span><span> String </span><span>nextSymbol</span><span>() {</span>
<span>      </span><span>return</span><span> symbolMatcher.</span><span>find</span><span>() </span><span>?</span><span> symbolMatcher.</span><span>group</span><span>(</span><span>1</span><span>) : </span><span>null</span><span>;</span>
<span>    }</span>

<span>    </span><span>private</span><span> </span><span>void</span><span> </span><span>replaceAllInstances</span><span>(String symbolName) {</span>
<span>      </span><span>if</span><span> (shouldReplaceSymbol(symbolName))</span>
<span>        replaceSymbol(symbolName);</span>
<span>    }</span>

<span>    </span><span>private</span><span> </span><span>boolean</span><span> </span><span>shouldReplaceSymbol</span><span>(String symbolName) {</span>
<span>      </span><span>return</span><span> getSymbol(symbolName) </span><span>!=</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>alreadyReplaced.</span><span>contains</span><span>(symbolName);</span>
<span>    }</span>

<span>    </span><span>private</span><span> </span><span>void</span><span> </span><span>replaceSymbol</span><span>(String symbolName) {</span>
<span>      alreadyReplaced.</span><span>add</span><span>(symbolName);</span>
<span>      stringToReplace </span><span>=</span><span> stringToReplace.</span><span>replace</span><span>(</span>
<span>        symbolExpression(symbolName),</span>
<span>        translate(symbolName));</span>
<span>    }</span>

<span>    </span><span>private</span><span> String </span><span>symbolExpression</span><span>(String symbolName) {</span>
<span>      </span><span>return</span><span> </span><span>&#34;$&#34;</span><span> </span><span>+</span><span> symbolName;</span>
<span>    }</span>
</code></pre></div>

<p>So much better, right?! <code>replace</code> is now two lines instead of ten. But now there’s six other methods you have to read to understand how the class works. “But it’s easier to follow.” Not if I’m trying to track down a bug and I have to keep scrolling up and down, jumping from method to method to understand the whole. Is that really so much better than using comments?</p>
<div><pre><code data-lang="java"><span></span><span>    String </span><span>replace</span><span>() {</span>
<span>      Pattern symbolPattern </span><span>=</span><span> Pattern.</span><span>compile</span><span>(</span><span>&#34;\\$([a-zA-Z]\\w*)&#34;</span><span>); </span><span>//f.ex $F1a3</span>
<span>      Matcher symbolMatcher </span><span>=</span><span> symbolPattern.</span><span>matcher</span><span>(stringToReplace);</span>

<span>      </span><span>// Replace all symbols</span>
<span>      </span><span>while</span><span> (symbolMatcher.</span><span>find</span><span>()) {</span>
<span>        String symbolName </span><span>=</span><span> symbolMatcher.</span><span>group</span><span>(</span><span>1</span><span>);</span>
<span>        </span><span>// translate will replace all instances; only need to run it once</span>
<span>        </span><span>if</span><span> (getSymbol(symbolName) </span><span>!=</span><span> </span><span>null</span><span> </span><span>&amp;&amp;</span><span> </span><span>!</span><span>alreadyReplaced.</span><span>contains</span><span>(symbolName)) {</span>
<span>          alreadyReplaced.</span><span>add</span><span>(symbolName);</span>
<span>          stringToReplace </span><span>=</span><span> stringToReplace.</span><span>replace</span><span>(</span><span>&#34;$&#34;</span><span> </span><span>+</span><span> symbolName, translate(symbolName));</span>
<span>        }</span>
<span>      }</span>
<span>      </span><span>return</span><span> stringToReplace;</span>
</code></pre></div>

<p>I think that’s more understandable than either the original case or the clean code case, because you don’t have to context switch to a different method to understand what’s going on. Obviously this isn’t always the case, and often comments are superfluous. I’m just saying that there are at least a few cases where writing a ‘what’ comment is the right choice, so we shouldn’t reject them out-of-hand.</p>

<p>Welp that’s my argument so flame war awaaaaaaaaaay</p>


</div>

    



  </article></div>
  </body>
</html>
