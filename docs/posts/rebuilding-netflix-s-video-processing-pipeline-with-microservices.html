<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://netflixtechblog.com/rebuilding-netflix-video-processing-pipeline-with-microservices-4e5e6310e359?gi=d48b3333df75">Original</a>
    <h1>Rebuilding Netflix&#39;s video processing pipeline with microservices</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><div><div><div><div><div><a href="https://netflixtechblog.medium.com" rel="noopener follow"><div><div aria-hidden="false"><div><div><p><img alt="Netflix Technology Blog" src="https://miro.medium.com/v2/resize:fill:88:88/1*BJWRqfSMf9Da9vsXG9EBRQ.jpeg" width="44" height="44" loading="lazy" data-testid="authorPhoto"/></p></div></div></div></div></a><a href="https://netflixtechblog.com" rel="noopener  ugc nofollow"><div><div><div aria-hidden="false"><div><div><p><img alt="Netflix TechBlog" src="https://miro.medium.com/v2/resize:fill:48:48/1*ty4NvNrGg4ReETxqU2N3Og.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto"/></p></div></div></div></div></div></a></div></div></div></div></div></div></div><p id="67ae"><a href="https://www.linkedin.com/in/liwei-guo-a5aa6311/" rel="noopener ugc nofollow" target="_blank">Liwei Guo</a>, <a href="https://www.linkedin.com/in/anush-moorthy-b8451142/" rel="noopener ugc nofollow" target="_blank">Anush Moorthy</a>, <a href="https://www.linkedin.com/in/li-heng-chen-a75458a2/" rel="noopener ugc nofollow" target="_blank">Li-Heng Chen</a>, <a href="https://www.linkedin.com/in/carvalhovinicius/" rel="noopener ugc nofollow" target="_blank">Vinicius Carvalho</a>, <a href="https://www.linkedin.com/in/aditya-mavlankar-7139791/" rel="noopener ugc nofollow" target="_blank">Aditya Mavlankar</a>, <a href="https://www.linkedin.com/in/agataopalach/" rel="noopener ugc nofollow" target="_blank">Agata Opalach</a>, <a href="https://www.linkedin.com/in/adithyaprakash/" rel="noopener ugc nofollow" target="_blank">Adithya Prakash</a>, Kyle Swanson, <a href="https://www.linkedin.com/in/jessicatweneboah/" rel="noopener ugc nofollow" target="_blank">Jessica Tweneboah</a>, <a href="https://www.linkedin.com/in/subbu-venkatrav-126172a/" rel="noopener ugc nofollow" target="_blank">Subbu Venkatrav</a>, <a href="https://www.linkedin.com/in/lishan-z-51302abb/" rel="noopener ugc nofollow" target="_blank">Lishan Zhu</a></p><p id="994f"><em>This is the first blog in a multi-part series on how Netflix rebuilt its video processing pipeline with microservices, so we can maintain our rapid pace of innovation and continuously improve the system for member streaming and studio operations. This introductory blog focuses on an overview of our journey. Future blogs will provide deeper dives into each service, sharing insights and lessons learned from this process.</em></p><p id="4c32">The Netflix video processing pipeline went live with the launch of our streaming service in 2007. Since then, the video pipeline has undergone substantial improvements and broad expansions:</p><ul><li id="989a">Starting with Standard Dynamic Range (SDR) at <a href="https://en.wikipedia.org/wiki/Display_resolution" rel="noopener ugc nofollow" target="_blank">Standard-Definitions</a>, we expanded the encoding pipeline to 4K and High Dynamic Range (HDR) which enabled support for our premium offering.</li><li id="14a4">We moved from centralized linear encoding to <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/high-quality-video-encoding-at-scale-d159db052746">distributed chunk-based encoding</a>. This architecture shift greatly reduced the processing latency and increased system resiliency.</li><li id="4357">Moving away from the use of dedicated instances that were constrained in quantity, we tapped into Netflix’s <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/creating-your-own-ec2-spot-market-6dd001875f5">internal trough</a> created due to autoscaling microservices, leading to significant improvements in computation elasticity as well as resource utilization efficiency.</li><li id="f28f">We rolled out encoding innovations such as <a href="https://medium.com/netflix-techblog/per-title-encode-optimization-7e99442b62a2" rel="noopener">per-title</a> and <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/optimized-shot-based-encodes-now-streaming-4b9464204830">per-shot</a> optimizations, which provided significant quality-of-experience (QoE) improvement to Netflix members.</li><li id="9fbe">By integrating with studio content systems, we enabled the pipeline to leverage rich metadata from the creative side and create more engaging member experiences like <a href="https://en.wikipedia.org/wiki/Black_Mirror:_Bandersnatch" rel="noopener ugc nofollow" target="_blank">interactive storytelling</a>.</li><li id="d14f">We expanded pipeline support to serve our studio/content-development use cases, which had different latency and resiliency requirements as compared to the traditional streaming use case.</li></ul><p id="98bf">Our experience of the last decade-and-a-half has reinforced our conviction that an efficient, flexible video processing pipeline that allows us to innovate and support our streaming service, as well as our studio partners, is critical to the continued success of Netflix. To that end, the Video and Image Encoding team in Encoding Technologies (ET) has spent the last few years rebuilding the video processing pipeline on our next-generation microservice-based computing platform <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/the-netflix-cosmos-platform-35c14d9351ad">Cosmos</a>.</p><h2 id="c16e">Reloaded</h2><p id="b517">Starting in 2014, we developed and operated the video processing pipeline on our third-generation platform <a href="https://www.youtube.com/watch?v=JouA10QJiNc" rel="noopener ugc nofollow" target="_blank">Reloaded</a>. Reloaded was well-architected, providing good stability, scalability, and a reasonable level of flexibility. It served as the foundation for numerous encoding innovations developed by our team.</p><p id="1ede">When Reloaded was designed, we focused on a single use case: converting high-quality media files (also known as mezzanines) received from studios into compressed assets for Netflix streaming. Reloaded was created as a single monolithic system, where developers from various media teams in ET and our platform partner team Content Infrastructure and Solutions (CIS)¹ worked on the same codebase, building a single system that handled all media assets. Over the years, the system expanded to support various new use cases. This led to a significant increase in system complexity, and the limitations of Reloaded began to show:</p><ul><li id="34e7"><em>Coupled functionality:</em> Reloaded was composed of a number of worker modules and an orchestration module. The setup of a new Reloaded module and its integration with the orchestration required a non-trivial amount of effort, which led to a bias towards augmentation rather than creation when developing new functionalities. For example, in Reloaded <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/netflix-video-quality-at-scale-with-cosmos-microservices-552be631c113">the video quality calculation was implemented inside the video encoder module</a>. With this implementation, it was extremely difficult to recalculate video quality without re-encoding.</li><li id="2a71"><em>Monolithic structure</em>: Since Reloaded modules were often co-located in the same repository, it was easy to overlook code-isolation rules and there was quite a bit of unintended reuse of code across what should have been strong boundaries. Such reuse created tight coupling and reduced development velocity. The tight coupling among modules further forced us to deploy all modules together.</li><li id="dd66"><em>Long release cycles</em>: The joint deployment meant that there was increased fear of unintended production outages as debugging and rollback can be difficult for a deployment of this size. This drove the approach of the “release train”. Every two weeks, a “snapshot” of all modules was taken, and promoted to be a “release candidate”. This release candidate then went through exhaustive testing which attempted to cover as large a surface area as possible. This testing stage took about two weeks. Thus, depending on when the code change was merged, it could take anywhere between two and four weeks to reach production.</li></ul><p id="f9bd">As time progressed and functionalities grew, the rate of new feature contributions in Reloaded dropped. Several promising ideas were abandoned owing to the outsized work needed to overcome architectural limitations. The platform that had once served us well was now becoming a drag on development.</p><h2 id="5b0b">Cosmos</h2><p id="7d05">As a response, in 2018 the CIS and ET teams started developing the next-generation platform, Cosmos. In addition to the scalability and the stability that the developers already enjoyed in Reloaded, Cosmos aimed to significantly increase system flexibility and feature development velocity. To achieve this, Cosmos was developed as a computing platform for workflow-driven, media-centric microservices.</p><p id="bb0d">The microservice architecture provides strong decoupling between services. Per-microservice workflow support eases the burden of implementing complex media workflow logic. Finally, relevant abstractions allow media algorithm developers to focus on the manipulation of video and audio signals rather than on infrastructural concerns. A comprehensive list of benefits offered by Cosmos can be found in the linked <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/the-netflix-cosmos-platform-35c14d9351ad">blog</a>.</p><h2 id="88a4">Service Boundaries</h2><p id="9ae7">In the microservice architecture, a system is composed of a number of fine-grained services, with each service focusing on a single functionality. So the first (and arguably the most important) thing is to identify boundaries and define services.</p><p id="e2c6">In our pipeline, as media assets travel through creation to ingest to delivery, they go through a number of processing steps such as analyses and transformations. We analyzed these processing steps to identify “boundaries” and grouped them into different domains, which in turn became the building blocks of the microservices we engineered.</p><p id="9f21">As an example, in Reloaded, the video encoding module bundles 5 steps:</p><p id="078a">1. divide the input video into small chunks</p><p id="f5d1">2. encode each chunk independently</p><p id="d4c3">3. calculate the quality score (<a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/vmaf-the-journey-continues-44b51ee9ed12">VMAF</a>) of each chunk</p><p id="f530">4. assemble all the encoded chunks into a single encoded video</p><p id="a67b">5. aggregate quality scores from all chunks</p><p id="f114">From a system perspective, the assembled encoded video is of primary concern while the internal chunking and separate chunk encodings exist in order to fulfill certain latency and resiliency requirements. Further, as alluded to above, the video quality calculation provides a totally separate functionality as compared to the encoding service.</p><p id="2c71">Thus, in Cosmos, we created two independent microservices: Video Encoding Service (VES) and <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/netflix-video-quality-at-scale-with-cosmos-microservices-552be631c113">Video Quality Service (VQS)</a>, each of which serves a clear, decoupled function. As implementation details, the chunked encoding and the assembling were abstracted away into the VES.</p><h2 id="cccc">Video Services</h2><p id="ef6a">The approach outlined above was applied to the rest of the video processing pipeline to identify functionalities and hence service boundaries, leading to the creation of the following video services².</p><ol><li id="106b">Video Inspection Service (VIS): This service takes a mezzanine as the input and performs various inspections. It extracts metadata from different layers of the mezzanine for downstream services. In addition, the inspection service flags issues if invalid or unexpected metadata is observed and provides actionable feedback to the upstream team.</li><li id="ee76">Complexity Analysis Service (CAS): The optimal encoding recipe is highly content-dependent. This service takes a mezzanine as the input and performs analysis to understand the content complexity. It calls Video Encoding Service for <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/dynamic-optimizer-a-perceptual-video-encoding-optimization-framework-e19f1e3a277f">pre-encoding</a> and Video Quality Service for quality evaluation. The results are saved to a database so they can be reused.</li><li id="068a">Ladder Generation Service (LGS): This service creates an entire bitrate ladder for a given encoding family (H.264, AV1, etc.). It fetches the complexity data from CAS and runs the optimization algorithm to create encoding recipes. The CAS and LGS cover much of the innovations that we have previously presented in our tech blogs (<a href="http://techblog.netflix.com/2015/12/per-title-encode-optimization.html" rel="noopener ugc nofollow" target="_blank">per-title</a>, <a href="http://techblog.netflix.com/2016/12/more-efficient-mobile-encodes-for.html" rel="noopener ugc nofollow" target="_blank">mobile encodes</a>, <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/optimized-shot-based-encodes-now-streaming-4b9464204830">per-shot</a>, <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/optimized-shot-based-encodes-for-4k-now-streaming-47b516b10bbb">optimized 4K encoding</a>, etc.). By wrapping ladder generation into a separate microservice (LGS), we decouple the ladder optimization algorithms from the creation and management of complexity analysis data (which resides in CAS). We expect this to give us greater freedom for experimentation and a faster rate of innovation.</li><li id="d3c1">Video Encoding Service (VES): This service takes a mezzanine and an encoding recipe and creates an encoded video. The recipe includes the desired encoding format and properties of the output, such as resolution, bitrate, etc. The service also provides options that allow fine-tuning latency, throughput, etc., depending on the use case.</li><li id="87ff">Video Validation Service (VVS): This service takes an encoded video and a list of expectations about the encode. These expectations include attributes specified in the encoding recipe as well as conformance requirements from the codec specification. VVS analyzes the encoded video and compares the results against the indicated expectations. Any discrepancy is flagged in the response to alert the caller.</li><li id="a274"><a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/netflix-video-quality-at-scale-with-cosmos-microservices-552be631c113">Video Quality Service (VQS)</a>: This service takes the mezzanine and the encoded video as input, and calculates the quality score (VMAF) of the encoded video.</li></ol><h2 id="bc44">Service Orchestration</h2><p id="a36b">Each video service provides a dedicated functionality and they work together to generate the needed video assets. Currently, the two main use cases of the Netflix video pipeline are producing assets for member streaming and for studio operations. For each use case, we created a dedicated workflow orchestrator so the service orchestration can be customized to best meet the corresponding business needs.</p><p id="009c">For the streaming use case, the generated videos are deployed to our content delivery network (CDN) for Netflix members to consume. These videos can easily be watched millions of times. The Streaming Workflow Orchestrator utilizes almost all video services to create streams for an impeccable member experience. It leverages VIS to detect and reject non-conformant or low-quality mezzanines, invokes LGS for encoding recipe optimization, encodes video using VES, and calls VQS for quality measurement where the quality data is further fed to Netflix’s data pipeline for analytics and monitoring purposes. In addition to video services, the Streaming Workflow Orchestrator uses audio and timed text services to generate audio and text assets, and packaging services to “containerize” assets for streaming.</p><p id="59fb">For the studio use case, some example video assets are marketing clips and daily production editorial proxies. The requests from the studio side are generally latency-sensitive. For example, someone from the production team may be waiting for the video to review so they can decide the shooting plan for the next day. Because of this, the Studio Workflow Orchestrator optimizes for fast turnaround and focuses on core media processing services. At this time, the Studio Workflow Orchestrator calls VIS to extract metadata of the ingested assets and calls VES with predefined recipes. Compared to member streaming, studio operations have different and unique requirements for video processing. Therefore, the Studio Workflow Orchestrator is the exclusive user of some encoding features like forensic watermarking and timecode/text burn-in.</p></div></div><div><div><p id="0d08">We have had the new video pipeline running alongside Reloaded in production for a few years now. During this time, we completed the migration of all necessary functionalities from Reloaded, began gradually shifting over traffic one use case at a time, and completed the switchover in September of 2023.</p><p id="39c0">While it is still early days, we have already seen the benefits of the new platform, specifically the ease of feature delivery. Notably, Netflix launched the <a rel="noopener ugc nofollow" target="_blank" href="https://netflixtechblog.com/ensuring-the-successful-launch-of-ads-on-netflix-f99490fdf1ba">Advertising-supported plan</a> in November 2022. Processing Ad creatives posed some new challenges: media formats of Ads are quite different from movie and TV mezzanines that the team was familiar with, and there was a new set of media processing requirements related to the business needs of Ads. With the modularity and developer productivity benefits of Cosmos, we were able to quickly iterate the pipeline to keep up with the changing requirements and support a successful product launch.</p><p id="1f05">Rebuilding the video pipeline was a huge undertaking for the team. We are very proud of what we have achieved, and also eager to share our journey with the technical community. This blog has focused on providing an overview: a brief history of our pipeline and the platforms, why the rebuilding was necessary, what these new services look like, and how they are being used for Netflix businesses. In the next blog, we are going to delve into the details of the Video Encoding Service (VES), explaining step-by-step the service creation, and sharing lessons learned (we have A LOT!). We also plan to cover other video services in future tech blogs. Follow the<a href="https://netflixtechblog.com/" rel="noopener ugc nofollow" target="_blank"> Netflix Tech Blog</a> to stay up to date.</p><p id="17a7">A big shout out to the CIS team for their outstanding work in building the Cosmos platform and their receptiveness to feedback from service developers.</p><p id="2753">We want to express our appreciation to our users, the Streaming Encoding Pipeline team, and the Video Engineering team. Just like our feedback helps iron out the platform, the feedback from our users has been instrumental in building high-quality services.</p><p id="9dd2">We also want to thank Christos Bampis and Zhi Li for their significant contributions to video services, and our two former team members, Chao Chen and Megha Manohara for contributing to the early development of this project.</p></div></div></div>
  </body>
</html>
