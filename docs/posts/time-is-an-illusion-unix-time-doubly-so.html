<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.netmeister.org/blog/epoch.html">Original</a>
    <h1>Time is an illusion, Unix time doubly so</h1>
    
    <div id="readability-page-1" class="page"><div width="75%">
    <tbody><tr>
      <td>
<p><small>October 23rd, 2022</small></p>

<p><a href="https://www.unix.date/"><img src="https://www.netmeister.org/blog/images/epoch-clock.jpg" alt="Unix
Epoch clock" title="This clock will become useless on
2286-11-20T17:46:39..."/></a>
As you well know, on Unix systems we measure time as
the number of seconds since &#34;the epoch&#34;: 00:00:00 UTC
on January 1st, 1970.  This has made a lot of people
very angry and been widely regarded as a bad move.</p>

<p>For starters, this definition is not based on
something sensical such as, say, the objective
frequency of vibration of a Cesium-133 atom, but on a
convenient fraction of the time it takes a particular
large rock to complete a full rotation around its own
axis.</p>

<p>You see, in Unix time each day is guaranteed to have
exactly 86400 seconds, and we pretend that this number
monotonically increases.  When it turns out that
because our reference rock actually took a bit longer
than what was convenient for us to complete its
rotation and we need to add a leap second, we simply
pretend that didn&#39;t happen, and our timestamp
mechanism ceases to identify a unique point in
time.</p>

<p>The other thing that continues to cause problems here
is that as we try to count seconds, we run into data
storage and representation issues, because honestly,
computers aren&#39;t really all that good at numbers, it
turns out.  Talk about &#34;<a href="https://xkcd.com/376/">epoch fail</a>&#34;.</p>

<p>So how did we get here?  It all began back in 1971,
when the <a href="https://www.bell-labs.com/usr/dmr/www/pdfs/man22.pdf">First
Edition Unix Programmer&#39;s Manual</a> defined Unix time
as &#34;<em>the time since 00:00:00, 1 January 1971,
measured in sixtieths of a second</em>&#34;:</p>

<p><img src="https://www.netmeister.org/blog/images/epoch-1971.jpg" alt="Excerpt from the Unix Programmer&#39;s Manual showing
the definition of Unix time" title="We&#39;re about to get chronological-minded..."/>
</p>

<p>That&#39;s right, the original Unix epoch was
<tt>1971-01-01T00:00:00</tt>.  What timezone, you ask?  Well,
it sure wasn&#39;t &#34;UTC&#34;, because that didn&#39;t replace GMT
as the standard time until 1972.  Secondly, note that
time was measured in 1/60ths of a second, not in
seconds.  Why would that be?</p>

<p>Remember that at that time, Unix was being
developed in the US on a PDP-11.  These systems had a
<a href="https://www.learningpdp11.com/post/using-the-pdp-11-line-clock">Line-Time
Clock (LTC)</a>, which takes the AC power frequency to
generate an interrupt for the processor.  This
interrupt is then used to <a href="https://accu.org/journals/overload/23/130/schmidt_2185/">update
the system clock</a>.</p>

<p>The funny thing here is that this interrupt
frequency thus depends on the <a href="https://en.wikipedia.org/wiki/Utility_frequency">utility
frequency</a> of its power supply.  In much of Asia
and Europe, this frequency is 50 Hertz, but in the US,
the Westinghouse Electric Corporation observed that
the <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=628099">carbon
arc lamps in use at the time had less flicker</a> at
60 Hz and standardized on that frequency. (Fun fact:
Westinghouse, an early <a href="https://en.wikipedia.org/wiki/War_of_the_currents">competitor
to Thomas Edison and General Electric</a>,
would later buy CBS and was then bought by Viacom.)
</p>

<p>A weird side effect of this US/Europe split is
that in Japan, <em>both</em> are used: in the West,
where the first generators were purchased from the
German AEG and installed in Tokyo, the utility
frequency is 50 Hz; in the East, they were installed
in Osaka from G.E., and using 60 Hz.  As a result, the
country now uses several High-Voltage, Direct Current
(HVDC) electric power transmission systems to convert
the elecitricity between the two regions!</p>

<p><img src="https://www.netmeister.org/blog/images/japan-power-grid.png" alt="The Power Grid of Japan"/></p>

<p>Aaaaanyway... so yeah, the 1st Edition UNIX
measured time at those 60 Hz using a 32-bit integer,
thus only being capable of counting <tt>2^32 / 60
ticks/second * 60 s/m * 60 m/h * 24 h/d * 365 d/y =
2.3 years</tt>, as noted in the original manual.  Some
time in 1971, the time measurement was redefined to
count seconds, now capable of representing 136 years
of time, and the Unix epoch date was -- contrary to
the common misconception that it represents the
birthdate of Unix --  somewhat arbitrarily picked to
be 1970:</p>

<blockquote><pre>&#34;At the time we didn&#39;t have tapes and we had a couple
of file-systems running and we kept changing the
origin of time,&#34; he said. &#34;So finally we said, &#39;Let&#39;s
pick one thing that&#39;s not going to overflow for a
while.&#39; 1970 seemed to be as good as any. &#34;
-- <em>Dennis Ritchie</em>, <a href="https://www.wired.com/2001/09/unix-tick-tocks-to-a-billion/">Wired</a></pre></blockquote>

<p>(The actual birthdate of Unix lands somewhere in
1969, when Ken Thompson ported &#34;<a href="https://en.wikipedia.org/wiki/Space_Travel_(video_game)">Space
Travel</a>&#34; to the PDP-7, so it&#39;s easy to see why the
Unix epoch <em>seems</em> like it would represent the
birth of Unix.)</p>

<h2>Leap Seconds</h2>

<p>Ok, so now we have our 32-bit
seconds-since-the-epoch counter, which monotonically
increases at a rate of 1 Hz, and promising us to count
exactly 86400 seconds for any 24 hour period.  But our
silly reference rock appears to be slowing down in its
rotation, making it necessary to fudge this number a
bit every so often.</p>

<p>To do that, the International Earth Rotation
Service (IERS) (now &#34;<a href="https://en.wikipedia.org/wiki/International_Earth_Rotation_and_Reference_Systems_Service">International
Earth Rotation and Reference Systems Service</a>&#34;)
sends out an email to all Time Lords indicating
whether or not a leap second will be introduced:</p>

<p><img src="https://www.netmeister.org/blog/images/iers.jpg" alt="Screenshot of an email from the IERS announcing a
Leap Second in 2016"/></p>

<p>Now we can&#39;t really blame the Unix epoch time for
not accounting for leap seconds initially, since those
did not exist up until 1972.  Since then, we&#39;ve had 27
positive leap seconds (as of 2022), the last one being
introduced at the end of 2016.  Whenever a positive
leap second occurs, our Unix epoch time simply
pretends it didn&#39;t, with the result being that two
dates map to the same epoch timestamp (<a href="https://www.netmeister.org/blog/epoch-time.c">epoch-time.c</a>):</p>

<div><pre>From epoch to time, via gmtime(3) to strftime(3):
1483228798 2016-12-31T23:59:58
1483228799 2016-12-31T23:59:59
<span><em>missing leap second here</em></span>
1483228800 2017-01-01T00:00:00

From time to epoch, via strptime(3) to mktime(3):
2016-12-31T23:59:58 is 1483228798
2016-12-31T23:59:59 is 1483228799
2016-12-31T23:59:60 is 1483228800
2017-01-01T00:00:00 is 1483228800 <span><em>duplicate timestamp here</em></span>
</pre></div>

<p>(And let&#39;s forget all about negative leap seconds,
or the fact that some Unix system define the range of
<tt>tm_sec</tt> from <tt>[0-61]</tt>, accounting
for a mystical &#34;double leap second&#34; that <a href="https://groups.google.com/g/comp.dcom.telecom/c/Qq0lwZYG_fI?hl=en#02dd6ed5bb9ed84e">never
actually existed</a>.)</p>

<p>Good thing this is all in line with what <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_16">POSIX
requires</a>:</p>

<blockquote><pre>4.16 Seconds Since the Epoch

A value that approximates the number of seconds that have elapsed since
the Epoch.

The relationship between the actual time of day and the current value
for seconds since the Epoch is unspecified.

How any changes to the value of seconds since the Epoch are made to
align to a desired relationship with the current actual time is
implementation-defined. As represented in seconds since the Epoch, each
and every day shall be accounted for by exactly 86400 seconds.
</pre></blockquote>

<h3>Year 2038 Problem</h3>

<p>Now even counting monotonically forward and
ignoring leap seconds, the <tt>time_t</tt> data type used to measure
seconds since the epoch is eventually going to
overflow.  Good thing we have standards to save us
here!  Sure, POSIX is quiet on this, but the good
thing about standards is that there are so many to
choose from, right?  Oh wait <em>*taps ear*</em>,
what&#39;s that?  I see.</p>

<p>Bad news everybody: standards are not going to save
us.  For example, the <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2310.pdf">C
standard says</a>:</p>

<blockquote><pre>The range and precision of times representable in
clock_t and time_t are implementation-defined.</pre></blockquote>

<p>Well, ok then.  With a 32-bit <tt>time_t</tt>, we can then account for
roughly 136 years starting in 1970.  Except, <tt>time_t</tt> is a <em>signed</em> 32-bit
integer, so we only get 68 years in either direction,
leaving us with what you all know as the &#34;<a href="https://en.wikipedia.org/wiki/Year_2038_problem">Year
2038 Problem</a>&#34;.</p>

<p>That is, the largest date that can be represented
as a <tt>time_t</tt> using a 32-bit
signed integer is epoch <tt>2^31 - 1 =
2147483647</tt>, or 2038-01-19T03:14:07Z:</p>

<p><img src="https://www.netmeister.org/blog/images/Year_2038_problem.gif" alt="Illustration of the Year 2038 Problem showing the
date wrapping."/></p>

<p>Easy to fix, right?  We &#34;just&#34; change the data type
of a <tt>time_t</tt> to be a 64-bit
signed integer, yielding a theoretical maximum epoch
date of <tt>2^63-1 = 9223372036854775807</tt> after
January 1st, 1970.  As people like to point out, that
represents a date around 292 billion years in
the future, or roughly 22 times the estimated age of
the universe, and thus officially Somebody Else&#39;s
Problem.</p>

<p>But -- there&#39;s always a &#34;but&#34;, isn&#39;t there? -- is that
really what happens?  Why don&#39;t we give it a try and
see how different systems behave when we hand them
not-quite-so-reasonable times to chew
on.</p>

<h3><tt>mktime(3)</tt> wrapping</h3>

<p>While time is represented as a <tt>time_t</tt>, the other common format in
use to represent broken down time is a <tt>struct tm</tt>, from which you can then
get a <tt>time_t</tt> by calling
<tt>mktime(3)</tt>.  The distinct elements of the <tt>struct tm</tt> are noted by <a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html">POSIX</a>
to be:</p>

<div><pre>int    tm_sec   Seconds [0,60]. 
int    tm_min   Minutes [0,59]. 
int    tm_hour  Hour [0,23]. 
int    tm_mday  Day of month [1,31]. 
int    tm_mon   Month of year [0,11]. 
int    tm_year  Years since 1900. 
int    tm_wday  Day of week [0,6] (Sunday =0). 
int    tm_yday  Day of year [0,365]. 
int    tm_isdst Daylight Savings flag. 
</pre></div>

<p>The funny thing about the ranges noted there are
that they are... advisory at best.  POSIX specifically
<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/mktime.html">notes</a>:</p>

<blockquote><pre>...the original values of the [...] components shall not
be restricted to the ranges described in &lt;time.h&gt;.
</pre>
</blockquote>

<p>So what exactly happens when you feed
<tt>mktime(2)</tt> a <tt>struct tm</tt>
with values outside of these ranges?  Consider the
following program:</p>

<div><pre>int main() {
        struct tm t;
        time_t epoch;

	/* 2022-12-31 */
        t.tm_year = 122; t.tm_mon = 11; t.tm_mday = 31;

	/* 22:57 */
        t.tm_hour = 22; t.tm_min = 57;

        <span>t.tm_sec = 3785;</span>

        if ((epoch = mktime(&amp;t)) == -1) {
                err(EXIT_FAILURE, &#34;mktime&#34;);
        }

        (void)printf(&#34;%s&#34;, ctime(&amp;epoch));

	return 0;
}
$ cc -Wall -Werror -Wextra t.c
$ ./a.out
Sun Jan  1 00:00:05 2023
$ </pre></div>

<p>Here, before we set <tt>tm_sec</tt>,
our <tt>struct tm</tt> represented
December 31st, 22:57:00, 2022.  But then we set <tt>tm_sec</tt> to <tt><span>3785</span></tt>, i.e., 1
hour, 3 minutes, and 5 seconds.  This then leads to <tt>tm_min</tt> to be incremented by 3
minutes, which leads to <tt>tm_hour</tt>
to be bumped up by one.  Then we increment <tt>tm_hour</tt> once more (from the
remaining 3600 seconds from <tt>tm_sec</tt>), which wraps that value over
to <tt>00</tt> and leads to <tt>tm_mday</tt> needing to be incremented.
<tt>tm_mday</tt> now wraps to <tt>01</tt>
with <tt>tm_year</tt> incrementing, ultimately leading
to the final date being
<tt>2023-01-01T00:00:05</tt>.</p>

<p>This normalization of timestamps gets even more
confusing once you add negative values (e.g., <tt>tm_mday = -1</tt> means the
last day of <tt>tm_mon - 1</tt>) or
(again) with leap seconds in play and can make your
head hurt.  It&#39;s best to avoid this situation.</p>

<h3>Funny <tt>date(1)</tt></h3>

<p>Now let&#39;s look at epoch dates at or around the
epoch.  We&#39;ll ignore the fact that epoch times prior
to 1972 are not well defined, because our epoch time
is defined to be in UTC, but (see above) UTC had not
yet been standardized before 1972.  We&#39;ll just be like
Unix with leap seconds and pretend that doesn&#39;t
concern us.</p>

<p>Displaying an arbitrary date using the
<tt>date(1)</tt> command is easy enough.  You just
give it the date in the format
<tt>CCyymmddHHMM.SS</tt>.  Unless you&#39;re using
Linux, where GNU <tt>date(1)</tt> wants to use what is
perhaps the most infuriating format
(<tt>MMDDhhmmCCYY.ss</tt>), even using inconsistent
capitalization of the date fields compared to the
<tt>strftime(3)</tt> % sequences.  Why would you stick
the <em>year</em> in between minutes and
seconds?</p>

<p>But using either format is not useful for our
purposes anyway, because at some point we want to go
beyond four-digit years, so instead let&#39;s
specify seconds since the epoch directly (&#34;<tt>-r
&lt;seconds&gt;</tt>&#34; for BSD <tt>date(1)</tt>,
&#34;<tt>--date @&lt;seconds&gt;</tt>&#34; for GNU
<tt>date(1)</tt>).</p>

<p>Displaying dates at or around the epoch is
straight forward:</p>

<table>
<tbody><tr>
<td>
<div><pre>NetBSD / FreeBSD / macOS:
$ date -r 0
Thu Jan  1 00:00:00 UTC 1970
$ date -r -1
Wed Dec 31 23:59:59 UTC 1969
$ date -r 1 
Thu Jan  1 00:00:01 UTC 1970</pre></div>
</td>
<td>
<div><pre>Linux:
$ date --date @0
Thu Jan  1 12:00:00 AM UTC 1970
$ date --date @-1
Wed Dec 31 11:59:59 PM UTC 1969
$ date --date @1
Thu Jan  1 12:00:01 AM UTC 1970</pre></div>
</td>
<td>
<div><pre>OmniOS (using GNU date)
$ date -r 0
January  1, 1970 at 12:00:00 AM UTC
$ date -r -1
December 31, 1969 at 11:59:59 PM UTC
$ date -r 1
January  1, 1970 at 12:00:01 AM UTC</pre></div>
</td>
</tr>
</tbody></table>

<p>(GNU <tt>date(1)</tt> using AM/PM instead of a
24-hour clock here is annoying, but ok.)</p>

<p>Let&#39;s see what happens if we try to probe for
32-bit <tt>time_t</tt> s.  As discussed
above, the Year 2038 Problem would be triggered at
epoch <tt>2147483648</tt> /
<tt>-2147483649</tt>:</p>

<table>
<tbody><tr>
<td>
<div><pre>netbsd$ date -r 2147483647
Tue Jan 19 03:14:07 UTC 2038
netbsd$ date -r 2147483648
Tue Jan 19 03:14:08 UTC 2038
netbsd$ date -r -2147483648
Fri Dec 13 20:45:52 UTC 1901
netbsd$ date -r -2147483649
Fri Dec 13 20:45:51 UTC 1901</pre></div>
</td>
<td>
<div><pre>linux$ date --date @2147483647
Tue Jan 19 03:14:07 AM UTC 2038
linux$ date --date @2147483648
Tue Jan 19 03:14:08 AM UTC 2038
linux$ date --date @-2147483648
Fri Dec 13 08:45:52 PM UTC 1901
linux$ date --date @-2147483649
Fri Dec 13 08:45:51 PM UTC 1901</pre></div>
</td>
</tr>
<tr>
<td colspan="2">
<div><pre>omnios$ date -r -2147483648
December 13, 1901 at 08:45:52 PM UTC
omnios$ date -r -2147483649
date: failed to parse -r argument: -2147483649
omnios$ date -r 2147483647
January 19, 2038 at 03:14:07 AM UTC
omnios$ date -r 2147483648
date: failed to parse -r argument: 2147483648</pre></div>
</td>
</tr>
</tbody></table>

<p>Oh, hey, look at that.  OmniOS seems to have
problems with epoch dates beyond 2^31.  I wonder
what&#39;s going to happen if we not only <em>display</em>
the date, but <em>set</em> it?  Let&#39;s loop, set the
date, and print the date:</p>

<div><pre>omnios$ for s in 5 6 7 8; do sudo date -u 011903142038.0$s; date; done
January 19, 2038 at 03:14:05 AM UTC
January 19, 2038 at 03:14:05 AM UTC
January 19, 2038 at 03:14:06 AM UTC
January 19, 2038 at 03:14:06 AM UTC
January 19, 2038 at 03:14:07 AM UTC
<span>December 13, 1901 at 08:45:52 PM UTC</span>
ld.so.1: date: fatal: /lib/libc.so.1: Value too large for defined data type
Killed
omnios$ date
ld.so.1: date: fatal: /lib/libc.so.1: Value too large for defined data type
Killed
omnios$ ls
ld.so.1: ls: fatal: /lib/libc.so.1: Value too large for defined data type
Killed
omnios$ sudo reboot
sudo: unknown uid 100
sudo: error initializing audit plugin sudoers_audit
omnios$ </pre></div>

<p>Nice.  Note how the date actually <span>wraps</span> around
before the OS freaks out.  Now the other systems
should not have any problems setting a date.
Right?</p>

<table>
<tbody><tr>
<td>
<div><pre>netbsd# date 197001010000; date +%s
Thu Jan  1 00:00:00 UTC 1970
0
netbsd# date 196912312359
date: settimeofday: Invalid argument
netbsd$ </pre></div>
</td>
<td>
<div><pre>linux$ sudo date -s @0
date: cannot set date: Invalid argument
Thu Jan  1 12:00:00 AM UTC 1970
linux$ uptime; sudo date -s @7080
 03:34:27 up  1:57,  1 user,  load average: 0.04
Thu Jan  1 01:58:00 AM UTC 1970</pre></div>
</td>
</tr>
</tbody></table>

<p>That is, on NetBSD we can&#39;t set the date to
<em>before</em> the epoch, while on Linux (since
kernel version 4.3) we can&#39;t set the date before the
current uptime.  This is, <tt>settimeofday(2)</tt>
will return <tt>EINVAL</tt>, because of <a href="https://man7.org/linux/man-pages/man2/clock_settime.2.html">guarantees</a>
made by its &#34;<tt>CLOCK_MONOTONIC</tt>&#34; clock that, <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_getres.html">according
to POSIX</a> &#34;<em>represents the amount of time since
an unspecified point in the past</em>&#34;:</p>

<blockquote><pre>All CLOCK_MONOTONIC variants guarantee that the time returned by
consecutive calls will not go backwards, but successive calls
may—depending on the architecture—return identical (not-increased) time
values.</pre></blockquote>

<p>Along those lines, it looks like OmniOS calculates uptime based on
boot time relative to the system date, while NetBSD and Linux, for
example, keep separate counters:</p>

<div><pre>omnios$ sudo date -u 010100001970.00
January  1, 1970 at 12:00:00 AM GMT
omnios$ uptime
00:01:46    up -49 min(s),  1 user,  load average: 0.00, 0.00, 0.02
omnios$ sudo date -u 011803142038.00
January 18, 2038 at 03:14:00 AM GMT
omnios$ uptime
03:14:11    up 5567 day(s), 7 min(s),  1 user,  load average: 0.24, 0.16, 0.07
</pre></div>

<p>Trying to set the date to before the epoch yields
different results as well.  On NetBSD and Linux, it&#39;ll
simply fail, but on OmniOS, it will set the month,
day, hour, minute, and second, but pin the year to
1970:</p>

<div><pre>omnios$ sudo date -u 020100001969.00
February  1, 1970 at 12:00:00 AM GMT
omnios$ date
February  1, 1970 at 12:00:01 AM UTC
omnios$ sudo date -u 121308451901.52
December 13, 1970 at 08:45:52 AM GMT
omnios$ date
December 13, 1970 at 08:45:54 AM UTC</pre></div>

<p>But so what is the largest date we can set our
clock to on systems that use a 64-bit <tt>time_t</tt>?  As noted above, we&#39;d expect
to be able to set it to epoch <tt>2^63
- 1 = 9223372036854775807</tt>.  Let&#39;s first display
  the date, then try to set it:</p>

<table>
<tbody><tr>
<td colspan="2">
<div><pre>netbsd$ date -r 9223372036854775807
date: 9223372036854775807: localtime: Value too large to be stored in data type
netbsd$ date -r 67768036191676799
Wed Dec 31 23:59:59 UTC 2147485547
netbsd$ date -r 67768036191676800
date: 67768036191676800: localtime: Value too large to be stored in data type</pre></div>
</td>
</tr>
<tr>
<td>
<div><pre>linux$ date --date @9223372036854775807
date: time ‘9223372036854775807’ is out of range
linux$ date --date @67768036191676799
Wed Dec 31 11:59:59 PM UTC 2147485547
linux$ date --date @67768036191676800
date: time ‘67768036191676800’ is out of range
linux$ </pre></div>
</td>
<td>
<div><pre>freebsd$ date -r 9223372036854775807
date: invalid time
freebsd$ date -r 67768036191676799
date: invalid time
freebsd$ date -r 67767976233532799
Tue Dec 31 23:59:59 UTC 2147483647
freebsd$ date -r 67767976233532800
date: invalid time</pre></div>
</td>
</tr>
</tbody></table>

<p>So this is interesting.  Even though we were
promised a 64-bit <tt>time_t</tt>, we
can&#39;t set the time to <tt>9223372036854775807</tt>.
We seem to max out at <tt>67768036191676799</tt> in
the year 2,147,485,547.  While that seems initially
arbitrary, you may notice that 2147485547 is <tt>2^31
-1</tt>, and suddenly this makes sense: even though
the <tt>time_t</tt> is 64-bit, the <tt>struct tm</tt>&#39;s <tt>tm_year</tt> is still 32-bit, and so the
maximum value that can be represented is thus the last
second of the year 2,147,485,547.</p>

<p>But what&#39;s the deal with FreeBSD?  Somehow there
the epoch of <tt>67768036191676799</tt> is invalid,
but epoch <tt>67767976233532799</tt> represents what
on the other platforms is <tt>67768036191676799</tt>?
If you do the math, you&#39;ll notice that the difference
between these two epoch times is 1900 years -- so
apparently FreeBSD bases it&#39;s <tt>tm_year</tt> not on the year 1900 (as the
<tt>struct tm</tt> in
<tt>&lt;time.h&gt;</tt> claims), but on the year 0?
Since I couldn&#39;t figure this out, I <a href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=267266">filed
a bug report</a>. ¯\_(ツ)_/¯ </p>

<p>When we try to <em>set</em> the date, we first observe
that using NetBSD <tt>date(1)</tt> it&#39;s impossible to
set a date beyond the year 9999 (<a href="https://gnats.netbsd.org/cgi-bin/query-pr-single.pl?number=57069">another
bug report</a>), but, fun fact, that doesn&#39;t really
matter because it turns out we can&#39;t go higher than
the year 4147 anyway:</p>

<div><pre>netbsd# date 414708200732.17
date: settimeofday: Invalid argument
netbsd# date 414708200732.16; date +%s
Sun Aug 20 07:32:16 UTC 4147
68719476736</pre></div>

<p>The reason for that is that NetBSD has a hardcoded
limit of <tt>2^36 = 68719476736</tt> on the <tt>tv_sec</tt> value it will accept when
setting the time, because larger value made <a href="https://man.netbsd.org/kernel_sanitizers.7">KUBSAN</a>
unhappy (<a href="http://cvsweb.netbsd.org/bsdweb.cgi/src/sys/kern/kern_time.c.diff?r1=1.205&amp;r2=1.206">code</a>):</p>

<div><pre>        /*
         * The time being set to an unreasonable value
         * will cause unreasonable system behaviour.
         */
        if (ts-&gt;tv_sec &lt; 0 || ts-&gt;tv_sec &gt; (1LL &lt;&lt; 36))
                return EINVAL;
</pre></div>

<p>On Linux, we have a <em>different</em> practical maximum
date, set in 2232:</p>

<div><pre>linux$ sudo date -s @8277292036
date: cannot set date: Invalid argument
Wed Apr 18 11:47:16 PM UTC 2232
linux$ sudo date -s &#39;@8277292035&#39;
Wed Apr 18 11:47:15 PM UTC 2232
linux$ sleep 10; date +%s
8277292045
linux$ sudo date -s @$(date +%s)
date: cannot set date: Invalid argument
Wed Apr 18 11:47:25 PM UTC 2232</pre></div>

<p>The reason for <em>this</em> limitation is found <a href="https://elixir.bootlin.com/linux/v6.0.3/source/include/linux/time64.h#L36">in
the source</a> as to be such that it can accommodate a
30-year uptime before the counter wraps:</p>

<div><pre>#define NSEC_PER_SEC    1000000000L
#define KTIME_MAX       ((s64)~((u64)1 &lt;&lt; 63))
#define KTIME_SEC_MAX   (KTIME_MAX / NSEC_PER_SEC)

/*
 * Limits for settimeofday():
 *
 * To prevent setting the time close to the wraparound point time setting
 * is limited so a reasonable uptime can be accomodated. Uptime of 30 years
 * should be really sufficient, which means the cutoff is 2232. At that
 * point the cutoff is just a small part of the larger * problem.
 */
#define TIME_UPTIME_SEC_MAX    (30LL * 365 * 24 *3600)
#define TIME_SETTOD_SEC_MAX    (KTIME_SEC_MAX - TIME_UPTIME_SEC_MAX)</pre></div>

<p>Interestingly, this means that on Linux, the
signed 64-bit max time value (<tt>2^63 - 1 =
9223372036854775807</tt>) does not represent the
<em>seconds</em> since the epoch, but counts the
<em>nanoseconds</em> since the epoch, bringing Linux&#39;s
theoretical max date (<tt>KTIME_SEC_MAX</tt>) to a
mere <tt>9223372036</tt> epoch seconds or the date
2262-04-23T11:47:16 -- a fair bit away from the &#34;22
times the estimated age of the universe&#34; and a bit
more in the realm of possibly becoming an actual
problem.</p>

<p>Lastly, when trying to see what value FreeBSD lets
us set the clock to, I found that the value differed
between the two latest releases, but either had the <a href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=267157">unpleasant
problem</a> of leading to a spontaneous reboot of
the system:</p>

<div><pre>freebsd# date -u -f &#34;%s&#34; 49282253052249598
Fri Dec 31 23:59:58 UTC 1561694399
49282253052249598
freebsd# sleep 1; date; date +%s
Fri Dec 31 23:59:59 UTC 1561694399
49282253052249599
freebsd# sleep 1; date; date +%s
Sat Jan  1 00:00:00 UTC 1561694400
49282253052249600
[ system reboots ]</pre></div>

<p>Note: I&#39;m able to initially set the date to values
larger than <tt>49282253052249598</tt>, but about
three seconds later, the system reboots.  If I set the
date to one second earlier, i.e.,
<tt>49282253052249597</tt>, then the system will not
reboot, even as the system time progresses beyond the
next value.  Aren&#39;t computers great?</p>

<h3>Oh, and one more thing...</h3>

<p>We all love how macOS is a UNIX -- one of only 6
operating systems currently registered (the <a href="https://en.wikipedia.org/wiki/Single_UNIX_Specification#Currently_registered_UNIX_systems">others being</a>
AIX, EulerOS (a commercial Linux distribution made by
Huawei), HP-UX, Xinuos (previously UnixWare, via the
old AT&amp;T Unix System Laboratories + Novell, SCO,
Caldera, and UnXis), and z/OS).  But Apple&#39;s
<a href="https://developer.apple.com/documentation/corefoundation">Core
Foundation</a>
framework does <em>not</em> use the Unix epoch as it&#39;s basis
for time.  Instead, it uses 2001-01-01T00:00:00 GMT as
it&#39;s <a href="https://developer.apple.com/documentation/corefoundation/time_utilities:">reference date</a>:

</p><blockquote><pre>All CLOCK_MONOTONIC variants guarantee that the time returned by Core
Foundation measures time in units of seconds. The base data type is the
CFTimeInterval, which measures the difference in seconds between two
times. Fixed times, or dates, are defined by the CFAbsoluteTime data
type, which measures the time interval between a particular date and the
absolute reference date of Jan 1 2001 00:00:00 GMT.</pre></blockquote>

<p>So if you want to convert those timestamps into Unix
epoch, you need to add <tt>978307200</tt>.</p>

<hr/>

<p>As I said, time is an illusion, and Unix time
doubly so.  And while the Year 2038 Problem may not
concern you (unless you happen to use OmniOS, I
suppose), perhaps I was able to show you that there
are plenty of other surprises lurking.  And we haven&#39;t
even touched upon the insanity that is <a href="https://youtu.be/3N2aH1vUacQ?t=575">timezones and
Daylight Saving Time</a>...</p>

<p><small>October 23rd, 2022</small></p>

<hr/>

<p><small>Links:</small></p>

<ul>
<li><small><a href="https://twitter.com/jschauma/status/1584740954258526209">This blog post as a Twitter thread</a></small></li>
<li><small><a href="https://news.ycombinator.com/item?id=33341652">Discussion on HackerNews</a></small></li>
</ul>
      </td>
    </tr>
  </tbody></div></div>
  </body>
</html>
