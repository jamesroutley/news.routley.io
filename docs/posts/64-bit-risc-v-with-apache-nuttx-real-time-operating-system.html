<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lupyuen.codeberg.page/articles/riscv.html">Original</a>
    <h1>64-Bit RISC-V with Apache NuttX Real-Time Operating System</h1>
    
    <div id="readability-page-1" class="page">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

        <!-- Begin scripts/rustdoc-before.html: Pre-HTML for Custom Markdown files processed by rustdoc, like chip8.md -->

    <!-- Begin Theme Picker -->
    
    
    
    <!-- Theme Picker -->

    <!-- End scripts/rustdoc-before.html -->
    

    
    <nav id="TOC"><ul>
<li><a href="#boot-nuttx-on-64-bit-risc-v-qemu">1 Boot NuttX on 64-bit RISC-V QEMU</a><ul></ul></li>
<li><a href="#qemu-emulator-for-risc-v">2 QEMU Emulator for RISC-V</a><ul></ul></li>
<li><a href="#qemu-starts-nuttx">3 QEMU Starts NuttX</a><ul></ul></li>
<li><a href="#risc-v-boot-code-in-nuttx">4 RISC-V Boot Code in NuttX</a><ul>
<li><a href="#get-cpu-id">4.1 Get CPU ID</a><ul></ul></li>
<li><a href="#disable-interrupts">4.2 Disable Interrupts</a><ul></ul></li>
<li><a href="#wait-for-interrupt">4.3 Wait for Interrupt</a><ul></ul></li>
<li><a href="#load-interrupt-vector">4.4 Load Interrupt Vector</a><ul></ul></li>
<li><a href="#32-bit-vs-64-bit-risc-v">4.5 32-bit vs 64-bit RISC-V</a><ul></ul></li>
<li><a href="#other-instructions">4.6 Other Instructions</a><ul></ul></li></ul></li>
<li><a href="#jump-to-start">5 Jump to Start</a><ul></ul></li>
<li><a href="#whats-next">6 What‚Äôs Next</a><ul></ul></li>
<li><a href="#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu">7 Appendix: Build Apache NuttX RTOS for 64-bit RISC-V QEMU</a><ul></ul></li>
<li><a href="#appendix-compile-apache-nuttx-rtos-for-64-bit-risc-v-qemu">8 Appendix: Compile Apache NuttX RTOS for 64-bit RISC-V QEMU</a><ul></ul></li>
<li><a href="#appendix-download-toolchain-for-64-bit-risc-v">9 Appendix: Download Toolchain for 64-bit RISC-V</a><ul></ul></li></ul></nav><p>üìù <em>25 Jun 2023</em></p>
<p><img src="https://lupyuen.codeberg.page/images/riscv-title.png" alt="Apache NuttX RTOS on 64-bit QEMU RISC-V Emulator"/></p>
<p><a href="https://nuttx.apache.org/docs/latest/index.html"><strong>Apache NuttX</strong></a> is a <strong>Real-Time Operating System (RTOS)</strong> that runs on many kinds of devices, from 8-bit to 64-bit.</p>
<p>(Think Linux, but a lot smaller and simpler)</p>
<p>In this article we‚Äôll‚Ä¶</p>
<ul>
<li>
<p>Boot NuttX RTOS on a <strong>64-bit RISC-V</strong> device</p>
</li>
<li>
<p>Explore the <strong>Boot Code</strong> that starts NuttX on RISC-V</p>
</li>
<li>
<p>And learn a little <strong>RISC-V Assembly</strong>!</p>
</li>
</ul>
<p><em>But we need RISC-V Hardware?</em></p>
<p>No worries! We‚Äôll run NuttX on the <strong>QEMU Emulator</strong> for 64-bit RISC-V.</p>
<p>(Which will work on Linux, macOS and Windows machines)</p>
<p><img src="https://lupyuen.codeberg.page/images/riscv-build.png" alt="Building Apache NuttX RTOS in 4 minutes"/></p>
<p><a href="https://lupyuen.codeberg.page/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><em>Building Apache NuttX RTOS in 4 minutes</em></a></p>

<p>We begin by <strong>booting NuttX RTOS</strong> on RISC-V QEMU Emulator (64-bit)‚Ä¶</p>
<ol>
<li>
<p>Download and install <a href="https://www.qemu.org/download/"><strong>QEMU Emulator</strong></a>.</p>
<p>For macOS we may use <strong><code>brew</code></strong>‚Ä¶</p>
</li>
<li>
<p>Download <strong><code>nuttx</code></strong> from the <a href="https://github.com/lupyuen/lupyuen.github.io/releases/tag/nuttx-riscv64"><strong>NuttX Release</strong></a>‚Ä¶</p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/releases/download/nuttx-riscv64/nuttx"><strong>nuttx: NuttX Image for 64-bit RISC-V QEMU</strong></a></p>
<p>If we prefer to <strong>build NuttX</strong> ourselves: <a href="https://lupyuen.codeberg.page/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><strong>Follow these steps</strong></a></p>
</li>
<li>
<p>Start the <strong>QEMU RISC-V Emulator</strong> (64-bit) with NuttX RTOS‚Ä¶</p>
<div><pre><code>qemu-system-riscv64 \
  -semihosting \
  -M virt,aclint=on \
  -cpu rv64 \
  -smp 8 \
  -bios none \
  -kernel nuttx \
  -nographic
</code></pre></div></li>
<li>
<p>NuttX is now running in the QEMU Emulator! (Pic below)</p>
<div><pre><code>uart_register: Registering /dev/console
uart_register: Registering /dev/ttyS0
nx_start_application: Starting init thread

NuttShell (NSH) NuttX-12.1.0-RC0
nsh&gt; nx_start: CPU0: Beginning Idle Loop
nsh&gt;
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8">(See the Complete Log)</a></p>
</li>
<li>
<p>Enter ‚Äú<strong>help</strong>‚Äù to see the available commands‚Ä¶</p>
<div><pre><code>nsh&gt; help
help usage:  help [-v] [&lt;cmd&gt;]

    .         break     dd        exit      ls        ps        source    umount
    [         cat       df        false     mkdir     pwd       test      unset
    ?         cd        dmesg     free      mkrd      rm        time      uptime
    alias     cp        echo      help      mount     rmdir     true      usleep
    unalias   cmp       env       hexdump   mv        set       truncate  xd
    basename  dirname   exec      kill      printf    sleep     uname

Builtin Apps:
    nsh     ostest  sh
</code></pre></div></li>
<li>
<p>NuttX works like a tiny version of Linux, so the commands will look familiar‚Ä¶</p>
<div><pre><code>nsh&gt; uname -a
NuttX 12.1.0-RC0 275db39 Jun 16 2023 20:22:08 risc-v rv-virt

nsh&gt; ls /dev
/dev:
console
null
ttyS0
zero

nsh&gt; ps
  PID GROUP PRI POLICY   TYPE    NPX STATE    EVENT     SIGMASK           STACK   USED  FILLED COMMAND
    0     0   0 FIFO     Kthread N-- Ready              0000000000000000 002000 001224  61.2%  Idle Task
    1     1 100 RR       Task    --- Running            0000000000000000 002992 002024  67.6%  nsh_main
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8">(See the Complete Log)</a></p>
</li>
</ol>
<p>Let‚Äôs talk about QEMU‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/riscv-title.png" alt="Apache NuttX RTOS on RISC-V QEMU"/></p>
<p><a href="https://gist.github.com/lupyuen/93ad51d49e5f02ad79bb40b0a57e3ac8"><em>Apache NuttX RTOS on RISC-V QEMU</em></a></p>

<p><em>Earlier we ran this command. What does it mean?</em></p>
<div><pre><code>qemu-system-riscv64 \
  -kernel nuttx \
  -cpu rv64 \
  -smp 8 \
  -M virt,aclint=on \
  -semihosting \
  -bios none \
  -nographic
</code></pre></div>
<p>The above command starts the <a href="https://www.qemu.org/docs/master/system/target-riscv.html"><strong>QEMU Emulator for RISC-V</strong></a> (64-bit) with‚Ä¶</p>
<ul>
<li>
<p>Kernel Image: <strong>nuttx</strong> </p>
</li>
<li>
<p>CPU: <a href="https://www.qemu.org/docs/master/system/target-riscv.html"><strong>64-bit RISC-V</strong></a></p>
</li>
<li>
<p>Symmetric Multiprocessing: <strong>8 CPU Cores</strong></p>
</li>
<li>
<p>Machine: <a href="https://www.qemu.org/docs/master/system/riscv/virt.html"><strong>Generic Virtual Platform (virt)</strong></a></p>
</li>
<li>
<p>Handle Interrupts with <a href="https://patchwork.kernel.org/project/qemu-devel/cover/20210724122407.2486558-1-anup.patel@wdc.com/"><strong>Advanced Core Local Interruptor (ACLINT)</strong></a></p>
<p><a href="https://five-embeddev.com/baremetal/interrupts/#the-machine-mode-interrupts">(Instead of the older SiFive Core Local Interruptor CLINT)</a></p>
</li>
<li>
<p>Enable <a href="https://www.qemu.org/docs/master/about/emulation.html#semihosting"><strong>Semihosting Debugging</strong></a> without BIOS</p>
</li>
</ul>
<p><em>Which RISC-V Instructions are supported by QEMU?</em></p>
<p>QEMU‚Äôs RISC-V <a href="https://www.qemu.org/docs/master/system/riscv/virt.html#supported-devices"><strong>Generic Virtual Platform (virt)</strong></a> supports <strong>RV64GC</strong>, which is equivalent to <a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions"><strong>RV64IMAFDCZicsr_Zifencei</strong></a> (phew)‚Ä¶</p>
<div><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><strong>RV64I</strong></td><td>64-bit Base Integer Instruction Set</td></tr>
<tr><td><strong>M</strong></td><td>Integer Multiplication and Division</td></tr>
<tr><td><strong>A</strong></td><td>Atomic Instructions</td></tr>
<tr><td><strong>F</strong></td><td>Single-Precision Floating-Point</td></tr>
<tr><td><strong>D</strong></td><td>Double-Precision Floating-Point</td></tr>
<tr><td><strong>C</strong></td><td>Compressed Instructions</td></tr>
<tr><td><strong>Zicsr</strong></td><td>Control and Status Register (CSR) Instructions</td></tr>
<tr><td><strong>Zifencei</strong></td><td>Instruction-Fetch Fence</td></tr>
</tbody></table>
</div>
<p><a href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions">(Source)</a></p>
<p>We‚Äôll meet these instructions shortly.</p>

<p><em>What happens when NuttX RTOS boots on QEMU?</em></p>
<p>Let‚Äôs find out by tracing the <strong>RISC-V Boot Code</strong> in NuttX!</p>
<p>Earlier we ran this command to generate the <a href="https://lupyuen.codeberg.page/articles/riscv#appendix-build-apache-nuttx-rtos-for-64-bit-risc-v-qemu"><strong>RISC-V Disassembly</strong></a> for the NuttX Kernel‚Ä¶</p>
<div><pre><code>riscv64-unknown-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p>This produces <a href="https://github.com/lupyuen/lupyuen.github.io/releases/download/nuttx-riscv64/nuttx.S"><strong>nuttx.S</strong></a>, the disassembled NuttX Kernel for RISC-V.</p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/releases/download/nuttx-riscv64/nuttx.S"><strong>nuttx.S</strong></a> begins with this RISC-V code‚Ä¶</p>
<div><pre><code>0000000080000000 &lt;__start&gt;:
nuttx/arch/risc-v/src/chip/qemu_rv_head.S:46
__start:
  /* Load mhartid (cpuid) */
  csrr a0, mhartid
    80000000:	f1402573  csrr  a0, mhartid
</code></pre></div>
<p>This says‚Ä¶</p>
<ul>
<li>
<p>NuttX Boot Code is at <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L41-L120"><strong>qemu_rv_head.S</strong></a></p>
</li>
<li>
<p>NuttX Kernel begins execution at address <strong><code>0x8000</code> <code>0000</code></strong></p>
<p>(Why? What if NuttX is started by the U-Boot Bootloader?)</p>
</li>
</ul>
<p>Now we head into the NuttX Boot Code‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/riscv-code.png" alt="RISC-V Boot Code for Apache NuttX RTOS"/></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S"><em>RISC-V Boot Code for Apache NuttX RTOS</em></a></p>

<p><em>What‚Äôs inside the NuttX Boot Code?</em></p>
<p>The RISC-V Assembly code in <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L41-L120"><strong>qemu_rv_head.S</strong></a> will‚Ä¶</p>
<ol>
<li>
<p>Get the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L41-L47"><strong>CPU ID</strong></a></p>
</li>
<li>
<p>Check the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L54-L68"><strong>Number of CPUs</strong></a></p>
</li>
<li>
<p>Set the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L68-L98"><strong>Stack Pointer</strong></a></p>
</li>
<li>
<p>Disable <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L96-L102"><strong>Interrupts</strong></a></p>
</li>
<li>
<p>Load the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L102-L105"><strong>Interrupt Vector</strong></a></p>
</li>
<li>
<p>Jump to <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L105-L109"><strong>qemu_rv_start</strong></a></p>
</li>
</ol>
<p>Let‚Äôs decipher the RISC-V Instructions in our Boot Code‚Ä¶</p>
<h2 id="get-cpu-id"><a href="#get-cpu-id">4.1 Get CPU ID</a></h2>
<p>This is how we fetch the <strong>CPU ID</strong> in RISC-V Assembly: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L43-L47">qemu_rv_head.S</a></p>
<div><pre><code>/* Load mhartid (cpuid) */
csrr  a0, mhartid
</code></pre></div>
<p>Let‚Äôs break it down‚Ä¶</p>
<ul>
<li>
<p><strong><code>csrr</code></strong> is the RISC-V Instruction that reads the <a href="https://five-embeddev.com/quickref/instructions.html#-csr--csr-instructions"><strong>Control and Status Register</strong></a></p>
<p>(Which contains the CPU ID)</p>
</li>
<li>
<p><strong><code>a0</code></strong> is the RISC-V Register that will be loaded with the CPU ID.</p>
<p>According to the <a href="https://github.com/riscv-non-isa/riscv-eabi-spec/blob/master/EABI.adoc#3-register-usage-and-symbolic-names"><strong>RISC-V EABI</strong></a> (Embedded Application Binary Interface), <strong>a0</strong> is actually an alias for the Official RISC-V Register <strong>x10</strong>.</p>
<p>(‚Äúa‚Äù refers to ‚ÄúFunction Call Argument‚Äù)</p>
</li>
<li>
<p><strong><code>mhartid</code></strong> says that we‚Äôll read from the <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#hart-id-register-mhartid"><strong>Hart ID Register</strong></a>, containing the ID of the Hardware Thread (‚ÄúHart‚Äù) that‚Äôs running our code.</p>
<p>(Equivalent to CPU ID)</p>
</li>
</ul>
<p>So the above code will load the CPU ID into Register <strong>x10</strong>.</p>
<p>(We‚Äôll call it <strong>a0</strong> for convenience)</p>
<h2 id="disable-interrupts"><a href="#disable-interrupts">4.2 Disable Interrupts</a></h2>
<p>To <strong>disable interrupts</strong> in RISC-V, we do this: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L98-L102">qemu_rv_head.S</a></p>
<div><pre><code>/* Disable all interrupts (i.e. timer, external) in mie */
csrw  mie, zero
</code></pre></div>
<p>Which means‚Ä¶</p>
<ul>
<li>
<p><strong><code>csrw</code></strong> will write to the <a href="https://five-embeddev.com/quickref/instructions.html#-csr--csr-instructions"><strong>Control and Status Register</strong></a></p>
<p>(Which controls interrupts and other CPU settings)</p>
</li>
<li>
<p><strong><code>mie</code></strong> says that we‚Äôll write to the <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-interrupt-registers-mip-and-mie"><strong>Machine Interrupt Enable Register</strong></a></p>
<p>(0 to Disable Interrupts, 1 to Enable)</p>
</li>
<li>
<p><strong><code>zero</code></strong> says that we‚Äôll read from <a href="https://five-embeddev.com/quickref/regs_abi.html"><strong>Register x0</strong></a>‚Ä¶</p>
<p>Which always reads as 0!</p>
</li>
</ul>
<p>Thus the above instruction will set the Machine Interrupt Enable Register to 0, which will disable interrupts.</p>
<p>(Yeah RISC-V has a funny concept of ‚Äú0‚Äù)</p>
<h2 id="wait-for-interrupt"><a href="#wait-for-interrupt">4.3 Wait for Interrupt</a></h2>
<p>Now check out this curious combination of instructions: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L62-L68">qemu_rv_head.S</a></p>
<div><pre><code>/* Wait forever */
csrw  mie, zero
wfi
</code></pre></div>
<p>From the previous section, we know that ‚Äú<strong>csrw mie, zero</strong>‚Äù will disable interrupts.</p>
<p>But <strong><code>wfi</code></strong> will <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#wfi"><strong>Wait for Interrupt</strong></a>‚Ä¶</p>
<p>Which will never happen because we <strong>disabled interrupts!</strong></p>
<p>Thus the above code will get stuck there, <strong>waiting forever</strong>. (Intentionally)</p>
<p><a href="https://developer.arm.com/documentation/ddi0596/2020-12/Base-Instructions/WFI--Wait-For-Interrupt-">(<strong><code>wfi</code></strong> is probably the only instruction common to <strong>RISC-V and Arm CPUs</strong>)</a></p>
<h2 id="load-interrupt-vector"><a href="#load-interrupt-vector">4.4 Load Interrupt Vector</a></h2>
<p>RISC-V handles interrupts by looking up the <a href="https://five-embeddev.com/quickref/interrupts.html"><strong>Interrupt Vector Table</strong></a>.</p>
<p>This is how we load the <strong>Address of the Vector Table</strong> into the CPU Settings: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L102-L105">qemu_rv_head.S</a></p>
<div><pre><code>/* Load address of Interrupt Vector Table */
la    t0, __trap_vec
csrw  mtvec, t0
</code></pre></div>
<ul>
<li>
<p><a href="https://michaeljclark.github.io/asm.html#:~:text=The%20la%20(load%20address)%20instruction,command%20line%20options%20or%20an%20."><strong><code>la</code></strong></a> loads the Address of the Vector Table into <strong>Register t0</strong></p>
<p><a href="https://github.com/riscv-non-isa/riscv-eabi-spec/blob/master/EABI.adoc#3-register-usage-and-symbolic-names">(Which is aliased to <strong>Register x5</strong>)</a></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_vectors.S">(<strong>trap_vec</strong> is defined here)</a></p>
</li>
<li>
<p><strong><code>csrw</code></strong> writes <strong>t0</strong> into the <a href="https://five-embeddev.com/quickref/instructions.html#-csr--csr-instructions"><strong>Control and Status Register</strong></a> at‚Ä¶</p>
</li>
<li>
<p><strong><code>mtvec</code></strong>, the <a href="https://five-embeddev.com/riscv-isa-manual/latest/machine.html#machine-trap-vector-base-address-register-mtvec"><strong>Machine Trap-Vector Base-Address Register</strong></a></p>
</li>
</ul>
<p>Which will load the Address of our Interrupt Vector Table into the CPU Settings.</p>
<p><a href="https://michaeljclark.github.io/asm.html#:~:text=The%20la%20(load%20address)%20instruction,command%20line%20options%20or%20an%20.">(<strong><code>la</code></strong> is actually a Pseudo-Instruction that expands to <strong><code>auipc</code></strong> and <strong><code>addi</code></strong>)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-register-immediate-instructions">(<strong><code>auipc</code></strong> loads an Address Offset from the Program Counter)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-register-immediate-instructions">(<strong><code>addi</code></strong> adds an Immediate Value to a Register)</a></p>
<h2 id="32-bit-vs-64-bit-risc-v"><a href="#32-bit-vs-64-bit-risc-v">4.5 32-bit vs 64-bit RISC-V</a></h2>
<p>Adapting 32-bit code for 64-bit sounds hard‚Ä¶ But it‚Äôs easy peasy for RISC-V!</p>
<p>Our Boot Code uses an Assembler Macro to figure out if we‚Äôre running <strong>32-bit or 64-bit</strong> RISC-V: <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L73-L82">qemu_rv_head.S</a></p>
<div><pre><code>#ifdef CONFIG_ARCH_RV32
  /* Do this for 32-bit RISC-V */
  slli t1, a0, 2

#else
  /* Do this for 64-bit RISC-V */
  slli t1, a0, 3
#endif
</code></pre></div>
<p>Which means that the exact same Boot Code will run on <strong>32-bit AND 64-bit RISC-V</strong>!</p>
<p>(<strong><code>slli</code></strong> sounds ‚Äúsilly‚Äù, but it‚Äôs <a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-register-immediate-instructions"><strong>Logical Shift Left</strong></a>)</p>
<p>(<strong>CONFIG_ARCH_RV32</strong> is derived from our <a href="https://github.com/apache/nuttx/blob/master/boards/risc-v/qemu-rv/rv-virt/configs/nsh64/defconfig"><strong>NuttX Build Configuration</strong></a>)</p>
<h2 id="other-instructions"><a href="#other-instructions">4.6 Other Instructions</a></h2>
<p><em>What about the other RISC-V Instructions in our Boot Code?</em></p>
<p>Let‚Äôs skim through the rest‚Ä¶</p>
<ul>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-c--control-transfer-instructions"><strong><code>bnez</code></strong></a> branches to <strong>Label <code>1f</code></strong> if <strong>Register a0</strong> is Non-Zero</p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L47-L50">(Source)</a></p>
</li>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-c--control-transfer-instructions"><strong><code>j</code></strong></a> jumps to <strong>Label <code>2f</code></strong></p>
<p>(We‚Äôll explain Labels in a while)</p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L52-L54">(Source)</a></p>
</li>
<li>
<p><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions"><strong><code>li</code></strong></a> loads the <strong>Value 1</strong> into <strong>Register t1</strong></p>
<p><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions">(<strong><code>li</code></strong> is a Pseudo-Instruction that expands to <strong><code>addi</code></strong>)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-register-immediate-instructions">(<strong><code>addi</code></strong> adds an Immediate Value to a Register)</a></p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L59-L62">(Source)</a></p>
</li>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--conditional-branches"><strong><code>blt</code></strong></a> branches to <strong>Label <code>3f</code></strong> if <strong>Register a0</strong> is less than <strong>Register t1</strong></p>
<p>(And grabs a sandwich)</p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L62-L65">(Source)</a></p>
</li>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--integer-computational-instructions"><strong><code>add</code></strong></a> sets <strong>Register t0</strong> to the value of <strong>Register t0</strong> + <strong>Register t1</strong></p>
<p><a href="https://github.com/riscv-non-isa/riscv-eabi-spec/blob/master/EABI.adoc#3-register-usage-and-symbolic-names">(<strong>t1</strong> is aliased to <strong>Register x15</strong>)</a></p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L80-L82">(Source)</a></p>
</li>
<li>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/common/riscv_internal.h#L55-L63"><strong><code>REGLOAD</code></strong></a> is an Assembly Macro that expands to <strong><code>ld</code></strong></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv64--load-and-store-instructions"><strong><code>ld</code></strong></a> loads <strong>Register t0</strong> into the <strong>Stack Pointer Register</strong></p>
<p><a href="https://github.com/riscv-non-isa/riscv-eabi-spec/blob/master/EABI.adoc#3-register-usage-and-symbolic-names">(Which is aliased to <strong>Register x2</strong>)</a></p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L82-L86">(Source)</a></p>
</li>
<li>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--programmers-model-for-base-integer-isa"><strong><code>jal</code></strong></a> (Jump And Link) will jump to the address <strong>qemu_rv_start</strong> and store the Return Address in <strong>Register x1</strong></p>
<p>(Works like a Function Call)</p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L105-L109">(Source)</a></p>
</li>
<li>
<p><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions"><strong><code>ret</code></strong></a> returns from a Function Call.</p>
<p><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions">(<strong><code>ret</code></strong> is a Pseudo-Instruction that expands to <strong><code>jalr</code></strong>)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html#-rv32--unconditional-jumps">(<strong><code>jalr</code></strong> ‚ÄúJump And Link Register‚Äù will jump to the Return Address stored in <strong>Register x1</strong>)</a></p>

<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L117-L120">(Source)</a></p>
<p><a href="https://five-embeddev.com/quickref/instructions.html">(See the list of all <strong>RISC-V Instructions</strong>)</a></p>
<p><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#-a-listing-of-standard-risc-v-pseudoinstructions">(And <strong>RISC-V Pseudo-Instructions</strong>)</a></p>
</li>
</ul>
<p><em>Why are the RISC-V Labels named ‚Äú1f‚Äù, ‚Äú2f‚Äù, ‚Äú3f‚Äù?</em></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L47-L50"><strong>‚Äú<code>1f</code>‚Äù</strong></a> refers to the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_head.S#L53-L56"><strong>Local Label ‚Äú<code>1</code>‚Äù</strong></a> with a <a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#labels"><strong>Forward Reference</strong></a>.</p>
<p>(Instead of a <a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md#labels"><strong>Backward Reference</strong></a>)</p>
<p>Let‚Äôs jump to <strong>qemu_rv_start</strong>‚Ä¶</p>
<p><img src="https://lupyuen.codeberg.page/images/riscv-start.png" alt="RISC-V Start Code for NuttX RTOS"/></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L94-L151"><em>RISC-V Start Code for NuttX RTOS</em></a></p>

<p><em>Our Boot Code jumps to qemu_rv_start‚Ä¶</em></p>
<p><em>What happens next?</em></p>
<p><a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L94-L151"><strong>qemu_rv_start</strong></a> is the very first C Function that NuttX runs when it boots on QEMU.</p>
<p>The function will‚Ä¶</p>
<ol>
<li>
<p>Configure the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L105-L108"><strong>Floating-Point Unit</strong></a></p>
</li>
<li>
<p>Clear the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L113-L117"><strong>BSS Memory</strong></a></p>
</li>
<li>
<p>Initialise the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L119-L123"><strong>Serial Port</strong></a></p>
</li>
<li>
<p>Initialise the <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L129-L135"><strong>Memory Management Unit</strong></a></p>
<p>(For Kernel Mode only)</p>
</li>
<li>
<p>Call <a href="https://github.com/apache/nuttx/blob/master/arch/risc-v/src/qemu-rv/qemu_rv_start.c#L135-L139"><strong>nx_start</strong></a></p>
</li>
</ol>
<p><em>What happens in nx_start?</em></p>
<p><a href="https://github.com/apache/nuttx/blob/master/sched/init/nx_start.c#L297-L707"><strong>nx_start</strong></a> will initialise a whole bunch of NuttX things‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/unicorn2#after-primary-routine"><strong>‚ÄúAfter Primary Routine: nx_start‚Äù</strong></a></li>
</ul>
<p>Which will start the NuttX Shell that we‚Äôve seen earlier.</p>
<p>And that‚Äôs how NuttX RTOS boots on QEMU Emulator for RISC-V!</p>
<p><em>Why are we doing all this?</em></p>
<p>We‚Äôre about to port NuttX to the <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> RISC-V SoC and <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> Single-Board Computer.</p>
<p>The analysis we‚Äôve done today will be super helpful as we write the Boot Code for these RISC-V devices.</p>
<p>Stay tuned for updates in the next article!</p>

<p>I hope this article has been an educational exploration of Apache NuttX RTOS on 64-bit RISC-V‚Ä¶</p>
<ul>
<li>
<p>We booted NuttX RTOS on an emulated <strong>64-bit RISC-V</strong> device</p>
</li>
<li>
<p>We peeked at the <strong>Boot Code</strong> that starts NuttX on RISC-V</p>
</li>
<li>
<p>And hopefully we learnt a little <strong>RISC-V Assembly</strong>!</p>
</li>
</ul>
<p>As we‚Äôve seen, NuttX is a tiny operating system that‚Äôs perfect for experimenting with RISC-V gadgets. We‚Äôll do this and much more in the upcoming articles!</p>
<p><a href="https://lupyuen.codeberg.page/articles/pr">(We welcome <strong>your contribution</strong> to Apache NuttX RTOS)</a></p>
<p>Many Thanks to my <a href="https://github.com/sponsors/lupyuen"><strong>GitHub Sponsors</strong></a> for supporting my work! This article wouldn‚Äôt have been possible without your support.</p>
<ul>
<li>
<p><a href="https://github.com/sponsors/lupyuen"><strong>Sponsor me a coffee</strong></a></p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=36453810"><strong>Discuss this article on Hacker News</strong></a></p>
</li>
<li>
<p><a href="https://github.com/lupyuen/pinephone-nuttx"><strong>My Current Project: ‚ÄúApache NuttX RTOS for PinePhone‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/articles/book"><strong>My Other Project: ‚ÄúThe RISC-V BL602 Book‚Äù</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page"><strong>Check out my articles</strong></a></p>
</li>
<li>
<p><a href="https://lupyuen.codeberg.page/rss.xml"><strong>RSS Feed</strong></a></p>
</li>
</ul>
<p><em>Got a question, comment or suggestion? Create an Issue or submit a Pull Request here‚Ä¶</em></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/blob/master/src/riscv.md"><strong>lupyuen.github.io/src/riscv.md</strong></a></p>
<p><img src="https://lupyuen.codeberg.page/images/riscv-build.png" alt="Build Apache NuttX RTOS for 64-bit RISC-V QEMU"/></p>

<p>The easiest way to run <strong>Apache NuttX RTOS on 64-bit RISC-V</strong> is to download the <strong>NuttX Image</strong> and boot it on QEMU Emulator‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/riscv#boot-nuttx-on-64-bit-risc-v-qemu"><strong>‚ÄúBoot NuttX on 64-bit RISC-V QEMU‚Äù</strong></a></li>
</ul>
<p>But if we‚Äôre keen to <strong>build NuttX ourselves</strong>, here are the steps‚Ä¶</p>
<ol>
<li>
<p>Install the Build Prerequisites, skip the RISC-V Toolchain‚Ä¶</p>
<p><a href="https://lupyuen.codeberg.page/articles/nuttx#install-prerequisites"><strong>‚ÄúInstall Prerequisites‚Äù</strong></a></p>
</li>
<li>
<p>Download the RISC-V Toolchain for <strong>riscv64-unknown-elf</strong>‚Ä¶</p>
<p><a href="https://lupyuen.codeberg.page/articles/riscv#appendix-download-toolchain-for-64-bit-risc-v"><strong>‚ÄúDownload Toolchain for 64-bit RISC-V‚Äù</strong></a></p>
</li>
<li>
<p>Download and configure NuttX‚Ä¶</p>
<div><pre><code>mkdir nuttx
cd nuttx
git clone https://github.com/apache/nuttx nuttx
git clone https://github.com/apache/nuttx-apps apps

cd nuttx
tools/configure.sh rv-virt:nsh64
make menuconfig
</code></pre></div></li>
<li>
<p>In <strong>menuconfig</strong>, browse to ‚Äú<strong>Build Setup</strong> &gt; <strong>Debug Options</strong>‚Äù</p>
<p>Select the following options‚Ä¶</p>
<div><pre><code>Enable Debug Features
Enable Error Output
Enable Warnings Output
Enable Informational Debug Output
Enable Debug Assertions
Scheduler Debug Features
Scheduler Error Output
Scheduler Warnings Output
Scheduler Informational Output
</code></pre></div>
<p>Save and exit <strong>menuconfig</strong>.</p>
</li>
<li>
<p>Build the NuttX Project and dump the RISC-V Disassembly‚Ä¶</p>
<div><pre><code>make V=1 -j7

riscv64-unknown-elf-objdump \
  -t -S --demangle --line-numbers --wide \
  nuttx \
  &gt;nuttx.S \
  2&gt;&amp;1
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9d9b89dfd91b27f93459828178b83b77">(See the Build Log)</a></p>
<p><a href="https://github.com/lupyuen/lupyuen.github.io/releases/tag/nuttx-riscv64">(See the Build Outputs)</a></p>
</li>
<li>
<p>If the build fails with‚Ä¶</p>
<div><pre><code>sed: 1: &#34;/CONFIG_BASE_DEFCONFIG/ ...&#34;: bad flag in substitute command: &#39;}&#39;
</code></pre></div>
<p>Please run ‚Äú<strong>make menuconfig</strong> &gt; <strong>Build Setup</strong> &gt; <strong>Debug Options</strong>‚Äù and uncheck ‚Äú<strong>Enable Debug Features</strong>‚Äù. Save, exit <strong>menuconfig</strong> and rebuild NuttX with <strong>make</strong>.</p>
</li>
</ol>
<p>This produces the NuttX Image <strong>nuttx</strong> that we may boot on QEMU RISC-V Emulator‚Ä¶</p>
<ul>
<li><a href="https://lupyuen.codeberg.page/articles/riscv#boot-nuttx-on-64-bit-risc-v-qemu"><strong>‚ÄúBoot NuttX on 64-bit RISC-V QEMU‚Äù</strong></a></li>
</ul>
<p>Let‚Äôs look at the GCC Command that compiles NuttX for 64-bit RISC-V QEMU‚Ä¶</p>

<p>From the previous section, we see that the NuttX Build compiles the source files with these <strong>GCC Options</strong>‚Ä¶</p>
<div><pre><code>riscv64-unknown-elf-gcc \
  -c \
  -fno-common \
  -Wall \
  -Wstrict-prototypes \
  -Wshadow \
  -Wundef \
  -Os \
  -fno-strict-aliasing \
  -fomit-frame-pointer \
  -ffunction-sections \
  -fdata-sections \
  -g \
  -march=rv64imac \
  -mabi=lp64 \
  -mcmodel=medany \
  -isystem nuttx/include \
  -D__NuttX__ \
  -DNDEBUG \
  -D__KERNEL__  \
  -pipe \
  -I nuttx/arch/risc-v/src/chip \
  -I nuttx/arch/risc-v/src/common \
  -I nuttx/sched \
  chip/qemu_rv_start.c \
  -o  qemu_rv_start.o
</code></pre></div>
<p><a href="https://gist.github.com/lupyuen/9d9b89dfd91b27f93459828178b83b77">(See the Build Log)</a></p>
<p>The <strong>RISC-V Options</strong> are‚Ä¶</p>
<ul>
<li>
<p><strong>march=rv64imac</strong>: This generates Integer-Only 64-bit RISC-V code, no Floating-Point.</p>
<p>Which is surprising because RISC-V QEMU actually <a href="https://lupyuen.codeberg.page/articles/riscv#qemu-emulator-for-risc-v"><strong>supports Floating-Point</strong></a>.</p>
<p>We‚Äôll fix this as we port NuttX to the <a href="https://doc-en.rvspace.org/Doc_Center/jh7110.html"><strong>StarFive JH7110</strong></a> RISC-V SoC and <a href="https://wiki.pine64.org/wiki/STAR64"><strong>Pine64 Star64</strong></a> SBC.</p>
</li>
<li>
<p><strong>mabi=lp64</strong>: This Application Binary Interface says that Long Pointers are 64-bit. No Floating-Point Arguments will be passed in Registers.</p>
<p>We might fix this for JH7110 SoC and Star64 SBC.</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/RISC-V-Options.html">(More about this)</a></p>
</li>
<li>
<p><strong>mcmodel=medany</strong>: Sounds like a burger (or fast-food AI model) but it actually generates code for the Medium-Any Code Model. (Instead of Medium-Low)</p>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc-9.1.0/gcc/RISC-V-Options.html">(More about this)</a></p>
</li>
</ul>

<p>Follow these steps to download the <strong>64-bit RISC-V Toolchain</strong> for building Apache NuttX RTOS on Linux, macOS or Windows‚Ä¶</p>
<ol>
<li>
<p>Download the <a href="https://github.com/sifive/freedom-tools/releases/tag/v2020.12.0"><strong>riscv64-unknown-elf RISC-V Toolchain</strong></a> for Linux, macOS or Windows‚Ä¶</p>
<ul>
<li>
<p><a href="https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.12/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-ubuntu14.tar.gz"><strong>Ubuntu Linux</strong></a></p>
</li>
<li>
<p><a href="https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.12/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-linux-centos6.tar.gz"><strong>CentOS Linux</strong></a></p>
</li>
<li>
<p><a href="https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.12/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-apple-darwin.tar.gz"><strong>macOS</strong></a></p>
</li>
<li>
<p><a href="https://static.dev.sifive.com/dev-tools/freedom-tools/v2020.12/riscv64-unknown-elf-toolchain-10.2.0-2020.12.8-x86_64-w64-mingw32.zip"><strong>Windows MinGW</strong></a></p>
</li>
</ul>
</li>
<li>
<p>Extract the Downloaded Toolchain</p>
</li>
<li>
<p>Add the Extracted Toolchain to the <strong><code>PATH</code></strong> Environment Variable‚Ä¶</p>
<div><pre><code>riscv64-unknown-elf-toolchain-.../bin
</code></pre></div></li>
<li>
<p>Check the RISC-V Toolchain‚Ä¶</p>
<div><pre><code>riscv64-unknown-elf-gcc -v
</code></pre></div></li>
</ol>

    


</div>
  </body>
</html>
