<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://simulavr.com/blog/fpga-image-processing-pipeline/">Original</a>
    <h1>SimulaVR FPGA Image Processing Pipeline</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            <p>We have recently been <a href="https://simulavr.com/blog/fpga/">working on an FPGA Board</a> to help process camera data for Simula&#39;s AR Mode. <strong>We&#39;ve recently made some block diagrams which show the signal flow from the Camera Boards to the FPGA to the Host. Below, we show these diagrams, and then discuss the image processing pipeline inside the FPGA.</strong></p>

<!-- Below are some block diagrams showing the signal flow from the Camera Boards to the FPGA to the Host.  -->
<h2 id="1-1-camera-boards-fpga">1.1 Camera Boards -&gt; FPGA</h2>
<p>We have two diagrams describing signal flow from the Camera Boards to the FPGA.</p>
<h3 id="1-1-1-image-data-flow-slvs-ec">1.1.1 Image Data Flow (SLVS-EC)</h3>
<p>The first and most important diagram explains how image data flows from the Camera Boards to the FPGA via SLVS-EC. (Note that boxes in blue denote non-FPGA boards, boxes in white denote interfaces, and boxes in yellow mark FPGA abstractions):</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/FPGA_SLVS-EC_flow.png" alt=""/></p>
<p>SLVS-EC is the protocol we are using to route images from our Camera Boards to our new FPGA board. It stands for &#34;Scalable Low-Voltage Signaling with Embedded Clock&#34;, and is developed by Sony. It features an embedded clock signal, supports up to 8 lanes (including multiple streams or sensors at once). </p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/SLVS-EC_protocol.png" alt=""/></p>
<p>Some other terms used in the diagram:</p>
<ul>
<li><strong>INCK:</strong> Stands for &#34;Input Clock&#34;</li>
<li><strong>GTY.</strong> A transceiver block used in Xilinx FPGAs for high-speed communication interfaces</li>
<li><strong><code>RX*</code>:</strong> Stands for receiver channels</li>
<li><strong>REFCLK:</strong> Stands for &#34;Reference Clock&#34;</li>
<li><strong>MicroBlaze:</strong> A <a href="https://en.wikipedia.org/wiki/Soft_microprocessor">soft microprocessor</a> IP core provided by Xilinx</li>
<li><strong>AXI4-Stream:</strong> A protocol designed for transporting arbitrary unidirectional data</li>
</ul>
<h3 id="1-1-2-camera-control">1.1.2 Camera Control</h3>
<p>The second diagram shows the Camera Control signals going between Camera Boards and the FPGA (see the next section for some examples of these signals). SPI stands for &#34;Serial Peripheral Interface&#34;, which is another communication protocol used for exchanging data between digital devices:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/FPGA_Camera_Control_flow.png" alt=""/></p>
<p>The microprocessors on the Camera Boards are for power sequencing only (hence the label &#34;Power Sequencing&#34;). The Image Sensors on the Camera Boards have a variety of control signals though, including:</p>
<ul>
<li><strong>Triggers:</strong> E.g. signals that start and stop the process of capturing an image.</li>
<li><strong>HSYNC:</strong> Indicates that one line of the frame is transmitted.</li>
<li><strong>VSYNC:</strong> Indicates that an entire frame is transferred.</li>
<li><strong>SPI configuration:</strong> E.g. clock frequency, data bit lengths, etc.</li>
</ul>
<p>Other camera settings also include aperture length and exposure time. This is explained in more detail in the next section.</p>
<h2 id="1-2-fpga-host">1.2 FPGA -&gt; Host</h2>
<p>The final diagram indicates the <a href="https://en.wikipedia.org/wiki/PCI_Express">PCI Express</a> signal flow from the FPGA to the Host (Simula&#39;s onboard computer):</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/FPGA_PCIe_flow.png" alt=""/></p>
<p>Note that the large blue box on the left labeled &#34;PCIe&#34; denotes the Host. &#34;C2H&#34; stands for &#34;card-to-host&#34;. &#34;PCIe DMA&#34; (labeled orange) stands for &#34;Direct Memory Access&#34;, and is what allow the Host to directly grab the processed FPGA data (used for Simula&#39;s AR Mode).</p>

<p>After image data arrives to the FPGA from the Camera Boards, it is subjected to a multi-stage image processing pipeline before being handed off to the Host:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_pipeline.png" alt=""/></p>
<p>Below we review each of these steps.</p>
<h2 id="2-1-black-level-flat-field-correction">2.1 Black Level &amp; Flat Field Correction</h2>
<p>A pixel&#39;s &#34;black point&#34; refers to the minimum brightness value that it can have, given a sensor/configuration. In theory, every pixel&#39;s &#34;black point&#34; should be 0; in practice, this isn&#39;t always true. <strong>Black level correction</strong> is then a process that force-adjusts the black point of each pixel to 0.</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_black_and_flat_correction.png" alt=""/></p>
<p>Similarly, <strong>flat field correction</strong> cancels the effects of image artifacts caused by variations in the pixel-to-pixel sensitivity of an image sensor and/or the non-uniformity of the camera lenses.</p>
<p>To do this, a &#34;flat-field image&#34; is captured from a uniform, featureless surface (such as a screen or lens cap). The uniform image is then used a reference to detect for unwanted variations in the brightness across the pixels, which can then later be corrected for via adjustments:</p>
<p>In our FPGA, both processes can be visualized as follows:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_black_and_flat_correction.png" alt=""/></p>
<ul>
<li>Here, the load coefficients refer to the brightness values of each image sensor pixel.</li>
<li><code>Dark(x,y)</code> refers to a pixel&#39;s brightness when the sensor covered/made dark.</li>
<li><code>Flat(x,y)</code> refers to the adjustment factor determined from the &#34;flat field&#34; test</li>
</ul>
<h2 id="2-2-bad-pixel-correction">2.2 Bad Pixel Correction</h2>
<p>Image sensors can have defective pixels that fail to sense light levels correctly. In our FPGA pipeline, we check for defective pixels and then replace them with the average value of surrounding pixels:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_bad_pixel_correction.png" alt=""/></p>
<h2 id="2-3-debayering">2.3 Debayering</h2>
<p>Debayering (also referred to as &#34;demosaicing&#34;) refers to the process of converting a mosaic patterned image of R,G, or B pixels into a full-color image.</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/business/png/image_sensor_mosaic.png" alt=""/></p>
<p>Under the hood, an image sensor (like our Sony IMX547) contains a grid of non-overlapping Red, Green, and Blue photosensors. As light hits the sensor, each of these photosensors only detects its corresponding color (red, green, or blue). This means the image sensor lacks complete color data in every node, which necessitates further image processing (in our FPGA) to interpolate the missing color details.</p>
<p>As an example, the following (non-overlapping) photosensor nodes are split up into red, green, and blue photosensor nodes:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/business/png/red_green_blue_nodes.png" alt=""/></p>
<p>As can be seen above, an (e.g.) &#34;red&#34; node in the sensor lacks &#34;green&#34; and &#34;blue&#34; data. To fill in for the missing color data, a process called &#34;demosaicing&#34; has to be undertaken, which interpolates the unknown color data for each node:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/business/png/demosaiced_data.png" alt=""/></p>
<p>The end result is a recognizable image with full color data in every pixel.</p>
<h2 id="2-4-auto-exposure">2.4 Auto Exposure</h2>
<p><strong>Auto Exposure</strong> refers to the automatic adjusting of exposure time and aperture length to produce a well-exposed image.</p>
<ul>
<li><strong>Exposure time:</strong> Length of time that the image sensor is exposed to light</li>
<li><strong>Aperture length:</strong> Size of opening of the camera&#39;s lenses</li>
</ul>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_auto_exposure.png" alt=""/></p>
<p>In the FPGA, we take a full frame of pixels, convert them into a luminance histogram, and then feed the data into our soft microcontroller (&#34;MicroBlaze&#34;). This then sends signals back to the Camera Boards to adjust the aperture/exposure settings accordingly.</p>
<h2 id="2-5-auto-white-balance">2.5 Auto White Balance</h2>
<p><strong>Auto White Balance</strong> refers to the process of automatically adjusting the colors in an image to neutralize the color cast caused by different lighting conditions. Algorithmically, we use the &#34;Gray World Assumption&#34; for this, or the assumption that the average color of any image ought to be a neutral gray:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_auto_white_balance.png" alt=""/></p>
<p>Each frame, we take grab the pixels and multiply/adjust them so that so that the transformed frame&#39;s average value is a neutral gray.</p>
<h2 id="2-6-color-correction">2.6 Color Correction</h2>
<p>While white balance aims to remove color casts in an image by making the colors appear more neutral, <strong>color correction</strong> aims to improve the overall color representation and saturation of an image:</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_color_correction.png" alt=""/></p>
<p>In the FPGA, the colors are adjusted on image frames based on a pre-defined matrix to produce a desired color balance.</p>
<h2 id="2-7-gamma-correction">2.7 Gamma Correction</h2>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_gamma_correction_chart.png" alt=""/></p>
<p><strong>Gamma correction</strong> adjusts the shades captured by digital cameras to better match how they should appear to our actual eyes. Consider:</p>
<ul>
<li><strong>Image sensors (linear).</strong> When twice the number of photos hit an image sensor, it receives twice the signal.</li>
<li><strong>Human eyes (non-linear).</strong> When twice the number of photos hit our eyes, our eyes perceive it as only a fraction brighter (nonlinearly).</li>
</ul>
<p>The purpose of gamma correction is to correct for this discrepency. Pixel tones are redistributed so that they are closer to how our human eyes perceive them.</p>
<p><img src="https://www.wolframcloud.com/obj/george.w.singer/simula/png/ImageProcessing_gamma_correction.png" alt=""/></p>
<p>In the FPGA, gamma correction is undertaken by simple matrix multiplication and exponentiation. Note that Gamma correction can also be done on the GPU during rendering instead of the FPGA. (In fact, pretty much anything that just modifies the debayered image can be done on the GPU instead).</p>

          </div></div>
  </body>
</html>
