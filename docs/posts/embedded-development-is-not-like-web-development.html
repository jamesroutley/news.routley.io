<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://the.scapegoat.dev/embedded-development-is-not-like-web-development/">Original</a>
    <h1>Embedded development is not like web development</h1>
    
    <div id="readability-page-1" class="page"><div>
<div><p>When I wrote <a href="https://the.scapegoat.dev/embedded-programming-is-like-web-development/">Embedded programming is like web development</a>, I thought it would be a pretty uncontroversial article—I expected the response to be along the lines of &#34;geez manuel, that&#39;s pretty obvious.&#34;</p>
<p>It turns out that that was far from the case—most feedback I got was that both were significantly different. This puzzles me deeply: I switch back and forth between both domains weekly, yet I feel like I am using the same techniques and writing almost identical code.</p>
<p>To gain a better perspective, I wrote up all the reasons I could think of why embedded development is not like web development. I hope that this gives some context to the previous article and helps me provide more clarity moving forward.</p>

<p>I will use  bare-metal microcontroller-oriented work as a stand-in for &#34;embedded development.&#34; While a fair amount of embedded development these days involves Linux system programming, cloud computing, graphical UIs, and data processing, I don&#39;t want to blur the boundaries too much and muddy my examples.</p>
<p>If you do bare-metal programming, you need to know a certain set of tools and practical skills:</p>
<ul>
<li>It helps to learn how your CPU works. It is frequent to change architectures on different projects, and there is a wide range of peripheral buses and architectures that need to be relearned. While programming languages stay the same, there is a lot of datasheet reading involved.</li>
<li>You must be comfortable with various physical tools: oscilloscope, logic analyzer, soldering iron, and breadboards.</li>
<li>You need to know at least rudimentary electronics to pinpoint electrical bugs and know how to use the oscilloscope. More advanced electronics knowledge is useful for building peripheral circuits.</li>
<li>Running and debugging your program requires a debugging probe.</li>
<li>You have to be able to read and step through assembly language. The compiler output often demands special scrutiny.</li>
<li>You will have to deal with intermediate board versions that are often broken in subtle ways (wrong traces, signal noise, bad power supply).</li>
<li>You usually work with real-world prototypes (for example, a set of motors on your desk instead of the real machine). These not only exhibit their own quirky bugs but often are incomplete.</li>
</ul>
<p>The code and runtime requirements are very different:</p>
<ul>
<li>Codebases are usually small and self-contained.</li>
<li>There is low code reuse, and open-source libraries are fairly uncommon (although that is changing).</li>
<li>Much of the code is interfacing with peripherals and bus protocols, requiring a lot of reading and comprehending datasheets.</li>
<li>Memory management is typically manual, and memory is scarce: dynamic allocation and fancy data structures are usually out.</li>
<li>Parts of the system have real-time constraints, often hard real-time.</li>
<li>Doing IO usually involves dealing with interrupts, having to program peripherals by reading and writing memory-mapped IO, and often using DMA and timers. This is asynchronous by nature; there is often no OS to provide blocking semantics.</li>
<li>There is no or limited persistent storage.</li>
<li>Debugging usually perturbs the system badly enough that <a href="https://the.scapegoat.dev/10-debugging-tips-for-embedded-and-distributed-systems/">elaborate debugging strategies</a> have to be devised.</li>
<li>There is not that much material out there to learn from. Communities are fragmented and scarce (this has changed over the years, with the influx of developers growing up on Arduino and now with the Rust embedded movement).</li>
</ul>
<h2 id="skills-of-a-web-full-stack-developer">Skills of a web full-stack developer</h2>
<p>Similarly, web development has its own tools, technologies, workflows, and constraints.</p>
<ul>
<li>A lot of different technologies are involved in a single project. You will need to know some CSS, HTML, SQL, and Linux skills in addition to &#34;pure&#34; programming. You will often interface with a plethora of external APIs.</li>
<li>There is a lot of code reuse. You often work against big frameworks like Django, React, and Vue. These frameworks move quickly, and there is always some new hype around the corner.</li>
<li>There are a lot of tools: you manage packages, minify, lint, type check, bundle, transpile your front end, migrate your database, scaffold new components, run development containers, do remote debugging, and deploy and monitor your services in production. These tools evolve at the speed of the modern open-source community, which can be overwhelming.</li>
<li>Programming trends and techniques evolve often; there is a lot of hype-driven iteration. Conversely, there are a lot of learning materials, conferences, and communities out there to help you stay up to date.</li>
<li>Your code interfaces with a lot of third-party systems and services. Even a simple web application usually deals with a web server, a cache, a database, a load balancer, cloud storage, a logging service, and more. More complex systems deal with container orchestration, microservices, message buses, secrets management, and edge computing.</li>
<li>Much time is spent working with UX, graphic design, and marketing, so much so that some of these functions are sometimes part of engineering teams.</li>
<li>Your system runs on pretty beefy machines (browser, cloud servers). You can be fairly loose with runtime and memory requirements and use a lot of &#34;layered&#34; frameworks.</li>
<li>While asynchronous code is fairly common, you are offered a lot of synchronous APIs to simplify your code, especially in backend work.</li>
<li>Products tend to be significantly more complicated, with complex UX workflows, large-scale deployments, and the integration of many services.</li>
<li>The actual runtime environment of your system is often significantly different from the development or staging environment. There will be emergent behavior at scale that can&#39;t easily be replicated on a developer&#39;s machine.</li>
<li>Products are continuously observed and maintained while they are running. There usually is a dedicated ops team responsible for maintaining the application&#39;s runtime.</li>
</ul>
<h2 id="so-why-did-i-say-that-embedded-development-is-just-like-web-development">So, why did I say that embedded development is just like web development?</h2>
<p>I think that the day-to-day of a programmer differs significantly depending on which domain they work with. The set of skills, the onboarding, and the learning experience are tremendously different. You can&#39;t just put a junior embedded developer before a web application and have them contribute meaningfully.</p>
<p>However, once you become a seasoned developer (at a senior+/staff level), your work becomes much more abstract: you think in systems more than in the minutiae of actual code.</p>
<p>In fact, with the decreasing amount of coding you do, you can quickly become rusty. It&#39;s been years since I have written a kernel driver or a bare-metal firmware, and I have to fight with webpack every time I get back into front-end development. My CSS knowledge—poor in the best of times—evaporates every few weeks. However, I know that I can pick up whatever current knowledge is required to build them, and I know where they fit in the system and what tradeoffs can be made. I can also provide guidance and advice to more junior developers on the team and help them grow.</p>
<p>Overall, higher-level patterns transpose very effectively from one domain to the other. Someone knowledgeable about &#34;real-time&#34; WebRTC, WebSockets, HTTP, and gRPC will have no trouble understanding the nuances of USB or how a network protocol might fit the problem at hand. Similarly, a frontend developer that is knowledgeable in building complex asynchronous applications using state reducers, promises, and state machines will have no problem designing and code reviewing some more intricate firmware—even writing one after having been shown the nitty-gritty of flashing and debugging by an experience embedded develop.</p>
<p>I hope to give concrete code examples to make this admittedly abstract statement much more tangible in my next few posts.</p>
<p>(thanks to Ed for taking the time to give me feedback!)</p>
</div>
</div></div>
  </body>
</html>
