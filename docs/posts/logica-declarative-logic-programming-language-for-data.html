<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://logica.dev/">Original</a>
    <h1>Logica â€“ Declarative logic programming language for data</h1>
    
    <div id="readability-page-1" class="page"><div>
  <a href="https://github.com/evgskv/logica">
    <div onclick="thumbsUp()">
      <p><img src="https://logica.dev/github-mark.png" height="80px"/></p>
    </div>
  </a>



<div>
<p>
  Logica is an <a href="https://github.com/evgskv/logica">open source</a>
  declarative logic programming language for data manipulation.
</p>

<p>
  Logica extends syntax of logic programming for intuitive and efficient data
  manipulation. It compiles to SQL thus providing you access to the power
  of SQL engines with the convenience of logic programming syntax.
</p>
</div>


  


<p>
  One may say that for programming languages like Python and Java functions are the
  basic building blocks. For Logica and other logic programming languages
  those building blocks are <i>predicates</i>. 

  Logic program is defined as a set of rules that define output predicates
  from pre-defied predicates. Those pre-defined predecates represent input data.

  For example here is a rule to identify names of expensive books, from an existing
  table of book prices.
</p>


<p>
# Logica rule to get expensive books.
ExpensiveBook(book_name) :-   # book_name is expensive if and only if
  Book(book_name, price),     # book_name costs price
  price &gt; 100;                # and price is greater than 100.
</p>

<p>
If you are familiar with SQL, you may see that the rule above
is equivalent to the flowing SQL statement. Not that familiarity with SQL is
required to learn Logica, not at all.
</p>

<p>
# SQL statement to get expensive books.
SELECT book_name
FROM book
WHERE price &gt; 100;
</p><p>

Predicate is a statement with variables. Any table can be treated as predicate,
where column names are the variables, and each row is a set of values of the variables
that satisfies the statement. 

While SQL is quite convenient for small queries like the one above it
gets hard to read when complexity grows. Logica leverages power of
mathematical syntax to scale nicely as complexity grows.

Let&#39;s assume we have a table <span>BabyNames</span>
that for each <span>name, year, city</span> and
<span>gender</span> specifies 
<span>number</span> of babies of that name born.
The following program finds a list of <i>popular</i> names, where a name
is defined as popular if it was the most popular name on some year.

</p><p>
# Count babies per year.
NameCountByYear(name:, year:) += number :-
  BabyNames(name:, year:, number:);
  
# For each year pick the most popular.
TopNameByYear(year) ArgMax= name -&gt; NameCountByYear(name:, year:);

# Accumulate most popular name into a table, droppig the year.
PopularName(name: TopNameByYear());
</p><p>

Sometimes data analysis requires solving algorithmic problems. Logica&#39;s
syntax is suited for it naturally. Here is a program finding prime numbers
that are less than 100.

</p><p>
  # Define numbers 1 to 30.
  Number(x + 1) :- x in Range(30);
  
  # Defining composite numbers.
  Composite(a * b) distinct :- Number(a), Number(b), a &gt; 1, b &gt; 1;
  
  # Defining primes as &#34;not composite&#34;.
  Prime(n) distinct :- Number(n), n &gt; 1, ~Composite(n);
</p>

<p>
Finally here is an example of program that runs over
<a href="https://www.gdeltproject.org/">GDELT Project</a> dataset,
finding people mentioned in the context of &#34;artificial general intelligence&#34;.
</p>


<p>Observe that program is divided into a rule defining predicate
  <span>NewsData</span> and rule for <span>AgiMentions</span>.
The first rule is essentially doing data cleaning, formatting the dataset in a shape
that is convenient to use. Then second rule peforms the task at hand.
</p>

<p>
In Logica problems are naturally split into smaller components that end up
reusable. So in the future if we have more analysis to do with GDELT dataset
we may take advantage of the <span>NewsData</span> predicate that we just wrote.
</p>

<p>
# Structuring the data conveniently.
NewsData(year:, month:, day:, persons:, quotations:) :-
  gdelt-bq.gdeltv2.gkg(persons: persons_str, quotations:, date: date_num),
  # Column `data` in GDELT dataset is given as an integer.
  year == ToInt64(Substr(ToString(date_num), 1, 4)),
  month == ToInt64(Substr(ToString(date_num), 5, 2)),
  day == ToInt64(Substr(ToString(date_num), 7, 2)),
  persons List= (person :- person in Split(persons_str, &#34;;&#34;));

# Performing the task at hand.
@OrderBy(AgiMentions, &#34;mentions desc&#34;);
@Limit(AgiMentions, 10);
AgiMentions(person:, mentions? += 1) distinct :-
  person in persons,
  Like(quotations, &#34;%artificial general intelligence%&#34;),
  NewsData(persons:, quotations:);

</p><p>

This program completes in interactive time
when ran over the 4TB dataset
via BigQuery.

</p><div>
  <p>

Logica is for engineers, data scientists and other specialists who 
need to perform complex data processing and analysis.
Queries and pipelines written in Logica can run on
<a href="https://cloud.google.com/bigquery">BigQuery</a>, <a href="https://sqlite.org/index.html">SQLite</a>
and <a href="https://www.postgresql.org/">PostgreSQL</a> engines.
Information stored in these systems is thus available in Logica.


</p><p>
Logica compiles to SQL and gives you access to the power of SQL engines,
including the massively distrbuted Google BigQuery engine,
with the convenience of logic programming syntax. This is useful because
BigQuery is magnitudes more powerful than state of the art native
logic programming engines.
</p>

<p>
We encourage you to try Logica, especially if
</p>

<ul>
  <li>   you already use logic programming and need more computational power, or </li>
  <li>   you already have data in BigQuery, PostgreSQL or SQLite, or </li>
  <li>   you want to learn logic programming and apply it to processing of Big Data.</li>
</ul><p>

Among other engines, there is partial support for Trino and Databricks.
Contributions to improve this support are
<a href="https://github.com/EvgSkv/logica/discussions">very welcome</a>!

</p></div>



<p>
Logic programming is a declarative programming paradigm where the program is
written as a set of logical statements.
</p>

<p>
Logic programming was developed in academia from the late 60s. Prolog and
Datalog are the most prominent examples of logic programming languages. 
Logica is a successor to
<a href="https://research.google/pubs/pub43462/">Yedalog</a>,
a language created at Google earlier. Logica as well as Yedalog belong to
Datalog family.
</p>

<p>
Datalog and relational databases start from the same idea: think of data
as relations and think of data manipulation as a sequence of operations over
these relations. But Datalog and SQL differ in how these operations are
described. Datalog is inspired by the mathematical syntax of the first order
propositional logic and SQL follows the syntax of natural language.
</p>

<p>
SQL was based on the natural language to give access to databases to the people
without formal training in computer programming or mathematics. This convenience
may become costly when the logic that you want to express is non trivial.
There are many examples of hard-to-read SQL queries that correspond to simple
logic programs.
</p>

<p>
Logica follows Yedalog in the attempt to merge these branches back together:
extending the elegant syntax of Logic Programming to solve practical problems
and leverage the tremendous advances of SQL infrastructure for the execution.
</p>


<p>

Logica compiles the logic program into a SQL expression,
so it can be executed on BigQuery, the state of the art SQL engine.

Among database theoreticians Datalog and SQL are known to be equivalent.
And indeed the conversion from Datalog to SQL and back is often straightforward.
However there are a few nuances, for example how to treat disjunction and negation. In Logica we tried to make choices that make understanding of the resulting SQL structure as easy as possible, thus empowering user to write programs that are executed efficiently.

</p><p>

Logica stands for <b>Logic</b> with <b>a</b>ggregation.

</p>

<p>
Learn basics of Logica with the
<a href="https://colab.research.google.com/github/EvgSkv/logica/blob/main/tutorial/Logica_tutorial.ipynb">CoLab tutorial</a> 
located at <a href="https://github.com/EvgSkv/logica/tree/main/tutorial">tutorial</a> folder.
See <a href="https://github.com/EvgSkv/logica/tree/main/examples">examples</a> of using Logica in examples folder.

You try Logica immediately in the browser in <a href="https://logica.dev/sandbox.html">Playground</a>.
</p>

<p>
It is easy to install Logica on your machine as well.
</p>

<p>

Install Logica with `pip`.

</p><p>
# Install:
$ python3 -m pip install logica
# Run:
$ python3 -m logica
# (optional) Create alias for convenience:
alias logica=python3 -m logica
</p><p>

Let&#39;s say this program is written in file
 <span>hello.l</span>.
</p><p>
@Engine(&#34;sqlite&#34;);
Greeting(&#34;Hello world!&#34;);
</p><p>

When exectued with

</p><p>
$ logica hello.l run Greeting
</p><p>

it should produce the following table:</p></div></div>
  </body>
</html>
