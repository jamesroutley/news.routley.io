<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nmn.gl/blog/ai-and-programmers">Original</a>
    <h1>I tried resisting LLMs for programming. Then I tried using them. Both were painful.</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    
    
      <p>Every day I see another heartfelt post about “resisting AI use” or “keeping the craft pure.”</p>

<p>Those posts remind me of myself. If you met me two years ago, you’d see me tastefully craft each line and function of the code I write.</p>

<p>Fast forward to today, and I’ve let go of control and I let the AI handle a lot of my codebase. Not because I necessarily want to, but because I feel like we programmers <em>don’t have a choice anymore?</em></p>

<p>The uncomfortable truth is that AI is changing our work whether we like it or not. And spoiler alert: it’s not all productive.</p>

<!--more-->

<h2 id="when-i-thought-i-knew-everything">When I thought I knew everything</h2>

<p>In 2016, I had a couple of years experience as a developer and was making sites serving millions of users with <em>pure</em> HTML, CSS, JS, and a little bit of jQuery.</p>

<p>Around that time, I was seeing React gain popularity— and I wasn’t a fan at all.</p>

<p>SPA frameworks increased load times (remember waiting 10 seconds for a simple landing page?), were worse for SEO (Google was terrible at indexing JS-rendered content back then), and downright bad for accessibility. I was confident that the trend would die out.</p>

<p>And I wasn’t alone. There were a lot of people like me on Reddit, as evidenced by Mr. <code>[deleted]</code>’s rant:</p>

<figure>
  <img src="https://nmn.gl/blog/assets/framework-hate.png" alt=""/>
  <figcaption>My kind of people</figcaption>
</figure>

<p>Convinced, I doubled down on using plain old JS, no framework. I was writing <em>pure</em> code. I was crafting “elegant” solutions. And I knew that the world would eventually see reason, and return to simpler approaches.</p>

<h2 id="want-to-guess-how-that-turned-out">Want to guess how that turned out?</h2>

<p>Here’s what actually happened:</p>

<ul>
  <li>Developers who embraced React shipped more applications faster.</li>
  <li>Companies that adopted it could iterate quicker and push features that users actually noticed.</li>
  <li>Meanwhile, my “elegant” vanilla JS solutions took three times as long to build.</li>
</ul>

<p>The industry had simply moved on, while I was busy being “right”.</p>

<h2 id="hard-truth-about-businesses">Hard truth about businesses</h2>

<p>Let’s take some time to think about <em>why</em> so much code exists in the first place.</p>

<p>I learned this lesson from my former engineering manager. We were celebrating after a product launch, and I was complaining about some tech debt we’d accumulated.</p>

<p><em>“You know what?”</em> he said. <em>“I’ve never once heard the CEO care about our code quality. The only thing that matters is if we can deliver before deadlines or not. Nobody’s getting promoted for clean code if the feature ships late.”</em></p>

<p>It was disappointing, but also… <em>enlightening</em>?</p>

<p>Code written for businesses allows executing repeatable processes that increase profits and/or save time. It is a means of delivering specific business objectives, not an “art.”</p>

<figure>
  <img src="https://nmn.gl/blog/assets/devs-vs-businesses-art-vs-deadlines.png" alt="Devs vs Businesses"/>
  <figcaption>What devs prioritize vs what businesses prioritize</figcaption>
</figure>

<p>As a programmer, since I live <em>inside</em> my codebase, I want to make it perfect exactly the way I want. I still get a dopamine hit when I refactor a messy function into something elegant.</p>

<p>But if I think about this from the perspective of a business, my code is merely a <em>tool</em> to earn profits.</p>

<h2 id="ai-is-not-your-savior">AI is not your savior</h2>

<p>So, I started using AI <em>heavily</em> to get results quicker. After 6 months of daily AI coding, some facts:</p>

<ul>
  <li><strong>It confidently <a href="https://nmn.gl/blog/dangers-vibe-coding">generates absolute garbage.</a></strong> Just last week, it gave me a security vulnerability disguised as a best practice. <em>Thanks, AI!</em></li>
  <li><strong>The debugging overhead is real.</strong> Sometimes fixing AI’s “solution” takes longer than writing it yourself.</li>
  <li><strong>It can’t understand complex business logic.</strong> Ask it to implement a multi-tenant authorization system, and watch it fall apart.</li>
</ul>

<p>But here’s the thing—and this is important—despite all these frustrations, I keep using it.</p>

<h2 id="why-i-still-use-ai">Why I (still) use AI</h2>

<p>The painful reality is that someone using AI will outpace someone who is not.</p>

<p>Not because AI is perfect, but because:</p>

<ul>
  <li>The mundane stuff is automated. Writing boilerplate, setting up API endpoints, implementing standard patterns—AI handles these faster than I can type.</li>
  <li>The frustration is worth it. Even with the debugging overhead, I’m still faster overall.</li>
  <li>My PRs are bigger, my features ship faster. The code quality is actually often better because I’m less fatigued from writing repetitive code.</li>
</ul>

<h2 id="what-a-good-programmer-means-now">What a “Good Programmer” means now</h2>

<p>Remember what defined a good programmer a few years ago? Back when I first started, being “senior” meant you had encyclopedic knowledge of your stack.</p>

<p>With AI, that definition is outdated. Now, a good programmer needs different skills:</p>

<ul>
  <li>Prompt engineering. This seems obvious, but there’s an art to it. The quality of your AI output directly corresponds to your prompt skills. I keep a list of <a href="https://nmn.gl/blog/ai-prompt-engineering">effective prompts for different situations</a>.</li>
  <li>Code reviewing. AI will confidently generate nonsense. Getting good at identifying it quickly is necessary now</li>
  <li>Architecture thinking. AI handles the implementation; you focus on the design.</li>
  <li>Business translation. Converting vague requirements into precise technical specs that AI can execute.</li>
</ul>

<h2 id="how-to-keep-up">How to Keep Up</h2>

<p>It’s a completely different mental process to be programming with AI. I’ve been experimenting with ways to get comfortable with it. Here’s what’s actually working:</p>

<ul>
  <li>Build your verification instincts. When AI outputs code, I learned to spot the red flags: incorrect library usage, not using existing functions or patterns, incorrect domain knowledge.</li>
  <li>Operate at the edge of your abilities. Use AI for the mundane stuff (boilerplate, standard patterns, typical integrations), then <a href="https://nmn.gl/blog/ai-and-learning">apply your creativity to the novel problems</a> AI can’t handle yet.</li>
  <li>Deep dive when things break. The best learning happens at failure points. When AI-generated code breaks, that’s your cue to really understand the underlying system. Add logs, use the debugger, manually go through each part of the code flow.</li>
  <li>Keep a “WTF AI” journal. Document the spectacular failures. It’s therapeutic and surprisingly educational.</li>
</ul>

<h2 id="the-uncomfortable-truth">The Uncomfortable Truth</h2>

<p>AI is not optional for programmers anymore. Just like frameworks, high-level languages, and Stack Overflow before it, AI is now part of the workflow.</p>

<p>The developers who adjust to this new reality fastest will have the most interesting careers over the next decade.</p>

<p>But let’s be real—it’s not all productivity gains. It’s frustration, debugging, and occasionally questioning your life choices. AI is a powerful but flawed tool—one that needs constant supervision, but ultimately lets you build things you never had time to before.</p>

<p>Maybe, just maybe, we’ll look back at this era the same way we look at the framework debates. Another tool that felt threatening until it became indispensable.</p>

<p>Time will tell.</p>

<p><em>Thanks to <a href="https://www.linkedin.com/in/jmontroy90/">John</a>, <a href="https://cysabi.github.io/">Cyrene</a>, and <a href="https://www.linkedin.com/in/mikkqu/">Mikhail</a> for helping me think deeper about these ideas and for sharing feedback on my drafts</em></p>

    
    
    
      
        <p>P.S. I made an AI code reviewer that saves 15 hours/week per developer. Used by developers &amp; teams worldwide. <a href="https://gigamind.dev/code-reviewer?utm_source=blog&amp;utm_medium=post&amp;utm_campaign=post-promotion&amp;utm_content=I+tried+resisting+LLMs+for+programming.+Then+I+tried+using+them.+Both+were+painful.&amp;utm_term=%2Fai-and-programmers">Check out Giga AI</a>.</p>
      
    
  </div></div>
  </body>
</html>
