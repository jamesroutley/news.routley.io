<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/first-impressions-of-lean-and-coq/">Original</a>
    <h1>My first impressions from a few weeks with Lean and Coq</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Friday, October 28, 2022</strong></p>

    <p>For the last few weeks, some of us have been working through learning about interactive theorem proving together at Recurse Center.
I&#39;ve been curious about proof assistants since undergrad, and finally have the time, space, and peers to dive into it with.
It&#39;s been an interesting experience getting started.
Since we&#39;re just getting started, I can&#39;t tell you much about the long-term experience, but I can give some basic guidance on what it&#39;s like to get started on each and who I imagine the audience for each is.</p>
<p>First off, <strong>what&#39;s a proof assistant?</strong>
Simply, it&#39;s a piece of software that helps develop formal proofs via human-machine collaboration.
You want formal proofs in a lot of cases; they&#39;re used in math, but it would also be great to know that an algorithm you want to implement does what you say it does, or that a bigger piece of software is proven correct.
Proving software correct does, of course, lead to the question of how you check that the spec is correct, and that you&#39;re specifying the properties you care about.
That&#39;s a whole other conversation.</p>
<p>There are a bunch of different proof assistants available.
The big names are:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Coq">Coq</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lean_(proof_assistant)">Lean</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lean_(proof_assistant)">Isabelle</a></li>
</ul>
<p>From the outside it&#39;s hard to know which one to pick based on features of the proof assistant itself, so we chose based on the material available to learn from.
If you learn one, it&#39;ll make learning the others easier, so going off what&#39;s most accessible to learn is a great approach.</p>
<p>Where we went wrong is we <em>thought</em> we picked the one that was most accessible to learn.
We started out with Lean, using <a href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving in Lean 4</a>.
When we started, I wasn&#39;t aware that there&#39;s a split in the community.
The maintainers of Lean have moved on from Lean 3 and started Lean 4, which aims to (among other things) also be a fully-featured general purpose programming language.
Unfortunately, much of the material out there is for Lean 3 (such as the impressive library of math that they&#39;re proving as a community!) which is now also maintained by the community in <a href="https://github.com/leanprover-community/lean">a fork</a>.
I&#39;m not sure which would be better to learn. If I tried it again, I&#39;d probably try Lean 3 since the community is there, but I&#39;d also probably not try again.</p>
<p>I did take away some important concepts from our brief misadventures with lean, and there were some positives.
The tooling was very nice and easy to install.
Lean has a nice <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">LSP</a> implementation, making it easy to integrate with your text editor of choice, and there are robust plugins available.
The whole thing was nice and easy to install.
But that&#39;s sort of where the fun ended.</p>
<p>The learning material was very choppy and difficult for us to work through.
It had sparse exercises, and there was a sudden cliff of complexity in the first chapter.
Overall it felt like the target audience (appropriately) was mathematicians, and we&#39;re decidedly <em>not</em> mathematicians.</p>
<p>We moved on and started reading <a href="https://softwarefoundations.cis.upenn.edu/current/lf-current/index.html">Logical Foundations</a>, the first book in the Software Foundations series.
This series uses Coq, and it is targeting folks who are specifically interested in software, not in math.
For people who want to learn proof assistants with a software background, this feels like <strong>a much better choice</strong>.
It also helps that this is written by a group of professors who have a wealth of teaching experience, and it comes bundled with both exercises and an autograder for some of those exercises, so it&#39;s feasible to work through without an instructor.</p>
<p>The first chapter of Logical Foundations went much better for us than the first chapter of the Lean book.
There were things we didn&#39;t understand right away, and things we had to work through as a group.
In my opinion, this means that we found something that&#39;s the right level of difficulty:
It wasn&#39;t so hard that we can&#39;t get through it (hi, Lean), nor was it so easy that we&#39;re not learning.
It&#39;s a difficult that feels achievable but definitely stretches us.</p>
<p>And that&#39;s right on brand for working through something at Recurse Center, where one of the main principles is to work at the edge of your abilities.</p>
<p>Coq itself was not without its difficulties, however.
In particular, one of my fellow Recursers had a non-trivial time getting it installed.
This might be a particular issue with M1 Mac support, because I had a package available for nice and easy installation on Fedora.
It wasn&#39;t as easy setup as Lean, but then it eventually got out of our way.</p>
<p>In retrospect, Coq is also a much more solid choice for us to learn, curriculum and tooling aside.
It sees more use in the software industry than Lean, and has been used to produce <a href="https://compcert.org/doc/index.html">CompCert</a>, a C compiler which has been formally proven.
(Not that I&#39;m jumping to use CompCert: I&#39;d still be writing C, and my <em>own</em> programs would be riddled with memory errors.)
Isabelle is also a solid choice.
It&#39;s used to verify the <a href="https://sel4.systems/">seL4 Microkernel</a>, and Martin Kleppmann has used it to <a href="https://martin.kleppmann.com/2022/10/12/verifying-distributed-systems-isabelle.html">verify distributed algorithms</a>.
We didn&#39;t choose simply because we found good resources for Coq but not Isabelle.
I&#39;d like to explore Isabelle someday, because it looks a little more explicit than Coq, which I think would be more to my taste.
If you know any Isabelle resources, please send them my way!</p>
<p>Overall it&#39;s been a pretty great experience learning a proof assistant, in large part due to having peers learning it with me.
(Shoutout to Mary, Paul, and Ed!)
I&#39;d highly recommend trying it out if you&#39;re interested.
It&#39;s less scary than it seemsâ€”if you have the right material to learn from.</p>

  </article><p>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
