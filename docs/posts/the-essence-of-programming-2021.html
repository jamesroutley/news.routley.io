<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.gingerbill.org/article/2021/02/01/the-essence-of-programming/">Original</a>
    <h1>The Essence of Programming (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
<header>
	
	
	<p>
		<span>2021-02-01</span>
		</p>
</header>
<p>One thing I have noticed a lot when a programmer is struggling to solve a problem, especially a novice, is that he is stuck worrying about the “best way” to <em>implement</em> the solution rather than actually understanding the problem he has. I believe a lot of this stems from not understanding the essence of what programming fundamentally is.</p>
<h2 id="essentially-ordered-aspects">Essentially Ordered Aspects</h2>
<p>In a <a href="https://www.gingerbill.org/article/2020/05/31/progamming-pragmatist-proverbs/">previous article</a> of mine, I state that “Programming is a tool to solve problems that you have in the domain of computers”. At the essence of everything to do with programming, it is using and building tools with computers. My honest belief is that studying the concept of a tool itself and its essentially ordered aspects<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> will aid the use into correctly structuring our thinking about how we build tools in general.</p>
<p>The fundamental aspects of a tool are:</p>
<ul>
<li>Its Purpose,</li>
<li>Function,</li>
<li>Usage,</li>
<li>And Implementation/Form.</li>
</ul>
<p>Each following aspect/stage is a fulfilment of the previous, to which so stage can be skipped.</p>
<h3 id="purpose">Purpose</h3>
<p>A tool by its very nature is a means to achieve a particular ends. A good tool is one that fulfils its <em>purpose</em> well, the <em>reason</em> it was made. We use and build tools for <em>purposes</em>, there is a <em>why</em> behind the tool.</p>
<h3 id="function">Function</h3>
<p>The <em>function</em> of a tool, is the tasks that a particular means is assigned to accomplish. Using an example, the function of hammer may be described in that it used to drive nails, but in general, it hits other lesser tools (a nail being another kind of tool). The specific function of the tool is determined by the specific problem.</p>
<p><strong>Note:</strong> To clarify the difference, the purpose is the <em>why</em> behind the tool and the function is the <em>what</em> behind the tool.</p>
<h3 id="usage">Usage</h3>
<p>A tool is <em>used</em> in a particular way by the user. The <em>usage</em> is the fulfilment of its function. Most hammers will have a place for the user to hold, its handle, and a part which it can be used to hit things, its head/face. The <em>usage</em> of a tool is restricted by what <em>function</em> that tool has.</p>
<h3 id="implementationform">Implementation/Form</h3>
<p>Finally, how that tool is to be <em>implemented</em> is restricted and dictated by how tool is meant to be <em>used</em>. If all of the previous aspects have been fulfilled, then the <em>implementation</em> is most of the time not complicated (especially in programming). A hammer used for bricklaying may be implemented with a wooden handle, and a flat smooth steel head.</p>
<p><strong>Note:</strong> <em>Aesthetics</em> fits under this category of implementation or form. The implementation and how it appears can be separated, but rarely is in practice. How someone implements a tool is part of the aesthetic of that specific tool. Aesthetics is usually something that is evolved and discovered through tradition and not from pure reason.</p>
<h2 id="the-novices-pitfall">The Novice’s Pitfall</h2>
<p>For most people reading this article, most of this will seem dead obvious but they may not have seen it in this specific articulation. So why do I bring it up? Because forgetting (or not knowing of) this structure of the reality of what you are actually doing is the pitfall many novices, and even veterans, fall into when programming. Getting caught up in what is the best way to implement a program, or any problem for that matter, distracts the programmer from the problem.</p>
<p>For the vast majority of problems, especially the problems novices have, if you understand the purpose, function, and usage of the tool you are creating, then its implementation will be “trivial” in the sense that the previous aspects restrict how you approach the problem.</p>
<h3 id="teaching">Teaching</h3>
<p>When teaching novices, I have found that there are usually two different kinds of people (sometimes embodied in the same person):</p>
<ul>
<li>Novices who are stuck worrying about how to best implement their programs, but do not actually understand what the <em>purpose</em> of the program they are trying to do</li>
<li>Novices who understand what the purpose, function, and usage, of what their program is, but do not know the tools well enough about how to implement stuff</li>
</ul>
<p>Interestingly, the former is much more common than the latter.</p>
<p>In the latter case, these individuals are natural problem solvers and require only teaching the explicit thinking that goes on and the tools they require for producing their program, e.g. algorithms and data structures. In this case, practising is required to hone the skills of the novice.</p>
<p>In the former case, it does not matter if all the tools can be taught at all if the individual does not understand how to use them, what their function is, nor what the purpose of the problem he is trying to solve. This kind of novice needs to learn how to think like a problem solver.</p>
<p>Understanding this process of structuring your thinking of what a is tool, allows you to apply it further, and that can be applied to every aspect itself recursively. Each stage can be split up further into its own four-part structure. For example, there usually are many different ways to implement something to achieve the same ends which means understanding which one is the best compromise for the current situation.</p>
<p>Each stage can also give feedback as to whether it is possible to fulfil the previous stage, i.e. trying to implement a particular usage may unearth the impracticability or impossibility of the usage. This does not mean the process has been reversed but rather shown that the previous aspects were not stable foundations to work upon. Understanding how something is implemented can aid a lot about <em>why</em> something is used a particular way too.</p>
<p>Sometimes the implementation of something is difficult to determine, as hard problems are hard. Sometimes you cannot make a problem less complicated, but you can try to make it less complex by breaking it down into smaller problems. This is a skill that is continually learnt over many years, and not something you will ever perfect but will get better at.</p>
<h3 id="best-way">“Best Way”</h3>
<p>There is no such thing as an unqualified universal <em>“best way”</em> to solve a given problem in the abstract. And what is needed to be done is to understand the particular situations that requires one to attend to such problems. Compromise is a given, and the only way to get better is to practice, practice, practice. Abstract solutions are called algorithms, but how that algorithm is implemented depends on what it will be implemented on—the machine.</p>
<p>For novices, it should be made clear that being taught tools (e.g algorithms, data structures, paradigms, idioms, etc), does not imply that the “correct way” to do things has been learnt. The “correct way” is heavily specific to the problem domain; this cannot be taught but only learnt through experience over many years. Actualizing abstract ideas into reality is difficult to do, even for veterans to programming.</p>
<p>Aiming to abstract/generalize a problem is a recipe for disaster, especially for novices, because it is rarely ever the case problems are abstract/general. Most problems are particular/specific, and require knowledge of the domain of that problem. Application is should not be separated from the teaching of the topic. Try to solve the <em>specific</em> problem that is actually at hand, not a <em>general</em> problem that <em>might</em> exist<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>. Programming is an inherently practical endeavour rather than a theoretical one. And its teaching should reflect that. Theory is important, but most programmers do not want to, nor should they, have to become mathematicians in order to understand the application of anything.</p>
<p><strong>Note:</strong> For novices, a good rule of thumb when implementing a program is to aim for clarity, especially for others to read and comprehend, and do not try to be clever. And novices ought not be afraid to rewrite code if needed. Getting a good (not perfect) solution the first time is not expected of a novice, and through experience, getting a good solution will come quicker. Through the habit of practice, one will become better at the art of programming.</p>
<h3 id="process-of-thinking">Process of Thinking</h3>
<p>It should be clearly noted that this ordering only works for solving known problems, it is a way of thinking about purpose-driven domains, i.e. <em>engineering</em>. This process of structuring your thinking does not apply to exploratory things such as <em>research</em> and <em>science</em>. <em>Science</em> is not a purpose-driven domain but a exploration-driven domain. There is not a “goal” to the art of science, but a continuous process of discovery. As a discipline, programming is fundamentally closer to something like carpentry than a science. Programming is a craft of solving problems on computers.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Understanding the essence of what a tool is helps us structure our thinking when solving problems. It gives us a language and process to understand why and how we approach building tools. Many novices fall into the same trap of not understanding the problem that is trying to be solved, and are too concerned about the implementation. Teaching novices how to think about solving problems is extremely important in improving and honing in the craft.</p>


</article>
</div></div>
  </body>
</html>
