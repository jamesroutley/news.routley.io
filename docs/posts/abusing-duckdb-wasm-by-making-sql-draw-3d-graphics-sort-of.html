<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.hey.earth/posts/duckdb-doom">Original</a>
    <h1>Abusing DuckDB-WASM by making SQL draw 3D graphics (Sort Of)</h1>
    
    <div id="readability-page-1" class="page"><div id="__next"><article dir="ltr"><h2>Building a SQL-Powered Doom Clone in the Browser<span id="building-a-sql-powered-doom-clone-in-the-browser"></span><a href="#building-a-sql-powered-doom-clone-in-the-browser" aria-label="Permalink for this section"></a></h2>
<p>I had this slightly crazy idea: Could I ditch most of the conventional JavaScript game loop and rendering logic and build a 3D game engine where <strong>SQL queries</strong> did the heavy lifting? Naturally, I decided to try building a primitive, text-based Doom clone to see how far I could push it using <strong>DuckDB-WASM</strong>.</p>
<p><img alt="A screenshot of the text-based Doom clone, showing the 3D view and minimap" loading="lazy" width="922" height="536" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fduckdb-doom.5f9e25b8.png&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fduckdb-doom.5f9e25b8.png&amp;w=1920&amp;q=75 2x" src="https://www.hey.earth/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fduckdb-doom.5f9e25b8.png&amp;w=1920&amp;q=75"/></p>
<p>Spoiler: It <em>kind of</em> works, it was often painful, but I learned a ton about the surprising power (and quirks) of running an analytical database engine in the browser for tasks it was definitely not designed for.</p>
<h2>The Setup: SQL Isn&#39;t Just for <code dir="ltr">SELECT *</code> Anymore<span id="the-setup-sql-isnt-just-for-select--anymore"></span><a href="#the-setup-sql-isnt-just-for-select--anymore" aria-label="Permalink for this section"></a></h2>
<p>Forget managing game state in JavaScript objects or drawing pixels with Canvas/WebGL. My approach looked like this:</p>
<ol>
<li>
<p><strong>The Database is the World:</strong> The 16x16 map, player coordinates (<code dir="ltr">x</code>, <code dir="ltr">y</code>, <code dir="ltr">dir</code>), enemy/bullet positions, game settings – everything lives in DuckDB tables, right there in the browser tab.</p>

</li>
<li>
<p><strong>SQL Dictates Reality:</strong></p>
<ul>
<li>Want to move forward? <code dir="ltr">UPDATE player SET x = x + COS(dir)*step, y = y + SIN(dir)*step;</code></li>
<li>Bullet hits a wall? <code dir="ltr">DELETE FROM bullets WHERE EXISTS (SELECT 1 FROM map WHERE ...)</code></li>
<li>Enemy fragged? A <code dir="ltr">JOIN</code> between <code dir="ltr">bullets</code> and <code dir="ltr">enemies</code> followed by <code dir="ltr">DELETE</code> statements.</li>
</ul>

</li>
<li>
<p><strong>The Renderer is a SQL <code dir="ltr">VIEW</code>:</strong> This is where it gets wild. I defined a SQL <code dir="ltr">VIEW</code> named <code dir="ltr">render_3d_frame</code> that actually performs raycasting and renders the 3D scene. This beast uses recursive CTEs to cast rays for each screen column, calculates wall distances (with fish-eye correction!), determines the height of the wall slice for that column, and then uses <code dir="ltr">string_agg</code> to stitch together the characters (<code dir="ltr">&#39; &#39;</code>, <code dir="ltr">.</code>, <code dir="ltr">█</code>, <code dir="ltr">▓</code>, <code dir="ltr">▒</code>, <code dir="ltr">░</code>) for each row of the final text frame.</p>
<p>Here&#39;s the core of the raycasting algorithm in SQL:</p>

<p>Yes, SQL is calculating perspective and drawing characters. DuckDB&#39;s recursive CTE capabilities are unexpectedly powerful for this kind of work.</p>
</li>
<li>
<p><strong>JavaScript Glues It Together (and Handles Sprites):</strong> My JS code became the orchestrator. It handles keyboard input, runs the <code dir="ltr">setInterval</code> game loop, calls the SQL view to get the background frame, <em>then</em> fetches entity (bullet/enemy) positions and pre-calculated wall distances (from <em>another</em> SQL view!). It performs a quick Z-buffer check in JS to see if a sprite is closer than the wall at its projected screen column, draws it onto the background frame if it is, and finally outputs the resulting text onto a <code dir="ltr">&lt;pre&gt;</code> tag.</p>

</li>
</ol>
<p>Essentially, I took DuckDB-WASM – designed for fast analytics – and coerced it into acting like a state machine and a rudimentary rendering pipeline.</p>
<h2>The Gauntlet: My Battles with Bugs, Binders, and Browsers<span id="the-gauntlet-my-battles-with-bugs-binders-and-browsers"></span><a href="#the-gauntlet-my-battles-with-bugs-binders-and-browsers" aria-label="Permalink for this section"></a></h2>
<p>This wasn&#39;t exactly a smooth ride. Here&#39;s a log of some of the more... memorable... challenges and the fixes that eventually worked:</p>
<h3>1. The Initial Roadblock: DuckDB-WASM Just Wouldn&#39;t Load (404s)<span id="1-the-initial-roadblock-duckdb-wasm-just-wouldnt-load-404s"></span><a href="#1-the-initial-roadblock-duckdb-wasm-just-wouldnt-load-404s" aria-label="Permalink for this section"></a></h3>
<ul>
<li><strong>Pain Point:</strong> My first attempts using standard CDN links for the worker script just flat-out failed with <code dir="ltr">net::ERR_ABORTED 404</code>. Debugging WASM loading issues in the browser isn&#39;t always intuitive.</li>
<li><strong>The Fix:</strong> Digging into the DuckDB-WASM docs revealed the more robust initialization pattern: using their helper functions (<code dir="ltr">getJsDelivrBundles</code>) or explicitly selecting a bundle (<code dir="ltr">mvp</code> for max compatibility), creating the worker via <code dir="ltr">URL.createObjectURL(new Blob(...))</code>, and using the <code dir="ltr">+esm</code> CDN endpoint for the main module import.</li>
</ul>

<p>The lesson: When working with WASM libraries, always follow the recommended initialization patterns from the library authors.</p>
<h3>2. SQL Dialect Gotchas: <code dir="ltr">AUTOINCREMENT</code> vs. <code dir="ltr">SEQUENCE</code><span id="2-sql-dialect-gotchas-autoincrement-vs-sequence"></span><a href="#2-sql-dialect-gotchas-autoincrement-vs-sequence" aria-label="Permalink for this section"></a></h3>
<ul>
<li><strong>Pain Point:</strong> Muscle memory from SQLite/MySQL led me to use <code dir="ltr">AUTOINCREMENT</code> for the <code dir="ltr">bullets</code> table ID. DuckDB promptly slapped me with a <code dir="ltr">Parser Error: syntax error at or near &#34;AUTOINCREMENT&#34;</code>.</li>
<li><strong>The Fix:</strong> Remembering that DuckDB adheres more closely to standard SQL sequences. This meant <code dir="ltr">CREATE SEQUENCE my_seq;</code> and then <code dir="ltr">CREATE TABLE ... (id INTEGER PRIMARY KEY DEFAULT nextval(&#39;my_seq&#39;), ...)</code>.</li>
</ul>

<p>This highlights an important point about DuckDB: it&#39;s not just SQLite in the browser. It has its own SQL dialect with nuances from PostgreSQL and standard SQL.</p>
<h3>3. Fighting the Query Planner (Binder Errors &amp; Table Functions)<span id="3-fighting-the-query-planner-binder-errors--table-functions"></span><a href="#3-fighting-the-query-planner-binder-errors--table-functions" aria-label="Permalink for this section"></a></h3>
<ul>
<li>
<p><strong>Pain Point:</strong> This one drove me nuts for a while. I tried using <code dir="ltr">generate_series(0, settings.view_w - 1)</code> inside my rendering <code dir="ltr">VIEW</code>. The binder freaked out with errors like <code dir="ltr">Table function cannot contain subqueries</code> and even <code dir="ltr">Conversion Error: Could not convert string &#39;s.view_w&#39; to INT32</code>.</p>
</li>
<li>
<p><strong>The Fix:</strong> I had to restructure the view logic significantly. Instead of generating the exact range needed, I generated a <em>fixed, oversized</em> range (like 0-255) first, then added another CTE layer to <em>filter</em> that oversized range using the actual <code dir="ltr">view_w</code> from the settings CTE.</p>
</li>
</ul>

<p>I also initially forgot to alias the output of <code dir="ltr">generate_series</code>, leading to <code dir="ltr">Referenced column &#34;value&#34; not found</code> errors. Fixed with <code dir="ltr">generate_series(...) AS gs(col)</code>.</p>
<p>This approach satisfied the query planner, even though it&#39;s less elegant. It taught me that SQL query planners have strict rules about how and when references can be resolved, especially with table-generating functions.</p>
<h3>4. The Dreaded <code dir="ltr">async</code>/<code dir="ltr">setInterval</code> Race Condition<span id="4-the-dreaded-asyncsetinterval-race-condition"></span><a href="#4-the-dreaded-asyncsetinterval-race-condition" aria-label="Permalink for this section"></a></h3>
<ul>
<li>
<p><strong>Pain Point:</strong> My game loop was simple: <code dir="ltr">setInterval(async () =&gt; { await tick(); await render(); }, 150)</code>. But because <code dir="ltr">tick()</code> and <code dir="ltr">render()</code> involved <code dir="ltr">async</code> database calls, sometimes a new interval would fire before the previous one finished. This was most obvious with the temporary <code dir="ltr">collisions</code> table used for bullet hits – I&#39;d get rapid-fire &#34;table <code dir="ltr">collisions</code> does not exist!&#34; followed by &#34;table <code dir="ltr">collisions</code> already exists!&#34; errors.</p>
</li>
<li>
<p><strong>The Fix:</strong> A classic solution: a simple boolean lock (<code dir="ltr">isProcessingTick</code>). The interval callback now checks this flag; if true, it bails immediately. If false, it sets the flag, runs the async work in a <code dir="ltr">try...finally</code>, and clears the flag in the <code dir="ltr">finally</code> block, ensuring it&#39;s always released.</p>
</li>
</ul>

<p>This was a classic reminder that asynchronous timing with recurring events needs careful handling, especially when database operations are involved.</p>
<h3>5. Sprites: Beyond the SQL Background (Z-Buffer Logic)<span id="5-sprites-beyond-the-sql-background-z-buffer-logic"></span><a href="#5-sprites-beyond-the-sql-background-z-buffer-logic" aria-label="Permalink for this section"></a></h3>
<ul>
<li>
<p><strong>Pain Point:</strong> The SQL view rendered walls/floor/ceiling beautifully (well, beautifully for text mode). But enemies and bullets were just data. Drawing them required knowing <em>if they were hidden by a wall</em>.</p>
</li>
<li>
<p><strong>The Fix:</strong> A hybrid approach combining SQL and JavaScript. I created <em>another</em> SQL view (<code dir="ltr">column_distances</code>) specifically to output the distance to the nearest wall for each screen column:</p>
</li>
</ul>

<p>Then, in my JavaScript <code dir="ltr">render3d</code> function, I performed the Z-buffer check by comparing entity depth to wall depth for each screen column.</p>
<h2>Performance and Results<span id="performance-and-results"></span><a href="#performance-and-results" aria-label="Permalink for this section"></a></h2>
<p>How did it actually run? Surprisingly well, considering what we&#39;re asking SQL to do. On a modern laptop, I get about 6-7 FPS with the 150ms game loop interval. The most expensive operation is the SQL raycasting view, which takes about 80-100ms to execute. The sprite rendering in JavaScript is quite fast in comparison.</p>
<p><img alt="A GIF showing gameplay with player movement and shooting" loading="lazy" width="870" height="508" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fduckdb-doom.3aba91f6.gif&amp;w=1080&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fduckdb-doom.3aba91f6.gif&amp;w=1920&amp;q=75 2x" src="https://www.hey.earth/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fduckdb-doom.3aba91f6.gif&amp;w=1920&amp;q=75"/></p>
<p>Here&#39;s what the game looks like in action. The main view shows the 3D perspective with text-based graphics, while the smaller box in the corner shows a top-down minimap. You can see how the walls are rendered with different characters based on distance, giving a primitive 3D effect.</p>
<p>The movement feels responsive enough, and the SQL-based collision detection works well. There&#39;s something strangely satisfying about mowing down enemies with SQL <code dir="ltr">DELETE</code> statements.</p>
<h2>Pushing SQL to Its Limits: What I Learned<span id="pushing-sql-to-its-limits-what-i-learned"></span><a href="#pushing-sql-to-its-limits-what-i-learned" aria-label="Permalink for this section"></a></h2>
<p>This experiment taught me several important lessons about both SQL and browser-based development:</p>
<ol>
<li>
<p><strong>SQL is surprisingly powerful for non-traditional use cases.</strong> It&#39;s not just for data retrieval. The combination of recursive CTEs, window functions, and aggregate functions makes complex algorithms possible.</p>
</li>
<li>
<p><strong>DuckDB-WASM is impressively performant.</strong> Running an analytical database engine in the browser that can handle complex recursive queries 6-7 times per second is no small feat.</p>
</li>
<li>
<p><strong>The boundaries between languages can be blurred.</strong> This project combined SQL for game state and rendering fundamentals, with JavaScript for orchestration and sprite handling. Neither could have done the job alone.</p>
</li>
<li>
<p><strong>Debugging across language boundaries is challenging.</strong> When something went wrong, it wasn&#39;t always clear if the issue was in the JavaScript, the SQL, or at the interface between them. I added extensive logging to track the flow between components.</p>
</li>
<li>
<p><strong>Query planning is a complex art.</strong> I had to work around many limitations of how SQL planners work, especially around table function evaluation and CTEs.</p>
</li>
</ol>
<h2>Would I Recommend This Approach?<span id="would-i-recommend-this-approach"></span><a href="#would-i-recommend-this-approach" aria-label="Permalink for this section"></a></h2>
<p>For a production game? Absolutely not. It&#39;s a fun hack, but there are much better tools for game development.</p>
<p>But as a learning exercise? 100% yes. This project forced me to think deeply about:</p>
<ul>
<li>SQL query optimization and execution planning</li>
<li>Raycasting algorithms and 3D projection</li>
<li>Asynchronous JavaScript patterns</li>
<li>The capabilities and limitations of WASM in the browser</li>
</ul>
<h2>Try It Yourself!<span id="try-it-yourself"></span><a href="#try-it-yourself" aria-label="Permalink for this section"></a></h2>
<p>If you want to experiment with this SQL-powered monstrosity yourself, I&#39;ve put the <a target="_blank" rel="noreferrer" href="https://github.com/patricktrainer/duckdb-doom">full source code on GitHub<span> (opens in a new tab)</span></a>. It&#39;s about 500 lines of code total, with roughly half being SQL and half JavaScript.</p>
<p>I&#39;d love to see how far others can push this concept. Could you add textures? Implement a more complex game world? Add enemies that move and shoot back? The SQL rabbit hole goes deep!</p>
<h2>What&#39;s Next?<span id="whats-next"></span><a href="#whats-next" aria-label="Permalink for this section"></a></h2>
<p>This experiment has me wondering what other unconventional uses might exist for DuckDB-WASM in the browser. Physics simulations? Path finding algorithms? Full-text search engines?</p>
<p>Sometimes the most interesting projects come from using tools in ways they were never intended to be used. What weird DuckDB-WASM experiment would you like to see next?</p><small>not made by a 🤖</small></article><!--$--><!--/$--></div></div>
  </body>
</html>
