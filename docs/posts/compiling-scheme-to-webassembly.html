<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2026/compiling-scheme-to-webassembly/">Original</a>
    <h1>Compiling Scheme to WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>One of my oldest open-source projects - <a href="https://github.com/eliben/bobscheme">Bob</a>
- has <a href="https://eli.thegreenplace.net/2010/11/06/bob-a-scheme-interpreter-compiler-and-vm-in-python">celebrated 15 a couple of months ago</a>.
Bob is a suite of implementations of the Scheme programming language in Python,
including an interpreter, a compiler and a VM. Back then I was doing some hacking
on CPython internals and was very curious about how CPython-like bytecode VMs
work; Bob was an experiment to find out, by implementing one from scratch for
R5RS Scheme.</p>
<p>Several months later I <a href="https://eli.thegreenplace.net/2011/04/09/a-c-vm-added-to-bob">added a C++ VM to Bob</a>,
as an exercise to learn how such VMs are implemented in a low-level language
without all the runtime support Python provides; most importantly, without the
built-in GC. The C++ VM in Bob implements its own mark-and-sweep GC.</p>
<p>After many quiet years (with just a sprinkling of cosmetic changes, porting to
GitHub, updates to Python 3, etc), I felt the itch to work on Bob again just
before the holidays. Specifically, I decided to add another compiler to the
suite - this one from Scheme directly to WebAssembly.</p>
<p>The goals of this effort were two-fold:</p>
<ol>
<li>Experiment with lowering a real, high-level language like Scheme to
WebAssembly. Experiments like the recent <a href="https://eli.thegreenplace.net/2025/revisiting-lets-build-a-compiler/">Let&#39;s Build a Compiler</a>
compile toy languages that are at the C level (no runtime). Scheme has built-in
data structures, lexical closures, garbage collection, etc. It&#39;s much more challenging.</li>
<li>Get some hands-on experience with the WASM GC extension <a href="#footnote-1" id="footnote-reference-1">[1]</a>. I have several
samples of using WASM GC in the <a href="https://github.com/eliben/wasm-wat-samples">wasm-wat-samples repository</a>,
but I really wanted to try it for something &#34;real&#34;.</li>
</ol>
<p>Well, it&#39;s done now; here&#39;s an updated schematic of the Bob project:</p>
<p><img alt="Bob project diagram with all the components it includes" src="https://eli.thegreenplace.net/images/2026/bob_toplevel.png"/></p><p>The new part is the rightmost vertical path. A <a href="https://github.com/eliben/bobscheme/blob/main/bob/wasmcompiler.py">WasmCompiler</a>
class lowers parsed Scheme expressions all the way down to WebAssembly text,
which can then be compiled to a binary and executed using standard WASM tools <a href="#footnote-2" id="footnote-reference-2">[2]</a>.</p>
<div id="highlights">
<h2>Highlights</h2>
<p>The most interesting aspect of this project was working with WASM GC to
represent Scheme objects. As long as we properly box/wrap all values in
<tt>ref</tt>s, the underlying WASM execution environment will take care of the
memory management.</p>
<p>For Bob, here&#39;s how some key Scheme objects are represented:</p>
<div><pre><span></span>;; PAIR holds the car and cdr of a cons cell.
(type $PAIR (struct (field (mut (ref null eq))) (field (mut (ref null eq)))))

;; BOOL represents a Scheme boolean. zero -&gt; false, nonzero -&gt; true.
(type $BOOL (struct (field i32)))

;; SYMBOL represents a Scheme symbol. It holds an offset in linear memory
;; and the length of the symbol name.
(type $SYMBOL (struct (field i32) (field i32)))
</pre></div>
<p><tt>$PAIR</tt> is of particular interest, as it may contain arbitrary objects in
its fields; <tt>(ref null eq)</tt> means &#34;a nullable reference to something that
has identity&#34;. <tt>ref.test</tt> can be used to check - for a given
reference - the run-time type of the value it refers to.</p>
<p>You may wonder - what about numeric values? Here WASM has a trick - the <tt>i31</tt>
type can be used to represent a reference to an integer, but without
actually boxing it (one bit is used to distinguish such an object from a
real reference). So we don&#39;t need a separate type to hold references to numbers.</p>
<p>Also, the <tt>$SYMBOL</tt> type looks unusual - how is it represented with two
numbers? The key to the mystery is that WASM has no built-in support for
strings; they should be implemented manually using offsets to linear memory.
The Bob WASM compiler emits the string values of all symbols encountered into
linear memory, keeping track of the offset and length of each one; these are
the two numbers placed in <tt>$SYMBOL</tt>. This also allows to fairly easily
implement the string interning feature of Scheme; multiple instances of the
same symbol will only be allocated once.</p>
<p>Consider this trivial Scheme snippet:</p>

<p>The compiler emits the symbols &#34;foo&#34; and &#34;bar&#34; into linear memory as follows <a href="#footnote-3" id="footnote-reference-3">[3]</a>:</p>
<div><pre><span></span>(data (i32.const 2048) &#34;foo&#34;)
(data (i32.const 2051) &#34;bar&#34;)
</pre></div>
<p>And looking for one of these addresses in the rest of the emitted code, we&#39;ll
find:</p>
<div><pre><span></span>(struct.new $SYMBOL (i32.const 2051) (i32.const 3))
</pre></div>
<p>As part of the code for constructing the constant <tt>cons</tt> list representing the
argument to <tt>write</tt>; address 2051 and length 3: this is the symbol <tt>bar</tt>.</p>
<p>Speaking of <tt>write</tt>, implementing this builtin was quite interesting. For
compatibility with the other Bob implementations in my repository, <tt>write</tt>
needs to be able to print recursive representations of arbitrary Scheme values,
including lists, symbols, etc.</p>
<p>Initially I was reluctant to implement all of this functionality by hand in
WASM text, but all alternatives ran into challenges:</p>
<ol>
<li>Deferring this to the host is difficult because the host environment has
no access to WASM GC references - they are completely opaque.</li>
<li>Implementing it in another language (maybe C?) and lowering to WASM is also
challenging for a similar reason - the other language is unlikely to have
a good representation of WASM GC objects.</li>
</ol>
<p>So I bit the bullet and - with some AI help for the tedious parts - just wrote
an implementation of <tt>write</tt> directly in WASM text; it wasn&#39;t really that
bad. I import only two functions from the host:</p>
<div><pre><span></span>(import &#34;env&#34; &#34;write_char&#34; (func $write_char (param i32)))
(import &#34;env&#34; &#34;write_i32&#34; (func $write_i32 (param i32)))
</pre></div>
<p>Though emitting integers <a href="https://eli.thegreenplace.net/2023/itoa-integer-to-string-in-webassembly/">directly from WASM isn&#39;t hard</a>,
I figured this project already has enough code and some host help here would
be welcome. For all the rest, only the lowest level <tt>write_char</tt> is used.
For example, here&#39;s how booleans are emitted in the canonical Scheme notation
(<tt>#t</tt> and <tt>#f</tt>):</p>
<div><pre><span></span>(func $emit_bool (param $b (ref $BOOL))
    (call $emit (i32.const 35)) ;; &#39;#&#39;
    (if (i32.eqz (struct.get $BOOL 0 (local.get $b)))
        (then (call $emit (i32.const 102))) ;; &#39;f&#39;
        (else (call $emit (i32.const 116))) ;; &#39;t&#39;
    )
)
</pre></div>
</div>
<div id="conclusion">
<h2>Conclusion</h2>
<p>This was a really fun project, and I learned quite a bit about realistic code
emission to WASM. Feel free to check out the source code of <a href="https://github.com/eliben/bobscheme/blob/main/bob/wasmcompiler.py">WasmCompiler</a> - it&#39;s
very well documented. While it&#39;s a bit over 1000 LOC in total <a href="#footnote-4" id="footnote-reference-4">[4]</a>, more than half
of that is actually WASM text snippets that implement the builtin types and
functions needed by a basic Scheme implementation.</p>
<hr/>




</div>

            </div></div>
  </body>
</html>
