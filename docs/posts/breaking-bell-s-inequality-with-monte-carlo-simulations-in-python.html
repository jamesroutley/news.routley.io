<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bytepawn.com/quantum-entanglement-bell-inequality-python.html">Original</a>
    <h1>Breaking Bell&#39;s Inequality with Monte Carlo Simulations in Python</h1>
    
    <div id="readability-page-1" class="page"><div>
    <h2>Introduction</h2>
<p>In this article, we explore a game that challenges the very foundations of classical physics and introduces us to the strange world of quantum mechanics. The game involves three players — Alice, Bob, and Victor — who perform a series of experiments to test a fundamental principle known as Bell&#39;s theorem. By carefully selecting their measurement devices and analyzing the outcomes, Alice and Bob aim to determine whether the physical world can be explained by deterministic local hidden variables. Through Monte Carlo Python simulations, we will see how classical strategies adhere to Bell&#39;s inequality, and how to break it using non-local action-at-a-distance and entangled qubits. <a href="https://github.com/mtrencseni/playground/blob/master/Bell.ipynb">The code is up on Github.</a></p>
<h2>Bell game</h2>
<p>Imagine a game — let&#39;s call it the Bell game — involving three players: Alice, Bob, and Victor. Alice and Bob are situated in two distant locations, far enough apart that no signal — not even light — could travel between them in the time it takes to perform a single round of the game. Their colleague, Victor, prepares a pair of particles, the left particle and the right particle, and sends them to Alice and Bob, respectively. The particles may be classical objects like coins, dice, apples, or, bits recorded on digital storage, or, intriguingly, quantum particles such as entangled photons, which can be modeled as qubits. Before the game, Victor tells Alice and Bob what kind of particles he will send, and Alice and Bob can agree between each other what measurement devices to use. Once the game starts, the choice of measurement devices is fixed.</p>
<p>Upon receiving their respective particles, Alice and Bob each perform one of two possible measurements. Alice chooses between two measurement devices, which we will call $A_H$ (for Heads) and $A_T$ (for Tails). Similarly, Bob also chooses between two measurement devices, $B_H$ and $B_T$. Both Alice and Bob flip a fair coin to pick their measurement devices, which means the 4 cases $HH$, $HT$, $TH$ and $TT$ are all equally like at $p=1/4$. Each measurement results in a binary outcome: either $+1$ or $-1$.</p>
<p>The key assumption underlying the classical view of this experiment is that the properties of the particles — the hidden variables — determine the outcomes of these measurements. If Alice measured $A_H$ and obtains the result $+1$, it is assumed that the particle she received already carried a hidden property corresponding to $+1$ for the measurement $A_H$. Likewise, if Bob measures $B_T$ and gets $-1$, then his particle must have had a hidden property corresponding to -1 for $B_T$.</p>
<p>At the end of each round, both Alice and Bob send back to Victor two pieces of information each: whether they flipped $H$ or $T$, and what their measurement outcomes was, $+1$ or $-1$. Victor records 4 pieces of binary information: (Alice flipped $H$ or $T$, Alice measured $+1$ or $-1$, Bob flipped $H$ or $T$, Bob measured $+1$ or $-1$). The game is played repeatedly over a large number $N$ of rounds, and Victor ends up with an $N$ long list of records. Per the above consideration, each combination $HH$, $HT$, $TH$ and $TT$ will occur about $N/4$ times.</p>
<p>The full game is depicted below:</p>
<p><img src="https://bytepawn.com/images/bell-game.png" alt="Bell game"/></p>
<h2>Bell statistic</h2>
<p>The goal of the game is to compute a special mathematical quantity called the <strong>Bell statistic</strong>, which quantifies the correlation between the measurement outcomes of Alice and Bob. This statistic is calculated over a large $N$ number of rounds, as follows:</p>
<p>$ S = \langle A_H B_H \rangle + \langle A_H B_T \rangle + \langle A_T B_H \rangle - \langle A_T B_T \rangle $</p>
<p>Here, each term represents a product of Alice&#39;s and Bob&#39;s measurement outcomes, averaged over many rounds of the game. For example, $A_H B_H$ is the product of Alice&#39;s outcome when she measures $A_H$ and Bob&#39;s outcome when he measures $B_H$. The average here is taken over the roughly $N/4$ times when Alice and Bob both flipped H. This can be made more explicit by indexing the averaging operator $\langle \cdot \rangle$ by the cases it is indexing:</p>
<p>$ S = \langle A_H B_H \rangle_{HH} + \langle A_H B_T \rangle_{HT} + \langle A_T B_H \rangle_{TH} - \langle A_T B_T \rangle_{TT} $</p>
<p>For large $N$, the 4 cases $HH$, $HT$, $TH$ and $TT$ will occur roughly at the same frequency $N/4$, so each of the term counts will be abpit $N/4$. This means the sum can be rewritten into an overall average:</p>
<p>$ S = 4 \cdot \langle A_H B_H + A_H B_T + A_T B_H - A_T B_T \rangle_{all} $</p>
<p>Now, let&#39;s establish a crucial constraint: If the world is governed by <strong>deterministic local hidden variables</strong>, which assume that the particles’ properties are fully determined by hidden variables existing prior to and independent of measurement, then the Bell statistic $S$ is bound to always lie within a certain range. Specifically, if Alice and Bob perform many rounds of this game and compute the $S$ over all trials, the absolute value of this average cannot exceed 2:</p>
<p>$ S \leq 2 $</p>
<p>This is known as a <strong>Bell inequality</strong>. It captures the essential limitation imposed by any theory based on local hidden variables — theories that adhere to classical notions of determinism (no random chance in the measurement apparatus), locality (no faster-than-light influences) and realism (pre-existing properties).</p>
<h2>Relating the game to local hidden variables</h2>
<p>Let&#39;s explore why this inequality holds for any deterministic local hidden variable theory. The central idea is that if the measurement outcomes are predetermined by hidden variables, then Alice’s and Bob’s choices of measurements and their outcomes cannot affect each other instantaneously. Each particle, upon leaving Victor, carries its own set of hidden variables that dictate the outcomes of Alice&#39;s and Bob&#39;s measurements.</p>
<p>Consider the combination:</p>
<p>$ a_H b_H + a_H b_T + a_T b_H - a_T b_T $</p>
<p>where $a_H$, $a_T$, $b_H$, and $b_T$ are the predetermined hidden values (either $+1$ or $-1$) that dictate the outcomes for Alice’s and Bob’s measurements. We can simply look through all $ 2^{4} = 16 $ combinations of assigning +1 and -1 to these variables, and see that in all cases, the Bell sum above is always $+2$ or $-2$:</p>
<div><pre><span></span><code><span>def</span> <span>bell_sum</span><span>(</span><span>A_H</span><span>,</span> <span>A_T</span><span>,</span> <span>B_H</span><span>,</span> <span>B_T</span><span>):</span>
    <span>return</span> <span>A_H</span><span>*</span><span>B_H</span> <span>+</span> <span>A_H</span><span>*</span><span>B_T</span> <span>+</span> <span>A_T</span><span>*</span><span>B_H</span> <span>-</span> <span>A_T</span><span>*</span><span>B_T</span>

<span>print</span><span>(</span><span>&#39;A_H  A_T  B_H  B_T    Bell-sum&#39;</span><span>)</span>
<span>print</span><span>(</span><span>&#39;------------------------------&#39;</span><span>)</span>
<span>values</span> <span>=</span> <span>[</span><span>-</span><span>1</span><span>,</span> <span>+</span><span>1</span><span>]</span>
<span>for</span> <span>A_H</span><span>,</span> <span>A_T</span><span>,</span> <span>B_H</span><span>,</span> <span>B_T</span> <span>in</span> <span>product</span><span>(</span><span>values</span><span>,</span> <span>values</span><span>,</span> <span>values</span><span>,</span> <span>values</span><span>):</span>
    <span>print</span><span>(</span><span>f</span><span>&#39; </span><span>{</span><span>A_H</span><span>:</span><span>2</span><span>}</span><span>   </span><span>{</span><span>A_T</span><span>:</span><span>2</span><span>}</span><span>   </span><span>{</span><span>B_H</span><span>:</span><span>2</span><span>}</span><span>   </span><span>{</span><span>B_T</span><span>:</span><span>2</span><span>}</span><span>    -&gt;    </span><span>{</span><span>bell_sum</span><span>(</span><span>A_H</span><span>,</span><span> </span><span>A_T</span><span>,</span><span> </span><span>B_H</span><span>,</span><span> </span><span>B_T</span><span>)</span><span>:</span><span>2</span><span>}</span><span>&#39;</span><span>)</span>
</code></pre></div>

<p>Prints:</p>
<div><pre><span></span><code><span>A_H  A_T  B_H  B_T    Bell-sum</span>
<span>------------------------------</span>
 -1   -1   -1   -1    -&gt;     2
 -1   -1   -1    1    -&gt;     2
 -1   -1    1   -1    -&gt;    -2
 -1   -1    1    1    -&gt;    -2
 -1    1   -1   -1    -&gt;     2
 -1    1   -1    1    -&gt;    -2
 -1    1    1   -1    -&gt;     2
 -1    1    1    1    -&gt;    -2
  1   -1   -1   -1    -&gt;    -2
  1   -1   -1    1    -&gt;     2
  1   -1    1   -1    -&gt;    -2
  1   -1    1    1    -&gt;     2
  1    1   -1   -1    -&gt;    -2
  1    1   -1    1    -&gt;    -2
  1    1    1   -1    -&gt;     2
  1    1    1    1    -&gt;     2
</code></pre></div>

<p>Note that the Bell sum above is not the same thing as the Bell statistic, which can take on values between $-2$ and $2$.</p>
<p>As a result, if Victor prepares many such pairs and the game is repeated over numerous trials, the average value of this combination will always fall within the range $[-2, +2]$. No matter how Alice and Bob choose their measurements, or what hidden variables Victor might encode in the particles, the Bell inequality holds if local hidden variables govern the experiment.</p>
<h2>Simulating the Bell game in Python</h2>
<p>To understand Bell&#39;s theorem through simulation, let&#39;s set up a Python program that models the game between Alice, Bob, and Victor. In this game, Victor prepares a composite system, splits it into two parts (<code>left</code> and <code>right</code> in the code), and sends one part to Alice and the other to Bob. Alice and Bob then perform their measurements $H$ or $T$ based on a coin flip, and we compute the Bell statistic to see if they can violate the Bell inequality:</p>
<div><pre><span></span><code><span>def</span> <span>bell_experiment</span><span>(</span><span>N</span><span>):</span>
    <span>total</span> <span>=</span> <span>0</span>
    <span>for</span> <span>_</span> <span>in</span> <span>range</span><span>(</span><span>N</span><span>):</span>
        <span># Generate a composite object and split it</span>
        <span>composite</span> <span>=</span> <span>generate_composite</span><span>()</span>
        <span>left</span><span>,</span> <span>right</span> <span>=</span> <span>split</span><span>(</span><span>composite</span><span>)</span>

        <span># Alice&#39;s coin flip determines which measurement device she uses</span>
        <span>A_which</span> <span>=</span> <span>flip_coin</span><span>()</span>
        <span>measure_A</span> <span>=</span> <span>measure_A_H</span> <span>if</span> <span>A_which</span> <span>==</span> <span>0</span> <span>else</span> <span>measure_A_T</span>
        <span>A</span> <span>=</span> <span>measure_A</span><span>(</span><span>left</span><span>)</span>

        <span># Bob&#39;s coin flip determines which measurement device he uses</span>
        <span>B_which</span> <span>=</span> <span>flip_coin</span><span>()</span>
        <span>measure_B</span> <span>=</span> <span>measure_B_H</span> <span>if</span> <span>B_which</span> <span>==</span> <span>0</span> <span>else</span> <span>measure_B_T</span>
        <span>B</span> <span>=</span> <span>measure_B</span><span>(</span><span>right</span><span>)</span>

        <span># Compute the contribution to the Bell statistic</span>
        <span>multiplier</span> <span>=</span> <span>-</span><span>1</span> <span>if</span> <span>A_which</span> <span>==</span> <span>1</span> <span>and</span> <span>B_which</span> <span>==</span> <span>1</span> <span>else</span> <span>1</span>
        <span>total</span> <span>+=</span> <span>multiplier</span> <span>*</span> <span>A</span> <span>*</span> <span>B</span>

    <span># Calculate the Bell statistic and print the result</span>
    <span>bell_statistic</span> <span>=</span> <span>4</span> <span>*</span> <span>float</span><span>(</span><span>total</span><span>)</span> <span>/</span> <span>N</span>
    <span>print</span><span>(</span><span>f</span><span>&#39;Bell Statistic: </span><span>{</span><span>bell_statistic</span><span>:</span><span>.3</span><span>}</span><span>&#39;</span><span>)</span>
</code></pre></div>

<p>To make this work, we have to define the functions <code>generate_composite()</code>, which returns something that van then be split into two parts, <code>left</code> and <code>right</code>, using the <code>split()</code> function. Additionally, we need 4 measurement functions: <code>measure_A_H(), measure_A_T(), measure_B_H(), measure_A_T()</code>. Remember that the measurement functions have to return $+1$ or $-1$. To clarify the setup of the game, it is assumed that both Alice and Bob know what function Victor is using to <code>generate_composite()</code> and <code>split()</code>, and can cooperate with the other to pick what measurement function they use to attempt to break the Bell inequality.</p>
<p>In the simplest case, we can have the measurement functions return a fixed value, like:</p>
<div><pre><span></span><code><span>def</span> <span>measure_A_H</span><span>(</span><span>_</span><span>):</span>
    <span>return</span> <span>1</span>

<span>def</span> <span>measure_A_T</span><span>(</span><span>_</span><span>):</span>
    <span>return</span> <span>1</span>

<span>def</span> <span>measure_B_H</span><span>(</span><span>_</span><span>):</span>
    <span>return</span> <span>1</span>

<span>def</span> <span>measure_B_T</span><span>(</span><span>_</span><span>):</span>
    <span>return</span> <span>1</span>
</code></pre></div>

<p>In this trivial case, the particles aren&#39;t even needed, we can just use a dummy implementation, like:</p>
<div><pre><span></span><code><span>def</span> <span>generate_composite</span><span>():</span>
    <span>return</span> <span>None</span><span>,</span> <span>None</span>

<span>def</span> <span>split</span><span>(</span><span>composite</span><span>):</span>
    <span>left</span> <span>=</span> <span>composite</span><span>[</span><span>0</span><span>]</span>
    <span>right</span> <span>=</span> <span>composite</span><span>[</span><span>1</span><span>]</span>
    <span>return</span> <span>left</span><span>,</span> <span>right</span>
</code></pre></div>

<p>We can run the simulation like:</p>
<div><pre><span></span><code><span>bell_experiment</span><span>(</span><span>N</span><span>=</span><span>1000</span><span>*</span><span>1000</span><span>)</span>
</code></pre></div>

<p>It will print <code>2.0</code>. The reader is free to try the other 16 combinations as well, and observe that they do not break the Bell inequality. How about if Victor rolls a dice, and sends the same dice to Alice and Bob?</p>
<div><pre><span></span><code><span>def</span> <span>generate_composite</span><span>():</span>
    <span>d</span> <span>=</span> <span>roll_dice</span><span>()</span>
    <span>composite</span> <span>=</span> <span>(</span><span>d</span><span>,</span> <span>d</span><span>)</span>
    <span>return</span> <span>composite</span>
</code></pre></div>

<p>Now Alice and Bob receive some random number between $1$ and $6$, and they know that the other also received the same.</p>
<p>Let&#39;s say Alice&#39;s $H$ function cuts the range in half, and her $T$ function checks for parity and Bob does the same:</p>
<div><pre><span></span><code><span>def</span> <span>measure_A_H</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>&lt;=</span> <span>3</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>result</span>

<span>def</span> <span>measure_A_T</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>result</span>

<span>measure_B_H</span> <span>=</span> <span>measure_A_H</span>
<span>measure_B_T</span> <span>=</span> <span>measure_A_T</span>
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>-0.665</code>. We can also try Bob doing the opposite:</p>
<div><pre><span></span><code>measure_B_H = measure_A_T
measure_B_T = measure_A_H
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>2.0</code>. These are just examples, the point is that in these cases Victor introduces randomness (in this example, by using <code>roll_dice()</code>), Alice and Bob both get the same thing, their measurement functions are deterministic (don&#39;t use randomness) and local (don&#39;t peek at what the other is doing), and they cannot break Bell inequality, however we change the code.</p>
<p>Let&#39;s see what happens if Victor also randomly changes what he sends to Alice and Bob. He rolls a dice, if its less than or equal to $4$, both Alice and Bob get the same result. But if it&#39;s 5 or 6, Alice gets the value, but for Bob he sends 5 or 6 based on a coin flip. So if Alice and Bob get a value less than or equal to $4$, they know the other has the same, but if they get 5 or 6, the other may have the other one. So the values are not always identical, but correlated. In code:</p>
<div><pre><span></span><code><span>def</span> <span>generate_composite</span><span>():</span>
    <span>d</span> <span>=</span> <span>roll_dice</span><span>()</span>
    <span>composite</span> <span>=</span> <span>(</span><span>d</span><span>,</span> <span>d</span> <span>if</span> <span>d</span> <span>&lt;=</span> <span>4</span> <span>else</span> <span>flip_coin</span><span>(</span><span>heads</span><span>=</span><span>5</span><span>,</span> <span>tails</span><span>=</span><span>6</span><span>))</span>
    <span>return</span> <span>composite</span>
</code></pre></div>

<p>Again, we can try various measurement functions for Alice and Bob, for example:</p>
<div><pre><span></span><code><span>def</span> <span>measure_A_H</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>&lt;=</span> <span>4</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>result</span>

<span>def</span> <span>measure_A_T</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>result</span>

<span>measure_B_H</span> <span>=</span> <span>measure_A_H</span>
<span>measure_B_T</span> <span>=</span> <span>measure_A_T</span>
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>0.33</code>. Switching Bob&#39;s functions prints <code>1.67</code>. As before, these are just examples, but they demonstate that Alice and Bob cannot break the Bell inequality.</p>
<h2>Random measurement functions</h2>
<p>One last thing we could try is introducing randomness into the measurement functions. In the cases above, they always took their portion of the composite Victor constructed (<code>left</code> or <code>right</code>), and the Python code was completely deterministic, a series of <code>if</code> statements. If we do this, we no longer <strong>deterministic</strong>, the first word in &#34;deterministic local hidden variable theory&#34;. But, even with randomness, Alice and Bob cannot break the Bell inequality. We can try this like:</p>
<div><pre><span></span><code><span>def</span> <span>generate_composite</span><span>():</span>
    <span>d</span> <span>=</span> <span>roll_dice</span><span>()</span>
    <span>composite</span> <span>=</span> <span>(</span><span>d</span><span>,</span> <span>d</span> <span>if</span> <span>d</span> <span>&lt;=</span> <span>4</span> <span>else</span> <span>flip_coin</span><span>(</span><span>heads</span><span>=</span><span>5</span><span>,</span> <span>tails</span><span>=</span><span>6</span><span>))</span>
    <span>return</span> <span>composite</span>

<span>def</span> <span>measure_A_H</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>&lt;=</span> <span>4</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>result</span>

<span>def</span> <span>measure_A_T</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>result</span>

<span>measure_B_H</span> <span>=</span> <span>measure_A_T</span>

<span>def</span> <span>measure_B_T</span><span>(</span><span>q</span><span>):</span>
    <span>result</span> <span>=</span> <span>flip_coin</span><span>(</span><span>heads</span><span>=</span><span>1</span><span>,</span> <span>tails</span><span>=-</span><span>1</span><span>)</span> <span># &lt;----------- randomness at Bob</span>
    <span>return</span> <span>result</span>
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>0.66</code>. We can try all sorts of other versions, but we won&#39;t be able to break the Bell inequality.</p>
<h2>Breaking the Bell inequality with non-local information</h2>
<p>So far it seems like our initial argument stands: we said that there are $16$ combinations of $+1$ and $-1$ outcomes for the measurement outcomes, and all are either $+2$ or $-2$, and so the average has to be between $+2$ and $-2$. The way to break it is to condition the measurement value of one of the players on the other&#39;s. For example, in our code, Bob&#39;s measurement functions will check whether Alice used $A_H$ or $A_T$, and what the measurement result was ($+1$ or $-1$), and conditions the return based on that. This means that in our simulation Bob&#39;s measurement accesses Alice&#39;s measurement, which, per our initial assumption is not possible since they are far apart (there is not enough time for light to arrive from one to the other per round). But, we can still simulate this seemingly non-physical scenario in Python code. First, we change the particle creation code, and simulate action-at-a-distance (like a &#34;worm hole&#34;), that allows the <code>left</code> and <code>right</code> particles to see each other:</p>
<div><pre><span></span><code><span>def</span> <span>generate_composite</span><span>():</span>
    <span>d</span> <span>=</span> <span>roll_dice</span><span>()</span>
    <span>composite</span> <span>=</span> <span>(</span><span>d</span><span>,</span> <span>d</span> <span>if</span> <span>d</span> <span>&lt;=</span> <span>4</span> <span>else</span> <span>flip_coin</span><span>(</span><span>heads</span><span>=</span><span>5</span><span>,</span> <span>tails</span><span>=</span><span>6</span><span>))</span>
    <span>return</span> <span>composite</span>

<span>def</span> <span>split</span><span>(</span><span>composite</span><span>):</span>
    <span>left</span>  <span>=</span> <span>{</span><span>&#39;value&#39;</span><span>:</span> <span>composite</span><span>[</span><span>0</span><span>]}</span>
    <span>right</span> <span>=</span> <span>{</span><span>&#39;value&#39;</span><span>:</span> <span>composite</span><span>[</span><span>1</span><span>]}</span>
    <span># we enable both left and right parts to peek at each other</span>
    <span># in physics, this is called action-at-a-distance</span>
    <span>left</span><span>[</span><span>&#39;other&#39;</span><span>]</span> <span>=</span> <span>right</span>
    <span>right</span><span>[</span><span>&#39;other&#39;</span><span>]</span> <span>=</span> <span>left</span>
    <span>return</span> <span>left</span><span>,</span> <span>right</span>
</code></pre></div>

<p>Let&#39;s have Alice use her usual measurement devices, but let&#39;s have the particle remember which measurement happened — this in itself does not break any of our assumptions. In code:</p>
<div><pre><span></span><code><span>def</span> <span>measure_A_H</span><span>(</span><span>q</span><span>):</span>
    <span># the particle remembers which measurement was performed and what the result was</span>
    <span># in itself, this is not cheating</span>
    <span>q</span><span>[</span><span>&#39;measure&#39;</span><span>]</span> <span>=</span> <span>&#39;H&#39;</span>
    <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span> <span>&lt;=</span> <span>4</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span>

<span>def</span> <span>measure_A_T</span><span>(</span><span>q</span><span>):</span>
    <span>q</span><span>[</span><span>&#39;measure&#39;</span><span>]</span> <span>=</span> <span>&#39;T&#39;</span>
    <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>1</span> <span>if</span> <span>q</span><span>[</span><span>&#39;value&#39;</span><span>]</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span> <span>else</span> <span>-</span><span>1</span>
    <span>return</span> <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span>
</code></pre></div>

<p>Bob&#39;s measurement apparatus will use action-at-a-distance and peek at what happened at Alice&#39;s side:</p>
<div><pre><span></span><code><span>def</span> <span>measure_B_H</span><span>(</span><span>q</span><span>):</span>
    <span># always return what Alice measured</span>
    <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>q</span><span>[</span><span>&#39;other&#39;</span><span>][</span><span>&#39;result&#39;</span><span>]</span>
    <span>return</span> <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span>

<span>def</span> <span>measure_B_T</span><span>(</span><span>q</span><span>):</span>
    <span># condition on which measurement Alice performced and use her result</span>
    <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>q</span><span>[</span><span>&#39;other&#39;</span><span>][</span><span>&#39;result&#39;</span><span>]</span> <span>if</span> <span>q</span><span>[</span><span>&#39;other&#39;</span><span>][</span><span>&#39;measure&#39;</span><span>]</span> <span>==</span> <span>&#39;H&#39;</span> <span>else</span> <span>-</span><span>1</span><span>*</span><span>q</span><span>[</span><span>&#39;other&#39;</span><span>][</span><span>&#39;result&#39;</span><span>]</span>
    <span>return</span> <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span>
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>4.0</code>. <strong>We broke the Bell inequality!</strong> </p>
<p>What happened here? Because $B_H$ always returns what Alice measured, these $ A B $ products will always be $+1$ in the Bell sum.
In $B_T$, if Alice measured $A_H$, we return the same, again in this case the $ A B $ products will be $+1$, and in the $A_T$ case, we return Alice&#39;s result multiplied by -1. So in the $A_T B_T$ case the $ A B $ product will be $-1$, but remember that in the Bell statistic this term has a $-1$ multiplier in front (the last term):</p>
<p>$ S = \langle A_H B_H \rangle + \langle A_H B_T \rangle + \langle A_T B_H \rangle - \langle A_T B_T \rangle $</p>
<p>So, by accessing the other&#39;s measurement results instantly, which in Physics is called action-at-a-distance, we are able to force the Bell sum $S$ to be like:</p>
<p>$ S = 1 + 1 + 1 - (-1) = 4 $</p>
<p>This is only possible with action-at-a-distance, since otherwise Bob does not know whether Alice is using her $A_H$ or $A_T$ measurement device, so even if Bob flipped $T$ and knows what her particle is (because let&#39;s say they&#39;re identical, like in the earlier cases), he doesn&#39;t know what to do, because he doesn&#39;t know whether Alice used her $H$ or $T$.</p>
<p>Now, here&#39;s where things get interesting: <strong>what about our physical reality?</strong> Can any sort of composite system prepared by Victor, then separated—the &#34;left&#34; part sent to Alice, the &#34;right&#34; part sent to Bob—break the Bell inequality, with Alice and Bob being spacelike-separated per round?</p>
<h2>Quantum mechanics breaks the Bell inequality</h2>
<p>The shocking result is that, <strong>Yes, our physical reality breaks the Bell inequality!</strong>.</p>
<p>Victor can prepare a pair of quantum particles in a special state known as an <strong>entangled state</strong>. In this state, the outcomes of Alice&#39;s and Bob&#39;s measurements are not just random but are correlated in a way that defies any classical explanation based on local hidden variables. Remarkably, quantum mechanics predicts that the Bell statistic can exceed the classical bound of $2$. In fact, it can reach up to $2\sqrt{2} \approx 2.828$, a limit known as the <strong>Tsirelson bound</strong>. So it cannot get all the way up to $4$, like our toy Python example, but it does break $2$.</p>
<p>In this scenario Victor takes $2$ electrons (or $2$ photons), each of which can be modeled as a $2$-state quantum object, a qubit. He takes these $2$ qubits, and prepares them in the so-called anti-aligned singlet state:</p>
<p>$ ( | 01 \rangle - | 10 \rangle )/√2 $</p>
<p>Then, he sends the left qubit to Alice, and the right qubit to Bob. Alice flips her coin, and either uses the Pauli operator $\sigma_z$ or $\sigma_x$ to measure her qubit. Bob flips his coin, and either uses the operator $ -(\sigma_x + \sigma_z)/\sqrt{2} $ or $ (\sigma_x - \sigma_z)/\sqrt{2} $ to measure the second qubit. What this exactly means is will not be clear from this article, but the point is:</p>
<ul>
<li>this can be done in practice</li>
<li>Alice and Bob do not communicate with eather, they are space-like separated in each round</li>
</ul>
<p>However, because measurements in quantum mechanics have the weird property of action-at-a-distance, in the above scenario, Victor would compute the Bell statistic $2.828$, ie. our physical world breaks the Bell inequality. In other words, quantum mechanics cannot be decribed by a deterministic, local hidden variable theory. The below Python code simulates this scenario, and because quantum mechanics has action-at-a-distance, we have to keep our seemingly unphysical &#34;other&#34; references in our particles, and our measurement functions have to peek:</p>
<div><pre><span></span><code><span>def</span> <span>generate_composite</span><span>():</span>
    <span># we generate pairs of particles with anti-aligned spins in the singlet state</span>
    <span># the line of code below doesn&#39;t matter, it&#39;s just for documentation</span>
    <span>return</span> <span>{</span><span>&#39;state&#39;</span><span>:</span> <span>&#39;(|01&gt;-|10&gt;)/√2&#39;</span><span>}</span>
    <span># |0&gt; is the eigenstate of the Pauli operator σ_z corresponding to eigenvalue (=measurement outcome) +1</span>
    <span># |1&gt; is the eigenstate of the Pauli operator σ_z corresponding to eigenvalue (=measurement outcome) -1</span>
    <span># |+&gt; is the eigenstate of the Pauli operator σ_x corresponding to eigenvalue (=measurement outcome) +1</span>
    <span># |-&gt; is the eigenstate of the Pauli operator σ_x corresponding to eigenvalue (=measurement outcome) -1</span>
    <span># the above state can be rewritten in terms of |+&gt; and |-&gt;, like:</span>
    <span># (|01&gt;-|10&gt;)/√2  =  (|-+&gt;-|+-&gt;)/√2</span>

<span>def</span> <span>split</span><span>(</span><span>composite</span><span>):</span>
    <span># in quantum mechanics, there is no sense to talk about a left and right</span>
    <span># value (before measurement) of a singlet composite system..</span>
    <span>left</span>  <span>=</span> <span>{</span><span>&#39;value&#39;</span><span>:</span> <span>None</span><span>}</span>
    <span>right</span> <span>=</span> <span>{</span><span>&#39;value&#39;</span><span>:</span> <span>None</span><span>}</span>
    <span># we enable both left and right parts to peek at each other</span>
    <span># in physics, this is called action-at-a-distance</span>
    <span>left</span><span>[</span><span>&#39;other&#39;</span><span>]</span> <span>=</span> <span>right</span>
    <span>right</span><span>[</span><span>&#39;other&#39;</span><span>]</span> <span>=</span> <span>left</span>
    <span>return</span> <span>left</span><span>,</span> <span>right</span>

<span>def</span> <span>measure_first_qubit</span><span>(</span><span>q</span><span>,</span> <span>orientation</span><span>):</span>
    <span>q</span><span>[</span><span>&#39;measure&#39;</span><span>]</span> <span>=</span> <span>orientation</span>
    <span># Alice measures using σ_z or σ_x</span>
    <span># in both cases, the amplitudes of the 2 possible states are equal = 1/√2,</span>
    <span># so the probability of both measurement outcomes is 1/2</span>
    <span># but the post-measurement state is not the same in the 4 cases (2 measurements, each 2 outcomes ±1</span>
    <span># if Alice uses σ_z and measures +1 on the first qubit, the post measurement state of the composite system is |01&gt;</span>
    <span># if Alice uses σ_z and measures -1 on the first qubit, the post measurement state of the composite system is |10&gt;</span>
    <span># if Alice uses σ_x and measures +1 on the first qubit, the post measurement state of the composite system is |+-&gt;</span>
    <span># if Alice uses σ_x and measures -1 on the first qubit, the post measurement state of the composite system is |-+&gt;</span>
    <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>flip_coin</span><span>(</span><span>heads</span><span>=</span><span>1</span><span>,</span> <span>tails</span><span>=-</span><span>1</span><span>)</span>
    <span>return</span> <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span>

<span>measure_A_H</span> <span>=</span> <span>lambda</span> <span>q</span><span>:</span> <span>measure_first_qubit</span><span>(</span><span>q</span><span>,</span> <span>&#39;H&#39;</span><span>)</span> <span># Alice uses the Pauli operator σ_z to measure the first qubit</span>
<span>measure_A_T</span> <span>=</span> <span>lambda</span> <span>q</span><span>:</span> <span>measure_first_qubit</span><span>(</span><span>q</span><span>,</span> <span>&#39;T&#39;</span><span>)</span> <span># Alice uses the Pauli operator σ_x to measure the first qubit</span>

<span>p</span> <span>=</span> <span>1</span><span>/</span><span>(</span><span>4</span><span>-</span><span>2</span><span>*</span><span>sqrt</span><span>(</span><span>2</span><span>))</span>
<span>def</span> <span>measure_second_qubit</span><span>(</span><span>q</span><span>,</span> <span>orientation</span><span>):</span>
    <span># Bob&#39;s H corresponds to using the operator -(σ_x+σ_z)/√2 to measure the second qubit</span>
    <span># Bob&#39;s T corresponds to using the operator  (σ_x-σ_z)/√2 to measure the second qubit</span>
    <span># the math here is straightforward quantum theory:</span>
    <span># let&#39;s look at an example:</span>
    <span># suppose Alice flipped a coin and used σ_z (which we labeled Alice&#39;s H) and measured +1 on the first qubit, leaving the composite system in the state |01&gt;</span>
    <span># suppose that now Bob flips a coin and uses -(σ_x+σ_z)/√2 (which we labeled Bob&#39;s H):</span>
    <span># the challenge now is to express the composite state |01&gt; in terms of the eigenvectors of Bob&#39;s measurement operator -(σ_x+σ_z)/√2</span>
    <span># suppose the 2 eigenvectors are U and V with eigenvalues +1 and -1, and we can write |01&gt; = u*|U&gt; + v*|V&gt;, where u and v are the complex amplitudes</span>
    <span># this can be done on a piece of paper, to find u, v, U, V, and then the probabilities of outcome +1 is p=u^2 and -1 is 1-p=v^2=1-u^2</span>
    <span># .. where p is the number defined above p = 1/(4-2*sqrt(2)), because I did the math on paper</span>
    <span># there are 16 combinations of Alice and Bob measurements and outcomes (2 people, each 2 measurements, each measurement 2 outcomes)</span>
    <span># .. which can be neatly written into a table, and the probability is always p or 1-p</span>
    <span># see:</span>
    <span>#     https://docs.google.com/spreadsheets/d/1MfsGAqPoN1gK5iA3veipgoaSQ_mhqOL4bLhfYCqy_Sk</span>
    <span># </span>
    <span># the code below encodes this table</span>
    <span>q</span><span>[</span><span>&#39;measure&#39;</span><span>]</span> <span>=</span> <span>orientation</span>
    <span>sign</span> <span>=</span> <span>1</span> <span>if</span> <span>orientation</span> <span>==</span> <span>&#39;H&#39;</span> <span>or</span> <span>q</span><span>[</span><span>&#39;other&#39;</span><span>][</span><span>&#39;measure&#39;</span><span>]</span> <span>!=</span> <span>orientation</span> <span>else</span> <span>-</span><span>1</span>
    <span>if</span> <span>q</span><span>[</span><span>&#39;other&#39;</span><span>][</span><span>&#39;result&#39;</span><span>]</span> <span>==</span> <span>1</span><span>:</span>
        <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>sign</span> <span>*</span> <span>flip_coin</span><span>(</span><span>p</span><span>,</span> <span>1</span><span>,</span> <span>-</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span> <span>=</span> <span>sign</span> <span>*</span> <span>flip_coin</span><span>(</span><span>p</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>1</span><span>)</span>
    <span>return</span> <span>q</span><span>[</span><span>&#39;result&#39;</span><span>]</span>

<span>measure_B_H</span> <span>=</span> <span>lambda</span> <span>q</span><span>:</span> <span>measure_second_qubit</span><span>(</span><span>q</span><span>,</span> <span>&#39;H&#39;</span><span>)</span>
<span>measure_B_T</span> <span>=</span> <span>lambda</span> <span>q</span><span>:</span> <span>measure_second_qubit</span><span>(</span><span>q</span><span>,</span> <span>&#39;T&#39;</span><span>)</span>
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>2.82</code>. Note that this code just simulates quantum mechanics, in the sense that in this simulation, it returns the measurement outcomes $+1$ and $-1$ with the correct probabilities, but it&#39;s not simulating a qubit in essence — only a qubit in a quantum computer can simulate another qubit.</p>
<h2>Explanation</h2>
<p>I will not provide the derivation of the quantum mechanicalal probabilities, but will simply give the table of values. The key is that the conditional probabilities of Bob measuring $+1$ or $-1$ with his $H$ and $T$ devices, given whether Alice used $H$ or $T$ and measured $+1$ or $-1$ is given by this table, where $ p = 1/(4-2\sqrt{2}) \approx 0.8535 $. Deriving this table is relatively easy, a talented college physics student can do it, I did it with pen and paper:</p>
<p><img src="https://bytepawn.com/images/bell-cond-prob-matrix.jpg" alt="Bell experiment conditional probability matrix"/></p>
<p>So, for example, if Alice flips $H$ and measures $+1$, and Bob flips $H$, then he will measure $+1$ with probability $p$, and measure $-1$ with probability $1-p$. The Python code above encodes this table in an efficient way. The key here is that the measurement outcomes of Bob in the world of quantum mechanics depends on both:</p>
<ol>
<li>which device Alice used</li>
<li>what the measurement outcome of Alice was</li>
</ol>
<p>Note that the second point is not action-at-a-distance in itself, since even in the classical case, Bob&#39;s measurement outcome can be correlated with Alice — for example, in one of the examples above, Victor sent the same particle to both, and both can use the same devices, so their measurements will be identical — so Bob will always know what Alice&#39;s outcome is for both measurement, but he won&#39;t know which one she measured.</p>
<p>Notice that the probability matrix is symmetrical, so it doesn&#39;t matter whether in our simulation Alice goes first, and then Bob measures, or vica versa. This makes sense, since in the physical situation we&#39;re simulating, Alice and Bob are space-like separated, so physically there is no sense to say which of them goes first.</p>
<p>Also note that the probability matrix has four 2x2 sub-matrices. The green ones are all identical, while the red one is the transpose of the green one. It is the presence of the red matrix that leads to the violation of the Bell inequality and requires action-at-a-distance. To see this, let&#39;s replace the red one with another copy of the green matrix, like:</p>
<p><img src="https://bytepawn.com/images/green-cond-prob-matrix.jpg" alt="Bell experiment conditional probability matrix"/></p>
<p>This version no longer required action-at-a-distance, in fact it can be encoded quite simply with hidden parameters by Victor:</p>
<div><pre><span></span><code><span>p</span> <span>=</span> <span>1</span><span>/</span><span>(</span><span>4</span><span>-</span><span>2</span><span>*</span><span>sqrt</span><span>(</span><span>2</span><span>))</span>

<span>def</span> <span>generate_composite</span><span>():</span>
    <span>A_result</span> <span>=</span> <span>flip_coin</span><span>(</span><span>bias</span><span>=</span><span>0.5</span><span>,</span> <span>heads</span><span>=</span><span>1</span><span>,</span> <span>tails</span><span>=-</span><span>1</span><span>)</span>
    <span>if</span> <span>A_result</span> <span>==</span> <span>1</span><span>:</span>
        <span>B_result</span> <span>=</span> <span>flip_coin</span><span>(</span><span>bias</span><span>=</span><span>p</span><span>,</span> <span>heads</span><span>=</span><span>1</span><span>,</span> <span>tails</span><span>=-</span><span>1</span><span>)</span>
    <span>else</span><span>:</span>
        <span>B_result</span> <span>=</span> <span>flip_coin</span><span>(</span><span>bias</span><span>=</span><span>1</span><span>-</span><span>p</span><span>,</span> <span>heads</span><span>=</span><span>1</span><span>,</span> <span>tails</span><span>=-</span><span>1</span><span>)</span>
    <span>composite</span> <span>=</span> <span>A_result</span><span>,</span> <span>B_result</span>
    <span>return</span> <span>composite</span>

<span>def</span> <span>split</span><span>(</span><span>composite</span><span>):</span>
    <span>left</span> <span>=</span> <span>composite</span><span>[</span><span>0</span><span>]</span>
    <span>right</span> <span>=</span> <span>composite</span><span>[</span><span>1</span><span>]</span>
    <span>return</span> <span>left</span><span>,</span> <span>right</span>

<span>def</span> <span>trivial_measurement</span><span>(</span><span>q</span><span>):</span> <span>return</span> <span>q</span>

<span>measure_A_H</span> <span>=</span> <span>trivial_measurement</span>
<span>measure_A_T</span> <span>=</span> <span>trivial_measurement</span>
<span>measure_B_H</span> <span>=</span> <span>trivial_measurement</span>
<span>measure_B_H</span> <span>=</span> <span>trivial_measurement</span>

<span>bell_experiment</span><span>(</span><span>N</span><span>=</span><span>1000</span><span>*</span><span>1000</span><span>)</span>
</code></pre></div>

<p>Running <code>bell_experiment(N=1000*1000)</code> prints <code>1.41</code>, so it no longer breaks the Bell inequality. Note that this pre-setting approach, where Victor generates the randomness and Alice and Bob just observe it — which is the root assumption of deterministic local hidden variable theories — cannot reproduce the red-and-green matrix, because, per the rules of the game, Victor does not know in advance whether Alice (or Bob) will use $H$ or $T$, but he needs to change the probabilities based on that. He could of course hide several outcomes into the particles, but then in that case, Bob would still need to access Alice&#39;s measurment to know which one to choose to reproduce the probabilities. This is why no deterministic local hidden variable can reproduce the measurement results of quantum mechanics!</p>
<h2>Conclusion</h2>
<p>In this post I focused on the explanation on the logic of the Bell game, and Bell inequality, to make disambiguate it using Python code, and show what it takes to break it. I skipped over the details of the physics of qubits, Pauli operators and measurements. In the next post, I will show the quantum mechanics derivation of the conditional probabilities above.</p>
  </div></div>
  </body>
</html>
