<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://philipotoole.com/how-is-rqlite-tested/">Original</a>
    <h1>How rqlite is tested</h1>
    
    <div id="readability-page-1" class="page"><div>
			<p><strong><a href="https://www.rqlite.io" target="_blank" rel="noopener"><img decoding="async" src="https://philipotoole.com/wp-content/uploads/2016/04/j.png" alt="" width="131" height="126"/></a></strong><a href="https://www.rqlite.io" target="_blank" rel="noopener">rqlite</a> is a lightweight, open-source, distributed relational database built on <a href="http://sqlite.com/" target="_blank" rel="noopener">SQLite</a> and <a href="https://raft.github.io/" target="_blank" rel="noopener">Raft</a>. With its <a href="https://philipotoole.com/replicating-sqlite-using-raft-consensus/">origins dating back to 2014</a>, its <a href="https://rqlite.io/docs/design/" target="_blank" rel="noopener">design</a> has always prioritized reliability, and quality. The robustness of rqlite is also a testament to its disciplined testing strategy: after more than 10 years of development and deployments, users have <a href="https://github.com/rqlite/rqlite/issues" target="_blank" rel="noopener">reported</a> fewer than 10 instances of <a href="https://gobyexample.com/panic" target="_blank" rel="noopener">panics</a> in production.</p>
<p>Testing a distributed system like rqlite is no small feat. It requires careful consideration of various layers: from individual components to the entire system in operation. Let’s explore how rqlite is tested, following its philosophy of maintaining quality without unnecessary complexity.</p>

<hr/>
<h3>The Testing Pyramid: An Effective Approach</h3>
<p><a href="https://philipotoole.com/2021-rqlite-cmu-tech-talk" target="_blank" rel="noopener"><img fetchpriority="high" decoding="async" src="https://philipotoole.com/wp-content/uploads/2025/01/sloc-test-300x257.png" alt="" width="300" height="257" srcset="https://philipotoole.com/wp-content/uploads/2025/01/sloc-test-300x257.png 300w, https://philipotoole.com/wp-content/uploads/2025/01/sloc-test.png 668w" sizes="(max-width: 300px) 100vw, 300px"/></a>Testing rqlite adheres to the well-known <a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank" rel="noopener"><strong>testing pyramid</strong></a>, which prioritizes unit tests as the foundation, supported by integration tests, and capped with minimal end-to-end (E2E) tests. This strategy reflects decades of software development experience, ensuring test suites remain efficient, targeted, and easy to debug — and in my experience this approach <strong>works</strong>.</p>
<h4>Unit Testing: The Core of Quality</h4>
<p>At the base of the pyramid lies <a href="https://github.com/search?q=repo%3Arqlite%2Frqlite+path%3A*_test.go&amp;type=code" target="_blank" rel="noopener"><strong>unit testing</strong></a>, covering isolated components. Unit testing dominates rqlite’s test suite because it offers the best balance of speed and precision. Given that rqlite’s database layer is built around SQLite and a “shared nothing” architecture, most database-related functionality can be reliably tested with unit tests.</p>
<p>Testing is also a huge part of the design process. If a component cannot be unit-tested easily, it often signals issues with its design. A little dependency injection during testing is a good thing, but too much indicates an over-reliance on other components. Meeting the goal of easy unit testing means clean interfaces, helping components remain focused on a single task.</p>
<p>Let’s look at the numbers. As of version 8.34.0, <strong>the entire rqlite code base is approximately 75,000 lines long</strong> (including tests, but excluding imported packages). Of that rqlite’s unit test suite comprises <strong>27,000 lines of source code</strong>, making it the largest testing investment. Despite its breadth, the entire suite runs in just a few minutes, <a href="https://app.circleci.com/pipelines/github/rqlite/rqlite" target="_blank" rel="noopener">enabling frequent testing</a> during development.</p>
<hr/>
<h4>System-Level Testing: Validating Consensus</h4>
<p>Above unit testing lies <a href="https://github.com/rqlite/rqlite/tree/v8.36.4/system_test" target="_blank" rel="noopener"><strong>system-level testing</strong></a> (also known as <em>integration testing</em>), which focuses on the interplay between the Raft consensus module and SQLite. Since Distributed Consensus is at the core of rqlite, the correctness of this layer is crucial. Tests in this category validate:</p>
<ul>
<li>Replication of SQLite statements across nodes.</li>
<li>Behavior of read operations at different consistency levels.</li>
<li>Resilience during cluster disruptions, such as node failures and subsequent recoveries, as well as Leader elections.</li>
</ul>
<p>System tests include both single-node and multi-node configurations, ensuring the database operates correctly under varying cluster conditions. As of version 8.34.0, approximate <strong>7000 lines of system-level tests</strong> <strong>exist</strong>, offering comprehensive coverage of these interactions.</p>
<hr/>
<h4>End-to-End Testing: A Minimal Layer</h4>
<p>End-to-end testing in rqlite serves as a <a href="https://en.wikipedia.org/wiki/Smoke_testing_(software)" target="_blank" rel="noopener"><strong>smoke check</strong></a>, verifying that the system starts, clusters, and performs basic operations. Written in <a href="https://www.python.org/" target="_blank" rel="noopener">Python</a>, <a href="https://github.com/rqlite/rqlite/tree/v8.36.4/system_test/e2e" target="_blank" rel="noopener">these tests launch real rqlite clusters</a> to ensure “happy path” functionality, guarding against embarrassing issues like a cluster failing to start due to a bug in command-line flag parsing.</p>
<p>End-to-end tests are deliberately limited to scenarios that cannot be tested at lower levels. Over-reliance on end-to-end testing is avoided because debugging failures in such tests can become prohibitively costly. For instance, a misconfigured dependency deep in the stack might surface in an end-to-end test, but tracing the root cause would require navigating through numerous layers.</p>
<p>For version 8.340, only <strong>5000 lines of end-to-end tests</strong> <strong>exist</strong>, demonstrating a targeted approach.</p>
<hr/>
<h3>Performance Testing: Pushing the Limits</h3>
<p><img loading="lazy" decoding="async" src="https://philipotoole.com/wp-content/uploads/2021/02/5.6.1-annotated-300x159.png" alt="" width="300" height="159" srcset="https://philipotoole.com/wp-content/uploads/2021/02/5.6.1-annotated-300x159.png 300w, https://philipotoole.com/wp-content/uploads/2021/02/5.6.1-annotated-1024x543.png 1024w, https://philipotoole.com/wp-content/uploads/2021/02/5.6.1-annotated-768x407.png 768w, https://philipotoole.com/wp-content/uploads/2021/02/5.6.1-annotated-1536x814.png 1536w, https://philipotoole.com/wp-content/uploads/2021/02/5.6.1-annotated.png 1872w" sizes="auto, (max-width: 300px) 100vw, 300px"/>Beyond functional correctness, rqlite undergoes performance testing to evaluate its limits under load. These tests measure metrics such as:</p>
<ul>
<li>Maximum INSERT rates.</li>
<li>Handling of concurrent queries.</li>
<li>Comparing memory, CPU, and <a href="https://philipotoole.com/rqlite-5-10-0-released-comparing-its-disk-usage-to-5-6-0/">disk usage across releases</a>.</li>
</ul>
<p>A notable example involves testing with large SQLite databases, sometimes exceeding <strong>2GB</strong>. Such scenarios highlight bottlenecks like rqlite’s memory management or disk write latencies, which are intrinsic to its architecture. Generating such large datasets efficiently remains an ongoing challenge, with potential solutions involving prebuilt SQLite databases stored in cloud buckets.</p>
<p>Performance testing also ensures stability, identifying issues like <a href="https://philipotoole.com/plugging-a-memory-leak-in-rqlite/">memory leaks</a> or unexpected Leader elections under stress.</p>
<hr/>
<h3>Lessons Learned</h3>
<p>Testing rqlite has taught me valuable lessons, many of which resonate beyond database development:</p>
<ol>
<li><strong>Start Small:</strong> Unit testing is the most effective way to build confidence in your system. If a bug exists, you’ll likely find it faster here than in an integration or end-to-end test.</li>
<li><strong>Don’t ignore test failures.</strong> Any test failure, no matter how difficult to understand, no matter how rare, i<a href="https://philipotoole.com/how-i-found-a-bug-in-sqlite/">s telling you something about your software</a> — potentially something you don’t understand. Those hard-to-debug test cases often reveal a potential critical flaw in your code. Treat them as a gift and fix them.</li>
<li><strong>Maximize determinism.</strong> Build mechanisms into your system so you can trigger, on demand, what are normally automatic processes in your system. This allows you to test how your system performs when those operations occur. This approach is used in rqlite to <a href="https://github.com/rqlite/rqlite/blob/v8.36.5/http/service.go#L808" target="_blank" rel="noopener">test Raft snapshotting</a>, which normally runs at semi-random intervals but can be explicitly triggered as needed during testing.</li>
<li><strong>Be Deliberate:</strong> Adding tests at higher levels must be justified. Excessive integration or end-to-end tests can quickly bog down development and debugging.</li>
<li><strong>Adapt and Iterate:</strong> For example, performance tests revealed that <strong><a href="https://man7.org/linux/man-pages/man2/fsync.2.html" target="_blank" rel="noopener">fsync</a> calls</strong> were the primary bottleneck, leading to further optimizations in disk usage – such as compressing Raft log entries before writing them to disk.</li>
<li><strong>Efficiency Matters:</strong> With a suite that runs in a matter of minutes, I can iterate rapidly with confidence, a crucial advantage in maintaining an active open-source project.</li>
</ol>
<hr/>
<h3>Quality Matters</h3>
<p>By adhering to the testing pyramid and focusing on targeted, efficient tests, rqlite maintains high quality while minimizing overhead. Whether through unit tests for component reliability, system tests for distributed consensus, or end-to-end tests for sanity checks, every layer serves a purpose.</p>
<p>As rqlite continues to evolve, so will its testing practices. With distributed systems becoming increasingly complex, maintaining simplicity in testing will remain a cornerstone of its design philosophy. After all, the goal is not just to build a database but to build one that works reliably, and is easy to operate, in the real world.</p>
		</div></div>
  </body>
</html>
