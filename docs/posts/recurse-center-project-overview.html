<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0021-recurse-projects-part-3/">Original</a>
    <h1>Recurse Center project overview</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2024-02-08</p>

<p>In this post I give will an overview of the programming and writing I have worked on as a <a href="https://www.recurse.com/">Recurse</a> participant. I also added some more notes about Forth, Daisy and SIMD.</p>

<h2>What I worked on</h2>

<p>In reverse chronological order.</p>

<ul>
<li><a href="https://github.com/jacobvosmaer/1brc">1brc</a> — <a href="https://blog.jacobvosmaer.nl/0020-1-billion-row-challenge/">Taking on the One Billion Row Challenge in C</a>, also see <a href="#simd">SIMD in 1brc</a></li>
<li><a href="https://github.com/jacobvosmaer/yaforth">yaforth</a> — <a href="#yaforth">Yet another Forth (in C)</a></li>
<li><a href="https://blog.jacobvosmaer.nl/0019-recurse-projects-part-2/#cryptopals">Cryptopals</a></li>
<li><a href="https://gitlab.com/jacobvosmaer/midiparser">midiparser</a> — <a href="https://blog.jacobvosmaer.nl/0018-midi-parser/">A small MIDI parser</a></li>
<li><a href="https://github.com/jacobvosmaer/CZengine">CZengine</a> — <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#czengine">Casio CZ synthesis emulation</a></li>
<li><a href="https://github.com/jacobvosmaer/MidiRecorder">MidiRecorder</a> — <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#midirecorder">raw MIDI UART data recorder</a></li>
<li><a href="https://github.com/jacobvosmaer/DaisyX7">DaisyX7</a> — <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#daisyx7">Yamaha DX7 synthesis emulation</a></li>
<li><a href="https://github.com/jacobvosmaer/sineko">sineko</a> — <a href="https://blog.jacobvosmaer.nl/0013-sineko/">Sine wave kernel module</a></li>
<li><a href="https://blog.jacobvosmaer.nl/0019-recurse-projects-part-2/#static-site">Blog static site generator</a></li>
<li><a href="https://github.com/jacobvosmaer/FV1toDaisy">FV1toDaisy</a> — <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#fv1todaisy">FV1 assembly transpiler</a></li>
<li><a href="https://github.com/jacobvosmaer/DaisyAudioMangler">DaisyAudioMangler</a> — <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#mangler">audio reversing effect</a>, also see <a href="#mangler">Improving DaisyAudioMangler</a></li>
</ul>

<h2><a id="yaforth">Yet another Forth (in C)</a></h2>

<p><a href="https://github.com/jacobvosmaer/yaforth">GitHub</a></p>

<p>I have read about <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">Forth</a> plenty of times and while I was always intrigued by the language I never knew how get started with it. Forth is a minimal yet flexible programming language  that can be bootstrapped from assembler relatively easily. Therefore it seems to be a popular challenge to do just that. But I am not comfortable enough with assembly language so I always felt lost when reading about Forth.</p>

<p>At Recurse it is encouraged to write daily status updates (&#34;checkins&#34;) on <a href="https://zulip.com/">Zulip</a> (an app similar to Slack) to share what you are working on or looking into. This is very valuable because it can lead to serendipitous advice and collaborations. Through other people&#39;s checkins I came across a long blog post title <a href="https://ratfactor.com/forth/the_programming_language_that_writes_itself.html">&#34;Forth: The programming language that writes itself: The Web Page&#34;</a>. It talks about the origins of Forth and, suprise surprise, showcases the author&#39;s adventures with writing their own Forth in assembler.</p>

<p>Even though this was yet another reinforcement of my &#34;Forth requires assembler&#34; idea, the blog post also taught me that Forth is more like a set of ideas or principles than a specific language.
I cannot exhaustively list the Forth ideas but some of them are:</p>

<ul>
<li><a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish notation</a>, which is very easy to parse</li>
<li>Passing function arguments anonymously via an argument stack</li>
<li>All words from the language sit in a &#34;dictionary&#34; which can be freely extended with new words, defined recursively in terms of previously defined words</li>
<li>A strong bias towards implementation simplicity over pretty syntax or convenience</li>
</ul>

<p>I find this idea that Forth is a set of principles freeing because it tells me that I don&#39;t have to do assembly. I can learn about Forth, and from Forth, by exploring the &#34;Forth ideas&#34;.</p>

<p>The second helping hand I received was from a Recurse participant who shared a <a href="https://news.ycombinator.com/item?id=13082825">great Hacker News comment</a> where someone outlines some simple steps to get started writing your own Forth, without assembler.</p>

<p>Primed by these two experiences I felt inspired to start writing my own <a href="https://github.com/jacobvosmaer/yaforth">Forth in C</a> which I unimaginatively called &#34;yaforth&#34; which stands for &#34;yet another Forth&#34;.</p>

<p>I got far enough to implement &#34;IF THEN&#34; branching and support for recursive function definitions, but I cannot do loops yet. I don&#39;t know if or when I will get back to it. But what matters here is that I got to finally explore Forth, freed from the &#34;obligation&#34; of doing assembly. Yay!</p>

<h2><a id="mangler">Improving DaisyAudioMangler</a></h2>

<p><a href="https://github.com/jacobvosmaer/DaisyAudioMangler">GitHub</a></p>

<p>In the past month I have gone back and improved the <a href="https://blog.jacobvosmaer.nl/0012-recurse-projects/#mangler">&#34;Mangler&#34;</a> audio effect. I developed it on the  <a href="https://www.electro-smith.com/daisy/pod">Daisy Pod</a> prototyping board which is great for prototyping, but too fragile to sit in my studio. I just don&#39;t have a good feeling about all the exposed circuits.</p>



<p><img src="https://blog.jacobvosmaer.nl/0021-recurse-projects-part-3/daisypod.jpg"/></p>

<p>To address this, I built a bare <a href="https://electro-smith.com/products/daisy-seed">Daisy Seed</a> board into a <a href="https://www.hammfg.com/files/parts/pdf/1593VTBU.pdf?t=1697661943">Hammond enclosure</a>.</p>

<p><img src="https://blog.jacobvosmaer.nl/0021-recurse-projects-part-3/mangler.jpg"/></p>

<p>I also rewrote the Mangler firmware, which was using Daisy Pod buttons and knobs to read parameter changes, so that it could be controlled via MIDI instead. I could quickly tell that MIDI control was opening up new possibilities for &#34;playing&#34; the effect like an instrument.</p>

<p>Once I finally had the Mangler installed in my studio and I tried to use it I got the impression that there were clicks in the audio. This is really to be expected when you abruptly move a read pointer in an audio buffer, I don&#39;t know why it wasn&#39;t noticeable before. To remedy the clicks I refactored the firmware a second time so that it runs all audio engines at once and is able to cross-fade between them.</p>

<p>All this was a good reminder how much work it takes to &#34;finish&#34; a project once you think the hard part is done.  Even though the Mangler is such a simple, almost trivial effect, I look forward to being able to use it in <a href="https://soundcloud.com/collector-current">my music</a>.</p>

<h2><a id="simd">SIMD in 1brc</a></h2>

<p><a href="https://github.com/jacobvosmaer/1brc/blob/master/c/c8.c">GitHub</a></p>

<p>I previously <a href="https://blog.jacobvosmaer.nl/0020-1-billion-row-challenge/">wrote</a> about my work on the &#34;One Billion Row challenge&#34;. This is a challenge to write a program that processes a 15GB file as fast as possible. In that post I mentioned <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> programming, i.e. vectorizing, as a possible furter performance improvement.</p>

<p>I am happy to report that I managed to write a SIMD parser  for the simple number format of the challenge using ARM Neon intrinsics. It took me nearly a day to figure out what that means and how to do it. It is a fun exercise to take a character-at-a-time algorithm and to vectorize it which means to write it so that it does a vector&#39;s worth of work at once. In this particular case, it means taking a string of 4 characters like <code>12.3</code> and turning it into the number 123 by operating on all 4 characters at once. While I was at it I also made sure there is no branching.</p>

<details><summary>A parser for numbers of the formats <code>12.3\n</code>, <code>-12.3\n</code>, <code>1.2\n</code> and <code>-1.2\n</code>.
</summary>

<pre><code>
int64_t parsenumneon(char **pp) {
  uint16x8_t normalized, scaled,
      minimums = {&#39;0&#39;, &#39;0&#39;, &#39;.&#39;, &#39;0&#39;, &#39;0&#39;, &#39;.&#39;, &#39;0&#39;, &#39;\n&#39;},
      scaletens = {100, 10, 0, 1, 10, 0, 1, 0},
      maximums = {9, 9, 0, 9, 9, 0, 9, 0}, invec, rangecheck;
  uint16_t input[4];
  int16_t sign;
  uint16_t isddpd, isdpdn;
  uint8_t *p = (uint8_t *)*pp;
  int64_t out = 0;

  sign = 1 - 2 * (*p == &#39;-&#39;);
  p += (*p == &#39;-&#39;);

  input[0] = p[0];
  input[1] = p[1];
  input[2] = p[2];
  input[3] = p[3];
  invec = vcombine_u16(vld1_u16(input), vld1_u16(input));

  /* Note that x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39; is equivalent to x - &#39;0&#39; &gt;= 0 &amp;&amp; x - &#39;0&#39;
   * &lt;= 9. With unsigned integers, y &gt;= 0 is always true so we can simplify this
   * to x - &#39;0&#39; &lt;= 9. Similarly, x == &#39;.&#39; is equivalent to x - &#39;.&#39; &lt;= 0. So we
   * can simultaneously do the range checks for the digits and look for the &#39;.&#39;
   * by doing vector subtraction followed by less-than-or-equal. */

  normalized = vsubq_u16(invec, minimums);
  rangecheck = vcleq_u16(normalized, maximums);

  /* ddpd is the &#34;digit digit period digit&#34; pattern; dpdn is &#34;digit period digit
   * newline&#34; */
  isddpd = !!vminv_u16(vget_low_u16(rangecheck));
  isdpdn = !!vminv_u16(vget_high_u16(rangecheck));

  scaled = vmulq_u16(normalized, scaletens);
  out = isddpd * sign * vaddv_u16(vget_low_u16(scaled)) +
        isdpdn * sign * vaddv_u16(vget_high_u16(scaled));
  p += isddpd * 4 + isdpdn * 3;
  *pp = (char *)p;
  return out;
}
</code></pre>

</details>

<p>The bad news is that my program barely got any faster! This is what you get when you &#34;optimize&#34; things without good profiling data. So really the next step would be for me to move development over to Linux, or figure out how to get CPU profiles on macOS.</p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/recurse.html">recurse</a>
</p><details><summary>Edit history</summary><table>
<tbody><tr><td>2024-02-08</td><td></td><td>0021 publish</td></tr>
<tr><td>2024-02-08</td><td></td><td>0021 more writing</td></tr>
<tr><td>2024-02-08</td><td></td><td>Start writing 0021 recurse projects part 3</td></tr>
</tbody></table></details><p><a href="https://blog.jacobvosmaer.nl/">Back</a></p>
</div></div>
  </body>
</html>
