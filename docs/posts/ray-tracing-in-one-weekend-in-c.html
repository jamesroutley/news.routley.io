<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jacobvosmaer.nl/0022-ray-tracing-weekend/">Original</a>
    <h1>Ray Tracing in One Weekend in C</h1>
    
    <div id="readability-page-1" class="page"><div><p><i><a href="https://blog.jacobvosmaer.nl/">Jacob Vosmaer&#39;s blog</a></i></p>

<p>2024-02-19</p>

<p>In this post I reflect on following the <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">Ray Tracing in One Weekend</a> course <a href="https://github.com/jacobvosmaer/raytracingweekend">in C</a>.</p>

<h2>The book</h2>

<p><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html">&#34;Ray Tracing in One Weekend&#34;</a> is a free online book about 3D computer graphics. It tells you how to build a self-contained program that uses <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray tracing</a> to generate a 3D image. Each chapter ends with an image. If you wrote your program correctly, its output matches the example in the book (up to randomness).</p>

<p>The first image you produce looks like this:</p>

<p><img src="https://blog.jacobvosmaer.nl/0022-ray-tracing-weekend/first.jpg" alt="a square image with a color gradient from red to green"/></p>

<p>By the time you finish the last chapter your program is able to generate an image like this:</p>

<p><img src="https://blog.jacobvosmaer.nl/0022-ray-tracing-weekend/raytracing.jpg" alt="spheres of different size, color and material"/></p>

<p>The book encourages you to write your program in C++ and it contains partial C++ listings that show the changes you need to make at each step. The successive improvements are explained and motivated by drawings and mathematical formulas but it is possible to follow along and write your program without really understanding the math.</p>

<p>Of course you are free to use a programming language other than C++ and I chose C.</p>

<h2>My impressions</h2>

<p>The book is very well structured and has a good pace. I chose to write my program in C instead of C++ because I am currently interested in getting better at C. This required me to constantly &#34;translate&#34; the listings in the book but that is not too difficult because the languages are so similar.</p>

<p>At times it is frustrating to write a bunch of code without really understanding what it&#39;s doing but it is still rewarding to reach all the intermediate goals. There is the conceptual goal of getting each iteration of the program running but also the visual goal of the image you generate. It feels like a little triumph each time the images from your program matches the image in the book.</p>

<p>Also, in spite of the occasional frustration of merely doing what I am told, it does feel like I learn <em>something</em> in the process.</p>

<h2>Adapting the book to C</h2>

<p>I will share some observations about how I adapted the C++ code of the book <a href="https://github.com/jacobvosmaer/raytracingweekend">to C</a>.</p>

<p>The graphics code uses a lot of vector arithmetic on 3-dimensional vectors for both points in 3D space and RGB colors. The book uses C++ <a href="https://en.cppreference.com/w/cpp/language/operators">operator overloading</a> to make it possible to write things like <code>v + w</code> for vectors <code>v</code>, <code>w</code>. In my C version that ends up as a regular function call <code>v3add(v, w)</code>. While this is more verbose I did not find it difficult to work with.</p>

<p>The book introduces a C++ <a href="https://en.cppreference.com/w/cpp/language/abstract_class">abstract class</a> for &#34;hittable objects&#34;, meaning physical objects in the 3D scene that can be hit by a ray of light. The only hittable objects in the book are spheres but the idea is you could also add different shapes. C does not have an equivalent built-in construct for an abstract class. Because we only have spheres anyway, I just did not create this abstraction in my version. Wherever the book has a hittable object, my program has a sphere.</p>

<p>Another abstraction introduced by the book is that of a sphere material. The book implements three materials: a matte material it calls <a href="https://en.wikipedia.org/wiki/Lambertian_reflectance">Lambertian</a>, metal, and dielectric (e.g. glass). To factor out the different behaviors of the materials the book again uses an abstract class <code>material</code> with one <a href="https://en.cppreference.com/w/cpp/language/virtual">virtual method</a> <code>scatter</code> which determines if and how a ray of light bounces off the material.
Because there is only that one method on the <code>material</code> class I could get away with a normal <code>scatter</code> function in C which <a href="https://github.com/jacobvosmaer/raytracingweekend/blob/31382b5959d75317d9a15fd10a95da8c513fe097/main.c#L215-L254">performs a switch</a> on the material type <code>enum</code>.</p>

<p>Finally, the book makes a point of using <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">shared pointers</a> to manage the lifecycle of C++ objects. Maybe this does something useful in the C++ version but my program uses stack allocation for practically all objects and this works fine. In the few places where I use <code>malloc</code>, the allocation exists for the life of the process so there is no need to call <code>free</code>, let alone worry about when or where to call <code>free</code>. In other words memory management was a non-issue for me.</p>

<h2>Performance</h2>

<p>The final image in the book is <code>1200 * 675 = 810,000</code> pixels large. Each pixel is computed 500 times and then averaged so the program has to trace <code>810,000 * 500 = 405,000,000</code> rays. Computing each pixel more than once is needed to prevent stair stepping artifacts (aliasing) and to correctly implement dielectric materials (glass). When a ray hits a dielectric material it effectively splits in two: a reflected part (the mirror image) and a refracted part (the transparent image). The ray tracer randomly chooses to either reflect or refract. By repeating this many times and averaging, you get the combined effect of both reflection and refraction.</p>

<p>It speaks to the good structure of the book and the speed of modern computers and compilers that my first, single threaded implementation of the image ran in under 12 minutes on my M1 MacBook Pro.  On the other hand, 12 minutes is slow enough for me to want to make the program go faster.</p>

<h2>SIMD</h2>

<p>I recently <a href="https://blog.jacobvosmaer.nl/0022-ray-tracing-weekend/0021-recurse-projects-part-3/#simd">learned</a> how to use <a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Advanced_SIMD_(Neon)">ARM Neon</a> <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> instructions in C. Because SIMD is really about vector operations, and because my ray tracing program does so much vector arithmetic, it seemed like an obvious thing to try.</p>

<p>This was probably the first time I was glad I used a <a href="https://en.cppreference.com/w/c/language/typedef"><code>typedef</code></a> for a complex data structure. My code already used <code>vec3</code> instead of <code>struct vec3</code> everywhere. This made it possible to change the underlying type of <code>vec3</code> at compile time to <code>float32x4_t</code> which is a special Neon type which holds 4 <code>float</code> values. I only need 3 so I set the 4th value to 0.</p>

<details><summary> My vector operations mapped directly to Neon intrinsics. </summary>

<pre><code>
vec3 v3add(vec3 v, vec3 w) { return vaddq_f32(v, w); }
vec3 v3sub(vec3 v, vec3 w) { return vsubq_f32(v, w); }
vec3 v3mul(vec3 v, vec3 w) { return vmulq_f32(v, w); }
vec3 v3scale(vec3 v, float c) { return vmulq_n_f32(v, c); }
float v3dot(vec3 v, vec3 w) { return vaddvq_f32(vmulq_f32(v, w)); }
</code></pre>

</details>

<details><summary>For comparison, the struct version of <code>v3add</code>.</summary>

<pre><code>
vec3 v3add(vec3 v, vec3 w) {
  v.x += w.x;
  v.y += w.y;
  v.z += w.z;
  return v;
}
</code></pre>

</details>

<p>My program was still single threaded when I added SIMD. It made the program run about 10% faster with practically no changes outside the <code>vec3</code> functions. It may be possible to go even faster if you write the program for SIMD from the ground up but I don&#39;t know how to do that or how much time that would take. Moreover you would end up with either a program that only runs on ARM processors, or with multiple separate implementations of the same program. Right now the combined amount of <a href="https://github.com/jacobvosmaer/raytracingweekend/blob/31382b5959d75317d9a15fd10a95da8c513fe097/vec3.c#L8-L73">duplicated code</a> is 66 lines.</p>

<h2>Multi-threading</h2>

<p>Although it is fun to play with SIMD, a more promising optimization is to use multi-threading. The program performs its raytracing algorithm for 405M rays which are all independent: it has a high degree of parallelism.</p>

<p>After adding SIMD my single-threaded program ran in about 620 seconds.</p>

<p>The book structures the program to write the output file one pixel at a time. That means you do 500 ray tracing operations, take their average, then write 1 pixel. My first attempt at multi-threading followed this structure by fanning out the raytracing work to 8 worker threads, wait for them to trace 500 rays, then fan in and compute the result pixel. This got the runtime down to about 175 seconds but I could see on the macOS Activity Monitor that the process used only about 600% CPU. With 8 threads you would expect 800%. By using the &#39;Sample&#39; button in Activity Monitor I could also see my threads were spending a lot of time locking and unlocking mutexes. This was because I had to do the fan-out and fan-in 810,000 times!</p>

<p>It took me a while but I eventually realized I needed to move away from &#34;pixel at a time&#34;. I modified the program to create a big buffer for the output image. I then changed the threading code so that each thread fills in its own set of scan lines. Thread 0 renders line 0, 8, 16 etc. into the output buffer. Thread 1 renders line 1, 9, 17, etc. This way the main thread only needs to create the 8 worker threads and wait for them to finish. Once all threads are done the main threads write the image file from the output buffer in one pass. There is no coordination between the threads so they can spend all their time doing ray tracing. After this change my program did reach 800% CPU, and it completed the work in about 125 seconds.</p>

<p>There is still room for improvement because with 8 threads you would want the work to take <code>620 / 8 = 77</code> seconds. The book suggests giving each thread its own random number generator. If I were to try to make my version faster I think that is what I would try next.</p>

<h2>Conclusion</h2>

<p>I learned about this course because other <a href="https://www.recurse.com/">Recurse</a> participants in my batch went through the book. Even though my batch is over I decided I could still try it out myself.
I am happy to see that I am now fluent enough in C to actually do the work in a weekend as the title suggests.</p>

<p>It was fun to also do some performance tweaking with my experience with the <a href="http://localhost:8080/0020-1-billion-row-challenge/">One Billion Row Challenge</a> still fresh in my mind.</p>

<p>If you like programming and are curious about 3D graphics you might enjoy this book too!</p>
<p>Tags:
<a href="https://blog.jacobvosmaer.nl/recurse.html">recurse</a>
<a href="https://blog.jacobvosmaer.nl/c.html">c</a>
</p><details><summary>Edit history</summary><table>
<tbody><tr><td>2024-02-19</td><td></td><td>Add &#34;c&#34; tag</td></tr>
<tr><td>2024-02-19</td><td></td><td>0022: publish</td></tr>
<tr><td>2024-02-19</td><td></td><td>0022 edits after proof reading</td></tr>
<tr><td>2024-02-19</td><td></td><td>0022: hide code for the sake of mobile</td></tr>
<tr><td>2024-02-19</td><td></td><td>Add 0022 ray tracing first draft</td></tr>
</tbody></table></details><p><a href="https://blog.jacobvosmaer.nl/">Back</a></p>
</div></div>
  </body>
</html>
