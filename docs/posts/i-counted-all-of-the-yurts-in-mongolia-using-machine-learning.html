<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://monroeclinton.com/counting-all-yurts-in-mongolia/">Original</a>
    <h1>I counted all of the yurts in Mongolia using machine learning</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>The <em>Fall of Civilizations</em> podcast put out a <a href="https://www.youtube.com/watch?v=YyqS9V7yHQA">6¾-hour episode</a>
on the history of the Mongol Empire, which I eagerly listened to. After finishing the episode I wondered
about contemporary Mongolian society, I wanted to learn what the lands that the Mongol Empire
exploded from are like in our current day. There are many ways to try to understand a society,
whether it be quantifying it or looking at the lived experiences within it. If you look at
data provided by the World Bank, you’ll see a country that has rapidly reduced poverty in the 21st
century, has a high economic growth rate, a healthy fertility rate, and is solidly an
upper-middle-income country. While Mongolia is a republic with a competitive party system,
<a href="https://www.worldbank.org/en/publication/worldwide-governance-indicators/interactive-data-access">Worldwide Governance Indicators</a>
from the World Bank show a government that has issues with corruption, regulatory quality, and effectiveness.</p>
<table>
<thead>
<tr>
<th>Indicator</th>
<th>Value</th>
<th>Years</th>
</tr>
</thead>
<tbody>
<tr>
<td>Population</td>
<td>3,481,145</td>
<td>2023</td>
</tr>
<tr>
<td>Fertility rate</td>
<td>2.7</td>
<td>2023</td>
</tr>
<tr>
<td>Intentional homicides (per 100,000 people)</td>
<td>6</td>
<td>2021</td>
</tr>
<tr>
<td>Individuals using the Internet (% of population)</td>
<td>1% → 83%</td>
<td>2000 → 2023</td>
</tr>
<tr>
<td>Poverty headcount ratio at $2.15 a day (2017 PPP) (% of population)</td>
<td>11.6% → 0.2%</td>
<td>2002 → 2022</td>
</tr>
<tr>
<td>Average GDP growth</td>
<td>6.62%</td>
<td>2003 → 2023</td>
</tr>
<tr>
<td>GDP per capita, PPP (current international $)</td>
<td>$4,399.4 → $18,004.9</td>
<td>2003 → 2023</td>
</tr>
</tbody>
</table>
<blockquote>
<p>(“Mongolia”)</p>
</blockquote>
<p>All of these indicators are interesting to look at, but they don’t really show what a society is
like. I feel you get much more understanding by going to a country, walking the streets, and
talking to people there. If you’re unable to do this, the next best thing is spending hours
exploring Google Maps, which I did. I opened a satellite view of Ulaanbaatar, the capital of Mongolia.
I saw new glass buildings, Soviet-designed apartment blocks (called ugsarmal), impressive government
buildings, factories, and industrial areas. But something stood out to me. Yurts, extending for kilometers
in all directions.</p>
<p><img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/yurts-1.jpg" alt="Satellite view of Ulaanbaatar containing yurts"/></p>
<blockquote>
<p>Maps Data: Google © 2025 Airbus, CNES / Airbus, Maxar Technologies</p>
</blockquote>
<p>Naturally, I was impressed by the quantity of yurts I saw, and I was curious: just how many yurts (ger in Mongolian) are in
Mongolia and why? This set me on the path drawing bounding boxes on over 10,000 yurts to train a machine learning
model to count the rest of the yurts in the country. While I was training the model, I wondered what
the story behind these yurts are, I did a small investigation for later in this article. For now,
this is the story of counting them.</p>
<h2 id="counting-all-the-yurts-in-mongolia">Counting all the yurts in Mongolia</h2>
<p>I was unable to find a count of the yurts in Mongolia, this left me with
the task of doing it myself. Although I had never studied or worked with machine learning, I knew
through some osmosis that machine learning is well fit for this task. I created a simple plan in my
brain:</p>
<ol>
<li>Train a model to identify yurts</li>
<li>Reduce input space and parallelize searching of input space</li>
<li>Keep track of the yurts found</li>
</ol>
<h3 id="training-a-model-to-identify-yurts">Training a model to identify yurts</h3>
<p>The first thing I needed was training data, and lots of it. There’s many different options for satellite
imagery such as <a href="https://www.mapbox.com/imagery">Mapbox</a>, <a href="https://developers.google.com/maps/documentation/tile">Google Maps</a>,
and <a href="https://developers.arcgis.com/rest/basemap-styles/arcgis-imagery-webmap-get/">ArcGIS</a>. I
decided to use Google Maps since I’m already familiar with it.</p>
<p>For digital maps, many systems break the world up into a series of 256 x 256 tiles identified by X, Y, Z values. This is
referred to as tiled web maps and allows for progressively loading maps at different zoom levels and
positions. The zoom level values tend to be 0 through 20, where 0 has the least tiles and 20 the
most. The formula for calculating the number of tiles at a given zoom (z) level is: <span> $2^z * 2^z$ </span>
.
This means increasing <code>z</code> by one will increase the tile count by four times.</p>
<p>I wrote a Python script that generated tiles from a box around Ulaanbaatar and downloaded
them to a folder to use as training data. To list the tiles inside a bounding box made up of a
southwest and northeast coordinates, I used the <a href="https://mercantile.readthedocs.io/en/latest/">mercantile package</a>.</p>
<div><pre tabindex="0"><code data-lang="python"><span>for</span> <span>tile</span> <span>in</span> <span>mercantile</span><span>.</span><span>tiles</span><span>(</span><span>sw_lng</span><span>,</span> <span>sw_lat</span><span>,</span> <span>ne_lng</span><span>,</span> <span>ne_lat</span><span>,</span> <span>zooms</span><span>=</span><span>z</span><span>):</span>
    <span>download_tile</span><span>(</span><span>*</span><span>tile</span><span>)</span>
</code></pre></div><p><img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/tile-1.jpeg" alt="Sample tile from Google Maps"/>
<img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/tile-2.jpeg" alt="Sample tile from Google Maps"/>
<img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/tile-3.jpeg" alt="Sample tile from Google Maps"/></p>
<blockquote>
<p>Tiles from Google Maps, you can see yurts on the right tile. Maps Data: Google © 2025 Airbus, CNES / Airbus, Maxar Technologies</p>
</blockquote>
<p>I decided to start at zoom level <code>17</code> as it is the lowest zoom level that I can still identify yurts
at. Once I downloaded several hundred tiles at this zoom level, I needed a way to label the yurts on
these tiles. Labeling is the process of drawing boxes around objects in an image. The idea is to
draw these boxes manually, creating what is called annotated data, and then training a model to do
the labeling using the annotated data.
There’s an open source tool called <a href="https://labelstud.io/">Label Studio</a> that does just
this.</p>
<p><img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/label-studio.jpg" alt="Label Studio showing yurts labeled"/></p>
<blockquote>
<p>Here I drew bounding boxes on the tile around the yurts.</p>
</blockquote>
<p>A couple dozen yurts later and I wanted to try and train a model based on my tiny amount of
annotated data. I had the choice between object detection (bounding boxes) and segmentation (outline
objects). Segmentation probably would be more accurate because yurts are not rectangular,
but it seemed like it would take longer to setup. I decided to go with object detection.</p>
<p>I looked at various ways to train an object detection model, my requirements were:</p>
<ul>
<li>Open source</li>
<li>As simple as possible to setup</li>
<li>Able to quickly iterate</li>
<li>Detection speed of the model is a priority due to the potentially large amount of data</li>
<li>Has good default settings around data augmentation, warmups, loss functions, etc</li>
<li>Monitor current and previous training runs to compare accuracy</li>
</ul>
<p>After doing a brief survey of the machine learning landscape, I landed on using <a href="https://docs.ultralytics.com/">YOLO11</a> by Ultralytics.
The YOLO series is a set of models that can complete computer vision tasks, and can be trained with
custom data.
In Label Studio you’re able to export to many different dataset types, YOLO being one of them. After
exporting my annotated data as a YOLO dataset, I split the dataset into training and validation data
and configured the dataset in <code>dataset.yaml</code> for YOLO to use.</p>





<div>
    
    <div>
        <div><pre tabindex="0"><code data-lang="yaml"><span>train</span><span>:</span><span> </span><span>images/train</span><span>
</span><span></span><span>val</span><span>:</span><span> </span><span>images/val</span><span>
</span><span>
</span><span></span><span>nc</span><span>:</span><span> </span><span>1</span><span>
</span><span></span><span>names</span><span>:</span><span>
</span><span>  </span>- <span>yurt</span></code></pre></div>
    </div>
</div>

<p>From the ultralytics package, I used the YOLO class to use their pre-trained <code>yolo11n</code> object
detection model. Ultralytics allows easy tuning of the model with annotated data through the <code>train</code>
method of the <code>YOLO</code> class. The tuned model can be exported through <code>export</code> in various formats.</p>
<div><pre tabindex="0"><code data-lang="python"><span>from</span> <span>ultralytics</span> <span>import</span> <span>YOLO</span>

<span>model</span> <span>=</span> <span>YOLO</span><span>(</span><span>&#34;yolo11n.pt&#34;</span><span>)</span>
<span>model</span><span>.</span><span>train</span><span>(</span>
    <span>data</span><span>=</span><span>&#34;dataset.yaml&#34;</span><span>,</span>
    <span>device</span><span>=</span><span>&#34;cpu&#34;</span><span>,</span>
<span>)</span>

<span>path</span> <span>=</span> <span>model</span><span>.</span><span>export</span><span>(</span><span>name</span><span>=</span><span>&#34;yurt&#34;</span><span>)</span>
</code></pre></div><p>With some testing I found my Yurt model was less than adequate, which I expected due to the tiny
amount of annotated data. I then did a couple hours of labeling, but the model would always miss
around 10-15% of the yurts in a given tile. At this point I had two options, either increase the
zoom level or gather more training data. To base my decision I decided to calculate how many tiles I
would need to search at each zoom level.</p>
<h3 id="refining-the-search-area">Refining the search area</h3>
<p>Mongolia is 1,564,116 square kilometers, using this we can calculate how many tiles at each zoom
level there are in Mongolia. The world has <span> $2^z * 2^z$ </span>
 tiles, so
on a single axis there are <span> $2^z$ </span>
 tiles. The map projection is from a sphere
a tile will represent more or less area depending on the latitude.
To find the width of the projection at a latitude for Web Mercator, we can
use this formula where <span>$R = 6,378.137$</span>
 is the radius of the equator in kilometers and <span>$\phi = 47.923107575288114$</span>
 is the
latitude of Mongolia in degrees which is converted to radians:</p>
<p><span> $$2\pi * R * \cos(\phi * \dfrac{\pi}{180}) = 26,855.3636571$$</span></p><p>We then need to divide the number of tiles on the x-axis at this location to get the width of a
tile. For the area of a tile, just square the width and divide the area of Mongolia by the area of a
single tile to get the tile count.</p>
<table>
<thead>
<tr>
<th>Zoom Level</th>
<th>Tile Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>17</td>
<td>37,258,617</td>
</tr>
<tr>
<td>18</td>
<td>149,034,469</td>
</tr>
<tr>
<td>19</td>
<td>596,137,879</td>
</tr>
<tr>
<td>20</td>
<td>2,384,551,518</td>
</tr>
</tbody>
</table>
<p>Since Mongolia is such a large country, I began to wonder if there are more ways to reduce the
amount of tiles other than just zoom level. It’s a sparsely populated country, with much of the
country being uninhabited. Also, nearly all yurts are located in urban areas, with the City of
Ulaanbaatar estimating 60% of the population lives in ger (yurt) districts (City of Ulaanbaatar 17).</p>
<p>I used <a href="https://overpass-turbo.eu/">overpass turbo</a> to do a query for all the places human settlements might be in the
country and exported this data as GeoJSON. The query returned several thousand points of interest.</p>
<pre tabindex="0"><code>[out:json][timeout:25];
{{geocodeArea:Mongolia}}-&gt;.searchArea;
(
  node[place](area.searchArea);
  node[man_made](area.searchArea);
  node[historic](area.searchArea);
);
out body;
&gt;;
out skel qt;
</code></pre><p>I wanted to know how many unique tiles for searching a 2,000 meter area around each point there are,
so I wrote a script to do this using geopandas.</p>
<div><pre tabindex="0"><code data-lang="python"><span>gdf</span> <span>=</span> <span>gpd</span><span>.</span><span>read_file</span><span>(</span><span>&#34;./mongolia.geojson&#34;</span><span>)</span>
<span>gdf_merc</span> <span>=</span> <span>gdf</span><span>.</span><span>to_crs</span><span>(</span><span>&#34;EPSG:3857&#34;</span><span>)</span>
<span>gdf_merc</span><span>[</span><span>&#34;buffer&#34;</span><span>]</span> <span>=</span> <span>gdf_merc</span><span>.</span><span>geometry</span><span>.</span><span>buffer</span><span>(</span><span>2000</span><span>)</span>

<span>gdf_buffer</span> <span>=</span> <span>gdf_merc</span><span>.</span><span>set_geometry</span><span>(</span><span>&#34;buffer&#34;</span><span>)</span><span>.</span><span>to_crs</span><span>(</span><span>&#34;EPSG:4326&#34;</span><span>)</span>

<span>tiles</span> <span>=</span> <span>{}</span>
<span>for</span> <span>polygon</span> <span>in</span> <span>gdf_buffer</span><span>.</span><span>geometry</span><span>:</span>
    <span>minx</span><span>,</span> <span>miny</span><span>,</span> <span>maxx</span><span>,</span> <span>maxy</span> <span>=</span> <span>polygon</span><span>.</span><span>bounds</span>

    <span>for</span> <span>tile</span> <span>in</span> <span>mercantile</span><span>.</span><span>tiles</span><span>(</span><span>minx</span><span>,</span> <span>miny</span><span>,</span> <span>maxx</span><span>,</span> <span>maxy</span><span>,</span> <span>zooms</span><span>=</span><span>Z</span><span>):</span>
        <span>tiles</span><span>[</span><span>&#34;</span><span>{}</span><span>-</span><span>{}</span><span>-</span><span>{}</span><span>&#34;</span><span>.</span><span>format</span><span>(</span><span>str</span><span>(</span><span>tile</span><span>.</span><span>x</span><span>),</span> <span>str</span><span>(</span><span>tile</span><span>.</span><span>y</span><span>),</span> <span>str</span><span>(</span><span>tile</span><span>.</span><span>z</span><span>))]</span> <span>=</span> <span>True</span>
</code></pre></div><table>
<thead>
<tr>
<th>Zoom Level</th>
<th>Tile Count</th>
</tr>
</thead>
<tbody>
<tr>
<td>17</td>
<td>270,559</td>
</tr>
<tr>
<td>18</td>
<td>1,016,617</td>
</tr>
<tr>
<td>19</td>
<td>3,938,174</td>
</tr>
<tr>
<td>20</td>
<td>15,506,872</td>
</tr>
</tbody>
</table>
<h3 id="building-a-model-backend-for-labeling">Building a model backend for labeling</h3>
<p>To speed up the labeling of yurts I wanted Label Studio to use my model to label yurts.
Label Studio has the ability to integrate with a model backend,
essentially an API wrapper around a model, to request predictions. When labeling a tile, Label
Studio makes a request to this API for predictions. The API returns the bounding boxes for the tile.
I fix any mistakes the model made, and submit the tile. Every so often I retrain the model, creating
a feedback loop that improves the model with more and more annotated data.</p>





<div>
    
    <div>
        <div><pre tabindex="0"><code data-lang="python"><span>class</span> <span>YurtModel</span><span>:</span>
    <span># Initialize trained model to reuse across requests</span>
    <span>def</span> <span>__init__</span><span>(</span><span>self</span><span>):</span>
        <span>self</span><span>.</span><span>model</span> <span>=</span> <span>YOLO</span><span>(</span><span>&#34;best.pt&#34;</span><span>,</span> <span>task</span><span>=</span><span>&#34;detect&#34;</span><span>)</span>

    <span># Task a task sent by Label Studio, and return bounding boxes of yurts</span>
    <span>def</span> <span>predict</span><span>(</span><span>self</span><span>,</span> <span>tasks</span><span>):</span>
        <span>predictions</span> <span>=</span> <span>[]</span>
        <span>for</span> <span>task</span> <span>in</span> <span>tasks</span><span>:</span>
            <span># Get the path to the file from label studio</span>
            <span>path</span> <span>=</span> <span>get_local_path</span><span>(</span>
                <span>task</span><span>[</span><span>&#34;data&#34;</span><span>][</span><span>&#34;image&#34;</span><span>],</span>
                <span>task_id</span><span>=</span><span>task</span><span>[</span><span>&#34;id&#34;</span><span>],</span>
            <span>)</span>

            <span>results</span> <span>=</span> <span>self</span><span>.</span><span>model</span><span>(</span><span>path</span><span>)</span>

            <span>for</span> <span>result</span> <span>in</span> <span>results</span><span>:</span>
                <span>regions</span> <span>=</span> <span>[]</span>
                <span>for</span> <span>prediction</span> <span>in</span> <span>result</span><span>.</span><span>boxes</span><span>:</span>
                    <span>xyxy</span> <span>=</span> <span>prediction</span><span>.</span><span>xyxy</span><span>[</span><span>0</span><span>]</span><span>.</span><span>tolist</span><span>()</span>
                    <span>regions</span><span>.</span><span>append</span><span>({</span>
                        <span>&#34;model_version&#34;</span><span>:</span> <span>&#34;1.0&#34;</span><span>,</span>
                        <span>&#34;from_name&#34;</span><span>:</span> <span>&#34;label&#34;</span><span>,</span>
                        <span>&#34;to_name&#34;</span><span>:</span> <span>&#34;image&#34;</span><span>,</span>
                        <span>&#34;type&#34;</span><span>:</span> <span>&#34;rectanglelabels&#34;</span><span>,</span>
                        <span>&#34;score&#34;</span><span>:</span> <span>prediction</span><span>.</span><span>conf</span><span>.</span><span>item</span><span>(),</span>
                        <span>&#34;value&#34;</span><span>:</span> <span>{</span>
                            <span>&#34;x&#34;</span><span>:</span> <span>xyxy</span><span>[</span><span>0</span><span>]</span> <span>/</span> <span>256</span> <span>*</span> <span>100</span><span>,</span>
                            <span>&#34;y&#34;</span><span>:</span> <span>xyxy</span><span>[</span><span>1</span><span>]</span> <span>/</span> <span>256</span> <span>*</span> <span>100</span><span>,</span>
                            <span>&#34;width&#34;</span><span>:</span> <span>(</span><span>xyxy</span><span>[</span><span>2</span><span>]</span> <span>-</span> <span>xyxy</span><span>[</span><span>0</span><span>])</span> <span>/</span> <span>256</span> <span>*</span> <span>100</span><span>,</span>
                            <span>&#34;height&#34;</span><span>:</span> <span>(</span><span>xyxy</span><span>[</span><span>3</span><span>]</span> <span>-</span> <span>xyxy</span><span>[</span><span>1</span><span>])</span> <span>/</span> <span>256</span> <span>*</span> <span>100</span><span>,</span>
                            <span>&#34;rectanglelabels&#34;</span><span>:</span> <span>[</span>
                                <span>&#34;yurt&#34;</span><span>,</span>
                            <span>],</span>
                        <span>},</span>
                    <span>})</span>

                <span>all_scores</span> <span>=</span> <span>[</span><span>region</span><span>[</span><span>&#34;score&#34;</span><span>]</span> <span>for</span> <span>region</span> <span>in</span> <span>regions</span> <span>if</span> <span>&#34;score&#34;</span> <span>in</span> <span>region</span><span>]</span>
                <span>avg_score</span> <span>=</span> <span>sum</span><span>(</span><span>all_scores</span><span>)</span> <span>/</span> <span>max</span><span>(</span><span>len</span><span>(</span><span>all_scores</span><span>),</span> <span>1</span><span>)</span>

                <span>predictions</span><span>.</span><span>append</span><span>({</span>
                    <span>&#34;result&#34;</span><span>:</span> <span>regions</span><span>,</span>
                    <span>&#34;score&#34;</span><span>:</span> <span>avg_score</span><span>,</span>
                    <span>&#34;model_version&#34;</span><span>:</span> <span>&#34;1.0&#34;</span><span>,</span>
                <span>})</span>

        <span>return</span> <span>{</span>
            <span>&#34;results&#34;</span><span>:</span> <span>predictions</span><span>,</span>
        <span>}</span>

<span>model</span> <span>=</span> <span>YurtModel</span><span>()</span></code></pre></div>
    </div>
</div>

<p>We then need to fill out the API routes that Label Studio expects, which is a <code>/predict</code> route for
label studio to send tiles and receive predictions, a <code>/setup</code> route to do any initialization
required, and a <code>/health</code> route to do health checks on. I used <a href="https://fastapi.tiangolo.com/">FastAPI</a> to build the API and use
the <code>YurtModel</code> from above.</p>





<div>
    
    <div>
        <div><pre tabindex="0"><code data-lang="python"><span>@app</span><span>.</span><span>post</span><span>(</span><span>&#34;/predict&#34;</span><span>)</span>
<span>async</span> <span>def</span> <span>predict</span><span>(</span><span>request</span><span>:</span> <span>Request</span><span>):</span>
    <span>res</span> <span>=</span> <span>await</span> <span>request</span><span>.</span><span>json</span><span>()</span>
    <span>return</span> <span>model</span><span>.</span><span>predict</span><span>(</span><span>res</span><span>[</span><span>&#34;tasks&#34;</span><span>])</span>

<span>@app</span><span>.</span><span>post</span><span>(</span><span>&#34;/setup&#34;</span><span>)</span>
<span>async</span> <span>def</span> <span>setup</span><span>():</span>
    <span>return</span> <span>{</span>
        <span>&#34;model_version&#34;</span><span>:</span> <span>&#34;1.0&#34;</span><span>,</span>
    <span>}</span>

<span>@app</span><span>.</span><span>get</span><span>(</span><span>&#34;/health&#34;</span><span>)</span>
<span>async</span> <span>def</span> <span>health</span><span>():</span>
    <span>return</span> <span>{</span>
        <span>&#34;status&#34;</span><span>:</span> <span>&#34;UP&#34;</span><span>,</span>
        <span>&#34;model_class&#34;</span><span>:</span> <span>str</span><span>(</span><span>YurtModel</span><span>.</span><span>__class__</span><span>),</span>
    <span>}</span></code></pre></div>
    </div>
</div>

<p>By relying on the model to find most of the yurts when labeling, I was able to rapidly create more
annotated data. I quickly built a dataset of over 10,000 yurts.</p>
<h3 id="monitoring-accuracy-of-each-model">Monitoring accuracy of each model</h3>
<h3 id="scaling-training-of-models">Scaling training of models</h3>
<p>As the size of the annotated data grew, training the models on my laptop became too slow.
I decided to use <a href="https://vast.ai">vast.ai</a> to rent GPUs to do my training runs. To train
the models on vast.ai, I needed everything to run in Docker. I wrote a Dockerfile for the training
script, and I pushed it to <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry">GitHub Container Registry</a>.
In vast.ai I set up authentication with the private image registry so it could pull the image I pushed up.</p>
<p><img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/docker-auth.png" alt="vast.ai Docker authentication"/></p>
<blockquote>
<p>Docker authentication in vast.ai</p>
</blockquote>
<p>Here is the Dockerfile that I used to run the training script on the dataset I created.</p>
<div><pre tabindex="0"><code data-lang="shell">FROM ghcr.io/astral-sh/uv:python3.10-bookworm-slim

WORKDIR /app

<span># Copy training script, annotated data, and requirements to image</span>
COPY scripts/train_model.py .
COPY datasets ./datasets
COPY dataset.yaml .
COPY pyproject.toml .
COPY uv.lock .

<span># Needed for ...</span>
RUN apt-get update -y <span>&amp;&amp;</span> apt-get install -y libgl1-mesa-dev libglib2.0-0

<span># Install package requirements</span>
RUN uv sync --no-dev

<span># Run the training script</span>
CMD <span>[</span><span>&#34;uv&#34;</span>, <span>&#34;run&#34;</span>, <span>&#34;python&#34;</span>, <span>&#34;train_model.py&#34;</span><span>]</span>
</code></pre></div><p>In order to build and push this image to GitHub I ran:</p>
<div><pre tabindex="0"><code data-lang="shell">docker build -t ghcr.io/monroeclinton/yurt -f Dockerfile .
docker push ghcr.io/monroeclinton/yurt:latest
</code></pre></div><p>Since the training happened in ephemeral containers, I needed a way to retrieve the finished model. I
decided to upload the model to S3 after it finished training. To monitor the accuracy of the
models, I also needed the metadata associated with the runs, so I uploaded everything in the
run folder to S3.</p>





<div>
    
    <div>
        <div><pre tabindex="0"><code data-lang="python"><span>model</span> <span>=</span> <span>YOLO</span><span>(</span><span>&#34;yolo11n.pt&#34;</span><span>)</span>

<span>model</span><span>.</span><span>train</span><span>(</span>
    <span>data</span><span>=</span><span>&#34;dataset.yaml&#34;</span><span>,</span>
    <span>epochs</span><span>=</span><span>1000</span><span>,</span>
    <span>patience</span><span>=</span><span>150</span><span>,</span>
    <span>imgsz</span><span>=</span><span>256</span><span>,</span>
    <span>device</span><span>=</span><span>&#34;cuda&#34;</span><span>,</span>
<span>)</span>

<span>path</span> <span>=</span> <span>model</span><span>.</span><span>export</span><span>(</span><span>name</span><span>=</span><span>&#34;yurt&#34;</span><span>)</span>
<span>train_dir</span> <span>=</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>dirname</span><span>(</span><span>os</span><span>.</span><span>path</span><span>.</span><span>dirname</span><span>(</span><span>path</span><span>))</span>

<span>s3</span> <span>=</span> <span>boto3</span><span>.</span><span>client</span><span>(</span>
    <span>service_name</span> <span>=</span><span>&#34;s3&#34;</span><span>,</span>
    <span>endpoint_url</span><span>=</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;S3_ENDPOINT&#34;</span><span>],</span>
    <span>aws_access_key_id</span><span>=</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;S3_ACCESS_KEY_ID&#34;</span><span>],</span>
    <span>aws_secret_access_key</span><span>=</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;S3_SECRET_ACCESS_KEY&#34;</span><span>],</span>
    <span>region_name</span><span>=</span><span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;S3_REGION&#34;</span><span>],</span>
<span>)</span>

<span>timestamp</span> <span>=</span> <span>time</span><span>.</span><span>time</span><span>()</span>

<span>for</span> <span>root</span><span>,</span> <span>dirs</span><span>,</span> <span>files</span> <span>in</span> <span>os</span><span>.</span><span>walk</span><span>(</span><span>train_dir</span><span>):</span>
    <span>for</span> <span>file</span> <span>in</span> <span>files</span><span>:</span>
        <span>local_path</span> <span>=</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>root</span><span>,</span> <span>file</span><span>)</span>
        <span>s3_key</span> <span>=</span> <span>f</span><span>&#34;models/</span><span>{</span><span>int</span><span>(</span><span>timestamp</span><span>)</span><span>}</span><span>/</span><span>{</span><span>os</span><span>.</span><span>path</span><span>.</span><span>relpath</span><span>(</span><span>local_path</span><span>,</span> <span>train_dir</span><span>)</span><span>}</span><span>&#34;</span>
        <span>s3</span><span>.</span><span>upload_file</span><span>(</span><span>local_path</span><span>,</span> <span>os</span><span>.</span><span>environ</span><span>[</span><span>&#34;S3_BUCKET&#34;</span><span>],</span> <span>s3_key</span><span>)</span></code></pre></div>
    </div>
</div>

<h3 id="deploying-models-and-searching-mongolia">Deploying models and searching Mongolia</h3>
<p>After dozens of training runs and greatly improving the accuracy of the model, I decided to finally
do my count of Mongolia. There were many options to run my deployment, however I made my choice based on three
criteria:</p>
<ul>
<li>Simplicity in setup and deployment</li>
<li>At least 100 instances of my model should be run</li>
<li>The bottleneck is I/O (downloading tiles), so should be deployed on many CPUs</li>
</ul>
<p>Based on these criteria, I used <a href="https://docs.docker.com/engine/swarm/">Docker Swarm</a> to orchestrate the workload.
It’s already packaged in Docker, so there’s no need to install anything else. Docker Swarm also is
fairly simple to set up, scale, and deploy services with. I rented eight servers, each with 16 vCPUs
(128 vCPUs total), and connected them over a private network.</p>
<p>I picked one server to be the <a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/#manager-nodes">manager node</a>.
On this server, I ran this to initialize the swarm:</p>
<div><pre tabindex="0"><code data-lang="bash">docker swarm init --advertise-addr 10.0.0.2
</code></pre></div><p>This command sets up the swarm and prints a command to run on the worker nodes to connect them to
the manager. Each worker node joined using the token and the manager’s address:</p>
<div><pre tabindex="0"><code data-lang="bash">docker swarm join --token SWARM_TOKEN 10.0.0.2:2377
</code></pre></div><p>I deployed the container images, which I had pushed to GHCR, and pulled with
<code>--with-registry-auth</code> to allow access from the server to GHCR.
There were two images, the <code>api</code> image and the <code>worker</code> image. The API managed a list of
search areas (the areas around the points found from overpass turbo), giving
search areas to workers, and expanding the search radius by 500 meters when yurts were found.
The workers requested search areas from the API and sent back a list of yurts found within the
search areas.</p>
<h4 id="api">API</h4>
<p>I used FastAPI to build the API, in which there were two routes.</p>
<ul>
<li>GET /search-area - Workers sent a request to this route to get a search area to search.</li>
</ul>
<p>This route first checks if there are any stale areas, where a worker had requested a search area
but never finished it. The workers should send periodic health checks to the API, if this fails then
it will return the search area to a different worker after one minute.</p>
<div><pre tabindex="0"><code data-lang="python"><span>stale_area</span> <span>=</span> <span>(</span>
    <span>db</span><span>.</span><span>query</span><span>(</span><span>SearchArea</span><span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>SearchArea</span><span>.</span><span>searching</span> <span>==</span> <span>True</span><span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>SearchArea</span><span>.</span><span>health_check</span> <span>&lt;</span> <span>one_minute_ago</span><span>)</span>
    <span>.</span><span>with_for_update</span><span>()</span>
    <span>.</span><span>first</span><span>()</span>
<span>)</span>
</code></pre></div><p>If there are no stale search areas, then a new point will be selected at random, and the search area
will be increased if there have been previous searches.</p>
<div><pre tabindex="0"><code data-lang="python"><span>point</span> <span>=</span> <span>(</span>
    <span>db</span><span>.</span><span>query</span><span>(</span><span>Point</span><span>)</span>
    <span>.</span><span>options</span><span>(</span><span>joinedload</span><span>(</span><span>Point</span><span>.</span><span>search_areas</span><span>))</span>
    <span>.</span><span>filter</span><span>(</span><span>Point</span><span>.</span><span>searched</span> <span>==</span> <span>False</span><span>)</span>
    <span>.</span><span>filter</span><span>(</span><span>~</span><span>Point</span><span>.</span><span>search_areas</span><span>.</span><span>any</span><span>(</span><span>SearchArea</span><span>.</span><span>searched</span> <span>==</span> <span>False</span><span>))</span>
    <span>.</span><span>order_by</span><span>(</span><span>func</span><span>.</span><span>random</span><span>())</span>
    <span>.</span><span>first</span><span>()</span>
<span>)</span>

<span>if</span> <span>not</span> <span>point</span><span>:</span>
    <span>raise</span> <span>HTTPException</span><span>(</span>
        <span>status_code</span><span>=</span><span>404</span><span>,</span> <span>detail</span><span>=</span><span>&#34;No available point to search&#34;</span><span>)</span>

<span>previous_areas</span> <span>=</span> <span>[</span><span>sa</span> <span>for</span> <span>sa</span> <span>in</span> <span>point</span><span>.</span><span>search_areas</span><span>]</span>
<span>if</span> <span>previous_areas</span><span>:</span>
    <span>max_meters</span> <span>=</span> <span>max</span><span>(</span><span>area</span><span>.</span><span>meters</span> <span>for</span> <span>area</span> <span>in</span> <span>previous_areas</span><span>)</span>
    <span>new_meters</span> <span>=</span> <span>max_meters</span> <span>+</span> <span>500</span>
<span>else</span><span>:</span>
    <span>new_meters</span> <span>=</span> <span>500</span>
</code></pre></div><p>A <code>SearchArea</code> has a list of tiles that are inside it. Each <code>Tile</code> has as status of <code>searched</code>.
I used geopandas, as shown earlier, to generate a bounding box over the search area and create a list
of tiles. For each of these tiles, I check the database to see if they have already been created + searched.
If they haven’t then they are upserted and assigned to the search area.</p>
<div><pre tabindex="0"><code data-lang="python"><span>created_tiles</span> <span>=</span> <span>(</span>
    <span>db</span><span>.</span><span>query</span><span>(</span><span>Tile</span><span>)</span>
    <span>.</span><span>filter</span><span>(</span>
        <span>tuple_</span><span>(</span><span>Tile</span><span>.</span><span>x</span><span>,</span> <span>Tile</span><span>.</span><span>y</span><span>,</span> <span>Tile</span><span>.</span><span>z</span><span>)</span><span>.</span><span>in_</span><span>(</span>
            <span>[(</span><span>tile</span><span>[</span><span>&#34;x&#34;</span><span>],</span> <span>tile</span><span>[</span><span>&#34;y&#34;</span><span>],</span> <span>tile</span><span>[</span><span>&#34;z&#34;</span><span>])</span>
             <span>for</span> <span>tile</span> <span>in</span> <span>tiles_to_create</span><span>]</span>
        <span>)</span>
    <span>)</span>
    <span>.</span><span>all</span><span>()</span>
<span>)</span>

<span>new_area</span><span>.</span><span>tiles</span><span>.</span><span>extend</span><span>(</span><span>created_tiles</span><span>)</span>
</code></pre></div><p>The route returns the search area, containing a list of tiles to search.</p>
<ul>
<li>POST /search-area/:id - Workers sent a request containing the yurts to this route.</li>
</ul>
<p>This route inserts the yurts into the database, and marks the <code>Point</code>, <code>SearchArea</code>, and <code>Tile</code> as
searched as needed. The <code>Point</code> gets marked as searched if no yurts are found, and the <code>SearchArea</code>
and <code>Tile</code> are marked as searched.</p>
<div><pre tabindex="0"><code data-lang="python"><span>if</span> <span>len</span><span>(</span><span>yurts_to_create</span><span>)</span> <span>&gt;</span> <span>0</span><span>:</span>
    <span>stmt</span> <span>=</span> <span>insert</span><span>(</span><span>Yurt</span><span>)</span><span>.</span><span>values</span><span>(</span><span>yurts_to_create</span><span>)</span>
    <span>stmt</span> <span>=</span> <span>stmt</span><span>.</span><span>on_conflict_do_nothing</span><span>(</span>
        <span>index_elements</span><span>=</span><span>[</span><span>&#34;longitude&#34;</span><span>,</span> <span>&#34;latitude&#34;</span><span>])</span>
    <span>db</span><span>.</span><span>execute</span><span>(</span><span>stmt</span><span>)</span>
<span>else</span><span>:</span>
    <span>db</span><span>.</span><span>execute</span><span>(</span>
        <span>update</span><span>(</span><span>Point</span><span>)</span><span>.</span><span>where</span><span>(</span>
            <span>exists</span><span>()</span><span>.</span><span>where</span><span>(</span>
                <span>(</span><span>SearchArea</span><span>.</span><span>point_id</span> <span>==</span> <span>Point</span><span>.</span><span>id</span><span>)</span> <span>&amp;</span> <span>(</span><span>Point</span><span>.</span><span>id</span> <span>==</span> <span>id</span><span>)</span>
            <span>)</span>
        <span>)</span><span>.</span><span>values</span><span>(</span>
            <span>searched</span><span>=</span><span>True</span><span>,</span>
        <span>)</span>
    <span>)</span>
</code></pre></div><h4 id="worker">Worker</h4>
<p>The worker script ran in a loop until it encountered the <code>No available point to search</code> error.
This loop consisted of requesting the <code>/search-area</code> to get a list of tiles to search, downloading
each tile, then passing the tile image to the model to detect yurts. Finally, the worker sends a
list of yurts to the API.</p>
<div><pre tabindex="0"><code data-lang="python"><span>def</span> <span>find_yurts</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>):</span>
    <span>filepath</span> <span>=</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>&#34;tiles&#34;</span><span>,</span> <span>&#34;</span><span>{}</span><span>_</span><span>{}</span><span>_</span><span>{}</span><span>.jpeg&#34;</span><span>.</span><span>format</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>))</span>

    <span>results</span> <span>=</span> <span>model</span><span>(</span><span>filepath</span><span>,</span> <span>imgsz</span><span>=</span><span>256</span><span>)</span>

    <span>yurts</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>result</span> <span>in</span> <span>results</span><span>:</span>
        <span>for</span> <span>prediction</span> <span>in</span> <span>result</span><span>.</span><span>boxes</span><span>:</span>
            <span>xyxy</span> <span>=</span> <span>prediction</span><span>.</span><span>xyxy</span><span>[</span><span>0</span><span>]</span><span>.</span><span>tolist</span><span>()</span>

            <span># Find center of the bounding box</span>
            <span>pixel_x</span> <span>=</span> <span>xyxy</span><span>[</span><span>0</span><span>]</span> <span>+</span> <span>(</span><span>xyxy</span><span>[</span><span>2</span><span>]</span> <span>-</span> <span>xyxy</span><span>[</span><span>0</span><span>])</span> <span>/</span> <span>2</span>
            <span>pixel_y</span> <span>=</span> <span>xyxy</span><span>[</span><span>1</span><span>]</span> <span>+</span> <span>(</span><span>xyxy</span><span>[</span><span>3</span><span>]</span> <span>-</span> <span>xyxy</span><span>[</span><span>1</span><span>])</span> <span>/</span> <span>2</span>

            <span>lat</span><span>,</span> <span>lon</span> <span>=</span> <span>tile_xyz_to_lonlat</span><span>(</span><span>x</span><span>,</span> <span>y</span><span>,</span> <span>z</span><span>,</span> <span>pixel_x</span><span>,</span> <span>pixel_y</span><span>)</span>

            <span>yurts</span><span>.</span><span>append</span><span>({</span>
                <span>&#34;latitude&#34;</span><span>:</span> <span>lat</span><span>,</span>
                <span>&#34;longitude&#34;</span><span>:</span> <span>lon</span><span>,</span>
                <span>&#34;score&#34;</span><span>:</span> <span>prediction</span><span>.</span><span>conf</span><span>.</span><span>item</span><span>(),</span>
            <span>})</span>

    <span>return</span> <span>yurts</span>
</code></pre></div><p>I began scaling this service slowly and eventually ramped up to 120 workers running in parallel
using <code>docker service scale worker=120</code>. Each container processed its assigned tile, and if yurts
were found, posted their coordinates to the API.</p>
<h3 id="the-resulting-count">The resulting count</h3>
<p>After searching a couple million tiles I downloaded the yurt dataset, which I uploaded <a href="https://cdn.monroeclinton.com/yurts.json">here (12mb file)</a>.
In total I found 172,689 yurts with a prediction score of greater than 40%.</p>
<p>Perhaps there’s some lonesome yurts far in the Gobi Desert or the Altai Mountains I missed, so we
could add a hundred or so for those. I could have also done more like
providing image context and training on more data from smaller towns, but I only have so much time.</p>
<p>For fun I did some querying using <a href="https://postgis.net/">PostGIS</a> to find areas with high concentrations
of yurts. Generally I found places that are hotels or remote areas near mines.</p>
<p><img src="https://monroeclinton.com/counting-all-yurts-in-mongolia/many-yurts.jpeg" alt="Many yurts"/></p>
<blockquote>
<p>Maps Data: Google © 2025 Airbus, CNES / Airbus, Maxar Technologies</p>
</blockquote>
<h2 id="the-people-of-the-yurts">The people of the yurts</h2>
<p>Historically, yurts have been a home for the nomadic peoples of the steppe to live. As
Mongolia developed into the modern world, the usage of yurts changed with the country. For example,
I found a reference to yurts being used as makeshift schools in the early 1900s. This period was the
start of the transformation from a nomadic herder society to an urban industrial society.</p>
<blockquote>
In the rural areas, in addition to the existing 60 scribe schools, at least 49 state primary schools were established by 1917. They were largely housed in yurts and financed with state, municipal, and private funds. (Steiner-Khamsi and Stolpe 36)
</blockquote>

<p>This reflects the developmental history of Mongolia, and how people are adjusting to the modern
world. Mongolia has transitioned from a mostly nomadic herder society, to a mostly urbanized
industrial society. As people transition from one system of life to another, remnants of their old
system persist. Housing and infrastructure are expensive, so as Mongolia transformed, once nomadic
herders took their yurts to urban areas and continued living in them.</p>
<blockquote>
The 51 percent urban population reported in the 1979 census
reflected rapid migration to the cities in the 1970s. The influx of
rural people created housing problems, among them long waits for
assignment to an apartment, expansion of ger districts on the edges
of built-up areas, and pressure to invest in more housing, roads,
and other urban infrastructure. (Worden et al. 86)
</blockquote>

<p>Due to the large number of people moving to urban locations, it has been difficult for the government to
build the infrastructure needed for them. The informal settlements that grew from this difficulty
are now known as ger districts. There have been many efforts to formalize and develop these areas.
The Law on Allocation of Land to Mongolian Citizens for Ownership, passed in 2002, allowed for
existing ger district residents to formalize the land they settled, and allowed for others to
receive land from the government into the future.</p>
<p>Along with the privatization of land, the Mongolian government has been pushing for the development
of ger districts into areas with housing blocks connected to utilities. The plan for this was
published in 2014 as Ulaanbaatar 2020 Master Plan and Development Approaches for 2030. Although
progress has been slow (Choi and Enkhbat 7), they have been making progress in building housing blocks in ger
distrcts. Residents of ger districts sell or exchange their plots to developers who then build housing
blocks on them. Often this is in exchange for an apartment in the building, and often the value of the
apartment is less than the land they originally had (Choi and Enkhbat 15).</p>
<p>Based on what I’ve read about the ger districts, they have been around since at least the 1970s,
and progress on developing them has been slow. When ineffective policy results in a large chunk of
the populace generationally living in yurts on the outskirts of urban areas, it’s clear that there
is failure.
One of the most important functions of government is inspiring the citizenry to achieve greatness.
Most governments around the world fail in this, but we should all work towards it. I think a step
the Mongolian government could take for this is to analyze which policy failures have led to such
slow progress on the ger district issue.</p>
<p>The Mongolian government’s long-term vision is to provide utilities and good housing
for these areas. Although I can’t contribute anything to this vision, I wish for the best
success in this plan.
I’m glad to have learned about a country and people I used to know nothing about. Hopefully in the
future I’ll study more about Mongolia, but for now I’m off to my next project.</p>
<h3 id="further-questions">Further questions</h3>
<ul>
<li>What causes Mongolia and other countries to urbanize and industrialize?</li>
<li>Why do some Mongolians head to the cities and others stay?</li>
<li>What challenges does the Mongolian government face in developing ger districts?</li>
<li>What causes the difference in speed of development between countries?</li>
</ul>

<ul>
<li><p>Choi, Mack Joong, and Urandulguun Enkhbat. “Distributional Effects of Ger Area Redevelopment in Ulaanbaatar, Mongolia.” International Journal of Urban Sciences, vol. 24, no. 1, Jan. 2020, pp. 50–68. DOI.org (Crossref), <a href="https://doi.org/10.1080/12265934.2019.1571433">https://doi.org/10.1080/12265934.2019.1571433</a>.</p>

</li>
<li><p>City of Ulaanbaatar. <em>Ulaanbaatar 2020 Master Plan and Development Approach for 2030.</em> 2014.</p>

</li>
<li>

</li>
<li><p>Steiner-Khamsi, Gita, and Ines Stolpe. <em>Educational Import: Local Encounters with Global Forces in Mongolia.</em> 1st ed, Palgrave Macmillan, 2006.</p>

</li>
<li><p>Worden, Robert L, et al. <em>Mongolia: A Country Study.</em> Washington, D.C.: Federal Research Division, Library of Congress: For sale by the Supt. of Docs., U.S. G.P.O, 1991. Pdf. Retrieved from the Library of Congress, &lt;www.loc.gov/item/90006289/&gt;.</p>

</li>
<li><p>Yang, Jeasurk, et al. <em>Poverty Mapping in Mongolia with AI-Based Ger Detection Reveals Urban Slums Persist after the COVID-19 Pandemic.</em> arXiv:2410.09522, arXiv, 12 Oct. 2024. <em>arXiv.org</em>, <a href="https://doi.org/10.48550/arXiv.2410.09522">https://doi.org/10.48550/arXiv.2410.09522</a>.</p>

</li>
</ul>

        </div></div>
  </body>
</html>
