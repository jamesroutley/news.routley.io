<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://arhamjain.com/2021/11/22/nim-simple-chat.html">Original</a>
    <h1>Building a simple room-based chat application in Nim (using HTMX)</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>This is going to be a bit of a weird tutorial - rather than walking you through the natural progression of how one would build an application, I’ll instead be explaining the code step by step of the existing application. This is done for two reasons: first, it’s easier to write a tutorial. Second, if you just want to see the final code, you can skip ahead and not have to bear with me as I explain things that you may already know.</p>

<p>A quick note - I use the word templating and template a bit in this explanation. A <code>template</code> refers to a construct in Nim that allows for code substitution. Templating refers to translating our data into HTML, using Karax’s DSL in this instance.</p>

<p>With that out of the way, let’s get started! The final code can be found <a href="https://github.com/ajusa/simple-chat">in this Github repo</a>. Here are a few screenshots of what we’ll be building.</p>

<p><img src="https://arhamjain.com/images/2021/simple-chat-home.png" alt="sign in"/></p>

<p><img src="https://arhamjain.com/images/2021/simple-chat-room.png" alt="chatroom"/></p>

<div><div><pre><code><span>import</span> <span>std</span><span>/[</span><span>strutils</span><span>,</span> <span>asyncdispatch</span><span>,</span> <span>sets</span><span>,</span> <span>hashes</span><span>,</span> <span>json</span><span>]</span>
<span>import</span> <span>karax</span><span>/[</span><span>karaxdsl</span><span>,</span> <span>vdom</span><span>]</span><span>,</span> <span>jester</span><span>,</span> <span>ws</span><span>,</span> <span>ws</span><span>/</span><span>jester_extra</span>
</code></pre></div></div>
<p>On the first line we’ve got stdlib imports, and the second line has all of the external libraries we’ll be using. To install them, just run</p>

<div><div><pre><code>nimble <span>install </span>karax jester ws
</code></pre></div></div>

<div><div><pre><code><span>converter</span> <span>toString</span><span>(</span><span>x</span><span>:</span> <span>VNode</span><span>):</span> <span>string</span> <span>=</span> <span>$</span><span>x</span>
<span>type</span> <span>User</span> <span>=</span> <span>object</span>
  <span>name</span><span>:</span> <span>string</span>
  <span>socket</span><span>:</span> <span>WebSocket</span>
<span>proc </span><span>hash</span><span>(</span><span>x</span><span>:</span> <span>User</span><span>):</span> <span>Hash</span> <span>=</span> <span>hash</span><span>(</span><span>x</span><span>.</span><span>name</span><span>)</span>
<span>var</span> <span>chatrooms</span> <span>=</span> <span>initTable</span><span>[</span><span>string</span><span>,</span> <span>HashSet</span><span>[</span><span>User</span><span>]]</span><span>()</span>
</code></pre></div></div>

<p>Now, we’ve got some real code. The first line is a converter. In Nim, converters are automatically ran to convert between types if needed. In our case, we are converting a “VNode” to a string whenever it is required. A VNode is just a DOM element, which is what the Karax DSL uses to represent HTML. However, Jester only responds with string. With this converter, we can simply <code>resp vnode</code> and have it automatically get converted.</p>

<p>The next few lines simply set up the data structures for this chat application. A user consists of a username, and the websocket corresponding to their computer. We define a hash function for this type so that we can use it in a hashset. Then, we define the core in-memory variable that’ll be storing all of our users and rooms. It’s a map from string, to HashSet[User]. In other words, each room name maps to a set of users that are connected.</p>

<div><div><pre><code><span>template</span> <span>index</span><span>*</span><span>(</span><span>rest</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>buildHtml</span><span>(</span><span>html</span><span>(</span><span>lang</span> <span>=</span> <span>&#34;en&#34;</span><span>)):</span>
    <span>head</span><span>:</span>
      <span>meta</span><span>(</span><span>charset</span> <span>=</span> <span>&#34;UTF-8&#34;</span><span>,</span> <span>name</span><span>=</span><span>&#34;viewport&#34;</span><span>,</span> <span>content</span><span>=</span><span>&#34;width=device-width, initial-scale=1&#34;</span><span>)</span>
      <span>link</span><span>(</span><span>rel</span> <span>=</span> <span>&#34;stylesheet&#34;</span><span>,</span> <span>href</span> <span>=</span> <span>&#34;https://unpkg.com/@picocss/pico@latest/css/pico.min.css&#34;</span><span>)</span>
      <span>script</span><span>(</span><span>src</span> <span>=</span> <span>&#34;https://unpkg.com/htmx.org@1.6.0&#34;</span><span>)</span>
      <span>title</span><span>:</span> <span>text</span> <span>&#34;Simple Chat&#34;</span>
    <span>body</span><span>:</span>
      <span>nav</span><span>(</span><span>class</span><span>=</span><span>&#34;container-fluid&#34;</span><span>):</span>
        <span>ul</span><span>:</span> <span>li</span><span>:</span> <span>a</span><span>(</span><span>href</span> <span>=</span> <span>&#34;/&#34;</span><span>,</span> <span>class</span><span>=</span><span>&#34;secondary&#34;</span><span>):</span> <span>strong</span><span>:</span> <span>text</span> <span>&#34;Simple Chat&#34;</span>
      <span>main</span><span>(</span><span>class</span><span>=</span><span>&#34;container&#34;</span><span>):</span> <span>rest</span>
</code></pre></div></div>
<p>Now we get into some of the templating/boilerplate. This snippet builds our “header” and takes in the rest of the page “rest” as input. Taking a closer look, we can see that we load a stylesheet (<a href="https://picocss.com/">PicoCSS</a>) and <a href="https://htmx.org/">HTMX</a>. We then create a quick navbar, all using the Karax DSL.</p>

<p>Note that this is a <code>template</code> and not a <code>proc</code>. So, anything that is passed in as the rest argument performs simple code substitution. We’ll see an example of that in a second.</p>

<div><div><pre><code><span>proc </span><span>chatInput</span><span>():</span> <span>VNode</span> <span>=</span> <span>buildHtml</span><span>(</span><span>input</span><span>(</span><span>name</span><span>=</span><span>&#34;message&#34;</span><span>,</span> <span>id</span><span>=</span><span>&#34;clearinput&#34;</span><span>,</span> <span>autofocus</span><span>=</span><span>&#34;&#34;</span><span>,</span> <span>required</span><span>=</span><span>&#34;&#34;</span><span>))</span>
<span>proc </span><span>sendAll</span><span>(</span><span>users</span><span>:</span> <span>HashSet</span><span>[</span><span>User</span><span>]</span><span>,</span> <span>msg</span><span>:</span> <span>string</span><span>)</span> <span>=</span>
  <span>for</span> <span>user</span> <span>in</span> <span>users</span><span>:</span> <span>discard</span> <span>user</span><span>.</span><span>socket</span><span>.</span><span>send</span><span>(</span><span>msg</span><span>)</span>
<span>template</span> <span>buildMessage</span><span>*</span><span>(</span><span>msg</span><span>:</span> <span>untyped</span><span>):</span> <span>untyped</span> <span>=</span>
  <span>buildHtml</span><span>(</span><span>tdiv</span><span>(</span><span>id</span><span>=</span><span>&#34;content&#34;</span><span>,</span> <span>hx</span><span>-</span><span>swap</span><span>-</span><span>oob</span><span>=</span><span>&#34;beforeend&#34;</span><span>)):</span>
    <span>tdiv</span><span>:</span> <span>msg</span>
</code></pre></div></div>
<p>We’ve got some helper procedures here. chatInput generates our input field using the Karax DSL that grabs focus. It’s also required, so that the user can’t just spam sending empty messages. <code>sendAll</code> just sends a string to all of the users in a room by iterating over them.</p>

<p><code>buildMessage</code> is another template that we can use to help us reuse code for building HTML. You’ll also notice an interesting attribute: <code>hx-swap-oob</code>. The documentation for that can be found <a href="https://htmx.org/attributes/hx-swap-oob/">here</a>, but in a nutshell what this does is put the innerHTML of this <code>&lt;div&gt;</code> into a new element, which is the last child of anything matching an id of “content”. If you’ve never used HTMX you may think that this is a very ugly way of doing things, but trust me: it works.</p>

<p>In other words, any time the client sees this div being returned, it appends the content into the end of the DOM element with an id of “content”.</p>

<div><div><pre><code><span>routes</span><span>:</span>
  <span>get</span> <span>&#34;/&#34;</span><span>:</span>
    <span>let</span> <span>html</span> <span>=</span> <span>index</span><span>:</span>
      <span>h1</span><span>:</span> <span>text</span> <span>&#34;Join a room!&#34;</span>
      <span>form</span><span>(</span><span>action</span><span>=</span><span>&#34;/chat&#34;</span><span>,</span> <span>`</span><span>method</span><span>`</span><span>=</span><span>&#34;get&#34;</span><span>):</span>
        <span>label</span><span>:</span>
          <span>text</span> <span>&#34;Room&#34;</span>
          <span>input</span><span>(</span><span>type</span><span>=</span><span>&#34;text&#34;</span><span>,</span> <span>name</span><span>=</span><span>&#34;room&#34;</span><span>)</span>
        <span>label</span><span>:</span>
          <span>text</span> <span>&#34;Username&#34;</span>
          <span>input</span><span>(</span><span>type</span><span>=</span><span>&#34;text&#34;</span><span>,</span> <span>name</span><span>=</span><span>&#34;name&#34;</span><span>)</span>
        <span>input</span><span>(</span><span>type</span><span>=</span><span>&#34;submit&#34;</span><span>,</span> <span>value</span><span>=</span><span>&#34;Join&#34;</span><span>)</span>
    <span>resp</span> <span>html</span>
</code></pre></div></div>
<p>Finally, some Jester code! This is the index page, where we can join a room. You’ll notice we use our <code>index</code> template form earlier, to help us build the first part of the page, before we insert the rest of it. This code is pretty self explanatory as it’s just HTML, but we’re creating a form that asks for a room name and a username. Submitting this form will then send a <code>GET</code> request to <code>/chat</code>.</p>

<div><div><pre><code>  <span>get</span> <span>&#34;/chat&#34;</span><span>:</span>
    <span>let</span> <span>html</span> <span>=</span> <span>index</span><span>:</span>
      <span>h1</span><span>:</span> <span>text</span> <span>@</span><span>&#34;room&#34;</span>
      <span>tdiv</span><span>(</span><span>hx</span><span>-</span><span>ws</span><span>=</span><span>&#34;connect:/chat/&#34;</span> <span>&amp;</span> <span>@</span><span>&#34;room&#34;</span> <span>&amp;</span> <span>&#34;/&#34;</span> <span>&amp;</span> <span>@</span><span>&#34;name&#34;</span><span>):</span>
        <span>p</span><span>(</span><span>id</span><span>=</span><span>&#34;content&#34;</span><span>)</span>
        <span>form</span><span>(</span><span>hx</span><span>-</span><span>ws</span><span>=</span><span>&#34;send&#34;</span><span>,</span> <span>id</span><span>=</span><span>&#34;message&#34;</span><span>):</span> <span>chatInput</span><span>()</span>
    <span>resp</span> <span>html</span>
</code></pre></div></div>
<p>After submitting that form, we end up in this bit of code. Based on the <code>name</code> attributes from the earlier snippet, we can access the username and room the user submitted with <code>@&#34;name&#34;</code> and <code>@&#34;room&#34;</code>. You’ll notice the <code>hx-ws</code> attribute here as well, from HTMX. The <a href="https://htmx.org/attributes/hx-ws/">documentation for it</a> says it will try and open a websocket connection to the URL it is given.</p>

<p>Moving on, we see a paragraph with the id “content”. This is where the earlier snippet can be used to append HTML inside of that tag. Within this div, we have a form with the attribute <code>hx-ws</code> again, only this time it is set to “send”. Looking at the documentation from earlier shows that any time this form is submitted, a JSON response will be send to the closest opened websocket. In other words, submitting this form will send something like</p>

<div><div><pre><code><span>{</span><span>&#34;message&#34;</span><span>:</span><span> </span><span>&#34;here is my message!&#34;</span><span>}</span><span>
</span></code></pre></div></div>
<p>over the websocket connection to the server.</p>

<div><div><pre><code>  <span>get</span> <span>&#34;/chat/@room/@name&#34;</span><span>:</span>
    <span>var</span> <span>ws</span> <span>=</span> <span>await</span> <span>newWebSocket</span><span>(</span><span>request</span><span>)</span>
    <span>var</span> <span>user</span> <span>=</span> <span>User</span><span>(</span><span>name</span><span>:</span> <span>@</span><span>&#34;name&#34;</span><span>,</span> <span>socket</span><span>:</span> <span>ws</span><span>)</span>
</code></pre></div></div>
<p>Here’s where we handle the websocket connection. We use <a href="https://github.com/treeform/ws">treeform’s library</a> to create a new websocket, and then we create a new User that corresponds to that websocket. The following code is a bit tricky, as it uses the helpers we defined earlier.</p>

<div><div><pre><code>    <span>try</span><span>:</span>
      <span>chatrooms</span><span>.</span><span>mgetOrPut</span><span>(</span><span>@</span><span>&#34;room&#34;</span><span>,</span> <span>initHashSet</span><span>[</span><span>User</span><span>]</span><span>()).</span><span>incl</span><span>(</span><span>user</span><span>)</span>
      <span>let</span> <span>joined</span> <span>=</span> <span>buildMessage</span><span>:</span>
        <span>italic</span><span>:</span> <span>text</span> <span>user</span><span>.</span><span>name</span>
        <span>italic</span><span>:</span> <span>text</span> <span>&#34; has joined the room&#34;</span>
      <span>chatrooms</span><span>[@</span><span>&#34;room&#34;</span><span>]</span><span>.</span><span>sendAll</span><span>(</span><span>joined</span><span>)</span>
      <span>while</span> <span>user</span><span>.</span><span>socket</span><span>.</span><span>readyState</span> <span>==</span> <span>Open</span><span>:</span>
        <span>let</span> <span>sentMessage</span> <span>=</span> <span>(</span><span>await</span> <span>user</span><span>.</span><span>socket</span><span>.</span><span>receiveStrPacket</span><span>()).</span><span>parseJson</span><span>[</span><span>&#34;message&#34;</span><span>]</span>
        <span>discard</span> <span>user</span><span>.</span><span>socket</span><span>.</span><span>send</span><span>(</span><span>chatInput</span><span>())</span>
        <span>let</span> <span>reply</span> <span>=</span> <span>buildMessage</span><span>:</span>
          <span>bold</span><span>:</span> <span>text</span> <span>user</span><span>.</span><span>name</span>
          <span>text</span> <span>&#34;: &#34;</span> <span>&amp;</span> <span>sentMessage</span><span>.</span><span>getStr</span><span>()</span>
        <span>chatrooms</span><span>[@</span><span>&#34;room&#34;</span><span>]</span><span>.</span><span>sendAll</span><span>(</span><span>reply</span><span>)</span>
</code></pre></div></div>
<p>Oh boy, here we go. Well, everything is wrapped in a <code>try</code> block first of all. First, we create a new HashSet in that table we defined earlier if it didn’t already exist. We also add the user to the HashSet that holds the users for the given room. The following lines generate the message that is sent on join. We use the <code>buildMessage</code> template to ensure it is appended to the end of the main content. Then, we use the <code>sendAll</code> proc to ensure it is sent to every user connected to that room.</p>

<p>The following while loop only runs while the user is connected (readyState == Open). Remember, we are using Nim’s async module, so the loop is non-blocking. We wait for a message to be sent over websockets, parse the JSON, and grab the “message” key. I talked about the JSON format a bit earlier.</p>

<p>The following line is weird - we send the chatInput back to the client we just got a message from. If you remember from earlier, anything that is sent over the websocket will have it’s id attribute checked, and the content will affect the DOM. In this case, the element that is sent over will replace the <code>input</code> tag that the user has on their machine. This is done for two reasons:</p>

<ol>
  <li>The input tag that the user has on their machine has some text in it (the message that they sent). By sending over a blank one, we clear the message.</li>
  <li>Due to the <code>autofocus</code> attribute, we regain focus of the text input.</li>
</ol>

<p>Normally, you’d probably clear the input with Javascript. Since we’re using HTMX however, this is the recommended way of doing things. Additionally, imagine that you had to filter the messages (for example, to check for slurs). In this way, you’d be able to quickly and easily clear the input and include a message along with the cleared input telling the user why the message wasn’t accepted.</p>

<p>After that somewhat lengthy explanation, we build the message itself in Karax’s DSL, using our buildMessage helper. Then, we send the message to all the connected users.</p>

<div><div><pre><code>    <span>except</span><span>:</span>
      <span>chatrooms</span><span>[@</span><span>&#34;room&#34;</span><span>]</span><span>.</span><span>excl</span><span>(</span><span>user</span><span>)</span>
      <span>let</span> <span>left</span> <span>=</span> <span>buildMessage</span><span>:</span>
        <span>italic</span><span>:</span> <span>text</span> <span>user</span><span>.</span><span>name</span>
        <span>italic</span><span>:</span> <span>text</span> <span>&#34; has left the room&#34;</span>
      <span>chatrooms</span><span>[@</span><span>&#34;room&#34;</span><span>]</span><span>.</span><span>sendAll</span><span>(</span><span>left</span><span>)</span>
    <span>resp</span> <span>&#34;&#34;</span>
</code></pre></div></div>
<p>Remember how all that code was wrapped in a <code>try</code> block? Here’s the matching <code>except</code>. An exception in this code will usually be thrown if there was some sort of error with the websocket. If you wanted to be more precise you could catch the specific exceptions, but as this is SIMPLE chat I didn’t bother.</p>

<p>If there’s an error with the websocket, we take that to mean that the user has disconnected. We remove them from the chat room that they were in. Then, we build a message to show that the user has left the room. Finally, we send that to all of the remaining clients in the room! The last <code>resp</code> is there to make sure that Jester has something to terminate the connection with for the user that left.</p>

<h2 id="conclusion">Conclusion</h2>

<p>And that’s it! Around 70 lines of code to build a room based chat using nothing but HTMX and Jester! The best part of this code? You don’t need to know or understand Javascript to work with this stack, it’s fantastic. The code surface for bugs on the client side is pretty much 0, but on the server side it does go up a bit with the <code>hx-swap</code> logic. Still, at least the logic is only in one codebase.</p>

<p>This stack isn’t for everyone, and I’m not claiming that you can build every sort of application with it. I consider it to be very powerful for what it can accomplish without a whole lot of code. I hope that this was informational and helpful!</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
