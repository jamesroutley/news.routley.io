<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://joyofrails.com/articles/simple-trick-to-understand-ruby-lazy-enumerator">Original</a>
    <h1>A visual demo of Ruby&#39;s lazy enumerator</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/Article">
        <div itemprop="articleBody">
      <p>In this article, we&#39;ll explore a simple visual trick to help understand how lazy enumeration works in Ruby.</p> <p>Lazy enumeration may seem like an abstract concept at first. It might be difficult to conceptualize. But taking a moment to get familiar with the lazy enumerator pays dividends. <code>Enumerator::Lazy</code> is extremely useful in scenarios where you want to build complex pipelines of data transformations or when working with large datasets.</p> <p>Let’s see how.</p> <h2 id="enumerable-is-eager-by-default"><a href="#enumerable-is-eager-by-default">      <svg version="1.1" aria-hidden="true" stroke="currentColor" viewBox="0 0 16 16" width="28" height="28">
        <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
      </svg>
<span>Link to heading</span> </a>Enumerable is eager by default</h2> <p>Consider an Enumerable method chain.</p> <div><div><pre><code><span>7</span><span>.</span><span>times</span><span>.</span><span>map</span> <span>{</span> <span>|</span><span>n</span><span>|</span> <span>n</span> <span>+</span> <span>1</span> <span>}.</span><span>select</span><span>(</span><span>&amp;</span><span>:even?</span><span>).</span><span>take</span><span>(</span><span>3</span><span>)</span>
<span># =&gt; [2, 4, 6]</span>
</code></pre> </div></div><p>At each step of the chain, method calls are evaluated <em>eagerly</em>. Each element from the previous step must be processed before moving on to the next step.</p> <p>I think of this as &#34;vertical&#34; enumeration.</p> <p>To illustrate what I mean, I’ve included a visual demonstration below. Press Play/Pause/Reset to interact with the animation.</p> <p>See it?</p> <p>The collection of items is represented as a vertical column of objects. The <code>map</code> operation computes a new collection, represented by the second column. The <code>select</code> operation filters out some objects to produce the third column. The <code>take</code> operation picks the first 3 to yield the last column. Each column forms vertically one by one. Each intermediate collection is constructed before moving to the next.</p> <p>This represents the <em>eagerness</em> of default enumeration in Ruby.</p> <h2 id="making-enumeration-lazy"><a href="#making-enumeration-lazy">      <svg version="1.1" aria-hidden="true" stroke="currentColor" viewBox="0 0 16 16" width="28" height="28">
        <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
      </svg>
<span>Link to heading</span> </a>Making enumeration lazy</h2> <p>Now let’s consider <em>laziness</em>. First, we use the <code>Enumerable#lazy</code> method to produce a lazy enumerator.</p> <div><div><pre><code><span>7</span><span>.</span><span>times</span><span>.</span><span>lazy</span>
<span># =&gt; #&lt;Enumerator::Lazy: ...&gt;</span>
</code></pre> </div></div><p>Methods like <code>to_a</code> or <code>force</code> convert a lazy enumerator back into a normal collection:</p> <div><div><pre><code><span>7</span><span>.</span><span>times</span><span>.</span><span>lazy</span><span>.</span><span>force</span>
<span># =&gt; [0, 1, 2, 3, 4, 5, 6]</span>
</code></pre> </div></div><p>Lazy enumeration is useful for working with large collections or expensive operations. It is even necessary in some cases, like enumerating an infinite Ruby range:</p> <div><div><pre><code><span>(</span><span>1</span><span>..</span><span>).</span><span>lazy</span><span>.</span><span>select</span><span>(</span><span>&amp;</span><span>:even?</span><span>).</span><span>take</span><span>(</span><span>3</span><span>).</span><span>force</span>
</code></pre> </div></div><p>Lazy enumeration flips the order of operations on its side. I visualize this as &#34;horizontal&#34; enumeration. Try it:</p> <p>Did you spot the difference? In the lazy enumeration demo, each object moves across the method chain one at time before evaluation of the next item begins.</p> <p>Here are the key insights: we may be able to run fewer operations and save memory, especially with large collections. We avoid performing any operations on subsequent items after the required 3 items are &#34;taken&#34; at the end of the chain. Fewer operations are performed since only a subset of items are processed. Laziness reduces the overall amount of work being done. We also avoid constructing intermediate collections at each step of the chain. This might be an important consideration, especially with large collections and memory constraints.</p> <p>With this visual in mind, you may be able to see how lazy enumerator can be helpful when working with large datasets or expensive operations. Lazy doesn’t make the operations faster but it may be a strategy to avoid unnecessary work.</p> <h2 id="ruby-works-hard-so-you-can-be-lazy"><a href="#ruby-works-hard-so-you-can-be-lazy">      <svg version="1.1" aria-hidden="true" stroke="currentColor" viewBox="0 0 16 16" width="28" height="28">
        <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
      </svg>
<span>Link to heading</span> </a>Ruby works hard so you can be lazy</h2> <p>Ruby actually redefines Enumerable methods in <code>Enumerator::Lazy</code> so they return another lazy enumerator instead of intermediate arrays or hashes. Intermediate methods in the lazy chain, like <code>map</code> and <code>select</code> in our example, immediately yield their current value. Methods like <code>take</code> control how many items complete the enumeration chain.</p> <p>A deeper dive is beyond the scope of this article, but if you’re curious to learn more about how Ruby implements laziness, look no further than Pat Shaughnessy’s <a href="https://patshaughnessy.net/2013/4/3/ruby-2-0-works-hard-so-you-can-be-lazy" title="" target="_blank" rel="noopener noreferrer">Ruby 2.0 Works Hard So You Can Be Lazy</a>. Though written with Ruby 2 in mind, the concepts are still applicable to Ruby 3 today.</p> <h2 id="reprise"><a href="#reprise">      <svg version="1.1" aria-hidden="true" stroke="currentColor" viewBox="0 0 16 16" width="28" height="28">
        <path d="M4 9h1v1h-1c-1.5 0-3-1.69-3-3.5s1.55-3.5 3-3.5h4c1.45 0 3 1.69 3 3.5 0 1.41-0.91 2.72-2 3.25v-1.16c0.58-0.45 1-1.27 1-2.09 0-1.28-1.02-2.5-2-2.5H4c-0.98 0-2 1.22-2 2.5s1 2.5 2 2.5z m9-3h-1v1h1c1 0 2 1.22 2 2.5s-1.02 2.5-2 2.5H9c-0.98 0-2-1.22-2-2.5 0-0.83 0.42-1.64 1-2.09v-1.16c-1.09 0.53-2 1.84-2 3.25 0 1.81 1.55 3.5 3 3.5h4c1.45 0 3-1.69 3-3.5s-1.5-3.5-3-3.5z"></path>
      </svg>
<span>Link to heading</span> </a>Reprise</h2> <p>Here’s the demo again with some controls to play with the speed and style of enumeration. You can use the Eager/Lazy toggle to switch between strategies. Use the slider to move manually forward and backward through the animation.</p> <p>Next time you’re dealing with a large dataset or you encounter <code>lazy</code> in the wild, perhaps visualizing the &#34;vertical&#34; vs &#34;horizontal&#34; operation analogy will help you understand how your Ruby behaves.</p> <p>Let me know if you found this visual helpful!</p> <turbo-frame id="poll_01jh250mxjefbxpjqpxpmmqpde" src="/share/polls/01jh250mxjefbxpjqpxpmmqpde"></turbo-frame><hr/><p>If you liked this article, please feel free to share it and <a href="#newsletter-signup" title="">subscribe</a> to hear more from me and get notified of new articles by email.</p> <p>Did you find a mistake or do you have questions about the content? You can <a href="https://joyofrails.com/cdn-cgi/l/email-protection#0b796478784b616472646d796a62677825686466" title="" target="_blank" rel="noopener noreferrer">send me an email</a>, connect with me on <a href="https://x.com/rossta" title="" target="_blank" rel="noopener noreferrer">Twitter</a>, <a href="https://bsky.app/profile/rossta.net" title="" target="_blank" rel="noopener noreferrer">Bluesky</a>, <a href="https://github.com/rossta" title="" target="_blank" rel="noopener noreferrer">Github</a>, <a href="https://ruby.social/@rossta" title="" target="_blank" rel="noopener noreferrer">Mastodon</a>, and/or <a href="https://www.linkedin.com/in/rosskaffenberger" title="" target="_blank" rel="noopener noreferrer">Linkedin</a>.</p> <p>Curious to peek behind the curtain and get a glimpse of the magic? <a href="https://github.com/joyofrails/joyofrails.com" title="" target="_blank" rel="noopener noreferrer">Joy of Rails is open source on Github</a>. Feel free to look through the code and contribute. </p><figure><img alt="Peas, please" loading="lazy" src="https://joyofrails.com/assets/articles/simple-trick-to-understand-ruby-lazy-enumerator/peas-9a96e710.webp"/><figcaption>Peas, please</figcaption></figure> 

          <h3>More articles to enjoy</h3>
          <ul>
              <li id="page_01jb9cdk61tstv7b2e4x5yfbby">
                <a href="https://joyofrails.com/articles/introducing-joy-of-rails" data-turbo-frame="_top"><p>Introducing Joy of Rails</p><p>Joy of Rails is a Rails application dedicated to teaching and showing programmers how to use Ruby on Rails and highlighting news, notes, and contributions relevant to the broader Ruby on Rails community. It is open sourced on Github.</p></a>
</li>              <li id="page_01jb9cdk7twvt0tnb6zjd4g9by">
                <a href="https://joyofrails.com/articles/custom-color-schemes-with-ruby-on-rails" data-turbo-frame="_top"><p>Custom Color Schemes with Ruby on Rails</p><p>You can edit the color scheme of this website right in content of this blog post. Play with the controls while we highlight the benefits of Rails, Hotwire, and CSS variables.</p></a>
</li>              <li id="page_01jb9cdjm0s8tt186ywxtje7bz">
                <a href="https://joyofrails.com/articles/web-push-notifications-from-rails" data-turbo-frame="_top"><p>Sending Web Push Notifications from Rails</p><p>An embedded Web Push demo and deep dive recipe for Web Push notifications for a Ruby on Rails application in advance of Rails 8 Action Notifier.</p></a>
</li>          </ul>
    </div>
  </article></div>
  </body>
</html>
