<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://friendshipcastle.zip/blog/glaceon">Original</a>
    <h1>How I learned to stop worrying and love userspace networking</h1>
    
    <div id="readability-page-1" class="page"><article><img src="https://elijer.github.io/images/glaceon.webp?__frsh_c=f13002cdf50ec9c6f593a6b1286e3e89c719c42e"/><p><small>Published on 8/28/2024 - 2 min read (641 words, 1095 tokens)</small><span><p>I like self-hosting things when I can. I have a little server running <a href="https://k3s.io/">k3s</a> at home that I run stuff on. I also have a few things in the cloud on <a href="https://fly.io">fly.io</a> (those cheap L40ses are great btw). I wanted my workloads on k3s to access the AI server on fly, but I didn&#39;t want to set up a VPN to my private network because mixing VPNs and Kubernetes is painful. I also didn&#39;t want to expose the AI server to the internet because it&#39;s not really meant to be public, and every time it gets poked, it costs me money.</p>
<p>Who says you need to do networking in the kernel though? Networking is just a program that takes in bytes and sometimes puts out different bytes. It&#39;s usually exposed to programs via the kernel and system calls, but there&#39;s nothing stopping you from doing it in userspace. This&#39;d give you all the fun of fucking about with the network but none of those pesky sudo commands or risks of breaking your network stack until you reboot.</p>
<p>So I looked around and found <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/golang.zx2c4.com/wireguard/tun/netstack">wireguard-go has support for netstack</a>, a userspace TCP/IP stack for Go programs. It&#39;s pretty poorly documented, but I figured out I could dial sockets once I loaded it with config and messed around with the &#34;uapi&#34; a bit. I had to bring in an ini parser to load the WireGuard configs, which is probably wrong, but it works enough.</p>
<p>Figuring out how to do that was a huge pain. I had to <code>strace</code> the <code>wg-quick</code> command and everything it was doing, but eventually I got the wire form of the config and I was able to make HTTP requests. I also found out that the uapi form had to pre-resolve DNS addresses, the hard way, of course.</p>
<p>I got things working and published it on the GitHubs as <a href="https://github.com/Twi/glaceon"><code>glaceon</code></a>. It&#39;s a Go program that exposes an HTTP reverse proxy to a given remote host over WireGuard. It&#39;s also the most minimal example I can find for how to use wireguard-go from userspace. Maybe how this works is is worth documenting in another post.</p>
<p>I was just spawning them manually on k3s when I was told that <a href="https://sdk.operatorframework.io/">operator-sdk</a> would let me make <a href="https://github.com/Twi/glaceon-operator">my own operator</a>. This is an opinionated template that makes it easy to program Kubernetes operators based on &#34;best practices&#34;. I kinda hate working with the Go in this framework, but at the very least everything is separated out and all the concerns are easily understood.</p>
<p>Once it was working, I was able to do something incredibly cheeky:</p>
<pre lang="yaml"><code>apiVersion: v1
kind: Namespace
metadata:
  name: flycast
---
apiVersion: glaceon.friendshipcastle.zip/v1alpha1
kind: MachineProxy
metadata:
  name: twi-ollama
  namespace: flycast
spec:
  org: personal
  region: yyz
  target: http://twi-ollama.flycast
  port: 80
</code></pre>
<p>This let my apps access my Ollama server via <code>http://twi-ollama.flycast</code> in k3s, just like they can on fly.</p>
<h2>Installing</h2>
<p>Installing this is easy. First, install the operator:</p>
<pre lang="sh"><code>kubectl apply -f \
  https://raw.githubusercontent.com/Twi/glaceon-operator/main/config/rendered.yaml
</code></pre>
<p>Then create a token for the fly org you want to expose to your Kubernetes cluster:</p>
<pre lang="sh"><code>fly tokens create org personal
</code></pre>
<p>Copy that into the Kubernetes secret <code>glaceon-operator</code> in the namespace <code>glaceon-operator-system</code> with the name <code>FLY_API_TOKEN</code>:</p>
<pre lang="sh"><code>kubectl create secret generic \
  glaceon-operator \
  --from-literal=FLY_API_TOKEN=&lt;your-token-value&gt; \
  -n glaceon-operator-system
</code></pre>
<p>Then you can create a MachineProxy resource:</p>
<pre lang="sh"><code>cat &lt;&lt;&#39;EOF&#39; | kubectl apply -f -
apiVersion: glaceon.friendshipcastle.zip/v1alpha1
kind: MachineProxy
metadata:
  name: twi-ollama
  namespace: flycast
spec:
  org: personal
  region: yyz
  target: http://twi-ollama.flycast
  port: 80
EOF
</code></pre>
<p>And that&#39;s it!</p>
</span></p></article></div>
  </body>
</html>
