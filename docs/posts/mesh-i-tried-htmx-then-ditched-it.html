<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ajmoon.com/posts/mesh-i-tried-htmx-then-ditched-it">Original</a>
    <h1>Mesh: I tried Htmx, then ditched it</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>There is a kind of exciting movement in Web dev right now. Web devs are talking about <a target="_blank" rel="noreferrer" href="https://allenpike.com/2025/javascript-fatigue-ssr">&#34;JavaScript Fatigue&#34;</a>, <a target="_blank" rel="noreferrer" href="https://blog.raed.dev/posts/framework-fatigue-the-real-reason-developers-get-angry-about-new-tech">&#34;Framework Fatigue&#34;</a>, the <a target="_blank" rel="noreferrer" href="https://viktorstanchev.com/posts/exploring-htmx-and-the-revival-of-hypermedia/">&#34;Revival of Hypermedia&#34;</a> and <a target="_blank" rel="noreferrer" href="https://hotwired.dev/">&#34;HTML Over The Wire&#34;</a>. In a word: we&#39;re asking ourselves why we&#39;re building HTML in JavaScript.</p>
<p>The figurehead for this movement is undoubtedly <a target="_blank" rel="noreferrer" href="https://htmx.org/">HTMX</a>. It shows that much of what we do in JavaScript could instead be done declaratively, with HTML attributes. If browsers adopted these semantics natively, many websites - and even apps - wouldn&#39;t need JavaScript at all. I love this idea! Writing HTML first and adding JS on top is the way the Web should work.</p>
<p>At present, we write JavaScript first, and we use it to generate HTML. How did we get it so backwards? I believe the answer is pretty straightforward: SPA frameworks are a joy to use. They impose structure, enforcing conventions, ultimately making it easy to keep concerns separated in one&#39;s mind.</p>
<p>My big problem with HTMX, as it stands, is that it lacks that structure. Taking a look at HTMX the first time, my reaction was: &#34;...so, declarative <a target="_blank" rel="noreferrer" href="https://jquery.com/">jQuery</a>.&#34; I could see, as if before my very eyes, the spaghetti that inevitably grows out of a library like this. HTMX leaves it up to the developer to impose discipline on their code, however they see fit.</p>
<p>So, I decided to accept the challenge. I want to do modular SSR the way HTMX encourages, but I want to do it with something like an SPA framework. I want nestable components, each with their own HTML, CSS, and JS - and back-end code - sitting side by side. I want there to be one, and only one, right way to do something.</p>
<p>The result of this journey is <a target="_blank" rel="noreferrer" href="https://github.com/alex-moon/mesh">MESH - modular element SSR with hydration</a>. MESH is based on a simple principle: <strong>one component = one endpoint</strong>. This is a powerful idea - it allows us to write a HTML-first back-end in such a way that it <em>feels like</em> writing an SPA.</p>
<p><strong>This write-up includes a lot of code snippets. I&#39;ve tried to keep these minimal. If you want to follow along with more context, you can find the <a target="_blank" rel="noreferrer" href="https://github.com/alex-moon/mesh/commits/main">whole commit history for MESH on GitHub</a>.</strong></p>
<h2>Basic Interactivity</h2>
<p>Looking around, it seemed the back-end of choice for HTMX devs is <a target="_blank" rel="noreferrer" href="https://go.dev/">Go</a> with <a target="_blank" rel="noreferrer" href="https://templ.guide/">Templ</a>. I&#39;ve never really had my &#34;Damascus moment&#34; with Go, but this was a good opportunity to get my feet wet. I will say this much: it is a joy to work with something genuinely blazingly fast to build and deploy.</p>
<p>I also wanted to have a go with proper vibe coding - writing code without reading it - with <a target="_blank" rel="noreferrer" href="https://www.jetbrains.com/help/junie/get-started-with-junie.html">Junie</a>. What fun this was! I can see why people would be tempted to write whole apps this way. I&#39;ll only say this much: as someone who&#39;s battled addiction in the past, I didn&#39;t like what I noticed my brain was doing with it. That&#39;s a subject for another blog post another time.</p>
<p>My mission was, in a word, to write something like an opinionated framework or &#34;harness&#34; for HTMX which would give me a standard way to use it with <a target="_blank" rel="noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components">Web Components</a>. Specifically, what I had in mind was a &#34;one component one endpoint&#34; model. HTMX would always swap the entire component, which would then be &#34;hydrated&#34;.</p>
<p>It turns out there is a standard way to do server-side rendered custom elements, called <a target="_blank" rel="noreferrer" href="https://web.dev/articles/declarative-shadow-dom">Declarative Shadow DOM</a> (DSD). <a target="_blank" rel="noreferrer" href="https://tympanus.net/codrops/2024/08/20/server-first-web-components-with-dsd-htmx-and-islands/">Others have already had some success using HTMX and DSD together</a>. The combo looked promising.</p>
<p>There is one significant limitation, however: HTMX will not cross shadow root boundaries. This is by design, to be clear - this is how we should expect HTMX to behave. No sweat, we can do a simple hack to make it work - and, at the same time, to enforce component-level swaps:</p>
<pre><code><span>import</span> <span>type</span> {<span>HtmxBeforeSwapDetail</span>} <span>from</span> <span>&#34;./types/htmx&#34;</span>;

<span>function</span> <span>enforceComponentSwap</span>(<span><span>evt</span>: <span>CustomEvent</span>&lt;<span>HtmxBeforeSwapDetail</span>&gt;</span>) {
  <span>const</span> detail = evt.<span>detail</span>;
  <span>let</span> elt = detail.<span>elt</span>;
  <span>let</span> root = elt.<span>getRootNode</span>();
  
  <span>if</span> (root <span>instanceof</span> <span>ShadowRoot</span>) {
    detail.<span>target</span> = root.<span>host</span> <span>as</span> <span>HTMLElement</span>;
    detail.<span>swapOverride</span> = <span>&#34;outerHTML&#34;</span>;
  }
}

<span>document</span>.<span>body</span>.<span>addEventListener</span>(<span>&#34;htmx:beforeSwap&#34;</span>, enforceComponentSwap <span>as</span> <span>EventListener</span>);
</code></pre><p>With this little helper, I can now start building out a very simple Trello clone to prove the concept. Let&#39;s build a little editable card component:</p>
<pre><code><span>package</span> card

<span>import</span> (
  <span>&#34;mesh/src/services&#34;</span>
  <span>&#34;fmt&#34;</span>
)

<span>type</span> CardProps <span>struct</span> {
  *services.Card
}

templ Card(props CardProps) {
  &lt;mesh-card
    id={ fmt.Sprintf(<span>&#34;card-%d&#34;</span>, props.Card.ID) }
  &gt;
    &lt;template shadowrootmode=<span>&#34;open&#34;</span>&gt;
      &lt;base href=<span>&#34;/&#34;</span>/&gt;
      &lt;link rel=<span>&#34;stylesheet&#34;</span> href=<span>&#34;/static/css/components/card.css&#34;</span>/&gt;
      &lt;div data-view class=<span>&#34;card&#34;</span>&gt;
        &lt;div class=<span>&#34;card-header&#34;</span>&gt;
          &lt;h3&gt;{ props.Card.Title }&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class=<span>&#34;card-content&#34;</span>&gt;
          { props.Card.Content }
        &lt;/div&gt;
        &lt;div class=<span>&#34;actions&#34;</span>&gt;
          &lt;button <span>type</span>=<span>&#34;button&#34;</span> mesh-click=<span>&#34;edit&#34;</span>&gt;Edit&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;form data-form class=<span>&#34;card hide&#34;</span> hx-patch=<span>&#34;/card&#34;</span>&gt;
        &lt;input <span>type</span>=<span>&#34;hidden&#34;</span> name=<span>&#34;cardID&#34;</span> value={ props.Card.ID } /&gt;
        &lt;label&gt;
          Title
          &lt;input <span>type</span>=<span>&#34;text&#34;</span> name=<span>&#34;title&#34;</span> value={ props.Data.Title } /&gt;
        &lt;/label&gt;
        &lt;label&gt;
          Content
          &lt;textarea name=<span>&#34;content&#34;</span>&gt;{ props.Data.Content }&lt;/textarea&gt;
        &lt;/label&gt;
        &lt;div class=<span>&#34;actions&#34;</span>&gt;
          &lt;button <span>type</span>=<span>&#34;button&#34;</span> mesh-click=<span>&#34;cancel&#34;</span>&gt;Cancel&lt;/button&gt;
          &lt;button <span>type</span>=<span>&#34;submit&#34;</span>&gt;Save&lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/template&gt;
  &lt;/mesh-card&gt;
}
</code></pre><p>Now let&#39;s hydrate it. I&#39;m going to start with a simple base element that&#39;ll ensure that our shadow root is attached properly and <a target="_blank" rel="noreferrer" href="https://htmx.org/examples/web-components/">processed by HTMX</a>:</p>
<pre><code><span>export</span> <span>class</span> <span>MeshElement</span> <span>extends</span> <span>HTMLElement</span> {
  <span>connectedCallback</span>(<span></span>) { 
    <span>if</span> (!<span>this</span>.<span>shadowRoot</span>) {
      
      <span>const</span> root = <span>this</span>.<span>attachShadow</span>({ <span>mode</span>: <span>&#39;open&#39;</span> });
      <span>const</span> template = <span>this</span>.<span>querySelector</span>(<span>&#39;template[shadowrootmode=&#34;open&#34;]&#39;</span>);
      <span>if</span> (template) {
        root.<span>appendChild</span>((template <span>as</span> <span>any</span>).<span>content</span>.<span>cloneNode</span>(<span>true</span>));
      }
    }
    <span>if</span> (<span>window</span>.<span>htmx</span>) {
      <span>window</span>.<span>htmx</span>.<span>process</span>(<span>this</span>);
      <span>if</span> (<span>this</span>.<span>shadowRoot</span>) {
        <span>window</span>.<span>htmx</span>.<span>process</span>(<span>this</span>.<span>shadowRoot</span>);
      }
    }
    <span>this</span>.<span>bindListeners</span>();
  }

  <span>protected</span> <span>bindListeners</span>(<span></span>) {
    <span>const</span> supportedEvents = [<span>&#39;click&#39;</span>];

    supportedEvents.<span>forEach</span>(<span><span>eventName</span> =&gt;</span> {
      <span>const</span> attribute = <span>&#34;mesh-&#34;</span> + eventName;
      <span>this</span>.<span>all</span>(<span>&#39;[&#39;</span> + attribute + <span>&#39;]&#39;</span>, <span><span>el</span> =&gt;</span> {
        <span>const</span> methodName = el.<span>getAttribute</span>(attribute);
        <span>if</span> (!methodName) {
          <span>return</span>;
        }
        <span>const</span> method = (<span>this</span> <span>as</span> <span>any</span>)[methodName];
        <span>if</span> (!method || <span>typeof</span> method !== <span>&#39;function&#39;</span>) {
          <span>console</span>.<span>error</span>(<span>`Method <span>${methodName}</span> is not a function`</span>);
          <span>return</span>;
        }

        el.<span>addEventListener</span>(eventName, method.<span>bind</span>(<span>this</span>));
      });
    });
  }

  <span>all</span>(<span><span>selector</span>: <span>string</span>, <span>cb</span>: (el: HTMLElement) =&gt; <span>void</span></span>) {
    <span>return</span> <span>this</span>.<span>shadowRoot</span>!.<span>querySelectorAll</span>(selector).<span>forEach</span>(<span><span>e</span> =&gt;</span> <span>cb</span>(e <span>as</span> <span>HTMLElement</span>));
  }
}
</code></pre><p>Then our card element is straightforward to implement:</p>
<pre><code><span>import</span> {<span>MeshElement</span>} <span>from</span> <span>&#34;../base/mesh-element.ts&#34;</span>;

<span>export</span> <span>class</span> <span>Card</span> <span>extends</span> <span>MeshElement</span> {
  <span>edit</span>(<span></span>) {
    <span>this</span>.<span>show</span>(<span>&#39;[data-form]&#39;</span>);
    <span>this</span>.<span>hide</span>(<span>&#39;[data-view]&#39;</span>);
  }
  
  <span>cancel</span>(<span></span>) {
    <span>this</span>.<span>hide</span>(<span>&#39;[data-form]&#39;</span>);
    <span>this</span>.<span>show</span>(<span>&#39;[data-view]&#39;</span>);
  }

  <span>show</span>(<span><span>selector</span>: <span>string</span></span>) {
    <span>this</span>.<span>all</span>(selector, <span><span>el</span> =&gt;</span> {
      el.<span>classList</span>.<span>remove</span>(<span>&#39;hide&#39;</span>);
    });
  }

  <span>hide</span>(<span><span>selector</span>: <span>string</span></span>) {
    <span>this</span>.<span>all</span>(selector, <span><span>el</span> =&gt;</span> {
      el.<span>classList</span>.<span>add</span>(<span>&#39;hide&#39;</span>);
    });
  }
}
<span>window</span>.<span>customElements</span>.<span>define</span>(<span>&#39;mesh-card&#39;</span>, <span>Card</span>);
</code></pre><p>This works great! I&#39;ve enhanced my card component with some basic JS to show that it can be done, and otherwise this is all just plain old HTMX.</p>
<p>The next step is adding functionality to move the cards between columns. This is where we&#39;ll run into a common difficulty with HTMX: how to swap out &#34;parent&#34; components given an update on a child component.</p>
<p>Now, HTMX devs have <a target="_blank" rel="noreferrer" href="https://github.com/bigskysoftware/htmx/issues/44">a number of differing opinions</a> on how best to go about this. One common practice is to <a target="_blank" rel="noreferrer" href="https://htmx.org/examples/update-other-content/">&#34;expand the target&#34;</a>, which means your component needs to be aware of parent components. Another way is to <a target="_blank" rel="noreferrer" href="https://htmx.org/headers/hx-trigger/">trigger events in the response headers</a> - this is better, in that it moves responsibility for this back to the server. I believe front-end components shouldn&#39;t know anything their own placement on the page.</p>
<p>Fortunately, HTMX gives us another way to do this - and it appears to be the emerging &#34;best practice&#34; - with <a target="_blank" rel="noreferrer" href="https://htmx.org/attributes/hx-swap-oob/">&#34;out of band&#34; (OOB) swaps</a>. If, in our response to a call to the card endpoint, we return any other components that need updating, and simply flag them as OOB, HTMX will handle the swaps for us. This best reflects my own aims for MESH, so let&#39;s see how we get along doing it this way.</p>
<p>Let&#39;s add &#34;promote&#34; functionality to our card component - this will simply move the card one column to the right:</p>
<pre><code><span>package</span> card

<span>import</span> (
  <span>&#34;mesh/src/services&#34;</span>
  <span>&#34;fmt&#34;</span>
)

<span>const</span> PutActionPromote = <span>&#34;promote&#34;</span>

<span>type</span> CardProps <span>struct</span> {
  *services.Card
  CanPromote <span>bool</span>
}

templ Card(props CardProps) {
  &lt;mesh-card
    id={ fmt.Sprintf(<span>&#34;card-%d&#34;</span>, props.Card.ID) }
  &gt;
    &lt;template shadowrootmode=<span>&#34;open&#34;</span>&gt;
      &lt;base href=<span>&#34;/&#34;</span>/&gt;
      &lt;link rel=<span>&#34;stylesheet&#34;</span> href=<span>&#34;/static/css/components/card.css&#34;</span>/&gt;
      &lt;div data-view class=<span>&#34;card&#34;</span>&gt;
        &lt;div class=<span>&#34;card-header&#34;</span>&gt;
          &lt;h3&gt;{ props.Card.Title }&lt;/h3&gt;
        &lt;/div&gt;
        &lt;div class=<span>&#34;card-content&#34;</span>&gt;
          { props.Card.Content }
        &lt;/div&gt;
        &lt;div class=<span>&#34;actions&#34;</span>&gt;
          <span>if</span> props.CanPromote {
            &lt;form hx-put=<span>&#34;/card&#34;</span>&gt;
              &lt;input <span>type</span>=<span>&#34;hidden&#34;</span> name=<span>&#34;action&#34;</span> value=<span>&#34;promote&#34;</span> /&gt;
              &lt;input <span>type</span>=<span>&#34;hidden&#34;</span> name=<span>&#34;cardID&#34;</span> value={props.Card.ID} /&gt;
              &lt;button <span>type</span>=<span>&#34;submit&#34;</span> aria-label=<span>&#34;Move to next column&#34;</span>&gt;
                &lt;i data-lucide=<span>&#34;arrow-right&#34;</span>&gt;&lt;/i&gt;
              &lt;/button&gt;
            &lt;/form&gt;
          }
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/template&gt;
  &lt;/mesh-card&gt;
}
</code></pre><p>To handle the OOB updates, we&#39;ll write a &#34;context-enriched&#34; pub-sub:</p>
<pre><code><span>type</span> EventContext <span>struct</span> {
	Context        context.Context
	ResponseWriter http.ResponseWriter
}

<span><span>func</span> <span>(e *EventContext)</span></span> Write(component templ.Component) {
	err := component.Render(e.Context, e.ResponseWriter)
	<span>if</span> err != <span>nil</span> {
		http.Error(e.ResponseWriter, <span>&#34;Failed to render OOB updates&#34;</span>, http.StatusInternalServerError)
	}
}

<span><span>func</span> <span>(e *EventService)</span></span> Publish(event Event, w http.ResponseWriter, ctx context.Context) {
  eventContext := EventContext{
    Context:        ctx,
    ResponseWriter: w,
  }
  <span>for</span> _, subscriber := <span>range</span> e.subscribers[event.Key()] {
    subscriber(event, eventContext)
  }
}

<span><span>func</span> <span>(e *EventService)</span></span> Subscribe(key <span>string</span>, subscriber <span><span>func</span><span>(event Event, context EventContext)</span></span>) {
  e.subscribers[key] = <span>append</span>(e.subscribers[key], subscriber)
}
</code></pre><p>Then we can publish in the card handler:</p>
<pre><code><span><span>func</span> <span>(h *Handler)</span></span> Put(w http.ResponseWriter, r *http.Request) {
  card, err := h.getCardFromRequest(r)
  <span>if</span> err != <span>nil</span> {
    http.Error(w, err.Error(), http.StatusNotFound)
    <span>return</span>
  }
  action := r.FormValue(<span>&#34;action&#34;</span>)
  <span>switch</span> action {
  <span>case</span> PutActionPromote:
    fromColumn, toColumn, err := h.CardService.Promote(card.ID)
    <span>if</span> err != <span>nil</span> {
      http.Error(w, err.Error(), http.StatusBadRequest)
    } <span>else</span> {
      h.EventService.PublishCardMoved(card.ID, fromColumn.ID, toColumn.ID, w, r.Context())
    }
    <span>break</span>
  }
}
</code></pre><p>And we can subscribe in the column handler:</p>
<pre><code><span><span>func</span> <span>(h *Handler)</span></span> OnCardMoved(event *services.CardMovedEvent, context services.EventContext) {
  column, err := h.CardService.GetColumn(event.ToColumnID)
  <span>if</span> err == <span>nil</span> {
    context.Write(h.RenderComponent(column, <span>true</span>))
  } <span>else</span> {
    http.Error(context.ResponseWriter, err.Error(), http.StatusInternalServerError)
  }
  column, err = h.CardService.GetColumn(event.FromColumnID)
  <span>if</span> err == <span>nil</span> {
    context.Write(h.RenderComponent(column, <span>true</span>))
  } <span>else</span> {
    http.Error(context.ResponseWriter, err.Error(), http.StatusInternalServerError)
  }
}
</code></pre><p>This way, our components can communicate with each other without needing to know about each other. The subscriber takes the request context from the publisher and simply writes to the response. The result is a response from the back-end with</p>
<ol>
<li>the component-specific update, followed by</li>
<li>any other OOB updates simply appended to the response.</li>
</ol>
<p>This works surprisingly well.</p>
<p>Unfortunately, we once again run into the same limitation as before: HTMX will not cross shadow root boundaries. At this point, it seems clear that, if we want to use HTMX as intended, we are going to have to give up on shadow DOM entirely. Again, this is intended behaviour. JavaScript should not cross shadow root boundaries by default. What this means is that, if we&#39;re wedded to shadow DOM, we are going to have to fight HTMX all the way.</p>
<p>I&#39;m undeterred, of course - all we need is another little hack:</p>
<pre><code><span>function</span> <span>findInShadow</span>(<span><span>root</span>: <span>any</span>, <span>id</span>: <span>string</span></span>): <span>any</span> {
  <span>const</span> element = root.<span>getElementById</span>?.(id);
  <span>if</span> (element) {
    <span>return</span> element;
  }
  <span>const</span> allElements = root.<span>querySelectorAll</span>(<span>&#39;*&#39;</span>);
  <span>for</span> (<span>let</span> element <span>of</span> allElements) {
    <span>if</span> (element.<span>shadowRoot</span>) {
      <span>const</span> found = <span>findInShadow</span>(element.<span>shadowRoot</span>, id);
      <span>if</span> (found) {
        <span>return</span> found;
      }
    }
  }
  <span>return</span> <span>null</span>;
}

<span>function</span> <span>enableOobSwap</span>(<span><span>evt</span>: <span>CustomEvent</span>&lt;<span>any</span>&gt;</span>) {
  <span>const</span> id = evt.<span>detail</span>.<span>content</span>.<span>id</span>;
  <span>const</span> found = <span>findInShadow</span>(<span>document</span>, id);
  <span>if</span> (found) {
    found.<span>outerHTML</span> = evt.<span>detail</span>.<span>content</span>.<span>outerHTML</span>;
    evt.<span>preventDefault</span>();
  }
}

<span>document</span>.<span>body</span>.<span>addEventListener</span>(<span>&#34;htmx:oobErrorNoTarget&#34;</span>, enableOobSwap <span>as</span> <span>EventListener</span>);
</code></pre><p>You&#39;ll notice we&#39;ve done the <code>outerHTML</code> swap ourselves here, overriding HTMX entirely. I&#39;m not a fan of this. I tried as many approaches as I could think of to get HTMX to do the swap - and, thus, leverage existing functionality HTMX provides for these (maintaining scroll position and focus and so on) - but did not succeed.</p>
<p>Nevertheless, this works for my purposes. I&#39;m happy to leave the problem alone for now. Let&#39;s add some drag-and-drop functionality to our cards. In our card component:</p>
<pre><code><span>import</span> {<span>MeshElement</span>} <span>from</span> <span>&#34;../base/mesh-element.ts&#34;</span>;

<span>export</span> <span>class</span> <span>Card</span> <span>extends</span> <span>MeshElement</span> {
  <span>setupDragAndDrop</span>(<span></span>) {
    <span>this</span>.<span>one</span>(<span>&#39;.grip&#39;</span>, <span><span>grip</span> =&gt;</span> {
      grip.<span>draggable</span> = <span>true</span>;
      <span>this</span>.<span>addEventListener</span>(<span>&#39;dragstart&#39;</span>, <span>this</span>.<span>handleDragStart</span>.<span>bind</span>(<span>this</span>));
      <span>this</span>.<span>addEventListener</span>(<span>&#39;dragend&#39;</span>, <span>this</span>.<span>handleDragEnd</span>.<span>bind</span>(<span>this</span>));
    });
  }

  <span>handleDragStart</span>(<span><span>e</span>: <span>any</span></span>) {
    e.<span>dataTransfer</span>.<span>setData</span>(<span>&#39;text/plain&#39;</span>, <span>this</span>.<span>dataset</span>.<span>id</span>);
    <span>this</span>.<span>classList</span>.<span>add</span>(<span>&#39;dragging&#39;</span>);
    e.<span>dataTransfer</span>.<span>effectAllowed</span> = <span>&#39;move&#39;</span>;
  }

  <span>handleDragEnd</span>(<span></span>) {
    <span>this</span>.<span>classList</span>.<span>remove</span>(<span>&#39;dragging&#39;</span>);
  }
}
</code></pre><p>And in our column component:</p>
<pre><code><span>import</span> {<span>MeshElement</span>} <span>from</span> <span>&#34;../base/mesh-element.ts&#34;</span>;

<span>export</span> <span>class</span> <span>Column</span> <span>extends</span> <span>MeshElement</span> {
  <span>setupDropTarget</span>(<span></span>) {
    <span>this</span>.<span>addEventListener</span>(<span>&#39;dragover&#39;</span>, <span>this</span>.<span>handleDragOver</span>.<span>bind</span>(<span>this</span>));
    <span>this</span>.<span>addEventListener</span>(<span>&#39;drop&#39;</span>, <span>this</span>.<span>handleDrop</span>.<span>bind</span>(<span>this</span>));
  }

  <span>handleDragOver</span>(<span><span>e</span>: <span>any</span></span>) {
    e.<span>preventDefault</span>();
    e.<span>dataTransfer</span>.<span>dropEffect</span> = <span>&#39;move&#39;</span>;
  }

  <span>handleDrop</span>(<span><span>e</span>: <span>any</span></span>) {
    e.<span>preventDefault</span>();
    <span>this</span>.<span>classList</span>.<span>remove</span>(<span>&#39;drag-over&#39;</span>);

    <span>const</span> cardId = e.<span>dataTransfer</span>.<span>getData</span>(<span>&#39;text/plain&#39;</span>);
    <span>const</span> columnId = <span>this</span>.<span>dataset</span>.<span>id</span>;
    <span>if</span> (!cardId || !columnId) {
      <span>throw</span> <span>new</span> <span>Error</span>(<span>&#39;Missing card or column ID&#39;</span>);
    }

    <span>const</span> position = <span>this</span>.<span>calculateDropPosition</span>(e);
    <span>this</span>.<span>moveCard</span>(cardId, +columnId, position);
  }

  <span>async</span> <span>moveCard</span>(<span><span>cardId</span>: <span>number</span>, <span>columnId</span>: <span>number</span>, <span>position</span>: <span>number</span></span>) {
    <span>window</span>.<span>htmx</span>.<span>ajax</span>(<span>&#39;put&#39;</span>, <span>&#39;/card&#39;</span>, {
      <span>swap</span>: <span>&#39;none&#39;</span>,
      <span>values</span>: {
        <span>action</span>: <span>&#39;move&#39;</span>,
        <span>cardID</span>: cardId,
        <span>columnID</span>: columnId,
        <span>position</span>: position,
      }
    } <span>as</span> <span>any</span>);
  }
}
</code></pre><p>This is great! This use case is precisely why HTMX provides the ajax JS API. With a bit of hacking, we&#39;ve demonstrated that it&#39;s possible to use HTMX to handle modular SSR based on the premise of &#34;component = endpoint&#34;. I&#39;m pretty happy with how this has turned out.</p>
<h2>Realtime Collaboration</h2>
<p>From the moment I conceived of this project, one of the things I wanted to do was to support realtime collaboration with <a target="_blank" rel="noreferrer" href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events">server-sent events (SSE)</a>. <a target="_blank" rel="noreferrer" href="https://htmx.org/extensions/sse/">HTMX supports SSE with a standard plugin</a> which is easy enough to set up:</p>
<pre><code><span>&lt;<span>html</span> <span>lang</span>=<span>&#34;en&#34;</span> <span>hx-ext</span>=<span>&#34;sse&#34;</span>&gt;</span>
<span>&lt;<span>body</span> <span>hx-ext</span>=<span>&#34;sse&#34;</span> <span>sse-connect</span>=<span>&#34;/sse&#34;</span> <span>sse-swap</span>=<span>&#34;oob-update&#34;</span>&gt;</span>
</code></pre><p>In theory this should <em>just work</em> once I&#39;ve written my SSE back-end. I ended up using <a target="_blank" rel="noreferrer" href="https://github.com/r3labs/sse">r3labs/sse</a> for this, which I found very easy to use.  We wrap this in a service and provide a &#34;broadcast&#34; method that sends OOB updates to all subscribed clients immediately:</p>
<pre><code><span><span>func</span> <span>(s *SSEService)</span></span> BroadcastOOBUpdate(component templ.Component) {
   <span>var</span> buf strings.Builder
   err := component.Render(context.Background(), &amp;buf)
   <span>if</span> err != <span>nil</span> {
       s.log.Error(<span>&#34;Failed to render component for SSE broadcast&#34;</span>, <span>&#34;error&#34;</span>, err)
       <span>return</span>
   }

   html := buf.String()
   s.server.Publish(<span>&#34;oob-updates&#34;</span>, &amp;sse.Event{
       Event: []<span>byte</span>(<span>&#34;oob-update&#34;</span>),
       Data:  html,
   })
}
</code></pre><p>Then we call it in our handler:</p>
<pre><code><span><span>func</span> <span>(h *Handler)</span></span> OnCardMoved(event *services.CardMovedEvent) {
  column, err := h.CardService.GetColumn(event.ToColumnID)
  <span>if</span> err == <span>nil</span> {
    component := h.RenderComponent(column, <span>true</span>)
    h.SSEService.BroadcastOOBUpdate(component)
  } <span>else</span> {
    h.Log.Error(<span>&#34;Failed to get to-column for SSE broadcast&#34;</span>, <span>&#34;columnID&#34;</span>, event.ToColumnID, <span>&#34;error&#34;</span>, err)
  }

  column, err = h.CardService.GetColumn(event.FromColumnID)
  <span>if</span> err == <span>nil</span> {
    h.SSEService.BroadcastOOBUpdate(h.RenderComponent(column, <span>true</span>))
  } <span>else</span> {
    h.Log.Error(<span>&#34;Failed to get from-column for SSE broadcast&#34;</span>, <span>&#34;columnID&#34;</span>, event.FromColumnID, <span>&#34;error&#34;</span>, err)
  }
}
</code></pre><p>This makes our back-end code a lot cleaner! We no longer need to pass the request context around with our event, and we no longer need to append a bunch of OOB updates to the response. Having done this both ways, I have come to believe that SSE is the most natural way to do these kind of asynchronous cross-context modular updates, even with only a single user.</p>
<p>I was hoping this would also allow me to get rid of my <code>outerHTML</code> hack, but alas it was not to be. The longer I worked on this project, the more it became clear to me that I&#39;m not really using HTMX the way it&#39;s intended to be used. More importantly, there is a lot of other HTMX functionality that I&#39;m not using at all.</p>
<p>Naturally, I was intrigued to see if I could just get rid of HTMX entirely. So I did, and the result is a lot cleaner and easier to reason about. We are left with two JS modules - one for the custom elements:</p>
<pre><code><span>export</span> <span>class</span> <span>MeshElement</span> <span>extends</span> <span>HTMLElement</span> {
  <span>connectedCallback</span>(<span></span>) {
    <span>if</span> (!<span>this</span>.<span>shadowRoot</span>) {
      <span>const</span> root = <span>this</span>.<span>attachShadow</span>({ <span>mode</span>: <span>&#39;open&#39;</span> });
      <span>const</span> template = <span>this</span>.<span>querySelector</span>(<span>&#39;template[shadowrootmode=&#34;open&#34;]&#39;</span>);
      <span>if</span> (template) {
        root.<span>appendChild</span>((template <span>as</span> <span>any</span>).<span>content</span>.<span>cloneNode</span>(<span>true</span>));
      }
    }
    <span>this</span>.<span>bindFormHandlers</span>();
  }

  <span>protected</span> <span>bindFormHandlers</span>(<span></span>) {
    <span>const</span> supported = [
      <span>&#39;get&#39;</span>, <span>&#39;post&#39;</span>, <span>&#39;put&#39;</span>, <span>&#39;patch&#39;</span>, <span>&#39;delete&#39;</span>,
    ];

    supported.<span>forEach</span>(<span><span>verb</span> =&gt;</span> {
      <span>const</span> attribute = <span>&#34;mesh-&#34;</span> + verb;
      <span>this</span>.<span>all</span>(<span>&#39;[&#39;</span> + attribute + <span>&#39;]&#39;</span>, <span><span>el</span> =&gt;</span> {
        <span>const</span> form = el <span>as</span> <span>HTMLFormElement</span>;
        form.<span>addEventListener</span>(<span>&#39;submit&#39;</span>, <span>(<span><span>event</span>: <span>Event</span></span>) =&gt;</span> {
          event.<span>preventDefault</span>();
          <span>const</span> method = verb.<span>toUpperCase</span>();
          <span>const</span> url = form.<span>getAttribute</span>(attribute);

          <span>if</span> (!url) {
            <span>console</span>.<span>error</span>(<span>&#39;No URL specified for form submission&#39;</span>);
            <span>return</span>;
          }

          <span>const</span> formData = <span>new</span> <span>FormData</span>(form);
          <span>this</span>.<span>makeRequest</span>(method, url, formData)
            .<span>then</span>(<span><span>response</span> =&gt;</span> {
              <span>if</span> (response.<span>ok</span>) {
                <span>return</span> response.<span>text</span>();
              } <span>else</span> {
                <span>throw</span> <span>new</span> <span>Error</span>(<span>&#39;Form submission failed: &#39;</span> + response.<span>statusText</span>);
              }
            })
            .<span>then</span>(<span><span>html</span> =&gt;</span> <span>this</span>.<span>outerHTML</span> = html)
            .<span>catch</span>(<span><span>error</span> =&gt;</span> <span>console</span>.<span>error</span>(<span>&#39;Form submission failed:&#39;</span>, error));
        });
      });
    });
  }

  <span>protected</span> <span>async</span> <span>makeRequest</span>(<span>method</span>: <span>string</span>, <span>url</span>: <span>string</span>, <span>formData</span>: <span>FormData</span>): <span>Promise</span>&lt;<span>Response</span>&gt; {
    <span>const</span> <span>options</span>: <span>RequestInit</span> = {
      method,
      <span>headers</span>: {
        <span>&#39;X-Requested-With&#39;</span>: <span>&#39;XMLHttpRequest&#39;</span>,
      },
    };

    <span>if</span> (method === <span>&#39;GET&#39;</span>) {
      <span>const</span> params = <span>new</span> <span>URLSearchParams</span>(formData <span>as</span> <span>any</span>);
      url += (url.<span>includes</span>(<span>&#39;?&#39;</span>) ? <span>&#39;&amp;&#39;</span> : <span>&#39;?&#39;</span>) + params.<span>toString</span>();
    } <span>else</span> {
      options.<span>body</span> = formData;
    }

    <span>return</span> <span>fetch</span>(url, options);
  }
}
</code></pre><p>and one for SSE:</p>
<pre><code><span>export</span> <span>class</span> <span>SSEManager</span> {
  <span>private</span> <span>eventSource</span>: <span>EventSource</span> | <span>null</span> = <span>null</span>;

  <span>constructor</span>(<span><span>private</span> <span>url</span>: <span>string</span> = <span>&#39;/sse?stream=oob-updates&#39;</span></span>) {
    <span>this</span>.<span>connect</span>();
  }

  <span>private</span> <span>connect</span>(<span></span>) {
    <span>if</span> (<span>this</span>.<span>eventSource</span>) {
      <span>this</span>.<span>eventSource</span>.<span>close</span>();
    }

    <span>this</span>.<span>eventSource</span> = <span>new</span> <span>EventSource</span>(<span>this</span>.<span>url</span>);

    <span>this</span>.<span>eventSource</span>.<span>addEventListener</span>(<span>&#39;oob-update&#39;</span>, <span>(<span>event</span>) =&gt;</span> {
      <span>this</span>.<span>processOOBUpdate</span>(event <span>as</span> <span>MessageEvent</span>);
    });

    <span>this</span>.<span>eventSource</span>.<span>onerror</span> = <span>(<span>error</span>) =&gt;</span> {
      <span>console</span>.<span>error</span>(<span>&#39;SSE connection error:&#39;</span>, error);
      <span>setTimeout</span>(<span>() =&gt;</span> <span>this</span>.<span>connect</span>(), <span>5000</span>);
    };
  }

  <span>private</span> <span>processOOBUpdate</span>(<span><span>html</span>: <span>string</span></span>) {
    <span>const</span> template = <span>document</span>.<span>createElement</span>(<span>&#39;template&#39;</span>);
    template.<span>innerHTML</span> = html.<span>trim</span>();

    <span>for</span> (<span>const</span> content <span>of</span> template.<span>content</span>.<span>querySelectorAll</span>(<span>&#39;[mesh-swap-oob]&#39;</span>)) {
      <span>const</span> id = content.<span>id</span>;
      <span>const</span> target = <span>this</span>.<span>findInShadow</span>(<span>document</span>, id);

      <span>if</span> (target) {
        target.<span>outerHTML</span> = content.<span>outerHTML</span>;
      } <span>else</span> {
        <span>console</span>.<span>warn</span>(<span>&#39;OOB target not found:&#39;</span>, id);
      }
    }
  }

  <span>private</span> <span>findInShadow</span>(<span>root</span>: <span>Document</span> | <span>ShadowRoot</span> | <span>Element</span>, <span>id</span>: <span>string</span>): <span>Element</span> | <span>null</span> {
    <span>let</span> element = root.<span>querySelector</span>(<span>`#<span>${id}</span>`</span>);
    <span>if</span> (element) {
      <span>return</span> element;
    }

    <span>const</span> allElements = root.<span>querySelectorAll</span>(<span>&#39;*&#39;</span>);
    <span>for</span> (<span>const</span> el <span>of</span> allElements) {
      <span>if</span> (el.<span>shadowRoot</span>) {
        element = <span>this</span>.<span>findInShadow</span>(el.<span>shadowRoot</span>, id);
        <span>if</span> (element) {
          <span>return</span> element;
        }
      }
    }

    <span>return</span> <span>null</span>;
  }
}

<span>new</span> <span>SSEManager</span>();
</code></pre><p>And that&#39;s it! That&#39;s all the JS it takes to replace all of HTMX that I&#39;m using for this project.</p>
<h2>Takeaways</h2>
<p>This was a fun project. First, let me say, if you&#39;re writing apps with jQuery, please check out HTMX! It&#39;s very dev-friendly and a proper 2020s way of doing <em>that</em> kind of dev. Personally, however, I am happy to have convinced myself it&#39;s not for me.</p>
<p>I, for one, don&#39;t believe the HTMX spec, or something like it, will be merged back into HTML, at least until it can answer one fundamental question: what is the default swap behaviour? When I declare a <code>form</code> with a <code>method</code>, I understand how that form will behave: it will reload the entire page. What happens when I declare a <code>form</code> with <code>hx-post</code> or equivalent? The default behaviour in HTMX is that the <code>innerHTML</code> of <em>the form itself</em> becomes the swap target. This does not seem like a sane default to me.</p>
<p>So what&#39;s the answer? Well, as anyone who&#39;s aware of the state of the art on SSR will have noticed, all I&#39;ve actually done with MESH is reinvent <a target="_blank" rel="noreferrer" href="https://hotwired.dev/">HotWire</a>, <a target="_blank" rel="noreferrer" href="https://livewire.laravel.com/">LiveWire</a>, <a target="_blank" rel="noreferrer" href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html">LiveView</a> and friends. Personally, I find this encouraging! It is clear to me that there is a kind of best practice to be found here.</p>
<p>I believe the default swap behaviour should be: always swap the whole component. One component, one endpoint. This is how these frameworks do it. My problem with them is they lock you into a specific back-end. I believe the principle is generalisable, that there is a way to do this kind of modular SSR in a back-end-agnostic way, like HTMX does. MESH is my attempt to show what that would look like.</p>
<p>I will certainly keep using MESH for my projects, fleshing it out as I go. The <a target="_blank" rel="noreferrer" href="https://mesh.ajmoon.com">Trello clone</a> will always be online for anyone to play with.</p>

    </div></div>
  </body>
</html>
