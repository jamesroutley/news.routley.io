<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fev.al/posts/neat/">Original</a>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    
    <p>NEAT is a machine learning algorithm that simulates evolution to train its brains. Let’s try to build a game, and then an AI that masters it.</p>



<p>We will play a little game of snake. You can play with IJKL:</p>


<pre id="one"></pre>



<p>Now that’s all well an fun, but the computer isn’t as smart as you, and we need to transform that view into something it can reasonably understand from its inception. We start by centering the game on the player. That way the problem becomes relative to the snake, rather than absolute to the board:</p>


<pre id="two"></pre>



<p>Better. Now another problem is with directions. We have four, this is way too complex and redundant. We want to make things relative. So we’ll rotate the map accordingly so that forward is always up. Since directions are now relative, commands should also be: we’ll use U and O to turn left and right:</p>


<pre id="three"></pre>



<p>It gets harder, but also the problem we are looking at is standardized now: apples are passing by, and you want to turn to hit them, without hitting you tail.</p>

<p>Now we’ve got something working that we can feed the computer. Time to switch to the AI</p>



<p>We will build a neural network that will learn how to play this game. In fact, we will build a bunch of these, kill the worse, keep the best, make them mate together, take their progeny and keep iterating till we find one that actually works.</p>

<p>The algorithm we’ll loosely follow is <a href="http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf">NEAT</a>. There are a few bits we need to build.</p>

<ul>
  <li>Two entities: genomes, and networks. Networks take inputs, transform them to output. Like in biology, genomes are the encoding of the network.</li>
  <li>A mechanism to transform a genome to a network.</li>
  <li>A mechanism to handle our collection of genomes, including ablation (removing the least fit) and mating</li>
  <li>A mechanism to iterate, run the game, etc.</li>
</ul>

<p>We will start with the whole genome and network.</p>

<p>We’ll use this structure:</p>

<pre>interface Link {
  innovationId: string,
  from: node,
  to: node,
  weight: number, // 0 .. 1
  enabled: bool
}

interface Node {
  type: &#34;in&#34; | &#34;out&#34; | &#34;hidden&#34;,
  pos: {                    // when type = in
    row: number, 
    col: number 
  }, 
  dir: &#34;left&#34; | &#34;right&#34;,    // when type = out
  nodeId: number  // when type = hidden
}
</pre>

<p>First let’s look at an intelligently designed organism’s genome:</p>





<p>Each of the genes is indicating a link from a node to another. The nodes formatted like “1x2” are input nodes. Nodes indicating directions are output nodes. The number on top is called the “innovation number”. We’ll come back to it in a moment.</p>

<p>Here is a view of the topology it generates:</p>







<p>Let’s see what it can do. We’ll transform the genome into a set of functions. There will be one function per output, taking the board as input, and determine how much the output is activated, applying an activation function over the sum of the incoming signal.</p>



<p>For example if we simulate something on the right of our snake:</p>





<p>We now have a functional transformation of the genome into a decision function. The last step necessary is to build a player from that and let it play snake.</p>


<pre id="four"></pre>



<p>Now this is a pretty simple genome, but works relatively well. It turns whenever it sees an apple or when it’s gonna eat itself. Running it a few times already teaches us a few things. A) it’s much faster than you at snake. B) it’s not perfect, despite being intelligently designed. C) scores are not completely deterministic. In fact, let’s try to understand how much runs settle a good average, Monte Carlo style. (It’s mostly going to give us an indication for this species, but should give an order of magnitude).</p>

<p>
  
   iterations 
  </p>




<p>This yields interesting results. First, we see a significant spread between min and max. Second, we see that the game is not terribly optimized, and iterations take a few ms each. Third, we observe that the average results are consistent to +/-5% over 5 iterations, +/- 10% over 10 iterations, and about +/- 2% over 100 iterations.</p>

<p>Figuring the right number of trial per species is a balancing game between obtaining precise results each round, and having more rounds. 10% fidelity seem enough for a variety of reasons.</p>



<p>Let’s see if we can build species which can evolve genes that play the game, and maybe beat our simple intelligent design genome.</p>

<p>There are two aspects of evolution: variation (changing the species) and selection. Let’s focus on variation first.</p>

<h2 id="variation">Variation</h2>

<p>Variation is the set of mechanisms changing the genome of a species. It introduces entropy in the system so that better fitted (and worse…) species appear.</p>

<h3 id="mutation">Mutation</h3>

<p>The first mechanism of variation is mutation, introducing random changes within a genome.</p>

<p>We can do so by changing the existing genes by activating deactivated genes or randomizing the weight of existing links. We can also create new genes, i.e. create new connections, and new nodes.</p>



<p> with probabilities ([0, 1]) for mutation on
weight: 
enable: 
disable: 
split link: 
new link: </p>





<h3 id="mating">Mating</h3>

<p>The second mechanism of variation is mating. It allows traits to be propagated between generations by crossing the genomes of two individuals. Randomly merging topologies is hard: how do you know if a node with the same id is the same between two genomes? How do you know if a given topology will make sense?</p>

<p>NEAT introduces the notion of <em>innovation</em> to handle this. Every time a new node or a new link is inserted, we give it an innovation. The innovation id is global, that means that if a new link between two given nodes, the new link’s innovation id will always be the same across individuals and species. Respectively, for nodes. This is how NEAT traces ancestry and allows simple mating between genomes: a given gene’s innovation id will be the same throughout genomes.</p>

<p>We implement a dictionary that will generate innovation ids accordingly. If the node or the link gene is indeed new, it gets a new id. If it creates a topology that we already encountered, we reuse the same innovation id.</p>

<p> between  and . Result: &lt;div id=&#34;innovation-id-demo-split-result&#34; &gt;&lt;/div&gt;</p>

<p> between  and . Result: &lt;div id=&#34;innovation-id-demo-insert-result&#34; &gt;&lt;/div&gt;</p>



<p>Now we can proceed with mating. This happens through matching two genomes. Matching genes are selected randomly. Excess genes are picked from the fittest parent. If fitness is equal, all are selected.</p>


<p>Fitness delta:  (&gt; 0 means genome on the left is fittest)</p>

<p>Viewed as graph:</p>
<p><span id="mating-genome-1-graph"></span>
  +
  <span id="mating-genome-2-graph"></span>
</p>
<p>= </p>



<h2 id="selection">Selection</h2>

<p>We have the basics of evolution at an individual level, now we’ll tackle the selection part. This will happen by having generation after generation compete in our game, eliminate the lowest performers, breed the rest, rinse and repeat.</p>

<p>NEAT introduces the concept of speciation in addition, so that new genes that could be beneficial compete “locally” and have more chances to survive their introduction. The idea here is that we group genomes that are similar, operate selection and ablation within a species, mate, reassemble species, then carry on.</p>

<h3 id="species">Species</h3>

<p>Compatibility distance is calculated based on the number of genes that differ, and the distance of weights.</p>

<div id="distance">
  
  <p>
  Distance using coefficients: 
    weight: 
    excess genes count: 
    disjointed genes count: 
    gene pool total size: </p><p>Distance: 0</p>
</div>



<p>Calculating distance will allow to group genomes by species, and allowing the development of variations in a semi-protected environments. This happens by maintaining a list of species from a generation to the next. For each species an individual genome is picked randomly as a representative. Each individual from the new generation is placed with the first species with which it is compatible (i.e. compatibility &gt; threshold). If it ain’t compatible, then a new species is created, with that genome as representative.</p>



<p>Now we’ll switch to executing all of that. Starting with an initial population with all gene links between input and output, but disabled.</p>





<p>We’ll plug all of that into an evolutionary loop, in which:</p>
<ul>
  <li>We’ll make all the individual compete at snake</li>
  <li>We’ll prune the 1/2 less fit portion of each species</li>
  <li>We’ll prune species that have been under-performing for a few generations</li>
  <li>Repopulate with offspring of the remaining species, introducing mutations as well</li>
  <li>Re-sort into species</li>
</ul>

<h2 id="fight">FIGHT</h2>




  </div></div>
  </body>
</html>
