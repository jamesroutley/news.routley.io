<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.appsignal.com/2023/09/12/phoenix-1-7-for-elixir-edit-a-form-in-a-modal.html">Original</a>
    <h1>Phoenix 1.7 for Elixir: Edit a Form in a Modal</h1>
    
    <div id="readability-page-1" class="page"><div><p>In part one of this series, we introduced the <code>CoreComponents</code> that get generated when bootstrapping a new
Phoenix project. In part two, we implemented a create modal.</p>
<p>Now, we will implement
an edit modal.</p>
<p><em>You can continue following along with our <a href="https://github.com/Adzz/petacular">companion repo</a>.</em></p>
<h2 id="editing-a-form-in-a-modal">Editing a Form in a Modal</h2>
<p>You will first notice that each item will need a different changeset. We
want to edit each item, so we need to be able to build a changeset from
a different struct each time.</p>
<p>You <em>could</em> do this by iterating over all of the items in <code>mount</code>
and rendering a different modal for every row, but this won&#39;t work at all. You would have to have
one changeset per assign, which doesn&#39;t work when you have a list to add to. It would
also mean a lot more HTML because you&#39;d render the whole modal once per row. It&#39;s an all-round bad idea.</p>
<p>Instead, we need a way to build the correct changeset based on the item we click on.
We can do that by using another <code>JS</code> function — <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html#push/1"><code>push</code></a>.
This will push an event to the backend, along with any attributes that we want to send. If we add an edit button per row, the click action can push an event to the backend
with the <code>pet_id</code> as a param. Then, we can select the pet from the list of assigns and build
a changeset out of it.</p>
<p>First, add the button to the markup. It might be nice to use an icon for this, so let&#39;s take
a quick detour to icons.</p>
<h2 id="icons-in-phoenix">Icons in Phoenix</h2>
<p>Phoenix 1.7 ships with a vendored heroicons library and an <code>&lt;.icon&gt;</code> component in <code>CoreComponents</code>.
It works by supplying the name of an icon as a <code>name</code> attr, like so:</p>

<p>The names for the available icons are the filenames contained in the following
path: <code>assets/vendor/heroicons/optimized/20/solid/</code>.
Looking at the files doesn&#39;t tell us much about what they look like because we just see svg
markup.</p>
<p>What would be cool is if we could render a dev-only route that displays all icons on one page.
Then when we consider using an icon, we can go to that page and peruse them all at our leisure.</p>
<p>First, let&#39;s add the route:</p>

<p>Then, we can make the necessary <code>PetacularWeb.Pages.StoryBookLive</code> module. We&#39;ll now write a function that
generates all the icon names from the files in the assets folder, then iterate over them
and create an icon from each one. This will give us a dynamic list of icons to render.</p>
<p>Here are the <code>icon_names</code> (this assumes you will start your server from the project&#39;s route):</p>

<p>Then the markup:</p>

<p>There is one more thing to do, though. Tailwind will purge all classes it doesn&#39;t see
being used when the app is built. Usually, this is great because it means the bundle size is
smaller, with more lightweight pages. However, here, it is going to bite us. When you
refer to classes dynamically, Tailwind doesn&#39;t see those classes being used, so it purges them. <a href="https://tailwindcss.com/docs/content-configuration#dynamic-class-names">Tailwind&#39;s docs warn about this</a>.</p>
<p>We need to tell Tailwind <em>not</em> to purge all the icon modules so we can render them. We do that by adding a line of config into <code>tailwind.config.js</code>, like so:</p>

<p>Now, we can head to <code>http://localhost:4000/dev/storybook</code> and see all the icons. See
<a href="https://github.com/Adzz/petacular/commit/91a0ff0e3af688a47864dc030a83b0f705e8f021">this commit</a>
for all of the changes.</p>

<h3 id="back-to-editing-our-form">Back to Editing Our Form</h3>
<p>Okay, now we can select our edit icon and put it on the page.</p>

<p>We will put this in a button and add a <code>phx-click</code> that opens our edit modal for us. All
this can live in the <a href="https://github.com/Adzz/petacular/blob/main/lib/petacular_web/pages/home_live.ex">homepage</a> we used in parts one and two.</p>

<p>We also need to create our <code>Edit</code> modal. This will be similar to our <code>Create</code> modal, but a bit different, so we&#39;ll just create a new modal.</p>
<p>We can put this in our <code>~H</code> component just before the other modal:</p>

<p>Now we need to add a changeset to the assigns. Initially, we can put any changeset in mount because when we open the modal, we are going to seed it:</p>

<h2 id="add-the-open_edit_modal-function">Add the <code>open_edit_modal</code> Function</h2>
<p>Now let&#39;s implement the <code>open_edit_modal</code> function. This has to do two things:</p>
<ol>
<li>Open the modal.</li>
<li>Trigger a message to the backend so we can seed the changeset.</li>
</ol>

<p>The handler for this event needs to select the relevant pet from the list of pets and
put that into the changeset:</p>

<p>When we open the modal, the page will re-render the form because the changeset has changed,
and the form will be seeded with the correct data. We can verify this by using
<code>|&gt; IO.inspect(limit: :infinity, label: &#34;&#34;)</code> on the form value:</p>

<h3 id="debugging-an-issue-with-the-open_edit_modal">Debugging an Issue with the <code>open_edit_modal</code></h3>
<p>If you open the modal, you will see the correct value printed. But there is a problem — it&#39;s
not showing on the page! What on earth could be the issue? This one is a doozy, so I will
save you some hours of debugging.</p>
<p>The function that we use to <a href="https://github.com/Adzz/petacular/blob/main/lib/petacular_web/components/core_components.ex#L591">open our modal</a> has this line, which focuses the first &#34;focussable&#34;
element in the modal:</p>

<p>This is done for accessibility, and so is generally a good idea.</p>
<p>The input happens to be the first focussable thing in our edit form. Phoenix also ensures
that the client is the source of truth for <a href="https://hexdocs.pm/phoenix_live_view/form-bindings.html#javascript-client-specifics">an input&#39;s value</a>:</p>
<blockquote>
<p>For any given input with focus, LiveView will never overwrite the input&#39;s current value, even if it deviates from the server&#39;s rendered updates.</p>
</blockquote>
<p>So what happens in our case? We push an asynchronous message to the backend, which changes an assign (the edit
form), causing a re-render — <code>|&gt; JS.push(&#34;open_edit_modal&#34;, value: %{pet_id: pet_id})</code>. Then we
open the modal with JavaScript, but because the message to the server is async, the modal
opens <em>before</em> we get a reply. The first focussable element is the input field, so that gets
focus, then the server responds. This would normally re-render the input field, but now won&#39;t, because the input has focus!</p>
<h3 id="fixing-the-issue">Fixing the Issue</h3>
<p>We&#39;ve done everything right, yet are left adrift. What are our options?</p>
<ol>
<li>Remove the auto-focus capabilities of the modal.</li>
<li>Have the edit modal focus on something that is not the input first.</li>
<li>Somehow make the form opening synchronous to the server message.</li>
</ol>
<p>I honestly don&#39;t know which is better, but let&#39;s reason them out. One is easy to do — just <a href="https://github.com/Adzz/petacular/blob/main/lib/petacular_web/components/core_components.ex#L600">remove this line</a>
from the <code>show_modal</code> function — but may have accessibility implications, which makes it a non-starter.</p>
<p>The second option seems reasonable at first. We could maybe set the <code>tabindex</code> on the heading,
but <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/Understanding_WCAG/Keyboard">mdn</a>
recommends the following:</p>
<blockquote>
<p>If an element can be focused using the keyboard, then it should be interactive; that is, the user should be able to do something to it and produce a change of some kind (for example, activating a link or changing an option).</p>
</blockquote>
<p>So that&#39;s out.</p>
<p>The third option is possible, but requires some ceremony. Instead of opening the modal with JS, you could have the backend trigger a JS event that opens the modal when it&#39;s finished
seeding the changeset. That requires adding a handler in JS to listen for the event
and also means that the modal open is slower, because it requires at least one round trip to
the server. For me, that is out as well.</p>
<p>The solution? A secret fourth option — set the value of the field with JS. This means
the field will open quickly, be set to the correct value, and auto-focus.</p>
<p>To support that, we alter our <a href="https://github.com/Adzz/petacular/blob/main/lib/petacular_web/pages/home_live.ex#L74"><code>open_edit_modal</code></a>
function to accept the name, then use <code>JS.set_attribute</code> to set the field value.</p>

<h2 id="implementing-the-update-in-our-phoenix-application">Implementing the Update in Our Phoenix Application</h2>
<p>Now the only thing left to do is implement the <code>edit_pet</code> handler. This is similar to the
create version, where we flash an error and close the modal on success. We first want to
select the pet we are editing, which means we need the pet&#39;s id. How can we get that?</p>
<p>The easiest way is to use a hidden input on the form. That way, when the form is submitted, the pet id will also be sent. To do that, we need to add the hidden input:</p>

<p>And set the value when we open the modal:</p>

<p>We will see the id of the pet appear in the params, allowing us to select
the pet we are editing from the assigns:</p>

<p>See <a href="https://github.com/Adzz/petacular/commit/364bec4c35c796bcd19f63ccd42ad230c0ed4afc">this commit</a>
for all the relevant changes.</p>
<p>And with that, we are done!</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>This concludes our three-part series in which we took a fresh Phoenix 1.7 application and built a create and edit modal for
it.</p>
<p>Hopefully, this gives you some new ideas you can extend and implement for your own apps.</p>
<p>Happy coding!</p>
<p><strong>P.S. If you&#39;d like to read Elixir Alchemy posts as soon as they get off the press, <a href="https://blog.appsignal.com/elixir-alchemy">subscribe to our Elixir Alchemy newsletter and never miss a single post</a>!</strong></p></div></div>
  </body>
</html>
