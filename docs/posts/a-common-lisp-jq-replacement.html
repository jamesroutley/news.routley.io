<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://world-playground-deceit.net/blog/2025/03/a-common-lisp-jq-replacement.html">Original</a>
    <h1>A Common Lisp jq replacement</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><div id="content-body"><hr/><p>Title says it all, I seriously dislike <a href="https://jqlang.org/"><code>jq</code></a>&#39;s convoluted, impossible-to-remember <i>ad hoc</i> DSL that instantly joined heaps of
 misery like CMake and gnuplot in my heart. It should really have been a library with a CLI wrapper
 around <code>eval</code> in a well-known scripting language like Python.</p><p>And I&#39;m not the only one I&#39;ve heard complain about this, yet it&#39;s the one that seized the
 mindshare and thus became easy to find in any package repository (sometimes even preinstalled) and
 with the most copy-paste fodder on the web. It won for the usual reasons: lack of serious
 competition at the time, enough flexibility to manage most tasks with enough pain and elbow grease
 and now inertia.</p><p>But me, I&#39;ve reached my <q>enough is enough!</q> point and decided to do like <a href="https://www.vapoursynth.com/about/">VapourSynth</a> or <a href="https://waf.io/">waf</a> and replace it with a language I know and love: CL.</p><p>For now, <a href="https://git.sr.ht/~q3cpma/cl-json-utils"><code>cljq</code></a> is only a very
 bare-bones pipeline that parses a JSON (argv or stdin) into a variable <code>$</code>, <a href="https://www.lispworks.com/documentation/HyperSpec/Body/f_eval.htm#eval"><code>eval</code></a> an arbitrary CL form and serializes the result to stdout (using <a href="https://github.com/Zulu-Inuoe/jzon">jzon</a>). But the query operator <code>?</code> inspired by <a href="https://datatracker.ietf.org/doc/html/rfc9535#name-jsonpath-examples">JSONPath</a> is already an improvement, in my eyes:</p><pre>$ json=&#39;{&#34;root&#34;: {&#34;a&#34;: [0, 1], &#34;b&#34;: [2, 3]}}&#39;
$ echo &#34;$json&#34; | jq &#39;.root | map(.[1])&#39;
[
  1,
  3
]
$ echo &#34;$json&#34; | cljq &#39;(? $ &#34;root&#34; * 1)&#39;
[
  1,
  3
]
</pre><p>Here&#39;s a small JSONPath &lt;=&gt; <code>?</code> correspondance table (using some examples found in
 the aforementioned RFC):</p><table><tbody><tr><th>JSONPath</th><th>cljq&#39;s <code>?</code></th></tr><tr><td><code>$.store.book[*].author</code></td><td><code>(? $ &#34;store&#34; &#34;book&#34; * &#34;author&#34;)</code></td></tr><tr><td><code>$..author</code></td><td><code>(? $ ** &#34;author&#34;)</code></td></tr><tr><td><code>$.store.*</code></td><td><code>(? $ &#34;store&#34; *)</code></td></tr><tr><td><code>$.store..price</code></td><td><code>(? $ &#34;store&#34; ** &#34;price&#34;)</code></td></tr><tr><td><code>$..book[-1]</code></td><td><code>(? $ ** &#34;book&#34; -1)</code></td></tr><tr><td><code>$..book[0,1]</code></td><td><code>(? $ ** &#34;book&#34; (or 0 1))</code></td></tr><tr><td><code>$..book[0:2]</code></td><td><code>(? $ ** &#34;book&#34; (subseq 0 2))</code></td></tr></tbody></table><p>That&#39;s it for now; the README has a TODO section, if you want an idea of what&#39;s coming.</p><p>Anyone else rocking homegrown tools to fight the proliferation of crappy DSLs? Write an article
 about it and send me an email, I&#39;ll link it!</p></div></div></div>
  </body>
</html>
