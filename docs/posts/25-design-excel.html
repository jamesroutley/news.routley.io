<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/25%29-Design-Excel">Original</a>
    <h1>25) Design Excel</h1>
    
    <div id="readability-page-1" class="page"><article><h2 id="backstory">Backstory<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#backstory"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Atticus Yang advised me on how to prepare for a coding interview. He didn’t know exactly where to find this problem, but asked Anthropic’s Claude for the “Design Excel” challenge, and then sent me the result. This was it:</p>
<h2 id="the-challenge-design-excel">The Challenge: “Design Excel”<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#the-challenge-design-excel"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Design a data structure that represents an Excel spreadsheet. Implement the following functionalities:</p>
<ol>
<li>
<p>set(row: int, col: int, value: int): Sets the value at the given cell (row, col).</p>
</li>
<li>
<p>get(row: int, col: int): Gets the value at the given cell (row, col).</p>
</li>
<li>
<p>setFormula(row: int, col: int, formula: String): Sets a formula for a cell.</p>
</li>
<li>
<p>Formulas are given as strings and can include references to other cells (e.g., “A1+B2”) or simple arithmetic operations.</p>
</li>
<li>
<p>sum(row1: int, col1: int, row2: int, col2: int): Calculates the sum of the rectangular region defined by (row1, col1) as the top-left corner and (row2, col2) as the bottom-right corner.</p>
</li>
</ol>
<p>This problem tests your ability to design a system that can:</p>
<ul>
<li>Efficiently store and retrieve cell values</li>
<li>Parse and evaluate formulas</li>
<li>Handle dependencies between cells</li>
<li>Perform range-based operations like sum</li>
</ul>
<h2 id="why-i-think-this-is-worthwhile">Why I Think this is Worthwhile<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#why-i-think-this-is-worthwhile"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Because it resembles other challenges I have had to do in various tech interviews. I haven’t done this particular one, but this type of longer-running usage of interconnected data structures to manipulate a central body of data is certainly a theme. I’ve seen undo, I’ve seen a cache-store where each item has a TTL. Each of these challenges so far has taught me a lot, so if Atticus is telling me I may specifically see this questions, I think it’s <em>definitely</em> worthwhile. Spoilers it definitely teaches me some new things.</p>
<h2 id="conversation-with-claude">Conversation with Claude:<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#conversation-with-claude"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>AKA: How doing thought experiments on the architecture of Base-10 helps illuminate what encoding to and from Base-N looks like. In this case, Base-26.</p>
<h2 id="initial-progress">Initial Progress<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#initial-progress"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>So I get going and get to about here in 20 minutes and feel pretty good.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>// Okay remember</span></span>
<span data-line=""><span>// The internal indexing IS 0 based, i.e. for 10x10, bottom right is 99x99, top left is 0, 0</span></span>
<span data-line=""><span>// BUT. the methods automatically uses 1,1 for top left. So we need to translate this stuff</span></span>
<span data-line=""> </span>
<span data-line=""><span>class</span><span> Excel</span><span>{</span></span>
<span data-line=""> </span>
<span data-line=""><span>  cells</span><span>:</span><span> number</span><span>[][]</span></span>
<span data-line=""><span>  rows</span><span>:</span><span> number</span></span>
<span data-line=""><span>  cols</span><span>:</span><span> number</span></span>
<span data-line=""> </span>
<span data-line=""><span>  constructor</span><span>(</span><span>rows</span><span>:</span><span> number</span><span>, </span><span>cols</span><span>:</span><span> number</span><span>){</span></span>
<span data-line=""><span>    this</span><span>.rows </span><span>=</span><span> rows</span></span>
<span data-line=""><span>    this</span><span>.cols </span><span>=</span><span> cols</span></span>
<span data-line=""><span>    this</span><span>.cells </span><span>=</span><span> []</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> col </span><span>=</span><span> 0</span><span>; col </span><span>&lt;</span><span> cols; col</span><span>++</span><span>){</span></span>
<span data-line=""><span>      this</span><span>.cells.</span><span>push</span><span>([])</span></span>
<span data-line=""><span>      for</span><span> (</span><span>let</span><span> row </span><span>=</span><span> 0</span><span>; row </span><span>&lt;</span><span> rows; row</span><span>++</span><span>){</span></span>
<span data-line=""><span>        this</span><span>.cells[col].</span><span>push</span><span>(</span><span>0</span><span>)</span></span>
<span data-line=""><span>      }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  set</span><span>(</span><span>row</span><span>:</span><span> number</span><span>, </span><span>col</span><span>:</span><span> number</span><span>, </span><span>value</span><span>:</span><span> number</span><span>)</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (col </span><span>&lt;</span><span> 0</span><span> ||</span><span> row </span><span>&lt;</span><span> 0</span><span>){</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>&#34;The top left cell is 1, 1&#34;</span><span>)</span></span>
<span data-line=""><span>      return</span><span> false</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> (row </span><span>&gt;</span><span> this</span><span>.rows </span><span>||</span><span> col </span><span>&gt;</span><span> this</span><span>.cols){</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>`(${</span><span>row</span><span>},${</span><span>col</span><span>}) Is out of bounds`</span><span>)</span></span>
<span data-line=""><span>      return</span><span> false</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    this</span><span>.cells[col</span><span>-</span><span>1</span><span>][row</span><span>-</span><span>1</span><span>] </span><span>=</span><span> value</span></span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  get</span><span>(</span><span>row</span><span>:</span><span> number</span><span>, </span><span>col</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (col </span><span>&lt;</span><span> 0</span><span> ||</span><span> row </span><span>&lt;</span><span> 0</span><span>){</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>&#34;The top left cell is 1, 1&#34;</span><span>)</span></span>
<span data-line=""><span>      return</span><span> -</span><span>1</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    if</span><span> (row </span><span>&gt;</span><span> this</span><span>.rows </span><span>||</span><span> col </span><span>&gt;</span><span> this</span><span>.cols){</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>`(${</span><span>row</span><span>},${</span><span>col</span><span>}) Is out of bounds`</span><span>)</span></span>
<span data-line=""><span>      return</span><span> -</span><span>1</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""> </span>
<span data-line=""><span>    return</span><span> this</span><span>.cells[row</span><span>-</span><span>1</span><span>][col</span><span>-</span><span>1</span><span>]</span></span>
<span data-line=""><span>    // Gets the value at the given cell (row, col).</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span></code></pre></figure>
<p>But then I look at this next bit and I just baulk. I ask Claude what it would do, and I don’t regret it. At the time <em>and</em> in hindsight, I think that figuring out these next functions on my own is not a good use of my time. They are much higher order, and completely unlike anything I’ve seen before. They are even more challenging for how much simpler they appeared to me at first glance. Claude gives me this:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>class</span><span> Excel</span><span> {</span></span>
<span data-line=""><span>  cells</span><span>:</span><span> (</span><span>number</span><span> |</span><span> string</span><span>)[][]</span></span>
<span data-line=""><span>  formulas</span><span>:</span><span> { [</span><span>key</span><span>:</span><span> string</span><span>]</span><span>:</span><span> string</span><span> }</span></span>
<span data-line=""><span>  rows</span><span>:</span><span> number</span></span>
<span data-line=""><span>  cols</span><span>:</span><span> number</span></span>
<span data-line=""> </span>
<span data-line=""><span>  constructor</span><span>(</span><span>rows</span><span>:</span><span> number</span><span>, </span><span>cols</span><span>:</span><span> number</span><span>) {</span></span>
<span data-line=""><span>    this</span><span>.rows </span><span>=</span><span> rows</span></span>
<span data-line=""><span>    this</span><span>.cols </span><span>=</span><span> cols</span></span>
<span data-line=""><span>    this</span><span>.cells </span><span>=</span><span> []</span></span>
<span data-line=""><span>    this</span><span>.formulas </span><span>=</span><span> {}</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> col </span><span>=</span><span> 0</span><span>; col </span><span>&lt;</span><span> cols; col</span><span>++</span><span>) {</span></span>
<span data-line=""><span>      this</span><span>.cells.</span><span>push</span><span>([])</span></span>
<span data-line=""><span>      for</span><span> (</span><span>let</span><span> row </span><span>=</span><span> 0</span><span>; row </span><span>&lt;</span><span> rows; row</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        this</span><span>.cells[col].</span><span>push</span><span>(</span><span>0</span><span>)</span></span>
<span data-line=""><span>      }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  set</span><span>(</span><span>row</span><span>:</span><span> number</span><span>, </span><span>col</span><span>:</span><span> number</span><span>, </span><span>value</span><span>:</span><span> number</span><span>)</span><span>:</span><span> boolean</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (col </span><span>&lt;</span><span> 1</span><span> ||</span><span> row </span><span>&lt;</span><span> 1</span><span> ||</span><span> row </span><span>&gt;</span><span> this</span><span>.rows </span><span>||</span><span> col </span><span>&gt;</span><span> this</span><span>.cols) {</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>`(${</span><span>row</span><span>},${</span><span>col</span><span>}) Is out of bounds`</span><span>)</span></span>
<span data-line=""><span>      return</span><span> false</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    this</span><span>.cells[col </span><span>-</span><span> 1</span><span>][row </span><span>-</span><span> 1</span><span>] </span><span>=</span><span> value</span></span>
<span data-line=""><span>    return</span><span> true</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  get</span><span>(</span><span>row</span><span>:</span><span> number</span><span>, </span><span>col</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> |</span><span> string</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (col </span><span>&lt;</span><span> 1</span><span> ||</span><span> row </span><span>&lt;</span><span> 1</span><span> ||</span><span> row </span><span>&gt;</span><span> this</span><span>.rows </span><span>||</span><span> col </span><span>&gt;</span><span> this</span><span>.cols) {</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>`(${</span><span>row</span><span>},${</span><span>col</span><span>}) Is out of bounds`</span><span>)</span></span>
<span data-line=""><span>      return</span><span> -</span><span>1</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    const</span><span> cellKey</span><span> =</span><span> `${</span><span>row</span><span>},${</span><span>col</span><span>}`</span></span>
<span data-line=""><span>    if</span><span> (cellKey </span><span>in</span><span> this</span><span>.formulas) {</span></span>
<span data-line=""><span>      return</span><span> this</span><span>.</span><span>evaluateFormula</span><span>(</span><span>this</span><span>.formulas[cellKey])</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> this</span><span>.cells[col </span><span>-</span><span> 1</span><span>][row </span><span>-</span><span> 1</span><span>]</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  setFormula</span><span>(</span><span>row</span><span>:</span><span> number</span><span>, </span><span>col</span><span>:</span><span> number</span><span>, </span><span>formula</span><span>:</span><span> string</span><span>)</span><span>:</span><span> void</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (col </span><span>&lt;</span><span> 1</span><span> ||</span><span> row </span><span>&lt;</span><span> 1</span><span> ||</span><span> row </span><span>&gt;</span><span> this</span><span>.rows </span><span>||</span><span> col </span><span>&gt;</span><span> this</span><span>.cols) {</span></span>
<span data-line=""><span>      console.</span><span>log</span><span>(</span><span>`(${</span><span>row</span><span>},${</span><span>col</span><span>}) Is out of bounds`</span><span>)</span></span>
<span data-line=""><span>      return</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    const</span><span> cellKey</span><span> =</span><span> `${</span><span>row</span><span>},${</span><span>col</span><span>}`</span></span>
<span data-line=""><span>    this</span><span>.formulas[cellKey] </span><span>=</span><span> formula</span></span>
<span data-line=""><span>    this</span><span>.cells[col </span><span>-</span><span> 1</span><span>][row </span><span>-</span><span> 1</span><span>] </span><span>=</span><span> this</span><span>.</span><span>evaluateFormula</span><span>(formula)</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  sum</span><span>(</span><span>row1</span><span>:</span><span> number</span><span>, </span><span>col1</span><span>:</span><span> number</span><span>, </span><span>row2</span><span>:</span><span> number</span><span>, </span><span>col2</span><span>:</span><span> number</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> sum </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> row </span><span>=</span><span> row1; row </span><span>&lt;=</span><span> row2; row</span><span>++</span><span>) {</span></span>
<span data-line=""><span>      for</span><span> (</span><span>let</span><span> col </span><span>=</span><span> col1; col </span><span>&lt;=</span><span> col2; col</span><span>++</span><span>) {</span></span>
<span data-line=""><span>        const</span><span> value</span><span> =</span><span> this</span><span>.</span><span>get</span><span>(row, col)</span></span>
<span data-line=""><span>        if</span><span> (</span><span>typeof</span><span> value </span><span>===</span><span> &#39;number&#39;</span><span>) {</span></span>
<span data-line=""><span>          sum </span><span>+=</span><span> value</span></span>
<span data-line=""><span>        }</span></span>
<span data-line=""><span>      }</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> sum</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  private</span><span> evaluateFormula</span><span>(</span><span>formula</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    // Simple formula evaluation (supports basic arithmetic and cell references)</span></span>
<span data-line=""><span>    const</span><span> cellReference</span><span> =</span><span> /</span><span>(</span><span>[A-Z]</span><span>)(</span><span>\d</span><span>+</span><span>)</span><span>/</span><span>g</span></span>
<span data-line=""><span>    formula </span><span>=</span><span> formula.</span><span>replace</span><span>(cellReference, (</span><span>match</span><span>, </span><span>col</span><span>, </span><span>row</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span data-line=""><span>      const</span><span> colIndex</span><span> =</span><span> col.</span><span>charCodeAt</span><span>(</span><span>0</span><span>) </span><span>-</span><span> 64</span></span>
<span data-line=""><span>      return</span><span> this</span><span>.</span><span>get</span><span>(</span><span>parseInt</span><span>(row), colIndex).</span><span>toString</span><span>()</span></span>
<span data-line=""><span>    })</span></span>
<span data-line=""><span>    try</span><span> {</span></span>
<span data-line=""><span>      return</span><span> eval</span><span>(formula)</span></span>
<span data-line=""><span>    } </span><span>catch</span><span> (error) {</span></span>
<span data-line=""><span>      console.</span><span>error</span><span>(</span><span>&#39;Invalid formula:&#39;</span><span>, formula)</span></span>
<span data-line=""><span>      return</span><span> 0</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  private</span><span> columnToLetter</span><span>(</span><span>column</span><span>:</span><span> number</span><span>)</span><span>:</span><span> string</span><span> {</span></span>
<span data-line=""><span>    let</span><span> temp</span><span>:</span><span> number</span><span>, letter </span><span>=</span><span> &#39;&#39;</span></span>
<span data-line=""><span>    while</span><span> (column </span><span>&gt;</span><span> 0</span><span>) {</span></span>
<span data-line=""><span>      temp </span><span>=</span><span> (column </span><span>-</span><span> 1</span><span>) </span><span>%</span><span> 26</span></span>
<span data-line=""><span>      letter </span><span>=</span><span> String.</span><span>fromCharCode</span><span>(temp </span><span>+</span><span> 65</span><span>) </span><span>+</span><span> letter</span></span>
<span data-line=""><span>      column </span><span>=</span><span> (column </span><span>-</span><span> temp </span><span>-</span><span> 1</span><span>) </span><span>/</span><span> 26</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> letter</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""> </span>
<span data-line=""><span>  private</span><span> letterToColumn</span><span>(</span><span>letter</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    let</span><span> column </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 0</span><span>; i </span><span>&lt;</span><span> letter.</span><span>length</span><span>; i</span><span>++</span><span>) {</span></span>
<span data-line=""><span>      column </span><span>+=</span><span> (letter.</span><span>charCodeAt</span><span>(i) </span><span>-</span><span> 64</span><span>) </span><span>*</span><span> Math.</span><span>pow</span><span>(</span><span>26</span><span>, letter.</span><span>length</span><span> -</span><span> i </span><span>-</span><span> 1</span><span>)</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> column</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>It looks good, and explains a lot. In particular, extracting letterToColumn into functions is crucial, because although it’s not many lines, it’s way to complex to reason about within another function, and it’s quite functional - even if I don’t initially understand how it works, I don’t have to in order to use it because the I/O is dead simple.</p>
<ul>
<li><code>AA -&gt; 27</code></li>
<li><code>AZ =&gt; 52</code></li>
</ul>
<p>But yeah. The machinery inside of the function is whack. I break apart this <code>letterToColumn</code> function in about a half hour or so, after watching an episode of White Lotus to chill out.</p>
<p>For this one, going through it with a few example I/O’s is enough to illuminate the workings.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>const</span><span> lettersToNumber</span><span> =&gt;</span><span> (</span><span>letters</span><span>:</span><span> string</span><span>)</span><span>:</span><span> number</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>	column </span><span>=</span><span> 0</span></span>
<span data-line=""><span>	for</span><span> (</span><span>let</span><span> i </span><span>=</span><span> 1</span><span>; i </span><span>&lt;=</span><span> letters.</span><span>length</span><span>; i</span><span>++</span><span>){</span></span>
<span data-line=""><span>		column </span><span>+=</span><span> (letters.</span><span>charCodeAt</span><span>(i)</span><span>-</span><span>64</span><span>) </span><span>*</span><span> Math.</span><span>pow</span><span>(</span><span>26</span><span>, letters.</span><span>length</span><span> -</span><span> i)</span></span>
<span data-line=""><span>	}</span></span>
<span data-line=""><span>	return</span><span> column</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>I was <em>almost</em> able to just write that from scratch just now, except that I confused <code>charCodeAt</code> with <code>charFromString</code>which isn’t a function (I was sort of thinking of <code>String.fromCharCode</code>, but we’ll get there).</p>
<p>You might notice I change the for loop to be <code>1-index</code>. I found this reduced the complexity a bit and was easier to reason about, even if it is a bit unconventional.</p>
<p>Here’s some scribbles of me working it out earlier:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>  // CDA</span></span>
<span data-line=""><span>  // 2133</span></span>
<span data-line=""><span>  // while 2133 &gt; 0</span></span>
<span data-line=""><span>  // 2132 % 26 = 0 (because it goes in 82 times)</span></span>
<span data-line=""><span>  // 0 + 65 + &#39;&#39; = A</span></span>
<span data-line=""><span>  // column = 2133 - 0 / 26 = 82</span></span></code></pre></figure>
<p>This type of exercise made understanding it relatively easy.</p>
<p>Although not technically needed for this challenge, I <em>also</em> took it upon myself to understand columnToLetter, but that ended up being WAY harder. I had to go on a whole journey of understanding different Base-N numeric systems to get there, which I will include below:</p>
<h3 id="me">Me:<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#me"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>This is so hard for me to fully Grok. I understand LetterToColumn pretty well. Somehow though, line by line, it’s really hard for me to get this one:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>  private </span><span>columnToLetter</span><span>(column: number): string {</span></span>
<span data-line=""><span>    let</span><span> temp</span><span>:</span><span> number</span><span>, letter </span><span>=</span><span> &#39;&#39;</span></span>
<span data-line=""><span>    while</span><span> (column </span><span>&gt;</span><span> 0</span><span>) {</span></span>
<span data-line=""><span>      temp </span><span>=</span><span> (column </span><span>-</span><span> 1</span><span>) </span><span>%</span><span> 26</span></span>
<span data-line=""><span>      letter </span><span>=</span><span> String.</span><span>fromCharCode</span><span>(temp </span><span>+</span><span> 65</span><span>) </span><span>+</span><span> letter</span></span>
<span data-line=""><span>      column </span><span>=</span><span> (column </span><span>-</span><span> temp </span><span>-</span><span> 1</span><span>) </span><span>/</span><span> 26</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> letter</span></span>
<span data-line=""><span>  }</span></span></code></pre></figure>
<p>Can you help me understand it backwards and forwards? Like, really break it down and teach me how it works.</p>
<h3 id="claude">Claude<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#claude"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>…
Think of it like this: if you were converting a decimal number to binary, you’d repeatedly divide by 2 and keep track of the remainders. This is the same concept, but we’re dividing by 26 instead of 2, and using letters instead of 0 and 1.</p>
<h3 id="me-1">Me:<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#me-1"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><em>(misunderstanding and thinking Claude was talking about normal base-10, but luckily it works in my favor)</em>
Okay yes the base 10 corollary does help. Let’s say we are doing this for 124. We are converting it down to be letters from A-I.</p>
<p>124%10=4 (because 10 goes into 120 12 times, leaving 4)</p>
<p>Line 2 of the while loop really just builds the string</p>
<p>But I think that’s what’s hardest for me to understand and it bothers me - why are we building the end of the string first? How does this correspond to the modulu operation exactly?</p>
<p>We modulo it by 10, get that remainder or 4. That means 4 is going to be the last digit. The smallest digit. But I don’t know why - in my head, it could just as easily be the first digit, I don’t know why it’s one no the other, you know?</p>
<p>Anyways. After adding that to the “end” of the string,</p>
<p>We move on to line 3, we cut off that reminder that we’ve dealt with somehow, and we divide it by 10 (or 26 in the real function) again.</p>
<p>I suppose that’s the reason. Every time we go in the while loop, we’ve divided by our base again…so although our “column” number is shrinking, it’s not shrinking in a normal way. We’re cutting off the parts of it that overflow each level of a base. We start with the first level of a base - in this case, any number that won’t fit into a multiple of 10. We do this, and we are left with 120.</p>
<p>Now we find everything that won’t fit into a multiple of 100 (because now all numbers left over are technically a multiple of 10 - we’ve removed the last “digit”, or in the case of converting one base to another, the level of that base (still sort of a digit, just not a digit in the 10-base sense))</p>
<p>And what we cut off on that stage is 20. 10s fit into 20, but not 100s. 2 tens to be precise, so we can take that entire “stage” and re-encode it to 2, put at the symbolic position of 2.</p>
<p>I guess that’s sort of my challenge too, is the wording.</p>
<p>Each position contains information.</p>
<p>On base 26, a letter at position 2 from the right (1 position left of the first characer), reprsent 2 26s. We could move that same quantity to the 1 position, sort of, in a weird way, but then it would change form, to 52. Which, well, it won’t fit there. It’s 52 units of base 26, which if you wanted to be insane, COULD be represented in base10 as 52 I guess. But that’s sort of like saying, hey, let’s create another 16 characters that represent the numbers from 10-26 so that we can fit 26 characters in the 1st position.</p>
<p>I guess, just to ride this train, we could actually create a base 52 system that uses all the lowercase and uppercase characters together, where lowercase is 1-26 and uppercase is 27-52. If we did THAT, then we could express the base 26 value of “20” (which is the equivalent of Z in the normal excel-style alphabet by the way, when encoded with base 26 characers - it’s also the ASCII character 90) with the character Z (but in the context of a base-52, a-zA-Z character base), and Z alone. That’s the only way we could really FIT it in the first position. I guess you could do other super weird funky stuff if you wanted other ways to express numbers like this, and cram them into the first position.</p>
<p>Like we could I suppose appropriate superscript notation away from exponent expression to mean the amount of bases it represents. With this weird quirky language, in the context still of a base-26 numerical system, we could do 2²</p>
<p>Instead, which is to say that 2 represents 2 26’s (52).</p>
<p>If we just went crazy with this sort of thing, no rules, we could do this:</p>
<p>3¹1³2²</p>
<p>So here, 3 represents 3, 1 represents 676 and 2 represents 52.</p>
<p>This entire “number” would then be 679.</p>
<p>This is really the same as writing 123 in base-26 notation, it’s just that instead of encoding “how many bases up” each number is with their <em>position,</em> we are doing it with the superscript, freeing them to be all over the place in no particular order. Definitely not an improvement, but I think it illuminates how information is being encoded in these different ways.</p>
<p>So yeah. I think I get it.</p>
<p>We start with this big number.</p>
<p>We subtract 1 because excel is 1-indexed and we want to change it to 0-indexed.</p>
<p>We modulo it off of 26. When we do this, we are in the first position of base-26, where each character represents just 1, or 26^0.</p>
<p>In this mode, we can add 65 (the value of A in ASCII) to whatever modulo we cut off. If the entire number is a multiple of 26, we actually don’t <em>have</em> a remainder, because this first position is only for numbers that don’t fit evenly into 26.</p>
<p>We have the <code>+ letter</code> for later, but <code>letter = &#39;&#39;</code> right now, so we don’t worry about it.</p>
<p>We go to the last line in the while loop, where we actually go ahead and do what that modulo foreshadowed, and divide our working <code>column</code> amount by our base. This is like saying, okay, for <code>26⁰</code>, or numbers that don’t evenly go into 26, we’re good. We’ve encoded that in our base-26 encoding with A-Z characters. That’s now in the first position of the string we’re building. Next up, since we’re done with things that aren’t multiples of 26, we now will focus on things that <em>are</em> multiples of 26 but not of 676.</p>
<p>We’ll take THOSE slices of the overall number and we’ll encode them as an A-Z character in the second position.</p>
<p>If there’s still something left over, that’s because we have more than 676 characters, which is the limit of what we could encode with ZZ I believe.</p>
<p>That brings us to ZZA territory, where we have 677.</p>
<p>Damn. Yeah that’s it. Super tricky to wrap my head around but I think I kind of get it now.</p>
<h2 id="what-next">What Next?<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#what-next"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>I’m not quite done with this challenge, but I’m proud of my progress and will pick it up tomorrow.</p></article></div>
  </body>
</html>
