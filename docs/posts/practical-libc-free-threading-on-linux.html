<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2023/03/23/">Original</a>
    <h1>Practical Libc-free threading on Linux</h1>
    
    <div id="readability-page-1" class="page"><div lang="en">
<article>
  <h2><a href="https://blog.plover.com/blog/2023/03/23/">Practical libc-free threading on Linux</a></h2>
  <time datetime="2023-03-23">
    March 23, 2023
  </time>
  <p>
    nullprogram.com/blog/2023/03/23/
  </p>

  <p>Suppose you’re <a href="https://blog.plover.com/blog/2023/02/15/">not using a C runtime</a> on Linux, and instead you’re
programming against its system call API. It’s long-term and stable after
all. <a href="https://www.rfleury.com/p/untangling-lifetimes-the-arena-allocator">Memory management</a> and <a href="https://blog.plover.com/blog/2023/02/13/">buffered I/O</a> are easily
solved, but a lot of software benefits from concurrency. It would be nice
to also have thread spawning capability. This article will demonstrate a
simple, practical, and robust approach to spawning and managing threads
using only raw system calls. It only takes about a dozen lines of C,
including 4 or so inline assembly instructions.</p>

<p>The catch is that there’s no way to avoid using a bit of assembly. Neither
the <code>clone</code> nor <code>clone3</code> system calls have threading semantics compatible
with C, so you’ll need to paper over it with a bit of inline assembly per
architecture. This article will focus on x86-64, but the basic concept
should work on all architecture supported by Linux. The <a href="https://man7.org/linux/man-pages/man2/clone.2.html">glibc <code>clone(2)</code>
wrapper</a> fits a C-compatible interface on top of the raw system call,
but we won’t be using it here.</p>

<p>Before diving in, the complete, working demo: <a href="https://github.com/skeeto/scratch/blob/master/misc/stack_head.c"><strong><code>stack_head.c</code></strong></a></p>

<h3 id="the-clone-system-call">The clone system call</h3>

<p>On Linux, threads are spawned using the <code>clone</code> system call with semantics
like the classic unix <code>fork(2)</code>. One process goes in, two processes come
out in nearly the same state. For threads, those processes share almost
everything and differ only by two registers: the return value — zero in
the new thread — and stack pointer. Unlike typical thread spawning APIs,
the application does not supply an entry point. It only provides a stack
for the new thread. The simple form of the raw clone API looks something
like this:</p>

<div><div><pre><code><span>long</span> <span>clone</span><span>(</span><span>long</span> <span>flags</span><span>,</span> <span>void</span> <span>*</span><span>stack</span><span>);</span>
</code></pre></div></div>

<p>Sounds kind of elegant, but it has an annoying problem: The new thread
begins life in the <em>middle</em> of a function without any established stack
frame. Its stack is a blank slate. It’s not ready to do anything except
jump to a function prologue that will set up a stack frame. So besides the
assembly for the system call itself, it also needs more assembly to get
the thread into a C-compatible state. In other words, <strong>a generic system
call wrapper cannot reliably spawn threads</strong>.</p>

<div><div><pre><code><span>void</span> <span>brokenclone</span><span>(</span><span>void</span> <span>(</span><span>*</span><span>threadentry</span><span>)(</span><span>void</span> <span>*</span><span>),</span> <span>void</span> <span>*</span><span>arg</span><span>)</span>
<span>{</span>
    <span>// ...</span>
    <span>long</span> <span>r</span> <span>=</span> <span>syscall</span><span>(</span><span>SYS_clone</span><span>,</span> <span>flags</span><span>,</span> <span>stack</span><span>);</span>
    <span>// DANGER: new thread may access non-existant stack frame here</span>
    <span>if</span> <span>(</span><span>!</span><span>r</span><span>)</span> <span>{</span>
        <span>threadentry</span><span>(</span><span>arg</span><span>);</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>For odd historical reasons, each architecture’s <code>clone</code> has a slightly
different interface. The newer <code>clone3</code> unifies these differences, but it
suffers from the same thread spawning issue above, so it’s not helpful
here.</p>



<p>I <a href="https://blog.plover.com/blog/2015/05/15/">figured out a neat trick eight years ago</a> which I continue to use
today. The parent and child threads are in nearly identical states when
the new thread starts, but the immediate goal is to diverge. As noted, one
difference is their stack pointers. To diverge their execution, we could
make their execution depend on the stack. An obvious choice is to push
different return pointers on their stacks, then let the <code>ret</code> instruction
do the work.</p>

<p>Carefully preparing the new stack ahead of time is the key to everything,
and there’s a straightforward technique that I like call the <code>stack_head</code>,
a structure placed at the high end of the new stack. Its first element
must be the entry point pointer, and this entry point will receive a
pointer to its own <code>stack_head</code>.</p>

<div><div><pre><code><span>struct</span> <span>__attribute</span><span>((</span><span>aligned</span><span>(</span><span>16</span><span>)))</span> <span>stack_head</span> <span>{</span>
    <span>void</span> <span>(</span><span>*</span><span>entry</span><span>)(</span><span>struct</span> <span>stack_head</span> <span>*</span><span>);</span>
    <span>// ...</span>
<span>}</span><span>;</span>
</code></pre></div></div>

<p>The structure must have 16-byte alignment on all architectures. I used an
attribute to help keep this straight, and it can help when using <code>sizeof</code>
to place the structure, as I’ll demonstrate later.</p>

<p>Now for the cool part: The <code>...</code> can be anything you want! Use that area
to seed the new stack with whatever thread-local data is necessary. It’s a
neat feature you don’t get from standard thread spawning interfaces. If I
plan to “join” a thread later — wait until it’s done with its work — I’ll
put a join futex in this space:</p>

<div><div><pre><code><span>struct</span> <span>__attribute</span><span>((</span><span>aligned</span><span>(</span><span>16</span><span>)))</span> <span>stack_head</span> <span>{</span>
    <span>void</span> <span>(</span><span>*</span><span>entry</span><span>)(</span><span>struct</span> <span>stack_head</span> <span>*</span><span>);</span>
    <span>int</span> <span>join_futex</span><span>;</span>
    <span>// ...</span>
<span>}</span><span>;</span>
</code></pre></div></div>

<p>More details on that futex shortly.</p>

<h3 id="the-clone-wrapper">The clone wrapper</h3>

<p>I call the <code>clone</code> wrapper <code>newthread</code>. It has the inline assembly for the
system call, and since it includes a <code>ret</code> to diverge the threads, it’s a
“naked” function <a href="https://blog.plover.com/blog/2023/02/12/">just like with <code>setjmp</code></a>. The compiler will
generate no prologue or epilogue, and the function body is limited to
inline assembly. It cannot even reliably reference its parameters by name.
Like <code>clone</code>, it doesn’t accept a thread entry point. Instead it accepts a
<code>stack_head</code> seeded with the entry point. The whole wrapper is just four
instructions:</p>

<div><div><pre><code><span>__attribute</span><span>((</span><span>naked</span><span>))</span>
<span>static</span> <span>long</span> <span>newthread</span><span>(</span><span>struct</span> <span>stack_head</span> <span>*</span><span>stack</span><span>)</span>
<span>{</span>
    <span>__asm</span> <span>volatile</span> <span>(</span>
        <span>&#34;xchg   %%rdi, %%rsi</span><span>\n</span><span>&#34;</span>
        <span>&#34;syscall</span><span>\n</span><span>&#34;</span>
        <span>&#34;mov    %%rsp, %%rdi</span><span>\n</span><span>&#34;</span>
        <span>&#34;ret</span><span>\n</span><span>&#34;</span>
        <span>:</span>
        <span>:</span> <span>&#34;a&#34;</span><span>(</span><span>SYS_clone</span><span>),</span> <span>&#34;S&#34;</span><span>(</span><span>0x50f00L</span><span>)</span>
        <span>:</span> <span>&#34;rdi&#34;</span><span>,</span> <span>&#34;rcx&#34;</span><span>,</span> <span>&#34;r11&#34;</span><span>,</span> <span>&#34;memory&#34;</span>
    <span>);</span>
<span>}</span>
</code></pre></div></div>

<p>On x86-64, both function calls and system calls use <code>rdi</code> and <code>rsi</code> for
their first two parameters. Per the reference <code>clone(2)</code> prototype above:
the first system call argument is <code>flags</code> and the second argument is the
new <code>stack</code>, which will point directly at the <code>stack_head</code>. However, the
stack pointer arrives in <code>rdi</code>. So I load the flags (<code>0x50f00L</code>) into
<code>rsi</code>, then exchange (<code>xchg</code>) the registers in the inline assembly,
preparing both system call arguments at once.</p>

<p>Where does that <code>0x50f00L</code> come from? That’s the bare minimum thread spawn
flag set expressed as a constant. If any flag is missing then threads will
not spawn reliably — as discovered the hard way by trial and error across
different system configurations, not from documentation. Give it a name if
you like, but don’t use an automatic local variable because it’s a naked
function.</p>

<div><div><pre><code>    <span>long</span> <span>flags</span> <span>=</span> <span>0</span><span>;</span>
    <span>flags</span> <span>|=</span> <span>CLONE_FILES</span><span>;</span>
    <span>flags</span> <span>|=</span> <span>CLONE_FS</span><span>;</span>
    <span>flags</span> <span>|=</span> <span>CLONE_SIGHAND</span><span>;</span>
    <span>flags</span> <span>|=</span> <span>CLONE_SYSVSEM</span><span>;</span>
    <span>flags</span> <span>|=</span> <span>CLONE_THREAD</span><span>;</span>
    <span>flags</span> <span>|=</span> <span>CLONE_VM</span><span>;</span>
</code></pre></div></div>

<p>When the system call returns, it copies the stack pointer into <code>rdi</code>, the
first argument for the entry point. In the new thread the stack pointer
will be the same value as <code>stack</code>, of course. In the old thread this is a
harmless no-op because <code>rdi</code> is a volatile register in this ABI. Finally,
<code>ret</code> pops the address at the top of the stack and jumps. In the old
thread this returns to the caller with the system call result, either an
error (<a href="https://blog.plover.com/blog/2016/09/23/">negative errno</a>) or the new thread ID. In the new thread
<strong>it pops the first element of <code>stack_head</code></strong> which, of course, is the
entry point. That’s why it must be first!</p>

<p>The thread has nowhere to return from the entry point, so when it’s done
it must either block indefinitely or use the <code>exit</code> (<em>not</em> <code>exit_group</code>)
system call to terminate itself.</p>

<h3 id="caller-point-of-view">Caller point of view</h3>

<p>The caller side looks something like this:</p>

<div><div><pre><code><span>static</span> <span>void</span> <span>threadentry</span><span>(</span><span>struct</span> <span>stack_head</span> <span>*</span><span>stack</span><span>)</span>
<span>{</span>
    <span>// ... do work ...</span>
    <span>__atomic_store_n</span><span>(</span><span>&amp;</span><span>stack</span><span>-&gt;</span><span>join_futex</span><span>,</span> <span>1</span><span>,</span> <span>__ATOMIC_SEQ_CST</span><span>);</span>
    <span>futex_wake</span><span>(</span><span>&amp;</span><span>stack</span><span>-&gt;</span><span>join_futex</span><span>);</span>
    <span>exit</span><span>(</span><span>0</span><span>);</span>
<span>}</span>

<span>__attribute</span><span>((</span><span>force_align_arg_pointer</span><span>))</span>
<span>void</span> <span>_start</span><span>(</span><span>void</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>stack_head</span> <span>*</span><span>stack</span> <span>=</span> <span>newstack</span><span>(</span><span>1</span><span>&lt;&lt;</span><span>16</span><span>);</span>
    <span>stack</span><span>-&gt;</span><span>entry</span> <span>=</span> <span>threadentry</span><span>;</span>
    <span>// ... assign other thread data ...</span>
    <span>stack</span><span>-&gt;</span><span>join_futex</span> <span>=</span> <span>0</span><span>;</span>
    <span>newthread</span><span>(</span><span>stack</span><span>);</span>

    <span>// ... do work ...</span>

    <span>futex_wait</span><span>(</span><span>&amp;</span><span>stack</span><span>-&gt;</span><span>join_futex</span><span>,</span> <span>0</span><span>);</span>
    <span>exit_group</span><span>(</span><span>0</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>Despite the minimalist, 4-instruction clone wrapper, this is taking the
shape of a conventional threading API. It would only take a bit more to
hide the futex, too. Speaking of which, what’s going on there? The <a href="https://blog.plover.com/blog/2022/10/05/">same
principal as a WaitGroup</a>. The futex, an integer, is zero-initialized,
indicating the thread is running (“not done”). The joiner tells the kernel
to wait until the integer is non-zero, which it may already be since I
don’t bother to check first. When the child thread is done, it atomically
sets the futex to non-zero and wakes all waiters, which might be nobody.</p>

<p>Caveat: It’s not safe to free/reuse the stack after a successful join. It
only indicates the thread is done with its work, not that it exited. You’d
need to wait for its <code>SIGCHLD</code>. If this sounds like a problem, consider
<a href="https://vimeo.com/644068002">your context</a> more carefully: Why do you feel the need to free the
stack? It will be freed when the process exits. Worried about leaking
stacks? Why are you starting and exiting an unbounded number of threads?
In the worst case park the thread in a thread pool until you need it
again. Only worry about this sort of thing if you’re building a general
purpose threading API like pthreads. I know it’s tempting, but avoid doing
that unless you absolutely must.</p>

<p>What’s with the <code>force_align_arg_pointer</code>? Linux doesn’t align the stack
for the process entry point like a System V ABI function call. Processes
begin life with an unaligned stack. This attribute tells GCC to fix up the
stack alignment in the entry point prologue, <a href="https://blog.plover.com/blog/2023/02/15/#stack-alignment-on-32-bit-x86">just like on Windows</a>.
If you want to access <code>argc</code>, <code>argv</code>, and <code>envp</code> you’ll need <a href="https://blog.plover.com/blog/2022/02/18/">more
assembly</a>. (I wish doing <em>really basic things</em> without libc on Linux
didn’t require so much assembly.)</p>

<div><div><pre><code><span>__asm</span> <span>(</span>
    <span>&#34;.global _start</span><span>\n</span><span>&#34;</span>
    <span>&#34;_start:</span><span>\n</span><span>&#34;</span>
    <span>&#34;   movl  (%rsp), %edi</span><span>\n</span><span>&#34;</span>
    <span>&#34;   lea   8(%rsp), %rsi</span><span>\n</span><span>&#34;</span>
    <span>&#34;   lea   8(%rsi,%rdi,8), %rdx</span><span>\n</span><span>&#34;</span>
    <span>&#34;   call  main</span><span>\n</span><span>&#34;</span>
    <span>&#34;   movl  %eax, %edi</span><span>\n</span><span>&#34;</span>
    <span>&#34;   movl  $60, %eax</span><span>\n</span><span>&#34;</span>
    <span>&#34;   syscall</span><span>\n</span><span>&#34;</span>
<span>);</span>

<span>int</span> <span>main</span><span>(</span><span>int</span> <span>argc</span><span>,</span> <span>char</span> <span>**</span><span>argv</span><span>,</span> <span>char</span> <span>**</span><span>envp</span><span>)</span>
<span>{</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>Getting back to the example usage, it has some regular-looking system call
wrappers. Where do those come from? Start with this 6-argument generic
system call wrapper.</p>

<div><div><pre><code><span>long</span> <span>syscall6</span><span>(</span><span>long</span> <span>n</span><span>,</span> <span>long</span> <span>a</span><span>,</span> <span>long</span> <span>b</span><span>,</span> <span>long</span> <span>c</span><span>,</span> <span>long</span> <span>d</span><span>,</span> <span>long</span> <span>e</span><span>,</span> <span>long</span> <span>f</span><span>)</span>
<span>{</span>
    <span>register</span> <span>long</span> <span>ret</span><span>;</span>
    <span>register</span> <span>long</span> <span>r10</span> <span>asm</span><span>(</span><span>&#34;r10&#34;</span><span>)</span> <span>=</span> <span>d</span><span>;</span>
    <span>register</span> <span>long</span> <span>r8</span>  <span>asm</span><span>(</span><span>&#34;r8&#34;</span><span>)</span>  <span>=</span> <span>e</span><span>;</span>
    <span>register</span> <span>long</span> <span>r9</span>  <span>asm</span><span>(</span><span>&#34;r9&#34;</span><span>)</span>  <span>=</span> <span>f</span><span>;</span>
    <span>__asm</span> <span>volatile</span> <span>(</span>
        <span>&#34;syscall&#34;</span>
        <span>:</span> <span>&#34;=a&#34;</span><span>(</span><span>ret</span><span>)</span>
        <span>:</span> <span>&#34;a&#34;</span><span>(</span><span>n</span><span>),</span> <span>&#34;D&#34;</span><span>(</span><span>a</span><span>),</span> <span>&#34;S&#34;</span><span>(</span><span>b</span><span>),</span> <span>&#34;d&#34;</span><span>(</span><span>c</span><span>),</span> <span>&#34;r&#34;</span><span>(</span><span>r10</span><span>),</span> <span>&#34;r&#34;</span><span>(</span><span>r8</span><span>),</span> <span>&#34;r&#34;</span><span>(</span><span>r9</span><span>)</span>
        <span>:</span> <span>&#34;rcx&#34;</span><span>,</span> <span>&#34;r11&#34;</span><span>,</span> <span>&#34;memory&#34;</span>
    <span>);</span>
    <span>return</span> <span>ret</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>I could define <code>syscall5</code>, <code>syscall4</code>, etc. but instead I’ll just wrap it
in macros. The former would be more efficient since the latter wastes
instructions zeroing registers for no reason, but for now I’m focused on
compacting the implementation source.</p>

<div><div><pre><code><span>#define SYSCALL1(n, a) \
    syscall6(n,(long)(a),0,0,0,0,0)
#define SYSCALL2(n, a, b) \
    syscall6(n,(long)(a),(long)(b),0,0,0,0)
#define SYSCALL3(n, a, b, c) \
    syscall6(n,(long)(a),(long)(b),(long)(c),0,0,0)
#define SYSCALL4(n, a, b, c, d) \
    syscall6(n,(long)(a),(long)(b),(long)(c),(long)(d),0,0)
#define SYSCALL5(n, a, b, c, d, e) \
    syscall6(n,(long)(a),(long)(b),(long)(c),(long)(d),(long)(e),0)
#define SYSCALL6(n, a, b, c, d, e, f) \
    syscall6(n,(long)(a),(long)(b),(long)(c),(long)(d),(long)(e),(long)(f))
</span></code></pre></div></div>

<p>Now we can have some exits:</p>

<div><div><pre><code><span>__attribute</span><span>((</span><span>noreturn</span><span>))</span>
<span>static</span> <span>void</span> <span>exit</span><span>(</span><span>int</span> <span>status</span><span>)</span>
<span>{</span>
    <span>SYSCALL1</span><span>(</span><span>SYS_exit</span><span>,</span> <span>status</span><span>);</span>
    <span>__builtin_unreachable</span><span>();</span>
<span>}</span>

<span>__attribute</span><span>((</span><span>noreturn</span><span>))</span>
<span>static</span> <span>void</span> <span>exit_group</span><span>(</span><span>int</span> <span>status</span><span>)</span>
<span>{</span>
    <span>SYSCALL1</span><span>(</span><span>SYS_exit_group</span><span>,</span> <span>status</span><span>);</span>
    <span>__builtin_unreachable</span><span>();</span>
<span>}</span>
</code></pre></div></div>

<p>Simplified futex wrappers:</p>

<div><div><pre><code><span>static</span> <span>void</span> <span>futex_wait</span><span>(</span><span>int</span> <span>*</span><span>futex</span><span>,</span> <span>int</span> <span>expect</span><span>)</span>
<span>{</span>
    <span>SYSCALL4</span><span>(</span><span>SYS_futex</span><span>,</span> <span>futex</span><span>,</span> <span>FUTEX_WAIT</span><span>,</span> <span>expect</span><span>,</span> <span>0</span><span>);</span>
<span>}</span>

<span>static</span> <span>void</span> <span>futex_wake</span><span>(</span><span>int</span> <span>*</span><span>futex</span><span>)</span>
<span>{</span>
    <span>SYSCALL3</span><span>(</span><span>SYS_futex</span><span>,</span> <span>futex</span><span>,</span> <span>FUTEX_WAKE</span><span>,</span> <span>0x7fffffff</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>And so on.</p>

<p>Finally I can talk about that <code>newstack</code> function. It’s just a wrapper
around an anonymous memory map allocating pages from the kernel. I’ve
hardcoded the constants for the standard mmap allocation since they’re
nothing special or unusual. The return value check is a little tricky
since a large portion of the negative range is valid, so I only want to
check for a small range of negative errnos. (Allocating a arena looks
basically the same.)</p>

<div><div><pre><code><span>static</span> <span>struct</span> <span>stack_head</span> <span>*</span><span>newstack</span><span>(</span><span>long</span> <span>size</span><span>)</span>
<span>{</span>
    <span>unsigned</span> <span>long</span> <span>p</span> <span>=</span> <span>SYSCALL6</span><span>(</span><span>SYS_mmap</span><span>,</span> <span>0</span><span>,</span> <span>size</span><span>,</span> <span>3</span><span>,</span> <span>0x22</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>);</span>
    <span>if</span> <span>(</span><span>p</span> <span>&gt;</span> <span>-</span><span>4096UL</span><span>)</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
    <span>long</span> <span>count</span> <span>=</span> <span>size</span> <span>/</span> <span>sizeof</span><span>(</span><span>struct</span> <span>stack_head</span><span>);</span>
    <span>return</span> <span>(</span><span>struct</span> <span>stack_head</span> <span>*</span><span>)</span><span>p</span> <span>+</span> <span>count</span> <span>-</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The <code>aligned</code> attribute comes into play here: I treat the result like an
array of <code>stack_head</code> and return the last element. The attribute ensures
each individual elements is aligned.</p>

<p>That’s it! There’s not much to it other than a few thoughtful assembly
instructions. It took doing this a few times in a few different programs
before I noticed how simple it can be.</p>



  <ul>
    
    <li><a href="https://blog.plover.com/tags/c/">c</a></li>
    
    <li><a href="https://blog.plover.com/tags/optimization/">optimization</a></li>
    
    <li><a href="https://blog.plover.com/tags/linux/">linux</a></li>
    
    <li><a href="https://blog.plover.com/tags/x86/">x86</a></li>
    
  </ul>
  <ol></ol>

  <div>
    <p>Have a comment on this article? Start a discussion in my
    <a href="https://lists.sr.ht/~skeeto/public-inbox">public inbox</a>
    by sending an email to
    <a href="mailto:~skeeto/public-inbox@lists.sr.ht?Subject=Re%3A%20Practical%20libc-free%20threading%20on%20Linux">
        ~skeeto/public-inbox@lists.sr.ht
    </a>
    <span>
    [<a href="https://man.sr.ht/lists.sr.ht/etiquette.md">mailing list etiquette</a>]
    </span>,
    or see
    <a href="https://lists.sr.ht/~skeeto/public-inbox?search=Practical+libc-free+threading+on+Linux">existing discussions</a>.
    </p>

    
    
    
  </div>

  <nav>
  
    <div>
      <p><span>«</span>
      <a href="https://blog.plover.com/blog/2023/02/15/">
        CRT-free in 2023: tips and tricks
      </a>
    </p></div>
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
