<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.circle-lang.org/site/intro/">Original</a>
    <h1>Circle C&#43;&#43; with Memory Safety</h1>
    
    <div id="readability-page-1" class="page"><div role="main" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div itemprop="articleBody">
              
                
<p>Over the past two years, the United States Government has been issuing warnings about memory-unsafe programming languages with increasing urgency. Much of the country&#39;s critical infrastructure relies on software written in C and C++, languages which are very memory <em>unsafe</em>, leaving these systems more vulnerable to exploits by adversaries.</p>
<ul>
<li>
<p>Nov. 10, 2022 - <strong>NSA Releases Guidance on How to Protect Against Software Memory Safety Issues</strong><sup id="fnref:nsa-guidance"><a href="#fn:nsa-guidance">1</a></sup></p>
</li>
<li>
<p>Sep. 20, 2023 - <strong>The Urgent Need for Memory Safety in Software Products</strong><sup id="fnref:cisa-urgent"><a href="#fn:cisa-urgent">2</a></sup></p>
</li>
<li>
<p>Dec. 6, 2023 - <strong>CISA Releases Joint Guide for Software Manufacturers: The Case for Memory Safe Roadmaps</strong><sup id="fnref:cisa-roadmaps"><a href="#fn:cisa-roadmaps">3</a></sup></p>
</li>
<li>
<p>Feb. 26, 2024 - <strong>Future Software Should Be Memory Safe</strong><sup id="fnref:white-house"><a href="#fn:white-house">4</a></sup></p>
</li>
</ul>
<p>The government papers are backed by industry research. Microsoft&#39;s bug telemetry reveals that 70% of its vulnerabilities would be stopped by memory-safe programming languages.<sup id="fnref:ms-vulnerabilities"><a href="#fn:ms-vulnerabilities">5</a></sup> Google&#39;s research has found 68% of 0day exploits are related to memory corruption.<sup id="fnref:google-0day"><a href="#fn:google-0day">6</a></sup> </p>
<ul>
<li>Mar. 4, 2024 - <strong>Secure by Design: Google&#39;s Perspective on Memory Safety</strong><sup id="fnref:secure-by-design"><a href="#fn:secure-by-design">7</a></sup></li>
</ul>
<p>Security professionals loudly advocate that projects migrate away from C++ and start using memory safe languages. But the scale of the problem is daunting. C++ powers products that have generated trillions of dollars of value. There are a lot of C++ programmers and a lot of C++ code. Given how wide-spread C and C++ code is, what can industry really do to improve software quality and reduce vulnerabilities? What are the options for introducing new memory safe code into existing projects and hardening software that already exists?</p>
<p>There&#39;s only one systems-level/non-garbage collected language that provides rigorous memory safety. That&#39;s the Rust language.<sup id="fnref:rust-language"><a href="#fn:rust-language">8</a></sup> But while they play in the same space, C++ and Rust are idiomatically very different with limited interop capability, making incremental migration from C++ to Rust a slow, painstaking process.</p>
<p>Rust lacks function overloading, templates and inheritance. C++ lacks traits, relocation and lifetime parameters. These discrepancies are responsible for an impedence mismatch when interfacing the two languages. Most code generators for inter-language bindings do not even attempt to represent the features of one language in terms of the features of another. They typically identify a number of special vocabulary types,<sup id="fnref:vocabulary-types"><a href="#fn:vocabulary-types">9</a></sup> which have first-class ergonomics, and limit functionality of other constructs.</p>
<p>The foreignness of Rust for career C++ developers along with the inadequacies of interop tools makes hardening C++ applications by rewriting critical sections in Rust very difficult. Why is there no in-language solution to memory safety? <em>Why not a Safe C++?</em></p>
<h2 id="extend-c-for-safety">Extend C++ for safety</h2>
<p>My aim is to produce a superset of C++ that has a rigorously safe subset. Start a new project, or take an existing one, and write safe code in C++. Code written in the safety context exhibits the same strong safety guarantees as safe code programmed in Rust. Indeed, lifetime safety is enforced statically with borrow checking, the signature safety technology first introduced in Rust.<sup id="fnref:borrow-checking"><a href="#fn:borrow-checking">10</a></sup></p>
<p>The argument for Rust: it&#39;s a clean new language designed from the ground up for safety.</p>
<p>The argument for Safe C++: it provides the same rigorous safety guarantees as Rust, but since it extends C++, it has unbeatable interoperability with your existing code.</p>
<p>The goal is to write robust, sound software. Rust is a proven tool to achieve that. Safe C++ could be another viable tool. What&#39;s not viable is to continue adding unsafe, vulnerability-ridden code.</p>
<p>What properties characterize Safe C++?</p>
<ul>
<li>A superset of C++ with a <em>safe subset</em>. Undefined behavior is prohibited from originating in the safe subset.</li>
<li>The safe and unsafe parts of the language are clearly delineated, and users must explicitly leave the safe context to use unsafe operations.</li>
<li>The safe subset must remain <em>useful</em>. If we get rid of a crucial unsafe technology, like unions or pointers, we should supply a safe alternative, like choice types or borrows. A perfectly safe language is not useful if it&#39;s so inexpressive you can&#39;t get your work done.</li>
<li>The new system can&#39;t break existing code. If you point a Safe C++ compiler at existing C++ code, that code must compile normally. Users opt into the new safety mechanisms. Safe C++ is an extension of C++. It&#39;s not a new language.</li>
</ul>
<pre><code>#feature on safety
#include &#34;std2.h&#34;

int main() safe {
  std2::vector&lt;int&gt; vec { 11, 15, 20 };

  for(int x : vec) {
    // Ill-formed. mutate of vec invalidates iterator in ranged-for.
    if(x % 2)
      vec^.push_back(x);

    unsafe printf(&#34;%d\n&#34;, x);
  }
}
</code></pre>
<pre><code>$ circle iter3.cxx 
safety: iter3.cxx:10:10
      vec^.push_back(x); 
         ^
mutable borrow of vec between its shared borrow and its use
loan created at iter3.cxx:7:15
  for(int x : vec) { 
              ^
</code></pre>
<p>Consider this demonstration of Safe C++ that catches iterator invalidation, which would lead to a use-after-free bug. Let&#39;s break it down line by line:</p>
<p>Line 1: <code>#feature on safety</code> - Turn on the new safety-related keywords within this file. Other files in your translation unit are unaffected. This is how Safe C++ avoids breaking existing code--everything is opt-in, including the new keywords and syntax. The safety feature changes the object model for function definitions, enabling object relocation, partial and deferred initialization. It lowers function definitions to mid-level intermediate representation (MIR)<sup id="fnref:mir"><a href="#fn:mir">11</a></sup>, on which borrow checking is performed to flag potential use-after-free bugs on checked references.</p>
<p>Line 2: <code>#include &#34;std2.h&#34;</code> - Include the new safe containers and algorithms. Safety hardening is about reducing your exposure to unsafe APIs. The current Standard Library is full of unsafe APIs. The new Standard Library in namespace <code>std2</code> will provide the same basic functionality, but with containers that are lifetime-aware and type safe.</p>
<p>Line 4: <code>int main() safe</code> - The new <em>safe-specifier</em> is part of a function&#39;s type, just like <em>noexcept-specifier</em>. To callers, the function is marked as safe, so that it can be called from a safe context. <code>main</code>&#39;s definition starts in a safe context, so unsafe operations like pointer dereferences, and calling unsafe functions, is not allowed. Rust&#39;s functions are safe by default. C++&#39;s are unsafe by default. But that&#39;s now just a syntax difference. Once you enter a safe context in C++ by using the <em>safe-specifier</em>, you&#39;re backed by the same rigorous safety guarantees that Rust provides.</p>
<p>Line 5: <code>std2::vector&lt;int&gt; vec { 11, 15, 20 };</code> - List initialization of a memory-safe vector. This vector is aware of lifetime parameters, so borrow checking would extend to element types that have lifetimes. The vector&#39;s constructor doesn&#39;t use <code>std::initializer_list&lt;int&gt;</code><sup id="fnref:init-list"><a href="#fn:init-list">12</a></sup>. That type is problematic for two reasons: first, users are given pointers into the argument data, and reading from pointers is unsafe; second, the <code>std::initializer_list</code> <em>doesn&#39;t own</em> its data, making relocation impossible. For these reasons, Safe C++ introduces a <code>std2::initializer_list&lt;T&gt;</code>, which can be used in a safe context and supports our ownership object model.</p>
<p>Line 7: <code>for(int x : vec)</code> - Ranged-for on the vector. The standard mechanism<sup id="fnref:ranged-for"><a href="#fn:ranged-for">13</a></sup> returns a pair of iterators, which are pointers wrapped in classes. C++ iterators are unsafe. They come in begin and end pairs, and don&#39;t share common lifetime parameters, making borrow checking them impractical. The Safe C++ version uses slice iterators, which resemble Rust&#39;s <code>Iterator</code>.<sup id="fnref:rust-iterator"><a href="#fn:rust-iterator">14</a></sup> These safe types use lifetime parameters making them robust against iterator invalidation.</p>
<p>Line 10: <code>vec^.push_back(x);</code> - Push a value onto the vector. What&#39;s the <code>^</code> doing there? That&#39;s a <em>postfix-object-operator</em> which indicates a mutable borrow on the object argument of the member function call. When <code>#feature on safety</code> is enabled, <em>all mutations are explicit</em>. Explicit mutation lends precision when choosing between shared borrows and mutable borrows of an object. Rust doesn&#39;t feature function overloading, so it will implicitly borrow (mutably or shared) from the member function&#39;s object. C++ of course has function overloading, so we&#39;ll need to be explicit in order to get the overload we want.</p>
<p>Line 12: <code>unsafe printf(&#34;%d\n&#34;, x);</code> - Call <code>printf</code>. It&#39;s a very unsafe function. Since we&#39;re in a safe context, we have to escape with the <code>unsafe</code> keyword. Safe C++ doesn&#39;t lock off any parts of the C++ language. You&#39;re free to shoot yourself in the foot, provided you sign the waiver in the form of the <code>unsafe</code> keyword. <code>unsafe</code> means that you swear to follow the preconditions of the function, rather than relying on the compiler to ensure those preconditions for you.</p>
<p>If <code>main</code> checks out syntatically, its AST is lowered to MIR, where it is borrow checked. The hidden iterator that powers the ranged-for loop stays initialized during execution of the loop. The <code>push_back</code> <em>invalidates</em> that iterator, by mutating a place (the vector) that the iterator has a constraint on. When the value <code>x</code> is next loaded out of the iterator, the borrow checker raises an error: <code>mutable borrow of vec between its shared borrow and its use</code>. The borrow checker prevents Circle compiling a program that may have exhibited undefined behavior. This is all done at compile time, with no impact on your program&#39;s size or speed.</p>
<p>This sample is only a few lines, but I&#39;ve introduced many new mechanisms and types. Security experts keep reminding us, and it is true, that <strong>C++ is very unsafe</strong>. It takes a systematic effort to supply a superset of the language with a safe subset that has enough flexibility to remain expressive.</p>
<h2 id="the-memory-safety-value-proposition">The memory safety value proposition</h2>
<p>Memory-safe languages are predicated on a basic observation of human nature: people would rather try something, and only then ask for help if it doesn&#39;t work. For programming, this means developers try to use a library, and only then read the docs if they can&#39;t get it to work. This has proven very dangerous, since appearing to work is not the same as working.</p>
<p>Many C++ functions have preconditions that are only known after careful of their perusal of their documentation. Preconditions can be anything; users don&#39;t come with expectations as to what safe usage should look like. Violating preconditions, which is possible with benign-looking usage, causes undefined behavior and opens your software to attack. <strong>Software safety and security should not be predicated on programmers following documentation.</strong> </p>
<p>Here&#39;s the value proposition: compiler and library vendors make an extra effort to provide a robust environment so that users <em>don&#39;t have to read the docs</em>. No matter how they use the language and library, their actions will not raise undefined behavior and open the software to safety-related exploits. No system can guard against all misuse, and hastily written code may have plenty of logic bugs. But those logic bugs won&#39;t lead to memory safety vulnerabilities.</p>
<p>Last week I found that my compiler would occassional segfault on some input. I tracked the issue down to a usage of <code>std::isprint</code>.<sup id="fnref:isprint"><a href="#fn:isprint">15</a></sup> This function has an <code>int</code> parameter. I was calling it with UNICODE code points. I didn&#39;t consider that I might be violating the preconditions, which require that the function be called only with an argument between -1 and 255:</p>
<blockquote>
<p>Like all other functions from <code>&lt;cctype&gt;</code>, the behavior of <code>std::isprint</code> is undefined if the argument&#39;s value is neither representable as unsigned char nor equal to EOF. To use these functions safely with plain chars (or signed chars), the argument should first be converted to unsigned char.
Similarly, they should not be directly used with standard algorithms when the iterator&#39;s value type is char or signed char. Instead, convert the value to unsigned char first.</p>
</blockquote>
<p>This is very stupid. While the mistake was mine, the library&#39;s design goes against human nature. Do not rely on the programmer to closely read the docs before using your function. The safe context provided by memory safe languages prevents usage or authoring of functions like <code>std::isprint</code> which exhibit undefined behavior. </p>
<p>Some memory safety issues, like the one described above, are easy to fix. Others can&#39;t be fixed in a language as unsafe as ISO C++. It&#39;s not enough to read documentation, follow C++ Core Guidelines<sup id="fnref:core-guidelines"><a href="#fn:core-guidelines">16</a></sup> or write unit tests. To address lifetime and thread safety issues, new language technologies like borrow checking and fearless concurrency<sup id="fnref:fearless-concurrency"><a href="#fn:fearless-concurrency">17</a></sup> are essential. These are non-local problems and require system-wide solutions.</p>
<h2 id="categories-of-safety">Categories of safety</h2>
<p>I like to break the memory safety problem down into five categories. Each of these is addressed with a different strategy.</p>
<h3 id="1-lifetime-safety">1. <a href="https://www.circle-lang.org/site/lifetime/">Lifetime safety</a></h3>
<p>This is a hard one. How do we eliminate dangling pointer bugs<sup id="fnref:dangling-pointer"><a href="#fn:dangling-pointer">18</a></sup> for objects that are allocated on the stack? Borrow checker technology is a compile-time local analysis that defines a network of constraints against a function&#39;s control flow graph. Solving the constraints grows regions, which define the points at which each loan is in scope. Invalidating actions, such as reads or writes to places that overlap in-scope loans raise borrow checker errors. This is a brilliant system. It&#39;s compatible with C++&#39;s manual memory management and RAII<sup id="fnref:raii"><a href="#fn:raii">19</a></sup> object model.</p>
<p>Borrow checking a function only has to consider the body of that function. It avoids whole-program analysis by instituting the <em>Law of Exclusivity</em>. Checked references (borrows) come in two flavors: mutable and shared, noted respectively as <code>T^</code> and <code>const T^</code>. There can be one live mutable reference to a place, or any number of shared references to a place, but not both at once. Upholding this principle makes it much easier to reason about your program. If a function is passed a mutable reference and some shared references, you can be certain that the function won&#39;t have side effects that, through the mutable reference, cause the invalidation of those shared references. Why not? Because you can&#39;t form shared references to an overlapping same place as the mutable reference to even pass to that function.</p>
<p>This principle eliminates much subtlety needed for library work. The downside is a loss of flexibility. There are idioms that are expressible with unsafe that aren&#39;t expressible with borrows. Clever engineers have spent a lot of effort developing safe analogs to existing unsafe paradigms.</p>
<p>Is there a learning curve? Is there disruption? Of course. But what alternative do we have? C++&#39;s current safety story is unacceptable. If you&#39;re going to keep writing code that runs on devices attached to the network, you&#39;re going to have to harden it against vulnerabilities. If you want to use manual memory management and RAII, the borrow is the only viable option.</p>
<h3 id="2-type-safety-null-variety">2. <a href="https://www.circle-lang.org/site/type/">Type safety - null variety</a></h3>
<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&#39;t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p>
<p>-- <cite>Tony Hoare<sup id="fnref:hoare"><a href="#fn:hoare">20</a></sup></cite></p>
</blockquote>
<p>The &#34;billion-dollar mistake&#34; is a type safety problem. Consider <code>std::unique_ptr</code>. It has two states: engaged and disengaged. The class presents member functions like <code>operator*</code> and <code>operator-&gt;</code> that are valid when the object is in the engaged state and <em>undefined</em> when the object is disengaged. <code>-&gt;</code> is the most important API for smart pointers. Calling it when the pointer is null? That&#39;s your billion-dollar mistake.</p>
<p>As Hoare observes, the problem was conflating two different things, a pointer to an object and an empty state, into the same type and giving them the same interface. Smart pointers should only hold valid pointers. If you want to represent an empty state, use some other mechanism that has its own interface. Denying the null state eliminates undefined behavior.</p>
<p><code>std2::unique_ptr</code> has no null state. There&#39;s no default constructor. If the object is in scope, you can dereference it without risk of undefined behavior. Why doesn&#39;t C++ simply introduce its own fixed <code>unique_ptr</code> without a null state? Blame C++11 move semantics.</p>
<p>How do you move objects around in C++? Use <code>std::move</code> to select the move constructor. That moves data out of the old object, leaving it in a default state. For smart pointers, that&#39;s the null state. If <code>unique_ptr</code> didn&#39;t have a null state, it couldn&#39;t be moved in C++.</p>
<p>Addressing the null type safety problem means entails overhauling the object model. Safe C++ features a new kind of move: <em>relocation</em>, also called <em>destructive move</em>. Unless explicitly initialized, objects start out <em>uninitialized</em>. They can&#39;t be used in this state. When you assign to an object, it becomes initialized. When you relocate from an object, it&#39;s back to being uninitialized. If you relocate from an object inside control flow, it becomes <em>potentially uninitialized</em>, and its destructor is conditionally executed after reading an automatically-generated drop flag.</p>
<pre><code>int main() {
  // p is uninitialized.
  std2::unique_ptr&lt;int&gt; p;

  // Error: p is uninitialized.
  int x = *p;

  // p is definitely initialized.
  p = std2::unique_ptr&lt;int&gt;::make(5);

  // Ok.
  int y = *p;

  // p is moved into q. Now p is uninitialized again.
  auto q = rel p;

  // Error: p is uninitialized.
  int z = *p;
}
</code></pre>
<p>The <em>rel-expression</em> names a local variable object or subobject and relocates that into a new value. The old object becomes uninitialized. Any uses of uninitialized objects generates a compiler error. Using a null <code>unique_ptr</code> was undefined behavior. Using an uninitialized one is a compile-time error.</p>
<p>We have to reimagine our standard library in the presence of relocation. Most kinds of resource handles include null states. These should all be replaced by safe versions to reduce exposure to unsafe APIs.</p>
<h3 id="3-type-safety-union-variety">3. <a href="https://www.circle-lang.org/site/type/">Type safety - union variety</a></h3>
<p>The compiler can only relocate local variables. How do we move objects that live on the heap, or for which we only have a pointer or reference? We need to use optional types.</p>
<pre><code>template&lt;typename T&gt;
choice optional {
  default none,
  some(T)
};

struct Data {
  // May be engaged (some) or disengaged (none).
  optional&lt;std2::unique_ptr&lt;int&gt;&gt; value;
};
</code></pre>
<p>We use an optional type to represent both aspects of our the smart pointer: disengaged (<code>none</code>) and engaged (<code>some</code>). If you want to move the pointer, detach it from the optional, which changes the state of the optional from <code>some</code> to <code>none</code>. The C++ Standard Library has an optional type,<sup id="fnref:optional"><a href="#fn:optional">21</a></sup> but it&#39;s not safe to use. The optional API is full of undefined behaviors.<sup id="fnref:optional-undefined"><a href="#fn:optional-undefined">22</a></sup></p>
<p><img alt="std::optional::operator*" src="https://www.circle-lang.org/site/optional-undefined.png"/></p>
<p>A similar class, <code>std::expected</code>, which is new to C++23, is also full of undefined behaviors.<sup id="fnref:expected-undefined"><a href="#fn:expected-undefined">23</a></sup></p>
<p>If we were to wrap the safe <code>std2::unique_ptr</code> in an <code>std::optional</code>, it would be just as unsafe as using <code>std::unique_ptr</code>. Using <code>-&gt;</code> with a disengaged value would cause undefined behavior.</p>
<p>The new <code>std2::optional</code> is a <em>choice type</em>, a first-class discriminated union, that can only be accessed with <em>pattern matching</em>. Pattern matching makes the union variety of type safety violations impossible: we can&#39;t access the wrong state of the sum type.</p>
<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;

union Value {
  int i32;
  float f32;
  double f64;
  const char* str;
};

void print(Value val) {
  // C++ does not protect us from accessing bits with the wrong type.
  // Catastrophe!
  std::cout&lt;&lt; val.str&lt;&lt; &#34;\n&#34;;
}

int main() {
  Value value { };
  value.i32 = 101;
  print(value);
}
</code></pre>
<p>C++&#39;s sum type support is built on top of unions. Unions are extremely unsafe. Naming a union field is like implicitly using <code>reintepret_cast</code> to convert the object&#39;s bits into the type of the field. The defects in <code>std::optional</code> and <code>std::expected</code> are of this nature: the libraries don&#39;t guard against access using an invalid type. C++ builds abstractions on top of unions, but they&#39;re not <em>safe</em> abstractions.</p>
<pre><code>#feature on safety
#include &lt;iostream&gt;
#include &lt;string&gt;

// A discriminated union that&#39;s impossible to misuse.
choice Value {
  i32(int),
  f32(float),
  f64(double),
  str(std::string)
};

void print(Value val) {
  match(val) {
    // Type safety bugs are impossible inside the pattern match.
    // The alternatives listed must be exhaustive.
    .i32(i32) =&gt; &amp;std::cout&lt;&lt; i32&lt;&lt; &#34;\n&#34;;
    .f32(f32) =&gt; &amp;std::cout&lt;&lt; f32&lt;&lt; &#34;\n&#34;;
    .f64(f64) =&gt; &amp;std::cout&lt;&lt; f64&lt;&lt; &#34;\n&#34;;
    .str(str) =&gt; &amp;std::cout&lt;&lt; str&lt;&lt; &#34;\n&#34;;
  };
}

int main() {
  print(.i32(5));
  print(.f32(101.3f));
  print(.f64(3.15159));
  print(.str(&#34;Hello safety&#34;));
}
</code></pre>
<p>Choice types are Circle&#39;s type-safe offering. They&#39;re just like Rust&#39;s enums,<sup id="fnref:rust-enum"><a href="#fn:rust-enum">24</a></sup> one of features most credited for that language&#39;s enviable ergonomics. Accessing members of a choice object requires testing for the active type with a <em>match-expression</em>. If the match succeeds, a new declaration is bound to the corresponding payload, and that declaration is visible in the scope following the <code>=&gt;</code>.</p>
<p>The compiler also performs exhaustiveness testing. Users must name all the alternatives, or use a wildcard <code>_</code> to default the unnamed ones.</p>
<p>Pattern matching and choice types aren&#39;t just a qualify-of-life improvement. They&#39;re a critical part of the memory safety puzzle and all modern languages provide them.</p>
<h3 id="4-thread-safety">4. <a href="https://www.circle-lang.org/site/thread/">Thread safety</a></h3>
<p>A memory-safe language should be robust against data races to shared mutable state. If one thread is writing to shared state, no other thread should be allowed access to it. Rust provides thread safety using a really novel extension of the type system. </p>
<h3 id="5-runtime-checks">5. <a href="https://www.circle-lang.org/site/safe/#panic-functions">Runtime checks</a></h3>
<h2 id="the-road-not-taken">The road not taken</h2>
<p>There are many efforts at library mitigations<sup id="fnref:miracle-ptr"><a href="#fn:miracle-ptr">25</a></sup> <sup id="fnref:buffer-hardening"><a href="#fn:buffer-hardening">26</a></sup> of undefined behaviors. There is work on sanitizers, which are special build targets that flag undefined behavior at runtime.<sup id="fnref:addresssan"><a href="#fn:addresssan">27</a></sup> <sup id="fnref:pizlonator"><a href="#fn:pizlonator">28</a></sup> These kinds of projects serve as a first defense against vulnerabilities in C++ codes. </p>
<p>But what work has been done to bring memory safety constructs directly to the C++ language? Aside from Circle C++, there is no ongoing effort to extend C++ for the rigorous memory safety guarantees required by security researches in industry and government. There are no attempts at building a safe context into mainline compilers like MSVC, Clang and GCC. Companies that built their fortunes on this language, such as Microsoft, Google, NVIDIA, Intel, Adobe and Bloomberg have not made efforts to stave off its obsolescence. The C++ ISO committee has no insights into this problem and no strategy to address it.</p>
<p>Why have compiler vendors and standardization workers not taken seriously the growing costs of security vulnerabilties in C++? I think it&#39;s because the problem seems too challenging for any single effort to make real headway:</p>
<p><strong>The solution has a broad scope.</strong> Memory safety vulnerabilities come in a menagerie of categories, related to lifetime safety, bounds safety, thread safety, and several flavors of type safety. Each needs its own treatment. The surface area for addressing all of these categories makes for a very large extension. One belief is that all these changes in the aggregate represent too much work for either the committee or the vendors to to deal with.</p>
<p><strong>Major upgrades to tooling are required.</strong> Not only does the compiler frontend need an overhaul, but a new middle-end is required to support borrow checking and object relocation. A new standard library has to be written that gradually replaces the legacy one, reducing exposure to unsafe operations. Frontend, backend, library. This is a vertical problem larger than the usual remit of compiler developers.</p>
<p><strong>The new technology is difficult.</strong> The most novel part of Rust&#39;s safety model is its NLL borrow checker.<sup id="fnref2:borrow-checking"><a href="#fn:borrow-checking">10</a></sup> This is complicated feature. You can&#39;t begin to understand how it works after reading an introductory book about Rust or through casual usage of the language. The sophistication of the feature has scared off everyone from considering integrating the technology into a C++ compiler. It&#39;s a beautiful idea, but it feels a bit like mastering alien technology if you&#39;re a frontend engineer who doesn&#39;t already work extensively with control-flow graphs.</p>
<p><strong>Mainline compilers are too burdensome for experimentation.</strong> C++ is the result of more than 50 years of evolution, from K&amp;R C to C++23. The language is fantastically complex with compilers that are commensurately challenging to write and maintain. It would be very difficult to do this level of experimentation on MSVC, Clang or GCC. The Circle compiler is only about 310,000 lines of code, which is compact compared to other compilers. I wrote every line, and I know how everything fits together, and this gives me a huge agility advantage compared to people working on the mainline toolchains.</p>
<p><strong>C++ users are arrogant.</strong> There&#39;s an attitude of &#34;get good&#34; among C and C++ practitioners. They reason that if you make a mess of things, it&#39;s your own fault, and the solution is to get better. But software design is a collaborative effort, even for one-man shops like my own. You&#39;re always relying on other people&#39;s code, and you can&#39;t understand how it all works. It&#39;s not realistic to expect flawless programming on a large project. A memory-safe language makes mistakes much less costlty: your program won&#39;t exhibit undefined behavior, and constructs that can&#39;t be checked for soundness by the compiler are flagged as potentially unsafe, giving programmers the opportunity to rethink their design and perhaps express those operations using memory safe APIs.</p>
<p>Institutional users of C++ should be worried. The security community is baying for this language&#39;s extinction. The government is on our case about it, and legislation banning C++&#39;s use in certain sectors looks like a possibility. I don&#39;t think nitpicking the NSA is a compelling response. </p>
<p><em>We have to do something real.</em> We should solve the underlying safety problem. I want to see industry jolted into action. </p>

              
            </div>
          </div></div>
  </body>
</html>
