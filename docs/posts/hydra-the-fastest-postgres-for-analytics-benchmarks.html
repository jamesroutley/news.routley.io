<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://hydras.io/blog/2022-12-13-how-we-built-fastest-postgres-db-for-analytics">Original</a>
    <h1>Hydra ‚Äì the fastest Postgres for analytics [benchmarks]</h1>
    
    <div id="readability-page-1" class="page"><div>
      <article>
        <p>Hydra is a fully-managed open source data warehouse built on Postgres. It‚Äôs easy to use and designed to scale analytics (OLAP) &amp; hybrid transactional workloads. Our team is excited to announce that Hydra is the fastest Postgres database for analytics. Learn how we enabled columnar storage, vectorization and query parallelization to deliver 23x faster performance than Postgres!</p>

<p><a href="https://calendly.com/hydrasdb/hydra-early-access">Schedule time with our team to get your 14 day free trial</a> üêòüéÑüí®¬†of cloud-managed Hydra!</p>

<h2>Postgres OLAP is here</h2>

<p>Hydra scales analytic performance with:</p>

<ul>
<li>Columnar storage</li>
<li>Parallelized query execution</li>
<li>Vectorization</li>
</ul>

<h2>Benchmarks</h2>

<p>We chose to use the ClickBench benchmarks due to their relevance and usefulness to analytic workloads. <a href="https://github.com/ClickHouse/ClickBench/#readme">ClickBench</a> methodology is as follows:</p>

<blockquote>
<p>This benchmark represents typical workload in the following areas: clickstream and traffic analysis, web analytics, machine-generated data, structured logs, and events data. It covers the typical queries in ad-hoc analytics and real-time dashboards. The dataset from this benchmark was obtained from the actual traffic recording of one of the world&#39;s largest web analytics platforms.[1]</p>
</blockquote>

<p><img alt="Query Speed Benchmarks (via ClickBench)" src="https://hydras.io/assets/blog/2022-12-13/benchmarks-80c22880c171cee7cca18d496ca3d497c20767233a776921e3b54e3f1702be46.png"/></p>

<p><strong><a href="#clickbench">Jump to the full ClickBench report.</a></strong></p>

<h2>Columnar Storage</h2>

<p>Columnar storage is a key part of the data warehouse, but why is that? Let‚Äôs review what columnar storage is and why it‚Äôs important for scalable analytics.</p>

<p>By default, data in Postgres is stored in a heap table. Heap tables are arranged row-by-row, similar to how you would arrange data when creating a large spreadsheet. Columnar tables are organized transversely from row tables. Instead of rows being added one after another, rows are inserted in bulk into a stripe. Within each stripe, data from each column is stored next to each other. Imagine rows of a table containing:</p>
<div><pre><code>| a | b | c | d |
| a | b | c | d |
| a | b | c | d |
</code></pre></div>
<p>This data would be stored as follows in columnar:</p>
<div><pre><code>| a | a | a |
| b | b | b |
| c | c | c |
| d | d | d |
</code></pre></div>
<p>Heap row tables are organized into <em>pages</em>. Each page holds 8kb of data. Each page holds pointers to the start of each row in the data. In columnar, you can think of each stripe as a row of metadata that also holds up to 150,000 rows of data. Within each stripe, data is divided into <em>chunks</em> of 1000 rows, and then within each chunk, there is a ‚Äúrow‚Äù for each <em>column</em> of data you stored in it. Additionally, columnar stores the minimum, maximum, and count for each column in each chunk.</p>

<h3>Advantages to columnar</h3>

<p>Columnar is optimized for table scans ‚Äî in fact, it doesn‚Äôt use indexes at all. Using columnar, it‚Äôs much quicker to obtain all data for a particular column. The database doesn‚Äôt need to read data that you are not interested in at the moment. It also uses the metadata about the values in the chunks to eliminate reading data. This is a form of ‚Äúauto-indexing‚Äù the data.</p>

<p>In addition, very high data compression is possible because similar data is stored next to each other. Data compression is an important benefit because columnar is often used to store huge amounts of data. By compressing the data, you can effectively read data more quickly from disk, which both reduces I/O and increasing effective fetch speed. It has the additional effect of making better use of disk caching as data is cached in its compressed form. Lastly, you greatly reduce your storage costs.</p>

<h3>Our approach to columnar</h3>

<p>Our approach is to use a Postgres extension. Extensions allows us to maintain 100% compatibility between Hydra and the community Postgres versions &amp; ecosystem. We looked into existing open source columnar storage engines and chose the columnar access method developed at Citus[2]. Testing Citus Columnar we found performance was better than row-based tables for analytics, but could be improved with vectorization and parallel query execution.</p>

<h2>Parallelization + Vectorization</h2>

<p>It was clear that columnar storage was missing features that were essential to boost performance. The obvious choice was to enable the parallelization of queries. We started with single process columnar execution and enabled parallel execution of SELECT queries. This provided an impressive performance boost.</p>

<p>The next step was to enable vectorization when processing queries. We started by enabling vectorized execution on <em>WHERE</em> clauses. Work will continue as we invest resources in vectorized execution of aggregate functions, use of explicit SIMD execution, support for more types but in general vectorized execution.</p>

<h3>Parallelization</h3>

<p>PostgreSQL introduced parallelization feature in version 9.6. Only single process was doing all the work before that. Parallelism in PostgreSQL was implemented as part of multiple features which cover sequential scans, aggregates, and joins.</p>

<p>By definition, query parallelization works by dividing the work of a query into smaller tasks, which are then executed simultaneously on multiple cores or machines. This allows the database to take advantage of modern processors, which are designed to perform multiple operations simultaneously and can significantly improve the performance of queries that involve large amounts of data.</p>

<p>To enable parallelization, custom scan needs to implement specific <strong><em>CustomExecMethods</em></strong> callbacks.</p>
<div><pre><code>  <span>Size</span> <span>(</span><span>*</span><span>EstimateDSMCustomScan</span><span>)</span> <span>(</span><span>CustomScanState</span> <span>*</span><span>node</span><span>,</span>
                                 <span>ParallelContext</span> <span>*</span><span>pcxt</span><span>);</span>
  <span>void</span> <span>(</span><span>*</span><span>InitializeDSMCustomScan</span><span>)</span> <span>(</span><span>CustomScanState</span> <span>*</span><span>node</span><span>,</span>
                                   <span>ParallelContext</span> <span>*</span><span>pcxt</span><span>,</span>
                                   <span>void</span> <span>*</span><span>coordinate</span><span>);</span>
  <span>void</span> <span>(</span><span>*</span><span>ReInitializeDSMCustomScan</span><span>)</span> <span>(</span><span>CustomScanState</span> <span>*</span><span>node</span><span>,</span>
                                     <span>ParallelContext</span> <span>*</span><span>pcxt</span><span>,</span>
                                     <span>void</span> <span>*</span><span>coordinate</span><span>);</span>
  <span>void</span> <span>(</span><span>*</span><span>InitializeWorkerCustomScan</span><span>)</span> <span>(</span><span>CustomScanState</span> <span>*</span><span>node</span><span>,</span>
                                      <span>shm_toc</span> <span>*</span><span>toc</span><span>,</span>
                                      <span>void</span> <span>*</span><span>coordinate</span><span>);</span>
</code></pre></div>
<p>PostgreSQL parallelization communication is done via shared memory and parallelization is achieved with multiple processes rather than threads.</p>

<p>Queries start with single process called <em>leader</em> that will provide size of custom scan shared memory via <strong>EstimateDSMCustomScan</strong>. After that, leader needs to initialize shared memory with <strong>InitializeDSMCustomScan</strong>. Custom scan shared memory structure is shared between workers and each worker needs to setup it own memory custom scan structures in <strong>InitializeWorkerCustomScan</strong> callback. <strong>ReinitializeDSMCustomScan</strong> is used when there is request to re-initialize scan, which means that workers will shutdown and than be created again - e.g. behavior of nested-loop joins.</p>

<p>There was question that needed to be answered when doing custom scan parallel implementation - how to divide data between workers to scan and process unique tuples? Luckily, internal columnar storage structure helped us with this problem and solution was straight forward - each worker will work on different stripe. It provided us with logical and physical barrier that will satisfy the uniqueness of data that is processed in parallel.</p>

<p>Shared memory variable is used to track allocation of next stripe. Variable is defined as atomic so fetch-and-add CPU instruction will handle atomicity between workers‚Äô assignments.</p>

<h3>Vectorization</h3>

<p>Vectorized execution is a technique that is used to improve the performance of database queries by executing multiple operations simultaneously. This is in contrast to traditional execution, where each operation is performed one at a time.</p>

<p>Vectorized execution works by dividing data into small chunks, called vectors, and then executing multiple operations on each vector in parallel. This allows the database to take advantage of modern processors, which are designed to perform multiple operations simultaneously, and can significantly improve the performance of queries that involve large amounts of data.</p>

<p>Vectorization currently supported in Hydra, for now, is limited to WHERE clauses. These clauses are processed directly in custom scan node so we have full control how to execute code.</p>

<p>Vectorized execution will be used only if there exists vectorized function that accepts same arguments and operator between them. Currently, we support basic types and compression operator between them. Supported types are CHAR, SMALLINT, INT, BIGINT, DATE, TIME.</p>

<p>Another limitation of current implementation is that only work with single variable and constant value.</p>

<p>WHERE clause are stored in list and and <em>top-level</em> clauses will be evaluated sequentially by <strong><em>AND</em></strong> operator. More complex clauses will construct multiple tree like structures.</p>

<p>Hydra vectorization expects that all clauses in single tree can be vectorized and if this is not true vectorized execution will not be used for that branch.</p>
<div><pre><code><span>CREATE</span> <span>TABLE</span> <span>t</span><span>(</span><span>a</span> <span>INT</span><span>,</span> <span>b</span> <span>TEXT</span><span>)</span> <span>using</span> <span>columnar</span><span>;</span>
<span>INSERT</span> <span>INTO</span> <span>t</span> <span>SELECT</span> <span>g</span><span>,</span> <span>g</span> <span>%</span> <span>20</span><span>,</span> <span>&#39;random&#39;</span> <span>||</span> <span>g</span> <span>FROM</span> <span>generate_series</span><span>(</span><span>0</span><span>,</span><span>1000000</span> <span>-</span> <span>1</span><span>)</span> <span>g</span><span>;</span>
</code></pre></div><div><pre><code><span>postgres</span><span>=#</span> <span>set</span> <span>columnar</span><span>.</span><span>enable_vectorization</span> <span>to</span> <span>false</span><span>;</span>
<span>SET</span>
<span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span><span>;</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>--------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2592</span><span>.</span><span>51</span><span>..</span><span>2592</span><span>.</span><span>52</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>92</span><span>.</span><span>51</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Filter</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span>
         <span>Columnar</span> <span>Chunk</span> <span>Group</span> <span>Filters</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>

<span>postgres</span><span>=#</span> <span>set</span> <span>columnar</span><span>.</span><span>enable_vectorization</span> <span>to</span> <span>default</span><span>;</span>
<span>SET</span>
<span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span><span>;</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>--------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2592</span><span>.</span><span>51</span><span>..</span><span>2592</span><span>.</span><span>52</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>92</span><span>.</span><span>51</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span>
         <span>Columnar</span> <span>Chunk</span> <span>Group</span> <span>Filters</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
         <span>Columnar</span> <span>Vectorized</span> <span>Filter</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
</code></pre></div>
<p>In this first example single WHERE clause is used which can be vectorized so we can trigger vectorized execution for this query. Clause list will be evaluated</p>

<ul>
<li><strong>AND</strong>( <em>b &lt; 15</em> )</li>
</ul>
<div><pre><code><span>postgres</span><span>=#</span> <span>set</span> <span>columnar</span><span>.</span><span>enable_vectorization</span> <span>to</span> <span>false</span><span>;</span>
<span>SET</span>
<span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span> <span>AND</span> <span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>;</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>---------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2638</span><span>.</span><span>77</span><span>..</span><span>2638</span><span>.</span><span>78</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>138</span><span>.</span><span>77</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Filter</span><span>:</span> <span>((</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span> <span>AND</span> <span>(</span><span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>::</span><span>text</span><span>))</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span>
         <span>Columnar</span> <span>Chunk</span> <span>Group</span> <span>Filters</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>

<span>postgres</span><span>=#</span> <span>set</span> <span>columnar</span><span>.</span><span>enable_vectorization</span> <span>to</span> <span>default</span><span>;</span>
<span>SET</span>
<span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span> <span>AND</span> <span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>;</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>---------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2638</span><span>.</span><span>77</span><span>..</span><span>2638</span><span>.</span><span>78</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>138</span><span>.</span><span>77</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Filter</span><span>:</span> <span>(</span><span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>::</span><span>text</span><span>)</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span>
         <span>Columnar</span> <span>Chunk</span> <span>Group</span> <span>Filters</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
         <span>Columnar</span> <span>Vectorized</span> <span>Filter</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
</code></pre></div>
<p>This example shows that even if we don‚Äôt have support for all where clauses still vectorization will be used. This is possible because top-level clauses are independent and can be processed sequentially. Clauses for this example are evaluated as</p>

<ul>
<li><strong>AND</strong>( <em>b &lt; 15</em>, <em>c &lt;&gt; ‚Äò‚Äô</em> )</li>
</ul>
<div><pre><code><span>postgres</span><span>=#</span> <span>set</span> <span>columnar</span><span>.</span><span>enable_vectorization</span> <span>to</span> <span>false</span><span>;</span>
<span>SET</span>

<span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span> <span>OR</span> <span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>;</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>---------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2916</span><span>.</span><span>30</span><span>..</span><span>2916</span><span>.</span><span>31</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>416</span><span>.</span><span>30</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Filter</span><span>:</span> <span>((</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span> <span>OR</span> <span>(</span><span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>::</span><span>text</span><span>))</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span>

<span>postgres</span><span>=#</span> <span>set</span> <span>columnar</span><span>.</span><span>enable_vectorization</span> <span>to</span> <span>default</span><span>;</span>
<span>SET</span>
<span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span> <span>OR</span> <span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>;</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>---------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2916</span><span>.</span><span>30</span><span>..</span><span>2916</span><span>.</span><span>31</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>416</span><span>.</span><span>30</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Filter</span><span>:</span> <span>((</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span> <span>OR</span> <span>(</span><span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>::</span><span>text</span><span>))</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span>
</code></pre></div>
<p>In this example, vectorization will not be used. OR operator is used between two clauses where one of clauses can be vectorized while second cannot. Clauses are evaluated as</p>

<ul>
<li><strong>AND</strong>( <strong>OR</strong> ( <em>b &lt; 15</em>, <em>c &lt;&gt; ‚Äò‚Äô</em> ) )</li>
</ul>

<p>Since not all tree leafs for OR branch cannot be vectorized we don‚Äôt use vectorization for this query.</p>
<div><pre><code><span>postgres</span><span>=#</span> <span>EXPLAIN</span> <span>SELECT</span> <span>sum</span><span>(</span><span>a</span><span>)</span> <span>FROM</span> <span>t</span> <span>WHERE</span> <span>b</span> <span>&lt;</span> <span>15</span> <span>AND</span> <span>(</span><span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span> <span>OR</span> <span>a</span> <span>&lt;</span> <span>40</span><span>);</span>
                                   <span>QUERY</span> <span>PLAN</span>
<span>---------------------------------------------------------------------------------</span>
 <span>Aggregate</span>  <span>(</span><span>cost</span><span>=</span><span>2638</span><span>.</span><span>77</span><span>..</span><span>2638</span><span>.</span><span>78</span> <span>rows</span><span>=</span><span>1</span> <span>width</span><span>=</span><span>8</span><span>)</span>
   <span>-&gt;</span>  <span>Custom</span> <span>Scan</span> <span>(</span><span>ColumnarScan</span><span>)</span> <span>on</span> <span>t</span>  <span>(</span><span>cost</span><span>=</span><span>0</span><span>.</span><span>00</span><span>..</span><span>138</span><span>.</span><span>77</span> <span>rows</span><span>=</span><span>1000000</span> <span>width</span><span>=</span><span>4</span><span>)</span>
         <span>Filter</span><span>:</span> <span>((</span><span>c</span> <span>&lt;&gt;</span> <span>&#39;&#39;</span><span>::</span><span>text</span><span>)</span> <span>OR</span> <span>(</span><span>a</span> <span>&lt;</span> <span>40</span><span>))</span>
         <span>Columnar</span> <span>Projected</span> <span>Columns</span><span>:</span> <span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span>
         <span>Columnar</span> <span>Chunk</span> <span>Group</span> <span>Filters</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
         <span>Columnar</span> <span>Vectorized</span> <span>Filter</span><span>:</span> <span>(</span><span>b</span> <span>&lt;</span> <span>15</span><span>)</span>
</code></pre></div>
<p>Last example shows how vectorized execution is used for one of the clauses but not for the second clause.</p>

<p>Where clause is evaluated as:</p>

<ul>
<li><strong>AND</strong>( <em>b &lt; 15</em>, <strong>OR</strong> ( <em>c &lt;&gt; ‚Äò‚Äô</em> , a &lt; 40 ) )</li>
</ul>

<p>Vectorization can be enabled or disabled with <strong><em>columnar.enable_vectorization</em></strong> GUC variable which is by default set to true.</p>

<p>Vectorization is there to to speed up execution but if non-vectorized performance is fast enough vectorization can even add overhead to performance. We are expecting in OLAP cases that are dealing with complex queries and big data that this feature can improve performance.</p>

<h3>Optimizing Postgres Settings</h3>

<p>Getting the most performance out of PostgreSQL isn‚Äôt complete without tuning. Postgres default parameters do not take full advantage of the hardware you are running it on without telling Postgres how much it can use. If you are running Hydra on a dedicated machine, these are the settings we recommend for Hydra. You may wish to reduce <code>work_mem</code> and <code>hash_mem_multiplier</code> depending on your available memory and concurrency load.</p>
<div><pre><code>max_worker_processes <span>=</span> 2 <span>*</span> num CPUs
max_parallel_workers <span>=</span> num CPUs
columnar.min_parallel_processes <span>=</span> num CPUs
shared_buffers <span>=</span> 25% of your total available memory
effective_cache_size <span>=</span> 75% of your total available memory
effective_io_concurrency <span>=</span> 100
hash_mem_multiplier <span>=</span> 8
work_mem <span>=</span> 64MB
</code></pre></div>
<h2>ClickBench Report <a id="clickbench"></a></h2>

<p>You can <a href="https://benchmark.clickhouse.com/#eyJzeXN0ZW0iOnsiQXRoZW5hIChwYXJ0aXRpb25lZCkiOnRydWUsIkF0aGVuYSAoc2luZ2xlKSI6dHJ1ZSwiQXVyb3JhIGZvciBNeVNRTCI6dHJ1ZSwiQXVyb3JhIGZvciBQb3N0Z3JlU1FMIjp0cnVlLCJCeXRlSG91c2UiOnRydWUsIkNpdHVzIjp0cnVlLCJjbGlja2hvdXNlLWxvY2FsIChwYXJ0aXRpb25lZCkiOnRydWUsImNsaWNraG91c2UtbG9jYWwgKHNpbmdsZSkiOnRydWUsIkNsaWNrSG91c2UiOnRydWUsIkNsaWNrSG91c2UgKHR1bmVkKSI6dHJ1ZSwiQ2xpY2tIb3VzZSAoenN0ZCkiOnRydWUsIkNsaWNrSG91c2UgQ2xvdWQiOnRydWUsIkNyYXRlREIiOnRydWUsIkRhdGFiZW5kIjp0cnVlLCJkYXRhZnVzaW9uIjp0cnVlLCJBcGFjaGUgRG9yaXMiOnRydWUsIkRydWlkIjp0cnVlLCJEdWNrREIgKFBhcnF1ZXQpIjp0cnVlLCJEdWNrREIiOnRydWUsIkVsYXN0aWNzZWFyY2giOnRydWUsIkVsYXN0aWNzZWFyY2ggKHR1bmVkKSI6dHJ1ZSwiR3JlZW5wbHVtIjpmYWxzZSwiSGVhdnlBSSI6dHJ1ZSwiSHlkcmEiOnRydWUsIkluZm9icmlnaHQiOnRydWUsIk1hcmlhREIgQ29sdW1uU3RvcmUiOnRydWUsIk1hcmlhREIiOnRydWUsIk1vbmV0REIiOnRydWUsIk1vbmdvREIiOnRydWUsIk15U1FMIChNeUlTQU0pIjp0cnVlLCJNeVNRTCI6dHJ1ZSwiUGlub3QiOnRydWUsIlBvc3RncmVTUUwiOnRydWUsIlF1ZXN0REIgKHBhcnRpdGlvbmVkKSI6dHJ1ZSwiUXVlc3REQiI6dHJ1ZSwiUmVkc2hpZnQiOnRydWUsIlNlbGVjdERCIjp0cnVlLCJTaW5nbGVTdG9yZSI6dHJ1ZSwiU25vd2ZsYWtlIjp0cnVlLCJTUUxpdGUiOnRydWUsIlN0YXJSb2NrcyAodHVuZWQpIjp0cnVlLCJTdGFyUm9ja3MiOnRydWUsIlRpbWVzY2FsZURCIChjb21wcmVzc2lvbikiOnRydWUsIlRpbWVzY2FsZURCIjp0cnVlfSwidHlwZSI6eyJzdGF0ZWxlc3MiOmZhbHNlLCJtYW5hZ2VkIjpmYWxzZSwiSmF2YSI6ZmFsc2UsImNvbHVtbi1vcmllbnRlZCI6ZmFsc2UsIkMrKyI6ZmFsc2UsIk15U1FMIGNvbXBhdGlibGUiOmZhbHNlLCJyb3ctb3JpZW50ZWQiOmZhbHNlLCJDIjpmYWxzZSwiUG9zdGdyZVNRTCBjb21wYXRpYmxlIjp0cnVlLCJDbGlja0hvdXNlIGRlcml2YXRpdmUiOmZhbHNlLCJlbWJlZGRlZCI6ZmFsc2UsIlJ1c3QiOmZhbHNlLCJzZWFyY2giOmZhbHNlLCJkb2N1bWVudCI6ZmFsc2UsInRpbWUtc2VyaWVzIjpmYWxzZX0sIm1hY2hpbmUiOnsic2VydmVybGVzcyI6dHJ1ZSwiMTZhY3UiOnRydWUsIkwiOnRydWUsIk0iOnRydWUsIlMiOnRydWUsIlhTIjp0cnVlLCJjNmEuNHhsYXJnZSwgNTAwZ2IgZ3AyIjp0cnVlLCJjNS40eGxhcmdlLCA1MDBnYiBncDIiOnRydWUsImM2YS5tZXRhbCwgNTAwZ2IgZ3AyIjp0cnVlLCIxNiB0aHJlYWRzIjp0cnVlLCIyMCB0aHJlYWRzIjp0cnVlLCIyNCB0aHJlYWRzIjp0cnVlLCIyOCB0aHJlYWRzIjp0cnVlLCIzMCB0aHJlYWRzIjp0cnVlLCI0OCB0aHJlYWRzIjp0cnVlLCI2MCB0aHJlYWRzIjp0cnVlLCJtNWQuMjR4bGFyZ2UiOnRydWUsImYxNnMgdjIiOnRydWUsImM2YS40eGxhcmdlLCAxNTAwZ2IgZ3AyIjp0cnVlLCJyYTMuMTZ4bGFyZ2UiOnRydWUsInJhMy40eGxhcmdlIjp0cnVlLCJyYTMueGxwbHVzIjp0cnVlLCJTMiI6dHJ1ZSwiUzI0Ijp0cnVlLCIyWEwiOnRydWUsIjNYTCI6dHJ1ZSwiNFhMIjp0cnVlLCJYTCI6dHJ1ZX0sImNsdXN0ZXJfc2l6ZSI6eyIxIjp0cnVlLCIyIjp0cnVlLCI0Ijp0cnVlLCI4Ijp0cnVlLCIxMiI6dHJ1ZSwiMTYiOnRydWUsIjMyIjp0cnVlLCI2NCI6dHJ1ZSwiMTI4Ijp0cnVlLCJzZXJ2ZXJsZXNzIjp0cnVlLCJ1bmRlZmluZWQiOnRydWV9LCJtZXRyaWMiOiJob3QiLCJxdWVyaWVzIjpbdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZSx0cnVlLHRydWUsdHJ1ZV19">see the results for yourself</a> to review the queries, methodology, and data size.</p>

<p><img alt="Screenshot of ClickBench results" src="https://hydras.io/assets/blog/2022-12-13/clickbench-9bfeae8a8cc0546dafa313c9b0b623a1048b36697356b0d1f1d9d783cbd79257.png"/></p>

<h2>Conclusion and Future Work</h2>

<p>With Hydra, it‚Äôs never been easier to scale analytics and eliminate data silos with Postgres. This is just the start- the Hydra team will keep investing our resources to drive performance faster. Hydra is open source and 100% compatible with community Postgres. You can test this out for yourself using hydra docker-compose!</p>

<p>Starting today, we‚Äôre excited to extend <strong>14-day free trials</strong> of Hydra‚Äôs managed cloud databases! <a href="https://calendly.com/hydrasdb/hydra-early-access">Schedule time</a> with our team to unlock your free trial.</p>

<p>We‚Äôd love your support, <a href="https://github.com/HydrasDB/hydra">GH stars</a>, and contributions to Hydra open source. Join our <a href="https://discord.com/invite/SQrwnAxtDw">Discord</a> channel to share your test results and ideas for future enhancements. Together, we can take Hydra to the next level of performance!</p>

<p>Meanwhile, our team is already hard at work to bring the next level of scale and speed to the Hydra data warehouse! Follow us on <a href="https://twitter.com/HydrasDB">Twitter</a>, <a href="https://www.linkedin.com/company/hydrasdb">LinkedIn</a>, or <a href="https://discord.gg/SQrwnAxtDw">Discord</a> to be the first to hear.</p>

<h2>References</h2>

<p>[1] <a href="https://github.com/ClickHouse/ClickBench/#readme">https://github.com/ClickHouse/ClickBench/#readme</a></p>

<p>[2] <a href="https://github.com/citusdata/citus/tree/main/src/backend/columnar">https://github.com/citusdata/citus/tree/main/src/backend/columnar</a></p>

      </article>
    </div></div>
  </body>
</html>
