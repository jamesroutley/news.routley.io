<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://maizure.org/projects/decoded-gnu-coreutils/">Original</a>
    <h1>Decoded: GNU Coreutils</h1>
    
    <div id="readability-page-1" class="page"><div id="page">

	

	<div id="content">

		

		<div>
            			<div>
				<div>

  <div id="primary">

    <main id="main" role="main">

<div>
<article id="post-252" class="page">
	
	<div>
<p><i>October 2018
</i></p>
<p><img src="https://maizure.org/projects/decoded-gnu-coreutils/GNU.png" width="640" height="320" alt="coreutils brought to you by the GNU project"/></p>
<p>This is a long-term project to decode all of the GNU coreutils in version 8.3.</p> 
<p>This resource is for novice programmers exploring the design of command-line utilities. It is best used as an accompaniment providing useful background while reading the <a href="https://github.com/MaiZure/coreutils-8.3/tree/master/src">source code</a> of the utility you may be interested in. This is <strong>not</strong> a user guide -- Please see applicable <a href="http://man7.org/linux/man-pages/dir_by_project.html#coreutils">man pages</a> for instructions on using these utilities.</p>
<p><strong>Status</strong>: Complete!
</p><ul>
<li>Phase 1 [<strong>complete</strong>] - Each utility has a dedicated page discussing the namespace and execution overview.</li>
<li>Phase 2 [<strong>complete</strong>] - Expanded discussion about important design decisions and algorithms. Tracing utility lineage both from UNIX and early Coreutils. Porting content to something more collaborative. Enhancing source walkthrough to something more useful. Creating a source code evolution visualizer</li>
<li>Phase indefinite - Line by line code walkthrough for each utility will be accomplished over a long period. <a href="https://github.com/MaiZure/decoded-coreutils">GitHub repo available</a> to gather line-by-line notes. This segment was deferred due to consistent feedback that readers were more interested in high-level discussion. </li>
</ul>


<hr/>
	
<h2>The GNU Core Utilities</h2>
<p>I&#39;ll link the utility pages here at the top. Click the command name for the detailed page decoding that utility. The discussion, source code, and walkthroughs are available on each page. <strong>Bolded</strong> utilities have been expanded as part of phase 2. Enjoy!</p>


<h2>Helpful background for code reading</h2><p>
The GNU coreutils has its foibles. Many of these utilities are approaching 30 years old and include revisions by many people over the years. Here are some things to keep in mind when reading the code:
</p><ul>
<li><strong>Tiny programs</strong> - These utilities are small, (mostly) single-source file programs designed to do one thing and do it well. They are not designed for long life or to scale beyond their role. Consequently, we see designs often considered &#39;bad practice&#39; such as:
  <ul>
  <li>Many globals</li>
  <li>Liberal use of macros</li>
  <li><code>goto</code> statements</li>
  <li>Long functions with nested switchs/loops</li>
  </ul>
</li>
<li><strong>Know POSIX</strong> - Start with the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02">Utility Syntax Guidelines</a>. In general, POSIX supports interoperability by defining appropriate inputs and outputs, but leaves the &#39;work&#39; to the implementation. While the GNU coreutils <a href="https://www.gnu.org/software/coreutils/manual/html_node/Standards-conformance.html">may not strictly conform</a> to POSIX, many ideas are entrenched: permission bits, uids/gids, environment variables, exit status, and about <a href="http://www.open-std.org/jtc1/sc22/open/n4217.pdf">3718 pages</a> of more trivia. </li>
<li><strong>Outside help</strong> - Portability is a complex problem and coreutils relies on extra help from a related project: <a href="https://www.gnu.org/s/gnulib/">gnulib</a>. Almost every utility includes functions from gnulib which are specially designed for common problems used in many places across various systems - No need to reinvent the wheel.</li>
<li><strong>Launched from a shell</strong> - The Core utilities expect support from a shell such as bash, zsh, ksh, and others. The shell forks/clones in to the utility, passes the arguments, sets up the environment, redirects I/O via pipes, and retains exit values.</li>
<li><strong>Three families</strong> - GNU coreutils were originally three distinct packages for shell, text, and file utilities. Utilities within the same type share many of the same design patterns.</li>
</ul>

<h3>Basic design</h3>
<p>Most CLI utilities look something close to this:</p>
<p><img src="https://maizure.org/projects/decoded-gnu-coreutils/general_cli_utility.png" width="1080" height="240" alt="General CLI procedure"/></p>
<p>The key ideas:</p>
<ul>
<li>A setup phase for flags, options, localization, etc</li>
<li>An argument parsing phase thats reads input to set execution parameters</li>
<li>A processing/execution phase that prepares input for one or more syscalls</li>
<li>Many opportunities to check constraints and fail out of execution
  <ul><li>Distinct EXIT status hint about problem location</li>
  <li>EXIT_FAILURE is general and commonly used</li></ul>
</li>
<li>Providing feedback after failed execution</li>
</ul>
<p>This is the framework I&#39;ll use to organize the decoding of each utility. We&#39;ll see that each has a unique variant of this idea which range from a few lines to thousands of lines. I&#39;d categorize the variants in three groups: trivial, wrappers, and full utilities</p>

<p><strong>Trivial utilities</strong></p>

<p><strong>Wrapper utilities</strong></p>

<p><strong>Full utilities</strong></p>

<hr/>

<h2>Digging deeper</h2>
<p>Let&#39;s go through the most common ideas shared across many of the utilities. Knowing these concepts beforehand should speed up code reading.</p>

<h3 id="i18n">Utility Initialization</h3>
<p>All utilities have a short initialization procedure near the beginning of <code>main()</code>: </p>
<pre>  initialize_main (&amp;argc, &amp;argv);
  set_program_name (argv[0]);
  setlocale (LC_ALL, &#34;&#34;);
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  atexit (close_stdout);
</pre>
<p>This preamble solves a few administrative issues; the most important of which are <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/locale.h.html">internationalization</a> and assigning the exit action. I&#39;ll go through each of these lines <a href="https://maizure.org/projects/decoded-gnu-coreutils/index.html#commonlines">below</a>. This lines don&#39;t impact the specific action of a utility.</p>

<h3 id="getopt">Parsing with Getopt</h3>
<p>Ever wonder why command line utilities have had the same look and feel for the past 40 years? You can thank the <a href="https://www.gnu.org/software/libc/manual/html_node/Parsing-Program-Arguments.html">Getopt</a> toolset. The bare minimum you need to know to follow the coreutils is:</p>
<ul>
<li>Command line options can be &#39;short&#39; and &#39;long&#39;, prefixed with (-) and (--) respectively. Short options are defined as a string while long options use a <a href="https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Options.html#Getopt-Long-Options">struct</a>.</li>
<li>Short options use 1) only a letter if the option has no argument, 2) A single colon (:) for mandatory arguments, and (::) for optional arguments. For example, the short option string for <em>kill</em> is: <code>Lln:s:t</code>. Which says that <code>L</code>, <code>l</code>, <code>t</code> take no arguments but <code>n</code> and <code>s</code> need an argument.</li>
<li>Long options often have a short analogue</li>
<li>The <code>getopt_long()</code> function returns the next option and is used in all utilities</li>
<li>The <code>optind</code> index is a position within the <code>argv[]</code> array for the next argument.</li>
<li>The <code>optarg</code> char pointer points to the value of the option&#39;s argument.</li>
</ul>

<h3 id="fts">Traversing the file system with fts</h3>
<p>Unix-like systems often support the <a href="https://www.freebsd.org/cgi/man.cgi?query=fts&amp;apropos=0&amp;sektion=3&amp;manpath=FreeBSD+11.2-RELEASE+and+Ports&amp;arch=default&amp;format=html">fts</a> library to easily manage walking through the file system. The basic hand-waved details are:</p>
<ul>
<li>The tree is represented by an <code>FTS</code> structure built by calling <code>fts_open()</code> or <code>xfts_open()</code> on a path.</li>
<li>A node (file/directory) from the tree is a <code>FTSENT</code> structure.</li>
<li>Calling <code>fts_read()</code> on the FTS generates <code>FTSENT</code>s. This is walking the tree.</li>
<li>The <code>FTSENT-&gt;fts_info</code> field describes the entries. It is used often to decide how to handle the entry.</li>
</ul>

<h3>Syscall wrappers, and helpers</h3>
<p>coreutils often invokes syscalls through wrappers and helpers beyond those provided by libc. Many are linked through the <a href="https://www.gnu.org/software/gnulib/">Gnulib project</a>.</p>
<h4>write</h4>
<p>libc provides many text writing functions, such as <code>fwrite()</code> for buffered stream access, and the <code>write()</code> syscall wrapper. Coreutils brings in non-standard functions such as <code>full_write()</code>. The <a href="https://github.com/coreutils/gnulib/blob/master/lib/full-write.c">full_write()</a> function continuously retries writes unless there is a hard failure. It relies on <a href="https://github.com/coreutils/gnulib/blob/master/lib/safe-read.c">safe_write()</a> to retry the <code>write()</code> syscall across interrupts. Other write-related helpers are used only in a single utility. Such as <code>iwrite()</code> in <em>dd</em>, <code>cwrite()</code> in <em>split</em>. I&#39;ll discuss those within the utilities themselves.</p>

<h3>Common functions</h3>
<p>All utilities use at least three functions: <code>main()</code>, <code>usage()</code>, and <code>_()</code>.</p>
<p>The <code>usage()</code> function displays help for the utility that includes a list of input parameters, their meaning, and appropriate syntax.</p>
<p>The <code>_()</code> function is really a macro defined in <code>system.h</code> that binds simple strings to the Native Language Support capability in GNU <a href="https://github.com/coreutils/gnulib/blob/master/lib/gettext.h">gettext.h</a>. If it&#39;s a string meant to be shown to the user, it&#39;s probably wrapped with this function.</p>

<h3 id="commonlines">Common code lines</h3>
<p>The following code lines occur in most non-trivial utilities:</p>
<p><code>#include &#34;system.h&#34;</code></p>

<p><code>#define PROGRAM_NAME &#34;cat&#34;</code></p>

<p><code>#define AUTHORS proper_name (&#34;Richard M. Stallman&#34;)</code></p>

<p><code>emit_try_help ()</code></p>

<p><code>emit_ancillary_info (PROGRAM_NAME)</code></p>

<p><code>exit (status)</code></p>

<p><code>initialize_main(&amp;argc, &amp;argv)</code></p>

<p><code>set_program_name(argv[0]);</code></p>

<p><code>setlocale(LC_ALL, &#34;&#34;);</code></p>

<p><code>bindtextdomain (PACKAGE, LOCALEDIR);</code></p>

<p><code>textdomain (PACKAGE);</code></p>

<p><code>atexit(close_stdout);</code></p>

<p><code>IF_LINT(something);</code></p>

<h3>C idioms</h3>
<p>There are a few idioms buried in the coreutils source that may be unfamiliar to beginners.</p><p><code>!!</code></p>
<p><code>do { ... } while (0)</code></p><pre>if (condition)
  MACRO;
else 
  something else
</pre><p>
Note that lack of semi-colon after while -- It&#39;s manually added after the macro in the C code.</p>

<hr/>

<h2>Utility Maintenance</h2>
<p>An active project like coreutils is always evolving. In general, updates proceed across three arcs:</p>
<ul>
<li><strong>Project-wide changes</strong> - These are larger scale changes to underlying architecture and dependencies across all utilities. Some highlights include:
  <ul>
  <li>1995: Native language support was added thanks to the GNU <a href="https://www.gnu.org/software/gettext/manual/html_node/History.html">gettext project</a>. This incorporated the <code>_()</code> macro around most text output lines. Internationalization support expanded in 1996, adding several initializers to <code>main()</code> as discussed in the previous section</li>
  <li>1995: Short descriptions of utility purpose were added to usage output</li>
  <li>2003: VMS wildcard support. This is visible via the <code>initialize_main()</code> function</li>
  <li>2016: The <code>die()</code> macro replaces most <code>exit()</code> and <code>error()</code> functions on failure paths to avoid compiler warnings</li>
  <li>Various: Incorporating macro constants such as EXIT_SUCCESS, PROGRAM_NAME, AUTHORS, among others.</li>
  </ul>
</li>
<li><strong>Utility-specific updates</strong> - Many changes apply only to a subset or single utility. These cases usually fall in to three categories: bug fixes, new features, and optimizations. Examples of each type include:</li>
  <ul>
  <li>Bug: The <em>join</em>, <em>sort</em>, and <em>uniq</em> commands were susceptible to an overflow attack until <a href="http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=commit;h=b2eadd109c3a508011705761dfe24a35180d925d">patched</a> in 2016</li>
  <li>Feature: The <code>--output</code> option was <a href="http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=blob;f=src/df.c;hb=dae8d223b69bdea7c8913d33640a7b36ef0ff755">added</a> to <em>df</em> in 2013</li>
  <li>Optimization: The <em>yes</em> utility performance <a href="http://git.savannah.gnu.org/gitweb/?p=coreutils.git;a=commitdiff;h=35217221c211f3116f374f305654462195aa634a">improved</a> with better buffering</li>
  </ul>
<li><strong>Annual maintenance</strong> - At a minimum, the copyright years of all utilities are updated. Another administrative change includes updating the FSF address. These changes have no effect on execution</li>
</ul>
<p>For curious readers, I&#39;ve included an &#39;evolution&#39; view within each utility page to visualize utility changes over time.</p>

<h3>Contributing</h3>
<p>People interested in contributing should read everything on the <a href="https://www.gnu.org/software/coreutils/">GNU project page</a>. The <a href="https://git.savannah.gnu.org/cgit/coreutils.git/plain/HACKING">contribution guidelines</a> and list of <a href="https://www.gnu.org/software/coreutils/rejected_requests.html">rejected features</a> are especially enlightening. Finally, go through the <a href="https://lists.gnu.org/archive/html/coreutils/">mailing list archives</a> to get an idea of what contributions are most valuable. A very short list of things to consider before writing any code:</p>
<ul>
<li>Can this functionality be reproduced with existing tools?</li>
<li>Does your contribution break backwards compatibility?</li>
<li>Does the proposed behavior deviate significantly from POSIX?</li>
</ul>
<p>Not sure? Send your concerns to the community on the mailing list</p>

<hr/>

<h2>Fun stuff</h2>
<p>Veteran developers looking for a reason to peek inside these utilities may want to start their journey here.</p>
<h3>Trivia</h3>
<p>
Shortest utility: <strong>false</strong> (2 lines - tied with arch, dir, and vdir)</p>
<ul>
<li>Many utilities trace back to Research UNIX in the 1970s. A handful even further back to Multics</li>
<li>The oldest spiritual ancestor is the CTSS <em>LISTF</em> command (~1963). Thankfully shorted to <em>ls</em>
<ul><li>LISTF is one of the original 18 utilities in the <a href="http://larch-www.lcs.mit.edu:8001/~corbato/sjcc62/">1962 design paper</a> </li></ul>
</li><li>The distinct syntax of the <em>dd</em> utility is reminiscent of the OS/360 <a href="https://en.wikipedia.org/wiki/Job_Control_Language#Concatenating_input_files">job control language</a> (early 1960s).</li>
<li>The <em>sort</em> program is the only utility that takes advantage of multi-threading</li>
<li>The <em>fmt</em> utility demonstrates optimization of lines and paragraphs using feature costs</li>
<li>The deceptively simple <em>yes</em> utility has high-performance output using page-aligned memory buffers</li>
<li>The <em>df</em> utility is faster than <em>du</em>. The former uses device metadata while the latter checks all files</li>
<li><em>cksum</em> includes two entry points, one for normal operation and one to generate the CRC-32 table</li>
<li>There is no failure condition for the <em>echo</em> utility</li>
<li>The design of the <em>test</em> and <em>expr</em> utilities departs significantly from the typical utility</li>
<li><em>su</em> was originally maintained by coreutils/shellutils</li>
<li>My personal least used utilities are <em>tsort</em> and <em>ptx</em> - I tested them once in the late 1990s</li>
</ul>


<h3>Interesting implementations</h3>
<p>There are a few standalone code snippets within coreutils worth investigating:</p>
<ul>
<li>An <a href="https://en.wikipedia.org/wiki/ISAAC_(cipher)">ISAAC cipher</a> for random numbers used by <a href="https://maizure.org/projects/decoded-gnu-coreutils/shuf.html"><em>shuf</em></a> and <a href="https://maizure.org/projects/decoded-gnu-coreutils/shuf.html"><em>shred</em></a></li>
<li><a href="https://en.wikipedia.org/wiki/Reservoir_sampling">Reservoir sampling</a> used by <a href="https://maizure.org/projects/decoded-gnu-coreutils/shuf.html"><em>shuf</em></a></li>
<li>Legacy <a href="https://en.wikipedia.org/wiki/SYSV_checksum">System V</a> and <a href="https://en.wikipedia.org/wiki/BSD_checksum">BSD</a> checksums used in <a href="https://maizure.org/projects/decoded-gnu-coreutils/sum.html"><em>sum</em></a></li>
<li>Left-associative expression evaluation used in <a href="https://maizure.org/projects/decoded-gnu-coreutils/expr.html"><em>expr</em></a></li>
<li><a href="https://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html">Secure overwrite</a> used by the <a href="https://maizure.org/projects/decoded-gnu-coreutils/shred.html"><em>shred</em></a> utility</li>
<li>The <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC-32 checksum</a> computed by <a href="https://maizure.org/projects/decoded-gnu-coreutils/cksum.html"><em>cksum</em></a> utility</li>
<li><a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort</a> as adapted for <a href="https://maizure.org/projects/decoded-gnu-coreutils/sort.html"><em>sort</em></a></li>
<li>The litany of mathemagic behind <a href="https://maizure.org/projects/decoded-gnu-coreutils/factor.html"><em>factor</em></a>
</li></ul>
<hr/>

<h2>FAQ</h2>
<p><strong>Nice project! How can I donate to support this effort?</strong></p>

    </div>

	</article>
</div>

        
      
    </main>

  </div>

		</div>
	</div>
</div>

	
</div>




</div></div>
  </body>
</html>
