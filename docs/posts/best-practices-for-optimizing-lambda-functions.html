<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cloudash.dev/blog/best-practices-for-optimizing-lambda-functions">Original</a>
    <h1>Best practices for optimizing Lambda functions</h1>
    
    <div id="readability-page-1" class="page"><div><p>AWS Lambda is the backbone of every serverless architecture.</p>
<p>While browsing endless serverless patterns, architectures and solutions available online, it&#39;s hard to find one without at least a single lambda function. <a target="_blank" rel="noopener noreferrer" href="https://www.youtube.com/watch?v=9eHoyUVo-yg">Since its announcement in 2014</a>, AWS Lambda has become a de-facto synonym for &#34;serverless&#34;.</p>
<p>The promise of AWS Lambda is simple:</p>
<blockquote>
<p>AWS Lambda is a serverless, event-driven compute service that lets you run code for virtually any type of application or backend service without provisioning or managing servers. You can trigger Lambda from over 200 AWS services and software as a service (SaaS) applications, and only pay for what you use.</p>
</blockquote>
<p><cite>Source: <a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/lambda/">https://aws.amazon.com/lambda/</a></cite></p><p>Note the <em>only pay for what you use</em> part, which clearly indicates that we, the developers, have plenty of options when it comes to optimizing our Lambda functions in terms of latency, cost and sometimes both. This post aims to give you a quick overview of the most important configuration options/best practices and how to optimize your Lambda functions.</p>
<p>(<em>And no, this post won&#39;t tell you to rewrite everything in Rust</em>)</p>
<h2 id="0-measure-first-optimize-later"><a href="#0-measure-first-optimize-later" aria-hidden="true" tabindex="-1"><span></span></a>0. Measure first, optimize later</h2>
<p>AWS has famously established that &#34;security is job zero&#34; when building its services. In software optimization, &#34;measurements are job zero&#34; (and that&#39;s why this tip is the 0th one).</p>
<p>When it comes to optimizing your Lambda functions, it&#39;s hugely important to measure first and optimize later. To quote <a target="_blank" rel="noopener noreferrer" href="https://www.manning.com/books/serverless-architectures-on-aws">&#34;Serverless Architectures on AWS&#34;</a>:</p>
<blockquote>
<p>You can&#39;t optimize what you can&#39;t measure.</p>
</blockquote>
<p>Before you start figuring out how to optimize the latency and cost of your serverless functions, you must have a consistent approach to monitoring necessary metrics and cost.</p>
<h3 id="understand-the-cost-breakdown-of-your-serverless-application"><a href="#understand-the-cost-breakdown-of-your-serverless-application" aria-hidden="true" tabindex="-1"><span></span></a>Understand the cost breakdown of your serverless application</h3>
<p>Before spending weeks trying to squeeze that 0.1ms out of your Lambda function performance, figure out whether it&#39;s actually worth it. Saving 10 cents per month is not exactly worth it if for instance CloudWatch Logs are 95% of your AWS bill (which happens more often than you think).</p>
<p>While rewriting your entire production stack to Rust sure does sound fun, it may not be necessarily in the best interest of your project. If half of your bill is caused by unused EC2 instances, shut down those first before optimizing your Lambda functions.</p>
<h3 id="monitor-all-necessary-metrics-with-cloudwatch-metrics"><a href="#monitor-all-necessary-metrics-with-cloudwatch-metrics" aria-hidden="true" tabindex="-1"><span></span></a>Monitor all necessary metrics with CloudWatch metrics</h3>
<p>Every service used in serverless applications emits a set of standard metrics that will help you understand the performance and availability of your system. Few AWS Lambda examples:</p>
<ul>
<li><strong>Invocations</strong> - total number of requests received by a given function. For instance an API Gateway custom authorizer Lambda function will be invoked way, way more often than &#34;sign up for premium membership&#34; one. In general you should strive to optimize the most invoked functions first, as they might be a bottleneck of your entire system (a webapp with 5 minute login flow is not exactly likely to be successful)</li>
<li><strong>Duration</strong> - total time spent in a given function. It&#39;s a good idea to optimize functions that take longer to execute, since that directly translates to larger cost and latency. Note that &#34;longer to execute&#34; is subjective and depends on your business requirements. In addition to that it&#39;s important to monitor for anomalies in terms of function duration (so that you can revert a Friday night commit that caused the function to run 10x slower)</li>
<li><strong>Errors</strong> - total number of errors that occurred in a given function. Note that this does not measure errors which are caused by internal issues in AWS Lambda service itself or due to throttling (since throttled function is not technically an error since it was never executed).</li>
<li><strong>Throttles</strong> - total number of Lambda function invocations that did not result in your function code being actually executed. There are a number of factors that may cause a function to be throttled, including the account-wide concurrency limit (by default 1,000 concurrenct executions, which can be raised with an AWS Support ticket) or reserved concurrency limit.</li>
</ul>
<p>Small note on AWS Lambda limits, <a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/premiumsupport/knowledge-center/lambda-concurrency-limit-increase/">according to AWS docs</a>:</p>
<blockquote>
<ul>
<li>The default concurrency limit per AWS Region is 1,000 invocations at any given time.</li>
<li>The default burst concurrency quota per Region is between 500 and 3,000, which varies per Region.</li>
<li>There is no maximum concurrency limit for Lambda functions. However, limit increases are granted only if the increase is required for your use case.</li>
<li>To avoid throttling, it&#39;s a best practice to request a limit increase at least two weeks prior to when the increase is needed.</li>
<li>If you&#39;re using Lambda with CloudFront Lambda@Edge, then you must open a separate quota increase case for each Region.</li>
</ul>
</blockquote>
<h3 id="discover-performance-issues-with-aws-x-ray"><a href="#discover-performance-issues-with-aws-x-ray" aria-hidden="true" tabindex="-1"><span></span></a>Discover performance issues with AWS X-Ray.</h3>
<p>As the name suggest, AWS X-Ray is excellent for performing an x-ray scan of what <em>exactly</em> is happening whenever your Lambda function gets executed. AWS X-Ray generated traces for a subset of requests that each of your Lambda function receives and presents you with a visual interface that allows developers to investigate which factores contributed e.g. to a slower than usual response time.</p>
<p>X-Ray trace data is retained for 30 days from the time it is recorded at no additional cost which allows you to investigate performance hiccups that happened e.g. two weeks ago.</p>
<p>Since X-Ray is not a free service, it&#39;s not enabled by default for every Lambda function in your account(s). Check <a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/xray/pricing/">X-Ray pricing page</a> for reference.</p>
<p>Now that we&#39;ve measured what we need to understand our performance bottlenecks, let&#39;s start optimizing.</p>
<h2 id="1-set-proper-memory-size-for-a-lambda-function"><a href="#1-set-proper-memory-size-for-a-lambda-function" aria-hidden="true" tabindex="-1"><span></span></a>1. Set proper memory size for a Lambda function</h2>
<p>The performance of a given Lambda function depends partially on the amount of CPU and memory allocated to it (<em>partially</em>, because e.g. a <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Bogosort">BogoSort</a> will never be fast, no matter how much hardware you throw at it).</p>
<p>AWS does not allow you to independently scale the CPU and memory allocated to a given function, developers are instead given a single setting &#34;Memory (MB)&#34; setting. Apart from increasing the available RAM for a given function, this setting will also influence its cost per request (functions with more memory will be billed more per 1ms) and the CPU power proportional to increase in RAM.</p>
<p>As of December 1st, 2020 - AWS Lambda supports up to 10 GB of memory and 6 vCPU cores for Lambda Functions.</p>
<p>There&#39;s a tradeoff here - functions with larger memory size cost more per 1ms while at the same time are executed faster (which means that you get charged for less milliseconds of exeuction time). For every Lambda function there&#39;s a memory setting which allows you to get the best performance/cost optimization. While you can increment your function memory setting by 128MB and run some tests yourself there&#39;s a better solution - <a target="_blank" rel="noopener noreferrer" href="https://github.com/alexcasalboni/aws-lambda-power-tuning">AWS Lambda Power Tuning</a>.</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/alexcasalboni/aws-lambda-power-tuning">AWS Lambda Power Tuning</a> is a state machine powered by AWS Step Functions that helps you optimize your Lambda functions for cost and/or performance in a data-driven way. Basically, you can provide a Lambda function ARN as input and the state machine will invoke that function with multiple power configurations (from 128MB to 10GB, you decide which values). Then it will analyze all the execution logs and suggest you the best power configuration to minimize cost and/or maximize performance.</p>
<h2 id="2-minimize-deployment-artifact-size"><a href="#2-minimize-deployment-artifact-size" aria-hidden="true" tabindex="-1"><span></span></a>2. Minimize deployment artifact size</h2>
<p><span><span><img alt="" aria-hidden="true" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMxMSIgaGVpZ2h0PSI3MTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmVyc2lvbj0iMS4xIi8+"/></span><img alt="" srcset="/_next/image?url=%2Fstatic%2Fblog%2Fcold_start.png&amp;w=1920&amp;q=75 1x, /_next/image?url=%2Fstatic%2Fblog%2Fcold_start.png&amp;w=3840&amp;q=75 2x" src="https://cloudash.dev/_next/image?url=%2Fstatic%2Fblog%2Fcold_start.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="intrinsic"/></span></p>
<p>As shown above, a Lambda function livecycle has several steps, some of those are optimized by AWS itself, and some can be optimized by developers using the service.</p>
<ul>
<li>First, Lambda service needs to download your code</li>
<li>Secondly, unless a &#34;warm&#34; execution environment is available, a brand new execution environment will be created</li>
<li>Next, your init code (that is - everything outside of the <code>handler</code> function) is executed</li>
<li>And lastly, your <code>handler</code> code is executed</li>
</ul>
<p>In order to optimize the time it takes to optimize downloading your code consider... shipping less of it. AWS Lambda has a limit of 250MB for the deployment artifact (so shipping your entire <code>node_modules</code> is out of the question) and in general - the less code you ship per a function, the faster it will be downloaded &amp; executed during a full cold start.</p>
<p>Note on cold/warm starts: AWS does not publish the data on how long an environment is kept warm, but many developers agree it&#39;s for somewhere between 5 and 20 minutes. You can test it yourself by forcing a cold start (changing the Lambda function code or an environment variable will force AWS to discard the warm execution environment).</p>
<p>Avoiding so-called &#34;Lambdalith&#34; is a the best practice, building small functions which are focused on a single goal (e.g. <code>deleteThing</code>, <code>createThing</code>) is a better choice than a huge <code>allMyBusinessLogic</code> function, both in terms of cold start latency and maintenance.</p>
<p>The best practice is to carefully choose external dependencies for a Lambda function, removing everything that&#39;s not needed for the function to run. In addition to that avoid importing the whole <code>aws-sdk</code> in your function:</p>
<div><pre><code><span><span>const</span> <span>AWS</span> <span>=</span> <span>require</span><span>(</span><span>&#34;aws-sdk&#34;</span><span>)</span><span>;</span>
</span><span>
</span><span><span>const</span> s3Client <span>=</span> <span>new</span> <span><span>AWS</span></span><span>.</span><span>S3</span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span>
</span><span><span>await</span> s3Client<span>.</span><span>createBucket</span><span>(</span>params<span>)</span><span>;</span>
</span></code></pre></div>
<p>Do this instead:</p>
<div><pre><code><span><span>const</span> <span>{</span> <span>S3</span> <span>}</span> <span>=</span> <span>require</span><span>(</span><span>&#34;@aws-sdk/client-s3&#34;</span><span>)</span><span>;</span>
</span><span>
</span><span><span>const</span> s3Client <span>=</span> <span>new</span> <span><span>S3</span></span><span>(</span><span>{</span><span>}</span><span>)</span><span>;</span>
</span><span><span>await</span> s3Client<span>.</span><span>createBucket</span><span>(</span>params<span>)</span><span>;</span>
</span></code></pre></div>
<p>Source: <a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/blogs/developer/modular-packages-in-aws-sdk-for-javascript/">https://aws.amazon.com/blogs/developer/modular-packages-in-aws-sdk-for-javascript/</a></p>
<h2 id="3-optimize-function-logic"><a href="#3-optimize-function-logic" aria-hidden="true" tabindex="-1"><span></span></a>3. Optimize function logic</h2>
<p>If you measure performance issues in a given Lambda function, perform an audit of its code. If you&#39;ve avoided building a &#34;Lambdalith&#34;, there shouldn&#39;t be <em>too much</em> code to read and at scale even the smallest 1% performance improvements can give noticeable improvements.</p>
<p>Optimize CPU-heavy algorithms used in a function, consider not fetching your entire DynamoDB table with <code>Scan</code> in order to fetch a single item (that&#39;s what <code>Query</code> is for), try to find a faster dependency that solves the same problem etc.</p>
<p>In addition to that, consider whether you can move initialization code outside of the <code>handler</code> function. Everything that&#39;s outside of the <code>handler</code> function is executed only during the cold start and is subsequently reused during warm invocations. As such you&#39;d want to e.g. initialize the <code>DynamoDB.DocumentClient</code> once outside of the <code>handler</code> function and reuse it in future invocations of the function to improve its performance.</p>
<h2 id="4-consider-using-provisioned-concurrency"><a href="#4-consider-using-provisioned-concurrency" aria-hidden="true" tabindex="-1"><span></span></a>4. Consider using provisioned concurrency</h2>
<p>Once your &#34;Uber for X&#34; startup gets to scale, you&#39;ll need to consider how to scale your Lambda function.</p>
<p>By default there&#39;s a soft limit (which can be increased with a support ticket) of 1,000 concurrent invocations of <strong>all</strong> Lambda functions in a given account (yet another reason to use multiple AWS accounts in your organization, btw). In addition to that, there&#39;s an account-wide limit on the rate at which you can scale up your concurrent executions:</p>
<blockquote>
<p>Your functions&#39; concurrency is the number of instances that serve requests at a given time. For an initial burst of traffic, your functions&#39; cumulative concurrency in a Region can reach an initial level of between 500 and 3000, which varies per Region. Note that the burst concurrency quota is not per-function; it applies to all your functions in the Region.</p>
</blockquote>
<blockquote>
<p>After the initial burst, your functions&#39; concurrency can scale by an additional 500 instances each minute. This continues until there are enough instances to serve all requests, or until a concurrency limit is reached. When requests come in faster than your function can scale, or when your function is at maximum concurrency, additional requests fail with a throttling error (429 status code).</p>
</blockquote>
<p>Source: <a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-scaling.html#scaling-behavior">https://docs.aws.amazon.com/lambda/latest/dg/invocation-scaling.html#scaling-behavior</a></p>
<p>Luckily, since late 2019, AWS Lambda has a provisioned concurrency feature:</p>
<blockquote>
<p>Provisioned concurrency initializes a requested number of execution environments so that they are prepared to respond immediately to your function&#39;s invocations. Note that configuring provisioned concurrency incurs charges to your AWS account.</p>
</blockquote>
<p>Source: <a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html">https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html</a></p>
<p>With provisioned concurrency whenever you <em>know</em> that extra concurrency for a given function will be needed (because it&#39;s going to be executed e.g. during a Black Friday promotion), you can prepare <strong>up-front</strong> a given number of warm execution environment for your function. When you configure a number for provisioned concurrency, Lambda initializes that number of execution environments. Your function is ready to serve a burst of incoming requests with very low latency. When all provisioned concurrency is in use, the function scales up normally to handle any additional requests.</p>
<h2 id="5-protect-downstream-resources-with-reserved-concurrency"><a href="#5-protect-downstream-resources-with-reserved-concurrency" aria-hidden="true" tabindex="-1"><span></span></a>5. Protect downstream resources with reserved concurrency</h2>
<p>Reserved concurrency guarantees the maximum number of concurrent instances for a given Lambda function. When a function has reserved concurrency, no other function can use that concurrency. There is no charge for configuring reserved concurrency for a function.</p>
<p>You might be thinking - why would I want to limit the maximum number of concurrent executions of a given function? Won&#39;t it get throttled at some point?</p>
<p>Yes, and that might be the desired behavior in some cases. Imagine that a Lambda function is calling a downstream legacy API that can only handle 10 requests at the same time. By setting a reserved concurrency of 10, you&#39;re making sure that even if your function is called more than 10 times, the downstream service won&#39;t be overloaded. While some requests may get throttled, it&#39;s better for a client to use an <a target="_blank" rel="noopener noreferrer" href="https://dzone.com/articles/understanding-retry-pattern-with-exponential-back#:~:text=The%20idea%20behind%20using%20exponential,we%20retry%20after%20one%20second.">exponential backoff retry strategy</a> than to make the legacy API explode (and inevitably wake up the poor soul on on-call duty).</p>
<h2 id="6-set-conservative-timeouts"><a href="#6-set-conservative-timeouts" aria-hidden="true" tabindex="-1"><span></span></a>6. Set conservative timeouts</h2>
<p>The maximum timeout value you can configure for an AWS Lambda function is 15 minutes. While it might be tempting to always set a timeout of 15 minutes (e.g. to avoid timeout alerts), in my opinion it&#39;s not a good idea to do so.</p>
<p>In fact, in order to keep an eye on performance/latency issues, Lambda function timeouts should be rather conservative - if a given function should execute under a second than the configured timeout should reflect that.</p>
<p>Otherwise you may risk unnecessary costs - if a bug were introduced to your most-invoked function, bumping its duration to e.g. 5 minutes you wouldn&#39;t even notice due to its high timeout value (but you&#39;ll definitely notice the difference on your AWS bill). In addition to that, your UX will suffer since the user will be waiting for a long time for a response from your function.</p>
<p>That&#39;s why proper monitoring/alerting and conservative timeouts greatly help with providing the best latency for your clients.</p>
<h2 id="7-consider-taking-advantage-of-multi-threaded-programming"><a href="#7-consider-taking-advantage-of-multi-threaded-programming" aria-hidden="true" tabindex="-1"><span></span></a>7. Consider taking advantage of multi-threaded programming</h2>
<p>In one of previous sections we&#39;ve established that a Lambda function can use up to 6 vCPU cores and up to 10 GB of memory. <a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-function-common.html#:~:text=MB%20increments.%20At-,1%2C769,-MB%2C%20a%20function">At 1,769 MB, a function has the equivalent of one vCPU (one vCPU-second of credits per second)</a>, and above this value we get access to 2vCPU cores and more (depending on the memory setting).</p>
<p>What this boils down to is after crossing the threshold of ~2GB of memory, you can start using multi-threaded programming in your Lambda function to optimize its performance. This is of course easier said than done (and heavily depends on the programming language of choice as well as developer&#39;s skills), but is certainly an option. Optimizing work to be done in parallel on multiple vCPU cores will bring latency and cost of a function down.</p>
<p>It&#39;s not clear at which point Lambda function receives access to more than 2 vCPU cores. A <a target="_blank" rel="noopener noreferrer" href="https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading">AWS re:Invent 2020 Day 3: Optimizing Lambda Cost with Multi-Threading</a> suggests that after crossing 3GB of memory a function receives 3 vCPU cores, 4 cores at ~5308MB, 5 cores at ~7077MB and 6 cores at ~8846MB. I was unable to find an official confirmation of those values published <strong>anywhere</strong> in <a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/index.html">AWS Lambda documentation</a>.</p>
<h2 id="8-save-on-aws-lambda-amazon-cloudwatch-logs-costs"><a href="#8-save-on-aws-lambda-amazon-cloudwatch-logs-costs" aria-hidden="true" tabindex="-1"><span></span></a>8. Save on AWS Lambda Amazon CloudWatch Logs costs</h2>
<p>Our friend, Wojciech Matuszewski published an entire post on this topic, which you are welcome to read here: <a target="_blank" rel="noopener noreferrer" href="https://cloudash.dev/blog/saving-aws-lambda-cloudwatch-costs">Saving on AWS Lambda Amazon CloudWatch Logs costs</a></p>
<hr/>
<p>References:</p>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://www.manning.com/books/serverless-architectures-on-aws">&#34;Serverless Architectures on AWS&#34;</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading">https://www.sentiatechblog.com/aws-re-invent-2020-day-3-optimizing-lambda-cost-with-multi-threading</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html">https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/">https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-1/</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-2/">https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-2/</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-3/">https://aws.amazon.com/blogs/compute/operating-lambda-performance-optimization-part-3/</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html">https://docs.aws.amazon.com/lambda/latest/dg/configuration-concurrency.html</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/premiumsupport/knowledge-center/lambda-concurrency-limit-increase/">https://aws.amazon.com/premiumsupport/knowledge-center/lambda-concurrency-limit-increase/</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/lambda/">https://aws.amazon.com/lambda/</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://aws.amazon.com/blogs/developer/modular-packages-in-aws-sdk-for-javascript/">https://aws.amazon.com/blogs/developer/modular-packages-in-aws-sdk-for-javascript/</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-scaling.html#scaling-behavior">https://docs.aws.amazon.com/lambda/latest/dg/invocation-scaling.html#scaling-behavior</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://dzone.com/articles/understanding-retry-pattern-with-exponential-back">https://dzone.com/articles/understanding-retry-pattern-with-exponential-back</a></li>
</ul></div></div>
  </body>
</html>
