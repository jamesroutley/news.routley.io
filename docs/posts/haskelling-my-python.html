<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unnamed.website/posts/haskelling-my-python/">Original</a>
    <h1>Haskelling My Python</h1>
    
    <div id="readability-page-1" class="page"><div id="content"><div><div><p>A few years ago, Pleng showed me <a href="https://tcpc.me/2021/12/21/lazy-power-series-integration.html">a really cool trick</a> you can do with lazy infinite lists in Haskell.</p><p><img src="https://unnamed.website/img/kublai.png"/></p><blockquote><b>Kublai</b>: Oh no, not Haskell! ðŸ˜±</blockquote><p>Donâ€™t worry. There will be no mandatory Haskell in this post (although it is a really nice language which you should check out!). Instead, today <a href="https://erikz.xyz">Erik</a> asked me if that trick also works using infinite Python generators, and turns out it does!</p><p>First, as a warm-up, letâ€™s define an infinite generator for the positive integers.</p><p><img src="https://unnamed.website/img/kublai.png"/></p><blockquote><b>Kublai</b>: Oh, oh, I know how to do this! Thatâ€™s easy!</blockquote><div><pre tabindex="0"><code data-lang="py"><span><span><span>def</span> <span>ints</span>():
</span></span><span><span>    cnt <span>=</span> <span>1</span>
</span></span><span><span>    <span>while</span> <span>True</span>:
</span></span><span><span>        <span>yield</span> cnt
</span></span><span><span>        cnt <span>+=</span> <span>1</span>
</span></span></code></pre></div><p>Nice! That works. However, weâ€™re going to define it in a slightly different way. Recursively! The commented line is Haskell and below that is the translation into Python.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span># ints = 1 : map (+1) ints</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>ints</span>():
</span></span><span><span>    <span>yield</span> <span>1</span>
</span></span><span><span>    <span>yield from</span> map(<span>lambda</span> x: x <span>+</span> <span>1</span>, ints())
</span></span></code></pre></div><p><img src="https://unnamed.website/img/kublai.png"/></p><blockquote><b>Kublai</b>: WTF? How does that work?</blockquote><p>Itâ€™s actually pretty simple. The first positive integer is 1, obviously. The remaining integers after 1 are just the positive integers but with 1 added to each one. As simple as that.</p><p>Weâ€™ll need a function for printing out the first few elements of that generator. (Assuming you already imported the correct modules.)</p><div><pre tabindex="0"><code data-lang="py"><span><span><span># take n f</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>take</span>(n, f):
</span></span><span><span>    <span>return</span> list(itertools<span>.</span>islice(f, n))
</span></span></code></pre></div><p>And now letâ€™s test it with <code>ints()</code>.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span>&gt;&gt;&gt;</span> take(<span>10</span>, ints())
</span></span><span><span>[<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>8</span>, <span>9</span>, <span>10</span>]
</span></span></code></pre></div><p>Yay! It works!</p><p>Next, letâ€™s define a function to integrate a Taylor series, where the coefficients of the Taylor series will be expressed as an infinite generator. Recall that the integral of $x^n$ is $\frac{1}{n+1}x^{n+1}+C$. That means our integral is some leading constant plus all the terms of the original Taylor series shifted over by one and divided by $n+1$.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span># integrate f c = c : zipWith (/) f ints</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>integrate</span>(f, c):
</span></span><span><span>    <span>yield</span> c
</span></span><span><span>    <span>yield from</span> map(operator<span>.</span>truediv, f, ints())
</span></span></code></pre></div><p>Now time for some magic. Recall that the derivative of $e^x$ is itself and $e^x = \int_0^x e^y dy + 1$ so the integration constant is 1. So, letâ€™s use these properties to define $e^x$!</p><div><pre tabindex="0"><code data-lang="py"><span><span><span># expSeries = integrate expSeries 1</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>expSeries</span>():
</span></span><span><span>    <span>yield from</span> integrate(expSeries(), <span>1</span>)
</span></span></code></pre></div><p>Letâ€™s print it out.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span>&gt;&gt;&gt;</span> take(<span>10</span>, expSeries())
</span></span><span><span>[<span>1</span>, <span>1.0</span>, <span>0.5</span>, <span>0.16666666666666666</span>, <span>0.041666666666666664</span>, <span>0.008333333333333333</span>, <span>0.001388888888888889</span>, <span>0.0001984126984126984</span>, <span>2.48015873015873e-05</span>, <span>2.7557319223985893e-06</span>]
</span></span></code></pre></div><p>Whoa! Thatâ€™s the Taylor series for $e^x$!</p><p><img src="https://unnamed.website/img/kublai.png"/></p><blockquote><b>Kublai</b>: Wait, we never even told Python what $e^x$ is, other than that itâ€™s equal to its own integral! What kind of crazy magic is this?</blockquote><p>We can also evaluate $e^x$ using that Taylor series.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span># evalAt n f x = foldr (\a acc -&gt; a + acc * x) 0 (take n f)</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>evalAt</span>(n, f, x):
</span></span><span><span>    <span>return</span> functools<span>.</span>reduce(<span>lambda</span> acc, a: a <span>+</span> acc <span>*</span> x, reversed(take(n, f)))
</span></span></code></pre></div><p>Letâ€™s compare it to the one in the Python standard library.</p><div><pre tabindex="0"><code data-lang="py"><span><span><span>&gt;&gt;&gt;</span> evalAt(<span>100</span>, expSeries(), <span>2</span>)
</span></span><span><span><span>7.38905609893065</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> math<span>.</span>exp(<span>2</span>)
</span></span><span><span><span>7.38905609893065</span>
</span></span></code></pre></div><p>Pretty close!</p><p>Hereâ€™s the punchline. Recall that $\sin x = \int_0^x \cos y dy$ and $\cos x = -\int_0^x \sin y dy + 1$. Letâ€™s encode that in Python!</p><div><pre tabindex="0"><code data-lang="py"><span><span><span># sine = integrate cosine 0</span>
</span></span><span><span><span># cosine = map negate (integrate sine -1)</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>sine</span>():
</span></span><span><span>    <span>yield from</span> integrate(cosine(), <span>0</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>cosine</span>():
</span></span><span><span>    <span>yield from</span> map(operator<span>.</span>neg, integrate(sine(), <span>-</span><span>1</span>))
</span></span></code></pre></div><p>Now letâ€™s evaluate sine:</p><div><pre tabindex="0"><code data-lang="py"><span><span><span>&gt;&gt;&gt;</span> evalAt(<span>100</span>, sine(), <span>2</span>)
</span></span><span><span><span>0.9092974268256817</span>
</span></span><span><span><span>&gt;&gt;&gt;</span> math<span>.</span>sin(<span>2</span>)
</span></span><span><span><span>0.9092974268256817</span>
</span></span></code></pre></div><p><img src="https://unnamed.website/img/kublai.png"/></p><blockquote><b>Kublai</b>: ðŸ¤¯</blockquote><h2 id="bonus-making-it-fast">Bonus: Making it fast!</h2><p>Pleng noticed that my Python code can be pretty slow since Python generators arenâ€™t memoized unlike Haskell lists (and also hits the Python recursion limit).</p><p>Fortunately, <a href="https://stackoverflow.com/questions/4566769/can-i-memoize-a-python-generator/53437323#53437323">someone on StackOverflow</a> has already solved this problem using a decorator, so hereâ€™s the fix:</p><div><pre tabindex="0"><code data-lang="py"><span><span><span>def</span> <span>memoize</span>(f):
</span></span><span><span>    cache <span>=</span> {}
</span></span><span><span>    <span>@functools.wraps</span>(f)
</span></span><span><span>    <span>def</span> <span>wrapper</span>(<span>*</span>args, <span>**</span>kwargs):
</span></span><span><span>        k <span>=</span> args, frozenset(kwargs<span>.</span>items())
</span></span><span><span>        it <span>=</span> cache[k] <span>if</span> k <span>in</span> cache <span>else</span> f(<span>*</span>args, <span>**</span>kwargs)
</span></span><span><span>        cache[k], result <span>=</span> itertools<span>.</span>tee(it)
</span></span><span><span>        <span>return</span> result
</span></span><span><span>    <span>return</span> wrapper
</span></span><span><span>
</span></span><span><span><span>@memoize</span> <span># Add this line</span>
</span></span><span><span><span>def</span> <span>ints</span>():
</span></span><span><span>    <span>yield</span> <span>1</span>
</span></span><span><span>    <span>yield from</span> map(<span>lambda</span> x: x <span>+</span> <span>1</span>, ints())
</span></span><span><span>
</span></span><span><span><span>@memoize</span> <span># Add this line</span>
</span></span><span><span><span>def</span> <span>expSeries</span>():
</span></span><span><span>    <span>yield from</span> integrate(expSeries(), <span>1</span>)
</span></span><span><span>
</span></span><span><span>print(take(expSeries(), <span>1000</span>))
</span></span></code></pre></div><p>And now itâ€™s fast!</p><p>Also, Isaac noted that this trick also works using Pythonâ€™s <code>fractions</code> module to get the answer as a rational number instead of a float.</p></div></div></div></div>
  </body>
</html>
