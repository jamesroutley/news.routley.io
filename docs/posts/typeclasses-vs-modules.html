<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sm2n.ca/articles/typeclasses-vs-modules/">Original</a>
    <h1>Typeclasses vs Modules</h1>
    
    <div id="readability-page-1" class="page"><div>  <p>For a long time I’ve noticed that there’s a lot of persistent confusion about the differences and similarities between module systems (as seen in languages like OCaml) and typeclasses (as seen in languages like Haskell or Rust). This is an attempt to clear up the confusion.</p>
<h2 id="the-short-answer">The short answer</h2>
<p>The main goal of typeclasses as a language construct is to provide <em>ad-hoc polymorphism</em>. This is also known as <em>operator overloading</em> or <em>type-based dispatch</em>. The main point of ad-hoc polymorphism is as a convenience feature for programming in the small: it lets you reuse the same identifiers across types. For example, I might want to use the <code>+</code> symbol to denote both addition on integers and addition on vectors of floats (Importantly the vector type might be defined in a random library, so we can’t hardcode this behaviour in the language).</p>
<p>The main goal of module systems as a language construct is to provide <em>modular abstraction</em>. Some parts of this feature have names in the broader software industry, like <em>dependency injection</em>, <em>encapsulation</em>, and <em>information hiding</em>. The main point of modular abstraction is to enable more efficient programming in the large, by allowing you to express your program decomposition explicitly. It gives you a compositional way to break down programs into component pieces recursively.</p>
<p>The main factors that I think lead to confusion are:</p>
<ul>
<li>historically, programming languages have tended to pick one or the other</li>
<li>they share some of the underlying mechanism
<ul>
<li>a way to specify an <em>interface</em></li>
<li>and a way to show that some bundle of code <em>conforms to the interface</em></li>
</ul>
</li>
<li>you sometimes can kinda sorta emulate one using the other (i.e use typeclasses to provide modular abstraction, and use modules to provide ad-hoc polymorphism).</li>
</ul>
<p>However, while emulation is possible in many cases it’s usually not optimal.</p>
<h2 id="why-and-what-typeclasses">Why and What: Typeclasses</h2>
<p>The motivational idea behind typeclasses is basically, if you’re going to overload a symbol, it should “morally” mean the same thing. For example the symbol <code>+</code> denotes the abstract idea of addition, and we can have different implementations for different types. This is in contrast to for example C++ where <code>&lt;&lt;</code> can mean bitshift or stream redirection depending on the type, which have nothing in common. The goal here is for the meaning of programs to be easier to understand (relative to the unprincipled C++ thing), while reducing cognitive overhead by reducing the number of symbols. We can learn a few symbols that work with abstract structures, like <code>+</code> or <code>&gt;&gt;=</code>, and use them across a variety of different concrete structures.</p>
<p>If we want to be a bit more serious about this we need to consider the semantics as well. How do we make sure <code>+</code> does in fact denote an abstract addition operation? Well, we can add laws to the typeclass. For instance we can say that addition has to satisfy <span><span><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a + b) + c = a + (b + c)</annotation></semantics></math></span><span aria-hidden="true"><span><span></span><span>(</span><span>a</span><span></span><span>+</span><span></span></span><span><span></span><span>b</span><span>)</span><span></span><span>+</span><span></span></span><span><span></span><span>c</span><span></span><span>=</span><span></span></span><span><span></span><span>a</span><span></span><span>+</span><span></span></span><span><span></span><span>(</span><span>b</span><span></span><span>+</span><span></span></span><span><span></span><span>c</span><span>)</span></span></span></span> (though this isn’t true for floats), and then check that new implementations do in fact satisfy the law using a property test or a proof witness. In general, each typeclass can be bundled with some description of semantics, ideally machine checked in the form of a test suite or proof obligation.</p>
<p>For taste, here is the definition of the <code>Num</code> typeclass in Haskell, taken from <a href="https://hackage.haskell.org/package/ghc-internal-9.1201.0/docs/src/GHC.Internal.Num.html#Num">ghc</a>. Notice that it gives some laws, but in this case they are only customary. For instance, floating point multiplication is not associative but it still has a <code>Num</code> instance.</p>
<pre tabindex="0" data-language="haskell"><code><span><span>--</span><span> </span><span>|</span><span> </span><span>Basic</span><span> </span><span>numeric</span><span> </span><span>class.</span></span>
<span><span>--</span></span>
<span><span>--</span><span> </span><span>The</span><span> </span><span>Haskell</span><span> </span><span>Report</span><span> </span><span>defines</span><span> </span><span>no</span><span> </span><span>laws</span><span> </span><span>for</span><span> </span><span>&#39;Num&#39;.</span><span> </span><span>However,</span><span> </span><span>@(&#39;+&#39;)@</span><span> </span><span>and</span><span> </span><span>@(&#39;*&#39;)@</span><span> </span><span>are</span></span>
<span><span>--</span><span> </span><span>customarily</span><span> </span><span>expected</span><span> </span><span>to</span><span> </span><span>define</span><span> </span><span>a</span><span> </span><span>ring</span><span> </span><span>and</span><span> </span><span>have</span><span> </span><span>the</span><span> </span><span>following</span><span> </span><span>properties:</span></span>
<span><span>--</span></span>
<span><span>--</span><span> </span><span>[__Associativity</span><span> </span><span>of</span><span> </span><span>@(&#39;+&#39;)@__]:</span><span> </span><span>@(x</span><span> </span><span>+</span><span> </span><span>y)</span><span> </span><span>+</span><span> </span><span>z@</span><span> </span><span>=</span><span> </span><span>@x</span><span> </span><span>+</span><span> </span><span>(y</span><span> </span><span>+</span><span> </span><span>z)@</span></span>
<span><span>--</span><span> </span><span>[__Commutativity</span><span> </span><span>of</span><span> </span><span>@(&#39;+&#39;)@__]:</span><span> </span><span>@x</span><span> </span><span>+</span><span> </span><span>y@</span><span> </span><span>=</span><span> </span><span>@y</span><span> </span><span>+</span><span> </span><span>x@</span></span>
<span><span>--</span><span> </span><span>[__@&#39;fromInteger&#39;</span><span> </span><span>0@</span><span> </span><span>is</span><span> </span><span>the</span><span> </span><span>additive</span><span> </span><span>identity__]:</span><span> </span><span>@x</span><span> </span><span>+</span><span> </span><span>fromInteger</span><span> </span><span>0@</span><span> </span><span>=</span><span> </span><span>@x@</span></span>
<span><span>--</span><span> </span><span>[__&#39;negate&#39;</span><span> </span><span>gives</span><span> </span><span>the</span><span> </span><span>additive</span><span> </span><span>inverse__]:</span><span> </span><span>@x</span><span> </span><span>+</span><span> </span><span>negate</span><span> </span><span>x@</span><span> </span><span>=</span><span> </span><span>@fromInteger</span><span> </span><span>0@</span></span>
<span><span>--</span><span> </span><span>[__Associativity</span><span> </span><span>of</span><span> </span><span>@(&#39;*&#39;)@__]:</span><span> </span><span>@(x</span><span> </span><span>*</span><span> </span><span>y)</span><span> </span><span>*</span><span> </span><span>z@</span><span> </span><span>=</span><span> </span><span>@x</span><span> </span><span>*</span><span> </span><span>(y</span><span> </span><span>*</span><span> </span><span>z)@</span></span>
<span><span>--</span><span> </span><span>[__@&#39;fromInteger&#39;</span><span> </span><span>1@</span><span> </span><span>is</span><span> </span><span>the</span><span> </span><span>multiplicative</span><span> </span><span>identity__]:</span></span>
<span><span>--</span><span> </span><span>@x</span><span> </span><span>*</span><span> </span><span>fromInteger</span><span> </span><span>1@</span><span> </span><span>=</span><span> </span><span>@x@</span><span> </span><span>and</span><span> </span><span>@fromInteger</span><span> </span><span>1</span><span> </span><span>*</span><span> </span><span>x@</span><span> </span><span>=</span><span> </span><span>@x@</span></span>
<span><span>--</span><span> </span><span>[__Distributivity</span><span> </span><span>of</span><span> </span><span>@(&#39;*&#39;)@</span><span> </span><span>with</span><span> </span><span>respect</span><span> </span><span>to</span><span> </span><span>@(&#39;+&#39;)@__]:</span></span>
<span><span>--</span><span> </span><span>@a</span><span> </span><span>*</span><span> </span><span>(b</span><span> </span><span>+</span><span> </span><span>c)@</span><span> </span><span>=</span><span> </span><span>@(a</span><span> </span><span>*</span><span> </span><span>b)</span><span> </span><span>+</span><span> </span><span>(a</span><span> </span><span>*</span><span> </span><span>c)@</span><span> </span><span>and</span><span> </span><span>@(b</span><span> </span><span>+</span><span> </span><span>c)</span><span> </span><span>*</span><span> </span><span>a@</span><span> </span><span>=</span><span> </span><span>@(b</span><span> </span><span>*</span><span> </span><span>a)</span><span> </span><span>+</span><span> </span><span>(c</span><span> </span><span>*</span><span> </span><span>a)@</span></span>
<span><span>--</span><span> </span><span>[__Coherence</span><span> </span><span>with</span><span> </span><span>&#39;toInteger&#39;__]:</span><span> </span><span>if</span><span> </span><span>the</span><span> </span><span>type</span><span> </span><span>also</span><span> </span><span>implements</span><span> </span><span>&#39;GHC.Real.Integral&#39;,</span><span> </span><span>then</span></span>
<span><span>--</span><span> </span><span>&#39;fromInteger&#39;</span><span> </span><span>is</span><span> </span><span>a</span><span> </span><span>left</span><span> </span><span>inverse</span><span> </span><span>for</span><span> </span><span>&#39;GHC.Internal.Real.toInteger&#39;,</span><span> </span><span>i.e.</span><span> </span><span>@fromInteger</span><span> </span><span>(toInteger</span><span> </span><span>i)</span><span> </span><span>==</span><span> </span><span>i@</span></span>
<span><span>class</span><span> </span><span> </span><span>Num</span><span> </span><span>a</span><span> </span><span> </span><span>where</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>(</span><span>+</span><span>)</span><span>,</span><span> </span><span>(</span><span>-</span><span>)</span><span>,</span><span> </span><span>(</span><span>*</span><span>)</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>::</span><span> </span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>a</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>|</span><span> </span><span>Unary</span><span> </span><span>negation.</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>negate</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>::</span><span> </span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>a</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>|</span><span> </span><span>Absolute</span><span> </span><span>value.</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>abs</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>::</span><span> </span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>a</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>|</span><span> </span><span>Sign</span><span> </span><span>of</span><span> </span><span>a</span><span> </span><span>number.</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>The</span><span> </span><span>functions</span><span> </span><span>&#39;abs&#39;</span><span> </span><span>and</span><span> </span><span>&#39;signum&#39;</span><span> </span><span>should</span><span> </span><span>satisfy</span><span> </span><span>the</span><span> </span><span>law:</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>&gt;</span><span> </span><span>abs</span><span> </span><span>x</span><span> </span><span>*</span><span> </span><span>signum</span><span> </span><span>x</span><span> </span><span>==</span><span> </span><span>x</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>For</span><span> </span><span>real</span><span> </span><span>numbers,</span><span> </span><span>the</span><span> </span><span>&#39;signum&#39;</span><span> </span><span>is</span><span> </span><span>either</span><span> </span><span>@-1@</span><span> </span><span>(negative),</span><span> </span><span>@0@</span><span> </span><span>(zero)</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>or</span><span> </span><span>@1@</span><span> </span><span>(positive).</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>signum</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>::</span><span> </span><span>a</span><span> </span><span>-&gt;</span><span> </span><span>a</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>|</span><span> </span><span>Conversion</span><span> </span><span>from</span><span> </span><span>an</span><span> </span><span>&#39;Integer&#39;.</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>An</span><span> </span><span>integer</span><span> </span><span>literal</span><span> </span><span>represents</span><span> </span><span>the</span><span> </span><span>application</span><span> </span><span>of</span><span> </span><span>the</span><span> </span><span>function</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>&#39;fromInteger&#39;</span><span> </span><span>to</span><span> </span><span>the</span><span> </span><span>appropriate</span><span> </span><span>value</span><span> </span><span>of</span><span> </span><span>type</span><span> </span><span>&#39;Integer&#39;,</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>--</span><span> </span><span>so</span><span> </span><span>such</span><span> </span><span>literals</span><span> </span><span>have</span><span> </span><span>type</span><span> </span><span>@(&#39;Num&#39;</span><span> </span><span>a)</span><span> </span><span>=&gt;</span><span> </span><span>a@.</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>fromInteger</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>::</span><span> </span><span>Integer</span><span> </span><span>-&gt;</span><span> </span><span>a</span></span>
<span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>x</span><span> </span><span>-</span><span> </span><span>y</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>negate</span><span> </span><span>y</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>negate</span><span> </span><span>x</span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>=</span><span> </span><span>0</span><span> </span><span>-</span><span> </span><span>x</span></span></code></pre>
<h2 id="why-and-what-modules">Why and What: Modules</h2>
<p>The point of modules is to allow you to ergonomically abstract over parts of your program. To do that, we split the program up into parts (“modules”, “structures”), and then explicitly specify how they slot together. Importantly, we can reduce the total effort to reason about the full program by making each module hide parts of itself (encapsulation!) from other modules that interact with it.</p>
<p>That’s good for outputs, but we also have to consider abstracting over inputs. To do that, we can make parametrized modules (these are often called <em>functors</em> for historical reasons) that are not modules but can become a module when instantiated with some other module(s). Which modules are we allowed to instantiate with? All the modules that conform to a particular interface (which are often called <em>signatures</em> in the literature)!</p>
<p>Again, if we’re being serious about this we might attach some semantics to the interface, such as customary laws, a test suite or a proof obligation. After all, one of the most common reasons to structure your program with a modular decomposition is to increase ease of testing. Identifying important interfaces and testing at the interface is a quite effective way to get a lot of coverage for cheap.</p>
<p>Let’s go through an example that uses many features. I have taken the following code from the <a href="https://github.com/bcpierce00/unison/blob/master/src/fsmonitor/watchercommon.mli">unison file synchronization project</a>.</p>
<p>First, we declare that we have a <code>StringMap</code> type which conforms to the <code>Map.S</code> signature from the standard library, but with the key type specialized to String. That means any code that depends on the interface the stdlib exposes can use our custom map, and it’ll even check that all callsites have the correct key type.</p>
<p>Next we have a parametrized module. The high level idea is that this is an interface that abstracts over platform-specific apis for file watching.</p>
<ul>
<li>We declare a parametrized module F
<ul>
<li>that takes a module M
<ul>
<li>that defines a <code>watch</code> handle type</li>
</ul>
</li>
<li>and returns a module that supports the limited file descriptor-esque API declared afterwards.
<ul>
<li>We declare a signature <code>S</code> that exposes an api for working with watchers</li>
<li>there’s also a parametrized module <code>F.F</code>
<ul>
<li>that can be used to initialize <code>F</code></li>
<li>using a module that implements <code>S</code> (since the parametrized module returns something with an empty signature, it can only be used for its side-effects.)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre tabindex="0" data-language="ocaml"><code><span><span>module</span><span> </span><span>StringMap</span><span> </span><span>:</span><span> </span><span>Map</span><span>.</span><span>S</span><span> </span><span>with</span><span> </span><span>type</span><span> </span><span>key</span><span> </span><span>=</span><span> </span><span>string</span></span>
<span></span>
<span><span>module</span><span> </span><span>F</span><span> </span><span>(</span><span>M</span><span> </span><span>:</span><span> </span><span>sig</span><span> </span><span>type</span><span> </span><span>watch</span><span> </span><span>end</span><span>)</span><span> </span><span>:</span><span> </span><span>sig</span></span>
<span></span>
<span><span> </span><span> </span><span>type</span><span> </span><span>t</span></span>
<span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>get_id</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>int</span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>get_watch</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>M</span><span>.</span><span>watch</span><span> </span><span>option</span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>set_watch</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>M</span><span>.</span><span>watch</span><span> </span><span>option</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>get_subdirs</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>t</span><span> </span><span>StringMap</span><span>.</span><span>t</span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>is_root</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>bool</span></span>
<span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>file_by_id</span><span> </span><span>:</span><span> </span><span>(</span><span>int</span><span>,</span><span> </span><span>t</span><span>)</span><span> </span><span>Hashtbl</span><span>.</span><span>t</span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>dir_path</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>string</span><span> </span><span>-&gt;</span><span> </span><span>string</span></span>
<span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>signal_change</span><span> </span><span>:</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>float</span><span> </span><span>-&gt;</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>string</span><span> </span><span>option</span><span> </span><span>-&gt;</span><span> </span><span>[&gt;</span><span> </span><span>`CREAT</span><span> </span><span>|</span><span> </span><span>`DEL</span><span> </span><span>]</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span><span> </span><span> </span><span>val</span><span> </span><span>signal_overflow</span><span> </span><span>:</span><span> </span><span>unit</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span></span>
<span><span> </span><span> </span><span>module</span><span> </span><span>type</span><span> </span><span>S</span><span> </span><span>=</span><span> </span><span>sig</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>val</span><span> </span><span>add_watch</span><span> </span><span>:</span><span> </span><span>string</span><span> </span><span>-&gt;</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>bool</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>val</span><span> </span><span>release_watch</span><span> </span><span>:</span><span> </span><span>t</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>val</span><span> </span><span>watch</span><span> </span><span>:</span><span> </span><span>unit</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>val</span><span> </span><span>clear_event_memory</span><span> </span><span>:</span><span> </span><span>unit</span><span> </span><span>-&gt;</span><span> </span><span>unit</span></span>
<span><span> </span><span> </span><span>end</span></span>
<span></span>
<span><span> </span><span> </span><span>module</span><span> </span><span>F</span><span> </span><span>(</span><span>M</span><span> </span><span>:</span><span> </span><span>S</span><span>)</span><span> </span><span>:</span><span> </span><span>sig</span><span> </span><span>end</span></span>
<span></span>
<span><span>end</span></span></code></pre>
<h2 id="how-modularity-with-typeclasses">How: Modularity with Typeclasses</h2>
<p>Typeclasses are often used for abstraction. For example, here’s some simple code from a project of mine:</p>
<pre tabindex="0" data-language="rust"><code><span><span>pub</span><span> </span><span>trait</span><span> </span><span>FileSystem</span><span> </span><span>{</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Check</span><span> </span><span>if</span><span> </span><span>a</span><span> </span><span>path</span><span> </span><span>exists</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>fn</span><span> </span><span>exists</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>path</span><span>:</span><span> </span><span>&amp;</span><span>Path</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>bool</span><span>;</span></span>
<span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Get</span><span> </span><span>the</span><span> </span><span>file</span><span> </span><span>type</span><span> </span><span>of</span><span> </span><span>a</span><span> </span><span>path</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Returns</span><span> </span><span>an</span><span> </span><span>error</span><span> </span><span>if</span><span> </span><span>the</span><span> </span><span>path</span><span> </span><span>doesn&#39;t</span><span> </span><span>exist</span><span> </span><span>or</span><span> </span><span>can&#39;t</span><span> </span><span>be</span><span> </span><span>accessed</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Note:</span><span> </span><span>follows</span><span> </span><span>symlinks,</span><span> </span><span>so</span><span> </span><span>a</span><span> </span><span>symlink</span><span> </span><span>to</span><span> </span><span>a</span><span> </span><span>directory</span><span> </span><span>will</span><span> </span><span>return</span><span> </span><span>FileType::Dir</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>fn</span><span> </span><span>file_type</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>path</span><span>:</span><span> </span><span>&amp;</span><span>Path</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>FileType</span><span>&gt;;</span></span>
<span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>List</span><span> </span><span>entries</span><span> </span><span>in</span><span> </span><span>a</span><span> </span><span>directory</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Returns</span><span> </span><span>an</span><span> </span><span>iterator</span><span> </span><span>of</span><span> </span><span>(name,</span><span> </span><span>file_type)</span><span> </span><span>pairs</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Note:</span><span> </span><span>follows</span><span> </span><span>symlinks,</span><span> </span><span>so</span><span> </span><span>a</span><span> </span><span>symlink</span><span> </span><span>to</span><span> </span><span>a</span><span> </span><span>directory</span><span> </span><span>will</span><span> </span><span>return</span><span> </span><span>FileType::Dir</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>fn</span><span> </span><span>read_dir</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>path</span><span>:</span><span> </span><span>&amp;</span><span>Path</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>impl</span><span> </span><span>Iterator</span><span>&lt;</span><span>Item</span><span> </span><span>=</span><span> </span><span>Result</span><span>&lt;(</span><span>OsString</span><span>,</span><span> </span><span>FileType</span><span>)&gt;&gt;&gt;;</span></span>
<span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>///</span><span> </span><span>Read</span><span> </span><span>the</span><span> </span><span>contents</span><span> </span><span>of</span><span> </span><span>a</span><span> </span><span>file</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>string</span></span>
<span><span> </span><span> </span><span> </span><span> </span><span>fn</span><span> </span><span>read_to_string</span><span>(</span><span>&amp;</span><span>self</span><span>,</span><span> </span><span>path</span><span>:</span><span> </span><span>&amp;</span><span>Path</span><span>)</span><span> </span><span>-&gt;</span><span> </span><span>Result</span><span>&lt;</span><span>String</span><span>&gt;;</span></span>
<span><span>}</span></span></code></pre>
<p>Since I don’t need many filesystem operations, I only declare the ones I need, which makes it tractable to test at that interface easily.</p>
<p>What have we lost relative to using modules instead?</p>
<ul>
<li>The way we decompose things isn’t compositional. For instance, here I’ve said that <code>read_dir</code> may return something that satisfies the <code>Iterator</code> trait with a specialized <code>Item</code> type. But I can’t express “this method returns something that matches this particular signature” (i.e inline interfaces aren’t a thing). All interfaces must be tied to some type (which exist in a scope) and can’t be nested.</li>
<li>Now, every function that wants to write against this interface acquires a trait bound, which is more verbose than the concrete version. It’s annoying and noisy when you end up with extremely long function signatures. With modules, you can put the bound at the module level and each function doesn’t have to declare the dependency explicitly (Rust sort of has this with <code>impl</code> blocks but they’re also not composable).</li>
<li>Since typeclasses are designed for ad-hoc polymorphism, instance search is usually part of the implementation, which can be expensive at compile time. (eg. in rust <code>foo.bar()</code> has to first infer the type of foo, then look at everything that might transitively <code>impl foo</code>, then see what possible implementations for <code>bar</code> there are)</li>
</ul>
<p>In general, I think this approach promotes what I call a “set of functions” approach to program decomposition. The typeclass worldview is that there is a global type database, and functions may see different parts of this database depending on scoping, but ultimately the program is just a set of functions. Each function stands alone and you have to reason at the function level.</p>
<p>Modules give us a richer way to think about program decomposition. We’re not limited to drawing the boundaries at functions. We can reason about larger parts of our program at once. In terms of the earlier analogy, modules let us think in terms of nontrivial subsets of the program at a time.</p>
<h2 id="how-ad-hoc-polymorphism-with-modules">How: Ad-hoc polymorphism with Modules</h2>
<p>Well there’s one thing left, which is going the other way.</p>
<p>Many ML programmers will say “you don’t need ad-hoc polymorphism, and maybe it’s bad actually”. This isn’t as unreasonable an argument as it sounds: with careful use of lexically scoped imports, the lack of ad-hoc polymorphism is only slightly more verbose, and is probably more mechanically easy to understand. Plus since everything is explicit, the compiler doesn’t have to do any search to resolve polymorphic operations, which speeds up compilation. I think part of the appeal of Zig over Rust for many Zig users is because Zig programmers tend to fall on that side of the fence as well.</p>
<p>All of that is a long way to say that at least in OCaml, the way to achieve ad-hoc polymorphism is to simply not have it. For example here is some code from <a href="https://dev.realworldocaml.org/files-modules-and-programs.html">Real World OCaml</a> that illustrates some ways to use <code>Int64</code> arithmetic without having to namespace every arithmetic operation.</p>
<pre tabindex="0" data-language="ocaml"><code><span><span>let</span><span> </span><span>average</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>=</span></span>
<span><span> </span><span> </span><span>let</span><span> </span><span>open</span><span> </span><span>Int64</span><span> </span><span>in</span></span>
<span><span> </span><span> </span><span>(</span><span>x</span><span> </span><span>+</span><span> </span><span>y</span><span>)</span><span> </span><span>/</span><span> </span><span>of_int</span><span> </span><span>2</span><span>;;</span></span>
<span><span> </span><span> </span></span>
<span><span>let</span><span> </span><span>average</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>=</span></span>
<span><span> </span><span> </span><span>Int64</span><span>.</span><span>((</span><span>x</span><span> </span><span>+</span><span> </span><span>y</span><span>)</span><span> </span><span>/</span><span> </span><span>of_int</span><span> </span><span>2</span><span>);;</span></span></code></pre>
<p>Let’s say we really want ad-hoc polymorphism. If we think about it, traditional typeclasses can be expressed in terms of modules in the following way:</p>
<ul>
<li>We have a global database of signatures</li>
<li>We have a global database of types</li>
<li>We have a global database of modules, each of which is associated with a type (i.e every module has a type, but a type can have multiple modules)</li>
<li>Each signature also knows all the modules that conform to it, and hence their associated type</li>
</ul>
<p>And then, whenever we use something from a signature, we infer the type and then lookup the concrete module using it.</p>
<p>In theory, you could implement ad-hoc polymorphism pretty much the exact same way as the typeclass-first approach like this, with no real loss in ergonomics. This is basically what the <a href="https://www.cl.cam.ac.uk/~jdy22/papers/modular-implicits.pdf">Modular Implicits</a> proposal for OCaml suggests.</p>
<p>Scala 3 also supports what it calls <a href="https://docs.scala-lang.org/scala3/reference/contextual/index.html">“Contextual Abstraction”</a>, which is essentially a way of doing the above. The main difference with more traditional typeclass systems is that it doesn’t require <em>coherence</em> which is something out of the scope of this post.</p>
<h2 id="modules-and-typeclasses">Modules AND Typeclasses?</h2>
<p>Yes! Haskell has the Backpack module system that nobody uses, in addition to the typeclass system everybody uses. In theory, it has good support for both modular abstraction and ad-hoc polymorphism. Unfortunately, Backpack came kind of late to the ecosystem and has not seen much adoption.</p>
<p>I believe Rocq (formerly Coq) also has independent module and typeclass systems.</p>
<p>Rust has a module system separate from its trait system, but it’s too weak to support full modular programming. The module system only supports encapsulation and has no way to specify abstract module signatures, and therefore can’t have parametrized modules.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Please remember the distinction between <em>modular abstraction</em> and <em>ad-hoc polymorphism</em>. They can both be useful features in a programming language, and they have different concerns: one is for programming in the large, and the other in the small. Typeclasses and Modules are simply means to those ends.</p>
<p>If you’re designing a new language, I think a lot of people reach for typeclasses and good support for ad-hoc polymorphism first, with modular abstraction an afterthought. I personally think that is backwards: I find, in practice, good support for modular abstraction more valuable than ad-hoc polymorphism for writing high quality programs.</p>  </div></div>
  </body>
</html>
