<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://glama.ai/blog/2024-08-29-reverse-engineering-minified-code-using-openai">Original</a>
    <h1>OpenAI is shockingly good at unminifying code</h1>
    
    <div id="readability-page-1" class="page"><div data-sentry-component="Prose" data-sentry-source-file="Prose.tsx"><p>While browsing the Internet for inspiration, I came across an <a href="https://reactive.network/hackathon">interesting-looking component</a>.</p>
<!-- -->
<p><img src="https://glama.ai/images/reactive-VTS6R4H7.gif" alt="Reactive Network Hackathon"/></p><p>I thought the block with the running ASCII art looked cool, but I couldn&#39;t quite figure out how it was implemented, so I started looking at the source code.</p>
<p>I found the code that looked like it might be doing the job, but it was minified.</p>
<pre><code>const { floor: ra, abs: KE, min: QE } = Math,
    O5 = [&#34;reactive.network REACTIVE.NETWORK&#34;, &#34;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~&lt;&gt;i!lI;:,^`&#39;. .:â–‘â–’â–“â–ˆ&#34;],
    G7 = Date.now() % 3 ? O5[1] : O5[0],
    V5 = G7.length,
    JE = { fps: 60 };
function eT(e, t, n, r) {
    const i = t.time * 8e-5,
        s = QE(t.cols, t.rows),
        o = t.metrics.aspect * 0.2,
        l = { x: ((4 * (e.x - t.cols / 6.25)) / s) * o, y: (5 * (e.y - t.rows / 4)) / s },
        u = ra(KE(YE(l) - i) * V5 + (ra(e.x / 1) % 2) * 2) % V5;
    return G7[u];
}
const tT = () =&gt; {
    const e = j.useRef(null),
        [t, n] = j.useState({ height: null, width: null });
    return (
        j.useEffect(() =&gt; {
            function r() {
                n({ height: window.innerHeight, width: window.innerWidth });
            }
            if (typeof window &lt; &#34;u&#34;) return n({ height: window.innerHeight, width: window.innerWidth }), window.addEventListener(&#34;resize&#34;, r), () =&gt; window.removeEventListener(&#34;resize&#34;, r);
        }, []),
        j.useEffect(() =&gt; {
            const r = e.current;
            if (!r) return;
            const i = 12,
                s = ra(t.width / i) * 1.6,
                o = ra(t.height / i),
                l = { aspect: s / o },
                u = setInterval(() =&gt; {
                    let c = &#34;&#34;;
                    for (let d = 0; d &lt; o; d++) {
                        for (let f = 0; f &lt; s; f++) c += eT({ x: f, y: d }, { cols: s, rows: o, metrics: l, time: Date.now() });
                        c += `
`;
                    }
                    r.textContent = c;
                }, 1e3 / JE.fps);
            return () =&gt; clearInterval(u);
        }, [t]),
        a.jsx(&#34;div&#34;, { style: { position: &#34;absolute&#34;, top: 0, left: 0, width: &#34;100%&#34;, height: &#34;100%&#34; }, children: a.jsx(&#34;div&#34;, { ref: e, style: { width: &#34;100%&#34;, height: &#34;100%&#34;, whiteSpace: &#34;pre&#34;, overflow: &#34;hidden&#34; } }) })
    );
};
function nT(e) {
    return Math.cos(e.x * e.x - e.y * e.y);
}
const { floor: ia, abs: rT, min: iT } = Math,
    D5 = [&#34;reactive.network REACTIVE.NETWORK&#34;, &#34;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~&lt;&gt;i!lI;:,^`&#39;. .:â–‘â–’â–“â–ˆ&#34;],
    X7 = Date.now() % 3 ? D5[1] : D5[0],
    F5 = X7.length,
    sT = { fps: 60 };
function oT(e, t, n, r) {
    const i = t.time * 8e-5,
        s = iT(t.cols, t.rows),
        o = t.metrics.aspect * 0.2,
        l = { x: ((4 * (e.x - t.cols / 6.25)) / s) * o, y: (5 * (e.y - t.rows / 4)) / s },
        u = ia(rT(nT(l) - i) * F5 + (ia(e.x / 1) % 2) * 2) % F5;
    return X7[u];
}
const aT = () =&gt; {
    const e = j.useRef(null),
        [t, n] = j.useState({ height: null, width: null });
    return (
        j.useEffect(() =&gt; {
            function r() {
                n({ height: window.innerHeight, width: window.innerWidth });
            }
            if (typeof window &lt; &#34;u&#34;) return n({ height: window.innerHeight, width: window.innerWidth }), window.addEventListener(&#34;resize&#34;, r), () =&gt; window.removeEventListener(&#34;resize&#34;, r);
        }, []),
        j.useEffect(() =&gt; {
            const r = e.current;
            if (!r) return;
            const i = 12,
                s = ia(t.width / i) * 1.6,
                o = ia(t.height / i),
                l = { aspect: s / o },
                u = setInterval(() =&gt; {
                    let c = &#34;&#34;;
                    for (let d = 0; d &lt; o; d++) {
                        for (let f = 0; f &lt; s; f++) c += oT({ x: f, y: d }, { cols: s, rows: o, metrics: l, time: Date.now() });
                        c += `
`;
                    }
                    r.textContent = c;
                }, 1e3 / sT.fps);
            return () =&gt; clearInterval(u);
        }, [t]),
        a.jsx(&#34;div&#34;, { style: { position: &#34;absolute&#34;, top: 0, left: 0, width: &#34;100%&#34;, height: &#34;100%&#34; }, children: a.jsx(&#34;div&#34;, { ref: e, style: { width: &#34;100%&#34;, height: &#34;100%&#34;, whiteSpace: &#34;pre&#34;, overflow: &#34;hidden&#34; } }) })
    );
},
</code></pre>
<p>Usually, I would just powerthrough reading the minimized code to understand the implementation (or look for a <code>.map</code> file to restore the original code). However, I realized that I never tried asking ChatGPT to do it for me... So I copied all of the above code and asked ChatGPT to &#34;explain the code&#34;. Here is the response:</p>
<blockquote>
<p>The provided code is quite complex, but I&#39;ll break it down into a more understandable format, explaining its different parts and their functionalities.</p>
<h3>Overview</h3>
<p>The code defines several functions and components using JavaScript, specifically in the context of a React application. It deals with generating some dynamic text content, presumably ASCII art or some kind of visual effect using characters from a predefined set. Additionally, it includes utility functions for event handling, performance timing, and HTML content conversion.</p>
<h3>Key Components and Functions</h3>
<ol>
<li><strong>Character Set Selection:</strong>
<pre><code>const { floor: ra, abs: KE, min: QE } = Math;
const O5 = [&#34;reactive.network REACTIVE.NETWORK&#34;, &#34;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~&lt;&gt;i!lI;:,^`&#39;. .:â–‘â–’â–“â–ˆ&#34;];
const G7 = Date.now() % 3 ? O5[1] : O5[0];
const V5 = G7.length;
</code></pre>
<ul>
<li>This part of the code imports some common Math functions (<code>floor</code>, <code>abs</code>, and <code>min</code>) and defines two sets of characters, stored in <code>O5</code>.</li>
<li>Based on the current time (<code>Date.now() % 3</code>), it selects one of these sets (<code>G7</code>) to use later.</li>
<li>The length of the selected character set is stored in <code>V5</code>.</li>
</ul>
</li>
<li><strong>Dynamic Character Selection Function:</strong>
<pre><code>function eT(e, t, n, r) {
    const i = t.time * 8e-5;
    const s = QE(t.cols, t.rows);
    const o = t.metrics.aspect * 0.2;
    const l = { x: ((4 * (e.x - t.cols / 6.25)) / s) * o, y: (5 * (e.y - t.rows / 4)) / s };
    const u = ra(KE(YE(l) - i) * V5 + (ra(e.x / 1) % 2) * 2) % V5;
    return G7[u];
}
</code></pre>
<ul>
<li>The <code>eT</code> function generates a character based on the input position (<code>e.x</code>, <code>e.y</code>) and the current time (<code>t.time</code>).</li>
<li>It adjusts the position using some aspect ratio calculations and selects a character from <code>G7</code> based on a combination of the position and time.</li>
<li>The purpose of <code>YE</code> function isn&#39;t directly clear from the code, but it seems to be a custom function used in this calculation.</li>
</ul>
</li>
<li><strong>React Component (<code>tT</code>) for Displaying Dynamic Content:</strong>
<pre><code>const tT = () =&gt; {
    const e = j.useRef(null);
    const [t, n] = j.useState({ height: null, width: null });
    j.useEffect(() =&gt; {
        function r() {
            n({ height: window.innerHeight, width: window.innerWidth });
        }
        if (typeof window &lt; &#34;u&#34;) {
            n({ height: window.innerHeight, width: window.innerWidth });
            window.addEventListener(&#34;resize&#34;, r);
            return () =&gt; window.removeEventListener(&#34;resize&#34;, r);
        }
    }, []);

    j.useEffect(() =&gt; {
        const r = e.current;
        if (!r) return;
        const i = 12;
        const s = ra(t.width / i) * 1.6;
        const o = ra(t.height / i);
        const l = { aspect: s / o };
        const u = setInterval(() =&gt; {
            let c = &#34;&#34;;
            for (let d = 0; d &lt; o; d++) {
                for (let f = 0; f &lt; s; f++) c += eT({ x: f, y: d }, { cols: s, rows: o, metrics: l, time: Date.now() });
                c += `
`;
            }
            r.textContent = c;
        }, 1e3 / JE.fps);
        return () =&gt; clearInterval(u);
    }, [t]);

    return a.jsx(&#34;div&#34;, { style: { position: &#34;absolute&#34;, top: 0, left: 0, width: &#34;100%&#34;, height: &#34;100%&#34; }, children: a.jsx(&#34;div&#34;, { ref: e, style: { width: &#34;100%&#34;, height: &#34;100%&#34;, whiteSpace: &#34;pre&#34;, overflow: &#34;hidden&#34; } }) });
};
</code></pre>
<ul>
<li>This is a React component that sets up an interval to periodically update the content of a <code>div</code> element (<code>e.current</code>) with dynamically generated characters.</li>
<li>It calculates the number of columns (<code>s</code>) and rows (<code>o</code>) based on the window size and then fills the <code>div</code> with characters generated by the <code>eT</code> function.</li>
<li>The effect runs at a specified frames per second (<code>JE.fps</code>).</li>
</ul>
</li>
</ol>
</blockquote>
<p>I followed up asking to &#34;implement equivalent code in TypeScript and make it human readable&#34; and got the following response:</p>
<pre><code>import React, { useEffect, useRef, useState } from &#39;react&#39;;

const selectedCharacterSet =
  &#34;$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/|()1{}[]?-_+~&lt;&gt;i!lI;:,^`&#39;. .:â–‘â–’â–“â–ˆ&#34;;
const characterSetLength = selectedCharacterSet.length;

const calculateCharacter = (
  x: number,
  y: number,
  cols: number,
  rows: number,
  aspect: number,
  time: number,
): string =&gt; {
  const timeFactor = time * 0.000_08;
  const size = Math.min(cols, rows);
  const aspectRatio = aspect * 0.2;
  const position = {
    x: ((4 * (x - cols / 6.25)) / size) * aspectRatio,
    y: (5 * (y - rows / 4)) / size,
  };

  const index =
    Math.floor(
      Math.abs(
        Math.cos(position.x * position.x - position.y * position.y) -
          timeFactor,
      ) *
        characterSetLength +
        (Math.floor(x) % 2) * 2,
    ) % characterSetLength;
  return selectedCharacterSet[index];
};

type Size = {
  height: null | number;
  width: null | number;
};

const AsciiArtGenerator: React.FC = () =&gt; {
  const textRef = useRef&lt;HTMLDivElement&gt;(null);
  const [size, setSize] = useState&lt;Size&gt;({ height: null, width: null });

  useEffect(() =&gt; {
    const handleResize = () =&gt; {
      setSize({ height: window.innerHeight, width: window.innerWidth });
    };

    // Initial size setting
    handleResize();

    window.addEventListener(&#39;resize&#39;, handleResize);
    return () =&gt; {
      window.removeEventListener(&#39;resize&#39;, handleResize);
    };
  }, []);

  useEffect(() =&gt; {
    const element = textRef.current;
    if (!element || !size.width || !size.height) return undefined;

    const cols = Math.floor(size.width / 12) * 1.6;
    const rows = Math.floor(size.height / 12);
    const aspectRatio = cols / rows;

    const intervalId = setInterval(() =&gt; {
      let content = &#39;&#39;;

      for (let y = 0; y &lt; rows; y++) {
        for (let x = 0; x &lt; cols; x++) {
          content += calculateCharacter(
            x,
            y,
            cols,
            rows,
            aspectRatio,
            Date.now(),
          );
        }

        content += &#39;\n&#39;;
      }

      element.textContent = content;
    }, 1_000 / 60); // 60 fps

    return () =&gt; {
      clearInterval(intervalId);
    };
  }, [size]);

  return (
    &lt;div
      ref={textRef}
      style={{
        height: &#39;100%&#39;,
        overflow: &#39;hidden&#39;,
        whiteSpace: &#39;pre&#39;,
        width: &#39;100%&#39;,
      }}
    /&gt;
  );
};

export default () =&gt; {
  return &lt;AsciiArtGenerator /&gt;;
};
</code></pre>
<p>To my surprise, the response is not only good enough, but it is also very readable.</p>
<p>Here is the above component in action:</p>
<!-- -->

<p>Comparing the outputs, <del>it looks like LLM response overlooked a few implementation details</del>, but it is still a good enough implementation to learn from. Definitely a neat use case I&#39;ve not considered before!</p>
<blockquote>
<p>Update (2024-08-29): Initially, I thought that the LLM didn&#39;t replicate the logic accurately because the output was missing a few characters visible in the original component (e.g., <code>░▒▓█</code>). However, <a href="https://news.ycombinator.com/item?id=41389791">a user on HN forum</a> pointed out that it was likely a copy-paste error.</p>
<p>Upon further investigation, I discovered that the original code contains different characters than what I pasted into ChatGPT. This appears to be an encoding issue, as I was able to get the correct characters after downloading the script. After updating the code to use the correct characters, the output is now identical to the original component.</p>
<p>I apologize, GPT-4, for mistakenly accusing you of making mistakes.</p>
</blockquote></div></div>
  </body>
</html>
