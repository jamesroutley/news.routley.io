<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gabevenberg.com/posts/cli-renaissance/">Original</a>
    <h1>The Modern CLI Renaissance</h1>
    
    <div id="readability-page-1" class="page"><div><p>Over the past few years, it seems like the rate at which new CLI tools are being written has picked back up again,
accelerating after seeing relatively little activity between ~1995 and ~2015.
I’d like to talk about this trend I’ve noticed,
where people are rewriting and rethinking staples of the command line interface,
why I think this trend might be happening,
and why I think this trend is a good thing.</p><h2 id="history">History</h2><p>The terminal and the command line interface have been staples of computer user interfaces before computer monitors were even available,
with some of the first computers offering an interactive mode in the late 1950’s.
The recognizable Linux terminal traces its linage to the very first version of Unix in 1971.
Many utilities that a Linux user interacts with every day,
commands like <code>rm</code>, <code>cat</code>, <code>cd</code>, <code>cp</code>, <code>man</code>, and a host of other core commands trace their initial versions to this first version of Unix.
Other tools are a bit newer, such as <code>sed</code> (1974), <code>diff</code> (1974) <code>bc</code> (1975), <code>make</code> (1976), or <code>vi</code> (1976).
There were a few more tools introduced in the 90’s, such as <code>vim</code> (1991) and <code>ssh</code> (1995), but you get the picture.
The majority of the foundational CLI tools on a Linux pc, even one installed yesterday, are older than Linux itself is.</p><h2 id="ok-so">Ok, so?</h2><p>Now, there’s nothing wrong with this.
The tools still work fine, but in the half-century since they were first written,
terminals and the broader Linux ecosystem have all changed.
Terminals now have capacity to display more colours, Unicode symbols, and even inline images.
Terminal programs now coexist with graphical user interfaces,
and only a small subset of computer users even know they exist,
whereas in the past, terminals were the only way one interacted with the computer.</p><p>These changes to the environment surrounding CLI apps in recent years have
led to a resurgence in development of command line utilities.
Instead of just developing completely new tools or cloning old tools,
I’ve noticed that people are rethinking and reinventing tools that have existed since the early days of Unix.</p><p>This isn’t just some compulsive need to rewrite every tool out there in your favorite language.
People are looking at the problem these tools set out to solve,
and coming up with their own solutions to them,
exploring the space of possible solutions and taking new approaches.</p><p>Its this exploration of the solution space that id like to take a look at:
the ways that tools are changing,
why people are changing them,
and what kicked off this phenomenon.</p><h2 id="the-lessons-learned-from-the-past">The lessons learned from the past</h2><p>A large amount of the innovation in the area, I think,
can be attributed to lessons that have been learned in 50 years of using software:
sharp edges we have repeatedly cut ourselves on,
unintuitive interfaces that repeatedly trip us up,
and growing frustration at the limitations that maintaining decades of backwards compatibility imposes on our tools.</p><p>These lessons have been gathering in the collective conciousness;
through cheatsheets, guides, and FAQs;
resources to guide us through esoteric error messages, complex configurations, and dozens upon dozens of flags.</p><p>Id like to go over a couple of the more prominent lessons that I feel terminal tools have learned in the past several decades.</p><h3 id="a-good-out-of-the-box-experience">A good out of the box experience</h3><p>While configurability is great,
one should not need to learn a new configuration language and dozens or hundreds of options to get a usable piece of software.
Configuration should be for customization, not setup.</p><p>One of the earliest examples of this principle may be the fish shell.
Both zsh and fish have powerful prompt and autocompletion engines,
but zsh requires you to setup a custom prompt and enable completions in order to use the features that set it apart from the competition.
With no config file, zsh is no better than bash.
When starting fish for the first time, however,
its powerful autocompletion and information rich prompt are front and center with no configuration required.
Of course, fish still has the same level of configurability as zsh, it just also has sensible defaults.</p><p>To demonstrate my point, this is the default prompt for zsh with no configuration.
It <em>only</em> shows the hostname, none of the advanced features you can get out of a zsh prompt even without plugins.
<img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/zsh-prompt.png" alt="zsh prompt, only shows hostname"/>
Here is bash’s prompt.
It actually gives more info than zsh’s, even though zsh can do more when properly configured.
<img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/bash-prompt.png" alt="bash prompt, shows hostname and current directory"/>
And here is fish’s default prompt.
It has a few colours, shows everything the bash prompt does, and additionally shows the git branch we are on.
<img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/fish-prompt.png" alt="fish prompt, has colours, shows hostname, current directory, and git info"/></p><p>Text editors are another great example of the evolution of out of the box defaults.
Vim and Neovim both improved on their predecessors,
but much of that improvement is locked behind extremely complex configuration experiences and plugins.
Here’s four different terminal text editors with no configuration applied:</p><p><img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/editors.png" alt="vi, vim, neovim, and helix editors in their default
configuration"/></p><p>Vi, (top left) is our baseline, and, as far as I can tell, doesn’t actually
support much for configuration. What you see out of the box is more or less
whats there.</p><p>Vim (top right) greatly improved on Vi, adding things such as syntax highlighting, line numbers, spellchecking, split windows, folding, and even basic autocompletion.
However, everything but syntax highlighting is either extremely clunky or outright disabled without configuration.
For example, the earliest things I did when I first made a <code>.vimrc</code> was to enable indent folding,
make some better keybinds for navigating windows, and adding a line number ruler to the side.</p><p>Neovim (bottom left) further improved on Vim, adding support for Treesitter and the Language Server Protocol,
but the out of the box experience is the <em>exact</em> same as vim!
In order to take advantage of the LSP and Treesitter support, you have to install plugins,
which means learning a Nvim package manager, learning how to configure LSPs,
and configuring a new LSP for every language you want to use it with
or finding out about Mason and being OK with having multiple levels of package management in your Nvim install alone.
Don’t get me wrong: Neovim is a great editor once you get over the hump.
I still use it as my daily driver, but so much of its functionality is simply hidden.</p><p>Then we have the Helix (bottom right) editor.
Slightly glaring default colour scheme aside, everything is just <em>there</em>.
Helix doesn’t have plugin support <a href="https://github.com/helix-editor/helix/discussions/3806">yet</a>,
but it has so much stuff in core that,
looking through my neovim plugins,
pretty much all of them are in the core editor!
Ironically, the one feature that I feel helix is missing, <a href="https://github.com/helix-editor/helix/issues/1840">folding</a>,
is a core part of neovim, albeit one that requires some configuration to get good use out of.
Helix does have a config file where you can change a huge amount of settings,
but its an extremely usable IDE out of the box thanks to having all of its features enabled by default.</p><h3 id="helpful-error-messages">Helpful error messages</h3><p>When the user does do something wrong, it is vital to let them know exactly what, where, and how it went wrong,
and if at all possible, what action the user can do to fix it.
<code>Operation Failed</code>, <code>Error</code> or <code>syntax error</code> on their own are horrible error messages.
They tell you that something <em>somewhere</em> failed, giving almost no information the user can use to troubleshoot.
In the worst case, they can even point you in a completely different direction than what is actually needed to fix things.
Git is a good example of this. As much as I love git, sometimes its error messages are the opposite of helpful.
To borrow an example from <a href="https://jvns.ca/blog/2024/04/10/notes-on-git-error-messages/#git-checkout-asdf">Julia Evans</a>,
if you run <code>git checkout SomeNonExistantBranch</code>, you get:
<code>error: pathspec &#39;SomeNonexistantBranch&#39; did not match any file(s) known to git</code>.
This is confusing because you are trying to checkout a branch, you arent thinking about files.</p><p>Another example, I covered <a href="https://gabevenberg.com/posts/nushell">before</a> is the contrast between Bash and Nushell.
Consider the following script:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>$ <span>for</span> i in <span>$(</span>ls -l | tr -s <span>&#34; &#34;</span> | cut --fields<span>=</span><span>5</span> --delimiter<span>=</span><span>&#34; &#34;</span><span>)</span>; <span>do</span>
</span></span><span><span>echo <span>&#34;</span>$i<span> / 1000&#34;</span> | bc
</span></span><span><span><span>done</span></span></span></code></pre></div><p>This gets the sizes of all the files in KiB. But what if we typo the cut field?</p><div><pre tabindex="0"><code data-lang="sh"><span><span>$ <span>for</span> i in <span>$(</span>ls -l | tr -s <span>&#34; &#34;</span> | cut --fields<span>=</span><span>6</span> --delimiter<span>=</span><span>&#34; &#34;</span><span>)</span>; <span>do</span>
</span></span><span><span>echo <span>&#34;</span>$i<span> / 1000&#34;</span> | bc
</span></span><span><span><span>done</span>
</span></span><span><span>
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error
</span></span><span><span><span>(</span>standard_in<span>)</span> 1: syntax error</span></span></code></pre></div><p>Due to the syntax error coming from bc rather than bash directly,
even the line number it gives you is misleading,
and in order to have the slightest clue whats going on,
you have to start print debugging.</p><p>The equivalent in nushell would be:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>&gt; ls | get size | each <span>{</span>|item| $item / 1000<span>}</span></span></span></code></pre></div><p>and the equivilant error would be:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>&gt; ls | get type | each <span>{</span>|item| $item / 1000<span>}</span>
</span></span><span><span>Error: nu::shell::eval_block_with_input
</span></span><span><span>
</span></span><span><span>  × Eval block failed with pipeline input
</span></span><span><span>   ╭─<span>[</span>entry <span>#5:1:1]</span>
</span></span><span><span> <span>1</span> │ ls | get type | each <span>{</span>|item| $item / 1000<span>}</span>
</span></span><span><span>   · ─┬
</span></span><span><span>   ·  ╰── source value
</span></span><span><span>   ╰────
</span></span><span><span>
</span></span><span><span>Error: nu::shell::type_mismatch
</span></span><span><span>
</span></span><span><span>  × Type mismatch during operation.
</span></span><span><span>   ╭─<span>[</span>entry <span>#5:1:30]</span>
</span></span><span><span> <span>1</span> │ ls | get type | each <span>{</span>|item| $item / 1000<span>}</span>
</span></span><span><span>   ·                              ──┬── ┬ ──┬─
</span></span><span><span>   ·                                │   │   ╰── int
</span></span><span><span>   ·                                │   ╰── type mismatch <span>for</span> operator
</span></span><span><span>   ·                                ╰── string
</span></span><span><span>   ╰────</span></span></code></pre></div><p>Though the first error isnt helpful, the second one tells us right away that <code>$item</code> is not what we expect it to be,
hopefully pointing us to the <code>get type</code> mistake.
Nushells error messages are miles ahead of other shells just…
being useful, helping you find where you made an error,
rather than just telling you theres an error <em>somewhere</em>.</p><h3 id="concise-and-discoverable-documentation">Concise and discoverable documentation</h3><p>In my Nvim config, I use <a href="https://github.com/folke/which-key.nvim">which-key</a>,
a plugin that displays available keybindings as you type.
I’ve been using vim for almost a decade, including a long time without which-key,
so its not like I never learned the keybindings, but I still find which-key useful.
Why is that, you may ask?
Well, because even though I use (n)vim every day, I don’t use all the keybindings every day.
I might go months between using, for example, <code>dap</code> (delete current paragraph), or <code>C-w x</code> (swap current window for next).
Naturally, when you go months without using certain parts of a program, you tend to forget they exist.
Which-key solves that handily, by offering quick, non-intrusive reminders of what is available.
Here’s what my which-key config looks like:</p><p><img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/nvim-which-key.png" alt="Which-key.nvim, showing contextual key hints"/></p><p>Now, which-key and its like have been around for a while,
but other TUI programs have integrated contextual hints without the need for a plugin.
The two that I am aware of are zellij and helix.</p><p><img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/helix-contextual-hint.png" alt="Helix&amp;rsquo;s contextual hint"/></p><p>Helix both has autocompletion for its built in command line and a contextual hint that appears when you press the first key in a multi key combo.
This drastically helps both new and experienced users learn and remember keybinds without making the editor any less powerful.</p><p><img loading="lazy" src="https://gabevenberg.com/posts/cli-renaissance/zellij-hints.png" alt="Zellij&amp;rsquo;s hint bar"/></p><p>Zellij has a bottom bar displaying keybindings available in the current mode.
This has proven invaluable for me, as I don’t use a terminal multiplexer much
(On GUI systems, I use the window manager for managing multiple terminals), and as such tend to forget the keybinds.
Though it does take up screen space, and a person who used Zellij every day would most likely disable it,
the hints bar is more than worth it for new and occasional users.</p><h3 id="common-usecases-should-be-easy">Common usecases should be easy</h3><p>Where possible, documentation should not even be required for the most common use cases.
Whenever I want to use <code>find</code>, I almost always have to first look at the man page,
as I don’t use it quite often enough to memorize it.
But that’s totally unneeded! 90% of my uses of <code>find</code> take the form of <code>find ./ -name &#34;*foo*&#34;</code>.
With <a href="https://github.com/sharkdp/fd">fd</a>, the exact same invocation is a simple <code>fd foo</code>, dead simple, no man page needed.
Of course, 10% of the time I’m doing something else and have to look at the manual even with fd,
but the point is that manuals are for when you want to do something with the tool that is not the most common usecase.</p><p>There are many other examples as well. How many of your grep invocations are in the form of <code>grep -R &#39;foo&#39; ./</code>?
Most of mine are. <a href="https://github.com/BurntSushi/ripgrep">Ripgrep</a> shortens that to <code>rg foo</code>
while still having all the power of grep when I need it, and it is faster as well!</p><p>This isn’t to say that tools should ‘dumb themselves down’ or hobble themselves to make them easier to use.
However they should keep in mind the most common usecase that their tool is likely to be used in,
and streamline that usecase.</p><h2 id="shedding-historical-baggage">Shedding historical baggage</h2><p>Many tools were made for one thing, and over time have evolved into another thing entirely.
This can happen by conscious design or, more commonly,
from an industry or community picking a tool up and using it for something it was not originally designed for.
While hacking tools for uses they were not designed for is always fun and in many cases the only way to do something,
its perhaps better to make a dedicated tool when the design choices made for the old usecases start hindering the new usecases.</p><p>A great example of this is <a href="https://github.com/casey/just">just</a>, a command runner heavily inspired by GNU make.
Make was (and in large part still is) a C build system.
As such, it includes features such as implicit rules
(if a file called <code>foo.o</code> is needed and there is no explicit rule is there, the C compiler will be invoked on the file <code>foo.c</code>
(there are similar rules for C++ and linking))
and file modification time laziness
(fantastic for a build system, needs liberal sprinkling of <code>.PHONY</code> rules when used as a task runner).</p><p>These features are <em>good</em> features when make is being used as a build system,
but another major use of make that has emerged has been as a way to run common tasks.
So alongside <code>make build</code> to build your program, you would have <code>make bootstrap</code>, <code>make test</code>, <code>make config</code>, etc.
This is where the design decisions behind make the build system start to hinder make the task runner,
making one learn about make the build system in order to work around those features to use make the task runner.
However, make cant drop these features, both because projects still actively use make as a build system,
and because even makefiles that are just used as taskrunners still work around the footguns and
would be broken by make making large changes to its syntax and semantics.</p><p>However, Just was designed from the outset to be a command runner, and as a result,
it is much easier to pick up the just language and make a quick set of commands that can be run.
By leaving behind the old tool, a new tool can be made that better fits the tasks that people use the tool for.</p><h2 id="the-languages">The languages</h2><p>Another thing I’ve noticed is that while the language of choice for CLI tools used to be C,
More recent tooling has been dominated by Rust and Go.</p><p>Of course, there are exceptions to the pattern.
TeX was written in pascal, Neovim kept C as its primary language,
and there is the occasional new tool written in C or C++.
But there is still a clear pattern in the language choice for newly written tools.</p><p>Now, why do you think that pattern has changed?
And have these new languages led to an increase in the number of tools being written?
I think so, and I don’t actually think its the languages itself, so much as the libraries surrounding them.</p><p>Both Rust and Go have healthy package ecosystems surrounding interaction with the terminal.
Rust has Clap for argument parsing,
crossterm for dealing with ANSI escape codes and other terminal interaction,
and Ratatui for making TUIs.
Go has a similar set of tools, with Cobra for CLI argument parsing,
Viper for config file management integrated with Cobra,
Gocui, tview, and Termui for TUIs,
or Bubbletea for pretty UI components.</p><p>These libraries combined with the extra ergonomics offered by the languages themselves,
make the barrier to entry lower,
allowing for more people to experiment with the design and ergonomics of CLI tools.</p><h2 id="conclusion">Conclusion</h2><blockquote><p>If I have seen further than others, it is by standing on the shoulders of giants.</p></blockquote><p>– Isaac Newton, 1675</p><p>Once again, Id like to state that I am not advocating for shiny new tools <em>because</em> they are shiny and new.
Likewise, I dont think the old tools are <em>bad</em>, nor does their age alone count against them.
However, new tools have the opportunity to learn from their predecessors and build upon them.
In this way, the new tools are a tribute to those tools that came before;
a recognition of their strengths, an acknowledgement of their weaknesses.</p><p>Now, these new tools are not the be-all end-all of the command line interface.
Just because this new generation of tools improve on the old ones,
it does not mean they are themselves perfect.
As we use these tools, we will become familiar with them,
and we will discover their sharp edges,
or their common usecase will change,
or we develop a new usecase entirely.
And when these things happen, we will develop yet another generation of tools,
one further polished and adapted to new usecases.</p><p>This is an extremely unscientific table of command line tools that I have tried, have used, or currently use.
It is assuredly incomplete, but <em>should</em> be broadly representative.
The date data has been gathered from the first git commit where available,
wikipedia otherwise, and sorting is by year first, then alphabetical.</p><table><thead><tr><th>tool</th><th>year</th><th>language</th></tr></thead><tbody><tr><td>ls</td><td>1961</td><td>c</td></tr><tr><td>cat</td><td>1971</td><td>c</td></tr><tr><td>cd</td><td>1971</td><td>c</td></tr><tr><td>cp</td><td>1971</td><td>c</td></tr><tr><td>man</td><td>1971</td><td>c</td></tr><tr><td>rm</td><td>1971</td><td>c</td></tr><tr><td>grep</td><td>1973</td><td>c</td></tr><tr><td>diff</td><td>1974</td><td>c</td></tr><tr><td>sed</td><td>1974</td><td>c</td></tr><tr><td>bc</td><td>1975</td><td>c</td></tr><tr><td>make</td><td>1976</td><td>c</td></tr><tr><td>vi</td><td>1976</td><td>c</td></tr><tr><td>TeX</td><td>1978</td><td>pascal</td></tr><tr><td>bourne shell</td><td>1979</td><td>c</td></tr><tr><td>awk</td><td>1985</td><td>c</td></tr><tr><td>screen</td><td>1987</td><td>c</td></tr><tr><td><a href="https://www.gnu.org/software/bash/">bash</a></td><td>1989</td><td>c</td></tr><tr><td><a href="https://www.zsh.org/">zsh</a></td><td>1990</td><td>c</td></tr><tr><td><a href="https://www.vim.org/">vim</a></td><td>1991</td><td>c</td></tr><tr><td>midnight commander</td><td>1994</td><td>c</td></tr><tr><td>ssh</td><td>1995</td><td>c</td></tr><tr><td><a href="https://github.com/curl/curl">curl</a></td><td>1996</td><td>c</td></tr><tr><td><a href="https://fishshell.com/">fish</a></td><td>2005</td><td>c++ (currently being rewritten in rust)</td></tr><tr><td><a href="https://fossil-scm.org/home/doc/trunk/www/index.wiki">fossil</a></td><td>2006</td><td>c</td></tr><tr><td><a href="https://github.com/tmux/tmux">tmux</a></td><td>2007</td><td>c</td></tr><tr><td><a href="https://git-scm.com/">git</a></td><td>2008</td><td>c</td></tr><tr><td><a href="https://github.com/ggreer/the_silver_searcher">the silver searcher</a></td><td>2011</td><td>c</td></tr><tr><td><a href="https://go.dev/">go 1.0</a></td><td>2012</td><td>go</td></tr><tr><td><a href="https://github.com/jqlang/jq">jq</a></td><td>2012</td><td>c</td></tr><tr><td><a href="https://github.com/junegunn/fzf">fzf</a></td><td>2013</td><td>go</td></tr><tr><td><a href="https://github.com/eza-community/eza">eza/exa</a></td><td>2014</td><td>rust</td></tr><tr><td><a href="https://neovim.io/">neovim</a></td><td>2015</td><td>c</td></tr><tr><td><a href="https://github.com/Nukesor/pueue">pueue</a></td><td>2015</td><td>rust</td></tr><tr><td><a href="https://www.rust-lang.org/">rust 1.0</a></td><td>2015</td><td>rust</td></tr><tr><td><a href="https://github.com/casey/just">just</a></td><td>2016</td><td>rust</td></tr><tr><td><a href="https://micro-editor.github.io/">micro</a></td><td>2016</td><td>go</td></tr><tr><td><a href="https://github.com/jarun/nnn">nnn</a></td><td>2016</td><td>c</td></tr><tr><td><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a></td><td>2016</td><td>rust</td></tr><tr><td><a href="https://github.com/sharkdp/fd">fd</a></td><td>2017</td><td>rust</td></tr><tr><td><a href="https://github.com/sharkdp/bat">bat</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://dystroy.org/broot/">broot</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://difftastic.wilfred.me.uk/">difftastic</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://github.com/sharkdp/hyperfine">hyperfine</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://github.com/jesseduffield/lazygit">lazygit</a></td><td>2018</td><td>go</td></tr><tr><td><a href="https://github.com/lsd-rs/lsd">lsd</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://www.nushell.sh/">nushell</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://github.com/boyter/scc">scc</a></td><td>2018</td><td>go</td></tr><tr><td><a href="https://github.com/chmln/sd">sd</a></td><td>2018</td><td>rust</td></tr><tr><td><a href="https://github.com/ClementTsang/bottom">bottom</a></td><td>2019</td><td>rust</td></tr><tr><td><a href="https://github.com/dandavison/delta">git-delta</a></td><td>2019</td><td>rust</td></tr><tr><td><a href="https://github.com/pemistahl/grex">grex</a></td><td>2019</td><td>rust</td></tr><tr><td><a href="https://starship.rs/">starship</a></td><td>2019</td><td>rust</td></tr><tr><td><a href="https://github.com/dduan/tre">tre</a></td><td>2019</td><td>rust</td></tr><tr><td><a href="https://typst.app/">typst</a></td><td>2019</td><td>rust</td></tr><tr><td><a href="https://github.com/imsnif/diskonaut">diskonaut</a></td><td>2020</td><td>rust</td></tr><tr><td><a href="https://github.com/muesli/duf">duf</a></td><td>2020</td><td>go</td></tr><tr><td><a href="https://helix-editor.com/">helix</a></td><td>2020</td><td>rust</td></tr><tr><td><a href="https://pijul.org/">pijul</a></td><td>2020</td><td>rust</td></tr><tr><td><a href="https://zellij.dev/">zellij</a></td><td>2020</td><td>rust</td></tr><tr><td><a href="https://github.com/ajeetdsouza/zoxide">zoxide</a></td><td>2020</td><td>rust</td></tr><tr><td><a href="https://github.com/aristocratos/btop">btop</a></td><td>2021</td><td>c++</td></tr><tr><td><a href="https://github.com/ast-grep/ast-grep">ast-grep</a></td><td>2022</td><td>rust</td></tr><tr><td><a href="https://github.com/sxyazi/yazi">yazi</a></td><td>2024</td><td>rust</td></tr></tbody></table></div></div>
  </body>
</html>
