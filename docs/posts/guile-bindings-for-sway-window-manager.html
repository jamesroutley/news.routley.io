<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/ebeem/guile-swayer">Original</a>
    <h1>Guile bindings for Sway window manager</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">
<p dir="auto">I am an <code>Emacs</code> user and previously used <code>StumpWM</code>, an <code>X11</code> window manager written in <code>Common Lisp</code>. I believe window managers should be scriptable because the level of workflow customization required by users often exceeds what can be achieved with simple configuration parameters (see my workflow below for a clearer understanding of why this is the case). Unfortunately, <code>Sway/i3</code> lacks a straightforward programmable interface for customization. This project provides complete control over <code>Sway/i3</code> using <code>Guile</code>!</p>

<p dir="auto">I had to migrate to <code>Wayland</code> at some point. Being a big fan of <code>StumpWM</code>, I tried to replicate a similar environment in one of the <code>Wayland</code> window managers. I made some progress with <code>hyprland</code> using a set of <code>Guile</code> bindings I developed called <code>hypripc</code>, but I found that <code>Hyprland</code> isn’t as stable as <code>Sway</code>.</p>

<p dir="auto">Note: refer to the github wiki for more documentation.</p>
<p dir="auto">After cloning this repository, you can immediately test it using the provided <code>examples/playground/example.scm</code> file in the directory, which demonstrates some of the features available in this package.</p>
<p dir="auto">The <code>examples/playground/example.scm</code> file will:</p>
<ul dir="auto">
  <li>Print the current focused workspace</li>
  <li>Add a keybinding (Super+t) that launches Alacritty</li>
  <li>Print a message when a workspace change event occurs</li>
</ul>
<div dir="auto" data-snippet-clipboard-copy-content="guile ./examples/playground/example.scm"><pre>guile ./examples/playground/example.scm</pre></div>

<p dir="auto">All the examples included in this project reference the <code>guile-swayer</code> package relatively for ease of testing. To make <code>guile-swayer</code> package publicly visible to guile, it must be added to the <code>GUILE_LOAD_PATH</code> which should be <code>/usr/local/share/guile/site/3.0</code> for <code>guile-3</code></p>
<p dir="auto">If you use <code>GUIX</code>, you can simply install <code>guile-swayer</code> from the <code>GUIX</code> repository (thanks to @wrest64 [Alec Barreto]). If you are using another distro, you will have to ensure <code>GUILE_LOAD_PATH</code> points to correct path and execute the below commands to install <code>guile-swayer</code></p>
<div dir="auto" data-snippet-clipboard-copy-content="autoreconf -i
./configure
make
sudo make install"><pre>autoreconf -i
./configure
make
sudo make install</pre></div>


<p dir="auto">You can retrieve information about <code>Sway</code>, such as list of available <code>workspaces</code> or <code>outputs</code>. The response will be in Guile records, which you can easily manipulate! (refer to <code>swayipc/info.scm</code>)</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; get focused workspace from a list of workspaces
(define (focused-workspace-name workspaces)
  (cond
    ((null? workspaces) #f)
    ((equal? #t (sway-workspace-focused (car workspaces)))
     (sway-workspace-name (car workspaces)))
    (else (focused-workspace-name (cdr workspaces)))))

(format #t &#34;output record from function #sway-get-workspaces:\n ~a\n&#34;
        (sway-get-workspaces))

(format #t &#34;current focused workspace is [~a]\n&#34;
        (focused-workspace-name (sway-get-workspaces)))"><pre><span><span>;</span>; get focused workspace from a list of workspaces</span>
(<span>define</span> (<span>focused-workspace-name</span><span> workspaces</span>)
  (<span>cond</span>
    ((<span>null?</span> workspaces) <span>#f</span>)
    ((<span>equal?</span> <span>#t</span> (sway-workspace-focused (<span>car</span> workspaces)))
     (sway-workspace-name (<span>car</span> workspaces)))
    (<span>else</span> (focused-workspace-name (<span>cdr</span> workspaces)))))

(format <span>#t</span> <span><span>&#34;</span>output record from function #sway-get-workspaces:<span>\n</span> ~a<span>\n</span><span>&#34;</span></span>
        (sway-get-workspaces))

(format <span>#t</span> <span><span>&#34;</span>current focused workspace is [~a]<span>\n</span><span>&#34;</span></span>
        (focused-workspace-name (sway-get-workspaces)))</pre></div>
<p dir="auto">Note: To send commands to Sway, you must connect to the Sway sockets. Without connecting to the socket your commands won’t be sent to Sway. use the function <code>(sway-connect-socktes!)</code> immediately after the imports in your <code>init.scm</code> to ensure that the rest of the expressions can successfully send commands to Sway.</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; connect to sway sockets
(sway-connect-sockets!)"><pre><span><span>;</span>; connect to sway sockets</span>
(sway-connect-sockets!)</pre></div>

<p dir="auto">You can assign keybindings that execute Guile code! Obviously, running shell commands is straightforward since you’re operating within Guile. Additionally, you have full access to Sway/i3 specific commands (refer to <code>swayipc/dispatcher.scm</code>).</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; normal sway keybindings (limited and can&#39;t easily execute guile code)
(sway-bindsym &#34;Mod4+t&#34; &#34;exec alacritty&#34;)

;; general.scm interface for sway keybindings
;; this uses sway-bindsym behind the scenes, but provides a much
;; user friendly interface to create complex keybindings structure
;; it also allows you to execute guile expressions on trigger.
;; refer to modules/general.scm for more about how this is done.

;; define leader keymap
(define (exec command)
  &#34;execute given shell command&#34;
  (format #t &#34;running: ~a\n&#34; command)
  (system command))

(general-define-keys
 #:prefix &#34;s-Space&#34; #:wk &#34;Leader&#34;
 `(&#34;o&#34; (exec &#34;rofi -show drun&#34;))
 `(&#34;C-g&#34; (sway-mode &#34;default&#34;) #:wk &#34;abort&#34;)

 ;; rofi keymap
 `(general-define-keys
   #:prefix &#34;r&#34; #:wk &#34;Rofi&#34;
   (&#34;p&#34; (exec &#34;~/.config/rofi/bin/password-manager&#34;))
   (&#34;m&#34; (exec &#34;rofi-mount&#34;))
   (&#34;u&#34; (exec &#34;rofi-unmount&#34;))
   (&#34;w&#34; (exec &#34;.config/rofi/bin/wifi&#34;))
   (&#34;b&#34; (exec &#34;~/.config/rofi/bin/bluetooth&#34;))
   (&#34;f&#34; (exec &#34;~/.config/rofi/bin/finder&#34;))
   (&#34;k&#34; (exec &#34;~/.config/rofi/bin/keyboard-layout&#34;))
   (&#34;P&#34; (exec &#34;~/.config/rofi/bin/powermenu&#34;))
   (&#34;s&#34; (exec &#34;~/.config/rofi/bin/sound-input&#34;))
   (&#34;S&#34; (exec &#34;~/.config/rofi/bin/sound-output&#34;)))

 ;; window management
 `(general-define-keys
   #:prefix &#34;w&#34; #:wk &#34;Window&#34;
   (&#34;v&#34; (sway-layout SWAY-LAYOUT-SPLITV))
   (&#34;h&#34; (sway-layout SWAY-LAYOUT-SPLITH))
   (&#34;f&#34; (sway-fullscreen SWAY-FULLSCREEN-TOGGLE))
   (&#34;d&#34; (sway-layout SWAY-LAYOUT-DEFAULT))
   (&#34;t&#34; (sway-layout SWAY-LAYOUT-TABBED))))"><pre><span><span>;</span>; normal sway keybindings (limited and can&#39;t easily execute guile code)</span>
(sway-bindsym <span><span>&#34;</span>Mod4+t<span>&#34;</span></span> <span><span>&#34;</span>exec alacritty<span>&#34;</span></span>)

<span><span>;</span>; general.scm interface for sway keybindings</span>
<span><span>;</span>; this uses sway-bindsym behind the scenes, but provides a much</span>
<span><span>;</span>; user friendly interface to create complex keybindings structure</span>
<span><span>;</span>; it also allows you to execute guile expressions on trigger.</span>
<span><span>;</span>; refer to modules/general.scm for more about how this is done.</span>

<span><span>;</span>; define leader keymap</span>
(<span>define</span> (<span>exec</span><span> command</span>)
  &#34;execute given shell command&#34;
  (format <span>#t</span> <span><span>&#34;</span>running: ~a<span>\n</span><span>&#34;</span></span> command)
  (system command))

(general-define-keys
 #:prefix <span><span>&#34;</span>s-Space<span>&#34;</span></span> #:wk <span><span>&#34;</span>Leader<span>&#34;</span></span>
 `(<span><span>&#34;</span>o<span>&#34;</span></span> (exec <span><span>&#34;</span>rofi -show drun<span>&#34;</span></span>))
 `(<span><span>&#34;</span>C-g<span>&#34;</span></span> (sway-mode <span><span>&#34;</span>default<span>&#34;</span></span>) #:wk <span><span>&#34;</span>abort<span>&#34;</span></span>)

 <span><span>;</span>; rofi keymap</span>
 `(general-define-keys
   #:prefix <span><span>&#34;</span>r<span>&#34;</span></span> #:wk <span><span>&#34;</span>Rofi<span>&#34;</span></span>
   (<span><span>&#34;</span>p<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/password-manager<span>&#34;</span></span>))
   (<span><span>&#34;</span>m<span>&#34;</span></span> (exec <span><span>&#34;</span>rofi-mount<span>&#34;</span></span>))
   (<span><span>&#34;</span>u<span>&#34;</span></span> (exec <span><span>&#34;</span>rofi-unmount<span>&#34;</span></span>))
   (<span><span>&#34;</span>w<span>&#34;</span></span> (exec <span><span>&#34;</span>.config/rofi/bin/wifi<span>&#34;</span></span>))
   (<span><span>&#34;</span>b<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/bluetooth<span>&#34;</span></span>))
   (<span><span>&#34;</span>f<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/finder<span>&#34;</span></span>))
   (<span><span>&#34;</span>k<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/keyboard-layout<span>&#34;</span></span>))
   (<span><span>&#34;</span>P<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/powermenu<span>&#34;</span></span>))
   (<span><span>&#34;</span>s<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/sound-input<span>&#34;</span></span>))
   (<span><span>&#34;</span>S<span>&#34;</span></span> (exec <span><span>&#34;</span>~/.config/rofi/bin/sound-output<span>&#34;</span></span>)))

 <span><span>;</span>; window management</span>
 `(general-define-keys
   #:prefix <span><span>&#34;</span>w<span>&#34;</span></span> #:wk <span><span>&#34;</span>Window<span>&#34;</span></span>
   (<span><span>&#34;</span>v<span>&#34;</span></span> (sway-layout SWAY-LAYOUT-SPLITV))
   (<span><span>&#34;</span>h<span>&#34;</span></span> (sway-layout SWAY-LAYOUT-SPLITH))
   (<span><span>&#34;</span>f<span>&#34;</span></span> (sway-fullscreen SWAY-FULLSCREEN-TOGGLE))
   (<span><span>&#34;</span>d<span>&#34;</span></span> (sway-layout SWAY-LAYOUT-DEFAULT))
   (<span><span>&#34;</span>t<span>&#34;</span></span> (sway-layout SWAY-LAYOUT-TABBED))))</pre></div>

<p dir="auto">Certain scenarios necessitate subscribing to events. One example from my <code>workflow</code> described below requires this capability. With <code>guile-swayer</code>, you have the ability to listen for events and execute actions in response.</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; subscribe to events
(define (workspace-changed workspace-event)
  (let* ((current-tree (sway-workspace-event-current workspace-event))
         (workspace (sway-tree-name current-tree)))

    (format #t &#34;workspace changed to ~a!\n&#34; workspace)))

(add-hook! sway-workspace-hook workspace-changed)"><pre><span><span>;</span>; subscribe to events</span>
(<span>define</span> (<span>workspace-changed</span><span> workspace-event</span>)
  (<span>let*</span> ((current-tree (sway-workspace-event-current workspace-event))
         (workspace (sway-tree-name current-tree)))

    (format <span>#t</span> <span><span>&#34;</span>workspace changed to ~a!<span>\n</span><span>&#34;</span></span> workspace)))

(add-hook! sway-workspace-hook workspace-changed)</pre></div>
<p dir="auto">Note: To receive any events, you must subscribe to them. You can subscribe to individual events that interest you or to all available events. Without subscribing and running the event listener in your <code>init.scm</code>, your hooks will not receive any events.</p>
<p dir="auto">The event listener thread is a Unix socket that waits for sway events. This must be executed, preferably as the last expression in your <code>init.scm</code> file, because <code>thread-join</code> will block execution. This blocking is necessary to keep the listener active and prevent the script from exiting.</p>
<div dir="auto" data-snippet-clipboard-copy-content=";; subscribe to all events
(sway-subscribe-all)

(sway-start-event-listener-thread)
(thread-join! SWAY-LISTENER-THREAD)"><pre><span><span>;</span>; subscribe to all events</span>
(sway-subscribe-all)

(sway-start-event-listener-thread)
(thread-join! SWAY-LISTENER-THREAD)</pre></div>

<p dir="auto">Refer to the wiki for more information.
  Most of the source code is documented. You can refer to <code>examples/stumpwm-like/init.scm</code> for a complex stumpwm like configuration example. Here are some important points to consider before hacking your Sway setup</p>

<p dir="auto">Clone this repository to your <code>~/.config/sway</code>
  It’s important to know where you clone the repo as you will have to reference it later by path to make a perfect setup.</p>


<markdown-accessiblity-table><table>
  <tbody><tr><th>File</th><th>Description</th></tr>
  <tr><td>examples</td><td>Examples of configurations the you can refer to for inspiration</td></tr>
  <tr><td>modules</td><td>Directory containing modules for extending Sway using <code>guile-swayer</code>.</td></tr>
  <tr><td>sjson</td><td>A patched version of <code>guile-json</code> (temporarily).</td></tr>
  <tr><td>swayipc</td><td>Directory containing the core code for <code>swayipc</code>.</td></tr>
  <tr><td>README.org</td><td>This readme file</td></tr>
</tbody></table></markdown-accessiblity-table>

<markdown-accessiblity-table><table>
  <tbody><tr><th>File</th><th>Description</th></tr>
  <tr><td>libs</td><td>Helpful libraries to help <code>modules</code> perform command sway <code>tasks</code></td></tr>
  <tr><td>modules</td><td>Directory containing modules for extending Sway using <code>guile-swayer</code>.</td></tr>
  <tr><td>sjson</td><td>A patched version of <code>guile-json</code> (temporarily).</td></tr>
  <tr><td>swayipc</td><td>Directory containing the core code for <code>swayipc</code>.</td></tr>
</tbody></table></markdown-accessiblity-table>
<div dir="auto"><h4 tabindex="-1" dir="auto">guile-swayer/swayipc Directory</h4><a id="user-content-guile-swayerswayipc-directory" aria-label="Permalink: guile-swayer/swayipc Directory" href="#guile-swayerswayipc-directory"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
  <tbody><tr><th>File</th><th>Description</th></tr>
  <tr><td>connection</td><td>Establishes <code>IPC</code> connection for handling events and commands with Sway.</td></tr>
  <tr><td>dispatcher</td><td>Provides <code>Guile functions</code> for all available <code>Sway</code> commands.</td></tr>
  <tr><td>events</td><td>Provides <code>Gulie Hooks</code> for all available <code>Sway</code> events.</td></tr>
  <tr><td>info</td><td>Provides <code>Guile functions</code> for querying Sway’s current state and information.</td></tr>
  <tr><td>records</td><td>Provides <code>Guile records</code> representing Sway’s data structures.</td></tr>
</tbody></table></markdown-accessiblity-table>
<div dir="auto"><h4 tabindex="-1" dir="auto">guile-swayer/modules Directory</h4><a id="user-content-guile-swayermodules-directory" aria-label="Permalink: guile-swayer/modules Directory" href="#guile-swayermodules-directory"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<markdown-accessiblity-table><table>
  <tbody><tr><th>File</th><th>Description</th></tr>
  <tr><td>auto-reload.scm</td><td>Watcher to automatically reload Sway when Guile files change.</td></tr>
  <tr><td>general.scm</td><td>Inspired by Emacs <code>general</code> package; provides an easy interface for keybindings.</td></tr>
  <tr><td>kbd.scm</td><td>Translates Emacs-like keybindings to be compatible with <code>Sway</code>.</td></tr>
  <tr><td>which-key.scm</td><td>Inspired by Emacs <code>which-key</code> package; enhances keybinding discovery.</td></tr>
  <tr><td>workspace-grid.scm</td><td>Configures workspaces in a grid (see workflow below).</td></tr>
  <tr><td>workspace-groups.scm</td><td>Spans/synchronizes workspaces across monitors (see workflow below).</td></tr>
</tbody></table></markdown-accessiblity-table>
<p dir="auto">1- You can start your <code>guile-swayer</code> configurations from the <code>REPL</code>, <code>terminal</code>, or a <code>configuration file</code>.
  Remember: for debugging or displaying output, it’s best to run Guile from the <code>REPL</code> or <code>terminal</code>. You can also pipe the output to a file if you desire.</p>
<pre lang="conf"># good idea to kill all current guile guile-swayer instances first
exec_always &#34;pkill -f &#39;.*guile.*sway/init.scm&#39;&#34;

# then run a fresh instance, sleeping ensures a more reilable execution
exec_always &#34;sleep 0.5 &amp;&amp; ~/.config/sway/init.scm&#34;
</pre>
<p dir="auto">2- I plan to publish a module for <code>guile-swayer</code>, it’s currently not hosted anywhere. You’ll need to add the module to your <code>load path</code>. Additionally, <code>guile-swayer</code> includes another patched Guile library called <code>guile-json</code>, which is embedded for now. In the future, this will be included as a separate dependency rather than embedded.</p>
<div dir="auto" data-snippet-clipboard-copy-content="(add-to-load-path
 (dirname (or (current-filename)
              (string-append (getenv &#34;HOME&#34;) &#34;/.config/sway/init.scm&#34;))))"><pre>(add-to-load-path
 (dirname (<span>or</span> (current-filename)
              (string-append (getenv <span><span>&#34;</span>HOME<span>&#34;</span></span>) <span><span>&#34;</span>/.config/sway/init.scm<span>&#34;</span></span>))))</pre></div>


<p dir="auto">I arrange my workspaces in a grid format. Typically, workspaces are laid out horizontally. With nine workspaces, navigating from workspace 1 to 9 using only horizontal directions can be cumbersome. Assigning a key to each workspace would be efficient but would clutter default mode keybindings. Some might create another mode or submap, but pressing multiple keys to move between workspaces becomes inefficient . I find the optimal solution is organizing workspaces in a grid format, enabling both horizontal and vertical navigation. Currently, I use a 3x3 grid with wraparound navigation.</p>
<p dir="auto">Horizontal vs Grid 9 workspaces</p>
<p dir="auto">Horizontal</p>
<pre>1 2 3 4 5 6 7 8 9
</pre>
<p dir="auto">Grid (3x3)</p>
<pre>1 2 3
4 5 6
7 8 9
</pre>
<p dir="auto">Example navigation in a grid (<code>cs#idx</code> is current workspace):</p>
<pre>cs#1&gt; go right
cs#2&gt; go down
cs#5&gt; go down
cs#8&gt; go down (notice wraparound behavior)
cs#2&gt; go right
cs#3&gt; ..
</pre>
<p dir="auto">Note: this behavior is achieved  via <code>modules/workspace-grid.scm</code></p>

<p dir="auto">My workspaces function as groups or tasks that span across all three monitors in my setup. For example, if I switch to my <code>communication</code> workspace on one monitor, I want all monitors to switch to their respective <code>communication</code> workspaces. This means if I have WhatsApp on monitor #1, Discord on monitor #2, and IRC on monitor #3, they should all align to their designated communication workspace when I switch tasks.</p>
<p dir="auto">Similarly, this setup extends to projects I work on. If I focus on my dotfiles, I want all monitors to switch to the workspace dedicated to that task. The same principle applies to game development or any other specific task or project workspace I engage with.</p>
<p dir="auto">Normal workspaces</p>
<pre>| ws#1 | ws#2 | ws#3 | ws#4 | ws#5 | ws#6 |
</pre>
<p dir="auto">Grouped workspaces (3 monitors)</p>
<pre>|           ws#1           |           ws#2           |
|-----------------------------------------------------|
| ws#1-1 &amp; ws#1-2 &amp; ws#1-3 | ws#2-1 &amp; ws#2-2 &amp; ws#2-3 |
</pre>
<p dir="auto">Example of navigation into a workspace (same behavior regardless of the method used to switch workspaces):</p>
<pre>ws#1&gt; go to ws#2-1
ws#2&gt; go to ws#2-2 (same group, no switching)
ws#2&gt; go to ws#1-3
ws#1&gt; ..
</pre>
<p dir="auto">You can partially configure workspace groups to span or sync only some workspaces. This allows you to have workspaces that do not span and others that do, with the ability to pin specific workspaces to their monitors when focused.</p>
<p dir="auto">Note: this behavior is achieved  via <code>modules/workspace-groups.scm</code></p>


<p dir="auto"><code>which-key</code> is a <code>guile-swayer</code> module that displays available key bindings in a pop-up window as you start typing a key sequence. This immediate feedback helps users discover and remember commands, reducing the need for memorization and speeding up the learning process. It improves workflow efficiency by allowing users to quickly access commands without interrupting their tasks. Additionally, <code>which-key</code> is highly customizable, supporting complex keymaps and personalized setups.</p>

<p dir="auto">Submaps are keymaps bound to specific prefix keys, grouping related commands under a common prefix. This logical grouping makes key bindings easier to remember and use while reducing conflicts by isolating namespaces for different command sets. Submaps support a hierarchical structure, which is scalable and modular, allowing users to expand and manage their configurations more effectively.</p>

<p dir="auto">Together, <code>which-key</code> and submaps provide a powerful combination for managing key bindings. <code>which-key</code> enhances the discoverability of commands within submaps, helping users learn complex setups interactively. This combination reduces the memorization burden, streamlines workflows, and ensures an organized and efficient keybinding system in your sway setup.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://github.com/ebeem/guile-swayer/blob/master/preview/which-key.gif"><img src="https://github.com/ebeem/guile-swayer/raw/master/preview/which-key.gif" alt="./preview/which-key.gif" data-animated-image=""/></a></p>

<p dir="auto">Layouts is a crucial feature of any tiling window manager. Sway, as a manual tiling window manager based on a tree structure, offers immense flexibility, theoretically allowing you to represent almost any layout you desire. However, the complexity of managing these layouts remains a challenge. Common layouts can make Sway much more user-friendly if they are easily toggled as needed. The goal of the layout feature in Guile Swayer is to provide these common layouts and make them easily togglable for specific workspaces. This feature is still very experimental and not yet intended for daily use.</p>

<ul dir="auto">
  <li>Alternating Layout</li>
  <li>Emacs Layout</li>
  <li>Xmonad</li>
  <li>Matrix</li>
</ul>
<p dir="auto">Example of alternating layout currently implemented.
  <a target="_blank" rel="noopener noreferrer" href="https://github.com/ebeem/guile-swayer/blob/master/preview/alternating-layout.gif"><img src="https://github.com/ebeem/guile-swayer/raw/master/preview/alternating-layout.gif" alt="./preview/alternating-layout.gif" data-animated-image=""/></a></p>

<p dir="auto">V0.4.2</p>
<ul dir="auto">
  <li>swayipc: improved the <code>sway-output</code> function to accept output properties as parameters rather than a string</li>
  <li>general: fixed issue #8, general doesn’t accept numeric values for keybindings</li>
</ul>
</article></div></div>
  </body>
</html>
