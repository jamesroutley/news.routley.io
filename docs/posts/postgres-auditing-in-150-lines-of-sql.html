<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://supabase.com/blog/2022/03/08/audit">Original</a>
    <h1>Postgres Auditing in 150 lines of SQL</h1>
    
    <div id="readability-page-1" class="page"><article><div><div><p>Data auditing is a system that tracks changes to tables&#39; contents over time.
PostgreSQL has a robust set of features which we can leverage to create a generic auditing solution in 150 lines of SQL.</p><p>Auditing is particularly useful for historical analysis. To demonstrate, imagine you have a <code>users</code> table that tracks when a user is online.
You might add a <code>status</code> column which can have one of two values: <code>online</code> and <code>offline</code>. How would you track how long a user is online for throughout an entire month?
An auditing system would track every change with timestamps, and so you can measure the difference between each timestamp and sum them up for the entire month.</p><p>The goals of our auditing solution are: </p><ul><li>low maintenance</li><li>easy to use</li><li>fast to query</li></ul><p>To demonstrate what we&#39;re working towards, the following example shows what we&#39;ll have at the end of the blog post:</p><pre><div><pre><code><span>-- create a table</span><span>
</span><span></span><span>create</span><span> </span><span>table</span><span> public.members(
</span><span>    id </span><span>int</span><span> </span><span>primary</span><span> key,
</span><span>    name text </span><span>not</span><span> </span><span>null</span><span>
</span>);

<span></span><span>-- Enable auditing on the new table</span><span>
</span><span></span><span>select</span><span> audit.enable_tracking(</span><span>&#39;public.members&#39;</span><span>);
</span>
</code></pre></div></pre><p>Produce some records to audit</p><pre><div><pre><code><span>-- create a new record</span><span>
</span><span></span><span>insert</span><span> </span><span>into</span><span> public.members(id, name) </span><span>values</span><span> (</span><span>1</span><span>, </span><span>&#39;foo&#39;</span><span>);
</span>
<span></span><span>-- edit the record</span><span>
</span><span>update public.members </span><span>set</span><span> name </span><span>=</span><span> </span><span>&#39;bar&#39;</span><span> </span><span>where</span><span> id </span><span>=</span><span> </span><span>1</span><span>;
</span>
<span></span><span>-- delete the record</span><span>
</span><span></span><span>delete</span><span> </span><span>from</span><span> public.members;
</span>
</code></pre></div></pre><p>Review the audit log</p><pre><div><pre><code><span>select</span><span> </span><span>*</span><span> </span><span>from</span><span> audit.record_history
</span>
</code></pre></div></pre><pre><div><pre><code><span> id |              record</span><span>_id               |            old_</span><span>record</span><span>_id             |   op   |                 ts                  | table_</span><span>oid | table</span><span>_schema | table_</span><span>name |          record          |        old</span><span>_record        
</span><span>----+--------------------------------------+--------------------------------------+--------+-------------------------------------+-----------+--------------+------------+--------------------------+--------------------------
</span><span>  2 | 1ecd5ff0-1b6b-5bc2-ad80-1cb19769c081 |                                      | INSERT | Mon Feb 28 18:13:52.698511 2022 PST |     16452 | public       | members    | {&#34;id&#34;: 1, &#34;name&#34;: &#34;foo&#34;} | 
</span><span>  3 | 1ecd5ff0-1b6b-5bc2-ad80-1cb19769c081 | 1ecd5ff0-1b6b-5bc2-ad80-1cb19769c081 | UPDATE | Mon Feb 28 18:13:52.698511 2022 PST |     16452 | public       | members    | {&#34;id&#34;: 1, &#34;name&#34;: &#34;bar&#34;} | {&#34;id&#34;: 1, &#34;name&#34;: &#34;foo&#34;}
</span><span>  4 |                                      | 1ecd5ff0-1b6b-5bc2-ad80-1cb19769c081 | DELETE | Mon Feb 28 18:13:52.698511 2022 PST |     16452 | public       | members    |                          | {&#34;id&#34;: 1, &#34;name&#34;: &#34;bar&#34;}
</span><span>(3 rows)
</span><span>
</span></code></pre></div></pre><p>Notice that our <code>record_id</code> and <code>old_record_id</code> stayed constant as we updated the row so we can easily query for a single row&#39;s history over time!</p><h2 id="lets-get-building">Lets get building</h2><h3 id="namespace">Namespace</h3><p>To quote a tenet from <a href="https://www.python.org/dev/peps/pep-0020/">the zen of python</a>: </p><blockquote><p>Namespaces are one honking great idea -- let&#39;s do more of those!</p></blockquote><p>So first things first, we&#39;ll create a separate schema named <code>audit</code> to house our auditing entities.</p><pre><div><pre><code><span>create</span><span> schema if </span><span>not</span><span> </span><span>exists</span><span> audit;
</span>
</code></pre></div></pre><h3 id="storage">Storage</h3><p>Next, we need a table to track inserts, updates and deletes.</p><p>Classically, an audit table&#39;s schema mirrors the table being audited and appends some metadata columns like the commit&#39;s timestamp. That solution has a few maintenance challenges: </p><ul><li>enabling auditing on a table requires a database migration</li><li>when the source table&#39;s schema changes, the audit table&#39;s schema must also change</li></ul><p>So instead, we&#39;ll lean on PostgreSQL&#39;s schema-less <a href="https://www.postgresql.org/docs/current/datatype-json.html"><code>JSONB</code> data type</a> to store each record&#39;s data in a single column.
That approach has the added benefit of allowing us to store multiple tables&#39; audit history in a single audit table.</p><pre><div><pre><code><span>create</span><span> </span><span>table</span><span> audit.record_version(
</span><span>  id             bigserial </span><span>primary</span><span> key,
</span><span>  </span><span>-- auditing metadata</span><span>
</span><span>  record_id      uuid, </span><span>-- identifies a new record by it&#39;s table + primary key</span><span>
</span><span>  old_record_id  uuid, </span><span>-- ^</span><span>
</span><span>  op             </span><span>varchar</span><span>(</span><span>8</span><span>) </span><span>not</span><span> </span><span>null</span><span>, </span><span>-- INSERT/UPDATE/DELETE/TRUNCATE</span><span>
</span><span>  ts             timestamptz </span><span>not</span><span> </span><span>null</span><span> </span><span>default</span><span> now(),
</span><span>  </span><span>-- table identifiers</span><span>
</span><span>  table_oid      oid </span><span>not</span><span> </span><span>null</span><span>,  </span><span>-- pg internal id for a table</span><span>
</span><span>  table_schema   name </span><span>not</span><span> </span><span>null</span><span>, </span><span>-- audited table&#39;s schema name e.g. &#39;public&#39;</span><span>
</span><span>  table_name     name </span><span>not</span><span> </span><span>null</span><span>, </span><span>-- audited table&#39;s table name e.g. &#39;account&#39;</span><span>
</span><span>  </span><span>-- record data</span><span>
</span><span>  record         jsonb, </span><span>-- contents of the new record   </span><span>
</span><span>  old_record     jsonb  </span><span>-- previous record contents (for UPDATE/DELETE)</span><span>
</span>);

</code></pre></div></pre><details><summary>Postgres version compatibility</summary><p>The table above uses PostgreSQL&#39;s built-in <a href="https://www.postgresql.org/docs/14/functions-uuid.html">uuid functionality</a>, which is available from version 14. For backwards compatibility you can use the uuid-ossp extension.</p><div><pre><code><span>create extension </span><span>if</span><span> not exists </span><span>&#34;uuid-ossp&#34;</span><span>;</span></code></pre></div></details><h3 id="query-patterns">Query Patterns</h3><p>An audit log doesn&#39;t do us much good if its too slow to query! There are 2 query patterns we think are table stakes (ðŸ˜‰) for an audit system:</p><p><strong>Changes to a Table in a Time Range</strong></p><p>For time slices, we need an index on the <code>ts</code> column. Since the table is append-only and the <code>ts</code> column is populated by insertion date, our values for <code>ts</code> are naturally in ascending order. </p><p>PostgreSQL&#39;s builtin <a href="https://www.postgresql.org/docs/current/brin-intro.html">BRIN index</a> can leverage that correlation between value and physical location to produce an index that, at scale, is many hundreds of times smaller than the default (BTREE index) with faster lookup times.</p><pre><div><pre><code><span>-- index ts for time range filtering</span><span>
</span><span></span><span>create</span><span> index record_version_ts
</span><span>  </span><span>on</span><span> audit.record_version
</span><span>  </span><span>using</span><span> brin(ts);
</span>
</code></pre></div></pre><p>For table filtering, we&#39;ve included a <code>table_oid</code> column which tracks PostgreSQL&#39;s internal numeric table identifier. We can add an index to this column instead of the <code>table_schema</code> and <code>table_name</code> columns, minimizing the index size and offering better performance.</p><pre><div><pre><code><span>-- index table_oid for table filtering</span><span>
</span><span></span><span>create</span><span> index record_version_table_oid
</span><span>  </span><span>on</span><span> audit.record_version
</span><span>  </span><span>using</span><span> btree(table_oid);
</span>
</code></pre></div></pre><p><strong>Changes to a Record Over Time</strong></p><p>One of the downsides to storing each row&#39;s data as <code>jsonb</code> is that filtering based on a column&#39;s value becomes very inefficient. If we want to look up a row&#39;s history quickly, we need to extract and index a unique identifier for each row.</p><p>For the globally unique identifier, we&#39;ll use the following structure</p><pre><div><pre><code><span>[table_oid, primary_key_value_1, primary_key_value_2, ...]
</span>
</code></pre></div></pre><p>and hash that array as a UUID v5 to get an efficiently indexable UUID type to identify the row that is robust to data changes.</p><p>We&#39;ll use one utility function to lookup a record&#39;s primary key column names:</p><pre><div><pre><code><span>create</span><span> </span><span>or</span><span> replace </span><span>function</span><span> audit.primary_key_columns(entity_oid oid)
</span><span>    </span><span>returns</span><span> text[]
</span>    stable
    security definer
<span>    </span><span>language</span><span> </span><span>sql</span><span>
</span><span></span><span>as</span><span> $$
</span><span>    </span><span>-- Looks up the names of a table&#39;s primary key columns</span><span>
</span><span>    </span><span>select</span><span>
</span><span>        </span><span>coalesce</span><span>(
</span><span>            </span><span>array_agg</span><span>(pa.attname::text </span><span>order</span><span> </span><span>by</span><span> pa.attnum),
</span><span>            </span><span>array</span><span>[]::text[]
</span>        ) column_names
<span>    </span><span>from</span><span>
</span>        pg_index pi
<span>        </span><span>join</span><span> pg_attribute pa
</span><span>            </span><span>on</span><span> pi.indrelid </span><span>=</span><span> pa.attrelid
</span><span>            </span><span>and</span><span> pa.attnum </span><span>=</span><span> </span><span>any</span><span>(pi.indkey)
</span><span>    </span><span>where</span><span>
</span><span>        indrelid </span><span>=</span><span> $</span><span>1</span><span>
</span><span>        </span><span>and</span><span> indisprimary
</span>$$;

</code></pre></div></pre><p>and another to consume the <code>table_oid</code> and primary key, converting the result into the record&#39;s UUID.</p><pre><div><pre><code><span>create</span><span> </span><span>or</span><span> replace </span><span>function</span><span> audit.to_record_id(
</span>        entity_oid oid,
        pkey_cols text[],
        rec jsonb
)
<span>    </span><span>returns</span><span> uuid
</span>    stable
<span>    </span><span>language</span><span> </span><span>sql</span><span>
</span><span></span><span>as</span><span> $$
</span><span>    </span><span>select</span><span>
</span><span>        </span><span>case</span><span>
</span><span>            </span><span>when</span><span> rec </span><span>is</span><span> </span><span>null</span><span> </span><span>then</span><span> </span><span>null</span><span>
</span><span>                        </span><span>-- if no primary key exists, use a random uuid</span><span>
</span><span>            </span><span>when</span><span> pkey_cols </span><span>=</span><span> </span><span>array</span><span>[]::text[] </span><span>then</span><span> uuid_generate_v4()
</span><span>            </span><span>else</span><span> (
</span><span>                </span><span>select</span><span>
</span>                    uuid_generate_v5(
<span>                        </span><span>&#39;fd62bc3d-8d6e-43c2-919c-802ba3762271&#39;</span><span>,
</span>                        ( 
<span>                                                    jsonb_build_array(to_jsonb($</span><span>1</span><span>))
</span><span>                                                    </span><span>||</span><span> jsonb_agg($</span><span>3</span><span> </span><span>-</span><span>&gt;&gt;</span><span> key_)
</span>                                                )::text
                    )
<span>                </span><span>from</span><span>
</span><span>                    </span><span>unnest</span><span>($</span><span>2</span><span>) x(key_)
</span>            )
<span>        </span><span>end</span><span>
</span>$$;

</code></pre></div></pre><p>Finally, we index the <code>record_id</code> and <code>old_record_id</code> columns that contain these unique identifiers for fast querying.</p><pre><div><pre><code><span>-- index record_id for fast searching</span><span>
</span><span></span><span>create</span><span> index record_version_record_id
</span><span>    </span><span>on</span><span> audit.record_version(record_id)
</span><span>    </span><span>where</span><span> record_id </span><span>is</span><span> </span><span>not</span><span> </span><span>null</span><span>;
</span>
<span></span><span>-- index old_record_id for fast searching</span><span>
</span><span></span><span>create</span><span> index record_version_old_record_id
</span><span>    </span><span>on</span><span> audit.record_version(record_id)
</span><span>  </span><span>where</span><span> old_record_id </span><span>is</span><span> </span><span>not</span><span> </span><span>null</span><span>;
</span>
</code></pre></div></pre><h3 id="enrollment">Enrollment</h3><p>Okay, so we have a home for our audit data that we&#39;re confident it can be queried efficiently. Now how do we populate it?</p><p>We need the audit table to populate without end-users making any changes to their transactions. So we&#39;ll set up a <a href="https://www.postgresql.org/docs/current/sql-createtrigger.html">trigger</a> to fire when the data changes. In this case, we&#39;ll fire the trigger once for every inserted/updated/deleted row.</p><pre><div><pre><code><span>create</span><span> </span><span>or</span><span> replace </span><span>function</span><span> audit.insert_update_delete_trigger()
</span><span>    </span><span>returns</span><span> </span><span>trigger</span><span>
</span>    security definer
<span>    </span><span>language</span><span> plpgsql
</span><span></span><span>as</span><span> $$
</span><span></span><span>declare</span><span>
</span><span>    pkey_cols text[] </span><span>=</span><span> audit.primary_key_columns(TG_RELID);
</span><span>    record_jsonb jsonb </span><span>=</span><span> to_jsonb(</span><span>new</span><span>);
</span><span>    record_id uuid </span><span>=</span><span> audit.to_record_id(TG_RELID, pkey_cols, record_jsonb);
</span><span>    old_record_jsonb jsonb </span><span>=</span><span> to_jsonb(</span><span>old</span><span>);
</span><span>    old_record_id uuid </span><span>=</span><span> audit.to_record_id(TG_RELID, pkey_cols, old_record_jsonb);
</span><span></span><span>begin</span><span>
</span>
<span>    </span><span>insert</span><span> </span><span>into</span><span> audit.record_version(
</span>        record_id,
        old_record_id,
        op,
        table_oid,
        table_schema,
        table_name,
        record,
        old_record
    )
<span>    </span><span>select</span><span>
</span>        record_id,
        old_record_id,
        TG_OP,
        TG_RELID,
        TG_TABLE_SCHEMA,
        TG_TABLE_NAME,
        record_jsonb,
        old_record_jsonb;

<span>    </span><span>return</span><span> </span><span>coalesce</span><span>(</span><span>new</span><span>, </span><span>old</span><span>);
</span><span></span><span>end</span><span>;
</span>$$;

</code></pre></div></pre><h2 id="public-api">Public API</h2><p>Finally, we&#39;ll wrap up the trigger creation and removal process behind a clean, idempotent, user facing API.</p><p>The API we&#39;ll expose for enabling auditing on a table is</p><pre><div><pre><code><span>select</span><span> audit.enable_tracking(</span><span>&#39;&lt;schema&gt;.&lt;table&gt;&#39;</span><span>::regclass);
</span>
</code></pre></div></pre><p>and for disabling tracking</p><pre><div><pre><code><span>select</span><span> audit.disable_tracking(</span><span>&#39;&lt;schema&gt;.&lt;table&gt;&#39;</span><span>::regclass);
</span>
</code></pre></div></pre><p>Under the hood, those functions register our auditing trigger against the requested table.</p><pre><div><pre><code><span>create</span><span> </span><span>or</span><span> replace </span><span>function</span><span> audit.enable_tracking(regclass)
</span><span>    </span><span>returns</span><span> void
</span>    volatile
    security definer
<span>    </span><span>language</span><span> plpgsql
</span><span></span><span>as</span><span> $$
</span><span></span><span>declare</span><span>
</span><span>    statement_row text </span><span>=</span><span> format(</span><span>&#39;
</span><span>        create trigger audit_i_u_d
</span><span>            before insert or update or delete
</span><span>            on %I
</span><span>            for each row
</span><span>            execute procedure audit.insert_update_delete_trigger();&#39;</span><span>,
</span><span>        $</span><span>1</span><span>
</span>    );

<span>    pkey_cols text[] </span><span>=</span><span> audit.primary_key_columns($</span><span>1</span><span>);
</span><span></span><span>begin</span><span>
</span><span>    if pkey_cols </span><span>=</span><span> </span><span>array</span><span>[]::text[] </span><span>then</span><span>
</span><span>        raise exception </span><span>&#39;Table % can not be audited because it has no primary key&#39;</span><span>, $</span><span>1</span><span>;
</span><span>    </span><span>end</span><span> if;
</span>
<span>    if </span><span>not</span><span> </span><span>exists</span><span>(</span><span>select</span><span> </span><span>1</span><span> </span><span>from</span><span> pg_trigger </span><span>where</span><span> tgrelid </span><span>=</span><span> $</span><span>1</span><span> </span><span>and</span><span> tgname </span><span>=</span><span> </span><span>&#39;audit_i_u_d&#39;</span><span>) </span><span>then</span><span>
</span><span>        </span><span>execute</span><span> statement_row;
</span><span>    </span><span>end</span><span> if;
</span><span></span><span>end</span><span>;
</span>$$;

<span></span><span>create</span><span> </span><span>or</span><span> replace </span><span>function</span><span> audit.disable_tracking(regclass)
</span><span>    </span><span>returns</span><span> void
</span>    volatile
    security definer
<span>    </span><span>language</span><span> plpgsql
</span><span></span><span>as</span><span> $$
</span><span></span><span>declare</span><span>
</span><span>    statement_row text </span><span>=</span><span> format(
</span><span>        </span><span>&#39;drop trigger if exists audit_i_u_d on %I;&#39;</span><span>,
</span><span>        $</span><span>1</span><span>
</span>    );
<span></span><span>begin</span><span>
</span><span>    </span><span>execute</span><span> statement_row;
</span><span></span><span>end</span><span>;
</span>$$;

</code></pre></div></pre><p>And we&#39;re done with 2 lines of code to spare!</p><h3 id="performance">Performance</h3><p>Auditing tables always reduces throughput of inserts, updates, and deletes. In cases where throughput is less than 1000 writes per second the overhead is typically negligible. For tables with a higher write frequency, consider logging changes outside of SQL with a tool like <a href="https://www.pgaudit.org/">pgAudit</a>.</p><h3 id="do-i-really-expect-you-to-copypaste-all-that">Do I really expect you to copy/paste all that?</h3><p>Nope, for a turnkey solution to auditing in PostgreSQL, we&#39;ve packaged this script into an extension with some extra goodies like <code>TRUNCATE</code> support. Check it out at <a href="https://github.com/supabase/supa_audit">https://github.com/supabase/supa_audit</a>.</p></div></div></article></div>
  </body>
</html>
