<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cceckman.com/writing/computer-engineering-resources/">Original</a>
    <h1>Computer Engineering Resources</h1>
    
    <div id="readability-page-1" class="page"><div>


<p>A <a target="_blank" href="https://www.recurse.com/scout/click?t=8238c6d9149cbd0865752e535795d509">Recurser</a>
 <!-- Paul Batchelor --> recently asked
me about my background with computer engineering, and what resources I’d recommend from learning more.</p>
<p>A lot of what I know about computer engineering and computer architecture
comes from my <a href="https://hackread.com/resume/">education and work experience</a>, namely:
an undergraduate degree, plus several years writing software for custom silicon.<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup></p>
<p>Since not everyone can walk that path, here’s some resources!
Some I’ve tried myself; others are what I’d try if I were starting out
today. I have received no compensation from any of the parties/projects mentioned.</p>
<p>Enjoy!</p>
<h2 id="nand2tetris">Getting started: <em>From NAND to Tetris</em></h2>
<p><em><a href="https://www.nand2tetris.org/" target="_blank">https://www.nand2tetris.org/</a></em></p>
<p>This course starts with Boolean logic and builds up to a full
16-bit computer. And then goes further, into compilers and VMs!</p>
<p>This starting point skips over the more “electrical” side of things,
like how to construct logic gates and memories out of transistors.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
But it’s a great place to start if you’re coming from a programming background.</p>
<p>I haven’t gone through this course; I’ve heard good things from
folks who have.</p>
<h2 id="logisim">Playing with logic: Logisim (Evolution)</h2>
<p><em><a href="https://github.com/logisim-evolution/logisim-evolution" target="_blank">https://github.com/logisim-evolution/logisim-evolution</a></em></p>
<p>Logisim provided a visual editor and simulator for digital logic.
Drag-and-drop logic gates and wires, watch them toggle on and off.
I used it during my first digital logic design course to prepare for all the labs.</p>
<p>The original Logisim has been <a href="http://www.cburch.com/logisim/retire-note.html" target="_blank">retired</a>
by the author, but there seems to be an actively-maintained
fork called <a href="https://github.com/logisim-evolution/logisim-evolution" target="_blank">Logisim Evolution</a>.</p>
<p>It looks like the <a href="#nand2tetris">Nand to Tetris</a> course has its own
simulation software, so you may not need Logisim if going down that path.</p>
<h2 id="righto">Historic Hardware: Ken Shirriff’s blog</h2>
<p><em><a href="https://www.righto.com/" target="_blank">https://www.righto.com/</a></em></p>
<p>Ken takes apart integrated circuits,
like an <a href="https://www.righto.com/2024/04/intel-8088-bus-state-machine.html" target="_blank">8088</a> or <a href="https://www.righto.com/2024/07/pentium-standard-cells.html" target="_blank">Pentium</a> processor, and reverse-engineers them.</p>
<p>“Normal” computer engineering involves lowering logic constructs
to netlists, then to gates, then to transistors with a physical layout.
Ken goes the other direction, reasoning from the physical artifact back
into logic blocks.</p>
<p>Ken does a lot of explaining along the way. He covers the
historical context of the IC, the technical basis of how the components
work, and they “why” of doing things one way or another.</p>
<h2 id="textbook-_computer-organization-and-design_">Textbook: <em>Computer Organization and Design</em></h2>
<p><em>ISBN 978-0128203316</em><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup></p>
<p><em>Computer Organization and Design</em> by Patterson and Hennessey
is a very common college textbook; I’d say it’s good for a second or
third course in computer architecture (i.e. after <a href="#nand2tetris">nand2tetris</a>).</p>
<p>I held on to my copy after university.
I think it does a good job of giving real examples,
and talking about the engineering tradeoffs of different choices.</p>
<p>As of 2024, I’d recommend one of the “<a href="#risc-v">RISC-V</a> editions” (2017 or later) – see the next heading.</p>
<h2 id="risc-v">Open Standard: RISC-V</h2>
<p><em><a href="https://riscv.org/" target="_blank">https://riscv.org/</a></em></p>
<p>Recent editions of <a href="#textbook">CO&amp;D</a> are based around RISC-V,
an <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture" target="_blank">instruction set architecture</a> that is</p>
<ol>
<li>freely licensed, and</li>
<li>designed for use in teaching computer architecture.<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup></li>
</ol>
<p>The first volume of the <a href="https://riscv.org/technical/specifications/" target="_blank">specification</a> is littered with comments
about the engineering implications of different choices;
I find it a very interesting read.</p>
<p>Since RISC-V is freely licensed, there’s a bunch of
implementations that you can read, <a href="#fpgas">use</a>, and learn from.
“Implement a RISC-V CPU” is a common project, too, once you have some background
(and a little ambition!)</p>
<h2 id="getting-real">Getting real</h2>
<p>One of the fun things about computer engineering is that you can make a
project tangible – after all is done, you can <em>touch</em> it. <sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p>
<p>You should always start by testing a design with simulation. After that…</p>
<h3 id="breadboard">Components and breadboards</h3>
<p>For simple designs, you can get a <a href="https://learn.sparkfun.com/tutorials/how-to-use-a-breadboard/all" target="_blank">breadboard</a>, some <a href="https://en.wikipedia.org/wiki/7400-series_integrated_circuits" target="_blank">7400-series chips</a>,
and miscellaneous switches and LEDs – and see everything work!</p>
<p>This is exactly what I did in my first computer engineering labs,
after simulating the solution in <a href="#logisim">Logisim</a>. It’s very satisfying!</p>
<p>It’s not easy to scale up to larger designs, though. And if you design
is dynamic (has a clock), you might need an oscilloscope to debug it.</p>
<h3 id="fpgas">Field-programmable gate arrays (FPGAs)</h3>
<p><a href="https://en.wikipedia.org/wiki/Field-programmable_gate_array" target="_blank">FPGAs</a> are reprogrammable hardware, which can host more complicated designs.</p>
<p>In the last 5-10 years, there’s been some nice trends in
making FPGAs accessible to hobbyists and unaffiliated students:</p>
<ul>
<li>
<p>Some generous folks have built open-source toolchains
for using FPGAs.<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>
I haven’t played much with these tools, but this <a href="https://github.com/YosysHQ/oss-cad-suite-build" target="_blank">index from Yosys</a> looks
like a good starting point.</p>
</li>
<li>
<p>You can buy development platforms at reasonable prices.
<a href="https://tomu.im/fomu.html" target="_blank">Fomu</a> is a neat little object: an FPGA that sits in your USB port.
For a more complete platform, I’ve heard good things about <a href="https://www.crowdsupply.com/radiona/ulx3s" target="_blank">ULX3S</a>.</p>
</li>
<li>
<p>At least in the hobby universe, there now are <a href="https://en.wikipedia.org/wiki/Hardware_description_language" target="_blank">hardware description languages</a>
that are easier to understand than the incumbents (Verilog and VHDL).<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup></p>
<p>I see <a href="https://github.com/B-Lang-org/bsc" target="_blank">Bluespec</a>, <a href="https://github.com/m-labs/migen" target="_blank">Migen</a>, and <a href="https://github.com/amaranth-lang/amaranth" target="_blank">Amaranth</a> discussed. I don’t have
experience with any of them, but it’s probably worth trying one or more
before diving into Verilog/VHDL.</p>
</li>
</ul>
<h3 id="tiny-tapeout">Tiny Tapeout</h3>
<p><em><a href="https://tinytapeout.com/" target="_blank">https://tinytapeout.com/</a></em></p>
<p>Creating an integrated circuit is a pretty complicated process – expensive if you go to the experts.<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup></p>
<p>Tiny <a href="https://en.wikipedia.org/wiki/Tape-out" target="_blank">Tapeout</a> looks like a neat project. By putting many small projects into a single
integrated circuit, they can amortize the per-IC costs, putting custom silicon
into the “reachable for classrooms” price category.<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup></p>
<p>Their site also has articles on digital design, silicon manufacturing, and related topics.
I haven’t reviewed those articles, or used the service,
so consider this heading “something Charles is curious about” rather than a recommendation.</p>
<h2 id="callout">Your advice?</h2>
<p>I’d love to hear from you:</p>
<ul>
<li>If you used one of these resources and it was / wasn’t helpful, or</li>
<li>If there’s a resource you found helpful that I didn’t mention!</li>
</ul>
<p>You can reach me by:</p>


<!--
# My background

## Education
- CpE at UVA: https://engineering.virginia.edu/offices-programs/computer-engineering-program
- Joint program between EE and CS departments. CpE had some required courses with CS, some required courses with EE, and some courses that were required for CpE but electives in the other programs.
- CpE could take electives from EE or CS departments. I mostly took CS courses, which is why I wound up as a programmer rather than chip designer.
- But did do "design a processor" third year, and put it on an FPGA.

## Work

- ~4.5 years on ASIC SW; worked closely with the hardware team. Lots of design discussions and back-and-forth.
    - "If we build it like X, what will the impact be to software?"
    - "Runtime needs a feature like Y, what parts of the hardware need to change for that to work?"
    - "We're rearchitecting this part of the software; can you give us hardware XYZ? No? Then how about PDQ? Great!"
- In that time, a lot of asking "why", "how". e.g.: understanding the topology of on-chip network X helped me understand where certain bugs might show up.
-->


</div></div>
  </body>
</html>
