<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.peterzhu.ca/ruby-c-ext-part-10/">Original</a>
    <h1>A Rubyist&#39;s Walk Along the C-Side (Part 10): Benchmarking</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content"> <article itemscope="" itemtype="https://schema.org/BlogPosting">  <div itemprop="articleBody"> <blockquote> <p>This is an article in a multi-part series called <a href="https://blog.peterzhu.ca/ruby-c-ext">“A Rubyist’s Walk Along the C-side”</a></p> </blockquote> <p>In the <a href="https://blog.peterzhu.ca/ruby-c-ext-part-9">previous article</a>, you implemented a circular buffer in two different ways as C extensions. In this article, we’ll benchmark the three implementations (pure Ruby vs. instance variables in C vs. TypedData objects) to compare how the implementation affects performance!</p>  <p>There are many different tools that can be used to benchmark Ruby code. I’ll be introducing two: the <code>Benchmark</code> module and <code>benchmark-ips</code>.</p> <h2 id="rubys-benchmark-module"> Ruby’s <code>Benchmark</code> module <a href="#rubys-benchmark-module"></a> </h2> <p>The <a href="https://docs.ruby-lang.org/en/master/Benchmark.html"><code>Benchmark</code> module</a> built into Ruby provides a way to time a block of code. You can look at the documentation to learn about the various features it provides. We’ll look at the <code>Benchmark.measure</code> method to measure a single block of code.</p> <p>Let’s see an example of code that calculates the Fibonacci sequence:</p> <div><div><pre><code><span>require</span> <span>&#34;benchmark&#34;</span>

<span>puts</span><span>(</span><span>Benchmark</span><span>.</span><span>measure</span> <span>do</span>
  <span>fib_hash</span> <span>=</span> <span>{</span> <span>0</span> <span>=&gt;</span> <span>0</span><span>,</span> <span>1</span> <span>=&gt;</span> <span>1</span> <span>}</span>
  <span>fib_hash</span><span>.</span><span>default_proc</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>h</span><span>,</span> <span>k</span><span>|</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>2</span><span>]</span> <span>+</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>1</span><span>]</span> <span>}</span>

  <span>puts</span> <span>&#34;F(30) = </span><span>#{</span><span>fib_hash</span><span>[</span><span>30</span><span>]</span><span>}</span><span>&#34;</span>
<span>end</span><span>)</span>
</code></pre></div></div> <p>Let’s run this code and see the output:</p> <div><div><pre><code>F(30) = 832040
  0.094039   0.000224   0.094263 (  0.094286)
</code></pre></div></div> <p>We see that the 31st Fibonacci number is <code>832040</code>. It’s followed by four numbers on the next line, which is the output from <code>Benchmark</code>, which each are (from left to right):</p> <ol> <li><strong>User CPU time</strong>: time spent inside of the Ruby process. You can think of this as the time spent running the code.</li> <li><strong>System CPU time</strong>: time spent inside of the system kernel for the Ruby process. While this isn’t time spent by the program’s execution, it’s directly impacted by the code. Privileged operations like file I/O, network I/O, and allocating memory require switching to the system kernel. So reducing the number and complexity of system calls can reduce the system CPU time.</li> <li><strong>Sum of user and system CPU times</strong>: total time the program occupied the CPU.</li> <li><strong>Elapsed time</strong>: the time spent executing the program if it was timed using a stopwatch. This is the time that the user experiences.</li> </ol> <p>It’s interesting to note that the elapsed time may differ significantly from the sum of user and system CPU times in different scenarios. The elapsed time may be higher when the system is under high load and the system scheduler decides to allocate time for other processes to run instead. The elapsed time may be lower when we use multithreading since the user and system CPU times are calculated as the sum of time spent in each CPU core. You can see this behavior when running the code above in multiple <a href="https://docs.ruby-lang.org/en/master/Ractor.html"><code>Ractor</code></a>, but this is left as an exercise for the reader.</p> <p>Going back to the code above, if you have a keen eye, you might have noticed that there was a memoization optimization that I missed. We can change this line:</p> <div><div><pre><code><span>fib_hash</span><span>.</span><span>default_proc</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>h</span><span>,</span> <span>k</span><span>|</span> <span>h</span><span>[</span><span>k</span><span>]</span> <span>=</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>2</span><span>]</span> <span>+</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>1</span><span>]</span> <span>}</span>
</code></pre></div></div> <p>And run the benchmark again:</p> <div><div><pre><code>F(30) = 832040
  0.000014   0.000011   0.000025 (  0.000024)
</code></pre></div></div> <p>Much faster.</p> <h3 id="problem-with-the-benchmark-module"> Problem with the <code>Benchmark</code> module <a href="#problem-with-the-benchmark-module"></a> </h3> <p>A problem with the <code>Benchmark</code> module in Ruby is that it requires a good estimate (or trial-and-error) in finding a good program that runs in a reasonable amount of time. If it takes too long, it’s a slow feedback loop. If it takes too short, the data has few significant digits and high variance which has low statistical significance. For example, I can say that the improvement in the memoized version above is about 3700x (0.094263/0.000025). However, if I rerun my optimized version, I get a total CPU time of 0.000019 which changes the improvement to about 5000x (0.094263/0.000019). That’s quite a big difference!</p> <h2 id="the-benchmark-ips-gem"> The <code>benchmark-ips</code> gem <a href="#the-benchmark-ips-gem"></a> </h2> <p>The <a href="https://github.com/evanphx/benchmark-ips"><code>benchmark-ips</code> gem</a> aims to take more of the guesswork out of benchmarking. It works by having two phases: it first performs a warmup phase to estimate how long the code takes to execute, and a calculation phase where it runs the code for the duration that was specified (default of 5 seconds) using the estimation from the warmup phase.</p> <p>Let’s write a small benchmark to measure the two implementations above using <code>benchmark-ips</code>! Here’s the code:</p> <div><div><pre><code><span># Install benchmark-ips from RubyGems</span>
<span>require</span> <span>&#34;bundler/inline&#34;</span>
<span>gemfile</span> <span>do</span>
  <span>source</span> <span>&#34;https://rubygems.org&#34;</span>
  <span>gem</span> <span>&#34;benchmark-ips&#34;</span>
<span>end</span>

<span>Benchmark</span><span>.</span><span>ips</span> <span>do</span> <span>|</span><span>x</span><span>|</span>
  <span># Benchmark for unoptimized Fibonacci</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;unoptimized&#34;</span><span>)</span> <span>do</span>
    <span>fib_hash</span> <span>=</span> <span>{</span> <span>0</span> <span>=&gt;</span> <span>0</span><span>,</span> <span>1</span> <span>=&gt;</span> <span>1</span> <span>}</span>
    <span>fib_hash</span><span>.</span><span>default_proc</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>h</span><span>,</span> <span>k</span><span>|</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>2</span><span>]</span> <span>+</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>1</span><span>]</span> <span>}</span>
    <span>fib_hash</span><span>[</span><span>30</span><span>]</span>
  <span>end</span>

  <span># Benchmark for the memoized Fibonacci</span>
  <span>x</span><span>.</span><span>report</span><span>(</span><span>&#34;memoized&#34;</span><span>)</span> <span>do</span>
    <span>fib_hash</span> <span>=</span> <span>{</span> <span>0</span> <span>=&gt;</span> <span>0</span><span>,</span> <span>1</span> <span>=&gt;</span> <span>1</span> <span>}</span>
    <span>fib_hash</span><span>.</span><span>default_proc</span> <span>=</span> <span>proc</span> <span>{</span> <span>|</span><span>h</span><span>,</span> <span>k</span><span>|</span> <span>h</span><span>[</span><span>k</span><span>]</span> <span>=</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>2</span><span>]</span> <span>+</span> <span>h</span><span>[</span><span>k</span> <span>-</span> <span>1</span><span>]</span> <span>}</span>
    <span>fib_hash</span><span>[</span><span>30</span><span>]</span>
  <span>end</span>

  <span># Compare the results</span>
  <span>x</span><span>.</span><span>compare!</span>
<span>end</span>
</code></pre></div></div> <p>Let’s run the code and see the output:</p> <div><div><pre><code>Warming up --------------------------------------
         unoptimized     1.000  i/100ms
            memoized    27.928k i/100ms
Calculating -------------------------------------
         unoptimized     10.413  (± 0.0%) i/s -     53.000  in   5.094071s
            memoized    287.847k (± 1.3%) i/s -      1.452M in   5.046056s

Comparison:
            memoized:   287847.2 i/s
         unoptimized:       10.4 i/s - 27642.42x  slower
</code></pre></div></div> <p><code>benchmark-ips</code> first runs a warmup where it estimates how many iterations we can do per 100 milliseconds. It then runs the benchmark and outputs the iterations per second for each of the benchmarks. In this case, the unoptimized implementation ran about 10 times per second while the memoized version ran 287 thousand times per second! We also see the standard deviation to show the spread of our runs (the unoptimized version had an unmeasurable amount of variation between runs whereas the memoized version had 1.3% of variation). We can see that the comparison shows that the memoized version is almost 28 thousand times faster in calculating the 31st Fibonacci number!</p> <p>Since <code>benchmark-ips</code> runs for a constant amount of time, it takes the guesswork out of the benchmarking. We can run this benchmark multiple times and we will always get similar results.</p>  <p>If you completed the <a href="https://blog.peterzhu.ca/ruby-c-ext-part-9">previous article</a>, you should have three implementations of the circular buffer: one written in pure Ruby, one written using instance variables, and one written using TypedData objects. If you just want the answers, you can <a href="https://github.com/peterzhu2118/ruby-c-ext-code/tree/main/part10">find the solutions here</a>. We’re now going to benchmark these solutions and see what kinds of performance improvements we can achieve.</p> <p>The benchmark script can be <a href="https://github.com/peterzhu2118/ruby-c-ext-code/blob/main/part10/benchmark.rb">found here</a>. It can be run by first executing <code>bundle install</code> to install dependencies and then <code>bundle exec rake benchmark</code> to run the benchmark.</p> <p>On my machine, I get the following output:</p> <div><div><pre><code>Warming up --------------------------------------
circular_buffer_ruby   403.000  i/100ms
circular_buffer_ivar   740.000  i/100ms
circular_buffer_typeddata
                         1.465k i/100ms
Calculating -------------------------------------
circular_buffer_ruby      4.026k (± 0.6%) i/s -     20.150k in   5.004632s
circular_buffer_ivar      7.362k (± 1.2%) i/s -     37.000k in   5.026645s
circular_buffer_typeddata
                         14.757k (± 2.0%) i/s -     74.715k in   5.065155s

Comparison:
circular_buffer_typeddata:    14757.1 i/s
circular_buffer_ivar:     7361.8 i/s - 2.00x  slower
circular_buffer_ruby:     4026.4 i/s - 3.67x  slower
</code></pre></div></div> <p>We can see that the pure Ruby implementation is the slowest, we achieve nearly double the performance by using instance variables in our C extension, and we yet again double in performance by using TypedData objects! Ultimately, our TypedData implementation ends up being nearly 4x faster than the pure Ruby implementation. Not bad.</p>  <p>In this article, we looked at two different tools to benchmark Ruby code, and we benchmarked the project from the previous part. The benchmark showed a significant performance improvement using TypedData objects over the pure Ruby implementation. In the next article, we’ll look at some ways to make our lives less miserable when the inevitable day comes: our C extension crashes.</p> </div> </article> </div></div>
  </body>
</html>
