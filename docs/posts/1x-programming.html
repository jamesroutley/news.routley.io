<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tim.mcnamara.nz/post/667318290442600448/1x-programming">Original</a>
    <h1>1x Programming</h1>
    
    <div id="readability-page-1" class="page"><div>
						<p>It’s actually okay to be a 1x programmer. Or even a 0.7x programmer.</p><figure data-orig-width="600" data-orig-height="400"><img src="https://64.media.tumblr.com/955192198f9c9921fe3413f03f367d99/fccc7a72e5d9ec65-b5/s500x750/00ef13738530f4a57b1257706c42d7403b342510.png" data-orig-width="600" data-orig-height="400" width="500" height="333" alt="image"/></figure><h2>Programming is a tool, little more<br/></h2><p>What
 do I mean, “like a tool”? Well, programming is a tool in the sense that
 most programming is done to achieve something other than programming.</p><p>Spending
 three hours in front of a screen might enable you to start a business, 
to pursue some creative outlet or perhaps to fix some problem in the 
world. But, under this mindset, programming has no a value in itself. <br/></p><p>If
 there was a better tool than programming to achieve your aims, you 
would be perfectly entitled to learn that instead. A formal way to 
describe this would be to say that programming’s value is purely 
instrumental, or its value is derived from the other things that you 
produce with it.</p><p>That’s not 
to say that you’re not entitled to refine your skills and improve your 
productivity. However, I want you to know that you’re not a lessor 
person because you’re not able to produce 10x of something that’s almost
 unmeasureable, like software. It turns out that <a href="https://href.li/?https://third-bit.com/talks/greatest-hits/?utm_campaign=CLICKWORTHY&amp;utm_medium=email&amp;utm_source=Revue%20newsletter#28" target="_blank">some programmers who are at least 10x more productive</a> than others, however <a href="https://href.li/?https://journals.plos.org/ploscompbiol/article?id=10.1371%2Fjournal.pcbi.1006023&amp;utm_campaign=CLICKWORTHY&amp;utm_medium=email&amp;utm_source=Revue%20newsletter#sec002" target="_blank">no one is born as a better programmer</a>.</p><p>Here
 are some principles that I think hold merit. I haven’t ranked them in 
any particular order. I hope that you feel like they’re slightly 
provocative. I don’t want this list to seem like it is in any sense 
canonical. I’m learning too. So feel free to pick and choose!</p><figure data-orig-height="400" data-orig-width="600"><img src="https://64.media.tumblr.com/504b0d443a0f08b8da6bb79c3990f0af/fccc7a72e5d9ec65-4a/s500x750/7ffc8b8a9811d830f2c7468dd7bad4519dda4bc7.png" data-orig-height="400" data-orig-width="600" width="500" height="333" alt="image"/></figure><h2> Principles of the 1x programmer</h2><p><b>Software is a team sport</b><br/></p><p>Even if you’re coding for yourself, you’re still coding for a team. Your
 future self will not have the same cognitive context that you do 
currently. Therefore, you should always code in a way that respects the 
people who are following you.</p><p>One of the best introductions to this type of socially minded programming is called <i><a href="https://href.li/?https://buildtogether.tech/?utm_campaign=CLICKWORTHY&amp;utm_medium=email&amp;utm_source=Revue%20newsletter" target="_blank">Building Software Together</a></i> (freely licensed under CC-BY-NC 4.0) by Greg Wilson and contributors. <br/></p><blockquote><p>Our aim is to teach you how to be a compassionate programmer:
 one who cares as much about the well-being of their colleagues and 
users as they do about their own. This focus is not entirely 
altruistic—everything you do to help others also helps your future 
self—but now that we all know how much harm software can do, we hope 
you’ll be interested in some practical idealism.</p></blockquote><p><b>Learn through mimicry</b></p><p>Find the best software written in
 your programming language of choice. Usually, the language’s standard 
library is a good place to start. Look for patterns. Try to consider how
 you would implement things.</p><p>Small children learn by copying others. Why shouldn’t adults?<i><br/></i></p><p><b>Being a computer scientist is less useful than you might think</b><i><br/></i></p><p>​​Synthesis is essence of 
software engineering, whereas abstraction is the essence of computer 
science. Your job as a software developer will be to synthesise 
something new from composable pieces. What you create should be simple 
to understand and extend.</p><p>You are unlikely to implement sophisticated data structures and algorithms. <br/></p><p>I don’t agree with everything that pg writes, but <a href="https://href.li/?http://paulgraham.com/weird.html?utm_campaign=CLICKWORTHY&amp;utm_medium=www&amp;utm_source=timmcnamara.co.nz" target="_blank">this struck out</a>.</p><blockquote><p>99.5% of programming consists of gluing together calls to library functions.</p></blockquote><p><b>The time to fix things is now</b></p><p>Your
 team isn’t going to have fewer priorities next week or next month. 
There will not be an opportunity to the wholesale rewrite that the code 
base deserves. The only way to improve a code base is incrementally.</p><p>I learned this through John Ousterhout’s book, <i>A Philosophy of Software Design</i>.
 The overall suggestion that I took away from the book is that if your 
team is struggling with a spaghetti code base, its members should be 
investing about 10-20% of their total development time cleaning it up.</p><p><b>You’re paid to build</b></p><p>If you think that you’re employed to write software, then you’ve not thought hard enough.</p><p>You’re employed to make money – or save money – for someone. And the way to do that is probably through programming.</p><p>The phrase is terrible, but it’s worth repeating anyway. Make sure that you “add value”.</p><p>This matters because sometimes – perhaps often – working on the boring 
thing that no one wants to work on is really the thing that you should 
be doing.<br/></p><p><b>Simplicity really helps</b></p><p>We
 all want to write simple software, as hard as that is. Ideally, your 
code should be simple enough so that a junior programmer who doesn’t 
like you can understand it.</p><p>Ironically,
 simple code probably has a shorter lifespan than complex code. Complex 
and difficult code remains fixed because people are afraid to change it.
 Complex code is very hard to test. And without regression tests, we 
don’t know if we’ve broken behaviour. So it becomes brittle.</p><p><b>API beats algorithm</b></p><p>Syntax matters. One of the lessons from the success of Kenneth Reith’s <code>requests</code>
 package — which completely took over from the standard library’s own 
implementation of making web requests — is that the (public) API is more
 important than every millisecond that you save from implementing the 
perfect algorithm. Users care about convenience. Convenient code is easy
 to write, easy to read and easy to maintain.However, it’s also 
understand what comprises your <a href="https://href.li/?https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain?utm_campaign=CLICKWORTHY&amp;utm_medium=email&amp;utm_source=Revue%20newsletter" target="_blank">“Porcelain API” and your “Plumbing API”</a>.<br/></p><p><b>Other people make mistakes</b></p><p>The majority of us are better drivers than average. I’m sure the same is true for programming.Brains are imperfect. <br/></p><p>It’s impossible for you to assess your own skill level.</p><p><b>If you want adoption, software is just the start</b></p><p>If
 you care about adoption, there’s lots of work to do once the code has 
been written. That is, unless you’re Fabrice Bellard, I guess.</p><p>This,
 to me, is the ultimate reason why being a 1x programmer (even in a 
professional setting) can be sufficient. You might be able to contribute
 to other areas that someone who is focused purely on the code is not 
able (or, more commonly, unwilling) to do. 10x programmers care about 
the code. Everything else is secondary.</p><p>Users
 care about themselves. To them, they need to be the primary priority. 
This rift causes a problem when open source maintainers decide that 
their users are indeed secondary. But that might be the theme of a 
future post<i>.</i></p><figure data-orig-height="400" data-orig-width="600"><img src="https://64.media.tumblr.com/95a889483bc13857018b9498684b896c/fccc7a72e5d9ec65-8c/s500x750/36d927030fb60ae18ead7477f6d4e751abc30a69.png" data-orig-height="400" data-orig-width="600" width="500" height="333" alt="image"/></figure><h2>Please improve this list<br/></h2><p>What have you learned in the course of your learning journey? Please let me know. I have plenty to learn.
					</p></div></div>
  </body>
</html>
