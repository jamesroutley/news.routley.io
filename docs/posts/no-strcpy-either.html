<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://daniel.haxx.se/blog/2025/12/29/no-strcpy-either/">Original</a>
    <h1>No strcpy either</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Some time ago I mentioned that we went through the curl source code and eventually got rid of all <code>strncpy</code>() calls.</p>



<p>strncpy() is a weird function with a crappy API. It might not null terminate the destination and it <em>pads</em> the target buffer with zeroes. Quite frankly, most code bases are probably better off completely avoiding it because each use of it is a potential mistake.</p>



<p>In that particular rewrite when we made strncpy calls extinct, we made <em>sure</em> we would either copy the full string properly or return error. It is rare that copying a partial string is the right choice, and if it is, we can just as well <code>memcpy</code> it and handle the null terminator explicitly. This meant no case for using strlcpy or anything such either.</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;69541a6e2ec9c&#34;}" data-wp-interactive="core/image" data-wp-key="69541a6e2ec9c"><img decoding="async" width="2668" height="1501" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://daniel.haxx.se/blog/wp-content/uploads/2025/12/Screenshot-2025-12-29-at-17-08-28-curl-Project-status-dashboard.png" alt=""/><figcaption>strncpy density in curl over time</figcaption></figure>
</div>


<h2>But strcpy?</h2>



<p>strcpy however, has its valid uses and it has a less bad and confusing API. The main challenge with strcpy is that when using it we do not specify the length of the target buffer nor of the source string.</p>



<p>This is normally not a problem because in a C program <code>strcpy</code> should only be used when we have full control of both.</p>



<p>But <em>normally</em> and <em>always</em> are not necessarily the same thing. We are but all human and we all do mistakes. Using strcpy implies that there is at least one or maybe two, buffer size checks done prior to the function invocation. In a good situation.</p>



<p>Over time however – let’s imagine we have code that lives on for decades – when code is maintained, patched, improved and polished by many different authors with different mindsets and approaches, those size checks and the function invoke may glide apart. The further away from each other they go, the bigger is the risk that something happens in between that nullifies one of the checks or changes the conditions for the strcpy.</p>



<h2>Enforce checks close to code</h2>



<p>To make sure that the size checks cannot be separated from the copy itself we introduced a string copy replacement function the other day that takes the <em>target buffer</em>, <em>target size</em>, <em>source buffer</em> and <em>source string length</em> as arguments and only if the copy can be made and the null terminator also fits there, the operation is done.</p>



<p>This made it possible to implement the replacement using memcpy(). Now we can completely ban the use of strcpy in curl source code, like we already did strncpy.</p>



<p>Using this function version is a little more work and more cumbersome than strcpy since it needs more information, but we believe the upsides of this approach will help us have an oversight for the extra pain involved. I suppose we will see how that will fare down the road. Let’s come back in a decade and see how things developed!</p>


<div>
<figure data-wp-context="{&#34;imageId&#34;:&#34;69541a6e2ef0c&#34;}" data-wp-interactive="core/image" data-wp-key="69541a6e2ef0c"><img loading="lazy" decoding="async" width="2668" height="1501" data-wp-class--hide="state.isContentHidden" data-wp-class--show="state.isContentVisible" data-wp-init="callbacks.setButtonStyles" data-wp-on--click="actions.showLightbox" data-wp-on--load="callbacks.setButtonStyles" data-wp-on-window--resize="callbacks.setButtonStyles" src="https://daniel.haxx.se/blog/wp-content/uploads/2025/12/Screenshot-2025-12-29-at-17-08-50-curl-Project-status-dashboard.png" alt=""/><figcaption>strcpy density in curl over time</figcaption></figure>
</div>


<pre>void curlx_strcopy(char *dest,</pre>



<p><a href="https://github.com/curl/curl/blob/master/lib/curlx/strcopy.c">the strcopy source</a></p>



<h2>AI slop</h2>



<p>An additional minor positive side-effect of this change is of course that this should effectively prevent the AI chatbots to report strcpy uses in curl source code and insist it is insecure if anyone would ask (as people still apparently do). It has been proven numerous times already that strcpy in source code is like a honey pot for generating hallucinated vulnerability claims.</p>



<p>Still, this will just make them find something else to make up a report about, so there is probably no net gain. AI slop is not a game we can win.</p>
	</div></div>
  </body>
</html>
