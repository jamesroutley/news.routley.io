<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://coder-mike.com/blog/2022/06/11/microvium-is-very-small/">Original</a>
    <h1>Microvium Is Small</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p><strong>TL;DR</strong>: The Microvium JavaScript engine for microcontrollers takes about <strong>8.5 kB of ROM</strong> and <strong>34 bytes</strong> <strong>of RAM</strong> per VM while idle, making it possibly the smallest JavaScript engine to date with more language features than engines 5x its size.</p>



<hr/>



<p>I’ve designed <a href="https://coder-mike.com/behind-microvium/" target="_blank" rel="noreferrer noopener">Microvium</a> from the ground up with the intention for it to be <em>tiny</em>, and it’s been an absolute success in that sense. Microvium may be the smallest JavaScript engine out there, but it still packs a punch in terms of features.</p>







<p>Size often matters in small MCU devices. A large proportion of microcontroller models available on the market still have less than 64 kB of flash and less than 2 kB of RAM. These are still used because they’re smaller, cheaper, and have lower power than their larger counterparts. All the microcontrollers I’ve worked with in my career as a firmware engineer have had ≤ 16kB RAM.</p>



<p>Some might say that you shouldn’t even want JavaScript on such small devices, and certainly in some cases that would be true. But <a rel="noreferrer noopener" href="https://coder-mike.com/blog/2022/05/27/single-threading-is-more-memory-efficient/" target="_blank">as I pointed out in my last post</a>, juggling multiple operations in firmware can be both easier and more memory efficient if the high-level logic is described in terms of a language like JavaScript, even if that’s the only thing you’re using it for.</p>



<p>Even on larger devices, do you really want to dedicate a large chunk of it to a JavaScript engine? A smaller engine is a smaller commitment to make — a lower barrier to entry.</p>







<p>If I Google “smallest JavaScript engine for microcontrollers”, the first one on the list is <a rel="noreferrer noopener" href="https://github.com/cesanta/elk" target="_blank">Elk</a>. Elk is indeed pretty tiny. For me, it compiles to just 11.5kB of flash<sup id="rf1-1952"><a href="#fn1-1952" title="All of the sizes quoted in this post are when targetting the 32-bit ARM Cortex M0 using GCC with optimization for size. I’m measuring these sizes in June 2022, and of course they may change over time." rel="footnote">1</a></sup>. But Microvium compiled with the same settings compiles to just 8.5kB.</p>



<p>What about RAM?</p>



<p>The amount of RAM Elk uses is not pre-defined — you give it a buffer of RAM of any size you want, but it needs to be at least 96 bytes for the VM kernel state. Microvium takes 54 bytes for the kernel state.</p>



<p>But where there’s a massive difference in memory requirement is that Elk requires all of its memory allocated upfront, and keeps it for the lifetime of the VM. If your script’s peak memory in Elk is 1kB then you need to give it a 1kB buffer at startup, so its idle memory usage is 1kB. Microvium on the other hand uses malloc and free to allocate when needed and free when not needed. Its idle memory usage can be as low as 34 bytes. In typical firmware, idle memory is much more important than peak memory, <a rel="noreferrer noopener" href="https://coder-mike.com/blog/2022/05/27/single-threading-is-more-memory-efficient/" target="_blank">as I explained in my last post</a>.</p>



<p>What about the feature set? This is another area where Microvium and Elk diverge significantly. The following table shows the differences:</p>



<figure><table><thead><tr><th></th><th data-align="center">Microvium</th><th data-align="center">Elk</th></tr></thead><tbody><tr><td><code>var</code>, <code>const</code> (Elk supports <code>let</code> only) </td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td><code>do</code>, <code>switch</code>, <code>for</code></td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Computed member access <code>a[b]</code></td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Arrow functions, closures</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Modules</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Snapshotting</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Uses intermediate bytecode (better performance)</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Parser at runtime</td><td data-align="center"></td><td data-align="center">✓</td></tr><tr><td>ROM</td><td data-align="center">8.5 kB</td><td data-align="center">11.5 kB</td></tr><tr><td>Idle RAM</td><td data-align="center">36 B</td><td data-align="center">Lots</td></tr><tr><td>Peak kernel RAM</td><td data-align="center">54 B</td><td data-align="center">96 B</td></tr><tr><td>Slot size (size of simple variables)</td><td data-align="center">2 B</td><td data-align="center">8 B</td></tr></tbody></table></figure>



<p>The only thing that Elk can do that Microvium can’t do is execute strings of JavaScript text at runtime. So if your use case involves having human users directly provide scripts to the device, without any intermediate tools that could pre-process the script, then you can’t use Microvium and you might want to use Elk, mJS, or a larger engine like XS. On the other hand, if your use case has at any point a place where you can preprocess scripts before downloading them to the device then you can use Microvium.</p>







<p>But Cesanta, the maker of Elk, also made a larger JS engine with more features: <a rel="noreferrer noopener" href="https://github.com/cesanta/mjs" target="_blank">mJS</a>, which is probably the closest match to Microvium in terms of feature set. mJS lets you write for-loops and switch statements for example.</p>



<p>Since they’re closely matched for intent and features, I did a more detailed <a rel="noreferrer noopener" href="https://github.com/coder-mike/microvium/blob/main/doc/microvium-vs-mjs.md" target="_blank">comparison of mJS and Microvium here</a>. But here’s a summary:</p>



<figure><table><tbody><tr><td></td><td data-align="center">Microvium</td><td data-align="center">mJS</td><td data-align="center">Elk</td></tr><tr><td><code>var</code>, <code>const</code> (mJS supports <code>let</code> only)</td><td data-align="center">✓</td><td data-align="center"></td><td data-align="center"></td></tr><tr><td>Template strings</td><td data-align="center">✓</td><td data-align="center"></td><td data-align="center"></td></tr><tr><td>Arrow functions and closures</td><td data-align="center">✓</td><td data-align="center"></td><td data-align="center"></td></tr><tr><td>ES Modules</td><td data-align="center">✓</td><td data-align="center"></td><td data-align="center"></td></tr><tr><td><code>do</code>, <code>switch</code>, <code>for</code></td><td data-align="center">✓</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Computed member access <code>a[b]</code></td><td data-align="center">✓</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Uses intermediate bytecode (better performance)</td><td data-align="center">✓</td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Some builtin-functions</td><td data-align="center"></td><td data-align="center">✓</td><td data-align="center"></td></tr><tr><td>Parser at runtime</td><td data-align="center"></td><td data-align="center">✓</td><td data-align="center">✓</td></tr><tr><td>ROM</td><td data-align="center">8.5 kB</td><td data-align="center">45.6 kB</td><td data-align="center">11.5 kB</td></tr><tr><td>Slot size</td><td data-align="center">2 B</td><td data-align="center">8 B</td><td data-align="center">8 B</td></tr></tbody></table></figure>



<p>I’ve lumped “some builtin-functions” into one box because it’s not a language feature as such. mJS has a number of builtin functions that Microvium doesn’t have – most notably <code>print</code>, <code>ffi</code>, <code>s2o</code>, <code>JSON.stringify</code>, <code>JSON.parse</code> and <code>Object.create</code>. You can implement these yourself in Microvium quite easily without modifying the engine (or find implementations online), and it gives you the option of choosing what you want rather than having all that space forced on you<sup id="rf2-1952"><a href="#fn2-1952" title="The &lt;code&gt;ffi&lt;/code&gt; in mJS is something that would need to be a built-in in most engines but Microvium’s unique snapshotting approach makes it possible to implement the &lt;code&gt;ffi&lt;/code&gt; as a library just like any of the other functions" rel="footnote">2</a></sup>. </p>



<p>In terms of features, mJS is a more “realistic” JavaScript engine, compared to Elk’s minimalistic approach. I wouldn’t want to write any substantial real-world JavaScript without a for-loop for example. Like Microvium, mJS also precompiles the scripts to bytecode and then executes the bytecode, which results in much better performance than trying to parse on the fly. Engines like Elk that parse as they execute also have the unexpected characteristic that <em>comments and whitespace slow them down</em> at runtime.</p>



<p>But the added features in mJS means it costs a lot more in terms of ROM space — about 4x more than Elk and 5x more than Microvium.</p>



<p>Microvium still has more core language features than mJS, making it arguably a more pleasant language to work in. These features are actually quite useful in certain scenarios:</p>



<ul><li>Proper ES module support is important for code organization and means that your Microvium modules can also be imported into<strong> a node.js or browser environment</strong>. You can have the same algorithms shared by your edge devices (microcontrollers), backend servers, and web interfaces, to give your users a unified experience.</li><li>Closures are fundamental to callback-style asynchronous code, as I explained <a rel="noreferrer noopener" href="https://coder-mike.com/blog/2022/05/27/single-threading-is-more-memory-efficient/" data-type="post" data-id="1903" target="_blank">in my previous post</a>. </li></ul>







<p>I’m obviously somewhat biased since Microvium is my own creation, but the overall picture I get is this:</p>



<ul><li>Microvium is the smallest JavaScript engine that I’m aware of<sup id="rf3-1952"><a href="#fn3-1952" title="Please let me know if you know of a smaller JS engine than Microvium." rel="footnote">3</a></sup></li><li>In this tiny size, Microvium actually supports more core language features than engines more than 5x its size. Some of these features are <em>really</em> useful for writing real-world JS apps.</li><li>Having said that, Microvium has fewer built-in functions — it’s more of a pay-as-go philosophy where your upfront commitment is much less and you bring in support for what you need when you need it.</li><li>The big trade-off is that Microvium doesn’t have a parser at runtime. In the rare case that you really need a parser at runtime, Microvium simply won’t work for you.</li></ul>



<p>Something that made me smile is this note by one of the authors of mJS in a blog posts:</p>



<blockquote><p>That makes mJS fit into <strong>less than 50k of flash space (!)</strong> and <strong>less than 1k of RAM (!!)</strong>. That is hard to beat.</p><cite>https://mongoose-os.com/blog/mjs-a-new-approach-to-embedded-scripting/</cite></blockquote>



<p>I have great respect for the authors of mJS and what they’ve done, which makes me all the more proud that Microvium is able to knock this out of the ballpark, beating what the seasoned professionals have called “hard to beat”. Of course, this comes with some tradeoffs (no parser and no builtin functions), but I’ve achieved my objective of making a JavaScript engine that has a super-low upfront commitment and will squeeze into the tiniest of free spaces, all while still including most of the language features I consider to be important for real-world JavaScript apps.</p>

							</div></div>
  </body>
</html>
