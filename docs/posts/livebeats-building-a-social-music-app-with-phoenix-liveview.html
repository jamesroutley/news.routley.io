<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/blog/livebeats/">Original</a>
    <h1>LiveBeats: Building a social music app with Phoenix LiveView</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://avatars.githubusercontent.com/u/576796?v=4" alt="Chris McCord" srcset=""/> <dl> <dt>Name</dt> <dd> Chris McCord </dd> <dt>Twitter</dt> <dd> <a href="https://twitter.com/chris_mccord" target="_blank"> @chris_mccord </a> </dd> </dl> </dd> </dl> <section> <img src="https://fly.io/blog/2022-02-01/livebeats-cover.jpg" alt=""/> <p> Fly.io is now free for small Phoenix projects. This post is about building a wicked LiveView app with realtime collaboration features. If you already have a Phoenix app to deploy, <a href="https://fly.io/docs/getting-started/elixir/">try us out</a>. You can be up and running in just a few minutes.</p><p>We decided that 2022 was a good year to ship a full-stack Phoenix reference app.</p> <p>The &#34;full stack&#34; metaphor has progressed beyond its humble beginnings of some REST endpoints and sprinkles of JS and CSS. Showing off a todo app is also no longer state of the art. A reference app should really stress a framework and match the needs of apps being built today. Remember <a href="https://turntable.fm">turntable.fm</a>? That&#39;s a more interesting challenge.</p> <p>A good full-stack framework should help you solve ALL the problems you need to build something like turntable.fm quickly, and then iteratively make it more powerful. Live updates are no longer optional, and a solo full stack developer should be able to deliver on these features with the same productivity of a CRUD Rails app in 2010.</p> <p><a href="https://livebeats.fly.dev">Meet LiveBeats</a>, a social music application we wrote to show off the LiveView UX, while serving as a learning example and a test-bed for new LiveView features. As such, it is, of course, open source — follow the development <a href="https://github.com/fly-apps/live_beats">here</a>!</p> <p>If you&#39;re not familiar with LiveView, our <a href="https://fly.io/blog/how-we-got-to-liveview/">overview</a> states:</p> <blockquote> <p>LiveView strips away layers of abstraction, because it solves both the client and server in a single abstraction. HTTP almost entirely falls away. No more REST. No more JSON. No GraphQL APIs, controllers, serializers, or resolvers. You just write HTML templates, and a stateful process synchronizes it with the browser, updating it only when needed. And there&#39;s no JavaScript to write.</p> </blockquote> <p>Here are some of the things LiveBeats demonstrates:</p> <ol> <li><p>A &#34;live&#34;, shared UI. What one person does is visible to everyone else who&#39;s connected.</p> </li><li><p>File management. Uploads should be quick, with a live UI. And the framework should make it easy to use different storage backends. Third party object storage is one way to do this, but sometimes development is simpler with just a filesystem. LiveView uploads is great for both!</p> </li><li><p>Presence! Apps are more interesting when your friends show up.</p> </li></ol> <p>We can accomplish all this with just Phoenix and LiveView, in a shockingly small amount of code. It&#39;s also super fast.</p> <p>To really see what&#39;s special about LiveView and its new features, you need to <a href="https://livebeats.fly.dev">experience it for yourself</a>. Sign in with GitHub OAuth, upload a playlist of MP3&#39;s, and listen to music with your friends. Playback syncs in real-time, presence shows who is currently listening, and file uploads are processed concurrently as they are uploaded.</p> <p>Here&#39;s a two-minute demo to see it in action:</p> <div> <p> <iframe width="100%" height="100%" src="https://www.youtube.com/embed/w3xq-t2hpHY" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe></p></div><h2 id="playlist-sync-and-presence-with-phoenix-pubsub"><a href="#playlist-sync-and-presence-with-phoenix-pubsub" aria-label="Anchor"></a>Playlist Sync and Presence with Phoenix PubSub</h2><p>The hallmark of any &#34;live&#34; or social app is seeing your friends&#39; activity as it happens. In our case, we want to show who is currently listening to a given playlist, and sync the playback of songs as the owner drives the song selection. This is what it looks like:</p>  <p>Phoenix PubSub makes this trivial. In a few lines of code in our business logic, we broadcast updates, then with a few LOC in the LiveViews we listen for the events we care about. When they come in, we update the UI. Everyone connected sees the pages update, even if they are on different horizontally scaled servers.</p> <p>With friction-free PubSub at your fingertips, any feature that makes sense to be real-time gets to be real-time—even changing URLs on the fly.</p> <p>For example, user profiles are served at their username, such as <code>livebeats.fly.dev/chrismccord</code>. But we allow users to update their username in the app, which changes that URL. We don&#39;t want other users listening to their profile to be stuck with an invalid URL that fails on refresh, sharing, or with a click on the profile link.</p> <p>Handling the URL change took a whopping six lines of code in our Profile LiveView!</p> <div><pre><code>  <span>def</span> <span>handle_info</span><span>({</span><span>MediaLibrary</span><span>,</span> <span>%</span><span>PublicProfileUpdated</span><span>{}</span> <span>=</span> <span>update</span><span>},</span> <span>socket</span><span>)</span> <span>do</span>
    <span>{</span><span>:noreply</span><span>,</span>
     <span>socket</span>
     <span>|&gt;</span> <span>assign</span><span>(</span><span>profile:</span> <span>update</span><span>.</span><span>profile</span><span>)</span>
     <span>|&gt;</span> <span>push_patch</span><span>(</span><span>to:</span> <span>profile_path</span><span>(</span><span>update</span><span>.</span><span>profile</span><span>))}</span>
  <span>end</span>
</code></pre></div><p>We are already subscribed to profile notifications, so we just have to handle the <code>PublicProfileUpdated</code> event, update the template profile state, and then <code>push_patch</code> to the client to trigger a <code>pushState</code> browser URL change.</p> <p>For a traditional application, this kind of feature would take standing up WebSocket connections, ad-hoc HTTP protocols, polling the server for changes, and other complexities.</p> <p>Let&#39;s see it in action:</p>  <h2 id="concurrent-upload-processing"><a href="#concurrent-upload-processing" aria-label="Anchor"></a>Concurrent Upload Processing</h2><p>LiveView uploads are handled over the existing WebSocket connection, providing interactive file uploads with file progress out-of-the-box - with no user-land JavaScript.</p> <p>It also allows other neat features like processing the file on the server before writing it to its final location. You might be thinking handling files on your server is sooo mid 2000&#39;s, but hear me out! Servers can have volumes… and you can like write files to them!</p> <p>Think about it. There aren&#39;t any Lambdas to wire up (and pay for per invocation), no webhooks to wire up, and no external message queues to configure, because it all happens over the existing LiveView connection. Compared to a typical cloud upload solution, we can cut out probably a few paid products and just as many failure modes.</p> <p>LiveView also guarantees the temporary uploaded file is on the same load-balanced instance of the LiveView processing the page. There&#39;s no external state to jump around between servers. So you write regular code that takes the file, post-processes or verifies the bits on disk, then writes it to its final location – all the while reporting to the UI the progress of each step.</p> <p>And we do need to extract data out of those binary blobs one way or another, because before we write that MP3 to storage, we want to know that (a) it&#39;s not a malicious file masquerading as an MP3 and (b) it&#39;s less than 20 minutes long.</p> <p>So the user drags and drops a handful of MP3s into the app, we upload them concurrently over the WebSocket connection, then we concurrently parse the binary MP3 data in a temporary file to verify it&#39;s a valid MP3 of acceptable duration. Once complete, we show the calculated duration on the UI and the user can save their playlist.</p>  <p>An aside: It turns out calculating MP3 duration from file content is actually a pain.</p> <p>MP3s can contain ID3 tag metadata about the file, but answering the simple question of &#34;how long is this song?&#34; is surprisingly difficult. To properly calculate the duration of an MP3, you must walk all the frames and take bitrate encodings into consideration. There&#39;s a great write-up <a href="https://shadowfacts.net/2021/mp3-duration/">here</a> on what&#39;s involved with step-by-step Elixir code to make it happen.</p> <h2 id="components"><a href="#components" aria-label="Anchor"></a>Components</h2><p>LiveView recently shipped a new HEEx template engine that supports React-style template syntax with <em>function components</em>. Function components are reusable functions that encapsulate a bit of markup to be used throughout your UI. Think dropdowns, modals, tables, etc. We have a <a href="https://fly.io/phoenix-files/function-components/">post all about function components</a>, if you want to dive deeper.</p> <p>For example, one of our components is a TailwindUI dropdown, which looks like this:</p> <p><img src="https://fly.io/blog/2022-02-01/livebeats-4.jpg?center&amp;1/2&amp;card&amp;border" alt="A Tailwind UI dropdown under Chris McCord&#39;s name, username, and photo, with options &#34;View Profile,&#34; &#34;Settings,&#34; and &#34;Sign out&#34;"/></p> <p>And this is what it looks like in code to use anywhere you&#39;d like a dropdown:</p> <div><pre><code><span>~H&#34;&#34;</span><span>&#34;
&lt;.dropdown id={@id}&gt;
  &lt;:img src={@current_user.avatar_url}/&gt;
  &lt;:title&gt;&lt;%= @current_user.name %&gt;&lt;/:title&gt;
  &lt;:subtitle&gt;@&lt;%= @current_user.username %&gt;&lt;/:subtitle&gt;

  &lt;:link navigate={profile_path(@current_user)}&gt;View Profile&lt;/:link&gt;
  &lt;:link navigate={Routes.settings_path(Endpoint, :edit)}&gt;Settings&lt;/:link&gt;
  &lt;:link href={Routes.session_path(Endpoint, :sign_out)} method={:delete}&gt;
    Sign out
  &lt;/:link&gt;
&lt;/.dropdown&gt;
&#34;&#34;&#34;</span>
</code></pre></div><p>Along with function components, LiveView includes <em>slots,</em> which allows a component to specify a named area of the component where arbitrary content can be placed by the caller. The actual dropdown component is just a simple function that encapsulates all the markup and classes of our Tailwind dropdown:</p> <div><pre><code><span>def</span> <span>dropdown</span><span>(</span><span>assigns</span><span>)</span> <span>do</span>
  <span>assigns</span> <span>=</span>
    <span>assigns</span>
    <span>|&gt;</span> <span>assign_new</span><span>(</span><span>:img</span><span>,</span> <span>fn</span> <span>-&gt;</span> <span>nil</span> <span>end</span><span>)</span>
    <span>|&gt;</span> <span>assign_new</span><span>(</span><span>:title</span><span>,</span> <span>fn</span> <span>-&gt;</span> <span>nil</span> <span>end</span><span>)</span>
    <span>|&gt;</span> <span>assign_new</span><span>(</span><span>:subtitle</span><span>,</span> <span>fn</span> <span>-&gt;</span> <span>nil</span> <span>end</span><span>)</span>

  <span>~H&#34;&#34;</span><span>&#34;
  &lt;div class=&#34;</span><span>px</span><span>-</span><span>3</span> <span>mt</span><span>-</span><span>6</span> <span>relative</span> <span>inline</span><span>-</span><span>block</span> <span>text</span><span>-</span><span>left</span><span>&#34;&gt;
    ...
  &lt;/div&gt;
  &#34;&#34;&#34;</span>
<span>end</span>
</code></pre></div><p>There&#39;s a lot going on inside the function with Tailwind classes, SVGs, list item building, accessibility attributes, etc, but the internal details aren&#39;t important. The idea is: we define our dropdown in a single place in our application, complete with how it&#39;s styled and accessible, and then we use <code>&lt;.dropdown&gt;</code> throughout our UI.</p> <h2 id="going-global"><a href="#going-global" aria-label="Anchor"></a>Going Global</h2><p>Elixir is a distributed programming language and we exploit this fully. LiveBeats is deployed on five continents and the servers cluster together automatically over a private network to broker updates. This is what the future of full-stack looks like.</p> <p>You should serve your full-stack app close to users for the same reason we all agree CDNs are necessary for serving assets close to users. Less latency and more responsiveness improves the experience, and conversions are increased across the board. Folks know this intuitively, but historically we&#39;ve only applied it to assets. With Elixir, our entire stack can take advantage of regional access.</p> <figure> <figcaption> <p> Distributed by design, Elixir Phoenix apps are a perfect fit with the globe-spanning Fly.io network.</p><p><a href="https://fly.io/docs/getting-started/elixir/"> Deploy an Elixir app  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/public/images/cta-dog.jpg" srcset="/public/images/cta-dog@2x.jpg 2x" alt=""/></p></figure><p>For LiveBeats, we went global with only minor changes. First, we set up file proxying between servers, where we stream data from one region to another. Next, we set up Postgres read replicas in each region and we perform standard replica reads against mostly static data.</p> <p>We even set up a ping tracker for each user. You can view your own pings, along with the locations and pings of any other visitors, to visualize where your friends are connected across the globe. It&#39;s also neat to see what kind of speedy UX they have on the app.</p> <p>Check it out:</p>  <p>Here we have a user connecting from the US (iad) and one from Australia (syd), both with <a href="https://fly.io/blog/last-mile-redis/">fast</a> pings to the regional LiveBeats instances.</p> <p>Here&#39;s a bonus video giving a window into the process of scaling LiveBeats across regions on Fly.io.</p> <div> <p> <iframe width="100%" height="100%" src="https://www.youtube.com/embed/JrqBudJd2YM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""> </iframe></p></div><h2 id="client-side-interactions"><a href="#client-side-interactions" aria-label="Anchor"></a>Client-side interactions</h2><p>The LiveView paradigm necessarily requires a server to be connected, but this doesn&#39;t mean all interactions should go to the server. Operations that can immediately happen on the client should stay on the client.</p> <p>LiveView has a <code>JS</code> command interface that allows you to declare client-side effects that work seamlessly with server-issued UI updates. Things like opening modal dialogs, toggling menu visibility, etc happen instantly on the client without the server needing to be aware - just as it should.</p> <p>Let&#39;s see it in action using the LiveBeats modal:</p> <div><pre><code><span>&lt;.</span><span>modal</span>
  <span>id</span><span>=</span><span>{</span><span>@id</span><span>}</span>
  <span>on_confirm</span><span>=</span><span>{</span>
    <span>JS</span><span>.</span><span>push</span><span>(</span><span>&#34;delete&#34;</span><span>,</span> <span>value:</span> <span>%{</span><span>id:</span> <span>@song</span><span>.</span><span>id</span><span>})</span>
    <span>|&gt;</span> <span>hide_modal</span><span>(</span><span>@id</span><span>)</span>
    <span>|&gt;</span> <span>hide</span><span>(</span><span>&#34;#song-</span><span>#{</span><span>@song</span><span>.</span><span>id</span><span>}</span><span>&#34;</span><span>)</span>
  <span>}</span>
<span>&gt;</span>
  <span>Are</span> <span>you</span> <span>sure</span> <span>you</span> <span>want</span> <span>to</span> <span>delete</span> <span>&#34;&lt;%= @song.title %&gt;&#34;</span><span>?</span>
  <span>&lt;</span><span>:cancel</span><span>&gt;</span><span>Cancel</span><span>&lt;/</span><span>:cancel</span><span>&gt;</span>
  <span>&lt;</span><span>:confirm</span><span>&gt;</span><span>Delete</span><span>&lt;/</span><span>:confirm</span><span>&gt;</span>
<span>&lt;/.</span><span>modal</span><span>&gt;</span>
</code></pre></div><p>When a user attempts to delete a song, we show a modal component asking for confirmation. The key aspect is this: when &#34;Delete&#34; is clicked, our <code>on_confirm</code> attribute asynchronously pushes a delete event to the server, but <em>immediately</em> hides the modal and song in the playlist.</p> <p>So we get instant user interaction without any latency, while the song is deleted on the server, just like traditional optimistic UI patterns in a JavaScript framework.</p> <p>Since the <code>JS</code> command interface is regular Elixir code, we can compose functions to handle client-UI operations, such as <code>hide</code> above:</p> <div><pre><code><span>def</span> <span>hide</span><span>(</span><span>js</span> <span>\\</span> <span>%</span><span>JS</span><span>{},</span> <span>selector</span><span>)</span> <span>do</span>
  <span>JS</span><span>.</span><span>hide</span><span>(</span><span>js</span><span>,</span>
    <span>to:</span> <span>selector</span><span>,</span>
    <span>time:</span> <span>300</span><span>,</span>
    <span>transition:</span>
      <span>{</span><span>&#34;transition ease-in duration-300&#34;</span><span>,</span> <span>&#34;transform opacity-100 scale-100&#34;</span><span>,</span>
       <span>&#34;transform opacity-0 scale-95&#34;</span><span>}</span>
  <span>)</span>
<span>end</span>
</code></pre></div><p>This wraps <code>JS.hide</code> and uses <code>:transition</code> to give it a slick Tailwind-based CSS transition when hiding elements.</p> <h2 id="what-s-next"><a href="#what-s-next" aria-label="Anchor"></a>What&#39;s Next</h2><p>With LiveBeats fleshed out, we&#39;ll continue to add features and use it as a test-bed for in-progress LiveView development. Expect future content deep diving into approaches and considerations when bringing your LiveView application close to users around the world!</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/blog/free-postgres/"> Free Postgres Databases </a> </dd> </dl> </article></div>
  </body>
</html>
