<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/domfarolino/observable">Original</a>
    <h1>Observable API Proposal</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">This is the explainer for the Observable API proposal for more ergonomic and
composable event handling.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-introduction" aria-hidden="true" href="#introduction"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Introduction</h2>
<h3 tabindex="-1" dir="auto"><a id="user-content-eventtarget-integration" aria-hidden="true" href="#eventtarget-integration"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a><code>EventTarget</code> integration</h3>
<p dir="auto">This proposal adds an <code>.on()</code> method to <code>EventTarget</code> that becomes a better
<code>addEventListener()</code>; specifically it returns a <a href="#the-observable-api">new
<code>Observable</code></a> that adds a new event listener to the target
when its <code>subscribe()</code> method is called. The Observable calls the subscriber&#39;s
<code>next()</code> handler with each event.</p>
<p dir="auto">Observables turn event handling, filtering, and termination, into an explicit, declarative flow
that&#39;s easier to understand and
<a href="https://stackoverflow.com/questions/44112364/what-does-this-mean-in-the-observable-tc-39-proposal" rel="nofollow">compose</a>
than today&#39;s imperative version, which often requires nested calls to <code>addEventListener()</code> and
hard-to-follow callback chains.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-example-1" aria-hidden="true" href="#example-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example 1</h4>
<div dir="auto" data-snippet-clipboard-copy-content="// Filtering and mapping:
element.on(&#39;click&#39;)
  .filter(e =&gt; e.target.matches(&#39;.foo&#39;))
  .map(e =&gt; ({x: e.clientX, y: e.clientY }))
  .subscribe({next: handleClickAtPoint});"><pre><span>// Filtering and mapping:</span>
<span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span>
  <span>.</span><span>filter</span><span>(</span><span>e</span> <span>=&gt;</span> <span>e</span><span>.</span><span>target</span><span>.</span><span>matches</span><span>(</span><span>&#39;.foo&#39;</span><span>)</span><span>)</span>
  <span>.</span><span>map</span><span>(</span><span>e</span> <span>=&gt;</span> <span>(</span><span>{</span><span>x</span>: <span>e</span><span>.</span><span>clientX</span><span>,</span> <span>y</span>: <span>e</span><span>.</span><span>clientY</span> <span>}</span><span>)</span><span>)</span>
  <span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>handleClickAtPoint</span><span>}</span><span>)</span><span>;</span></pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-example-2" aria-hidden="true" href="#example-2"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example 2</h4>
<div dir="auto" data-snippet-clipboard-copy-content="// Automatic, declarative unsubscription via the takeUntil method:
element.on(&#39;mousemove&#39;)
  .takeUntil(document.on(&#39;mouseup&#39;))
  .subscribe({next: e =&gt; … });

// Since reduce and some other terminators return promises, they also play
// well with async functions:
await element.on(&#39;mousemove&#39;)
  .takeUntil(element.on(&#39;mouseup&#39;))
  .reduce((e, soFar) =&gt; …);"><pre><span>// Automatic, declarative unsubscription via the takeUntil method:</span>
<span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;mousemove&#39;</span><span>)</span>
  <span>.</span><span>takeUntil</span><span>(</span><span>document</span><span>.</span><span>on</span><span>(</span><span>&#39;mouseup&#39;</span><span>)</span><span>)</span>
  <span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>e</span> <span>=&gt;</span> <span>…</span> <span>}</span><span>)</span><span>;</span>

<span>// Since reduce and some other terminators return promises, they also play</span>
<span>// well with async functions:</span>
<span>await</span> <span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;mousemove&#39;</span><span>)</span>
  <span>.</span><span>takeUntil</span><span>(</span><span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;mouseup&#39;</span><span>)</span><span>)</span>
  <span>.</span><span>reduce</span><span>(</span><span>(</span><span>e</span><span>,</span> <span>soFar</span><span>)</span> <span>=&gt;</span> <span>…</span><span>)</span><span>;</span></pre></div>
<details>
<summary>Imperative version</summary>
<div dir="auto" data-snippet-clipboard-copy-content="// Imperative
const controller = new AbortController();
element.addEventListener(&#39;mousemove&#39;, e =&gt; {
  element.addEventListener(&#39;mouseup&#39;, e =&gt; controller.abort());
  console.log(e);
}, {signal});"><pre><span>// Imperative</span>
<span>const</span> <span>controller</span> <span>=</span> <span>new</span> <span>AbortController</span><span>(</span><span>)</span><span>;</span>
<span>element</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;mousemove&#39;</span><span>,</span> <span>e</span> <span>=&gt;</span> <span>{</span>
  <span>element</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;mouseup&#39;</span><span>,</span> <span>e</span> <span>=&gt;</span> <span>controller</span><span>.</span><span>abort</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>e</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>{</span>signal<span>}</span><span>)</span><span>;</span></pre></div>
</details>
<h4 tabindex="-1" dir="auto"><a id="user-content-example-3" aria-hidden="true" href="#example-3"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example 3</h4>
<p dir="auto">Tracking all link clicks within a container
(<a href="https://github.com/whatwg/dom/issues/544#issuecomment-351705380" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">example</a>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="container.on(&#39;click&#39;).filter(e =&gt; e.target.closest(&#39;a&#39;)).subscribe({next: e =&gt; {
  // …
}});"><pre><span>container</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>e</span> <span>=&gt;</span> <span>e</span><span>.</span><span>target</span><span>.</span><span>closest</span><span>(</span><span>&#39;a&#39;</span><span>)</span><span>)</span><span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>e</span> <span>=&gt;</span> <span>{</span>
  <span>// …</span>
<span>}</span><span>}</span><span>)</span><span>;</span></pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-example-4" aria-hidden="true" href="#example-4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example 4</h4>
<p dir="auto">Find the maximum Y coordinate while the mouse is held down
(<a href="https://github.com/whatwg/dom/issues/544#issuecomment-351762493" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">example</a>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="const maxY = await element.on(&#39;mousemove&#39;)
                          .takeUntil(element.on(&#39;mouseup&#39;))
                          .map(e =&gt; e.clientY)
                          .reduce((y, soFar) =&gt; Math.max(y, soFar), 0);"><pre><span>const</span> <span>maxY</span> <span>=</span> <span>await</span> <span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;mousemove&#39;</span><span>)</span>
                          <span>.</span><span>takeUntil</span><span>(</span><span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;mouseup&#39;</span><span>)</span><span>)</span>
                          <span>.</span><span>map</span><span>(</span><span>e</span> <span>=&gt;</span> <span>e</span><span>.</span><span>clientY</span><span>)</span>
                          <span>.</span><span>reduce</span><span>(</span><span>(</span><span>y</span><span>,</span> <span>soFar</span><span>)</span> <span>=&gt;</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>y</span><span>,</span> <span>soFar</span><span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span></pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-example-5" aria-hidden="true" href="#example-5"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example 5</h4>
<p dir="auto">Multiplexing a <code>WebSocket</code>, such that a subscription message is send on connection,
and an unsubscription message is send to the server when the user unsubscribes.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const socket = new WebSocket(&#39;wss://example.com&#39;);

function multiplex({ startMsg, stopMsg, match }) {
  if (socket.readyState !== WebSocket.OPEN) {
    return socket
      .on(&#39;open&#39;)
      .flatMap(() =&gt; multiplex({ startMsg, stopMsg, match }));
  } else {
    socket.send(JSON.stringify(startMsg));
    return socket
      .on(&#39;message&#39;)
      .filter(match)
      .takeUntil(socket.on(&#39;close&#39;))
      .takeUntil(socket.on(&#39;error&#39;))
      .map((e) =&gt; JSON.parse(e.data))
      .finally(() =&gt; {
        socket.send(JSON.stringify(stopMsg));
      });
  }
}

function streamStock(ticker) {
  return multiplex({
    startMsg: { ticker, type: &#39;sub&#39; },
    stopMsg: { ticker, type: &#39;unsub&#39; },
    match: (data) =&gt; data.ticker === ticker,
  });
}

function finish(stopMsg) {
  socket.send(JSON.stringify(stopMsg));
}

const googTrades = streamStock(&#39;GOOG&#39;);
const nflxTrades = streamStock(&#39;NFLX&#39;);

const googController = new AbortController();
const googSubscription = googTrades.subscribe({next: updateView, signal: googController.signal});
const nflxSubscription = nflxTrades.subscribe({next: updateView, ...});

// And the stream can disconnect later, which
// automatically sends the unsubscription message
// to the server.
googController.abort();"><pre><span>const</span> <span>socket</span> <span>=</span> <span>new</span> <span>WebSocket</span><span>(</span><span>&#39;wss://example.com&#39;</span><span>)</span><span>;</span>

<span>function</span> <span>multiplex</span><span>(</span><span>{</span> startMsg<span>,</span> stopMsg<span>,</span> match <span>}</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>socket</span><span>.</span><span>readyState</span> <span>!==</span> <span>WebSocket</span><span>.</span><span>OPEN</span><span>)</span> <span>{</span>
    <span>return</span> <span>socket</span>
      <span>.</span><span>on</span><span>(</span><span>&#39;open&#39;</span><span>)</span>
      <span>.</span><span>flatMap</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>multiplex</span><span>(</span><span>{</span> startMsg<span>,</span> stopMsg<span>,</span> match <span>}</span><span>)</span><span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>startMsg</span><span>)</span><span>)</span><span>;</span>
    <span>return</span> <span>socket</span>
      <span>.</span><span>on</span><span>(</span><span>&#39;message&#39;</span><span>)</span>
      <span>.</span><span>filter</span><span>(</span><span>match</span><span>)</span>
      <span>.</span><span>takeUntil</span><span>(</span><span>socket</span><span>.</span><span>on</span><span>(</span><span>&#39;close&#39;</span><span>)</span><span>)</span>
      <span>.</span><span>takeUntil</span><span>(</span><span>socket</span><span>.</span><span>on</span><span>(</span><span>&#39;error&#39;</span><span>)</span><span>)</span>
      <span>.</span><span>map</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>e</span><span>.</span><span>data</span><span>)</span><span>)</span>
      <span>.</span><span>finally</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>stopMsg</span><span>)</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>streamStock</span><span>(</span><span>ticker</span><span>)</span> <span>{</span>
  <span>return</span> <span>multiplex</span><span>(</span><span>{</span>
    <span>startMsg</span>: <span>{</span> ticker<span>,</span> <span>type</span>: <span>&#39;sub&#39;</span> <span>}</span><span>,</span>
    <span>stopMsg</span>: <span>{</span> ticker<span>,</span> <span>type</span>: <span>&#39;unsub&#39;</span> <span>}</span><span>,</span>
    <span>match</span>: <span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>data</span><span>.</span><span>ticker</span> <span>===</span> <span>ticker</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>finish</span><span>(</span><span>stopMsg</span><span>)</span> <span>{</span>
  <span>socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>stopMsg</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>googTrades</span> <span>=</span> <span>streamStock</span><span>(</span><span>&#39;GOOG&#39;</span><span>)</span><span>;</span>
<span>const</span> <span>nflxTrades</span> <span>=</span> <span>streamStock</span><span>(</span><span>&#39;NFLX&#39;</span><span>)</span><span>;</span>

<span>const</span> <span>googController</span> <span>=</span> <span>new</span> <span>AbortController</span><span>(</span><span>)</span><span>;</span>
<span>const</span> <span>googSubscription</span> <span>=</span> <span>googTrades</span><span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>updateView</span><span>,</span> <span>signal</span>: <span>googController</span><span>.</span><span>signal</span><span>}</span><span>)</span><span>;</span>
<span>const</span> <span>nflxSubscription</span> <span>=</span> <span>nflxTrades</span><span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>updateView</span><span>,</span> ...<span>}</span><span>)</span><span>;</span>

<span>// And the stream can disconnect later, which</span>
<span>// automatically sends the unsubscription message</span>
<span>// to the server.</span>
<span>googController</span><span>.</span><span>abort</span><span>(</span><span>)</span><span>;</span></pre></div>
<details>
<summary>Imperative version</summary>
<div dir="auto" data-snippet-clipboard-copy-content="// Imperative
function multiplex({ startMsg, stopMsg, match }) {
  const start = (callback) =&gt; {
    const teardowns = [];

    if (socket.readyState !== WebSocket.OPEN) {
      const openHandler = () =&gt; start({ startMsg, stopMsg, match })(callback);
      socket.addEventListener(&#39;open&#39;, openHandler);
      teardowns.push(() =&gt; {
        socket.removeEventListener(&#39;open&#39;, openHandler);
      });
    } else {
      socket.send(JSON.stringify(startMsg));
      const messageHandler = (e) =&gt; {
        const data = JSON.parse(e.data);
        if (match(data)) {
          callback(data);
        }
      };
      socket.addEventListener(&#39;message&#39;, messageHandler);
      teardowns.push(() =&gt; {
        socket.send(JSON.stringify(stopMsg));
        socket.removeEventListener(&#39;message&#39;, messageHandler);
      });
    }

    const finalize = () =&gt; {
      teardowns.forEach((t) =&gt; t());
    };

    socket.addEventListener(&#39;close&#39;, finalize);
    teardowns.push(() =&gt; socket.removeEventListener(&#39;close&#39;, finalize));
    socket.addEventListener(&#39;error&#39;, finalize);
    teardowns.push(() =&gt; socket.removeEventListener(&#39;error&#39;, finalize));

    return finalize;
  };

  return start;
}

function streamStock(ticker) {
  return multiplex({
    startMsg: { ticker, type: &#39;sub&#39; },
    stopMsg: { ticker, type: &#39;unsub&#39; },
    match: (data) =&gt; data.ticker === ticker,
  });
}

const googTrades = streamStock(&#39;GOOG&#39;);
const nflxTrades = streamStock(&#39;NFLX&#39;);

const unsubGoogTrades = googTrades(updateView);
const unsubNflxTrades = nflxTrades(updateView);

// And the stream can disconnect later, which
// automatically sends the unsubscription message
// to the server.
unsubGoogTrades();"><pre><span>// Imperative</span>
<span>function</span> <span>multiplex</span><span>(</span><span>{</span> startMsg<span>,</span> stopMsg<span>,</span> match <span>}</span><span>)</span> <span>{</span>
  <span>const</span> <span>start</span> <span>=</span> <span>(</span><span>callback</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>teardowns</span> <span>=</span> <span>[</span><span>]</span><span>;</span>

    <span>if</span> <span>(</span><span>socket</span><span>.</span><span>readyState</span> <span>!==</span> <span>WebSocket</span><span>.</span><span>OPEN</span><span>)</span> <span>{</span>
      <span>const</span> <span>openHandler</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>start</span><span>(</span><span>{</span> startMsg<span>,</span> stopMsg<span>,</span> match <span>}</span><span>)</span><span>(</span><span>callback</span><span>)</span><span>;</span>
      <span>socket</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;open&#39;</span><span>,</span> <span>openHandler</span><span>)</span><span>;</span>
      <span>teardowns</span><span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>socket</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;open&#39;</span><span>,</span> <span>openHandler</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>startMsg</span><span>)</span><span>)</span><span>;</span>
      <span>const</span> <span>messageHandler</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>const</span> <span>data</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>e</span><span>.</span><span>data</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>match</span><span>(</span><span>data</span><span>)</span><span>)</span> <span>{</span>
          <span>callback</span><span>(</span><span>data</span><span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>;</span>
      <span>socket</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;message&#39;</span><span>,</span> <span>messageHandler</span><span>)</span><span>;</span>
      <span>teardowns</span><span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>socket</span><span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>stopMsg</span><span>)</span><span>)</span><span>;</span>
        <span>socket</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;message&#39;</span><span>,</span> <span>messageHandler</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span>

    <span>const</span> <span>finalize</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>teardowns</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>t</span><span>)</span> <span>=&gt;</span> <span>t</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>

    <span>socket</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;close&#39;</span><span>,</span> <span>finalize</span><span>)</span><span>;</span>
    <span>teardowns</span><span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>socket</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;close&#39;</span><span>,</span> <span>finalize</span><span>)</span><span>)</span><span>;</span>
    <span>socket</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;error&#39;</span><span>,</span> <span>finalize</span><span>)</span><span>;</span>
    <span>teardowns</span><span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>socket</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;error&#39;</span><span>,</span> <span>finalize</span><span>)</span><span>)</span><span>;</span>

    <span>return</span> <span>finalize</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> <span>start</span><span>;</span>
<span>}</span>

<span>function</span> <span>streamStock</span><span>(</span><span>ticker</span><span>)</span> <span>{</span>
  <span>return</span> <span>multiplex</span><span>(</span><span>{</span>
    <span>startMsg</span>: <span>{</span> ticker<span>,</span> <span>type</span>: <span>&#39;sub&#39;</span> <span>}</span><span>,</span>
    <span>stopMsg</span>: <span>{</span> ticker<span>,</span> <span>type</span>: <span>&#39;unsub&#39;</span> <span>}</span><span>,</span>
    <span>match</span>: <span>(</span><span>data</span><span>)</span> <span>=&gt;</span> <span>data</span><span>.</span><span>ticker</span> <span>===</span> <span>ticker</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>googTrades</span> <span>=</span> <span>streamStock</span><span>(</span><span>&#39;GOOG&#39;</span><span>)</span><span>;</span>
<span>const</span> <span>nflxTrades</span> <span>=</span> <span>streamStock</span><span>(</span><span>&#39;NFLX&#39;</span><span>)</span><span>;</span>

<span>const</span> <span>unsubGoogTrades</span> <span>=</span> <span>googTrades</span><span>(</span><span>updateView</span><span>)</span><span>;</span>
<span>const</span> <span>unsubNflxTrades</span> <span>=</span> <span>nflxTrades</span><span>(</span><span>updateView</span><span>)</span><span>;</span>

<span>// And the stream can disconnect later, which</span>
<span>// automatically sends the unsubscription message</span>
<span>// to the server.</span>
<span>unsubGoogTrades</span><span>(</span><span>)</span><span>;</span></pre></div>
</details>
<h4 tabindex="-1" dir="auto"><a id="user-content-example-6" aria-hidden="true" href="#example-6"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example 6</h4>
<p dir="auto">Here we&#39;re leveraging observables to match a secret code, which is a pattern of
keys the user might hit while using an app:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const pattern = [
  &#39;ArrowUp&#39;,
  &#39;ArrowUp&#39;,
  &#39;ArrowDown&#39;,
  &#39;ArrowDown&#39;,
  &#39;ArrowLeft&#39;,
  &#39;ArrowRight&#39;,
  &#39;ArrowLeft&#39;,
  &#39;ArrowRight&#39;,
  &#39;b&#39;,
  &#39;a&#39;,
  &#39;b&#39;,
  &#39;a&#39;,
  &#39;Enter&#39;,
];

const keys = document.on(&#39;keydown&#39;).map((e) =&gt; e.key);
keys
  .flatMap((firstKey) =&gt; {
    if (firstKey === pattern[0]) {
      return keys
        .take(pattern.length - 1)
        .every((k, i) =&gt; k === pattern[i + 1]);
    }
  })
  .filter(matched =&gt; matched)
  .subscribe({next: _ =&gt; {
    console.log(&#39;Secret code matched!&#39;);
  }});"><pre><span>const</span> <span>pattern</span> <span>=</span> <span>[</span>
  <span>&#39;ArrowUp&#39;</span><span>,</span>
  <span>&#39;ArrowUp&#39;</span><span>,</span>
  <span>&#39;ArrowDown&#39;</span><span>,</span>
  <span>&#39;ArrowDown&#39;</span><span>,</span>
  <span>&#39;ArrowLeft&#39;</span><span>,</span>
  <span>&#39;ArrowRight&#39;</span><span>,</span>
  <span>&#39;ArrowLeft&#39;</span><span>,</span>
  <span>&#39;ArrowRight&#39;</span><span>,</span>
  <span>&#39;b&#39;</span><span>,</span>
  <span>&#39;a&#39;</span><span>,</span>
  <span>&#39;b&#39;</span><span>,</span>
  <span>&#39;a&#39;</span><span>,</span>
  <span>&#39;Enter&#39;</span><span>,</span>
<span>]</span><span>;</span>

<span>const</span> <span>keys</span> <span>=</span> <span>document</span><span>.</span><span>on</span><span>(</span><span>&#39;keydown&#39;</span><span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>e</span><span>.</span><span>key</span><span>)</span><span>;</span>
<span>keys</span>
  <span>.</span><span>flatMap</span><span>(</span><span>(</span><span>firstKey</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>firstKey</span> <span>===</span> <span>pattern</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>{</span>
      <span>return</span> <span>keys</span>
        <span>.</span><span>take</span><span>(</span><span>pattern</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>)</span>
        <span>.</span><span>every</span><span>(</span><span>(</span><span>k</span><span>,</span> <span>i</span><span>)</span> <span>=&gt;</span> <span>k</span> <span>===</span> <span>pattern</span><span>[</span><span>i</span> <span>+</span> <span>1</span><span>]</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span>
  <span>.</span><span>filter</span><span>(</span><span>matched</span> <span>=&gt;</span> <span>matched</span><span>)</span>
  <span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>_</span> <span>=&gt;</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;Secret code matched!&#39;</span><span>)</span><span>;</span>
  <span>}</span><span>}</span><span>)</span><span>;</span></pre></div>
<details>
<summary>Imperative version</summary>
<div dir="auto" data-snippet-clipboard-copy-content="const pattern = [...];

// Imperative
document.addEventListener(&#39;keydown&#39;, e =&gt; {
  const key = e.key;
  if (key === pattern[0]) {
    let i = 1;
    const handler = (e) =&gt; {
      const nextKey = e.key;
      if (nextKey !== pattern[i++]) {
        document.removeEventListener(&#39;keydown&#39;, handler)
      } else if (pattern.length === i) {
        console.log(&#39;Secret code matched!&#39;);
        document.removeEventListener(&#39;keydown&#39;, handler)
      }
    }
    document.addEventListener(&#39;keydown&#39;, handler)
  }
})"><pre><span>const</span> <span>pattern</span> <span>=</span> <span>[</span>...<span>]</span><span>;</span>

<span>// Imperative</span>
<span>document</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span> <span>e</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>key</span> <span>=</span> <span>e</span><span>.</span><span>key</span><span>;</span>
  <span>if</span> <span>(</span><span>key</span> <span>===</span> <span>pattern</span><span>[</span><span>0</span><span>]</span><span>)</span> <span>{</span>
    <span>let</span> <span>i</span> <span>=</span> <span>1</span><span>;</span>
    <span>const</span> <span>handler</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>const</span> <span>nextKey</span> <span>=</span> <span>e</span><span>.</span><span>key</span><span>;</span>
      <span>if</span> <span>(</span><span>nextKey</span> <span>!==</span> <span>pattern</span><span>[</span><span>i</span><span>++</span><span>]</span><span>)</span> <span>{</span>
        <span>document</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span> <span>handler</span><span>)</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>pattern</span><span>.</span><span>length</span> <span>===</span> <span>i</span><span>)</span> <span>{</span>
        <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;Secret code matched!&#39;</span><span>)</span><span>;</span>
        <span>document</span><span>.</span><span>removeEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span> <span>handler</span><span>)</span>
      <span>}</span>
    <span>}</span>
    <span>document</span><span>.</span><span>addEventListener</span><span>(</span><span>&#39;keydown&#39;</span><span>,</span> <span>handler</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span></pre></div>
</details>
<h3 tabindex="-1" dir="auto"><a id="user-content-the-observable-api" aria-hidden="true" href="#the-observable-api"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>The <code>Observable</code> API</h3>
<p dir="auto">Observables are first-class objects representing composable, repeated events.
They&#39;re like Promises but for multiple events, and specifically with
<a href="#eventtarget-integration"><code>EventTarget</code> integration</a>, they are to events what
Promises are to callbacks. They can be:</p>
<ul dir="auto">
<li>Created by script or by platform APIs, and passed to anyone interested in
consuming events via <code>subscribe()</code></li>
<li>Fed to <a href="#operators">operators</a> like <code>Observable.map()</code>, to be composed &amp;
transformed without a web of nested callbacks</li>
</ul>
<p dir="auto">Better yet, the transition from event handlers <g-emoji alias="arrow_right" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png">➡️</g-emoji> Observables is simpler than
that of callbacks <g-emoji alias="arrow_right" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png">➡️</g-emoji> Promises, since Observables integrate nicely on top of
<code>EventTarget</code>, the de facto way of subscribing to events from the platform <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/EventTarget#examples" rel="nofollow">and
custom script</a>.
As a result, developers can use Observables without migrating tons of code on
the platform, since it&#39;s an easy drop-in wherever you&#39;re handling events today.</p>
<p dir="auto">The proposed API shape is as follows:</p>
<div dir="auto" data-snippet-clipboard-copy-content="partial interface EventTarget {
  Observable on(DOMString type, optional AddEventListenerOptions options);
};

// `SubscribeCallback` is where the Observable &#34;creator&#39;s&#34; code lives. It&#39;s
// called when `subscribe()` is called, to set up a new subscription.
callback SubscribeCallback = undefined (Subscriber subscriber);
callback ObserverCallback = undefined (any value);

dictionary Observer {
  ObserverCallback next;
  VoidFunction complete;
  ObserverCallback error;

  AbortSignal signal;
};

[Exposed=*]
interface Subscriber {
  undefined next(any result);
  undefined complete();
  undefined error(any error);

  readonly attribute AbortSignal signal;
};

callback Predicate = boolean (any value);

[Exposed=*]
interface Observable {
  constructor(SubscribeCallback callback);
  undefined subscribe(Observer observer);

  undefined finally(VoidFunction callback);

  // Observable-returning operators. See &#34;Operators&#34; section below.
  // TODO: Use more specific callback types than `Function`.
  Observable takeUntil(Observable notifier);
  Observable map(Function project);
  Observable filter(Predicate predicate);
  Observable take(unsigned long long);
  Observable drop(unsigned long long);
  Observable flatMap(Function project);
  Observable toArray();
  Observable forEach(Function callback);

  // Promise-returning. See &#34;Concerns&#34; section below.
  Promise&lt;any&gt; every(Predicate predicate);
  // Maybe? Promise&lt;any&gt; first();
  Promise&lt;any&gt; find(Predicate predicate);
  Promise&lt;any&gt; some(Predicate predicate);
  Promise&lt;any&gt; reduce(Function accumulator, optional any);
};"><pre><span>partial</span> <span>interface</span> <span>EventTarget</span> <span>{</span>
  <span>Observable</span> <span>on</span><span>(</span><span>DOMString</span> <span>type</span><span>,</span> <span>optional</span> <span>AddEventListenerOptions</span> <span>options</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>// `SubscribeCallback` is where the Observable &#34;creator&#39;s&#34; code lives. It&#39;s</span>
<span>// called when `subscribe()` is called, to set up a new subscription.</span>
<span>callback</span><span></span> <span>SubscribeCallback</span> <span>=</span> <span>undefined</span> <span>(</span><span>Subscriber</span> <span>subscriber</span><span>)</span><span>;</span>
<span>callback</span><span></span> <span>ObserverCallback</span> <span>=</span> <span>undefined</span> <span>(</span><span>any</span> <span>value</span><span>)</span><span>;</span>

<span>dictionary</span> <span>Observer</span> <span>{</span>
  <span>ObserverCallback</span> <span>next</span><span>;</span>
  <span>VoidFunction</span> <span>complete</span><span>;</span>
  <span>ObserverCallback</span> <span>error</span><span>;</span>

  <span>AbortSignal</span> <span>signal</span><span>;</span>
<span>}</span><span>;</span>

<span>[</span><span>Exposed</span><span>=</span><span>*</span><span>]</span>
<span>interface</span> <span>Subscriber</span> <span>{</span>
  <span>undefined</span> <span>next</span><span>(</span><span>any</span> <span>result</span><span>)</span><span>;</span>
  <span>undefined</span> <span>complete</span><span>(</span><span>)</span><span>;</span>
  <span>undefined</span> <span>error</span><span>(</span><span>any</span> <span>error</span><span>)</span><span>;</span>

  <span>readonly</span> <span>attribute</span> <span>AbortSignal</span> <span>signal</span><span>;</span>
<span>}</span><span>;</span>

<span>callback</span> <span>Predicate</span> <span>=</span> <span>boolean</span> <span>(</span><span>any</span> <span>value</span><span>)</span><span>;</span>

<span>[</span><span>Exposed</span><span>=</span><span>*</span><span>]</span>
<span>interface</span> <span>Observable</span> <span>{</span>
  <span>constructor</span><span>(</span><span>SubscribeCallback</span> <span>callback</span><span>)</span><span>;</span>
  <span>undefined</span> <span>subscribe</span><span>(</span><span>Observer</span> <span>observer</span><span>)</span><span>;</span>

  <span>undefined</span> <span>finally</span><span>(</span><span>VoidFunction</span> <span>callback</span><span>)</span><span>;</span>

  <span>// Observable-returning operators. See &#34;Operators&#34; section below.</span>
  <span>// TODO: Use more specific callback types than `Function`.</span>
  <span>Observable</span> <span>takeUntil</span><span>(</span><span>Observable</span> <span>notifier</span><span>)</span><span>;</span>
  <span>Observable</span> <span>map</span><span>(</span><span>Function</span> <span>project</span><span>)</span><span>;</span>
  <span>Observable</span> <span>filter</span><span>(</span><span>Predicate</span> <span>predicate</span><span>)</span><span>;</span>
  <span>Observable</span> <span>take</span><span>(</span><span>unsigned</span> <span>long</span> <span>long</span><span>)</span><span>;</span>
  <span>Observable</span> <span>drop</span><span>(</span><span>unsigned</span> <span>long</span> <span>long</span><span>)</span><span>;</span>
  <span>Observable</span> <span>flatMap</span><span>(</span><span>Function</span> <span>project</span><span>)</span><span>;</span>
  <span>Observable</span> <span>toArray</span><span>(</span><span>)</span><span>;</span>
  <span>Observable</span> <span>forEach</span><span>(</span><span>Function</span> <span>callback</span><span>)</span><span>;</span>

  <span>// Promise-returning. See &#34;Concerns&#34; section below.</span>
  <span>Promise</span><span>&lt;</span><span>any</span><span>&gt;</span> <span>every</span><span>(</span><span>Predicate</span> <span>predicate</span><span>)</span><span>;</span>
  <span>// Maybe? Promise&lt;any&gt; first();</span>
  <span>Promise</span><span>&lt;</span><span>any</span><span>&gt;</span> <span>find</span><span>(</span><span>Predicate</span> <span>predicate</span><span>)</span><span>;</span>
  <span>Promise</span><span>&lt;</span><span>any</span><span>&gt;</span> <span>some</span><span>(</span><span>Predicate</span> <span>predicate</span><span>)</span><span>;</span>
  <span>Promise</span><span>&lt;</span><span>any</span><span>&gt;</span> <span>reduce</span><span>(</span><span>Function</span> <span>accumulator</span><span>,</span> <span>optional</span> <span>any</span><span>)</span><span>;</span>
<span>}</span><span>;</span></pre></div>
<p dir="auto">The creator of an Observable passes in a callback that gets invoked
synchronously whenever <code>subscribe()</code> is called. The <code>subscribe()</code> method can be
called <em>any number of times</em>, and the callback it invokes sets up a new
&#34;subscription&#34; by registering the caller of <code>subscribe()</code> as a Observer. With
this in place, the Observable can signal any number of events to the Observer
via the <code>next()</code> callback, optionally followed by a single call to either
<code>complete()</code> or <code>error()</code>, signaling that the stream of data is finished.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const observable = new Observable(subscriber =&gt; {
  let i = 0;
  setInterval(() =&gt; {
    if (i &gt;= 10)
      subscriber.complete();
    else
      subscriber.next(i++);
  }, 2000);
});

observable.subscribe({
  // Print each value the Observable produces.
  next: console.log
});"><pre><span>const</span> <span>observable</span> <span>=</span> <span>new</span> <span>Observable</span><span>(</span><span>subscriber</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
  <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>if</span> <span>(</span><span>i</span> <span>&gt;=</span> <span>10</span><span>)</span>
      <span>subscriber</span><span>.</span><span>complete</span><span>(</span><span>)</span><span>;</span>
    <span>else</span>
      <span>subscriber</span><span>.</span><span>next</span><span>(</span><span>i</span><span>++</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>observable</span><span>.</span><span>subscribe</span><span>(</span><span>{</span>
  <span>// Print each value the Observable produces.</span>
  <span>next</span>: <span>console</span><span>.</span><span>log</span>
<span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto"><strong>Issue</strong>: See <a data-error-text="Failed to load title" data-id="1630551881" data-permission-text="Title is private" data-url="https://github.com/domfarolino/observable/issues/3" data-hovercard-type="issue" data-hovercard-url="/domfarolino/observable/issues/3/hovercard" href="https://github.com/domfarolino/observable/issues/3">#3</a> about having
the Observable constructor being able to register teardown upon unsubscription.</p>
<p dir="auto">While custom Observables can be useful on their own, the primary use case they
unlock is with event handling. Observables returned by the new
<code>EventTarget#on()</code> method are created natively with an internal callback that
uses the same <a href="https://dom.spec.whatwg.org/#add-an-event-listener" rel="nofollow">underlying
mechanism</a> as
<code>addEventListener()</code>. Therefore calling <code>subscribe()</code> essentially registers a
new event listener whose events are exposed through the Observer handler
functions and are composable with the various
<a href="#operators">combinators</a> available to all Observables.</p>
<h4 tabindex="-1" dir="auto"><a id="user-content-lazy-synchronous-delivery" aria-hidden="true" href="#lazy-synchronous-delivery"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Lazy, synchronous delivery</h4>
<p dir="auto">Crucially, Observables are &#34;lazy&#34; in that they do not start emitting data until
they are subscribed to, nor do they queue any data <em>before</em> subscription. They
can also start emitting data synchronously during subscription, unlike Promises
which always queue microtasks when invoking <code>.then()</code> handlers. Consider this
<a href="https://github.com/whatwg/dom/issues/544#issuecomment-351758385" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">example</a>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="el.on(&#39;click&#39;).subscribe({next: () =&gt; console.log(&#39;One&#39;)});
el.on(&#39;click&#39;).find(() =&gt; {…}).then(() =&gt; console.log(&#39;Three&#39;));
el.click();
console.log(&#39;Two&#39;);
// Logs &#34;One&#34; &#34;Two&#34; &#34;Three&#34;"><pre><span>el</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span><span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;One&#39;</span><span>)</span><span>}</span><span>)</span><span>;</span>
<span>el</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span><span>.</span><span>find</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span><span>…</span><span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;Three&#39;</span><span>)</span><span>)</span><span>;</span>
<span>el</span><span>.</span><span>click</span><span>(</span><span>)</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;Two&#39;</span><span>)</span><span>;</span>
<span>// Logs &#34;One&#34; &#34;Two&#34; &#34;Three&#34;</span></pre></div>
<h4 tabindex="-1" dir="auto"><a id="user-content-firehose-of-synchronous-data" aria-hidden="true" href="#firehose-of-synchronous-data"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Firehose of synchronous data</h4>
<p dir="auto">By using <code>AbortController</code>, you can unsubscribe from an Observable even as it
synchronously emits data <em>during</em> subscription:</p>
<div dir="auto" data-snippet-clipboard-copy-content="// An observable that synchronously emits unlimited data during subscription.
let observable = new Observable(subscriber =&gt; {
  let i = 0;
  while (true) {
    subscriber.next(i++);
  }
});

let controller = new AbortController();
observable.subscribe({next: data =&gt; {
  if (data &gt; 100)
    controller.abort();
}, signal: controller.signal});"><pre><span>// An observable that synchronously emits unlimited data during subscription.</span>
<span>let</span> <span>observable</span> <span>=</span> <span>new</span> <span>Observable</span><span>(</span><span>subscriber</span> <span>=&gt;</span> <span>{</span>
  <span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>subscriber</span><span>.</span><span>next</span><span>(</span><span>i</span><span>++</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

<span>let</span> <span>controller</span> <span>=</span> <span>new</span> <span>AbortController</span><span>(</span><span>)</span><span>;</span>
<span>observable</span><span>.</span><span>subscribe</span><span>(</span><span>{</span><span>next</span>: <span>data</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>data</span> <span>&gt;</span> <span>100</span><span>)</span>
    <span>controller</span><span>.</span><span>abort</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>signal</span>: <span>controller</span><span>.</span><span>signal</span><span>}</span><span>)</span><span>;</span></pre></div>
<h3 tabindex="-1" dir="auto"><a id="user-content-operators" aria-hidden="true" href="#operators"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Operators</h3>
<p dir="auto">We propose the following operators in addition to the <code>Observable</code> interface:</p>
<ul dir="auto">
<li><code>takeUntil(Observable)</code>
<ul dir="auto">
<li>Returns an observable that mirrors the one that this method is called on,
until the input observable emits its first value</li>
</ul>
</li>
<li><code>finally()</code>
<ul dir="auto">
<li>Like <code>Promise.finally()</code>, it takes a callback which gets fired after the
observable completes in any way (<code>done()</code>/<code>error()</code>)</li>
</ul>
</li>
</ul>
<p dir="auto">Versions of the above are often present in userland implementations of
observables as they are useful for observable-specific reasons, but in addition
to these we offer a set of common operators that follow existing platform
precedent and can greatly increase utility and adoption. These exist on other
iterables, and are derived from TC39&#39;s <a href="https://github.com/tc39/proposal-iterator-helpers">iterator helpers
proposal</a> which adds the
<a href="https://tc39.es/proposal-iterator-helpers/#sec-iteratorprototype" rel="nofollow">following
methods</a> to
<code>Iterator.prototype</code>:</p>
<ul dir="auto">
<li><code>map()</code></li>
<li><code>filter()</code></li>
<li><code>take()</code></li>
<li><code>drop()</code></li>
<li><code>flatMap()</code></li>
<li><code>reduce()</code></li>
<li><code>toArray()</code></li>
<li><code>forEach()</code></li>
<li><code>some()</code></li>
<li><code>every()</code></li>
<li><code>find()</code></li>
<li>maybe: <code>from()</code><sup><a href="#user-content-fn-1-d721e2e0af89241489ea510ae4d065c7" id="user-content-fnref-1-d721e2e0af89241489ea510ae4d065c7" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup></li>
</ul>
<p dir="auto">We expect userland libraries to provide more niche operators that integrate with
the <code>Observable</code> API central to this proposal, potentially shipping natively if
they get enough momentum to graduate to the platform. But for this initial
proposal, we&#39;d like to restrict the set of operators to those that follow the
precedent stated above, similar to how web platform APIs that are declared
<a href="https://webidl.spec.whatwg.org/#es-setlike" rel="nofollow">Setlike</a> and
<a href="https://webidl.spec.whatwg.org/#es-maplike" rel="nofollow">Maplike</a> have native properties
inspired by TC39&#39;s
<a href="https://tc39.es/ecma262/#sec-properties-of-the-map-prototype-object" rel="nofollow">Map</a> and
<a href="https://tc39.es/ecma262/#sec-properties-of-the-set-prototype-object" rel="nofollow">Set</a>
objects. Therefore we&#39;d consider most discussion of expanding this set as
out-of-scope for the <em>initial</em> proposal, suitable for discussion in an appendix.
Any long tail of operators could <em>conceivably</em> follow along if there is support
for the native Observable API presented in this explainer.</p>
<p dir="auto">Note that the operators <code>every()</code>, <code>find()</code>, <code>some()</code>, and <code>reduce()</code> return
Promises whose scheduling differs from that of Observables, which sometimes
means event handlers that call <code>e.preventDefault()</code> will run too late. See the
<a href="#concerns">Concerns</a> section which goes into more detail.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-background--landscape" aria-hidden="true" href="#background--landscape"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Background &amp; landscape</h2>
<p dir="auto">To illustrate how Observables fit into the current landscape of other reactive
primitives, see the below table which is an attempt at combining
<a href="https://github.com/kriskowal/gtor#a-general-theory-of-reactivity">two</a>
other <a href="https://rxjs.dev/guide/observable" rel="nofollow">tables</a> that classify reactive
primitives by their interaction with producers &amp; consumers:</p>
<table>
  <thead>
    <tr>
      <th></th>
      <th colspan="2">Singular</th>
      <th colspan="2">Plural</th>
    </tr>
    <tr>
      <th>
      </th><th>Spatial</th>
      <th>Temporal</th>
      <th>Spatial</th>
      <th>Temporal</th>
    </tr>
  </thead>
 <tbody>
    <tr>
      <th>Push</th>
      <td>Value</td>
      <td>Promise</td>
      <td colspan="2">Observable</td>
    </tr>
    <tr>
      <th>Pull</th>
      <td>Function</td>
      <td>Async iterator</td>
      <td>Iterable</td>
      <td>Async iterator</td>
    </tr>
  </tbody>
</table>
<h3 tabindex="-1" dir="auto"><a id="user-content-history" aria-hidden="true" href="#history"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>History</h3>
<p dir="auto">Observables were first proposed to the platform in <a href="https://github.com/tc39/proposal-observable">TC39</a>
in May of 2015. The proposal failed to gain traction, in part due to some opposition that
the API was suitable to be a language-level primitive. In an attempt to renew the proposal
at a higher level of abstraction, a WHATWG <a href="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">DOM issue</a> was
filed in December of 2017. Despite ample <a href="https://foolip.github.io/spec-reactions/" rel="nofollow">developer demand</a>,
<em>lots</em> of discussion, and no strong objectors, the DOM Observables proposal sat mostly still for several
years (with some flux in the API design) due to a lack of implementer prioritization.</p>
<p dir="auto">Later in 2019, <a href="https://github.com/tc39/proposal-observable/issues/201" data-hovercard-type="issue" data-hovercard-url="/tc39/proposal-observable/issues/201/hovercard">an attempt</a> at reviving the
proposal was made back at the original TC39 repository, which involved some API simplifications and
added support for the synchronous &#34;firehose&#34; problem.</p>
<p dir="auto">This repository is an attempt to again breath life into the Observable proposal with the hope
of shipping a version of it to the Web Platform.</p>
<h3 tabindex="-1" dir="auto"><a id="user-content-userland-libraries" aria-hidden="true" href="#userland-libraries"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Userland libraries</h3>
<p dir="auto">In <a href="https://github.com/whatwg/dom/issues/544#issuecomment-1433955626" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">prior discussion</a>,
<a href="https://github.com/benlesh">Ben Lesh</a> has listed several custom userland implementations of
observable primitives, of which RxJS is the most popular with &#34;47,000,000+ downloads <em>per week</em>.&#34;</p>
<ul dir="auto">
<li><a href="https://github.com/ReactiveX/rxjs/blob/9ddc27dd60ac23e95b2503716ae8013e64275915/src/internal/Observable.ts#L10">RxJS</a>: Started as a reference implementation of the TC39 proposal, is nearly identical to this proposal&#39;s observable.</li>
<li><a href="https://github.com/facebook/relay/blob/af8a619d7f61ea6e2e26dd4ac4ab1973d68e6ff9/packages/relay-runtime/network/RelayObservable.js">Relay</a>: A mostly identical contract with the addition of <code>start</code> and <code>unsubscribe</code> events for observation and acquiring the <code>Subscription</code> prior to the return.</li>
<li><a href="https://github.com/trpc/trpc/blob/21bcb5e6723023d3acb0b836b63627922407c682/packages/server/src/observable/observable.ts">tRPC</a>: A nearly identical implemention of observable to this proposal.</li>
<li><a href="https://github.com/statelyai/xstate/blob/754afa022047518ef4813f7aa85398218b39f960/packages/core/src/types.ts#L1711C19-L1737">XState</a>: uses an observable interface in several places in their library, in particular for their <code>Actor</code> type, to allow <a href="https://github.com/statelyai/xstate/blob/754afa022047518ef4813f7aa85398218b39f960/packages/xstate-solid/src/useActor.ts#L47-L51">subscriptions to changes in state, as shown in their <code>useActor</code> hook</a>. Using an identical observable is also a <a href="https://github.com/statelyai/xstate/blob/754afa022047518ef4813f7aa85398218b39f960/packages/xstate-solid/README.md?plain=1#L355-L368">documented part</a> of access state machine changes when using XState with SolidJS.</li>
<li><a href="https://github.com/solidjs/solid/blob/46e5e78710cdd9f170a7afd0ddc5311676d3532a/packages/solid/src/reactive/observable.ts#L46">SolidJS</a>: An identical interface to this proposal is exposed for users to use.</li>
<li><a href="https://github.com/apollographql/apollo-client/blob/a1dac639839ffc5c2de332db2ee4b29bb0723815/src/utilities/observables/Observable.ts">Apollo GraphQL</a>: Actually re-exporting from <a href="https://github.com/zenparsing/es-observable">zen-observable</a> as <a href="https://github.com/apollographql/apollo-client/blob/a1dac639839ffc5c2de332db2ee4b29bb0723815/src/core/index.ts#L76">their own thing</a>, giving some freedom to reimplement on their own or pivot to something like RxJS observable at some point.</li>
<li><a href="https://github.com/zenparsing/zen-observable/tree/8406a7e3a3a3faa080ec228b9a743f48021fba8b">zen-observable</a>: A reference implementation of the TC39 observable proposal. Nearly identical to this proposal.</li>
<li><a href="https://github.com/remix-run/react-router/tree/610ce6edf0993384300ff3172fc6db00ead50d33">React Router</a>: Uses a <code>{ subscribe(callback: (value: T) =&gt; void): () =&gt; void }</code> pattern in their <a href="https://github.com/remix-run/react-router/blob/610ce6edf0993384300ff3172fc6db00ead50d33/packages/router/router.ts#L931">Router</a> and <a href="https://github.com/remix-run/react-router/blob/610ce6edf0993384300ff3172fc6db00ead50d33/packages/router/utils.ts#L1338">DeferredData</a> code. This was pointed out by maintainers as being inspired by Observable.</li>
<li><a href="https://github.com/preactjs/preact/blob/ac1f145877a74e49f4c341e6acbf888a96e60afe/src/jsx.d.ts#LL69C1-L73C3">Preact</a> Uses a <code>{ subscribe(callback: (value: T) =&gt; void): () =&gt; void }</code> interface for their signals.</li>
<li><a href="https://github.com/TanStack/query/blob/878d85e44c984822e2e868af94003ec260ddf80f/packages/query-core/src/subscribable.ts">TanStack</a>: Uses a subscribable interface that matches <code>{ subscribe(callback: (value: T) =&gt; void): () =&gt; void }</code> in <a href="https://github.com/search?q=repo%3ATanStack/query%20Subscribable&amp;type=code">several places</a></li>
<li><a href="https://github.com/reduxjs/redux/blob/c2b9785fa78ad234c4116cf189877dbab38e7bac/src/createStore.ts#LL344C12-L344C22">Redux</a>: Implements an observable that is nearly identical to this proposal&#39;s observable as a means of subscribing to changes to a store.</li>
<li><a href="https://github.com/sveltejs/svelte">Svelte</a>: Supports <a href="https://github.com/sveltejs/svelte/blob/3bc791bcba97f0810165c7a2e215563993a0989b/src/runtime/internal/utils.ts#L69">subscribing</a> to observables that fit this exact contract, and also exports and uses a <a href="https://github.com/sveltejs/svelte/blob/3bc791bcba97f0810165c7a2e215563993a0989b/src/runtime/store/index.ts">subscribable contract for stores</a> like <code>{ subscribe(callback: (value: T) =&gt; void): () =&gt; void }</code>.</li>
<li><a href="https://github.com/dexie/Dexie.js">Dexis.js</a>: Has an <a href="https://github.com/solidjs/solid/blob/46e5e78710cdd9f170a7afd0ddc5311676d3532a/packages/solid/src/reactive/observable.ts#L46">observable implementation</a> that is used for creating <a href="https://github.com/dexie/Dexie.js/blob/bf9004b26228e43de74f7c1fa7dd60bc9d785e8d/src/live-query/live-query.ts#L36">live queries</a> to IndexedDB.</li>
<li><a href="https://github.com/mobxjs/mobx">MobX</a>: Uses <a href="https://github.com/mobxjs/mobx/blob/7cdc7ecd6947a6da10f10d2e4a1305297b816007/packages/mobx/src/types/observableobject.ts#L583">similar interface</a> to Observable internally for observation: <code>{ observe_(callback: (value: T)): () =&gt; void }</code>.</li>
</ul>
<h3 tabindex="-1" dir="auto"><a id="user-content-ui-frameworks-supporting-observables" aria-hidden="true" href="#ui-frameworks-supporting-observables"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>UI Frameworks Supporting Observables</h3>
<ul dir="auto">
<li><a href="https://github.com/sveltejs/svelte">Svelte</a>: Directly supports implicit subscription and unsubscription to observables simply by binding to them in templates.</li>
<li><a href="https://github.com/angular/angular">Angular</a>: Directly supports implicit subscription and unsubscription to observables using their <code>| async</code> &#34;async pipe&#34; functionality in templates.</li>
<li><a href="https://github.com/vuejs/vuejs">Vue</a>: maintains a <a href="https://github.com/vuejs/vue-rx">dedicated library</a> specifically for using Vue with RxJS observables.</li>
<li><a href="https://github.com/cyclejs/cyclejs">Cycle.js</a>: A UI framework built entirely around observables</li>
</ul>
<p dir="auto">Given the extensive prior art in this area, there exists a public
&#34;<a href="https://reactivex.io/documentation/contract.html" rel="nofollow">Observable Contract</a>&#34;.</p>
<p dir="auto">Additionally many JavaScript APIs been trying to adhere to the contract defined by the <a href="https://github.com/tc39/proposal-observable">TC39 proposal from 2015</a>.
To that end, there is a library, <a href="https://www.npmjs.com/package/symbol-observable?activeTab=dependents" rel="nofollow">symbol-observable</a>,
that ponyfills (polyfills) <code>Symbol.observable</code> to help with interoperability between observable types that adheres to exactly
the interface defined here. <code>symbol-observable</code> has 479 dependent packages on npm, and is downloaded more than 13,000,000 times
per week. This means that there are a minimum of 479 packages on npm that are using the observable contract in some way.</p>
<p dir="auto">This is similar to how <a href="https://promisesaplus.com/" rel="nofollow">Promises/A+</a> specification that was developed before <code>Promise</code>s were
adopted into ES2015 as a first-class language primitive.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-concerns" aria-hidden="true" href="#concerns"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Concerns</h2>
<p dir="auto">One of the main <a href="https://github.com/whatwg/dom/issues/544#issuecomment-351443624" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">concerns</a>
expressed in the original WHATWG DOM thread has to do with Promise-ifying APIs on Observable,
such as the proposed <code>first()</code>. The potential footgun here with microtask scheduling and event
integration. Specifically, the following innocent-looking code would not <em>always</em> work:</p>
<div dir="auto" data-snippet-clipboard-copy-content="element.on(&#39;click&#39;).first.then(e =&gt; {
  e.preventDefault();
  // Do something custom...
});"><pre><span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span><span>.</span><span>first</span><span>.</span><span>then</span><span>(</span><span>e</span> <span>=&gt;</span> <span>{</span>
  <span>e</span><span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
  <span>// Do something custom...</span>
<span>}</span><span>)</span><span>;</span></pre></div>
<p dir="auto">If <code>Observable#first()</code> returns a Promise that resolves when the first event is fired on an
<code>EventTarget</code>, then the user-supplied Promise <code>.then()</code> handler will run:</p>
<ul dir="auto">
<li><g-emoji alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png">✅</g-emoji> Synchronously after event firing, for events triggered by the user</li>
<li><g-emoji alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png">❌</g-emoji> Asynchronously after event firing, for all events triggered by script (i.e., <code>element.click()</code>)
<ul dir="auto">
<li>This means <code>e.preventDefault()</code> will have happened too late and effectively been ignored</li>
</ul>
</li>
</ul>
<details>
To understand why this is the case, you must understand how and when the microtask queue is flushed
(and thus how microtasks, including Promise resolution handlers, are invoked).
<p dir="auto">In WebIDL after a callback is invoked, the HTML algorithm
<em><a href="https://html.spec.whatwg.org/C#clean-up-after-running-script" rel="nofollow">clean up after running script</a></em>
<a href="https://webidl.spec.whatwg.org/#ref-for-clean-up-after-running-script%E2%91%A0" rel="nofollow">is called</a>, and
this algorithm calls <em><a href="https://html.spec.whatwg.org/C#perform-a-microtask-checkpoint" rel="nofollow">perform a microtask checkpoint</a></em>
if and only if the JavaScript stack is empty.</p>
<p dir="auto">Concretely, that means for <code>element.click()</code> in the above example, the following steps occur:</p>
<ol dir="auto">
<li>To run <code>element.click()</code>, a JavaScript execution context is first pushed onto the stack</li>
<li>To run the internal <code>click</code> event listener callback (the one created natively by the
<code>Observable#from()</code> implementation), <em>another</em> JavaScript execution context is pushed onto
the stack, as WebIDL prepares to run the internal callback</li>
<li>The internal callback runs, which immediately resolves the Promise returned by <code>Observable#first()</code>;
now the microtask queue contains the Promise&#39;s user-supplied <code>then()</code> handler which will cancel
the event once it runs</li>
<li>The top-most execution context is removed from the stack, and the microtask queue <strong>cannot be
flushed</strong>, because there is still JavaScript on the stack.</li>
<li>After the internal <code>click</code> event callback is executed, the rest of the event path continues since
event was not canceled during or immediately after the callback. The event does whatever it would
normally do (submit the form, <code>alert()</code> the user, etc.)</li>
<li>Finally, the JavaScript containing <code>element.click()</code> is finished, and the final execution context
is popped from the stack and the microtask queue is flushed. The user-supplied <code>.then()</code> handler
is run, which attempts to cancel the event too late</li>
</ol>
</details>
<p dir="auto">Two things mitigate this concern. First, there is a very simple workaround to <em>always</em> avoid the
case where your <code>e.preventDefault()</code> might run too late:</p>
<div dir="auto" data-snippet-clipboard-copy-content="element.on(&#39;click&#39;).map(e =&gt; (e.preventDefault(), e)).first()"><pre><span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span><span>.</span><span>map</span><span>(</span><span>e</span> <span>=&gt;</span> <span>(</span><span>e</span><span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>,</span> <span>e</span><span>)</span><span>)</span><span>.</span><span>first</span><span>(</span><span>)</span></pre></div>
<p dir="auto">...or if Observable had a <code>.do()</code> method (see <a data-error-text="Failed to load title" data-id="281633681" data-permission-text="Title is private" data-url="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard?comment_id=351457179&amp;comment_type=issue_comment" href="https://github.com/whatwg/dom/issues/544#issuecomment-351457179">whatwg/dom#544 (comment)</a>):</p>
<div dir="auto" data-snippet-clipboard-copy-content="element.on(&#39;click&#39;).do(e =&gt; e.preventDefault()).first()"><pre><span>element</span><span>.</span><span>on</span><span>(</span><span>&#39;click&#39;</span><span>)</span><span>.</span><span>do</span><span>(</span><span>e</span> <span>=&gt;</span> <span>e</span><span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>)</span><span>.</span><span>first</span><span>(</span><span>)</span></pre></div>
<p dir="auto">...or by <a href="https://github.com/whatwg/dom/issues/544#issuecomment-351779661" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard">modifying</a> the semantics of
<code>first()</code> to take a callback that produces a value that the returned Promise resolves to:</p>
<div dir="auto" data-snippet-clipboard-copy-content="el.on(&#34;submit&#34;).first(e =&gt; e.preventDefault()).then(doMoreStuff)"><pre><span>el</span><span>.</span><span>on</span><span>(</span><span>&#34;submit&#34;</span><span>)</span><span>.</span><span>first</span><span>(</span><span>e</span> <span>=&gt;</span> <span>e</span><span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>)</span><span>.</span><span>then</span><span>(</span><span>doMoreStuff</span><span>)</span></pre></div>
<p dir="auto">Second, this &#34;quirk&#34; already exists in today&#39;s thriving Observable ecosystem, and there are no serious
concerns or reports from that community that developers are consistently running into this. This gives
some confidence that baking this behavior into the web platform will not be dangerous.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-standards-venue" aria-hidden="true" href="#standards-venue"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Standards venue</h2>
<p dir="auto">There&#39;s been much discussion about which standards venue should ultimately host an Observables
proposal. The venue is not inconsequential, as it effectively decides whether Observables becomes a
language-level primitive like <code>Promise</code>s, that ship in all JavaScript browser engines, or a web platform
primitive with <em>optional</em> consideration in other environments like Node.js (see <a href="https://nodejs.org/api/globals.html#class-abortcontroller" rel="nofollow"><code>AbortController</code></a> for example).</p>
<p dir="auto">In previous discussion it had been decided that <a href="https://github.com/whatwg/dom">WHATWG DOM Standard</a>
is the right home for Observables due to its integration with the web platform event <a href="#this">event system</a> and
lack of new syntax or language capabilities. In attempt to avoid relitigating this discussion, we&#39;d urge the
reader to see the following discussion comments:</p>
<ul dir="auto">
<li><a data-error-text="Failed to load title" data-id="281633681" data-permission-text="Title is private" data-url="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard?comment_id=351520728&amp;comment_type=issue_comment" href="https://github.com/whatwg/dom/issues/544#issuecomment-351520728">whatwg/dom#544 (comment)</a></li>
<li><a data-error-text="Failed to load title" data-id="281633681" data-permission-text="Title is private" data-url="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard?comment_id=351561091&amp;comment_type=issue_comment" href="https://github.com/whatwg/dom/issues/544#issuecomment-351561091">whatwg/dom#544 (comment)</a></li>
<li><a data-error-text="Failed to load title" data-id="281633681" data-permission-text="Title is private" data-url="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard?comment_id=351582862&amp;comment_type=issue_comment" href="https://github.com/whatwg/dom/issues/544#issuecomment-351582862">whatwg/dom#544 (comment)</a></li>
<li><a data-error-text="Failed to load title" data-id="281633681" data-permission-text="Title is private" data-url="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard?comment_id=351607779&amp;comment_type=issue_comment" href="https://github.com/whatwg/dom/issues/544#issuecomment-351607779">whatwg/dom#544 (comment)</a></li>
<li><a data-error-text="Failed to load title" data-id="281633681" data-permission-text="Title is private" data-url="https://github.com/whatwg/dom/issues/544" data-hovercard-type="issue" data-hovercard-url="/whatwg/dom/issues/544/hovercard?comment_id=351718686&amp;comment_type=issue_comment" href="https://github.com/whatwg/dom/issues/544#issuecomment-351718686">whatwg/dom#544 (comment)</a></li>
</ul>
<h2 tabindex="-1" dir="auto"><a id="user-content-authors" aria-hidden="true" href="#authors"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Authors:</h2>
<ul dir="auto">
<li><a href="https://github.com/domfarolino">Dominic Farolino</a></li>
<li><a href="https://github.com/benlesh">Ben Lesh</a></li>
</ul>
<section data-footnotes="">
<ol dir="auto">
<li id="user-content-fn-1-d721e2e0af89241489ea510ae4d065c7">
<p dir="auto">This appears <a href="https://github.com/tc39/proposal-iterator-helpers#fromobject">in the TC39 proposal&#39;s <code>README.md</code></a> file but not the spec, so its fate is unclear. <a href="#user-content-fnref-1-d721e2e0af89241489ea510ae4d065c7" data-footnote-backref="" aria-label="Back to reference 1"><g-emoji alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji></a></p>
</li>
</ol>
</section>
</article>
          </div></div>
  </body>
</html>
