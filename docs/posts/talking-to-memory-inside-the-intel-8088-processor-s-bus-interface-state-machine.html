<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2024/04/intel-8088-bus-state-machine.html">Original</a>
    <h1>Talking to memory: Inside the Intel 8088 processor&#39;s bus interface state machine</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6532479184485643882" itemprop="description articleBody">
<p>In 1979, Intel introduced the 8088 microprocessor, a variant of the 16-bit 8086 processor.
IBM&#39;s decision to use the 8088 processor in the IBM PC (1981) was a critical point in computer history,
leading to the success of the x86 architecture.
The designers of the IBM PC selected the 8088 for multiple reasons, but a key factor was that the 8088 processor&#39;s 8-bit bus was
similar to the bus of the 8085 processor.<span id="fnref:8085"><a href="#fn:8085">1</a></span>
The designers were familiar with the 8085 since they had selected it for
the IBM System/23 Datamaster, a now-forgotten desktop computer, making
the more-powerful 8088 processor an easy choice for the IBM PC.</p>
<p>The 8088 processor communicates over the bus with memory and I/O devices through a highly-structured sequence of steps called &#34;T-states.&#34;
A typical 8088 bus cycle consists of four T-states, with one T-state per clock cycle.
Although a four-step bus cycle may sound straightforward, its implementation uses a complicated state machine making it one of the most difficult parts of
the 8088 to explain.
First, the 8088 has many special cases that complicate the bus cycle.
Moreover, the bus cycle is really six steps, with two undocumented &#34;extra&#34; steps to make bus operations more efficient.
Finally, the complexity of the bus cycle is largely arbitrary, a consequence of Intel&#39;s attempts to make the 8088&#39;s bus
backward-compatible with the earlier 8080 and 8085 processors.
However, investigating the bus cycle circuitry in detail provides insight into the timing of the processor&#39;s instructions.
In addition, this circuitry illustrates the tradeoffs and implementation decisions that are necessary in a production processor.
In this blog post, I look in detail at the circuitry that implements this state machine.</p>
<p>By examining the die of the 8088 microprocessor, I could reverse engineer the bus circuitry.
The die photo below shows the 8088 microprocessor&#39;s silicon die under a microscope.
Most visible in the photo is the metal layer on top of the chip, with the silicon and polysilicon mostly hidden underneath. Around the edges of the die, bond wires connect pads to
the chip&#39;s 40 external pins.
Architecturally, the chip is partitioned into a Bus Interface Unit (BIU) at the top
and an Execution Unit (EU) below, with the two units running largely independently.
The BIU handles bus communication (memory and I/O accesses), while the Execution Unit (EU) executes instructions.
In the diagram, I&#39;ve labeled the processor&#39;s key functional blocks.
This article focuses on the bus state machine, highlighted in red, but other parts of the Bus Interface Unit will
also play a role.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/die-labeled.jpg"><img alt="The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." height="627" src="https://static.righto.com/images/8086-bus8088/die-labeled-w600.jpg" title="The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version." width="600"/></a></p><p>The 8088 die under a microscope, with main functional blocks labeled. This photo shows the chip&#39;s single metal layer; the polysilicon and silicon are underneath. Click on this image (or any other) for a larger version.</p>
<p>Although I&#39;m focusing on the 8088 processor in this blog post, the 8086 is mostly the same.
The 8086 and 8088 processors present the same 16-bit architecture to the programmer.
The key difference is that
the 8088 has an 8-bit data bus for communication with memory and I/O, rather than the 16-bit bus of the 8086.
For the most part, the 8086 and 8088 are very similar internally, apart from trivial but numerous layout changes on the die.
In this article, I&#39;m focusing on the 8088 processor, but
most of the description applies to the 8086 as well.
Instead of constantly saying &#34;8086/8088&#34;, I&#39;ll refer to the 8088 and try to point out places where the 8086 is different.</p>
<h2>The bus cycle</h2>
<p>In this section, I&#39;ll describe the basic four-step bus cycles that the 8088 performs.<span id="fnref:io"><a href="#fn:io">2</a></span>
To start, the diagram below shows the states for a write cycle (slightly simplified<span id="fnref:timing"><a href="#fn:timing">3</a></span>), when the 8088 writes to memory or an I/O device.
The external bus activity is organized as four &#34;T-states&#34;, each one clock cycle long and called <code>T1</code>, <code>T2</code>, <code>T3</code>, and <code>T4</code>, with
specific actions during each state.
During <code>T1</code>, the 8088 outputs the address on the pins. During the <code>T2</code>, <code>T3</code>, and <code>T4</code> states, the 8088 outputs the data word on the same pins.
The external memory or I/O device uses the T states to know when it is receiving address information or data over the bus lines.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/write-cycle.jpg"><img alt="A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." height="120" src="https://static.righto.com/images/8086-bus8088/write-cycle-w600.jpg" title="A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." width="600"/></a></p><p>A typical write bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.</p>
<p>For a read, the bus cycle is slightly different from the write cycle, but uses the same four T-states.
During <code>T1</code>, the address is provided on the pins, the same as for a write.
After that, however, the processor&#39;s data pins are &#34;tri-stated&#34; so they float electrically, allowing the external memory to put data on the bus.
The processor reads the data at the end of the <code>T3</code> state.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/read-cycle.jpg"><img alt="A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." height="138" src="https://static.righto.com/images/8086-bus8088/read-cycle-w600.jpg" title="A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16." width="600"/></a></p><p>A typical read bus cycle consists of four T states. Based on The 8086 Family Users Manual, B-16.</p>
<p>The purpose of the bus state machine is to move through these four T states for a read or a write.
This process may seem straightforward, but (as is usually the case with the 8088) many complications
make this process anything but easy.
In the next sections, I&#39;ll discuss these complications.
After that, I&#39;ll explain the state machine circuitry with a schematic.</p>
<h2>Address calculation</h2>
<p>One of the notable (if not hated) features of the 8088 processor is segmentation: the processor supports 1 megabyte of memory, but
memory is partitioned into segments of 64 KB for compatibility with the earlier 8080 and 8085 processors.
The 8088 calculates each 20-bit memory address by adding the value of a segment register to a 16-bit offset.
This calculation is done by a dedicated address adder in the Bus Interface Unit, completely separate from the chip&#39;s ALU.
(This address adder can be spotted in the upper left of the earlier die photo.)</p>
<p>Calculating the memory address complicates the bus cycle. As the timing diagrams above show, the processor issues the memory address during state <code>T1</code> of the bus cycle.
However, it takes time to perform the address calculation addition, so the address calculation must take place
before <code>T1</code>.
To accomplish this, there are two &#34;invisible&#34; bus states before <code>T1</code>; I call these states &#34;TS&#34; (T-start) and &#34;T0&#34;.
During these states, the Bus Interface Unit uses the address adder to compute the address, so the address will be available
during the <code>T1</code> state.
These states are invisible to the external circuitry because they don&#39;t affect the signals from the chip.</p>
<p>Thus, a single memory operation takes six clock cycles: two preparatory cycles to compute the address before the four visible cycles.
However, if multiple memory operations are performed, the operations are overlapped to achieve a degree of pipelining that improves performance.
Specifically, the address calculation for the next memory operation takes place during the last two clock cycles of the current
memory operation, saving two clock cycles.
That is, for consecutive bus cycles, <code>T3</code> and <code>T4</code> of one bus cycle overlap with <code>TS</code> and <code>T0</code> of the next cycle.
In other words, during <code>T3</code> and <code>T4</code> of one bus cycle, the memory address gets computed for the next bus cycle.
This pipelining significantly improves the performance of the 8088, compared to taking 6 clock cycles for each bus cycle.</p>
<p>With this timing, the address adder is free during cycles <code>T1</code> and <code>T2</code>.
To improve performance in another way, the 8088 uses the adder during this idle time to increment or decrement memory addresses.
For instance, after popping a word from the stack, the stack pointer needs to be incremented by 2.<span id="fnref:predecrement"><a href="#fn:predecrement">5</a></span>
Another case is block move operations (string operations), which need to increment or decrement the pointers each step.
By using the address adder, the new pointer value is calculated &#34;for free&#34; as part of the memory
cycle, without using the processors regular ALU.<span id="fnref:adder"><a href="#fn:adder">4</a></span></p>
<!-- 
The use of the address pins is closely tied to the 8086's external timing.
The diagram below shows how a typical bus cycle is divided into four "T" states, each one corresponding to one clock cycle.
During `T1`, the CPU puts the memory address on the bus using the address pins.
During `T3` and `T4`, the CPU writes to memory by putting the data value on the data pins.
Alternatively, the CPU reads from memory by reading the data value during `T3` and `T4`.
State `T2` acts a buffer period to ensure that memory and the CPU don't try to write to the bus at the same time.

![A typical bus cycle consists of four T states. Diagram from The 8086 Family Users Manual, figure 4-5.](bus-cycle.jpg "w500")
-->

<h2>Address corrections</h2>
<p>The address adder is used in one more context: correcting the Instruction Pointer value.
Conceptually, the Instruction Pointer (or Program Counter) register points to the next instruction to execute.
However, since the 8088 prefetches instructions, the Instruction Pointer indicates the next instruction to
be <em>fetched</em>. 
Thus, the Instruction Pointer typically runs ahead of the &#34;real&#34; value.
For the most part, this doesn&#39;t matter. This discrepancy becomes an issue, though, for a subroutine call, which needs to push the
return address.
It is also an issue for a relative branch, which jumps to an address relative to the current execution position.</p>
<p>To support instructions that need the next instruction address, the 8088 implements a micro-instruction <code>CORR</code>, which corrects the Instruction Pointer.
This micro-instruction subtracts the length of the prefetch queue from the Instruction Pointer to determine the &#34;real&#34; Instruction Pointer.
This subtraction is performed by the address adder, using correction constants that are stored in a small Constant ROM.</p>
<p>The tricky part is ensuring that using the address adder for correction doesn&#39;t conflict with other uses of the adder.
The solution is to run a special shortened memory cycle—just the
<code>TS</code> and <code>T0</code> states—while the <code>CORR</code> micro-instruction is performed.<span id="fnref:corr"><a href="#fn:corr">6</a></span>
These states block a regular memory cycle from starting, preventing a conflict over the address adder.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/adder-zoom.jpg"><img alt="A closeup of the address adder circuitry in the 8086. From my article on the adder." height="449" src="https://static.righto.com/images/8086-bus8088/adder-zoom-w600.jpg" title="A closeup of the address adder circuitry in the 8086. From my article on the adder." width="600"/></a></p><p>A closeup of the address adder circuitry in the 8086. From <a href="https://www.righto.com/2020/08/reverse-engineering-adder-inside-intel.html">my article</a> on the adder.</p>
<h2>Prefetching</h2>
<p>The 8088 prefetches instructions before they are needed, loading instructions from memory into a 4-byte prefetch queue.
Prefetching usually improves performance, but can result in an
instruction&#39;s memory access being delayed by a prefetch, hurting overall performance.
To minimize this delay, a bus request from an instruction will preempt a prefetch, even if the prefetch has
gone through <code>TS</code> and <code>T0</code>.
At that point, the prefetch hasn&#39;t created any bus activity yet (which first happens in <code>T1</code>), so preempting the prefetch
can be done cleanly.
To preempt the prefetch, the bus cycle state machine jumps back to <code>TS</code>, skipping over <code>T1</code> through <code>T4</code>, and starting the desired access.</p>
<p>A prefetch will also be preempted by the micro-instruction that stops prefetching (<code>SUSP</code>) or the micro-instruction
that corrects addresses (<code>CORR</code>). In these cases, there is no point in completing the prefetch, so the state machine cycle
will end with <code>T0</code>.</p>
<h2>Wait states</h2>
<p>One problem with memory accesses is that the memory may be slower than the system&#39;s clock speed, a characteristic of less-expensive
memory chips.
The solution in the 1970s was &#34;wait states&#34;.
If the memory couldn&#39;t respond fast enough, it would tell the processor to add idle clock cycles called wait states, until
the memory could respond.<span id="fnref:byte"><a href="#fn:byte">7</a></span>
To produce a wait state, the memory (or I/O device) lowers the processor&#39;s <code>READY</code> pin until it is ready to proceed.
During this time, the Bus Interface Unit waits, although the Execution Unit continues operation if possible.
Although Intel&#39;s documentation gives the wait cycle a separate name (<code>Tw</code>), internally the wait is implemented by repeating the <code>T3</code> state as long as the <code>READY</code> pin is not active.</p>
<h2>Halts</h2>
<p>Another complication is that the 8088 has a <code>HALT</code> instruction that halts program execution until an interrupt comes in.
One consequence is that <code>HALT</code> stops bus operations (specifically prefetching, since stopping execution will automatically stop instruction-driven bus operations).
A complication is that the 8088 indicates the <code>HALT</code> state to external devices by performing a special <code>T1</code> bus cycle
without any following bus cycles.
But wait: there&#39;s another complication. External devices can take control of the bus through the <code>HOLD</code> functionality,
allowing external devices to perform operations such as DMA (Direct Memory Access).
When the device ends the <code>HOLD</code>, the 8088 performs another special <code>T1</code>
bus cycle, indicating that the <code>HALT</code> is still in effect.
Thus, the bus state machine must generate these special <code>T1</code> states based on <code>HALT</code> and <code>HOLD</code> actions.
(I discussed the <code>HALT</code> process in detail <a href="https://www.righto.com/2023/01/reverse-engineering-intel-8086.html">here</a>.)</p>
<h2>Putting it all together: the state diagram</h2>
<p>The state diagram below summarizes the different types of bus cycles.
Each circle indicates a specific T-state, and the arrows indicate the transitions between states.
The green line shows the basic bus cycle or cycles, starting in <code>TS</code> and then going around the cycle.
From <code>T3</code>, a new cycle can start with <code>T0</code> or the cycle will end with <code>T4</code>.
Thus, new cycles can start every four clocks, but a full cycle takes six states (counting the &#34;invisible&#34; <code>TS</code> and <code>T0</code>).
The brown line shows that the bus cycle will stay in <code>T3</code> as long as there is a wait state.
The red line shows the two cycles for a CORR correction, while the purple line shows the special <code>T1</code> state for a <code>HALT</code>
instruction.
The cyan line shows that a prefetch cycle can be preempted after <code>T0</code>; the cycle will either restart at <code>TS</code> or end.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/state-diagram.jpg"><img alt="A state diagram showing the basic bus cycle and various complications." height="421" src="https://static.righto.com/images/8086-bus8088/state-diagram-w400.jpg" title="A state diagram showing the basic bus cycle and various complications." width="400"/></a></p><p>A state diagram showing the basic bus cycle and various complications.</p>
<p>I&#39;m showing states <code>TS</code> and <code>T3</code> together since they overlap but aren&#39;t the same.
Likewise, I&#39;m showing <code>T4</code> and <code>T0</code> together. <code>T4</code> is grayed out because it doesn&#39;t exist from the state machine&#39;s perspective;
the circuitry doesn&#39;t take any particular action during <code>T4</code>.</p>
<p>The schematic below shows the implementation of the state machine.
The four flip-flops represent the four states, with one flip-flop active at a time, generating states <code>T0</code>, <code>T1</code>, <code>T2</code>,
and <code>T3</code> (from top to bottom).
Each output feeds into the logic for the next state, with <code>T3</code> wrapping back to the top, so the circuit moves through
the states in sequence.
The flip-flops are clocked so the active state will move from one flip-flop to the next according to the system clock.
State <code>TS</code> doesn&#39;t have its own flip-flop, but is represented by the input to the <code>T0</code> flip-flop, so it happens one clock
cycle earlier.<span id="fnref:ts"><a href="#fn:ts">8</a></span>
State <code>T4</code> doesn&#39;t have a flip-flop since it isn&#39;t &#34;real&#34; to the bus state machine.
The logic gates handle the special cases: blocking the state transfer if necessary or starting a state.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/state-machine-schematic.jpg"><img alt="Schematic of the state machine." height="642" src="https://static.righto.com/images/8086-bus8088/state-machine-schematic-w650.jpg" title="Schematic of the state machine." width="650"/></a></p><p>Schematic of the state machine.</p>
<p>I&#39;ll explain the logic for each state in more detail.
The circuitry for the <code>TS</code> state has two AND gates to generate new bus cycles starting from <code>TS</code>.
The first one (a) causes <code>TS</code> to happen with <code>T3</code> if there is a pending bus request (and no <code>HOLD</code>). The second AND gate (b) starts a bus cycle if
the bus is not currently active and there is a bus request or a <code>CORR</code> micro-instruction.
The flip-flop causes <code>T0</code> to follow <code>T3</code>/<code>TS</code>, one clock cycle later.</p>
<p>The next gates (c) generate the <code>T1</code> state following <code>T0</code> if there is pending bus activity and the cycle isn&#39;t preempted to <code>T3</code>. The AND gate (d)
starts the special <code>T1</code> for the <code>HALT</code> instruction.<span id="fnref:halt"><a href="#fn:halt">9</a></span>
The <code>T2</code> state follows <code>T1</code> unless <code>T1</code> was generated by a <code>HALT</code> (e).</p>
<p>The <code>T3</code> logic is more complicated. First, <code>T3</code> will always follow <code>T2</code> (f).
Next, a wait state will cause <code>T3</code> to remain in <code>T3</code> (g).
Finally, for a preempt, <code>T3</code> will follow <code>T0</code> (h) if there is a prefetch and a microcode bus operation (i.e. an instruction specified the bus operation).</p>
<p>Next, I&#39;ll explain <code>BUS-ACTIVE</code>, an important signal that indicates if the bus is active or not.
The Bus Interface Unit generates the <code>BUS-ACTIVE</code> signal to help control the state machine.
The <code>BUS-ACTIVE</code> signal is also widely used in the Bus Interface Unit, controlling many functions such as transfers to and from
the address registers.
<code>BUS-ACTIVE</code> is generated by the complex circuit below that determines if the bus will be active,
specifically in states <code>T0</code> through <code>T3</code>.
Because of the flip-flop, the computation of <code>BUS-ACTIVE</code> happens in the previous clock cycle.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/schematic-bus-active.png"><img alt="The circuit to determine if the bus will be active next cycle." height="370" src="https://static.righto.com/images/8086-bus8088/schematic-bus-active-w600.png" title="The circuit to determine if the bus will be active next cycle." width="600"/></a></p><p>The circuit to determine if the bus will be active next cycle.</p>
<p>In more detail, the signal <code>BUS-ACTIVE-PRE</code> indicates if the bus cycle will continue or will end on the next clock cycle.
Delaying this signal through the flip-flop generates <code>BUS-ACTIVE</code>, which indicates if the bus is currently active in states <code>T0</code> through <code>T3</code>.
The top AND gate (a) is responsible for starting a cycle or keeping a cycle going (a1).
It will allow a new cycle if there is a bus request (without <code>HOLD</code>) (a3).
It will also allow a new cycle if there is a <code>CORR</code> micro-instruction prior to the <code>T1</code> state (even if there is a <code>HOLD</code>, since
this &#34;fake&#34; cycle won&#39;t use the bus) (a2).
Finally, it allows a new cycle for a <code>HALT</code>, using <code>T1-pre</code> (a2).<span id="fnref:t1pre"><a href="#fn:t1pre">10</a></span>
Next are the special cases that end a bus cycle.
The second AND gate (b) ends the bus cycle after <code>T3</code> unless there is a wait state or another bus request.
(But a <code>HOLD</code> will block the next bus request.)
The remaining gates end the cycle after <code>T0</code> to preempt a prefetch if a <code>CORR</code> or <code>SUSP</code> micro-instruction occurs (d), or
end after <code>T1</code> for a <code>HALT</code> (e).</p>
<p>The <code>BUS-ACTIVE</code> circuit above uses a complex gate, a 5-input NOR gate fed by 5 AND gates with two attached OR gates. Surprisingly,
this is implemented in the processor as a single gate with 14 inputs.
Due to how gates are implemented with NMOS transistors, it is straightforward to implement this as a single gate.
The inverter and NOR gate on the left, however, needed to be implemented separately, as they involve inversion;
an NMOS gate must have a single inversion.</p>
<p><a href="https://static.righto.com/images/8086-bus8088/circuitry-zoom.jpg"><img alt="The bus state machine circuitry on the die." height="567" src="https://static.righto.com/images/8086-bus8088/circuitry-zoom-w700.jpg" title="The bus state machine circuitry on the die." width="700"/></a></p><p>The bus state machine circuitry on the die.</p>
<p>The diagram above shows the layout of the bus state machine circuitry on the die, zooming in on the top region of the die.
The metal layer has been removed to expose the underlying silicon and polysilicon.
The layout of each flip-flop is completely different, since the layout of each transistor is optimized to its surroundings.
(This is in contrast to later processors such as the 386, which used <a href="https://www.righto.com/2024/01/intel-386-standard-cells.html">standard-cell layout</a>.)
Even though the state machine consists of just a handful of flip-flops and gates, it takes a noticeable area on the die due to
the large 3.2 µm feature size of the 8088.
(Modern processors have features measured in nanometers, not micrometers.)</p>
<h2>Conclusions</h2>
<p>The bus state machine is an example of how the 8088&#39;s design consists of complications on top of complications.
While the four-state bus cycle seems straightforward at first, it gets more complicated due to prefetching,
wait states, the <code>HALT</code> instruction, and the bus hold feature, not to mention the interactions between these features.
While there were good motivations behind these features, they made the processor considerably more complicated.
Looking at the internals of the 8088 gives me a better understanding of why simple RISC processors became popular.</p>
<p>The bus state machine is a key part of the read and write circuitry,
moving the bus operation through the necessary T-states.
However, the state machine is not the only component in this process; a higher-level circuit decides <em>when</em> to perform a read, write,
or prefetch, as well as breaking a 16-bit operation into two 8-bit operations.<span id="fnref:8086"><a href="#fn:8086">11</a></span>
These circuits work together with the higher-level circuit telling the state machine when to go through the states.</p>
<p>In my next blog post, I&#39;ll describe the higher-level memory circuit so
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="http://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;m also on Mastodon as <a href="https://oldbytes.space/@kenshirriff">oldbytes.space@kenshirriff</a>.
If you&#39;re interested in the 8086, I wrote about the <a href="http://www.righto.com/2020/06/a-look-at-die-of-8086-processor.html">8086 die</a>, its <a href="https://www.righto.com/2020/06/die-shrink-how-intel-scaled-down-8086.html">die shrink process</a>, and the <a href="http://www.righto.com/2020/07/the-intel-8086-processors-registers.html">8086 registers</a> earlier.</p>
<h2>Notes and references</h2>
<div>
<ol>
<li id="fn:8085">
<p>The 8085 and 8088 processors both use a 4-step bus cycle for instruction fetching.
For other reads and writes, the 8085&#39;s bus cycle has three steps compared to four for the 8088.
Thus, the 8085 and 8088 bus cycles are similar but not an exact match. <a href="#fnref:8085" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:io">
<p>The 8088 has separate instructions to read or write an I/O device.
From the bus perspective, there&#39;s no difference between an I/O operation and a memory operation except that a pin
on the chip indicates if the operation is for memory or I/O.</p>
<p>The 8088 supports I/O operations for historical reasons, going back through the 8086, 8080, 8008, and
the <a href="https://www.righto.com/2023/08/datapoint-to-8086.html">Datapoint 2200</a> system.
In contrast, many other contemporary processors such as the 6502 used memory-mapped I/O, using standard memory accesses for
I/O devices.</p>
<p>The 8086 has a pin M/<span>IO</span> that is high for a memory access and low for
an I/O access. External hardware uses this pin to determine how to handle the request.
Confusingly, the pin&#39;s function is inverted on the 8088, providing IO/<span>M</span>.
One motivation behind the 8088&#39;s 8-bit bus was to allow reuse of peripherals from the earlier 8-bit 8085 processor.
Thus, the pin&#39;s function was inverted so it matched the 8085.
(The pin is only available when the 8086/8088 is used in &#34;minimum mode&#34;; &#34;maximum mode&#34; remaps some of the pins,
making the system more complicated but providing more control.) <a href="#fnref:io" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:timing">
<p>I&#39;ve made the timing diagram somewhat idealized so actions line up with the clock.
In the real datasheet, all the signals are skewed by various amounts so the timing is more complicated.
See the datasheet for pages of timing constraints on exactly when
signals can change. <a href="#fnref:timing" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:adder">
<p>For more information on the implementation of the address adder, see my <a href="https://www.righto.com/2020/08/reverse-engineering-adder-inside-intel.html">previous blog post</a>. <a href="#fnref:adder" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
<li id="fn:predecrement">
<p>The <code>POP</code> operation is an example of how the address adder updates a memory pointer.
In this case, the stack address is moved from the Stack Pointer to the <code>IND</code> register in order to perform the memory read.
As part of the read operation, the <code>IND</code> register is incremented by 2. The address is then moved from the <code>IND</code> register to
the Stack Pointer.
Thus, the address adder not only performs the segment arithmetic, but also computes the new value for the <code>SP</code> register.</p>
<p>Note that the increment/decrement of the <code>IND</code> register happens after the memory operation.
For stack operations, the SP must be decremented before a <code>PUSH</code> and incremented after a <code>POP</code>.
The adder cannot perform a predecrement, so the <code>PUSH</code> instruction uses the ALU (Arithmetic/Logic Unit) to perform the decrement. <a href="#fnref:predecrement" title="Jump back to footnote 5 in the text">↩</a></p>
</li>
<li id="fn:corr">
<p>During the <code>CORR</code> micro-instruction, the Bus Interface Unit performs special <code>TS</code> and <code>T0</code> states.
Note that these states don&#39;t have any external effect, so they are invisible
outside the processor. <a href="#fnref:corr" title="Jump back to footnote 6 in the text">↩</a></p>
</li>
<li id="fn:byte">
<p>The tradeoff with memory boards was that slower RAM chips were cheaper. 
The better RAM boards advertised &#34;<a href="https://archive.org/details/byte-magazine-1979-08/page/n1/mode/2up?q=%22wait+states%22">no wait states</a>&#34;, but cheaper boards would add one or more wait states to every access, reducing performance. <a href="#fnref:byte" title="Jump back to footnote 7 in the text">↩</a></p>
</li>
<li id="fn:ts">
<p>Only the second half of the <code>TS</code> state has an effect on the Bus Interface Unit, so <code>TS</code> is not a full state like
the other states.
Specifically, a delayed <code>TS</code> signal is taken from the first half of the <code>T0</code> flip-flop, and this signal is used to
control various actions in the Bus Interface Unit.
(Alternatively, you could think of this as an early <code>T0</code> state.)
This is why there isn&#39;t a separate flip-flop for the <code>TS</code> state.
I suspect this is due to timing issues; by the time the <code>TS</code> state is generated by the logic, there isn&#39;t enough time
to do anything with the state in that half clock cycle, due to propagation delays. <a href="#fnref:ts" title="Jump back to footnote 8 in the text">↩</a></p>
</li>
<li id="fn:halt">
<p>There is a bit more circuitry for the <code>T1</code> state for a <code>HALT</code>. Specifically, there is a flip-flop that is set on this signal.
On the next cycle, this flip-flop both blocks the generation of another <code>T1</code> state and blocks the previous <code>T1</code> state from
progressing to <code>T2</code>. In other words, this flip-flop makes sure the special <code>T1</code> lasts for one cycle.
However, a <code>HOLD</code> state resets this flip-flop. That allows another special <code>T1</code> to be generated when the <code>HOLD</code> ends. <a href="#fnref:halt" title="Jump back to footnote 9 in the text">↩</a></p>
</li>
<li id="fn:t1pre">
<p>The trickiest part of this circuit is using <code>T1-pre</code> to start a (short) cycle for <code>HALT</code>. 
The way it works is that the <code>T1-pre</code> signal only makes a difference if there isn&#39;t a bus cycle already active.
The only way to get an &#34;unexpected&#34; <code>T1-pre</code> signal is if the state machine generates it for the first cycle of a <code>HALT</code>.
Thus, the <code>HALT</code> triggers <code>T1-pre</code> and thus the <code>bus-active</code> signal.
You might wonder why the <code>bus-active</code> uses this roundabout technique rather than getting triggered directly by <code>HALT</code>.
The motivation is that the special <code>T1</code> state for <code>HALT</code> requires the AND of three signals to ensure that the state is
generated once for the <code>HALT</code> rather than continuously, but happens again after a <code>HOLD</code>, and waits until the current
bus cycle is done. Instead of duplicating that AND gate, the circuit uses <code>T1-pre</code> which incorporates that logic.
(This took me a <em>long</em> time to figure out.) <a href="#fnref:t1pre" title="Jump back to footnote 10 in the text">↩</a></p>
</li>
<li id="fn:8086">
<p>The 8088 has a 16-bit bus, compared to the 8088&#39;s 8-bit bus.
Thus, a 16-bit bus operation on the 8088 will always require two 8-bit operations, while the 8086 can usually
perform this operation in a single step.
However, a 16-bit bus operation on the 8086 will still need to be broken into two 8-bit operations
if the address is unaligned (i.e. odd). <a href="#fnref:8086" title="Jump back to footnote 11 in the text">↩</a></p>
</li>
</ol>
</div>

</div></div>
  </body>
</html>
