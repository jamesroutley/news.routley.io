<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://samwho.dev/reservoir-sampling/">Original</a>
    <h1>Reservoir Sampling</h1>
    
    <div id="readability-page-1" class="page"><article>
    <main id="content">
        

<a href="https://samwho.dev/">
    <img alt="samwho keyboard logo" src="https://samwho.dev/images/samwho-keyslogo.svg"/>
</a>
<header>
  
</header>
<p>Reservoir sampling is a technique for selecting a fair random sample when you
don&#39;t know the size of the set you&#39;re sampling from. By the end of this essay
you will know:</p>
<ul>
<li>When you would need reservoir sampling.</li>
<li>The mathematics behind how it works, using only basic operations:
subtraction, multiplication, and division. No math notation, I promise.</li>
<li>A simple way to implement reservoir sampling if you want to use it.</li>
</ul>
<s-dog name="doe">
  Before you scroll! This post has been sponsored by the wonderful folks at <a href="https://ittybit.com/?ref=sam">ittybit</a>, and their API for working
  with videos, images, and audio. If you need to store, encode, or get
  intelligence from the media files in your app, check them out!
</s-dog>
<h2 id="sampling-when-you-know-the-size"><a href="#sampling-when-you-know-the-size">#</a>
Sampling when you know the size</h2>
<p>In front of you are 10 playing cards and I ask you to pick 3 at random. How do
you do it?</p>
<p>The first technique that might come to mind from your childhood is to mix them
all up in the middle. Then you can straighten them out and pick the first 3.
You can see this happen below by clicking &#34;Shuffle.&#34;</p>

<p>Every time you click &#34;Shuffle,&#34; the chart below tracks what the first 3 cards
were.</p>
<s-card-select-bar-chart id="random-shuffle-chart" target="random-shuffle">
</s-card-select-bar-chart>
<p>At first you&#39;ll notice some cards are selected more than others, but if you
keep going it will even out. All cards have an equal chance of being selected.
This makes it &#34;fair.&#34;</p>
<p>Click &#34;Shuffle 100 times&#34; until the chart evens out.  You can reset the chart if
you&#39;d like to start over.</p>

<p>This method works fine with 10 cards, but what if you had 1 million cards?
Mixing those up won&#39;t be easy. Instead, we could use a random number generator
to pick 3 indices. These would be our 3 chosen cards.</p>

<p>We no longer have to move all of the cards, and if we click the &#34;Select&#34; button
enough times we&#39;ll see that this method is just as fair as the mix-up method.</p>
<s-card-select-bar-chart id="random-select-chart" target="random-select">
</s-card-select-bar-chart>

<p>I&#39;m stretching the analogy a little here. It would take a long time to count
through the deck to get to, say, index 436,234. But when it&#39;s an array in
memory, computers have no trouble finding an element by its index.</p>
<p>Now let me throw you a curveball: what if I were to show you 1 card at a time,
and you had to pick 1 at random?</p>
<s-dog position="right" mode="confused">
  How many cards are you going to show me?
</s-dog>
<p>That&#39;s the curveball: you don&#39;t know.</p>
<s-dog position="right" mode="default">
  Can I hold on to all the cards you give me and then pick 1 after you stop?
</s-dog>
<p>No, you can only hold on to 1 card at a time. You&#39;re free to swap your card
with the newest one each time I show you a card, but you can only hold one and
you can&#39;t go back to a card you&#39;ve already seen.</p>
<s-dog position="right" mode="concerned">
  Then it&#39;s impossible! Why would I ever need to do this anyway?
</s-dog>
<p>Believe it or not, this is a real problem and it has a real and elegant
solution.</p>
<p>For example, let&#39;s say you&#39;re building a log collection service. Text logs, not
wooden ones. This service receives log messages from other services and
stores them so that it&#39;s easy to search them in one place.</p>
<p>One of the things you need to think about when building a service like this is
what do you do when another service starts sending you way too many logs.  Maybe
it&#39;s a bad release, maybe one of your videos goes viral. Whatever the reason, it
threatens to overwhelm your log collection service.</p>
<p>Let&#39;s simulate this. Below you can see a stream of logs that experiences
periodic spikes. A horizontal line indicates the <h->threshold</h-> of logs per
second that the log collection service can handle, which in this example is 5
logs per second.</p>
<!--
Yes, this is not web scale.
-->


<p>You can see that every so often, logs per second spikes above the
<h->threshold</h->. One way to deal with this is &#34;sampling.&#34; Deciding to send
only a fraction of the logs to the log collection service.  Let&#39;s send 10% of
the logs.</p>
<p>Below we will see the same simulation again, but this time logs that don&#39;t get
sent to our log collection service will be greyed out. The graph has 2 lines: a
black line tracks <h->sent logs</h->, the logs that are sent to our log
collection service, and a grey line tracks <h->total logs</h->.</p>


<p>The rate of <h->sent logs</h-> never exceeds the <h->threshold</h->, so we never
overwhelm our log collection service. However, in the quieter periods we&#39;re
throwing away 90% of the logs when we don&#39;t need to!</p>
<p>What we really want is to send <em>at most</em> 5 logs per second.  This would mean
that during quiet periods you get all the logs, but during spikes you discard
logs to protect the log collection service.</p>
<p>The simple way to achieve this would be to send the first 5 logs you see each
second, but this isn&#39;t fair. You aren&#39;t giving all logs an equal chance of being
selected.</p>
<h2 id="sampling-when-you-don-t-know-the-size"><a href="#sampling-when-you-don-t-know-the-size">#</a>
Sampling when you don&#39;t know the size</h2>
<p>We instead want to pick a fair sample of all the logs we see each second. The
problem is that we don&#39;t know how many we will see. Reservoir sampling is an
algorithm that solves this exact problem.</p>
<s-dog position="right" mode="confused">
  1 second isn&#39;t a long time, can&#39;t we just store all the messages we see and
  then use the select method from way back up there?
</s-dog>
<p>You <em>could</em>, but why live with that uncertainty?  You&#39;d be holding on to an
unknown number of logs in memory. A sufficiently big spike could cause you
problems.  Reservoir sampling solves this problem, and does so without ever
using more memory than you ask it to.</p>
<p>Let&#39;s go back to our curveball of me showing you 1 card at a time.  Here&#39;s a
recap of the rules:</p>
<ol>
<li>I&#39;ll draw cards one at a time from a deck.</li>
<li>Each time I show you a card, you have to choose to hold it or discard it.</li>
<li>If you were already holding a card, you discard your held card before
replacing it with the new card.</li>
<li>At any point I can stop drawing cards and whatever card you&#39;re holding is the
one you&#39;ve chosen.</li>
</ol>
<p>How would you play this game in a way that ensures all cards have been given an
equal chance to be selected when I decide to stop?</p>
<s-dog position="right" mode="triumphant">
  How about we flip a coin every new card? If it&#39;s heads, we keep the card we
  have. If it&#39;s tails, we swap it out for the new card.
</s-dog>
<p>You&#39;re on the right track. Let&#39;s have a look at how the coin flip idea plays out
in practice. Below you see a deck of cards. Clicking &#34;Deal&#34; will draw a card and
50% of the time it will go to the <h->discard pile</h-> on the right, and 50% of
the time it will become your <h->held card</h-> in the center, with any
previously held card moving to the discard pile.</p>

<p>The problem is that while the <h->hold</h-> vs <h->discard</h-> counts are
roughly equal, which feels fair, later cards are much more likely to be held
when I stop than earlier cards. The first card drawn has to win 10 coin flips to
still be in your hand after the 10th card is drawn. The last card only has to
win 1.</p>
<p>Scrub the slider below to see how the chances change as we draw more cards. Each
bar represents a card in the deck, and the height of the bar is the chance we&#39;re
holding that card when I stop. Below the slider are the chances we&#39;re
holding the first card drawn vs. the last card drawn.</p>

<p>Anything older than 15 cards ago is has a less than 0.01% chance of being held
when I stop.</p>
<s-dog position="right" mode="concerned">
  You said I was on the right track! How can this be the right track when I&#39;m
  more likely to win the lottery than to be holding the card I saw 24 draws ago?
</s-dog>
<p>Because believe it or not, we only have to make one small change to this idea
to make it fair.</p>
<p>Instead of flipping a coin to decide if we&#39;ll hold the card or not, instead we
give each new card a <code>1/n</code> chance of being held, where <code>n</code> is the number of
cards we&#39;ve seen so far.</p>
<s-dog position="right" mode="concerned">
  Wait, that&#39;s it? That makes it fair?
</s-dog>
<p>Yep! In order to be fair, every card must have an equal chance of being
selected. So for the 2nd card, we want both cards to have a <code>1/2</code> chance.  For
the 3rd card, we want all 3 cards to have a <code>1/3</code> chance. For the 4th card, we
want all 4 cards to have a <code>1/4</code> chance, and so on. So if we use <code>1/n</code> for the
new card, we can at least say that the new card has had a fair shot.</p>
<p>Let&#39;s have a look at the chances as you draw more cards with this new
method.</p>

<s-dog position="right" mode="confused">
  I get how each <b>new</b> card has the right chance of being selected, but how
  does that make the <b>older</b> cards fair?
</s-dog>
<p>So far we&#39;ve focused on the chance of the new card being selected, but we also
need to consider the chance of the card you&#39;re holding staying in your hand.
Let&#39;s walk through the numbers.</p>
<h3 id="card-1"><a href="#card-1">#</a>
Card 1</h3>
<p>The first card is easy: we&#39;re not holding anything, so we always choose to hold
the first card. The chance we&#39;re holding this card is <code>1/1</code>, or <code>100%</code>.</p>

<h3 id="card-2"><a href="#card-2">#</a>
Card 2</h3>
<p>This time we have a real choice. We can keep hold of the card we have, or
replace it with the new one. We&#39;ve said that we&#39;re going to do this with a <code>1/n</code>
chance, where <code>n</code> is the number of cards we&#39;ve seen so far. So our chance of
replacing the first card is <code>1/2</code>, or <code>50%</code>, and our chance of keeping hold of
the first card is its chance of being chosen last time multiplied by its chance
of being replaced, so <code>100% * 1/2</code>, which is again <code>50%</code>.</p>

<h3 id="card-3"><a href="#card-3">#</a>
Card 3</h3>
<p>The card we&#39;re holding has a <code>50%</code> chance of being there. This is true
regardless what happened up to this point. No matter whether we&#39;re holding card
1 or card 2, it&#39;s <code>50%</code>.</p>
<p>The new card has a <code>1/3</code> chance of being selected, so the card we&#39;re holding has
a <code>1/3</code> chance of being replaced. This means that our held card has a <code>2/3</code>
chance of remaining held. So its chances of &#34;surviving&#34; this round are <code>50% * 2/3</code>.</p>

<h3 id="card-n"><a href="#card-n">#</a>
Card N</h3>
<p>This pattern continues for as many cards as you want to draw. We can express
both options as formulas.  Drag the slider to substitute <code>n</code> with real numbers
and see that the two formulas are always equal.</p>
<div>
  <div>
    <p>
      Hold
    </p>
    <p>
      1/(n-1) * (1-(1/n))
    </p>
    <p>
      -
    </p>
  </div>
  
</div>


<p>If <code>1/n</code> is the chance of choosing the new card, <code>1/(n-1)</code> is the chance of
choosing the new card from the previous draw. The chance of <em>not</em> choosing the
new card is the <em>complement</em> of <code>1/n</code>, which is <code>1-(1/n)</code>.</p>
<p>Below are the cards again except this time set up to use <code>1/n</code> instead of a
coin flip. Click to the end of the deck. Does it feel fair to you?</p>

<p>There&#39;s a good chance that through the 2nd half of the deck, you never swap
your chosen card. This <em>feels</em> wrong, at least to me, but as we saw above the
numbers say it is completely fair.</p>
<h2 id="choosing-multiple-cards"><a href="#choosing-multiple-cards">#</a>
Choosing multiple cards</h2>
<p>Now that we know how to select a single card, we can extend this to selecting
multiple cards. There are 2 changes we need to make:</p>
<ol>
<li>Rather than new cards having a <code>1/n</code> chance of being selected, they now have
a <code>k/n</code> chance, where <code>k</code> is the number of cards we want to choose.</li>
<li>When we decide to replace a held card, we choose one of the <code>k</code> cards we&#39;re
holding at random.</li>
</ol>
<p>So our new previous card selection formula becomes <code>k/(n-1)</code> because we&#39;re now
holding <code>k</code> cards. Then the chance that any of the cards we&#39;re holding get
replaced is <code>1-(1/n)</code>.</p>
<p>Let&#39;s see how this plays out with real numbers.</p>
<div>
  <div>
    <p>
      Hold
    </p>
    <p>
      k/(n-1) * (1-(1/n))
    </p>
    <p>
      -
    </p>
  </div>
  
</div>


<p>The fairness still holds, and will hold for any <code>k</code> and <code>n</code> pair. This is
because all held cards have an equal chance of being replaced, which keeps them
at an equal likelihood of still being in your hand every draw.</p>
<p>A nice way to implement this is to use an array of size <code>k</code>. For each new card,
generate a random number between 0 and <code>n</code>. If the random number is less than
<code>k</code>, replace the card at that index with the new card.  Otherwise, discard the
new card.</p>

<p>And that&#39;s how reservoir sampling works!</p>
<h2 id="applying-this-to-log-collection"><a href="#applying-this-to-log-collection">#</a>
Applying this to log collection</h2>
<p>Let&#39;s take what we now know about reservoir sampling and apply it to our log
collection service. We&#39;ll set <code>k=5</code>, so we&#39;re &#34;holding&#34; at most 5 log messages
at a time, and every second we will send the selected logs to the log collection
service. After we&#39;ve done that, we empty our array of size 5 and start again.</p>
<p>This creates a &#34;lumpy&#34; pattern in the graph below, and highlights a trade-off
when using reservoir sampling. It&#39;s no longer a real-time stream of logs, but
chunks of logs sent at an interval. However, <h->sent logs</h-> never exceeds
the <h->threshold</h->, and during quiet periods the two lines track each other
almost perfectly.</p>


<p>No logs lost during quiet periods, and never more than <h->threshold</h-> logs
per second sent during spikes.  The best of both worlds. It also doesn&#39;t store
more than <code>k=5</code> logs, so it will have predictable memory usage.</p>
<h2 id="further-reading"><a href="#further-reading">#</a>
Further reading</h2>
<p>Something you may have thought while reading this post is that some logs are
more valuable than others. You almost certainly want to keep all error logs, for
example.</p>
<p>For that use-case there <em>is</em> a <a href="https://en.wikipedia.org/wiki/Reservoir_sampling#Weighted_random_sampling">weighted</a> variant of reservoir sampling. I
wasn&#39;t able to find a simpler explanation of it, so that link is to Wikipedia
which I personally find a bit hard to follow. But the key point is that it
exists and if you need it you can use it.</p>
<h2 id="conclusion"><a href="#conclusion">#</a>
Conclusion</h2>
<p>Reservoir sampling is one of my favourite algorithms, and I&#39;ve been wanting to
write about it for years now. It allows you to solve a problem that at first
seems impossible, in a way that is both elegant and efficient.</p>
<p>Thank you again to <a href="https://ittybit.com/?ref=sam">ittybit</a> for sponsoring this
post.  I really couldn&#39;t have hoped for a more supportive first sponsor. Thank
you for believing in and understanding what I&#39;m doing here.</p>
<p>Thank you to everyone who read this post and gave their feedback. You made this
post much better than I could have done on my own, and steered me away from
several paths that just weren&#39;t working.</p>
<p>If you want to tell me what you thought of this post by sending me an anonymous
message that goes directly to my phone, go to <a href="https://samwho.dev/ping">https://samwho.dev/ping</a>.</p>

    </main>
</article></div>
  </body>
</html>
