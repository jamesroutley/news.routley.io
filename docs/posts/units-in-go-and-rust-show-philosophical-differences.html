<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ntietz.com/blog/units-in-go-rust/">Original</a>
    <h1>Units in Go and Rust show philosophical differences</h1>
    
    <div id="readability-page-1" class="page"><article>
    

    <p><strong>Monday, June  5, 2023</strong></p>

    <p>Units are a key part of doing any calculation.
A number on its own is just a scalar and doesn&#39;t represent anything in particular.
If I tell you to go drive 5, you&#39;d naturally ask &#34;5 what?&#34;</p>
<p>Software often has to deal with quantities that represent real-world things.
How we represent these quantities in different languages is an interesting window into how those languages represent and interact with these quantities.
A common one we run into is the representation of <strong>time</strong>.
Nearly every program will eventually need to deal with time, even just to do a little sleeping (as a treat).</p>
<p>Let&#39;s compare how Go and Rust represent units of time!
Specifically, we&#39;ll look at how they represent durations of time for things like thread sleeps.
For this, we&#39;ll look primarily at the standard library; other libraries may do it differently, but this is a somewhat &#34;blessed&#34; path, and the world of libraries is so vast.
The standard libraries also are more likely to represent idiomatic usage<sup><a href="#1">1</a></sup>.</p>

<p>Let&#39;s start with Go.
Times use the package <a href="https://pkg.go.dev/time">time</a>.
Specifically, this package defines the type <code>Duration</code>, which represents elapsed time between two instants.
It&#39;s defined as an integer, representing elapsed nanoseconds.
Here&#39;s the full definition of the type:</p>
<pre><code><span>type </span><span>Duration </span><span>int64
</span></code></pre>
<p>There are also some constants provided: <code>Nanosecond</code>, <code>Microsecond</code>, <code>Millisecond</code>, <code>Second</code>, <code>Minute</code>, and <code>Hour</code>.
These give easy constants to allow easily constructing durations.</p>
<p>Here is the example of printing out a 10-second duration from the <a href="https://pkg.go.dev/time#pkg-constants">docs</a>:</p>
<pre><code><span>seconds </span><span>:= </span><span>10
</span><span>fmt</span><span>.</span><span>Print</span><span>(time</span><span>.</span><span>Duration</span><span>(seconds)</span><span>*</span><span>time</span><span>.</span><span>Second) </span><span>// prints 10s
</span></code></pre>
<p>We create a <code>time.Duration</code> (casting the input int, 10, into a <code>Duration</code>), which represents 10 nanoseconds.
When we multiply it by <code>time.Second</code>, we are multiplying by the number of nanoseconds in a second, which scales the duration to represent 10 seconds.</p>
<p>At all times, a <code>Duration</code> is <em>just</em> an int, which largely means you can use it like an int (but may have to cast it sometimes).
You can do all the usual integer things, like adding other integers and multiplying by other integers.</p>
<p>The same example as above can be represented using integer math:</p>
<pre><code><span>duration </span><span>:= </span><span>time</span><span>.</span><span>Second </span><span>* </span><span>10
</span><span>fmt</span><span>.</span><span>Print</span><span>(duration) </span><span>// prints 10s
</span></code></pre>
<p>And you could add, here representing 1.00000001s:</p>
<pre><code><span>duration </span><span>:= </span><span>time</span><span>.</span><span>Second </span><span>+ </span><span>10
</span><span>fmt</span><span>.</span><span>Print</span><span>(duration) </span><span>// prints 1.00000001s
</span></code></pre>
<p>Rust takes a different approach.
Times are in the package <a href="https://doc.rust-lang.org/stable/std/time/index.html">std::time</a>.
Within this package, we have <a href="https://doc.rust-lang.org/stable/std/time/struct.Duration.html">Duration</a>.</p>
<p>This type is more complicated in its definition, as it is a struct.
In fact, the docs do not tell us what the internal representation is, just giving us:</p>
<pre><code><span>pub struct </span><span>Duration </span><span>{ </span><span>/* private fields */ </span><span>}
</span></code></pre>
<p>If we look at the source code, we can see that it doesn&#39;t contain very much:</p>
<pre><code><span>// some attributes are skipped for clarity

</span><span>#</span><span>[</span><span>derive</span><span>(Clone</span><span>,</span><span> Copy</span><span>,</span><span> PartialEq</span><span>,</span><span> Eq</span><span>,</span><span> PartialOrd</span><span>,</span><span> Ord</span><span>,</span><span> Hash</span><span>,</span><span> Default)]
</span><span>pub struct </span><span>Duration </span><span>{
    secs</span><span>: </span><span>u64</span><span>,
    nanos</span><span>:</span><span> Nanoseconds, </span><span>// Always 0 &lt;= nanos &lt; NANOS_PER_SEC
</span><span>}

</span><span>#</span><span>[</span><span>derive</span><span>(Clone</span><span>,</span><span> Copy</span><span>,</span><span> PartialEq</span><span>,</span><span> Eq</span><span>,</span><span> PartialOrd</span><span>,</span><span> Ord</span><span>,</span><span> Hash)]
</span><span>struct </span><span>Nanoseconds</span><span>(</span><span>u32</span><span>)</span><span>;
</span></code></pre>
<p>This differs significantly from the Go definition in two ways:</p>
<ul>
<li>It&#39;s storing seconds (and nanoseconds for sub-second precision), not nanoseconds</li>
<li>It&#39;s stored in a structured way, rather than as an integer that you can use as an integer</li>
</ul>
<p>You construct <code>Duration</code>s using struct methods.
For example, you can make 10 seconds using <code>Duration::from_secs(10)</code>.</p>
<p>Here&#39;s the same example as above, adapted for Rust:</p>
<pre><code><span>let</span><span> seconds </span><span>= </span><span>Duration</span><span>::</span><span>from_secs(</span><span>10</span><span>)</span><span>;
</span><span>println!</span><span>(</span><span>&#34;</span><span>{:?}</span><span>&#34;</span><span>)</span><span>;
</span></code></pre>
<p>However, the arithmetic operators are not all defined here with integers!
You can multiply a duration by an integer, which makes sense: we know that 1 second times a unitless 10 is 10 seconds.
But what does it mean to add a unitless 10 to 1 second?
It doesn&#39;t mean anything, and if you try you get an error message saying that the operation isn&#39;t defined.</p>

<p>Between Go and Rust, we see a philosophical difference.
Rust prefers to put the unit into the type system, preventing errors by enforcing that usage goes through the implemented interface.
In contrast, Go prefers to document the unit and use a relatively bare type definition but placing fewer restrictions on the programmer.
Rust makes things explicit; Go allows things to be implicit.</p>
<p>These are philosophical differences, not limitations or enhancements afforded by either language, because both approaches can be implemented in either language.
You could define a similar <code>Duration</code> struct in Go, like so:</p>
<pre><code><span>type </span><span>Duration </span><span>struct </span><span>{
    secs </span><span>int64
    </span><span>nanos </span><span>int32
</span><span>}
</span></code></pre>
<p>And in Rust, we could define <code>Duration</code> as a type alias, similar to what was done in Go:</p>
<pre><code><span>type </span><span>Duration </span><span>= </span><span>u64</span><span>;
</span></code></pre>
<p>This example reflects a lot of my feelings and experiences using both of these languages in general.
They&#39;re great tools that excel in overlapping domains, and they come at it from different angles.
Go tends to feel like it expects the programmer to be diligent and careful, and it gives you footguns (though notably fewer than C or C++, which I&#39;m thankful about).
Rust tends to feel like it&#39;s working hard to prevent the programmer from making mistakes, which can be very comforting and can also feel awfully restrictive sometimes.</p>
<p>I&#39;m <em>extremely</em> thankful that Rust is restrictive about memory accesses to prevent pernicious memory bugs.
This sort of handling of unit bugs could also help prevent <a href="https://en.wikipedia.org/wiki/Mars_Climate_Orbiter#Cause_of_failure">bugs that crash space probes</a>.
But we&#39;re not all writing systems software or Mars orbiters, and this can feel like overkill sometimes.</p>
<p>To me, the Rust approach feels better, because it lives up to the promise of code being self-documenting and it helps prevent mistakes in codebases we don&#39;t understand.
And let&#39;s be honest, we don&#39;t understand <em>most</em> of the codebases we work in, because they&#39;re too large for any one human to fit in their head, let alone their working memory.
My opinion is that the more things we can push onto the compiler, the more we free up cognitive resources to actually think about the problems we&#39;re solving.</p>
<p>The Rust approach isn&#39;t <em>quite</em> there to me, because a lot of extra complexity comes along for the ride.
I overheard someone describe it recently as a language that has both a systems programming community and a fancy programming language community.
It feels like there&#39;s a lot of baggage from the latter that doesn&#39;t necessarily improve the overall use of the language.
It&#39;s still a really fun language, but I am also optimistic that we may get something even better in the future:
Something cleaner and easier, which still affords the most important protections that Rust provides.</p>
<hr/>
<p>Post notes: I think there are also some important things to say about the cultural differences between the Go and Rust communities.
But, I don&#39;t think I&#39;m the person to say them.
I&#39;m largely on the outside of both communities, because I don&#39;t spend a lot of time talking about the languages with other people; just using them, and collaborating in work and hobby contexts.
Both communities have great strengths and tragic flaws.
Just like the languages.</p>
<hr/>
<div id="1"><p><sup>1</sup></p><p>That said, standard libraries are also slower to change than practices may be, so idiomatic use can shift out from under them. But I think it&#39;s a reasonable basis, because it&#39;s what a lot of users will look to and will seek to remain compatible with.</p>
</div>

  </article><p>
    If this post was enjoyable or useful for you, <strong>please share it!</strong>
    If you have comments, questions, or feedback, please email <a href="mailto:~ntietz/public-inbox@lists.sr.ht">my public inbox</a> or <a href="mailto:me@ntietz.com">my personal email</a>.
    To get new posts, please use my <a href="https://ntietz.com/atom.xml">RSS feed</a>.
  </p></div>
  </body>
</html>
