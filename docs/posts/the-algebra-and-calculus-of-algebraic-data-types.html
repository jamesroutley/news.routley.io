<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types">Original</a>
    <h1>The algebra (and calculus) of algebraic data types</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>Note: This article assumes some introductory Haskell knowledge.</p>

<h2 id="introduction">Introduction</h2>

<p>Just as algebra is fundamental to the whole of mathematics, algebraic data types (ADTs) are fundamental to many common functional programming languages. They’re the primitives upon which all of our richer data structures are built, including everything from sets, maps, and queues, to <a href="http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html">bloom filters</a> and <a href="http://hackage.haskell.org/package/hnn">neural networks</a>.</p>

<p>Algebraic data types and mathematical algebra have some similar looking operations. In fact, it’s common in type theory to use the algebraic notation to define algebraic data types, rather than the Haskell-style data type declarations:</p>

<table>
  <thead>
    <tr>
      <th>Haskell</th>
      <th>Math     </th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>data Void</code></td>
      <td><span><span><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>0</span></span></span></span></td>
      <td>It’s impossible to construct a term of this type (needs <code>LANGUAGE EmptyDataDecls</code>)</td>
    </tr>
    <tr>
      <td><code>data Unit = Unit</code></td>
      <td><span><span><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>1</span></span></span></span></td>
      <td>The type with just one term</td>
    </tr>
    <tr>
      <td><code>data Bool = True | False</code></td>
      <td><span><span><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 + 1</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>1</span><span>+</span><span>1</span></span></span></span></td>
      <td>Also known as <code>2</code> (<code>3</code>, <code>4</code>, etc are exactly as you’d imagine)</td>
    </tr>
    <tr>
      <td><code>data Maybe a = Just a | Nothing</code></td>
      <td><span><span><math><semantics><mrow><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a + 1</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>+</span><span>1</span></span></span></span></td>
      <td>Read “<span><span><math><semantics><mrow><mo>+</mo></mrow><annotation encoding="application/x-tex">+</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>+</span></span></span></span>” as “Either”</td>
    </tr>
    <tr>
      <td><code>data Either a b = Left a | Right b</code></td>
      <td><span><span><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a + b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>+</span><span>b</span></span></span></span></td>
      <td> </td>
    </tr>
    <tr>
      <td><code>data (a, b) = (a, b)</code></td>
      <td><span><span><math><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>×</span><span>b</span></span></span></span></td>
      <td>Read “<span><span><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>×</span></span></span></span>” as “And”</td>
    </tr>
    <tr>
      <td><code>a -&gt; b</code></td>
      <td><span><span><math><semantics><mrow><msup><mi>b</mi><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">b ^ a</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span>b</span><span><span><span><span>​</span></span><span><span>a</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></td>
      <td>More on this in a moment</td>
    </tr>
  </tbody>
</table>

<p>In this essay, we’ll explore this coincidence and what that means for us as programmers. We’ll follow the path all the way to calculus.</p>

<h2 id="counting-inhabitants">Counting inhabitants</h2>

<p>As a first foray into the equivalence of algebraic data types and the algebra most of us are more familiar with, we’ll start with simple arithmetic. Specifically, we’ll start by counting the number of <em>inhabitants</em> (values) of a given type. Looking back at the examples:</p>

<table>
  <tbody>
    <tr>
      <td>There are <strong>0</strong> ways to construct <code>Void</code>.</td>
    </tr>
    <tr>
      <td><code>Unit</code>, the type constructor, has <strong>1</strong> inhabitant (<code>Unit</code>, the data constructor).</td>
    </tr>
    <tr>
      <td><code>Bool</code> has <strong>2</strong>. We can count the data constructors by hand, but we can also just simplify the algebraic expression to 2.</td>
    </tr>
    <tr>
      <td><code>Either a b</code> has as many as <code>a</code> and <code>b</code>, combined. Again, the number of inhabitants looks exactly the same as the algebraic form, <span><span><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a + b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>+</span><span>b</span></span></span></span>.</td>
    </tr>
    <tr>
      <td><code>(a, b)</code> has an inhabitant for each combination of <code>a</code>s and <code>b</code>s, <span><span><math><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>×</span><span>b</span></span></span></span>.</td>
    </tr>
    <tr>
      <td><code>a -&gt; b</code> has <span><span><math><semantics><mrow><msup><mi>b</mi><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">b ^ a</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span>b</span><span><span><span><span>​</span></span><span><span>a</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span>. Why? Think about <code>data Tri = Zelda | Link | Ganon</code>. Why are there eight inhabitants of <code>Tri -&gt; Bool</code>, but nine of <code>Bool -&gt; Tri</code>? It helps to write out each possible function. <sup id="fnref:answer"><a href="#fn:answer">1</a></sup> <sup id="fnref:bottom"><a href="#fn:bottom">2</a></sup></td>
    </tr>
  </tbody>
</table>

<h2 id="algebraic-manipulations">Algebraic manipulations</h2>

<p>Counting inhabitants is interesting and useful, but the connection runs much deeper! We can use it to gain insight into the nature of our datatypes. Let’s look at an example.</p>

<p>Consider <code>data Choice a = LeftChoice a | RightChoice a</code>, i.e. <span><span><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + a</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>+</span><span>a</span></span></span></span>. We can manipulate this using the familiar rules of algebra to the equivalent <span><span><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">2 \times a</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>2</span><span>×</span><span>a</span></span></span></span>, or <code>type Choice&#39; a = (Bool, a)</code>.</p>

<p>The manipulation was done using a rule we learned in grade school, before we’d ever heard of algebraic data types. What’s more, the rules of algebra were established centuries before algebraic data types were even invented. Yet the result makes sense. Our <code>Choice</code> data type tags each <code>a</code> as either a “left <code>a</code>” or a “right <code>a</code>.” Clearly it’s equivalent to <code>Choice</code>’s use of a boolean tag. Isn’t it remarkable that algebraic manipulations agree with our intuition?</p>

<p>Exercise for the reader: Explain why <code>Bool -&gt; a</code> is <em>not</em> equivalent to <code>Either a a</code>, but <em>is</em> equivalent to <code>(a, a)</code> both algebraically and intuitively.</p>

<p>Discovering I could do this felt very much like learning algebra for the first time – elegant, powerful, exciting. It raises the questions of what else one can do? How might we use this new tool? What new powers does it give us? Where does it fail?</p>

<h3 id="taylor-series">Taylor series</h3>

<p>We’re going to play fast and loose with notation for a moment. Bear with me.</p>

<p>Let’s start with the familiar <code>List</code> data type.</p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>List</span> <span>a</span> <span>=</span> <span>Nil</span> <span>|</span> <span>Cons</span> <span>a</span> <span>(</span><span>List</span> <span>a</span><span>)</span>

<span>-- or, with Haskell&#39;s special syntax</span>
<span>data</span> <span>[</span><span>a</span><span>]</span> <span>=</span> <span>[]</span> <span>|</span> <span>a</span> <span>:</span> <span>[</span><span>a</span><span>]</span></code></pre></figure>

<p>We can repeatedly expand the definition by expressing it with algebraic notation.</p>

<p><span><span><span><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>L</mi></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi><mo fence="true">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi><mo fence="true">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>a</mi><mn>3</mn></msup><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi><mo fence="true">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mo>…</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
L &amp; = 1 + a L \\
  &amp; = 1 + a \left(1 + a L\right) \\
  &amp; = 1 + a + a^2 \left(1 + a L\right) \\
  &amp; = 1 + a + a^2 + a^3 \left(1 + a L\right) \\
  &amp; = 1 + a + a^2 + a^3 + \ldots
\end{align}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span><span><span><span><span><span>​</span></span><span><span>L</span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span>​</span></span></span><span></span><span></span><span><span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span>L</span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span><span>(</span><span>1</span><span>+</span><span>a</span><span>L</span><span>)</span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span><span>(</span><span>1</span><span>+</span><span>a</span><span>L</span><span>)</span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span><span><span>(</span><span>1</span><span>+</span><span>a</span><span>L</span><span>)</span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>…</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></span></span></span></p>
<p>Remarkably, this makes sense. The last line tells us that a list is either <code>[]</code>, <code>[a]</code>, <code>[a, a]</code>, or <code>[a, a, a]</code>, and so on.</p>

<p>Neat trick, but let’s push our luck. The Taylor series for <span><span><math><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">1 / \left(1 - a\right)</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>1</span><span>/</span><span><span>(</span><span>1</span><span>−</span><span>a</span><span>)</span></span></span></span></span> is <span><span><math><semantics><mrow><mn>1</mn><mo>+</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mo>…</mo></mrow><annotation encoding="application/x-tex">1 + a + a^2 + a^3 + \ldots</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>1</span><span>+</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>…</span></span></span></span>, which we can use to bypass the manual expansion.</p>

<p><span><span><span><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>L</mi></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi></mrow></mtd></mtr><mtr><mtd><mrow><mi>L</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><mi>L</mi></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mrow><mo fence="true">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow><mi>L</mi></mrow></mtd><mtd><mrow><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mo>…</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
L &amp; = 1 + a L \\
L \left(1 - a\right) &amp; = 1 \\
L &amp; = 1 / \left(1 - a\right) \\
L &amp; = 1 + a + a^2 + a^3 + \ldots
\end{align}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span><span><span><span><span><span>​</span></span><span><span>L</span></span></span><span><span><span>​</span></span><span><span>L</span><span><span>(</span><span>1</span><span>−</span><span>a</span><span>)</span></span></span></span><span><span><span>​</span></span><span><span>L</span></span></span><span><span><span>​</span></span><span><span>L</span></span></span><span><span><span>​</span></span>​</span></span></span><span></span><span></span><span><span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span>L</span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>/</span><span><span>(</span><span>1</span><span>−</span><span>a</span><span>)</span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>1</span><span>+</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>…</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></span></span></span></p>
<p>Let’s pause for a moment to remember that we’re dealing with <em>types</em>. And the expression <code>1 / (1 - a)</code> contains both a <em>negative</em> and a <em>fractional</em> type, neither of which have a meaning yet. Let’s consider what they could possibly mean. Algebra tells us that <code>(1 - a) + a</code> = <code>1</code>. So, this data types combines either a <code>1 - a</code> or an <code>a</code>, to get just <code>1</code>. What? The fractional type is just as unintelligible – given a <code>1 / a</code> and an <code>a</code>, we have… <code>1</code>. In either case it seems we get out less than we put in! Some research has been done on deciphering some <a href="http://www.cs.indiana.edu/~sabry/papers/rational.pdf">meaning from this mess</a>, but I can’t use negative and fractional types without adopting the additional language semantics they propose. One final note – though we took some morally objectionable steps, using types we don’t have any justification for, we came out fine on the other end.</p>

<p>For fun, let’s try our luck with binary trees.</p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>BinaryTree</span> <span>a</span> <span>=</span> <span>Leaf</span> <span>a</span> <span>|</span> <span>Branch</span> <span>(</span><span>BinaryTree</span> <span>a</span><span>)</span> <span>(</span><span>BinaryTree</span> <span>a</span><span>)</span></code></pre></figure>

<h3 id="expansion-by-hand">Expansion by hand</h3>

<p><span><span><span><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>T</mi></mrow></mtd><mtd><mrow><mo>=</mo><mi>a</mi><mo>+</mo><msup><mi>T</mi><mn>2</mn></msup></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mi>a</mi><mo>+</mo><mo>(</mo><mi>a</mi><mo>+</mo><msup><mi>T</mi><mn>2</mn></msup><msup><mo>)</mo><mn>2</mn></msup></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>a</mi><msup><mi>T</mi><mn>2</mn></msup><mo>+</mo><msup><mi>T</mi><mn>4</mn></msup></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>5</mn><msup><mi>a</mi><mn>4</mn></msup><mo>+</mo><mn>1</mn><mn>4</mn><msup><mi>a</mi><mn>5</mn></msup><mo>+</mo><mo>…</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
T &amp; = a + T^2 \\
  &amp; = a + (a + T^2)^2 \\
  &amp; = a + a^2 + 2aT^2 + T^4 \\
  &amp; = ... \\
  &amp; = a + a^2 + 2 a^3 + 5 a^4 + 14 a^5 + \ldots
\end{align}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span><span><span><span><span><span>​</span></span><span><span>T</span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span>​</span></span></span><span></span><span></span><span><span><span><span><span>​</span></span><span><span>=</span><span>a</span><span>+</span><span><span>T</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>a</span><span>+</span><span>(</span><span>a</span><span>+</span><span><span>T</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span><span>)</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>2</span><span>a</span><span><span>T</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span><span>T</span><span><span><span><span>​</span></span><span><span>4</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>.</span><span>.</span><span>.</span></span></span><span><span><span>​</span></span><span><span>=</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>2</span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>5</span><span><span>a</span><span><span><span><span>​</span></span><span><span>4</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>1</span><span>4</span><span><span>a</span><span><span><span><span>​</span></span><span><span>5</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>…</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></span></span></span></p>
<h3 id="taylor-series-1">Taylor series</h3>

<p><span><span><span><math><semantics><mrow><mtable><mtr><mtd><mrow><mi>T</mi></mrow></mtd><mtd><mrow><mo>=</mo><mi>a</mi><mo>+</mo><msup><mi>T</mi><mn>2</mn></msup></mrow></mtd></mtr><mtr><mtd><mrow><msup><mi>T</mi><mn>2</mn></msup><mo>−</mo><mi>T</mi><mo>+</mo><mi>a</mi></mrow></mtd><mtd><mrow><mo>=</mo><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mi>T</mi></mrow></mtd><mtd><mrow><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msqrt><mrow><mn>1</mn><mo>−</mo><mn>4</mn><mi>a</mi></mrow></msqrt></mrow><mrow><mn>2</mn></mrow></mfrac></mrow></mtd></mtr><mtr><mtd><mrow><mi>T</mi></mrow></mtd><mtd><mrow><mo>=</mo><mi>a</mi><mo>+</mo><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><msup><mi>a</mi><mn>3</mn></msup><mo>+</mo><mn>5</mn><msup><mi>a</mi><mn>4</mn></msup><mo>+</mo><mn>1</mn><mn>4</mn><msup><mi>a</mi><mn>5</mn></msup><mo>+</mo><mo>…</mo></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
T &amp; = a + T^2 \\
T^2 - T + a &amp; = 0 \\
T &amp; = \frac{1 - \sqrt{1 - 4a}}{2} \\
T &amp; = a + a^2 + 2 a^3 + 5 a^4 + 14 a^5 + \ldots
\end{align}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span><span><span><span><span><span>​</span></span><span><span>T</span></span></span><span><span><span>​</span></span><span><span><span>T</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>−</span><span>T</span><span>+</span><span>a</span></span></span><span><span><span>​</span></span><span><span>T</span></span></span><span><span><span>​</span></span><span><span>T</span></span></span><span><span><span>​</span></span>​</span></span></span><span></span><span></span><span><span><span><span><span>​</span></span><span><span>=</span><span>a</span><span>+</span><span><span>T</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>0</span></span></span><span><span><span>​</span></span><span><span>=</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>2</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>1</span><span>−</span><span><span><span>√</span></span><span><span><span><span>​</span></span><span><span>1</span><span>−</span><span>4</span><span>a</span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>a</span><span>+</span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>2</span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>5</span><span><span>a</span><span><span><span><span>​</span></span><span><span>4</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>1</span><span>4</span><span><span>a</span><span><span><span><span>​</span></span><span><span>5</span></span></span><span><span><span>​</span></span>​</span></span></span><span>+</span><span>…</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></span></span></span></p>
<p>(By the way, those coefficients are the <a href="http://en.wikipedia.org/wiki/Catalan_number">Catalan numbers</a>)</p>

<p>This describes a binary tree as being either a single leaf, the tree with two leaves, one of the two trees with three leaves, or one of the five trees with four leaves, and so on. Finally a reward for our diligence! We can answer the question of how many ways there are to produce a binary tree with five leaves (14), or 11 (16796)!</p>

<p>As you might expect, an alternate definition of binary trees which can be empty produces almost exactly the same result. Try it for yourself!</p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>BinaryTree</span> <span>a</span> <span>=</span> <span>Leaf</span> <span>|</span> <span>Branch</span> <span>a</span> <span>(</span><span>BinaryTree</span> <span>a</span><span>)</span> <span>(</span><span>BinaryTree</span> <span>a</span><span>)</span></code></pre></figure>

<h3 id="trouble">Trouble</h3>

<p>Examining the <code>Nat</code> data structure shows that there are issues we haven’t yet considered. <sup id="fnref:peano"><a href="#fn:peano">3</a></sup></p>

<figure><pre><code data-lang="haskell"><span>data</span> <span>Nat</span> <span>=</span> <span>Zero</span> <span>|</span> <span>Succ</span> <span>Nat</span></code></pre></figure>

<p><span><span><span><math><semantics><mrow><mtext><mi mathvariant="normal">N</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mtext><mo>=</mo><mn>1</mn><mo>+</mo><mtext><mi mathvariant="normal">N</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">t</mi></mtext></mrow><annotation encoding="application/x-tex">\text{Nat} = 1 + \text{Nat}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span>N</span><span>a</span><span>t</span></span><span>=</span><span>1</span><span>+</span><span><span>N</span><span>a</span><span>t</span></span></span></span></span></span></p>
<p>This equation is clearly inconsistent, since <span><span><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">x = 1 + x</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>x</span><span>=</span><span>1</span><span>+</span><span>x</span></span></span></span> is false for all possible values of <span><span><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>x</span></span></span></span>. Why does this go wrong? Is it valid to just expand to <code>Nat = 1 + 1 + 1 + 1 + ...</code> (which is right), even though we can’t isolate <code>Nat</code> algebraically (and thus solve for it with Taylor series)?</p>

<h2 id="poking-holes-in-things">Poking holes in things</h2>

<p>It’s almost time for calculus on data types, and I want to get there just as desperately as you, dear reader, but we’ll require some motivation first. And so, it’s time for a brief interlude to think about poking holes in things. Yes, holes.</p>

<p>What do I mean by a hole? We want to find the places in our data structure where data could go, and remove it.</p>

<p>How many holes of type <code>a</code> can we find in a tuple?</p>

<table>
  <tbody>
    <tr>
      <td><span><span><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span>a</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span> has 2</td>
      <td><code>(a, a) -&gt; (_, a), (a, _)</code></td>
    </tr>
    <tr>
      <td><span><span><math><semantics><mrow><msup><mi>a</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">a^3</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span>a</span><span><span><span><span>​</span></span><span><span>3</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span> has 3</td>
      <td><code>(a, a, a) -&gt; (_, a, a), (a, _, a), (a, a, _)</code></td>
    </tr>
    <tr>
      <td><span><span><math><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>×</span><span>b</span></span></span></span> has 1</td>
      <td><code>(a, b) -&gt; (_, b)</code> (remember we’re looking for holes of type <code>a</code>)</td>
    </tr>
    <tr>
      <td><span><span><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a+a</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>+</span><span>a</span></span></span></span> has 2</td>
      <td><code>Either a a -&gt; Left _, Right _</code></td>
    </tr>
    <tr>
      <td><span><span><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>a</span><span>+</span><span>b</span></span></span></span> has 1</td>
      <td><code>Either a b -&gt; Left _</code></td>
    </tr>
    <tr>
      <td><span><span><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>b</span></span></span></span> has 0</td>
      <td> </td>
    </tr>
    <tr>
      <td><span><span><math><semantics><mrow><mo>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>)</mo><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">(a + b) \times b</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>(</span><span>a</span><span>+</span><span>b</span><span>)</span><span>×</span><span>b</span></span></span></span> has 1</td>
      <td><code>(Either a b, b) -&gt; (Left _, b)</code></td>
    </tr>
  </tbody>
</table>

<p>We can make a few observations:</p>

<ul>
  <li>Data types with no <code>a</code>s (constants) have no holes of type <code>a</code>.</li>
  <li>The number of holes in a sum is the sum of the number of holes in each side.</li>
  <li>The number of holes in a product is the number of positions in the product times the number of ways to make a hole in each of those positions.</li>
</ul>

<p>And with that we’ve finally made it. Ready for the big reveal? The rules we just saw are mysteriously similar to the familiar rules of differentiation. Differentiation tells us how to poke holes in data types. Read <span><span><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial a}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span></span></span></span> as “the of holes of type <code>a</code>”:</p>

<table>
  <tbody>
    <tr>
      <td>There are no holes in a constant</td>
      <td><span><span><math><semantics><mrow><msub><mi mathvariant="normal">∂</mi><mi>a</mi></msub><mi>c</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\partial_a c = 0</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span>∂</span><span><span><span><span>​</span></span><span><span>a</span></span></span><span><span><span>​</span></span>​</span></span></span><span>c</span><span>=</span><span>0</span></span></span></span></td>
    </tr>
    <tr>
      <td>Sums are straightforward</td>
      <td><span><span><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>+</mo><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>+</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial a} f(a) + g(a) = \frac{\partial}{\partial a} f(a) + \frac{\partial}{\partial a} g(a)</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>f</span><span>(</span><span>a</span><span>)</span><span>+</span><span>g</span><span>(</span><span>a</span><span>)</span><span>=</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>f</span><span>(</span><span>a</span><span>)</span><span>+</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>g</span><span>(</span><span>a</span><span>)</span></span></span></span></td>
    </tr>
    <tr>
      <td>As are products</td>
      <td><span><span><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>×</mo><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>×</mo><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>+</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo><mo>×</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>g</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial a} f(a) \times g(a) = \frac{\partial}{\partial a} f(a) \times g(a) + f(a) \times \frac{\partial}{\partial a} g(a)</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>f</span><span>(</span><span>a</span><span>)</span><span>×</span><span>g</span><span>(</span><span>a</span><span>)</span><span>=</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>f</span><span>(</span><span>a</span><span>)</span><span>×</span><span>g</span><span>(</span><span>a</span><span>)</span><span>+</span><span>f</span><span>(</span><span>a</span><span>)</span><span>×</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>g</span><span>(</span><span>a</span><span>)</span></span></span></span></td>
    </tr>
    <tr>
      <td>The chain rule still applies for composition</td>
      <td><span><span><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mrow><mo fence="true">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>f</mi><mo>∘</mo><mi>g</mi><mo fence="true">)</mo></mrow><mo>×</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mi>g</mi></mrow><annotation encoding="application/x-tex">\frac{\partial}{\partial a} \left(f \circ g\right) = \left(\frac{\partial}{\partial a} f \circ g\right) \times \frac{\partial}{\partial a} g</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span><span>(</span><span>f</span><span>∘</span><span>g</span><span>)</span></span><span>=</span><span><span><span>(</span></span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>f</span><span>∘</span><span>g</span><span><span>)</span></span></span><span>×</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span>g</span></span></span></span></td>
    </tr>
  </tbody>
</table>

<p>Let’s take a moment to marvel at the fact that differentiation, a tool developed by Newton and Leibniz over 300 years ago for physics, has made an unexpected appearance in the most discrete of settings. The correspondence was <a href="http://strictlypositive.org/calculus/">noticed in 2001</a> by Conor McBride.</p>

<h2 id="the-zipper">The zipper</h2>

<p>The <a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">zipper</a> is a way to “focus” on one element of a data structure, in order to edit it efficiently. The name is meant to evoke “going up and down in the structure … analogous to closing and opening a zipper in a piece of clothing.”</p>

<p>I’ll demonstrate with a list.</p>

<div><pre><code>: -&gt; : -&gt; : -&gt; : -&gt; []
|    |    |    |
1    2    3    4
</code></pre></div>
<p>Let’s focus on the <code>3</code>.</p>

<div><pre><code>[] &lt;- : &lt;- : &lt;- FOCUS -&gt; : -&gt; []
      |    |      |      |
      1    2      3      4
</code></pre></div>
<p>We can move left:</p>

<div><pre><code>[] &lt;- : &lt;- FOCUS -&gt; : -&gt; : -&gt; []
      |      |      |    |
      1      2      3    4
</code></pre></div>
<p>Or right:</p>

<div><pre><code>[] &lt;- : &lt;- : &lt;- : &lt;- FOCUS -&gt; []
      |    |    |      |
      1    2    3      4
</code></pre></div>
<p>With each operation taking constant time.</p>

<p>What did we just accomplish? Normally editing an arbitrary list element is O(n), but each zipper operation is O(1).</p>

<p>Relating this back to holes, we see that our zipper was constructed by poking a hole in the list.</p>

<p>Reminder what lists look like:</p>

<p><span><span><span><math><semantics><mrow><mi>L</mi><mo>=</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">L = 1 + aL</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span>L</span><span>=</span><span>1</span><span>+</span><span>a</span><span>L</span></span></span></span></span></p>
<p>What results from poking out the <code>a</code>s?</p>

<p><span><span><span><math><semantics><mrow><mtable><mtr><mtd><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac></mrow></mtd><mtd><mrow><mo>=</mo><mfrac><mrow><mi mathvariant="normal">∂</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><mi>a</mi><mi>L</mi><mo fence="true">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><mi>L</mi><mo>+</mo><mi>a</mi><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
\frac{\partial L}{\partial a} &amp; = \frac{\partial}{\partial a} \left(1 + a L\right) \\
&amp; = L + a \frac{\partial L}{\partial a}
\end{align}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span><span><span><span><span><span>​</span></span><span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span><span>L</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span>​</span></span></span><span></span><span></span><span><span><span><span><span>​</span></span><span><span>=</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span><span><span>(</span><span>1</span><span>+</span><span>a</span><span>L</span><span>)</span></span></span></span><span><span><span>​</span></span><span><span>=</span><span>L</span><span>+</span><span>a</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span><span>L</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><math><semantics><mrow><mtable><mtr><mtd><mrow><mfrac><mrow><mi mathvariant="normal">∂</mi><mi>L</mi></mrow><mrow><mi mathvariant="normal">∂</mi><mi>a</mi></mrow></mfrac></mrow></mtd><mtd><mrow><mo>=</mo><mfrac><mrow><mi>L</mi></mrow><mrow><mn>1</mn><mo>−</mo><mi>a</mi></mrow></mfrac></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mo>=</mo><msup><mi>L</mi><mn>2</mn></msup></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{align}
\frac{\partial L}{\partial a} &amp; = \frac{L}{1 - a} \\
&amp; = L^2
\end{align}</annotation></semantics></math></span><span aria-hidden="true"><span></span><span></span><span><span><span><span><span><span><span><span>​</span></span><span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>∂</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>∂</span><span>L</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span>​</span></span></span><span></span><span></span><span><span><span><span><span>​</span></span><span><span>=</span><span><span></span><span><span><span><span><span>​</span></span><span><span><span>1</span><span>−</span><span>a</span></span></span></span><span><span><span>​</span></span><span></span></span><span><span><span>​</span></span><span><span><span>L</span></span></span></span><span><span><span>​</span></span>​</span></span></span><span></span></span></span></span><span><span><span>​</span></span><span><span>=</span><span><span>L</span><span><span><span><span>​</span></span><span><span>2</span></span></span><span><span><span>​</span></span>​</span></span></span></span></span><span><span><span>​</span></span>​</span></span></span></span></span></span></span></span></span></p>
<p>Looking back at the diagrams above, we can see that <code>L^2</code> is exactly the type of our focused structure, with one list pointing left and one pointing right.</p>

<p>What just happened? Differentiating a data structure gave us the type of its context, which can be used as a zipper. In fact, differentiation can be used to build zippers for arbitrary ADTs – trees, maps, etc.</p>

<h2 id="disappointing-news">Disappointing news</h2>

<p>Can we extend the analogy to integration? Why does differentiation make a surprise appearance here? Unfortunately, I can’t answer either question.</p>

<p>I frankly have no clue how to interpret integration. As for why the rules for differentiation and hole-poking are the same, the best I can do is to point out that our goal is nearly the same in either case. In differentiation, the goal is to see how a function varies as one of its variables varies. In hole-poking, the goal is to see how a data structure changes as we examine one type variable. In either case, we need to see how our data changes as we vary the variable, in each place it occurs.</p>

<h2 id="summary">Summary</h2>

<p>Algebraic data types are aptly named, for they bear a remarkably strong resemblance to the algebra we’re familiar with. This allows us to count the inhabitants of a type and manipulate data types between equivalent forms. Further, we can extend the analogy as far as calculus, where differentiation helps us build zippers for any data type.</p>

<h2 id="epilogue">Epilogue</h2>

<p>I called our data type manipulations a “coincidence,” but the connection actually rests on solid mathematical ground. Our tricks can be justified by the fact that ADTs <a href="https://pavpanchekha.com/blog/zippers/derivative.html#sec-2">form a semiring</a>.</p>

<p>We explored ADTs thoroughly, but only had time to scratch the surface of zippers. The rabbit hole is very deep, but I can send you straight to the bottom. Rather than taking the data structure view, Oleg Kiselyov advocates for zippers as the delimited continuation of a traversal, and has gone so far as creating a zipper filesystem, <a href="http://okmij.org/ftp/continuations/zipper.html">ZipperFS</a>, and zippers with several holes. This is just one example of the large body of work on zippers.</p>



  </article></div>
  </body>
</html>
