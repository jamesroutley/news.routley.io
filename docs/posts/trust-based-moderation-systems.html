<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://cblgh.org/trustnet/">Original</a>
    <h1>Trust-based moderation systems</h1>
    
    <div id="readability-page-1" class="page"><div><article>

<p><em>preface</em></p>

<ul>
<li><em>for more information, <a href="https://cblgh.org/dl/trustnet-cblgh.pdf">read the full 103-page Master’s Thesis report (~4MB)</a></em></li>
<li><em>if you are able to support independent research, see <a href="https://cblgh.org/support.html">cblgh.org/support</a></em></li>
<li><em>code &amp; repository links at the bottom of this article</em></li>
</ul>

<h2>Trust-based Moderation Systems</h2>

<p>How do you remove malicious participants from a chat? For a set of participants, what are the steps needed such that the
malicious participant is no longer visible by anyone in the set?</p>

<p>In the centralized context, removing a malicious participant is the action of a moderator. Usually it is one or two
clicks, and the malicious participant has been removed for all other participants.</p>

<p>In a distributed context, there are many possible answers to this problem. The first and naive solution is to delegate
the responsibility of removing the malicious participant to each individual participant. Thus everyone participating has
to individually hide offenders. Viewed as an isolated case it works, but repeated instances will risk causing an outsize
burden on the participants.</p>

<p>Traditional moderation systems grant a special privilege to the initiator of the chat group. This can become problematic
for many reasons. The initiator may disappear, leaving the group moderation-less. Similarly, the initiator may be adept
at starting new contexts, but lacking in skill concerning matters of moderation (e.g. assigning new moderators).
Finally, issues may arise where previously good moderators have a falling out and start banning people, as demonstrated
in increasing frequency by large community-driven Mastodon instances.</p>

<p>A subjective system, where participants can themselves decide who moderates on their behalf, sidesteps the mentioned
problems. Additionally, the mechanism of freely allowing multiple people to moderate also spreads out the invisible
care-giving labour required to keep a community free from abuse.</p>

<p>This work explores an approach to implementing a subjective, trust-based system.</p>

<p>What if participants could automatically block the malicious peer, if they discover that the peer has been blocked by
someone the participant trusts? This is similar to the administrator from the centralized context, but more flexible. In
the centralized context, if the administrator is misbehaving and a participant loses trust in them, their only options
are to live with it, or to leave the group. In the system where you effectively choose who can moderate for you, you can
also choose to revert that decision if your trust later proves to have been misplaced.</p>

<p>How this can be achieved will be explored in the rest of this post in the form of a new system for managing and
interacting with trust, <strong>TrustNet</strong>.</p>

<h2>Trust Network</h2>

<p>The proposed system, <strong>TrustNet</strong>, is a system for interacting with and
managing trust. Underlying the system is a transitive trust algorithm. The
system as a whole was originally intended for use in combination with
peer-to-peer distributed chat systems, where peers assign trust (a value
between 0.0 and 1.0; 1.0 being complete trust, 0.0 the complete absence of
trust) to other peers.</p>

<h4>Trust Spectrum</h4>

<pre><code>    Trust weight (t)  Semantic         Human-meaningful label
    ----------------------------------------------------------
    t == 0            no trust         New person
    0 &lt; t &lt; 0.25      low trust        Acquaintance
    0.25 &gt;= t &lt; 0.75  medium trust     Friend
    0.75 &gt;= t &lt; 1.0   high trust       Peer
    t == 1            complete trust   Partner
</code></pre>

<p>In the above plot, we can see how different trust weights have different meanings. A trust weight between 0 and 0.25 is
equivalent to <em>low trust</em>. But using direct trust weights, or the semantic labels, does not meaningfully translate to
any real life situation. Thus, any system that allows people to issue trust to each other should have labels which are
natural for people to use, enabling them to interface with the system in a way that causes for less individual
distortions.</p>

<p>For Alice’s semantics regarding a trust assignment of 0.65 might differ from Bob’s view of what a trust level of 0.65
means, but they both have notions of <strong>friend</strong> which is more likely to converge than pure floating point
representations of trust.</p>

<p><em>Note</em>: the labels that are to be used should ideally be specific to the trust area. It might make less sense to use the
label <em>friend</em> in a trust area of <em>music recommendations</em> as compared to using the label <em>good taste</em>, for instance.</p>

<h4>Trust Areas</h4>

<p>Trust is assigned in a <strong>trust area</strong>. The trust area acts as a grouping for related trust assignments; trust is only
transitive within a given trust area.  Example of trust areas could be <em>moderation</em> or <em>music recommendation</em>, for
example.</p>

<p>Thus, the trust area captures the <strong>context</strong> that the trust is extended within; for outside of the realm of computers, we trust
each other varying amounts depending on a given domain. Friends I trust for financial advice may have <em>horrible</em> taste in
music, for example.</p>

<p>In the remaining text, we will be talking about how TrustNet works within a given trust area.</p>

<h4>Transitive Trust</h4>

<p>With the issued trust assignments as a basis, a trust network is then discovered for a particular peer by following
their outgoing trust assignments transitively. So, for a particular peer, we find the set of peers that they trust. For
each peer in the set of trusted peers, get the set of peers that <em>they</em> trust. And so on, for a maximum path-length
between 3-6 nodes away from the root.</p>

<p>We now have a basic trust graph, with a starting node and the peers they (transitively) trust. The varying levels of trust
between nodes are represented by weighted and directed edges. Using this weighted trust graph we can now calculate a
list of the most trusted peers for the starting node.</p>

<h2>Trust Computation</h2>

<p>To find the most trusted peers, we use
<a href="http://www2.informatik.uni-freiburg.de/~cziegler/papers/ISF-05-CR.pdf">Appleseed</a>, a peer-reviewed algorithm and trust
metric which was proposed in the mid 2000s by Cai-Nicolas Ziegler and Georg Lausen from the University of Freiburg.
Appleseed operates on precisely the kind of weighted graph structure we have described, and it is also guaranteed to
converge after a variable (but finite) number of iterations.  Appleseed, once converged, produces a ranking of the most
trusted peers.</p>

<p>Appleseed produces its rankings by effectively releasing a predefined amount of energy at the trust source, or starting
node, and letting that energy flow
through the trust relations. The energy pools up in the nodes of the graph,
with more energy remaining with the more trusted peers. After the computation
has converged, each peer has captured a portion of the initial energy, where the
peer with the most energy is regarded as the most trusted.  The initial amount
of energy is also completely distributed across the nodes in the trust graph,
meaning there are no losses after convergence.</p>

<p>The computed trust ranking contains the same nodes as the initial weighted
trust graph. Thus, it is a list where the most trusted peers are at the top of the
list, and the peers with the least amount of trust (but still trusted) are at
the bottom. In order to make this list of peers actionable and more useful, TrustNet
uses something called <em>ranking strategies</em>. A ranking strategy basically
operates on the ranked list and produces a subet of it, according to the chosen
strategy.</p>

<h2>Ranking strategies</h2>

<p>One ranking strategy: from the list of peers, pick the most trusted peer. Or, more generally, pick the <code>N</code> most trusted
peers. Another form of strategy would be to use a clustering algorithm to identify clusters of nodes with similar ranks,
creating groupings of high trusted peers, as well as medium trusted and low trusted peers. This latter strategy is what
TrustNet uses to find its most trusted peers.</p>

<h4>Clustering Strategy</h4>

<p>The clustering strategy relies on the <a href="https://en.wikipedia.org/wiki/K-means_clustering">k-means clustering algorithm</a>,
breaking Appleseed’s produced ranking into three groups. The group containing the lowest trust ranks is discarded, and
the remaining two are merged, representing TrustNet’s trusted peers.</p>

<h4>Low Trust Graphs</h4>

<p>One caveat with all strategies is that, while the rankings produce the most
trusted peers for the given trust graph, we might be operating on a graph based
in low amounts of trust. That is, a graph where the trust source has only
issued trust assignments with low trust weights: 0.1 instead of 0.75, for
example. In this case, we would still get a ranking where one peer has the
highest amount of trust, but it would be a relatively low trusted peer in terms
of the trust source. The reason we end up with a low trust graph has to do with
how Appleseed’s rankings are computed. The rankings returned from Appleseed are
effectively calculated in proportion to the initial set of trust assignments
issued by the trust source. Thus, Appleseed’s trust ranking will contain more
reliable results if the trust source has issued at least one higher trust
assignment, as the rest of the trust graph’s edges will be placed in relation
to the trust source’s higher trust assignment.</p>

<p>A meta strategy could take this into consideration by also looking at the initial trust weights. The strategy could
return an empty list if it discovers that the initial peer does not have any direct outgoing trust assignments of medium
or high weights. TrustNet implements this type of <strong>threshold strategy</strong>.</p>

<h4>A Note on Trusted Peers</h4>

<p>TrustNet uses a clustering technique to get the most trusted peers, in combination with the described trust threshold.
Importantly, however, <strong>any peer which has been directly trusted is added to the pool of most trusted peers</strong>. Because,
if you know somebody and you trust them, then of course they are to be regarded as trusted.</p>

<p>The trust weight, then, acts more as classifying a <strong>similarity in judgement</strong>, where a higher trust weight entails a
greater similarity. Thus, higher trust weights can be seen as being granted a greater recommendation influence. You
might trust your best friend, but you also know that they aren’t that reliable for recommendations. Thus you assign a
lower trust weight to them, lessening their impact with regard to recommendations for others to trust, while still being
able to rely on them for moderation.</p>

<h2>Usecases of a Trust Network</h2>

<p>You have a network of peers (with varying levels of trust) and running Appleseed gets you a ranking of those peers. We
run the computed rankings through a ranking strategy and end up with an actionable list of trusted peers.</p>

<p>We can use this curated list of trusted peers in multiple ways:</p>

<ul>
<li>Implement moderation, essentially granting the trusted peers moderator powers to act on your behalf. This effectively
creates a dynamic blocklist, with many sources. The peer moderators and their changes can also be revoked if abused:
you stop trusting them, unassigning any previously assigned trust.</li>
<li>Regard the list as a set of trusted sources from which to request secondary indexes in a distributed network.</li>
<li>Use the rankings as a suggestion on whom to follow / become friends with / talk more with.</li>
<li>Filter the greater network to only show messages from the trusted network. Make it is togglable.</li>
<li>Allow pooling of trust behind actions: if many medium to low trusted (they are still trusted, just low amounts) peers
commit to an action, then that collectively adds up to an amount of weight/trust behind that action.</li>
<li>Use the rankings to inform recommendations within a particular kind of domain (e.g. having a domain of ‘music taste’,
and using the trust weight for each peer as an indication of music taste, higher being more aligned music
taste/subjectively better music taste) .</li>
<li>Use rankings in combination with news articles/sources to vet ‘fake news’ from reputable sources.</li>
<li>Automatically fetch resources / images / binary blobs from those within your trust network, while resources from those
outside of the trusted peers might be fetched manually.</li>
<li>Perform computations issued from within the trust network.</li>
</ul>

<h2>The Replication Layer</h2>

<p>The proposed system does not live in isolation, there are so called peers who have to perform trust assignments. These
peers come from other systems, distributed protocols whose primary use at the moment are for chat. Systems like <a href="https://ssb.nz">Secure
Scuttlebutt</a>, a gossip based network, or <a href="https://cabal.chat">Cabal</a>, a peer-to-peer chat platform.</p>

<p><img src="https://cblgh.org/media/trustnet-structure.png" alt="The TrustNet structure"/></p>

<p>A peer in these systems typically consists of an ed25519 keypair, which writes messages to a log and shares the log with
other peers. Each message is signed by the peer’s private key, establishing authenticity of the message. Any peer can
store and transmit the log of any other peer, which is how information propagates through the system.</p>

<p>This replication layer differs between protocols, but what remains the same in these systems is that every peer locally
stores all of the messages for any other peer it can see in the network. In Cabal, all peers connect to the same
identifier and will eventually see each other. In Secure Scuttlebutt the replication layer consists of follow relations,
where a peer will replicate the peers they follow, and often one or two hops further. If a client is configured for two
hop replication that means that a peer will replicate every peer they follow and also every followed peer of that
first-order peer.</p>

<p>The replication layer is fundamentally the database of the local peer, and thus the substrate from which the trust
graph, with its trust assignments, can be constructed. So, to be explicit, the trust network (or trust layer) lives ontop of
the replication layer; it is fed the replicated data.</p>

<p>A trust assignment would be another message type in these systems, one with a type that indentifies it as a trust
assignment and which contains:</p>

<ul>
<li>a <strong>trust weight</strong> (between 0.0 and 1.0),</li>
<li>a <strong>trust target</strong> (the public key which is being assigned trust),</li>
<li>the <strong>trust area</strong> (e.g. moderation, or music recommendations),</li>
<li>as well as the <strong>trust source</strong> (the id of the peer issuing the trust assignment).</li>
</ul>

<p>To construct the weighted trust graph of a particular peer we would do the following:</p>

<ul>
<li>In the peer’s log, find all messages which are trust assignments. By definition, these are the trust assignments
issued by this peer.</li>
<li>For each trust assignment: get the target and find all of their trust assignments.</li>
<li>Repeat this until we run out of trust assignments, or we have a maximum path length from the root to a leaf node in the
graph of no more than 3-6 nodes.</li>
</ul>

<p>To update the trust graph, we keep track of the latest message of each peer’s log. When new messages arrive, scan
them to see if there are any new trust assignments. If there are, signal that we need to reconstruct the trust graph.</p>

<p>Implementation-wise, one would reconstruct the graph after a timeout. The timeout is refreshed each time a new message
comes in from a log. This ensures that the trust graph is not constantly being reconstructed, which could be the case if
we recently reconnected to the Internet for the first time in a few weeks and are in the middle of syncing up with peers.</p>

<p>Once we have all of the trust assignments for the trust graph, we normalise them to the form that TrustNet consumes.
After trust computation has been performed with Appleseed, and the resulting ranked list has been produced, and a
ranking strategy has been used, we now have a list of trusted peers.</p>

<p>Using the trusted peers we can now look at what moderation actions they have issued, and automatically issue our own as a result of
theirs.</p>

<h2>Subjective Moderation &amp; Disambiguating Intentions</h2>

<p>A moderation action has a set of semantics that need to be regarded in order for a subjective moderation system to
function according to the expectations of its participants. We will illustrate the semantics by looking closely at the
<strong>hide</strong> action, which hides all content originating from the hidden peer.</p>

<p>We propose that there are three modes of the hide action for a subjective moderation system: the <strong>personal</strong>,
<strong>network</strong>, and <strong>propagated</strong> modes. The three modes can be implemented in various ways, but they need to exist in
some form in order to disambiguate the <strong>intention</strong> of the hide. We will now detail the three modes and the intentions
they are intended to represent.</p>

<h4>Personal</h4>

<p>A personal hide is issued for the local participant and does not necessarily signal anything other than the
participant not wanting to see the hidden participant anymore. A personal hide may be <strong>private</strong>, i.e. not transmitted
in a format readable by any other participant (that is, it is encrypted to the local participant only).</p>

<p>The personal hide exists to reflect that, while the hide action is issued for a valid reason, it is purely personal and
does not by necessity mean that other peers should issue hides of their own.</p>

<h4>Network</h4>

<p>A network hide is issued by a participant to signal to others who trust them that they, too, should hide the hidden
participant.  Thus, the network hide is the mechanism by which one participant can signal and warn others of a malicious
participant.</p>

<h4>Propagated</h4>

<p>A propagated hide is issued as a <strong>result</strong> of a network hide by another, trusted participant; i.e. it has been
<strong>propagated</strong> from a network hide. Propagated actions should not result in further actions—it is propagat<strong>ed</strong>, not
propagat<strong>ing</strong>.</p>

<p>The propagated hide needs to exist so that hides that were issued as a result of trust in another participant can be
tracked to their origin and also revoked, if the trust has been lost.</p>

<h2>On Distrust</h2>

<p>The proposed system is transitive, meaning that there will be indirect trust relations by way of those whom you trust
directly. This works out in a lot of cases but, occasionally, someone you trust will trust someone else whom you have
had bad experiences with, and now distrust. Distrust can be be implemented in multiple ways, the simplest (and most
robust) is to remove the distrusted nodes from the trust graph before computing.</p>

<p>For social reasons, these distrust statements are advised to be stored in a way which is unreadable to other peers. This
could be in an encrypted format, or purely locally, unpublished to the peer’s log. Thus, after having constructed
the transitive trust graph, we perform a final search through it, comparing each node to the list of distrusted public keys we
maintain locally. If we find someone we distrust, we remove their node and the subgraph that extends out from them.</p>

<p>The reason we remove people which the distrusted peer trusts is that it is difficult to make any statements, or draw any
conclusions, concerning a distrusted node. Maybe you hate them as a person, which is why you distrust them. Or they are
someone you like a lot, but they just happen to differ too much in judgement as compared to yourself, so you distrust them to
exclude their judgement from the final trust network.</p>

<h2>Conclusion</h2>

<p>TrustNet is a system for representing, and interacting with, computational trust. The system is comprised of a trust
metric, a system for trust propagation, and it takes distrust into account. Most importantly, it provides a simple
interface for using and interacting with the results of the trust propagation.</p>

<h4>Report</h4>

<p>If you wish to know more, or you have any questions, <a href="https://cblgh.org/dl/trustnet-cblgh.pdf"><strong>read the report</strong></a>.</p>

<p>It may be long, but it is easy to read. Areas such as <em>public-key cryptography</em>, <em>peer-to-peer</em> and <em>distributed
systems</em>, <a href="https://cabal.chat">Cabal</a> and <a href="https://ssb.nz">Secure Scuttlebutt</a>, <em>trust</em> and <em>computational trust</em>, are
all introduced, <strong>without expectations of prior knowledge</strong>. Appleseed and TrustNet, the core of this work, are of
course also thoroughly introduced and described.</p>

<p>Particularly recommended are <strong>Chapter 5 (Trust)</strong>, <strong>Chapter 6 (Appleseed)</strong>, and <strong>Chapter 7 (TrustNet)</strong>, if you are already
familiar with peer-to-peer systems and moderation.</p>

<h4>Code</h4>

<ul>
<li><a href="https://github.com/cblgh/trustnet">Visit the TrustNet repository</a></li>
<li><a href="https://github.com/cblgh/appleseed-metric">Visit the Appleseed repository</a></li>
</ul>

<p>Both repositories contain full documentation, and an assortment of tests.</p>

<h4>Presentation</h4>

<p>If you want to watch my thesis presentation, which describes the above with other words and with examples, <a href="https://www.youtube.com/watch?v=bVkesgWZlTU"><strong>see the
presentation</strong></a>.</p>

<p>In the presentation, I show an interactive demo I built as part of the thesis. If there is an interest, I can look at
finishing the demo such that it can be put online for others to explore.</p>

<h4>Fin.</h4>

<p>Finally, for more independent research like this, and you are able: <a href="https://cblgh.org/support.html"><strong>support me</strong></a>.</p>

<p>Thank you for reading,</p>
</article></div></div>
  </body>
</html>
