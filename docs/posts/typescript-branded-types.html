<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://prosopo.io/articles/typescript-branding/">Original</a>
    <h1>TypeScript: Branded Types</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p><strong><a href="https://prosopo.io/articles/typescript-mapped-type-magic/">PART 1: TypeScript Mapped Type Magic</a></strong></p><p>Ahoy there TypeScript warriors! üëã Today we&#39;re extending our work in the <a href="https://prosopo.io/articles/typescript-mapped-type-magic/">TypeScript mapped types article</a> to provide <em>branding</em>. The previous article discussed how to use TypeScript mapped types in a nominal rather than structural nature.</p><pre><code><span>type</span> <span><span>A</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span>
<span>}</span>

<span>type</span> <span><span>B</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span>
<span>}</span></code></pre><p>This is a fancy way of saying TypeScript is structural by default, i.e. it will see type <code>A</code> and <code>B</code> as equal when dealing with types. Making type <code>A</code> and <code>B</code> nominal would make TypeScript differentiate them apart, even though their structure is the same.</p><p>In this post, we&#39;re building on that work to produce a way to <em>brand</em> a type, providing an automated and easy-to-use way of making a type nominal. Branding focuses on the type system only, rather than introducing runtime fields like in the previous post, which is a major benefit over the previous approach.</p><h2>What&#39;s the problem?</h2><p>Branding, also known as opaque types, enable differentiation of types in TypeScript which otherwise would be classified as the same type. For example</p><pre><code>
<span>type</span> <span><span>A</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span>

<span>type</span> <span><span>B</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span>
</code></pre><p><code>A</code> and <code>B</code> are structurally the same, ergo TypeScript accepts any instance of <code>A</code> or <code>B</code> in place of each other:</p><pre><code>
<span>const</span> <span>fn</span> <span>=</span> <span>(</span>a<span>:</span> <span>A</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;do something with A&#39;</span><span>)</span>
<span>}</span>

<span>const</span> obj<span>:</span> <span>B</span> <span>=</span> <span>{</span>
    x<span>:</span> <span>1</span><span>,</span>
    y<span>:</span> <span>true</span><span>,</span>
    z<span>:</span> <span>&#39;hello&#39;</span>
<span>}</span>

<span>fn</span><span>(</span>obj<span>)</span> </code></pre><p>The function is looking for a value of type <code>A</code> as input, whereas we&#39;re passing it a value of type <code>B</code>. TypeScript compares the types structurally, and because they have exactly the same structure it deems this operation to be fine.</p><p>But what if we need to tell <code>A</code> and <code>B</code> apart? What if, conceptually speaking, they must be different? What if we&#39;re doing something fancy with <code>A</code> and <code>B</code> which TypeScript is unaware of but we require the types to be different? That&#39;s exactly the situation we found ourselves in lately!</p><p>We need branding to do exactly that.</p><h2>The solution</h2><p>Much like in the <a href="https://prosopo.io/articles/typescript-mapped-type-magic/">TypeScript mapped types article</a>, the key lies in creating a field with the name of a symbol to act as our <em>id</em>. However, with branding we only need this field at a type-level rather than the runtime-level. Since types are erased after compilation, we need to add this field to a type without altering the runtime data whatsoever. Casting, anyone?</p><p>First, lets introduce the <code>brand</code> field.</p><pre><code>
<span>const</span> brand <span>=</span> <span>Symbol</span><span>(</span><span>&#39;brand&#39;</span><span>)</span> 

<span>type</span> <span><span>A</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span> <span>&amp;</span> <span>{</span>
    <span>[</span>brand<span>]</span><span>:</span> <span>&#39;A&#39;</span>
<span>}</span></code></pre><p>Here we&#39;re adding the <code>brand</code> field to type <code>A</code>. The brand field name is a symbol, akin to a UUID. We use a symbol to ensure the <code>brand</code> field never clashes with any other field for <code>A</code>, because we&#39;d be overwriting a field otherwise and introducing the worse kind of bugs: type bugs üêõ . We&#39;ve set the brand to <code>&#39;A&#39;</code> at the moment, though this could be anything you desire. It&#39;s akin to the type name. Now let&#39;s compare <code>A</code> and <code>B</code> again:</p><pre><code>
<span>const</span> <span>fn</span> <span>=</span> <span>(</span>a<span>:</span> <span>A</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;do something with A&#39;</span><span>)</span>
<span>}</span>

<span>const</span> obj<span>:</span> <span>B</span> <span>=</span> <span>{</span>
    x<span>:</span> <span>1</span><span>,</span>
    y<span>:</span> <span>true</span><span>,</span>
    z<span>:</span> <span>&#39;hello&#39;</span>
<span>}</span>

<span>fn</span><span>(</span>obj<span>)</span> </code></pre><p>Here&#39;s the error:</p><pre><code>Argument of type &#39;B&#39; is not assignable to parameter of type &#39;A&#39;.
  Property &#39;[brand]&#39; is missing in type &#39;B&#39; but required in type &#39;{ [brand]: &#34;a&#34;; }&#39;.ts(2345)
</code></pre><p>TypeScript won&#39;t let us pass an instance of <code>B</code> to the function accepting <code>A</code> because it&#39;s missing the <code>brand</code> field - brilliant! <code>A</code> and <code>B</code> are now different types. But what about if <code>B</code> had its own brand?</p><pre><code>
<span>type</span> <span><span>B</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span> <span>&amp;</span> <span>{</span>
    <span>[</span>brand<span>]</span><span>:</span> <span>&#39;B&#39;</span>
<span>}</span></code></pre><p>Note that we&#39;re using the same <code>brand</code> variable from before. It&#39;s important to keep this constant, otherwise we&#39;re declaring fields with different names!</p><p>Now lets try the function again:</p><pre><code>
<span>const</span> <span>fn</span> <span>=</span> <span>(</span>a<span>:</span> <span>A</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;do something with A&#39;</span><span>)</span>
<span>}</span>

<span>const</span> obj<span>:</span> <span>B</span> <span>=</span> <span>{</span>
    x<span>:</span> <span>1</span><span>,</span>
    y<span>:</span> <span>true</span><span>,</span>
    z<span>:</span> <span>&#39;hello&#39;</span>
<span>}</span>

<span>fn</span><span>(</span>obj<span>)</span> </code></pre><p>And here&#39;s the error</p><pre><code>Argument of type &#39;B&#39; is not assignable to parameter of type &#39;A&#39;.
  Type &#39;B&#39; is not assignable to type &#39;{ [brand]: &#34;A&#34;; }&#39;.
    Types of property &#39;[brand]&#39; are incompatible.
      Type &#39;&#34;B&#34;&#39; is not assignable to type &#39;&#34;A&#34;&#39;.ts(2345)
</code></pre><p>There we go! The error is saying that though both types have a <code>brand</code> field, the value for the brand is different for the two types, i.e. <code>&#39;A&#39; != &#39;B&#39;</code>!</p><p>Let&#39;s see what happens if the <code>brand</code> is the same:</p><pre><code>

<span>type</span> <span><span>A</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span> <span>&amp;</span> <span>{</span>
    <span>[</span>brand<span>]</span><span>:</span> <span>&#39;foobar&#39;</span>
<span>}</span>

<span>type</span> <span><span>B</span></span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span> <span>&amp;</span> <span>{</span>
    <span>[</span>brand<span>]</span><span>:</span> <span>&#39;foobar&#39;</span>
<span>}</span>

<span>const</span> <span>fn</span> <span>=</span> <span>(</span>a<span>:</span> <span>A</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#39;do something with A&#39;</span><span>)</span>
<span>}</span>

<span>const</span> obj<span>:</span> <span>B</span> <span>=</span> <span>{</span>
    x<span>:</span> <span>1</span><span>,</span>
    y<span>:</span> <span>true</span><span>,</span>
    z<span>:</span> <span>&#39;hello&#39;</span>
<span>}</span>

<span>fn</span><span>(</span>obj<span>)</span> 
</code></pre><p>No error! <code>A</code> and <code>B</code> are seen as interchangeable types because they&#39;re structurally the same, having the same fields <em>and</em> same brand value of <code>&#39;foobar&#39;</code>. Excellent!</p><h2>Make it generic!</h2><p>Awesome, so that works. But it&#39;s a toy example, not fit for production. Let&#39;s create a <code>Brand</code> type which can brand any type you wish:</p><pre><code><span>const</span> brand <span>=</span> <span>Symbol</span><span>(</span><span>&#39;brand&#39;</span><span>)</span> 

<span>type</span> <span>Brand<span>&lt;</span><span>T</span><span>,</span> <span>U</span><span>&gt;</span></span> <span>=</span> <span>T</span> <span>&amp;</span> <span>{</span>
    <span>[</span>brand<span>]</span><span>:</span> <span>U</span>
<span>}</span></code></pre><p>This type is very simple, it takes your type <code>T</code> and adds a <code>brand</code> field with <code>U</code> being the brand value. Here&#39;s how to use it:</p><pre><code>
<span>type</span> <span>A_Unbranded</span> <span>=</span> <span>{</span>
    x<span>:</span> <span>number</span><span>,</span>
    y<span>:</span> <span>boolean</span><span>,</span>
    z<span>:</span> <span>string</span><span>,</span>
<span>}</span>

<span>type</span> <span><span>A</span></span> <span>=</span> Brand<span>&lt;</span>A_Unbranded<span>,</span> <span>&#39;A&#39;</span><span>&gt;</span> 





</code></pre><p>So now we can brand any type. For completeness, here&#39;s the same kind of thing to <em>remove</em> the brand and go back to plain ol&#39; TypeScript types:</p><pre><code><span>type</span> <span>RemoveBrand<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>=</span> <span>T</span><span>[</span>Exclude<span>&lt;</span><span>keyof</span> <span>T</span><span>,</span> <span>typeof</span> brand<span>&gt;</span><span>]</span></code></pre><p>And this will remove the <code>brand</code> field from any branded type. Also note that if the type is not branded, it will not be touched!</p><h2>Real world usage</h2><p>Let&#39;s put this into practice. We&#39;ve got a class which needs branding to identify its type when dealing with <a href="https://prosopo.io/articles/typescript-mapped-type-magic/">mapped types</a>.</p><p>For simplicity, lets boil the class down to a <code>Dog</code> class:</p><pre><code>
<span>class</span> <span>Dog</span> <span>{</span>
    <span>constructor</span><span>(</span><span>public</span> name<span>:</span> <span>string</span><span>)</span> <span>{</span><span>}</span>
<span>}</span>

<span>type</span> <span>DogBranded</span> <span>=</span> Brand<span>&lt;</span>Dog<span>,</span> <span>&#39;Dog&#39;</span><span>&gt;</span>

<span>const</span> dog <span>=</span> <span>new</span> <span>DogBranded</span><span>(</span><span>&#39;Spot&#39;</span><span>)</span> 
</code></pre><p>TypeScript won&#39;t let us construct a branded dog üò¢ . We&#39;re going to need to do some casting using the constructor to brand the <em>constructor</em> rather than the <em>class</em> itself.</p><pre><code>
<span>type</span> <span>Ctor<span>&lt;</span><span>T</span><span>&gt;</span></span> <span>=</span> <span>new</span> <span>(</span><span>...</span>args<span>:</span> <span>any</span><span>[</span><span>]</span><span>)</span> <span>=&gt;</span> <span>T</span>

<span>const</span> addBrand <span>=</span> <span>&lt;</span><span>T</span><span>&gt;</span><span>(</span>ctor<span>:</span> Ctor<span>&lt;</span><span>T</span><span>&gt;</span><span>,</span> name<span>:</span> <span>string</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>return</span> ctor <span>as</span> Ctor<span>&lt;</span>Brand<span>&lt;</span><span>T</span><span>,</span> <span>typeof</span> name<span>&gt;&gt;</span>
<span>}</span>

<span>const</span> DogBranded <span>=</span> <span>addBrand</span><span>(</span>Dog<span>,</span> <span>&#39;Dog&#39;</span><span>)</span>

<span>const</span> dog <span>=</span> <span>new</span> <span>DogBranded</span><span>(</span><span>&#39;Spot&#39;</span><span>)</span> </code></pre><p>The <code>addBrand</code> function takes a constructor of a class and casts it to a branded type. This essentially makes an alias for the <code>Dog</code> class which can be used in exactly the same way as the <code>Dog</code> class, e.g. calling <code>new</code> on it.</p><p>We can <code>export</code> the <code>DogBranded</code> type to allow the outer world to use our class whilst ensuring it&#39;s always branded:</p><pre><code><span>export</span> <span>type</span> <span>DogExported</span> <span>=</span> <span>typeof</span> DogBranded</code></pre><p>Likewise, we can do the same for brand removal:</p><pre><code>
<span>const</span> removeBrand <span>=</span> <span>&lt;</span><span>T</span><span>&gt;</span><span>(</span>value<span>:</span> <span>T</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>return</span> value <span>as</span> RemoveBrand<span>&lt;</span><span>T</span><span>&gt;</span>
<span>}</span></code></pre><p>This simply removes the brand by casting the type to a type mapped without the brand field.</p><p>And there we go: a sure-fire way to brand and un-brand your types in TypeScript üòÉ</p><p>We&#39;ve published this work as a library which you can access via <a href="https://www.npmjs.com/package/@prosopo/ts-brand">NPM</a>!</p><p>At Prosopo, we&#39;re using TypeScript branding to fortify our types and do clever type mapping for our soon-to-be-released runtime type validator. Stay tuned for updates!</p><p><strong><a href="https://prosopo.io/articles/typescript-mapped-type-magic/">PART 1: TypeScript Mapped Type Magic</a></strong></p><hr/></div></div></div></div></div>
  </body>
</html>
