<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nexdock.com/">Original</a>
    <h1>NexDock turns your smartphone into a laptop</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
            

            <p>
    Posted on  3 July 2024
    
</p>


<p>I’m happy to announce that you can now run GHCi entirely in your browser<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<h2 id="where">Where?</h2>
<p><a href="https://vaibhavsagar.com/amd64-ghc-wasi-demo">Here</a>.</p>
<h2 id="how">How?</h2>
<p>I used <a href="https://github.com/ktock/container2wasm"><code>container2wasm</code></a> to convert
an OCI image containing GHC to a WASM blob that I could serve using a lightly
modified <a href="https://github.com/ktock/container2wasm-demo"><code>container2wasm-demo</code></a>.
If you’re curious, the website repo is
<a href="https://github.com/vaibhavsagar/amd64-ghc-wasi-demo">here</a> and the chunks of
WASM are <a href="https://github.com/vaibhavsagar/amd64-ghc-wasi-container">here</a>.</p>
<p>As of this writing, only images with an uncompressed size below 2GB can be used
with <code>container2wasm</code> (tracked
<a href="https://github.com/ktock/container2wasm/issues/230">here</a>) and my initial
attempts using an OCI image generated by Nix were unsuccessful because of
duplicate filenames (tracked
<a href="https://github.com/ktock/container2wasm/issues/263">here</a>).</p>
<h2 id="why">Why?</h2>
<p>I’ve wanted to do something like this for a long time. In my capacity as
a maintainer of <a href="https://github.com/IHaskell/IHaskell">IHaskell</a>, installation
issues are the most common category of support request I receive. Wouldn’t it
be great if a user could simply navigate to a webpage and have a correctly
configured Jupyter notebook waiting for them? The Jupyter folks also seem to be
thinking the same thing, based on the existence of
<a href="https://jupyterlite.readthedocs.io/en/stable/">JupyterLite</a>. Unfortunately
we’re a long way off from Haskell support<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>, but I hope my proof-of-concept
shows that this is possible.</p>
<p>Even outside Jupyter-land, a fully-functional GHCi REPL in the browser would be
generally useful. For example, currently
<a href="https://www.haskell.org/">Haskell.org</a> has a “Try it!” section where you can
enter expressions, which are currently passed to a backend server to execute.
A client-side GHCi could provide a better experience and allow us to get rid of
the backend entirely. Another wild idea: the Hackage documentation for
a package could provide a REPL with that package pre-installed for users to try
out immediately. Wouldn’t that be amazing?</p>
<section id="footnotes" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1"><p>As long as your browser supports WebAssembly and you are willing to
download ~700MB of WASM.<a href="#fnref1" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>It’s not something I’m working on and I don’t know how to go from this
Goldbergian blob of WASM to a kernel that would work with JupyterLite. If you
have ideas, please get in touch!<a href="#fnref2" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

        </div></div>
  </body>
</html>
