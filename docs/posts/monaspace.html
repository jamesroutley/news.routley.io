<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://monaspace.githubnext.com/">Original</a>
    <h1>Monaspace</h1>
    
    <div id="readability-page-1" class="page">
  <header>
    <a href="https://the.scapegoat.dev/">
      
    </a>
    <nav>
      <p>üè° <a href="https://the.scapegoat.dev/">Home</a> üìù <a href="https://the.scapegoat.dev/blog/">Blog</a></p>

    </nav>
  </header>
  <main>
    







<p>
    <i>
        <time datetime="2023-11-05">
            05 Nov, 2023
        </time>
    </i>
</p>

<p>(This is part of a <a href="https://typeshare.co/go-go-golems">longer series of short essays</a> I&#39;m writing as part of a marketing writing course. This is the first article I think is meaty enough to be published here. I will rework most of my material once the course is over.)</p>
<p>Unit tests enable bold refactors and protect against subtle errors introduced by Large Language Models. However, while unit testing strengthens codebases for the long haul, they drain developer bandwidth with rote work.</p>
<p>In this article, we&#39;ll explore tactics to leverage LLMs as a unit testing sidekick - taking care of the grunt work so you can focus on the good stuff.</p>
<h3 id="craft-test-blueprints">Craft test blueprints</h3>
<p>Following <a href="https://typeshare.co/go-go-golems/posts/write-boldly-and-error-free-with-the-chatgpt-funnel-method">the funnel method</a>, we leverage LLMs in crafting unit tests by transforming the code we want into an actionable unit testing plan.</p>
<ul>
<li><strong>Summarize the code as bullet points</strong>, to ensure the language model understands what needs to be tested. Experiment with providing only your code&#39;s API (<a href="https://chat.openai.com/share/7f1610e8-5e17-47a4-aceb-6c94ae759835">transcript</a>) or its actual implementation (<a href="https://chat.openai.com/share/d867d11e-af0f-4a7d-9ad5-c12cd0683d7e">transcript</a>).</li>
<li><strong>Prompt the LLM to look for edge cases</strong>, common scenarios, complex combinations of parameters. Don&#39;t hesitate to provide your own edge cases too. Don&#39;t forget to regenerate often (<a href="https://chat.openai.com/share/55d2de2f-d716-4b45-8355-88de4d207a9b">transcript</a>).</li>
<li><strong>Don&#39;t have the model output any code at this point.</strong> We are actually interested in transforming the formal input into something higher up <a href="https://typeshare.co/go-go-golems/posts/understanding-chatgpts-main-strength-moving-up-and-down-the-ladder-of-language">the language ladder</a>, as it provides denser information in less tokens.</li>
</ul>
<p>Once you have a testing plan that you are happy with, it is time to take a step back (or a short walk around the block) and make sure that you have taken everything into account.</p>
<h3 id="reviewing-the-test-blueprints">Reviewing the test blueprints</h3>
<p>Reviewing the test blueprint is pivotal to ensure it captures the essence and intricacies of your target code. This blueprint will be used for actual code generation; it is crucial to ensure it is concise, correct and exhaustive.</p>
<ul>
<li><strong>Begin by manually scrutinizing each test</strong>, checking that it indeed makes sense. Don&#39;t hesitate to manually edit the blueprint.</li>
<li><strong>When faced with complex tests, don&#39;t hesitate to ask the LLM for clarifications</strong> on their purpose and expected outcomes; this not only aids comprehension but also doubles as invaluable documentation. It will also enhance the LLM&#39;s ability to generate proper code (<a href="https://chat.openai.com/share/3b933431-cc4e-49d3-951a-e44447f13f6e">transcript</a>).</li>
</ul>
<p>Ready to bring the blueprint to life? Dive into the next section: creating a testing skeleton.</p>
<h3 id="implementing-the-tests">Implementing the tests</h3>
<p>After crafting a strong list of unit tests, it&#39;s time to let the model write the actual code.</p>
<ul>
<li><strong>Set a consistent style by generating a list of unit test signatures</strong> and brief descriptions (remember how <a href="https://typeshare.co/go-go-golems/posts/under-the-hood-how-to-use-chatgpts-attention-mechanism-for-better-prompts">self-attention</a> works).</li>
<li><strong>Guide the model by providing a template example</strong> that shows which framework, checks, and mock objects to use. This will ensure the upcoming tests align with existing code. (It&#39;s often beneficial to have the model produce table-driven tests for uniformity).</li>
<li><strong>Always ask for clear error messages</strong> and possible reasons for test failure, making failed tests easy to decode.</li>
<li><strong>Don&#39;t ask the model to implement all tests at once.</strong> Instead, iterate through the signatures and use the same template each time to ensure consistency.</li>
<li><strong>Make sure the template implementation is spotless.</strong> This will improve the quality of future implementations (<a href="https://chat.openai.com/share/2517d7b3-e057-4ab5-ae2a-eb3e39a6d343">transcript</a>, note the LLM-esque off by one in the key iteration).</li>
</ul>
<p>With straightforward tests and clear error info, there&#39;s no need to spend hours sifting through test code when issues arise.</p>
<h3 id="the-future-of-unit-testing">The future of unit testing</h3>
<p>LLMs&#39; convenience means that even when faced with tight deadlines, there&#39;s always time for thorough tests: a short investment of 10-15 minutes can ensure foundational coverage. This makes me pretty confident saying that <strong>large language models will revolutionize unit testing</strong>.</p>
<p>Remember, the aim isn&#39;t to let LLMs fully take the reins, but to utilize them as invaluable colleagues.</p>



    

    
    


    



  </main>
  

</div>
  </body>
</html>
