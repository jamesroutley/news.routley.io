<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pcreux.com/2024/10/07/rails-data-sync-service.html">Original</a>
    <h1>Building a robust data synchronization framework with Rails</h1>
    
    <div id="readability-page-1" class="page"><div>
      <div>
        <div>
          <div>
            <h4>
  <a href="https://pcreux.com/">¬´ Philippe Creux</a>
</h4>


<p>07 Oct 2024</p>

<p>At <a href="https://getzipline.com/">Zipline</a>, we offer a one-stop shop application for retail employees that handles everything from clocking to task management and team communication. To achieve this, we need to integrate with numerous third-party applications with unique requirements. We decided to develop a satellite service called ZipIO for data synchronization. In this post, I‚Äôll review our journey of building this robust and scalable system.</p>

<h2 id="key-design-principles">Key Design Principles</h2>

<ol>
  <li>
    <p><strong>Language and Framework</strong>: We chose Ruby on Rails for its simplicity and productivity. However, we structured our core logic as POROs (Plain Old Ruby Object) to decouple the core logic from the engine that runs it.</p>
  </li>
  <li>
    <p><strong>Modular Architecture</strong>: We broke down the workflow into discrete steps: Signals, Commands, Outcomes, and Tasks. This modular approach allows for easy reuse of logic across different third-party integrations.</p>
  </li>
  <li>
    <p><strong>Asynchronous Processing</strong>: While we support synchronous operations for specific use cases, 99% of our workflows run asynchronously for optimal performance and scalability.</p>
  </li>
  <li>
    <p><strong>Robust Error Handling</strong>: Each step in the workflow is designed to handle errors gracefully, ensuring smooth operation even when issues arise.</p>
  </li>
  <li>
    <p><strong>Full Visibility</strong>: We prioritized comprehensive logging and monitoring to make troubleshooting and maintenance as painless as possible.</p>
  </li>
</ol>

<h2 id="defining-workflows">Defining workflows</h2>

<h3 id="steps">Steps</h3>

<p>Our workflow consists of four main kind of steps:</p>

<ol>
  <li><strong>Signals</strong>: These are triggers, often from API calls or webhooks, that initiate a workflow.</li>
  <li><strong>Commands</strong>: Actions performed in response to signals, such as synchronizing data with another app.</li>
  <li><strong>Outcomes</strong>: The results of commands, which can be success, failure, or skipped.</li>
  <li><strong>Tasks</strong>: Scheduled operations that poll third-party services for new data to sync. They create <strong>Signals</strong>, in turn.</li>
</ol>

<p>Each step in the workflow is designed as a standalone Ruby object that takes a data input, performs an action, and returns the next step(s) to be executed.
Since each step defines the downstream step(s), it can perform complex routing depending on input data or user configuration.
For example, a Signal could return several Commands to sync an event to multiple third-party services.</p>

<pre><code>flowchart LR

A[Signal: New Order]
B[Command: Sync to service A]
C[Command: Sync to service B]
BB[Outcome: Success]
CB[Outcome: Success]

A --&gt; B
A --&gt; C
B --&gt; BB
C --&gt; CB
</code></pre>

<p>The data inputs are defined as <code>Dry::Struct</code>. Each step declares the type(s) of step it returns, adding an extra layer of type safety and allowing us to generate documentation automatically.</p>

<p>Here is an example:</p>

<div><div><pre><code><span># This signal is created when we receive a new order via a webhook.</span>
<span>class</span> <span>Stripe::Signals::NewOrder</span> <span>&lt;</span> <span>ZipIO</span><span>::</span><span>Step</span>
  <span>data_struct</span> <span>[</span><span>Stripe</span><span>::</span><span>Structs</span><span>::</span><span>Order</span><span>]</span>

  <span>emits</span> <span>MyStore</span><span>::</span><span>Commands</span><span>::</span><span>SaveOrder</span>

  <span># Convert Stripe Order to a Generic Struct and return a Command to create the order</span>
  <span>def</span> <span>call</span>
    <span>order</span> <span>=</span> <span>Transformer</span><span>.</span><span>call</span><span>(</span><span>data</span><span>,</span> <span>to: </span><span>Generic</span><span>::</span><span>Structs</span><span>::</span><span>Order</span><span>)</span>

    <span>MyStore</span><span>::</span><span>Commands</span><span>::</span><span>CreateOrder</span><span>.</span><span>new</span><span>(</span><span>order</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>class</span> <span>Stripe::Commands::CreateOrder</span> <span>&lt;</span> <span>ZipIO</span><span>::</span><span>Step</span>
  <span># Create an order via an API and return an Outcome according to the response.</span>
 <span>def</span> <span>call</span>
   <span>response</span> <span>=</span> <span>api_client</span><span>.</span><span>orders</span><span>.</span><span>post</span><span>(</span><span>data</span><span>)</span>

   <span>if</span> <span>response</span><span>.</span><span>success?</span>
     <span>MyStore</span><span>::</span><span>Outcome</span><span>::</span><span>OrderCreated</span><span>.</span><span>new</span><span>(</span><span>response</span><span>.</span><span>parsed_body</span><span>)</span>
   <span>else</span>
     <span>MyStore</span><span>::</span><span>Outcome</span><span>::</span><span>OrderCreateFailure</span><span>.</span><span>new</span><span>(</span><span>response</span><span>.</span><span>parsed_body</span><span>)</span>
  <span>end</span>

  <span>private</span>

  <span>def</span> <span>api_client</span>
    <span># ...</span>
  <span>end</span>
<span>end</span>

<span># Two outcomes. They are the final steps of the workflow so they don&#39;t do anything.</span>
<span>Stripe</span><span>::</span><span>Commands</span><span>::</span><span>OrderCreated</span> <span>=</span> <span>Class</span><span>.</span><span>new</span><span>(</span><span>ZipIO</span><span>::</span><span>Outcomes</span><span>::</span><span>Success</span><span>)</span>
<span>Stripe</span><span>::</span><span>Commands</span><span>::</span><span>OrderCreateFailure</span> <span>=</span> <span>Class</span><span>.</span><span>new</span><span>(</span><span>ZipIO</span><span>::</span><span>Outcomes</span><span>::</span><span>Failure</span><span>)</span>

<span># Order received from Stripe.</span>
<span>class</span> <span>Stripe::Structs::Order</span> <span>&lt;</span> <span>DryStruct</span>
  <span>attribute</span> <span>:amount</span><span>,</span> <span>Types</span><span>::</span><span>Decimal</span>
  <span>attribute</span> <span>:order_id</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
  <span>attribute</span> <span>:user_id</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
  <span>attribute</span> <span>:email</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
  <span>attribute</span> <span>:payment_type</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
<span>end</span>

<span># Generic order used throughout the system.</span>
<span>class</span> <span>Generic::Structs::Order</span> <span>&lt;</span> <span>DryStruct</span>
  <span>attribute</span> <span>:amount</span><span>,</span> <span>Types</span><span>::</span><span>Decimal</span>
  <span>attribute</span> <span>:order_id</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
  <span>attribute</span> <span>:integration_key</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
  <span>attribute</span> <span>:email</span><span>,</span> <span>Types</span><span>::</span><span>String</span>
  <span>attribute</span> <span>:payment_source</span><span>,</span> <span>Types</span><span>::</span><span>String</span><span>.</span><span>enum</span><span>(</span><span>&#39;credit_card&#39;</span><span>,</span> <span>&#39;debit_card&#39;</span><span>)</span>
<span>end</span>
</code></pre></div></div>

<h3 id="transforming-data">Transforming data</h3>

<p>The core logic is to transform data from one schema (ex: Stripe Order) to another (ex: Generic Order). We created a simple library inspired by <a href="https://github.com/pcreux/csv-importer/">csv-importer</a> to define data transformation using a DSL.</p>

<div><div><pre><code><span>class</span> <span>StripeOrderToGenericOrder</span> <span>&lt;</span> <span>ZipIO</span><span>::</span><span>Transformer</span>
  <span># map `amount` to `amount`</span>
  <span>attribute</span> <span>:amount</span>

  <span># map `stripe_order_id` to `order_id`</span>
  <span>attribute</span> <span>:order_id</span><span>,</span> <span>source: :stripe_order_id</span>

  <span># build a custom integration key</span>
  <span>attribute</span> <span>:integration_key</span><span>,</span> <span>source: </span><span>-&gt;</span><span>(</span><span>data</span><span>)</span> <span>{</span>
    <span>[</span><span>data</span><span>.</span><span>fetch</span><span>(</span><span>:user_id</span><span>),</span> <span>data</span><span>.</span><span>fetch</span><span>(</span><span>:order_id</span><span>)].</span><span>join</span><span>(</span><span>&#34;-&#34;</span><span>)</span>
  <span>}</span>

  <span># downcase email</span>
  <span>attribute</span> <span>:email</span><span>,</span> <span>transform: </span><span>-&gt;</span> <span>{</span> <span>_1</span><span>.</span><span>&amp;</span><span>downcase</span> <span>}</span>

  <span># Define mapping</span>
  <span>attribute</span> <span>:payment_source</span><span>,</span> <span>source: :payment_type</span><span>,</span> <span>transform: </span><span>Mapper</span><span>.</span><span>new</span><span>(</span>
    <span>&#34;cc&#34;</span> <span>=&gt;</span> <span>&#34;credit_card&#34;</span><span>,</span>
    <span>&#34;dc&#34;</span> <span>=&gt;</span> <span>&#34;debit_card&#34;</span><span>,</span>
    <span># ...</span>
  <span>)</span>
<span>end</span>
</code></pre></div></div>

<p>Using a proper naming convention, we can look up the transformers on the fly:</p>

<div><div><pre><code><span>Transformer</span><span>.</span><span>call</span><span>(</span><span>stripe_order</span><span>,</span> <span>to: </span><span>Generic</span><span>::</span><span>Structs</span><span>::</span><span>Order</span><span>)</span>
<span># =&gt; &lt;# Generic::Structs::Order ...&gt;</span>
</code></pre></div></div>

<h3 id="live-documentation">Live documentation</h3>

<p>Since Steps, Structs, and Transformers are defined using DSLs, we can introspect them to generate documentation. This documentation is available in our Admin UI so that non-technical folks (Product Owners, Account Managers, ‚Ä¶) understand how the data flows and how it‚Äôs transformed.</p>

<p>We traverse the graph of  <code>emit</code>-ed steps to render a flow chart:</p>

<pre><code>flowchart LR

A[Stripe::Signals::Webhook] --&gt; B[Stripe::Signals::PaymentSucceeded]

A[Stripe::Signals::Webhook] --&gt; C[Stripe::Signals::NewOrder]

A[Stripe::Signals::Webhook] --&gt; D[Stripe::Outcome::IgnoredWebhookEvent]

C --&gt; E[MyStore::Commands::CreateOrder]

E --&gt; F[MyStore::Outcome::OrderCreated]

E --&gt; G[MyStore::Outcome::OrderCreateFailure]

L[Shopify::Signals::Webhook] --&gt; M

M[Shopify::Signals::NewOrder] --&gt; E
</code></pre>



<p>We look up all Structs and Transformers to display them in a human-friendly way.
Here is for example the documentation for <code>StripeOrderToGenericOrder</code>:</p>

<table>
  <tbody><tr>
    <th> Source </th>
    <th></th>
    <th> Target </th>
    <th> Transform </th>
</tr>
  <tr>
    <td> amount </td>
    <td> ‚û°Ô∏è </td>
    <td> amount </td>
  </tr>
  <tr>
    <td> stripe_order_id </td>
    <td> ‚û°Ô∏è </td>
    <td> order_id </td>
  </tr>
  <tr>
    <td> <details><summary>Proc</summary><code>[data.fetch(:user_id), data.fetch(:order_id)].join(&#34;-&#34;)</code></details> </td>
    <td> ‚û°Ô∏è </td>
    <td> integration_key </td>
  </tr>
  <tr>
    <td> email </td>
    <td> ‚û°Ô∏è </td>
    <td> email </td>
    <td> <details><summary>Proc</summary>
    <code>-&gt; { _1.&amp;downcase }</code>
    </details></td>
  </tr>
  <tr>
    <td> payment_source </td>
    <td> ‚û°Ô∏è </td>
    <td> payment_type </td>
    <td>
      <table>
        <tbody><tr>
        <td> &#34;cc&#34; </td>
        <td> ‚û°Ô∏è </td>
        <td> &#34;credit_card&#34; </td>
        </tr>
        <tr>
        <td> &#34;dc&#34; </td>
        <td> ‚û°Ô∏è </td>
        <td> &#34;debit_card&#34; </td>
        </tr>
      </tbody></table>
    </td>
  </tr>
</tbody></table>

<p>So far, we‚Äôve defined the steps, structs, and transformations. Let‚Äôs see how we make data flow through them.</p>
<h2 id="processing-a-workflow">Processing a Workflow</h2>

<p>Processing a Workflow synchronously is straightforward.</p>

<div><div><pre><code><span># Run a workflow synchronously and return a collection of child steps.</span>
<span># Ex: [ Stripe::Signals::NewOrder, [ MyStore::Commands::CreateOrder, [ MyStore::Outcome::OrderCreated ] ] ]</span>
<span>def</span> <span>run</span><span>(</span><span>step</span><span>)</span>
  <span>return</span> <span>step</span> <span>if</span> <span>step</span><span>.</span><span>is_a?</span><span>(</span><span>Symbol</span><span>)</span> <span># e.g. :success, :skip, ...</span>

  <span>next_steps</span> <span>=</span> <span>Array</span><span>(</span><span>step</span><span>.</span><span>call</span><span>)</span>

  <span>next_steps</span><span>.</span><span>map</span> <span>do</span> <span>|</span><span>next_step</span><span>|</span>
    <span>run</span><span>(</span><span>next_step</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>We use this approach to perform integration tests where we want to exerce an entire workflow. On a production environment, we persist Pipelines and Steps to the database and we process them asynchronously.</p>

<h3 id="database-structure">Database Structure</h3>

<p>We use a minimal set of Rails models:</p>
<ul>
  <li><code>Pipeline</code>: A specific instance of a pipeline</li>
  <li><code>PipelineStep</code>: Individual steps within a pipeline</li>
</ul>

<h3 id="asynchronous-processing">Asynchronous Processing</h3>

<p>When a signal is received:</p>
<ol>
  <li>A new pipeline is created and persisted in the database.</li>
  <li>A job is enqueued to process the first step.</li>
  <li>Each step, when processed, can trigger subsequent steps, which are then enqueued as separate jobs.</li>
</ol>

<p>This approach allows for excellent scalability, fault tolerance, and visibility.</p>

<h3 id="error-handling-and-retry-mechanism">Error Handling and Retry Mechanism</h3>

<p>By persisting each step in the database, we can retry failed steps without restarting the entire workflow. This is particularly useful for long sequences of API calls where only one step might fail.</p>

<h3 id="scalability">Scalability</h3>

<p>Our service runs on Heroku, using <a href="https://judoscale.com/">Judoscale</a> to auto-scale background workers. This setup allows us to handle peak loads efficiently by spinning up additional workers as needed.</p>

<h3 id="example">Example</h3>

<p>In the example below, we handle Stripe webhooks. Each webhook can contain multiple events, so we start a pipeline where the first step breaks down each event into its own Signal.</p>

<div><div><pre><code><span>class</span> <span>StripeWebhooksController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span># POST /webhooks/stripe</span>
  <span># The webhooks can contain multiple events.</span>
  <span># Build a Webhook signal from the raw payload and start a Pipeline.</span>
  <span>def</span> <span>create</span>
    <span>signal</span> <span>=</span> <span>Stripe</span><span>::</span><span>Signals</span><span>::</span><span>Webhook</span><span>.</span><span>new</span><span>(</span><span>params</span><span>)</span>
    <span>Pipeline</span><span>.</span><span>start!</span><span>(</span><span>signal</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>class</span> <span>Stripe::Signals::Webhook</span> <span>&lt;</span> <span>ZipIO</span><span>::</span><span>Signal</span>
  <span># Return an array of individual signals.</span>
  <span># These signals will be processed in parallel.</span>
  <span>def</span> <span>call</span><span>(</span><span>webhook</span><span>)</span>
    <span>webhook</span><span>.</span><span>events</span><span>.</span><span>filter_map</span> <span>do</span> <span>|</span><span>event</span><span>|</span>
      <span>case</span> <span>event</span><span>.</span><span>type</span>
      <span>when</span> <span>&#39;payment_intent.succeeded&#39;</span>
        <span>Stripe</span><span>::</span><span>Signals</span><span>::</span><span>PaymentSucceeded</span><span>.</span><span>new</span><span>(</span><span>event</span><span>)</span>
      <span>when</span> <span>&#39;orders.succeeded&#39;</span>
        <span># See definition above.</span>
        <span>Stripe</span><span>::</span><span>Signals</span><span>::</span><span>NewOrder</span><span>.</span><span>new</span><span>(</span><span>event</span><span>)</span>
      <span>else</span>
        <span>Stripe</span><span>::</span><span>Outcome</span><span>::</span><span>IgnoredWebhookEvent</span><span>.</span><span>new</span><span>(</span><span>event</span><span>)</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<p>At a high level, the Pipeline implementation looks like this:</p>

<div><div><pre><code><span>class</span> <span>Pipeline</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span># Persist the signal as the first step of the pipeline and process it asynchronously.</span>
  <span>def</span> <span>self</span><span>.</span><span>start!</span><span>(</span><span>signal</span><span>)</span>
    <span>PipelineStep</span><span>.</span><span>enqueue</span><span>(</span><span>signal</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>class</span> <span>PipelineStep</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span># Persist the step and process it asynchronously.</span>
  <span>def</span> <span>self</span><span>.</span><span>enqueue</span><span>(</span><span>step</span><span>,</span> <span>pipeline: </span><span>nil</span><span>)</span>
    <span>pipeline</span> <span>||=</span> <span>Pipeline</span><span>.</span><span>create!</span>

    <span>step_model</span> <span>=</span> <span>create!</span><span>(</span><span>data: </span><span>step</span><span>.</span><span>attributes</span><span>,</span> <span>step_class: </span><span>step</span><span>.</span><span>class</span><span>.</span><span>name</span><span>,</span> <span>pipeline: </span><span>pipeline</span><span>)</span>

    <span>step_model</span><span>.</span><span>process_async!</span>
  <span>end</span>

  <span># Enqueue a job that calls `process!`</span>
  <span>def</span> <span>process_async!</span>
    <span>ProcessPipelineStepJob</span><span>.</span><span>perform_async</span><span>(</span><span>self</span><span>)</span>
  <span>end</span>

  <span># Constantize the persisted step, trigger `call`, and enqueue the resulting steps.</span>
  <span>def</span> <span>process!</span>
    <span>step</span> <span>=</span> <span>step_class</span><span>.</span><span>constantize</span><span>.</span><span>new</span><span>(</span><span>data</span><span>)</span> <span># ex: Stripe::Signals::Webhook</span>
    <span># Trigger the step</span>
    <span>resulting_step</span> <span>=</span> <span>step</span><span>.</span><span>call</span>

    <span>return</span> <span>if</span> <span>resulting_step</span><span>.</span><span>is_a?</span><span>(</span><span>Symbol</span><span>)</span> <span># :success, :fail, :skip</span>

    <span>Array</span><span>(</span><span>resulting_step</span><span>).</span><span>each</span> <span>do</span> <span>|</span><span>step</span><span>|</span>
      <span>PipelineStep</span><span>.</span><span>enqueue</span><span>(</span><span>step</span><span>,</span> <span>pipeline: </span><span>self</span><span>.</span><span>pipeline</span><span>)</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre></div></div>

<h3 id="instrumentation-visibility-and-monitoring">Instrumentation, visibility, and monitoring</h3>

<p>Since every single step is persisted in the database, writing an admin interface that gives complete visibility into each pipeline and its steps is straightforward.</p>

<p>Thanks to this admin interface, most debugging sessions are painless. There‚Äôs no need to dig into the logs or open a Rails console; everything is nicely laid out in a web UI.</p>

<p>Every step run is sent to Datadog to help us monitor the system‚Äôs health and alert us when failure rates are high.</p>

<h2 id="conclusion">Conclusion</h2>

<p>I‚Äôm very happy with how ZipIO turned out.
We succeeded to built a framework that allows us to define the core logic by writing simple and elegant code.
After three years of operation, the codebase defines 125 steps and 50 transformers. We have processed 1 billion steps, and our service continues to be a pleasure to work with and expand.</p>

<p>Questions? Comments? üëâ <a href="https://ruby.social/@pcreux">pcreux@ruby.social</a>.</p>



<hr/>

<p>You might also be interested in:</p>
<ul>




  <li><a href="https://pcreux.com/2024/09/26/aaa-engines">Organize your Rails codebase with aaa engines</a></li>



  <li><a href="https://pcreux.com/2024/01/19/handling-webhooks-with-ruby-on-rails">Handling webhooks in Ruby on Rails</a></li>



  <li><a href="https://pcreux.com/2023/11/05/snapshot-testing-with-dbt">Snapshot testing with dbt</a></li>


</ul>

          </div>
        </div>
      </div>
    </div></div>
  </body>
</html>
