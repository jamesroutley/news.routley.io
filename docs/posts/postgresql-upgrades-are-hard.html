<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreas.scherbaum.la/blog/archives/1116-PostgreSQL-Upgrades-are-hard!.html#_content">Original</a>
    <h1>PostgreSQL Upgrades Are Hard</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>Together with <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/postgresql.life/post/laetitia_avrot/&#39;]);" href="https://postgresql.life/post/laetitia_avrot/" target="_blank">Lætitia Avrot</a> and <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/postgresql.life/post/nikolay_samokhvalov/&#39;]);" href="https://postgresql.life/post/nikolay_samokhvalov/" target="_blank">Nikolay Samokhvalov</a> I was invited to participate in a <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/app.hopin.com/events/postgres-vision/expo/773371&#39;]);" href="https://app.hopin.com/events/postgres-vision/expo/773371" target="_blank">Community Panel</a> (<a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/www.youtube.com/watch?v=kgO_ms0o22E&#39;]);" href="https://www.youtube.com/watch?v=kgO_ms0o22E" target="_blank">YouTube video</a>) about <em>PostgreSQL Upgradability</em> at <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/www.postgresvision.com/&#39;]);" href="https://www.postgresvision.com/" target="_blank">Postgres Vision 2022</a>. The panel was moderated by <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/postgresql.life/post/bruce_momjian/&#39;]);" href="https://postgresql.life/post/bruce_momjian/" target="_blank">Bruce Momjian</a> and initiated and organized by <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/postgresql.life/post/jimmy_angelakos/&#39;]);" href="https://postgresql.life/post/jimmy_angelakos/" target="_blank">Jimmy Angelakos</a>. Bruce did talk with each of us before, which helped a lot to guide the discussion in the right direction. The recording of the <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/vyruss.org/blog/postgresql-community-panel-upgradability-postgres-vision-2022.html&#39;]);" href="https://vyruss.org/blog/postgresql-community-panel-upgradability-postgres-vision-2022.html" target="_blank">panel discussion</a> is available on the Postgres Vision website.</p>

<p>During this panel each of us provided examples for how easy or complicated PostgreSQL upgrades still are.</p>



                </div><div id="extended">
        <h3>Minor version upgrades</h3>

<p>One result of our discussion is that minor upgrades (as example v14.0 to v14.1) are relatively easy to do, but might hold some surprises for anyone who does not pay attention to the details (e.g., the release notes). A good example is the recent release of PostgreSQL <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/www.postgresql.org/about/news/postgresql-144-released-2470/&#39;]);" href="https://www.postgresql.org/about/news/postgresql-144-released-2470/" target="_blank">version 14.4</a>. It is a minor upgrade, so no new features. But it requires extensive work on B-tree indexes. For the DBA it is not easy to figure out how much work this is, or how long the maintenance window needs to be.</p>



<h3>Major version upgrades</h3>

<p>Major upgrades (as example v13 to v14) are a whole different category. Everyone agrees that those upgrades are complicated and need a lot of preparation and testing, both on the database side as well as on the application side. PostgreSQL has the <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/www.postgresql.org/docs/current/pgupgrade.html&#39;]);" href="https://www.postgresql.org/docs/current/pgupgrade.html" target="_blank">pg_upgrade</a> tool to run a major version upgrade on the same server, but even this tool is lacking features which are crucial for today’s business world. As example, the --check option does a preliminary check of the database, but this does not cover all the details, doesn’t give a time estimate, and does not catch all errors.</p>

<h3></h3>

<p>Currently the PostgreSQL Project supports 5 major versions. Compared to commercial products, that is a large number of supported versions. This becomes a problem for some users: by the time the product runs out of support, the amount of changes is so big that a major upgrade is no longer feasible, or easy to do. One discussed approach are LTS releases, and not supporting every major release for 5 years, but this will not make the actual problem go away.</p>

<h3></h3>

<p>In today’s business world, many PostgreSQL installations run in a replicated fashion. Either by using physical or logical replication. However PostgreSQL by itself is not aware of the cluster, and does not support this out of the box.</p>



<h3>Downtime required for an upgrade</h3>

<p>Nikolay pointed out that zero-downtime upgrades are not possible. The time required for the upgrade can be minimized, but it can’t be zero. One of the main reasons is that the server must be restarted for the upgrade, which interrupts ongoing connections. A restart requires a <a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/www.postgresql.org/docs/current/sql-checkpoint.html&#39;]);" href="https://www.postgresql.org/docs/current/sql-checkpoint.html" target="_blank">checkpoint</a>, which in turn writes out all dirty buffers to disk. Prepping the database with advanced checkpoints is possible, but write-heavy databases will still need some time to write out the remaining changes, and then restart the server. During that time no new connections are accepted, and applications trying to connect will receive an error. Even a connection pooler can only hold incoming connections, but it’s not possible to keep connections and queries running while the server is upgraded.</p>



<h3>Upgrade strategies</h3>

<p>Over time, the PostgreSQL world developed several different upgrade strategies, just to name a few:</p>

<ul>
	<li>Running pg_upgrade in –link mode: this is relatively fast (minutes, usually), but once the new version is started a rollback is not possible (short of using additional tools like filesystem snapshots).</li>
	<li>Running pg_upgrade in copy mode (the default): This requires twice the disk space, because the upgrade process creates a copy of each file. It is also slow, and the runtime depends on the size of the database and the performance of the hardware. Can be hours.</li>
	<li><a onclick="_gaq.push([&#39;_trackPageview&#39;, &#39;/extlink/www.postgresql.org/docs/current/logical-replication.html&#39;]);" href="https://www.postgresql.org/docs/current/logical-replication.html" target="_blank">Logical replication</a>: This approach creates replication slots on the primary, a new replica with the new version is set up using a pg_dump backup, and then the logical changes stream into the replica until it catches up with the primary. Then the application is switched to the new replica, running the new version. This approach might overload the primary, because it needs to store WAL for the time from when the backup starts to the time the replica caught up with all the changes. Write-heavy databases can create several TB or WAL during that time.</li>
	<li>Slony-I: Slony uses triggers to gather changes in tables, and send them to the replicas. This is a resource consuming approach, and can’t deal with DDL changes. Development of Slony-I stopped a while ago.</li>
	<li>pg_dump and pg_restore: Use the pg_dump tool of the new version to take a snapshot of the database, and install it in the new version. This approach works across multiple servers, but requires twice the disk space, and a lot of time. During the restore every index needs to be rebuilt, and afterwards the statistics need to be updated. Data changes are not possible during the upgrade, however the applications can access the old database in read-only mode.</li>
</ul>



<h3>Possible improvements</h3>

<p>During the panel discussion we discussed a number of possible changes and improvements:</p>

<ul>
	<li>Use pg_upgrade for all upgrades, and have an option which shows necessary changes and steps between upgrades, also between minor upgrades</li>
	<li>Better verification of the upgrade process, catch more possible problems in advance</li>
	<li>Calculate time and space estimates for the upgrade</li>
	<li>Make PostgreSQL cluster-aware: show information about each node in all nodes</li>
	<li>Make it possible to upgrade the entire cluster at once</li>
</ul>



<h3>Acknowledgements</h3>

<p>Thanks to Lætitia, Nikolay, Bruce and Jimmy for helping with this blog post, and organizing and participating in the panel discussion.</p>

        </div></div>
  </body>
</html>
