<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chrispenner.ca/posts/interview">Original</a>
    <h1>Silly job interview questions in Haskell</h1>
    
    <div id="readability-page-1" class="page"><article>
        <p>Today I thought it&#39;d be fun to take a look at a few common &amp;
simple &#34;interview questions&#34; in Haskell. These sorts of questions are
often used to establish whether someone has programming and problem
solving skills, and I thought it might be useful for folks to see how
they play out in Haskell since our beloved language&#39;s solutions tend to
follow a different paradigm than most other languages do. I&#39;ll withhold
any judgement on whether these questions are in any way helpful in
determining programming skill whatsoever ðŸ˜…; please don&#39;t @ me about
it.</p>
<h2 id="palindromes">Palindromes</h2>
<p>Let&#39;s start off nice and easy with the standard &#34;is it a palindrome&#34;
question! The task is to write a function which determines whether a
given string is a palindrome (i.e. whether it reads the same in both
reverse and forwards)</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>isPalindrome ::</span> <span>String</span> <span>-&gt;</span> <span>Bool</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>isPalindrome str <span>=</span> str <span>==</span> <span>reverse</span> str</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> isPalindrome <span>&#34;racecar&#34;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span>True</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> isPalindrome <span>&#34;hello world!&#34;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>False</span></span></code></pre></div>
<p>That&#39;ll do it! Not much to say about this one, it&#39;s nice that our
definition roughly matches an English sentence describing the problem
&#34;does a given string equal itself in reverse&#34;. I&#39;ll leave it as an
exercise for the reader to expand it to handle differences in
capitalization however you like.</p>
<h2 id="fizz-buzz">Fizz Buzz</h2>
<p>Next up is the infamous Fizz Buzz! For the 3 of you who are
unfamiliar, for each number from 1 to 100 we need to print out &#34;Fizz&#34; if
it&#39;s divisible by 3, &#34;Buzz&#34; if it&#39;s divisible by 5, and &#34;Fizz Buzz&#34; if
it&#39;s divisible by both 3 AND 5! Otherwise we print the number
itself.</p>
<p>Let&#39;s see it!</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Foldable</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span>fizzle ::</span> <span>Int</span> <span>-&gt;</span> <span>String</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>fizzle n</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> n <span>`mod`</span> <span>3</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> n <span>`mod`</span> <span>5</span> <span>==</span> <span>0</span> <span>=</span> <span>&#34;Fizz Buzz!&#34;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span>|</span> n <span>`mod`</span> <span>3</span> <span>==</span> <span>0</span> <span>=</span> <span>&#34;Fizz!&#34;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span>|</span> n <span>`mod`</span> <span>5</span> <span>==</span> <span>0</span> <span>=</span> <span>&#34;Buzz!&#34;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>otherwise</span> <span>=</span> <span>show</span> n</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>main <span>=</span> <span>do</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    for_ [<span>1</span><span>..</span><span>100</span>] (<span>putStrLn</span> <span>.</span> fizzle)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> main</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span>1</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span>2</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span>Fizz</span><span>!</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span>4</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span>Buzz</span><span>!</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span>Fizz</span><span>!</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span>7</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span>8</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span>Fizz</span><span>!</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span>Buzz</span><span>!</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span>11</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span>Fizz</span><span>!</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span>13</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a><span>14</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span>Fizz</span> <span>Buzz</span><span>!</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span>16</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span>-- ...you get the idea</span></span></code></pre></div>
<p>I write a helper function &#34;fizzle&#34; here which converts a number into
its appropriate string so I can keep the &#34;printing&#34; logic separate,
which is good programming style in Haskell as it makes things easier to
both test and reason about.</p>
<p>We can see that &#34;case analysis&#34; is very helpful for these sorts of
problems, I&#39;m using &#34;pattern guards&#34; to do a sort of multi-way if
statement. Since &#34;divisible by both 3 &amp; 5&#34; overlaps with the other
conditions and also is the most restrictive, we check for that one
first, then check the other two cases falling back on returning the
string version of the number itself. It all works beautifully!</p>
<p>I really enjoy looking at this problem as an example of how Haskell
is different from other languages. Most things in Haskell are
<em>functions</em>, even our loops are just higher-order functions! The
nice thing about that is that functions are <em>composable</em> and have
very clean boundaries, which means we don&#39;t need to intermingle the
<strong>syntax</strong> of a <strong>for-loop</strong> with our logic.
It&#39;s these same principles which allow us to easily separate our
<em>effectful</em> printing logic from our function which computes the
output string.</p>
<p>The next difference we can see is that we use pattern-matching,
specifically &#34;pattern guards&#34;, which allow us to select which definition
of a function we want to use. It looks a bit like a glorified
if-statement, but I find it&#39;s less syntactic noise once you get used to
it, and there are many more things pattern guards can do!</p>
<p>All that&#39;s left is to loop over all the numbers and print them out
one by one, which is a snap thanks to the <code>for_</code>
function!</p>
<p>Next!</p>
<h3 id="sum-up-to-n-problem">Sum up to N problem</h3>
<p>Here&#39;s a less-common problem that nonetheless I&#39;ve still heard a few
times! I think it was in one of my algorithms assignments back in the
day...</p>
<p>The task is to take a <strong>list of numbers</strong> and find any
<strong>combinations of <em>3</em> numbers</strong> which add up to a
specified total. For instance, if we want to determine all combinations
of <strong>3</strong> numbers which add up to <strong>15</strong>, we&#39;d
expect our result to look something like this:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> sumToN <span>15</span> [<span>2</span>, <span>5</span>, <span>3</span>, <span>10</span>, <span>4</span>, <span>1</span>, <span>0</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>[[<span>2</span>,<span>3</span>,<span>10</span>],[<span>5</span>,<span>10</span>,<span>0</span>],[<span>10</span>,<span>4</span>,<span>1</span>]]</span></code></pre></div>
<p>Notice how each inner list sums to 15? We only care about
<em>combinations</em> here, not <em>permutations</em>, so we have
<code>[2, 3, 10]</code>, but don&#39;t bother with
<code>[3, 2, 10]</code>!</p>
<p>So how will we set about implementing an algorithm for this? Well,
the first thing to come to mind here is that we&#39;re finding
<em>combinations</em>, then we&#39;re filtering them down to match a
predicate!</p>
<p>In Haskell we like to split problems into smaller composable pieces,
the filter part should be pretty easy, so let&#39;s tackle the combinations
problem first.</p>
<p>After a quick look through hackage it looks like there <em>is</em> a
<a href="https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:permutations"><code>permutations</code></a>
function, but strangely there&#39;s no <code>combinations</code> function! I
suppose we could somehow try to de-duplicate the output of
<code>permutations</code>, but it&#39;ll be fun to write our own version!
<code>combinations</code> are quite nice to compute recursively, so
let&#39;s try it that way!</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span>combinations ::</span> <span>Int</span> <span>-&gt;</span> [a] <span>-&gt;</span> [[a]]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span>-- Only one way to get zero things</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>combinations <span>0</span> _ <span>=</span> [[]]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>combinations n (x<span>:</span>xs) <span>=</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span>-- Get all combinations containing x by appending x to all (n-1)</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span>-- combinations of the rest of the list</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span>fmap</span> (x<span>:</span>) (combinations (n<span>-</span><span>1</span>) xs)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span>-- Combine it with all combinations from the rest of the list</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>      <span>&lt;&gt;</span> combinations n xs</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span>-- No elements means no combinations!</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>combinations _ [] <span>=</span> []</span></code></pre></div>
<p>Here we&#39;re using pattern matching and recursion to do our dirty work.
First we can confidently say that there&#39;s only ONE way to get 0 elements
from <strong>any</strong> list of elements, so we can fill that in. Next
we&#39;ll handle a single step, if we have at least one element left in the
list, we can compute all the combinations which contain that element by
prepending it to all the combinations of size <code>n-1</code> from the
remainder of the list; and we&#39;ll concatenate that with all the
combinations of the <strong>rest</strong> of the list.</p>
<p>Lastly we add one more pattern match which handles all invalid inputs
(either negative numbers or empty lists) and simply assert that they
have no valid combinations.</p>
<p>Let&#39;s try out our implementation before we move on to the next
part.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> combinations <span>3</span> [<span>1</span><span>..</span><span>5</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>[[<span>1</span>,<span>2</span>,<span>3</span>],[<span>1</span>,<span>2</span>,<span>4</span>],[<span>1</span>,<span>2</span>,<span>5</span>],[<span>1</span>,<span>3</span>,<span>4</span>],[<span>1</span>,<span>3</span>,<span>5</span>],[<span>1</span>,<span>4</span>,<span>5</span>],[<span>2</span>,<span>3</span>,<span>4</span>],[<span>2</span>,<span>3</span>,<span>5</span>],[<span>2</span>,<span>4</span>,<span>5</span>],[<span>3</span>,<span>4</span>,<span>5</span>]]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> combinations <span>2</span> [<span>1</span><span>..</span><span>4</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>[[<span>1</span>,<span>2</span>],[<span>1</span>,<span>3</span>],[<span>1</span>,<span>4</span>],[<span>2</span>,<span>3</span>],[<span>2</span>,<span>4</span>],[<span>3</span>,<span>4</span>]]</span></code></pre></div>
<p>Feel free to take the time to convince yourself that these are
correct ðŸ˜€</p>
<p>To finish it off we need to find any of these combinations which add
up to our target number.</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>sumNToTotal ::</span> <span>Int</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> [<span>Int</span>] <span>-&gt;</span> [[<span>Int</span>]]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>sumNToTotal n totalNeeded xs <span>=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span>filter</span> matchesSum (combinations n xs)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    matchesSum ys <span>=</span> <span>sum</span> ys <span>==</span> totalNeeded</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> sumNToTotal <span>3</span> <span>15</span> [<span>2</span>, <span>5</span>, <span>3</span>, <span>10</span>, <span>4</span>, <span>1</span>, <span>0</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>[[<span>2</span>,<span>3</span>,<span>10</span>],[<span>5</span>,<span>10</span>,<span>0</span>],[<span>10</span>,<span>4</span>,<span>1</span>]]</span></code></pre></div>
<p>Great! We can simply get all possible combinations and filter out the
results which don&#39;t properly sum to the expected number. One other nifty
thing here is that, because Haskell is <strong>lazy</strong>, if we only
need to find the <strong>first</strong> valid combination, we could just
grab the first result of the list and Haskell won&#39;t do any more work
than absolutely necessary.</p>
<p>But wait! There&#39;s a surprise <strong>part two</strong> of this
problem:</p>
<p>We now have to find all combinations of ANY length which sum to a
target number, lucky for us, that&#39;s pretty easy for us to adapt for!</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>sumAnyToTarget ::</span> <span>Int</span> <span>-&gt;</span> [<span>Int</span>] <span>-&gt;</span> [[<span>Int</span>]]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>sumAnyToTarget totalNeeded xs</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>foldMap</span> (\n <span>-&gt;</span> sumNToTotal n totalNeeded xs) [<span>0</span><span>..</span><span>length</span> xs]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> sumAnyToTarget <span>15</span> [<span>2</span>, <span>5</span>, <span>3</span>, <span>10</span>, <span>4</span>, <span>1</span>, <span>0</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>[ [<span>5</span>,<span>10</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>, [<span>2</span>,<span>3</span>,<span>10</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>, [<span>5</span>,<span>10</span>,<span>0</span>]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>, [<span>10</span>,<span>4</span>,<span>1</span>]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>, [<span>2</span>,<span>3</span>,<span>10</span>,<span>0</span>]</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>, [<span>10</span>,<span>4</span>,<span>1</span>,<span>0</span>]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>, [<span>2</span>,<span>5</span>,<span>3</span>,<span>4</span>,<span>1</span>]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>, [<span>2</span>,<span>5</span>,<span>3</span>,<span>4</span>,<span>1</span>,<span>0</span>]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<p>This new version re-uses the <code>sumNToTotal</code> function we
wrote in the previous step! It iterates over each possible length of
combination and finds all the winning combinations using
<code>sumNToTotal</code>, then concatenates them using
<code>foldMap</code>! Works out pretty cleanly if I do say so
myself!</p>
<h2 id="check-if-two-strings-are-anagrams">Check if two strings are
anagrams</h2>
<p>For whatever reason, interviewers LOVE string manipulation questions;
so let&#39;s try another one!</p>
<p>Here our task is to determine whether two strings are anagrams of
each other. I&#39;d say the difficulty for this one comes from thinking up
your <em>strategy</em> rather than the implementation itself. Here&#39;s how
I&#39;d give this a go in Haskell!</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Function</span> (on)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span>isAnagram ::</span> <span>String</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>Bool</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>isAnagram <span>=</span> (<span>==</span>) <span>`on`</span> <span>sort</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> isAnagram <span>&#34;elbow&#34;</span> <span>&#34;below&#34;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span>True</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> isAnagram <span>&#34;bored&#34;</span> <span>&#34;road&#34;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span>False</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> isAnagram <span>&#34;stressed&#34;</span> <span>&#34;desserts&#34;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span>True</span></span></code></pre></div>
<p>Here we&#39;re using a funky higher-order function called
<code>on</code>; <code>on</code> takes two functions, AND THEN takes two
arguments! In this case it calls &#34;sort&#34; on both arguments, then checks
if the sorted results are equal! It turns out this is sufficient to know
if two strings are anagrams!</p>
<p>But wait! What&#39;s that? What if they&#39;re in differing cases! Okay
fine!</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Char</span> (toLower)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span>isAnagram ::</span> <span>String</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>Bool</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>isAnagram a b <span>=</span> (<span>==</span>) <span>`on`</span> (<span>sort</span> <span>.</span> <span>map</span> <span>toLower</span>)</span></code></pre></div>
<p>Happy now? No? What&#39;s that? It seems non-performant? Well yes, but
actually no!</p>
<p>While it&#39;s true that sort has an <code>O(nlogn)</code> performance
profile, one interesting thing here is that sorting is
<strong>lazy</strong> in Haskell! This means that if our two strings are
unequal, they will only be sorted far enough to determine inequality! In
fact, if the first elements of each sorted string aren&#39;t equal to each
other, then we won&#39;t bother sorting any more.</p>
<p>Sure, our function isn&#39;t perfect, but it&#39;s not bad, especially since
this is the first approach that came to mind. Compare our 2 line
solution with the <a href="https://javarevisited.blogspot.com/2013/03/Anagram-how-to-check-if-two-string-are-anagrams-example-tutorial.html">Java
Solution</a> provided in the post which gave me the idea for this
problem. It might be more performant (though to be honest I haven&#39;t
benchmarked them), but if I&#39;m going to be reading this code often in the
future, I&#39;d much prefer the clearest version which performs at an
adequate level.</p>
<h2 id="min-and-max">Min and Max</h2>
<p>Here&#39;s a problem! Given a list of elements, find the smallest and
largest element of that list!</p>
<p>I&#39;ll show and discuss three different strategies for this one.</p>
<p>Here&#39;s the first:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>simpleMinMax ::</span> <span>Ord</span> a <span>=&gt;</span> [a] <span>-&gt;</span> (a, a)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>simpleMinMax xs <span>=</span> (<span>minimum</span> xs, <span>maximum</span> xs)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> simpleMinMax [<span>3</span>, <span>1</span>, <span>10</span>, <span>5</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>(<span>1</span>,<span>10</span>)</span></code></pre></div>
<p>This is the simplest way we could imagine doing this sort of thing;
and indeed it does work! Unfortunately, there are few skeletons from
&#34;legacy&#34; haskell that are hidden in this closet. Look what happens if we
try it on an empty list!</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> simpleMinMax []</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(<span>***</span> <span>Exception</span><span>:</span> Prelude.minimum<span>:</span> empty list</span></code></pre></div>
<p>Oops... Haskell isn&#39;t supposed to throw exceptions! That&#39;s okay
though, there are some other good ways to accomplish this which won&#39;t
blow up in our faces!</p>
<p>Time for the next one!</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>boundedMinMax ::</span> (<span>Bounded</span> a, <span>Ord</span> a) <span>=&gt;</span> [a] <span>-&gt;</span> (a, a)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>boundedMinMax xs <span>=</span> coerce <span>$</span> <span>foldMap</span> (\x <span>-&gt;</span> (<span>Min</span> x, <span>Max</span> x)) xs</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> boundedMinMax [<span>4</span>, <span>1</span>, <span>23</span>, <span>7</span>]<span> ::</span> (<span>Int</span>, <span>Int</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>(<span>1</span>,<span>23</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> boundedMinMax []<span> ::</span> (<span>Int</span>, <span>Int</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>(<span>9223372036854775807</span>,<span>-</span><span>9223372036854775808</span>)</span></code></pre></div>
<p>This implementation might be a bit confusing if you haven&#39;t learned
enough about Semigroups and Monoids, but don&#39;t let that scare you! These
are both very common abstractions in Haskell and are used very often and
to great effect!</p>
<p>A Semigroup is a type of interface which provides an implementation
which lets us combine multiple elements together. Haskell has two
semigroup type-wrappers which provide specific behaviour to whichever
type we wrap: <code>Min</code> and <code>Max</code>!</p>
<p>These types define a combining operation which, any time we combine
two elements, will keep only the smallest or largest value respectively!
I&#39;m using <code>foldMap</code> here to project each list element into a
tuple of these two types which, when the list is collapsed by
<code>foldMap</code>, will all combine together and will include the
lowest and highest elements, all in a single pass!</p>
<p>So what&#39;s up with the second example? Well, it&#39;s a bit unexpected,
but not necessarily <em>wrong</em>. When we&#39;re missing any elements to
compare foldMap will use the default value for each of our type
wrappers, which it can do if they&#39;re monoids. For <code>Min</code> and
<code>Max</code> the default value is the &#34;smallest&#34; and &#34;largest&#34; value
of the wrapped type, which is defined by the <code>Bounded</code>
interface that we require in the type signature. This works okay, and
behaves as expected under <em>most</em> circumstances, but maybe we can
try one more time:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Semigroup</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>minMax ::</span> <span>Ord</span> a <span>=&gt;</span> [a] <span>-&gt;</span> <span>Maybe</span> (a, a)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>minMax xs <span>=</span> <span>case</span> <span>foldMap</span> (\a <span>-&gt;</span> <span>Just</span> (<span>Min</span> a, <span>Max</span> a)) xs <span>of</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                <span>Just</span> (<span>Min</span> x, <span>Max</span> y) <span>-&gt;</span> <span>Just</span> (x, y)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                _ <span>-&gt;</span> <span>Nothing</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> minMax [<span>4</span>, <span>1</span>, <span>9</span>, <span>5</span>]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span>Just</span> (<span>1</span>,<span>9</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span>&gt;&gt;&gt;</span> minMax []</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span>Nothing</span></span></code></pre></div>
<p>Okay! This is pretty much the same, but we needed an
<strong>explicit</strong> way to correctly handle an empty list of
values. In this case, by wrapping our tuple in <code>Just</code> we
invoke the <code>Maybe</code> monoid, and remember that
<code>foldMap</code> is smart enough to return the &#34;empty&#34; element of
that monoid if our list is empty! That means we get <code>Nothing</code>
back if there are no elements.</p>
<p>This may seem like &#34;magic&#34; at first, but all of these
<em>typeclasses</em> have <strong>laws</strong> which dictate their
behaviour and make them predictable. I suggest learning more about
monoids if you have time, they&#39;re fascinating and useful!</p>
<p>This is a very &#34;safe&#34; implementation, in fact much safer than most
languages would offer. We explicitly return <code>Nothing</code> in the
case that the list is empty, and the <code>Maybe</code> return type
requires the caller to handle that case. I mentioned earlier how
functions are composable, and it turns out that data-types are too! If
we pair two objects with a semigroup together in a tuple, that tuple has
a semigroup instance too, which combines respective element together
when we combine tuples!</p>
<h2 id="word-frequency">Word Frequency</h2>
<p>This is a pretty popular one too!</p>
<p>The challenge this time is, given a block of text, find the most
common word!</p>
<p>Ultimately, this comes down to an understanding of
data-structures.</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.List</span> (maximumBy)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>Data.Function</span> (on)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>import</span> <span>qualified</span> <span>Data.Map</span> <span>as</span> <span>M</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span>mostCommonWord ::</span> <span>String</span> <span>-&gt;</span> <span>Maybe</span> <span>String</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>mostCommonWord str <span>=</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span>if</span> <span>null</span> wordCounts</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>       <span>then</span> <span>Nothing</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>       <span>else</span> <span>Just</span> <span>.</span> <span>fst</span> <span>.</span> maximumBy (<span>compare</span> <span>`on`</span> <span>snd</span>) <span>.</span> M.toList <span>$</span> wordCounts</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    wordCounts <span>=</span> M.unionsWith (<span>+</span>) <span>.</span> <span>fmap</span> (\w <span>-&gt;</span> M.singleton w <span>1</span>) <span>.</span> <span>words</span> <span>$</span> str</span></code></pre></div>
<p>There&#39;s a bit more going on this time, so let&#39;s break it down a
bit!</p>
<p>In Haskell, we use &#34;math-style&#34; function composition using
<code>.</code>, so we read most expressions from right-to-left.</p>
<p>Let&#39;s look at the <code>wordCounts</code> binding down in the
<code>where</code> clause first. Reading from right to left, first we
use the <code>words</code> function from the built-in Prelude to split
the incoming stream into a list of words, then we create a key-value map
out of each one, consisting of the word as the key with a value of
<code>1</code> to start.</p>
<p>Now we have a list of key-value maps, and can add them up all up
key-wise using <code>unionsWith</code> from the <code>Data.Map</code>
library, this will count up the number of elements of each key and will
result in a key-value mapping where the values represent
occurrences.</p>
<p>We&#39;ve got a mapping now, so let&#39;s find the largest count!</p>
<p>First things first, to be safe we&#39;ll check whether the map has any
values at all, if it doesn&#39;t then we&#39;ll return <code>Nothing</code>.
Otherwise, we can convert the map into a list of key-value pairs by
calling <code>M.toList</code>, then we can use <code>maximumBy</code> to
return the biggest element according to a comparison function that we
specify! <code>on</code> comes in handy here and we can tell it to
compare on the second element, which is the count. That will return us
the key-value pair with the largest value, then we just need to grab the
key as a result using <code>fst</code>!</p>
<p>Ultimately this is a bit of a naive implementation which won&#39;t work
well on huge texts, but it should be enough to get you through the
whiteboard portion of the interview ðŸ˜„.</p>
<h2 id="summary">Summary</h2>
<p>That&#39;s all I&#39;ve got for you today, nothing to revolutionary I&#39;m sure,
but hopefully you had a bit of fun, or maybe learned a thing or two
about what code looks like in Haskell compared to your favourite
language ðŸ˜„</p>

        <p>
          Hopefully you learned something ðŸ¤ž! If you did, please consider
          checking out my book: It teaches the principles of using optics in
          Haskell and other functional programming languages and takes you all
          the way from an beginner to wizard in all types of optics! You can get
          it <a href="https://leanpub.com/optics-by-example/">here</a>. Every
          sale helps me justify more time writing blog posts like this one and
          helps me to continue writing educational functional programming
          content. Cheers!
        </p>

        <!--Share buttons-->
        

        <!-- Disqus Comments -->
        <!-- <div id="disqus_thread"></div> -->
        <!-- <script type="text/javascript"> -->
        <!--     var disqus_shortname = 'chrispenner'; -->
        <!--     var disqus_identifier = ''; -->
        <!--     var disqus_url = 'http://chrispenner.ca'; -->

        <!-- (function() { -->
        <!-- var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; -->
        <!-- dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; -->
        <!-- (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); -->
        <!-- })(); -->
        <!-- </script> -->
      </article></div>
  </body>
</html>
