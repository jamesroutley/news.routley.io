<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lowleveldesign.org/2022/01/17/com-revisited/">Original</a>
    <h1>COM&#43; Revisited</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>More than ten years ago (how time flies!), when I published the basic sample of a COM+ server and client, I thought that I wouldn‚Äôt be touching this subject again. But here we are, in 2022, and I have so much interaction with COM at work that I decided to write a new, updated, and a bit more detailed post about this technology üòÅ I don‚Äôt want to convince you to use COM as the backbone for your new applications. Instead, I want to show you how you may approach and use COM APIs if you need to work with them. We will also do some COM debugging in WinDbg. Additionally, I plan to release <strong>a new COM troubleshooting tool</strong> as part of the <a href="https://wtrace.net/">wtrace toolkit</a>. Remember to <a href="https://wtrace.net/subscribe/"><strong>subscribe to wtrace updates</strong></a> if you‚Äôre interested.</p>



<p>Today‚Äôs post will continue using the <a href="https://lowleveldesign.org/2010/10/02/creating-a-simple-com-component-in-c/">old Protoss COM classes</a>, but we will update the code with various modern ideas. As you may remember, <code>Nexus</code> and <code>Probe</code> classes represent Blizzard‚Äôs Starcraft game objects. Nexus is a building that may produce Probes (<code>CreateUnit</code> method in the <code>INexus</code> interface), and Probe may build various structures, including Nexuses (<code>ConstructBuilding</code> method in the <code>IProbe</code> interface). I also added a new <strong><code>IGameObject</code> </strong>interface, shared by <code>Nexus</code> and <code>Probe</code>, that returns the cost in minerals and the time needed to build a given game object. In IDL, it looks as follows:</p>


<div><pre title="">[object, uuid(59644217-3e52-4202-ba49-f473590cc61a)]
interface IGameObject : IUnknown
{
    [propget]
    HRESULT Name([out, retval] BSTR* name);

    [propget]
    HRESULT Minerals([out, retval]LONG* minerals);

    [propget]
    HRESULT BuildTime([out, retval]LONG* buildtime);
}
</pre></div>


<p>I also added a <strong>type library</strong> to the IDL:</p>


<div><pre title="">[
    uuid(0332a9ab-e3bb-4042-bc6a-b98aebd6532d),
    version(1.0),
    helpstring(&#34;Protoss 1.0 Type Library&#34;)
    ]
library ProtossLib
{
    importlib(&#34;stdole2.tlb&#34;);

    interface INexus;
    interface IProbe;

    [
        uuid(F5353C58-CFD9-4204-8D92-D274C7578B53),
        helpstring(&#34;Nexus Class&#34;)
        ]
    coclass Nexus {
        [default] interface INexus;
        interface IGameObject;
    }

    [
        uuid(EFF8970E-C50F-45E0-9284-291CE5A6F771),
        helpstring(&#34;Probe Class&#34;)
        ]
    coclass Probe {
        [default] interface IProbe;
        interface IGameObject;
    }
}
</pre></div>


<p>If we run <strong>midl.exe</strong> after this change, it will generate a type library file (<strong>protoss.tlb</strong>). The type library provides a language-agnostic way to access COM metadata. For example, we may import it to a .NET assembly using the <strong>tlbimp.exe</strong> tool from .NET Framework SDK.</p>



<h3 id="the-protoss-com-server">Updating the Protoss COM server</h3>



<p>As you remember, the COM server requires a few DLL exports to make its COM classes instantiable. One of them is <code><strong>DllGetClassObject</strong></code>. The <code>DllGetClassObject</code> function from the old post directly constructed the <code>Nexus</code> and <code>Probe</code> objects. The more common approach is to return an <code><strong>IClassFactory</strong></code> instance for each implemented class and let the clients call its <code>CreateInstance</code> method. The clients often do this implicitly by calling the <code>CoCreateInstance</code> or <code>CoCreateInstanceEx</code> functions. These functions first ask for a class factory object and later use it to create a requested class instance. Supporting <code>IClassFactory</code> is straightforward:</p>


<div><pre title="">STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
	if (rclsid == __uuidof(Nexus)) {
		static ProtossObjectClassFactory&lt;Nexus, INexus&gt; factory{};
		return factory.QueryInterface(riid, ppv);
	} 
    if (rclsid == __uuidof(Probe)) {
		static ProtossObjectClassFactory&lt;Probe, IProbe&gt; factory{};
		return factory.QueryInterface(riid, ppv);
	}
	return CLASS_E_CLASSNOTAVAILABLE;
}
</pre></div>


<p>The <a href="https://github.com/lowleveldesign/protoss-com-example/blob/main/ProtossCom/factory.h"><code>ProtossObjectClassFactory</code></a> is a class template implementing the <code>IClassFactory</code> interface. I want to bring your attention to the <code>CreateInstance</code> method:</p>


<div><pre title="">HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter, REFIID riid, void** ppv) override {
    if (pUnkOuter) {
        return CLASS_E_NOAGGREGATION;
    }

    try {
        wil::com_ptr_t&lt;IUnknown&gt; unknown{};
        // attach does not call AddRef (we set ref_count to 1 in COM Objects)
        unknown.attach(static_cast&lt;IT*&gt;(new T()));
        return unknown-&gt;QueryInterface(riid, ppv);
    } catch (const std::bad_alloc&amp;) {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
</pre></div>


<p>It uses the <code><strong>wil::com_ptr_t</strong></code> class. It‚Äôs one of the many <strong>smart pointers</strong> provided by <a href="https://github.com/microsoft/wil"><strong>Windows Implementation Library</strong></a>. Thanks to <code>wil::com_ptr_t</code> or <code>wil::unique_handle</code>, we no longer need to call <code>Release</code> or <code>CloseHandle</code> methods explicitly ‚Äì they are called automatically in the smart pointer destructors. Thus, we free the resources when the pointers go out of scope. WIL and modern C++ really make using <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> with Windows API straightforward üòÅ.</p>



<p>One missing piece in the old code was <strong>registration</strong>. I used reg files to register the Protoss COM library in the system. It‚Äôs not the best way to do so, and, instead, we should implement <strong><code>DllRegisterServer</code> </strong>and <strong><code>DllUnregisterServer</code> </strong>functions so that the clients may register and unregister our library with the <strong>regsvr32.exe</strong> tool. The code presented below is based on the sample from the great <a href="https://leanpub.com/b/windows10systemprogrammingP1and2">Windows 10 System Programming book</a> by Pavel Yosifovich. Only in my version, I used WIL, and you may quickly see its usage benefits when you look at <a href="https://github.com/zodiacon/Win10SysProgBookSamples/blob/master/Chapter21/RPNCalcSvr/dllmain.cpp">the original version</a> (for example, no calls to <code>CloseHandle</code> and no error checks thanks to WIL result macros):</p>


<div><pre title="">std::array&lt;std::tuple&lt;std::wstring_view, std::wstring, std::wstring&gt;, 2&gt; coclasses{
	std::tuple&lt;std::wstring_view, std::wstring, std::wstring&gt; { L&#34;Protoss Nexus&#34;, wstring_from_guid(__uuidof(Nexus)), L&#34;Protoss.Nexus.1&#34; },
	std::tuple&lt;std::wstring_view, std::wstring, std::wstring&gt; { L&#34;Protoss Probe&#34;, wstring_from_guid(__uuidof(Probe)), L&#34;Protoss.Probe.1&#34; },
};

STDAPI DllRegisterServer() {
	auto create_reg_subkey_with_value = [](HANDLE transaction, HKEY regkey, std::wstring_view subkey_name, std::wstring_view subkey_value) {
		wil::unique_hkey subkey{};
		RETURN_IF_WIN32_ERROR(::RegCreateKeyTransacted(regkey, subkey_name.data(), 0, nullptr, REG_OPTION_NON_VOLATILE,
			KEY_WRITE, nullptr, subkey.put(), nullptr, transaction, nullptr));
		RETURN_IF_WIN32_ERROR(::RegSetValueEx(subkey.get(), nullptr, 0, REG_SZ,
			reinterpret_cast&lt;const BYTE*&gt;(subkey_value.data()), static_cast&lt;DWORD&gt;((subkey_value.size() + 1) * sizeof(wchar_t))));

		return S_OK;
	};

	wil::unique_handle transaction{ ::CreateTransaction(nullptr, nullptr, TRANSACTION_DO_NOT_PROMOTE, 0, 0, INFINITE, nullptr) };
	RETURN_LAST_ERROR_IF(!transaction.is_valid());

	for (const auto&amp; coclass : coclasses) {
		auto name{ std::get&lt;0&gt;(coclass) };
		auto clsid{ std::get&lt;1&gt;(coclass) };
		auto progId{ std::get&lt;2&gt;(coclass) };

		wil::unique_hkey regkey{};
		// CLSID
		RETURN_IF_WIN32_ERROR(::RegCreateKeyTransacted(HKEY_CLASSES_ROOT, (L&#34;CLSID\\&#34; + clsid).c_str(),
			0, nullptr, REG_OPTION_NON_VOLATILE, KEY_WRITE, nullptr, regkey.put(), nullptr, transaction.get(), nullptr));
		RETURN_IF_WIN32_ERROR(::RegSetValueEx(regkey.get(), L&#34;&#34;, 0, REG_SZ,
			reinterpret_cast&lt;const BYTE*&gt;(name.data()), static_cast&lt;DWORD&gt;((name.size() + 1) * sizeof(wchar_t))));

		RETURN_IF_FAILED(create_reg_subkey_with_value(transaction.get(), regkey.get(), L&#34;InprocServer32&#34;, dll_path));
		RETURN_IF_FAILED(create_reg_subkey_with_value(transaction.get(), regkey.get(), L&#34;ProgID&#34;, dll_path));

		// ProgID
		RETURN_IF_WIN32_ERROR(::RegCreateKeyTransacted(HKEY_CLASSES_ROOT, progId.c_str(),
			0, nullptr, REG_OPTION_NON_VOLATILE, KEY_WRITE, nullptr, regkey.put(), nullptr, transaction.get(), nullptr));
		RETURN_IF_WIN32_ERROR(::RegSetValueEx(regkey.get(), L&#34;&#34;, 0, REG_SZ,
			reinterpret_cast&lt;const BYTE*&gt;(name.data()), static_cast&lt;DWORD&gt;((name.size() + 1) * sizeof(wchar_t))));

		RETURN_IF_FAILED(create_reg_subkey_with_value(transaction.get(), regkey.get(), L&#34;CLSID&#34;, clsid));
	}

	RETURN_IF_WIN32_BOOL_FALSE(::CommitTransaction(transaction.get()));

	return S_OK;
}
</pre></div>


<p>As you maybe noticed, I also added the registration of <strong>ProgID</strong>s<strong> </strong>(Protoss.Nexus.1 and Protoss.Probe.1), which are human-friendly names for our COM classes. With these functions implemented, registering our COM classes is now a matter of calling <strong>regsvr32.exe protoss.dll </strong>from the administrator‚Äôs command line.</p>



<h3 id="updating-the-protoss-com-client">Updating the Protoss COM client</h3>



<p>Thanks to the type library, we no longer need to explicitly generate and include the header files, but we may import the type library directly into the source code. The <code>#import</code> directive that we use for this purpose has <a href="https://docs.microsoft.com/en-us/cpp/preprocessor/hash-import-attributes-cpp?view=msvc-170">several attributes</a> controlling the representation of the type library in C++. For example, in the Protoss COM client, I‚Äôm using the <code>raw_interfaces_only</code> attribute as I want to work with the Protoss interfaces directly using the WIL <code>com_ptr_t</code> smart pointers. Our COM server uses <code>IClassFactory</code>, so we may call the <strong><code>CoCreateInstance</code> </strong>function to create an instance of the <code>Nexus</code> class:</p>


<div><pre title="">#include &lt;iostream&gt;

#include &lt;Windows.h&gt;
#include &lt;wil/com.h&gt;

#import &#34;..\protoss.tlb&#34; raw_interfaces_only

using namespace ProtossLib;

HRESULT show_game_unit_data(IUnknown* unknwn) {
    wil::com_ptr_t&lt;IGameObject&gt; unit{};
    RETURN_IF_FAILED(unknwn-&gt;QueryInterface(unit.put()));

    wil::unique_bstr name{};
    RETURN_IF_FAILED(unit-&gt;get_Name(name.put()));
    LONG minerals;
    RETURN_IF_FAILED(unit-&gt;get_Minerals(&amp;minerals));
    LONG buildtime;
    RETURN_IF_FAILED(unit-&gt;get_BuildTime(&amp;buildtime));

    std::wcout &lt;&lt; L&#34;Name: &#34; &lt;&lt; name.get() &lt;&lt; L&#34;, minerals: &#34; &lt;&lt; minerals
        &lt;&lt; L&#34;, build time: &#34; &lt;&lt; buildtime &lt;&lt; std::endl;

    return S_OK;
}

void start_from_probe() {
	wil::com_ptr_t&lt;IProbe&gt; probe{};

	THROW_IF_FAILED(::CoCreateInstance(__uuidof(Probe), nullptr, CLSCTX_INPROC_SERVER, __uuidof(IProbe), probe.put_void()));
	THROW_IF_FAILED(show_game_unit_data(probe.get()));

	auto name{ wil::make_bstr(L&#34;Nexus&#34;) };
	wil::com_ptr_t&lt;INexus&gt; nexus{};
	THROW_IF_FAILED(probe-&gt;ConstructBuilding(name.get(), nexus.put_unknown()));
	THROW_IF_FAILED(show_game_unit_data(nexus.get()));
}

int main(int argc, char* argv[]) {
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    try {
        // a &#34;smart call object&#34; that will execute CoUnitialize in destructor
        auto runtime{ wil::CoInitializeEx(COINIT_APARTMENTTHREADED) };

        start_from_probe();

        return 0;
    } catch (const wil::ResultException&amp; ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    } catch (const std::exception&amp; ex) {
        std::cout &lt;&lt; ex.what() &lt;&lt; std::endl;
        return 1;
    }
}
</pre></div>


<p>If you run the client, you should see the calls to the <code>QueryInterface</code> method and logs from constructors and destructors in the console:</p>



<pre>Component: Nexus::QueryInterface: 246a22d5-cf02-44b2-bf09-aab95a34e0cf
Component: Probe::AddRef() ref_count = 2
Component: Probe::Release() ref_count = 1
Component: Probe::AddRef() ref_count = 2
Component: Probe::Release() ref_count = 1
Component: Nexus::QueryInterface: 246a22d5-cf02-44b2-bf09-aab95a34e0cf
Component: Probe::AddRef() ref_count = 2
Component: Probe::Release() ref_count = 1
Component: Nexus::QueryInterface: 59644217-3e52-4202-ba49-f473590cc61a
Component: Probe::AddRef() ref_count = 2
Name: Probe, minerals: 50, build time: 12
Component: Probe::Release() ref_count = 1
Component: Nexus::QueryInterface: 59644217-3e52-4202-ba49-f473590cc61a
Component: Nexus::AddRef() ref_count = 2
Name: Nexus, minerals: 400, build time: 120
Component: Nexus::Release() ref_count = 1
Component: Nexus::Release() ref_count = 0
Component: Nexus::~Nexus()
Component: Probe::Release() ref_count = 0
Component: Probe::~Probe()</pre>



<p>We can see that all class instances are eventually freed, so, hurray üéâ, we aren‚Äôt leaking any memory!</p>



<p>If you‚Äôd like to practice writing COM client code, you may implement a <code>start_from_nexus</code> function to output the same information, but create the <code>Nexus</code> class first. Don‚Äôt look at the client code in the repository, as this function is already there üòä</p>



<p>C++ is not the only language to write a COM client. Let‚Äôs now implement the same logic in <strong>C#</strong>. I picked C# not without reason. <strong>.NET Runtime</strong> provides excellent support for working with native COM objects. Each COM class receives a <strong><a href="https://docs.microsoft.com/en-us/dotnet/standard/native-interop/runtime-callable-wrapper">Runtime Callable Wrapper</a> </strong>that makes the COM class look like any other .NET class. Now, you can imagine the number of magic layers to make it happen. So, there is no surprise that sometimes, you may need to wear a magical debugging hat to resolve a problem in COM interop üòÖ But if you look at the code, it‚Äôs effortless:</p>


<div><pre title="">using ProtossLib;

public static class Program
{
    static void ShowGameUnitData(IGameObject go)
    {
        Console.WriteLine($&#34;Name: {go.Name}, minerals: {go.Minerals}, build time: {go.BuildTime}&#34;);
    }

    static void StartingFromProbe()
    {
        var probe = new Probe();
        ShowGameUnitData((IGameObject)probe);

        var nexus = probe.ConstructBuilding(&#34;Nexus&#34;);
        ShowGameUnitData((IGameObject)nexus);

        //_ = Marshal.ReleaseComObject(nexus);
        //_ = Marshal.ReleaseComObject(probe);
    }

    [STAThread]
    static void Main()
    {
        StartingFromProbe();

        // force release of the COM objects
        GC.Collect();
    }
}
</pre></div>


<p>If you decompile the ProtossLib.dll assembly, you will discover that <code>Probe</code> is, in fact, an interface with a CoClass attribute. And, although it does not implement <code>IGameObject</code>, we may cast it to <code>IGameObject</code>. Magical, isn‚Äôt it? üòä Mixed-mode debugging helps a lot when debugging COM interop in .NET. For example, if you set a breakpoint on the <code>QueryInterface</code> method in the <code>Probe</code> class, you will discover that it i called when you cast the managed <code>Probe</code> instance to <code>IGameObject</code>.</p>



<h3 id="debugging-com-in-windbg">Debugging COM in WinDbg</h3>



<p>In this paragraph, I want to focus on debugging COM servers and clients in WinDbg. I will show you some commands, hoping they will be helpful also in your COM troubleshooting.</p>



<p>Let‚Äôs start with a breakpoint on the typical entry point for creating COM objects, i.e., the <strong><code>CoCreateInstance</code> </strong>function (if the COM client does not use <code>CoCreateInstance</code>, you may set a breakpoint on the <code>CoGetClassObject</code> function):</p>


<div><pre title="">HRESULT CoCreateInstance(
  [in]  REFCLSID  rclsid,
  [in]  LPUNKNOWN pUnkOuter,
  [in]  DWORD     dwClsContext,
  [in]  REFIID    riid,
  [out] LPVOID    *ppv
);
</pre></div>


<p>Our goal is to print the function parameters (CLSID, IID, and the object address), so we know which object the client creates. If we have combase.dll private symbols, it‚Äôs a matter of calling the <strong>dv</strong> command. Otherwise, we need to rely on the <strong>dt</strong> command. For 32-bit, I usually create the <code>CoCreateInstance</code> breakpoint as follows:</p>



<pre>bp combase!CoCreateInstance &#34;dps @esp L8; dt ntdll!_GUID poi(@esp + 4); dt ntdll!_GUID poi(@esp + 10); .printf /D \&#34;==&gt; obj addr: %p\&#34;, poi(@esp+14);.echo; bp /1 @$ra; g&#34;</pre>



<p>And the 64-bit version is:</p>



<pre>bp combase!CoCreateInstance &#34;dps @rsp L8; dt ntdll!_GUID @rcx; dt ntdll!_GUID @r9; .printf /D \&#34;==&gt; obj addr: %p\&#34;, poi(@rsp+28);.echo; bp /1 @$ra; g&#34;</pre>



<p>I‚Äôm using <code><strong>bp /1 @$ra; g</strong></code> to break at the moment when the function returns. I didn‚Äôt want to use, for example, <code>gu</code> because one <code>CoCreateInstance</code> may call another <code>CoCreateInstance</code>, and one-time breakpoints are more reliable in such situations. An example 32-bit breakpoint hit might look as follows (notice that when we have private symbols, <code>dps</code> command nicely prints the GUIDs):</p>



<pre>009cfe00  008c36ae ProtossComClient!main+0x6e
009cfe04  008c750c ProtossComClient!_GUID_eff8970e_c50f_45e0_9284_291ce5a6f771
009cfe08  00000000
009cfe0c  00000001
009cfe10  008c74b4 ProtossComClient!_GUID_246a22d5_cf02_44b2_bf09_aab95a34e0cf
009cfe14  009cfe3c
009cfe18  36e9dfe6
009cfe1c  00e8b3e0
 {eff8970e-c50f-45e0-9284-291ce5a6f771}
   +0x000 Data1            : 0xeff8970e
   +0x004 Data2            : 0xc50f
   +0x006 Data3            : 0x45e0
   +0x008 Data4            : [8]  &#34;???&#34;
 {246a22d5-cf02-44b2-bf09-aab95a34e0cf}
   +0x000 Data1            : 0x246a22d5
   +0x004 Data2            : 0xcf02
   +0x006 Data3            : 0x44b2
   +0x008 Data4            : [8]  &#34;???&#34;
==&gt; obj addr: 009cfe3c
ModLoad: 76fb0000 7702e000   C:\Windows\System32\clbcatq.dll
ModLoad: 618b0000 618b9000   C:\Windows\SYSTEM32\ktmw32.dll
ModLoad: 76df0000 76e66000   C:\Windows\System32\sechost.dll
ModLoad: 75c40000 75cbb000   C:\Windows\System32\ADVAPI32.dll
ModLoad: 031a0000 031ae000   C:\Users\me\repos\protoss-com-example\Release\protoss.dll
Breakpoint 1 hit
eax=00000000 ebx=00628000 ecx=00e84ea0 edx=00000000 esi=00e84310 edi=00e8b3e0
eip=008c36ae esp=009cfe18 ebp=009cfe58 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
ProtossComClient!start_from_probe+0x23 [inlined in ProtossComClient!main+0x6e]:
008c36ae 8b4d04          mov     ecx,dword ptr [ebp+4] ss:002b:009cfe5c=008c56b1</pre>



<p>In the output, we can find <strong>CLSID </strong>(<code>eff8970e-c50f-45e0-9284-291ce5a6f771</code>), <strong>IID </strong>(<code>246a22d5-cf02-44b2-bf09-aab95a34e0cf</code>) and the created object address: <code>010ff620</code>. Before we start examining it, we need to check the returned status code. We can do that with the <code><strong>!error @$retreg</strong></code> command (or look at the <code>eax</code>/<code>rax</code> register). If it‚Äôs <code>0</code> (<code>S_OK</code>), we may set breakpoints on the returned object methods. As each COM object implements at least one interface (virtual class), it will have at least one virtual method table. Thanks to the <code>CoCreateInstance</code> breakpoint, we know the queried IID, and we may find the interface method list in the associated type library. If we don‚Äôt have access to the type library (or our IID is <code>IID_IUnknown</code>), we still may learn something about this object by placing breakpoints on the <code>IUnknown</code> interface methods (as you remember, all COM interfaces need to implement it):</p>


<div><pre title="">struct IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ _COM_Outptr_ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;

    virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0;

    virtual ULONG STDMETHODCALLTYPE Release( void) = 0;
};
</pre></div>


<p>The breakpoint is very similar to what we did for <code>CoCreateInstace</code>. The code snippet below presents the 32- and 64-bit versions:</p>



<pre>bp 031a6160 &#34;dt ntdll!_GUID poi(@esp + 8); .printf /D \&#34;==&gt; obj addr: %p\&#34;, poi(@esp + C);.echo; bp /1 @$ra; g&#34;

bp 00007ffe`1c751e6a &#34;dt ntdll!_GUID @rdx; .printf /D \&#34;==&gt; obj addr: %p\&#34;, @r8;.echo; bp /1 @$ra; g&#34;</pre>



<p>Let me show you how I got the address of the <code>QueryInterface</code> function for the 32-bit breakpoint (<code>031a6160</code>). The first four bytes at the object address (<code>009cfe3c</code>) point to the virtual method table. We may find the vtable address by calling <code>dpp 009cfe3c L1</code>:</p>



<pre>0:000&gt; dpp 009cfe3c L1
009cfe3c  00e84ea0 031a860c protoss!Probe::`vftable&#39;</pre>



<p>We can now dump the content of the vtable:</p>



<pre>0:000&gt; dps 031a860c L4
031a860c  031a6160 protoss!Probe::QueryInterface
031a8610  031a6070 protoss!Probe::AddRef
031a8614  031a60b0 protoss!Probe::Release
031a8618  031a6260 protoss!Probe::ConstructBuilding</pre>



<p>I knew that the <code>IProbe</code> interface (<code>246A22D5-CF02-44B2-BF09-AAB95A34E0CF</code>) has four methods (the first three coming from the <code>IUnknown</code> interface). Without this knowledge, I would have printed only the first three methods (<code>QueryInterface</code>, <code>AddRef</code>, and <code>Release</code>).</p>



<p>On each <code>QueryInterface</code> return, we may again examine the status code and returned object. The output below presents a <code>QueryInterface</code> hit for an <code>IProbe</code> instance. Let‚Äôs spend a moment analyzing it:</p>



<pre> {59644217-3e52-4202-ba49-f473590cc61a}
   +0x000 Data1            : 0x59644217
   +0x004 Data2            : 0x3e52
   +0x006 Data3            : 0x4202
   +0x008 Data4            : [8]  &#34;???&#34;
==&gt; obj addr: 009cfe00
Breakpoint 2 hit
eax=00000000 ebx=00628000 ecx=5a444978 edx=00000000 esi=00e84310 edi=00e8b3e0
eip=008c34f6 esp=009cfdec ebp=009cfe10 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
ProtossComClient!show_game_unit_data+0x46:
008c34f6 8bf0            mov     esi,eax</pre>



<p>The <code>59644217-3e52-4202-ba49-f473590cc61a</code> GUID represents the <code>IGameObject</code> interface. If you scroll up to the class definitions, you will find that it‚Äôs the second interface that the Probe class implements. The vtable at the object address looks as follows:</p>



<pre>0:000&gt; dpp 009cfe00 L1
009cfe00  00e84ea4 031a8620 protoss!Probe::`vftable&#39;
0:000&gt; dps 031a8620 L6
031a8620  031a5c40 protoss![thunk]:Probe::QueryInterface`adjustor{4}&#39;
031a8624  031a5c72 protoss![thunk]:Probe::AddRef`adjustor{4}&#39;
031a8628  031a5c4a protoss![thunk]:Probe::Release`adjustor{4}&#39;
031a862c  031a36f0 protoss!Probe::get_Name
031a8630  031a3720 protoss!Probe::get_Minerals
031a8634  031a3740 protoss!Probe::get_BuildTime</pre>



<p>You may now be wondering what the <code>adjustor</code> methods are? If we decompile any of them, we will find an interesting assembly code:</p>



<pre>0:000&gt; u 031a5c40
protoss![thunk]:Probe::QueryInterface`adjustor{4}&#39;:
031a5c40 836c240404      sub     dword ptr [esp+4],4
031a5c45 e916050000      jmp     protoss!Probe::QueryInterface (031a6160)</pre>



<p>To better understand what‚Äôs going on here, let‚Äôs put the last <code>dpp</code> commands (after <code>CoCreateInstance</code> and <code>QueryInterface</code>) next to each other:</p>



<pre>0:000&gt; dpp 009cfe3c L1
009cfe3c 00e84ea0 031a860c protoss!Probe::`vftable&#39; &lt;- CoCreateInstance
0:000&gt; dpp 009cfe00 L1
009cfe00 00e84ea4 031a8620 protoss!Probe::`vftable&#39; &lt;- QueryInterface</pre>



<p>In the above output, we see that <code>QueryInterface</code> for <code>IProbe</code> (called by <code>CoCreateInstance</code>) sets the object pointer to the address <code>00e84ea0</code>. While <code>QueryInterface</code> for <code>IGameObject</code> sets the object pointer to the address <code>00e84ea4</code> (four bytes further). And both calls were made on the same instance of the <code>Probe</code> class. Looking at the <code>QueryInterface</code> source code, we can see that this difference is caused by a <code>static_cast</code>:</p>


<div><pre title="">HRESULT __stdcall Probe::QueryInterface(REFIID riid, void** ppv) {
	std::cout &lt;&lt; &#34;Component: Nexus::QueryInterface: &#34; &lt;&lt; riid &lt;&lt; std::endl;

	if (riid == IID_IUnknown || riid == __uuidof(IProbe)) {
		*ppv = static_cast&lt;IProbe*&gt;(this);
	} else if (riid == __uuidof(IGameObject)) {
		*ppv = static_cast&lt;IGameObject*&gt;(this);
	} else {
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}
</pre></div>


<p>The instruction <code>*ppv = static_cast&lt;IProbe*&gt;(this)</code> is here equivalent to <code>*ppv = this</code>, as <code>IProbe</code> is the default (first) interface of the <code>Probe</code> class, and a pointer to its vtable occupies the first four bytes of the <code>Probe</code> instance memory. <code>IGameObject</code> is the second interface and a pointer to its vtable occupies the next four bytes of the <code>Probe</code> instance memory. After these two vtables, we can find fields of the <code>Probe</code> class. I draw the diagram below to better visualize these concepts:</p>



<figure><a href="https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png"><img data-attachment-id="4687" data-permalink="https://lowleveldesign.org/probe-mem-layout/" data-orig-file="https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png" data-orig-size="2500,1667" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="probe-mem-layout" data-image-description="" data-image-caption="" data-medium-file="https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=300" data-large-file="https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=982" src="https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=1024" alt="" srcset="https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=1024 1024w, https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=2048 2048w, https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=150 150w, https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=300 300w, https://lowleveldesign.files.wordpress.com/2022/01/probe-mem-layout.png?w=768 768w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<p>So, what are those adjustors in the <code>IGameObject</code> vtable? Adjustors allow the compiler to reuse the <code>IUnknown</code> methods already compiled for the <code>IProbe</code> implementation. The only problem with reusing is that methods implementing <code>IProbe</code> expect <code>this</code> to point to the beginning of the <code>Probe</code> class instance. So we can‚Äôt simply use their addresses in the <code>IGameObject</code> vtable ‚Äì we need first to adjust the <code>this</code> pointer. And that‚Äôs what the <code>sub dword ptr [esp+4],4</code> instruction is doing. Then, we can safely jump to the <code>IProbe</code>‚Äòs <code>QueryInterface</code> implementation, and everything will work as expected.</p>



<p>To end the vtables discussion, I have one more WinDbg script for you:</p>



<pre>.for (r $t0 = 0; @$t0 &lt; N; r $t0= @$t0 + 1) { bp poi(VTABLE_ADDRESS + @$t0 * @$ptrsize) }</pre>



<p>This script sets breakpoints on the first N methods of a given vtable (replace N with any number you need). For example, to break on all the methods of the <code>IGameObject</code> interface, I would run:</p>



<pre>.for (r $t0 = 0; @$t0 &lt; 6; r $t0= @$t0 + 1) { bp poi(031a8620 + @$t0 * @$ptrsize) }</pre>



<p>We may also <strong>track COM objects from a specific DLL</strong>. When the application loads the target DLL, we need to set a breakpoint on the exported <strong><code>DllGetClassObject</code> </strong>function. For example, let‚Äôs debug what is happening when we call <code>CoCreateInstance</code> for the <code>Probe</code> COM object. We start by setting a break on the protoss.dll load:</p>



<pre>0:000&gt; sxe ld:protoss.dll
0:000&gt; g
...
ModLoad: 66c90000 66cd4000   C:\temp\protoss-com-example\Debug\protoss.dll</pre>



<p>Next, we set a breakpoint on the <code>protoss!DllGetClassObject</code> function and wait for it to hit:</p>



<pre>0:000&gt; bp protoss!DllGetClassObject &#34;dps @esp L8; dt ntdll!_GUID poi(@esp + 4); dt ntdll!_GUID poi(@esp + 8); .printf /D \&#34;==&gt; obj addr: %p\&#34;, poi(@esp+c);.echo; bp /1 @$ra; g&#34;
0:000&gt; g
009cea10  75d6b731 combase!CClassCache::CDllPathEntry::GetClassObject+0x5a [onecore\com\combase\objact\dllcache.cxx @ 2581]
009cea14  00e9f354
009cea18  75ce84c8 combase!IID_IClassFactory
009cea1c  009cec40
009cea20  00000000
009cea24  00e9b3f8
009cea28  75ce84c8 combase!IID_IClassFactory
009cea2c  00e9f354
 {eff8970e-c50f-45e0-9284-291ce5a6f771}
   +0x000 Data1            : 0xeff8970e
   +0x004 Data2            : 0xc50f
   +0x006 Data3            : 0x45e0
   +0x008 Data4            : [8]  &#34;???&#34;
 {00000001-0000-0000-c000-000000000046}
   +0x000 Data1            : 1
   +0x004 Data2            : 0
   +0x006 Data3            : 0
   +0x008 Data4            : [8]  &#34;???&#34;
==&gt; obj addr: 009cec40
Breakpoint 1 hit</pre>



<p>We can see that <code>CoCreateInstance</code> uses the <code>Probe</code> class CLSID and asks for the <code>IClassFactory</code> instance. <code>IClassFactory</code> inherits from <code>IUnknown</code> (as all COM interfaces) and contains only two methods:</p>


<div><pre title="">struct IClassFactory : public IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE CreateInstance( 
        _In_opt_  IUnknown *pUnkOuter, _In_  REFIID riid, _COM_Outptr_  void **ppvObject) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE LockServer(/* [in] */ BOOL fLock) = 0;
};
</pre></div>


<p>Let‚Äôs set a breakpoint on the <code>CreateInstance</code> method and continue execution:</p>



<pre>0:000&gt; dpp 009cec40 L1
009cec40  031ab020 031a863c protoss!ProtossObjectClassFactory&lt;Probe,IProbe&gt;::`vftable&#39;
0:000&gt; dps 031a863c L5
031a863c  031a45e0
031a8640  031a45d0
031a8644  031a45d0
031a8648  031a4500
031a864c  031a44f0
0:000&gt; bp 031a4500 &#34;dt ntdll!_GUID poi(@esp + c); .printf /D \&#34;==&gt; obj addr: %p\&#34;, poi(@esp + 10);.echo; bp /1 @$ra; g&#34;
0:000&gt; g
 {246a22d5-cf02-44b2-bf09-aab95a34e0cf}
   +0x000 Data1            : 0x246a22d5
   +0x004 Data2            : 0xcf02
   +0x006 Data3            : 0x44b2
   +0x008 Data4            : [8]  &#34;???&#34;
==&gt; obj addr: 009cec58
Breakpoint 3 hit</pre>



<p>Our breakpoint gets hit, and we see that the requested IID equals <code>IID_IProbe</code>, which proves what I mentioned previously, that <code>CoCreateInstance</code> internally uses an <code>IClassFactory</code> instance to create a new <code>Probe</code> class instance.</p>



<p>Finally, when we deal with COM automation and need to decode parameters passed to the <strong><code>IDispatch</code> </strong>instance, we may use the <code>dt -r1 combase!tagVARIANT ARG_ADDRESS</code> command. It nicely formats all the <strong><code>VARIANT</code> </strong>fields but requires the combase.dll symbols.</p>



<p>We reached the end of this long post, and I hope I haven‚Äôt bored you too much üòÖ I also hope that the presented materials will help you better understand and troubleshoot COM APIs. The source code of the Protoss COM example is available at <a href="https://github.com/lowleveldesign/protoss-com-example">https://github.com/lowleveldesign/protoss-com-example</a>.</p>



<p>Until the next time! üëã</p>
			</div></div>
  </body>
</html>
