<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.mitchellhanberg.com/the-comprehensive-guide-to-elixirs-for-comprehension/">Original</a>
    <h1>The Comprehensive Guide to Elixir&#39;s List Comprehension (2022)</h1>
    
    <div id="readability-page-1" class="page"><div><section>
  
  
    <article>
  
    <h2 id="table-of-contents">Table of Contents</h2>

<ul id="markdown-toc">
  <li><a href="#what-is-it" id="markdown-toc-what-is-it">What is it?</a></li>
  <li><a href="#generators" id="markdown-toc-generators">Generators</a>    <ul>
      <li><a href="#multiple-generators" id="markdown-toc-multiple-generators">Multiple Generators</a></li>
      <li><a href="#generators-work-with-maps-too" id="markdown-toc-generators-work-with-maps-too">Generators work with maps too</a></li>
      <li><a href="#bitstring-generators" id="markdown-toc-bitstring-generators">Bitstring generators</a></li>
      <li><a href="#chaining-generators" id="markdown-toc-chaining-generators">Chaining generators</a></li>
      <li><a href="#generators-filter-non-matching-lhs-values" id="markdown-toc-generators-filter-non-matching-lhs-values">Generators filter non-matching lhs values</a></li>
    </ul>
  </li>
  <li><a href="#filters" id="markdown-toc-filters">Filters</a></li>
  <li><a href="#options" id="markdown-toc-options">Options</a>    <ul>
      <li><a href="#uniq" id="markdown-toc-uniq">:uniq</a></li>
      <li><a href="#into" id="markdown-toc-into">:into</a></li>
      <li><a href="#reduce" id="markdown-toc-reduce">:reduce</a></li>
    </ul>
  </li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
  <li><a href="#supplementary-information" id="markdown-toc-supplementary-information">Supplementary Information</a>    <ul>
      <li><a href="#list-comprehensions-in-erlang" id="markdown-toc-list-comprehensions-in-erlang">List Comprehensions in Erlang</a></li>
    </ul>
  </li>
</ul>

<h2 id="what-is-it">What is it?</h2>

<p>The <code>for</code> special form, also known as a list comprehension, is a construct designed for concise and powerful enumerable transformation in Elixir.</p>

<p>It looks very similar to a “for loop” in other languages like JavaScript and C, but rather than being a language construct, it is an expression (like everything else in Elixir). This means that it evaluates to a value that can be bound to a variable. You may have heard this before as “statement vs expression”.</p>

<div><div><pre><code><span>last_names</span> <span>=</span> 
  <span>for</span> <span>friend</span> <span>&lt;-</span> <span>friends</span> <span>do</span>
    <span>friend</span><span>.</span><span>last_name</span>
  <span>end</span>
</code></pre></div></div>

<p>Before reading this rest of this article, I suggest you read the list comprehension guide on <a href="https://elixir-lang.org/getting-started/comprehensions.html">elixir-lang.org</a>. I will go over some of the same details, but hopefully will go much more in depth.</p>

<h2 id="generators">Generators</h2>

<p>The primary ingredient in a comprehension is the generator. The only other place you will see this “left arrow” syntax (<code>lhs &lt;- rhs</code>) is in the <code>with</code> special form.</p>

<p>The right hand side is the enumerable you want to loop over and the left hand side is the intermediate pattern you want to match on during each iteration. This is a normal pattern, so you can pattern match like you would anywhere else.</p>

<div><div><pre><code><span>friends</span> <span>=</span> <span>[</span>
  <span>%{</span><span>first_name:</span> <span>&#34;Joe&#34;</span><span>,</span> <span>last_name:</span> <span>&#34;Swanson&#34;</span><span>},</span>
  <span>%{</span><span>first_name:</span> <span>&#34;Greg&#34;</span><span>,</span> <span>last_name:</span> <span>&#34;Mefford&#34;</span><span>},</span>
  <span>%{</span><span>first_name:</span> <span>&#34;Erik&#34;</span><span>,</span> <span>last_name:</span> <span>&#34;Plostins&#34;</span><span>},</span>
<span>]</span>

<span>for</span> <span>%{</span><span>last_name:</span> <span>last_name</span><span>}</span> <span>&lt;-</span> <span>friends</span> <span>do</span>
  <span>last_name</span>
<span>end</span>

<span># [&#34;Swanson&#34;, &#34;Mefford&#34;, &#34;Plostins&#34;]</span>
</code></pre></div></div>

<h3 id="multiple-generators">Multiple Generators</h3>

<p>Comprehensions are very concise in that you can declare multiple generators, allowing you to generate every permutation of both enumerables. A great example is generating a list of coordinate pairs from a range of <code>x</code> values and <code>y</code> values.</p>

<p>A key detail to recognize is that the both values are yielded to the same block, so the result is a flat list.</p>

<div><div><pre><code><span>for</span> <span>x</span> <span>&lt;-</span> <span>0</span><span>..</span><span>99</span><span>,</span> <span>y</span> <span>&lt;-</span> <span>0</span><span>..</span><span>99</span> <span>do</span>
  <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span>
<span>end</span>

<span># [{0, 0}, {0, 1}, {0, 2}, ...]</span>
</code></pre></div></div>

<p>The counter example using <a href="https://hexdocs.pm/elixir/Enum.html#map/2"><code>Enum.map/2</code></a> is not nearly as readable and demonstrates that you need to remember to flatten the outer loop, or else you’ll get a list of lists.</p>

<div><div><pre><code><span>Enum</span><span>.</span><span>flat_map</span><span>(</span><span>0</span><span>..</span><span>99</span><span>,</span> <span>fn</span> <span>x</span> <span>-&gt;</span>
  <span>Enum</span><span>.</span><span>map</span><span>(</span><span>0</span><span>..</span><span>99</span><span>,</span> <span>fn</span> <span>y</span> <span>-&gt;</span>
    <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span>
  <span>end</span><span>)</span>
<span>end</span><span>)</span>

<span># [{0, 0}, {0, 1}, {0, 2}, ...]</span>
</code></pre></div></div>

<h3 id="generators-work-with-maps-too">Generators work with maps too</h3>

<p>The comprehension works with anything that implements the <code>Enumerable</code> protocol, so you can iterate through a map as well. The generator will yield each key/value pair of the given map.</p>

<div><div><pre><code><span>dictionary</span> <span>=</span> <span>%{</span>
  <span>&#34;low-latency&#34;</span> <span>=&gt;</span> <span>&#34;short delay before a transfer of data begins following an instruction for its transfer&#34;</span><span>,</span>
  <span>&#34;distributed&#34;</span> <span>=&gt;</span> <span>&#34;(of a computer system) spread over several machines, especially over a network&#34;</span><span>,</span>
  <span>&#34;fault-tolerant&#34;</span> <span>=&gt;</span> <span>&#34;relating to or being a computer or program with a self-contained backup system that allows continued operation when major components fail&#34;</span>
<span>}</span>

<span>for</span> <span>{</span><span>word</span><span>,</span> <span>definition</span><span>}</span> <span>&lt;-</span> <span>dictionary</span> <span>do</span>
  <span>IO</span><span>.</span><span>puts</span> <span>&#34;</span><span>#{</span><span>word</span><span>}</span><span>: </span><span>#{</span><span>definition</span><span>}</span><span>&#34;</span>
<span>end</span>
</code></pre></div></div>

<p>As seen above, we can iterate through a <code>Range</code> as well.</p>

<div><div><pre><code><span>for</span> <span>x</span> <span>&lt;-</span> <span>0</span><span>..</span><span>99</span><span>,</span> <span>y</span> <span>&lt;-</span> <span>0</span><span>..</span><span>99</span> <span>do</span>
  <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span>
<span>end</span>

<span># [{0, 0}, {0, 1}, {0, 2}, ...]</span>
</code></pre></div></div>

<h3 id="bitstring-generators">Bitstring generators</h3>

<p>The generators we’ve seen so far have been “list generators”. The other type of generator is the “bitstring generator”. The bitstring generator allows you to easily loop over a bitstring while correctly parsing bytes.</p>

<p>For a primer on bitstrings, please see the fantastic guide on <a href="https://elixir-lang.org/getting-started/binaries-strings-and-char-lists.html#bitstrings">elixir-lang.org</a>.</p>

<p>This is often very useful when parsing binary protocols like database protocols. Below is an example that demonstrates that each iteration of the comprehension reads the message length and then uses it to know how much more of the bitstring to read next. While the previous examples could be translated into various form of <code>Enum.map/2</code>, this example can only be achieved with normal recursion.</p>

<div><div><pre><code><span>bitstring</span> <span>=</span> <span>&lt;&lt;</span><span>1</span><span>,</span> <span>&#34;I&#34;</span><span>,</span> <span>6</span><span>,</span> <span>&#34;really&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;love&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;list&#34;</span><span>,</span> <span>14</span><span>,</span> <span>&#34;comprehensions&#34;</span><span>,</span> <span>1</span><span>,</span> <span>&#34;!&#34;</span><span>&gt;&gt;</span>

<span># &lt;&lt;1, 73, 6, 114, 101, 97, 108, 108, 121, 4, 108, 111, 118, 101, 4, 108, 105,</span>
<span>#  115, 116, 14, 99, 111, 109, 112, 114, 101, 104, 101, 110, 115, 105, 111, 110,</span>
<span>#  115, 1, 33&gt;&gt;</span>

<span>for</span> <span>&lt;&lt;</span><span>message_length</span><span>::</span><span>integer</span><span>,</span> <span>message</span><span>::</span><span>binary</span><span>-</span><span>size</span><span>(</span><span>message_length</span><span>)</span> <span>&lt;-</span> <span>bitstring</span><span>&gt;&gt;</span> <span>do</span>
  <span>message</span>
<span>end</span>

<span># [&#34;I&#34;, &#34;really&#34;, &#34;love&#34;, &#34;list&#34;, &#34;comprehensions&#34;, &#34;!&#34;]</span>
</code></pre></div></div>

<p>The example using recursion looks like:</p>

<div><div><pre><code><span>defmodule</span> <span>For</span> <span>do</span>
  <span>def</span> <span>loop</span><span>(</span><span>&#34;&#34;</span><span>),</span> <span>do</span><span>:</span> <span>[]</span>

  <span>def</span> <span>loop</span><span>(</span><span>&lt;&lt;</span><span>message_length</span><span>::</span><span>integer</span><span>,</span> <span>message</span><span>::</span><span>binary</span><span>-</span><span>size</span><span>(</span><span>message_length</span><span>),</span> <span>rest</span><span>::</span><span>binary</span><span>&gt;&gt;</span><span>)</span> <span>do</span>
    <span>[</span><span>message</span> <span>|</span> <span>loop</span><span>(</span><span>rest</span><span>)]</span>
  <span>end</span>
<span>end</span>

<span>bitstring</span> <span>=</span> <span>&lt;&lt;</span><span>1</span><span>,</span> <span>&#34;I&#34;</span><span>,</span> <span>6</span><span>,</span> <span>&#34;really&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;love&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;list&#34;</span><span>,</span> <span>14</span><span>,</span> <span>&#34;comprehensions&#34;</span><span>,</span> <span>1</span><span>,</span> <span>&#34;!&#34;</span><span>&gt;&gt;</span>

<span>For</span><span>.</span><span>loop</span><span>(</span><span>bitstring</span><span>)</span>

<span># [&#34;I&#34;, &#34;really&#34;, &#34;love&#34;, &#34;list&#34;, &#34;comprehensions&#34;, &#34;!&#34;]</span>
</code></pre></div></div>

<p>To compare the two styles, let’s look at the syntax of the generator in the comprehension example and the second function head of <code>loop</code> in the function example.</p>

<p>In the function example, you’ll see that we pattern match on the bitstring in a similar manner to who you pattern match on a list. We pull several individual items off the beginning of the bitstring (<code>message_length::integer, message::binary-size(message_length)</code>) and we pattern match on the “rest” of the bitstring with <code>rest::binary</code>.</p>

<p>The list equivalent looks like:</p>

<div><div><pre><code><span>defmodule</span> <span>For</span> <span>do</span>
  <span>def</span> <span>loop</span><span>([]),</span> <span>do</span><span>:</span> <span>[]</span>

  <span>def</span> <span>loop</span><span>([</span><span>_length</span><span>,</span> <span>message</span> <span>|</span> <span>rest</span><span>])</span> <span>do</span>
    <span>[</span><span>message</span> <span>|</span> <span>loop</span><span>(</span><span>rest</span><span>)]</span>
  <span>end</span>
<span>end</span>

<span>list</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>&#34;I&#34;</span><span>,</span> <span>6</span><span>,</span> <span>&#34;really&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;love&#34;</span><span>,</span> <span>4</span><span>,</span> <span>&#34;list&#34;</span><span>,</span> <span>14</span><span>,</span> <span>&#34;comprehensions&#34;</span><span>,</span> <span>1</span><span>,</span> <span>&#34;!&#34;</span><span>]</span>

<span>For</span><span>.</span><span>loop</span><span>(</span><span>list</span><span>)</span>

<span># [&#34;I&#34;, &#34;really&#34;, &#34;love&#34;, &#34;list&#34;, &#34;comprehensions&#34;, &#34;!&#34;]</span>
</code></pre></div></div>

<p>Now if we compare this to the bitstring generator, we can see the similarity (<em><strong>with a caveat</strong></em>). The <code>lhs</code> of the bitstring generator is the pattern match on the individual items and the <code>rhs</code> is pattern matching on the “rest”. The caveat is that <code>bitstring</code> here is not actually the “rest” on each iteration, it is still the entire bitstring. I find this the best analogy to describe how the bitstring generator works since it is different enough from the “normal” list generator.</p>

<div><div><pre><code><span>#   👇 individual item         👇 individual item                      👇rest</span>
<span>for</span> <span>&lt;&lt;</span><span>message_length</span><span>::</span><span>integer</span><span>,</span> <span>message</span><span>::</span><span>binary</span><span>-</span><span>size</span><span>(</span><span>message_length</span><span>)</span> <span>&lt;-</span> <span>bitstring</span><span>&gt;&gt;</span> <span>do</span>
  <span># 👇 this will print the same thing every time</span>
  <span>IO</span><span>.</span><span>inspect</span><span>(</span><span>bitstring</span><span>)</span>

  <span>message</span>
<span>end</span>
</code></pre></div></div>

<h3 id="chaining-generators">Chaining generators</h3>

<p>List comprehensions allow you to chain generators together by using the <code>lhs</code> value from a generator in the <code>rhs</code> of a subsequent generator.</p>

<p>Here’s an example that demonstrates getting a list of all of your friends hobbies:</p>

<div><div><pre><code><span>friends</span> <span>=</span> <span>[</span>
  <span>%{</span><span>name:</span> <span>&#34;Derek&#34;</span><span>,</span> <span>hobbies:</span> <span>[</span><span>&#34;Movies&#34;</span><span>,</span> <span>&#34;Hot Sauce&#34;</span><span>]},</span>
  <span>%{</span><span>name:</span> <span>&#34;Joe&#34;</span><span>,</span> <span>hobbies:</span> <span>[</span><span>&#34;Yu-Gi-Oh!&#34;</span><span>,</span> <span>&#34;Tattoos&#34;</span><span>]},</span>
  <span>%{</span><span>name:</span> <span>&#34;Andres&#34;</span><span>,</span> <span>hobbies:</span> <span>[</span><span>&#34;Photoshop&#34;</span><span>,</span> <span>&#34;Oreos&#34;</span><span>,</span> <span>&#34;Cereal&#34;</span><span>]},</span>
<span>]</span>

<span>for</span> <span>%{</span><span>hobbies:</span> <span>hobbies</span><span>}</span> <span>&lt;-</span> <span>friends</span><span>,</span> <span>hobby</span> <span>&lt;-</span> <span>hobbies</span> <span>do</span>
  <span>hobby</span>
<span>end</span>

<span># [&#34;Movies&#34;, &#34;Hot Sauce&#34;, &#34;Yu-Gi-Oh!&#34;, &#34;Tattoos&#34;, &#34;Photoshop&#34;, &#34;Oreos&#34;, &#34;Cereal&#34;]</span>
</code></pre></div></div>

<h3 id="generators-filter-non-matching-lhs-values">Generators filter non-matching lhs values</h3>

<p>If the match expression in the <code>lhs</code> of a generator does not match on the value yielded from the <code>rhs</code>, it will be rejected, and the list comprehension will move on to the next element in the enumerable.</p>

<p>This is slightly surprising behavior at first and should be kept in mind when using list comprehensions. The following example might lead to a bug in your program.</p>

<div><div><pre><code><span>friends</span> <span>=</span> <span>[</span>
    <span>%{</span><span>&#34;name&#34;</span> <span>=&gt;</span> <span>&#34;Derek&#34;</span><span>},</span>
    <span>%{</span><span>name:</span> <span>&#34;Joe&#34;</span><span>}</span>
  <span>]</span>

<span>for</span> <span>%{</span><span>name:</span> <span>name</span><span>}</span> <span>&lt;-</span> <span>friends</span> <span>do</span>
  <span>name</span>
<span>end</span>

<span># [&#34;Joe&#34;]</span>
</code></pre></div></div>

<p>If you were to have written this program using <code>Enum.map/2</code>, you would have ran into a function clause error.</p>

<div><div><pre><code><span>friends</span> <span>=</span> <span>[</span>
    <span>%{</span><span>&#34;name&#34;</span> <span>=&gt;</span> <span>&#34;Derek&#34;</span><span>},</span>
    <span>%{</span><span>name:</span> <span>&#34;Joe&#34;</span><span>}</span>
  <span>]</span>

<span>Enum</span><span>.</span><span>map</span><span>(</span><span>friends</span><span>,</span> <span>fn</span> <span>%{</span><span>name:</span> <span>name</span><span>}</span> <span>-&gt;</span>
  <span>name</span>
<span>end</span><span>)</span>

<span># ** (FunctionClauseError) no function clause matching in :erl_eval.&#34;-inside-an-interpreted-fun-&#34;/1</span>
<span># </span>
<span>#    The following arguments were given to :erl_eval.&#34;-inside-an-interpreted-fun-&#34;/1:</span>
<span># </span>
<span>#        # 1</span>
<span>#        %{&#34;name&#34; =&gt; &#34;Derek&#34;}</span>
<span># </span>
<span>#    (stdlib 3.17.1) :erl_eval.&#34;-inside-an-interpreted-fun-&#34;/1</span>
<span>#    (stdlib 3.17.1) erl_eval.erl:834: :erl_eval.eval_fun/6</span>
<span>#    (elixir 1.13.3) lib/enum.ex:1593: Enum.&#34;-map/2-lists^map/1-0-&#34;/2</span>
</code></pre></div></div>

<p>This behaviour can be useful! If you only wanted to iterate over configuration options that are enabled, you could write something like this:</p>

<div><div><pre><code><span>configs</span> <span>=</span> <span>[</span>
  <span>%{</span><span>name:</span> <span>:feature_a</span><span>,</span> <span>enabled:</span> <span>true</span><span>},</span>
  <span>%{</span><span>name:</span> <span>:feature_b</span><span>,</span> <span>enabled:</span> <span>false</span><span>},</span>
  <span>%{</span><span>name:</span> <span>:feature_c</span><span>,</span> <span>enabled:</span> <span>true</span><span>}</span>
<span>]</span>

<span>for</span> <span>%{</span><span>enabled:</span> <span>true</span><span>}</span> <span>=</span> <span>config</span> <span>&lt;-</span> <span>configs</span> <span>do</span>
  <span>config</span>
<span>end</span>

<span># [%{name: :feature_a, enabled: true}, %{name: :feature_c, enabled: true}]</span>
</code></pre></div></div>

<h2 id="filters">Filters</h2>

<p>Now that we’ve talked about <em>generator filtering</em>, let’s talk about <em>Filters</em>.</p>

<p>So far we have seen one type of “argument” that can be passed to the comprehension, the generator. Another “argument” is the filter! Let’s look at a quick example.</p>

<p>In this example, we iterate over a list of employees, filter based on the employees status, and return a list of the employee’s names</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span><span>name:</span> <span>&#34;Eric&#34;</span><span>,</span> <span>status:</span> <span>:active</span><span>},</span>
  <span>%{</span><span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span> <span>status:</span> <span>:former</span><span>},</span>
  <span>%{</span><span>name:</span> <span>&#34;Greg&#34;</span><span>,</span> <span>status:</span> <span>:active</span><span>}</span>
<span>]</span>

<span>for</span> <span>employee</span> <span>&lt;-</span> <span>employees</span><span>,</span> <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span> <span>do</span>
  <span>employee</span><span>.</span><span>name</span>
<span>end</span>

<span># [&#34;Eric&#34;, &#34;Greg&#34;]</span>
</code></pre></div></div>

<p>As with generators, filters can use values bound in a previous step of the comprehension. And like generators, you can use multiple filters as well. You can even mix and match them!</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Eric&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Text Adventures&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Chickens&#34;</span><span>,</span> <span>type:</span> <span>:animals</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span>
    <span>status:</span> <span>:former</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Homebrewing&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Greg&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[</span>
      <span>%{</span><span>name:</span> <span>&#34;Dungeons &amp; Dragons&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span>
      <span>%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}</span>
    <span>]</span>
  <span>}</span>
<span>]</span>

<span>for</span> <span>employee</span> <span>&lt;-</span> <span>employees</span><span>,</span>
    <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span><span>,</span>
    <span>hobby</span> <span>&lt;-</span> <span>employee</span><span>.</span><span>hobbies</span><span>,</span>
    <span>hobby</span><span>.</span><span>type</span> <span>==</span> <span>:gaming</span> <span>do</span>
  <span>{</span><span>employee</span><span>.</span><span>name</span><span>,</span> <span>hobby</span><span>}</span>
<span>end</span>

<span># [</span>
<span>#   {&#34;Eric&#34;, %{name: &#34;Text Adventures&#34;, type: :gaming}},</span>
<span>#   {&#34;Greg&#34;, %{name: &#34;Dungeons &amp; Dragons&#34;, type: :gaming}}</span>
<span># ]</span>

</code></pre></div></div>

<p>At this point we can recognize that the list comprehension has the characteristics of a function with <a href="https://en.wikipedia.org/wiki/Variadic_function">variadic arguments</a>. If we were to write our own <code>for</code> using plain functions, we’d have to pass it a list of callbacks to evaluate and a final callback to do the mapping. While we aren’t necessarily concerned with how we’d implement <code>for</code> as a plain function, it’s important to recognize aspects that are “different” from “normal” constructs in the language.</p>

<p>One of the great things about the list comprehension is that it allows you to operate on <code>Enumerable</code> data structures in fewer passes (usually 1) than when using the <code>Enum</code> module.</p>

<p>We can write our previous example using functions like so:</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span><span>name:</span> <span>&#34;Eric&#34;</span><span>,</span> <span>status:</span> <span>:active</span><span>},</span>
  <span>%{</span><span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span> <span>status:</span> <span>:former</span><span>},</span>
  <span>%{</span><span>name:</span> <span>&#34;Greg&#34;</span><span>,</span> <span>status:</span> <span>:active</span><span>}</span>
<span>]</span>

<span>employees</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span> <span>employee</span> <span>-&gt;</span> <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span> <span>end</span><span>)</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>fn</span> <span>employee</span> <span>-&gt;</span> <span>employee</span><span>.</span><span>name</span> <span>end</span><span>)</span>

<span># [&#34;Eric&#34;, &#34;Greg&#34;]</span>

<span>employees</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>reduce</span><span>([],</span> <span>fn</span> <span>employee</span><span>,</span> <span>acc</span> <span>-&gt;</span> 
  <span>if</span> <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span> <span>do</span>
    <span>[</span><span>employee</span><span>.</span><span>name</span> <span>|</span> <span>acc</span><span>]</span>
  <span>else</span>
    <span>acc</span>
  <span>end</span>
<span>end</span><span>)</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>reverse</span><span>()</span>

<span># [&#34;Eric&#34;, &#34;Greg&#34;]</span>

<span>:lists</span><span>.</span><span>filtermap</span><span>(</span>
  <span>fn</span> <span>employee</span> <span>-&gt;</span>
    <span>if</span> <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span> <span>do</span>
      <span>{</span><span>true</span><span>,</span> <span>employee</span><span>.</span><span>name</span><span>}</span>
    <span>else</span>
      <span>false</span>
    <span>end</span>
  <span>end</span><span>,</span>
  <span>employees</span>
<span>)</span>

<span># [&#34;Eric&#34;, &#34;Greg&#34;]</span>
</code></pre></div></div>

<p>You can see benchmarks of all of these styles of “filter map” <a href="https://github.com/mhanberg/notebooks/blob/c0c0c710fd5ca7a6f36d5acdca9043911d49044d/notebooks/list_benchmarks.livemd">here</a>.</p>

<h2 id="options">Options</h2>

<p>Now that we’ve covered the basic principles of the list comprehension, we can explore the various options that can be passed to augment it’s behavior. The default behavior is to act more or less like <code>Enum.map/2</code> with regard to the return type.</p>

<p>As of this writing, there are three options available: <code>:uniq</code>, <code>:into</code>, and <code>:reduce</code></p>

<h3 id="uniq">:uniq</h3>

<p><code>:uniq</code> is the least interesting of the available options, but still quite powerful.</p>

<p>It simply ensures that the return result will only contain unique values.</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Eric&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Text Adventures&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Chickens&#34;</span><span>,</span> <span>type:</span> <span>:animals</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span>
    <span>status:</span> <span>:former</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Homebrewing&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Greg&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[</span>
      <span>%{</span><span>name:</span> <span>&#34;Dungeons &amp; Dragons&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span>
      <span>%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}</span>
    <span>]</span>
  <span>}</span>
<span>]</span>

<span>for</span> <span>employee</span> <span>&lt;-</span> <span>employees</span><span>,</span> <span>hobby</span> <span>&lt;-</span> <span>employee</span><span>.</span><span>hobbies</span><span>,</span> <span>uniq:</span> <span>true</span> <span>do</span>
  <span>hobby</span><span>.</span><span>name</span>
<span>end</span>

<span># [&#34;Text Adventures&#34;, &#34;Chickens&#34;, &#34;Woodworking&#34;, &#34;Homebrewing&#34;, &#34;Dungeons &amp; Dragons&#34;]</span>
</code></pre></div></div>

<p>You can see benchmarks of all of these styles of “map uniq” <a href="https://github.com/mhanberg/notebooks/blob/ae5362fded45465e22e74b9d310715e7852502d8/notebooks/list_benchmarks.livemd#results-mapuniq">here</a>.</p>

<h3 id="into">:into</h3>

<p><code>:into</code> is where things start to get interesting.</p>

<p>The default behavior for a list comprehension behaves more or less like a “map” operation, meaning that the expression evaluates to a list.</p>

<p>The <code>:into</code> option allows you to instead push the value returned by each iteration into a <em>collectable</em>. A data structure is collectable if it implements the <a href="https://hexdocs.pm/elixir/Collectable.html">Collectable</a> protocol.</p>

<p>If you aren’t familiar with protocols, you have already been using them! The <code>Enum</code> module is a set of functions that operate on data structures that implement the <a href="https://hexdocs.pm/elixir/Enumerable.html">Enumerable</a> protocol. The builtin data structures that implement the <code>Enumerable</code> protocol are the <code>List</code>, <code>Range</code>, <code>Map</code>, and <code>MapSet</code> types.</p>

<p>The builtin data structures that implement the <code>Collectable</code> protocol are <code>List</code>, <code>Map</code>, <code>MapSet</code>, and <code>BitString</code>. The <code>Enum</code> function that you would use to take advantage of this protocol is <a href="https://hexdocs.pm/elixir/Enum.html#into/3">Enum.into/2</a>.</p>

<p>Let’s take a look at some examples.</p>

<h4 id="list">List</h4>

<p>Using a list as the <code>:into</code> actually doesn’t change the behavior at all!</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Eric&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Text Adventures&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Chickens&#34;</span><span>,</span> <span>type:</span> <span>:animals</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span>
    <span>status:</span> <span>:former</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Homebrewing&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Greg&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[</span>
      <span>%{</span><span>name:</span> <span>&#34;Dungeons &amp; Dragons&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span>
      <span>%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}</span>
    <span>]</span>
  <span>}</span>
<span>]</span>

<span>for</span> <span>employee</span> <span>&lt;-</span> <span>employees</span><span>,</span>
    <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span><span>,</span>
    <span>hobby</span> <span>&lt;-</span> <span>employee</span><span>.</span><span>hobbies</span><span>,</span>
    <span>hobby</span><span>.</span><span>type</span> <span>==</span> <span>:gaming</span><span>,</span>
    <span>into:</span> <span>[]</span> <span>do</span>
  <span>{</span><span>employee</span><span>.</span><span>name</span><span>,</span> <span>hobby</span><span>}</span>
<span>end</span>

<span># [</span>
<span>#   {&#34;Eric&#34;, %{name: &#34;Text Adventures&#34;, type: :gaming}},</span>
<span>#   {&#34;Greg&#34;, %{name: &#34;Dungeons &amp; Dragons&#34;, type: :gaming}}</span>
<span># ]</span>
</code></pre></div></div>

<h4 id="map">Map</h4>

<p>But if we use a map, we can see that it pushes each key/value pair into the map that you pass for the option. Usually I use this with an empty map (<code>%{}</code> or <code>Map.new()</code>), but let’s look at an example using a non-empty map.</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Eric&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Text Adventures&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Chickens&#34;</span><span>,</span> <span>type:</span> <span>:animals</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span>
    <span>status:</span> <span>:former</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Homebrewing&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Greg&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[</span>
      <span>%{</span><span>name:</span> <span>&#34;Dungeons &amp; Dragons&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span>
      <span>%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}</span>
    <span>]</span>
  <span>}</span>
<span>]</span>

<span>base_map</span> <span>=</span> <span>%{</span>
  <span>&#34;Mitch&#34;</span> <span>=&gt;</span> <span>%{</span>
    <span>name:</span> <span>&#34;Reading&#34;</span><span>,</span>
    <span>type:</span> <span>:learning</span>
  <span>},</span>
  <span>&#34;Greg&#34;</span> <span>=&gt;</span> <span>%{</span>
    <span>name:</span> <span>&#34;Traveling&#34;</span><span>,</span>
    <span>type:</span> <span>:expensive</span>
  <span>}</span>
<span>}</span>

<span>for</span> <span>employee</span> <span>&lt;-</span> <span>employees</span><span>,</span>
    <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span><span>,</span>
    <span>hobby</span> <span>&lt;-</span> <span>employee</span><span>.</span><span>hobbies</span><span>,</span>
    <span>hobby</span><span>.</span><span>type</span> <span>==</span> <span>:gaming</span><span>,</span>
    <span>into:</span> <span>base_map</span> <span>do</span>
  <span>{</span><span>employee</span><span>.</span><span>name</span><span>,</span> <span>hobby</span><span>}</span>
<span>end</span>

<span># %{</span>
<span>#   &#34;Eric&#34; =&gt; %{name: &#34;Text Adventures&#34;, type: :gaming},</span>
<span>#   &#34;Greg&#34; =&gt; %{name: &#34;Dungeons &amp; Dragons&#34;, type: :gaming},</span>
<span>#   &#34;Mitch&#34; =&gt; %{name: &#34;Reading&#34;, type: :learning}</span>
<span># }</span>
</code></pre></div></div>

<p>Here we can observe three things.</p>

<ul>
  <li>The comprehension evaluates to a map.</li>
  <li>The <code>&#34;Mitch&#34;</code> key and its value were preserved in the final output.</li>
  <li>The <code>&#34;Greg&#34;</code> key’s value in the <code>base_map</code> was overwritten by the value yielded during the comprehension with the same key. If our comprehension were to have returned multiple key/value pairs with identical keys, the last one would have won.</li>
</ul>

<p>This option is very useful for transforming maps. Since iterating over a map with an <code>Enum</code> function turns it into a list of 2-tuples, you always need to pipe the return value into <code>Enum.into/2</code> or <code>Map.new/1</code>.</p>

<div><div><pre><code><span>employees</span> <span>=</span> <span>[</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Eric&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Text Adventures&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Chickens&#34;</span><span>,</span> <span>type:</span> <span>:animals</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Mitch&#34;</span><span>,</span>
    <span>status:</span> <span>:former</span><span>,</span>
    <span>hobbies:</span> <span>[%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>},</span> <span>%{</span><span>name:</span> <span>&#34;Homebrewing&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}]</span>
  <span>},</span>
  <span>%{</span>
    <span>name:</span> <span>&#34;Greg&#34;</span><span>,</span>
    <span>status:</span> <span>:active</span><span>,</span>
    <span>hobbies:</span> <span>[</span>
      <span>%{</span><span>name:</span> <span>&#34;Dungeons &amp; Dragons&#34;</span><span>,</span> <span>type:</span> <span>:gaming</span><span>},</span>
      <span>%{</span><span>name:</span> <span>&#34;Woodworking&#34;</span><span>,</span> <span>type:</span> <span>:making</span><span>}</span>
    <span>]</span>
  <span>}</span>
<span>]</span>

<span>base_map</span> <span>=</span> <span>%{</span>
  <span>&#34;Mitch&#34;</span> <span>=&gt;</span> <span>%{</span>
    <span>name:</span> <span>&#34;Reading&#34;</span><span>,</span>
    <span>type:</span> <span>:learning</span>
  <span>},</span>
  <span>&#34;Greg&#34;</span> <span>=&gt;</span> <span>%{</span>
    <span>name:</span> <span>&#34;Traveling&#34;</span><span>,</span>
    <span>type:</span> <span>:expensive</span>
  <span>}</span>
<span>}</span>

<span>employees</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span> <span>employee</span> <span>-&gt;</span> <span>employee</span><span>.</span><span>status</span> <span>==</span> <span>:active</span> <span>end</span><span>)</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>flat_map</span><span>(</span><span>fn</span> <span>employee</span> <span>-&gt;</span>
  <span>employee</span><span>.</span><span>hobbies</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>filter</span><span>(</span><span>fn</span> <span>hobby</span> <span>-&gt;</span> <span>hobby</span><span>.</span><span>type</span> <span>==</span> <span>:gaming</span> <span>end</span><span>)</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>fn</span> <span>hobby</span> <span>-&gt;</span>
    <span>{</span><span>employee</span><span>.</span><span>name</span><span>,</span> <span>hobby</span><span>}</span>
  <span>end</span><span>)</span>
<span>end</span><span>)</span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>into</span><span>(</span><span>base_map</span><span>)</span>

<span># %{</span>
<span>#   &#34;Eric&#34; =&gt; %{name: &#34;Text Adventures&#34;, type: :gaming},</span>
<span>#   &#34;Greg&#34; =&gt; %{name: &#34;Dungeons &amp; Dragons&#34;, type: :gaming},</span>
<span>#   &#34;Mitch&#34; =&gt; %{name: &#34;Reading&#34;, type: :learning}</span>
<span># }</span>
</code></pre></div></div>

<h4 id="strings-and-bitstrings">Strings and BitStrings</h4>

<p>You can build strings and bitstrings with the <code>:into</code> option as well!</p>

<p>This is useful when you want to build a string or a binary out of a list or map all in one pass. Let’s take a look at an example of creating an “attribute string” for use with HTML.</p>

<div><div><pre><code><span>attributes</span> <span>=</span> <span>[</span>
  <span>class:</span> <span>&#34;font-bold text-red-500 underline&#34;</span><span>,</span>
  <span>id:</span> <span>&#34;error-text&#34;</span><span>,</span>
  <span>data_controller:</span> <span>&#34;error-controller&#34;</span>
<span>]</span>

<span>for</span> <span>{</span><span>property</span><span>,</span> <span>value</span><span>}</span> <span>&lt;-</span> <span>attributes</span><span>,</span> <span>into:</span> <span>&#34;&#34;</span> <span>do</span>
  <span>property</span> <span>=</span>
    <span>property</span>
    <span>|&gt;</span> <span>to_string</span><span>()</span>
    <span>|&gt;</span> <span>String</span><span>.</span><span>replace</span><span>(</span><span>&#34;_&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>)</span>

  <span>~s| #{property}=&#34;#{value}&#34;|</span>
<span>end</span>

<span># &#34; class=\&#34;font-bold text-red-500 underline\&#34; id=\&#34;error-text\&#34; data-controller=\&#34;error-controller\&#34;&#34;</span>
</code></pre></div></div>

<h3 id="reduce">:reduce</h3>

<p>My favorite option to the comprehension is <code>:reduce</code>!</p>

<p>Reduce allows us to change the comprehension from behaving like a “map” operation to a “reduce” operation. This means that it will loop over an enumerable, but collect an “accumulator” instead.</p>

<p>Let’s take a look at the first example in the <code>Enum.reduce/3</code> documentation and then convert it to a comprehension. This example produces the sum of a list of integers.</p>

<div><div><pre><code><span>Enum</span><span>.</span><span>reduce</span><span>([</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>],</span> <span>0</span><span>,</span> <span>fn</span> <span>x</span><span>,</span> <span>acc</span> <span>-&gt;</span>
  <span>x</span> <span>+</span> <span>acc</span>
<span>end</span><span>)</span>

<span># 6</span>
</code></pre></div></div>

<p>We can express this as a comprehension like so:</p>

<div><div><pre><code><span>for</span> <span>x</span> <span>&lt;-</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>],</span> <span>reduce:</span> <span>0</span> <span>do</span>
  <span>acc</span> <span>-&gt;</span>
    <span>x</span> <span>+</span> <span>acc</span>
<span>end</span>

<span># 6</span>
</code></pre></div></div>

<p>There are two immediate things we can observe.</p>

<p>First, the <code>:reduce</code> option takes a value that is to be used as the first value of the accumulator.</p>

<p>Second, the comprehension in this mode includes a slightly different syntax. Here the inside of the block includes the “arg(s) and right arrow” syntax that you see in anonymous functions and case expressions. This is the syntax that allows the comprehensions to yield the accumulator to the block on every iteration.</p>

<p>The additional syntax is the same as the other places you have probably seen it; you can pattern match and pass additional clauses!</p>

<div><div><pre><code><span>directions</span> <span>=</span> <span>[</span>
  <span>left:</span> <span>2</span><span>,</span>
  <span>up:</span> <span>1</span><span>,</span>
  <span>down:</span> <span>5</span><span>,</span>
  <span>right:</span> <span>6</span>
<span>]</span>

<span># You can&#39;t move below or to the left of 0.</span>
<span>starting_position</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>0</span><span>}</span>

<span>for</span> <span>{</span><span>dir</span><span>,</span> <span>movement</span><span>}</span> <span>&lt;-</span> <span>directions</span><span>,</span> <span>reduce:</span> <span>starting_position</span>  <span>do</span>
  <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span> <span>when</span> <span>dir</span> <span>==</span> <span>:left</span> <span>and</span> <span>x</span> <span>-</span> <span>movement</span> <span>&gt;</span> <span>0</span> <span>-&gt;</span>
    <span>{</span><span>x</span> <span>-</span> <span>movement</span><span>,</span> <span>y</span><span>}</span>

  <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span> <span>when</span> <span>dir</span> <span>==</span> <span>:down</span> <span>and</span> <span>y</span> <span>-</span> <span>movement</span> <span>&gt;</span> <span>0</span> <span>-&gt;</span>
    <span>{</span><span>x</span><span>,</span> <span>y</span> <span>-</span> <span>movement</span><span>}</span>

  <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span> <span>when</span> <span>dir</span> <span>==</span> <span>:up</span> <span>-&gt;</span>
    <span>{</span><span>x</span><span>,</span> <span>y</span> <span>+</span> <span>movement</span><span>}</span>

  <span>{</span><span>x</span><span>,</span> <span>y</span><span>}</span> <span>when</span> <span>dir</span> <span>==</span> <span>:right</span> <span>-&gt;</span>
    <span>{</span><span>x</span> <span>+</span> <span>movement</span><span>,</span> <span>y</span><span>}</span>

  <span>position</span> <span>-&gt;</span>
    <span>IO</span><span>.</span><span>puts</span><span>(</span><span>&#34;Not possible to move </span><span>#{</span><span>dir</span><span>}</span><span> by </span><span>#{</span><span>movement</span><span>}</span><span> when you care located at </span><span>#{</span><span>inspect</span><span>(</span><span>position</span><span>)</span><span>}</span><span>&#34;</span><span>)</span>

    <span>position</span>
<span>end</span>

<span># {6, 1}</span>
</code></pre></div></div>

<p>Above we can observe that we’ve written 5 different clauses, pattern matched on the shape of the data, as well as added guard clauses that capture the data in the generator and the accumulator.</p>

<p>The beauty of using a comprehension as a reducer is the ability to use multiple generators and act on them as if they are one level of iteration.</p>

<div><div><pre><code><span>friends</span> <span>=</span> <span>[</span>
  <span>%{</span><span>name:</span> <span>&#34;Derek&#34;</span><span>,</span> <span>hobbies:</span> <span>[</span><span>&#34;Movies&#34;</span><span>,</span> <span>&#34;Hot Sauce&#34;</span><span>]},</span>
  <span>%{</span><span>name:</span> <span>&#34;Joe&#34;</span><span>,</span> <span>hobbies:</span> <span>[</span><span>&#34;Yu-Gi-Oh!&#34;</span><span>,</span> <span>&#34;Tattoos&#34;</span><span>]},</span>
  <span>%{</span><span>name:</span> <span>&#34;Andres&#34;</span><span>,</span> <span>hobbies:</span> <span>[</span><span>&#34;Photoshop&#34;</span><span>,</span> <span>&#34;Oreos&#34;</span><span>,</span> <span>&#34;Cereal&#34;</span><span>]},</span>
<span>]</span>

<span>for</span> <span>%{</span><span>hobbies:</span> <span>hobbies</span><span>,</span> <span>name:</span> <span>name</span><span>}</span> <span>&lt;-</span> <span>friends</span><span>,</span> <span>hobby</span> <span>&lt;-</span> <span>hobbies</span><span>,</span> <span>reduce:</span> <span>[]</span> <span>do</span>
  <span>tagged_hobbies</span> <span>-&gt;</span>
    <span>[{</span><span>name</span><span>,</span> <span>hobby</span><span>}</span> <span>|</span> <span>tagged_hobbies</span><span>]</span>
<span>end</span>

<span># [</span>
<span>#   {&#34;Andres&#34;, &#34;Cereal&#34;},</span>
<span>#   {&#34;Andres&#34;, &#34;Oreos&#34;},</span>
<span>#   {&#34;Andres&#34;, &#34;Photoshop&#34;},</span>
<span>#   {&#34;Joe&#34;, &#34;Tattoos&#34;},</span>
<span>#   {&#34;Joe&#34;, &#34;Yu-Gi-Oh!&#34;},</span>
<span>#   {&#34;Derek&#34;, &#34;Hot Sauce&#34;},</span>
<span>#   {&#34;Derek&#34;, &#34;Movies&#34;}</span>
<span># ]</span>
</code></pre></div></div>

<p>To write this without a comprehension it would look something like:</p>

<div><div><pre><code><span>Enum</span><span>.</span><span>reduce</span><span>(</span><span>friends</span><span>,</span> <span>[],</span> <span>fn</span> <span>%{</span><span>name:</span> <span>name</span><span>,</span> <span>hobbies:</span> <span>hobbies</span><span>},</span> <span>tagged_hobbies</span> <span>-&gt;</span>
  <span>new_hobbies</span> <span>=</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>hobbies</span><span>,</span> <span>fn</span> <span>hobby</span> <span>-&gt;</span> <span>{</span><span>name</span><span>,</span> <span>hobby</span><span>}</span> <span>end</span><span>)</span>

  <span>new_hobbies</span> <span>++</span> <span>tagged_hobbies</span>
<span>end</span><span>)</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>If you’ve made it this far, congrats! The comprehension packs a lot of features into a tiny programming construct and demonstrating all of them is a lot of work!</p>

<p>The comprehension is one of my favorite features of the Elixir programming language, and it was a pleasure to write about every feature in as much depth as I could.</p>

<p>If you have any questions about comprehensions or want to suggest examples or features that I’ve missed, feel free to reach out on <a href="https://twitter.com/mitchhanberg">Twitter</a> or <a href="mailto:contact@mitchellhanberg.com">email</a>.</p>

<h2 id="supplementary-information">Supplementary Information</h2>

<h3 id="list-comprehensions-in-erlang">List Comprehensions in Erlang</h3>

<p>It would be remiss to not mention that the list comprehension also exists in Erlang. I am not personally familiar with them, so I won’t explain them very much, but I I’ll provide an example and a link to learn more about them on your own.</p>

<p>The following examples are from the official Erlang/OTP documentation and can be found <a href="https://erlang.org/doc/programming_examples/list_comprehensions.html">here</a>.</p>

<div><div><pre><code><span>[</span><span>X</span> <span>||</span> <span>X</span> <span>&lt;-</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>a</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>b</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>],</span> <span>is_integer</span><span>(</span><span>X</span><span>),</span> <span>X</span> <span>&gt;</span> <span>3</span><span>].</span>

<span>% [4, 5, 6]
</span>
<span>[{</span><span>X</span><span>,</span> <span>Y</span><span>}</span> <span>||</span> <span>X</span> <span>&lt;-</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>],</span>  <span>Y</span> <span>&lt;-</span> <span>[</span><span>a</span><span>,</span> <span>b</span><span>]].</span>

<span>% [{1, a}, {1, b}, {2, a}, {2, b}, {3, a}, {3, b}]
</span></code></pre></div></div>


    </article>
    <div>
      <hr/>

      
      <p>
        Thank you to Seth Brown, Eric Oestrich, and Kevin Rankin for their help reviewing this article.
      </p>
      

      <div>
        <p>If you want to stay current with what I&#39;m working on and articles I write, join my mailing list!</p>

        <p>I seldom send emails, and I will <strong>never</strong> share your email address with anyone else.</p>

        
  


      </div>
    </div>
</section>


</div></div>
  </body>
</html>
