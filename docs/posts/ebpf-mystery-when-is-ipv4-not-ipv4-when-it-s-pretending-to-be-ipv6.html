<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.gripdev.xyz/2025/05/06/ebpf-mystery-when-is-ipv4-not-ipv4-when-its-ipv6/">Original</a>
    <h1>eBPF Mystery: When is IPv4 not IPv4? When it&#39;s pretending to be IPv6</h1>
    
    <div id="readability-page-1" class="page"><div>
    <main aria-label="Content">
        <article>
            
            
            <div>
                <p>This adventures starts with a simple eBPF program to transparently redirect DNS requests on port 53 for a single program (or docker container).</p>
<p>To do this I used <a href="https://docs.ebpf.io/linux/program-type/BPF_PROG_TYPE_CGROUP_SOCK_ADDR/#bpf_cgroup_inet4_connect-and-bpf_cgroup_inet6_connect"><code>BPF_CGROUP_INET4_CONNECT</code></a> on a <code>cgroup</code>. That lets me inspect and redirect traffic when <a href="https://www.man7.org/linux/man-pages/man2/connect.2.html"><code>syscall.connect</code></a> occurs from within the <code>cgroup</code>. Here is a simplified version üëá</p>

<div><pre tabindex="0"><code data-lang="c"><span><span><span>int</span> <span>handle_connect_redirect</span><span>(</span><span>struct</span> <span>bpf_sock_addr</span> <span>*</span><span>ctx</span><span>,</span> <span>__be32</span> <span>original_ip</span><span>,</span>
</span></span><span><span>                            <span>bool</span> <span>is_connect4</span><span>,</span> <span>struct</span> <span>redirect_result</span> <span>*</span><span>result</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>__be32</span> <span>new_ip</span> <span>=</span> <span>original_ip</span><span>;</span>
</span></span><span><span>  <span>__be16</span> <span>new_port</span> <span>=</span> <span>ctx</span><span>-&gt;</span><span>user_port</span><span>;</span>
</span></span><span><span>
</span></span><span><span>  <span>if</span> <span>(</span><span>ctx</span><span>-&gt;</span><span>user_port</span> <span>==</span> <span>bpf_htons</span><span>(</span><span>53</span><span>))</span> <span>{</span>
</span></span><span><span>    <span>new_ip</span> <span>=</span> <span>const_mitm_proxy_address</span><span>;</span> <span>// Our MITM DNS server we&#39;re using for intercept
</span></span></span><span><span><span></span>    <span>new_port</span> <span>=</span> <span>bpf_htons</span><span>(</span><span>const_dns_proxy_port</span><span>);</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>result</span><span>-&gt;</span><span>is_redirected</span> <span>=</span> <span>did_redirect</span><span>;</span>
</span></span><span><span>  <span>result</span><span>-&gt;</span><span>ip</span> <span>=</span> <span>new_ip</span><span>;</span>
</span></span><span><span>  <span>result</span><span>-&gt;</span><span>port</span> <span>=</span> <span>new_port</span><span>;</span>
</span></span><span><span>  <span>return</span> <span>1</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>SEC</span><span>(</span><span>&#34;cgroup/connect4&#34;</span><span>)</span>
</span></span><span><span><span>int</span> <span>connect4</span><span>(</span><span>struct</span> <span>bpf_sock_addr</span> <span>*</span><span>ctx</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>struct</span> <span>redirect_result</span> <span>r</span> <span>=</span> <span>{</span>
</span></span><span><span>      <span>.</span><span>ip</span> <span>=</span> <span>ctx</span><span>-&gt;</span><span>user_ip4</span><span>,</span>
</span></span><span><span>      <span>.</span><span>port</span> <span>=</span> <span>ctx</span><span>-&gt;</span><span>user_port</span><span>,</span>
</span></span><span><span>      <span>.</span><span>is_redirected</span> <span>=</span> <span>false</span><span>,</span>
</span></span><span><span>  <span>};</span>
</span></span><span><span>  <span>handle_connect_redirect</span><span>(</span><span>ctx</span><span>,</span> <span>ctx</span><span>-&gt;</span><span>user_ip4</span><span>,</span> <span>true</span><span>,</span> <span>&amp;</span><span>r</span><span>);</span>
</span></span><span><span>  <span>if</span> <span>(</span><span>r</span><span>.</span><span>is_redirected</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// If we redirected the request then we need to update the socket
</span></span></span><span><span><span></span>    <span>// destination to the new IP and port
</span></span></span><span><span><span></span>    <span>ctx</span><span>-&gt;</span><span>user_ip4</span> <span>=</span> <span>r</span><span>.</span><span>ip</span><span>;</span>
</span></span><span><span>    <span>ctx</span><span>-&gt;</span><span>user_port</span> <span>=</span> <span>r</span><span>.</span><span>port</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>return</span> <span>1</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></div>

<p>The machines running the program don‚Äôt have IPv6 support, so my assumption was that I‚Äôd covered the bases.</p>
<p>I then used an <a href="https://docs.ebpf.io/linux/program-type/BPF_PROG_TYPE_CGROUP_SKB/"><code>BPF_PROG_TYPE_CGROUP_SKB</code> eBPF program</a> to ensure that the redirect couldn‚Äôt be circumvented by making direct IP calls. Roughly this looked like üëá</p>

<div><pre tabindex="0"><code data-lang="c"><span><span><span>SEC</span><span>(</span><span>&#34;cgroup_skb/egress&#34;</span><span>)</span>
</span></span><span><span><span>int</span> <span>cgroup_skb_egress</span><span>(</span><span>struct</span> <span>__sk_buff</span> <span>*</span><span>skb</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>// Block IPv6 traffic. Currently not supported.
</span></span></span><span><span><span></span>  <span>if</span> <span>(</span><span>skb</span><span>-&gt;</span><span>family</span> <span>==</span> <span>AF_INET6</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>struct</span> <span>event</span> <span>info</span> <span>=</span> <span>{</span>
</span></span><span><span>        <span>...</span>
</span></span><span><span>        <span>.</span><span>eventType</span> <span>=</span> <span>PACKET_IPV6_TYPE</span><span>,</span>
</span></span><span><span>    <span>};</span>
</span></span><span><span>
</span></span><span><span>    <span>bpf_ringbuf_output</span><span>(</span><span>&amp;</span><span>events</span><span>,</span> <span>&amp;</span><span>info</span><span>,</span> <span>sizeof</span><span>(</span><span>info</span><span>),</span> <span>0</span><span>);</span>
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>EGRESS_DENY_PACKET</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>// .... then we&#39;d check if outbound ip was allowed and deny/allow ...
</span></span></span></code></pre></div>

<blockquote>
<p>Note: I‚Äôm using <a href="https://docs.ebpf.io/linux/helper-function/bpf_ringbuf_output/"><code>bpf_ringbuf_output</code></a> here to track events from the eBPF program and logging them from userspace. This was invaluable for tracking down this bug, without them, it would be very hard to reason about what was happening inside the eBPF portion of the progam.</p></blockquote>
<p>Everything was going very well, <strong>until a user tried <code>dotnet</code> CLI.</strong></p>
<p>When they ran <code>dotnet add package x</code> it would hang indefinitely and produce lots of <code>PACKET_IPV6_TYPE</code> blocked messages via the <code>ringbuf_output</code>.</p>
<h2 id="oh-dotnet-is-using-ipv6">Oh dotnet is using IPv6</h2>
<p>The obvious conclusion was the machine was somehow making IPv6 requests, so I did some digging</p>
<ul>
<li>‚ùì My <code>connect4</code> eBPF program was not getting hit, I added similar <code>bpf_ringbuf_output</code> events so I could stream to log in userspace</li>
<li>‚ùå Hooking up wireshark, I confirmed that <code>dotnet</code> wasn‚Äôt making IPv6 calls off the box and the box couldn‚Äôt make IPv6 requests to the internet</li>
</ul>
<p><strong>Now I‚Äôm baffled.</strong></p>
<ul>
<li>Network traffic shows IPv4 calls going out</li>
<li><code>egress</code> eBPF program shows IPv6</li>
<li><code>connect4</code> eBPF program doesn‚Äôt fire suggesting no IPv4 <code>connect</code> call is made</li>
</ul>
<p>What! These contradict each other!</p>
<h2 id="read-more-kernel-and-dotnet-source-code">Read more Kernel and <code>dotnet</code> source code</h2>
<p>At this point I knew there must be something I was misunderstanding.</p>
<p>I spent a bunch of timing digging into the kernel, eBPF and <code>dotnet</code> to see if I could find anything that made the <code>dotnet cli</code> special, as no other tooling seemed to be impacted.</p>
<p>I started changing the program to get more info, I added a <code>connect6</code> eBPF program and hook that this would hit for <code>syscall.connect</code> on IPv6. Hopefully it would confirm thas <code>dotnet</code> was infact using IPv6 somehow?!</p>

<div><pre tabindex="0"><code data-lang="c"><span><span><span>SEC</span><span>(</span><span>&#34;cgroup/connect6&#34;</span><span>)</span>
</span></span><span><span><span>int</span> <span>connect6</span><span>(</span><span>struct</span> <span>bpf_sock_addr</span> <span>*</span><span>ctx</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>struct</span> <span>event</span> <span>info</span> <span>=</span> <span>{</span>
</span></span><span><span>      <span>.</span><span>eventType</span> <span>=</span> <span>IPV4_VIA_IPV6_REDIRECT_TYPE</span><span>,</span>
</span></span><span><span>  <span>};</span>
</span></span><span><span>  <span>bpf_ringbuf_output</span><span>(</span><span>&amp;</span><span>events</span><span>,</span> <span>&amp;</span><span>info</span><span>,</span> <span>sizeof</span><span>(</span><span>info</span><span>),</span> <span>0</span><span>);</span>
</span></span><span><span>  <span>return</span> <span>1</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></div>

<p>Running the repro steps <code>dotnet add package x</code> with the above hook, I was immediately greeted by <code>connect6</code> being hit, even though wireshark showed IPv4 traffic exiting the VM.</p>
<p>At this point the only conclusion I could think of was that the kernel is seeing IPv6 but the traffic is actually IPv4.</p>
<p>This triggered a memory about dual stack networking. Digging through <code>dotnet</code> repos I found this:</p>
<blockquote>
<p>Since .NET 5, we are using DualMode sockets in SocketsHttpHandler. This allows us to handle IPv4 traffic from an IPv6 socket, and is considered to be a favorable practice by RFC 1933
<a href="https://devblogs.microsoft.com/dotnet/dotnet-6-networking-improvements/#an-option-to-globally-disable-ipv6">link</a>
<a href="https://datatracker.ietf.org/doc/html/rfc1933">rfc1933</a></p></blockquote>
<p>The feature had a kill switch! I gave it a try, with <code>DualMode sockets</code> disabled everything worked as expected, <code>connect4</code> got hit and the <code>egress</code> didn‚Äôt see the request as being IPv6. üöÄ</p>
<p>How the question was why? What was this feature doing under the covers.</p>
<h2 id="ipv4-compatible-ipv6-address-or-when-ipv4-pretends-to-be-ipv6-for-a-little-bit"><code>IPv4-Compatible IPv6 Address</code> or ‚ÄúWhen IPv4 pretends to be IPv6 for a little bit‚Äù</h2>
<p>This üëá line of the <code>dotnet</code> <code>DualMode</code> socket docs felt like the key üóù</p>
<blockquote>
<p>This allows us to handle IPv4 traffic from an IPv6 socket</p></blockquote>
<p>But how! Digging more into the source and kernel I found:</p>
<ul>
<li><a href="https://en.m.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses"><code>IPv4-mapped IPv6 addresses</code></a></li>
</ul>
<p>This is a way to encode an IPv4 address <strong>inside an IPv6 address</strong>.</p>
<p><img src="https://blog.gripdev.xyz/2025/05/06/ebpf-mystery-when-is-ipv4-not-ipv4-when-its-ipv6/image.png" alt="ipv4 mapped address image"/></p>
<p><strong>When used you get an IPv6 address where the last 32bits are actually a IPv4 address</strong>.</p>
<p>I updated my <code>connect6</code> eBPF to output the IPv6 address to me <code>bpf_ringbuf_output</code> event, so I could have a look at it.</p>
<p>Low and behold it was a <code>IPv4 mapped address</code> ü§Øüéâ</p>
<p><strong>When using <code>DualMode sockets</code> <code>dotnet</code> requests an IPv6 Socket, <strong>even for non-IPv6 requests</strong>, and sets the <code>user_ip6</code> address field to be a <a href="https://en.m.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses">IPv4-Mapped</a> address.</strong></p>
<blockquote>
<p>What does a IPv4 mapped address look like?
These look like <code>::ffff:1.1.1.1</code> encoding the IPv4 address at the end of the IPv6 address.</p></blockquote>
<p>I thought I must have this wrong, surely you can‚Äôt just smash an ipv4 address in ipv6 field and magic happens?! Nope, didn‚Äôt have it wrong, that‚Äôs what happens. Linux supports this, and will go on to route the request as IPv4.</p>
<p>My wireshark traces didn‚Äôt see the IPv6 traffic, as the kernel is translating it back to IPv4 when making the networking call, so this interim state is only visible to the <code>eBPF</code> programs/kernel.</p>
<h2 id="fixing-the-ebpf-to-handle-ipv4-mapped-ipv6-addresses">Fixing the eBPF to handle <code>IPv4-mapped IPv6 addresses</code></h2>
<p>To make my original <code>syscall.connect</code> intercept work I have to now hook both IPv4 and IPv6 version of it. For this case I updated the <code>connect6</code> from earlier to parse out the IPv4 address from the IPv6 address.</p>

<div><pre tabindex="0"><code data-lang="c"><span><span><span>SEC</span><span>(</span><span>&#34;cgroup/connect6&#34;</span><span>)</span>
</span></span><span><span><span>int</span> <span>connect6</span><span>(</span><span>struct</span> <span>bpf_sock_addr</span> <span>*</span><span>ctx</span><span>)</span> <span>{</span>
</span></span><span><span>  <span>// Check if we have an IPv4-mapped IPv6 address (::ffff:x.x.x.x)
</span></span></span><span><span><span></span>  <span>// The first 10 bytes should be zeros, followed by 2 bytes of 0xffff
</span></span></span><span><span><span></span>  <span>// user_ip6[0] and user_ip6[1] should be 0 (first 64 bits)
</span></span></span><span><span><span></span>  <span>// user_ip6[2] should be 0x0000ffff (next 32 bits with pattern 0000...1111)
</span></span></span><span><span><span></span>  <span>if</span> <span>(</span><span>ctx</span><span>-&gt;</span><span>user_ip6</span><span>[</span><span>0</span><span>]</span> <span>!=</span> <span>0</span> <span>||</span> <span>ctx</span><span>-&gt;</span><span>user_ip6</span><span>[</span><span>1</span><span>]</span> <span>!=</span> <span>0</span> <span>||</span>
</span></span><span><span>      <span>ctx</span><span>-&gt;</span><span>user_ip6</span><span>[</span><span>2</span><span>]</span> <span>!=</span> <span>bpf_htonl</span><span>(</span><span>0x0000ffff</span><span>))</span> <span>{</span>
</span></span><span><span>    <span>return</span> <span>1</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>
</span></span><span><span>  <span>// See: https://en.m.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses As
</span></span></span><span><span><span></span>  <span>// bpf_sock_addr stores `user_ip6` as IPv6 is 4x32 bits to get the IPv4
</span></span></span><span><span><span></span>  <span>// address we ignore the first 96 bits and take the last 32 bits which is the
</span></span></span><span><span><span></span>  <span>// __u32 at index 3 of the user_ip6 array
</span></span></span><span><span><span></span>  <span>__be32</span> <span>ipv4_address</span> <span>=</span> <span>ctx</span><span>-&gt;</span><span>user_ip6</span><span>[</span><span>3</span><span>];</span>
</span></span><span><span>
</span></span><span><span>  <span>struct</span> <span>event</span> <span>info</span> <span>=</span> <span>{</span>
</span></span><span><span>      <span>.</span><span>ip</span> <span>=</span> <span>bpf_ntohl</span><span>(</span><span>ipv4_address</span><span>),</span>
</span></span><span><span>      <span>.</span><span>eventType</span> <span>=</span> <span>IPV4_VIA_IPV6_REDIRECT_TYPE</span><span>,</span>
</span></span><span><span>  <span>};</span>
</span></span><span><span>  <span>bpf_ringbuf_output</span><span>(</span><span>&amp;</span><span>events</span><span>,</span> <span>&amp;</span><span>info</span><span>,</span> <span>sizeof</span><span>(</span><span>info</span><span>),</span> <span>0</span><span>);</span>
</span></span><span><span>
</span></span><span><span>  <span>struct</span> <span>redirect_result</span> <span>r</span> <span>=</span> <span>{</span>
</span></span><span><span>      <span>.</span><span>ip</span> <span>=</span> <span>ipv4_address</span><span>,</span>
</span></span><span><span>      <span>.</span><span>port</span> <span>=</span> <span>ctx</span><span>-&gt;</span><span>user_port</span><span>,</span>
</span></span><span><span>      <span>.</span><span>is_redirected</span> <span>=</span> <span>false</span><span>,</span>
</span></span><span><span>  <span>};</span>
</span></span><span><span>  <span>handle_connect_redirect</span><span>(</span><span>ctx</span><span>,</span> <span>ipv4_address</span><span>,</span> <span>false</span><span>,</span> <span>&amp;</span><span>r</span><span>);</span>
</span></span><span><span>  <span>if</span> <span>(</span><span>r</span><span>.</span><span>is_redirected</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// If we redirected the request then we need to update the socket
</span></span></span><span><span><span></span>    <span>// destination to the new IP and port
</span></span></span><span><span><span></span>    <span>ctx</span><span>-&gt;</span><span>user_ip6</span><span>[</span><span>3</span><span>]</span> <span>=</span> <span>r</span><span>.</span><span>ip</span><span>;</span>
</span></span><span><span>    <span>ctx</span><span>-&gt;</span><span>user_port</span> <span>=</span> <span>r</span><span>.</span><span>port</span><span>;</span>
</span></span><span><span>  <span>}</span>
</span></span><span><span>  <span>return</span> <span>1</span><span>;</span>
</span></span><span><span><span>}</span></span></span></code></pre></div>

<p>It pulls the original IPv4 address out and then calls the existing <code>handle_connect_redirect</code> method. Done right? Nope.</p>
<p>This wasn‚Äôt quite enough though as my <code>egress</code> eBPF program would still block these requests as IPv6.</p>
<p>I tracked this down to this check in the <code>egress</code> program:</p>

<div><pre tabindex="0"><code data-lang="c"><span><span><span>if</span> <span>(</span><span>skb</span><span>-&gt;</span><span>family</span> <span>==</span> <span>AF_INET6</span><span>)</span> <span>{</span>
</span></span><span><span>    <span>// end up here
</span></span></span><span><span><span></span>    <span>return</span> <span>0</span>
</span></span><span><span><span>}</span></span></span></code></pre></div>

<p>The mapped IPv4 socket was identifying its family as IPv6, how do I work around this? I want to block IPv6 but not IPv4 mapped via IPv6 sockets ü§î</p>
<p>After lots of playing I found this approach:</p>

<div><pre tabindex="0"><code data-lang="c"><span><span><span>if</span> <span>(</span><span>skb</span><span>-&gt;</span><span>protocol</span> <span>==</span> <span>bpf_htons</span><span>(</span><span>ETH_P_IPV6</span><span>))</span> <span>{</span>
</span></span><span><span>    <span>// IPv6 hits this but IPv4 Mapped doesn&#39;t
</span></span></span><span><span><span></span>    <span>return</span> <span>0</span>
</span></span><span><span><span>}</span></span></span></code></pre></div>

<p>By looking at the protocol on <code>skb</code> I was able to distinguish between IPv6 and IPv4 mapped onto IPv6 (TODO: more testing needed on this last bit).</p>
<h2 id="thats-it">That‚Äôs it</h2>
<p><strong>When is IPv4 not IPv4?</strong></p>
<p>When it‚Äôs using an <code>IPv4-Compatible IPv6 Address</code> to sending IPv4 over an IPv6 socket ü§Ø</p>

            </div>
        </article></main>
</div></div>
  </body>
</html>
