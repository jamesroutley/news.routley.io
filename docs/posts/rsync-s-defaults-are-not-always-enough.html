<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2025/05/31/sync/">Original</a>
    <h1>rsync&#39;s defaults are not always enough</h1>
    
    
<p>
rsync is one of those tools which is rather useful.  It saves you from 
spending the time and effort on copying data which you already have.  
It&#39;s the backbone of many a mirror site, and it also gets used for any 
number of backup solutions.
</p>
<p>
There&#39;s just one problem: in the name of efficiency, it can miss certain 
changes.  rsync normally looks at the size and modification time of a 
candidate file, and if they are the same at both ends, that&#39;s the end of 
any consideration.  It won&#39;t get any further attention and it moves on 
to something else.
</p>
<p>
&#34;So what&#34;, you might think.  &#34;All files change at least their mtime 
when someone writes to them.  That&#39;s the whole point of a mtime.&#34;
</p>
<p>
And yet... I&#39;m writing this post, and here we are.
</p>
<p>
The keen-eyed observers out there are probably already thinking &#34;ooh, 
bit rot&#34; and other things where one of the files has actually become 
corrupted while &#34;at rest&#34; for whatever reason.  Those observers are 
right!  That&#39;s totally a problem that you have to worry about, 
especially if you&#39;re using SSDs to hold your bits and those SSDs aren&#39;t 
always being powered.
</p>
<p>
But no, this is something you have to worry about *beyond* that.  This 
is about a &#34;sneak path&#34; that you probably didn&#39;t consider.  I didn&#39;t.
</p>
<p>
Here, let&#39;s run a little experiment.  If you have a x86_64 Debian box 
that&#39;s relatively current and you&#39;ve been backing up the whole thing 
via rsync for a year or two, go do something for me.
</p>
<p>
Go run your favorite file-hasher tool on 
/usr/lib/x86_64-linux-gnu/libfribidi.so.0.4.0 for me.  Give it a 
sha256sum or whatever, or even md5sum if you&#39;re feeling brash.  Then 
note the modification time on the file.
</p>
<p>
Now mount one of your backups and do the same thing on the version of 
the file that&#39;s on the backup device.  See anything ... odd?  Unusual?
</p>
<p>
Identical mtimes, identical sizes... and different hashes, right?  I 
spotted this on a bunch of my machines after going &#34;hmmm...&#34; about the 
whole SSD-data-loss thing.
</p>
<p>
Clearly, something unusual happened somewhere, and it&#39;s been escaping 
the notice of your rsync runs ever since.  I haven&#39;t gone digging into 
the package history for this thing to find out just when and where it 
happened, and (more importantly) how.  It&#39;s rather unusual.
</p>
<p>
If you&#39;re freaking out right now, there is some hope.  rsync has both -I 
and -c which promise to not use the quick method and instead will 
run a checksum on the files.  It&#39;s slower so you won&#39;t want to do this 
normally, but it&#39;s not a bad idea to add this to the mix of things that 
you do every so many rotations.
</p>
<p>
I should point out that the first time you do a forced-checksum run, 
--dry-run will let you see the changes before it blows anything away, 
so you can make the call as to which version is the right one!  In 
theory, your *source* files can get corrupted, and if you just copy one 
of those across, you have now corrupted your backup.
</p>
<p>
Isn&#39;t entropy FUN?
</p>

  </body>
</html>
