<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.polarsignals.com/blog/posts/2025/11/04/javascript-source-maps-internals">Original</a>
    <h1>How devtools map minified JS code back to your TypeScript source code</h1>
    
    <div id="readability-page-1" class="page"><article><p>Source maps are the main piece in the jigsaw puzzle of mapping symbols and locations from &#34;built&#34; JavaScript files back to the original source code. When you debug minified JavaScript in your browser&#39;s DevTools and see the original source with proper variable names and formatting, you&#39;re witnessing source maps in action.</p>
<p>For example, when your browser encounters an error at <code>bundle.min.js:1:27698</code>, the source map translates this to <code>src/index.ts:73:16</code>, revealing exactly where the issue occurred in your original TypeScript code:</p>

<p>But how does this actually work under the hood? In this post, we&#39;ll take a deep dive into the internals of source maps, exploring their format, encoding mechanisms, and how devtools use them to bridge the gap between production code and developer-friendly sources.</p>
<h2>The TypeScript Build Pipeline</h2>
<p>Modern JavaScript builds typically involve three main stages:</p>
<ul>
<li><strong>Transpilation</strong>: TypeScript → JavaScript</li>
<li><strong>Bundling</strong>: Combining modules into a single file</li>
<li><strong>Minification</strong>: Compressing code for production</li>
</ul>
<p>At each stage, source maps preserve the connection back to the original code.</p>
<div><div><div><div><div><h3>Stage 0: Source TS files</h3><p>The original TypeScript source files with full type annotations.</p></div><div><div><h4><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>Source Files</h4><div><pre><p><span>1</span><span>export</span><span> </span><span>function</span><span> </span><span>add</span><span>(</span><span>a</span><span>:</span><span> </span><span>number</span><span>,</span><span> b</span><span>:</span><span> </span><span>number</span><span>)</span><span>:</span><span> </span><span>number</span><span> </span><span>{</span><span></span></p><p><span>2</span><span>  </span><span>return</span><span> a </span><span>+</span><span> b</span><span>;</span><span></span></p><p><span>3</span><span></span><span>}</span></p></pre></div><div><pre><p><span>1</span><span>import</span><span> </span><span>{</span><span> add </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;./add&#39;</span><span>;</span><span></span></p><p><span>2</span><span>
</span></p><p><span>3</span><span></span><span>export</span><span> </span><span>function</span><span> </span><span>computeFibonacci</span><span>(</span><span>n</span><span>:</span><span> </span><span>number</span><span>)</span><span>:</span><span> </span><span>number</span><span> </span><span>{</span><span></span></p><p><span>4</span><span>  </span><span>if</span><span> </span><span>(</span><span>n </span><span>&lt;=</span><span> </span><span>1</span><span>)</span><span> </span><span>return</span><span> n</span><span>;</span><span></span></p><p><span>5</span><span>  </span><span>return</span><span> </span><span>add</span><span>(</span><span>computeFibonacci</span><span>(</span><span>n </span><span>-</span><span> </span><span>1</span><span>)</span><span>,</span><span> </span><span>computeFibonacci</span><span>(</span><span>n </span><span>-</span><span> </span><span>2</span><span>)</span><span>)</span><span>;</span><span></span></p><p><span>6</span><span></span><span>}</span></p></pre></div><div><pre><p><span>1</span><span>import</span><span> </span><span>{</span><span> computeFibonacci </span><span>}</span><span> </span><span>from</span><span> </span><span>&#39;./fibonacci&#39;</span><span>;</span><span></span></p><p><span>2</span><span>
</span></p><p><span>3</span><span></span><span>const</span><span> result </span><span>=</span><span> </span><span>computeFibonacci</span><span>(</span><span>10</span><span>)</span><span>;</span><span></span></p><p><span>4</span><span></span><span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>Fibonacci(10) = </span><span>${</span><span>result</span><span>}</span><span>`</span><span>)</span><span>;</span></p></pre></div></div><div><div><div><svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg><p>No source map at this stage</p></div></div></div></div></div></div></div></div>
<h2>The Source Map File Format</h2>
<p>Source maps use JSON format, typically with a <code>.js.map</code> extension. Let&#39;s examine a source map structure from our <code>add.js.map</code> file:</p>
<pre><code>{
  &#34;version&#34;: 3,
  &#34;file&#34;: &#34;add.js&#34;,
  &#34;sourceRoot&#34;: &#34;&#34;,
  &#34;sources&#34;: [&#34;add.ts&#34;],
  &#34;names&#34;: [&#34;add&#34;, &#34;a&#34;, &#34;b&#34;],
  &#34;mappings&#34;: &#34;AAAA,OAAO,SAAS,IAAI,CAAC,EAAE;EACrB,OAAO,IAAI;AACb&#34;
}
</code></pre>
<h5>Fields Breakdown:</h5>
<ul>
<li><strong><code>version</code></strong>: Indicates the source map version (currently always <code>3</code>).</li>
<li><strong><code>file</code></strong>: The generated file name this source map corresponds to.</li>
<li><strong><code>sourceRoot</code></strong>: Optional prefix for all source URLs. Useful when sources are hosted elsewhere.</li>
<li><strong><code>sources</code></strong>: Array of original source file paths from which the generated file was built.</li>
<li><strong><code>sourcesContent</code></strong>: Optional array containing the actual source code. This allows DevTools to display sources even if the original files aren&#39;t accessible. Usually disabled in production builds.</li>
<li><strong><code>names</code></strong>: Array of original identifiers (variable names, function names, etc.) that appear in the source. Referenced by the mappings.</li>
<li><strong><code>mappings</code></strong>: The compressed mapping data. This is the heart of the source map and uses VLQ encoding. More on this below.</li>
</ul>
<h2>Understanding the Mappings: VLQ Encoding</h2>
<p>The <code>mappings</code> field is where the real magic happens. It contains the actual position mappings between every token in the generated JavaScript file and its corresponding location in the original source files.</p>
<p>Essentially, it answers the question: &#34;For this character at line X, column Y in the minified file, where was it originally located?&#34;</p>
<p>This mapping data tracks:</p>
<ul>
<li>The file path and name of the original source file</li>
<li>The exact line and column in the source file</li>
<li>The original variable/function name (if renamed during minification)</li>
</ul>
<p>But instead of storing this as a massive JSON array of positions, which would be larger than the minified code itself, source maps use a highly compressed format. Here&#39;s what the encoded string looks like:</p>
<pre><code>&#34;AAAA,OAAO,SAAS,IAAI,CAAC,EAAE;EACrB,OAAO,IAAI;AACb&#34;
</code></pre>
<p>To keep file sizes manageable, mappings use <strong>Variable Length Quantity (VLQ)</strong> encoding with Base64 characters. Let&#39;s break this down.</p>
<h3>The Mapping Structure</h3>
<p>The mappings string is a series of segments separated by commas and semicolons:</p>
<pre><code>&#34;segment,segment,segment;segment,segment;segment&#34;
</code></pre>
<p>We&#39;ll see significance of commas and semicolons shortly, but first, what is a &#34;segment&#34;?</p>
<p>Each segment represents a mapping from a position in the generated file to a position in the source file. Segments come in three flavors:</p>
<ul>
<li>
<p><strong>1 value:</strong> This referenced column doesn&#39;t map to any source (e.g., webpack-generated code)</p>
</li>
<li>
<p><strong>4 values:</strong> This is the most common case, mapping a position in the generated file to a position in the source file:</p>
</li>
<li>
<p><strong>5 values:</strong> Same as 4, plus a reference to the original name of the variable/function:</p>
</li>
</ul>
<p>The most common case is 4 values (basic position mapping). The 5th value is only added when a variable or function was renamed during minification.</p>
<p><strong>But wait</strong>, notice that segments only contain the column in the generated file, not the line number. How does the decoder know which line a segment belongs to?</p>
<p>The answer lies in the structure: semicolons act as line breaks. The position of segments between semicolons determines their line number in the generated file.</p>

<p>This is why empty lines in the generated file still need semicolons, they maintain the line count even with no mappings.</p>
<p>Let&#39;s see how this works with a real example:</p>
<div><div><div><div><p>Original mapping string from add.js.map:</p><div><p><span><span>AAAA</span><span>,</span></span><span><span>OAAO</span><span>,</span></span><span><span>SAASS</span><span>,</span></span><span><span>IAAI</span><span>,</span></span><span><span>CAAC</span><span>,</span></span><span><span>EAAE</span></span><span>;</span><span><span>EACrB</span><span>,</span></span><span><span>OAAO</span><span>,</span></span><span><span>IAAI</span></span><span>;</span><span><span>AACb</span></span></p></div><div><div><div><p>Line </p><!-- --><p>0</p><!-- --> <!-- --><p>(before first semicolon)</p><!-- --><p>:</p></div><div><div><div><div><p>SAASS</p><p>(includes name index)</p></div></div></div></div></div><div><div><p>Line </p><!-- --><p>1</p><!-- --> <!-- --><p>(after first semicolon)</p><!-- --><p>:</p></div></div><div><div><p>Line </p><!-- --><p>2</p><!-- --> <!-- --><p>(after second semicolon)</p><!-- --><p>:</p></div></div></div></div></div></div></div>
<p>Notice how the decoded values give <strong>relative positions</strong>, each value represents the difference from the previous position, not absolute coordinates. This is crucial: instead of encoding large column numbers like 27698 in minified files, source maps only store small deltas like +7 or +15, making the encoded strings much more compact.</p>
<p>Now that we understand the mapping structure, let&#39;s see how these numbers actually get transformed into the Base64 alphabet characters we see in the mappings string.</p>
<h3>How VLQ Encoding Works</h3>
<p>VLQ (Variable Length Quantity) encoding is an efficient way to represent numbers using as few bytes as possible. It&#39;s perfect for source maps because most position differences are small numbers.</p>
<p>The encoding process has three main steps:</p>
<p><strong>1. Encode the sign bit</strong></p>
<p>Since we need to handle both positive and negative differences (code can move backward), VLQ uses the least significant bit (LSB) to encode the sign:</p>
<pre><code>Positive number: LSB = 0
Negative number: LSB = 1

Examples:
 5 → binary: 101 → with sign bit: 1010 (LSB=0 for positive)
-5 → binary: 101 → with sign bit: 1011 (LSB=1 for negative)
</code></pre>
<p><strong>2. Split into 5-bit groups</strong></p>
<p>Each Base64 character can represent 6 bits, but we need 1 bit as a &#34;continuation&#34; flag to indicate if more characters follow. This leaves 5 bits for data:</p>
<pre><code>[continuation bit][5 data bits]
       ↑              ↑
   1 = more coming    actual value bits
   0 = last character
</code></pre>
<p><strong>3. Convert to Base64</strong></p>
<p>Map each 6-bit value to a Base64 character:</p>
<pre><code>A=0, B=1, C=2... Z=25, a=26, b=27... z=51, 0=52, 1=53... 9=61, +=62, /=63
</code></pre>
<h6>Example</h6>
<p>Lets go through the steps to encode the number 7:</p>
<div><div><div><div><p>Step 1: Convert to binary</p><p><span>7</span><span>→</span><span>111</span></p><p>7 in binary representation</p></div><div><p>Step 2: Add sign bit</p><p><span>111</span><span>→</span><span>1110</span></p><p>Shift left (111 &lt;&lt; 1) and add 0 for positive. LSB = 0 indicates positive number</p></div><div><p>Step 3: Add continuation bit</p><p><span>1110</span><span>→</span><span>001110</span></p><p>Prepend 0 (no continuation) since it fits in 5 bits. First bit = 0 means this is the last character</p></div><div><p>Step 4: Convert to Base64</p><p><span>001110</span><span>→</span><span>O</span></p><p>001110 in binary = 14 in decimal. Base64[14] = O</p></div></div></div></div>
<p>That&#39;s why in our mapping example, the value 7 is encoded as &#39;O&#39;!</p>
<h2>Conclusion</h2>
<p>I hope this deep dive into JavaScript source maps has shed light on how they function under the hood and adds to your appreciation for the amount of position data they efficiently encode.</p>
<p><em>P.S. Stay tuned: source maps support is coming to parca-agent and Polar Signals Cloud, bringing the same debugging magic to your performance profiling workflow!</em></p></article></div>
  </body>
</html>
