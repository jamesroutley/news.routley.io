<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://okmij.org/ftp/ML/higher-kind-poly.html">Original</a>
    <h1>Higher-kinded bounded polymorphism in OCaml (2021)</h1>
    
    <div id="readability-page-1" class="page">



<div><p>Higher-kinded polymorphism -- the abstraction over a type
<em>constructor</em> to be later supplied with arguments -- is often needed,
for expressing generic operations over collections or embedding typed
DSLs, particularly in tagless-final style. Typically, the abstracted type
constructor is not arbitrary, but must implement a particular
interface (e.g., an abstract sequence) -- so-called bounded
polymorphism. 
</p><p>OCaml does not support higher-kinded polymorphism directly: OCaml type
variables range over types rather than type constructors, and type
constructors may not appear in type expressions without being applied
to the right number of arguments.  Nevertheless, higher-kinded
polymorphism is expressible in OCaml -- in fact, in several, more or
less cumbersome ways. The less cumbersome ways are particularly less
known, and kept being rediscovered. This page summarizes the different
ways of expressing, and occasionally avoiding, higher-kinded
polymorphism. They are collected from academic papers and messages on
the caml-list spread over the years -- and adjusted to fit the story
and differently explained.
</p></div>
<ul>
<li><a href="#intro">Introduction</a>
</li>
<li><a href="#complex">Why higher-kinded polymorphism is not supported directly in OCaml</a>
</li>
<li><a href="#functors">Higher-kinded functions as Functors</a>
</li>
<li><a href="#yw">Yallop and White&#39;s Lightweight higher-kinded polymorphism</a>
</li>
<li><a href="#avoid">Sidestepping higher-kinded polymorphism</a>
</li>
<li><a href="#algebra">Algebras</a>
</li>
<li><a href="#hkname">What&#39;s in a higher-kinded type name</a>
</li>
<li><a href="#conc">Conclusions</a>
</li></ul>
<hr/>


<h2><a name="intro">Introduction</a></h2>
<dl>
<dd>``Polymorphism abstracts types, just as functions abstract
values. Higher-kinded polymorphism takes things a step further,
abstracting both types and types constructors, just as higher-order
functions abstract both first-order values and functions.&#39;&#39; -- write
Yallop and White (FLOPS 2014).
<p>This remarkably concise summary is worth expounding upon, to
demonstrate how (bounded) higher-kinded polymorphism tends to
arise. The example introduced here is used all throughout the page.
</p><p>Summing up numbers frequently occurs in practice; abstracting from
concrete numbers leads to a function -- an operation that can be
uniformly performed on any collection (list) of numbers:

</p><pre>    let rec sumi : int list -&gt; int = function [] -&gt; 0 | h::t -&gt; h + sumi t
</pre>We may further abstract over <code>0</code> and the operation
<code>+</code>, which itself is a function (a parameterized value, so to
speak). The result is a higher-order function:

<pre>    let rec foldi (f: int-&gt;int-&gt;int) (z: int) : int list -&gt; int =
        function [] -&gt; z | h::t -&gt; f h (foldi f z t)
</pre>Folding over a list, say, of floating-point numbers proceeds similarly, so we
may abstract yet again -- this time not over values but over the type
<code>int</code>, replacing it with a type variable:

<pre>    let rec fold (f: &#39;a-&gt;&#39;a-&gt;&#39;a) (z: &#39;a) : &#39;a list -&gt; &#39;a =
        function [] -&gt; z | h::t -&gt; f h (fold f z t)
</pre>thus giving us the polymorphic function: the function that describes an
operation performed over lists of various types, uniformly.
The operation <code>f</code> and the value <code>z</code> can be collected into a 
parameterized record

<pre>    type &#39;a monoid = {op: &#39;a-&gt;&#39;a-&gt;&#39;a; unit: &#39;a}
</pre>The earlier <code>fold</code> then takes the form

<pre>    let rec foldm (m: &#39;a monoid) : &#39;a list -&gt; &#39;a =
        function [] -&gt; m.unit | h::t -&gt; m.op h (foldm m t)
</pre>When using <code>foldm</code> on a concrete list of the type <code>t list</code>, 
the type variable <code>&#39;a</code> gets
instantiated to the type <code>t</code> of the elements of this list. The type is not
completely arbitrary, however: there must exist the value 
<code>t monoid</code>, to be passed to <code>foldm</code> as the argument. We say the type
<code>t</code> must (at least) implement/support the <code>&#39;a monoid</code> interface; the <code>t monoid</code> value is then the witness that <code>t</code> indeed does so. Hence the
polymorphism in <code>foldm</code> is <em>bounded</em>.
<p><em>Exercise:</em> if <code>&#39;a monoid</code> really describes a monoid, 
<code>op x unit = x</code> holds. Write a more optimal version of <code>foldm</code> (and
its subsequent variants) taking advantage of this identity.
</p><p>A file, a string, an array, a sequence -- all can be folded over in the
same way. Any collection is foldable so long as it supports the
deconstruction operation, which tells if the collection is empty, or
gives its element and the rest of the sequence. One is tempted to
abstract again -- this time not over a mere type like <code>int</code> or <code>int list</code>, but over a type constructor such as <code>list</code>, and introduce

</p><pre>    type (&#39;a,&#39;F) seq = {decon: &#39;a &#39;F -&gt; (&#39;a * &#39;a &#39;F) option}
</pre>This is a hypothetical OCaml: the type variable &#39;F (with the
upper-case name) is to be instantiated not with types but one-argument
type constructors: technically, one says it has the <em>higher-kind</em>
<code>* -&gt; *</code> rather than the ordinary kind <code>*</code> of types and ordinary type variables
such as <code>&#39;a</code>. The record <code>seq</code> is, hence, higher-kind polymorphic. The
function <code>foldm</code> then generalizes to

<pre>    let rec folds (m: &#39;a monoid) (s: (&#39;a,&#39;F) seq) : &#39;a &#39;F -&gt; &#39;a = fun c -&gt;
        match s.decon c with None -&gt; m.unit | Some (h,t) -&gt; m.op h (folds m s t)
</pre>Again, <code>&#39;F</code> is instantiated not with just any type constructor, but only that
for which we can find the value <code>(&#39;a,&#39;F) seq</code>; thus <code>folds</code> exhibits 
<em>bounded higher-kinded</em> polymorphism.
<p>Alas, higher-kind type variables are not possible in OCaml. The
next section explains why. The following sections tell what we can do in
OCaml instead. There are several alternatives. In some, the end result
ends up looking almost exactly as the above imagined
higher-kind--polymorphic code.</p></dd></dl>


<h2><a name="complex">Why higher-kinded polymorphism is not supported directly in OCaml</a></h2>
<dl>
<dd>Higher-kind type variables are not supported in OCaml.  Yallop and
White&#39;s FLOPS 2014 paper (Sec. 1.1) explains why: in a word, type
aliasing. For completeness, we recount their explanation here, with
modifications.
<p>Consider the following two modules:

</p><pre>    module Tree = struct
      type &#39;a t = Leaf | Branch of &#39;a t * &#39;a * &#39;a t
    end
    
    module TreeA : dcont = struct
      type &#39;a t = (&#39;a * &#39;a) Tree.t
    end
</pre>Here, <code>&#39;a Tree.t</code> is a data type: a fresh type, distinct from
all other existing types. On the other hand, <code>&#39;a TreeA.t</code> is an alias:
as its declaration says, it is equal to an existing type, viz. <code>(&#39;a * &#39;a) Tree.t</code>.
<p>Suppose OCaml had higher-kind <code>* -&gt; *</code> type variables, such as <code>&#39;F</code>
hypothesized in the previous section. Type checking is, in the end,
solving/checking type equalities, such as <code>&#39;a &#39;F = &#39;b &#39;G</code>. If
higher-kind type variables ranged only over <em>data type</em> constructors,
the solution is easy: <code>&#39;a = &#39;b</code> and <code>&#39;F = &#39;G</code>: a data type is fresh, hence
equal only to itself. This is the situation in Haskell. To ensure that
only data type constructors can be substituted for higher-kind type
variables, a Haskell compiler keeps track of type aliases, even across
module boundaries. Module system in Haskell is rather simple, so such
tracking is unproblematic.
</p><p>Module system of ML is, in contrast, sophisticated. It has functors,
signatures, etc., and extensively relies on type aliases, for example:

</p><pre>    module F(T: sig type &#39;a t  val empty: &#39;a t end) = struct
      type &#39;a ft = &#39;a T.t
    end
</pre>If we preclude substitution of type aliases for higher-kind type
variables, we severely restrict expressiveness. For example, <code>&#39;a ft</code>
above is a type alias; hence <code>F(TRee).ft</code> cannot be substituted for a
higher-kind type variable, even though one may feel <code>F(TRee).ft</code> is
the same as <code>Tree.t</code>, which is substitutable.
<p>On the other hand, if we allow type aliases to be substituted for
higher-kind type variables, the equivalence of <code>&#39;a &#39;F = &#39;b &#39;G</code> and <code>&#39;a = &#39;b, &#39;F = &#39;G</code> breaks down. Indeed, consider <code>(int*int) &#39;F = int &#39;G</code>. This equation now has the solution: <code>&#39;F = Tree.t</code> and <code>&#39;G = TreeA.t</code>. Parameterized type aliases like <code>&#39;a TreeA.t</code> are type
functions, and type expressions like <code>int TreeA.t</code> are applications of
those functions, expanding to the right-hand-side of the alias
declaration with <code>&#39;a</code> substituted for <code>int</code>. Thus, with type aliases,
the type equality problem becomes the higher-order unification problem,
which is not decidable.</p></dd>
<dt><strong>References</strong></dt>
<dd>Jeremy Yallop and Leo White: Lightweight higher-kinded
polymorphism. FLOPS 2014.
</dd></dl>


<h2><a name="functors">Higher-kinded functions as Functors</a></h2>
<dl>
<dd>Although OCaml does not support higher-kind type variables, higher-kinded
polymorphism is not out of the question. There are other ways of
parameterizing by a type constructor: the module system (functor)
abstraction is the first to come to mind. 
It is however rather verbose and cumbersome. Let us see.
<p>We now re-write the hypothetical higher-kind--polymorphic OCaml code
at the end of [<a href="#intro">Introduction</a>] in the real OCaml -- by raising the level, so to
speak, from term-level to module-level. The hypothetical record

</p><pre>    type (&#39;a,&#39;F) seq = {decon: &#39;a &#39;F -&gt; (&#39;a * &#39;a &#39;F) option}
</pre>becomes the module signature

<pre>    module type seq_i = sig
      type &#39;a t                                (* sequence type *)
      val decon : &#39;a t -&gt; (&#39;a * &#39;a t) option
    end
</pre>which represents the higher-kind type variable <code>&#39;F</code>, not supported in
OCaml, with an ordinary type constructor <code>t</code> (type
constant). Different implementations of <code>seq_i</code> (see, e.g., <code>ListS</code>
below) instantiate <code>&#39;a t</code> in their own ways; hence
<code>t</code> does in effect act like a variable. The hypothetical
higher-kind--polymorphic function

<pre>    let rec folds (m: &#39;a monoid) (s: (&#39;a,&#39;F) seq) : &#39;a &#39;F -&gt; &#39;a = fun c -&gt;
        match s.decon c with None -&gt; m.unit | Some (h,t) -&gt; m.op h (folds m s t)
</pre>becomes the functor, parameterized by the <code>seq_i</code> signature:

<pre>    module FoldS(S:seq_i) = struct
      let rec fold (m: &#39;a monoid) : &#39;a S.t -&gt; &#39;a = fun c -&gt;
        match S.decon c with None -&gt; m.unit | Some (h,t) -&gt; m.op h (fold m t)
    end
</pre>We got what we wanted: abstraction over a sequence. To use
it to define other higher-kinded polymorphic functions, such as
<code>sums</code> to sum up a sequence, we also
need functors. Functors are infectious, one may say.

<pre>    module SumS(S:seq_i) = struct
      open S
      open FoldS(S)
      let sum : int t -&gt; int = fold monoid_plus
    end
</pre>
<p>Finally, an example of instantiating and using
higher-kind--polymorphic functions: summing a list. First we need an
instance of <code>seq_i</code> for a list: the witness that a list is a sequence.

</p><pre>    module ListS = struct
      type &#39;a t = &#39;a list
      let decon = function [] -&gt; None | h::t -&gt; Some (h,t)
    end
</pre>which we pass to the <code>SumS</code> functor:

<pre>    let 6 =
      let module M = SumS(ListS) in M.sum [1;2;3]
</pre>The accompanying code shows another example: using the same <code>SumS</code> to
sum up an array, which also can be made a sequence.
<p>Thus in this approach, all higher-kind--polymorphic functions are
functors, which leads to verbosity, awkwardness and boilerplate. For
example, we cannot even write a <code>SumS</code> application as <code>SumS(ListS).sum [1;2;3]</code>; we have to use the verbose expression above.</p></dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/HKPoly_seq.ml">HKPoly_seq.ml</a> [11K]</dd></dl>


<h2><a name="yw">Yallop and White&#39;s Lightweight higher-kinded polymorphism</a></h2>
<dl>
<dd>Perhaps surprisingly, higher-kinded polymorphism can always be reduced
to the ordinary polymorphism, as Yallop and White&#39;s FLOPS 2014 paper
cleverly demonstrated. They explained their approach as
defunctionalization. Here we recap it and explain in a different way.
<p>Consider the type <code>&#39;a list</code> again. It is a parameterized type: <code>&#39;a</code> is
the type of elements, and <code>list</code> is the name of the collection: `the
base name&#39;, so to speak. The combination of the element type and the
base name can be expressed differently, for example, as
<code>(&#39;a,list_name) app</code>, where <code>(&#39;a,&#39;b) app</code> is some fixed type, and
<code>list_name</code> is the ordinary type that tells the base name.  The fact
that the two representations are equivalent is witnessed by the
bijection:

</p><pre>    inj: &#39;a list -&gt; (&#39;a,list_name) app
    prj: (&#39;a,list_name) app -&gt; &#39;a list
</pre>
<p>Here is a way to implement it. First, we introduce the dedicated
`pairing&#39; data type. It is extensible, to let us define as many
pairings as needed.

</p><pre>    type (&#39;a,&#39;b) app = ..
</pre>For <code>&#39;a list</code>, we have:

<pre>    type list_name
    type (&#39;a,&#39;b) app += List_name : &#39;a list -&gt; (&#39;a,list_name) app
</pre>In this case the bijection <code>&#39;a list &lt;-&gt; (&#39;a,list_name) app</code> is:

<pre>    let inj x = List_name x and
    let prj (List_name x) = x
</pre>and the two functions are indeed inverses of each other.
<p><em>Exercise:</em> Actually, that the above <code>inj</code> and <code>prj</code> are
the inverses of each other is not as straightforward. It requires a
side-condition, which is satisfied in our case. State it.
</p><p>In this new representation of the polymorphic list as <code>(&#39;a,list_name) app</code>, the base name <code>list_name</code> is the ordinary (kind <code>*</code>)
type. Abstraction over it is straightforward: replacing with a
type variable. The base-name-polymorphism is, hence, the ordinary
polymorphism. We can then write the desired sequence-polymorphic
<code>folds</code> almost literally as the hypothetical code at the end of [<a href="#intro">Introduction</a>]:

</p><pre>    type (&#39;a,&#39;n) seq = {decon: (&#39;a,&#39;n) app -&gt; (&#39;a * (&#39;a,&#39;n) app) option}
    
    let rec folds (m: &#39;a monoid) (s: (&#39;a,&#39;n) seq) : (&#39;a,&#39;n) app -&gt; &#39;a = fun c -&gt;
        match s.decon c with None -&gt; m.unit | Some (h,t) -&gt; m.op h (folds m s t)
</pre>Instead of <code>&#39;a &#39;F</code> we write <code>(&#39;a,&#39;n) app</code>. That&#39;s it. Using <code>folds</code> in
other higher-kinded functions is straightforward, as if it were
a regular polymorphic function (which it actually is):

<pre>    let sums s c = folds monoid_plus s c
     (* val sums : (int, &#39;a) seq -&gt; (int, &#39;a) app -&gt; int = &lt;fun&gt; *)
</pre>Type annotations are not necessary: the type inference works. Here is a
usage example, summing a list:

<pre>    let list_seq : (&#39;a,list_name) seq =
      {decon = fun (List_name l) -&gt;
       match l with [] -&gt; None | h::t -&gt; Some (h,List_name t)}
    
    let 6 = sums list_seq (List_name [1;2;3])
</pre>
<p>There is still a bit of awkwardness remains: the user have to think up
the base name like <code>list_name</code> and the tag like <code>List_name</code>, and
ensure uniqueness.  Yallop and White automate using the module system,
see the code accompanying this page, or Yallop and White&#39;s paper (and
the Opam package `higher&#39;).
</p><p>We shall return to Yallop and White&#39;s approach later on this page,
with another perspective and implementation.</p></dd>
<dt><strong>References</strong></dt>
<dd>Jeremy Yallop and Leo White: Lightweight higher-kinded
polymorphism. FLOPS 2014.

<p><a href="https://okmij.org/ftp/ML/HKPoly_seq.ml">HKPoly_seq.ml</a> [11K]</p></dd></dl>


<h2><a name="avoid">Sidestepping higher-kinded polymorphism</a></h2>
<dl>
<dd>At times, higher-kinded polymorphism can be avoided altogether: upon
close inspection it may turn out that the problem at hand does not
actually require higher-kinded polymorphism. In fact, our running
example is such a problem.
<p>Let us examine the sequence interface,
parameterized both by the type of the sequence elements and the sequence
itself. The definition that first comes to mind, which cannot be written
as such in OCaml, is (from <a href="#intro">Introduction</a>):

</p><pre>    type (&#39;a,&#39;F) seq = {decon: &#39;a &#39;F -&gt; (&#39;a * &#39;a &#39;F) option}
</pre>It has a peculiarity: the sole operation <code>decon</code> consumes and produces
sequences of the same type <code>&#39;a &#39;F</code> (i.e., the same sort of sequence
with the elements of the same type). That is, <code>&#39;F</code>
always occurs as the type <code>&#39;a &#39;F</code>, where <code>&#39;a</code> is <code>seq</code>&#39;s parameter: <code>&#39;a</code> and
<code>&#39;F</code> do not vary independently. Therefore, there is actually
no higher-kinded polymorphism here. The sequence interface can be written
simply as 

<pre>    type (&#39;a,&#39;t) seq = {decon: &#39;t -&gt; (&#39;a * &#39;t) option}
</pre>with <code>folds</code> taking <em>exactly</em> the desired form:

<pre>    let rec folds (m: &#39;a monoid) (s: (&#39;a,&#39;t) seq) : &#39;t -&gt; &#39;a = fun c -&gt;
        match s.decon c with None -&gt; m.unit | Some (h,t) -&gt; m.op h (folds m s t)
</pre>It is the ordinary polymorphic function. There is no problem in using
it to define other such sequence-polymorphic functions, e.g.:

<pre>    let sums s c = folds monoid_plus s c
    (* val folds : &#39;a monoid -&gt; (&#39;a, &#39;t) seq -&gt; &#39;t -&gt; &#39;a = &lt;fun&gt; *)
</pre>and applying it, say, to a list:

<pre>    let list_seq : (&#39;a,&#39;a list) seq =
      {decon = function [] -&gt; None | h::t -&gt; Some (h,t)}
    
    let 6 = sums list_seq [1;2;3]
</pre>
<p><em>Exercise:</em> Consider the interface of collections that may be
`mapped&#39;, in the hypothetical OCaml with higher-kind type variables:

</p><pre>    type (&#39;a,&#39;b,&#39;F) ftor = {map: (&#39;a-&gt;&#39;b) -&gt; (&#39;a &#39;F -&gt; &#39;b &#39;F)}
</pre>Now <code>&#39;F</code> is applied to different types. Can this interface be still
expressed using the ordinary polymorphism, or higher-kinded
polymorphism is really needed here?
<p>Looking very closely at the higher-kinded polymorphic interface
<code>(&#39;a,&#39;F) seq</code> and the ordinary polymorphic <code>(&#39;a,&#39;t) seq</code>, one may
notice that the latter is larger. The higher-kinded interface
describes only polymorphic sequences such as <code>&#39;a list</code>, whereas
<code>(&#39;a,&#39;t) seq</code> applies also to files, strings, buffers, etc. Such an
enlargement is welcome here: we can apply the same <code>folds</code> to
sequences whose structure is optimized for the type of their
elements. In Haskell terms, <code>(&#39;a,&#39;t) seq</code> corresponds to `data
families&#39;, a later Haskell extension. Here is an
example, of applying <code>folds</code> to a string, which is not a polymorphic
sequence:

</p><pre>    let string_seq : (char,int*string) seq =
      {decon = fun (i,s) -&gt;
        if i &gt;= String.length s || i &lt; 0 then None else Some (s.[i], (i+1, s))}
    
    let &#39;c&#39; = folds monoid_maxchar string_seq (0,&#34;bca&#34;)
</pre>We can hence use <code>folds</code> with any collection, polymorphic or not, for
which there is an implementation of the <code>(&#39;a,&#39;t) seq</code> interface. We have
encountered the old, and very useful trick: enlarging the type but
restricting the set of its values by having to be able to define `witnesses&#39;
such as <code>(&#39;a,&#39;t) seq</code>.
<p><em>Exercise:</em> Yallop and White&#39;s approach can also deal with
non-polymorphic collections. Use it to implement <code>string_seq</code>.</p></dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/HKPoly_seq.ml">HKPoly_seq.ml</a> [11K]</dd></dl>


<h2><a name="algebra">Algebras</a></h2>
<dl>
<dd>The running example, the <code>seq</code> interface, was about deconstruction of
sequences: technically, about co-algebras. Let us now turn to
construction: building of values using a fixed set of operations,
which can be considered an embedded DSL. The abstraction over a DSL
implementation gives rise to polymorphism. If the embedded
DSL is typed, the polymorphism becomes higher-kinded -- as commonly seen
in DSL embeddings in tagless-final style.
<p>Here we briefly recount how the higher-kinded polymorphism arises in DSL
embeddings, and how it can be hidden away. The key idea is initial
algebra, which is, by definition, the abstraction over any concrete
algebra of the same signature, i.e., the abstraction over DSL implementations.
</p><p>Our running example in this section is a simple programming language
with integers and booleans: a dialect of the language used in Chap. 3
of Pierce&#39;s `Types and Programming Languages&#39; (TAPL). Here is the familiar
tagless-final embedding in OCaml. The grammar of the language is
represented as an OCaml signature:

</p><pre>    module type sym = sig
      type &#39;a repr
      val int    : int -&gt; int repr
      val add    : int repr -&gt; int repr -&gt; int repr
      val iszero : int repr -&gt; bool repr
      val if_    : bool repr -&gt; &#39;a repr -&gt; &#39;a repr -&gt; &#39;a repr
    end
</pre>The language is typed; therefore, the type <code>&#39;a repr</code>, which represents DSL
terms, is indexed by the term&#39;s type: an <code>int</code> or a <code>bool</code>. The
signature <code>sym</code> also defines the type system of the DSL: almost like
in TAPL, but with the typing rules written in a
vertical-space--economic way.
<p>Here is a sample term of the DSL:

</p><pre>    module SymEx1(I:sym) = struct
      open I
      let t1 = add (add (int 1) (int 2)) (int 3) (* intermediate binding *)
      let res = if_ (iszero t1) (int 0) (add t1 (int 1))
    end
</pre>It is written as a functor parameterized by <code>sym</code>: a DSL
implementation is abstracted out. The term is  polymorphic over
<code>sym</code> and, hence, may be evaluated in any implementation of the DSL. Since
<code>sym</code> contains a higher-kinded type <code>repr</code>, the polymorphism is
higher-kinded.
<p>The just presented (tagless-final) DSL embedding followed the
approach described in [<a href="#functors">Higher-kinded functions as Functors</a>]. Let us move away from functors
to ordinary terms. Actually, we never quite escape functors, but we
hide them in terms, relying on first-class modules.
As we have seen, a DSL term of the type <code>int</code> such as <code>SymEx1</code> is the functor

</p><pre>    functor (I:sym) -&gt; sig val res : int I.repr end
</pre>To abstract over <code>int</code>, we wrap it into a module

<pre>    module type symF = sig
      type a
      module Term(I:sym) : sig val res : a I.repr end
    end
</pre>which can then be turned into ordinary polymorphic type:

<pre>    type &#39;a sym_term = (module (symF with type a = &#39;a))
</pre>which lets us represent the functor <code>SymEx1</code> as an ordinary OCaml value:

<pre>    let sym_ex1 : _ sym_term = 
      (module struct type a = int module Term = SymEx1 end)
</pre>Here, the type annotation is needed. However, we let the type of the term
to be <code>_</code>, as a schematic variable. OCaml infers it as <code>int</code>.
If we have an implementation of <code>sym</code>, say, module <code>R</code>, we can use it
to run the example (and obtain the <code>sym_ex1</code>&#39;s value in <code>R</code>&#39;s interpretation):

<pre>    let _ = let module N = (val sym_ex1) in 
            let module M = N.Term(R) in M.res
</pre>
<p>The type <code>&#39;a sym_term</code> can itself implement the <code>sym</code> signature, in 
a `tautological&#39; sort of way:

</p><pre>    module SymSelf : (sym with type &#39;a repr = &#39;a sym_term) = struct
      type &#39;a repr = &#39;a sym_term
      let int : int -&gt; int repr = fun n -&gt;
        let module M(I:sym) = struct let res = I.int n end in
        (module struct type a = int module Term = M end)
      let add : int repr -&gt; int repr -&gt; int repr = fun (module E1) (module E2) -&gt;
        let module M(I:sym) = 
          struct module E1T = E1.Term(I) module E2T = E2.Term(I)
                 let res = I.add (E1T.res) (E2T.res) 
          end in
        (module struct type a = int module Term = M end)
       ...
    end
</pre>That was a mouthful. But writing <code>sym</code> DSL terms becomes much
easier, with no functors and no type annotations. The earlier <code>sym_ex1</code>
can now be written as

<pre>    let sym_ex1 = 
      let open SymSelf in
      let t1 = add (add (int 1) (int 2)) (int 3) in (* intermediate binding *)
      if_ (iszero t1) (int 0) (add t1 (int 1))
</pre>It can be evaluated in <code>R</code> or other implementation as shown before.
<p>Technically, <code>SymSelf</code> is the initial algebra: an implementation of
the DSL that can be mapped to any other implementation, and in a
unique way. That means its terms like <code>sym_ex1</code> can be evaluated in
any <code>sym</code> DSL implementation: they are polymorphic over DSL implementation.
</p><p>On the down-side, we have <code>SymSelf</code>, which is the epitome of
boilerplate: utterly trivial and voluminous code that has to be
written. On the up side, writing DSL terms cannot be easier: no type
annotations, no functors, no implementation passing -- and no overt
polymorphism, higher-kind or even the ordinary kind. Still, the terms
can be evaluated in any implementation of the DSL.
</p><p><em>Exercise:</em> Apply Yallop and White&#39;s method to this DSL
example. Hint: the first example in Yallop and White&#39;s paper, monad
representations, is an example of a DSL embedding in tagless-final
style.</p></dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/HKPoly_tf.ml">HKPoly_tf.ml</a> [13K]</dd></dl>


<h2><a name="hkname">What&#39;s in a higher-kinded type name</a></h2>
<dl>
<dd>We now look back at Yallop and White&#39;s approach of reducing
higher-kinded polymorphism to the ordinary polymorphism, from a
different perspective. It gives if not a new insight, at least new
implementations.
<p>A polymorphic type like <code>&#39;a list</code> represents a family of types,
indexed by a type (of list elements, in this example). A higher-kinded
type abstraction such as <code>&#39;a &#39;F</code> with the hypothetical (in OCaml)
higher-kind type variable <code>&#39;F</code> is the abstraction over a family name,
so to speak, while still keeping track of the index. Here is another
way of accomplishing such an abstraction. 
</p><p>Consider the existential type <code>exists a. a list</code> (realizable in OCaml
in several ways, although not in the shown notation. We will keep the
notation for clarity). The existential is now the ordinary, rank <code>*</code>
type and can be abstracted in a type variable, e.g., <code>&#39;d</code>. The `family
name&#39; is, hence, the family type with the hidden index. We have
lost track of the index, however. Therefore, we tack it back, ending
up with the type <code>(&#39;a,&#39;d) hk</code>. Thus <code>(t,exists a. a list) hk</code> is meant
to be the same as <code>t list</code> (for any type <code>t</code>).
</p><p>There is a problem however: <code>(&#39;a,&#39;d) hk</code> is a much bigger type. We
need the condition that in <code>(t,exists a. a list) hk</code>, the index <code>t</code> is
exactly the one that we hid in the existential quantification -- we
need dependent pairs, not supported in OCaml. Remember the old trick,
however: we may have a bigger type so long as we control the producers
of its values and ensure only the values satisfying the condition are
built. To be concrete, we must make certain that the only way to
produce <code>(&#39;a,&#39;d) hk</code> values is by using functions like <code>inj: &#39;a list -&gt; (&#39;a, exists a. a list) hk</code> that expose the same index they hide.
At some point the type checker will demand a
proof: when implementing the
inverse mapping <code>(&#39;a, exists a. a list) hk -&gt; &#39;a list</code> and extracting
the list out of the existential. There are several ways of going about
the proof.
</p><p>The simplest is to give our word -- that the condition always holds for
all <code>(&#39;a,&#39;d) hk</code> values actually produced, and we have a proof of that
on some piece of paper or in a <code>.v</code> file. This leads to the exceptionally
simple implementation, which does nothing at all
(all of its operations are the identity).

</p><pre>    module HK : sig
      type (&#39;a,&#39;d) hk                       (* abstract *)
      module MakeHK : functor (S: sig type &#39;a t end) -&gt; sig
        type anyt                           (* also abstract *)
        val inj : &#39;a S.t -&gt; (&#39;a,anyt) hk
        val prj : (&#39;a,anyt) hk -&gt; &#39;a S.t
      end
     end = struct
      type (&#39;a,&#39;d) hk = &#39;d
      module MakeHK(S:sig type &#39;a t end) = struct
        type anyt = Obj.t
        let inj : &#39;a S.t -&gt; (&#39;a,anyt) hk = Obj.repr
        let prj : (&#39;a,anyt) hk -&gt; &#39;a S.t = Obj.obj
      end
    end
</pre>The accompanying code shows a different, also quite simple
implementation without any <code>Obj</code> magic.
<p>After enriching the <code>sym</code> signature of the DSL from the previous
section with fake higher-kinded types:

</p><pre>    module type sym_hk = sig
      include sym
      include module type of HK.MakeHK(struct type &#39;a t = &#39;a repr end)
    end
</pre>we can write the earlier <code>SymEx1</code> example as a function (a term)
rather than a functor:

<pre>    let sym_ex1 (type d) (module I:(sym_hk with type anyt=d)) : (_,d) HK.hk =
      let open I in
      let t1 = add (add (int 1) (int 2)) (int 3) |&gt; inj in (* intermediate term *)
      let res = if_ (iszero t1) (int 0) (add t1 (int 1)) in
      inj res
</pre>It can be evaluated simply as

<pre>    sym_ex1 (module RHK) |&gt; RHK.prj
</pre>where <code>RHK</code> is a module implementing <code>sym_hk</code>. Incidentally, if <code>SHK</code>
is another module implementing <code>sym_hk</code> and we attempt
<code>sym_ex1 (module RHK) |&gt; SHK.prj</code>, we discover that
<code>(int,RHK.anyt) bk</code> and <code>(int,SHK.anyt) bk</code> are actually different
types. Although <code>HK</code> does not do anything (at runtime), it does
maintain safety and soundness.</dd>
<dt><strong>References</strong></dt>
<dd><a href="https://okmij.org/ftp/ML/HKPoly_tf.ml">HKPoly_tf.ml</a> [13K]</dd></dl>


<h2><a name="conc">Conclusions</a></h2>
<dl>
<dd>We have surveyed various ways of abstracting over a type
constructor -- or, writing interface-parameterized terms
when the interface involves a polymorphic type. Even if the
language does not support type-constructor--polymorphism directly,
such interface parameterization can still be realized, as:

<ul>
<li>interface abstraction as a functor abstraction
</li>
<li>reducing higher-kinded polymorphism to ordinary polymorphism,
by establishing a bijection between type constructors and
ordinary types
</li>
<li>hiding the polymorphism over DSL implementations
behind initial algebra
(if the interface is algebraic, as often happens in tagless-final
DSL embeddings)
</li>
<li>and in some problems, higher-kinded polymorphism is not actually
needed, on close inspection
</li></ul></dd></dl>
</div>
  </body>
</html>
