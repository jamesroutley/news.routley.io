<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://doeken.org/blog/coroutines-in-php">Original</a>
    <h1>Exploring Coroutines in PHP</h1>
    
    <div id="readability-page-1" class="page"><div>
                <p>The term &#34;coroutine&#34; often comes up when talking about asynchronous or non-blocking code, but what does it actually mean? In this post, we will explore coroutines as a concept and see how PHP supports them through Generators and Fibers. Whether you&#39;re building pipelines, CLI tools, or preparing to dive into concurrency, understanding coroutines is an essential first step.</p>

<h2>What are Coroutines?</h2>

<p>A coroutine is a function. However, where a regular function continuously runs from top to bottom until it is finished, a coroutine can pause/suspend itself and be resumed. It can return a value every time it suspends, and receive a value when it is resumed. While the coroutine is suspended and not yet finished, it will hold on to the current state it is in.</p>

<h3>Suspend and resume</h3>

<p>Once a coroutine is executed, it will start performing its task. During the execution, the coroutine can suspend itself, handing over control to the rest of the code. This means that the suspension of the execution can only originate <em>inside</em> the coroutine. It has to voluntarily release control (dare I say it should <code>yield</code>? Spoilers!)</p>

<p>After that, the fate of the coroutine is in the hands of the rest of the code. It cannot resume itself. The coroutine will have to be explicitly given control back with the instruction to resume. Until then, it waits while the rest of the code runs.</p>

<blockquote>
  <p><strong>Note</strong>: The other code could continue and never call the coroutine again, leaving it in its suspended state. Once the other code finishes, the program ends. It will not have to wait for the coroutine to finish.</p>
</blockquote>

<h3>Return and receive values</h3>

<p>When a coroutine suspends its execution, it can provide a value to go with that. This makes the suspension like a return statement. And because a coroutine can resume and suspend multiple times, it can return multiple values.</p>

<p>A coroutine can also receive a value when it is resumed. It will have this value available immediately after resuming and can act on it. This makes a coroutine bi-directional.</p>

<p>While returning and receiving values is <strong>possible</strong> in a coroutine, it is not <em>required</em>. A coroutine can just suspend its execution without doing anything else.</p>

<h3>Hold its state</h3>

<p>When a regular function is called, any internal parameters it creates to hold values are released from memory as soon as the function finishes. You can call a function multiple times, but the values from the first call will not be available in the function the second time it is called.</p>

<p>Since a coroutine is a function that can suspend and resume, values that are scoped inside the coroutine stay available while it hasn&#39;t finished. When the coroutine regains control and resumes its execution, it can still reference those variables. Only when the coroutine is finished are its internal variables released from memory.</p>

<h3>Types of coroutines</h3>

<p>Coroutines come in a few flavors. They can either be <strong>symmetrical or asymmetrical</strong>, and <strong>stackless or stackful</strong>.</p>

<h4>Asymmetrical vs. Symmetrical Coroutines</h4>

<p>When it comes to suspending its execution, as we now know, the control must be released by the coroutine. An <strong>asymmetrical</strong> coroutine can only release control <em>back</em> to the code that called the coroutine. A <strong>symmetrical</strong> coroutine can choose to whom it releases control, either a different coroutine or the original caller.</p>

<p>Let&#39;s imagine coroutines are playing a game of <strong>hot potato</strong>.</p>

<p>In an <strong>asymmetrical game</strong>, the main program <strong>always passes the potato to a coroutine</strong>, which can <strong>only toss it back to the caller</strong>, not to another coroutine.</p>

<p>In a <strong>symmetrical game</strong>, coroutines can <strong>pass the potato among themselves</strong>, deciding who goes next. The main program will start and end the game, but doesn‚Äôt have to control every pass.</p>

<blockquote>
  <p><strong>Note</strong>: Even in a symmetrical coroutine situation, at some point, the control must be released back to the original calling code for the program to finish. Otherwise, it would hang indefinitely.</p>
</blockquote>

<h4>Stackless vs. Stackful Coroutines</h4>

<p>Finally, there are stackless and stackful coroutines. The difference lies in where they are allowed to suspend execution.</p>

<p>A <strong>Stackless Coroutine</strong> can only yield control from its <em>outermost function</em>. While it can call other (nested) functions, it cannot suspend from within them.</p>

<p>A <strong>Stackful Coroutine</strong>, on the other hand, <em>can</em> suspend from within nested functions. It will release its control right there, and when it is resumed, it will resume from that exact location.</p>

<p>As a result, stackful coroutines are more flexible, since they allow suspension inside helper functions. This can reduce verbosity and keep the focus on the core logic.</p>

<h2>How are coroutines implemented in PHP?</h2>

<p>Now that we know the conditions that can make up a coroutine, let&#39;s see how PHP implements or facilitates coroutines.</p>

<h3>Coroutines using Generators</h3>

<p>The first introduction of Coroutines in PHP came with version 5.5 in the form of <a href="https://www.php.net/manual/en/language.generators.overview.php">Generators</a>.</p>

<p>Now, most developers know Generators as memory-preserving iterators. And if you haven&#39;t yet, I&#39;d highly recommend reading my earlier post <a href="https://doeken.org/blog/generators-over-arrays">Generators over Arrays</a> where I go into detail on how Generators can be used like this. But as we&#39;ll see, they are much more than just iterators.</p>

<p>As a quick reminder, here is an example of a Generator that yields a few values.</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>function</span><span> </span><span>exampleGenerator</span><span>():</span><span> </span><span>Generator</span><span> </span><span>{</span></p><p><span>    </span><span>echo</span><span> </span><span>&#34;</span><span>Started</span><span>&#34;</span><span>;</span></p><p><span>    </span><span>$</span><span>value </span><span>=</span><span> </span><span>4</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>1</span><span>;</span></p><p><span>    </span><span>yield</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>3</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>$</span><span>value</span><span>;</span></p><p><span>}</span></p><p><span>$</span><span>generator </span><span>=</span><span> </span><span>exampleGenerator</span><span>();</span></p></code></pre>

<p>So, how is this Generator also a coroutine? Let&#39;s examine the conditions we&#39;ve talked about so far.</p>

<h4>It can pause its execution</h4>

<p>When we call <code>$generator = exampleGenerator()</code>, it only returns the <code>Generator</code> instance. The code inside it has not yet been started. The generator will start when any function is called on it.</p>

<p>If we call <code>$result = $generator-&gt;current()</code>, for example, the first part of the code will run. It will echo <code>Started</code>, set the parameter of <code>$value</code> to <code>4</code>, and then it will pause its execution and <code>yield</code> control back.</p>

<h4>It can return a value</h4>

<p>Now that the execution is paused, the generator has also returned the value of <code>1</code>. We can see that when we dump the value of <code>$result</code>.</p>

<h4>It can be resumed</h4>

<p>When the generator is paused, we can do anything we want in our calling code. Send an email, write a log, <code>sleep</code> for a bit. But we can also resume the generator by calling <code>$generator-&gt;next()</code>. At this point, the generator will resume its code until it hits the next pause or <code>yield</code> keyword. If we call <code>$generator-&gt;current()</code> again, it will have a value of <code>null</code>, because the next <code>yield</code> keyword does not specify a value to be returned. It simply pauses execution.</p>

<h4>It remembers its state</h4>

<p>If we were to call <code>$generator-&gt;next()</code> two more times, it would be at the <code>yield $value</code> line. To prove that it has remembered its earlier state of the <code>$value</code> parameter, we can inspect <code>$generator-&gt;current()</code> and lo and behold, it will have the value <code>4</code>.</p>

<blockquote>
  <p><strong>Note:</strong> When using a Generator as an iterator with <code>foreach($generator as $key =&gt; $result)</code>, internally it will also use these methods. After calling <code>$generator-&gt;rewind()</code> once, it will call these methods for every iteration:</p>
  
  <ul>
  <li><code>$generator-&gt;valid()</code> - to make sure it has more values</li>
  <li><code>$generator-&gt;key()</code> - to return the value to <code>$key</code></li>
  <li><code>$generator-&gt;current()</code> - to return the value to <code>$result</code></li>
  <li>The body of the foreach loop runs</li>
  <li><code>$generator-&gt;next()</code> - to resume to the next <code>yield</code></li>
  </ul>
</blockquote>

<p>Here is the full code so far if you want to try it out:</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>function</span><span> </span><span>exampleGenerator</span><span>():</span><span> </span><span>Generator</span><span> </span><span>{</span></p><p><span>    </span><span>echo</span><span> </span><span>&#34;</span><span>Started</span><span>&#34;</span><span>;</span></p><p><span>    </span><span>$</span><span>value </span><span>=</span><span> </span><span>4</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>1</span><span>;</span></p><p><span>    </span><span>yield</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>3</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>$</span><span>value</span><span>;</span></p><p><span>}</span></p><p><span>$</span><span>generator </span><span>=</span><span> </span><span>exampleGenerator</span><span>();</span></p><p><span>$</span><span>result </span><span>=</span><span> </span><span>$</span><span>generator</span><span>-&gt;</span><span>current</span><span>();</span></p><p><span>var_dump</span><span>($</span><span>result</span><span>);</span><span> </span><span>// int(1)</span></p><p><span>// Other code, send email, log, sleep...</span></p><p><span>$</span><span>generator</span><span>-&gt;</span><span>next</span><span>();</span><span> </span><span>// Restart coroutine</span></p><p><span>var_dump</span><span>($</span><span>generator</span><span>-&gt;</span><span>current</span><span>());</span><span> </span><span>// NULL</span></p><p><span>$</span><span>generator</span><span>-&gt;</span><span>next</span><span>();</span><span> </span><span>// Current value = 3</span></p><p><span>$</span><span>generator</span><span>-&gt;</span><span>next</span><span>();</span></p><p><span>var_dump</span><span>($</span><span>generator</span><span>-&gt;</span><span>current</span><span>());</span><span> </span><span>// int(4)</span></p></code></pre>

<h4>It can receive a value (?!)</h4>

<p>Wait, what? Yes, it can. Well, our current example can&#39;t, but a Generator in general <strong>can</strong> receive a value when it resumes. To let the generator receive a value, it must be called with <code>$generator-&gt;send($value)</code>. So, where does this value enter the coroutine? Right after the last <code>yield</code>. Or better yet, &#34;before&#34;. Let me explain with an example:</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>function</span><span> </span><span>coroutine</span><span>():</span><span> </span><span>Generator</span><span> </span><span>{</span></p><p><span>    </span><span>$</span><span>received </span><span>=</span><span> </span><span>yield</span><span> </span><span>&#39;</span><span>Hello from the Coroutine</span><span>&#39;</span><span>;</span></p><p><span>    </span><span>yield</span><span> </span><span>&#34;</span><span>Received: </span><span>&#34;.</span><span> </span><span>$</span><span>received</span><span>;</span></p><p><span>}</span></p><p><span>$</span><span>coroutine </span><span>=</span><span> </span><span>coroutine</span><span>();</span></p><p><span>$</span><span>result </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>current</span><span>();</span></p><p><span>var_dump</span><span>($</span><span>result</span><span>);</span><span> </span><span>// Hello from the Coroutine</span></p><p><span>$</span><span>next </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>send</span><span>(</span><span>&#39;</span><span>Greetings from the code</span><span>&#39;</span><span>);</span></p><p><span>var_dump</span><span>($</span><span>next</span><span>);</span><span> </span><span>// Received: Greetings from the code.</span></p></code></pre>

<p>In this example, the Generator will be started by the <code>current()</code> method and immediately paused. During its suspension, the value the Generator returns will be <code>Hello from the Coroutine</code>.</p>

<p>The <code>Generator::send()</code> method not only sends the value, but it also instructs the Generator to resume its execution. At that point, the Generator will set the value of <code>$received</code> to the value it received from <code>send()</code> and <code>yield</code> it back prefixed by <code>Received:</code>. The result of the <code>-&gt;send()</code> will therefore be: <code>Received: Greetings from the Coroutine</code>.</p>

<p>You can also use <code>-&gt;throw(\Throwable $exception)</code> to throw an exception back into the Generator. It will be as if the 
current <code>yield</code> statement were replaced by that exception.</p>

<p>So, to summarize, the <code>yield</code> keyword can be used in different ways:</p>

<ul>
<li><code>yield;</code> Suspends the execution, returns nothing</li>
<li><code>yield $value;</code> Suspends and returns <code>$value</code></li>
<li><code>$received = yield;</code> Suspends, returns nothing, able to receive either a value to <code>$received</code>, or an exception</li>
<li><code>$received = yield $value;</code> Suspends, returns <code>$value</code>, able to receive either a value to <code>$received</code>, or an exception</li>
</ul>

<h4>It is Asymmetrical and Stackless</h4>

<p>As we&#39;ve seen, the <code>yield</code> keyword makes a function a coroutine, because it pauses the execution and releases control. However, it can not release control to any other coroutine. This would require a <code>yield to</code> syntax, which doesn&#39;t exist.</p>

<p>While a generator can start (and consume) a different generator, this isn&#39;t technically symmetrical because it is not releasing its control. It only starts the other generator, while it also still runs itself. This makes a generator an <strong>Asymmetric Coroutine</strong>.</p>

<p>Finally, a generator cannot be suspended from a nested function. This is because the <code>yield</code> keyword inside a function will make it return a <code>Generator</code>. So, when you call <code>yield</code> in a nested function, it becomes a generator, instead of suspending the parent. This lack of call stack awareness makes the generator a <strong>Stackless Coroutine</strong>.</p>

<h3>Coroutines using Fibers</h3>

<p>If you are anything like me, when PHP 8.1 introduced <a href="https://www.php.net/manual/en/language.fibers.php">Fibers</a>, you might have read about them and thought <em>&#34;ü§Ø this isn&#39;t for me&#34;</em>. And to be honest, it might very well not be. However, I think with the context of coroutines and generators, it is much easier to understand and see their use cases.</p>

<p>Where a <code>Generator</code> itself is a stackless coroutine, Fibers represent a toolbox that you can use to implement a stackful coroutine. Let&#39;s take a look at our last example,  written with Fibers.</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>$</span><span>coroutine </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>()</span><span> </span><span>{</span></p><p><span>    </span><span>$</span><span>received </span><span>=</span><span> </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Hello from the Coroutine</span><span>&#39;</span><span>);</span></p><p><span>    </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Received: </span><span>&#39;</span><span> </span><span>.</span><span> </span><span>$</span><span>received</span><span>);</span></p><p><span>});</span></p><p><span>$</span><span>result </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>start</span><span>();</span></p><p><span>var_dump</span><span>($</span><span>result</span><span>);</span><span> </span><span>// Hello from the Coroutine</span></p><p><span>$</span><span>next </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>resume</span><span>(</span><span>&#39;</span><span>Hello from the code</span><span>&#39;</span><span>);</span></p><p><span>var_dump</span><span>($</span><span>next</span><span>);</span><span> </span><span>// Received: Hello from the code</span></p></code></pre>

<p>With Fibers, the coroutine is now wrapped inside a <code>Fiber</code> instance. After that, you need to explicitly <code>start()</code> the <code>Fiber</code> instance.</p>

<blockquote>
  <p><strong>Note</strong>: any arguments you pass to the <code>start()</code> method will be provided to the callback function, just like it would when you call a generator function with arguments.</p>
</blockquote>

<h4>Suspending and resuming</h4>

<p>Just like in our previous generator example, a fiber can suspend its execution. Where the generator uses more iterator function names, because it is mostly used as such, a fiber&#39;s methods are very semantic: <code>Fiber::suspend()</code> and <code>$fiber-&gt;resume()</code>.</p>

<p>So why is <code>::suspend()</code> a static method, and <code>-&gt;resume()</code> a non-static method? This has to do with the call stack.
Unlike a generator, a <code>Fiber</code> has its own call stack. This means that suspension can happen deep within nested functions, not just at the top level. However, neither those nested functions nor the callback that starts the fiber have access to a <code>$this</code> variable representing the currently running instance.</p>

<p>This is where the static <code>Fiber::suspend()</code> function comes in. Because a fiber knows its call stack, <code>Fiber::suspend</code> can determine the closest instance it is being called in, and suspend it.</p>

<p>And because a coroutine can&#39;t resume itself, the instance must be resumed from the outside. This is why the instance has a public non-static method <code>resume()</code>.</p>

<h4>Returning and Receiving values &amp; Exceptions</h4>

<p>Just like a generator, a Fiber can return multiple values. Whenever you call <code>Fiber::suspend($value)</code>, you can provide a value that will be returned. A fiber will receive any value that is provided to the <code>$fiber-&gt;resume($value)</code> method.</p>

<p>You can also resume a fiber by throwing a <code>Throwable $exception</code> at it. This allows the Fiber to respond to different types of communication. You can send the fiber an exception by calling <code>$fiber-&gt;throw($exception)</code>. Inside your callback function, you should guard against this by wrapping (at least) the current <code>Fiber::suspend()</code> call in a <strong>try-catch</strong> block.</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>$</span><span>coroutine </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>()</span><span> </span><span>{</span></p><p><span>    </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Hello from the fiber.</span><span>&#39;</span><span>);</span></p><p><span>    </span><span>try</span><span> </span><span>{</span></p><p><span>       </span><span>$</span><span>received </span><span>=</span><span> </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Give me something.</span><span>&#39;</span><span>);</span></p><p><span>       </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>sprintf</span><span>(</span><span>&#39;</span><span>You gave me a value of &#34;%s&#34;: </span><span>&#39;</span><span>,</span><span> </span><span>$</span><span>received</span><span>));</span></p><p><span>    </span><span>}</span><span> </span><span>catch</span><span> </span><span>(\</span><span>Throwable</span><span> </span><span>$</span><span>e</span><span>)</span><span> </span><span>{</span></p><p><span>       </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>sprintf</span><span>(</span><span>&#39;</span><span>You gave me this exception: &#34;%s&#34;.</span><span>&#39;</span><span>,</span><span> </span><span>$</span><span>e</span><span>-&gt;</span><span>getMessage</span><span>()));</span></p><p><span>    </span><span>}</span></p><p><span>}</span><span> </span><span>);</span></p><p><span>$</span><span>hello </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>start</span><span>();</span></p><p><span>var_dump</span><span>($</span><span>hello</span><span>);</span><span> </span><span>// Hello from the fiber.</span></p><p><span>$</span><span>message </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>resume</span><span>(</span><span>&#39;</span><span>Hello from the code</span><span>&#39;</span><span>);</span></p><p><span>var_dump</span><span>($</span><span>message</span><span>);</span><span> </span><span>// Give me something.</span></p><p><span>$</span><span>result </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>throw</span><span>(</span><span> </span><span>new</span><span> </span><span>Exception</span><span>(</span><span> </span><span>&#39;</span><span>Exception from the code</span><span>&#39;</span><span> </span><span>)</span><span> </span><span>);</span></p><p><span>var_dump</span><span>($</span><span>result</span><span>);</span><span> </span><span>// You gave me this exception: &#34;Exception from the code&#34;.</span></p></code></pre>

<blockquote>
  <p><strong>Note</strong>: While a local catch is possible, a better approach would be to wrap your entire callback function body. Because an exception is always thrown from the outside, the callback does not control the exceptions, so it should always expect them.</p>
</blockquote>

<h4>Nested suspension</h4>

<p>We have seen that a Generator cannot be suspended from a nested function, as that would become a Generator itself. With Fibers, however, it <strong>is possible</strong> to have a nested function call that will suspend the current Fiber. This allows you to use helper functions, which can keep your code more DRY, more semantic, and easier to understand.</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>final</span><span> </span><span>class</span><span> </span><span>Logger</span><span> </span><span>{</span></p><p><span>    </span><span>public</span><span> </span><span>function</span><span> </span><span>warning</span><span>(</span><span>string</span><span> </span><span>$</span><span>message</span><span>):</span><span> </span><span>void</span><span> </span><span>{</span></p><p><span>       </span><span>echo</span><span> </span><span>$</span><span>message</span><span>;</span></p><p><span>    </span><span>}</span></p><p><span>}</span></p><p><span>function</span><span> </span><span>get_logger</span><span>():</span><span> </span><span>?</span><span>Logger</span><span> </span><span>{</span></p><p><span>    </span><span>try</span><span> </span><span>{</span></p><p><span>       </span><span>$</span><span>logger </span><span>=</span><span> </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span> </span><span>&#39;</span><span>Waiting for a logger instance...</span><span>&#39;</span><span> </span><span>);</span></p><p><span>       </span><span>return</span><span> </span><span>$</span><span>logger </span><span>instanceof</span><span> </span><span>Logger</span><span> </span><span>?</span><span> </span><span>$</span><span>logger </span><span>:</span><span> </span><span>null;</span></p><p><span>    </span><span>}</span><span> </span><span>catch</span><span> </span><span>(</span><span>Throwable</span><span>)</span><span> </span><span>{</span></p><p><span>       </span><span>return</span><span> </span><span>null;</span></p><p><span>    </span><span>}</span></p><p><span>}</span></p><p><span>$</span><span>coroutine </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>()</span><span> </span><span>{</span></p><p><span>    </span><span>$</span><span>message </span><span>=</span><span> </span><span>&#39;</span><span>I am a message that needs to be logged.</span><span>&#39;</span><span>;</span></p><p><span>    </span><span>$</span><span>logger </span><span>=</span><span> </span><span>get_logger</span><span>();</span></p><p><span>    </span><span>$</span><span>logger</span><span>?-&gt;</span><span>warning</span><span>($</span><span>message</span><span>);</span></p><p><span>});</span></p><p><span>$</span><span>message </span><span>=</span><span> </span><span>$</span><span>coroutine</span><span>-&gt;</span><span>start</span><span>();</span></p><p><span>var_dump</span><span>($</span><span>message</span><span>);</span><span> </span><span>// Waiting for a logger instance...</span></p><p><span>$</span><span>coroutine</span><span>-&gt;</span><span>resume</span><span>(</span><span>new</span><span> </span><span>Logger</span><span>());</span><span> </span><span>// I am a message that needs to be logged.</span></p></code></pre>

<p>In this example, we can see that the Fiber callback function does not explicitly suspend its execution. However, the <code>get_logger</code> helper function does. The code is suspended right there, and the control is handed off to the caller. When the caller resumes the coroutine with a new <code>Logger</code>, the coroutine also resumes right there in the nested function. It validates the input, returns the logger, and the coroutine continues. This makes the Fiber a <strong>Stackful Coroutine</strong>.</p>

<h4>Fibers are also Asymmetrical</h4>

<p>It would be cool if it all came full circle, and I told you that Fibers were also symmetrical. But unfortunately, that&#39;s not the case. Just like the <code>yield</code> keyword, the <code>Fiber::suspend()</code> method does not allow for suspending to a specific coroutine. It, too, can only release control to the caller, making the use of Fibers an <strong>Asymmetric Coroutine</strong>.</p>

<p>Just like in a Generator, calling <code>start()</code> or <code>resume()</code> on a different coroutine does not pause the current one. Here is a quick example that proves that:</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>$</span><span>a </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>(</span><span>Fiber</span><span> </span><span>$</span><span>b</span><span>)</span><span> </span><span>use</span><span> </span><span>(</span><span>&amp;</span><span>$</span><span>a</span><span>)</span><span> </span><span>{</span></p><p><span>    </span><span>echo</span><span> </span><span>&#34;</span><span>starting B</span><span>\n</span><span>&#34;</span><span>;</span></p><p><span>    </span><span>$</span><span>b</span><span>-&gt;</span><span>start</span><span>($</span><span>a</span><span>);</span></p><p><span>});</span></p><p><span>$</span><span>b </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>(</span><span>Fiber</span><span> </span><span>$</span><span>a</span><span>)</span><span> </span><span>{</span></p><p><span>    </span><span>echo</span><span> </span><span>&#34;</span><span>Resuming A</span><span>\n</span><span>&#34;</span><span>;</span></p><p><span>    </span><span>$</span><span>a</span><span>-&gt;</span><span>resume</span><span>();</span><span> </span><span>// FiberError: Cannot resume a fiber that is not suspended</span></p><p><span>});</span></p><p><span>$</span><span>a</span><span>-&gt;</span><span>start</span><span>($</span><span>b</span><span>);</span></p></code></pre>

<p>In this example, <code>$a</code> starts <code>$b</code>, and in turn, <code>$b</code> wants to resume <code>$a</code>. But because there was no handoff of control and suspension, <code>$a</code> is still running, resulting in an exception.</p>

<p>However, just because Fibers aren‚Äôt symmetrical doesn‚Äôt mean they‚Äôre useless or no better than Generators. Their stackful nature and added expressiveness make them a powerful tool in their own right.</p>

<h3>Comparing Generators and Fibers</h3>

<p>Now that we&#39;ve explored both, let&#39;s compare Generators and Fibers side by side to see how they differ.</p>

<table>
<thead>
<tr>
  <th>Capability</th>
  <th><strong>Generator</strong></th>
  <th><strong>Fibers</strong></th>
</tr>
</thead>
<tbody>
<tr>
  <td>Suspend / Resume</td>
  <td>‚úÖ <code>yield</code>, <code>-&gt;next()</code></td>
  <td>‚úÖ <code>Fiber::suspend()</code>, <code>-&gt;resume()</code></td>
</tr>
<tr>
  <td>Return Values</td>
  <td>‚úÖ via <code>yield $value</code></td>
  <td>‚úÖ via <code>Fiber::suspend($value)</code></td>
</tr>
<tr>
  <td>Receive Values</td>
  <td>‚úÖ via <code>-&gt;send($value)</code></td>
  <td>‚úÖ via <code>-&gt;resume($value)</code></td>
</tr>
<tr>
  <td>Exception Handling</td>
  <td>‚úÖ via <code>-&gt;throw($exception)</code></td>
  <td>‚úÖ via <code>-&gt;throw($exception)</code></td>
</tr>
<tr>
  <td>Symmetrical</td>
  <td>‚ùå Always resumes to original caller</td>
  <td>‚ùå Always resumes to original caller</td>
</tr>
<tr>
  <td>Stackful</td>
  <td>‚ùå Cannot suspend in nested functions</td>
  <td>‚úÖ Can suspend from within nested functions</td>
</tr>
<tr>
  <td>Iterator Integration</td>
  <td>‚úÖ Implements <code>Iterator</code> (great for <code>foreach</code>)</td>
  <td>‚ùå Not iterable ‚Äî requires manual handling</td>
</tr>
</tbody>
</table>

<h2>What are Coroutines useful for in PHP?</h2>

<p>The ability to pause code execution, have bidirectional I/O, and retain its current state makes coroutines a good candidate for various use cases. Let&#39;s have a look at some possibilities.</p>

<h3>State processing</h3>

<p>Because coroutines can retain their state between invocations, they are useful as state machines, chatbots, pipelines, and command-line (CLI) tools.</p>

<p>Let&#39;s look at a simple command-line tool that asks some questions to produce a final output.</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>$</span><span>cli </span><span>=</span><span> </span><span>(</span><span>function</span><span> </span><span>()</span><span> </span><span>{</span></p><p><span>    </span><span>$</span><span>state </span><span>=</span><span> </span><span>[];</span></p><p><span>    </span><span>$</span><span>state</span><span>[</span><span>&#39;</span><span>name</span><span>&#39;</span><span>]</span><span> </span><span>=</span><span> </span><span>yield</span><span> </span><span>&#39;</span><span>What is your name?</span><span>&#39;</span><span>;</span></p><p><span>    </span><span>$</span><span>state</span><span>[</span><span>&#39;</span><span>age</span><span>&#39;</span><span>]</span><span> </span><span>=</span><span> </span><span>yield</span><span> </span><span>&#39;</span><span>How old are you?</span><span>&#39;</span><span>;</span></p><p><span>    </span><span>return</span><span> </span><span>$</span><span>state</span><span>;</span></p><p><span>})();</span></p><p><span>$</span><span>cli</span><span>-&gt;</span><span>rewind</span><span>();</span></p><p><span>while</span><span> </span><span>($</span><span>cli</span><span>-&gt;</span><span>valid</span><span>())</span><span> </span><span>{</span></p><p><span>    </span><span>$</span><span>prompt </span><span>=</span><span> </span><span>$</span><span>cli</span><span>-&gt;</span><span>current</span><span>();</span></p><p><span>    </span><span>echo</span><span> </span><span>$</span><span>prompt </span><span>.</span><span> </span><span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span></p><p><span>    </span><span>$</span><span>input </span><span>=</span><span> </span><span>trim</span><span>(</span><span>fgets</span><span>(</span><span>STDIN</span><span>));</span></p><p><span>    </span><span>$</span><span>cli</span><span>-&gt;</span><span>send</span><span>($</span><span>input</span><span>);</span></p><p><span>}</span></p><p><span>$</span><span>result </span><span>=</span><span> </span><span>$</span><span>cli</span><span>-&gt;</span><span>getReturn</span><span>();</span></p><p><span>// Display the collected information</span></p><p><span>echo</span><span> </span><span>&#34;</span><span>\n</span><span>Collected information:</span><span>\n</span><span>&#34;</span><span>;</span></p><p><span>echo</span><span> </span><span>&#34;</span><span>Name: </span><span>&#34;</span><span> </span><span>.</span><span> </span><span>$</span><span>result</span><span>[</span><span>&#39;</span><span>name</span><span>&#39;</span><span>]</span><span> </span><span>.</span><span> </span><span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span></p><p><span>echo</span><span> </span><span>&#34;</span><span>Age: </span><span>&#34;</span><span> </span><span>.</span><span> </span><span>$</span><span>result</span><span>[</span><span>&#39;</span><span>age</span><span>&#39;</span><span>]</span><span> </span><span>.</span><span> </span><span>&#34;</span><span>\n</span><span>&#34;</span><span>;</span></p></code></pre>

<p>In this example, the Generator will return a few questions. We display every question and use <code>fgets(STDIN)</code> to input an answer. This answer will be sent back to the generator, and it will proceed to the next question. When the Generator finishes, we return the recorded state. We can use <code>-&gt;getReturn()</code> to get that value from the generator.</p>

<blockquote>
  <p><strong>Note:</strong> You can only use <code>getReturn</code> on a Generator or Fiber that has finished. Otherwise, it will throw an exception.</p>
</blockquote>

<h3>Lazy iteration</h3>

<p>Being able to return multiple values is what makes coroutines great at being lazy iterators. Because the data it returns does not need to exist before the iteration starts, it can save a lot of memory. In PHP, generators are perfect for this kind of job, since they implement the <code>Iterator</code> interface and plug right into <code>foreach</code> loops. If you‚Äôre curious to see this in action, check out my post on <a href="https://doeken.org/blog/generators-over-arrays">Generators over arrays</a>.</p>

<h3>Cooperative Multitasking (Concurrency)</h3>

<p>Concurrency is a concept of multiple tasks running at the same time. This can be achieved through <em>parallelism</em>, where tasks run on separate threads simultaneously, or through <strong>cooperative multitasking</strong>, where tasks take turns running by explicitly yielding control.</p>

<blockquote>
  <p><strong>Note</strong>: Because coroutines simply yield their control, you need a manager that determines which coroutine runs next. This is often implemented with something called an <strong>Event Loop</strong>, which will manage and schedule coroutines based on I/O events and timers. Out of the box, PHP does not provide this, but there are various projects like <a href="https://revolt.run">Revolt</a> and <a href="https://reactphp.org">ReactPHP</a> that do. We will touch on them in a different post.</p>
</blockquote>

<p>Imagine a chef preparing a meal. Instead of cooking the entire dish and cleaning everything afterward, the chef alternates between cooking steps and quick cleaning tasks. While both routes would have the same result, alternating makes for a cleaner work environment.</p>

<p>Here is what that could look like in code, using Fibers.</p>

<pre><code data-theme="material-theme-palenight" data-lang="php"><!-- Syntax highlighted by torchlight.dev --><p><span>$</span><span>cooking </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>(</span><span>array</span><span> </span><span>$</span><span>steps</span><span>):</span><span> </span><span>Meal</span><span> </span><span>{</span></p><p><span>    </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Ready to cook.</span><span>&#39;</span><span>);</span></p><p><span>    </span><span>foreach</span><span> </span><span>($</span><span>steps </span><span>as</span><span> </span><span>$</span><span>step</span><span>)</span><span> </span><span>{</span></p><p><span>        </span><span>// Perform step.</span></p><p><span>        </span><span>Fiber</span><span>::</span><span>suspend</span><span>($</span><span>step </span><span>.</span><span> </span><span>&#34;</span><span> finished</span><span>&#34;</span><span>);</span></p><p><span>    </span><span>}</span></p><p><span>    </span><span>return</span><span> </span><span>new</span><span> </span><span>Meal</span><span>();</span></p><p><span>});</span></p><p><span>$</span><span>cleaning </span><span>=</span><span> </span><span>new</span><span> </span><span>Fiber</span><span>(</span><span>function</span><span> </span><span>()</span><span> </span><span>{</span></p><p><span>    </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Waiting for something to clean.</span><span>&#39;</span><span>);</span></p><p><span>    </span><span>while</span><span> </span><span>(true)</span><span> </span><span>{</span></p><p><span>        </span><span>// Cleaning.</span></p><p><span>        </span><span>Fiber</span><span>::</span><span>suspend</span><span>(</span><span>&#39;</span><span>Finished cleaning</span><span>&#39;</span><span>);</span></p><p><span>    </span><span>}</span></p><p><span>});</span></p><p><span>$</span><span>cooking</span><span>-&gt;</span><span>start</span><span>([</span><span>&#39;</span><span>chopping</span><span>&#39;</span><span>,</span><span> </span><span>&#39;</span><span>mixing</span><span>&#39;</span><span>,</span><span> </span><span>&#39;</span><span>cooking</span><span>&#39;</span><span>,</span><span> </span><span>&#39;</span><span>plating</span><span>&#39;</span><span>]);</span><span> </span><span>// Ready to cook.</span></p><p><span>$</span><span>cleaning</span><span>-&gt;</span><span>start</span><span>();</span><span> </span><span>// Waiting for something to clean.</span></p><p><span>// Alternate between cooking and cleaning.</span></p><p><span>while</span><span> </span><span>(!$</span><span>cooking</span><span>-&gt;</span><span>isTerminated</span><span>())</span><span> </span><span>{</span></p><p><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>[Cooking] %s</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>$</span><span>cooking</span><span>-&gt;</span><span>resume</span><span>());</span></p><p><span>    </span><span>printf</span><span>(</span><span>&#34;</span><span>[Cleaning] %s</span><span>\n</span><span>&#34;</span><span>,</span><span> </span><span>$</span><span>cleaning</span><span>-&gt;</span><span>resume</span><span>());</span></p><p><span>}</span></p><p><span>$</span><span>meal </span><span>=</span><span> </span><span>$</span><span>cooking</span><span>-&gt;</span><span>getReturn</span><span>();</span></p></code></pre>

<p>And this could happen in code, too. Code uses memory, which can routinely be freed up to keep memory usage low. Especially when you are processing a lot of data, this constant switching between processing and cleaning can drastically improve your code&#39;s efficiency.</p>

<p>Where cooperative multitasking really shines is when you combine it with background processing. Instead of waiting for a function to finish its computation, you could allow the calling code to perform other tasks, while in the background the computation is finished. Then the function could pick up where it left off at a later moment, when the computation is completed.</p>

<h2>TL;DR (but scrolled here anyway)</h2>

<ul>
<li>Coroutines are functions that can pause and resume execution while retaining internal state.</li>
<li>PHP supports coroutines through <strong>Generators</strong> (asymmetric, stackless) and <strong>Fibers</strong> (asymmetric, stackful).</li>
<li>Use Generators for iteration and memory efficiency.</li>
<li>Use Fibers for cooperative multitasking and nested suspension.</li>
<li>Real-world applications include CLI tools, state machines, and async workflows.</li>
</ul>

<h2>Coming Up: Coroutines in Practice</h2>

<p>Now that we&#39;ve explored what coroutines are and how PHP supports them through Generators and Fibers, the next step is putting them to work. In a next post, we‚Äôll dive into <em>concurrency</em> in PHP, exploring event loops like <a href="https://revolt.run">Revolt</a>, coroutine schedulers, and async libraries like <a href="https://reactphp.org">ReactPHP</a>. We‚Äôll see how coroutines fit into the bigger picture of building responsive, non-blocking PHP applications.</p>
            </div></div>
  </body>
</html>
