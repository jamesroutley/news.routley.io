<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/three-ways-formally-verified-code-can-go-wrong-in/">Original</a>
    <h1>Three ways formally verified code can go wrong in practice</h1>
    
    <div id="readability-page-1" class="page"><div>
            
            <date>
                
                
                October 10, 2025
                
                
            </date>
            

            

            
            <h2>
                &#34;Correct&#34; doesn&#39;t mean &#34;correct&#34; when correctly using &#34;correct&#34;
            </h2>
            

            

            
            
            <h3>New Logic for Programmers Release!</h3>
<p><a href="https://leanpub.com/logic/" rel="noopener noreferrer nofollow" target="_blank">v0.12 is now available</a>! This should be the last major content release. The next few months are going to be technical review, copyediting and polishing, with a hopeful 1.0 release in March. <a href="https://github.com/logicforprogrammers/book-assets/blob/master/CHANGELOG.md" rel="noopener noreferrer nofollow" target="_blank">Full release notes here</a>.</p>
<figure><img alt="Cover of the boooooook" draggable="false" src="https://assets.buttondown.email/images/92b4a35d-2bdd-416a-92c7-15ff42b49d8d.jpg?w=960&amp;fit=max"/><figcaption></figcaption></figure>


<p>I run this small project called <a href="https://github.com/hwayne/lets-prove-leftpad" rel="noopener noreferrer nofollow" target="_blank">Let&#39;s Prove Leftpad</a>, where people submit formally verified proofs of the <a href="https://en.wikipedia.org/wiki/Npm_left-pad_incident" rel="noopener noreferrer nofollow" target="_blank">eponymous meme</a>. Recently I read <a href="https://lukeplant.me.uk/blog/posts/breaking-provably-correct-leftpad/" rel="noopener noreferrer nofollow" target="_blank">Breaking “provably correct” Leftpad</a>, which argued that most (if not all) of the provably correct leftpads have bugs! The lean proof, for example, <em>should</em> render <code>leftpad(&#39;-&#39;, 9, אֳֽ֑)</code> as <code>---------אֳֽ֑</code>, but actually does <code>------אֳֽ֑</code>.</p>
<p>You can read the article for a good explanation of why this goes wrong (Unicode). The actual problem is that correct can mean two different things, and this leads to confusion about how much formal methods can actually guarantee us. So I see this as a great opportunity to talk about the nature of proof, correctness, and how &#34;correct&#34; code can still have bugs.</p>
<h2>What we talk about when we talk about correctness</h2>
<p>In most of the real world, correct means &#34;no bugs&#34;. Except &#34;bugs&#34; isn&#39;t a very clear category. A bug is anything that causes someone to say &#34;this isn&#39;t working right, there&#39;s a bug.&#34; Being too slow is a bug, a typo is a bug, etc. &#34;correct&#34; is a little fuzzy.</p>
<p>In formal methods, &#34;correct&#34; has a very specific and precise meaning: the code conforms to a <strong>specification</strong> (or &#34;spec&#34;). The spec is a higher-level description of what is supposed the code&#39;s properties, usually something we can&#39;t just directly implement. Let&#39;s look at the most popular kind of proven specification:</p>
<div><pre><span></span><code><span>-- Haskell</span>
<span>inc</span><span> </span><span>::</span><span> </span><span>Int</span><span> </span><span>-&amp;</span><span>gt</span><span>;</span><span> </span><span>Int</span>
<span>inc</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>x</span><span> </span><span>+</span><span> </span><span>1</span>
</code></pre></div>
<p>The type signature <code>Int -&gt; Int</code> is a specification! It corresponds to the logical statement <code>all x in Int: inc(x) in Int</code>. The Haskell type checker can automatically verify this for us. It cannot, however, verify properties like <code>all x in Int: inc(x) &gt; x</code>. Formal verification is concerned with verifying arbitrary properties beyond what is (easily) automatically verifiable. Most often, this takes the form of proof. A human manually writes a proof that the code conforms to its specification, and the prover checks that the proof is correct.</p>
<p>Even if we have a proof of &#34;correctness&#34;, though, there&#39;s a few different ways the code can still have bugs.</p>
<h3>1. The proof is invalid</h3>
<p>For some reason the proof doesn&#39;t actually show the code matches the specification. This is pretty common in pencil-and-paper verification, where the proof is checked by someone saying &#34;yep looks good to me&#34;. It&#39;s much rarer when doing formal verification but it can still happen in a couple of specific cases:</p>
<ol><li><p>The theorem prover itself has a bug (in the code or introduced in the compiled binary) that makes it accept an incorrect proof. This is something people are really concerned about but it&#39;s so much rarer than every other way verified code goes wrong, so is only included for completeness.</p></li><li><p>For convenience, most provers and FM languages have an &#34;just accept this statement is true&#34; feature. This helps you work on the big picture proof and fill in the details later. If you leave in a shortcut, <em>and</em> the compiler is configured to allow code-with-proof-assumptions to compile, <em>then</em> you can compile incorrect code that &#34;passes the proof checker&#34;. You really should know better, though.</p></li></ol>

<h3>2. The properties are wrong</h3>
<blockquote><figure><img alt="The horrible bug you had wasn&#39;t covered in the specification/came from some other module/etc" draggable="false" src="https://cdn.prod.website-files.com/673b407e535dbf3b547179ff/681ca0bf4a045f39f785faeb_AD_4nXfFhdn6DGmgLAcmaUNHl9a3Nog8gH8Hluve5Kof7zLk4CyOlD4zCmCqVJaowKqu-pTicwZ393jE7anIrjYZTSuRvGiYhFhAkkX9vifNt9vEWYwZUp65hsbrRTmZzRgb9vgu7n7buA.png"/><figcaption></figcaption></figure><p><a href="https://www.galois.com/articles/what-works-and-doesnt-selling-formal-methods" rel="noopener noreferrer nofollow" target="_blank">Galois</a></p></blockquote>
<p>This code is provably correct:</p>
<div><pre><span></span><code><span>inc</span><span> </span><span>::</span><span> </span><span>Int</span><span> </span><span>-&amp;</span><span>gt</span><span>;</span><span> </span><span>Int</span>
<span>inc</span><span> </span><span>x</span><span> </span><span>=</span><span> </span><span>x</span><span>-</span><span>1</span>
</code></pre></div>
<p>The only specification I&#39;ve given is the type signature <code>Int -&gt; Int</code>. At no point did I put the property <code>inc(x) &gt; x</code> in my specification, so it doesn&#39;t matter that it doesn&#39;t hold, the code is still &#34;correct&#34;.</p>
<p>This is what &#34;went wrong&#34; with the leftpad proofs. They do <em>not</em> prove the property &#34;<code>leftpad(c, n, s)</code> will take up either <code>n</code> spaces on the screen or however many characters <code>s</code> takes up (if more than <code>n</code>)&#34;. They prove the weaker property &#34;<code>len(leftpad(c, n, s)) == max(n, len(s))</code>, for however you want to define <code>len(string)</code>&#34;. The second is a rough proxy for the first that works in most cases, but if someone really needs the former property they are liable to experience a bug.</p>
<p>Why don&#39;t we prove the stronger property? Sometimes it&#39;s because the code is meant to be used one way and people want to use it another way. This can lead to accusations that the developer is &#34;misusing the provably correct code&#34; but this should more often be seen as the verification expert failing to educate devs on was actually &#34;proven&#34;.</p>
<p>Sometimes it&#39;s because the property is too hard to prove. &#34;Outputs are visually aligned&#34; is a proof about Unicode inputs, and the <em>core</em> Unicode specification is <a href="https://www.unicode.org/versions/Unicode17.0.0/UnicodeStandard-17.0.pdf" rel="noopener noreferrer nofollow" target="_blank">1,243 pages long</a>.</p>
<p>Sometimes it&#39;s because the property we want is too hard to <em>express</em>. How do you mathematically represent &#34;people will perceive the output as being visually aligned&#34;? Is it OS and font dependent? These two lines are exactly five characters but not visually aligned:</p>
<blockquote><p>|||||</p><p>MMMMM</p></blockquote>
<p>Or maybe they are aligned for you! I don&#39;t know, lots of people read email in a monospace font. &#34;We can&#39;t express the property&#34; comes up a lot when dealing with human/business concepts as opposed to mathematical/computational ones.</p>
<p>Finally, there&#39;s just the possibility of a brain fart. All of the proofs in <a href="https://research.google/blog/extra-extra-read-all-about-it-nearly-all-binary-searches-and-mergesorts-are-broken/" rel="noopener noreferrer nofollow" target="_blank">Nearly All Binary Searches and Mergesorts are Broken</a> are like this. They (informally) proved the correctness of binary search with unbound integers, forgetting that many programming languages use <em>machine</em> integers, where a large enough sum can overflow.</p>
<h3>3. The assumptions are wrong</h3>
<p>This is arguably the most important and most subtle source of bugs. Most properties we prove aren&#39;t &#34;<code>X</code> is always true&#34;. They are &#34;<em>assuming</em> <code>Y</code> is true, <code>X</code> is also true&#34;. Then if <code>Y</code> is not true, the proof no longer guarantees <code>X</code>. A good example of this is binary <s>sort</s> <em>search</em>, which only correctly finds elements <em>assuming</em> the input list is sorted. If the list is not sorted, it will not work correctly.</p>
<p>Formal verification adds two more wrinkles. One: sometimes we need assumptions to make the property valid, but we can also add them to make the proof easier. So the code can be bug-free even if the assumptions used to verify it no longer hold! Even if a leftpad implements visual alignment for all Unicode glyphs, it will be a lot easier to <em>prove</em> visual alignment for just ASCII strings and padding.</p>
<p>Two: we need make a lot of <em>environmental</em> assumptions that are outside our control. Does the algorithm return output or use the stack? Need to assume that there&#39;s sufficient memory to store stuff. Does it use any variables? Need to assume nothing is concurrently modifying them. Does it use an external service? Need to assume the vendor doesn&#39;t change the API or response formats. You need to assume the compiler worked correctly, the hardware isn&#39;t faulty, and the OS doesn&#39;t mess with things, etc. Any of these could change well after the code is proven and deployed, meaning formal verification can&#39;t be a one-and-done thing.</p>
<p>You don&#39;t actually have to assume most of these, but each assumption drop makes the proof harder and the properties you can prove more restricted. Remember, the code might still be bug-free even if the environmental assumptions change, so there&#39;s a tradeoff in time spent proving vs doing other useful work.</p>
<p>Another common source of &#34;assumptions&#34; is when verified code depends on unverified code. The Rust compiler can prove that safe code doesn&#39;t have a memory bug <em>assuming</em> unsafe code does not have one either, but depends on the human to confirm that assumption. <a href="https://ucsd-progsys.github.io/liquidhaskell/" rel="noopener noreferrer nofollow" target="_blank">Liquid Haskell</a> is verifiable but can also call regular Haskell libraries, which are unverified. We need to assume that code is correct (in the &#34;conforms to spec&#34;) sense, and if it&#39;s not, our proof can be &#34;correct&#34; and still cause bugs.</p>
<hr/><p>These boundaries are fuzzy. I wrote that the &#34;binary search&#34; bug happened because they proved the wrong property, but you can just as well argue that it was a broken assumption (that integers could not overflow). What really matters is having a clear understanding of what &#34;this code is proven correct&#34; actually <em>tells</em> you. Where can you use it safely? When should you worry? How do you communicate all of this to your teammates?</p>
<p>Good lord it&#39;s already Friday</p>
            
            

            
            
            <p><em>If you&#39;re reading this on the web, you can subscribe <a href="https://cceckman.com/hillelwayne" target="_blank">here</a>. Updates are once a week. My main website is <a href="https://www.hillelwayne.com" target="_blank">here</a>.</em></p>
<p><em>My new book, </em>Logic for Programmers<em>, is now in early access! Get it <a href="https://leanpub.com/logic/" target="_blank">here</a>.</em></p>
            
            

            



        </div></div>
  </body>
</html>
