<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://antelang.org/blog/why_effects/">Original</a>
    <h1>Why Algebraic Effects?</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content">
                          
<p>Algebraic effects<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> (a.k.a. effect handlers) are a very useful up-and-coming feature that I personally think will see a huge surge in popularity in the programming
languages of tomorrow. They’re one of the core features of Ante, as well as being the focus of many research
languages including <a href="https://koka-lang.github.io/koka/doc/index.html">Koka</a>, <a href="https://effekt-lang.org/">Effekt</a>, <a href="https://www.eff-lang.org/">Eff</a>,
and <a href="https://flix.dev/">Flix</a>. However, while many articles or documentation snippets try to explain <em>what</em> effect handlers are (including
<a href="https://olu.online/docs/language#algebraic-effects">Ante’s own documentation</a>), few really go in-depth on <em>why</em> you would want to use them.
In this post I’ll explain exactly that and will include as complete a list as possible on all the use-cases of algebraic effects.</p>
<h2 id="a-note-on-syntax-and-semantics">A Note on Syntax and Semantics</h2>
<p>I’ll be using Ante pseudocode for much of this article. If you’re not familiar with effect handlers or Ante I encourage you to read the documentation link
above or read from any of the other effectful languages for a good head start! But I recognize it’s hard to get buy-in to learn something before showing
why it is useful first (hence this blog post!). So I’ll give a quick elevator pitch on a good mental model to think about effects.</p>
<p>You can think of algebraic effects essentially as exceptions that you can resume. You can declare an effect function:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>SayMessage</span> <span>with</span>
    <span>// This effect function takes a Unit type and returns a Unit type.</span>
    <span>// Note that `Unit` is roughly the same as `void` in imperative languages.</span>
    <span>// There are differences between them but none that are relevant here.</span>
    <span>say_message</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span>
</code></pre></div><p>You can “throw” an effect by calling the function, and the function you’re in must declare it can use that effect similar to checked exceptions:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>foo</span> <span>()</span> <span>can</span> <span>SayMessage</span> <span>=</span>
    <span>say_message</span> <span>()</span>
    <span>42</span>
</code></pre></div><p>And you can “catch” effects with a <code>handle</code> expression (think of these as <code>try/catch</code> expressions):</p>
<div><pre tabindex="0"><code data-lang="ante"><span>handle</span> <span>foo</span> <span>()</span>
<span>|</span> <span>say_message</span> <span>()</span> <span>-&gt;</span>
    <span>print</span> <span>&#34;Hello World!&#34;</span>  <span>// print out Hello World!</span>
    <span>resume</span> <span>()</span>             <span>// then resume the computation, returning 42</span>
</code></pre></div><p>If you have further questions I again encourage you to read <a href="https://olu.online/docs/language#algebraic-effects">some documentation</a> on effects, but now
that we can recognize effects when they’re used I’ll get into why exactly the idea of exceptions-you-can-resume are so useful!</p>
<hr/>
<h2 id="user-defineable-control-flow">User-defineable control-flow</h2>
<p>The most common reason you’ll hear for why to have effect handlers is that they are a single language feature which
allow for implementing what would normally be multiple separate language features (generators, exceptions, async, coroutines, etc)
as libraries. Moreover, they solve the <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">what color is your function</a>
problem by making functions polymorphic over effects. For example, a <code>map</code> function for vectors (growable arrays) can be written once:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>map</span> <span>(</span><span>input</span><span>:</span> <span>Vec</span> <span>a</span><span>)</span> <span>(</span><span>f</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>b</span> <span>can</span> <span>e</span><span>)</span><span>:</span> <span>Vec</span> <span>b</span> <span>can</span> <span>e</span> <span>=</span>
    <span>// Implementation omitted!</span>
</code></pre></div><p>This function’s signature says that the input function <code>f</code> can perform <em>any</em> effect(s) <code>e</code>, and that
<code>map</code> will perform those same effects <code>e</code>. So we can instantiate this with an <code>f</code> that prints to stdout,
an <code>f</code> that calls asynchronous functions, an <code>f</code> that yields elements into a stream, etc. Most languages
with effect handlers will let you omit the polymorphic effect variable <code>e</code> as well, giving us the
old, familiar signature for <code>map</code>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>map</span> <span>(</span><span>input</span><span>:</span> <span>Vec</span> <span>a</span><span>)</span> <span>(</span><span>f</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>b</span><span>)</span><span>:</span> <span>Vec</span> <span>b</span> <span>=</span>
    <span>// Implementation omitted!</span>
</code></pre></div><p>Ok, back to the topic though. Effect handlers are cool because we can implement generators, exceptions, coroutines,
<a href="https://effekt-lang.org/docs/casestudies/ad">automatic differentiation</a>, and much more with them. Surely such
constructs are difficult to implement, requiring low-level knowledge though, right? Nope. Most of these are pretty
straightforward actually.</p>
<p>Let’s consider exceptions. Remember when I described algebraic effects as resumeable exceptions? This actually works
pretty well as a hint on how to implement exceptions via effects. How do we do it? Just don’t <code>resume</code> the effect when it is thrown:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Throw</span> <span>a</span> <span>with</span>
    <span>throw</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>never_returns</span>

<span>safe_div</span> <span>x</span> <span>y</span> <span>=</span>
    <span>if</span> <span>y</span> <span>==</span> <span>0</span> <span>then</span>
        <span>throw</span> <span>&#34;error: Division by zero!&#34;</span>

    <span>x</span> <span>/</span> <span>y</span>

<span>// Output: &#34;error: Division by zero!&#34;</span>
<span>handle</span> 
    <span>safe_div</span> <span>5</span> <span>0</span>
    <span>print</span> <span>&#34;successfully divided by zero&#34;</span> <span>// we never get to this point</span>
<span>|</span> <span>throw</span> <span>msg</span> <span>-&gt;</span>
    <span>print</span> <span>msg</span>
</code></pre></div><p>How about something more advanced? Surely generators must be more difficult? Well, a little but the code still fits
onto a sticky note:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Yield</span> <span>a</span> <span>with</span>
    <span>yield</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>Unit</span>

<span>yield_all_elements_of_vec</span> <span>(</span><span>vec</span><span>:</span> <span>Vec</span> <span>a</span><span>)</span><span>:</span> <span>Unit</span> <span>can</span> <span>Yield</span> <span>a</span> <span>=</span>
    <span>vec</span><span>.</span><span>for_each</span> <span>fn</span> <span>elem</span> <span>-&gt;</span>
        <span>yield</span> <span>elem</span>

<span>// To filter a generator we&#39;re going to take in a generator function to filter</span>
<span>// as well as a predicate to tell us which elements to keep</span>
<span>filter</span> <span>(</span><span>generator</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span> <span>can</span> <span>Yield</span> <span>a</span><span>)</span> <span>(</span><span>predicate</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>Bool</span><span>)</span><span>:</span> <span>Unit</span> <span>can</span> <span>Yield</span> <span>a</span> <span>=</span>
    <span>handle</span> <span>generator</span> <span>()</span>
    <span>|</span> <span>yield</span> <span>x</span> <span>-&gt;</span>
        <span>// when `generator` yields us an element, re-raise it if `predicate` returns true for it</span>
        <span>if</span> <span>predicate</span> <span>x</span> <span>then</span>
            <span>yield</span> <span>x</span>
        <span>resume</span> <span>()</span>  <span>// continue yielding elements</span>

<span>// Finally, lets add a helper function for applying a function to each yielded element</span>
<span>my_for_each</span> <span>(</span><span>generator</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>Unit</span> <span>can</span> <span>Yield</span> <span>a</span><span>)</span> <span>(</span><span>f</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>Unit</span><span>)</span><span>:</span> <span>Unit</span> <span>=</span>
    <span>handle</span> <span>generator</span> <span>()</span>
    <span>|</span> <span>yield</span> <span>x</span> <span>-&gt;</span>
        <span>f</span> <span>x</span>
        <span>resume</span> <span>()</span>

<span>// Let&#39;s use it!</span>
<span>yield_all_elements_of_vec</span> <span>(</span><span>Vec</span><span>.</span><span>of</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>])</span>
    <span>// `with` is sugar to apply effect handler functions</span>
    <span>with</span> <span>filter</span> <span>(</span><span>fn</span> <span>x</span> <span>-&gt;</span> <span>x</span> <span>%</span> <span>2</span> <span>==</span> <span>0</span><span>)</span>
    <span>with</span> <span>my_for_each</span> <span>print</span>  <span>// prints 2 then 4</span>
</code></pre></div><p>You can similarly implement a cooperative scheduler with a <code>yield: Unit -&gt; Unit</code> effect which
yields control back to a handler which switches execution to another function. <a href="https://effekt-lang.org/docs/casestudies/scheduler">Here’s an example</a>
of that in Effekt.</p>
<p>Basically, algebraic effects get you a lot of expressivity in your language, and as a bonus these different
effects compose well with each other. We’ll get into this more later but algebraic effects composing well
is a huge usability win over other effect abstractions.</p>
<hr/>
<h2 id="as-an-abstraction">As an Abstraction</h2>
<p>Okay, now that the really flashy stuff is out of the way I want to go over some less obvious benefits of algebraic effects.
Since discussion on effects can often seem like they’re <em>only</em> for implementing generators, exceptions, async, etc., I want to
highlight that even if you don’t personally care for these features, there are still good reasons to use algebraic effects
in your run of the mill business application.</p>
<p>One reason to use them in such an application is that effects can be used for <em>dependency injection</em>. Let’s assume
we have code that touches a database:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>business_logic</span> <span>(</span><span>db</span><span>:</span> <span>Database</span><span>)</span> <span>(</span><span>x</span><span>:</span> <span>I32</span><span>)</span> <span>=</span>
    <span>db</span><span>.</span><span>query</span> <span>&#34;...&#34;</span>
    <span>db</span><span>.</span><span>query</span> <span>&#34;...&#34;</span>
    <span>db</span><span>.</span><span>query</span> <span>&#34;...&#34;</span>
    <span>x</span> <span>*</span> <span>2</span>
</code></pre></div><p>This is all well and fine until we want to use a different database, restrict access to this database, or you know, actually
test these functions. What we can do is move the database to an effect:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Database</span> <span>with</span>
    <span>query</span><span>:</span> <span>String</span> <span>-&gt;</span> <span>DbResponse</span>

<span>business_logic</span> <span>(</span><span>x</span><span>:</span> <span>I32</span><span>)</span> <span>can</span> <span>Database</span> <span>=</span>
    <span>query</span> <span>&#34;...&#34;</span>
    <span>query</span> <span>&#34;...&#34;</span>
    <span>query</span> <span>&#34;...&#34;</span>
    <span>x</span> <span>*</span> <span>2</span>
</code></pre></div><p>Now we can swap out the specific database used further up the call stack (let’s say in <code>main</code>) with a different database,
or even with a mock database for testing:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>mock_database</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Database</span><span>)</span><span>:</span> <span>a</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>query</span> <span>_msg</span> <span>-&gt;</span>
        <span>// Ignore the message and always return Ok</span>
        <span>resume</span> <span>DbResponse</span><span>.</span><span>Ok</span>

<span>test_business_logic</span> <span>()</span> <span>=</span>
    <span>// Apply the `mock_database` handler to the rest of the function</span>
    <span>with</span> <span>mock_database</span>

    <span>assert</span> <span>(</span><span>business_logic</span> <span>0</span> <span>==</span> <span>0</span><span>)</span>
    <span>assert</span> <span>(</span><span>business_logic</span> <span>1</span> <span>==</span> <span>2</span><span>)</span>
    <span>assert</span> <span>(</span><span>business_logic</span> <span>21</span> <span>==</span> <span>42</span><span>)</span>
    <span>// etc</span>
</code></pre></div><p>We can even redirect print outs into a string:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>output_messages</span> <span>()</span><span>:</span> <span>U32</span> <span>can</span> <span>Print</span> <span>=</span>
    <span>print</span> <span>&#34;Hello!&#34;</span>
    <span>print</span> <span>&#34;Not sure what to write here, honestly&#34;</span>
    <span>1234</span>

<span>// Collect `print` calls into a single string, separating each with newlines</span>
<span>print_to_string</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Print</span><span>)</span><span>:</span> <span>a</span><span>,</span> <span>String</span> <span>can</span> <span>Print</span> <span>=</span>
    <span>mut</span> <span>all_messages</span> <span>=</span> <span>&#34;&#34;</span>

    <span>handle</span>
        <span>result</span> <span>=</span> <span>f</span> <span>()</span>
        <span>result</span><span>,</span> <span>all_messages</span>
    <span>|</span> <span>print</span> <span>msg</span> <span>-&gt;</span>
        <span>all_messages</span> <span>:=</span> <span>all_messages</span> <span>++</span> <span>&#34;</span><span>\n</span><span>&#34;</span> <span>++</span> <span>msg</span>
        <span>resume</span> <span>()</span>

<span>// Now we can test `output_messages` without it printing to stdout</span>
<span>test_output_messages</span> <span>()</span> <span>=</span>
    <span>int</span><span>,</span> <span>messages</span> <span>=</span> <span>output_messages</span> <span>()</span> <span>with</span> <span>print_to_string</span>
    <span>assert</span> <span>(</span><span>int</span> <span>==</span> <span>1234</span><span>)</span>
    <span>assert</span> <span>(</span><span>messages</span> <span>==</span> <span>&#34;Hello!</span><span>\n</span><span>Not sure what to write here, honestly&#34;</span><span>)</span>
</code></pre></div><p>Or conditionally disable logging output:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Log</span> <span>with</span>
    <span>log</span><span>:</span> <span>LogLevel</span> <span>-&gt;</span> <span>String</span> <span>-&gt;</span> <span>Unit</span>

<span>type</span> <span>LogLevel</span> <span>=</span> <span>|</span> <span>Error</span> <span>|</span> <span>Warn</span> <span>|</span> <span>Info</span>

<span>LogLevel</span><span>.</span><span>greater_than_or_equal</span> <span>self</span> <span>(</span><span>other</span><span>:</span> <span>LogLevel</span><span>)</span><span>:</span> <span>Bool</span> <span>=</span>
    <span>match</span> <span>self</span><span>,</span> <span>other</span>
    <span>|</span> <span>Error</span><span>,</span> <span>_</span> <span>-&gt;</span> <span>true</span>
    <span>|</span> <span>Warn</span><span>,</span> <span>(</span><span>Warn</span> <span>|</span> <span>Info</span><span>)</span> <span>-&gt;</span> <span>true</span>
    <span>|</span> <span>Info</span><span>,</span> <span>Info</span> <span>-&gt;</span> <span>true</span>
    <span>|</span> <span>_</span><span>,</span> <span>_</span> <span>-&gt;</span> <span>false</span>

<span>foo</span> <span>()</span> <span>=</span>
    <span>log</span> <span>Info</span> <span>&#34;Entering foo...&#34;</span>
    <span>log</span> <span>Warn</span> <span>&#34;foo is a fairly lazy example function&#34;</span>
    <span>log</span> <span>Error</span> <span>&#34;an error occurred!&#34;</span>

<span>log_handler</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Log</span><span>)</span> <span>(</span><span>level</span><span>:</span> <span>LogLevel</span><span>)</span><span>:</span> <span>a</span> <span>can</span> <span>Print</span> <span>=</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>log</span> <span>msg_level</span> <span>msg</span> <span>-&gt;</span>
        <span>if</span> <span>level</span><span>.</span><span>greater_than_or_equal</span> <span>msg_level</span> <span>then</span>
            <span>print</span> <span>msg</span>
        <span>resume</span> <span>()</span>

<span>foo</span> <span>()</span> <span>with</span> <span>log_handler</span> <span>Error</span>  <span>// outputs &#34;an error occurred!&#34;</span>
</code></pre></div><hr/>
<h2 id="cleaner-apis">Cleaner APIs</h2>
<p>Algebraic effects can also make designing cleaner APIs easier. A common pattern in just about
any programming language is the use of a <code>Context</code> object which often needs to be passed to
most functions in the program or library. We can encode this pattern as an effect. All
we need are functions to <code>get</code> the context and to <code>set</code> it:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Use</span> <span>a</span> <span>with</span>
    <span>get</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span>
    <span>set</span><span>:</span> <span>a</span> <span>-&gt;</span> <span>Unit</span>
</code></pre></div><p>Most languages call this a state effect and it is generic over the type of state to use.</p>
<p>We can define a handler to provide the initial state value like so<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>state</span> <span>(</span><span>f</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>a</span> <span>can</span> <span>Use</span> <span>s</span><span>)</span> <span>(</span><span>initial</span><span>:</span> <span>s</span><span>)</span><span>:</span> <span>a</span> <span>=</span>
    <span>mut</span> <span>context</span> <span>=</span> <span>initial</span>
    <span>handle</span> <span>f</span> <span>()</span>
    <span>|</span> <span>get</span> <span>()</span> <span>-&gt;</span> <span>resume</span> <span>context</span>  <span>// give the context to the caller of `get`</span>
    <span>|</span> <span>set</span> <span>new_context</span> <span>-&gt;</span>
        <span>context</span> <span>:=</span> <span>new_context</span>
        <span>resume</span> <span>()</span>
</code></pre></div><p>And we can use this to help clean up code that uses one or more context objects.
Let’s imagine we have code which uses a vector internally and hands out references
to elements as indices into this vector. This would normally require passing around
the vector everywhere:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>type</span> <span>Strings</span> <span>=</span> <span>vec</span><span>:</span> <span>Vec</span> <span>String</span>
<span>type</span> <span>StringKey</span> <span>=</span> <span>index</span><span>:</span> <span>Usz</span>

<span>// `!` is a mutable reference</span>
<span>push_string</span> <span>(</span><span>strings</span><span>:</span> <span>!</span><span>Strings</span><span>)</span> <span>(</span><span>string</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>StringKey</span> <span>=</span>
    <span>key</span> <span>=</span> <span>StringKey</span> <span>(</span><span>strings</span><span>.</span><span>len</span> <span>())</span>
    <span>strings</span><span>.</span><span>push</span> <span>string</span>
    <span>key</span>

<span>get_string</span> <span>(</span><span>strings</span><span>:</span> <span>&amp;</span><span>Strings</span><span>)</span> <span>(</span><span>key</span><span>:</span> <span>StringKey</span><span>)</span><span>:</span> <span>&amp;</span><span>String</span> <span>=</span>
    <span>strings</span><span>.</span><span>get</span> <span>key</span> <span>|&gt;</span> <span>unwrap</span>

<span>append_with_separator</span> <span>(</span><span>strings</span><span>:</span> <span>!</span><span>Strings</span><span>)</span> <span>(</span><span>string1_key</span> <span>separator</span> <span>string2_key</span><span>:</span> <span>String</span><span>)</span> <span>=</span>
    <span>string1</span> <span>=</span> <span>get_string</span> <span>strings</span> <span>string1_key</span>
    <span>string2</span> <span>=</span> <span>get_string</span> <span>strings</span> <span>string2_key</span>
    <span>push_string</span> <span>strings</span> <span>(</span><span>string1</span> <span>++</span> <span>separator</span> <span>++</span> <span>string2</span><span>)</span>

<span>example</span> <span>(</span><span>strings</span><span>:</span> <span>!</span><span>Strings</span><span>)</span> <span>=</span>
    <span>string1</span> <span>=</span> <span>push_string</span> <span>strings</span> <span>&#34;Hello!&#34;</span>
    <span>string2</span> <span>=</span> <span>push_string</span> <span>strings</span> <span>&#34;Goodbye.&#34;</span>

    <span>// We have to pass `strings` to every function in our call stack which needs it</span>
    <span>append_with_separator</span> <span>strings</span> <span>string1</span> <span>&#34; &#34;</span> <span>string2</span>

<span>run_example</span> <span>()</span> <span>=</span>
    <span>mut</span> <span>context</span> <span>=</span> <span>Strings</span> <span>(</span><span>Vec</span><span>.</span><span>new</span> <span>())</span>
    <span>example</span> <span>!</span><span>context</span>
</code></pre></div><p>Using a state effect essentially threads through the context automatically:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>type</span> <span>Strings</span> <span>=</span> <span>vec</span><span>:</span> <span>Vec</span> <span>String</span>
<span>type</span> <span>StringKey</span> <span>=</span> <span>index</span><span>:</span> <span>Usz</span>

<span>push_string</span> <span>(</span><span>string</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>StringKey</span> <span>can</span> <span>Use</span> <span>Strings</span> <span>=</span>
    <span>mut</span> <span>strings</span> <span>=</span> <span>get</span> <span>()</span> <span>:</span> <span>Strings</span>
    <span>key</span> <span>=</span> <span>StringKey</span> <span>(</span><span>strings</span><span>.</span><span>len</span> <span>())</span>
    <span>strings</span><span>.</span><span>push</span> <span>string</span>
    <span>// We could modify `Use a` to give mutable references or</span>
    <span>// use it via `Use !Strings` but for the sake of example</span>
    <span>// we just make sure to `set` here when mutating `strings`.</span>
    <span>set</span> <span>strings</span>
    <span>key</span>

<span>get_string</span> <span>(</span><span>key</span><span>:</span> <span>StringKey</span><span>)</span><span>:</span> <span>String</span> <span>can</span> <span>Use</span> <span>Strings</span> <span>=</span>
    <span>strings</span> <span>=</span> <span>get</span> <span>()</span> <span>:</span> <span>Strings</span>
    <span>strings</span><span>.</span><span>get</span> <span>key</span> <span>|&gt;</span> <span>unwrap</span>

<span>append_with_separator</span> <span>(</span><span>string1_key</span> <span>separator</span> <span>string2_key</span><span>:</span> <span>String</span><span>)</span> <span>can</span> <span>Use</span> <span>Strings</span> <span>=</span>
    <span>string1</span> <span>=</span> <span>get_string</span> <span>string1_key</span>
    <span>string2</span> <span>=</span> <span>get_string</span> <span>string2_key</span>
    <span>push_string</span> <span>(</span><span>string1</span> <span>++</span> <span>separator</span> <span>++</span> <span>string2</span><span>)</span>

<span>example</span> <span>()</span> <span>can</span> <span>Use</span> <span>Strings</span> <span>=</span>
    <span>string1</span> <span>=</span> <span>push_string</span> <span>&#34;Hello!&#34;</span>
    <span>string2</span> <span>=</span> <span>push_string</span> <span>&#34;Goodbye.&#34;</span>
    <span>// No need to pass `strings` manually</span>
    <span>append_with_separator</span> <span>string1</span> <span>&#34; &#34;</span> <span>string2</span>

<span>run_example</span> <span>()</span> <span>=</span>
    <span>context</span> <span>=</span> <span>Strings</span> <span>(</span><span>Vec</span><span>.</span><span>new</span> <span>())</span>
    <span>example</span> <span>()</span> <span>with</span> <span>state</span> <span>context</span>
</code></pre></div><p>From the above we can see we now have to call <code>get</code> or <code>set</code> to access <code>strings</code>
in the primitive operations <code>push_string</code> and <code>get_string</code>, but we no longer have
to explicitly pass around <code>strings</code> in code that just uses these primitive operations.
Generally speaking, this trade-off works well for libraries and abstractions which
will usually completely wrap these operations, eliminating the need for code using
these libraries to care about the internal details of how context objects are passed around.</p>
<p>This pattern pops up in quite a few places. Using a <code>Use a</code> effect locks us to passing
around a particular context type but we can also abstract the functions we need into
an interface. If the interface requires an internal context to implement it will be
automatically passed around with the effect handler. This leads us into the next point:</p>
<h3 id="as-a-substitute-for-globals">As a substitute for globals</h3>
<p>There are a few interfaces programmers may often think of as stateless but actually
require passing around state, often by global values for convenience. Some examples
of this are generating random numbers or simply allocating memory.</p>
<p>Let’s consider an API for random numbers:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>Prng</span><span>.</span><span>new</span> <span>()</span><span>:</span> <span>Prng</span> <span>=</span> <span>...</span>

<span>// Return a random byte</span>
<span>Prng</span><span>.</span><span>random</span> <span>!</span><span>self</span><span>:</span> <span>U8</span> <span>=</span> <span>...</span>
</code></pre></div><p>We would have to require users to explicitly thread through the Prng object through their
program just to use random numbers for this API. This is perhaps a mild inconvenience but
it scales with the size of the program and is notable in that random numbers are usually
a small implementation detail to the program logic. Why should such a small implementation
detail cost so much to the terseness of the program? If we want to avoid this, we may make
the Prng a global, which many languages and libraries do, but this comes with the usual
downsides of globals - most notably requiring the object to be thread safe. If we make
it an effect like the following:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Random</span> <span>with</span>
    <span>// Return a random byte</span>
    <span>random</span><span>:</span> <span>Unit</span> <span>-&gt;</span> <span>U8</span>
</code></pre></div><p>We gain the ability to thread it through a program mostly for free
(users must still explicitly initialize it somewhere up the call stack with a handler).
Plus, if we later decide we want to use <code>/dev/urandom</code> or some other source of random
numbers instead of the Prng object, we only need to swap out the effect handler. Nothing
else in the call stack needs to be changed.</p>
<p>Similarly, let’s consider an <code>Allocate</code> effect:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>effect</span> <span>Allocate</span> <span>with</span>
    <span>allocate</span><span>:</span> <span>(</span><span>size</span><span>:</span> <span>Usz</span><span>)</span> <span>-&gt;</span> <span>Alignment</span> <span>-&gt;</span> <span>Ptr</span> <span>a</span>
    <span>free</span><span>:</span> <span>Ptr</span> <span>a</span> <span>-&gt;</span> <span>Unit</span>

<span>// example usage</span>
<span>Box</span><span>.</span><span>new</span> <span>(</span><span>elem</span><span>:</span> <span>a</span><span>)</span><span>:</span> <span>Box</span> <span>a</span> <span>can</span> <span>Allocate</span> <span>=</span>
    <span>...</span>
</code></pre></div><p>Such an effect would let us swap how we perform allocations by adding a different effect
handler for it somewhere up the call stack. We could use the global allocator for most calls,
then in a tight loop swap out each allocation in that loop with an arena allocator by just
adding a handler over the loop body.</p>
<p>I could go on with more examples of this (parsers, build systems, …) but I think
you get the gist.</p>
<h3 id="writing-in-a-direct-style">Writing in a Direct Style</h3>
<p>As a small note, effects being things that are thrown/performed rather than dedicated
values does often enable us to write in a more direct style compared to the alternative.</p>
<p>Exceptions are the easy example here, but just know this also applies to asynchronous
functions with <code>Future&lt;T&gt;</code> values or other types that are usually some wrapped effect.</p>
<p>So without exceptions we may use an error union or optional value like <code>Maybe t</code> which can be
<code>Some t</code> or <code>None</code>. If we have several computations returning results, we’ll need
to <code>map</code> the <code>Some</code> value in-between steps:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>// Imagine we have:</span>
<span>try_get_line_from_stdin</span> <span>()</span><span>:</span> <span>Maybe</span> <span>String</span> <span>can</span> <span>IO</span> <span>=</span> <span>...</span>
<span>try_parse</span> <span>(</span><span>s</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>Maybe</span> <span>U32</span> <span>=</span> <span>...</span>

<span>// read an integer from stdin, returning that value doubled</span>
<span>call_failable_functions</span> <span>()</span><span>:</span> <span>Maybe</span> <span>U32</span> <span>can</span> <span>IO</span> <span>=</span>
    <span>try_get_line_from_stdin</span> <span>()</span> <span>|&gt;.</span><span>and_then</span> <span>fn</span> <span>line</span> <span>-&gt;</span>
        <span>try_parse</span> <span>line</span> <span>|&gt;.</span><span>map</span> <span>fn</span> <span>x</span> <span>-&gt;</span>
            <span>x</span> <span>*</span> <span>2</span>
</code></pre></div><p>This is cumbersome enough languages like Rust provide syntax-sugar like <code>?</code>
to automatically return error values and focus on the good path. That isn’t
needed with effects though. The direct approach just works:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>// Now imagine we have:</span>
<span>get_line_from_stdin</span> <span>()</span><span>:</span> <span>String</span> <span>can</span> <span>Fail</span><span>,</span> <span>IO</span> <span>=</span> <span>...</span>
<span>parse</span> <span>(</span><span>s</span><span>:</span> <span>String</span><span>)</span><span>:</span> <span>U32</span> <span>can</span> <span>Fail</span> <span>=</span> <span>...</span>

<span>// read an integer from stdin, returning that value doubled</span>
<span>call_failable_functions</span> <span>()</span><span>:</span> <span>U32</span> <span>can</span> <span>Fail</span> <span>=</span>
    <span>line</span> <span>=</span> <span>get_line_from_stdin</span> <span>()</span>
    <span>x</span> <span>=</span> <span>parse</span> <span>line</span>
    <span>x</span> <span>*</span> <span>2</span>
</code></pre></div><p>If we need to go off the good path we can just apply a handler:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>call_failable_functions</span> <span>()</span><span>:</span> <span>U32</span> <span>can</span> <span>Fail</span> <span>=</span>
    <span>// get_line_from_stdin&#39;s Fail effect is now handled by `default` which returns &#34;42&#34; instead of failing</span>
    <span>line</span> <span>=</span> <span>get_line_from_stdin</span> <span>()</span> <span>with</span> <span>default</span> <span>&#34;42&#34;</span>
    <span>x</span> <span>=</span> <span>parse</span> <span>line</span>
    <span>x</span> <span>*</span> <span>2</span>
</code></pre></div><p>Compared to error unions we never have to wrap our data in <code>Some</code>/<code>Ok</code> and we don’t
have to worry about error types not composing well either:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>// Now imagine we have:</span>
<span>LibraryA</span><span>.</span><span>foo</span> <span>()</span><span>:</span> <span>U32</span> <span>can</span> <span>Throw</span> <span>LibraryA</span><span>.</span><span>Error</span> <span>=</span> <span>...</span>
<span>LibraryB</span><span>.</span><span>bar</span> <span>()</span><span>:</span> <span>U32</span> <span>can</span> <span>Throw</span> <span>LibraryB</span><span>.</span><span>Error</span> <span>=</span> <span>...</span>

<span>type</span> <span>MyError</span> <span>=</span> <span>message</span><span>:</span> <span>String</span>

<span>// Composing the different error types just works</span>
<span>my_function</span> <span>()</span><span>:</span> <span>Unit</span> <span>can</span> <span>Throw</span> <span>LibraryA</span><span>.</span><span>Error</span><span>,</span> <span>Throw</span> <span>LibraryB</span><span>.</span><span>Error</span><span>,</span> <span>Throw</span> <span>MyError</span> <span>=</span>
    <span>x</span> <span>=</span> <span>LibraryA</span><span>.</span><span>foo</span> <span>()</span>
    <span>y</span> <span>=</span> <span>LibraryB</span><span>.</span><span>bar</span> <span>()</span>
    <span>if</span> <span>x</span> <span>+</span> <span>y</span> <span>&lt;</span> <span>10</span> <span>then</span>
        <span>throw</span> <span>(</span><span>MyError</span> <span>&#34;The results of `foo` and `bar` are too small&#34;</span><span>)</span>
</code></pre></div><p>And if it gets too cumbersome to type out all those <code>Throw</code> clauses we can make a type alias
for the effects we want to handle:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>AllErrors</span> <span>=</span> <span>can</span> <span>Throw</span> <span>LibraryA</span><span>.</span><span>Error</span><span>,</span> <span>Throw</span> <span>LibraryB</span><span>.</span><span>Error</span><span>,</span> <span>Throw</span> <span>MyError</span>

<span>my_function</span> <span>()</span><span>:</span> <span>Unit</span> <span>can</span> <span>AllErrors</span> <span>=</span>
    <span>x</span> <span>=</span> <span>LibraryA</span><span>.</span><span>foo</span> <span>()</span>
    <span>y</span> <span>=</span> <span>LibraryB</span><span>.</span><span>bar</span> <span>()</span>
    <span>if</span> <span>x</span> <span>+</span> <span>y</span> <span>&lt;</span> <span>10</span> <span>then</span>
        <span>throw</span> <span>(</span><span>MyError</span> <span>&#34;The results of `foo` and `bar` are too small&#34;</span><span>)</span>
</code></pre></div><p>You can think of this as being similar to using an anonymous union type for error returns.
We don’t need to define explicit wrappers to combine all the errors we use as with tagged
unions, and different error types compose naturally into the union. This also means if a
library <code>can Throw String</code>, and our code also <code>can Throw String</code>, these will combine into
just one <code>can Throw String</code> effect. If we want to keep them separate we need to use a wrapper
type like <code>MyError</code> above.</p>
<hr/>
<h2 id="guaranteeing-purity">Guaranteeing Purity</h2>
<p>Most languages with effect handlers (barring perhaps only OCaml) also use effects wherever
side-effects may occur. You may have noticed the <code>can Print</code> or <code>can IO</code> on previous examples,
and it’s true - you can’t use side-effects in Ante without marking that the function may perform
them<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>. Setting aside the cases when <code>IO</code> or print outs are redirected or used for mocking,
these effects are usually handled in <code>main</code> automatically - so what benefit does it actually
provide by making programmers mark these functions?</p>
<p>For one, a number of functions actually require other non-side-effectful (ie. pure) functions
as input. When spawning threads for example, we can’t allow the spawning thread to call into
handlers owned by our thread:</p>
<div><pre tabindex="0"><code data-lang="ante"><span>// Spawn all the given functions as threads and wait until they complete</span>
<span>spawn_all</span> <span>(</span><span>functions</span><span>:</span> <span>Vec</span> <span>(</span><span>Unit</span> <span>-&gt;</span> <span>a</span> <span>pure</span><span>))</span><span>:</span> <span>Vec</span> <span>a</span> <span>can</span> <span>IO</span> <span>=</span> <span>...</span>
</code></pre></div><p>There is also a technique for concurrency called Software Transactional Memory (STM) which
requires pure functions. It works by running many functions simultaneously and if a value is
ever mutated out from under one thread while it was performing a transaction, it just restarts
that transaction. For the curious, there’s a proof of concept implementation of it in Effekt
<a href="https://github.com/effekt-community/effekt-stm/blob/main/stm.effekt">here</a>.</p>
<h3 id="replayability">Replayability</h3>
<p>Another neat aspect of purity is that it can give you replayability similar to the <code>rr</code> debugging
utility. This is the tech needed for deterministic network replication and log structured backups
used in databases and videogame networking.</p>
<p>To implement this you would need two handlers: <code>record</code> and <code>replay</code> which handle the top-level
effect emitted by <code>main</code>. In most languages this is named <code>IO</code>. <code>record</code> would record that the
effect occurred, re-raise it to be handled by the built-in <code>IO</code> handler, and record its result.
Then, on another run <code>replay</code> would handle <code>IO</code> and use the results from the effect log instead
of actually performing them. A particularly smart language could even <code>record</code> by default in
debug builds to always get deterministic debugging!</p>
<h3 id="capability-based-security">Capability-based Security</h3>
<p>The requirement to include all unhandled effects as part of the type signature of a function
helps greatly when auditing the security of libraries. When you call a function
<code>get_pi: Unit -&gt; F64</code> you know that it isn’t doing any sneaky IO in the background. If that
library is later updated to <code>get_pi: Unit -&gt; F64 can IO</code> you know something suspicious is
probably happening, and you’ll get an error in your code as long as the function you’re calling
<code>get_pi</code> in doesn’t already require the <code>IO</code> effect<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup><sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>. This has parallels with <a href="https://joeduffyblog.com/2015/11/10/objects-as-secure-capabilities/">Capability
Based Security</a>
(bonus paper <a href="https://arxiv.org/abs/2005.11444">Designing with Static Capabilities and Effects</a>)
where we must pass around capabilities like <code>fs: FileSystem</code> as explicit objects and only
functions with these objects can access the file system. With algebraic effects it works similarly
except the functions declare effects instead of taking capability parameters. There is a downside
to the effect approach though, and its the same one mentioned above: since effects are automatically
threaded through your program you won’t get an error if a function like <code>get_pi</code> is updated to
require <code>IO</code> if your function also already requires that effect. This can crop up anywhere
effects are used. E.g. with a <code>Fail</code> effect if a library function can’t <code>Fail</code> but then was
updated to possibly <code>Fail</code>, it’ll propagate upward to your existing <code>Fail</code> handler if used in
one of your functions that also can <code>Fail</code>. This may be fine but it may also be unintended depending
on the program. For example, perhaps a user may have preferred to handle it by providing a default value.</p>
<hr/>
<p>Whew! That was a lot, but we made it through. Obviously this post focused on the positives of effects
and why I think they’re going to be much more pervasive in the future, but there are negatives as well.
Aside from the accidental handling of effects issue mentioned above, the main downside with effects has
traditionally been efficiency concerns, although it should be said that compilation output of effects has improved
greatly in recent years. Most languages with algebraic effects will optimize “tail-resumptive” effects
(any effect where the last thing the handler does is call <code>resume</code>) into normal closure calls. This is great
because this is already most effects in practice (citation needed - although almost all the examples in this blog
post fit in this category! Exceptions being the only, <em>ahem</em>, exception here since they do not <code>resume</code> at all).
Different languages also have their own strategies for optimizing the remaining
effect handlers: <a href="https://koka-lang.github.io/koka/doc/index.html">Koka</a> uses
<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2021/08/genev-icfp21.pdf">evidence passing</a>
and bubbles up effects to handlers to compile to C without a runtime, <a href="https://antelang.org/">Ante</a> and
<a href="https://github.com/ocaml-multicore/ocaml-effects-tutorial">OCaml</a> limit <code>resume</code> to only being called
at most once which precludes some effects like non-determinism but simplifies resource handling and
allows the internal continuations to be implemented more efficiently (e.g. via segmented stacks), and
<a href="https://effekt-lang.org/">Effekt</a> specializes handlers out of the program completely<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup>!</p>


                        </div></div>
  </body>
</html>
