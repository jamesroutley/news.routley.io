<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eli.thegreenplace.net/2022/rust-extension-traits-greppability-and-ides/">Original</a>
    <h1>Rust extension traits, greppability and IDEs</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                <p>Traits are a central feature of Rust, critical for its implementation of
polymorphism; traits are used for both static (by serving as bounds for generic
parameters) and dynamic (by having trait objects to serve as interfaces)
polymorphism.</p>
<p>This post assumes some familiarity with traits and discusses only a specific
aspect of them - how <em>extension traits</em> affect code readability. To learn the
basics of traits in Rust, the <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">official book</a> is a good starting point.</p>
<div id="extension-traits">
<h2>Extension traits</h2>
<p><a href="https://rust-lang.github.io/rfcs/0445-extension-trait-conventions.html">This Rust RFC</a>
provides a good, short definition of extension traits:</p>
<blockquote>
Extension traits are a programming pattern that makes it possible to add
methods to an existing type outside of the crate defining that type.</blockquote>
<p>For example, here&#39;s a trait with a single method:</p>
<div><pre><span></span><span>trait</span><span> </span><span>Magic</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>magic_num</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>usize</span><span>;</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>We can now implement the <tt>Magic</tt> trait for our types:</p>
<div><pre><span></span><span>struct</span> <span>Foobar</span><span> </span><span>{</span><span></span>
<span>    </span><span>name</span>: <span>String</span><span>,</span><span></span>
<span>}</span><span></span>

<span>impl</span><span> </span><span>Magic</span><span> </span><span>for</span><span> </span><span>Foobar</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>magic_num</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>usize</span> <span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>if</span><span> </span><span>self</span><span>.</span><span>name</span><span>.</span><span>len</span><span>()</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>2</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>33</span><span> </span><span>};</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>Now a <tt>FooBar</tt> can be passed wherever a <tt>Magic</tt> is expected. <tt>FooBar</tt> is a
custom type, but what&#39;s really interesting is that we can also implement
<tt>Magic</tt> for any other type, including types that we did not define. Let&#39;s
implement it for <tt>bool</tt>:</p>
<div><pre><span></span><span>impl</span><span> </span><span>Magic</span><span> </span><span>for</span><span> </span><span>bool</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>magic_num</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>usize</span> <span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>if</span><span> </span><span>*</span><span>self</span><span> </span><span>{</span><span> </span><span>3</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>54</span><span> </span><span>};</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
<p>We can now write code like <tt>true.magic_num()</tt> and it will work! We&#39;ve added
a method to a built-in Rust type. Obviously, we can also implement this trait
for types in the standard library; e.g.:</p>
<div><pre><span></span><span>impl</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>Magic</span><span> </span><span>for</span><span> </span><span>Vec</span><span>&lt;</span><span>T</span><span>&gt;</span><span> </span><span>{</span><span></span>
<span>    </span><span>fn</span> <span>magic_num</span><span>(</span><span>&amp;</span><span>self</span><span>)</span><span> </span>-&gt; <span>usize</span> <span>{</span><span></span>
<span>        </span><span>return</span><span> </span><span>if</span><span> </span><span>self</span><span>.</span><span>len</span><span>()</span><span> </span><span>==</span><span> </span><span>0</span><span> </span><span>{</span><span> </span><span>10</span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span> </span><span>5</span><span> </span><span>};</span><span></span>
<span>    </span><span>}</span><span></span>
<span>}</span><span></span>
</pre></div>
</div>
<div id="extension-traits-in-the-wild">
<h2>Extension traits in the wild</h2>
<p>Extension traits aren&#39;t just a fringe feature; they are widely used in the Rust
ecosystem.</p>
<p>One example is the popular <tt>serde</tt> crate, which includes code that serializes
and deserializes data structures in multiple formats. One of the traits
<tt>serde</tt> provides is <tt><span>serde::Serialize</span></tt>; once we import this trait and one of
the concrete serializers <tt>serde</tt> provides, we can do stuff like <a href="#id3" id="id1">[1]</a>:</p>
<div><pre><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>serializer</span><span> </span><span>=</span><span> </span><span>serde_json</span>::<span>Serializer</span>::<span>new</span><span>(</span><span>std</span>::<span>io</span>::<span>stdout</span><span>());</span><span></span>
<span>185.</span><span>serialize</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>serializer</span><span>).</span><span>unwrap</span><span>();</span><span></span>
</pre></div>
<p>Importing <tt><span>serde::Serialize</span></tt> is critical for this code to work, even though we
don&#39;t refer to <tt>Serialize</tt> anywhere in our code explicitly. Rust requires
traits to be explicitly imported to imbue their methods onto existing types;
otherwise it&#39;s hard to avoid naming collisions in case multiple traits from
different crates provide the same methods.</p>
<p>Another example is the  <tt>byteorder</tt> crate, which helps encode numbers into
buffers with explicit length and endianness. To write some numbers into a vector
byte-by-byte, we have to import the relevant trait and enum first, and then
we can call the newly-added methods directly on a vector:</p>
<div><pre><span></span><span>use</span><span> </span><span>byteorder</span>::<span>{</span><span>LittleEndian</span><span>,</span><span> </span><span>WriteBytesExt</span><span>};</span><span></span>

<span>// ...</span>

<span>let</span><span> </span><span>mut</span><span> </span><span>wv</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[];</span><span></span>
<span>wv</span><span>.</span><span>write_u16</span>::<span>&lt;</span><span>LittleEndian</span><span>&gt;</span><span>(</span><span>259</span><span>).</span><span>unwrap</span><span>();</span><span></span>
<span>wv</span><span>.</span><span>write_u16</span>::<span>&lt;</span><span>LittleEndian</span><span>&gt;</span><span>(</span><span>517</span><span>).</span><span>unwrap</span><span>();</span><span></span>
</pre></div>
<p>The <tt>write_u16</tt> method is part of the <tt>WriteBytesExt</tt> trait, and it&#39;s
implemented on a <tt>Vec</tt> by the <tt>byteorder</tt> crate. To be more precise, it&#39;s
automatically implemented on any type that implements the <tt>Write</tt> trait.</p>
<p>Finally, let&#39;s look at <tt>rayon</tt> - a library for simplified data-parallelism. It
provides magical iterators that have the same functionality as <tt>iter</tt> but
compute their results in parallel, leveraging multiple CPU cores. The <tt>rayon</tt>
documentation recommends to import the traits the crate injects as follows:</p>
<blockquote>
It is recommended that you import all of these traits at once by adding
<tt>use <span>rayon::prelude::*</span></tt> at the top of each module that uses Rayon methods.</blockquote>
<p>Having imported it thus, we can proceed to use Rayon as follows:</p>
<div><pre><span></span><span>let</span><span> </span><span>exps</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[</span><span>2</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>6</span><span>,</span><span> </span><span>12</span><span>,</span><span> </span><span>24</span><span>];</span><span></span>
<span>let</span><span> </span><span>pows_of_two</span>: <span>Vec</span><span>&lt;</span><span>_</span><span>&gt;</span><span> </span><span>=</span><span> </span><span>exps</span><span>.</span><span>par_iter</span><span>().</span><span>map</span><span>(</span><span>|</span><span>n</span><span>|</span><span> </span><span>2_</span><span>u64</span><span>.</span><span>pow</span><span>(</span><span>*</span><span>n</span><span>)).</span><span>collect</span><span>();</span><span></span>
</pre></div>
<p>Note the <tt>par_iter</tt>, which replaces a regular <tt>iter</tt>. It&#39;s been magically
implemented on a vector, as well as a bunch of other types that support
iteration.</p>
</div>
<div id="on-greppability-and-code-readability">
<h2>On greppability and code readability</h2>
<p>All these uses of extension traits are pretty cool and useful, no doubt. But
that&#39;s not the main point of my post. What I really want to discuss is how the
general approach relates to <em>code readability</em>, which is in my mind one of the
most important aspects of programming we should all be thinking about.</p>
<p>This Rust technique fails the <em>greppability</em> test; it&#39;s not a word I made up -
google it! If it&#39;s not immediately apparent, greppability means the ability to
explore a code base using textual search tools like <tt>grep</tt>, <tt>git grep</tt>,
<tt>ripgrep</tt>, <a href="https://github.com/eliben/pss/">pss</a> or what have you.</p>
<p>Suppose you encounter this piece of code in a project you&#39;re exploring:</p>
<div><pre><span></span><span>let</span><span> </span><span>mut</span><span> </span><span>wv</span><span> </span><span>=</span><span> </span><span>vec</span><span>!</span><span>[];</span><span></span>
<span>wv</span><span>.</span><span>write_u16</span>::<span>&lt;</span><span>LittleEndian</span><span>&gt;</span><span>(</span><span>259</span><span>).</span><span>unwrap</span><span>();</span><span></span>
</pre></div>
<p>&#34;Interesting&#34;, you think, &#34;I didn&#39;t know that <tt>Vec</tt> has a <tt>write_u16</tt>
method&#34;. You quickly check the documentation - indeed, it doesn&#39;t! So where is
it coming from? You <tt>grep</tt> the project... nothing. It&#39;s nowhere in the
imports. You examine the imports one by one, and notice the:</p>
<div><pre><span></span><span>use</span><span> </span><span>byteorder</span>::<span>{</span><span>LittleEndian</span><span>,</span><span> </span><span>WriteBytesExt</span><span>};</span><span></span>
</pre></div>
<p>&#34;Aha!&#34;, you say, &#34;this imports <tt>LittleEndian</tt>, so maybe this has to do with
the <tt>byteorder</tt> crate&#34;. You check the documentation of that crate and indeed,
you find the <tt>write_u16</tt> method there; phew.</p>
<p>With <tt>par_iter</tt> you&#39;re less lucky. Nothing in imports will catch your eye,
unless you&#39;re already familiar with the <tt>rayon</tt> crate. If you&#39;re not, then
<tt>use <span>rayon::prelude::*</span></tt> won&#39;t ring much of a bell in relation to <tt>par_iter</tt>.</p>
<p>Of course, you can just google this symbol <a href="https://www.google.com/search?q=rust+par_iter">like this</a> and you&#39;ll find it. Or maybe
you don&#39;t even understand what the problem is, because your IDE is perfectly
familiar with these symbols and will gladly pop up their documentation when you
hover over them.</p>
</div>
<div id="ides-and-language-servers">
<h2>IDEs and language servers</h2>
<p>These days we have free, powerful and fast IDEs that make all of this a
non-issue (looking at Visual Studio Code, of course). Coupled with smart
<em>language servers</em>, these IDEs are as familiar with your code as the compiler;
the language servers typically run a full front-end sequence on the code, ending
up with type-checked ASTs cross-referenced with symbol tables that let them
understand where each symbol is coming from, its type and so on. For Rust the
language server is RLS, for Go its gopls; all popular languages have them these
days <a href="#id4" id="id2">[2]</a>.</p>
<p>It&#39;s entirely possible that using a language like Rust without a sophisticated
IDE is madness, and I&#39;m somewhat stuck in the past. But I have to say, I do
lament the loss of greppability. There&#39;s something very universal about being
able to understand a project using only <tt>grep</tt> and the official documentation.</p>
<p>In fact, for some languages it&#39;s likely that this has been the case for a long
while already. Who in their right mind has the courage to tackle a Java project
without an IDE? It&#39;s just that this wasn&#39;t always the case for systems
programming languages, and Rust going this way makes me slightly sad. Or maybe
I&#39;m just too indoctrinated in Go at this point, where all symbol access happens
as <tt>package.Symbol</tt>, packages are imported explicitly and there is no magic
name injection anywhere (almost certainly by design).</p>
<p>I can&#39;t exactly put my finger on why this is bothering me; perhaps I&#39;m just
<a href="https://knowyourmeme.com/memes/old-man-yells-at-cloud">yelling at clouds</a>
here. While I&#39;m at it, I should finally write that post about <tt>printf</tt>-based
debugging...</p>
<hr/>


</div>

            </div></div>
  </body>
</html>
