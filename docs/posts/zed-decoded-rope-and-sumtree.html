<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zed.dev/blog/zed-decoded-rope-sumtree">Original</a>
    <h1>Zed Decoded: Rope and SumTree</h1>
    
    <div id="readability-page-1" class="page"><div><article><header></header><p>For this second post in <strong>Zed Decoded</strong>, our blog &amp; video series in which we&#39;re taking a closer look at how Zed is built, I&#39;ve talked to Zed&#39;s three co-founders — Nathan, Max, Antonio — about the data structure at the heart of Zed: the rope.</p>
<div><div><div><p><b>Companion Video</b>: <!-- -->Rope &amp; SumTree</p><p>This post comes with a 1hr companion video, in which Thorsten, Nathan, Antonio, and Max use Zed to look at how Zed uses the Rope and SumTree types. It&#39;s a loose conversation in which we write and read a lot of code to understand how the rope in Zed works and is implemented.</p><p>Watch the video here:<!-- --> <a href="https://youtu.be/uUu9eFNNbjg">https://youtu.be/uUu9eFNNbjg</a></p></div><p><img src="https://zed.dev/img/post/zed-decoded-rope-sumtree/thumbnail.jpg" width="230" height="150"/></p></div></div>
<p>Going in I knew that data structures to represent text are a favorite topic in text editor circles. I had also used the <code>Rope</code> type in the Zed codebase and knew a little bit about ropes.</p>
<p>What I didn&#39;t really understand was how Zed&#39;s rope is implemented and what that implementation enables. So I asked Nathan, Max, and Antonio about it. They&#39;ve been writing code on top, below and inside the rope for years now. And, as it turns out, Zed&#39;s rope isn&#39;t really a rope, at least not in the classical sense. It&#39;s very impressive, but first: what&#39;s a rope?</p>
<h2 id="why-not-a-string"><span data-br=":R4nbrrrqbf9la:" data-brr="1">Why not a string?</span></h2>
<p>One of the most important things a text editor has to do is to represent text in memory. When you open a file in a text editor, you expect to see its contents and want to navigate through it, and — hey, that&#39;s where the name comes from — you also want to <em>edit</em> the text.</p>
<p>To do that, a text editor has to load the file contents into memory — you can&#39;t just let the user stare at the raw bytes on disk. You also <em>want</em> to keep it in memory, because not every change should immediately be saved to disk.</p>
<p>So the question is: how do you represent the text in memory?</p>
<p>My naive first choice would be to use a string. Good old string. Our best friend from when we started programming. Why not use a string? It&#39;s how we represent text in memory all the time. It&#39;s not immediately obvious that that would be a bad choice, right?</p>
<p>Hey, I bet you <em>could</em> go a long way with a string, but there are some problems with strings that prevent them from being the best choice, especially once you start dealing with large files and want your program to still be efficient and responsive.</p>
<h3 id="problems-with-strings"><span data-br=":Ranbrrrqbf9la:" data-brr="1">Problems with strings</span></h3>
<p>Strings are usually allocated as a continuous block of memory. That can make edits inefficient. Say you have a file with 20k lines in a string and you want to insert a word right in the middle of that string. In order to do that, you have to make room for the new word in the middle of the string, so that you still end up with a string that&#39;s a continuous block of memory. And to make room, you have to move all of the text that would come after your newly inserted word. And moving here really means making allocations. In the worst case you have to move everything — all 20k lines — to make room for your new word.</p>
<p>Or say you want to delete a word: you can&#39;t just poke a hole in a string, because that would mean it isn&#39;t a string — a continuous block of memory — anymore. Instead you have to move all the characters except the ones you deleted, so that you end up with a single, continuous block of memory again, this time without the deleted word.</p>
<p>When dealing with small files and small strings, these aren&#39;t problems. We all do similar string operations all day every day, right? Yes, but most of the time we&#39;re talking about relatively small strings. When you&#39;re dealing with large files and thus large strings or a lot of edits (maybe even at the same time — hello multiple cursors!) these things — allocations, moving strings in memory — become problems.</p>
<p>And that&#39;s not even touching on all the other requirements a text editor might have of its text representation.</p>
<p>Navigation, for example. What if the user wants to jump to line 523? With a string and without any other data, you&#39;d have to go through the string, character by character, and count the line breaks in it to find out where in the string line 523 is. And then what if the user presses the down-arrow ten times to go down ten lines and wants to end up in the same column? You&#39;ll again have to start counting line breaks in your string and then find the right offset after the last line break.</p>
<p>Or, say you want to draw a horizontal scrollbar at the bottom of your editor. To know how big the scroll thumb has to be, you have to know how long the longest line in the file is. Same thing again: you have to go through the string and count the lines and this time keeping track of the length of each line too.</p>
<p>Or what if the text file you want to load into your editor is larger than 1GB and the language you used to implement your text editor can <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length">only represent strings up to 1GB</a>? You might say &#34;1GB of string should be enough for everybody&#34; but that only tells me you haven&#39;t talked to enough users of text editors yet.</p>
<p>Kidding aside, I think we&#39;ve established that strings probably aren&#39;t the best solution to represent text in a text editor.</p>
<p>So what else can we use?</p>
<h2 id="whats-better-than-a-string"><span data-br=":Rknbrrrqbf9la:" data-brr="1">What&#39;s better than a string?</span></h2>
<p>If you really love strings, you might now be thinking &#34;better than a string? easy: multiple strings.&#34; And you wouldn&#39;t be that far off! Some editors <em>do</em> represent text as an array-of-lines with each line being a string. VS Code&#39;s <a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation">Monaco editor worked that way for quite a while</a>, but an array of strings can still be plagued by the same problems as a single string. Excessive memory consumption and performance issues made the VS Code team look for something better.</p>
<p>Luckily, there are better things than strings. Builders of text editors have long ago realized that strings aren&#39;t the best tool for the job and have come up with other data structures to represent text.</p>
<p>The most popular ones, as far as I can tell, are <a href="https://en.wikipedia.org/wiki/Gap_buffer">gap buffers</a>, <a href="https://en.wikipedia.org/wiki/Piece_table">piece tables</a>, and <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)">ropes</a>.</p>
<p>They each have their pros and cons and I&#39;m not here to compare them in detail. It&#39;s enough to know that they are all significantly better than strings and different editors made different decisions in face of different trade-offs and ended up with different data structures. To give you a taste: <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Buffer-Gap.html">Emacs uses gap buffers</a>, VS Code uses <a href="https://code.visualstudio.com/blogs/2018/03/23/text-buffer-reimplementation">a twist on piece tables</a>, Vim has <a href="https://github.com/vim/vim/blob/master/src/memline.c#L15">its own tree data structure</a>, and Helix <a href="https://github.com/helix-editor/helix/blob/master/docs/architecture.md">uses a rope</a>.</p>
<p>Zed, too, uses a rope. So let&#39;s take a look at the rope and see what advantages that has over a string.</p>
<h2 id="ropes"><span data-br=":Rqnbrrrqbf9la:" data-brr="1">Ropes</span></h2>
<p>Here&#39;s how Wikipedia explains what a rope is:</p>
<blockquote>
<p>A rope is a type of binary tree where each leaf (end node) holds a string and a length (also known as a &#34;weight&#34;), and each node further up the tree holds the sum of the lengths of all the leaves in its left subtree.</p>
</blockquote>
<p>Instead of a continuous block of memory, a rope is a tree and its leaves are the characters of the text it represents.</p>
<p>Here&#39;s what the text <code>&#34;This is a rope&#34;</code> would look like in a rope:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-sumtree/rope.png" alt="A rope representing &#34;This is a rope&#34;"/><figcaption>A rope representing &#34;This is a rope&#34;</figcaption></figure></div>
<p>You might now be thinking that this is a lot more complex than a string and you&#39;d be right — it is. But here&#39;s the crucial bit that makes this a rope triumph over strings in many cases: the leaves - <code>&#34;This&#34;, &#34; is &#34;, &#34;a &#34;, &#34;rope&#34;</code> — are essentially <em>immutable</em>. Instead of modifying strings, you modify the tree. Instead of poking holes in strings and moving parts of it around it memory, you modify the tree to get a new string. And by now, we as programmers have figured out how to efficiently work with trees.</p>
<p>Let&#39;s use the example from above again: deleting a word at a certain position in the text. With a string, you&#39;d have to reallocate all of the text that comes after the word, possibly the whole string. With a rope, you find the start and end positions of the word you want to delete, then split the tree at these two positions so you have four trees, you throw away the middle two trees (that only contain the deleted word), concatenate the other two, then rebalance the tree. Yes, <em>it does</em> sound like a lot and it does require some algorithmic finesse under the hood, but the memory and performance improvements over strings are very real: instead of moving things around in memory, you only have to update a few pointers. That might look silly for a text as short as <code>&#34;This is a rope&#34;</code>, but it pays off big time when you have very large texts.</p>
<p>I understand that this is very abstract, so let me show you. Let&#39;s take a look at Zed&#39;s rope implementation.</p>
<h2 id="zeds-rope-implementation"><span data-br=":R13nbrrrqbf9la:" data-brr="1">Zed&#39;s rope implementation</span></h2>
<p>Zed has its own rope implementation in its own crate: <a href="https://github.com/zed-industries/zed/blob/ae3c641bbee2029fb4588d008e45ddb783593622/crates/rope/src/rope.rs"><code>rope</code></a>. (One reason for why Zed has its own implementation instead of using a library is that a lot of libraries didn&#39;t exist when the Zed founders laid the groundwork for Zed in 2017.)</p>
<p>The main type in the <code>rope</code> crate is <code>Rope</code>. Here&#39;s how you&#39;d use it:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>let</span><span> mut</span><span> rope</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;Hello World! This is your captain speaking.&#34;</span><span>);</span></span></code></pre></div></figure>
<p>So far, so similar to <code>String</code>. Now let&#39;s say we have two ropes:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>let</span><span> mut</span><span> rope1</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope1</span><span>.</span><span>push</span><span>(</span><span>&#34;Hello World!&#34;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>let</span><span> mut</span><span> rope2</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope2</span><span>.</span><span>push</span><span>(</span><span>&#34;This is your captain speaking.&#34;</span><span>);</span></span></code></pre></div></figure>
<p>If we want to concatenate them, all we have to do is this:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>rope1</span><span>.</span><span>append</span><span>(</span><span>rope2</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>assert_eq!</span><span>(</span></span>
<span data-line=""><span>    rope1</span><span>.</span><span>text</span><span>(),</span></span>
<span data-line=""><span>    &#34;Hello World! This is your captain speaking.&#34;</span><span>.</span><span>to_string</span><span>()</span></span>
<span data-line=""><span>);</span></span></code></pre></div></figure>
<p>The call to <code>rope1.append</code> connects the two trees — <code>rope1</code> and <code>rope2</code> — by building a new tree that contains both. That&#39;s barely more than updating a few pointers. Compare that to strings: if you concatenate two strings, you&#39;ll have to move at least one of them in memory so that they end up next to each, forming a continuous block. Often you have to move both of them, because there&#39;s not enough space after the first string. Again: the text in this example is laughably short, but what if someone wants to have ten copies of the 25k line <a href="https://sqlite.org/amalgamation.html">SQLite amalgamation</a> in a single file?</p>
<p>What about replacing a word?</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>// Construct a rope</span></span>
<span data-line=""><span>let</span><span> mut</span><span> rope</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;One coffee, please. Black, yes.&#34;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Replace characters 4 to 10 (0-indexed) with &#34;guinness&#34;.</span></span>
<span data-line=""><span>rope</span><span>.</span><span>replace</span><span>(</span><span>4</span><span>..</span><span>10</span><span>, </span><span>&#34;guinness&#34;</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>rope</span><span>.</span><span>text</span><span>(), </span><span>&#34;One guinness, please. Black, yes.&#34;</span><span>);</span></span></code></pre></div></figure>
<p>What happens under the hood:</p>
<ul>
<li><code>replace()</code> creates a new rope that contains all of the nodes of the original <code>rope</code>, up until the 5th character (<code>c</code>)</li>
<li>the new text, <code>guinness</code>, is appended to the new rope</li>
<li>the rest of the original <code>rope</code>, everything after character 11, is appended to the new rope</li>
</ul>
<p>Deleting a word? Just replace it with <code>&#34;&#34;</code>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>let</span><span> mut</span><span> rope</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;One coffee, please. Black, yes.&#34;</span><span>);</span></span>
<span data-line=""><span>rope</span><span>.</span><span>replace</span><span>(</span><span>4</span><span>..</span><span>10</span><span>, </span><span>&#34;&#34;</span><span>);</span></span></code></pre></div></figure>
<p>These operations are very quick even when dealing with large amounts of text, because then most of the nodes in the tree can be reused and only have to be rewired.</p>
<p>But what happens with the word that was deleted, <code>&#34;coffee&#34;</code>? The leaf nodes that contain these characters will get automatically cleaned up as soon as no other node references them anymore. That&#39;s what immutable leaf nodes in ropes enable: when a rope is mutated, or a new rope is constructed from an old one, or two ropes are merged into a new one, essentially all that&#39;s changing are references to leaf nodes. And those <a href="https://en.wikipedia.org/wiki/Reference_counting">references are counted</a>: as soon as there&#39;s no reference to a node anymore, the node gets cleaned up, deallocated.</p>
<p>To be precise and get technical: the leaf nodes, the ones containing the actual text, aren&#39;t fully immutable in Zed&#39;s rope implementation. These leaf nodes have a maximum length and if, say, text gets appended to a rope and the new text is short enough to fit into the last leaf node without exceeding its maximum length, then that leaf node will be mutated and the text appended to it.</p>
<p>On a conceptual level, though, you can think of the rope as a persistent data structure and its nodes as reference-counted immutable nodes in a tree. That&#39;s what makes it a better choice than the string and brings us back to the question we skipped above: why did Zed chose a rope instead of one of the other data structures?</p>
<h2 id="why-use-a-rope-in-zed"><span data-br=":R1mnbrrrqbf9la:" data-brr="1">Why use a rope in Zed?</span></h2>
<p>Zed&#39;s goal is to be a high-performance code editor. Strings, as we saw, won&#39;t get you to high-performance. So what do you use instead? Gap buffers, ropes, piece tables?</p>
<p>There isn&#39;t a single, obvious best choice here. It all comes down to specific requirements and trade-offs you&#39;re willing to make to meet those requirements.</p>
<p>Maybe you&#39;ve heard that <a href="https://coredumped.dev/2023/08/09/text-showdown-gap-buffers-vs-ropes/">gap buffers can be faster than ropes</a>, or that they&#39;re easier to understand, or that piece tables are more elegant. That may be true, yes, but that still doesn&#39;t mean they&#39;re an obvious choice over, for example, a rope. Here&#39;s what <a href="https://github.com/emacs-ng/emacs-ng/issues/378#issuecomment-907680382">the author of <code>ropey</code>, a popular rope implementation in Rust, wrote about the performance trade-offs between ropes and gap buffers</a>:</p>
<blockquote>
<p>Ropes make a different performance trade-off, being a sort of &#34;jack of all trades&#34;. They&#39;re not amazing at anything, but they&#39;re always solidly good with <code>O(log N)</code> performance. They&#39;re not the best choice for an editor that only supports local editing patterns, since they leave a lot of performance on the table compared to gap buffers in that case (again, even for huge documents). But for an editor that encourages non-localized edits, or just wants flexibility in that regard, they&#39;re a great choice because they always have good performance, whereas gap buffers degrade poorly with unfavorable editing patterns.</p>
</blockquote>
<p>Ropes are &#34;not amazing at anything, but they&#39;re always solidly good.&#34; It depends on what you want to do, or what you want your editor to be able to do.</p>
<p>So what if you really want to make use of all the cores in your CPU? In <a href="https://coredumped.dev/2023/08/09/text-showdown-gap-buffers-vs-ropes/">&#34;Text showdown: Gap Buffers vs Ropes&#34;</a> concurrency is mentioned in a paragraph at the end:</p>
<blockquote>
<p>Ropes have other benefits besides good performance. Both Crop and Ropey [note: both are rope implementations in Rust] support concurrent access from multiple threads. This lets you take snapshots to do asynchronous saves, backups, or multi-user edits. This isn&#39;t something you could easily do with a gap buffer.</p>
</blockquote>
<p>In the <a href="https://youtu.be/uUu9eFNNbjg">companion video</a> you can hear what Max said about this paragraph: &#34;Yeah, it matters more than any of that other stuff.&#34; Nathan added that &#34;we use that all over the place&#34;, with &#34;that&#34; being concurrent access, snapshots, multi-user edits, asynchronous operations.</p>
<p>In other words: concurrent access to the text in a buffer was a hard requirement for Zed and that&#39;s why the rope ended up being the top choice.</p>
<p>Here&#39;s an example of how deeply ingrained concurrent access to text is into Zed: when you edit a buffer in Zed, with syntax highlighting enabled, <a href="https://github.com/zed-industries/zed/blob/a0fa8a489bb4af98059e5a064c7fac2a77b49aff/crates/language/src/buffer.rs#L1000-L1016">a snapshot of the buffer&#39;s text content is sent to a background thread</a> in which it&#39;s re-parsed using <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a>. That happens on every edit and it&#39;s very, very fast and efficient, since the snapshots don&#39;t require a full copy of the text. All that&#39;s needed is to bump a reference count, because the reference-counting for the nodes in Zed&#39;s rope is implemented with <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>, Rust&#39;s &#34;thread-safe reference-counting pointer&#34;.</p>
<p>That brings us to the most important bit: how Zed&#39;s rope is implemented. Because it isn&#39;t implemented like the classic rope you see on Wikipedia and its implementation gives Zed&#39;s rope certain properties that other rope implementations might not have and that implementation is actually what put the rope ahead of other data structures.</p>
<h2 id="its-not-a-rope-its-a-sumtree"><span data-br=":R22nbrrrqbf9la:" data-brr="1">It&#39;s not a rope, it&#39;s a SumTree</span></h2>
<p>Zed&#39;s rope is not a classic binary-tree rope, it&#39;s a SumTree. If you <a href="https://github.com/zed-industries/zed/blob/ae3c641bbee2029fb4588d008e45ddb783593622/crates/rope/src/rope.rs#L29">open up the definition of Zed&#39;s <code>Rope</code></a>, you&#39;ll see that it&#39;s nothing more than a <code>SumTree</code> of <code>Chunk</code>s:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>struct</span><span> Rope</span><span> {</span></span>
<span data-line=""><span>    chunks</span><span>: </span><span>SumTree</span><span>&lt;</span><span>Chunk</span><span>&gt;,</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>struct</span><span> Chunk</span><span>(</span><span>ArrayString</span><span>&lt;{ </span><span>2</span><span> * </span><span>CHUNK_BASE</span><span> }&gt;);</span></span></code></pre></div></figure>
<p>A <code>Chunk</code> is an <code>ArrayString</code>, which comes from the <a href="https://docs.rs/arrayvec/latest/arrayvec/"><code>arrayvec</code> crate</a> and allows storing strings inline and not on the heap somewhere else. Meaning: a <code>Chunk</code> is a collection of characters. <code>Chunk</code>s are the leafs in the SumTree and contain <em>at most</em> <code>2 * CHUNK_BASE</code> characters. In release builds of Zed, <code>CHUNK_BASE</code> is <code>64</code>.</p>
<p>So then what is a SumTree? Ask Nathan and he&#39;ll say that the SumTree is &#34;the soul of Zed&#34;. But a slightly more technical description of a SumTree is this:</p>
<p>A <code>SumTree&lt;T&gt;</code> is a B+ tree in which each leaf node contains multiple items of type <code>T</code> and a <code>Summary</code> for each <code>Item</code>. Internal nodes contain a <code>Summary</code> of the items in its subtree.</p>
<p>And here are the type definitions to match, which you can <a href="https://github.com/zed-industries/zed/blob/6721c91ab000cea73ab30209c4a57bd1e2e2ce56/crates/sum_tree/src/sum_tree.rs#L37">find in the <code>sum_tree</code> crate</a>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>struct</span><span> SumTree</span><span>&lt;</span><span>T</span><span>: </span><span>Item</span><span>&gt;(</span><span>pub</span><span> Arc</span><span>&lt;</span><span>Node</span><span>&lt;</span><span>T</span><span>&gt;&gt;);</span></span>
<span data-line=""> </span>
<span data-line=""><span>enum</span><span> Node</span><span>&lt;</span><span>T</span><span>: </span><span>Item</span><span>&gt; {</span></span>
<span data-line=""><span>    Internal</span><span> {</span></span>
<span data-line=""><span>        height</span><span>: </span><span>u8</span><span>,</span></span>
<span data-line=""><span>        summary</span><span>: </span><span>T</span><span>::</span><span>Summary</span><span>,</span></span>
<span data-line=""><span>        child_summaries</span><span>: </span><span>ArrayVec</span><span>&lt;</span><span>T</span><span>::</span><span>Summary</span><span>, { </span><span>2</span><span> * </span><span>TREE_BASE</span><span> }&gt;,</span></span>
<span data-line=""><span>        child_trees</span><span>: </span><span>ArrayVec</span><span>&lt;</span><span>SumTree</span><span>&lt;</span><span>T</span><span>&gt;, { </span><span>2</span><span> * </span><span>TREE_BASE</span><span> }&gt;,</span></span>
<span data-line=""><span>    },</span></span>
<span data-line=""><span>    Leaf</span><span> {</span></span>
<span data-line=""><span>        summary</span><span>: </span><span>T</span><span>::</span><span>Summary</span><span>,</span></span>
<span data-line=""><span>        items</span><span>: </span><span>ArrayVec</span><span>&lt;</span><span>T</span><span>, { </span><span>2</span><span> * </span><span>TREE_BASE</span><span> }&gt;,</span></span>
<span data-line=""><span>        item_summaries</span><span>: </span><span>ArrayVec</span><span>&lt;</span><span>T</span><span>::</span><span>Summary</span><span>, { </span><span>2</span><span> * </span><span>TREE_BASE</span><span> }&gt;,</span></span>
<span data-line=""><span>    },</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""><span>trait</span><span> Item</span><span>: </span><span>Clone</span><span> {</span></span>
<span data-line=""><span>    type</span><span> Summary</span><span>: </span><span>Summary</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    fn</span><span> summary</span><span>(&amp;</span><span>self</span><span>) -&gt; </span><span>Self</span><span>::</span><span>Summary</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>So what&#39;s a <code>Summary</code>? Anything you want! The only requirement is that you need to be able to add multiple summaries together, to create a sum of summaries:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>trait</span><span> Summary</span><span>: </span><span>Default</span><span> + </span><span>Clone</span><span> + </span><span>fmt</span><span>::</span><span>Debug</span><span> {</span></span>
<span data-line=""><span>    type</span><span> Context</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>    fn</span><span> add_summary</span><span>(&amp;</span><span>mut</span><span> self</span><span>, </span><span>summary</span><span>: &amp;</span><span>Self</span><span>, </span><span>cx</span><span>: &amp;</span><span>Self</span><span>::</span><span>Context</span><span>);</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>But I know you just rolled your eyes at that, so let&#39;s make it more concrete.</p>
<p>Since the <code>Rope</code> is a <code>SumTree</code> and each item in the SumTree has to have a summary, here&#39;s the <code>Summary</code> that&#39;s associated with each node in Zed&#39;s <code>Rope</code>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>struct</span><span> TextSummary</span><span> {</span></span>
<span data-line=""><span>    /// Length in UTF-8</span></span>
<span data-line=""><span>    len</span><span>: </span><span>usize</span><span>,</span></span>
<span data-line=""><span>    /// Length in UTF-16 code units</span></span>
<span data-line=""><span>    len_utf16</span><span>: </span><span>OffsetUtf16</span><span>,</span></span>
<span data-line=""><span>    /// A point representing the number of lines and the length of the last line</span></span>
<span data-line=""><span>    lines</span><span>: </span><span>Point</span><span>,</span></span>
<span data-line=""><span>    /// How many `char`s are in the first line</span></span>
<span data-line=""><span>    first_line_chars</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>    /// How many `char`s are in the last line</span></span>
<span data-line=""><span>    last_line_chars</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>    /// How many UTF-16 code units are in the last line</span></span>
<span data-line=""><span>    last_line_len_utf16</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>    /// The row idx of the longest row</span></span>
<span data-line=""><span>    longest_row</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>    /// How many `char`s are in the longest row</span></span>
<span data-line=""><span>    longest_row_chars</span><span>: </span><span>u32</span><span>,</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>All nodes in the SumTree — internal and leaf nodes — have such a summary, containing information about its subtree. The leaf nodes have a summary of their <code>Chunk</code>s and the internal nodes have a summary that is <em>the sum of the summaries of its child nodes</em>, recursively down the tree.</p>
<p>Let&#39;s say we have the following text:</p>
<div><pre><code>Hello World!
This is
your captain speaking.
Are you
ready for take-off?
</code></pre></div>
<p>5 lines of text. If this is pushed into a Zed <code>Rope</code>, the <code>SumTree</code> beneath the <code>Rope</code> would look like this, simplified:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-sumtree/sumtree_diagram.png" alt="A SumTree representing &#34;Hello World!\nThis is\nyour captain speaking.\nAre you\nready for take-off?\n&#34; with some summary fields left out"/><figcaption>A SumTree representing &#34;Hello World!\nThis is\nyour captain speaking.\nAre you\nready for take-off?\n&#34; with some summary fields left out</figcaption></figure></div>
<p>(I left out some of the fields of <code>TextSummary</code> to keep the diagram small-ish and also adjusted the maximum size of the chunks and maximum number of children per node. In a release-build of Zed, all five lines of the text would fit in a single node.)</p>
<p>Even with only three summary fields — <code>len</code>, <code>lines</code>, <code>longest_row_chars</code> — we can see that the summaries of the internal nodes are the sum of their child nodes summaries.</p>
<p>The root node&#39;s summary tells us about the complete text, the complete <code>Rope</code>: 72 characters, 5 lines, and the longest line has 22 characters (<code>your captain speaking.\n</code>). The internal nodes tell is about parts of the text. The left internal node here tells us, for example, that it&#39;s <code>38</code> characters from <code>&#34;Hell&#34;</code> to <code>&#34;spea&#34;</code> (including newline characters) and that there are two line breaks in that part of the text.</p>
<p>Okay, you might be thinking, a B+ tree with summarized summaries — what does that buy us?</p>
<h2 id="traversing-a-sumtree"><span data-br=":R2onbrrrqbf9la:" data-brr="1">Traversing a SumTree</span></h2>
<p>The SumTree is a concurrency-friendly B-tree that not only gives us a persistent, copy-on-write data structure to represent text, but through its summaries it also indexes the data in the tree and allows us to traverse the tree along dimensions of the summaries in <code>O(log n)</code> time.</p>
<p>In Max&#39;s words, the SumTree is &#34;not conceptually a map. It&#39;s more like a <code>Vec</code> that has these special indexing features where you can store any sequence of items you want. You decide the order and it just provides these capabilities to seek and slice.&#34;</p>
<p>Don&#39;t think of it as a tree that allows you to lookup values associated with keys (although it <em>can</em> do that), but think of it as a tree that allows you lookup items based on the summaries of each item and all the items that come before it in the tree.</p>
<p>Or, in other words: the items in a SumTree are ordered. Their summaries are also ordered. The SumTree allows you find any item in the tree in <code>O(log N)</code> time by traversing the tree from root to leaf node and deciding which node to visit based on the node&#39;s summary.</p>
<p>Say we have a <code>Rope</code> with three lines of text in it:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>let</span><span> mut</span><span> rope</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;Line one.</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;This is the second line.</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;This is three.</span><span>\n</span><span>&#34;</span><span>);</span></span></code></pre></div></figure>
<p>Once the <code>Rope</code> is constructed, it looks like this:</p>
<div><figure><img src="https://zed.dev/img/post/zed-decoded-rope-sumtree/sumtree_three_lines.png" alt="A SumTree representing &#34;Line one.\nThis is the second line.\nThis is three.\n&#34; with some summary fields left out"/><figcaption>A SumTree representing &#34;Line one.\nThis is the second line.\nThis is three.\n&#34; with some summary fields left out</figcaption></figure></div>
<p>Like we said above: each leaf node will hold multiple <code>Chunk</code>s and each leaf node&#39;s summary will contain information about the text in its <code>Chunk</code>s. The type of that summary is <code>TextSummary</code> from above. That means each node&#39;s summary can tell us about the <code>len</code> of the text in its chunks, the lines &amp; rows in them, the longest line, and all the other fields of <code>TextSummary</code>. The internal nodes in the SumTree then contain summaries of the summaries.</p>
<p>And since the items in the tree — internal nodes, leaf nodes, chunks — are <em>ordered</em> we can traverse that tree very efficiently, because the SumTree allows us to <em>traverse the tree based on the values in the summaries</em>. It allows us to seek along a single <em>dimension</em>, a single field for example, of a given summary.</p>
<p>Say we want to find out what the line and column in the rope is at the absolute offset <code>26</code>. Meaning: what&#39;s at character 26? In order to find out, we can traverse this three-line <code>rope</code> along the <code>len</code> field of the <code>TextSummary</code>. Because the <code>len</code> field, when added up from left to right, <em>is</em> an absolute offset. So in order to find what&#39;s at absolute offset <code>26</code>, we traverse down the tree, taking left or right turns, depending on the <code>len</code> value in the summaries of the internal nodes, until we end up at the leaf node we want:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>let</span><span> point</span><span> = </span><span>rope</span><span>.</span><span>offset_to_point</span><span>(</span><span>26</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>point</span><span>.row, </span><span>1</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>point</span><span>.column, </span><span>16</span><span>);</span></span></code></pre></div></figure>
<p>On the surface, the call to <code>rope.offset_to_point(26)</code> converts an absolute 0-based offset (<code>26</code>) into a row and column (<code>1</code> and <code>16</code>). What happens inside of <code>offset_to_point</code> is that a cursor traverses the SumTree until it finds the items where the aggregated <code>len</code> of the <code>TextSummary</code> is <code>&gt;= 26</code>. Once it found the first leaf node where that&#39;s true, it finds the exact chunk where the offset matches and parks the cursor there. On the way there, it not only kept counting the <code>len</code> field of the summaries it came across, but it also aggregated the <code>lines</code> field, which contains <code>row</code> and <code>column</code>. Neat, right?</p>
<p>Here&#39;s what I just described but in actual code, here&#39;s the <code>offset_to_point</code> method on the <code>Rope</code>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>fn</span><span> offset_to_point</span><span>(&amp;</span><span>self</span><span>, </span><span>offset</span><span>: </span><span>usize</span><span>) -&gt; </span><span>Point</span><span> {</span></span>
<span data-line=""><span>    if</span><span> offset</span><span> &gt;= </span><span>self</span><span>.</span><span>summary</span><span>().len {</span></span>
<span data-line=""><span>        return</span><span> self</span><span>.</span><span>summary</span><span>().lines;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> cursor</span><span> = </span><span>self</span><span>.chunks.</span><span>cursor</span><span>::&lt;(</span><span>usize</span><span>, </span><span>Point</span><span>)&gt;();</span></span>
<span data-line=""><span>    cursor</span><span>.</span><span>seek</span><span>(&amp;</span><span>offset</span><span>, </span><span>Bias</span><span>::</span><span>Left</span><span>, &amp;());</span></span>
<span data-line=""><span>    let</span><span> overshoot</span><span> = </span><span>offset</span><span> - </span><span>cursor</span><span>.</span><span>start</span><span>().</span><span>0</span><span>;</span></span>
<span data-line=""><span>    cursor</span><span>.</span><span>start</span><span>().</span><span>1</span></span>
<span data-line=""><span>        + </span><span>cursor</span></span>
<span data-line=""><span>            .</span><span>item</span><span>()</span></span>
<span data-line=""><span>            .</span><span>map_or</span><span>(</span><span>Point</span><span>::</span><span>zero</span><span>(), |</span><span>chunk</span><span>| </span><span>chunk</span><span>.</span><span>offset_to_point</span><span>(</span><span>overshoot</span><span>))</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>What it does is the following:</p>
<ul>
<li>sanity checks that the offset isn&#39;t past the end of the whole <code>Rope</code></li>
<li>creates a cursor that seeks along the <code>usize</code> (offset) and <code>Point</code> (a <code>Point</code> is a struct with two fields: <code>row</code> and <code>column</code>) dimensions, aggregating both while doing that</li>
<li>once it found an item at <code>offset</code>, it calculates the overshoot: the <code>offset</code> we&#39;re looking for might be in the middle of a single chunk and <code>cursor.start().0</code> is the <code>usize</code> (offset) at the start of a given chunk</li>
<li>take the lines up to the start of the current chunk (<code>cursor.start().1</code>) — which is the summary of <code>TextSummary.len</code> of the complete tree to the left of the current item!</li>
<li>add them to the lines at the offset in the, possibly, middle of the chunk (<code>chunk.offset_to_point(overshoot)</code>)</li>
</ul>
<p>The most interesting bit here is, of course, the cursor that&#39;s constructed with <code>self.chunks.cursor::&lt;(usize, Point)&gt;()</code>. This particular cursor has two dimensions and allows you to seek to a value on one dimension (<code>usize</code>) in the given <code>SumTree</code> and in the same operation also get the sum of the second dimension, the <code>Point</code>, at a particular cursor position.</p>
<p>The beauty of that is that it can do that in <code>O(log N)</code> time, because each internal node contains a summary of summaries (meaning: the total <code>len</code> of all items in its subtree in this case) and it can skip over all of those where <code>len &lt; 26</code>. In the diagram above, you can see that we don&#39;t even have to traverse the first two leaf nodes.</p>
<p>Isn&#39;t that amazing? There&#39;s more.</p>
<h2 id="using-the-sumtree"><span data-br=":R3dnbrrrqbf9la:" data-brr="1">Using the SumTree</span></h2>
<p>You can also traverse the <code>SumTree</code> the other way around, seeking along lines/rows and getting the final offset:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>// Go from offset to point:</span></span>
<span data-line=""><span>let</span><span> point</span><span> = </span><span>rope</span><span>.</span><span>offset_to_point</span><span>(</span><span>55</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>point</span><span>.row, </span><span>2</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>point</span><span>.column, </span><span>6</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Go from point to offset:</span></span>
<span data-line=""><span>let</span><span> offset</span><span> = </span><span>rope</span><span>.</span><span>point_to_offset</span><span>(</span><span>Point</span><span>::</span><span>new</span><span>(</span><span>2</span><span>, </span><span>6</span><span>));</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>offset</span><span>, </span><span>55</span><span>);</span></span></code></pre></div></figure>
<p>And — you probably guessed it — <code>point_to_offset</code> looks exactly like <code>offset_to_point</code>, except that the dimensions with which the cursor is constructed are flipped:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>fn</span><span> point_to_offset</span><span>(&amp;</span><span>self</span><span>, </span><span>point</span><span>: </span><span>Point</span><span>) -&gt; </span><span>usize</span><span> {</span></span>
<span data-line=""><span>    if</span><span> point</span><span> &gt;= </span><span>self</span><span>.</span><span>summary</span><span>().lines {</span></span>
<span data-line=""><span>        return</span><span> self</span><span>.</span><span>summary</span><span>().len;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> cursor</span><span> = </span><span>self</span><span>.chunks.</span><span>cursor</span><span>::&lt;(</span><span>Point</span><span>, </span><span>usize</span><span>)&gt;();</span></span>
<span data-line=""><span>    cursor</span><span>.</span><span>seek</span><span>(&amp;</span><span>point</span><span>, </span><span>Bias</span><span>::</span><span>Left</span><span>, &amp;());</span></span>
<span data-line=""><span>    let</span><span> overshoot</span><span> = </span><span>point</span><span> - </span><span>cursor</span><span>.</span><span>start</span><span>().</span><span>0</span><span>;</span></span>
<span data-line=""><span>    cursor</span><span>.</span><span>start</span><span>().</span><span>1</span></span>
<span data-line=""><span>        + </span><span>cursor</span></span>
<span data-line=""><span>            .</span><span>item</span><span>()</span></span>
<span data-line=""><span>            .</span><span>map_or</span><span>(</span><span>0</span><span>, |</span><span>chunk</span><span>| </span><span>chunk</span><span>.</span><span>point_to_offset</span><span>(</span><span>overshoot</span><span>))</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>This seeking along one dimension and aggregating (summarizing!) along multiple dimensions is made possible by some <a href="https://github.com/zed-industries/zed/blob/6721c91ab000cea73ab30209c4a57bd1e2e2ce56/crates/sum_tree/src/sum_tree.rs#L43-L94">very clever Rust code</a> that I won&#39;t explain in detail, but the short version is this.</p>
<p>Given a <code>TextSummary</code> like the following (which we already saw in full above) and a <code>ChunkSummary</code> that wraps it...</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>struct</span><span> TextSummary</span><span> {</span></span>
<span data-line=""><span>    len</span><span>: </span><span>usize</span><span>,</span></span>
<span data-line=""><span>    lines</span><span>: </span><span>Point</span><span>,</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // [...]</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>struct</span><span> ChunkSummary</span><span> {</span></span>
<span data-line=""><span>    text</span><span>: </span><span>TextSummary</span><span>,</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>... we can define the <code>len</code> and <code>lines</code> fields as <code>sum_tree::Dimensions</code>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>impl</span><span>&lt;&#39;</span><span>a</span><span>&gt; </span><span>sum_tree</span><span>::</span><span>Dimension</span><span>&lt;&#39;</span><span>a</span><span>, </span><span>ChunkSummary</span><span>&gt; </span><span>for</span><span> usize</span><span> {</span></span>
<span data-line=""><span>    fn</span><span> add_summary</span><span>(&amp;</span><span>mut</span><span> self</span><span>, </span><span>summary</span><span>: &amp;&#39;</span><span>a</span><span> ChunkSummary</span><span>, </span><span>_</span><span>: &amp;()) {</span></span>
<span data-line=""><span>        *</span><span>self</span><span> += </span><span>summary</span><span>.text.len;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>}</span></span>
<span data-line=""> </span>
<span data-line=""><span>impl</span><span>&lt;&#39;</span><span>a</span><span>&gt; </span><span>sum_tree</span><span>::</span><span>Dimension</span><span>&lt;&#39;</span><span>a</span><span>, </span><span>ChunkSummary</span><span>&gt; </span><span>for</span><span> Point</span><span> {</span></span>
<span data-line=""><span>    fn</span><span> add_summary</span><span>(&amp;</span><span>mut</span><span> self</span><span>, </span><span>summary</span><span>: &amp;&#39;</span><span>a</span><span> ChunkSummary</span><span>, </span><span>_</span><span>: &amp;()) {</span></span>
<span data-line=""><span>        *</span><span>self</span><span> += </span><span>summary</span><span>.text.lines;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>With that we can then <a href="https://github.com/zed-industries/zed/blob/6721c91ab000cea73ab30209c4a57bd1e2e2ce56/crates/sum_tree/src/sum_tree.rs#L323-L329">construct cursors</a> for a given <code>sum_tree::Dimension</code> or a <em>tuple of dimensions</em> (which is what we did above with <code>(usize, Point)</code>).</p>
<p>Once constructed, the cursor can then seek along any <code>Dimension</code> we have defined and aggregate either the complete <code>TextSummary</code> or just a single <code>Dimension</code> of a given summary type.</p>
<p>Or we can also seek along a single dimension and then get the whole summary once the cursor has found the target:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>let</span><span> mut</span><span> rope</span><span> = </span><span>Rope</span><span>::</span><span>new</span><span>();</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;This is the first line.</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;This is the second line.</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span data-line=""><span>rope</span><span>.</span><span>push</span><span>(</span><span>&#34;This is the third line.</span><span>\n</span><span>&#34;</span><span>);</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Construct cursor:</span></span>
<span data-line=""><span>let</span><span> mut</span><span> cursor</span><span> = </span><span>rope</span><span>.</span><span>cursor</span><span>(</span><span>0</span><span>);</span></span>
<span data-line=""><span>// Seek it to offset 55 and get the `TextSummary` at that offset:</span></span>
<span data-line=""><span>let</span><span> summary</span><span> = </span><span>cursor</span><span>.</span><span>summary</span><span>::&lt;</span><span>TextSummary</span><span>&gt;(</span><span>55</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>summary</span><span>.len, </span><span>55</span><span>);</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>summary</span><span>.lines, </span><span>Point</span><span>::</span><span>new</span><span>(</span><span>2</span><span>, </span><span>6</span><span>));</span></span>
<span data-line=""><span>assert_eq!</span><span>(</span><span>summary</span><span>.longest_row_chars, </span><span>24</span><span>);</span></span></code></pre></div></figure>
<p>The cursor stopped in the middle of line 2, at column 6, and up until that location the <code>longest_row_chars</code> in the summaries was <code>24</code>.</p>
<p>This is very, very powerful stuff. To scratch the surface: it allows us to easily convert between UTF8 rows/columns and UTF16 rows/columns, which is <a href="https://matklad.github.io/2023/10/12/lsp-could-have-been-better.html#Coordinates">sometimes required when working with the language server protocol (LSP)</a>. Just seek to a UTF8 <code>Point</code> and aggregate the UTF16 <code>Points</code>:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>fn</span><span> point_to_point_utf16</span><span>(&amp;</span><span>self</span><span>, </span><span>point</span><span>: </span><span>Point</span><span>) -&gt; </span><span>PointUtf16</span><span> {</span></span>
<span data-line=""><span>    if</span><span> point</span><span> &gt;= </span><span>self</span><span>.</span><span>summary</span><span>().lines {</span></span>
<span data-line=""><span>        return</span><span> self</span><span>.</span><span>summary</span><span>().</span><span>lines_utf16</span><span>();</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    let</span><span> mut</span><span> cursor</span><span> = </span><span>self</span><span>.chunks.</span><span>cursor</span><span>::&lt;(</span><span>Point</span><span>, </span><span>PointUtf16</span><span>)&gt;();</span></span>
<span data-line=""><span>    cursor</span><span>.</span><span>seek</span><span>(&amp;</span><span>point</span><span>, </span><span>Bias</span><span>::</span><span>Left</span><span>, &amp;());</span></span>
<span data-line=""><span>    // ... you know the rest ...</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>But there&#39;s more and I could go on and on and on and show more examples or use big words like <a href="https://xi-editor.io/docs/rope_science_02.html">monoid homomorphism</a>, but I&#39;ll stop here. You get the idea — the <code>SumTree</code>, a thread-safe, snapshot-friendly, copy-on-write B+ tree is very powerful and can be used for more than &#34;just&#34; text, which is why it&#39;s everywhere in Zed. Yes, literally.</p>
<h2 id="everythings-a-sumtree"><span data-br=":R3vnbrrrqbf9la:" data-brr="1">Everything&#39;s a SumTree</span></h2>
<p>Currently there are <a href="https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/zed-industries/zed%24+lang:rust+content:%22:+SumTree%3C%22&amp;patternType=keyword&amp;sm=0">over 20 uses of the <code>SumTree</code> in Zed</a>. The <code>SumTree</code> is not only used as the basis for the <code>Rope</code>, but in many different places. The list of files in a project is a <code>SumTree</code>. The information returned by <code>git blame</code> is stored in a <code>SumTree</code>. Messages in the chat channel: <code>SumTree</code>. Diagnostics: <code>SumTree</code>.</p>
<p>At the very core of Zed sits a data structured called <code>DisplayMap</code> that contains all the information about how a given buffer of text should be displayed — where the folds go, which lines wrap, where the inlay hints are displayed, ... — and it looks like this:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="rust" data-theme="light-plus"><code data-language="rust" data-theme="light-plus"><span data-line=""><span>struct</span><span> DisplayMap</span><span> {</span></span>
<span data-line=""><span>    /// The buffer that we are displaying.</span></span>
<span data-line=""><span>    buffer</span><span>: </span><span>Model</span><span>&lt;</span><span>MultiBuffer</span><span>&gt;,</span></span>
<span data-line=""><span>    /// Decides where the [`Inlay`]s should be displayed.</span></span>
<span data-line=""><span>    inlay_map</span><span>: </span><span>InlayMap</span><span>,</span></span>
<span data-line=""><span>    /// Decides where the fold indicators should be and tracks parts of a source file that are currently folded.</span></span>
<span data-line=""><span>    fold_map</span><span>: </span><span>FoldMap</span><span>,</span></span>
<span data-line=""><span>    /// Keeps track of hard tabs in a buffer.</span></span>
<span data-line=""><span>    tab_map</span><span>: </span><span>TabMap</span><span>,</span></span>
<span data-line=""><span>    /// Handles soft wrapping.</span></span>
<span data-line=""><span>    wrap_map</span><span>: </span><span>Model</span><span>&lt;</span><span>WrapMap</span><span>&gt;,</span></span>
<span data-line=""><span>    /// Tracks custom blocks such as diagnostics that should be displayed within buffer.</span></span>
<span data-line=""><span>    block_map</span><span>: </span><span>BlockMap</span><span>,</span></span>
<span data-line=""><span>    /// Regions of text that should be highlighted.</span></span>
<span data-line=""><span>    text_highlights</span><span>: </span><span>TextHighlights</span><span>,</span></span>
<span data-line=""><span>    /// Regions of inlays that should be highlighted.</span></span>
<span data-line=""><span>    inlay_highlights</span><span>: </span><span>InlayHighlights</span><span>,</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // [...]</span></span>
<span data-line=""><span>}</span></span></code></pre></div></figure>
<p>Guess what? All of these use a <code>SumTree</code> under the hood and in a future post we will explore them, but the point I want to make now is this:</p>
<p>The Zed co-founders didn&#39;t so much decide to use a rope over a gap buffer or over a piece table. They started with the <code>SumTree</code>, recognized how powerful it is, how it fits Zed&#39;s requirements, and then built the rope on top of it.</p>
<p>The rope may be at the heart of Zed, but the SumTree is, to quote Nathan again, &#34;the soul of Zed&#34;.</p><hr/></article></div></div>
  </body>
</html>
