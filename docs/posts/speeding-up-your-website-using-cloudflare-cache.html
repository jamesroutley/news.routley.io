<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://pillser.com/engineering/2024-08-25-speeding-up-your-website-using-cloudflare-cache">Original</a>
    <h1>Speeding Up Your Website Using Cloudflare Cache</h1>
    
    <div id="readability-page-1" class="page"><div><p>Performance is critical for websites to rank in Google search results. Pillser implements a number of techniques to load and render pages quickly. However, nothing beats caching. In this post, I will share my experience with Cloudflare cache.</p>
<h2>Cloudflare Cache</h2>
<p>I chose <a href="https://developers.cloudflare.com/cache/">Cloudflare Cache</a> because I am already using Cloudflare for other things.</p>
<p>To use Cloudflare cache, I needed to:</p>
<ol>
<li>Enable <a href="https://developers.cloudflare.com/cache/how-to/tiered-cache/">Tiered Cache</a></li>
<li>Enable <a href="https://developers.cloudflare.com/cache/advanced-configuration/cache-reserve/">Cache Reserve</a></li>
<li>Add <a href="https://developers.cloudflare.com/cache/how-to/cache-rules/">Cache Rules</a></li>
</ol>
<p><em>Tiered Cache</em> and <em>Cache Reserve</em> are not strictly necessary, but they enable more reliable and faster cache hits.</p>
<p>When you enable <em>Cache Reserve</em>, you are able to cache gigabytes of data. Meanwhile, <em>Tiered Cache</em> reduces the amount of servers that Cloudflare needs to hop through to serve your website, which improves performance, e.g. I saw cached response times go from 100ms to under 10ms when I enabled <em>Tiered Cache</em>.</p>

<p>Finally, you need to add <em>Cache Rules</em> to define which pages should be cached. For example, I only want to cache pages that are accessed by non-authenticated users (identified by the presence of a <code>user_account</code> cookie), and I only want to cache pages matching a specific URL pattern. Here is a rule that does just that:</p>
<pre><code>(
  not http.cookie contains &#34;user_account&#34; and (
    http.request.uri.path eq &#34;/&#34; or
    starts_with(http.request.uri.path, &#34;/supplements&#34;) or
    starts_with(http.request.uri.path, &#34;/probiotics&#34;) or
    starts_with(http.request.uri.path, &#34;/vitamins&#34;) or
    starts_with(http.request.uri.path, &#34;/minerals&#34;) or
    starts_with(http.request.uri.path, &#34;/brands&#34;)
  )
)
</code></pre>
<p>I love that Cloudflare cache is so flexible. Their <a href="https://developers.cloudflare.com/ruleset-engine/rules-language/">rules language</a> is very powerful.</p>
<h2>Cache by Device Type</h2>
<p>You can enable options like <em>Cache by device type</em> if you are serving different content to different devices. Example: Pillser will render a different number of supplements per page depending on whether the user is on a mobile device or a desktop.</p>
<p>Once enabled, Cloudflare sends a <code>CF-Device-Type</code> HTTP header to your origin with a value of either <code>mobile</code>, <code>tablet</code>, or <code>desktop</code> for every request to specify the visitor&#39;s device type.</p>
<h2>Utilize Strong ETags</h2>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag">ETag</a> HTTP response header is an identifier for a specific version of a resource.</p>
<p>Enable <em>Respect strong ETags</em> to ensure that the cache is invalidated when the content changes.</p>
<p>For this to function, you need to add a <code>ETag</code> header to the response. Fastify ecosystem has a <a href="https://github.com/fastify/fastify-etag">plugin</a> to automatically generate strong ETags.</p>
<h2>Serve Stale Content While Revalidating (Not Working as Expected)</h2>
<p>This is the only thing that I was not able to figure out.</p>
<p>My ideal behavior would be to cache products for a short period of time (e.g., 1 hour) and then serve stale content while revalidating.</p>
<p>I have therefore configured <code>Edge TTL</code> to <code>Ignore cache-control header and use this TTL</code> and set the TTL to 1 hour. This ensures that the cache becomes stale after 1 hour.</p>
<p>I have then left <code>Do not serve stale content while updating</code> <em>disabled</em>. This is supposed to make Cloudflare serve stale content while revalidating, but it does not seem to work.</p>
<p>I am still occasionally seeing content being served directly from the origin with <code>cf-cache-status</code> set to <code>MISS</code>. I would expect this to not happen, as the revalidation should happen in the background while the cache is being served. If you happen to know how to fix this, please let me know.</p>
<h2>Lacking Features: Max Age for Stale Content</h2>
<p>Another thing that I noticed is that Cloudflare will sometimes expire cached content based on <code>Cache-Control</code> headers. However, in the example of wanting to <em>serve stale content while revalidating</em>, I would expect that there would be a setting that allows me to explicitly say how long the content should be cached for regardless of the <code>Cache-Control</code> header, i.e., I would want to set max-age to several days, but require that Cloudflare revalidates the content every hour.</p>
<p>Effectively, I want to force Cloudflare to retain the cache beyond the TTL.</p>
<h2>Purging Cache</h2>
<p>Last but not least, I needed a way to purge the cache. Cloudflare provides <a href="https://developers.cloudflare.com/cache/how-to/purge-cache/">several ways</a> to purge the cache. However, I found that the API approach is the easiest to use:</p>
<pre><code>import { config } from &#39;#app/config.server&#39;;
import Cloudflare from &#39;cloudflare&#39;;

const cloudflare = new Cloudflare({
  apiEmail: config.CLOUDFLARE_API_EMAIL,
  apiKey: config.CLOUDFLARE_API_KEY,
});

const response = await cloudflare.cache.purge({
  files: [&#39;https://pillser.com/&#39;],
  zone_id: config.CLOUDFLARE_ZONE_ID,
});
</code></pre>
<p>This allows me to automate the purging of individual product cache, e.g. when a product is updated.</p>
<h2>Results</h2>
<p>I ran latency tests from several locations and captured the slowest response time for each URL. The results are below:</p>















































<table><thead><tr><th>URL</th><th>Country</th><th>Origin Response Time</th><th>Cached Response Time</th></tr></thead><tbody><tr><td><a href="https://pillser.com/vitamins/vitamin-b1">https://pillser.com/vitamins/vitamin-b1</a></td><td>us-west1</td><td>240ms</td><td>16ms</td></tr><tr><td><a href="https://pillser.com/vitamins/vitamin-b1">https://pillser.com/vitamins/vitamin-b1</a></td><td>europe-west3</td><td>320ms</td><td>10ms</td></tr><tr><td><a href="https://pillser.com/vitamins/vitamin-b1">https://pillser.com/vitamins/vitamin-b1</a></td><td>australia-southeast1</td><td>362ms</td><td>16ms</td></tr><tr><td><a href="https://pillser.com/supplements/vitamin-b1-3254">https://pillser.com/supplements/vitamin-b1-3254</a></td><td>us-west1</td><td>280ms</td><td>10ms</td></tr><tr><td><a href="https://pillser.com/supplements/vitamin-b1-3254">https://pillser.com/supplements/vitamin-b1-3254</a></td><td>europe-west3</td><td>340ms</td><td>12ms</td></tr><tr><td><a href="https://pillser.com/supplements/vitamin-b1-3254">https://pillser.com/supplements/vitamin-b1-3254</a></td><td>australia-southeast1</td><td>362ms</td><td>14ms</td></tr></tbody></table>
<p>The results are consistent across multiple regions. It is clear that Cloudflare cache hugely improves the performance of the website, especially for users further away from the origin (US).</p></div></div>
  </body>
</html>
