<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.runpyxl.com/gpio">Original</a>
    <h1>I built a hardware processor that runs Python</h1>
    
    <div id="readability-page-1" class="page"><div>
    <section>
      
      <p>Python, in hardware. 480ns GPIO. No interpreter. No C. Just PyXL.</p>
      <p>
        <iframe src="https://player.vimeo.com/video/1074893425?h=722d28efd8&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen" allowfullscreen=""></iframe>
      </p>
    </section>

    <section>
      <h2>TL;DR</h2>
      <ul>
        <li>‚ö° PyXL runs <strong>Python directly in hardware</strong> ‚Äî no VM, no OS, no JIT.</li>
        <li>üß™ A GPIO roundtrip takes <strong>480ns</strong> on PyXL vs. ~15,000ns on <a href="https://store.micropython.org/product/PYBv1.1" target="_blank" rel="noopener noreferrer">PyBoard</a> (MicroPython).</li>
        <li>üìâ PyXL is <strong>30x faster</strong> than MicroPython ‚Äî or <strong>50x</strong> when normalized for clock speed.</li>
        <li>üé• The video demo shows both systems in action on real hardware.</li>
        <li>üí° This isn&#39;t a C trick ‚Äî it&#39;s actual <strong>Python executed in silicon</strong>.</li>
        <li>üéØ Deterministic timing, real-time behavior, and sub-microsecond precision ‚Äî in Python.</li>
        <li>üîó More at <a href="https://runpyxl.com">runpyxl.com</a> ‚Äî contact link at the bottom.</li>
      </ul>
    </section>

    <section>
      <h2>What is PyXL?</h2>
      <p>PyXL is a custom hardware processor that executes Python <strong>directly</strong> ‚Äî no interpreter, no JIT, and no tricks. It takes regular Python code and runs it in silicon.</p>
      <p>A custom toolchain compiles a <code>.py</code> file into CPython ByteCode, translates it to a custom assembly, and produces a binary that runs on a pipelined processor built from scratch.</p>
    </section>

    <section>
      <h2>What PyXL is not</h2>
      <ul>
        <li>‚ùå Not a native C or inlined loop</li>
        <li>‚ùå Not MicroPython or JIT</li>
        <li>‚ùå Not running Linux or any OS</li>
      </ul>
      <p>It&#39;s a real processor for Python, built for determinism and speed.</p>
    </section>

    <section>
      <h2>Where does it run?</h2>
      <p>PyXL runs on a <strong>Zynq-7000 FPGA</strong> (Arty-Z7-20 dev board). The PyXL core runs at 100MHz. The ARM CPU on the board handles setup and memory, but the Python code itself is executed entirely in hardware.</p>
      <p>The toolchain is written in Python and runs on a standard development machine using unmodified CPython.</p>
    </section>

    <section>
      <h2>Wait ‚Äî what‚Äôs a GPIO?</h2>
      <p>
        GPIO stands for <strong>General Purpose Input/Output</strong>. It‚Äôs a simple hardware pin that software can read from or write to ‚Äî a way to control the outside world: LEDs, buttons, sensors, motors, and more.
      </p>
      <p>
        In MicroPython (like on the PyBoard), your Python code interacts with C functions that handle hardware registers underneath. It‚Äôs reasonably fast, but still goes through a Python VM and a software stack before reaching the pin.
      </p>
      <p>
        PyXL skips all of that. The Python bytecode is executed directly in hardware, and GPIO access is physically wired to the processor ‚Äî no interpreter, no function call, just native hardware execution.
      </p>
    </section>    

    <section>
      <h2>Now for the GPIO test. What was the video?</h2>
      <p>I have connected two pins in the Arty board with a jumper cable.</p>
      <p>Then, I wrote a python program that measures the time from when GPIO pin1 is set to 1, until 1 is measured on the other pin connected to it.</p>
      <p>The video shows a comparison between PyXL and PyBoard that runs MicroPython VM.</p>

      <h2>The program</h2>
      <pre>from compiler.intrinsics import *


def main():
    pyxl_write_gpio_pin1(0)              # Reset output pin

    c1 = pyxl_get_cycle_counter()        # Cycle counter (100 MHz)

    pyxl_write_gpio_pin1(1)              # Set output pin
    while pyxl_read_gpio_pin2() == 0:    # Wait until input pin is set to 1
        continue

    c2 = pyxl_get_cycle_counter()        # Cycle counter (100 MHz)

    return (c2 - c1) * 10                # Return result in nano seconds (each cycle is 10 ns)
          </pre>

      <p>As you can see, this is a regular python program, but it also has some unfamiliar function calls.</p>
        <pre>pyxl_get_cycle_counter()</pre>
        <p>Gets the current cycle counter from the PyXL CPU. This counter advances by 1 on every tick</p>

        <pre>pyxl_write_gpio_pin1()</pre>
        <p>Writes a value (0/1) to a GPIO pin. These are low-level intrinsics exposed by the compiler ‚Äî currently hardcoded for this test, but will evolve into a more general pyxl_gpio_write(pin, value) API.</p>

        <pre>pyxl_read_gpio_pin2()</pre>
        <p>Reads the value from Pin2. Same API comment is true here as well.</p>
      
    </section>

    <section>
      <h2>Wait, why isn&#39;t there a call to the main function?</h2>
      <p>The main function is just defined, but not invoked. why?</p>
      <p>At current stage, PyXL calls the main function automatically when it runs a program.</p>
      <p>This is just a convenience feature (for dev) and will change in the future.</p>
    </section>
    
    <section>
      <h2>So how does it work?</h2>
      <p>As described above, the program is compiled to a CPython Bytecode and then compiled again to PyXL assembly. It is then linked together and a binary is generated.</p>
      <p>This binary is sent via network to the Arty board, where an ARM CPU gets the application, copies it to a shared memory with the PyXL HW and starts running it.</p>
      <p>A typical Python runtime (CPython or MicroPython in case of the PyBoard or Python for embedded in general) has a big overhead that is caused by running the ByteCode on a Software based VM. In PyXL there&#39;s no VM, the HW does everything.</p>
      <p>As for reading and writing the GPIO - The GPIO headers are directly mapped to FPGA pins, and physically wired into PyXL&#39;s core top-level module. Think of it as the main function of the HW.</p>
      <p>In this test, all code and data reside in predictable low-latency memory, ensuring deterministic behavior (real-time behavior). This means that for the same input, it&#39;ll take the exact same time to run.
      </p>
    </section>
      
    <section>
      <h2>So how do these platforms compare?</h2>
      <div>
        <h3>GPIO Roundtrip Latency (ns). Lower is better.</h3>
        
        
        
        <div>
          <p><span>MicroPython (PyBoard)</span><span>14,741ns</span>
          </p>
          
        </div>
      </div>

      <p>As you can see, PyXL is 30x faster than PyBoard.</p>
      <p>Also, remember that PyXL&#39;s clock speed is lower than PyBoard.</p>
      <p>The reason for not operating at a higher clock is that PyXL is prototyped on an FPGA and PyBoard has an ASIC. But the gist of it is that it&#39;s not a limitation of PyXL and higher clocks can be achieved.</p>
      <p>Since a higher clock is achievable, we need to compare apples-to-apples and normalize the clock frequencies.</p>
    </section>

    <section>
      <h2>Why don&#39;t both tests run the exact same code?</h2>
      <p>To the keen eyes among you, you may have noticed in the video that the PyBoard code and the PyXL code aren&#39;t the same.</p>
      <p>Both are Python, this is obvious, but there&#39;re two main differences:</p>
      <p>1. API calls for measuring time and reading/writing GPIO pins. The reason being that this is not CPython that runs on a host, but systems that are aware of the underlying hardware, bringing their own runtime environment with them.</p>
      <p>2. The PyBoard runs the test in a tight loop to compensate for jitter and cold cache.</p>
    </section>

    <section>
      <h2>Big deal, who cares about making a signal go a bit faster?</h2>
      <p>
        This isn‚Äôt just a performance boost ‚Äî it&#39;s an unlock. PyXL brings a level of responsiveness and determinism that Python has never had in embedded or real-time contexts.
      </p>
      <p>
        Python VMs ‚Äî even those designed for microcontrollers ‚Äî are still built around software interpreters. That introduces overhead and complexity between your code and the hardware.
      </p>
      <p>
        PyXL removes this barrier. Your Python code is executed directly in hardware. GPIO access is physical. Control flow is predictable. Execution is tight and consistent by design.
      </p>
      <p>With this unlock, PyXL can be further developed and adapted to these use cases:</p>
      <ul>
        <li>üïπ Real-time control systems in pure Python</li>
        <li>üß† ML inference + sensor response loops with hard timing budgets</li>
        <li>ü§ñ Robotics tasks like motor feedback and sensor fusion with cycle-level precision</li>
        <li>üîß Embedded industrial systems where timing and reliability matter</li>
      </ul>
      <p>
        With PyXL, you can write performance-critical code once ‚Äî in Python ‚Äî and ship it as-is.
      </p>
    </section>

    <section>
      <h2>Sounds interesting? Let&#39;s talk.</h2>
      <a href="https://www.runpyxl.com/#contact">Reach out if you&#39;re curious.</a>
    </section>
  </div></div>
  </body>
</html>
