<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://benhoyt.com/writings/gogit/">Original</a>
    <h1>Show HN: Gogit – Just enough Git (in Go) to push itself to GitHub</h1>
    
    <div id="readability-page-1" class="page"><div id="container">



<div id="content">

<p>July 2023</p>

<blockquote>
  <p><strong>Go to:</strong> <a href="#technical-summary">Tech summary</a> | <a href="#error-handling">Error handling</a> | <a href="#performance">Performance</a> | <a href="#comparison-with-python-version">vs Python</a> | <a href="#conclusion">Conclusion</a></p>
</blockquote>

<p>A few years ago I wrote <a href="https://benhoyt.com/writings/pygit/">pygit</a>, a small Python program that’s just enough of a Git client to create a repository, add some commits, and push itself to GitHub.</p>

<p>I wanted to compare what it would look like in Go, to see if it was reasonable to write small scripts in Go – quick ’n’ dirty code where performance isn’t a big deal, and stack traces are all you need for error handling.</p>

<p>The result is <a href="https://github.com/benhoyt/gogit/blob/master/gogit.go">gogit</a>, a 400-line Go program that can initialise a repository, commit, and push to GitHub. It’s written in ordinary Go … except for error handling, which is just too verbose in idiomatic Go to work well for scripting (more on that <a href="#error-handling">below</a>).</p>

<h2 id="technical-summary">Technical summary</h2>

<p>I won’t go into detail about how Git works here (there’s a bit more in my <a href="https://benhoyt.com/writings/pygit/">pygit article</a>), suffice to say that the Git data model is pretty neat. It uses a simple file-based object store in <code>.git/objects</code>, where each object has a <a href="https://en.wikipedia.org/wiki/SHA-1">40-character hash</a> and can be a <em>commit</em>, a <em>tree</em> (directory listing), or a <em>blob</em> (committed file). That’s it – the <a href="https://github.com/benhoyt/gogit/blob/e94720d64dd93ca7aea17a314ea6430fc5f6b90c/gogit.go#L111-L164">gogit code</a> to write commits, trees, and blobs is about 50 lines.</p>

<p>I’ve implemented even less than pygit: only <code>init</code>, <code>commit</code>, and <code>push</code>. Gogit doesn’t even support the index (staging area), so instead of <code>gogit add</code>, you just <code>gogit commit</code> with the list of paths you want to commit each time. As <a href="https://github.com/benhoyt/pygit/blob/aa8d8bb62ae273ae2f4f167e36f24f40a11634b9/pygit.py#L231-L246">pygit’s code</a> shows, dealing with the index is messy. It’s also unnecessary, and I wanted gogit to be an exercise in minimalism.</p>

<p>Gogit also drops the commands <code>cat-file</code>, <code>hash-object</code>, and <code>diff</code> – those aren’t required for committing and pushing to GitHub. I did use Git’s <code>cat-file</code> during debugging, however.</p>

<p>Here are the commands I used to create the repo, commit, and push to GitHub (note the use of <a href="https://pkg.go.dev/cmd/go#hdr-Compile_and_run_Go_program"><code>go run</code></a> to compile and execute the “script”):</p>

<div><div><pre><code># Initialise the repo
$ go run . init

# Make the first commit (other commits are similar)
$ export GIT_AUTHOR_NAME=&#39;Ben Hoyt&#39;
$ export GIT_AUTHOR_EMAIL=benhoyt@gmail.com
$ go run . commit -m &#39;Initial commit&#39; gogit.go go.mod LICENSE.txt
commited 0580a17 to master

# Push updates to GitHub
$ export GIT_USERNAME=benhoyt
$ export GIT_PASSWORD=...
$ go run . push https://github.com/benhoyt/gogit
updating remote master from 0000000 to 0580a17 (5 objects)
</code></pre></div></div>

<h2 id="error-handling">Error handling</h2>

<p>The verbosity of Go’s error handling has been much-maligned. It’s simple and explicit, but every call to a function that may fail takes an additional three lines of code to handle the error:</p>

<div><div><pre><code><span>mode</span><span>,</span> <span>err</span> <span>:=</span> <span>strconv</span><span>.</span><span>ParseInt</span><span>(</span><span>modeStr</span><span>,</span> <span>8</span><span>,</span> <span>64</span><span>)</span>
<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>return</span> <span>err</span>
<span>}</span>
</code></pre></div></div>

<p>It’s not as big a deal when writing production code, because then you want more control over error handling anyway – nicely-wrapped errors, or human-readable messages, for example:</p>

<div><div><pre><code><span>mode</span><span>,</span> <span>err</span> <span>:=</span> <span>strconv</span><span>.</span><span>ParseInt</span><span>(</span><span>modeStr</span><span>,</span> <span>8</span><span>,</span> <span>64</span><span>)</span>
<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
    <span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;mode must be an octal number, not %q&#34;</span><span>,</span> <span>modeStr</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>In a simple script, however, <a href="https://www.reddit.com/r/golang/comments/6v63c2/comment/dly1pis/">all the error handling you need</a> is to show a message, print a stack trace, and exit the program. That’s what happens in Python when you don’t catch exceptions, and it’s easy to emulate in Go with a <a href="https://github.com/benhoyt/gogit/blob/e94720d64dd93ca7aea17a314ea6430fc5f6b90c/gogit.go#L84-L101">couple of helper functions</a>:</p>

<div><div><pre><code><span>func</span> <span>check0</span><span>(</span><span>err</span> <span>error</span><span>)</span> <span>{</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>panic</span><span>(</span><span>err</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>func</span> <span>check</span><span>[</span><span>T</span> <span>any</span><span>](</span><span>value</span> <span>T</span><span>,</span> <span>err</span> <span>error</span><span>)</span> <span>T</span> <span>{</span>
    <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
        <span>panic</span><span>(</span><span>err</span><span>)</span>
    <span>}</span>
    <span>return</span> <span>value</span>
<span>}</span>

<span>func</span> <span>assert</span><span>(</span><span>cond</span> <span>bool</span><span>,</span> <span>format</span> <span>string</span><span>,</span> <span>args</span> <span>...</span><span>any</span><span>)</span> <span>{</span>
    <span>if</span> <span>!</span><span>cond</span> <span>{</span>
        <span>panic</span><span>(</span><span>fmt</span><span>.</span><span>Sprintf</span><span>(</span><span>format</span><span>,</span> <span>args</span><span>...</span><span>))</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Now that Go has generics you can easily define a <code>check</code> function which returns a result. However, you still need variants based on the number of results returned. Normally this is zero or one, with one being most common, so I’ve named that variant just <code>check</code>, and the zero-results one <code>check0</code>. I’ve also defined <code>assert</code>, which takes a boolean and a formatted message instead of an error.</p>

<p>These helpers allow you to turn this code:</p>

<div><div><pre><code><span>func</span> <span>writeTree</span><span>(</span><span>paths</span> <span>[]</span><span>string</span><span>)</span> <span>([]</span><span>byte</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
    <span>sort</span><span>.</span><span>Strings</span><span>(</span><span>paths</span><span>)</span> <span>// tree object needs paths sorted</span>
    <span>var</span> <span>buf</span> <span>bytes</span><span>.</span><span>Buffer</span>
    <span>for</span> <span>_</span><span>,</span> <span>path</span> <span>:=</span> <span>range</span> <span>paths</span> <span>{</span>
        <span>st</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>Stat</span><span>(</span><span>path</span><span>)</span>
        <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
            <span>return</span> <span>nil</span><span>,</span> <span>err</span>
        <span>}</span>
        <span>if</span> <span>st</span><span>.</span><span>IsDir</span><span>()</span> <span>{</span>
            <span>panic</span><span>(</span><span>&#34;sub-trees not supported&#34;</span><span>)</span>
        <span>}</span>
        <span>data</span><span>,</span> <span>err</span> <span>:=</span> <span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>path</span><span>)</span>
        <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
            <span>return</span> <span>nil</span><span>,</span> <span>err</span>
        <span>}</span>
        <span>hash</span><span>,</span> <span>err</span> <span>:=</span> <span>hashObject</span><span>(</span><span>&#34;blob&#34;</span><span>,</span> <span>data</span><span>)</span>
        <span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
            <span>return</span> <span>nil</span><span>,</span> <span>err</span>
        <span>}</span>
        <span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>&#34;%o %s</span><span>\x00</span><span>%s&#34;</span><span>,</span> <span>st</span><span>.</span><span>Mode</span><span>()</span><span>.</span><span>Perm</span><span>()</span><span>|</span><span>0</span><span>o100000</span><span>,</span> <span>path</span><span>,</span> <span>hash</span><span>)</span>
    <span>}</span>
    <span>return</span> <span>hashObject</span><span>(</span><span>&#34;tree&#34;</span><span>,</span> <span>buf</span><span>.</span><span>Bytes</span><span>())</span>
<span>}</span>
</code></pre></div></div>

<p>Into the following, reducing the function body from 21 to 10 lines, which is comparable to the brevity of Python:</p>

<div><div><pre><code><span>func</span> <span>writeTree</span><span>(</span><span>paths</span> <span>[]</span><span>string</span><span>)</span> <span>[]</span><span>byte</span> <span>{</span>
    <span>sort</span><span>.</span><span>Strings</span><span>(</span><span>paths</span><span>)</span> <span>// tree object needs paths sorted</span>
    <span>var</span> <span>buf</span> <span>bytes</span><span>.</span><span>Buffer</span>
    <span>for</span> <span>_</span><span>,</span> <span>path</span> <span>:=</span> <span>range</span> <span>paths</span> <span>{</span>
        <span>st</span> <span>:=</span> <span>check</span><span>(</span><span>os</span><span>.</span><span>Stat</span><span>(</span><span>path</span><span>))</span>
        <span>assert</span><span>(</span><span>!</span><span>st</span><span>.</span><span>IsDir</span><span>(),</span> <span>&#34;sub-trees not supported&#34;</span><span>)</span>
        <span>data</span> <span>:=</span> <span>check</span><span>(</span><span>os</span><span>.</span><span>ReadFile</span><span>(</span><span>path</span><span>))</span>
        <span>hash</span> <span>:=</span> <span>hashObject</span><span>(</span><span>&#34;blob&#34;</span><span>,</span> <span>data</span><span>)</span>
        <span>fmt</span><span>.</span><span>Fprintf</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>&#34;%o %s</span><span>\x00</span><span>%s&#34;</span><span>,</span> <span>st</span><span>.</span><span>Mode</span><span>()</span><span>.</span><span>Perm</span><span>()</span><span>|</span><span>0</span><span>o100000</span><span>,</span> <span>path</span><span>,</span> <span>hash</span><span>)</span>
    <span>}</span>
    <span>return</span> <span>hashObject</span><span>(</span><span>&#34;tree&#34;</span><span>,</span> <span>buf</span><span>.</span><span>Bytes</span><span>())</span>
<span>}</span>
</code></pre></div></div>

<p>It’s not perfect, because the word <code>check</code> slightly obscures the function you’re calling, but it does makes writing quick ’n’ dirty scripts a lot nicer.</p>

<p>You even get “better” errors than a plain <code>return err</code>, because the stack trace shows you exactly what function and line of code was being executed:</p>

<div><div><pre><code>$ go run . push https://github.com/benhoyt/gogit
panic: Get &#34;https://github.com/benhoyt/gogit/info/refs?service=git-receive-pack&#34;:
    context deadline exceeded (Client.Timeout exceeded while awaiting headers)

goroutine 1 [running]:
main.check[...](...)
    /home/ben/h/gogit/gogit.go:94
main.getRemoteHash(0x416ad0?, {0x7ffe1f0152d9?, 0x4b87d4?}, {0xc00001c00d, 0x7}, {0xc00001a00d, 0x28})
    /home/ben/h/gogit/gogit.go:245 +0x6da
main.push({0x7ffe1f0152d9, 0x20}, {0xc00001c00d, 0x7}, {0xc00001a00d, 0x28})
    /home/ben/h/gogit/gogit.go:217 +0xd9
main.main()
    /home/ben/h/gogit/gogit.go:73 +0x21e
exit status 2
</code></pre></div></div>

<p><a href="https://github.com/benhoyt/gogit/commit/ad75a5fbf67924d5a62dc9794e772d069610d085">Changing from <code>return err</code> to <code>check</code></a> reduced the number of lines of code from 607 to 415, a reduction by 32%.</p>

<p>If you want to pursue this approach further, there’s even a library written by Joe Tsai and Josh Bleecher Snyder called <a href="https://github.com/dsnet/try"><code>try</code></a> that uses <a href="https://pkg.go.dev/builtin#recover"><code>recover</code></a> to do this “properly”. Interesting stuff! I’m still hoping the Go team figures out a way to make error handling less verbose.</p>

<h2 id="performance">Performance</h2>

<p>This is going to be a short section, because I don’t care about speed in this program, and the Go version is likely as fast or faster than the Python version. Go can be significantly faster, but we’re dealing with tiny files, and in Python, all the interesting code like hashing and writing to disk is written in C anyway.</p>

<p>Memory usage is another aspect of performance. Again, we’re dealing with small files here, so it’s not an issue to read everything into memory. In Python, you can do streaming, but it’s not as consistently easy as in Go, due to the amazing <a href="https://pkg.go.dev/io#Reader"><code>io.Reader</code></a> and <a href="https://pkg.go.dev/io#Writer"><code>io.Writer</code></a> interfaces.</p>

<p>That said, it’s still a bit easier in Go to read everything into <code>[]byte</code> or <code>string</code> and operate on those, so that’s what I’ve done in gogit. We’re talking about a few KB of memory, and my machine has a few GB.</p>

<h2 id="comparison-with-python-version">Comparison with Python version</h2>

<p>As it stands, Pygit is about 600 lines of code, and gogit about 400. However, that’s a bit misleading, as I removed several features when writing the Go version: there’s no support for the Git index, and there’s no <code>cat-file</code>, <code>hash-object</code>, or <code>diff</code>.</p>

<p>I did a quick test by removing those functions from the Python version, and it ends up at 360 lines of code. I consider 400 in Go versus 360 in Python not bad – it’s only 10% longer. And the Go version includes 20 lines of imports and 20 lines for the check/assert functions. So they’re really almost identical in size!</p>

<p>Let’s look at a couple of specific functions. First, <code>find_object</code>, which looks in the Git object store to find an object with the given prefix. Here’s the Python version:</p>

<div><div><pre><code><span>def</span> <span>find_object</span><span>(</span><span>sha1_prefix</span><span>):</span>
    <span>obj_dir</span> <span>=</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>&#39;.git&#39;</span><span>,</span> <span>&#39;objects&#39;</span><span>,</span> <span>sha1_prefix</span><span>[:</span><span>2</span><span>])</span>
    <span>rest</span> <span>=</span> <span>sha1_prefix</span><span>[</span><span>2</span><span>:]</span>
    <span>objects</span> <span>=</span> <span>[</span><span>name</span> <span>for</span> <span>name</span> <span>in</span> <span>os</span><span>.</span><span>listdir</span><span>(</span><span>obj_dir</span><span>)</span> <span>if</span> <span>name</span><span>.</span><span>startswith</span><span>(</span><span>rest</span><span>)]</span>
    <span>if</span> <span>not</span> <span>objects</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#39;object {!r} not found&#39;</span><span>.</span><span>format</span><span>(</span><span>sha1_prefix</span><span>))</span>
    <span>if</span> <span>len</span><span>(</span><span>objects</span><span>)</span> <span>&gt;=</span> <span>2</span><span>:</span>
        <span>raise</span> <span>ValueError</span><span>(</span><span>&#39;multiple objects ({}) with prefix {!r}&#39;</span><span>.</span><span>format</span><span>(</span>
                <span>len</span><span>(</span><span>objects</span><span>),</span> <span>sha1_prefix</span><span>))</span>
    <span>return</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>obj_dir</span><span>,</span> <span>objects</span><span>[</span><span>0</span><span>])</span>
</code></pre></div></div>

<p>And here’s the Go version:</p>

<div><div><pre><code><span>func</span> <span>findObject</span><span>(</span><span>hashPrefix</span> <span>string</span><span>)</span> <span>string</span> <span>{</span>
    <span>objDir</span> <span>:=</span> <span>filepath</span><span>.</span><span>Join</span><span>(</span><span>&#34;.git/objects&#34;</span><span>,</span> <span>hashPrefix</span><span>[</span><span>:</span><span>2</span><span>])</span>
    <span>rest</span> <span>:=</span> <span>hashPrefix</span><span>[</span><span>2</span><span>:</span><span>]</span>
    <span>entries</span><span>,</span> <span>_</span> <span>:=</span> <span>os</span><span>.</span><span>ReadDir</span><span>(</span><span>objDir</span><span>)</span>
    <span>var</span> <span>matches</span> <span>[]</span><span>string</span>
    <span>for</span> <span>_</span><span>,</span> <span>entry</span> <span>:=</span> <span>range</span> <span>entries</span> <span>{</span>
        <span>if</span> <span>strings</span><span>.</span><span>HasPrefix</span><span>(</span><span>entry</span><span>.</span><span>Name</span><span>(),</span> <span>rest</span><span>)</span> <span>{</span>
            <span>matches</span> <span>=</span> <span>append</span><span>(</span><span>matches</span><span>,</span> <span>entry</span><span>.</span><span>Name</span><span>())</span>
        <span>}</span>
    <span>}</span>
    <span>assert</span><span>(</span><span>len</span><span>(</span><span>matches</span><span>)</span> <span>&gt;</span> <span>0</span><span>,</span> <span>&#34;object %q not found&#34;</span><span>,</span> <span>hashPrefix</span><span>)</span>
    <span>assert</span><span>(</span><span>len</span><span>(</span><span>matches</span><span>)</span> <span>==</span> <span>1</span><span>,</span> <span>&#34;multiple objects with prefix %q&#34;</span><span>,</span> <span>hashPrefix</span><span>)</span>
    <span>return</span> <span>filepath</span><span>.</span><span>Join</span><span>(</span><span>objDir</span><span>,</span> <span>matches</span><span>[</span><span>0</span><span>])</span>
<span>}</span>
</code></pre></div></div>

<p>A lot of things are similar, for example the <code>os.path.join</code> vs <code>filepath.Join</code>, <code>os.listdir</code> vs <code>os.ReadDir</code>, and so on. But note the list comprehension in Python – a one-liner – is a five-line <code>for</code> loop in Go. I do miss list comprehensions when scripting in Go…</p>

<p>Let’s look at another one, the <code>commit</code> function, first in Python:</p>

<div><div><pre><code><span>def</span> <span>commit</span><span>(</span><span>message</span><span>,</span> <span>author</span><span>):</span>
    <span>tree</span> <span>=</span> <span>write_tree</span><span>()</span>
    <span>parent</span> <span>=</span> <span>get_local_master_hash</span><span>()</span>
    <span>timestamp</span> <span>=</span> <span>int</span><span>(</span><span>time</span><span>.</span><span>mktime</span><span>(</span><span>time</span><span>.</span><span>localtime</span><span>()))</span>
    <span>utc_offset</span> <span>=</span> <span>-</span><span>time</span><span>.</span><span>timezone</span>
    <span>author_time</span> <span>=</span> <span>&#39;{} {}{:02}{:02}&#39;</span><span>.</span><span>format</span><span>(</span>
            <span>timestamp</span><span>,</span>
            <span>&#39;+&#39;</span> <span>if</span> <span>utc_offset</span> <span>&gt;</span> <span>0</span> <span>else</span> <span>&#39;-&#39;</span><span>,</span>
            <span>abs</span><span>(</span><span>utc_offset</span><span>)</span> <span>//</span> <span>3600</span><span>,</span>
            <span>(</span><span>abs</span><span>(</span><span>utc_offset</span><span>)</span> <span>//</span> <span>60</span><span>)</span> <span>%</span> <span>60</span><span>)</span>
    <span>lines</span> <span>=</span> <span>[</span><span>&#39;tree &#39;</span> <span>+</span> <span>tree</span><span>]</span>
    <span>if</span> <span>parent</span><span>:</span>
        <span>lines</span><span>.</span><span>append</span><span>(</span><span>&#39;parent &#39;</span> <span>+</span> <span>parent</span><span>)</span>
    <span>lines</span><span>.</span><span>append</span><span>(</span><span>&#39;author {} {}&#39;</span><span>.</span><span>format</span><span>(</span><span>author</span><span>,</span> <span>author_time</span><span>))</span>
    <span>lines</span><span>.</span><span>append</span><span>(</span><span>&#39;committer {} {}&#39;</span><span>.</span><span>format</span><span>(</span><span>author</span><span>,</span> <span>author_time</span><span>))</span>
    <span>lines</span><span>.</span><span>append</span><span>(</span><span>&#39;&#39;</span><span>)</span>
    <span>lines</span><span>.</span><span>append</span><span>(</span><span>message</span><span>)</span>
    <span>lines</span><span>.</span><span>append</span><span>(</span><span>&#39;&#39;</span><span>)</span>
    <span>data</span> <span>=</span> <span>&#39;</span><span>\n</span><span>&#39;</span><span>.</span><span>join</span><span>(</span><span>lines</span><span>).</span><span>encode</span><span>()</span>
    <span>sha1</span> <span>=</span> <span>hash_object</span><span>(</span><span>data</span><span>,</span> <span>&#39;commit&#39;</span><span>)</span>
    <span>master_path</span> <span>=</span> <span>os</span><span>.</span><span>path</span><span>.</span><span>join</span><span>(</span><span>&#39;.git&#39;</span><span>,</span> <span>&#39;refs&#39;</span><span>,</span> <span>&#39;heads&#39;</span><span>,</span> <span>&#39;master&#39;</span><span>)</span>
    <span>write_file</span><span>(</span><span>master_path</span><span>,</span> <span>(</span><span>sha1</span> <span>+</span> <span>&#39;</span><span>\n</span><span>&#39;</span><span>).</span><span>encode</span><span>())</span>
    <span>return</span> <span>sha1</span>
</code></pre></div></div>

<p>Then in Go:</p>

<div><div><pre><code><span>func</span> <span>commit</span><span>(</span><span>message</span><span>,</span> <span>author</span> <span>string</span><span>,</span> <span>paths</span> <span>[]</span><span>string</span><span>)</span> <span>string</span> <span>{</span>
    <span>tree</span> <span>:=</span> <span>writeTree</span><span>(</span><span>paths</span><span>)</span>
    <span>var</span> <span>buf</span> <span>bytes</span><span>.</span><span>Buffer</span>
    <span>fmt</span><span>.</span><span>Fprintln</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>&#34;tree&#34;</span><span>,</span> <span>hex</span><span>.</span><span>EncodeToString</span><span>(</span><span>tree</span><span>))</span>
    <span>parent</span> <span>:=</span> <span>getLocalHash</span><span>()</span>
    <span>if</span> <span>parent</span> <span>!=</span> <span>&#34;&#34;</span> <span>{</span>
        <span>fmt</span><span>.</span><span>Fprintln</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>&#34;parent&#34;</span><span>,</span> <span>parent</span><span>)</span>
    <span>}</span>
    <span>now</span> <span>:=</span> <span>time</span><span>.</span><span>Now</span><span>()</span>
    <span>offset</span> <span>:=</span> <span>now</span><span>.</span><span>Format</span><span>(</span><span>&#34;-0700&#34;</span><span>)</span>
    <span>fmt</span><span>.</span><span>Fprintln</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>&#34;author&#34;</span><span>,</span> <span>author</span><span>,</span> <span>now</span><span>.</span><span>Unix</span><span>(),</span> <span>offset</span><span>)</span>
    <span>fmt</span><span>.</span><span>Fprintln</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>&#34;committer&#34;</span><span>,</span> <span>author</span><span>,</span> <span>now</span><span>.</span><span>Unix</span><span>(),</span> <span>offset</span><span>)</span>
    <span>fmt</span><span>.</span><span>Fprintln</span><span>(</span><span>&amp;</span><span>buf</span><span>)</span>
    <span>fmt</span><span>.</span><span>Fprintln</span><span>(</span><span>&amp;</span><span>buf</span><span>,</span> <span>message</span><span>)</span>
    <span>data</span> <span>:=</span> <span>buf</span><span>.</span><span>Bytes</span><span>()</span>
    <span>hash</span> <span>:=</span> <span>hashObject</span><span>(</span><span>&#34;commit&#34;</span><span>,</span> <span>data</span><span>)</span>
    <span>check0</span><span>(</span><span>os</span><span>.</span><span>WriteFile</span><span>(</span><span>&#34;.git/refs/heads/master&#34;</span><span>,</span> <span>[]</span><span>byte</span><span>(</span><span>hex</span><span>.</span><span>EncodeToString</span><span>(</span><span>hash</span><span>)</span><span>+</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>),</span> <span>0</span><span>o664</span><span>))</span>
    <span>return</span> <span>hex</span><span>.</span><span>EncodeToString</span><span>(</span><span>hash</span><span>)</span>
<span>}</span>
</code></pre></div></div>

<p>Interestingly, this time the Python version is longer: 23 lines versus Go’s 19. This mostly comes down to the better handling of timestamps. Go’s standard library isn’t perfect, but its <a href="https://pkg.go.dev/time"><code>time</code></a> package is better than Python’s <code>time</code> and <code>datetime</code> packages put together.</p>

<p>In general, Go’s standard library seems much more coherent and better-designed than Python’s, which feels like it was designed by many different people over several decades (because it was).</p>

<h2 id="conclusion">Conclusion</h2>

<p>When used with <code>panic</code>-based error handling, Go is good for writing quick ’n’ dirty command line scripts.</p>

<p>To be honest, I’d still probably reach for Python first for throwaway scripts, because of its terser syntax, list (and other) comprehensions, and exception handling by default.</p>

<p>However, for anything more than a throwaway script, I’d quickly move to Go. Its standard library is better-designed, its <code>io.Reader</code> and <code>io.Writer</code> interfaces are excellent, and its lightweight static typing helps catch bugs without getting in the way.</p>

<p>I’d love it if you <a href="https://github.com/sponsors/benhoyt/">sponsored me on GitHub</a> – it will motivate me to work on my open source projects and write more good content. Thanks!</p>


</div>

</div></div>
  </body>
</html>
