<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://8dcc.github.io/programming/pool-allocator.html">Original</a>
    <h1>Writing a simple pool allocator in C</h1>
    
    <div id="readability-page-1" class="page"><div id="text-adding-valgrind-support">
<p>
<a href="https://valgrind.org/">Valgrind</a> is a very useful tool for debugging and profiling programs. Among
other things, it lets you detect memory leaks and invalid memory
accesses. Personally, I have been using it for some years for detecting
memory-related bugs in programs that use the standard library (i.e. <code>malloc</code>,
<code>free</code>, etc.), but I didn’t know that the valgrind framework also had support for
custom allocators.
</p>

<p>
The <a href="https://valgrind.org/docs/manual/mc-manual.html">Memcheck manual</a> contains a lot of useful information for us, specially the
<a href="https://valgrind.org/docs/manual/mc-manual.html#mc-manual.mempools"><i>Memory Pools</i> section</a>. This <a href="https://developers.redhat.com/articles/2022/03/23/use-valgrind-memcheck-custom-memory-manager#">Red Hat article</a> also contains some useful
information about how the valgrind framework can be used with other kinds of
allocators.
</p>

<p>
First, we will need to include valgrind’s headers. You might need to install
some <code>valgrind-devel</code> package, depending on your distribution.
</p>

<div>
<pre><span>#include</span> <span>&lt;valgrind/valgrind.h&gt;</span>
<span>#include</span> <span>&lt;valgrind/memcheck.h&gt;</span>
</pre>
</div>

<p>
We will need to register an <i>anchor address</i> (i.e. the address of our <code>Pool</code>
structure) with <code>VALGRIND_CREATE_MEMPOOL</code> once, in <code>pool_new</code>. This <i>anchor address</i>
is needed to associate each chunk with its specific pool whenever it’s allocated
or freed. We will also have to use <code>VALGRIND_DESTROY_MEMPOOL</code> once we are done
with the pool, in <code>pool_close</code>.
</p>

<p>
The <code>VALGRIND_MAKE_MEM_NOACCESS</code> macro will be used when a memory region should be
inaccessible by the user (e.g. for the <code>Pool</code> and <code>ArrayStart</code> structures); while
the <code>VALGRIND_MAKE_MEM_DEFINED</code> macro will be used whenever we need to read or
write to a <code>NOACCESS</code> region (e.g. when accessing the <code>Pool.array_starts</code> member in
<code>pool_expand</code>). There is also a <code>VALGRIND_MAKE_MEM_UNDEFINED</code> macro, but we won’t
need to call it manually.
</p>

<p>
Finally, we will have to use <code>VALGRIND_MEMPOOL_ALLOC</code> when allocating a chunk from
the pool, and <code>VALGRIND_MEMPOOL_FREE</code> when freeing it. These functions will call
<code>VALGRIND_MAKE_MEM_UNDEFINED</code><sup><a id="fnr.4" href="#fn.4" role="doc-backlink">4</a></sup>  and <code>VALGRIND_MAKE_MEM_NOACCESS</code> respectively, so
we won’t have to worry about that.
</p>

<p>
With all that in mind, this is how our new code would look like:
</p>

<div>
<pre><span>Pool</span>* <span>pool_new</span>(<span>size_t</span> <span>pool_sz</span>, <span>size_t</span> <span>chunk_sz</span>) {
    <span>/* </span><span>...</span><span> */</span>

    VALGRIND_MAKE_MEM_NOACCESS(arr, pool_sz * chunk_sz);
    VALGRIND_MAKE_MEM_NOACCESS(pool-&gt;array_starts, <span>sizeof</span>(ArrayStart));
    VALGRIND_MAKE_MEM_NOACCESS(pool, <span>sizeof</span>(Pool));
    VALGRIND_CREATE_MEMPOOL(pool, <span>0</span>, <span>0</span>);

    <span>return</span> pool;
}

<span>bool</span> <span>pool_expand</span>(<span>Pool</span>* <span>pool</span>, <span>size_t</span> <span>extra_sz</span>) {
    <span>if</span> (pool == <span>NULL</span> || extra_sz == <span>0</span>)
        <span>return</span> <span>false</span>;

    VALGRIND_MAKE_MEM_DEFINED(pool, <span>sizeof</span>(Pool));

    <span>/* </span><span>...</span><span> */</span>

    VALGRIND_MAKE_MEM_NOACCESS(extra_arr, extra_sz * pool-&gt;chunk_sz);
    VALGRIND_MAKE_MEM_NOACCESS(array_start, <span>sizeof</span>(ArrayStart));
    VALGRIND_MAKE_MEM_NOACCESS(pool, <span>sizeof</span>(Pool));

    <span>return</span> <span>true</span>;
}

<span>void</span> <span>pool_close</span>(<span>Pool</span>* <span>pool</span>) {
    <span>if</span> (pool == <span>NULL</span>)
        <span>return</span>;

    VALGRIND_MAKE_MEM_DEFINED(pool, <span>sizeof</span>(Pool));

    <span>ArrayStart</span>* <span>array_start</span> = pool-&gt;array_starts;
    <span>while</span> (array_start != <span>NULL</span>) {
        VALGRIND_MAKE_MEM_DEFINED(array_start, <span>sizeof</span>(ArrayStart));
        <span>/* </span><span>...</span><span> */</span>
    }

    VALGRIND_DESTROY_MEMPOOL(pool);
    free(pool);
}

<span>void</span>* <span>pool_alloc</span>(<span>Pool</span>* <span>pool</span>) {
    <span>if</span> (pool == <span>NULL</span>)
        <span>return</span> <span>NULL</span>;
    VALGRIND_MAKE_MEM_DEFINED(pool, <span>sizeof</span>(Pool));

    <span>if</span> (pool-&gt;free_chunk == <span>NULL</span>)
        <span>return</span> <span>NULL</span>;
    VALGRIND_MAKE_MEM_DEFINED(pool-&gt;free_chunk, <span>sizeof</span>(<span>void</span>**));

    <span>/* </span><span>...</span><span> */</span>

    VALGRIND_MEMPOOL_ALLOC(pool, result, pool-&gt;chunk_sz);
    VALGRIND_MAKE_MEM_NOACCESS(pool-&gt;free_chunk, <span>sizeof</span>(<span>void</span>**));
    VALGRIND_MAKE_MEM_NOACCESS(pool, <span>sizeof</span>(Pool));
    <span>return</span> result;
}

<span>void</span> <span>pool_free</span>(<span>Pool</span>* <span>pool</span>, <span>void</span>* <span>ptr</span>) {
    <span>if</span> (pool == <span>NULL</span> || ptr == <span>NULL</span>)
        <span>return</span>;

    VALGRIND_MAKE_MEM_DEFINED(pool, <span>sizeof</span>(Pool));

    <span>/* </span><span>...</span><span> */</span>

    VALGRIND_MAKE_MEM_NOACCESS(pool, <span>sizeof</span>(Pool));
    VALGRIND_MEMPOOL_FREE(pool, ptr);
}
</pre>
</div>

<p>
Although it makes the code less readable, adding valgrind support is definitely
worth it.
</p>

<p>
As I mentioned, this is the first time I use valgrind with a non-standard
allocator, so feel free to <a href="https://github.com/8dcc/8dcc.github.io/pulls">contribute</a> if you have any suggestions or
improvements.
</p>
</div></div>
  </body>
</html>
