<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tonbo.io/blog/async-rust-is-not-safe-with-io-uring">Original</a>
    <h1>Async Rust is not safe with io_uring</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div data-svelte-h="svelte-184ng9o"> <p>October 30, 2024 by Tzu Gwo</p></div> <h2 data-svelte-h="svelte-s902pt">TL;DR</h2> <pre data-svelte-h="svelte-8brff3">	1. Clone <a href="https://github.com/ethe/io-uring-is-not-cancellation-safe">this repository</a> on a Linux system that supports io_uring.</pre> <pre data-svelte-h="svelte-vfyltr">	2. Try switching <a href="https://github.com/ethe/io-uring-is-not-cancellation-safe/blob/master/src/main.rs#L9-L10">these two lines.</a></pre> <pre data-svelte-h="svelte-1om2w1r">	3. Execute cargo run for a while.</pre> <p data-svelte-h="svelte-a92z3x">The demo shows that even though the behavior appears similar, TCP connections leak when
				using the io_uring driver but not with the epoll driver. I&#39;ve also <a href="https://github.com/ethe/io-uring-is-not-cancellation-safe/branches/all">tested this across various io_uring runtimes,</a> and it turns out to be a common issue across all of them.</p> <h2 data-svelte-h="svelte-1nsv6xs">Barbara&#39;s TCP connection mysteriously leaked</h2> <p data-svelte-h="svelte-10biiqt">Barbara had a lot of experience developing web services with async Rust. One day, she read a
				blog about io_uring, which described it as the next-generation async I/O interface for
				Linux. Interested, Barbara decided to try it out in her sidecar web service.</p> <p data-svelte-h="svelte-njq492">Rust&#39;s &#34;async/await&#34; model is separate from the async runtime and I/O interface
				implementations, making it easy to switch between different runtimes. Barbara was very
				familiar with Tokio, the most popular async runtime in Rust, which uses epoll for I/O
				interface. So, she looked for an async runtime that supported io_uring to transform her web
				service into an io_uring-based version.</p> <p data-svelte-h="svelte-1pil8jj">After some research, Barbara discovered several async runtimes like <a href="https://github.com/DataDog/glommio">glommio,</a> <a href="https://github.com/bytedance/monoio">monoio,</a>
				and
				<a href="https://github.com/compio-rs/compio">compio</a> that supported io_uring.
				She decided to give one of them a try—monoio, in particular, which provided both epoll and io_uring
				interfaces and allowed for easy switching. It seemed like the perfect fit for Barbara&#39;s io_uring
				exploration.</p> <p data-svelte-h="svelte-6gwc0">With her familiarity with Tokio, Barbara quickly wrote her first HTTP server demo:</p>    <p data-svelte-h="svelte-1lcrgpz">Barbara thought, &#34;Great, this looks no different from a typical Tokio program—first bind to
				an address, then continuously accept new TCP connections in a loop and process them.&#34;</p> <p data-svelte-h="svelte-133qamx">Barbara then considered her next steps. She decided to learn how to implement asynchronous
				control, such as timeouts, so that if the TCP listener did not accept a connection for a
				while, it could switch to handling some sidecar tasks (like logging) before resuming
				acceptance:</p>    <p data-svelte-h="svelte-1ocoebl">Using the concurrency primitive &#34;select&#34; to add timeouts to futures worked well with
				io_uring. Barbara was pleased and quickly updated her web service to use io_uring,
				eventually deploying it. Everything ran smoothly until one day she noticed something odd in
				the client logs: some requests were never processed. To investigate, Barbara wrote a minimal
				example, only to find the issue was far more complex than expected.</p> <p data-svelte-h="svelte-1q7x5qs">Barbara found that while the client running in a child thread was connecting correctly, the
				server in the main thread wasn’t proceeding as it should. Instead, the timeout kept getting
				triggered, as if the client&#39;s connection had vanished. <b>A TCP connection leak had occurred.</b>
				And it wasn&#39;t just monoio—this issue affected all async runtimes that used io_uring.</p> <h2 data-svelte-h="svelte-1ujqvyi">What’s going on?</h2> <p data-svelte-h="svelte-1q0g62a">Before understanding why using &#34;select&#34; for timeout control in an io_uring-based async
				runtime leads to TCP connection leaks, we need to first understand why this issue doesn’t
				occur with epoll.</p> <p data-svelte-h="svelte-1d2d4e6">The entire async Rust ecosystem is built around a core asynchronous primitive from the
				standard library: Future. Its definition is as follows:</p>    <p data-svelte-h="svelte-1efgqfq">In Rust, all asynchronous operations—not just those manually written by async library
				developers but also those written by users using &#34;async&#34; blocks—are defined as recursive
				future structures, which get instantiated when &#34;.await&#34; is called. The entire structure
				contains all the state that must be saved across suspended futures during pending
				operations. The async executor is then responsible for repeatedly calling the &#34;poll&#34; method
				to advance this state until completion. Consider this example async block:</p>    <p data-svelte-h="svelte-1ntevmc">will transform to below by compiler:</p>    <p data-svelte-h="svelte-d9uza6">For a more detailed explanation of futures and how they are executed, I recommend reading
				<a href="https://en.ihcblog.com/rust-runtime-design-1/">ihciah&#39;s blog.</a>
				He is one of the core authors of monoio.</p> <p data-svelte-h="svelte-w78mu4">Async Rust makes a few core assumptions about futures:</p> <pre data-svelte-h="svelte-sjik6d">	1. The state of futures only change when they are polled.</pre> <pre data-svelte-h="svelte-thrp6b">	2. Futures are implicitly cancellable by simply never polling them again.
				</pre> <p data-svelte-h="svelte-1sa0hh5">Futures bound to epoll adhere to these assumptions, which relates to the mechanism of epoll:
				epoll is not an asynchronous syscall mechanism; it’s an event notification mechanism. In the
				above example, the actual behavior of the &#34;listener.accept()&#34; future, simplified, is as
				follows:</p>    <p data-svelte-h="svelte-6wikbk">&#34;self.accept()&#34; runs synchronously, either succeeding by obtaining a TCP stream or
				encountering a &#34;would block&#34; exception, leaving it in a pending state until the kernel is
				ready. To cancel this operation, you simply stop polling, as the syscall only happens during
				polling.</p> <p data-svelte-h="svelte-1jfsmfl">However, io_uring-bound futures break these two assumptions:</p> <pre data-svelte-h="svelte-1l5soen">	1. The syscall is executed asynchronously by the kernel, not during polling. The kernel commit the TCP stream into a kernel / user shared ring buffer, meaning the accept event is completed implicitly.</pre> <pre data-svelte-h="svelte-17rm9ec">	2. You cannot simply cancel an io_uring-bound future by stopping polling, as the kernel might complete the syscall at any time, <b>even during the cancellation progress</b>.
				</pre> <p data-svelte-h="svelte-11qp05s">A step-by-step explanation of the earlier example will make this process clearer:</p>    <h2 data-svelte-h="svelte-ipliht">How to solve this?</h2> <p data-svelte-h="svelte-1qr0z9y">Before discussing the solution, we need to break the problem down into two parts:</p> <pre data-svelte-h="svelte-19la56n">	1. <b>I/O Safety</b>: Ensuring that accepted TCP streams are properly closed without leaking connections.</pre> <pre data-svelte-h="svelte-17qcix0">	2. <b>Halt Safety</b> (proposed by Yoshua Wuyts): Handling connections that have already been opened when they are cancelled, allowing them to continue being processed.
				</pre> <h3 data-svelte-h="svelte-6xjdyo">I/O Safety</h3> <p data-svelte-h="svelte-1a2p9rh">First of all, we are fortunate that the I/O safety problem can be addressed now, which safe
				Rust aims to ensure this in the future. Rust provides the Drop trait to define custom
				behavior when a value is cleaned up. Thus, we can do something like this:</p>    <p data-svelte-h="svelte-1jocbtu">We just need to encourage async runtimes to implement this fix.</p> <h3 data-svelte-h="svelte-6hh2fm">Halt Safety</h3> <p data-svelte-h="svelte-7uppsm">Halt safety is more complicated. Monoio provides a component called &#34;cancellable I/O&#34; to
				properly handle the cancellation of io_uring-bound futures. A complete example can be found
				here: <a href="https://github.com/ethe/io-uring-is-not-cancellation-safe/blob/cancelable-io/src/main.rs">cancellable I/O example.</a> You can run this branch to see that the connection handling behavior now matches that of epoll.
				Here, I’ll show a simplified usage:</p>    <p data-svelte-h="svelte-1fi05wx">As you can see, besides performing the accept operation in the regular select branch, the
				timeout branch explicitly cancels the accept future. Afterwards, it proceeds to .await the
				accept future again to confirm if a TCP stream was ready during the timeout period.</p> <p data-svelte-h="svelte-usjqk4">Monoio&#39;s component partially solves the problem, but there&#39;s still an issue: since a future
				is a recursive structure, an io_uring-bound future may not be directly at the place where
				cancellation occurs:</p>    <p data-svelte-h="svelte-qxefi9">Canceling a future that contains an io_uring-bound future will also affect its inner
				io_uring-bound futures. This means that the cancellation safety of io_uring-bound futures is
				&#34;contagious.&#34; Simply converting an io_uring-bound future to cancellable I/O does not solve
				all the issues.</p> <p data-svelte-h="svelte-1e286rt">Another key issue is that if you forget to handle the cancellation of an io_uring-bound
				future, there are no compile-time checks to catch it. For io_uring-bound futures, you need
				to &#34;.await&#34; them after cancellation to see if they have completed. This means they must be
				<b>used exactly once,</b>
				a concept called
				<a href="https://en.wikipedia.org/wiki/Substructural_type_system">linear types,</a> which ensures correct usage of resources at compile time.</p> <p data-svelte-h="svelte-1t3pja8">Unfortunately, Rust lacks the support for this kind of type system. For more details on why
				adding linear logic to Rust is challenging, you can refer to Without Boats&#39; blog:
				<a href="https://without.boats/blog/changing-the-rules-of-rust/#:~:text=Let%E2%80%99s%20say%20you%20want%20Rust%20to%20support%20types%20which%20can%E2%80%99t%20go%20out%20of%20scope%20without%20running%20their%20destructor.%20This%20is%20one%20of%20the%20two%20different%20definitions%20of%20%E2%80%9Clinear%20types%2C%E2%80%9D">Changing the rules of Rust.</a></p> <h2 data-svelte-h="svelte-1tliofq">Why wrote this?</h2> <p data-svelte-h="svelte-1i0gxro">There has been a lot of discussion about memory safety in the context of io_uring. For more
				details, you can refer to these resources:</p> <pre data-svelte-h="svelte-1yhsrhe"> • <a href="https://blog.yoshuawuyts.com/async-cancellation-1/">Async Cancellation by yoshuawuyts</a></pre> <pre data-svelte-h="svelte-13a8yeb"> • <a href="https://without.boats/blog/io-uring/">Notes on io-uring by withoutboats</a></pre> <pre data-svelte-h="svelte-vye3w7"> • <a href="https://github.com/bytedance/monoio/blob/master/docs/en/why-async-rent.md">Async Rent by ihciah</a></pre> <p data-svelte-h="svelte-1wcx2zr">However, the community rarely addresses I/O safety and halt safety with io_uring in async
				Rust. I&#39;m presenting a specific case to draw attention to this topic. The title of this blog
				might sound a bit dramatic, but everyone has different definitions and understandings of
				&#34;safety.&#34; What do you think about this issue:</p> <pre data-svelte-h="svelte-15q3iv8"> • Keep things as they are; I/O safety and halt safety do not need guarantees from the language.</pre> <pre data-svelte-h="svelte-eoedff"> • Rust should ensure I/O safety (this is already a goal outlined in the RFC, but not yet implemented in Rust.)</pre> <pre data-svelte-h="svelte-ts4uky"> • Rust should ensure halt safety (rarely discussed!)</pre></article></div></div></div>
  </body>
</html>
