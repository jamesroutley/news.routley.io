<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://alanza.xyz/log/how-magic-is-too-magic/">Original</a>
    <h1>How magic is too magic? Personalities of programming languages</h1>
    
    <div id="readability-page-1" class="page"><div><div id="remainder"><p>The languages I know best are Zig, Lua and Rust, each of which comes with very different goals and assumptions, lending to a different style in terms of what feels fun to do.</p><p>Of these three, I think it’s obvious that Zig is the most serious programming language. It prides itself on having “no hidden control flow”, for example, hands you control (if you want it) over the memory layout of types, and requires you to manage memory correctly. That’s not to say Zig isn’t fun: when <a href="https://github.com/robbielyman/uxn-zig">I implemented</a> the <a href="https://100r.co/site/uxn.html">Uxn</a> virtual machine, I was able to define my own type which takes up one byte of space, but treats each bit of that byte correctly as either a “mode flag” or as part of a list of instructions. Whereas in C one has to do bitwise arithmetic directly, in Zig you can ask whether a bit is set as if it were a regular boolean, or switch on only the enum field of the byte-sized struct. Other classic metaprogramming tasks are also a joy in Zig, simply because they realized that programming Zig should be done in Zig, even if the purpose of that code is to construct a generic type and so the code runs at <em>compile time</em> instead of run time.</p><p>Rust, by comparison, is positively loosey-goosey. I’ve read too many complaints that Rust is hard because of the borrow checker and having to think about ownership. I could be wrong, but I think the reason for these complaints is because Rust was born as a Haskell that realized it could come for C++’s crown, but has morphed instead into a JavaScript run on that most virtual of machines, the actual CPU.</p><p>When you think about it using these frames, Rust is a joy to write. The borrow checker makes powerful, “zero-cost” abstractions possible, like copy-on-write structures, reference counting, <code>Impl Drop for T</code> running arbitrary code, closures, iterators, etc. Combine this with implicit returns and chainable methods, and you get the ability to write these beautifully terse koans that through the magic of LLVM are somehow also fast too. I love writing Rust; it makes me want to give it a noogie. Is your object on the stack or the heap? You actually probably don’t get to know, but as long as you and the borrow checker agree, you don’t really need to, either.</p><p>Lua is interesting. On the one hand, somehow the <code>do</code> and the <code>then</code> and the <code>function</code> spelled all the way out like that give it a certain amount of clunk. On the other hand, if you’re willing to venture into the corners of the language, magic is truly possible. I want to spend the rest of this post describing a use of the Lua API that I’m pretty proud of.</p><p>Lua has very few types; this is to facilitate holding the entire language in your head as much as possible. Here is the full list: <code>nil</code>, <code>boolean</code>, <code>number</code> (integers, interestingly, exist as a bit of an odd subtype), <code>string</code>, <code>table</code>, <code>userdata</code>, “light userdata”, <code>thread</code> (really “coroutine” or “stack”) and <code>function</code>. Light userdata differ from “full” userdata in two ways: from C’s (or Zig’s) perspective, light userdata are just pointers; the object they point to is not in Lua’s universe so is not subject to garbage collection and mostly just sleets through the Lua environment undisturbed; their purpose is largely to enable Lua functions implemented in C to get handles to relevant data from the host environment. That’s one way; the other is that light userdata cannot be operated on—you can ask whether they’re equal (that’s just whether the addresses are equal), but you can’t index into them like you can a table.</p><h2>Userdata and metatables</h2><p>Full userdata, on the other hand, are also “just pointers” from C’s perspective, but the memory they point to is owned by the Lua environment, so is subject to garbage collection. In contrast to light userdata, full userdata may be made to behave more or less in the way that Lua tables do by providing a <em>metatable</em> for them.</p><p>A metatable is what it sounds like. I’m so sorry for writing that, but it’s true; at least in the common sense of “meta” as “referring to its own category”. functionally in Lua, the point of tables is that you can index into them. (They’re an interesting mix between an array and a hash map.) When a table <code>t</code> is missing a key <code>k</code>, but <code>t</code> has a metatable <code>mt</code>, the Lua virtual machine will query <code>mt</code> for its <code>__index</code> metamethod. If <code>__index</code> is a table, what you get will be <code>mt.__index[k]</code>. Otherwise if <code>__index</code> is a function, what you get is the result of <code>mt.__index(t, k)</code>. There is also a <code>__newindex</code> metamethod. Metatables provide other functionality too: for example, if you want to be able to add two tables together, you can do that with an <code>__add</code> metamethod. Or you want to <code>__call</code> a table as if it were a function? That’s allowed!</p><p>The interesting thing about this is that because functions are code, this means you can really go wild. An initial draft of this post intended to go further into this observation. Given that that post stalled out for a month, let me close by offering the following summary of it:</p><p>In my v2.0.0 rewrite of <a href="https://github.com/robbielyman/seamstress">seamstress</a>, an &#34;art engine&#34; and batteries-included Lua runtime, I have a <code>Timer</code> object type. From the perspective of the Zig code that implements it, a <code>Timer</code> is a little struct whose purpose is to sit on the seamstress event loop. From the perspective of Lua, a <code>Timer</code> has several builtin fields, perhaps the most interesting from today&#39;s perspective of which is named <code>running</code>. If <code>t</code> is an object of type <code>seamstress.Timer</code>, altering <code>t.running</code> from <code>true</code> to <code>false</code> executes code (like all code...) with the goal of removing the <code>Timer</code> from the event loop. In a language like Zig I would be aghast at this, since calling several functions as a result of setting a boolean feels like the definition of hidden control flow. Even as a writer of Rust I would probably balk at this. But in Lua? Bring it on.</p></div></div></div>
  </body>
</html>
