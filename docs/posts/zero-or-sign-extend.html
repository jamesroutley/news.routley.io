<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fgiesen.wordpress.com/2024/10/23/zero-or-sign-extend/">Original</a>
    <h1>Zero or Sign Extend</h1>
    
    <div id="readability-page-1" class="page"><div>
								
<p>A while back I had to deal with a bit-packed format that contained a list of integer values encoded in one of a pre-defined sets of bit widths, where both the allowed bit widths and the signed-ness were denoted in a header elsewhere. These values never got particularly long (the largest bit width I needed to support was around 14 bits I think?) but having a mixture of different bit widths and signedness-es (is that a word?) was annoying to deal with, particularly the latter. Signed values were stored in the usual two’s complement format.</p>



<p>In particular, sign-extending narrow types is surprisingly awkward. Most people’s go-to solution seems to be shifting the value up in a wider integer type to move the narrow value’s sign bit into the containing types sign bit, then use an arithmetic shift to repeat the sign bit on the way down. That’s a mouthful. I’m talking about code like this:</p>



<pre><code>int32 sign_extend(int32 val_11b) {
    int32 t = val_11b &lt;&lt; (32 - 11);
    return t &gt;&gt; (32 - 11);
}</code></pre>



<p>In C/C++, this explicitly relies on shifting something into the sign bit, which depending on the exact flavor of language standard you’re using is either not allowed or at best <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2218.htm">fairly recently</a> (voted into C++20) legal. It also explicitly needs to work with a fixed-size integer representation to know what to shift by. That’s not a problem, just not aesthetically pleasing.</p>



<p>There’s a different way to sign-extend that works directly from the definition of two’s complement and doesn’t use any bit-shifting at all, though: all that two’s complement really does is change the place value of the most significant bit. Take our example 11-bit integer, either signed or unsigned. No matter the type, bits 0 through 9 inclusive have place values of 1, 2, 4, .., 512. In an unsigned 11-bit integer, bit 10 has place value 1024; in a signed 11-bit integer, its place value is -1024 instead.</p>



<p>So if we have an unsigned 11-bit value in some integer variable and want to convert it to the corresponding signed 11-bit value (assuming the original value was in two’s complement form), we can do so without any shifting at all. Bits 0-9 retain their interpretation, but the value of bit 10 needs to have its sign flipped to turn unsigned into signed:</p>



<pre><code>int sign_extend(int val_11b) {
    return (val_11b &amp; 0x3ff) - (val &amp; 0x400);
}</code></pre>



<p>We pass through bits 0 through 9, isolate bit 10 using val &amp; 0x400 (which is either 0 if bit 10 wasn’t set or 0x400=1024 if it was), and subtract the result. This form doesn’t make any assumptions about the width of the used integer type or do anything undefined or implementation-specific, as long as the narrower values are small enough to never overflow the containing int type anyway. It doesn’t even assume the compilation target uses two’s complement! (Not that that’s a big ask these days.)</p>



<p>A minor variant is to skip the first mask entirely and think purely in terms of the correction we need to do. In our 11-bit example, if bit 10 was set, it contributes 1024 to the value when it should have contributed -1024, which is off by 2048 (twice the place value of that bit). This leads to a version with a single bit mask:</p>



<pre><code>int sign_extend(int val_11b) {
    return val - (val &amp; 0x400) * 2;
}</code></pre>



<p>Going back to my original problem, I had a mixture of different bit widths and needed to support either signed or unsigned. This can all be done by having two decoding variants, one for signed and one for unsigned, but with the formulation above, it’s really easy to have the same code handle both:</p>



<pre><code>int zero_or_sign_extend(int val, int sign_bit) {
    return val - (val &amp; sign_bit) * 2;
}</code></pre>



<p>We read everything as unsigned initially. When they’re meant to be that way, we pass 0 for <code>sign_bit</code>. For two’s complement signed values, we pass <code>1 &lt;&lt; (bit_width - 1)</code>. In my case this was determined at header decode time and stored along the bit widths. The code that actually interpreted the values used the above and didn’t need to do any explicit tests for whether values were meant to be signed or unsigned anywhere.</p>



<p>It’s not earth-shattering, but it sure is neat!</p>



<p><strong>UPDATE:</strong> even nicer formulation suggested by Harold Aptroot:</p>



<pre><code>int zero_or_sign_extend(int val, int sign_bit) {
    return (val ^ sign_bit) - sign_bit;
}</code></pre>



<p>This one is most easily understood by looking at it case by case. If <code>sign_bit</code> is 0 (unsigned case), both operations do nothing. Otherwise, it gives the mask for an actual sign bit. If that sign bit was originally clear (positive value), the initial XOR effectively adds the value of sign_bit, and then we immediately subtract it again, for a net contribution of 0. If the sign bit started out set, the XOR clears it (effectively subtracting <code>sign_bit</code> from <code>val</code>), and then we explicitly subtract it a second time, exactly like we needed to change the place value of that bit from +sign_bit to -sign_bit.</p>
											</div></div>
  </body>
</html>
