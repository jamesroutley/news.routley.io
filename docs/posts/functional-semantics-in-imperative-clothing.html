<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rtfeldman.com/imperative-clothing">Original</a>
    <h1>Functional semantics in imperative clothing</h1>
    
    <div id="readability-page-1" class="page"><div>
        
        
        <hr/>
        <p>There&#39;s an old joke about programming with pure functions:</p>
        <blockquote>“Eventually you have to do some effects. Otherwise you&#39;re just <span>heating up the CPU.”</span></blockquote>
        <p>
            I&#39;ve always wanted the purely functional
            <a href="https://www.roc-lang.org/">Roc programming language</a> to
            be delightful for I/O-heavy use cases. But when I recently sat down to
            port an I/O-heavy shell script from Bash to Roc, I wasn&#39;t happy with
            how the code felt.
        </p>
        <p>
            Fortunately, all it took was a bit of syntax sugar to change that. Thanks to
            one little operator, purely functional I/O in Roc has now become a real delight!
        </p>
        <h2>From Bash to Roc</h2>
        <p>
            The shell script in question assembles some static assets for the
            <a href="http://roc-lang.org">roc-lang.org</a> website. Here&#39;s part
            of the Bash version of the script:
        </p>
        <pre><samp>cp -r public/ build/


<span>if</span> <span>[</span> -v GITHUB_TOKEN <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span><span>&#39;</span>Fetching latest roc nightly...<span>&#39;</span></span>
    
    curl -fOL https://github.com…
    
    ls <span>|</span> grep <span>&#34;roc_nightly&#34;</span> <span>|</span> xargs tar -xzvf
    
    ls <span>|</span> grep <span>&#34;roc_nightly.*tar.gz&#34;</span> <span>|</span> xargs rm
    roc<span>=</span><span><span>&#39;</span>./roc_nightly/roc<span>&#39;</span></span>
<span>else</span>
    
    cargo build --release
    roc<span>=</span>target/release/roc
<span>fi</span>

<span>$roc</span> --version

<span>echo</span> <span><span>&#39;</span>Building site markdown content<span>&#39;</span></span>

<span>$roc</span> run www/main.roc www/content/ www/build/</samp></pre>
        <p>
            Here&#39;s how this code can now look in Roc, thanks to the new syntax
            sugar that our awesome contributor
            <a href="https://github.com/lukewilliamboswell/">Luke Boswell</a>
            recently implemented: the <code>!</code> suffix.
        </p>
        <pre><samp><span>Dir</span><span>.</span><span>copyAll</span><span>!</span> <span>&#34;public/&#34;</span> <span>&#34;build/&#34;</span>

<span>pathToRoc</span> =
    
    <span>if </span><span>Result</span><span>.</span><span>isOk</span> (<span>Env</span><span>.</span><span>var</span><span>!</span> <span>&#34;GITHUB_TOKEN&#34;</span>) <span>then</span>
        <span>Stdout</span><span>.</span><span>line</span><span>!</span> <span>&#34;Fetching latest roc nightly...&#34;</span>

        
        filename <span>=</span> <span>&#34;nightly.tar.gz&#34;</span>
        <span>Http</span><span>.</span><span>download</span><span>!</span> <span>&#34;https://github.com…&#34;</span> filename
        <span>Cmd</span><span>.</span><span>exec</span><span>!</span> <span>&#34;tar&#34;</span> <span>[</span><span>&#34;-xzvf&#34;</span>, filename<span>]</span>
        
        <span>File</span><span>.</span><span>removeIfExists</span><span>!</span> filename

        <span>&#34;./roc_nightly/roc&#34;</span>
    <span>else</span>
        
        <span>Cmd</span><span>.</span><span>exec</span><span>!</span> <span>&#34;cargo&#34;</span> <span>[</span><span>&#34;build&#34;</span>, <span>&#34;--release&#34;</span><span>]</span>

        <span>&#34;target/release/roc&#34;</span>

<span>roc</span> <span>=</span> <span>\</span>args <span>-&gt;</span> <span>Cmd</span><span>.</span><span>exec</span><span>!</span> pathToRoc args

<span>roc</span><span>!</span> <span>[</span><span>&#34;--version&#34;</span><span>]</span>

<span>Stdout</span><span>.</span><span>line</span><span>!</span> <span>&#34;Building site markdown content&#34;</span>

<span>roc</span><span>!</span> <span>[</span><span>&#34;www/main.roc&#34;</span>, <span>&#34;www/content/&#34;</span>, <span>&#34;www/build/&#34;</span><span>]</span></samp></pre>
        <p>
            I really like how this reads! It looks totally imperative, which is
            a nice fit for a script that&#39;s doing lots of I/O and not much
            else.
        </p>
        <p>
            In fact, it&#39;s so visually similar to the Bash version, you might not
            even guess that the Roc version desugars to a big pile of 100%
            statically type-checked pure functions.
        </p>
        <p>It&#39;s functional semantics in imperative clothing!</p>

        <h2>Desugaring the Sugar</h2>
        <a id="desugaring-the-sugar" aria-label="Permalink: Desugaring the Sugar" href="#desugaring-the-sugar"></a>
        <p>
            To explain how this imperative-looking code can actually be
            compiling down to nothing but pure functions, I need to start by
            explaining how the <code>!</code> suffix works.
        </p>
        <p>
            It&#39;s very similar to the <code>await</code> keyword in other
            languages. For example, this line…
        </p>
        <pre><samp><span>if </span><span>Result</span><span>.</span><span>isOk</span> (<span>Env</span><span>.</span><span>var</span><span>!</span> <span>&#34;GITHUB_TOKEN&#34;</span>) <span>then</span></samp></pre>
        <p>…might look like this in JavaScript:</p>
        <pre><samp><span>if</span> <span>(</span><span>Result</span><span>.</span><span>isOk</span><span>(</span><span>await</span> <span>Env</span><span>.</span><span>var</span><span>(</span><span>&#34;GITHUB_TOKEN&#34;</span><span>)</span><span>)</span><span>)</span> <span>{</span><span></span></samp></pre>
        <p>
            Before we had the <code>!</code> suffix, code like this didn&#39;t look
            nearly as nice. The closest we had was
            <a href="https://web.archive.org/web/20240329162732/https://www.roc-lang.org/tutorial%23backpassing">backpassing</a>, which was unhelpful in nested expressions; this one line would
            probably have been two lines instead:
        </p>
        <pre><samp><span>result</span> <span>&lt;-</span> <span>Env</span><span>.</span><span>var</span> <span>&#34;GITHUB_TOKEN&#34;</span> <span>|&gt;</span> <span>Task</span><span>.</span><span>await</span>

<span>if </span><span>Result</span><span>.</span><span>isOk</span> result <span>then</span></samp></pre>
        <p>
            Even when conditionals weren&#39;t involved, seeing
            <code>&lt;-</code> for some assignments and <code>=</code> for
            others, plus lots of <code>|&gt; Task.await</code>, wasn&#39;t nearly as
            nice as the style we have now.</p>

        <p>It might look like a minor difference
            when comparing one small line to another, but multplied across the
            whole program, the <code>!</code> version of the script felt much
            nicer.
        </p>
        <p>
            So what does the <code>!</code> suffix actually do? It basically
            desugars into two things:
        </p>
        <ol>
            <li>A call to <code>Task<span>.</span>await</code></li>
            <li>
                An anonymous function which gets passed to that
                <code>Task<span>.</span>await</code> call
            </li>
        </ol>
        <p>Let&#39;s walk through an example.</p>
        <pre><samp><span>html</span> <span>=</span> <span>Http</span><span>.</span><span>getUtf8</span><span>!</span> url
<span>path</span> <span>=</span> <span>Path</span><span>.</span><span>fromStr</span> filename
<span>File</span><span>.</span><span>writeUtf8</span><span>!</span> path html
<span>Stdout</span><span>.</span><span>line</span><span>!</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>This desugars to the following Roc code.</p>
        <pre><samp><span>Task</span><span>.</span><span>await</span> (<span>Http</span><span>.</span><span>getUtf8</span> url) <span>\</span>html <span>-&gt;</span>
    path <span>=</span> <span>Path</span><span>.</span><span>fromStr</span> filename
    <span>Task</span><span>.</span><span>await</span> (<span>File</span><span>.</span><span>writeUtf8</span> path html) <span>\</span>_ <span>-&gt;</span>
    <span>Stdout</span><span>.</span><span>line</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>
            If you wanted to, you could have written the code this way and it
            would have compiled to exactly the same program<span>!</span> Going line by line:
        </p>
        <pre><samp><span>html</span> <span>=</span> <span>Http</span><span>.</span><span>getUtf8</span><span>!</span> url</samp></pre>
        <p>…becomes:</p>
        <pre><samp><span>Task</span><span>.</span><span>await</span> (<span>Http</span><span>.</span><span>getUtf8</span> url) <span>\</span>html <span>-&gt;</span></samp></pre>
        <p>
            The <code>Task<span>.</span>await</code> function plays a similar role as the
            <code>await</code> keyword in other languages: it says &#34;wait until
            this <code>Task</code> successfully completes, then pass its output
            to a function.&#34; (A <code>Task</code> in Roc is a value that
            represents an asynchronous effect; the
            <code>Http<span>.</span>getUtf8</code> function returns a <code>Task</code>.)
        </p>
        <p>
            Tasks can be chained together using the
            <code>Task<span>.</span>await</code> function, similarly to how JavaScript
            Promises can be chained together using a Promise&#39;s
            <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>then()</code> method</a>. (You might also know functions in other languages similar to
            <code>Task<span>.</span>await</code> which go by names like <code>andThen</code>,
            <code>flatMap</code>, or <code>bind</code>.)
        </p>
        <p>
            The next line in our example was
            <code>path <span>=</span> Path<span>.</span>fromStr filename</code>, but that line was
            unchanged since it didn&#39;t use <code>!</code> at all. The next
            <code>!</code> was in this line:
        </p>
        <pre><samp><span>File</span><span>.</span><span>writeUtf8</span><span>!</span> path html</samp></pre>
        <p>It desugars to:</p>
        <pre><samp><span>Task</span><span>.</span><span>await</span> (<span>File</span><span>.</span><span>writeUtf8</span> path html) <span>\</span>_ <span>-&gt;</span></samp></pre>
        <p>
            Notice that here, since we didn&#39;t have <code>html <span>=</span></code> at the
            start (because we don&#39;t care about the output of a file write), we
            also didn&#39;t have the named argument <code><span>\</span>html <span>-&gt;</span></code> in the
            function being passed to <code>Task<span>.</span>await</code>. Instead we had
            <code><span>\</span>_ <span>-&gt;</span></code>, which is how in Roc we write a function that
            ignores its argument.
        </p>
        <p>
            It&#39;s worth noting that both <code>Http<span>.</span>getUtf8</code> and
            <code>File<span>.</span>writeUtf8</code> are operations that can fail. If they
            do, the whole chain of tasks will short-circuit to some
            error-handling code. That&#39;s part of what <code>Task<span>.</span>await</code> has
            always done, and the <code>!</code> sugar doesn&#39;t affect error
            handling at all.
        </p>
        <p>Finally, we had:</p>
        <pre><samp><span>Stdout</span><span>.</span><span>line</span><span>!</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>This desugars to:</p>
        <pre><samp><span>Stdout</span><span>.</span><span>line</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>
            Since this is the last task in a chain, the <span>!</span> doesn&#39;t do anything
            and isn&#39;t necessary…so we just drop it during desugaring instead of
            giving a compiler error or generating an unnecessary Task.await.
            This allows for a more consistent visual style, where async I/O
            operations always end in the <code>!</code> suffix, but doesn&#39;t have
            any runtime cost.
        </p>

        <h2>I/O from Pure Functions</h2>
        <a id="io-from-pure-functions" aria-label="Permalink: I/O From Pure Functions" href="#io-from-pure-functions"></a>
        <p>
            Earlier I said that this style of Roc code &#34;desugars to a big pile
            of 100% statically type-checked pure functions.&#34;
        </p>
        <p>
            The 100% statically type-checked part is easy to explain: Roc has
            full type inference, so your types always get checked, but you never
            need to write type annotations. You can optionally add annotations
            anywhere you think they&#39;ll be helpful, but for this shell script I
            didn&#39;t think they&#39;d be worth including. (For Roc programs that
            aren&#39;t shell scripts, the common practice is to annotate all
            top-level functions and that&#39;s usually about it.)
        </p>
        <p>
            What about the &#34;all pure functions&#34; part? By definition, pure
            functions don&#39;t have side effects, right? (A
            <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effect</a>
            is when a function changes some state outside the function itself,
            like a global variable or the file system.) So…how can these
            functions be pure if all this I/O is happening?
        </p>
        <p>It&#39;s surprisingly simple:</p>
        <ol>
            <li>
                Each function returns a value describing what I/O it wants done.
            </li>
            <li>
                The compiled program has a runtime which looks at those values
                and actually performs the I/O they describe.
            </li>
        </ol>
        <p>
            There are practical benefits to separating things this way (more on
            those later), but to illustrate what&#39;s happening behind the scenes
            here, let&#39;s go back to that example from earlier:
        </p>
        <pre><samp><span>html</span> <span>=</span> <span>Http</span><span>.</span><span>getUtf8</span><span>!</span> url
<span>path</span> <span>=</span> <span>Path</span><span>.</span><span>fromStr</span> filename
<span>File</span><span>.</span><span>writeUtf8</span><span>!</span> path html
<span>Stdout</span><span>.</span><span>line</span><span>!</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>We already went through how that code desugars to this code:</p>
        <pre><samp><span>Task</span><span>.</span><span>await</span> (<span>Http</span><span>.</span><span>getUtf8</span> url) <span>\</span>html <span>-&gt;</span>
<span>path</span> <span>=</span> <span>Path</span><span>.</span><span>fromStr</span> filename
<span>Task</span><span>.</span><span>await</span> (<span>File</span><span>.</span><span>writeUtf8</span> path html) <span>\</span>_ <span>-&gt;</span>
<span>Stdout</span><span>.</span><span>line</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>
            This code in turn compiles down to something which looks similar to
            the following at runtime. (I&#39;m using JavaScript syntax here rather
            than Roc, which will be convenient in the next example.)
        </p>
        <pre><samp><span>{</span>
  <span>operation</span>: <span>&#34;Http.getUtf8&#34;</span><span>,</span>
  <span>args</span>: <span>[</span><span>url</span><span>]</span><span>,</span>
  <span>afterwards</span>: <span>(</span><span>html</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>path</span> <span>=</span> <span>Path</span><span>.</span><span>fromStr</span><span>(</span><span>filename</span><span>)</span>

    <span>return</span> <span>{</span>
      <span>operation</span>: <span>&#34;File.writeUtf8&#34;</span><span>,</span>
      <span>args</span>: <span>[</span><span>path</span><span>,</span> <span>html</span><span>]</span><span>,</span>
      <span>afterwards</span>: <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
        <span>operation</span>: <span>&#34;Stdout.line&#34;</span><span>,</span>
        <span>args</span>: <span>[</span><span>`Wrote HTML to </span><span>${</span>filename<span>}</span><span>`</span><span>]</span><span>,</span>
        <span>afterwards</span>: <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span> <span>operation</span>: <span>&#34;done&#34;</span> <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span></samp></pre>
        <p>
            Nothing but nested object literals where one field is a function
            that returns another object literal. No side effects anywhere<span>!</span> (This
            structure isn&#39;t exactly how Roc represents <code>Task</code> values
            in memory—the operation isn&#39;t a string, for example—but let&#39;s go
            with it for simplicity&#39;s sake.)
        </p>

        <h2>Implementing a Runtime</h2>
        <a id="implementing-a-runtime" aria-label="Permalink: Implementing a Runtime" href="#implementing-a-runtime"></a>
        <p>
            Now let&#39;s look at how a runtime can translate those nested object
            literals into <span>I/O.</span>
        </p>
        <p>
            In <a href="https://nodejs.org">Node.js</a> I could do this by
            writing a loop which:
        </p>
        <ul>
            <li>Starts with one of these &#34;Task&#34; values to run</li>
            <li>
                Looks at the task&#39;s operation field and performs the requested
                I/O operation
            </li>
            <li>
                Calls the function in the task&#39;s afterwards field, passing the
                output of that I/O operation. (This function will return another
                Task value.)
            </li>
            <li>
                Loops back to the start to repeat this process until we
                encounter a Task whose operation field is &#34;done&#34;, which tells us
                we&#39;re done.
            </li>
        </ul>
        <p>Here&#39;s how that would look in code:</p>
        <pre><samp><span>while</span> <span>task</span><span>.</span><span>operation</span> <span>!=</span> <span>&#34;done&#34;</span> <span>{</span>
  <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;Http.getUtf8&#34;</span> <span>{</span>
    <span>const</span> <span>[</span><span>url</span><span>]</span> <span>=</span> <span>task</span><span>.</span><span>args</span>
    <span>const</span> <span>response</span> <span>=</span> <span>httpRequest</span><span>(</span><span>url</span><span>)</span>

    <span>task</span> <span>=</span> <span>task</span><span>.</span><span>afterwards</span><span>(</span><span>response</span><span>.</span><span>text</span><span>(</span><span>)</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;File.writeUtf8&#34;</span> <span>{</span>
    <span>const</span> <span>[</span><span>path</span><span>,</span> <span>content</span><span>]</span> <span>=</span> <span>task</span><span>.</span><span>args</span>
    <span>fs</span><span>.</span><span>writeFileSync</span><span>(</span><span>path</span><span>,</span> <span>content</span><span>)</span>

    <span>task</span> <span>=</span> <span>task</span><span>.</span><span>afterwards</span><span>(</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;Stdout.line&#34;</span> <span>{</span>
    <span>const</span> <span>[</span><span>line</span><span>]</span> <span>=</span> <span>task</span><span>.</span><span>args</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>line</span><span>)</span>

    <span>task</span> <span>=</span> <span>task</span><span>.</span><span>afterwards</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span></samp></pre>
        <p>
            Although this would work, Node encourages doing asynchronous I/O
            instead of synchronous like we&#39;ve done here.
        </p>
        <p>
            Fortunately, one of the benefits of representing effects as values
            that hold &#34;afterwards&#34;
            <a href="https://en.wikipedia.org/wiki/Continuation">continuation</a>
            functions like this is that the Task value can also be translated
            into async I/O. Here&#39;s the same Node code done in an asynchronous
            callback style instead—and using recursion instead of a while loop.
        </p>
        <pre><samp><span>const</span> <span>interpretTask</span> <span>=</span> <span>(</span><span>task</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;Http.getUtf8&#34;</span> <span>{</span>
    <span>const</span> <span>[</span><span>url</span><span>]</span> <span>=</span> <span>task</span><span>.</span><span>args</span>

    <span>fetch</span><span>(</span><span>url</span><span>,</span> <span>(</span><span>response</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>const</span> <span>text</span> <span>=</span> <span>response</span><span>.</span><span>text</span><span>(</span><span>)</span>

      <span>const</span> <span>nextTask</span> <span>=</span> <span>task</span><span>.</span><span>afterwards</span><span>(</span><span>text</span><span>)</span>
      <span>return</span> <span>interpretTask</span><span>(</span><span>nextTask</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;File.writeUtf8&#34;</span><span></span> <span>{</span>
    <span>const</span> <span>[</span><span>path</span><span>,</span> <span>content</span><span>]</span> <span>=</span> <span>task</span><span>.</span><span>args</span>

    <span>fs</span><span>.</span><span>writeFile</span><span>(</span><span>path</span><span>,</span> <span>content</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>const</span> <span>nextTask</span> <span>=</span> <span>task</span><span>.</span><span>afterwards</span><span>(</span><span>)</span>
      <span>return</span> <span>interpretTask</span><span>(</span><span>nextTask</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;Stdout.line&#34;</span> <span>{</span>
    <span>const</span> <span>[</span><span>line</span><span>]</span> <span>=</span> <span>task</span><span>.</span><span>args</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>line</span><span>)</span>

    <span>const</span> <span>nextTask</span> <span>=</span> <span>task</span><span>.</span><span>afterwards</span><span>(</span><span>)</span>
    <span>return</span> <span>interpretTask</span><span>(</span><span>nextTask</span><span>)</span>

    <span>}</span> <span>else</span> <span>if</span> <span>task</span><span>.</span><span>operation</span> <span>==</span> <span>&#34;done&#34;</span><span></span> <span>{</span>
      
   <span>}</span>
  <span>}</span></samp></pre>
        <p>
            The actual I/O can be implemented in any number of styles. Promises,
            for example. Or async/await. Outside of JavaScript, it could be done
            with high-performance low-level async I/O operating system
            primitives like
            <a href="https://en.wikipedia.org/wiki/Io_uring">io_uring</a> in C,
            Zig, or Rust—including inside async runtimes like
            <a href="https://tokio.rs/">Tokio</a>.
        </p>
        <p>
            Separating these I/O descriptions from the runtime that performs the
            actual I/O lets you drop in whatever async I/O runtime system you
            want, without having to change your application code at all!
        </p>
        <p>
            In fact, one of the main motivations for representing effects as
            values like this is so that future
            <a href="https://www.roc-lang.org/platforms">Roc platforms</a> can
            do all this &#34;traversing the data structure&#34; work behind the scenes
            to quietly give you excellent async I/O performance that&#39;s
            potentially even tailored to a particular domain (e.g. web servers,
            CLIs, games), while your application code gets to look as
            straightforward as it would in any imperative language:
        </p>
        <pre><samp><span>html</span> <span>=</span> <span>Http</span><span>.</span><span>getUtf8</span><span>!</span> url
<span>path</span> <span>=</span> <span>Path</span><span>.</span><span>fromStr</span> filename
<span>File</span><span>.</span><span>writeUtf8</span><span>!</span> path html
<span>Stdout</span><span>.</span><span>line</span><span>!</span> <span>&#34;Wrote HTML to: </span><span>$(</span>filename<span>)</span><span>&#34;</span></samp></pre>
        <p>
            Platform authors can also use this representation to offer features
            like &#34;dry-run mode&#34; in which all the requests for disk I/O are
            performed on a fake in-memory filesystem (perhaps using the current
            state of the real filesystem for its initial structure) so that
            scripts can be tried out without their &#34;I/O operations&#34; affecting
            the actual disk. Or automatic logging of all I/O operations, with
            the application code specifying the logging system to use. The list
            goes on!
        </p>
        <p>
            Besides platforms being able to apply different I/O runtimes to the
            same application, the functional semantics underneath the sugar have
            benefits for application authors too. For example, they unlock nicer
            testability.
        </p>

        <h2>Testability</h2>
        <a id="testability" aria-label="Permalink: Testability" href="#testability"></a>
        <p>
            We&#39;ve seen how individual functions can be pure while resulting in
            an overall program that does I/O. But at the end of the day, if the
            code is just resulting in the I/O being performed anyway, what could
            possibly make it easier to test?
        </p>
        <p>
            The key is that we can run a test on the value being returned,
            instead of handing it off to the runtime. That means no actual I/O
            gets performed, and the test is completely deterministic—yet all of
            the actual logic around the I/O can be tested!
        </p>
        <p>For example, here&#39;s a test I can write using only Task values:</p>
        <pre><samp><span>expect </span>task<span>.</span><span>operation</span> <span>==</span> <span>&#34;Http.getUtf8&#34;</span>
<span>expect </span>task<span>.</span><span>args</span> <span>==</span> <span>[</span><span>&#34;example.com/something&#34;</span><span>]</span>

<span>fakeResponse</span> <span>=</span> <span>&#34;&lt;html&gt;&lt;body&gt;testing!&lt;/body&gt;&lt;/html&gt;&#34;</span>
<span>next</span> <span>=</span> task<span>.</span><span>afterwards</span> <span>[</span>fakeResponse<span>]</span>

<span>expect </span>next<span>.</span><span>operation</span> <span>==</span> <span>&#34;writeUtf8&#34;</span>
<span>expect </span>answer<span>.</span><span>args</span> <span>==</span> <span>[</span>filename, fakeResponse<span>]</span></samp></pre>
        <p>
            This test will run extremely quickly, and it will never flake. All
            it does is look at values!
        </p>
        <p>
            I could also write a property test to randomly run this a bunch of
            times with random inputs and verify that (for example) no matter
            what lines are in the files, the output has commas there instead. I
            could simulate that a third-party server I have no control over is
            timing out, or returning 500 errors, and verify that my application
            is handling that correctly…all without actually contacting that
            server!
        </p>
        <p>
            (By the way, you can already write tests in Roc using the built-in
            expect keyword and the roc test CLI command, although writing
            simulation-style tests of Tasks relies on a language feature that
            hasn&#39;t been fully implemented yet. I plan to write about that after
            it ships!)
        </p>
        <p>
            Of course, many programming languages have ways to test logic
            without actually running I/O, such as
            <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>, mocking, and so on. What I like about this &#34;simulation&#34; style is
            that I don&#39;t have to guess which APIs need to be monkey patched, I
            don&#39;t have to make my implementation more generic than I want it to
            be (just so I can swap in
            <a href="https://en.wikipedia.org/wiki/Test_double">doubles</a> for
            testing), and the simulation works just fine even if third-party
            packages are involved in assembling the Task values.
        </p>
        <p>
            To be fair, any language can benefit from representing effects as
            values without going as far as to make all functions in the language
            pure, but there are
            <a href="https://youtu.be/3n17wHe5wEw">separate practical benefits to having all functions be pure</a>. Some of the other benefits take longer to explain than
            testability, so I&#39;ll stick to just that one example in this
            article…but I&#39;d like to write more about some of the others in the
            future!
        </p>

        <h2>Trying Out Roc</h2>
        <a id="trying-out-roc" aria-label="Permalink: Trying Out Roc" href="#trying-out-roc"></a>
        <p>
            If you&#39;re intrigued by this &#34;functional semantics in imperative
            clothing&#34; idea and want to give
            <a href="https://www.roc-lang.org/">Roc</a> a try for yourself, the
            <a href="https://www.roc-lang.org/tutorial">tutorial</a> is the
            easiest way to get up and running. It takes you from no Roc
            experience whatsoever to building your first program, while
            explaining language concepts along the way.
        </p>
        <p>
            I also highly recommend dropping in to say hi on
            <a href="https://roc.zulipchat.com/">Roc Zulip Chat</a>. There are
            lots of friendly people on there, and we love to help beginners get
            started with the language!
        </p>
        <p>
            Finally, if you&#39;d like to meet up with a bunch of Roc enthusiasts in
            person, there will be 3 different Roc talks at
            <a href="https://sycl.it/">Software You Can Love 2024</a> in Milan
            this May, and we expect it to be the largest in-person gathering of
            Roc programmers to date. It&#39;s going to be amazing!
        </p>
        </div></div>
  </body>
</html>
