<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/899543/">Original</a>
    <h1>The trouble with symbolic links</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Did you know...?</b><p>LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a href="https://lwn.net/subscribe/">buying a subscription</a> and keeping LWN on the
       net.</p></div>
           </center>
           
<p>At the <a href="https://sambaxp.org/archive">2022 sambaXP conference</a>,
Jeremy Allison gave a talk titled &#34;The UNIX Filesystem API is
profoundly broken: What to do about it?&#34;. LWN regulars may recall hints of
these talks in a recent <a href="https://lwn.net/Articles/882177/">comment
thread</a>.  He started his talk with the problems that symbolic links
(&#34;symlinks&#34;)
cause for application developers, then discussed how the solutions to
the problems posed by symlinks led to substantial increases in the
complexity of the APIs involved in working with pathnames.</p>

<p>Allison explained that hard links were the first &#34;interesting addition&#34;
to the original Unix filesystem API; unlike symlinks, though, they are not
dangerous, and are, in fact, easy to use.  A hard link is simply the connection between
a directory entry and the inode for the file (or directory) to which that
entry refers.  Unix systems allow multiple links to any file, but require
that the inode and directory entries all reside on the same filesystem.
</p><p>
By contrast, symlinks contain another path as data, and
the kernel transparently operates on the file at that path when system calls
like <a href="https://man7.org/linux/man-pages/man2/open.2.html"><tt>open()</tt></a>
or <a href="https://man7.org/linux/man-pages/man2/lchown.2.html"><tt>chown()</tt></a>
are called on the symlink.  This
seemingly innocuous feature led to the addition of incredible amounts of
complexity in the effort to fulfill the needs of programs that need to be
aware of whether a pathname contains a symlink or not.  Such programs
include archival programs like <tt>tar</tt>, file synchronization and transfer
programs such as <tt>rsync</tt>, network filesystem servers like Samba, and
many more that suffer security 
problems as a result of not giving sufficient attention to symlinks in
pathnames.</p>

<p>The variety of security problems resulting from symlinks can be seen in a <a href="https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=symbolic+link">search
of
CVE entries</a>, which gave Allison 1,361 results when he ran it.  These include
vulnerabilities that facilitate information disclosure, privilege
escalation, and arbitrary file manipulation including deletion, among other
attacks.  Without discussing any specific CVE in detail, he gave an
example of the kind of security problem that can result from
symlink-related vulnerabilities.</p>

<p>An application running as root may try to check that
<tt>/data/mydir</tt> is a regular directory (not a symlink) before opening
the file <tt>/data/mydir/passwd</tt>.  In between the
time the program does the directory check and the file open, an attacker
could replace the <tt>mydir</tt> directory with a symlink to <tt>/etc</tt>,
and now the file opened is, unexpectedly, <tt>/etc/passwd</tt>.  This is a
kind of race condition known as a <a href="https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use">time-of-check-to-time-of-use
(TOCTOU)</a>
race.</p>

<h4>Symlinks and complexity</h4>
<p>Symlinks were created, Allison theorized, because hard links are
restricted to linking within the same filesystem, so only symlinks (which
lack that restriction) could be
used if an administrator wanted to add new storage media without changing
the paths to users&#39; data.  He quoted an advertisement for 4.2BSD,
which touted, &#34;This feature frees the user of the constraints of the strict
hierarchy that a tree structure imposes. This flexibility is essential for
good namespace management.&#34;</p>

<p>The addition of symlinks led to the <tt><a href="https://man7.org/linux/man-pages/man2/lstat.2.html">lstat()</a></tt>
system call, which provided the means to identify whether the last
component in a pathname is a symlink.  This was, unfortunately,
insufficient for handling symlinks pointing to directories earlier in the
path, he explained.  An application could attempt to check each component
of the path individually, but not atomically — another application
could make a change to one of the components during this process, leading
to security vulnerabilities.</p>

<p>An option to the <tt>open()</tt> system call, <tt>O_NOFOLLOW</tt>, exhibits
the same problem as <tt>lstat()</tt>.   <tt>O_NOFOLLOW</tt> instructs the
system call to fail with <tt>ELOOP</tt> if the last component in the
pathname is a symbolic link, but it <i>only</i> checks the last component.  The
<a href="https://man7.org/linux/man-pages/man3/realpath.3.html"><tt>realpath()</tt></a>
C library function follows symlinks in a path and produces 
an absolute, canonical pathname that the application can then compare with
the original.  Allison described this as an appealing but incorrect
solution to the problem.  Another process could make a change in between
the time <tt>realpath()</tt> is called and another function is used to
manipulate the file in some fashion.  In other words, the same TOCTOU race
applies here.

</p><p>Allison said that the <tt>openat()</tt> system call was designed as a
solution to this problem; it introduces the idea of referring to files with respect
to a directory that&#39;s indicated by an already-open file descriptor.  The
only reliable way to identify a file&#39;s path is to walk the hierarchy using
multiple calls to <tt>openat()</tt>.  Everything else would be vulnerable
to race conditions.</p>

<p>But Allison also pointed out the flaw in this technique. &#34;You cannot
create a new directory with <tt>open()</tt>, you cannot remove a file, unlink a
file, or delete a directory with an <tt>open()</tt> call.&#34;  So, more functions
following the pattern of <tt>openat()</tt> had to be created:
<a href="https://man7.org/linux/man-pages/man2/mkdir.2.html"><tt>mkdirat()</tt></a>,
<a href="https://man7.org/linux/man-pages/man2/link.2.html"><tt>linkat()</tt></a>,
<a href="https://man7.org/linux/man-pages/man2/unlink.2.html"><tt>unlinkat()</tt></a>,
<a href="https://man7.org/linux/man-pages/man2/rename.2.html"><tt>renameat()</tt></a>,
and more.  Some are still missing, like
<tt>getxattrat()</tt> and <tt>setxattrat()</tt>.  Some, like
<a href="https://man7.org/linux/man-pages/man2/lchown.2.html"><tt>fchownat()</tt></a>
and <a href="https://man7.org/linux/man-pages/man2/access.2.html"><tt>faccessat()</tt></a>, 
don&#39;t follow the pattern cleanly.

</p><p>Allison didn&#39;t mince words: &#34;So our original clean and beautiful POSIX
filesystem API doesn’t look very clean and beautiful anymore...pathnames as
a concept are now utterly broken in POSIX.&#34;  One could reasonably
attribute, in part at least,
any perceived bitterness to Allison&#39;s struggles with the <a href="https://lwn.net/Articles/884052/">long road 
to a fix for CVE-2021-20316</a> in Samba.</p>

<p>
Because of the talk&#39;s focus on the role of symlinks in complicating the
Unix pathname API, Allison did not directly raise the point that race
conditions involving pathnames can occur even without symlinks.
It seems a major source of complexity is the lack of a mechanism for
atomically batching together operations that involve walking directories
and symlinks to eventually perform some operation on a file.</p>

<h4>Workarounds</h4>
<p>Allison then explained the use of the <tt>O_PATH</tt> flag to
<tt>open()</tt>, which will return a file descriptor that is only useful
for passing to the <tt>*at()</tt> system calls as the <tt>dirfd</tt>
argument.  Unfortunately for Samba, file descriptors opened with
<tt>O_PATH</tt> cannot be used for reading
or writing extended attributes.  He found a workaround, demonstrated by a snippet
of code that he described as &#34;one of the most beautiful hacks I’ve ever
seen, it’s so ugly it makes you want to vomit, but it’s amazing.&#34;</p>

<pre>    int fd = openat(dirfd, &#34;file&#34;, O_PATH|O_NOFOLLOW);
    sprintf(buf, &#34;/proc/self/fd/%d&#34;, fd);
    getxattr(buf, ea_name, value, size);
</pre>

<p>The contents of <tt>/proc/self/fd</tt> are symlinks that represent every
file descriptor the process has open.  Allison explained the code: &#34;If you
print into a buffer &#39;<tt>/proc/self/fd/</tt>&#39; and then the number of the
descriptor you just got back from O_PATH, you can then pass it to
<tt>getxattr()</tt> or <tt>setxattr()</tt> as a path, and it can’t be
symlink-raced.&#34; He wasn&#39;t sure
whether to attribute this code to Android or Red Hat developers, but a
similar use of <tt>/proc/self/fd/</tt> can be found in the <tt>open()</tt>
man page.

</p><p>Allison reiterated the main point of his talk: &#34;The concept of
pathnames is unusable on POSIX, completely. For a non-trivial application,
for a regular person writing code on POSIX, you will have symlink races in
your code.&#34;</p>

<p>Examples of (since fixed) CVEs were then provided, including one in the
<a href="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html">Rust
standard library</a>, which was <a href="https://lwn.net/Articles/882070/">discussed
extensively</a> here.  In the last few minutes of the talk, Allison
noted several proposed solutions offered by LWN readers, including <a href="https://lwn.net/Articles/882216/">a special <tt>prctl()</tt> call</a> and <a href="https://lwn.net/Articles/884413/">restrictions on when non-root
symlinks are followed</a>.  He said that the <a href="https://lwn.net/Articles/882487/"><tt>MOUNT_NOSYMFOLLOW</tt> mount
option</a>, which simply forbids following symlinks within a filesystem, is
his preferred solution: &#34;It’s perfect. It does exactly what we need.&#34;
Allison&#39;s talk concluded on that point.</p>

<p>While it certainly seems desirable to forbid symlinks in the name of
cleaning up the POSIX API, they are a frequently used system-administration tool.
Several popular &#34;symlink managers&#34; exist.  <a href="https://www.gnu.org/software/stow/">Gnu Stow</a>, for example,
provides a way for
administrators to install programs into a new directory hierarchy, such as
<tt>/usr/local/stow/packagename-version/</tt>, and then create forests of
symlinks from <tt>/usr/local/bin/example</tt> to
<tt>/usr/local/stow/packagename-version/bin/example</tt>, using the minimum
number of symlinks necessary.  This makes it possible to &#34;uninstall&#34; a
package simply by removing the symlinks with the help of <tt>stow -D</tt>.
</p><p>
The <tt>/etc/alternatives</tt> system created by Debian allows
administrators to switch between substitutable packages in a similar
manner without forcing the uninstallation or reinstallation of either
package. In a similar vein, the <a href="https://nixos.org/">Nix</a> and <a href="https://guix.gnu.org/">Guix</a> distributions make heavy use of
symlinks — a Guix profile consists of a tree of symlinks to packages
installed within <tt>/gnu/store/</tt>, making it easy to switch between
grouped combinations of specific versions of packages.</p>

<p>Banning symlinks entirely would break these use cases, but restricting
their creation to the root user would most likely suffice.  Users may still have
other legitimate needs for symlinks, though, and substantially restricting
them would likely be an unpopular change.</p>

<p>SambaXP has made the talk&#39;s <a href="https://www.youtube.com/watch?v=4JrY-DntoyU">video</a> and <a href="https://sambaxp.org/fileadmin/user_upload/sambaxp2022-Slides/Allison-Symlinks_considered_harmful.pdf">slides</a>
available.</p></div></div>
  </body>
</html>
