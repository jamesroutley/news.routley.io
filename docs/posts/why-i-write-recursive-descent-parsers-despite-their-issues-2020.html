<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/WhyRDParsersForMe">Original</a>
    <h1>Why I write recursive descent parsers, despite their issues (2020)</h1>
    
    <div id="readability-page-1" class="page"><div><h2>Why I write recursive descent parsers (despite their issues)</h2>

	<p><small>September 16, 2020</small></p>
</div><div><p>Today I read Laurence Tratt&#39;s <a href="https://tratt.net/laurie/blog/entries/which_parsing_approach.html">Which Parsing Approach?</a> (<a href="https://lobste.rs/s/9pcqys/which_parsing_approach">via</a>), which has a
decent overview of how parsing computer languages (including little
domain specific languages) is not quite the well solved problem
we&#39;d like it to be. As part of the article, Tratt discusses how
<a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parsers</a> have a
number of issues in practice and recommends using other things,
such as a LR parser generator.</p>

<p>I have a long standing interest in parsing, I&#39;m reasonably well
aware of the annoyances of recursive descent parsers (although some
of the issues Tratt raised hadn&#39;t occurred to me before now), and
I&#39;ve been exposed to parser generators like Yacc. Despite that, my
normal approach to parsing any new little language for real is to
write a recursive descent parser in whatever language I&#39;m using,
and Tratt&#39;s article is not going to change that. My choice here is
for entirely pragmatic reasons, because to me recursive descent
parsers generally have two significant advantages over all other
real parsers.</p>

<p>The first advantage is that almost always, a recursive descent parser
is the only or at least easiest form of parser you can readily create
using only the language&#39;s standard library and tooling. In particular,
parsing LR, LALR, and similar formal grammars generally requires you to
find, select, and install a parser generator tool (or more rarely, an
additional package). Very few languages ship their standard environment
with a parser generator (or a lexer, which is often required in some
form by the parser).</p>

<p>(The closest I know of is C on Unix, where you will almost always
find some version of lex and yacc. Not entirely coincidentally,
I&#39;ve used lex and yacc to write a parser in C, although a long time
ago.)</p>

<p>By contrast, a recursive descent parser is just code in the language.
You can obviously write that in any language, and you can build a
little lexer to go along with it that&#39;s custom fitted to your
particular recursive descent parser and your language&#39;s needs.  This
also leads to the second significant advantage, which is that if
you write a recursive descent parser, you don&#39;t need to learn a new
language, the language of the parser generator, and also learn how
to hook that new language to the language of your program, and then
debug the result. Your entire recursive descent parser (and your
entire lexer) are written in one language, the language you&#39;re
already working in.</p>

<p>If I was routinely working in a language that had a well respected
de facto standard parser generator and lexer, and regularly building
parsers for little languages for my programs, it would probably be
worth mastering these tools. The time and effort required to do so
would be more than paid back in the end, and I would probably have
a higher quality grammar too (Tratt points out how recursive descent
parsers hide ambiguity, for example). But in practice I bounce back
and forth between two languages right now (Go and Python, neither
of which have such a standard parser ecology), and I don&#39;t need to
write even a half-baked parser all that often. So writing another
recursive descent parser using my standard process for this has
been the easiest way to do it every time I needed one.</p>

<p>(I&#39;ve developed a standard process for writing recursive descent
parsers that makes the whole thing pretty mechanical, but that&#39;s a
discussion for another entry or really a series of them.)</p>

<p>PS: I can&#39;t comment about how easy it is to generate good error
messages in modern parser generators, because I haven&#39;t used any
of them. My experience with my own recursive descent parsers is
that it&#39;s generally straightforward to get decent error messages
for the style of languages that I create, and usually simple to
tweak the result to give clearer errors in some specific situations
(<a href="https://github.com/siebenmann/sinksmtp/blob/master/rparse.go#L432">eg</a>,
<a href="https://github.com/siebenmann/sinksmtp/blob/master/rparse.go#L575">also</a>).</p>
</div></div>
  </body>
</html>
