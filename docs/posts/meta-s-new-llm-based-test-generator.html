<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://read.engineerscodex.com/p/metas-new-llm-based-test-generator">Original</a>
    <h1>Meta&#39;s new LLM-based test generator</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p><em>Engineer‚Äôs Codex is a publication about real-world software engineering.</em></p><p><span>Meta recently released a </span><a href="https://arxiv.org/abs/2402.09171" rel="">paper called ‚ÄúAutomated Unit Test Improvement using Large Language Models at Meta‚Äù</a><span>. It‚Äôs a good look at how Big Tech is using AI internally to make development faster and software less buggy. For example, </span><a href="https://read.engineerscodex.com/i/139414745/critique-googles-code-review-tool" rel="">Google is using AI to speed up code reviews</a><span>.</span></p><p><span>A major win of this paper is that while it integrates LLMs into a developer‚Äôs workflow, it also recommends fully-formed software improvements that are verified to be both correct and an improvement to current code coverage. Compare this to GitHub Copilot, where suggestions still have to be manually verified to work by the human - and we all know that </span><a href="https://read.engineerscodex.com/p/clever-code-is-probably-the-worst" rel="">debugging code is twice as hard as writing it</a><span>.</span></p><p>Meta claims that this ‚Äúthis is the first paper to report on LLM-generated code that has been developed independent of human intervention (other than final review sign off), and landed into large scale industrial production systems with guaranteed assurances for improvement over the existing code base.‚Äù</p><p>Furthermore, there are solid principles that developers can take away in order to use AI effectively themselves.</p><p><strong>Table of Contents (total read time: 7 minutes):</strong></p><ul><li><p>Key Points (1 minute read)</p></li><li><p>Stats (1 minute read)</p></li><li><p><span>Actionable Takeaways </span><strong>‚Üê</strong><span> </span><strong>if you‚Äôre short on time, just read this!</strong><span> (3 minute read)</span></p></li><li><p>How TestGen-LLM Works (2 minute read)</p></li></ul><p><em><a href="http://swequiz.com" rel="">SWE Quiz</a><span> is for ambitious developers who want to make sure their software fundamentals are rock solid. Reveal gaps in your knowledge and make sure you really know what you‚Äôre doing both at work and while interviewing.</span></em></p><p><em><span>Take the tests for </span><a href="https://www.swequiz.com/learn/authentication-roadmap" rel="">authentication</a><span>, </span><a href="https://swequiz.com/learn/caching-roadmap" rel="">caching</a><span>, </span><a href="https://www.swequiz.com/learn/databases-roadmap" rel="">databases</a><span>, </span><a href="https://www.swequiz.com/learn/api-design-roadmap" rel="">API Design</a><span>, and </span><a href="https://www.swequiz.com/learn" rel="">more</a><span>.</span></em></p><p data-attrs="{&#34;url&#34;:&#34;https://swequiz.com&#34;,&#34;text&#34;:&#34;Check out SWE Quiz&#34;,&#34;action&#34;:null,&#34;class&#34;:null}" data-component-name="ButtonCreateButton"><a href="https://swequiz.com" rel=""><span>Check out SWE Quiz</span></a></p><p><span>TestGen-LLM uses an approach called ‚ÄòAssured LLM-based Software Engineering‚Äô (Assured LLMSE), using private, internal LLMs that are probably fine-tuned with Meta‚Äôs codebase. This means that it uses LLMs to generate code improvements that are backed by </span><strong>verifiable guarantees of improvement and non-regression.</strong></p><p><span>TestGen-LLM uses an </span><strong>ensemble approach </strong><span>to generate code improvements. This means that it uses </span><strong>multiple LLMs, prompts, and hyper-parameters</strong><span> to generate a set of candidate improvements, and then selects the best one. This approach can help to improve the quality of the generated improvements.</span></p><p><span>TestGen-LLM is specifically designed to </span><strong>improve existing human-written tests</strong><span> rather than </span><strong>generate code from scratch</strong><span>.¬†</span></p><p><span>TestGen-LLM has been </span><strong>integrated into Meta&#39;s software engineering workflows</strong><span>. This means that it can be used to automatically improve tests as part of the development process. It would be cool to see some screenshots of how exactly it‚Äôs integrated, but the paper doesn‚Äôt provide any.</span></p><p>These stats are either direct quotes or paraphrased quotes from the paper.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png" width="471" height="410.90994371482174" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:465,&#34;width&#34;:533,&#34;resizeWidth&#34;:471,&#34;bytes&#34;:null,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7a8257b1-bce4-41e3-b88b-42e7d71bcc7b_533x465.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><ul><li><p><span>The image above shows that: in an evaluation on Reels and Stories products for Instagram, 75% of TestGen-LLM test cases that were generated built correctly, 57% passed reliably, and </span><em>25% increased coverage</em><span>.</span></p></li><li><p><span>TestGen-LLM was able to improve </span><strong>10% of all classes to which it was applied and 73% of its test improvements were accepted by developers</strong><span>, and landed into production.</span></p></li><li><p><span>In a ‚Äútest-a-thon‚Äù between engineers, where various Meta engineers created tests in order to increase Instagram‚Äôs test coverage, ‚Äú</span><strong>the median number of lines of code added by a TestGen-LLM test was 2.5</strong><span>.‚Äù</span></p></li><li><p><span>However, one test case ‚Äúhit the jackpot‚Äù and covered 1,326 lines. This is a </span><em>really important stat, which I iterate upon below.</em></p></li><li><p>All improved cases generated during the ‚Äútest-a-thon‚Äù did ‚Äúcover at least one additional valid corner case, such as an early return and/or special processing for special values such as null and empty list.‚Äù</p></li></ul><p><strong>TestGen-LLM is a good example of how LLMs can be used to improve dev productivity and software reliability in a time-efficient manner.</strong><span> There are a few takeaways I got from reading this paper that give us a look both to how Big Tech is implementing LLMs internally and to how any developer or engineering manager reading this can use LLMs in a more productive manner. (Note: many of these are my own personal opinions that I‚Äôve taken away from the paper.)</span></p><p>Small context windows and scattered dependencies make LLMs nearly unusable for non-boilerplate solutions in large codebases. Aside from any privacy concerns, it‚Äôs not feasible to paste in multiple files of code into an LLM when there could be 20+ dependencies from across a codebase in a C++ header file (as an example). Even if you do paste in multiple files, there is a time and cognitive cost to actually using and trying the code outputted by an LLM in a chat window or even in the code editor by GitHub Copilot.</p><p><span>The price of extra cognitive load cannot be understated. </span><a href="https://news.ycombinator.com/item?id=39460788" rel="">Hacker News commenters find the inaccuracies of GPT-based tooling exhausting and unreliable.</a><span> This is where the </span><strong>verification of outputs being both valid and non-regressive is extremely important.</strong></p><p><span>This means that for a long-term productivity boost in large codebases,</span><strong> improvements will probably come in incremental, specialized use cases</strong><span>, like test generation and </span><a href="https://blog.research.google/2023/05/resolving-code-review-comments-with-ml.html" rel="">automatic suggestions during code reviews</a><span>. These are also low risk ways to save cumulative developer time. Basically, ‚ÄúGPT wrappers‚Äù will continue to be useful üôÇ.</span></p><p><strong>The real value of LLMs here are displayed through the edge cases</strong><span>. The paradox of writing good code is that </span><a href="https://web.mit.edu/nelsonr/www/Repenning=Sterman_CMR_su01_.pdf" rel="">nobody ever gets credit for fixing problems that never happened</a><span>.</span></p><p><a href="https://antithesis.com/blog/is_something_bugging_you/" rel="">Will Wilson writes</a><span>:</span></p><blockquote><p><em>‚ÄúThe fundamental problem of software testing‚Ä¶ is that software has to handle many situations that the developer has never thought of or will never anticipate. This limits the value of testing, because if you had the foresight to write a test for a particular case, then you probably had the foresight to make the code handle that case too. This makes conventional testing great for catching regressions, but really terrible at catching all the ‚Äúunknown unknowns‚Äù that life, the universe, and your endlessly creative users will throw at you.‚Äù</em></p></blockquote><p><span>Most of the test cases created by Meta‚Äôs TestGen-LLM only covered an extra 2.5 lines. However, one test case covered </span><em>1326 lines</em><span>! The value of that one test case is exponentially more valuable than most of the previous test cases and exponentially improves the value of TestGen-LLM. LLMs can vigorously ‚Äúthink outside the box‚Äù and the value of catching unexpected edge cases is very high here. </span></p><p><span>In fact, it‚Äôs so high that the creator of FoundationDB‚Äôs startup, </span><a href="https://antithesis.com/" rel="">Antithesis</a><span>, is entirely based on the fact that software testing edge cases are best found by AI. </span><a href="https://read.engineerscodex.com/p/how-apple-built-icloud-to-store-billions" rel="">For reference, FoundationDB was acquired by Apple and is the basis for Apple iCloud‚Äôs billions of databases.</a></p><p><span>Base model LLMs aren‚Äôt ‚Äúplug-n-play&#34; and shouldn‚Äôt reasonably ever be expected to. Sure, they might output pristine React and Tailwind CSS code, but that‚Äôs a narrow use case in most production codebases. They need a fair amount of processing and filtering for code generation tasks that require correctness. Part of this processing means grounding LLMs with examples. Google and Meta both make </span><strong>suggestions based on existing code</strong><span>, where the results are much, much better than raw generation.</span><strong> </strong><span>LLMs used in production should take ideas from how Meta processes and filters LLM outputs, and most outputs should be expected to be discarded.</span></p><p>LLMs do work best integrated into workflows. This is a reason why GitHub Copilot is so popular and another reason why Google‚Äôs Workspace integrations are a great idea. Asking a chatbot works great for certain use cases, like debugging and boilerplate code generation, but chatbots can often fail at more complex use cases.</p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png" data-component-name="Image2ToDOM" rel=""><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png" width="1456" height="379" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png&#34;,&#34;srcNoWatermark&#34;:null,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:379,&#34;width&#34;:1456,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:null,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:null,&#34;href&#34;:null,&#34;belowTheFold&#34;:true,&#34;topImage&#34;:false,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F105bb1eb-0ad0-4555-8721-58714b76bcdf_1600x416.png 1456w" sizes="100vw" loading="lazy"/></picture></div></a></figure></div><p>TestGen-LLM applies a series of semantic filters to candidate solutions generated by Meta‚Äôs internal LLMs, making sure that only the most valuable tests are preserved. Here‚Äôs how it works:</p><p><strong>Filter 1: Buildability:</strong><span> Initially, TestGen-LLM checks if the generated code can be built within the app&#39;s existing infrastructure. Any code that fails to build is immediately discarded.</span></p><p><strong>Filter 2: Execution (does the test pass?): </strong><span>Next, the system runs the tests that passed the buildability filter. Any test that doesn&#39;t pass is discarded. This step is crucial because, without a way to automatically determine the validity of a failing test (whether it&#39;s due to a bug or an incorrect assertion), TestGen-LLM opts to keep only those tests that can be used for regression testing (aka making sure they can protect current code against future regressions).¬†</span></p><p><strong>Filter 3: Flakiness:</strong><span> To address the issue of </span><a href="https://www.swequiz.com/learn/what-are-flaky-tests" rel="">flakiness</a><span> (tests that pass or fail inconsistently under the same conditions), TestGen-LLM employs repeated execution. A test must pass consistently across multiple (five) executions to be considered non-flaky.</span></p><p><strong>Filter 3: Coverage Improvement:</strong><span> Finally, to ensure that new tests actually add value, TestGen-LLM evaluates them for their contribution to test coverage. Tests that do not enhance coverage by exploring new code paths or conditions are discarded. Only tests that provide new insights or protect against regressions are kept.</span></p><p>These processing filters are pretty important as they guarantee improvements to a test suite. It also shows that LLMs are very far from being ‚Äúplug-and-play.‚Äù </p><p>The tests that successfully pass through all these filters are guaranteed to enhance the existing test suite, offering reliable regression testing capabilities without duplicating effort or wasting resources. Pre- and post-processing steps in TestGen-LLM facilitate the extraction and reconstruction of test classes, streamlining the integration of new tests into the software development workflow.</p><p>This paper is a good formalization of an use case that many devs probably already use LLMs like ChatGPT, Gemini, and Mistral/LLaMA for. Keeping it in writing is a good way of tracking the progress of future improvements on LLMs in the software reliability space. Unit tests are probably the lowest, most basic level of code generation where LLMs have the most immediate value, but as time goes on, we‚Äôll definitely see LLMs be able to catch and test for bugs in increasingly complex software systems.</p><p>The question is - will that make software easier to develop in the long run or will it lead to a proliferation of software complexity in the future?</p></div></div></div></article></div></div></div>
  </body>
</html>
