<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.digitalmars.com/articles/C-biggest-mistake.html">Original</a>
    <h1>C’s Biggest Mistake (2009)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
  
  
<p><small>written by Walter Bright</small></p>

<p><small>December 22, 2009</small></p>

<p>C is arguably the world’s most successful programming language. Its success has, of course,
endlessly tempted people to improve upon it. Thus, C is probably the patriarch of the
longest list of languages. Notable among these are C++, the D programming language,
and most recently, Go. There are endless discussion threads on how to fix C, going
back to the 80’s.
</p>

<p>So this is well trod ground. What could possibly be added to this soup? I posit
that most such discussions center around detail. More interesting is what is
the largest fundamental mistake. We should take into account the context of the times
that spawned C, and the problems it was trying to solve and the environment
in which it was intended to be used. Keep in mind it was developed for a 16
bit machine, with extremely limited resources available.
I’d like to dismiss things like it doesn’t
do garbage collection, functional programming, dynamic typing, or OOP. Those aren’t problems C
attempted to address, so the lack of them are not mistakes.
</p>

<p>What mistake has caused more grief, more bugs, more workarounds, more endless hours
consumed, etc., than any other? Many people would say
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">null pointers</a>.
I don’t agree.
</p>

<p>Conflating pointers with arrays.
</p>

<p>I don’t mean them using the same syntax, or the implicit conversion of
arrays to pointers. I mean the inability to pass an array to a function
as an array, even if it is declared to be an array. C will silently convert
the array to be a pointer, and will rewrite the function declaration
so it is semantically a pointer:
</p>

<pre><span>void</span> foo(<span>char</span> a[])
</pre>

<p>is exactly equivalent to [1]:
</p>

<pre><span>void</span> foo(<span>char</span> *a)
</pre>

<p>This seemingly innocuous convenience feature is the root of endless evil.
It means that once arrays leave the scope in which they are defined,
they become pointers, and lose the information which gives the extent
of the array — the array dimension. What are the consequences of losing
this information?
</p>

<p>An alternative must be used. For strings, it’s the whole reason for the 0 terminator.
For
other arrays, it is inferred programmatically from the context. Naturally,
every situation is different, and so an endless array (!) of bugs ensues.
</p>

<p>The trainwreck just unfolds in slow motion from there.
</p>

<p>The galaxy of C string functions, from the unsafe strcpy() to sprintf() onwards,
is a direct result. There are various attempts at fixing this, such as the
<a href="http://www.ddj.com/security/214502214">Safe C Library</a>.
Then there are all the buffer overflows, because functions
handed a pointer have no
idea what the limits are, and no array bounds checking is possible.
</p>

<p>This problem was inherited in toto by C++, which consequently spawned 10+ years
of attempts to create a usable string class. Even the eventual <tt>std::string</tt> result
is compromised by its need to be compatible with C 0-terminated strings.
C++ addressed the more general array problem by inventing <tt>std::vector<t></t></tt>, and
many programming guidelines eschew using <tt>T[]</tt> style arrays. But the legacy of
C arrays continues in C++ with the
<a href="http://www.boostcon.com/site-media/var/sphene/sphwiki/attachment/2009/05/08/iterators-must-go.pdf">unsafe iterator design</a>.
</p>

<p>The C99 attempted to fix this problem, but the fatal error it made was still
not combining the array dimension with the array pointer into one type.
</p>

<p>But all isn’t lost. C can still be fixed. All it needs is a little new syntax:
</p>

<pre><span>void</span> foo(<span>char</span> a[..])
</pre>

<p>meaning an array is passed as a so-called “fat pointer”, i.e. a pair consisting of a
pointer to the start of the array, and a <tt>size_t</tt> of the array dimension.
Of course, this won’t fix any existing code, but it will enable new code to be written
correctly and robustly. Over time, the syntax:
</p>

<pre><span>void</span> foo(<span>char</span> a[])
</pre>

<p>can be deprecated by convention and by compilers. Even better, transitioning to the
new way can be done by making the declarations binary compatible with older code:
</p>

<pre>#if NEWC
  <span>extern</span> <span>void</span> foo(<span>char</span> a[..]);
#elif C99
  <span>extern</span> <span>void</span> foo(size_t dim, <span>char</span> a[dim]);
#else
  <span>extern</span> <span>void</span> foo(size_t dim, <span>char</span> *a);
#endif
</pre>

<p>This change isn’t going to transform C into a modern language with all the shiny
bells and whistles. It’ll still be C, in spirit as well as practice. It will
just relieve C programmers of dealing with one particular constant, pernicious source of
bugs.
</p>


<h3>References</h3>

<ol><li>The relevant text from K+R’s The C Programming Language 5.3 is
“When an array name is passed to a function, what is passed is the
location of the beginning of the array. Within the called function,
this argument is a variable, just like any other variable, and so an
array name argument is truly a pointer, that is, a variable containing
an address.”</li>

<li>The relevant text from the C 99 Standard 6.7.5.3.7 is
“A declaration of a parameter as ‘array of type’
shall be adjusted to ‘qualified pointer to type’”</li>

<li>From Stroustrup’s The C++ Programming Language first edition 7.1
“and as usual, array names are converted to pointers.”</li>
</ol>


<h3>Acknowledgements</h3><p><i>Thanks to Bartosz Milewski for reviewing a draft of this.</i></p>


  
<!-- Google ad -->


</div><p>

Copyright © 1999-2022 by Digital Mars ®, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</p></div>
  </body>
</html>
