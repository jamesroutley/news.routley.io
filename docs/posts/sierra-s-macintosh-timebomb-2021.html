<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.benshoof.org/blog/sierras-macintosh-timebomb">Original</a>
    <h1>Sierra’s Macintosh Timebomb (2021)</h1>
    
    <div id="readability-page-1" class="page"><div>
				
			
				<div>
					<p>
					On Saturday, September 18 1993, Sierra&#39;s Macintosh games stopped working. Franchises froze as King&#39;s Quests, Space Quests, and even the Leisurely Suited Larries locked up. Practically every <a href="https://www.savagetaylor.com/2020/01/12/sierra-256-colour-and-sci-games-for-the-macintosh-68k-and-ppc/">Mac SCI game</a> had broken overnight. Sierra developed a <a href="https://web.archive.org/web/20060220084235/http://ftp.sierra.com/patches/mac/">patch</a> within nine days, released it on their BBS, and announced it in their <a href="https://archive.org/details/InterAction_Magazine_Vol._VI_Number_3_Holiday_1993_1993_Sierra_On-Line_US/page/n10/mode/1up">magazine</a>. Anyone who wrote in received a free patch disk in the mail. The MCDATE patch was a Mac program that fixed almost any game you pointed it at. And yet here in the future, they&#39;re failing all over again. What went wrong?
					</p>
			
					<p>
					<img src="https://raphlinus.github.io/rust/gpu/2023/01/07/images/phantasmagoria.png" alt="King&#39;s Quest 6 gets stuck on its copyright message" title="I reserve the right to make this a three day GIF"/>
					</p>
			
					<p>
					Each Mac game seems to lock up differently but they&#39;re all doing the same thing: waiting way too long for a pause to complete. Specifically, the games hang when they set a delay on a Script object in seconds. SCI games are full of these short delays and now they bring everything to a halt. King&#39;s Quest VI can&#39;t even finish its opening copyright message because of a three second pause that never seems to end.
					</p>
			
					<p>
					Timing is tricky in SCI, but for today we just need to know that Script delays in seconds are implemented by polling the system clock for changes. Scripts don&#39;t wait for three seconds, they wait for three clock changes. It doesn&#39;t matter what any of those times are as long as they&#39;re different than before. That&#39;s a pretty big clue. Just by looking at the scripts we can tell that the only way this scheme can get stuck is if the clock gets stuck, and scripts get their clock time from KGetTime.
					</p>
			
					<p>
					The K in KGetTime stands for Kernel. Kernel functions live in Sierra&#39;s interpreter for game scripts to call. Sierra ported SCI games to Mac by first converting the SCI interpreter to a Mac program, and that meant rewriting a lot of code to do things the Mac way. Reading the clock is one of those low-level things that&#39;s so different between platforms that it needs to be rewritten for each. That makes KGetTime a great candidate for a <span>Mac-only</span> bug.
					</p>
			
					<p>
					KGetTime has several modes to provide times in different formats. Our Mac problems occur when Script delays call KGetTime(1) so that&#39;s the one we&#39;ll focus on. KGetTime(1) returns the time of day in a 16-bit format:<code> HHHH MMMM MMSS SSSS</code>
					</p>
			
					<p>
					If a game wants to display the current time then it calls KGetTime(1) and unpacks those individual values, but if it&#39;s only looking to see if time has changed then it just stores the result and compares it to the next. Unfortunately some pope crammed too many seconds in a day and <span>16 bits</span> aren&#39;t enough to hold them. You need 17 bits for that, so KGetTime(1) compromises by limiting the hours to 12. If you need to know which half of the day it is then you use KGetTime(2), which compromises on the other end by limiting the resolution to every 2 seconds. Script delays only want to know when the seconds change so KGetTime(1) does the job. Although, that does mean all that bit packing is a waste of time, in like... a couple ways.
					</p>
			
					<p>
					KGetTime turns out to be just a small wrapper function. SysTime is where the real work is done.
					</p>
			
<pre>  

  2038 020c        <span>move.l</span>   <span>Time</span>, <span>d0</span>   
  80fc a8c0        <span>divu.w</span>   #$a8c0, <span>d0</span> 
  4840             <span>swap</span>     <span>d0</span>
  0280 0000 ffff   <span>andi.l</span>   #$ffff, <span>d0</span> 
  80fc 003c        <span>divu.w</span>   #60, <span>d0</span>
  7200             <span>moveq</span>    #0, <span>d1</span>
  3200             <span>move.w</span>   <span>d0</span>, <span>d1</span>
  4840             <span>swap</span>     <span>d0</span>         
  82fc 003c        <span>divu.w</span>   #60, <span>d1</span>
  3401             <span>move.w</span>   <span>d1</span>, <span>d2</span>
  4841             <span>swap</span>     <span>d1</span>
  ed49             <span>lsl.w</span>    #6, <span>d1</span>
  8041             <span>or.q</span>     <span>d1</span>, <span>d0</span>     
  123c 000c        <span>move.b</span>   #12 ,<span>d1</span>
  e36a             <span>lsl.w</span>    <span>d1</span>, <span>d2</span>
  8042             <span>or.w</span>     <span>d2</span>, <span>d0</span>     
</pre>
			
					<p>
					Macintosh clock time is the number of seconds since midnight on January 1 1904. The operating system updates the Time global variable every second. SysTime(1) only cares about the current 12 hour period so it divides Time by 12 hours ($A8C0 seconds) and takes the remainder. From there it calculates the hours and minutes and remaining seconds and packages them up in 16 sweet bits. All of this sounds good, but we know there&#39;s a problem here that involves September 18 1993. $A8C0 is the only interesting constant, so let&#39;s inspect that second instruction.
					</p>
			
					<p>
					The Motorola 68000 processor&#39;s DIVU instruction divides a 32-bit unsigned integer by a 16-bit unsigned integer and puts the quotient in the lower 16 bits and the remainder in the upper 16. If you only care about the remainder then you swap &#39;em and clear the upper bits, just like SysTime does. But DIVU can fail.
					</p>
			
					<blockquote>
					    <p>
					    Overflow may be detected and set before the instruction completes. If the instruction detects an overflow, it sets the overflow condition code, and the operands are unaffected.
					    </p>
					    
					</blockquote>
			
					<p>
					If Time gets too big then DIVU won&#39;t do anything but SysTime will proceed as if it had. SysTime will then cheerfully swap the bits from the Macintosh clock time, throw away the useful ones that change every second, and keep the lifers that only budge every 18 hours. At that point the rest of the code keeps producing the same result for quite a while and the clock is effectively stuck. Time gets too big when dividing by $A8C0 produces an answer that doesn&#39;t fit in 16 bits. Once that answer reaches $10000 the timebomb goes off. According to NumberWang, $A8C0 times $10000 is $A8C00000, or as its more colloquially known: the two billion eight hundred and thirty one million one hundred and fifty five thousand and two hundred seconds between January 1 1904 and September 18 1993.
					</p>
			
					<p>
					What terrible luck! Look, the entire software development profession and several of its more lucrative subfields are based on every programmer cranking out a dozen overflows a day. That&#39;s a given. But the Sierra programmer tasked with Mac SysTime in 1990 was working with a 136 year format that still had another 50 good years on it. And yet dividing by 12 hours happened to light a fuse so short that it would only run out once the code was in everyone&#39;s homes and still on the shelves. Mac SCI was born with barely four years to live! That would drive you totally Batty.
					</p>
			
					<p>
					Oh well, it&#39;s just a division overflow. There are plenty of ways to work around that when you only care about the remainder. Or hey, you could use Mac&#39;s Secs2Date function that does this work for you, and SysTime(3) already calls that. Patching binaries is hard, especially under pressure, but at least Sierra had options. I can&#39;t wait to see how they fixed this!
					</p>
			
<pre>  

  2038 020c        <span>move.l</span>   <span>Time</span>, <span>d0</span>       
<span>+ 0480 19bf cc00   subi.l   #$19bfcc00, d0 ; subtract 5,000 days</span>
  80fc a8c0        <span>divu.w</span>   #$a8c0, <span>d0</span>     
  4840             <span>swap</span>     <span>d0</span>
  0280 0000 ffff   <span>andi.l</span>   #$ffff, <span>d0</span>     
  ....             ....
</pre>
			
					<p>
					Oh so <i>that&#39;s</i> how we fixed Y2K. I sure hope we subtracted a bigger number! $19BFCC00 is 432,000,000 seconds which is 5,000 days which is 13.6 years which is almost a Guns N Roses song. <i>Sierra didn&#39;t disarm the damn bomb!</i> They just lashed on more fuse with a granny knot. I want to make fun of kicking the can down to May 28 2007, but that turned out to be a generous assessment of classic Mac&#39;s future. Here in <i>our</i> future, those 5,000 days blew by and these games are back to blowing up. But now they explode in emulators where you can&#39;t always change their clock to work around it. And changing <i>your</i> clock is an exercise in Kaczynskism that detonates your TLS connections and takes you off the grid.
					</p>
			
					<p>
					Actually we probably should make fun of this because it gets worse. It would be one thing if this was a temporary fix. After all, patching a fleet of binaries in the wild means operating under a lot of constraints. But no, bumping the incept date was Sierra&#39;s permanent solution. Future games with newer interpreters shipped with this same code instead of simply checking for overflow. As a result, there are now more Mac games with this bug than when it was fixed.
					</p>
			
					<p>
					Well, Sierra fudged it, but they weren&#39;t the only ones to try. <a href="https://erolfi.wordpress.com/">Enrico Rolfi</a> is a legendary SCI hacker of the Italian persuasion who reverse engineered a lot of resource formats before it was cool. His <a href="https://erolfi.wordpress.com/tradusci/">TraduSCI</a> software has allowed fans to completely translate Sierra games to other languages since 2004. Astoundingly, <i>he&#39;s still at it!</i> Two months ago he released a <a href="https://erolfi.wordpress.com/2021/10/09/tradusci-2-4-is-out/">new version</a> that integrates with Google Translate. I&#39;m terribly impressed, and I take comfort that someone else maintains their Bush-era Windows software and forgets their blog for years.
					</p>
			
					<p>
					In 2002, Enrico resurrected <a href="https://erolfi.wordpress.com/2009/06/16/space-quest-iii-patch-for-mac/">Space Quest III</a> and <a href="https://erolfi.wordpress.com/2009/06/16/space-quest-iv-patch-for-mac/">Space Quest IV</a> to run on newer Macintoshes, and that meant taking on KGetTime. Enrico&#39;s patched versions still run today no matter what year it is. <i>Success!</i> But they don&#39;t fix SysTime, they skip it. Instead, KGetTime ignores the mode parameter from the game scripts and always returns the tick counter. The interpreter increments this every 1/60th of second, so while Script delays no longer hang, they now run 60 times too fast. I know <a href="https://raphlinus.github.io/rust/gpu/2023/01/07/kings-quest-vi-tile-maze">some folks</a> who would love this...
					</p>
			
					<p>
					<img src="https://raphlinus.github.io/rust/gpu/2023/01/07/images/mcdate.png" alt="Sierra&#39;s MCDATE patch" title="totally canon"/>
					</p>
			
					<p>
					So what have we learned today? We&#39;ve learned why Sierra&#39;s Mac games froze on September 18 1993. We&#39;ve learned how a shoddy fix froze them again on March 28 2007. And we&#39;ve learned that they were never truly frozen; Mac users were just too impatient for a three day copyright message. But most importantly, we&#39;ve learned that Y2K will still murder us all in our sleep.<a href="https://raphlinus.github.io/rust/gpu/2023/01/07/keep-it-light">*</a>
					</p>
			
					<p>
					Here in the future, can we do any better? Pfft, maybe <i>you</i> can, the whole thing&#39;s a proper mess innit? Each game&#39;s interpreter is different and now they&#39;re patched or unpatched or post-patch or fan-patched. And patching these old programs yourself isn&#39;t simple; the code is in Mac resource forks and those forks are compressed. If you were really crazed, you could write a proper SysTime in m68k assembly with overflow checks and use ResEdit to patch that into Sierra&#39;s patcher. Seriously, if you can keep yours within 178 bytes you can replace the wonky SysTime at Data resource 128. You&#39;re on your own for applying that to post-patch games. That&#39;s a lot of work when we have ScummVM, which already goes out of its way to run Sierra&#39;s old Mac versions on all modern platforms. Classic Mac has sunk — <i>everybody into the lifeboat!</i>
					</p>
			
					<p>
					Of course the real obstacle to fixing Sierra&#39;s Mac games is that nobody cares. And why would they? It&#39;s never been easier to run Sierra games, meanwhile the Mac versions are increasingly inaccessible <i>and boring</i>. They&#39;re just ports of the DOS versions. Aside from a few Mac gimmicks, the games themselves don&#39;t bring anything new to the table. Although, there is <i>one</i> exception...
					</p>
			
					<p>
					<b>Next time:</b> Mo&#39; Mac? <i>Maybe!</i>
					</p>
				</div>
			</div></div>
  </body>
</html>
