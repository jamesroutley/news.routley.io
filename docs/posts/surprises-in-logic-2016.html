<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://math.ucr.edu/home/baez/surprises.html">Original</a>
    <h1>Surprises in Logic (2016)</h1>
    
    <div id="readability-page-1" class="page">

<h2> Surprises in Logic </h2>
<h4> John Baez </h4>
<h4> April 4, 2016 </h4>

<p>There&#39;s a complexity barrier built into the very laws of logic: roughly speaking, while lots of things are more complex than this, we can&#39;t prove any <i>specific</i> thing is more complex than this. And this barrier is surprisingly low!  Just how low?  Read this.</p>

<p>And then see what happens when combine this idea with the famous &#39;surprise examination paradox&#39;, also known as the &#39;unexpected hanging paradox&#39;.</p>

<p>Mathematically speaking, these ideas are called Chaitin&#39;s incompleteness theorem and the Kritchman–Raz proof of Gödel&#39;s second incompleteness theorem.  But don&#39;t be intimidated: I&#39;ll explain everything you need to know!</p>

<p>After that I&#39;ll explain another surprise: there&#39;s a computer that computes any uncomputable function... in some model of arithmetic.</p>

<h3><a name="chaitin"> Chaitin&#39;s incompleteness theorem</a> </h3>

<p>Could we grow the whole universe with all its seeming complexity starting from a little seed?  How much can you do with just a little information?</p>

<p>People have contests about this.  Dan Piponi pointed out this animated video <a href="http://pouet.net/prod.php?which=52938&#34;">created in 2009</a> using a program less than 4 kilobytes long that runs on a Windows XP machine:

</p><p>
<iframe width="460" height="315" src="https://www.youtube.com/embed/I5CTFMuFvb0" title="YouTube video player" frameborder="5" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
</p>

<p>A beautiful alien planet compressed into a mere 4 kilobytes of information!  As my friend the programmer Bruce Smith noted:</p>

<blockquote>
To be fair, the complexity of some of the OS, graphics drivers, and hardware should be included, but this is a lot less than you might think if you imagine rewriting it purely for compactness rather than for speed, and only including what this sort of program needs to produce output.
</blockquote>

<p>Still, it&#39;s quite amazing.</p>  

<p>Mind you, people didn&#39;t figure out how to produce such fancy images from tiny amounts of information overnight!  Iñigo Quílez, one of the guys who made this video, has explained some of the <a href="http://www.iquilezles.org/www/index.htm">tricks</a>.  They&#39;re deep!  And they were developed over decades in the <a href="http://en.wikipedia.org/wiki/Demoscene">demoscene</a> — a computer art subculture where people produce <a href="http://en.wikipedia.org/wiki/Demo_%28computer_programming%29">demos</a>: non-interactive audio-visual computer presentations that run in real time.  </p>

<p>According to the Wikipedia article on the demoscene:

</p><blockquote>
Recent computer hardware advancements include faster processors, more memory, faster video graphics processors, and hardware 3D acceleration. With many of the past&#39;s challenges removed, the focus in making demos has moved from squeezing as much out of the computer as possible to making stylish, beautiful, well-designed real time artwork. 

<p>The old tradition still lives on, though. <a href="http://en.wikipedia.org/wiki/Demoparty">Demo parties</a> have competitions with varying limitations in program size or platform (different series are called <a href="http://en.wikipedia.org/wiki/Compo_%28demoscene%29">compos</a>). On a modern computer the executable size may be limited to 64 kB or 4 kB. Programs of limited size are usually called <a href="http://en.wikipedia.org/wiki/Demo_%28computer_programming%29#Intros">intros</a>. In other compos the choice of platform is restricted; only old computers, like the 8-bit Commodore 64, or the 16-bit Amiga, or Atari ST, or mobile devices like handheld phones or PDAs are allowed. Such restrictions provide a challenge for coders, musicians and graphics artists and bring back the old motive of making a device do more than was intended in its original design.
</p></blockquote>

<p>What else can you do with just a little information?  Bruce Smith listed a couple more:</p>

<ul><li>Bill Gates&#39; first commercial success was an implementation of a useful version of BASIC in about 4000 bytes.</li>

<li> The complete genetic code of an organism can be as short as a few hundred thousand bytes, and that has to be encoded in a way that doesn&#39;t allow for highly clever compression schemes.</li></ul>

<p>So, amazingly complex things can be compressed into fairly little information.   You can&#39;t help but wonder: how complex can something be?  </p>

<p>The answer: arbitrarily complex!  At least that&#39;s true if we&#39;re talking about the <a href="http://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov complexity</a> of a string of bits: namely, the length of the shortest computer program that prints it out.   Lots of long strings of bits can&#39;t be compressed.   You can&#39;t print out most of them using short programs, since there aren&#39;t enough short programs to go around.</p>

<p>Of course, we need to fix a computer language ahead of time, so this is well-defined.  And we need to make sure the programs are written in binary, so the comparison is fair.</p>

<p>So, things can be arbitrarily complex.  But here&#39;s a more interesting question: how complex can we <i>prove</i> something to be?  </p>

<p>The answer is one of the most astounding facts I know.  It&#39;s called <a href="http://en.wikipedia.org/wiki/Chaitin%27s_incompleteness_theorem#Chaitin.27s_incompleteness_theorem">Chaitin&#39;s incompleteness theorem</a>.  It says, very roughly: </p>

<p><b>There&#39;s a number <i>L</i> such that we can&#39;t prove the Kolmogorov complexity of any specific string of bits is more than <i>L</i>.</b>
</p>

<p>Make sure you understand this.  For any number, we can prove there are infinitely many bit strings with  Kolmogorov complexity more than that.  But we can&#39;t point to any <i>particular</i> bit string and prove its Kolmogorov complexity is more than \(L\)! </p>

<p>Allen Knutson wrote:</p>

<blockquote>

<p>That&#39;s an incredibly disturbing theorem, like driving to the edge of the universe and finding a wall.
</p></blockquote>

<p>I call \(L\) the &#39;complexity barrier&#39;.  So one question is, how big is \(L\)?</p>

<p>\(L\) depends not only on the programming language we use, but also on the system of math we use to prove things.  By adjusting these in strange ways, we can make \(L\) as big as small as we like.  But suppose we make a &#39;reasonable&#39; choice?</p>

<p>Chaitin claims that for a certain version of the programming langauge LISP, and any system of math whose axioms can be encoded in a LISP program \(N\) bits long, the complexity barrier is 

$$  L \le N + 2359 $$

bits!  It&#39;s hard, or perhaps even impossible, to find the <i>smallest</i> \(L\) that does the job for a certain programming language and system of math, so this is an upper bound.  For details, see:

</p><ul><li>Gregory Chaitin, <i><a href="http://arxiv.org/pdf/chao-dyn/9407003v1.pdf" rel="nofollow">The Limits of Mathematics</a></i>, 1994.  </li></ul>

<p>It&#39;s also interesting to see what a skilled programmer would <i>guess</i> about the value of \(L\), after the proof of Chaitin&#39;s theorem has been explained ot them.  So, I asked my friend Bruce Smith to guess \(L\) for some other reasonable programming language and system of math.  He estimated that it&#39;s a <i>a few kilobytes!</i>  This is larger than Chaitin&#39;s value, but roughly consistent.</p>

<p>I&#39;d like to see a program a few kilobytes long that produces a video showing a big bang, the formation of stars and galaxies, then planets, including one where life evolves, then intelligent life, then the development of computers... and finally someone writing the very same program.  </p>

<p>I can&#39;t prove it&#39;s possible... but <i>you can&#39;t prove it isn&#39;t!</i></p>

<p>Let&#39;s see why.   Let&#39;s see the proof of Chaitin&#39;s incompleteness theorem.</p>

<h3> Chaitin&#39;s incompleteness theorem—the proof </h3>

<p>For starters, we need to choose some axioms for our system of math, so we know what &#39;provable&#39; means.  We need a system that&#39;s powerful enough to prove a bunch of basic facts about arithmetic, but simple enough that a computer program can check if a proof in this system is valid.  </p>

<p>There are lots of systems like this.  Three famous ones are <a href="http://en.wikipedia.org/wiki/Peano_axioms#First-order_theory_of_arithmetic">Peano arithmetic</a>, <a href="http://en.wikipedia.org/wiki/Robinson_arithmetic">Robinson arithmetic</a> (which is less powerful) and <a href="">Zermelo-Fraenkel set theory</a> (which is more powerful).</p>

<p>When you have a system of math like this, <a href="http://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems#First_incompleteness_theorem">Gödel&#39;s first incompleteness theorem</a> kicks in: if the system is consistent,  it can&#39;t be complete.  In other words, there are some questions it leaves unsettled.  This is why we shouldn&#39;t be utterly shocked that while a bunch of bit strings have complexity more than \( L\), we can&#39;t <i>prove</i> this.</p>

<p><a href="http://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems#Second_incompleteness_theorem">Gödel&#39;s second incompleteness theorem</a> also kicks in: if the system can prove that it&#39;s consistent, it&#39;s not!  (If it&#39;s not consistent, it can prove <i>anything</i>, so you shouldn&#39;t trust it.)  So, there&#39;s a sense in which we can never be completely sure that our system of math is consistent.  But let&#39;s assume it is.</p>

<p>Given this, Chaitin&#39;s theorem says:</p>

<p> There exists a constant \(L\) such that no string of bits has Kolmogorov complexity that provably exceeds \(L\).
</p>

<p>How can we get a number that does the job?  Any number \( L\) with</p>

$$ U + \log_2(L) + K \lt L $$

<p>will do.  Here:</p>

<ul><li> \(U\) is the length of a program where if you input a natural number \(i\), it will search through all proofs in Peano arithmetic until it finds one that proves some bit string has Kolmogorov complexity \( &gt; i\).  If it finds one, then it outputs this bit string.  If it never finds one, it grinds on endlessly.  (Of course, if \( i = L\), it will never find one!)</li>

<li> \(K\) is a small overhead cost: the length of the extra &#39;glue&#39; to create a bigger program that takes the number \( L\), written out in binary, and feeds it into the program described above. </li></ul>

<p>The length of \(L\) written out in binary is about \( \log_2(L)\).  This bigger program thus has length </p>

$$ U + \log_2(L) + K $$

<p>and for the proof of Chaitin&#39;s incompleteness theorem to work, we need this to be smaller than \(L\).  Obviously we can accomplish this by making \( L\) big enough, since \(\log_2 L\) grows slower than \(L\).</p>

<p>Given all the stuff I&#39;ve told you, the proof of Chaitin&#39;s theorem almost writes itself!  You run this bigger program I just described.  If there were a bit string whose Kolmogorov complexity is provably greater than \( L\), this program would print one out.  But that&#39;s a contradiction, because this program has length less than \( L\).</p>

<p>So, we just need to pick a computer language and a suitable system of math, and estimate \( U\) and, less importantly because it&#39;s so much smaller, \(K\).   Then \( L\) will be just a bit bigger than \( U + K\).</p>

<p>I picked the language C and Peano arithmetic and asked Bruce if he could guess, roughly, what answer we get for \(L\).  He replied:</p>

<blockquote>
I don&#39;t think it can be done in C, since C semantics are not well-defined unless you specify a particular finite machine size. (Since C programs can do things like convert pointers to integers and back, tell you the size of any datatype, and convert data of any specified datatype to bytes and back.) On a finite machine of \( N\) bits, all programs either finish in time less than about \( 2^N\) or take forever.

<p>But if you take &#34;C without size-specific operations&#34;, or a higher level language like Python, or for that matter a different sort of low-level language like a Turing machine, then that&#39;s not an issue—you can define a precise semantics that allows it to run a program for an arbitrarily long time and allocate an arbitrary number of objects in memory which contain pointers to each other. (To stick with the spirit of the question, for whatever language you choose, you&#39;d want to disallow use of any large external batch of information like a &#34;standard library&#34;, except for whatever is so basic that you think of it as part of the native language. This is not a serious handicap for this problem.)</p>

<p>The main things that the program &#39;U&#39; (I&#39;d rather call the program itself &#39;U&#39; than call its length &#39;\(U\)&#39;) needs to do are:</p>

<ul><li> recognize a syntactically correct statement or proof;</li>

<li> check the validity of a purported proof;</li>

<li> recognize certain statements as saying or implying &#34;The Kolmogorov complexity of \(n\) is more than \(i\)&#34; for some \(n\) and \(i\). (It&#39;s not necessary to recognize all such statements, just at least one for each \( n\) and \( i\), so it can just recognize a statement that consists of some template with specific values of \( n\) and \( i\) inserted into it at certain places.)</li></ul>

<p>Assuming that U expresses the proofs it wants to check in a practical proof language (which will be more like what a practical theorem-prover like <a href="http://en.wikipedia.org/wiki/Coq">Coq</a> uses than like what a traditional logician would recognize as &#34;straight Peano arithmetic&#34;, but which will not be excessively powerful in the spirit of this question), I&#39;d estimate that the most complex part is checking proof validity, but that that can still be expressed in at most a few dozen syntactic rules, each expressible in a few lines of code. (The authors of a system like Coq, which includes code to actually do that, would know better, as long as they remember that the vast majority of their system&#39;s actual code is not needed for this problem.)</p>

<p>This makes me think that even without trying to compact it much, in a reasonable language we could write U in a few hundred lines of code, or (after a bit of simple compression) a few thousand bytes. (And perhaps much less if we tried hard to compact the whole program in clever ways.)</p>

<p>So \(L\) will also be &#34;a few thousand&#34; (bytes or digits), or perhaps less, rather than some number you can never possibly count to.</p>

</blockquote>

<h3> The Kritchman–Raz proof of Gödel&#39;s second incompleteness theorem</h3>

<p>In 2010, Shira Kritchman and Ran Raz used Chaitin&#39;s incompleteness theorem to prove Gödel&#39;s incompleteness theorem in an unexpected new way.</p>

<p>I&#39;d like to explain to explain their argument a really sloppy way so everyone can understand it.  Logic is cool, but most people never get to the cool part because they can&#39;t fight their way through the rather dry technicalities.</p>

<p>You&#39;ve heard of the <a href="http://en.wikipedia.org/wiki/Unexpected_hanging_paradox">surprise examination paradox</a>, right? The teacher says one day he&#39;ll give a quiz and it will be a surprise. So the kids think &#34;well, it can&#39;t be on the last day then—we&#39;d know it was coming.&#34; And then they think &#34;well, so it can&#39;t be on the day before the last day, either!—we&#39;d know it was coming.&#34; And so on... and they convince themselves it can&#39;t happen at all. </p>

<p>But then the teacher gives it the very next day, and they&#39;re completely surprised.</p>

<p>People still argue a lot about how to settle this paradox.  But anyway, Kritchman and Raz used a <i>rigorous</i> version of this paradox together with <a href="http://en.wikipedia.org/wiki/Chaitin%27s_incompleteness_theorem#Chaitin.27s_incompleteness_theorem" rel="nofollow">Chaitin&#39;s incompleteness theorem</a> to demonstrate <a href="http://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems#Second_incompleteness_theorem">Gödel&#39;s second incompleteness theorem</a>—which says, <i>very</i> roughly, that:</p>

<p><b>If math can prove itself consistent, it&#39;s not</b>. 
</p>

<p>If you&#39;re a logician, I bet this sort of sloppy statement really annoys you.  If so, I&#39;m sorry: I want to summarize Kritchman and Raz&#39;s argument <i>in a really sloppy way</i>.  You can easily add the fine print to make this summary rigorous—or if you prefer, read <a href="http://www.ams.org/notices/201011/rtx101101454p.pdf">their paper</a>. 

</p><p>Okay, here we go:</p>

<p>Chaitin&#39;s theorem, which is already astounding, says there&#39;s some length \(L\) such that you can&#39;t prove any particular string of bits needs a program longer than \(L\) to print it out. At least, this is so if our system of math is consistent. If it&#39;s not consistent, you can prove anything!</p>

<p>On the other hand, there&#39;s some finite number of programs of length \(\le L\). So if you take a list of more numbers than that, say \(1, 2, \dots, N\), there&#39;s <i>got to be at least one</i> that needs a program longer than \(L\) to print it out.</p>

<p>Okay: <i>there&#39;s got to be at least one</i>. How many? Suppose <i>just one</i>. Then we can go through all programs of length \(\le L\), find those that print all the other numbers on our list... and thus, by a process of elimination, find the culprit.</p>

<p>But that means we&#39;ve proved that this culprit is a number can only be computed by a program of length \(\gt L\).  But Chaitin&#39;s theorem says that&#39;s impossible! At least, not if math is consistent.</p>

<p>So there can&#39;t be just one. At least, not if math is consistent.</p>

<p>Okay: suppose there are <i>just two</i>. Well, we can pull the same trick and find out who they are! So there can&#39;t be <i>just two</i>, either. At least, not if math is consistent.</p>

<p>We can keep playing this game until we rule out all the possibilities... and then we&#39;re really stuck. We get a contradiction. At least, if math is consistent.</p>

<p>So if we could prove math is consistent, we&#39;d know it&#39;s not!</p>

<h3> References </h3>

<p>This article first appeared as three posts on my blog.  I&#39;ve polished them up here, but there are lots of interesting comments over there, and you may want to make your own, or ask questions:</p>

<ul><li><a href="http://johncarlosbaez.wordpress.com/2011/10/28/the-complexity-barrier/">The complexity barrier</a>, Azimuth, October 28, 2011.
</li>

<li><a href="http://johncarlosbaez.wordpress.com/2011/10/06/chaitins-theorem-and-the-surprise-examination-paradox/">Chaitin&#39;s theorem and the unexpected examination paradox</a>, Azimuth, October 6, 2011.</li>

<li><a href="https://johncarlosbaez.wordpress.com/2016/04/02/computing-the-uncomputable/">Computing the uncomputable</a>, Azimuth, April 4, 2016.
</li></ul>


As I mentioned, Chaitin proves a version of his incompleteness theorem here:

<ul>
<li>
Gregory Chaitin, <i><a href="https://math.ucr.edu/home/baez/arxiv.org/pdf/chao-dyn/9407003v1.pdf">The Limits of Mathematics</a></i>, 1994.
</li>
</ul>

<p>However, this book is hard to read without going back to this earlier one:</p>

<ul>
<li>Gregory Chaitin, <i><a href="http://www.umcs.maine.edu/~chaitin/cup.pdf" rel="nofollow">Algorithmic Information Theory</a></i>, 2003.  (First edition was 1987.)
</li>
</ul>

<p>Kritchman and Raz proved their result here:</p>

<ul><li> Shira Kritchman and Ran Raz, <a href="http://www.ams.org/notices/201011/rtx101101454p.pdf" rel="nofollow">The surprise examination paradox and the second incompleteness theorem</a>, <i>AMS Notices</i> <b>57</b> (December 2010), 1454–1458.</li></ul>

<p>There&#39;s been a lot of discussion about the significance of Chaitin&#39;s incompleteness theorem.  Here&#39;s an intelligent argument that some of the claims are overblown:</p>

<ul>
<li>
Panu Raatikainen, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.142.516&amp;rep=rep1&amp;type=pdf">On interpreting Chaitin&#39;s incompleteness
theorem</a>, <i>Journal of Philosophical Logic</i> <b>27</b> (1998), 569–586.
</li>
</ul>

<p>For more on Kolmogorov complexity and related ideas, try:</p>

<ul>
<li>
Peter D. Grunwald and Paul M. B. Vitányi, <a href="http://arxiv.org/abs/0809.2754">Algorithmic information theory</a>, 2008. 
</li>
</ul>

<h3> The computability of incomputable functions </h3>

<p>Here&#39;s another surprising result:</p>

<ul>
<li> Joel David Hamkins, <a href="http://jdh.hamkins.org/every-function-can-be-computable/">Any function can be computable</a>, March 25, 2016.
</li>
</ul>

<p>Let me try to explain it without assuming you&#39;re an expert on mathematical logic.  That may be hard, but I&#39;ll give it a try.  We need to start with some background.</p>

<p>First, you need to know that there are many different models of arithmetic.  If you write down the usual axioms for the natural numbers, the <a href="http://www.xamuel.com/the-axioms-of-peano-arithmetic-modern-version/">Peano axioms</a>, you can then look around for different structures that obey these axioms.  These are called &#39;models&#39; of Peano arithmetic.</p>

<p>One of them is what <i>you</i> think the natural numbers are.  For you, the natural numbers are just 0, 1, 2, 3, ..., with the usual way of adding and multiplying them.  This is usually called the &#39;standard model&#39; of Peano arithmetic.  The numbers 0, 1, 2, 3, ... are called the &#39;standard&#39; natural numbers.</p>

<p>But there are also <a href="https://en.wikipedia.org/wiki/Non-standard_model_of_arithmetic">nonstandard models of arithmetic</a>.   These models contain extra numbers beside the standard ones!  These are called &#39;nonstandard&#39; natural numbers.</p>

<p>This takes a while to get used to.  There are several layers of understanding to pass through.</p>

<p>For starters, you should think of these extra &#39;nonstandard&#39; natural numbers as bigger than all the standard ones.  So, imagine a whole bunch of extra numbers tacked on after the standard natural numbers, with the operations of addition and multiplication cleverly defined in such a way that all the usual axioms still hold.</p>

<p>You can&#39;t just tack on finitely many extra numbers and get this to work.  But there can be countably many, or uncountably many.  There are infinitely many different ways to do this.  They are all rather hard to describe.</p>

<p>To get a handle on them, it helps to realize this.   Suppose you have a statement S in arithmetic that is neither provable nor disprovable from the Peano aioms.  Then S will hold in some models of Peano arithmetic, while its negation not(S) will hold in some other models.  </p>

<p>For example, the Gödel sentence G says &#34;this sentence is not provable from the Peano axioms&#34;.  If Peano arithmetic is consistent, neither G nor not(G) is provable in Peano arithmetic.  So G holds in some models, while not(G) holds in others.</p>

<p>Thus, you can intuitively think of different models as &#34;possible worlds&#34;.   If you have an undecidable statement, meaning one that you can&#39;t prove or disprove using the Peano axioms, then it holds in some worlds, while its negation holds in other worlds.</p>

<p>In the case of the Gödel sentence G, most mathematicians think G is &#34;true&#34;.  Why the quotes?  Truth is a slippery concept in logic — there&#39;s no precise definition of what it means for a sentence in arithmetic to be &#34;true&#34;.  All we can precisely define is:</p>

<p>1) whether or not a sentence is provable from some axioms</p>

<p>and</p>

<p>2) whether or not a sentence holds in some model.</p>

<p>Nonetheless, mathematicians are human, so they have beliefs about what&#39;s true.  Many mathematicians believe that G is true: indeed, in popular accounts one often hears that G is &#34;true but unprovable from the Peano axioms&#34;.   So, these mathematicians are inclined to say that any model where G doesn&#39;t hold is nonstandard.</p>

<p>Anyway, what is Joel David Hamkins&#39; result?  It&#39;s this:</p>

<blockquote>
There is a Turing machine T with the following property.  For any function \(f\) from the natural numbers to the natural numbers, there is a model of Peano arithmetic such that <em>in this model</em>, if we give T any standard natural \(n\) as input, it halts and outputs \(f(n).\)</blockquote>

<p>So, take \(f\) to be your favorite uncomputable function.  Then there&#39;s a model of arithmetic such that <em>in this model</em>, the Turing machine computes \(f,\) at least when you feed the machine standard numbers as inputs.</p>

<p>So, <em>very very</em> roughly, there&#39;s a possible world in which your uncomputable function becomes computable!</p>

<p>But you have to be very careful about how you interpret this result.</p>

<p>What&#39;s the trick?  The proof is beautiful, but it would take real work to improve on <a href="http://jdh.hamkins.org/every-function-can-be-computable/">Hamkins&#39; blog article</a>, so please read that.  I&#39;ll just say that he makes extensive use of <a href="https://en.wikipedia.org/wiki/Rosser&#39;s_trick">Rosser sentences</a>, which say:</p>

<blockquote>
For any proof of this sentence in theory T, there is a smaller proof of the negation of this sentence.
</blockquote>

<p>Rosser sentences are already mind-blowing, but Hamkins uses an <i>infinite sequence</i> of such sentences and their negations, chosen in a way that depends on the function \(f,\) to cleverly craft a model of arithmetic in which the Turing machine T computes this function on standard inputs.</p>

<p>But what&#39;s really going on?  How can using a nonstandard model make an uncomputable function become computable for standard natural numbers?  Shouldn&#39;t nonstandard models agree with the standard one on this issue?  After all, the only difference is that they have extra nonstandard numbers tacked on after all the standard ones!   How can that make a Turing machine succeed in computing \(f\) on <em>standard</em> natural numbers?</p>

<p>I&#39;m not 100% sure, but I think I know the answer.  I hope some logicians will correct me if I&#39;m wrong.</p>

<p>You have to read the result rather carefully:</p>

<blockquote>
There is a Turing machine T with the following property.  For any function \(f\) from the natural numbers to the natural numbers, there is a model of Peano arithmetic such that <em>in this model</em>, if we give T any standard natural \(n\) as input, it halts and computes \(f(n).\)
</blockquote>

<p>When we say the Turing machine halts, we mean it halts after \(N\) steps for some natural number \(N.\)  But this may not be a standard natural number!  It&#39;s a natural number in the model we&#39;re talking about.</p>

<p>So, the Turing machine halts... but perhaps only after a nonstandard number of steps.</p>

<p>In short: you can compute the uncomputable, but only if you&#39;re willing to wait long enough.  <i>You may need to wait a nonstandard amount of time</i>.</p>

<p>It&#39;s like that old Navy saying:</p>

<p><img src="https://johncarlosbaez.files.wordpress.com/2016/04/the-difficult-we-do-immediately-the-impossible-takes-a-little-longer.jpg?w=450" alt="the-difficult-we-do-immediately-the-impossible-takes-a-little-longer" width="450" height="323"/></p>

<p>But the trick becomes more evident if you notice that _one single_ Turing machine T computes _different functions_ from the natural numbers to the natural numbers... in different models.  That&#39;s even weirder than computing an uncomputable function.</p>

<p>The only way to build a machine that computes \(n+1\) in one model and \(n+2\) in another to build a machine that doesn&#39;t halt in a standard amount of time in either model.  It only halts after a _nonstandard_ amount of time.  In one model, it halts and outputs \(n+1.\)  In another, it halts and outputs \(n+2.\)</p>

<h3> A scary possibility </h3>

<p>To dig a bit deeper — and this is where it gets a bit scary — we have to admit that the standard model is a somewhat elusive thing.  I certainly didn&#39;t define it when I said this:</p>

<blockquote>
For you, the natural numbers are just 0, 1, 2, 3, ..., with the usual way of adding and multiplying them.  This is usually called the &#39;standard model&#39; of Peano arithmetic.  The numbers 0, 1, 2, 3, ... are called the &#39;standard&#39; natural numbers.
</blockquote>

<p>The point is that &#34;0, 1, 2, 3, ...&#34; here is vague.  It makes sense if you already know what the standard natural numbers are.  But if you don&#39;t already know, those three dots aren&#39;t going to tell you!</p>

<p>You might say the standard natural numbers are those of the form 1 + ··· + 1, where we add 1 to itself some finite number of times.  But what does &#39;finite number&#39; mean here?  It means a standard natural number!  So this is circular.</p>

<p>So, conceivably, the concept of &#39;standard&#39; natural number, and the concept of &#39;standard&#39; model of Peano arithmetic, are more subjective than most mathematicians think.  Perhaps some of my &#39;standard&#39; natural numbers are nonstandard for you!</p>

<p>I think most mathematicians would reject this possibility... but not all.  Edward Nelson tackled it head-on in his marvelous book <i><a href="https://web.math.princeton.edu/~nelson/books/1.pdf">Internal Set Theory</a></i>.  He writes:</p>

<blockquote>
Perhaps it is fair to say that &#34;finite&#34; does not mean what we have always thought it to mean. What have we always thought it to mean? I used to think  that I knew what I had always thought it to mean, but I no longer think so.
</blockquote>

<p>If we go down this road, Hamkins&#39; result takes on a different significance.  It says that any subjectivity in the notion of &#39;natural number&#39; may also infect what it means for a Turing machine to halt, and what function a Turing machine computes when it does halt.</p>

<hr/>
© 2016  John Baez </div>
  </body>
</html>
