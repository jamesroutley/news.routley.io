<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.righto.com/2025/01/pentium-carry-lookahead-reverse-engineered.html">Original</a>
    <h1>Reverse-engineering a carry-lookahead adder in the Pentium</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-256338700959855937" itemprop="description articleBody">
<p>Addition is harder than you&#39;d expect, at least for a computer.
Computers use multiple types of adder circuits with different tradeoffs of size versus speed.
In this article, I reverse-engineer an 8-bit adder in the Pentium&#39;s floating point unit.
This adder turns out to be a carry-lookahead adder,
in particular, a type known as &#34;Kogge-Stone.&#34;<span id="fnref:kogge-stone"><a href="#fn:kogge-stone">1</a></span>
In this article, I&#39;ll explain how a carry-lookahead adder works and I&#39;ll show how the Pentium implemented it.
Warning: lots of Boolean logic ahead.</p>
<p><a href="https://static.righto.com/images/pentium-adder/pentium-labeled.jpg"><img alt="The Pentium die, showing the adder. Click this image (or any other) for a larger version." height="627" src="https://static.righto.com/images/pentium-adder/pentium-labeled-w600.jpg" title="The Pentium die, showing the adder. Click this image (or any other) for a larger version." width="600"/></a></p><p>The Pentium die, showing the adder. Click this image (or any other) for a larger version.</p>
<p>The die photo above shows the main functional units of the Pentium.
The adder, in the lower right, is a small component of the floating point unit.
It is not a general-purpose adder, but is used only for determining quotient digits during division.
It played a role in the famous
Pentium FDIV division bug, which I wrote about <a href="https://www.righto.com/2024/12/this-die-photo-of-pentium-shows.html">here</a>.</p>
<h2>The hardware implementation</h2>
<p>The photo below shows the carry-lookahead adder used by the divider.
The adder itself consists of the circuitry highlighted in red.
At the top, logic gates compute signals in parallel for each of the 8 pairs of inputs: partial sum, carry generate, and carry propagate.
Next, the complex carry-lookahead logic determines in parallel if there will be a carry at each position.
Finally, XOR gates apply the carry to each bit.
Note that the sum/generate/propagate circuitry consists of 8 repeated blocks, and the same with the carry XOR
circuitry.
The carry lookahead circuitry, however, doesn&#39;t have any visible structure since it is different for each bit.<span id="fnref:8bit"><a href="#fn:8bit">2</a></span></p>
<p><a href="https://static.righto.com/images/pentium-adder/adder-silicon.jpg"><img alt="The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray)." height="787" src="https://static.righto.com/images/pentium-adder/adder-silicon-w550.jpg" title="The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray)." width="550"/></a></p><p>The carry-lookahead adder that feeds the lookup table. This block of circuitry is just above the PLA on the die. I removed the metal layers, so this photo shows the doped silicon (dark) and the polysilicon (faint gray).</p>
<p>The large amount of circuitry in the middle is used for testing; see the footnote.<span id="fnref:testing"><a href="#fn:testing">3</a></span>
At the bottom, the drivers amplify control signals for various parts of the circuit.</p>
<h2>The carry-lookahead adder concept</h2>
<p>The problem with addition is that carries make addition slow.
Consider calculating 99999+1 by hand.
You&#39;ll start with 9+1=10, then carry the one, generating another carry, which generates another carry, and so forth, until you go through all the digits.
Computer addition has the same problem:
If you&#39;re adding two numbers, the low-order bits can generate a carry that then propagates through all the bits.
An adder that works this way—known as a ripple carry adder—will be slow because the carry has to ripple through
all the bits.
As a result, CPUs use special circuits to make addition faster.</p>
<p>One solution is the carry-lookahead adder. In this adder, all the carry bits are computed in parallel, before computing
the sums. Then, the sum bits can be computed in parallel, using the carry bits.
As a result, the addition can be completed quickly, without waiting for the carries to ripple through
the entire sum.</p>
<p>It may seem impossible to compute the carries without computing the sum first, but there&#39;s a way to do it.
For each bit position, you determine signals called &#34;carry generate&#34; and &#34;carry propagate&#34;.
These signals can then be used to determine all the carries in parallel.
The <em>generate</em> signal indicates that the position generates a carry. For instance, if you add binary
<code>1xx</code> and <code>1xx</code> (where <code>x</code> is an arbitrary bit), a carry will be generated from the top bit,
regardless of the unspecified bits.
On the other hand, adding <code>0xx</code> and <code>0xx</code> will never produce a carry.
Thus, the <em>generate</em> signal is produced for the first case but not the second.</p>
<p>But what about <code>1xx</code> plus <code>0xx</code>? We might get a carry, for instance, <code>111+001</code>, but we might not get a carry,
for instance, <code>101+001</code>. In this &#34;maybe&#34; case, we set the <em>carry propagate</em> signal, indicating that a carry into the
position will get propagated out of the position. For example, if there is a carry out of
the middle position, <code>1xx+0xx</code> will have a carry from the top bit. But if there is no carry out of the middle position, then
there will not be a carry from the top bit. In other words, the <em>propagate</em> signal indicates that a carry into the top bit will be propagated out of the top
bit.</p>
<p>To summarize, adding <code>1+1</code> will generate a carry. Adding <code>0+1</code> or <code>1+0</code> will propagate a
carry.
Thus, the <em>generate</em> signal is formed at each position by <em>G<sub>n</sub> = A<sub>n</sub>·B<sub>n</sub></em>, where <em>A</em> and <em>B</em> are the inputs.
The <em>propagate</em> signal is <em>P<sub>n</sub> = A<sub>n</sub>+B<sub>n</sub></em>,
the logical-OR of the inputs.<span id="fnref:propagate"><a href="#fn:propagate">4</a></span></p>
<p>Now that the <em>propagate</em> and <em>generate</em> signals are defined, they can be used to compute the carry <em>C<sub>n</sub></em> at
each bit position:
</p>
<p>The important thing about these equations is that they can be computed in parallel, without waiting for a
carry to ripple through each position.
Once each carry is computed, the sum bits can be computed in parallel: <em>S<sub>n</sub> = A<sub>n</sub> ⊕ B<sub>n</sub> ⊕ C<sub>n</sub></em>. In other words, the two input bits and the computed carry are combined with exclusive-or.</p>
<h2>Implementing carry lookahead with a parallel prefix adder</h2>
<p>The straightforward way to implement carry lookahead is to directly implement the equations above.
However, this approach requires a lot of circuitry due to the complicated equations.
Moreover, it needs gates with many inputs, which are slow for electrical reasons.<span id="fnref:74181"><a href="#fn:74181">5</a></span></p>
<p>The Pentium&#39;s adder implements the carry lookahead in a different way, called the &#34;parallel prefix adder.&#34;<span id="fnref:parallel-prefix"><a href="#fn:parallel-prefix">7</a></span>
The idea is to produce the propagate and generate signals across ranges of bits, not just single bits as before.
For instance, the <em>propagate</em> signal <em>P<sub>32</sub></em> indicates that a carry in to bit 2 would be propagated out of bit 3.
And <em>G<sub>30</sub></em> indicates that bits 3 to 0 generate a carry out of bit 3.</p>
<p>Using some mathematical tricks,<span id="fnref:pg"><a href="#fn:pg">6</a></span> you can take the <em>P</em> and <em>G</em> values for two smaller ranges and merge them into
the <em>P</em> and <em>G</em> values for the combined range.
For instance, you can start with the <em>P</em> and <em>G</em> values for bits 0 and 1, and produce <em>P<sub>10</sub></em> and <em>G<sub>10</sub></em>.
These could be merged with <em>P<sub>32</sub></em> and <em>G<sub>32</sub></em> to produce <em>P<sub>30</sub></em> and <em>G<sub>30</sub></em>,
indicating if a carry is propagated across bits 3-0 or generated by bits 3-0.
Note that <em>G<sub>n0</sub></em> is the carry-lookahead value we need for bit <em>n</em>, so producing these <em>G</em> values gives 
the results that we need from the carry-lookahead implementation.</p>
<p>This merging process is more efficient than the &#34;brute force&#34; implementation of the carry-lookahead logic since
logic subexpressions can be reused.
This merging process can be implemented in many ways, including 
<a href="https://en.wikipedia.org/wiki/Kogge%E2%80%93Stone_adder">Kogge-Stone</a>, <a href="https://en.wikipedia.org/wiki/Brent%E2%80%93Kung_adder">Brent-Kung</a>, and Ladner-Fischer.
The different algorithms have different tradeoffs of performance versus circuit area.
In the next section, I&#39;ll show how the Pentium implements the Kogge-Stone algorithm.</p>
<h2>The Pentium&#39;s implementation of the carry-lookahead adder</h2>
<p>The Pentium&#39;s adder is implemented with four layers of circuitry.
The first layer produces the <em>propagate</em> and <em>generate</em> signals (<em>P</em> and <em>G</em>) for each bit, along with a partial sum (the sum
without any carries).
The second layer merges pairs of neighboring <em>P</em> and <em>G</em> values, producing, for instance <em>G<sub>65</sub></em> and <em>P<sub>21</sub></em>.
The third layer generates the carry-lookahead bits by merging previous <em>P</em> and <em>G</em> values. 
This layer is complicated because it has different circuitry for each bit.
Finally, the fourth layer applies the carry bits to the partial sum, producing the final arithmetic sum.</p>
<p>Here is the schematic of the adder, from my reverse engineering.
The circuit in the upper left is repeated 8 times to produce the propagate, generate, and partial sum for
each bit. This corresponds to the first layer of logic.
At the left are the circuits to merge the <em>generate</em> and <em>propagate</em> signals across pairs of bits. These circuits
are the second layer of logic.</p>
<p><a href="https://static.righto.com/images/pentium-adder/adder-schematic.jpg"><img alt="Schematic of the Pentium&#39;s 8-bit carry-lookahead adder. Click for a larger version." height="522" src="https://static.righto.com/images/pentium-adder/adder-schematic-w500.jpg" title="Schematic of the Pentium&#39;s 8-bit carry-lookahead adder. Click for a larger version." width="500"/></a></p><p>Schematic of the Pentium&#39;s 8-bit carry-lookahead adder. Click for a larger version.</p>
<p>The circuitry at the right is the interesting part—it computes the carries in parallel and then computes the
final sum bits using XOR. This corresponds to the third and fourth layers of circuitry respectively.
The circuitry gets more complicated going from bottom to top as the bit position increases.</p>
<p>The diagram below is the standard diagram that illustrates how a
<a href="https://en.wikipedia.org/wiki/Kogge%E2%80%93Stone_adder">Kogge-Stone</a> adder works.
It&#39;s rather abstract, but I&#39;ll try to explain it.
The diagram shows how the <em>P</em> and <em>G</em> signals are merged to produce each output at the bottom. 
Each line coresponds to both the <em>P</em> and the <em>G</em> signal.
Each square box generates the <em>P</em> and <em>G</em> signals for that bit.
(Confusingly, the vertical and diagonal lines have the same meaning, indicating inputs going into a diamond
and outputs coming out of a diamond.)
Each diamond combines two ranges of <em>P</em> and <em>G</em> signals to generate new <em>P</em> and <em>G</em> signals for the combined
range.
Thus, the signals cover wider ranges as they progress downward, ending with the <em>G<sub>n0</sub></em> signals that
are the outputs.</p>
<p><a href="https://static.righto.com/images/pentium-adder/kogge-stone7.png"><img alt="A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, Wikimedia Commons." height="276" src="https://static.righto.com/images/pentium-adder/kogge-stone7-w350.png" title="A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, Wikimedia Commons." width="350"/></a></p><p>A diagram of an 8-bit Kogge-Stone adder highlighting the carry out of bit 6 (green) and out of bit 2 (purple). Modification of the diagram by Robey Pointer, <a href="https://commons.wikimedia.org/wiki/File:Kogge-stone-8-bit.png">Wikimedia Commons</a>.</p>
<p>It may be easier to understand the diagram by starting with the outputs.
I&#39;ve highlighted two circuits: The purple circuit computes the carry into bit 3 (out of bit 2),
while the green circuit computes the carry into bit 7 (out of bit 6).
Following the purple output upward, note that it forms a tree reaching bits 2, 1, and 0, so it generates the
carry based on these bits, as desired.
In more detail, the upper purple diamond combines the <em>P</em> and <em>G</em> signals for bits 2 and 1, generating <em>P<sub>21</sub></em> and <em>G<sub>21</sub></em>.
The lower purple diamond merges in <em>P<sub>0</sub></em> and <em>G<sub>0</sub></em> to create <em>P<sub>20</sub></em> and <em>G<sub>20</sub></em>.
Signal <em>G<sub>20</sub></em> indicates of bits 2 through 0 generate a carry; this is the desired carry value into bit 3.</p>
<p>Now, look at the green output and see how it forms a tree going upward, combining bits 6 through 0.
Notice how it takes advantage of the purple carry output, reducing the circuitry required.
It also uses <em>P<sub>65</sub></em>, <em>P<sub>43</sub></em>, and the corresponding <em>G</em> signals.
Comparing with the earlier schematic shows how the diagram corresponds to the schematic, but abstracts out
the details of the gates.</p>
<p>Comparing the diagram to the schematic, each square box corresponds to
to the circuit in the upper left of the schematic that generates <em>P</em> and <em>G</em>, the first layer of circuitry.
The first row of diamonds corresponds to the pairwise combination circuitry on the left of the schematic, the
second layer of circuitry.
The remaining diamonds correspond to the circuitry on the right of the schematic, with each column
corresponding to a bit, the third layer of circuitry. (The diagram ignores the final XOR step, the fourth layer of circuitry.)</p>
<p>Next, I&#39;ll show how the diagram above, the logic equations, and the schematic are related.
The diagram below shows the logic equation for <em>C<sub>7</sub></em> and how it is implemented with gates; this
corresponds to the green diamonds above.
The gates on the left below computes <em>G<sub>63</sub></em>; this corresponds to the middle green diamond on the left.
The next gate below computes <em>P<sub>63</sub></em> from <em>P<sub>65</sub></em> and <em>P<sub>43</sub></em>; this corresponds to
the same green diamond.
The last gates mix in <em>C<sub>3</sub></em> (the purple line above); this corresponds to the bottom green diamond.
As you can see, the diamonds abstract away the complexity of the gates.
Finally, the colored boxes below show how the gate inputs map onto the logic equation. Each input corresponds to multiple
terms in the equation (6 inputs replace 28 terms), showing how this approach reduces the circuitry required.</p>
<p><a href="https://static.righto.com/images/pentium-adder/term7.jpg"><img alt="This diagram shows how the carry into bit 7 is computed, comparing the equations to the logic circuit." height="300" src="https://static.righto.com/images/pentium-adder/term7-w450.jpg" title="This diagram shows how the carry into bit 7 is computed, comparing the equations to the logic circuit." width="450"/></a></p><p>This diagram shows how the carry into bit 7 is computed, comparing the equations to the logic circuit.</p>
<p>There are alternatives to the Kogge-Stone adder. For example, a <a href="https://en.wikipedia.org/wiki/Brent%E2%80%93Kung_adder">Brent-Kung adder</a> (below) uses a different arrangement with fewer diamonds but more layers. Thus, a Brent-Kung adder uses less circuitry but is slower.
(You can follow each output upward to verify that the tree reaches the correct inputs.)</p>
<p><a href="https://static.righto.com/images/pentium-adder/brent-kung.png"><img alt="A diagram of an 8-bit Brent-Kung adder. Diagram by Robey Pointer, Wikimedia Commons." height="300" src="https://static.righto.com/images/pentium-adder/brent-kung-w300.png" title="A diagram of an 8-bit Brent-Kung adder. Diagram by Robey Pointer, Wikimedia Commons." width="300"/></a></p><p>A diagram of an 8-bit Brent-Kung adder. Diagram by Robey Pointer, <a href="https://commons.wikimedia.org/wiki/File:Brent-kung-8-bit.png">Wikimedia Commons</a>.</p>
<h2>Conclusions</h2>
<p>The photo below shows the adder circuitry. I&#39;ve removed the top two layers of metal, leaving the bottom layer
of metal. Underneath the metal, polysilicon wiring and doped silicon regions are barely visible; they form
the transistors. At the top are eight blocks of gates to generate the partial sum, generate, and propagate signals
for each bit.
(This corresponds to the first layer of circuitry as described earlier.)
In the middle is the carry lookahead circuitry. It is irregular since each bit has different circuitry.
(This corresponds to the second and third layers of circuitry, jumbled together.)
At the bottom, eight XOR gates combine the carry lookahead output with the partial sum to produce the adder&#39;s output.
(This corresponds to the fourth layer of circuitry.)</p>
<p><a href="https://static.righto.com/images/pentium-adder/adder-m1.jpg"><img alt="The Pentium&#39;s adder circuitry with the top two layers of metal removed." height="362" src="https://static.righto.com/images/pentium-adder/adder-m1-w700.jpg" title="The Pentium&#39;s adder circuitry with the top two layers of metal removed." width="700"/></a></p><p>The Pentium&#39;s adder circuitry with the top two layers of metal removed.</p>
<p>The Pentium uses many adders for different purposes: in the integer unit, in the floating point unit, and for
address calculation, among others.
Floating-point division is known to use a carry-save adder to hold the partial remainder at each step;
see my post on the <a href="https://www.righto.com/2024/12/this-die-photo-of-pentium-shows.html">Pentium FDIV division bug</a> for details.
I don&#39;t know what types of adders are used in other parts of the chip, but maybe I&#39;ll reverse-engineer some of them.
Follow me on Bluesky (<a href="https://bsky.app/profile/righto.com">@righto.com</a>) or <a href="https://www.righto.com/feeds/posts/default">RSS</a> for updates. (I&#39;m no longer on Twitter.)</p>



</div></div>
  </body>
</html>
