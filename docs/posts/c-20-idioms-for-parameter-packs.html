<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.scs.stanford.edu/~dm/blog/param-pack.html">Original</a>
    <h1>C&#43;&#43;20 Idioms for Parameter Packs</h1>
    
    <div id="readability-page-1" class="page">
 

<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#overview-of-variadic-templates" id="toc-overview-of-variadic-templates">Overview of variadic
templates</a>
<ul>
<li><a href="#expanding-parameter-packs" id="toc-expanding-parameter-packs">Expanding parameter packs</a></li>
<li><a href="#sizeof...pack" id="toc-sizeof...pack"><code>sizeof...(pack)</code></a></li>
<li><a href="#folds" id="toc-folds">Folds</a></li>
<li><a href="#capturing-parameter-packs" id="toc-capturing-parameter-packs">Capturing parameter packs</a>
<ul>
<li><a href="#template-parameter-packs" id="toc-template-parameter-packs">Template parameter packs</a></li>
<li><a href="#function-parameter-packs" id="toc-function-parameter-packs">Function parameter packs</a></li>
<li><a href="#init-capture-packs" id="toc-init-capture-packs">Init-capture packs</a></li>
</ul></li>
</ul></li>
<li><a href="#idioms" id="toc-idioms">Idioms</a>
<ul>
<li><a href="#recursing-over-argument-lists" id="toc-recursing-over-argument-lists">Recursing over argument
lists</a></li>
<li><a href="#recursing-over-template-parameters" id="toc-recursing-over-template-parameters">Recursing over template
parameters</a></li>
<li><a href="#comma-fold" id="toc-comma-fold">Comma fold</a></li>
<li><a href="#short-circuiting-and-folds" id="toc-short-circuiting-and-folds">Short-circuiting
<code>&amp;&amp;</code> and <code>||</code> folds</a></li>
<li><a href="#using-lambda-expressions-to-capture-packs" id="toc-using-lambda-expressions-to-capture-packs">Using lambda
expressions to capture packs</a></li>
<li><a href="#using-lambda-expressions-to-capture-packs-in-requires-clauses" id="toc-using-lambda-expressions-to-capture-packs-in-requires-clauses">Using
lambda expressions to capture packs in requires clauses</a></li>
<li><a href="#using-decltype-on-lambda-expressions" id="toc-using-decltype-on-lambda-expressions">Using
<code>decltype</code> on lambda expressions</a></li>
<li><a href="#multilambda" id="toc-multilambda">Multilambda</a></li>
<li><a href="#recursive-types-through-inheritance" id="toc-recursive-types-through-inheritance">Recursive types through
inheritance</a></li>
<li><a href="#homogeneous-function-parameter-packs" id="toc-homogeneous-function-parameter-packs">Homogeneous function
parameter packs</a></li>
<li><a href="#array-of-function-pointers" id="toc-array-of-function-pointers">Array of function pointers</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
</ul>
</nav>

<p>C++11 introduced <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic">variadic
templates</a>, which permit type-safe functions to accept a variable
number of arguments. They also permit template types such as <a href="https://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>
that can hold a variable number of elements. The main language mechanism
enabling variadic templates is <a href="https://en.cppreference.com/w/cpp/language/parameter_pack"><em>parameter
packs</em></a>, which hold an arbitrary number of values or types. Some
things are easy to do with parameter packs—for instance, passing the
values they comprise to a function. Other tasks are a bit trickier to
accomplish, such as iterating over a parameter pack or extracting
specific elements. However, these things can generally be accomplished
through various idioms, some more unwieldy than others.</p>
<p>Between C++11 and C++20, the language gained several improvements to
variadic templates. Improvements to other features, such as concepts and
lambdas, have also created new options for manipulating parameter packs,
thereby enabling new variadic template idioms. This post lays out a
grab-bag of techniques for using parameter packs in C++20. Ideally,
cataloging these tricks makes it easier for people to do what they need
with variadic templates. My interest in producing a clean C++20-focused
exposition stems from a conjecture that variadic templates are easier to
learn to use without the baggage of how we used to do things in C++17
and earlier. Moreover, even if a lot of the idioms are obvious at a high
level, they provide a good context in which to showcase some of the new
features of C++20.</p>

<p>A variadic template is a template whose definition captures a
<em>parameter pack</em> in its template arguments or function arguments.
A parameter pack is captured by introducing an identifier prefixed by an
ellipsis, as in <code>...X</code>. Once captured, a parameter pack can
later be used in a <em>pattern</em> expanded by an ellipsis (generally,
but not always, to the right of the pattern). Pack expansion is
conceptually equivalent to having one copy of the pattern for each
element of the parameter pack. Here’s a silly example of a program that
prints “<code>one two</code> ”:</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>void</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>print_strings<span>(</span><span>std::</span>convertible_to<span>&lt;</span><span>std::</span>string_view<span>&gt;</span> <span>auto</span><span>&amp;&amp;</span> <span>...</span>s<span>)</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span>{</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span>for</span> <span>(</span><span>auto</span> v <span>:</span> <span>std::</span>initializer_list<span>&lt;</span><span>std::</span>string_view<span>&gt;{</span> s<span>...</span> <span>})</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span>std::</span>cout<span> &lt;&lt;</span> v <span>&lt;&lt;</span> <span>&#34; &#34;</span><span>;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span>std::</span>cout<span> &lt;&lt;</span> <span>std::</span>endl<span>;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span>}</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span>int</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>main<span>()</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span>{</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>  print_strings<span>(</span><span>&#34;one&#34;</span><span>,</span> <span>std::</span>string<span>{</span><span>&#34;two&#34;</span><span>});</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span>}</span></span></code></pre></div>
<p>The <code>print_strings</code> function takes an arbitrary number of
arguments, all of which are captured by the parameter pack
<code>...s</code> in line 2. In line 4, this parameter pack is expanded
as <code>s...</code> to specify the values from which to construct an
<code>initializer_list</code>. We then iterate over the
<code>initializer_list</code> to print the strings.</p>
<p>As a reminder, the appearance of the placholder <code>auto</code> in
the arguments of <code>print_strings</code> makes
<code>print_strings</code> an <a href="https://timsong-cpp.github.io/cppwp/n4861/dcl.fct#18">abbreviated
function template</a>, which introduces an implicit template type
parameter for each occurrence of the placeholder. The use of
<code>auto&amp;&amp;</code> as opposed to <code>auto</code> or
<code>auto&amp;</code> is known as a <a href="https://timsong-cpp.github.io/cppwp/n4861/temp.deduct.call#3">forwarding
reference</a>, which can accept both lvalue and rvalue references (a
confusing syntax since in most contexts postfix <code>&amp;&amp;</code>
matches only rvalue references).<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a> We need the universality
of a forwarding reference because <code>&#34;one&#34;</code> is an lvalue (of
type <code>const char(&amp;)[4]</code>) while
<code>std::string{&#34;two&#34;}</code> is a prvalue—the former cannot be
captured by rvalue reference and the latter cannot be captured by
non-const lvalue reference.<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> Finally, note that the
<a href="https://en.cppreference.com/w/cpp/language/constraints">type-constraint</a>
<a href="https://en.cppreference.com/w/cpp/concepts/convertible_to"><code>convertible_to</code></a>
restricts the types that match the template argument; without this
constraint, the program would still work, but invocations of
<code>print_strings</code> with incompatible types would create less
intuitive error messages and, worse, any overloads of the
<code>print_strings</code> function would cause ambiguity errors.</p>
<h2 id="expanding-parameter-packs">Expanding parameter packs</h2>
<p>A captured parameter pack must be used in a <em>pattern</em> that is
<em>expanded</em> with an ellipsis (<code>...</code>). A pattern is a
set of tokens containing the identifiers of one or more parameter packs.
When a pattern contains more than one parameter pack, all packs must
have the same length. This length determines the number of times the
pattern is conceptually replicated in the expansion, once for each
position in the expanded pack(s). Here’s a simple example:</p>
<div id="expand"><pre><code><span id="expand-1"><a href="#expand-1"></a><span>void</span> dummy<span>(</span><span>auto</span><span>&amp;&amp;...)</span> <span>{}</span></span>
<span id="expand-2"><a href="#expand-2"></a></span>
<span id="expand-3"><a href="#expand-3"></a><span>template</span><span>&lt;</span><span>std::</span>same_as<span>&lt;</span><span>char</span><span>&gt;</span> <span>...</span>C<span>&gt;</span></span>
<span id="expand-4"><a href="#expand-4"></a><span>void</span></span>
<span id="expand-5"><a href="#expand-5"></a>expand<span>(</span>C<span>...</span>c<span>)</span></span>
<span id="expand-6"><a href="#expand-6"></a><span>{</span></span>
<span id="expand-7"><a href="#expand-7"></a>  <span>std::</span>tuple<span>&lt;</span>C<span>...&gt;</span> tpl<span>(</span>c<span>...);</span></span>
<span id="expand-8"><a href="#expand-8"></a></span>
<span id="expand-9"><a href="#expand-9"></a>  <span>const</span> <span>char</span> msg<span>[]</span> <span>=</span> <span>{</span> C<span>(</span><span>std::</span>toupper<span>(</span>c<span>))...,</span> <span>&#39;</span><span>\0</span><span>&#39;</span> <span>};</span></span>
<span id="expand-10"><a href="#expand-10"></a>  dummy<span>(</span>msg<span>,</span> c<span>...);</span></span>
<span id="expand-11"><a href="#expand-11"></a><span>}</span></span></code></pre></div>
<p>In line 3, the function <code>expand</code> captures a template
parameter pack <code>C</code> consisting of a sequence of zero or more
types, all of which must be <code>char</code> because of our use of the
<a href="https://en.cppreference.com/w/cpp/concepts/same_as"><code>std::same_as</code></a>
concept. In line 5, we capture a function parameter pack <code>c</code>
consisting of a sequence of values <span><em>c</em><sub><em>i</em></sub></span> each of type
<span><em>C</em><sub><em>i</em></sub></span> for the
<span><em>i</em></span>th position in parameter pack
<code>C</code>. (Of course, in this example every <span><em>C</em><sub><em>i</em></sub></span> is
<code>char</code>.) We then see several contexts in which these packs
are expanded:</p>
<ul>
<li><p>In line 7, <code>tuple&lt;C...&gt;</code> expands the pack
<code>C</code> in a <em>template-argument-list</em>, while
<code>tpl(c...)</code> expands <code>c</code> in an <a href="https://timsong-cpp.github.io/cppwp/n4868/dcl.init.general#nt:initializer-list"><em>initializer-list</em></a>
(which, not to be confused with <code>std::initializer_list</code>, is
the term in the C++ grammar for comma-separated lists of expressions
passed as arguments to function calls and constructors).</p></li>
<li><p>In line 9, we expand the pattern <code>C(std::toupper(c))</code>
in another initializer list. This is an example of a pattern with two
packs, <code>C</code> and <code>c</code>, both of which have the same
length and are expanded in lockstep. (<a href="https://en.cppreference.com/w/cpp/string/byte/toupper"><code>std::toupper</code></a>
returns <code>int</code> rather than <code>char</code>, so its result
requires a cast, though we could equivalently have written
<code>char(std::toupper(c))...</code> in this case.)</p></li>
<li><p>In line 10, we again expand <code>c</code> in an initializer
list.</p></li>
</ul>
<p>In most cases, an expanded pattern is conceptually equivalent to a
number of copies of the pattern equal to the size of the parameter pack.
Unless otherwise noted, a pattern is expanded by appending an ellipsis
(<code>...</code>). It is illegal to use a captured parameter pack
except in a pattern expanded by an ellipsis. Here is the list of <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#5">contexts</a>
in which a pattern can be expanded:</p>
<ul>
<li><p>In <strong>initializer-lists</strong> (as shown above), including
pack expansion in the arguments to a function call. Conceptually, such a
pack expansion is equivalent to a comma-separated list of instances of
the pattern.</p></li>
<li><p>In <strong>base specifier lists</strong>, to specify one base
class for each member of a type parameter pack, e.g.:</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>Base<span>&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> MyStruct <span>:</span>  Base<span>...</span> <span>{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        MyStruct<span>();</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span></code></pre></div></li>
<li><p>When initializing base classes in a <strong>mem-initializer
list</strong> in a class constructor, the pack expansion initializes a
list of base classes based on a type parameter pack:</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>Base<span>&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    MyStruct<span>&lt;</span>Base<span>...&gt;::</span>MyStruct<span>()</span> <span>:</span> Base<span>()...</span> <span>{}</span></span></code></pre></div></li>
<li><p>In <strong>template argument lists</strong> as in
<code>std::tuple&lt;C...&gt;</code>, the pack expands to the equivalent
of a comma-separated list of template arguments.</p></li>
<li><p>In lambda <strong>capture lists</strong>, the pattern expansion
is equivalent to a comma-separated list of captures. E.g.,</p>
<div id="capture-pattern"><pre><code><span id="capture-pattern-1"><a href="#capture-pattern-1" aria-hidden="true" tabindex="-1"></a>    <span>void</span></span>
<span id="capture-pattern-2"><a href="#capture-pattern-2" aria-hidden="true" tabindex="-1"></a>    f<span>(</span><span>auto</span><span>...</span>arg<span>)</span></span>
<span id="capture-pattern-3"><a href="#capture-pattern-3" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="capture-pattern-4"><a href="#capture-pattern-4" aria-hidden="true" tabindex="-1"></a>      <span>auto</span> with_copy <span>=</span> <span>[</span>arg<span>...]{</span></span>
<span id="capture-pattern-5"><a href="#capture-pattern-5" aria-hidden="true" tabindex="-1"></a>        <span>/* do something with arg... */</span></span>
<span id="capture-pattern-6"><a href="#capture-pattern-6" aria-hidden="true" tabindex="-1"></a>      <span>};</span></span>
<span id="capture-pattern-7"><a href="#capture-pattern-7" aria-hidden="true" tabindex="-1"></a>      with_copy<span>();</span></span>
<span id="capture-pattern-8"><a href="#capture-pattern-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="capture-pattern-9"><a href="#capture-pattern-9" aria-hidden="true" tabindex="-1"></a>      <span>auto</span> with_reference <span>=</span> <span>[&amp;</span>arg<span>...]{</span></span>
<span id="capture-pattern-10"><a href="#capture-pattern-10" aria-hidden="true" tabindex="-1"></a>        <span>/* do something with arg... */</span></span>
<span id="capture-pattern-11"><a href="#capture-pattern-11" aria-hidden="true" tabindex="-1"></a>      <span>};</span></span>
<span id="capture-pattern-12"><a href="#capture-pattern-12" aria-hidden="true" tabindex="-1"></a>      with_reference<span>();</span></span>
<span id="capture-pattern-13"><a href="#capture-pattern-13" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span></code></pre></div></li>
<li><p>Inside <strong>function parameters</strong> and <strong>template
parameters</strong>, a pack expansion behaves like a comma separated
list of patterns. An example in function parameters is the expansion
<code>C</code> in the definition of <code>expand(C...c)</code>, <a href="#expand-5">above</a>. An example in template parameters is the
expansion of <code>T</code> in <code>Inner</code>, here:</p>
<div id="Outer"><pre><code><span id="Outer-1"><a href="#Outer-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span> <span>struct</span> Outer <span>{</span></span>
<span id="Outer-2"><a href="#Outer-2" aria-hidden="true" tabindex="-1"></a>      <span>template</span><span>&lt;</span>T<span>...</span>V<span>&gt;</span> <span>struct</span> Inner <span>{</span></span>
<span id="Outer-3"><a href="#Outer-3" aria-hidden="true" tabindex="-1"></a>      <span>};</span></span>
<span id="Outer-4"><a href="#Outer-4" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span></code></pre></div>
<p>Note how in these these cases, the ellipsis plays double-duty,
serving at once to expand one parameter pack and capture another. The
<code>...</code> must always immediately precede the identifier of the
captured parameter pack. This means the ellipsis falls in the middle of
the pattern for arrays and function types, rather than at the end, but
the pattern is still expanded as usual. For example:</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>std::</span>size_t<span> ...</span>N<span>&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span>void</span> process_strings<span>(</span><span>const</span> <span>char</span> <span>(&amp;...</span>s<span>)[</span>N<span>])</span> <span>{</span> <span>/* ... */</span> <span>}</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span>// conceptually like:</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span>// process_strings(const char s1[N1], const char s2[N2], etc.)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span>auto</span> function_results<span>(</span>T <span>(&amp;...</span>f<span>)())</span> <span>{</span> <span>return</span> <span>std::</span>tuple<span>(</span>f<span>()...);</span> <span>}</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span>// conceptually like:</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span>// function_results(T1(&amp;f1)(), T2(&amp;f2)(), etc.)</span></span></code></pre></div></li>
<li><p>In a <strong>using declaration</strong>, the pattern conceptually
expands to a list of <code>using</code> declarations.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>Base<span>&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> MyStruct <span>:</span>  Base<span>...</span> <span>{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        MyStruct<span>();</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span>using</span> Base<span>::</span>f<span>...;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span>// Conceptually equivalent to:</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span>//   using Base_1::f;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span>//   using Base_2::f;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span>//   ...</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span></code></pre></div>
<p>Obviously a <code>using</code> pattern is most useful when the method
<code>f</code> of each base class in the pack has a different type
signature—otherwise invoking <code>f</code> would be ambiguous. See <a href="#multilambda">multilambda</a> for a great use of
<code>using</code> patterns.</p></li>
<li><p>In an <strong>alignment specifier</strong>, the argument must be
a single parameter pack and the ellipsis goes inside the
<code>alignas</code> operator. The result is an alignment restriction
compatible with all the types (if the pack expands to types) or all the
powers of two (if the pack expands to integer powers of two). In the
following example, the type <code>storage&lt;int, void*&gt;</code> would
be aligned to an address compatible with both <code>int</code> and
<code>void*</code>. (Note also the expansion <code>sizeof(T)...</code>
inside braces to create a
<code>std::initializer_list&lt;std::size_t&gt;</code> argument for
<code>std::max</code>.)</p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> <span>alignas</span><span>(</span>T<span>...)</span> storage <span>{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      <span>char</span> contents<span>[</span><span>std::</span>max<span>({</span> <span>sizeof</span><span>(</span>T<span>)...</span> <span>})];</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span></code></pre></div></li>
<li><p>The <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#5.8">standard</a>
also allows for pack expansions inside <strong>attribute lists</strong>.
However, this feature does not apply to any standard attributes, and
must be intended for compiler-specific ones.</p></li>
</ul>
<p>While a pack expansion mostly behaves like a series of copies of the
pattern, it is <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#example-6">okay</a>
to have a pack of size zero even when the program wouldn’t otherwise be
syntactically well formed. For example, while <code>f(x,)</code> and
<code>struct MyStruct : {};</code> are not valid C++ syntax,
<code>f(x, pack...)</code> and
<code>struct MyStruct : Base... {};</code> are okay even with empty
parameter packs for <code>pack</code> and <code>Base</code>.</p>
<p>A pattern may itself contain an expanded parameter pack, in which
case there is no need for the inner and outer packs to contain the same
number of elements. The expansion of the inner pack simply becomes part
of the pattern around the outer pack. For example:</p>
<div id="sum"><pre><code><span id="sum-1"><a href="#sum-1" aria-hidden="true" tabindex="-1"></a>    <span>constexpr</span> <span>int</span></span>
<span id="sum-2"><a href="#sum-2" aria-hidden="true" tabindex="-1"></a>    sum<span>(</span><span>std::</span>convertible_to<span>&lt;</span><span>int</span><span>&gt;</span> <span>auto</span> <span>...</span>il<span>)</span></span>
<span id="sum-3"><a href="#sum-3" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="sum-4"><a href="#sum-4" aria-hidden="true" tabindex="-1"></a>      <span>int</span> r <span>=</span> <span>0</span><span>;</span></span>
<span id="sum-5"><a href="#sum-5" aria-hidden="true" tabindex="-1"></a>      <span>for</span> <span>(</span><span>int</span> i <span>:</span> <span>{</span> <span>int</span><span>(</span>il<span>)...</span> <span>})</span></span>
<span id="sum-6"><a href="#sum-6" aria-hidden="true" tabindex="-1"></a>        r <span>+=</span> i<span>;</span></span>
<span id="sum-7"><a href="#sum-7" aria-hidden="true" tabindex="-1"></a>      <span>return</span> r<span>;</span></span>
<span id="sum-8"><a href="#sum-8" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="sum-9"><a href="#sum-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="sum-10"><a href="#sum-10" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>int</span> <span>...</span>N<span>&gt;</span></span>
<span id="sum-11"><a href="#sum-11" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> Nested <span>{</span></span>
<span id="sum-12"><a href="#sum-12" aria-hidden="true" tabindex="-1"></a>      <span>static</span> <span>constexpr</span> <span>int</span> nested_sum<span>(</span><span>auto</span> <span>...</span>v<span>)</span> <span>{</span></span>
<span id="sum-13"><a href="#sum-13" aria-hidden="true" tabindex="-1"></a>        <span>return</span> sum<span>(</span>sum<span>(</span>N<span>...,</span> v<span>)...);</span></span>
<span id="sum-14"><a href="#sum-14" aria-hidden="true" tabindex="-1"></a>      <span>}</span></span>
<span id="sum-15"><a href="#sum-15" aria-hidden="true" tabindex="-1"></a>    <span>};</span></span>
<span id="sum-16"><a href="#sum-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="sum-17"><a href="#sum-17" aria-hidden="true" tabindex="-1"></a>    <span>static_assert</span><span>(</span>Nested<span>&lt;</span><span>1</span><span>&gt;::</span>nested_sum<span>(</span><span>100</span><span>,</span> <span>200</span><span>)</span> <span>==</span> <span>302</span><span>);</span></span>
<span id="sum-18"><a href="#sum-18" aria-hidden="true" tabindex="-1"></a>    <span>// Equivalent to:  sum(sum(1, 100),sum(1, 200)) == 302</span></span></code></pre></div>
<p>It is worth noting that a pack expansion is <em>not</em> valid
outside of the contexts listed above. In particular, you cannot expand a
free-floating expression (though see <a href="#folds">folds</a> below),
and you cannot expand a <code>case</code> clause in a
<code>switch</code> statement.</p>
<h2 id="sizeof...pack"><code>sizeof...(pack)</code></h2>
<p>The <a href="https://timsong-cpp.github.io/cppwp/n4868/expr.sizeof#4"><code>sizeof...</code>
operator</a> returns a <code>std::size_t</code> corresponding to the
number of elements in a parameter pack. While technically considered a
pack expansion, it only ever returns a single value. Unlike ordinary
<code>sizeof</code>, the argument to <code>sizeof...</code> <a href="https://timsong-cpp.github.io/cppwp/n4868/expr.unary#general-1">must
always be</a> parenthesized and consist of a single identifier naming a
parameter pack.</p>
<h2 id="folds">Folds</h2>
<p>Another special form of pack expansion is <a href="https://timsong-cpp.github.io/cppwp/n4868/temp.variadic#10">folds</a>,
introduced in C++17. Above, we showed a function <a href="#sum"><code>sum</code></a> that summed a set of integers. This
function can be implemented far more concisely with a fold:</p>
<div id="sum2"><pre><code><span id="sum2-1"><a href="#sum2-1" aria-hidden="true" tabindex="-1"></a>    <span>constexpr</span> <span>int</span></span>
<span id="sum2-2"><a href="#sum2-2" aria-hidden="true" tabindex="-1"></a>    sum<span>(</span><span>std::</span>convertible_to<span>&lt;</span><span>int</span><span>&gt;</span> <span>auto</span> <span>...</span>i<span>)</span></span>
<span id="sum2-3"><a href="#sum2-3" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="sum2-4"><a href="#sum2-4" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>(</span><span>0</span> <span>+</span> <span>...</span> <span>+</span> i<span>);</span></span>
<span id="sum2-5"><a href="#sum2-5" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span></code></pre></div>
<p>Folds are defined in terms of the grammar rule for a <a href="https://timsong-cpp.github.io/cppwp/n4868/expr.cast#nt:cast-expression"><em>cast-expression</em></a>,
which is a C++ expression whose outer operators bind at least a tightly
(i.e., have <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">precedence</a>
at least as high as) the C-style cast operator <code>(Type) val</code>.
As an example, <code>&amp;p[5]</code> is a cast-expression, because the
left-associative subscript (<code>[]</code>) operator binds more tightly
than a cast, while the right associative address-of operator
(<code>&amp;</code>) has the same precedence as a cast. By contrast, the
expression <code>3*i</code> is not a cast-expression, because binary
<code>*</code> has lower precedence than a cast. Parenthesizing an
expression with lower-precedence operators, such as <code>(3*i)</code>,
makes it into a cast-expression.</p>
<p>There are four types of fold in C++. In these examples, let
<code>pat</code> be a cast-expression containing one more more
unexpanded parameter packs (i.e., a pattern). Let <code>e</code> be a
normal cast-expression without any unexpanded parameter packs. Let <span><em>p</em><sub>1</sub>, …, <em>p</em><sub><em>n</em></sub></span>
be the instances of <code>pat</code> corresponding to each element
captured by <code>pat</code>’s unexpanded parameter packs. Let <span>⊕</span> stand for any binary operator in the C++
grammar (<code>.*</code>, <code>-&gt;*</code>, <code>*</code>,
<code>/</code>, <code>%</code>, <code>+</code>, <code>-</code>,
<code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&lt;=&gt;</code>,
<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>,
<code>&gt;=</code>, <code>==</code>, <code>!=</code>,
<code>&amp;</code>, <code>^</code>, <code>|</code>,
<code>&amp;&amp;</code>, <code>||</code>, <code>=</code>,
<code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>,
<code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>,
<code>&amp;=</code>, <code>^=</code>, <code>|=</code>, or the comma
operator “<code>,</code>”).</p>
<p>A <strong>binary left fold</strong> has the form <code>(e</code><span>⊕</span><code>...</code><span>⊕</span><code>pat)</code> and is equivalent to
<code>(((e</code><span> ⊕ <em>p</em><sub>1</sub></span><code>)</code><span> ⊕ <em>p</em><sub>2</sub></span><code>)</code><span> ⊕ ⋯</span><code>)</code><span> ⊕ <em>p</em><sub><em>n</em></sub></span>.</p>
<p>A <strong>unary left fold</strong> has the form
<code>(...</code><span>⊕</span><code>pat)</code> and
is equivalent to <code>((</code><span><em>p</em><sub>1</sub> ⊕ <em>p</em><sub>2</sub></span><code>)</code><span> ⊕ ⋯</span><code>)</code><span> ⊕ <em>p</em><sub><em>n</em></sub></span>.</p>
<p>A <strong>binary right fold</strong> has the form
<code>(pat</code><span>⊕</span><code>...</code><span>⊕</span><code>e)</code> and is equivalent to <span><em>p</em><sub>1</sub>⊕</span><code>(</code><span><em>p</em><sub>2</sub>⊕</span><code>(</code><span>⋯⊕</span><code>(</code><span><em>p</em><sub><em>n</em></sub>⊕</span><code>e)))</code>.</p>
<p>A <strong>unary right fold</strong> has the form
<code>(pat</code><span>⊕</span><code>...)</code> and
is equivalent to <span><em>p</em><sub>1</sub>⊕</span><code>(</code><span><em>p</em><sub>2</sub>⊕</span><code>(</code><span>⋯ ⊕ <em>p</em><sub><em>n</em></sub></span><code>))</code>.</p>
<p>Note that parentheses are always required around a fold, regardless
of context.</p>
<p>When the parameter pack is empty (has size 0), a binary fold is
equivalent to <code>e</code>. A unary fold over an empty parameter pack
is only permitted for 3 specific binary operators:</p>
<ul>
<li>If <span>⊕</span> is <code>&amp;&amp;</code>,
then an empty unary fold is equivalent to <code>true</code>.</li>
<li>If <span>⊕</span> is <code>||</code>, then an
empty unary fold is equivalent to <code>false</code>.</li>
<li>If <span>⊕</span> is the comma operator
<code>,</code>, then an empty unary fold is equivalent to
<code>void()</code>.</li>
</ul>
<p>For all other binary operators, a unary fold over an empty parameter
pack results in an ill-formed program.</p>
<h2 id="capturing-parameter-packs">Capturing parameter packs</h2>
<p>While parameter packs can be expanded in a variety of places, they
can only be captured in a much more restricted set of contexts. There’s
an appealing proposal for <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1061r0.html">allowing
parameter packs in structured bindings</a>, which would simplify a lot
of idioms, but as of now there are only three contexts in which you can
introduce a new pack: template parameter packs, function parameter
packs, and init-capture packs. In all cases, the ellipsis must appear
immediately to the left of the identifier capturing the parameter pack
(<code>...X</code>).</p>
<h3 id="template-parameter-packs">Template parameter packs</h3>
<p>Template parameter packs consist of types, templates, and values
within the angle brackets of a template definition. Any normal template
parameter can be turned into a pack by prefixing the identifier with an
ellipsis. For example:</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span> <span>struct</span> S1<span>{};</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>int</span> <span>...</span>I<span>&gt;</span> <span>struct</span> S2<span>{};</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span><span>&gt;</span> <span>typename</span> <span>...</span>Tmpls<span>&gt;</span> <span>struct</span> S3<span>{};</span></span></code></pre></div>
<p>With two exceptions, a template parameter pack must generally be the
last entry in the template parameter list. The first exception is for
function templates, where template arguments can be inferred from the
function arguments. So long as every template parameter following a
captured parameter pack can be inferred, it is okay for the pack not to
be last. The second exception is in template specializations, where
captured packs may be used in the specialization. For example:</p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>    <span>// Illegal for pack not to be last</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T1<span>,</span> <span>typename</span> <span>...</span>T2<span>&gt;</span> <span>struct</span> S<span>{};</span> <span>// error</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    S<span>&lt;</span><span>int</span><span>,</span> <span>int</span><span>,</span> <span>bool</span><span>&gt;</span> a<span>;</span>  <span>// If this were legal, what would T1 and T2 be?</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span>// Okay to put ...Tmpls first because T inferred from function argument</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>template</span><span>&lt;</span><span>typename</span><span>...&gt;</span> <span>typename</span> <span>...</span>Tmpls<span>,</span> <span>typename</span> T<span>&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span>auto</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    ptr_tuple<span>(</span><span>const</span> T <span>&amp;</span>v<span>)</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>      <span>// Exception-safe since C++17 (see P0145R3)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>std::</span>tuple<span>(</span>Tmpls<span>&lt;</span>T<span>&gt;(</span><span>new</span> T<span>(</span>v<span>))...);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span>auto</span> ones <span>=</span> ptr_tuple<span>&lt;</span><span>std::</span>shared_ptr<span>,</span> <span>std::</span>unique_ptr<span>&gt;(</span><span>1</span><span>);</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span>using</span> <span>std::</span>tuple<span>;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> T1<span>,</span> <span>typename</span> T2<span>,</span> <span>typename</span> T3<span>&gt;</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> is_tuple_cat <span>:</span> <span>std::</span>false_type<span> {};</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span>// Okay for ...T1 not to be last in specialization</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T1<span>,</span> <span>typename</span> <span>...</span>T2<span>&gt;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> is_tuple_cat<span>&lt;</span>tuple<span>&lt;</span>T1<span>...&gt;,</span> tuple<span>&lt;</span>T2<span>...&gt;,</span> tuple<span>&lt;</span>T1<span>...,</span> T2<span>...&gt;&gt;</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>      <span>:</span> <span>std::</span>true_type<span> {};</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span>static_assert</span><span>(</span>is_tuple_cat<span>&lt;</span>tuple<span>&lt;</span><span>int</span><span>&gt;,</span> tuple<span>&lt;</span><span>char</span><span>*&gt;,</span> tuple<span>&lt;</span><span>int</span><span>,</span> <span>char</span><span>*&gt;&gt;{});</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span>static_assert</span><span>(!</span>is_tuple_cat<span>&lt;</span>tuple<span>&lt;</span><span>int</span><span>&gt;,</span> tuple<span>&lt;</span><span>char</span><span>*&gt;,</span> tuple<span>&lt;</span><span>int</span><span>,</span> <span>bool</span><span>&gt;&gt;{});</span></span></code></pre></div>
<p>A template parameter can also be an expansion of another parameter
pack, as we saw in the definition of <code>Inner</code> <a href="#Outer">above</a>.</p>
<h3 id="function-parameter-packs">Function parameter packs</h3>
<p>Function parameter packs consist of values in the argument list of a
function. We’ve seen examples like <code>c</code> in <a href="#expand-5"><code>expand(C...c)</code></a> and <code>i</code> in <a href="#sum2"><code>sum(std::convertible_to&lt;int&gt; auto ...i)</code></a>.
There’s a big restriction that a function parameter pack must either
itself be a pack expansion (as in <code>expand</code>) or else contain
the placeholder <code>auto</code> (as in <code>sum</code>). Otherwise,
the program is ill-formed. This is why all the examples make heavy use
of <code>std::convertible_to</code>. The C++ committee <a href="https://wg21.link/p1219r0">considered</a> but <a href="https://github.com/cplusplus/papers/issues/297">rejected</a>
allowing <span id="homogeneous-intro"><em>homogeneous variadic function
parameters</em></span>, which would have permitted the following simpler
code:</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;&gt;</span> <span>constexpr</span> <span>int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    sum<span>(</span><span>int</span> <span>...</span>i<span>)</span>  <span>// illegal</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>(</span><span>0</span> <span>+</span> <span>...</span> <span>+</span> i<span>);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span></code></pre></div>
<p>Why not allow the above code? The problem lies in the fact that, for
compatibility with really old C++, there are <a href="https://timsong-cpp.github.io/cppwp/n4868/dcl.fct#nt:parameter-declaration-clause">two
ways</a> of defining a <a href="https://en.cppreference.com/w/cpp/language/variadic_arguments">C-style
variadic function</a> function:</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>    <span>int</span> printf<span>(</span><span>const</span> <span>char</span> <span>*,</span> <span>...);</span>  <span>// better way, required by C</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span>int</span> printf<span>(</span><span>const</span> <span>char</span> <span>*...);</span>    <span>// 1983 C++ way, before C had prototypes</span></span></code></pre></div>
<p>If C++ allowed homogeneous variadic function parameters, there would
be an ambiguity between the older style of varargs definition above and
a template function <code>printf</code> accepting a homogeneous
parameter pack of <code>const char *</code> values. The standard
unfortunately <a href="https://timsong-cpp.github.io/cppwp/n4868/dcl.fct#22">requires</a>
that the ambiguity be resolved in favor of the C-style varargs
interpretation. The proposal to fix this did require an extra
<code>template&lt;&gt;</code> in front of our definition of
<code>sum</code>, which avoided the ambiguity. Moreover, if you give the
parameter pack <code>i</code> a name, that also avoids any ambiguity.
But the proposal lost anyway, so you can’t do that.</p>
<p>Is there a workaround for the lack of homogeneous variadic function
parameters? The following two functions seem like reasonable substitutes
for the illegal <code>f(int ...i)</code>:</p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span>int</span> f1<span>(</span><span>std::</span>same_as<span>&lt;</span><span>int</span><span>&gt;</span> <span>auto</span> <span>...</span>i<span>);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span>int</span> f2<span>(</span><span>std::</span>convertible_to<span>&lt;</span><span>int</span><span>&gt;</span> <span>auto</span> <span>...</span>i<span>);</span></span></code></pre></div>
<p>Unfortunately, it is important to realize that neither is quite
equivalent. When a parameter type is declared <code>int</code>, unlike
<code>auto</code>, it triggers <a href="https://en.cppreference.com/w/c/language/conversion#Integer_conversions">integer
conversion</a>. A concept such as <code>same_as</code> doesn’t change
the type inferred by <code>auto</code>, it only restricts permissible
types. Hence, calling <code>f1(0, sizeof(int))</code> won’t match the
above function, because <code>sizeof(int)</code> is a
<code>std::size_t</code>, so the second argument type is inferred as
<code>std::size_t</code>, which fails the constraint test
<code>std::same_as&lt;int&gt;</code>. The invocation
<code>f2(0, sizeof(int))</code> is okay, but its arguments are of
heterogeneous type, which means inside <code>f2</code> writing code such
as <code>for (int n : { i... })</code> won’t work.</p>
<p>A workaround for <code>f2</code> is to use a cast in the pattern for
expanding <code>i</code>, as in
<code>for (int n : { int(i)... })</code>. This solution is perfectly
fine for <code>int</code>. Unfortunately, for types with non-trivial
constructors, such as <code>std::string</code>, <code>f2</code> can lead
to gratuitous copies. For example, suppose that instead of taking
<code>int</code>, we have a type <code>Obj</code>:</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span>struct</span> Obj <span>{</span> <span>void</span> use<span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span> <span>/* ... */</span> <span>};</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span>void</span> good<span>()</span> <span>{}</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span>void</span> good<span>(</span>Obj o1<span>)</span> <span>{</span> o1<span>.</span>use<span>();</span> <span>}</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span>void</span> good<span>(</span>Obj o1<span>,</span> Obj o2<span>)</span> <span>{</span> o1<span>.</span>use<span>();</span> o2<span>.</span>use<span>();</span> <span>}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span>// ...</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span>void</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    bad<span>(</span><span>std::</span>convertible_to<span>&lt;</span>Obj<span>&gt;</span> <span>auto</span><span>&amp;&amp;</span> <span>...</span>o<span>)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>      <span>// Unary fold over comma</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      <span>(</span>Obj<span>{</span><span>std::</span>forward<span>&lt;</span><span>decltype</span><span>(</span>o<span>)&gt;(</span>o<span>)}.</span>use<span>(),</span> <span>...);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span></code></pre></div>
<p>If you call <code>good({})</code> or <code>good(Obj{})</code>, you
will construct exactly one object of type <code>Obj</code>. If you call
<code>bad({})</code>, the program is ill-formed (the compiler doesn’t
know what type <code>{}</code> should be). If you call
<code>bad(Obj{})</code>, then you will construct <em>two</em> objects of
type <code>Obj</code>. First, a temporary will be constructed to pass
into <code>bad</code>. Next, the cast expression in the fold will
move-construct a second <code>Obj</code> object from the first. See the
<a href="#homogeneous-function-parameter-packs">homogeneous function
parameter packs</a> idiom for a way to work around this problem.</p>
<h3 id="init-capture-packs">Init-capture packs</h3>
<p>The simplest way to capture a parameter pack in a lambda expression
is simply to expand it into a conceptual list of values to capture, as
seen <a href="#capture-pattern">above</a>. Sometimes, however, you want
to capture variables with an explicit initializer. For example, if your
function parameter pack contains rvalue references, it may be more
efficient to move-initialize the lambda’s captures than to
copy-initialize them. You can capture a parameter pack in the capture
clause of a lambda by prefixing an identifier with an ellipsis. In this
case, the initializer must be a pattern containing one or more packs (of
the same length). Here’s an example that will avoid copying any
temporary strings passed in as arguments:</p>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span>template</span><span>&lt;</span><span>std::</span>convertible_to<span>&lt;</span><span>std::</span>string<span>&gt;</span> <span>...</span>T<span>&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span>auto</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    make_prefixer<span>(</span>T<span>&amp;&amp;</span> <span>...</span>args<span>)</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span>using</span> <span>namespace</span> <span>std::</span>string_literals<span>;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>[...</span>p<span>=</span><span>std::</span>string<span>(</span><span>std::</span>forward<span>&lt;</span>T<span>&gt;(</span>args<span>))](</span><span>std::</span>string<span> </span>msg<span>)</span> <span>{</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span>// binary right fold over +</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span>return</span> <span>((</span>p <span>+</span> <span>&#34;: &#34;</span><span>s</span> <span>+</span> msg <span>+</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>s</span><span>)</span> <span>+</span> <span>...</span> <span>+</span> <span>&#34;&#34;</span><span>s</span><span>);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>      <span>};</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span>int</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    main<span>()</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span>{</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>      <span>auto</span> p <span>=</span> make_prefixer<span>(</span><span>&#34;BEGIN&#34;</span><span>,</span> <span>&#34;END&#34;</span><span>);</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>      <span>std::</span>cout<span> &lt;&lt;</span> p<span>(</span><span>&#34;message&#34;</span><span>);</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>      <span>// prints:</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>      <span>// </span><span>BEGIN</span><span>: message</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>      <span>// </span><span>END</span><span>: message</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span>}</span></span></code></pre></div>

<p>Below is a collection of idioms for working with parameter packs. I
place all the code in this blog post in the public domain, so feel free
to cut and paste. To keep things concise, I’ve omitted include files,
but the system library features used in the examples come from the
following set of includes:</p>
<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;algorithm&gt;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;array&gt;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;concepts&gt;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;initializer_list&gt;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;iostream&gt;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;memory&gt;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;string&gt;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;tuple&gt;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;type_traits&gt;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;utility&gt;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span>#include </span><span>&lt;variant&gt;</span></span></code></pre></div>
<h2 id="recursing-over-argument-lists">Recursing over argument
lists</h2>
<p>The most basic variadic template idiom, probably already known to
most people reading this blog post, is to iterate over the argument list
recursively, using function overloading to differentiate the base case
(no arguments) from the recursive case (one or more). A silly
example:</p>
<div id="cb15"><pre><code><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span>inline</span> <span>void</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>printall<span>()</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span>void</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>printall<span>(</span><span>const</span> <span>auto</span> <span>&amp;</span>first<span>,</span> <span>const</span> <span>auto</span> <span>&amp;...</span>rest<span>)</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>cout<span> &lt;&lt;</span> first<span>;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  printall<span>(</span>rest<span>...);</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Of course, since C++17, many uses of recursion are better
accomplished with folds:</p>
<div id="cb16"><pre><code><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span>void</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>printall2<span>(</span><span>const</span> <span>auto</span> <span>&amp;...</span>args<span>)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  <span>// binary left fold</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  <span>(</span><span>std::</span>cout<span> &lt;&lt;</span> <span>...</span> <span>&lt;&lt;</span> args<span>);</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<h2 id="recursing-over-template-parameters">Recursing over template
parameters</h2>
<p>Another common technique is to recurse over template parameters. This
can be done to consume the elements of a parameter pack, produce
elements of a parameter, or both. Here’s a simple example in which we
recursively produce the arguments of a parameter pack. The goal is, at
compile time, to produce a string corresponding to a number (so that you
can safely use the string even in global initializers). We recurse over
the parameter <code>N</code> so long as it is greater than 10, producing
one digit at a time. Finally, when <code>N</code> is less than 10, we
return a <code>char[]</code> from inside the <code>string_holder</code>
template.</p>
<div id="string-holder"><pre><code><span id="string-holder-1"><a href="#string-holder-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> <span>...</span>Cs<span>&gt;</span></span>
<span id="string-holder-2"><a href="#string-holder-2" aria-hidden="true" tabindex="-1"></a><span>struct</span> string_holder <span>{</span></span>
<span id="string-holder-3"><a href="#string-holder-3" aria-hidden="true" tabindex="-1"></a>  <span>static</span> <span>constexpr</span> <span>std::</span>size_t<span> </span>len <span>=</span> <span>sizeof</span><span>...(</span>Cs<span>);</span></span>
<span id="string-holder-4"><a href="#string-holder-4" aria-hidden="true" tabindex="-1"></a>  <span>static</span> <span>constexpr</span> <span>char</span> value<span>[]</span> <span>=</span> <span>{</span> Cs<span>...,</span> <span>&#39;</span><span>\0</span><span>&#39;</span> <span>};</span></span>
<span id="string-holder-5"><a href="#string-holder-5" aria-hidden="true" tabindex="-1"></a>  <span>constexpr</span> <span>operator</span> <span>const</span> <span>char</span> <span>*()</span> <span>const</span> <span>{</span> <span>return</span> value<span>;</span> <span>}</span></span>
<span id="string-holder-6"><a href="#string-holder-6" aria-hidden="true" tabindex="-1"></a>  <span>constexpr</span> <span>operator</span> <span>std::</span>string<span>()</span> <span>const</span> <span>{</span> <span>return</span> <span>{</span> value<span>,</span> len <span>};</span> <span>}</span></span>
<span id="string-holder-7"><a href="#string-holder-7" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="string-holder-8"><a href="#string-holder-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="string-holder-9"><a href="#string-holder-9" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>size_t</span> N<span>,</span> <span>char</span><span>...</span>Cs<span>&gt;</span></span>
<span id="string-holder-10"><a href="#string-holder-10" aria-hidden="true" tabindex="-1"></a><span>consteval</span> <span>auto</span></span>
<span id="string-holder-11"><a href="#string-holder-11" aria-hidden="true" tabindex="-1"></a>index_string<span>()</span></span>
<span id="string-holder-12"><a href="#string-holder-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="string-holder-13"><a href="#string-holder-13" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>constexpr</span> <span>(</span>N <span>&lt;</span> <span>10</span><span>)</span></span>
<span id="string-holder-14"><a href="#string-holder-14" aria-hidden="true" tabindex="-1"></a>    <span>return</span> string_holder<span>&lt;</span>N<span>+</span><span>&#39;0&#39;</span><span>,</span> Cs<span>...&gt;{};</span></span>
<span id="string-holder-15"><a href="#string-holder-15" aria-hidden="true" tabindex="-1"></a>  <span>else</span></span>
<span id="string-holder-16"><a href="#string-holder-16" aria-hidden="true" tabindex="-1"></a>    <span>return</span> index_string<span>&lt;</span>N<span>/</span><span>10</span><span>,</span> <span>(</span>N<span>%</span><span>10</span><span>)+</span><span>&#39;0&#39;</span><span>,</span> Cs<span>...&gt;();</span></span>
<span id="string-holder-17"><a href="#string-holder-17" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="string-holder-18"><a href="#string-holder-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="string-holder-19"><a href="#string-holder-19" aria-hidden="true" tabindex="-1"></a><span>// &#34;10&#34;</span></span>
<span id="string-holder-20"><a href="#string-holder-20" aria-hidden="true" tabindex="-1"></a><span>constinit</span> <span>const</span> <span>char</span> <span>*</span>ten <span>=</span> index_string<span>&lt;</span><span>10</span><span>&gt;();</span></span></code></pre></div>
<p>If you want to consume and produce argument packs recursively, then
you need to use some kind of holder type so as to accommodate multiple
parameter packs simultaneously. The <code>string_holder</code> type
above is an example of such a holder type. Suppose we want a function
<code>add_commas</code> that adds a comma between every three characters
of a string starting from the right. We can do this by consuming the
argument pack of one <code>string_holder</code> while producing the
argument pack of another:</p>
<div id="cb17"><pre><code><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> <span>...</span>Out<span>&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span>consteval</span> <span>auto</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>add_commas<span>(</span>string_holder<span>&lt;&gt;,</span> string_holder<span>&lt;</span>Out<span>...&gt;</span> out<span>)</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> out<span>;</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> In0<span>,</span> <span>char</span> <span>...</span>InRest<span>,</span> <span>char</span> <span>...</span>Out<span>&gt;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span>consteval</span> <span>auto</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>add_commas<span>(</span>string_holder<span>&lt;</span>In0<span>,</span> InRest<span>...&gt;,</span> string_holder<span>&lt;</span>Out<span>...&gt;</span> <span>=</span> <span>{})</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>constexpr</span> <span>(</span><span>sizeof</span><span>...(</span>InRest<span>)</span> <span>%</span> <span>3</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>sizeof</span><span>...(</span>InRest<span>)</span> <span>&gt;</span> <span>0</span><span>)</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span>return</span> add_commas<span>(</span>string_holder<span>&lt;</span>InRest<span>...&gt;{},</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>                      string_holder<span>&lt;</span>Out<span>...,</span> In0<span>,</span> <span>&#39;,&#39;</span><span>&gt;{});</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>  <span>else</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span>return</span> add_commas<span>(</span>string_holder<span>&lt;</span>InRest<span>...&gt;{},</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>                      string_holder<span>&lt;</span>Out<span>...,</span> In0<span>&gt;{});</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span>// &#34;1,000,000&#34;</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span>constinit</span> <span>const</span> <span>char</span> <span>*</span>million <span>=</span> add_commas<span>(</span>index_string<span>&lt;</span><span>1&#39;000&#39;000</span><span>&gt;());</span></span></code></pre></div>
<h2 id="comma-fold">Comma fold</h2>
<p>Often you want to do the same operation to every element in a
parameter pack. While you can accomplish this by recursing over the
parameter pack, it can be simpler to use a fold over the <a href="https://en.cppreference.com/w/cpp/language/operator_other#Built-in_comma_operator">comma
operator</a>, which just sequences one expression after the other. To
avoid any strange behavior in cases where the program overloads
<code>operator,</code>, you can cast the expression to void. Here’s a
simple example of a function that inserts an arbitrary number of
elements into a container supporting an <code>insert</code> method:</p>
<div id="cb18"><pre><code><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>,</span> <span>typename</span> <span>...</span>E<span>&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span>void</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>multi_insert<span>(</span>T <span>&amp;</span>t<span>,</span> E<span>&amp;&amp;...</span>e<span>)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span>// unary right fold over comma</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>  <span>(</span><span>void</span><span>(</span>t<span>.</span>insert<span>(</span><span>std::</span>forward<span>&lt;</span>E<span>&gt;(</span>e<span>))),</span> <span>...);</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span>int</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>main<span>()</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>set<span>&lt;</span><span>int</span><span>&gt;</span> s<span>;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  multi_insert<span>(</span>s<span>,</span> <span>1</span><span>,</span> <span>4</span><span>,</span> <span>7</span><span>,</span> <span>10</span><span>);</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  <span>for</span> <span>(</span><span>auto</span> i <span>:</span> s<span>)</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span>std::</span>cout<span> &lt;&lt;</span> i <span>&lt;&lt;</span> <span>&#34; &#34;</span><span>;</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>cout<span> &lt;&lt;</span> <span>std::</span>endl<span>;</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>  <span>// prints:</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>  <span>// 1 4 7 10</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>As always, remember that folds must be parenthesized, and that a bare
expression cannot be expanded as a pattern. Neither of the following
alternate function bodies for <code>multi_insert</code> would
compile:</p>
<div id="cb19"><pre><code><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span>void</span><span>(</span>t<span>.</span>insert<span>(</span><span>std::</span>forward<span>&lt;</span>E<span>&gt;(</span>e<span>))),</span> <span>...;</span>  <span>// error: bad fold</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>t<span>.</span>insert<span>(</span><span>std::</span>forward<span>&lt;</span>E<span>&gt;(</span>e<span>))...;</span>  <span>// error: bad expansion context</span></span></code></pre></div>
<h2 id="short-circuiting-and-folds">Short-circuiting
<code>&amp;&amp;</code> and <code>||</code> folds</h2>
<p>Sometimes you want to iterate over a parameter pack until some
condition holds. Of course, you can do this with recursion, simply
ending the recursion when you hit the stop condition. However, the
recursive approach can be cumbersome and require you to define several
functions. As an alternative, you can fold over the logical
<code>&amp;&amp;</code> and <code>||</code> operators, which
<em>short-circuit</em> evaluation and stop doing anything the minute the
condition is guaranteed to be true or false. Here’s an example of a
function that finds the index of the first item in a tuple to satisfy
some arbitrary predicate functor <code>f</code>:</p>
<div id="cb20"><pre><code><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>,</span> <span>typename</span> F<span>&gt;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span>std::</span>size_t</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>tuple_find<span>(</span><span>const</span> T <span>&amp;</span>t<span>,</span> F <span>&amp;&amp;</span>f<span>)</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>std::</span>apply<span>([&amp;</span>f<span>](</span><span>const</span> <span>auto</span> <span>&amp;...</span>e<span>)</span> <span>{</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    <span>std::</span>size_t<span> </span>r <span>=</span> <span>0</span><span>;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span>((</span><span>std::</span>forward<span>&lt;</span>F<span>&gt;(</span>f<span>)(</span>e<span>)</span> <span>||</span> <span>(++</span>r<span>,</span> <span>false</span><span>))</span> <span>||</span> <span>...);</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span>return</span> r<span>;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  <span>},</span> t<span>);</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a><span>int</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>main<span>()</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>tuple<span> </span>t<span>(-</span><span>2</span><span>,</span> <span>-</span><span>1</span><span>,</span> <span>0</span><span>U</span><span>,</span> <span>1</span><span>UL</span><span>,</span> <span>2</span><span>ULL</span><span>);</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>cout<span> &lt;&lt;</span> tuple_find<span>(</span>t<span>,</span> <span>[](</span><span>auto</span> i<span>)</span> <span>{</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>std::</span>cmp_greater<span>(</span>i<span>,</span> <span>-</span><span>1</span><span>);</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>  <span>})</span> <span>&lt;&lt;</span> <span>std::</span>endl<span>;</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>  <span>// prints:</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>  <span>// 2</span></span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Incidentally, while this has nothing to do with parameter packs, let
me gratuitously plug C++20’s <a href="https://en.cppreference.com/w/cpp/utility/intcmp">safe integer
comparison functions</a>. Had our lambda predicate read
<code>return i &gt; -1</code> instead of
<code>std::cmp_greater(i, -1)</code>, the program would have printed
<code>5</code>, because <a href="https://en.cppreference.com/w/c/language/conversion#Integer_conversions"><code>0U &gt; -1</code>
is false</a>.</p>
<p>Often the comma operator is handy to execute some action before
testing the stop condition in a fold over a logical operator. For
another example of the technique, see <a href="https://cor3ntin.github.io/posts/tuple/#-nothing-as-futuristic-as-a-spaceship">this
implementation of <code>operator&lt;=&gt;</code></a> on a tuple-like
type.</p>
<h2 id="using-lambda-expressions-to-capture-packs">Using lambda
expressions to capture packs</h2>
<p>While parameter packs can be expanded in many contexts, you sometimes
need to deconstruct a template type to extract the parameter pack. This
can be awkward because there are fewer contexts in which to capture a
pack. Worst-case scenario, this can be done by defining a helper type or
function, but this leads to a lot of code and exposes the private
internals of your implementation. One way to keep things more
self-contained is with a lambda expression.</p>
<p>Lambdas are particularly helpful in working with <a href="https://en.cppreference.com/w/cpp/utility/tuple">tuples</a>.
Combining a lambda with <code>std::apply</code> lets you capture a
parameter pack corresponding to the contents of a tuple.</p>
<div id="cb21"><pre><code><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span>auto</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>tuple_mult<span>(</span><span>auto</span> scalar<span>,</span> <span>auto</span> tpl<span>)</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span>return</span> apply<span>([&amp;</span>scalar<span>]&lt;</span><span>typename</span> <span>...</span>T<span>&gt;(</span>T<span>...</span>t<span>)</span> <span>{</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>      <span>return</span> <span>std::</span>tuple<span>(</span>T<span>(</span>scalar <span>*</span> t<span>)...);</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    <span>},</span> tpl<span>);</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span>int</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>main<span>()</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>  <span>auto</span> t <span>=</span> <span>std::</span>tuple<span>(</span><span>1</span><span>,</span> <span>2</span><span>U</span><span>,</span> <span>4.0</span><span>);</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>  t <span>=</span> tuple_mult<span>(</span><span>2</span><span>,</span> t<span>);</span></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>cout<span> &lt;&lt;</span> get<span>&lt;</span><span>0</span><span>&gt;(</span>t<span>)</span> <span>&lt;&lt;</span> <span>&#34; &#34;</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>            <span>&lt;&lt;</span> get<span>&lt;</span><span>1</span><span>&gt;(</span>t<span>)</span> <span>&lt;&lt;</span> <span>&#34; &#34;</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>            <span>&lt;&lt;</span> get<span>&lt;</span><span>2</span><span>&gt;(</span>t<span>)</span> <span>&lt;&lt;</span> <span>std::</span>endl<span>;</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  <span>// prints:</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  <span>// 2 4 8</span></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p><span id="integer-sequence">Using</span> lambdas to capture parameter
packs is especially useful with <a href="https://en.cppreference.com/w/cpp/utility/integer_sequence"><code>std::integer_sequence&lt;typename T, T...&gt;</code></a>,
a trivial type akin to <a href="#string-holder"><code>string_holder</code></a> above, but for
holding an arbitrary integer type <code>T</code>. Since
<code>std::size_t</code> is often what you want, the alias
<code>std::index_sequence&lt;T...&gt;</code> is equivalent to
<code>std::integer_sequence&lt;std::size_t, T...&gt;</code>. To create
<code>std::integer_sequence</code> types, you can use the type alias
<code>std::make_integer_sequence&lt;T, N&gt;</code> (or the
<code>std::size_t</code>-specific
<code>std::make_index_sequence&lt;N&gt;</code>) to make an integer
sequence containing the numbers from <code>0</code> through
<code>N-1</code>.</p>
<p>Suppose you want to add two tuples, element by element. You could use
two nested lambdas to expand the two tuples in succession, but this
would be a bit awkward. Instead, you can use
<code>std::make_index_sequence</code> to get the tuple indices, then use
the indices in a pattern that accesses the elements of both tuples
element by element. Here is the code:</p>
<div id="tuple-add"><pre><code><span id="tuple-add-1"><a href="#tuple-add-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span></span>
<span id="tuple-add-2"><a href="#tuple-add-2" aria-hidden="true" tabindex="-1"></a><span>auto</span></span>
<span id="tuple-add-3"><a href="#tuple-add-3" aria-hidden="true" tabindex="-1"></a>tuple_add<span>(</span><span>const</span> T <span>&amp;</span>a<span>,</span> <span>const</span> T<span>&amp;</span>b<span>)</span></span>
<span id="tuple-add-4"><a href="#tuple-add-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="tuple-add-5"><a href="#tuple-add-5" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>[&amp;</span>a<span>,</span> <span>&amp;</span>b<span>]&lt;</span><span>std::</span>size_t<span> ...</span>I<span>&gt;(</span><span>std::</span>index_sequence<span>&lt;</span>I<span>...&gt;)</span> <span>{</span></span>
<span id="tuple-add-6"><a href="#tuple-add-6" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>std::</span>tuple<span>(</span>get<span>&lt;</span>I<span>&gt;(</span>a<span>)</span> <span>+</span> get<span>&lt;</span>I<span>&gt;(</span>b<span>)...);</span></span>
<span id="tuple-add-7"><a href="#tuple-add-7" aria-hidden="true" tabindex="-1"></a>  <span>}(</span><span>std::</span>make_index_sequence<span>&lt;</span><span>std::</span>tuple_size_v<span>&lt;</span>T<span>&gt;&gt;{});</span></span>
<span id="tuple-add-8"><a href="#tuple-add-8" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="tuple-add-9"><a href="#tuple-add-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="tuple-add-10"><a href="#tuple-add-10" aria-hidden="true" tabindex="-1"></a><span>int</span></span>
<span id="tuple-add-11"><a href="#tuple-add-11" aria-hidden="true" tabindex="-1"></a>main<span>()</span></span>
<span id="tuple-add-12"><a href="#tuple-add-12" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="tuple-add-13"><a href="#tuple-add-13" aria-hidden="true" tabindex="-1"></a>  <span>auto</span> t <span>=</span> <span>std::</span>tuple<span>(</span><span>1</span><span>,</span> <span>2</span><span>U</span><span>,</span> <span>4.0</span><span>);</span></span>
<span id="tuple-add-14"><a href="#tuple-add-14" aria-hidden="true" tabindex="-1"></a>  t <span>=</span> tuple_add<span>(</span>t<span>,</span> tuple_mult<span>(</span><span>10</span><span>,</span> t<span>));</span></span>
<span id="tuple-add-15"><a href="#tuple-add-15" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>cout<span> &lt;&lt;</span> get<span>&lt;</span><span>0</span><span>&gt;(</span>t<span>)</span> <span>&lt;&lt;</span> <span>&#34; &#34;</span></span>
<span id="tuple-add-16"><a href="#tuple-add-16" aria-hidden="true" tabindex="-1"></a>            <span>&lt;&lt;</span> get<span>&lt;</span><span>1</span><span>&gt;(</span>t<span>)</span> <span>&lt;&lt;</span> <span>&#34; &#34;</span></span>
<span id="tuple-add-17"><a href="#tuple-add-17" aria-hidden="true" tabindex="-1"></a>            <span>&lt;&lt;</span> get<span>&lt;</span><span>2</span><span>&gt;(</span>t<span>)</span> <span>&lt;&lt;</span> <span>std::</span>endl<span>;</span></span>
<span id="tuple-add-18"><a href="#tuple-add-18" aria-hidden="true" tabindex="-1"></a>  <span>// prints:</span></span>
<span id="tuple-add-19"><a href="#tuple-add-19" aria-hidden="true" tabindex="-1"></a>  <span>// 11 22 44</span></span>
<span id="tuple-add-20"><a href="#tuple-add-20" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Once again, life is better in C++20 because a lambda expression can
have explicit type parameters, allowing us to capture the template
parameter pack <code>...I</code> from the inferred
<code>std::index_sequence</code> type of the function argument.</p>
<h2 id="using-lambda-expressions-to-capture-packs-in-requires-clauses">Using
lambda expressions to capture packs in requires clauses</h2>
<p>You can also use lambdas in requires clauses. Suppose you want to
define a <a href="https://en.cppreference.com/w/cpp/language/user_literal">user-defined
literal</a> <code>_hex</code> to create strings from a series of
hexadecimal digits specifying bytes. For example, the constant
<code>0x48656c6c6f21_hex</code> should be equivalent to
<code>std::string{&#34;Hello!&#34;}</code>. The C++ standard <a href="https://timsong-cpp.github.io/cppwp/n4868/over.literal#5">says</a>
such an operator must be defined as exactly
<code>template&lt;char ...C&gt; operator&#34;&#34;_hex()</code>, where the
template arguments are the characters of the literal. It might be nice
to strip the first two characters (<code>&#39;0&#39;</code> and
<code>&#39;x&#39;</code>) from the literal with different template parameters,
but unfortunately C++ disallows alternate definitions such as
<code>template&lt;char Zero, char X, char ...C&gt; operator&#34;&#34;_hex()</code>.</p>
<p>Here’s one possible implementation, where we simply create an array
from the template arguments and iterate over the characters, skipping
the first two:</p>
<div id="cb22"><pre><code><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span>constexpr</span> <span>int</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>hexdigit<span>(</span><span>char</span> c<span>)</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>c <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> c <span>&lt;=</span> <span>&#39;9&#39;</span><span>)</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span>return</span> c <span>-</span> <span>&#39;0&#39;</span><span>;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  c <span>|=</span> <span>0x20</span><span>;</span>            <span>// convert upper- to lower-case</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>(</span>c <span>&gt;=</span> <span>&#39;a&#39;</span> <span>&amp;&amp;</span> c <span>&lt;=</span> <span>&#39;f&#39;</span><span>)</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span>return</span> c <span>-</span> <span>(</span><span>&#39;a&#39;</span> <span>-</span> <span>10</span><span>);</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>-</span><span>1</span><span>;</span>            <span>// invalid</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> <span>...</span>C<span>&gt;</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span>requires</span> <span>(</span><span>sizeof</span><span>...(</span>C<span>)%</span><span>2</span> <span>==</span> <span>0</span><span>)</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span>constexpr</span> <span>std::</span>string</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>operator<span>&#34;&#34;</span>_hex<span>()</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  <span>constexpr</span> <span>std::</span>array<span> </span>digits<span>{</span> C<span>...</span> <span>};</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>string<span> </span>result<span>{};</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  <span>for</span> <span>(</span><span>std::</span>size_t<span> </span>i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> digits<span>.</span>size<span>();</span> i <span>+=</span> <span>2</span><span>)</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    result <span>+=</span> <span>char</span><span>(</span>hexdigit<span>(</span>digits<span>[</span>i<span>])&lt;&lt;</span><span>4</span> <span>|</span> hexdigit<span>(</span>digits<span>[</span>i<span>+</span><span>1</span><span>]));</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>  <span>return</span> result<span>;</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span>int</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>main<span>()</span></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>cout<span> &lt;&lt;</span> <span>0x48656c6c6f21</span><span>_hex</span> <span>&lt;&lt;</span> <span>std::</span>endl<span>;</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>  <span>// prints:</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>  <span>// Hello!</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Unfortunately, there are a few problems with this code. First,
nothing requires the constant to start with <code>0x</code>. For
example, you could type a decimal constant <code>1234_hex</code>, and
the result would be nonsense (the first two digits skipped). We could
also feed in a floating point number such as
<code>0xa98.76p0_hex</code>, which is allowed by the language, and we
would get nonsense. To prevent this, we could maybe sprinkle some
<code>static_assert</code> statements in the code, but: A) We’d rather
the <code>operator&#34;&#34;_hex</code> function simply not match than return
confusing errors from within the function, or more confusingly still, a
helper function, and B) We want all <em>except</em> the second character
(<code>x</code>) to be valid hex characters, so a simple
<code>&amp;&amp;</code> fold over all the digits won’t do the right
thing.</p>
<p>Of course, this could be handled by defining custom helper types and
maybe a dedicated concept, but a cleaner solution is just to unpack the
parameter pack with a lambda right in the requires clause:</p>
<div id="operator-hex"><pre><code><span id="operator-hex-1"><a href="#operator-hex-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> <span>...</span>C<span>&gt;</span></span>
<span id="operator-hex-2"><a href="#operator-hex-2" aria-hidden="true" tabindex="-1"></a><span>requires</span> <span>(</span><span>sizeof</span><span>...(</span>C<span>)%</span><span>2</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span></span>
<span id="operator-hex-3"><a href="#operator-hex-3" aria-hidden="true" tabindex="-1"></a>          <span>[](</span><span>char</span> zero<span>,</span> <span>char</span> x<span>,</span> <span>auto</span> <span>...</span>rest<span>)</span> <span>{</span></span>
<span id="operator-hex-4"><a href="#operator-hex-4" aria-hidden="true" tabindex="-1"></a>            <span>return</span> zero <span>==</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> x <span>==</span> <span>&#39;x&#39;</span> <span>&amp;&amp;</span> <span>((</span>hexdigit<span>(</span>rest<span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>&amp;&amp;</span> <span>...);</span></span>
<span id="operator-hex-5"><a href="#operator-hex-5" aria-hidden="true" tabindex="-1"></a>          <span>}(</span>C<span>...))</span></span>
<span id="operator-hex-6"><a href="#operator-hex-6" aria-hidden="true" tabindex="-1"></a><span>constexpr</span> <span>std::</span>string</span>
<span id="operator-hex-7"><a href="#operator-hex-7" aria-hidden="true" tabindex="-1"></a>operator<span>&#34;&#34;</span>_hex<span>()</span></span>
<span id="operator-hex-8"><a href="#operator-hex-8" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="operator-hex-9"><a href="#operator-hex-9" aria-hidden="true" tabindex="-1"></a>  <span>constexpr</span> <span>std::</span>array<span> </span>digits<span>{</span> C<span>...</span> <span>};</span></span>
<span id="operator-hex-10"><a href="#operator-hex-10" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>string<span> </span>result<span>{};</span></span>
<span id="operator-hex-11"><a href="#operator-hex-11" aria-hidden="true" tabindex="-1"></a>  <span>for</span> <span>(</span><span>std::</span>size_t<span> </span>i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> digits<span>.</span>size<span>();</span> i <span>+=</span> <span>2</span><span>)</span></span>
<span id="operator-hex-12"><a href="#operator-hex-12" aria-hidden="true" tabindex="-1"></a>    result <span>+=</span> <span>char</span><span>(</span>hexdigit<span>(</span>digits<span>[</span>i<span>])&lt;&lt;</span><span>4</span> <span>|</span> hexdigit<span>(</span>digits<span>[</span>i<span>+</span><span>1</span><span>]));</span></span>
<span id="operator-hex-13"><a href="#operator-hex-13" aria-hidden="true" tabindex="-1"></a>  <span>return</span> result<span>;</span></span>
<span id="operator-hex-14"><a href="#operator-hex-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Note how we take advantage of the fact that, as of C++17, lambdas are
implicitly <code>constexpr</code> when possible. Note also that C++20
requires most string operations to be <code>constexpr</code>, in which
case the above function could be <code>consteval</code> rather than
merely <code>constexpr</code>. Unfortunately, as of this writing,
<code>constexpr</code> strings aren’t supported by the standard
libraries available in common linux distributions.</p>
<p>By the way, here’s an alternative way of implementing this
user-defined literal with <a href="#string-holder"><code>string_holder</code></a> and <a href="#integer-sequence"><code>std::make_index_sequence</code></a>:</p>
<div id="cb23"><pre><code><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> <span>...</span>C<span>&gt;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span>requires</span> <span>(</span><span>sizeof</span><span>...(</span>C<span>)%</span><span>2</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>          <span>[](</span><span>char</span> zero<span>,</span> <span>char</span> x<span>,</span> <span>auto</span> <span>...</span>rest<span>)</span> <span>{</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>            <span>return</span> zero <span>==</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> x <span>==</span> <span>&#39;x&#39;</span> <span>&amp;&amp;</span> <span>((</span>hexdigit<span>(</span>rest<span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>&amp;&amp;</span> <span>...);</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>          <span>}(</span>C<span>...))</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span>consteval</span> <span>auto</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span>operator</span><span>&#34;&#34;</span>_hex<span>()</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>[]&lt;</span><span>std::</span>size_t<span> ...</span>I<span>&gt;(</span><span>std::</span>index_sequence<span>&lt;</span>I<span>...&gt;)</span> <span>{</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    <span>constexpr</span> <span>std::</span>array<span> </span>digits<span>{</span> C<span>...</span> <span>};</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span>return</span> string_holder<span>&lt;</span>hexdigit<span>(</span>digits<span>[</span><span>2</span><span>*</span>I<span>+</span><span>2</span><span>])&lt;&lt;</span><span>4</span> <span>|</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>                         hexdigit<span>(</span>digits<span>[</span><span>2</span><span>*</span>I<span>+</span><span>3</span><span>])...&gt;{};</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span>}(</span><span>std::</span>make_index_sequence<span>&lt;</span><span>sizeof</span><span>...(</span>C<span>)/</span><span>2</span><span>-</span><span>1</span><span>&gt;{});</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<h2 id="using-decltype-on-lambda-expressions">Using
<code>decltype</code> on lambda expressions</h2>
<p>Sometimes you want to modify the types in a parameter pack in a
context where it is inconvenient to capture the parameter pack. For
instance, suppose you want a way to take a <code>std::tuple</code> type
and generate another type corresponding to pointers to the types in the
tuple. The brute-force approach would be to introduce helper types to
leverage partial specialization, but the result is rather unwieldy:</p>
<div id="cb24"><pre><code><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span>// Clunky idiom with helper types</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span>namespace</span> detail <span>{</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span> <span>struct</span> tuple_ptr_helper<span>;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span>struct</span> tuple_ptr_helper<span>&lt;</span><span>std::</span>tuple<span>&lt;</span>T<span>...&gt;&gt;</span> <span>{</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span>using</span> type <span>=</span> <span>std::</span>tuple<span>&lt;</span>T<span>*...&gt;;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span>}</span> <span>// namespace detail</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span> <span>using</span> tuple_ptrs <span>=</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span>typename</span> detail::tuple_ptr_helper<span>&lt;</span>T<span>&gt;::</span>type<span>;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span>static_assert</span><span>(</span><span>std::</span>is_same_v<span>&lt;</span>tuple_ptrs<span>&lt;</span><span>std::</span>tuple<span>&lt;</span><span>int</span><span>,</span> <span>char</span><span>&gt;&gt;,</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>                             <span>std::</span>tuple<span>&lt;</span><span>int</span><span>*,</span> <span>char</span><span>*&gt;&gt;);</span></span></code></pre></div>
<p>Fortunately, C++20 lets us use lambdas in unevaluated contexts, which
means that instead of defining helper types, you can often use a lambda
expression inside of <code>decltype</code> to achieve what you want. In
this case, we can produce an entirely self-contained definition of
<code>tuple_ptrs</code> as follows:</p>
<div id="cb25"><pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span> <span>using</span> tuple_ptrs <span>=</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span>decltype</span><span>(</span><span>std::</span>apply<span>([](</span><span>auto</span> <span>...</span>t<span>)</span> <span>{</span> <span>return</span> <span>std::</span>tuple<span>(&amp;</span>t<span>...);</span> <span>},</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>                      <span>std::</span>declval<span>&lt;</span>T<span>&gt;()));</span></span></code></pre></div>
<h2 id="multilambda">Multilambda</h2>
<p>Thus far, we’ve been writing generic lambdas in functions like <a href="#tuple-add"><code>tuple_add</code></a> that use overloaded syntax
like the <code>+</code> operator to add numbers of different types.
However, what if we want to write different (non-generic) lambdas for
different types? We can implement a new variadic template type,
<code>multilambda</code>, that constructs a function object comprising
multiple lambdas with different type signatures. Here’s the
implementation:</p>
<div id="cb26"><pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> <span>...</span>L<span>&gt;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span>struct</span> multilambda <span>:</span> L<span>...</span> <span>{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span>using</span> L<span>::</span><span>operator</span><span>()...;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span>constexpr</span> multilambda<span>(</span>L<span>...</span>lambda<span>)</span> <span>:</span> L<span>(</span><span>std::</span>move<span>(</span>lambda<span>))...</span> <span>{}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span>int</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>main<span>()</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span>using</span> <span>namespace</span> <span>std::</span>string_literals<span>;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>tuple<span> </span>t <span>(</span><span>1</span><span>,</span> <span>true</span><span>,</span> <span>&#34;hello&#34;</span><span>s</span><span>,</span> <span>3.0</span><span>);</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span>constexpr</span> multilambda action <span>{</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span>[](</span><span>int</span> i<span>)</span> <span>{</span> <span>std::</span>cout<span> &lt;&lt;</span> i <span>&lt;&lt;</span> <span>std::</span>endl<span>;</span> <span>},</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span>[](</span><span>double</span> d<span>)</span> <span>{</span> <span>std::</span>cout<span> &lt;&lt;</span> d <span>&lt;&lt;</span> <span>std::</span>endl<span>;</span> <span>},</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>    <span>[](</span><span>bool</span> b<span>)</span> <span>{</span> <span>std::</span>cout<span> &lt;&lt;</span> <span>(</span>b <span>?</span> <span>&#34;yes</span><span>\n</span><span>&#34;</span> <span>:</span> <span>&#34;no</span><span>\n</span><span>&#34;</span><span>);</span> <span>},</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>    <span>[](</span><span>std::</span>string<span> </span>s<span>)</span> <span>{</span> <span>std::</span>cout<span> &lt;&lt;</span> s<span>.</span>size<span>()</span> <span>&lt;&lt;</span> <span>&#34; bytes</span><span>\n</span><span>&#34;</span><span>;</span> <span>},</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>  <span>};</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>  apply<span>([</span>action<span>](</span><span>auto</span> <span>...</span>v<span>)</span> <span>{</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span>(</span>action<span>(</span>v<span>),</span> <span>...);</span>  <span>// unary right fold</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>  <span>},</span> t<span>);</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>  <span>// prints:</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>  <span>// 1</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>  <span>// yes</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>  <span>// 5 bytes</span></span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>  <span>// 3</span></span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p><code>multilambda</code> takes a bunch of lambda expressions or other
callable objects as template parameters and makes them base classes.
Then, by expanding the pattern <code>using L::operator()...;</code>, it
brings all of the function call operators into scope, so that any of
them can be called so long as there is no ambiguity. The final thing to
note is that we are taking advantage of implicitly-generated <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">class
template deduction guides</a> so as to construct a
<code>multilambda</code> without having to supply explicit template
parameters.</p>
<p>Note that you can use <code>decltype</code> on
<code>multilambda</code> to do things concisely that would previously
have required auxiliary structs for partial specialization. For example,
here’s a <a href="https://en.cppreference.com/w/cpp/language/constraints"><em>concept</em></a>
that checks whether a particular type is an instance of a particular
template or a reference to an instance of that template:</p>
<div id="is-template"><pre><code><span id="is-template-1"><a href="#is-template-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>,</span> <span>template</span><span>&lt;</span><span>typename</span><span>...&gt;</span> <span>typename</span> Tmpl<span>&gt;</span></span>
<span id="is-template-2"><a href="#is-template-2" aria-hidden="true" tabindex="-1"></a><span>concept</span> is_template <span>=</span> <span>decltype</span><span>(</span>multilambda<span>{</span></span>
<span id="is-template-3"><a href="#is-template-3" aria-hidden="true" tabindex="-1"></a>    <span>[]&lt;</span><span>typename</span> <span>...</span>U<span>&gt;(</span><span>const</span> Tmpl<span>&lt;</span>U<span>...&gt;</span> <span>&amp;)</span> <span>{</span> <span>return</span> <span>std::</span>true_type<span>{};</span> <span>},</span></span>
<span id="is-template-4"><a href="#is-template-4" aria-hidden="true" tabindex="-1"></a>    <span>[](</span><span>const</span> <span>auto</span> <span>&amp;)</span> <span>{</span> <span>return</span> <span>std::</span>false_type<span>{};</span> <span>},</span></span>
<span id="is-template-5"><a href="#is-template-5" aria-hidden="true" tabindex="-1"></a>  <span>}(</span><span>std::</span>declval<span>&lt;</span>T<span>&gt;()))::</span>value<span>;</span></span>
<span id="is-template-6"><a href="#is-template-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="is-template-7"><a href="#is-template-7" aria-hidden="true" tabindex="-1"></a><span>static_assert</span><span>(</span>is_template<span>&lt;</span><span>std::</span>tuple<span>&lt;</span><span>int</span><span>,</span> <span>long</span><span>&gt;,</span> <span>std::</span>tuple<span>&gt;);</span></span>
<span id="is-template-8"><a href="#is-template-8" aria-hidden="true" tabindex="-1"></a><span>static_assert</span><span>(</span>is_template<span>&lt;</span><span>const</span> <span>std::</span>tuple<span>&lt;</span><span>int</span><span>,</span> <span>long</span><span>&gt;</span> <span>&amp;,</span> <span>std::</span>tuple<span>&gt;);</span></span>
<span id="is-template-9"><a href="#is-template-9" aria-hidden="true" tabindex="-1"></a><span>static_assert</span><span>(!</span>is_template<span>&lt;</span><span>std::</span>tuple<span>&lt;</span><span>int</span><span>,</span> <span>long</span><span>&gt;,</span> <span>std::</span>variant<span>&gt;);</span></span></code></pre></div>
<p>There’s one small issue with multilambda, which is that the copy
constructor might do a little work to move lambdas into the structure.
You can avoid this work by eliminating the constructor and directly
initializing all of the superclasses, using a deduction guide to specify
that the template types should be taken from the arguments:</p>
<div id="cb27"><pre><code><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> <span>...</span>Lambdas<span>&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span>struct</span> multilambda <span>:</span> Lambdas<span>...</span> <span>{</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span>using</span> Lambdas<span>::</span><span>operator</span><span>()...;</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span>};</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> <span>...</span>Lambdas<span>&gt;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>multilambda<span>(</span>Lambdas<span>...)</span> <span>-&gt;</span> multilambda<span>&lt;</span>Lambdas<span>...&gt;;</span></span></code></pre></div>
<h2 id="recursive-types-through-inheritance">Recursive types through
inheritance</h2>
<p>Sometimes you want to define a type that holds a variable number of
arguments depending on a parameter pack. <a href="https://en.cppreference.com/w/cpp/utility/tuple"><code>std::tuple</code></a>
is a good example of such a type. A good way to do this is through
inheritance, using the derived class to hold one element, and the base
class to hold the remaining elements. Here’s an example of a
“heterogeneous list” with head and tail operations:</p>
<div id="hlist"><pre><code><span id="hlist-1"><a href="#hlist-1"></a><span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span> <span>struct</span> HList<span>;</span></span>
<span id="hlist-2"><a href="#hlist-2"></a></span>
<span id="hlist-3"><a href="#hlist-3"></a><span>template</span><span>&lt;&gt;</span></span>
<span id="hlist-4"><a href="#hlist-4"></a><span>struct</span> HList<span>&lt;&gt;</span> <span>{</span></span>
<span id="hlist-5"><a href="#hlist-5"></a>  <span>static</span> <span>constexpr</span> <span>std::</span>size_t<span> </span>len <span>=</span> <span>0</span><span>;</span></span>
<span id="hlist-6"><a href="#hlist-6"></a><span>};</span></span>
<span id="hlist-7"><a href="#hlist-7"></a></span>
<span id="hlist-8"><a href="#hlist-8"></a><span>template</span><span>&lt;</span><span>typename</span> T0<span>,</span> <span>typename</span> <span>...</span>TRest<span>&gt;</span></span>
<span id="hlist-9"><a href="#hlist-9"></a><span>struct</span> HList<span>&lt;</span>T0<span>,</span> TRest<span>...&gt;</span> <span>:</span> HList<span>&lt;</span>TRest<span>...&gt;</span> <span>{</span></span>
<span id="hlist-10"><a href="#hlist-10"></a>  <span>using</span> <span>head_type</span> <span>=</span> T0<span>;</span></span>
<span id="hlist-11"><a href="#hlist-11"></a>  <span>using</span> <span>tail_type</span> <span>=</span> HList<span>&lt;</span>TRest<span>...&gt;;</span></span>
<span id="hlist-12"><a href="#hlist-12"></a></span>
<span id="hlist-13"><a href="#hlist-13"></a>  <span>static</span> <span>constexpr</span> <span>std::</span>size_t<span> </span>len <span>=</span> <span>1</span> <span>+</span> <span>sizeof</span><span>...(</span>TRest<span>);</span></span>
<span id="hlist-14"><a href="#hlist-14"></a>  <span>[[</span><span>no_unique_address</span><span>]]</span> <span>head_type</span> <span>value_</span><span>{};</span></span>
<span id="hlist-15"><a href="#hlist-15"></a></span>
<span id="hlist-16"><a href="#hlist-16"></a>  <span>constexpr</span> HList<span>()</span> <span>=</span> <span>default</span><span>;</span></span>
<span id="hlist-17"><a href="#hlist-17"></a>  <span>template</span><span>&lt;</span><span>typename</span> U0<span>,</span> <span>typename</span> <span>...</span>URest<span>&gt;</span></span>
<span id="hlist-18"><a href="#hlist-18"></a>  <span>constexpr</span> HList<span>(</span>U0 <span>&amp;&amp;</span>u0<span>,</span> URest <span>&amp;&amp;...</span>urest<span>)</span></span>
<span id="hlist-19"><a href="#hlist-19"></a>    <span>:</span> <span>tail_type</span><span>(</span><span>std::</span>forward<span>&lt;</span>URest<span>&gt;(</span>urest<span>)...),</span></span>
<span id="hlist-20"><a href="#hlist-20"></a>      <span>value_</span><span>(</span><span>std::</span>forward<span>&lt;</span>U0<span>&gt;(</span>u0<span>))</span> <span>{}</span></span>
<span id="hlist-21"><a href="#hlist-21"></a></span>
<span id="hlist-22"><a href="#hlist-22"></a>  <span>head_type</span> <span>&amp;</span>head<span>()</span> <span>&amp;</span> <span>{</span> <span>return</span> <span>value_</span><span>;</span> <span>}</span></span>
<span id="hlist-23"><a href="#hlist-23"></a>  <span>const</span> <span>head_type</span> <span>&amp;</span>head<span>()</span> <span>const</span><span>&amp;</span> <span>{</span> <span>return</span> <span>value_</span><span>;</span> <span>}</span></span>
<span id="hlist-24"><a href="#hlist-24"></a>  <span>head_type</span> <span>&amp;&amp;</span>head<span>()</span> <span>&amp;&amp;</span> <span>{</span> <span>return</span> <span>value_</span><span>;</span> <span>}</span></span>
<span id="hlist-25"><a href="#hlist-25"></a></span>
<span id="hlist-26"><a href="#hlist-26"></a>  <span>tail_type</span> <span>&amp;</span>tail<span>()</span> <span>&amp;</span> <span>{</span> <span>return</span> <span>*</span><span>this</span><span>;</span> <span>}</span></span>
<span id="hlist-27"><a href="#hlist-27"></a>  <span>const</span> <span>tail_type</span> <span>&amp;</span>tail<span>()</span> <span>const</span><span>&amp;</span> <span>{</span> <span>return</span> <span>*</span><span>this</span><span>;</span> <span>}</span></span>
<span id="hlist-28"><a href="#hlist-28"></a>  <span>tail_type</span> <span>&amp;&amp;</span>tail<span>()</span> <span>&amp;&amp;</span> <span>{</span> <span>return</span> <span>*</span><span>this</span><span>;</span> <span>}</span></span>
<span id="hlist-29"><a href="#hlist-29"></a><span>};</span></span>
<span id="hlist-30"><a href="#hlist-30"></a><span>// User-defined class template argument deduction guide:</span></span>
<span id="hlist-31"><a href="#hlist-31"></a><span>template</span><span>&lt;</span><span>typename</span> <span>...</span>T<span>&gt;</span> HList<span>(</span>T<span>...)</span> <span>-&gt;</span> HList<span>&lt;</span>T<span>...&gt;;</span></span>
<span id="hlist-32"><a href="#hlist-32"></a></span>
<span id="hlist-33"><a href="#hlist-33"></a><span>template</span><span>&lt;</span><span>std::</span>size_t<span> </span>N<span>&gt;</span> <span>struct</span> dummy<span>{};</span></span>
<span id="hlist-34"><a href="#hlist-34"></a><span>static_assert</span><span>(</span><span>sizeof</span><span>(</span>HList<span>&lt;</span>dummy<span>&lt;</span><span>0</span><span>&gt;,</span> dummy<span>&lt;</span><span>1</span><span>&gt;,</span> dummy<span>&lt;</span><span>2</span><span>&gt;&gt;)</span> <span>==</span> <span>1</span><span>);</span></span>
<span id="hlist-35"><a href="#hlist-35"></a><span>static_assert</span><span>(</span><span>sizeof</span><span>(</span>HList<span>&lt;</span>dummy<span>&lt;</span><span>0</span><span>&gt;,</span> dummy<span>&lt;</span><span>0</span><span>&gt;,</span> dummy<span>&lt;</span><span>0</span><span>&gt;&gt;)</span> <span>==</span> <span>3</span><span>);</span></span></code></pre></div>
<p>The basic idiom may already be familiar to the reader, but a few
things are worth pointing out for people less familiar with C++20 and
C++17. First, note the use of the attribute <a href="https://en.cppreference.com/w/cpp/language/attributes/no_unique_address"><code>[[no_unique_address]]</code></a>
on <a href="#hlist-14">line 14</a>. Without this attribute, the size of
<code>HList&lt;dummy&lt;0&gt;, dummy&lt;1&gt;, dummy&lt;2&gt;&gt;</code>
would be 3 bytes instead of 1 on <a href="#hlist-34">line 34</a>. Why?
Because C++ requires most objects (other than bit fields) to have a
unique address. However, there’s long been an exception called the <a href="https://en.cppreference.com/w/cpp/language/ebo">empty base
optimization (EBO)</a>. Roughly speaking, given the following types:</p>
<div id="cb28"><pre><code><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span>struct</span> Base <span>{};</span> <span>// empty</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span>struct</span> Derived <span>:</span> Base <span>{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span>/* ... unspecified ... */</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span>};</span></span></code></pre></div>
<p>EBO states that <code>Base</code> need not increase the size of
<code>Derived</code> so long as the first data member in
<code>Derived</code> doesn’t also start with <code>Base</code>. In other
words, <code>Base</code> is allowed to share the same address as any
other object not of type <code>Base</code>. Before C++20, implementers
of types such as <code>std::tuple</code> jumped through <a href="https://cor3ntin.github.io/posts/tuple/">quite a few hoops</a> to
exploit EBO to reduce tuple sizes. Now, however, we can use the <a href="https://en.cppreference.com/w/cpp/language/attributes/no_unique_address"><code>[[no_unique_address]]</code></a>
attribute to apply the same logic as EBO to any structure field, not
just the base class.</p>
<p>Note that despite this otimization,
<code>HList&lt;dummy&lt;0&gt;, dummy&lt;0&gt;, dummy&lt;0&gt;&gt;</code>
still has size 3 bytes, as seen on <a href="#hlist-35">line 35</a>,
because each instance of the same type <code>dummy&lt;0&gt;</code> still
needs a unique address. This makes a certain amount of sense. For
example, the constructor of <code>dummy&lt;0&gt;</code> might decide to
enter the object’s address in some global hash table, so while
<code>dummy&lt;1&gt;</code> and <code>dummy&lt;0&gt;</code> would
presumably have different hash tables, entering the same address twice
into <code>dummy&lt;0&gt;</code>’s hash table could lead to
confusion.</p>
<p>Another detail worth noting is the use of a <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">user-defined
deduction guide</a> on <a href="#hlist-31">line 31</a>. This allows us
to construct an <code>HList</code> without explicit template parameters,
as in <code>HList{1, 2, 3, &#34;hello&#34;}</code>. The deduction guide is
required because <code>HList::HList</code> takes arguments by forwarding
reference, yet we need to make sure to infer non-reference types for the
template parameters.</p>
<p><code>HList</code> lets us explore another good example application
of <a href="#integer-sequence"><code>std::make_index_sequence</code></a>, as
well as of our <a href="#is-template"><code>is_template</code></a>
concept above. Suppose we want to implement an <code>apply</code>
function analogous to <a href="https://en.cppreference.com/w/cpp/utility/apply"><code>std::apply</code></a>.
We can do this by implementing a <code>get</code> function, then
capturing an integer sequence of list indices to expand in
<code>apply</code>:</p>
<div id="cb29"><pre><code><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>std::</span>size_t<span> </span>N<span>,</span> is_template<span>&lt;</span>HList<span>&gt;</span> HL<span>&gt;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span>requires</span> <span>(</span>N <span>&lt;=</span> <span>std::</span>remove_cvref_t<span>&lt;</span>HL<span>&gt;::</span>len<span>)</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span>inline</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>drop<span>(</span>HL <span>&amp;&amp;</span>hl<span>)</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  <span>if</span> <span>constexpr</span> <span>(</span>N<span>)</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span>return</span> drop<span>&lt;</span>N<span>-</span><span>1</span><span>&gt;(</span><span>std::</span>forward<span>&lt;</span>HL<span>&gt;(</span>hl<span>).</span>tail<span>());</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  <span>else</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>std::</span>forward<span>&lt;</span>HL<span>&gt;(</span>hl<span>);</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>std::</span>size_t<span> </span>N<span>,</span> is_template<span>&lt;</span>HList<span>&gt;</span> HL<span>&gt;</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span>requires</span> <span>(</span>N <span>&lt;</span> <span>std::</span>remove_cvref_t<span>&lt;</span>HL<span>&gt;::</span>len<span>)</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span>inline</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>get<span>(</span>HL <span>&amp;&amp;</span>hl<span>)</span></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>  <span>return</span> drop<span>&lt;</span>N<span>&gt;(</span><span>std::</span>forward<span>&lt;</span>HL<span>&gt;(</span>hl<span>)).</span>head<span>();</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> F<span>,</span> is_template<span>&lt;</span>HList<span>&gt;</span> HL<span>&gt;</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span>decltype</span><span>(</span><span>auto</span><span>)</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>apply<span>(</span>F <span>&amp;&amp;</span>f<span>,</span> HL <span>&amp;&amp;</span>hl<span>)</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>  <span>[&amp;</span>f<span>,&amp;</span>hl<span>]&lt;</span><span>std::</span>size_t<span> ...</span>I<span>&gt;(</span><span>std::</span>index_sequence<span>&lt;</span>I<span>...&gt;)</span> <span>-&gt;</span> <span>decltype</span><span>(</span><span>auto</span><span>)</span> <span>{</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>std::</span>forward<span>&lt;</span>F<span>&gt;(</span>f<span>)(</span>get<span>&lt;</span>I<span>&gt;(</span><span>std::</span>forward<span>&lt;</span>HL<span>&gt;(</span>hl<span>))...);</span></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>  <span>}(</span><span>std::</span>make_index_sequence<span>&lt;</span><span>std::</span>remove_cvref_t<span>&lt;</span>HL<span>&gt;::</span>len<span>&gt;{});</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<h2 id="homogeneous-function-parameter-packs">Homogeneous function
parameter packs</h2>
<p>As <a href="#homogeneous-intro">previously mentioned</a>, it is
tricky to emulate a function taking a homogeneous variadic parameter
pack without introducing extra copies of the argument. Suppose you want
to implement a function equivalent to the (illegal)
<code>good(Obj ...obj)</code> that accepts a variable number of
arguments all of type <code>Obj</code> by value (meaning modification of
the arguments in the function does not affect the calling context). We
can of course write
<code>good(std::convertible_to&lt;Obj&gt; auto&amp;&amp; ...t)</code>,
but now we will capture a heterogeneous set of arguments. Some of these
arguments may be values from which we need to construct an
<code>Obj</code>, but others may already be an <code>Obj</code>
constructed specifically for this function, as when someone calls
<code>good(Obj{})</code>. In the latter case, we want to avoid
constructing a <em>second</em> <code>Obj</code> from the one that was
passed in as an argument. On the other hand, if the user called
<code>good(obj)</code> where <code>obj</code> is a variable containing
an existing <code>Obj</code>, then we must copy <code>obj</code>, since
the call-by-value semantics we want require that modifications of
argument variables inside <code>good</code> do not affect the variables
passed in.</p>
<p>When a new temporary <code>Obj</code> has been constructed as a
function call argument, the inferred type of the argument will be the
rvalue reference <code>Obj&amp;&amp;</code>. When an existing
<code>obj</code> is being passed in, the type will be the lvalue
reference <code>Obj&amp;</code> (or possibly
<code>const Obj&amp;</code>). The trick is to define a function
<code>local_copy</code> that will generate a new <code>Obj</code> in the
later case, but return a reference to an existing temporary
<code>Obj</code> in the former case. Here is the code:</p>
<div id="local-copy"><pre><code><span id="local-copy-1"><a href="#local-copy-1"></a><span>struct</span> Obj <span>{</span> <span>void</span> use<span>()</span> <span>{</span> <span>/* ... */</span> <span>}</span> <span>/* ... */</span> <span>};</span></span>
<span id="local-copy-2"><a href="#local-copy-2"></a></span>
<span id="local-copy-3"><a href="#local-copy-3"></a><span>template</span><span>&lt;</span><span>typename</span> Want<span>,</span> <span>typename</span> Have<span>&gt;</span></span>
<span id="local-copy-4"><a href="#local-copy-4"></a><span>inline</span> <span>std::</span>conditional_t<span>&lt;</span><span>std::</span>is_same_v<span>&lt;</span>Want<span>,</span> Have<span>&gt;,</span> Want <span>&amp;&amp;,</span> Want<span>&gt;</span></span>
<span id="local-copy-5"><a href="#local-copy-5"></a>local_copy<span>(</span>Have <span>&amp;</span>in<span>)</span></span>
<span id="local-copy-6"><a href="#local-copy-6"></a><span>{</span></span>
<span id="local-copy-7"><a href="#local-copy-7"></a>  <span>return</span> <span>static_cast</span><span>&lt;</span>Have<span>&amp;&amp;&gt;(</span>in<span>);</span></span>
<span id="local-copy-8"><a href="#local-copy-8"></a><span>}</span></span>
<span id="local-copy-9"><a href="#local-copy-9"></a></span>
<span id="local-copy-10"><a href="#local-copy-10"></a><span>template</span><span>&lt;</span><span>std::</span>convertible_to<span>&lt;</span>Obj<span>&gt;</span> <span>...</span>T<span>&gt;</span></span>
<span id="local-copy-11"><a href="#local-copy-11"></a><span>void</span></span>
<span id="local-copy-12"><a href="#local-copy-12"></a>good1<span>(</span>T<span>&amp;&amp;...</span>t<span>)</span></span>
<span id="local-copy-13"><a href="#local-copy-13"></a><span>{</span></span>
<span id="local-copy-14"><a href="#local-copy-14"></a>  <span>// Unary fold over comma operator</span></span>
<span id="local-copy-15"><a href="#local-copy-15"></a>  <span>(</span>local_copy<span>&lt;</span>Obj<span>,</span> T<span>&gt;(</span>t<span>).</span>use<span>(),</span> <span>...);</span></span>
<span id="local-copy-16"><a href="#local-copy-16"></a><span>}</span></span>
<span id="local-copy-17"><a href="#local-copy-17"></a></span>
<span id="local-copy-18"><a href="#local-copy-18"></a><span>// Another way to do it</span></span>
<span id="local-copy-19"><a href="#local-copy-19"></a><span>template</span><span>&lt;</span><span>std::</span>convertible_to<span>&lt;</span>Obj<span>&gt;</span> <span>...</span>T<span>&gt;</span></span>
<span id="local-copy-20"><a href="#local-copy-20"></a><span>void</span></span>
<span id="local-copy-21"><a href="#local-copy-21"></a>good2<span>(</span>T<span>&amp;&amp;...</span>t<span>)</span></span>
<span id="local-copy-22"><a href="#local-copy-22"></a><span>{</span></span>
<span id="local-copy-23"><a href="#local-copy-23"></a>  <span>auto</span> use <span>=</span> <span>[]&lt;</span><span>typename</span> U<span>&gt;(</span>U <span>&amp;&amp;</span>arg<span>)</span> <span>{</span></span>
<span id="local-copy-24"><a href="#local-copy-24"></a>    <span>decltype</span><span>(</span><span>auto</span><span>)</span> o <span>=</span> local_copy<span>&lt;</span>Obj<span>,</span> U<span>&gt;(</span>arg<span>);</span></span>
<span id="local-copy-25"><a href="#local-copy-25"></a>    o<span>.</span>use<span>();</span></span>
<span id="local-copy-26"><a href="#local-copy-26"></a>  <span>};</span></span>
<span id="local-copy-27"><a href="#local-copy-27"></a>  <span>(</span>use<span>(</span><span>std::</span>forward<span>&lt;</span>T<span>&gt;(</span>t<span>)),</span> <span>...);</span></span>
<span id="local-copy-28"><a href="#local-copy-28"></a><span>}</span></span></code></pre></div>
<p>To understand the implementation and use of <code>local_copy</code>,
you need to know a bunch of things about <a href="https://www.scs.stanford.edu/~dm/blog/decltype.html">C++ value
categories</a>:</p>
<ul>
<li><p>When a function argument is a <a href="https://timsong-cpp.github.io/cppwp/n4861/temp.deduct.call#3"><strong>forwarding
reference</strong></a>, as in
<code>template&lt;typename T&gt; void f(T &amp;&amp;t)</code>, the type
<code>T</code> will be an lvalue reference (e.g.,
<code>Type&amp;</code>) if <code>f</code> was invoked with an lvalue
(e.g., some variable <code>obj</code>) and a non-reference (e.g.,
<code>Type</code>) if <code>f</code> was invoked with an rvalue (e.g.,
<code>Obj{}</code>).</p></li>
<li><p>When you take a reference type <code>TR</code> and add an rvalue
reference, you get back <code>TR</code>, meaning
<code>TR&amp;&amp;</code> and <code>TR</code> are always the same type
for a reference. When you add an lvalue reference to reference type
<code>TR</code>, you always get back an lvalue reference, meaning
<code>TR&amp;</code> is always the same as
<code>std::remove_reference_t&lt;TR&gt;&amp;</code>. This is known as <a href="https://timsong-cpp.github.io/cppwp/n4861/dcl.ref#6"><strong>reference
collapsing</strong></a>, and it explains why, when an lvalue is passed
to forwarding reference <code>f(T&amp;&amp;t)</code>, <code>T</code> can
be inferred as an lvalue reference.</p></li>
<li><p>When treated as an expression, a variable <code>v</code> is
always an lvalue, regardless of whether <code>v</code> was declared as a
non-reference <code>T</code>, an lvalue-reference <code>T&amp;</code>,
or an rvalue-reference <code>T&amp;&amp;</code>. Hence, if you want a
forwarding reference to be inferred as something other than an lvalue
reference, you need to pass something other than a variable, such as a
function call result (e.g., <code>std::forward&lt;T&gt;(t)</code>) or a
cast (<code>static_cast&lt;T&amp;&amp;&gt;(t)</code>).</p></li>
<li><p>An expression that is an invocation of a function returning a
non-reference, non-<code>void</code> type is of a category known as a
<em>prvalue</em>. Since C++17, you can think of a prvalue as a set of
instructions for how to create an object that has not yet been created.
Hence, invoking <code>use_object</code> below creates only one
<code>Obj</code>, namely <code>o</code>, because what
<code>make_object()</code> returns is conceptually just a recipe saying,
“Please initialize some <code>Obj</code> with the default initializer
<code>{}</code>.”</p>
<div id="cb30"><pre><code><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span>// Doesn&#39;t copy or move an Obj, but requires the invoking</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span>// context to create a default-initialized Obj</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    Obj make_object<span>()</span> <span>{</span> <span>return</span> <span>{};</span> <span>}</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span>// Only one Obj is ever created per invocation</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span>void</span> use_object<span>()</span> <span>{</span> Obj o <span>=</span> make_object<span>();</span> o<span>.</span>use<span>();</span> <span>}</span></span></code></pre></div>
<p>This behavior is sometimes known as <a href="https://en.cppreference.com/w/cpp/language/copy_elision"><em>mandatory
copy elision</em></a>. Another way to think about it is that even if the
code for creating an <code>Obj</code> resides within the generated code
for <code>make_object</code>, the compiler must arrange for the new
<code>Obj</code> to reside in the stack frame that belongs to the
calling function (<code>use_object</code>) so that the <code>Obj</code>
isn’t destroyed on return from <code>make_object</code>.</p></li>
<li><p>When you declare a variable as <code>auto v = expression</code>,
the type deduction rules <a href="https://timsong-cpp.github.io/cppwp/n4861/dcl.type.auto.deduct#4">are
the same</a> as for templates—meaning <code>v</code>’s type will be the
non-reference type <code>T</code> inferred when invoking the template
function <!-- --> <code>template&lt;typename T&gt; void f(T t)</code>
with the same expression, i.e., <code>f(expression)</code>.</p></li>
<li><p>When you declare a variable as
<code>decltype(auto) v = expression</code>, the type of <code>v</code>
will be exactly <code>decltype(expression)</code>. <code>decltype</code>
is confusing for the uninitiated, as the single keyword does two totally
different things, often depending on something as trivial as extra
parentheses (<a href="https://www.scs.stanford.edu/~dm/blog/decltype.html#decltype-overview">details
here</a>). However, when <code>decltype</code> is applied to a function
call expression, the type is always exactly the return type of the
function, which can be a non-reference, lvalue-reference, or
rvalue-reference.</p></li>
</ul>
<p>In <code>good1</code>, we need to construct a new <code>Obj</code>
from the reference function argument in all cases except when the
argument was a temporary object (i.e., <code>good1(Obj{})</code>). When
the argument was a temporary, the inferred type <code>T</code> is
<code>Obj</code> (meaning argument <code>t</code> has type
<code>Obj&amp;&amp;</code>). If the argument was a variable of type
<code>Obj</code>, then <code>T</code> will be inferred as
<code>Obj&amp;</code>, and we need to copy it to avoid modifying it. If
the variable was anything other than an <code>Obj</code>, we need to
construct an <code>Obj</code> from it.</p>
<p>The goal of <a href="#local-copy-3"><code>local_copy</code></a> is to
construct a new object of type <code>Want</code> from an argument of
type <code>Have</code> unless the argument is already a temporary object
of type <code>Want</code>, in which case it should just return a
reference to the existing temporary object. The return type of the
function uses <a href="https://en.cppreference.com/w/cpp/types/conditional"><code>std::conditional_t</code></a>
to distinguish these two cases—it returns a new <code>Want</code>
(meaning a prvalue) unless <code>Want</code> and <code>Have</code> are
the same type, in which case it returns an rvalue reference to its input
object.</p>
<p>Notice that <code>local_copy</code> takes a <code>Have&amp;</code>
and not a <code>Have&amp;&amp;</code>, because it is intended to be used
with variables, whose expression type will always be an lvalue and hence
cannot be bound to an rvalue reference. (We explicitly specify the type
of <code>Have</code> when invoking <code>local_copy</code>, so it can’t
be a forwarding reference.) <code>local_copy</code> casts its return
value to <code>Have&amp;&amp;</code>, which (through reference
collapsing) is the same as <code>Have</code> when <code>Have</code> is
an lvalue reference. It’s also possible that the argument was a
temporary object of type other than <code>Obj</code>, in which case it
is returned as an rvalue reference from which the return
<code>Obj</code> is constructed.</p>
<p>There are still a few cases in which <code>good1</code> behaves
differently from the hypothetical homogeneous
<code>good(Obj ...arg)</code>. If you call
<code>good1(std::move(obj))</code>, no new <code>Obj</code> will be
constructed from the argument, whereas ordinarily you would expect to
move-construct a new <code>Obj</code>. Arguably this is a feature; since
a moved object is left in an unspecified state, the main differences in
semantics will be one fewer invocation of the move constructor
<code>Obj::Obj(Obj&amp;&amp;)</code> (or copy constructor if
<code>Obj</code> lacks a move constructor). Another difference is that
you can call <code>good({})</code> and the <code>{}</code> will
construct an <code>Obj</code>, since the argument type is known, whereas
<code>good1({})</code> is illegal because the compiler doesn’t know the
argument type.</p>
<p>By the way, if this all seems too complex, there is sometimes an
alternative to variadic functions for homogenous argument lists—you can
write functions to take an <code>initializer_list</code>:</p>
<div id="cb31"><pre><code><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span>inline</span> <span>void</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>almost_good3<span>(</span><span>std::</span>initializer_list<span>&lt;</span>Obj<span>&gt;</span> args<span>)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span>for</span> <span>(</span><span>const</span> Obj <span>&amp;</span>o <span>:</span> args<span>)</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    o<span>.</span>use<span>();</span> <span>// doesn&#39;t work with non-const method, though</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The two disadvantages are that you’ll have to call the function with
an extra set of braces, as in <code>alsmost_good3({obj, Obj{}})</code>,
and that you only have <code>const</code> access to members of
<code>std::initializer_list</code>, so it won’t work with our example
<code>Obj</code> type, in which the <code>use()</code> method is not
<code>const</code>.</p>
<!---
To make it work in our example, we need to use a `mutable` field of
type `Obj` that we can manipulate even in a `const` member of a
`std::initializer_list`:

~~~~ {.cc}
template<typename T>
struct mut_holder {
  mutable T val;

  template<typename ...U>
  mut_holder(U &&...u) : val(std::forward<U>(u)...) {}
};

inline void
good3(std::initializer_list<mut_holder<Obj>> args)
{
  for (auto &o : args)
    o.val.use();
}
~~~~
--->
<h2 id="array-of-function-pointers">Array of function pointers</h2>
<p>Sometimes you need to convert a runtime constant into a compile-time
constant without manually writing out every possible value in a
<code>switch</code> statement. The best way to do this is to initialize
an array of function pointers using a parameter pack expansion.</p>
<p>As an example, suppose you wish to serialize a <a href="https://en.cppreference.com/w/cpp/utility/variant"><code>std::variant</code></a>
<code>v</code>. You can serialize the current type of the variant by
serializing the number <code>v.index()</code>. Then you can serialize
the body of the variant with <a href="https://en.cppreference.com/w/cpp/utility/variant/visit"><code>std::visit</code></a>.
To deserialize <code>v</code>, you must reverse the process. First,
deserialize the index value <code>i</code>. Then set
<code>v.index()</code> to <code>i</code> by setting <code>v</code> to
contain its <code>i</code>th type. Finally, deserialize the contents
with <code>std::visit</code>.</p>
<p>Unfortunately, the problem with this plan is that the inverse of
<code>v.index()</code>—a method to <em>set</em> the index of the
variant—does not exist. We could try to implement such a function by
brute-force, but the result will be problematic:</p>
<div id="cb32"><pre><code><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span>// Painful to write, only works if variant has exactly 3 types</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span>void</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>set_index<span>(</span><span>auto</span> <span>&amp;</span>v<span>,</span> <span>std::</span>size_t<span> </span>n<span>)</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span>switch</span> <span>(</span>n<span>)</span> <span>{</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>0</span><span>:</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    v<span>.</span><span>template</span> emplace<span>&lt;</span><span>0</span><span>&gt;();</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span>break</span><span>;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>1</span><span>:</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    v<span>.</span><span>template</span> emplace<span>&lt;</span><span>1</span><span>&gt;();</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    <span>break</span><span>;</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>2</span><span>:</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    v<span>.</span><span>template</span> emplace<span>&lt;</span><span>2</span><span>&gt;();</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>    <span>break</span><span>;</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>The less serious problem with this code is that it is very tedious to
write. Even though <code>emplace</code> really is a different function
for each index of the variant, writing it out this way is painful. The
more serious problem is that the above function only works for variants
with exactly 3 cases. A variant with only 2 cases doesn’t have valid
code for <code>emplace&lt;2&gt;</code>, so invoking
<code>set_index</code> on such a type will fail to compile.</p>
<p>What we need is a way to take a runtime constant and convert it to a
compile time constant we can supply as a template parameter to
<code>v.emplace&lt;</code><span>∘</span><code>&gt;()</code>. We can represent
compile-time constants with the template type <a href="https://en.cppreference.com/w/cpp/types/integral_constant"><code>std::integral_constant</code></a>,
which has a <code>constexpr</code> conversion operator returning the
integral value represented by the type. Conceptually, we would like to
do something like this:</p>
<div id="cb33"><pre><code><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span>// Parse a pack of char as a decimal number</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span>constexpr</span> <span>std::</span>size_t</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>chars2size<span>(</span><span>std::</span>same_as<span>&lt;</span><span>char</span><span>&gt;</span> <span>auto</span> <span>...</span>c<span>)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  <span>std::</span>size_t<span> </span>r <span>=</span> <span>0</span><span>;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>  <span>for</span> <span>(</span><span>std::</span>size_t<span> </span>i <span>:</span> <span>{</span> c<span>...</span> <span>})</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    r <span>=</span> r<span>*</span><span>10</span> <span>+</span> i <span>-</span> <span>&#39;0&#39;</span><span>;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  <span>return</span> r<span>;</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a><span>// Define 0_const, 1_const, etc. as compile-time integral constants</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span>// (Note: doesn&#39;t work with clang++ yet)</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>char</span> <span>...</span>C<span>&gt;</span> <span>requires</span> <span>((</span>C <span>&gt;=</span> <span>&#39;0&#39;</span> <span>&amp;&amp;</span> C <span>&lt;=</span> <span>&#39;9&#39;</span><span>)</span> <span>&amp;&amp;</span> <span>...)</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span>consteval</span> <span>std::</span>integral_constant<span>&lt;</span><span>std::</span>size_t<span>,</span> chars2size<span>(</span>C<span>...)&gt;</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a><span>operator</span> <span>&#34;&#34;</span>_const<span>()</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>  <span>return</span> <span>{};</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a><span>// Illegal nonsense--a function can only return one type</span></span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a><span>auto</span></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>get_constant<span>(</span><span>std::</span>size_t<span> </span>n<span>)</span></span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>  <span>switch</span> <span>(</span>n<span>)</span> <span>{</span></span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>0</span><span>:</span></span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>0_const</span><span>;</span></span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>1</span><span>:</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>1_const</span><span>;</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>  <span>// ...</span></span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Of course, that doesn’t make sense because <code>0_const</code> and
<code>1_const</code> are of different types. A function can only return
one type (which obviously can’t depend on a runtime argument). In order
for a function to produce a type dependent on a runtime parameter,
instead of returning the type, the function needs to call an overloaded
function object. We therefore must implement something like the
following:</p>
<div id="cb34"><pre><code><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span><span>typename</span> R <span>=</span> <span>void</span><span>,</span> <span>typename</span> F<span>&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span>inline</span> <span>constexpr</span> R</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>with_constant<span>(</span><span>std::</span>size_t<span> </span>n<span>,</span> F <span>&amp;&amp;</span>f<span>)</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span>switch</span> <span>(</span>n<span>)</span> <span>{</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>0</span><span>:</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>std::</span>forward<span>&lt;</span>F<span>&gt;(</span>f<span>)(</span><span>0_const</span><span>);</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span>case</span> <span>1</span><span>:</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>    <span>return</span> <span>std::</span>forward<span>&lt;</span>F<span>&gt;(</span>f<span>)(</span><span>1_const</span><span>);</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  <span>// ...</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  <span>}</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span>}</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span>void</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>set_index<span>(</span><span>auto</span> <span>&amp;</span>v<span>,</span> <span>std::</span>size_t<span> </span>n<span>)</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>  with_constant<span>(</span>n<span>,</span> <span>[&amp;</span>v<span>](</span><span>auto</span> i<span>)</span> <span>{</span> v<span>.</span><span>template</span> emplace<span>&lt;</span>i<span>&gt;();</span> <span>});</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Okay, so now we know what the function should look like, but we still
have the problem that it only works for a fixed number of values of
<code>n</code>. Not even a fixed maximum, but a fixed number. However,
we can fix this by taking the maximum value as a parameter, then using
<code>std::make_index_sequence</code> to generate a parameter pack that
we expand into an array of function pointers.</p>
<div id="with-n"><pre><code><span id="with-n-1"><a href="#with-n-1"></a><span>namespace</span> detail <span>{</span></span>
<span id="with-n-2"><a href="#with-n-2"></a></span>
<span id="with-n-3"><a href="#with-n-3"></a><span>template</span><span>&lt;</span><span>std::</span>size_t<span> </span>I<span>,</span> <span>typename</span> R<span>,</span> <span>typename</span> F<span>&gt;</span></span>
<span id="with-n-4"><a href="#with-n-4"></a><span>inline</span> <span>constexpr</span> R with_integral_constant<span>(</span>F f<span>)</span></span>
<span id="with-n-5"><a href="#with-n-5"></a><span>{</span></span>
<span id="with-n-6"><a href="#with-n-6"></a>  <span>return</span> <span>static_cast</span><span>&lt;</span>F<span>&gt;(</span>f<span>)(</span><span>std::</span>integral_constant<span>&lt;</span><span>std::</span>size_t<span>,</span> I<span>&gt;{});</span></span>
<span id="with-n-7"><a href="#with-n-7"></a><span>}</span></span>
<span id="with-n-8"><a href="#with-n-8"></a></span>
<span id="with-n-9"><a href="#with-n-9"></a><span>}</span> <span>// namespace detail</span></span>
<span id="with-n-10"><a href="#with-n-10"></a></span>
<span id="with-n-11"><a href="#with-n-11"></a><span>template</span><span>&lt;</span><span>std::</span>size_t<span> </span>N<span>,</span> <span>typename</span> R <span>=</span> <span>void</span><span>,</span> <span>typename</span> F<span>&gt;</span></span>
<span id="with-n-12"><a href="#with-n-12"></a><span>inline</span> <span>constexpr</span> R</span>
<span id="with-n-13"><a href="#with-n-13"></a>with_n<span>(</span><span>int</span> n<span>,</span> F <span>&amp;&amp;</span>f<span>)</span></span>
<span id="with-n-14"><a href="#with-n-14"></a><span>{</span></span>
<span id="with-n-15"><a href="#with-n-15"></a>  <span>constexpr</span> <span>auto</span> invoke_array <span>=</span></span>
<span id="with-n-16"><a href="#with-n-16"></a>    <span>[]&lt;</span><span>std::</span>size_t<span>...</span>I<span>&gt;(</span><span>std::</span>index_sequence<span>&lt;</span>I<span>...&gt;)</span> <span>{</span></span>
<span id="with-n-17"><a href="#with-n-17"></a>    <span>return</span> <span>std::</span>array<span>{</span> detail::with_integral_constant<span>&lt;</span>I<span>,</span> R<span>,</span> F<span>&amp;&amp;&gt;...</span> <span>};</span></span>
<span id="with-n-18"><a href="#with-n-18"></a>  <span>}(</span><span>std::</span>make_index_sequence<span>&lt;</span>N<span>&gt;{});</span></span>
<span id="with-n-19"><a href="#with-n-19"></a></span>
<span id="with-n-20"><a href="#with-n-20"></a>  <span>return</span> invoke_array<span>.</span>at<span>(</span>n<span>)(</span><span>std::</span>forward<span>&lt;</span>F<span>&gt;(</span>f<span>));</span></span>
<span id="with-n-21"><a href="#with-n-21"></a><span>}</span></span>
<span id="with-n-22"><a href="#with-n-22"></a></span>
<span id="with-n-23"><a href="#with-n-23"></a><span>template</span><span>&lt;</span><span>typename</span> T<span>&gt;</span> <span>requires</span> <span>requires</span> <span>{</span></span>
<span id="with-n-24"><a href="#with-n-24"></a>  <span>{</span> <span>std::</span>variant_size_v<span>&lt;</span>T<span>&gt;+</span><span>0</span> <span>}</span> <span>-&gt;</span> <span>std::</span>same_as<span>&lt;</span><span>std::</span>size_t<span>&gt;;</span></span>
<span id="with-n-25"><a href="#with-n-25"></a><span>}</span></span>
<span id="with-n-26"><a href="#with-n-26"></a><span>void</span></span>
<span id="with-n-27"><a href="#with-n-27"></a>set_index<span>(</span>T <span>&amp;</span>t<span>,</span> <span>std::</span>size_t<span> </span>n<span>)</span></span>
<span id="with-n-28"><a href="#with-n-28"></a><span>{</span></span>
<span id="with-n-29"><a href="#with-n-29"></a>  with_n<span>&lt;</span><span>std::</span>variant_size_v<span>&lt;</span>T<span>&gt;&gt;(</span>n<span>,</span> <span>[&amp;</span>t<span>](</span><span>auto</span> i<span>)</span> <span>{</span></span>
<span id="with-n-30"><a href="#with-n-30"></a>    t<span>.</span><span>template</span> emplace<span>&lt;</span>i<span>&gt;();</span></span>
<span id="with-n-31"><a href="#with-n-31"></a>  <span>});</span></span>
<span id="with-n-32"><a href="#with-n-32"></a><span>}</span></span></code></pre></div>
<p>Some notes on the above code. First, note that <a href="#with-n-15"><code>invoke_array</code></a>, because it is an array,
must have all its elements be of the same type. Hence, we really do need
<a href="#with-n-3"><code>detail::with_integral_constant</code></a> to
be a function, rather than a lambda expression, to ensure all elements
of the array have the same type. We could create an array of <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function&lt;R(F&amp;&amp;)&gt;</code></a>,
but <code>std::function::~function</code> is not a
<code>constexpr</code> destructor, so then <code>invoke_array</code>
could not be <code>constexpr</code>, which might inhibit some compiler
optimizations. (Note in some cases, if you have non-generic lambdas with
no variable capture, they can be <a href="https://timsong-cpp.github.io/cppwp/n4868/expr.prim.lambda#closure-7">converted</a>
to ordinary function pointers by <a href="https://timsong-cpp.github.io/cppwp/n4868/over.built#9">prefixing
the lambda with <code>+</code></a>, as in <code>+[]{}</code>.)</p>
<p>Next, note that we supply the number of possible values,
<code>N</code>, as the first template argument to <a href="#with-n-12"><code>with_n</code></a>, and this argument is
mandatory. By using <code>std::array::at</code>, we ensure that an
exception will be thrown for out-of-bounds values of <code>n</code>.
Note also that if we want to use <code>with_n</code> with a return type
other than <code>void</code>, it must be supplied as the second template
argument <code>R</code>. Since the code is different for each value of
<code>n</code>, we can’t infer a return type. (Possibly we could do
something fancy to compute a plausible return type using <a href="https://en.cppreference.com/w/cpp/types/common_type"><code>std::common_type_t</code></a>,
but it doesn’t seem worth the complexity.)</p>
<p>As a reminder about <a href="https://en.cppreference.com/w/cpp/language/constraints">constraints</a>,
the clause
<code>{ std::variant_size_v&lt;T&gt;+0 } -&gt; std::same_as&lt;std::size_t&gt;</code>
is known as a <em>compound requirement</em>, and states that
<code>decltype((</code><span>∘</span><code>))</code>
of the expression in braces must satisfy the constraint to the right of
the arrows. Since the expression
<code>(std::variant_size_v&lt;T&gt;)</code> is probably an lvalue of
type <code>const std::size_t&amp;</code>, we just add 0 to turn it into
a prvalue of type <code>std::size_t</code>, avoiding any worries about
the const or references. An alternative would be to use our <a href="#is-template"><code>is_template</code></a> concept, as in:</p>
<div id="cb35"><pre><code><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span>template</span><span>&lt;</span>is_template<span>&lt;</span><span>std::</span>variant<span>&gt;</span> T<span>&gt;</span> </span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span>void</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>set_index<span>(</span>T <span>&amp;</span>t<span>,</span> <span>std::</span>size_t<span> </span>n<span>)</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span>/* ... */</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span>}</span></span></code></pre></div>
<p>Finally, note the importance of our <a href="#with-n-29">lambda</a>
in <code>set_index</code> accepting the parameter by value
(<code>auto i</code>) and not by reference
(<code>auto &amp;&amp;i</code> or <code>const auto &amp;i</code>).
Because of some quirkiness in how <code>constexpr</code> works, you <a href="https://github.com/cplusplus/papers/issues/973">can’t</a> call
<code>constexpr</code> methods (such as
<code>std::integral_constant::operator std::size_t</code>) on a
reference at compile time, only on a value. Hence, <a href="#with-n-30">line 30</a> will cause a compilation error if
<code>i</code> is a reference.</p>

<p>As C++ evolves, many old, error-prone, and frankly disgusting idioms
are no longer necessary and should be eliminated. For instance, you
should never again rely on <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> now
that we have <a href="https://en.cppreference.com/w/cpp/language/constraints">concepts</a>.
Similarly, it’s time to update our variadic function idioms to leverage
the new language features. Concepts now allow us to restrict the types
in a function parameter pack. <code>constexpr</code>-by-default lambdas
help us capture parameter packs even in contexts such as <a href="#using-lambda-expressions-to-capture-packs-in-requires-clauses">requires
clauses</a>. The ability to use lambdas in unevaluated contexts lets us
<a href="#using-decltype-on-lambda-expressions">avoid helper classes</a>
for many purposes. <a href="#comma-fold">Folds</a> and <a href="https://en.cppreference.com/w/cpp/language/if"><code>if constexpr</code></a>
can save us from implementing multiple overloaded functions for
recursive and base cases. <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class
template argument deduction</a> makes it possible to introduce types
such as <a href="#multilambda"><code>multilambda</code></a> without
helper functions to create them.</p>
<p>Unfortunately, effective use of variadic templates still involves
some unwieldy idioms, in large part because of the asymmetry between
expanding patterns (which works in many contexts) and capturing
parameter packs (which often requires introducing otherwise unnecessary
lambda expressions). If C++ adopts <a href="https://open-std.org/JTC1/SC22/WG21/docs/papers/2018/p1061r0.html">parameter
packs in structured bindings</a>, this will go a long way towards
further simplifying the use of parameter packs. Another nice feature
would be <a href="https://wg21.link/p1219r0">homogeneous variadic
function parameters</a>, though unfortunately that was <a href="https://github.com/cplusplus/papers/issues/297">rejected</a> by
the committee, so won’t be adopted in current form. Still, perhaps a
future version of the standard could at least deprecate omitting the
comma in declarations of old-style varargs functions, which is the main
impediment.</p>
<p>I hope the idioms I presented are useful to you. If you are still
writing C++17-compatible code, I hope this post provides further
motivation for you to abandon legacy compatibility and embrace the
significant improvements in C++20.</p>



</div>
  </body>
</html>
