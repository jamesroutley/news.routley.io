<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sjer.red/blog/2024-12-21/">Original</a>
    <h1>TIL: `satisfies` is my favorite TypeScript keyword</h1>
    
    <div id="readability-page-1" class="page"><div> <div>  <div> <article> <hgroup>  <span> <time datetime="2024-12-21T07:00:00.000Z"> Sat, Dec 21, 2024 </time>  </span> </hgroup>   <p>I’ve been doing a lot of work in TypeScript lately, and with that I’ve spent quite a bit of time learning more about its type system. TypeScript is a wonderfully advanced language though it has an unfortunately steep learning curve; in many ways it’s the complete opposite of Go.</p>
<p>One confusing thing about TypeScript is that it doesn’t always infer the most precise type possible. As an example:</p>
<pre tabindex="0" data-language="ts"><code><span><span>// name is of type &#34;Jerred&#34;</span></span>
<span><span>const</span><span> </span><span><span>name</span></span><span> =</span><span> &#34;Jerred&#34;</span><span>;</span></span>
<span></span>
<span><span>// person1 is of type { name: string }</span></span>
<span><span>const</span><span> </span><span><span>person1</span></span><span> =</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// person2 is of type { readonly name: &#34;Jerred&#34; }</span></span>
<span><span>const</span><span> </span><span><span>person2</span></span><span> =</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>} </span><span>as</span><span> </span><span><span>const</span></span><span>;</span></span></code></pre>
<p>Why is the name of <code>person1</code> of type <code>string</code> and not the literal <code>&#34;Jerred&#34;</code>? Because the object <em>could</em> be mutated to contain any other string.</p>
<p>What happens when I want to pass those objects to a function that requires <code>name</code> to be <code>&#34;Jerred&#34;</code>?</p>
<pre tabindex="0" data-language="ts"><code><span><span>function</span><span> </span><span><span>handleJerred</span></span><span>(</span><span><span>name</span></span><span>:</span><span> &#34;Jerred&#34;</span><span>) {</span></span>
<span><span>  // do something</span></span>
<span><span>}</span></span>
<span></span>
<span><span>// these are okay</span></span>
<span><span><span>handleJerred</span></span><span>(</span><span><span>name</span></span><span>);</span></span>
<span><span><span>handleJerred</span></span><span>(</span><span><span>person2</span></span><span>.</span><span><span>name</span></span><span>);</span></span>
<span></span>
<span><span><span>handleJerred</span></span><span>(</span><span><span>person1</span><span>.</span><span>name</span></span><span>);</span></span><p>Argument of type &#39;string&#39; is not assignable to parameter of type &#39;&#34;Jerred&#34;&#39;.</p></code></pre>
<p>As we’d expect, the types don’t match up. The most obvious way is to annotate the variable declaration with the expected type:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> </span><span><span>person1</span></span><span>:</span><span> { </span><span><span>name</span></span><span>:</span><span> &#34;Jerred&#34;</span><span> } </span><span>=</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// okay</span></span>
<span><span><span>handleJerred</span></span><span>(</span><span><span>person1</span></span><span>.</span><span><span>name</span></span><span>);</span></span></code></pre>
<p>We could also use the <code>satisfies</code> keyword. This keyword is a bit esoteric and not very common, but it comes in handy in some scenarios where you’d otherwise pull your hair out.</p>
<p>Here’s a quick example just to show the syntax:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> </span><span><span>person1</span></span><span> =</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>} </span><span>satisfies</span><span> { </span><span><span>name</span></span><span>:</span><span> &#34;Jerred&#34;</span><span> };</span></span>
<span></span>
<span><span>// okay</span></span>
<span><span><span>handleJerred</span></span><span>(</span><span><span>person1</span></span><span>.</span><span><span>name</span></span><span>);</span></span></code></pre>
<p><code>satisfies</code> is an alternative to an explicit variable type annotation. It tells TypeScript that your assignment should be <em>at least</em> assignable to the provided type. It’s kind of like a type-safe way to cast values.</p>
<p>The benefit of <code>satifies</code> over an variable type annotation is that it lets TypeScript infer a more specific type based on the value provided. Consider this scenario:</p>
<pre tabindex="0" data-language="ts"><code><span><span>type</span><span> </span><span><span>Person</span></span><span> =</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>:</span><span> string</span><span>;</span></span>
<span><span>  </span><span><span>isCool</span></span><span>:</span><span> boolean</span><span>;</span></span>
<span><span>};</span></span>
<span></span>
<span><span>function</span><span> </span><span><span>coolPeopleOnly</span></span><span>(</span><span><span>person</span></span><span>:</span><span> </span><span><span>Person</span></span><span> &amp;</span><span> { </span><span><span>isCool</span></span><span>:</span><span> true</span><span> }) {</span></span>
<span><span>  // only cool people can enter here</span></span>
<span><span>}</span></span>
<span></span>
<span><span>const</span><span> </span><span><span>person1</span></span><span>:</span><span> </span><span><span>Person</span></span><span> =</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>  </span><span><span>isCool</span></span><span>: </span><span>true</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// okay, so we need to say that `isCool` is true</span></span>
<span><span><span>coolPeopleOnly</span></span><span>(</span><span><span>person1</span></span><span>);</span></span><p>Argument of type &#39;Person&#39; is not assignable to parameter of type &#39;Person &amp; { isCool: true; }&#39;.
  Type &#39;Person&#39; is not assignable to type &#39;{ isCool: true; }&#39;.
    Types of property &#39;isCool&#39; are incompatible.
      Type &#39;boolean&#39; is not assignable to type &#39;true&#39;.</p><span></span>
<span><span>// and we also need to include the name field...</span></span>
<span><span>const</span><span> </span><span><span>person2</span></span><span>:</span><span> { </span><span><span>isCool</span></span><span>:</span><span> true</span><span> } </span><span>=</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span><p>Object literal may only specify known properties, and &#39;name&#39; does not exist in type &#39;{ isCool: true; }&#39;.</p><span><span>  </span><span><span>isCool</span></span><span>: </span><span>true</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>const</span><span> </span><span><span>person3</span></span><span>:</span><span> { </span><span><span>name</span></span><span>:</span><span> string</span><span>; </span><span><span>isCool</span></span><span>:</span><span> true</span><span> } </span><span>=</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>  </span><span><span>isCool</span></span><span>: </span><span>true</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span><span>coolPeopleOnly</span></span><span>(</span><span><span>person3</span></span><span>);</span></span></code></pre>
<p>A simpler solution is to use <code>satifies</code>:</p>
<pre tabindex="0" data-language="ts"><code><span><span>const</span><span> </span><span><span>person</span></span><span> =</span><span> {</span></span>
<span><span>  </span><span><span>name</span></span><span>: </span><span>&#34;Jerred&#34;</span><span>,</span></span>
<span><span>  </span><span><span>isCool</span></span><span>: </span><span>true</span><span>,</span></span>
<span><span>} </span><span>satisfies</span><span> </span><span><span>Person</span></span><span>;</span></span>
<span></span>
<span><span><span>coolPeopleOnly</span></span><span>(</span><span><span>person</span></span><span>);</span></span></code></pre>
<p>TypeScript will ensure that your value is assignable to your type. The type of the assigned variable will be made based on the type of the value instead of the type provided to <code>satisfies</code>.</p>
<p>This really comes in handy when you want to ensure that TypeScript is being as specific as possible.</p>
<p>Read more:</p>
<ul>
<li><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html">TypeScript documentation</a></li>
<li><a href="https://www.learningtypescript.com/articles/the-satisfies-operator">Learning TypeScript</a></li>
<li><a href="https://www.totaltypescript.com/clarifying-the-satisfies-operator">Total TypeScript</a></li>
</ul>   </article> </div>  </div> </div></div>
  </body>
</html>
