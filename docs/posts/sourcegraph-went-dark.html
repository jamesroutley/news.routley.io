<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://eric-fritz.com/articles/sourcegraph-went-dark/">Original</a>
    <h1>Sourcegraph went dark</h1>
    
    <div id="readability-page-1" class="page"><div id="site-wrapper"><main role="main"><div><article><header><h2><a href="https://eric-fritz.com/articles/sourcegraph-went-dark/">Sourcegraph went dark</a></h2></header><section><p>Towards the end of my mid-2019 job search, I was down to joining the Google Go team or Sourcegraph. Sourcegraph ultimately won due to cultural factors - the most important of which was the ability to <strong>build 100% in the open</strong>. All documents were public by default. Technical and product RFCs (and later PR/FAQs) were drafted, reviewed, and catalogued in a public Google Drive folder. All product implementation was done in public GitHub repositories.</p><p>Today, the <code>sourcegraph/sourcegraph</code> repository went private. This is the final cleaving blow, following many other smaller chops, on the culture that made Sourcegraph an attractive place to work. It’s a decision for a business from which I resigned, and therefore have no voice. But I still lament the rocky accessibility of artifacts showing four years of genuine effort into a product that I loved (and miss the use of daily in my current role).</p><p>On the bright side, I’ve cemented my place on the insights leaderboard for the remainder of time.</p><figure><a href="#img-insights"><img src="https://swe-to-mle.pages.dev/assets/images/sg-went-dark/leaderboard.png" alt="Contributor leaderboard"/></a></figure><a href="#_" id="img-insights"><img src="https://swe-to-mle.pages.dev/assets/images/sg-went-dark/leaderboard.png"/></a><p>Sourcegraph has made their future development repository private, but it seems they&#39;ve left a public snapshot available at <a href="https://github.com/sourcegraph/sourcegraph-public-snapshot"><code>sourcegraph/sourcegraph-public-snapshot</code></a> for the time being.</p><h2 id="keeping-references-alive">Keeping references alive</h2><p>Over my tenure at Sourcegraph I’ve done <a href="https://swe-to-mle.pages.dev/tags/sourcegraph/">a fair bit of writing</a> for the engineering blog, which I’ve inlined into this website for stable reference. It’s interesting to see what people are trying to build and, for an engineer, how they’re trying to build it. Much of my writing used links into relevant public code as a reference.</p><p>All of these links are now broken.</p><p>There’s a common saying that <a href="https://www.w3.org/Provider/Style/URI">cool URIs don’t change</a>. In a related sense, I have the hot take that <em>cool articles don’t suddenly start rotting links</em>. I’m going to break at least <strong>one</strong> of these best practices, and I can’t do anything about the first one. So I’ll attempt to preserve as much information in this writing as possible by moving these links into a repository under my influence.</p><p>I&#39;m opting to bite the bullet now and move references to something completely under my control rather than kick then can down the road by referencing another repository that _could_ suddenly disappear at any time.</p><p>I had a feeling this would be a risk a while ago, so I had forked <code>sourcegraph/sourcegraph</code> into <a href="https://github.com/efritz/sourcegraph"><code>efritz/sourcegraph</code></a> in preparation. Given the fork, it should be easy enough job to do a global find-and-replace of one repository name with another at this point and mission accomplished, right?</p><p>Unfortunately, no. I had links to code on the <code>main</code> branch, but also links to pull requests and commits within pull requests. Forks don’t inherit pull requests (problem #1). And commits not directly referenced by a branch of your fork are visible as only as long as they’re part of the repository network (problem #2).</p><figure><a href="#img-warning"><img src="https://swe-to-mle.pages.dev/assets/images/sg-went-dark/warning.png" alt="Non-local commit warning"/></a></figure><a href="#_" id="img-warning"><img src="https://swe-to-mle.pages.dev/assets/images/sg-went-dark/warning.png"/></a><p>I had wondered <a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/working-with-forks/what-happens-to-forks-when-a-repository-is-deleted-or-changes-visibility">what happens to forks when a repository is deleted or changes visibility</a> and found some calming information in the official GitHub documentation:</p><blockquote><p>In other words, a public repository’s forks will remain public in their own separate repository network even after the upstream repository is made private. This allows the fork owners to continue to work and collaborate without interruption. […] If a public repository is made private and then deleted, its public forks will continue to exist in a separate network.</p></blockquote><p><em>My fork will continue to exist</em> (yay), but the source repository becoming inaccessible might take commits outside of the <code>main</code> branch with it. I need to ensure that these commits are part of the new repository network.</p><h2 id="scraping-for-relevant-commits">Scraping for relevant commits</h2><p>Step one is to find all the commits I care about. I ran the following Go program to iterate through all of <em>my</em> pull requests on the source repository and write their payloads to disk for further processing.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span><span>49
</span><span>50
</span><span>51
</span><span>52
</span><span>53
</span><span>54
</span><span>55
</span><span>56
</span><span>57
</span><span>58
</span><span>59
</span><span>60
</span><span>61
</span><span>62
</span><span>63
</span><span>64
</span><span>65
</span><span>66
</span><span>67
</span><span>68
</span><span>69
</span><span>70
</span><span>71
</span><span>72
</span><span>73
</span><span>74
</span><span>75
</span><span>76
</span><span>77
</span><span>78
</span><span>79
</span><span>80
</span><span>81
</span><span>82
</span></code></pre></td><td><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> main
</span></span><span><span>
</span></span><span><span><span>import</span> (
</span></span><span><span>	<span>&#34;context&#34;</span>
</span></span><span><span>	<span>&#34;encoding/json&#34;</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;log&#34;</span>
</span></span><span><span>	<span>&#34;os&#34;</span>
</span></span><span><span>	<span>&#34;strings&#34;</span>
</span></span><span><span>	<span>&#34;time&#34;</span>
</span></span><span><span>
</span></span><span><span>	<span>&#34;github.com/google/go-github/v63/github&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>const</span> (
</span></span><span><span>	owner      = <span>&#34;sourcegraph&#34;</span>
</span></span><span><span>	repo       = <span>&#34;sourcegraph&#34;</span>
</span></span><span><span>	targetUser = <span>&#34;efritz&#34;</span>
</span></span><span><span>	token      = <span>&#34;ghp_pls_dont_hax_me&#34;</span>
</span></span><span><span>)
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span>() {
</span></span><span><span>	ctx <span>:=</span> context.<span>Background</span>()
</span></span><span><span>
</span></span><span><span>	<span>if</span> err <span>:=</span> <span>scrapePRs</span>(ctx); err <span>!=</span> <span>nil</span> {
</span></span><span><span>		log.<span>Fatalf</span>(<span>&#34;Error: %v&#34;</span>, err)
</span></span><span><span>	}
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>func</span> <span>scrapePRs</span>(ctx context.Context) <span>error</span> {
</span></span><span><span>	client <span>:=</span> github.<span>NewClient</span>(<span>nil</span>).<span>WithAuthToken</span>(token)
</span></span><span><span>
</span></span><span><span>	page <span>:=</span> <span>0</span>
</span></span><span><span>	<span>for</span> {
</span></span><span><span>		fmt.<span>Printf</span>(<span>&#34;Requesting page #%d...\n&#34;</span>, page)
</span></span><span><span>
</span></span><span><span>		prs, resp, err <span>:=</span> client.PullRequests.<span>List</span>(
</span></span><span><span>			ctx, 
</span></span><span><span>			owner, 
</span></span><span><span>			repo, 
</span></span><span><span>			<span>&amp;</span>github.PullRequestListOptions{
</span></span><span><span>				State: <span>&#34;all&#34;</span>,
</span></span><span><span>				ListOptions: github.ListOptions{
</span></span><span><span>					Page:    page,
</span></span><span><span>					PerPage: <span>100</span>,
</span></span><span><span>				},
</span></span><span><span>			},
</span></span><span><span>		)
</span></span><span><span>		<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>			<span>if</span> !resp.Rate.Reset.Time.<span>IsZero</span>() {
</span></span><span><span>				duration <span>:=</span> time.<span>Until</span>(resp.Rate.Reset.Time)
</span></span><span><span>				time.<span>Sleep</span>(duration)
</span></span><span><span>				<span>continue</span>
</span></span><span><span>			}
</span></span><span><span>
</span></span><span><span>			<span>return</span> err
</span></span><span><span>		}
</span></span><span><span>		<span>if</span> <span>len</span>(prs) <span>==</span> <span>0</span> {
</span></span><span><span>			<span>break</span>
</span></span><span><span>		}
</span></span><span><span>
</span></span><span><span>		<span>for</span> _, pr <span>:=</span> <span>range</span> prs {
</span></span><span><span>			<span>if</span> <span>*</span>pr.User.Login <span>!=</span> targetUser {
</span></span><span><span>				<span>continue</span>
</span></span><span><span>			}
</span></span><span><span>
</span></span><span><span>			fmt.<span>Printf</span>(<span>&#34;Saving %d: %s\n&#34;</span>, <span>*</span>pr.ID, <span>*</span>pr.Title)
</span></span><span><span>			serialized, err <span>:=</span> json.<span>Marshal</span>(pr)
</span></span><span><span>			<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>				<span>return</span> err
</span></span><span><span>			}
</span></span><span><span>			filename <span>:=</span> fmt.<span>Sprintf</span>(<span>&#34;prs/%d.json&#34;</span>, <span>*</span>pr.ID)
</span></span><span><span>			<span>if</span> err <span>:=</span> os.<span>WriteFile</span>(filename, serialized, <span>0777</span>); err <span>!=</span> <span>nil</span> {
</span></span><span><span>				<span>return</span> err
</span></span><span><span>			}
</span></span><span><span>		}
</span></span><span><span>
</span></span><span><span>		page<span>++</span>
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></td></tr></tbody></table></div></div><p>This program yielded 2,645 files with pull request metadata. I then used <code>jq</code> to read these JSON payloads and extract data for subsequent steps.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span><span>for</span> file in prs/*.json; <span>do</span>
</span></span><span><span>	<span>number</span><span>=</span><span>$(</span>jq -r <span>&#39;.number&#39;</span> <span>&#34;</span><span>$file</span><span>&#34;</span><span>)</span>
</span></span><span><span>	<span>merge_commit_sha</span><span>=</span><span>$(</span>jq -r <span>&#39;.merge_commit_sha // &#34;&#34;&#39;</span> <span>&#34;</span><span>$file</span><span>&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>echo</span> <span>&#34;</span><span>$number</span><span>&#34;</span> &gt;&gt; pr_ids.txt
</span></span><span><span> 	<span>echo</span> <span>&#34;</span><span>$merge_commit_sha</span><span>&#34;</span> &gt;&gt; commits.txt
</span></span><span><span>	<span>echo</span> <span>&#34;</span><span>$number</span><span> </span><span>$merge_commit_sha</span><span>&#34;</span> &gt;&gt; replace_pairs.txt
</span></span><span><span><span>done</span>
</span></span></code></pre></td></tr></tbody></table></div></div><p>This script creates three files:</p><ul><li><code>pr_ids.txt</code> is a flat list of GitHub identifiers, which are used in URLs. Since the list endpoint returns only enough data to render a pull request <em>list</em>, we’ll need to fetch additional information (intermediate commits) for each pull request by its ID.</li><li><code>commits.txt</code> is a flat list of git SHAs that were a result of merging a PR into the target branch (not always <code>main</code>). These commits may or may not be in the forked repository network, depending on the merge target. These should be synced over.</li><li><code>replace_pairs.txt</code> contains pairs of of pull request identifier and its merge commit. This will later be used to mass replace <code>/pull/{id}</code> with <code>/commit/{sha}</code>. Since pull requests can’t be linked directly anymore, I can at least link to the full pull request <em>contents</em>.</li></ul><p>Next, I ran a second program (with the same preamble as the program above) to list all the <em>non-merge commits</em> of each pull request. Based on the <a href="https://swe-to-mle.pages.dev/articles/i-am-abusive-to-git">pants-on-head way I work</a>, these will mostly be <code>WIP.</code> commits, but <em>sometimes</em> I did a better job and (possibly) linked directly to these.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span><span>15
</span><span>16
</span><span>17
</span><span>18
</span><span>19
</span><span>20
</span><span>21
</span><span>22
</span><span>23
</span><span>24
</span><span>25
</span><span>26
</span><span>27
</span><span>28
</span><span>29
</span><span>30
</span><span>31
</span><span>32
</span><span>33
</span><span>34
</span><span>35
</span><span>36
</span><span>37
</span><span>38
</span><span>39
</span><span>40
</span><span>41
</span><span>42
</span><span>43
</span><span>44
</span><span>45
</span><span>46
</span><span>47
</span><span>48
</span></code></pre></td><td><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>extractCommits</span>(ctx context.Context) <span>error</span> {
</span></span><span><span>	contents, err <span>:=</span> os.<span>ReadFile</span>(<span>&#34;pr_ids.txt&#34;</span>)
</span></span><span><span>	<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>		<span>return</span> err
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>var</span> ids []<span>int</span>
</span></span><span><span>	<span>for</span> _, line <span>:=</span> <span>range</span> strings.<span>Split</span>(<span>string</span>(contents), <span>&#34;\n&#34;</span>) {
</span></span><span><span>		<span>if</span> line <span>==</span> <span>&#34;&#34;</span> {
</span></span><span><span>			<span>continue</span>
</span></span><span><span>		}
</span></span><span><span>
</span></span><span><span>		<span>var</span> id <span>int</span>
</span></span><span><span>		_, _ = fmt.<span>Sscanf</span>(line, <span>&#34;%d&#34;</span>, <span>&amp;</span>id)
</span></span><span><span>		ids = <span>append</span>(ids, id)
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	client <span>:=</span> github.<span>NewClient</span>(<span>nil</span>).<span>WithAuthToken</span>(token)
</span></span><span><span>
</span></span><span><span>	<span>for</span> _, id <span>:=</span> <span>range</span> ids {
</span></span><span><span>		<span>for</span> {
</span></span><span><span>			commits, resp, err <span>:=</span> client.PullRequests.<span>ListCommits</span>(
</span></span><span><span>				ctx, 
</span></span><span><span>				owner, 
</span></span><span><span>				repo, 
</span></span><span><span>				id, 
</span></span><span><span>				<span>&amp;</span>github.ListOptions{},
</span></span><span><span>			)
</span></span><span><span>			<span>if</span> err <span>!=</span> <span>nil</span> {
</span></span><span><span>				<span>if</span> !resp.Rate.Reset.Time.<span>IsZero</span>() {
</span></span><span><span>					duration <span>:=</span> time.<span>Until</span>(resp.Rate.Reset.Time)
</span></span><span><span>					time.<span>Sleep</span>(duration)
</span></span><span><span>					<span>continue</span>
</span></span><span><span>				}
</span></span><span><span>
</span></span><span><span>				<span>return</span> err
</span></span><span><span>			}
</span></span><span><span>
</span></span><span><span>			<span>for</span> _, commit <span>:=</span> <span>range</span> commits {
</span></span><span><span>				fmt.<span>Println</span>(<span>*</span>commit.SHA)
</span></span><span><span>			}
</span></span><span><span>
</span></span><span><span>			<span>break</span>
</span></span><span><span>		}
</span></span><span><span>	}
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span>}
</span></span></code></pre></td></tr></tbody></table></div></div><p>Running <code>go run . &gt;&gt; commits.txt</code> dumped these commits onto the end of the file and completes the set of Git SHAs that need to be brought into the repository network for stable reference.</p><h2 id="bringing-commits-into-the-new-repository-network">Bringing commits into the new repository network</h2><p>Given the warning above (<em>“does not belong to any branch on this repository”</em>), it should be sufficient to ensure that my fork has a branch containing each relevant SHA I’d like to retain access to.</p><p>Bash here does a good enough job since all we’re doing is a bunch of git operations in sequence.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span>1
</span><span>2
</span><span>3
</span><span>4
</span><span>5
</span><span>6
</span><span>7
</span><span>8
</span><span>9
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span><span>for</span> SHA in <span>$(</span>cat commits.txt<span>)</span>; <span>do</span>
</span></span><span><span>    git fetch upstream <span>$SHA</span>             <span># Pull SHA from sg/sg</span>
</span></span><span><span>    git checkout -b <span>&#34;mirror/</span><span>$SHA</span><span>&#34;</span> <span>$SHA</span>  <span># Create reference in fork</span>
</span></span><span><span>    git push origin <span>&#34;mirror/</span><span>$SHA</span><span>&#34;</span>       <span># Push branch to efritz/sg</span>
</span></span><span><span>    git checkout main                   <span># Reset</span>
</span></span><span><span>    git branch -D <span>&#34;mirror/</span><span>$SHA</span><span>&#34;</span>         <span># Cleanup</span>
</span></span><span><span><span>done</span>
</span></span></code></pre></td></tr></tbody></table></div></div><h2 id="rewriting-references">Rewriting references</h2><p>At this point I should be safe and have <em>some target</em> to link to in my fork for each reference to a pull request or commit in the source repository. Now I just have to figure out how to automate that process (there are at least 275 code references over 15 files and I’m not doing that by hand).</p><p>Ironically, I used <a href="https://github.com/efritz/aidev">my own thing</a> instead of Cody to figure out how to use <code>xargs</code> correctly for this task.</p><div><div><table><tbody><tr><td><pre tabindex="0"><code><span> 1
</span><span> 2
</span><span> 3
</span><span> 4
</span><span> 5
</span><span> 6
</span><span> 7
</span><span> 8
</span><span> 9
</span><span>10
</span><span>11
</span><span>12
</span><span>13
</span><span>14
</span></code></pre></td><td><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span><span>sg_prefix</span><span>=</span><span>&#39;https://github.com/sourcegraph/sourcegraph&#39;</span>
</span></span><span><span><span>fork_prefix</span><span>=</span><span>&#39;https://github.com/efritz/sourcegraph&#39;</span>
</span></span><span><span>
</span></span><span><span><span># Rewrite direct references to commits to the fork</span>
</span></span><span><span>grep -rl <span>&#34;</span><span>${</span><span>sg_prefix</span><span>}</span><span>/commit/&#34;</span> . | <span>\
</span></span></span><span><span><span></span>xargs -I <span>{}</span> perl -i -pe <span>&#34;s|</span><span>${</span><span>sg_prefix</span><span>}</span><span>/commit/|</span><span>${</span><span>fork_prefix</span><span>}</span><span>/commit/|g&#34;</span> <span>{}</span>
</span></span><span><span>
</span></span><span><span><span># Rewrite references to pull request to their merge commit in the fork</span>
</span></span><span><span><span>while</span> <span>IFS</span><span>=</span><span>&#39; &#39;</span> <span>read</span> -r id sha; <span>do</span>
</span></span><span><span>    grep -rl <span>&#34;</span><span>${</span><span>sg_prefix</span><span>}</span><span>/pull/</span><span>${</span><span>id</span><span>}</span><span>&#34;</span> . | <span>\
</span></span></span><span><span><span></span>    xargs -I <span>{}</span> perl -i -pe <span>&#34;s|</span><span>${</span><span>sg_prefix</span><span>}</span><span>/pull/</span><span>${</span><span>id</span><span>}</span><span>|</span><span>${</span><span>fork_prefix</span><span>}</span><span>/commit/</span><span>${</span><span>sha</span><span>}</span><span>|g&#34;</span> <span>{}</span>
</span></span><span><span><span>done</span> &lt; replace_pairs.txt
</span></span></code></pre></td></tr></tbody></table></div></div><p><strong>Now</strong> I think we can say mission accomplished and I hope my dead links detector stops throwing a fit after <a href="https://github.com/efritz/blog/pull/48">all these changes</a>.</p></section></article></div></main></div></div>
  </body>
</html>
