<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://babbagefiles.xyz/lambda-calculus-and-lisp-01/">Original</a>
    <h1>Lambda Calculus and Lisp, part 1</h1>
    
    <div id="readability-page-1" class="page"><div>
            <p>The first of a series of envisioned blog posts on lambda calculus, and
Lisp. It‚Äôs unclear exactly where to start: there is a whole heap of
interesting issues, both theoretical and in terms of concrete
implementations, which tangle and interconnect.</p>
<p>A particular application of lambda calculus is a very salient part of
my ‚Äúday job‚Äù as a formal semanticist of natural language. And my
interests in Emacs and lisp(s) feel like they tie in here as
well‚Äîthough that‚Äôs a question in itself which is probably as good of a
starting point into this (planned) series of posts as any.</p>
<p>There is much to explore: origins of <a href="https://en.wikipedia.org/wiki/John_McCarthy_(computer_scientist)">John McCarthy</a>‚Äòs Lisp and <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo
Church</a>‚Äòs lambda calculus; encodings of the simple made complex by
restriction to a limited set of tools; recursion, fixed points, and
paradoxes; infinities, philosophy, and engineering. But much of this
requires stage setting.</p>
<p>And finding an exact entry point is yet tricky. But perhaps we start
with <strong>Œª</strong>: the divining rod, the wizard‚Äôs crooked staff, as it is the key
component of much magic of a sort.</p>
<h2 id="lisp-lambda-the-ultimate">Lisp: LAMBDA the Ultimate?¬†<a href="#lisp-lambda-the-ultimate">#</a> </h2>
<p>We‚Äôll start on the programming side, before turning to more
philosophical or mathematical abstractions, with <code>lambda</code>.</p>
<p>It is now not only Lisps which contain <code>lambda</code> as a keyword, many/most
programming languages have <code>lambda</code> as a keyword, usually for the
introduction of an anonymous function. That is, an unnamed function,
sometimes for one-off use.</p>
<p>But in McCarthy‚Äôs original formulation of LISP in 1958, <code>LAMBDA</code>
was used as the basis for the implementation of functions generally:</p>
<blockquote>
<p>Let <code>f</code> be an expression that stands for a function of two integer variables.
It should make sense to write <code>f</code> (3, 4) and the value of this expression should be
determined. The expression <code>y^2 + x</code> does not meet this requirement; <code>y^2 + x(3, 4)</code>
is not a conventional notation, and if we attempted to define it we would be
uncertain whether its value would turn out to be 13 or 19. Church calls an
expression like <code>y2 + x</code>, a form. A form can be converted into a function if we
can determine the correspondence between the variables occurring in the form
and the ordered list of arguments of the desired function. This is accomplished
by Church‚Äôs Œª-notation. [p.6]</p>
<p>‚Ä¶.</p>
<p><code>{Œª[[x_1;‚Ä¶; x_n]; ùìî]}‚àó</code> is <code>(LAMBDA, (x‚àó_1,‚Ä¶, x‚àó_n), ùìî‚àó)</code>. [p.16]</p>
<p><strong>[McCarthy 1960:6, 16<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>]</strong></p>
</blockquote>
<p>As in lambda calculus, <code>LAMBDA</code> binds variables, and replaces any
occurrences of them in the scope of the operator with whatever it
receives as arguments.</p>
<p>So the expression:</p>
<div><pre><code data-lang="lisp"><span>(</span><span>LAMBDA</span> <span>(</span><span>x</span> <span>y</span> <span>z</span><span>)</span> <span>(</span><span>+</span> <span>(</span><span>*</span> <span>y</span> <span>x</span><span>)</span> <span>(</span><span>*</span> <span>z</span> <span>x</span><span>)))</span>
</code></pre></div><p>if given the arguments <code>5</code>, <code>2</code>, <code>3</code>, would replace <code>x</code>&#39;s with <code>5</code>; <code>y</code>&#39;s with <code>2</code>,
and <code>z</code>&#39;s with <code>3</code>:</p>
<div><pre><code data-lang="lisp"><span>(</span><span>+</span> <span>(</span><span>*</span> <span>2</span> <span>5</span><span>)</span> <span>(</span><span>*</span> <span>3</span> <span>5</span><span>))</span>  <span>;; = (+ 10 15) = 25</span>
</code></pre></div><h3 id="the-illusion-of-a-blue-suffused-platonic-universe-of-car-s">The illusion of a blue-suffused platonic universe of <code>car</code>&#39;s¬†<a href="#the-illusion-of-a-blue-suffused-platonic-universe-of-car-s">#</a> </h3>
<p>The origin of <code>lambda</code> keywords in LISP, and the origin of LISP‚Äôs <code>LAMBDA</code>
in lambda calculus has suggested the idea that LISP was something like
an implementation of lambda calculus as a programming language, and
the certain mysticism<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup> attaching to both suggests perhaps a tighter
surface association than there is direct evidence for.</p>



<figure>
    
        
            <img src="https://imgs.xkcd.com/comics/lisp.jpg" alt="Figure 1: xkcd 224 [see https://www.explainxkcd.com/wiki/index.php/224:_Lisp]"/> <figcaption>
                
                <p>
                    <span>Figure 1: </span>xkcd 224 [see <a href="https://www.explainxkcd.com/wiki/index.php/224:_Lisp">https://www.explainxkcd.com/wiki/index.php/224:_Lisp</a>]
                    
                        
                        </p>
                
            </figcaption></figure>

<p>This is the topic of a 2019 blog post based on his talk for the Heart of Clojure
conference in Daniel Szmulewicz expands on the theme ‚ÄúLisp is <strong>not</strong> a
realization of the Lambda Calculus‚Äù.<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> One of the points
Szmulewicz draws attention to is McCarthy‚Äôs own words:</p>
<blockquote>
<p>‚Ä¶one of the myths concerning LISP that people think up or invent for
themselves becomes apparent, and that is that LISP is somehow a
realization of the lambda calculus, or that was the intention. The
truth is that I didn‚Äôt understand the lambda calculus, really.</p>
<p><strong>[McCarthy 1978b:190<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>]</strong></p>
</blockquote>
<p>In the paper version of the talk, McCarthy makes a similar point, but
it‚Äôs worth looking at it in the larger context:</p>
<blockquote>
<p>‚Ä¶how do you talk about the sum of the derivatives, and in programming
it, there were clearly two kinds of programs that could be written.</p>
<p>One is where you have a sum of a fixed number of terms, like just two,
where you regard a sum as a binary operation. And then you could write
down the formula easy enough. But the other was where you have a sum
of an indefinite number of terms, and you‚Äôd really like to make that
work too. To make that work, what you want to be able to talk about is
doing the same operation on all the elements of a lit. You want to be
able to get a new list whose elements are obtained from the old list
by just taking each element and doing a certain operation to it.</p>
<p>In order to describe that, one has to have a notation for
functions. So one could write this function called <code>mapcar</code>. This says,
‚ÄúApply the function <code>f</code> to all the elements of the list.‚Äù If the list is
null then you‚Äôre going to get a <code>NIL</code> here. Otherwise you are going to
apply the function to the first element of the list and put that onto
a front of a list which is obtained by doing the same operation again
to the rest of the list. So that‚Äôs <code>mapcar</code>. It wasn‚Äôt called <code>mapcar</code>
then. It was called <code>maplist</code>, but <code>maplist</code> is something different, which
I will describe in just a moment.</p>
<p>That was fine for that recursive definition of applying a function to
everything on the list. No new ideas were required. But then, how do
you write these functions?</p>
<p>And so, the way in which to do that was to borrow from Church‚Äôs Lambda
Calculus, to borrow the lambda definition. Now, having borrowed this
notation, one the myths concerning LISP that people think up or invent
for themselves becomes apparent, and that is that LISP is somehow a
realization of the lambda calculus, or that was the intention. The
truth is that I didn‚Äôt understand the lambda calculus, really. In
particular, I didn‚Äôt understand that you really could do conditional
expressions in recursion in some sense in the pure lambda
calculus. So, it wasn‚Äôt an attempt to make the lambda calculus
practical, although if someone had started out with that intention, he
might have ended up with something like LISP.</p>
<p><strong>[McCarthy 1978a:189‚Äì190<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>]</strong></p>
</blockquote>
<h3 id="the-discovery-of-lisp">The Discovery of LISP¬†<a href="#the-discovery-of-lisp">#</a> </h3>
<p>Two bits from the end of this I want to highlight. The first, well,
it‚Äôll come up in future posts, and probably later in this post itself,
and it has to do with recursion:</p>
<p><strong>‚ÄúI didn‚Äôt understand that you really could do conditional expressions in recursion in some sense in the pure lambda
calculus‚Äù</strong></p>
<p>And the second is that McCarthy hedges his ‚ÄúLISP as a realisation of
the lambda calculus is myth‚Äù stance slightly:</p>
<p><strong>‚ÄúSo, it wasn‚Äôt an attempt to make the lambda calculus practical, although if someone had started out with that intention, he
might have ended up with something like LISP.&#34;</strong></p>
<p>This does fit rather well with (and perhaps suggested) the framing
that <a href="https://en.wikipedia.org/wiki/Paul_Graham_(programmer)">Paul Graham</a> does of McCarthy as the ‚Äúdiscoverer‚Äù of Lisp ‚Äî like
Euclid of geometry ‚Äî rather than its inventor in his ‚ÄúThe Roots of
Lisp‚Äù paper:</p>
<blockquote>
<p>In 1960, John McCarthy published a remarkable paper in which he <strong>did
for programming something like what Euclid did for geometry</strong>. He
showed how, given a handful of simple operators and a notation for
functions, you can build a whole programming language. He called this
language Lisp, for ‚ÄúList Processing,‚Äù because one of his key ideas was
to use a simple data structure called a list for both code and data.</p>
<p>It‚Äôs worth understanding what McCarthy <strong>discovered</strong>, not just as a
landmark in the history of computers, but as a model for what
programming is tending to become in our own time.
‚Ä¶.
In this article I‚Äôm going to try to explain in the simplest possible
terms what McCarthy <strong>discovered</strong>. The point is not just to learn about
an interesting theoretical result someone figured out forty years ago,
but to show where languages are heading. The unusual thing about
Lisp‚Äîin fact, the defining quality of Lisp‚Äîis that it can be written
in itself.</p>
<p><strong>[Graham 2002:1<sup id="fnref:6"><a href="#fn:6" role="doc-noteref">6</a></sup> (emphasis mine)]</strong></p>
</blockquote>
<p>Graham‚Äôs paper itself, as well as some of Graham‚Äôs other
publications/postings (e.g., talking about Lisp as a sort of ‚Äúsecret
weapon‚Äù in comparison to ‚Äúblub languages‚Äù)<sup id="fnref:7"><a href="#fn:7" role="doc-noteref">7</a></sup> is perhaps another
contributor to the mystique of Lisp. (With the flip side of ‚ÄúLisp as
the Cleveriest Hacker‚Äôs Secret Weapon‚Äù enchanted coin being ‚Äúthe Curse
of Lisp‚Äù<sup id="fnref:8"><a href="#fn:8" role="doc-noteref">8</a></sup>.)</p>
<p>There are other components of the history of LISP, which are
suggestive of discovery rather than invention. McCarthy‚Äôs initial aim
for LISP was more akin that of the <a href="https://en.wikipedia.org/wiki/Turing_machine">Turing Machine</a>: as a formal abstraction
describing a mathematical model whose components were simple and few
but yet was capable of performing any (and all) arbitrary
computational operation:</p>
<blockquote>
<p>One mathematical consideration that influenced LISP was to express
programs as applicative expressions built up from variables and
constants using functions. I considered it important to make these
expressions obey the usual mathematical laws allowing replacement of
expressions by expressions giving the same value. The motive was to
allow proofs of properties of programs using ordinary mathematical
methods. This is only possible to the extent that side effects can be
avoided. Unfortunately, side effects are often a great convenience
when computational efficiency is important, and ‚Äúfunctions‚Äù with side
effects are present in LISP. However, the so-called pure LISP is free
of side effects, and Cartwright (1976) and Cartwright and McCarthy
(1978) show how to represent pure LISP programs by sentences and
schemata in first-order logic and prove their properties. This is an
additional vindication of the striving for mathematical neatness,
because it is now easier to prove that pure LISP programs meet their
specifications than it is for any other programming language in
extensive use. (Fans of other programming languages are challenged to
write a program to concatenate lists and prove that the operation is
associative.)</p>
<p>Another way to show that LISP was neater than Turing machines was to
write a universal LISP function and show that is briefer and more
comprehensible than the description of a universal Turing
machine. This was the LISP function <code>eval[e,a]</code>, which computers the
value of a LISP expression <code>e</code>, the second argument <code>a</code> being a list of
assignments of values to variables. (<code>a</code> is needed to make the recursion
work.) Writing <code>eval</code> required inventing a notation representing LISP
functions as LISP data, and such a notation was devised for the
purposes of the paper with no thought that it would be used to express
LISP programs in practice. Logical completeness required that the
notation used to express functions used as functional arguments be
extended to provide for recursive functions, and the <code>LABEL</code> notation
was invented by Nathaniel Rochester for that purpose. D.M.R. Park
pointed out that <code>LABEL</code> was logically unnecessary since the result
could be achieved using only <code>LAMBDA</code> ‚Äî by a construction analogous to
Church‚Äôs <em>Y</em>-operator, albeit in a more complicated way.</p>
<p>S.R. Russell noticed that <code>eval</code> could serve as an interpreter for LISP,
promptly hand coded it, and we now had a programming language with an
interpreter.</p>
<p><strong>[McCarthy 1978:179<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup>]</strong></p>
</blockquote>
<p>(There‚Äôs a lot going on in this passage, and its context.</p>
<p>Notions of reasons to avoid side-effects (an ideal of ‚Äúfunctional
programming‚Äù, emphasised in <a href="https://en.wikipedia.org/wiki/Haskell">Haskell</a> and <a href="https://en.wikipedia.org/wiki/Clojure">Clojure</a> (another lisp)): thus
the ‚Äúfunctional‚Äù mode of lambda calculus rather than the ‚Äúeverything
is state‚Äù mode of Turing machines and their infinitely long memory tapes.</p>
<p>Recursion again (which we‚Äôll get to, repeatedly).</p>
<p>And Alonzo Church, the originator (discoverer?)<a href="#are-we-in-platonic-heaven-yet">^{see ‚ÄúX‚Äù below}</a> of lambda calculus,
who we‚Äôll talk more about soon, and who was also Alan Turing‚Äôs PhD
supervisor at Princeton.</p>
<p>But, first: let‚Äôs turn back to the topic of the concrete instantiation
of Lisp on physical hardware by <a href="https://en.wikipedia.org/wiki/Steve_Russell_(computer_scientist)">Stephen Russell</a>.)</p>



<figure>
    
        <img src="https://babbagefiles.xyz/ox-hugo/lisp-byte_magazine-1979.jpg" alt="Figure 2: cover of Byte Magazine August 1979 [full mag here]"/> <figcaption>
                
                <p>
                    <span>Figure 2: </span>cover of Byte Magazine August 1979 [full mag <a href="https://dn790008.ca.archive.org/0/items/byte-magazine-1979-08-rescan/1979_08_BYTE_04-08_LISP.pdf">here</a>]
                    
                        
                        </p>
                
            </figcaption></figure>

<p>Elsewhere, McCarthy makes clear that he hadn‚Äôt thought at that point
of LISP being instantiatable but as a theoretical exploration of
computing at an abstract level. But, instead, the theoretical
description translated fairly easily and directly to a runnable
program, a LISP interpreter:</p>
<blockquote>
<p>This <code>EVAL</code> was written and published in the paper and Steve Russell
said, ‚Äúlook, why don‚Äôt I program this <code>EVAL</code>‚Äù ‚Ä¶ and I said to him, ‚Äúho,
ho, you‚Äôre confusing theory with practice, this <code>EVAL</code> is intended for
reading, not for computing‚Äù. But he went ahead and did it. That is, he
compiled the <code>EVAL</code> in my paper into IBM 704 machine code, fixing bugs,
and then advertised this as a Lisp interpreter, which it certainly
was. So at that point Lisp had essentially the form that it has today‚Ä¶</p>
<p><strong>[McCarthy 1974a:307<sup id="fnref:9"><a href="#fn:9" role="doc-noteref">9</a></sup>]</strong></p>
</blockquote>
<h3 id="no-compute-dot-only-read-dot-hell-eval-that-dot">‚ÄúNo compute. Only read.‚Äù ‚ÄúHell, EVAL that.‚Äù¬†<a href="#no-compute-dot-only-read-dot-hell-eval-that-dot">#</a> </h3>
<p>This is the <code>EVAL</code> code ‚Äúin the paper‚Äù referred to above:</p>
<div><pre><code data-lang="prolog"><span>eval</span><span>[</span><span>e</span><span>;</span> <span>a</span><span>]</span> <span>=</span> <span>[</span>
   <span>atom</span> <span>[</span><span>e</span><span>]</span> <span>‚Üí</span> <span>assoc</span> <span>[</span><span>e</span><span>;</span> <span>a</span><span>];</span>

   <span>atom</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>]]</span> <span>‚Üí</span> <span>[</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>QUOTE</span><span>]</span> <span>‚Üí</span> <span>cadr</span> <span>[</span><span>e</span><span>];</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>ATOM</span><span>]</span> <span>‚Üí</span> <span>atom</span> <span>[</span><span>eval</span> <span>[</span><span>cadr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]];</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>EQ</span><span>]</span> <span>‚Üí</span> <span>[</span><span>eval</span> <span>[</span><span>cadr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]</span> <span>=</span> <span>eval</span> <span>[</span><span>caddr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]];</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>COND</span><span>]</span> <span>‚Üí</span> <span>evcon</span> <span>[</span><span>cdr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>];</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>CAR</span><span>]</span> <span>‚Üí</span> <span>car</span> <span>[</span><span>eval</span> <span>[</span><span>cadr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]];</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>CDR</span><span>]</span> <span>‚Üí</span> <span>cdr</span> <span>[</span><span>eval</span> <span>[</span><span>cadr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]];</span>
        <span>eq</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>CONS</span><span>]</span> <span>‚Üí</span> <span>cons</span> <span>[</span><span>eval</span> <span>[</span><span>cadr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>];</span> <span>eval</span> <span>[</span><span>caddr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]];</span>
        <span>T</span> <span>‚Üí</span> <span>eval</span> <span>[</span><span>cons</span> <span>[</span><span>assoc</span> <span>[</span><span>car</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>];</span> <span>evlis</span> <span>[</span><span>cdr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]];</span> <span>a</span><span>]];</span>

   <span>eq</span> <span>[</span><span>caar</span> <span>[</span><span>e</span><span>];</span> <span>LABEL</span><span>]</span> <span>‚Üí</span> <span>eval</span> <span>[</span><span>cons</span> <span>[</span><span>caddar</span> <span>[</span><span>e</span><span>];</span> <span>cdr</span> <span>[</span><span>e</span><span>]];</span>
                                <span>cons</span> <span>[</span><span>list</span> <span>[</span><span>cadar</span> <span>[</span><span>e</span><span>];</span> <span>car</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>]]];</span>

   <span>eq</span> <span>[</span><span>caar</span> <span>[</span><span>e</span><span>];</span> <span>LAMBDA</span><span>]</span> <span>‚Üí</span> <span>eval</span> <span>[</span><span>caddar</span> <span>[</span><span>e</span><span>];</span>
                                 <span>append</span> <span>[</span><span>pair</span> <span>[</span><span>cadar</span> <span>[</span><span>e</span><span>];</span>
                                               <span>evlis</span> <span>[</span><span>cdr</span> <span>[</span><span>e</span><span>];</span> <span>a</span><span>];</span> <span>a</span><span>]]]</span>

<span>evcon</span><span>[</span><span>c</span><span>;</span> <span>a</span><span>]</span> <span>=</span> <span>[</span><span>eval</span><span>[</span><span>caar</span><span>[</span><span>c</span><span>];</span> <span>a</span><span>]</span> <span>‚Üí</span> <span>eval</span><span>[</span><span>cadar</span><span>[</span><span>c</span><span>];</span> <span>a</span><span>];</span> <span>T</span> <span>‚Üí</span> <span>evcon</span><span>[</span><span>cdr</span><span>[</span><span>c</span><span>];</span> <span>a</span><span>]]</span>

<span>evlis</span><span>[</span><span>m</span><span>;</span> <span>a</span><span>]</span> <span>=</span> <span>[</span><span>null</span><span>[</span><span>m</span><span>]</span> <span>‚Üí</span> <span>NIL</span><span>;</span> <span>T</span> <span>‚Üí</span> <span>cons</span><span>[</span><span>eval</span><span>[</span><span>car</span><span>[</span><span>m</span><span>];</span> <span>a</span><span>];</span> <span>evlis</span><span>[</span><span>cdr</span><span>[</span><span>m</span><span>];</span> <span>a</span><span>]]]</span>
</code></pre></div><p><span>Code Snippet 1:</span>
  McCarthy 1960, p.17 (see <a href="#fn:1" role="doc-noteref">fn. [1]</a>) [Nb.: not actually `prolog&#39; but highlights better as]
</p>
<p>Translated into slightly more familiar Lisp style (with added
named-function-making <code>label</code>&#39;s), it is:<sup id="fnref:10"><a href="#fn:10" role="doc-noteref">10</a></sup></p>
<div><pre><code data-lang="lisp"><span>(</span><span>label</span> <span>eval</span>
       <span>(</span><span>lambda</span> <span>(</span><span>e</span> <span>a</span><span>)</span>
         <span>(</span><span>cond</span>
           <span>((</span><span>atom</span> <span>e</span><span>)</span> <span>(</span><span>assoc</span> <span>e</span> <span>a</span><span>))</span>
           <span>((</span><span>atom</span> <span>(</span><span>car</span> <span>e</span><span>))</span>
            <span>(</span><span>cond</span>
              <span>((</span><span>eq</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>&#39;quote</span><span>)</span> <span>(</span><span>cadr</span> <span>e</span><span>))</span>
              <span>((</span><span>eq</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>&#39;atom</span><span>)</span>  <span>(</span><span>atom</span>  <span>(</span><span>eval</span> <span>(</span><span>cadr</span> <span>e</span><span>)</span> <span>a</span><span>)))</span>
              <span>((</span><span>eq</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>&#39;eq</span><span>)</span>    <span>(</span><span>eq</span>    <span>(</span><span>eval</span> <span>(</span><span>cadr</span> <span>e</span><span>)</span> <span>a</span><span>)</span>
                                          <span>(</span><span>eval</span> <span>(</span><span>caddr</span> <span>e</span><span>)</span> <span>a</span><span>)))</span>
              <span>((</span><span>eq</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>&#39;car</span><span>)</span>   <span>(</span><span>car</span>   <span>(</span><span>eval</span> <span>(</span><span>cadr</span> <span>e</span><span>)</span> <span>a</span><span>)))</span>
              <span>((</span><span>eq</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>&#39;cons</span><span>)</span>  <span>(</span><span>cons</span>  <span>(</span><span>eval</span> <span>(</span><span>cadr</span> <span>e</span><span>)</span> <span>a</span><span>)</span>
                                          <span>(</span><span>eval</span> <span>(</span><span>caddr</span> <span>e</span><span>)</span> <span>a</span><span>)))</span>
              <span>((</span><span>eq</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>&#39;cond</span><span>)</span>  <span>(</span><span>evcon</span> <span>(</span><span>cdr</span> <span>e</span><span>)</span> <span>a</span><span>))</span>
              <span>(</span><span>&#39;t</span>                  <span>(</span><span>eval</span> <span>(</span><span>cons</span> <span>(</span><span>assoc</span> <span>(</span><span>car</span> <span>e</span><span>)</span> <span>a</span><span>)</span>
                                               <span>(</span><span>cdr</span> <span>e</span><span>))</span>
                                         <span>a</span><span>))))</span>
           <span>((</span><span>eq</span> <span>(</span><span>caar</span> <span>e</span><span>)</span> <span>&#39;label</span><span>)</span>   <span>(</span><span>eval</span> <span>(</span><span>cons</span> <span>(</span><span>caddar</span> <span>e</span><span>)</span> <span>(</span><span>cdr</span> <span>e</span><span>))</span>
                                         <span>(</span><span>cons</span> <span>(</span><span>list</span> <span>(</span><span>cadar</span> <span>e</span><span>)</span> <span>(</span><span>car</span> <span>e</span><span>))</span> <span>a</span><span>)))</span>
           <span>((</span><span>eq</span> <span>(</span><span>caar</span> <span>e</span><span>)</span> <span>&#39;lambda</span><span>)</span>  <span>(</span><span>eval</span> <span>(</span><span>caddar</span> <span>e</span><span>)</span>
                                         <span>(</span><span>append</span> <span>(</span><span>pair</span> <span>(</span><span>cadar</span> <span>e</span><span>)</span>
                                                       <span>(</span><span>evlis</span> <span>(</span><span>cdr</span> <span>e</span><span>)</span> <span>a</span><span>))</span>
                                                 <span>a</span><span>))))))</span>

<span>(</span><span>label</span> <span>evcon</span>
       <span>(</span><span>lambda</span> <span>(</span><span>c</span> <span>a</span><span>)</span>
         <span>(</span><span>cond</span> <span>((</span><span>eval</span> <span>(</span><span>caar</span> <span>c</span><span>)</span> <span>a</span><span>)</span>
                <span>(</span><span>eval</span> <span>(</span><span>cadar</span> <span>c</span><span>)</span> <span>a</span><span>))</span>
               <span>(</span><span>&#39;t</span>
                <span>(</span><span>evcon</span> <span>(</span><span>cdr</span> <span>c</span><span>)</span> <span>a</span><span>)))))</span>

<span>(</span><span>label</span> <span>evlis</span>
       <span>(</span><span>lambda</span> <span>(</span><span>m</span> <span>a</span><span>)</span>
         <span>(</span><span>cond</span> <span>((</span><span>null</span> <span>m</span><span>)</span> <span>&#39;</span><span>())</span>
               <span>(</span><span>&#39;t</span> <span>(</span><span>cons</span> <span>(</span><span>eval</span>  <span>(</span><span>car</span> <span>m</span><span>)</span> <span>a</span><span>)</span>
                         <span>(</span><span>evlis</span> <span>(</span><span>cdr</span> <span>m</span><span>)</span> <span>a</span><span>))))))</span>
</code></pre></div><p><span>Code Snippet 2:</span>
  EVAL in more recognisable lisp form
</p>
<p>The above, given the few additional definitions for convenience
immediately following, is a full LISP interpreter.<sup id="fnref:11"><a href="#fn:11" role="doc-noteref">11</a></sup></p>
<div><pre><code data-lang="lisp"><span>(</span><span>label</span> <span>null</span>
       <span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span>
         <span>(</span><span>eq</span> <span>x</span> <span>&#39;</span><span>())))</span>

<span>(</span><span>label</span> <span>and</span>
       <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span><span>)</span>
         <span>(</span><span>cond</span> <span>(</span><span>x</span> <span>(</span><span>cond</span> <span>(</span><span>y</span> <span>&#39;t</span><span>)</span> <span>(</span><span>&#39;t</span> <span>&#39;</span><span>())))</span>
               <span>(</span><span>&#39;t</span> <span>&#39;</span><span>()))))</span>

<span>(</span><span>label</span> <span>not</span>
       <span>(</span><span>lambda</span> <span>(</span><span>x</span><span>)</span>
         <span>(</span><span>cond</span> <span>(</span><span>x</span> <span>&#39;</span><span>())</span>
               <span>(</span><span>&#39;t</span> <span>&#39;t</span><span>))))</span>

<span>(</span><span>label</span> <span>append</span>
       <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span><span>)</span>
         <span>(</span><span>cond</span> <span>((</span><span>null</span> <span>x</span><span>)</span> <span>y</span><span>)</span>
               <span>(</span><span>&#39;t</span> <span>(</span><span>cons</span> <span>(</span><span>car</span> <span>x</span><span>)</span>
                         <span>(</span><span>append</span> <span>(</span><span>cdr</span> <span>x</span><span>)</span> <span>y</span><span>))))))</span>

<span>(</span><span>label</span> <span>pair</span>
       <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span><span>)</span>
         <span>(</span><span>cond</span> <span>((</span><span>and</span> <span>(</span><span>null</span> <span>x</span><span>)</span> <span>(</span><span>null</span> <span>y</span><span>))</span> <span>&#39;</span><span>())</span>
               <span>((</span><span>and</span> <span>(</span><span>not</span> <span>(</span><span>atom</span> <span>x</span><span>))</span> <span>(</span><span>not</span> <span>(</span><span>atom</span> <span>y</span><span>)))</span>
                <span>(</span><span>cons</span> <span>(</span><span>list</span> <span>(</span><span>car</span> <span>x</span><span>)</span> <span>(</span><span>car</span> <span>y</span><span>))</span>
                      <span>(</span><span>pair</span> <span>(</span><span>cdr</span> <span>x</span><span>)</span> <span>(</span><span>cdr</span> <span>y</span><span>)))))))</span>

<span>(</span><span>label</span> <span>assoc</span>
       <span>(</span><span>lambda</span> <span>(</span><span>x</span> <span>y</span><span>)</span>
         <span>(</span><span>cond</span> <span>((</span><span>eq</span> <span>(</span><span>caar</span> <span>y</span><span>)</span> <span>x</span><span>)</span> <span>(</span><span>cadar</span> <span>y</span><span>))</span>
               <span>(</span><span>&#39;t</span> <span>(</span><span>assoc</span> <span>x</span> <span>(</span><span>cdr</span> <span>y</span><span>))))))</span>
</code></pre></div><p><span>Code Snippet 3:</span>
  additional convenience functions for EVAL
</p>
<p>The brevity of the code combined with the details of the story of the
implementation: seemingly the theoretical code works without
translation, suggesting a sort of natural discovery. But, the nature
of even the theoretical, pre-implementation code did not exist in some
Platonic heaven of mathematics, as can be seen by the nature of some
of the operations, particularly <code>car</code> and <code>cdr</code> (often in modern Lisps,
especially Scheme and Scheme-influenced Lisps, rendered instead more
transparently as <code>first</code> and <code>rest</code>.)</p>
<h3 id="the-non-platonic-mechanics-of-1950s-ibm-mainframes">The Non-Platonic mechanics of 1950s IBM mainframes¬†<a href="#the-non-platonic-mechanics-of-1950s-ibm-mainframes">#</a> </h3>
<p>LISP was designed with the <a href="https://en.wikipedia.org/wiki/IBM_704">IBM 704</a>-style architecture in mind, and <code>car</code>
and <code>cdr</code> make some reference to particular details of the hardware,
where the IBM 704 had ‚Äúaddress‚Äù and ‚Äúdecrement‚Äù fields in memory index
registers (‚âàlocations in physical RAM), and <code>car</code> referenced the
‚Äúaddress‚Äù field of the register (so CAR = ‚Äú<strong>C</strong>-ontents of the <strong>A</strong>-ddress
part of the <strong>R</strong>-egister‚Äù) and <code>cdr</code> the ‚Äúdecrement‚Äù field of the register
(CDR = ‚Äú<strong>C</strong>-ontents of the <strong>D</strong>-ecrement part of the <strong>R</strong>-egister‚Äù).<sup id="fnref:12"><a href="#fn:12" role="doc-noteref">12</a></sup></p>



<figure>
    
        <img src="https://babbagefiles.xyz/ox-hugo/my-other-car-is-a-cdr.jpg" alt="Figure 3: my other car is a cdr"/> <figcaption>
                
                <p>
                    <span>Figure 3: </span>my other car is a cdr
                    
                        
                        </p>
                
            </figcaption></figure>

<p>Lists in Lisp are singly-linked lists, with each node in the list
having a ‚Äúvalue‚Äù field and a ‚Äúnext‚Äù field, which points to the next
node; these ‚Äúvalue‚Äù and ‚Äúnext‚Äù fields correspond to the <code>car</code> and
<code>cdr</code> operations. So, if we have a list like <code>(a b c)</code>, the first node in the list has a
‚Äúvalue‚Äù field of <code>a</code> and a ‚Äúnext‚Äù field pointing at another node, with
this second node actually itself being ‚Äî not <code>b</code> ‚Äî but rather the list
<code>(b c)</code>. A proper list in Lisp is <code>nil</code>-terminated: that is, the last item
in the list is actually <code>nil</code> (which is the empty list <code>&#39;()</code>).</p>
<p>The operation <code>cons</code> above (for CONstructor) is a pair-forming operation
(where the pairs correspond to the ‚Äúvalue‚Äù and ‚Äúnext‚Äù fields),
returning what are variously called (in different lisps) ‚Äúconses‚Äù or
‚Äúpairs‚Äù. Not all conses/pairs are lists (at least in most Lisps),
since a proper <code>list</code> in Lisp is <code>nil</code>-terminated.</p>
<p>The operation <code>(cons &#39;a &#39;b)</code> will return a <code>cons</code>&#39;ed object with
essentially a single node, where the ‚Äúvalue‚Äù field will be <code>a</code> and the
‚Äúnext‚Äù field will be <code>b</code>. Lisps will usually print such non-list conses
(sometimes called ‚Äúimproper lists‚Äù) as ‚Äúdotted lists‚Äù, i.e., <code>(cons &#39;a &#39;b)</code> will print out as <code>(a . b)</code>.</p>
<p>The list <code>(a b c)</code> is actually the result of doing <code>(cons a (cons b (cons c nil)))</code> and would be printed in dotted-pair notation as <code>(a . (b . (c . nil)))</code> [which is equivalent to <code>(a . (b . (c . ())))</code>, since <code>nil</code> is
the empty list].</p>
<p>Unsurprisingly, a lot of early/traditional Lisp programming involves
manipulations of lists. But all modern Lisps implement other types of
data structures as well, including vectors/arrays, hash tables,
objects, and so on.</p>
<p>But, on the main topic of <code>(eq &#39;lisp &#39;lambdacalculus)</code>, others have also
pointed out the concrete hardware-connections of LISP from early days,
telling against the ‚ÄúLisp-as-pure-formal-<del>invention</del>-discovery‚Äù or
‚ÄúLisp as (semi-)direct implementation of lambda calculus‚Äù notions:</p>
<blockquote>
<p>Lisp was intended to be implemented on a computer from day 0. For
their IBM 704. Actually Lisp is based on earlier programming
experience. From 56 onwards John McCarthy implemented Lisp ideas in
Fortran &amp; FLPL. Then 58 the implementation of Lisp was started. 59 a
first runnable version was there. 1960 there was the Lisp 1
implementation. The widely known paper on the Lisp implementation and
recursive function theory was published in 1960. But his original
prime motivation was not to have a notation for recursive function
theory, it was to have a list processing programming language for
their IBM 704 for AI research.</p>
<p>Lisp as designed by McCarthy was very different from lambda calculus.</p>
<p>[going on to point to the <a href="https://doi.org/10.1145/800055.802047">Stoyan (1984) Early LISP history
(1956 - 1959) paper</a>.]</p>
<p><strong>‚Äî <a href="https://moth.social/@lispm">lispm</a>‚Äòs comment on <a href="https://www.reddit.com/r/lisp/comments/e467tk/is_it_more_correct_to_say_that_lisp_is_based_on/f99keh3/">r/lisp</a> thread on this topic</strong></p>
</blockquote>
<p>There‚Äôs obviously much more to explore for the early history of Lisp
and the nature of its connections to lambda calculus, but this much at
least should give a general sense of the distinctions/divergences
between Lisp and lambda calculus, while not ignoring important
interconnections between them.</p>
<h3 id="reaching-the--of-the-line">Reaching the <code>&#39;()</code> of the line¬†<a href="#reaching-the--of-the-line">#</a> </h3>
<p>And so while it‚Äôs tempting to delve off into other interesting
features (homoiconicity!) of LISP/Lisps and their history and dialects
(the Common Lisp of Endor; Schemes, Rackets, Chickens and Guile (oh
my!), Clojure, Fennel and others), I‚Äôd wanted to get to lambda
calculus proper much earlier in this piece already, and so we‚Äôll set
our (lispy) parens down for a moment, and trade in our <code>LAMBDA</code> for a <code>Œª</code>.</p>
<h2 id="cattle-prodding-functions-the-lambda-calculus">Cattle-prodding functions: the lambda calculus¬†<a href="#cattle-prodding-functions-the-lambda-calculus">#</a> </h2>
<p>The aforementioned Alonzo Church<sup id="fnref:13"><a href="#fn:13" role="doc-noteref">13</a></sup>, a Princeton
mathematician who supervised 31 doctoral students during his career,
influencing others important researchers (including <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a> [for
whom the programming language Haskell is named; as well as the
operating of <a href="https://en.wikipedia.org/wiki/Currying">currying</a>]), developed (the) lambda calculus as part of
his research into the foundations of mathematics.</p>
<p>Lambda calculus is <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a>, thus equivalent in computation
power to a Turing machine and a universal model of computation.</p>
<p>There are very few bits of machinery in basic untyped lambda
calculus. (A reason for which it seemed to be attractive to McCarthy
as a touchstone.)</p>
<p>Lambda calculus has variables and lambdas; function application; a
reduction operation (which may follow function application); and a
convenience variable-renaming operation.</p>
<p>More specifically, we have:</p>
<ol>
<li><strong>variables</strong>, like <code>x</code>, which are characters or strings representing ‚Äúa parameter‚Äù</li>
<li><strong>lambda abstraction</strong>: essentially just the definition of a function,
specifying its input (by a bound variable, say, <code>Œªx</code>) and returning an
output (say, <code>M</code>). E.g., the expression <code>Œªx.M</code> will take an input, and replace any and all
instances of <code>x</code> in the body <code>M</code><sup id="fnref:14"><a href="#fn:14" role="doc-noteref">14</a></sup> with whatever the input
was. (The <code>.</code> separates the lambda and specification of bound
variable (here <code>x</code>) (‚Äúinput taker‚Äù) from the body (the ‚Äúoutput‚Äù).)</li>
<li><strong>function application</strong>: a representation like <code>(M N)</code>, the function <code>M</code>
applies to <code>N</code>, where both <code>M</code> and <code>N</code> are some sort of lambda terms.</li>
<li><strong>Œ≤-reduction</strong> (beta reduction): bound variables inside body of the
expression are replaced by inputs ‚Äútaken‚Äù by the lambda
expressions. The basic form: <code>((Œªx.M) N)</code> ‚Üí <code>(M[x := N])</code>. (That is, an
expression <code>(Œªx.M)</code> combining with an expression <code>N</code> returns <code>(M)</code> where
all instances of <code>x</code> inside of <code>M</code> are replaced by <code>x</code>.)</li>
</ol>
<p>(Setting aside rule 4 for the moment.)</p>
<p>For example, we might have an expression:</p>
<p><code>Œªf.Œªx.(f x)</code></p>
<p>This would be an expression which combines, one at a time, with two
inputs, the lambdas operating from left to right, and then applying
the <code>f</code> input to the <code>x</code> input.</p>
<p>To see this in full working order, we need to specific one of the two
remaining operations (both reduction operations):</p>
<p>So, turning to rule 4 for Œ≤-reduction, taking our expression from
above and providing it with inputs, and walking through the (two)
application+Œ≤-reduction steps one at a time:</p>
<p><code>((Œªf.Œªx.(f x)) b a)</code> =</p>
<p><code>((Œªx.(b x)) a)</code> =</p>
<p><code>(b a)</code></p>
<p>That is, first, the leftmost lambda, <code>Œªf,</code> ‚Äútakes‚Äù the leftmost argument <code>b</code>
(in ‚Äútaking‚Äù an argument, it ‚Äúdischarges‚Äù and disappears) and the
(single) bound instance of the variable <code>f</code> in the body is replaced by
<code>b</code>. Then, the same thing happens with the remaining lambda, <code>Œªx</code>, and the
remaining argument, <code>a</code>. The result is a function where <code>b</code> applies to
<code>a</code>. (Though since in this case there are no more lambdas, nothing more
happens.)</p>
<p>Since <code>(b a)</code> looks somewhat unexciting/opaque, we can imagine a sort of
hybrid proper untyped lambda calculus/Lisp hybrid language ‚Äî let‚Äôs
call this toy language of ours ŒõŒôŒ£Œ† ‚Äî and illustrate what things might
look like there (assuming here that numbers are numbers and <code>#&#39;*</code> is a lispy
prefix multiplication function):</p>
<p><code>((Œªf.Œªx.Œªy.(f x y)) #&#39;* 6 7)</code> =</p>
<p><code>((Œªx.Œªy.(* x y)) 6 7)</code> =</p>
<p><code>((Œªy.(* 6 y)) 7)</code> =</p>
<p><code>(* 6 7)</code> =</p>
<p><code>42</code></p>
<p>This isn‚Äôt how mathematics works in classical untyped lambda calculus
‚Äî because we only have the 4 rules/entities enumerated above [plus a
variable-clash reduction operation called Œ±-reduction]<sup id="fnref:15"><a href="#fn:15" role="doc-noteref">15</a></sup> and nothing
else<sup id="fnref:16"><a href="#fn:16" role="doc-noteref">16</a></sup>: no integers, no stipulated mathematical operations, no <code>car</code> or
<code>cdr</code> or <code>cons</code> or <code>eq</code> or anything ‚Äî we can do all of these things in
lambda calculus with the tools we have, and we‚Äôll explore that in
another post, but for now I just wanted to show you the toy ŒõŒôŒ£Œ†
language snippet as I find something that feels a bit more familiar
and concrete can be helpful for understanding the notional unpinnings
of what‚Äôs going on in lambda calculus.</p>
<h3 id="ok-so-there-s-no-integers-or-cars-but-what-s-all-this-about-cattle-prods">Ok, so there‚Äôs no integers or cars, but what‚Äôs all this about cattle prods?¬†<a href="#ok-so-there-s-no-integers-or-cars-but-what-s-all-this-about-cattle-prods">#</a> </h3>
<p>Well, why is <code>Œª</code> / <code>LAMBDA</code> the ‚Äúfunction‚Äù-making operator? Maybe just
eeny-meeny-miney-moe amongst Greek letters, but at least at one point
Church explained that [A. Church, 7 July 1964. Unpublished letter to
Harald Dickson, ¬ß2] that it came from the notation ‚ÄúxÃÇ‚Äù used for
class-abstraction by Whitehead and Russell in their <em><a href="https://en.wikipedia.org/wiki/Principia_Mathematica">Principia
Mathematica</a></em> (which we‚Äôre refer to later on), by first modifying ‚ÄúxÃÇ‚Äù to
‚Äú^‚Å£x‚Äù to (and then for better visibility to ‚Äú‚àßx‚Äù) to distinguish
function-abstraction from class-abstraction, and then changing ‚Äú‚àß‚Äù
(which is similar to uppercase Greek ‚ÄúŒõ‚Äù) to (lowercase Greek) ‚ÄúŒª‚Äù for
ease of printing (and presumably to avoid confusion with other
mathematical uses of ‚Äú‚àß‚Äù, e.g., logical AND).<sup id="fnref:17"><a href="#fn:17" role="doc-noteref">17</a></sup>
[So maybe ‚ÄúxÃÇ‚Äù ‚áí ‚Äú^‚Å£x‚Äù ‚Üí ‚Äú‚àßx‚Äù ‚Üí ‚ÄúŒªx‚Äù.]</p>
<p>The Greek lambda (uppercase Œõ, lowercase Œª) as an ortheme itself
derives ultimately from a Semitic abjad, specifically from the
Phoenician <em>lƒÅmd</em> <strong>ê§ã</strong>, which (like most letters began as a pictogram of
sorts) is considered to originate from something like an ox-goad,
i.e., a cattle prod, or else a shepherd‚Äôs crook, i.e., a pastoral
staff. (The reconstructed Proto-Semitic word <em>*lamed-</em> means a
‚Äúgoad‚Äù.)<sup id="fnref:18"><a href="#fn:18" role="doc-noteref">18</a></sup></p>
<h3 id="are-we-in-platonic-heaven-yet">Are We in Platonic Heaven Yet?¬†<a href="#are-we-in-platonic-heaven-yet">#</a> </h3>
<p>Lambda calculus, not being tied to any particular hardware and being a
true formula abstraction, feels like something that might have a
better claim to being something like a property of the universe that
one might discover (I admit I find it hard not to feel something of
the sort ‚Äî but then I‚Äôve used lambda calculus for work on natural
language within a framework that wants to assign some sort of reality
to our formalisations, so it‚Äôs hard not to be pulled in this
direction), however, Church says (of his own formalism):</p>
<blockquote>
<p>We do not attach any character of uniqueness or absolute truth to any
particular system of logic. The entities of formal logic are
abstractions, invented because of their use in describing and
systematizing facts of experience or observation, and their
properties, determined in rough outline by this intended use, depend
for their exact character on the arbitrary choice of the inventor.</p>
<p><strong>[Alonzo Church 1932:348<sup id="fnref:19"><a href="#fn:19" role="doc-noteref">19</a></sup>]</strong></p>
</blockquote>
<p>(This seems part of Church‚Äôs constructivist philosophy, in
common with Frege.)<sup id="fnref:20"><a href="#fn:20" role="doc-noteref">20</a></sup></p>
<h2 id="what-s-next-Œªy-dot--equal-cdr-l--y">What‚Äôs <code>next</code>? : <code>Œªy.(equal? (cdr L) y)</code>¬†<a href="#what-s-next-Œªy-dot--equal-cdr-l--y">#</a> </h2>
<p>We‚Äôve pulled at a lot of disparate threads here, trying to explore
the nature of the connections between Lisp and (the) lambda
calculus. Neither the idea that Lisp is a direct instantiation of
lambda calculus nor the idea that McCarthy was largely ignorant of
properties of lambda calculus are quite right. But that there are an
interesting interplay of connections.</p>
<p>But. This is really to set the stage for me to talk about things I‚Äôm
interested in which draw on different aspects of Lisp(s) and lambda
calculus and formal or applied applications to do with one or the
other.</p>
<p>I was going to talk about <a href="https://en.wikipedia.org/wiki/Montague_grammar">Montague Grammar</a>, because it‚Äôs fascinating
(and it‚Äôs my day job), for which lambda calculus is a crucial
component.<sup id="fnref:21"><a href="#fn:21" role="doc-noteref">21</a></sup> But we‚Äôre at length now, so it should be
another day.</p>
<p>What I do want to look at next is a combination of Lisp and lambda
calculus, in various ways, starting with attempts to implement aspects
of lambda calculus in Emacs Lisp, and the challenges therein.</p>
<p>[fingers crossed that <code>(next &#39;blog)</code> does not eval to <code>undefined</code>.]</p>
<p>(Update: <code>(eval (next &#39;blog))</code>: <a href="https://babbagefiles.xyz/lambda-calculus-and-lisp-02-recursion/">Part 2: Recursion Excursion</a>.)</p>



        </div></div>
  </body>
</html>
