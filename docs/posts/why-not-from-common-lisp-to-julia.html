<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://gist.github.com/digikar99/24decb414ddfa15a220b27f6748165d7">Original</a>
    <h1>Why Not: From Common Lisp to Julia</h1>
    
    <div id="readability-page-1" class="page"><div>
  <div id="file-not-common-lisp-to-julia-org">
      
      <div id="file-not-common-lisp-to-julia-org-readme">
    <article itemprop="text">
<p dir="auto"><i>This article is a response to mfiano’s <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/" rel="nofollow">From Common Lisp to Julia</a> which might also convey some developments happening in Common Lisp. I do not intend to suggest that someone coming from a Matlab, R, or Python background should pickup Common Lisp. Julia is a reasonably good language when compared to what it intends to replace. You should pickup Common Lisp only if you are interested in programming in general, not limited to scientific computing, and envision yourself writing code for the rest of your life. It will expand your mind to what is possible, and that goes beyond the macro system. Along the same lines though, you should also pickup C, Haskell, Forth, and perhaps a few other languages that have some noteworthy things to teach, and that I too have been to lazy to learn.</i></p>
<p dir="auto"><i>I also do not intend to offend anyone. I’m okay with criticizing Common Lisp (I myself have done it below!), but I want the criticism to be done correctly. If I had to wish something from Julia, it would be to provide a way to turn off runtime optimization to (radically) speed up compile times for purposes of debugging.</i></p>

<ul dir="auto">
  <li><a href="#table-of-contents">Table of Contents</a></li>
  <li><a href="#why-i-still-use-common-lisp-and-did-not-switch-over-to-julia">Why I still use Common Lisp, and did not switch over to Julia</a>
    <ul dir="auto">
      <li><a href="#refuting-the-points">Refuting the points</a>
        <ul dir="auto">
          <li><a href="#condition-system">Condition System</a></li>
          <li><a href="#language-evolution">Language Evolution</a></li>
          <li><a href="#performance">Performance</a></li>
          <li><a href="#programming-paradigm">Programming Paradigm</a></li>
        </ul>
      </li>
      <li><a href="#the-points-not-mentioned">The points not mentioned</a>
        <ul dir="auto">
          <li><a href="#pmo-as-the-root-of-evil">PMO as the root of evil</a></li>
          <li><a href="#dynamic-binding">Dynamic Binding</a></li>
          <li><a href="#structural-editing">Structural editing</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#agreeing-with-some-points-what-common-lisp-can-improve">Agreeing with some points: what Common Lisp can improve</a>
    <ul dir="auto">
      <li><a href="#software-versioning-and-deployment">Software versioning and Deployment</a></li>
      <li><a href="#documentation">Documentation</a></li>
      <li><a href="#software-quality">Software Quality</a></li>
      <li><a href="#performance">Performance</a></li>
      <li><a href="#community">Community</a></li>
    </ul>
  </li>
  <li><a href="#conclusion-why-i-still-use-python-as-my-primary-language-and-when-might-i-switch-over-to-julia">Conclusion: Why I still use python as my primary language, and when might I switch over to Julia?</a></li>
</ul>

<h2 dir="auto"><a id="user-content-refuting-the-points" aria-hidden="true" href="#refuting-the-points"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Refuting the points</h2>
<h3 dir="auto"><a id="user-content-condition-system" aria-hidden="true" href="#condition-system"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Condition System</h3>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#why_i_no_longer_use_common_lisp" rel="nofollow">Editor Support</a></p>
<p dir="auto">I actually liked the mention of Editor Support going on to mention how Common Lisp provides a excellent ability to inspect the current state of the stack in case of an error or warning, or just a condition that is not an error. You can inspect the stack without rewinding the stack, exploring the values of the variables in various stack frames, making debugging is easier. I can merely point to phoe’s <a href="https://link.springer.com/book/10.1007/978-1-4842-6134-7" rel="nofollow">Common Lisp Condition System (2020)</a> for someone who might be intrigued by mfiano’s description.</p>
<p dir="auto">About emacs: I personally dislike emacs, but I dislike the other editors more. (EDIT) That does not mean you should use emacs. The <a href="https://lispcookbook.github.io/cl-cookbook/vscode-alive.html" rel="nofollow">ALIVE extension for VS Code</a> has been under development since 2020. I do look forward to seeing a Common Lisp tutorial series that uses VS Code instead of Emacs or Portacle.</p>
<h3 dir="auto"><a id="user-content-language-evolution" aria-hidden="true" href="#language-evolution"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Language Evolution</h3>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#language_evolution" rel="nofollow">Language Evolution</a></p>
<blockquote>
  <p dir="auto">All of these features are left to be implemented by third-party libraries, and if possible, portability libraries that allow them to function with a unified interface between all implementations of Common Lisp.</p>
</blockquote>
<p dir="auto">Yes, indeed, even though the ANSI standard has been frozen in 1994, there have been various attempts at adding support for the features added since then. <a href="https://portability.cl/" rel="nofollow">portability.cl</a> provides a nice summary of the implementation support for the features.</p>
<ul dir="auto">
  <li>multithreading,  which exists on the 13 implementations but <a href="https://github.com/jscl-project/jscl">JSCL</a> (yes that’s Javascript), and there is a higher level library <a href="https://lparallel.org/overview/" rel="nofollow">lparallel</a> built over it</li>
  <li>foreign function interface, which again exists on the 13 implementations but JSCL</li>
  <li>garbage collection interface, on 12 implementations (except MKCL and JSCL)</li>
  <li>networking support (usocket?), which exists on 11 but JSCL, Mezzano, and MKCL</li>
  <li>IEEE floats, I’m not sure what the exact status is about this, but the more popular implementations including SBCL and CCL do follow IEEE floating point format and provide support for 64-bit as well as 32-but floats. (I’ll revisit this point later.)</li>
  <li>unicode support, again I cannot comment on the status across implementations; there exists <a href="https://edicl.github.io/cl-unicode/" rel="nofollow">cl-unicode</a>, and <a href="https://github.com/sbcl/sbcl/releases/">SBCL 2.2.7 (July 2022) recently upgraded their support for unicode to Unicode 10.0.0</a>.</li>
</ul>
<p dir="auto">There will certainly be other features for which Julia has better support than SBCL, but the state of affairs in Common Lisp might not be as bad as the section on Language Evolution makes one believe.</p>
<blockquote>
  <p dir="auto">the standard is incredibly hard to navigate, especially as a beginner trying to learn the language. In many places it is very ambiguous, or erroneous, and often leads to long debates in the Common Lisp communication forums.</p>
</blockquote>
<p dir="auto">There exist <a href="https://lamberta.github.io/minispec/" rel="nofollow">MiniSpec</a> and <a href="http://clqr.boundp.org/clqr-a4-consec.pdf" rel="nofollow">Common Lisp Quick Reference</a> for a beginner. And if you are able to see the inconsistencies in the standard, and capable of understanding debates concerning it, you are no longer worthy of being a beginner :’).</p>
<p dir="auto">My personal interest in Common Lisp also stems from a vested interest in <i>very</i> long term stability, not just for programming, but for things in general. I’m interested in taking sometimes gold, sometimes outdated ideas (or code) from people who have lived before me, and passing them to the people coming ahead. I think, in the absence of knowing where our predecessors went wrong, our successors will only make the same mistakes. I usually lean more towards the side of implementing and testing ideas, rather than delivering a product to an end-user. And as such, I’m less interested in getting things to work now and here than trying to make a reasonable attempt at ensuring things work 10 or 20 or 40 years from now. I don’t care about this when I’m writing code for the end-user (in my case, as a student so far, instructors and real-life collaborators) who might not be as worried about long-term stability, and there I actually end up using python or javascript, or whatever will get things up fast, until I begin to face their limitations.</p>
<h3 dir="auto"><a id="user-content-performance" aria-hidden="true" href="#performance"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h3>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#performance" rel="nofollow">Performance</a></p>
<p dir="auto">I, again, highly agree with the mfiano. But again, things aren’t as gloomy. With CLTL2 through something like <a href="https://github.com/alex-gutev/cl-environments">cl-environments</a> and <a href="https://github.com/alex-gutev/cl-form-types/">cl-form-types</a>, it is possible to dispatch generic-functions statically using <a href="https://github.com/alex-gutev/static-dispatch">static-dispatch</a>.</p>
<p dir="auto">Comparison of performance is valid only in terms of implementations; thus a fair comparison would involve comparing one particular implementation of Common Lisp aka SBCL, with the only implementation of Julia. And, SBCL has been in development since the last 30 years (and more than that if you include CMUCL); monthly releases take place even today. SIMD support for intel architectures was added recently in June 2022. (Thanks Marco Heisig!) And <a href="https://gist.github.com/digikar99/13ed3868993ca8c71c91b50c8022a64d">here</a>’s using it to implement the multiplication of a 4x4 matrix with a 4-length vector, that was <a href="https://www.reddit.com/r/sbcl/comments/x1svhi/sbsimd_example_for_3d_vectormatrix_math/" rel="nofollow">requested by u/kaveh808</a> who has been working on <a href="https://github.com/kaveh808/kons-9/">an IDE for 3D production</a>.</p>
<p dir="auto">It is also certainly true that dynamicity and performance go against each other. This has less to do with Common Lisp, and more to do with what the nature of dynamicity: if you want to go fast, you want to minimize unnecessary checks; but if you want correct non-segfaulting behavior with objects whose structure is unknown at compile time, then you will need to runtime checks. At best, a language should provide facilities to swing towards either ends. And yes, in Common Lisp, this is <del>hard</del> impossible to do portably sticking to the ANSI standard. But if you are using another implementation-tied language, you might as well do with SBCL; or if you had to be forced to stick with SBCL, you might as well pick up the other language. Either is fine.</p>
<p dir="auto">I also agree about the lack of packed arrays of arbitrary structures in Common Lisp. Certainly there should be a way use FFI to achieve it. There should also be a way to put extensible-compound-types and polymorphic-functions to achieve it. And you also have Coalton. But this does not seem to have a native solution in the near future; the difficulty is related to garbage collection.</p>
<h3 dir="auto"><a id="user-content-programming-paradigm" aria-hidden="true" href="#programming-paradigm"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Programming Paradigm</h3>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#programming_paradigm" rel="nofollow">Programming Paradigm</a></p>
<blockquote>
  <p dir="auto">While I do think that CLOS is very nice, and it is hard to live without it, I also think that OOP in general does not fit every programming problem. Infact, for most applications, I would much rather have parametric polymorphism instead of ad-hoc polymorphism that you get with Common Lisp generic functions.</p>
  <p dir="auto">Generic functions in Common Lisp do not have arity-overloading like they do in Julia and other languages with generic functions. A generic function in Common Lisp has a fixed arity, and defines a protocol.</p>
</blockquote>
<p dir="auto">Besides the points mfiano mentioned, another major annoyance I have run into on ANSI CL is the inability to dispatch on specialized array types. I have been unable to do this using generic functions, CLOSER-MOP, or even SB-PCL. But have instead found it simpler to work on <a href="https://github.com/digikar99/polymorphic-functions">polymorphic-functions</a> to provide functions that dispatch on types rather than classes.</p>
<ul dir="auto">
  <li>And this is possible for optional and keyword arguments.</li>
  <li>And this is possible with heterogeneous argument lists.</li>
  <li>The static dispatch is optional, you can turn it off since some lispers think dynamic dispatch is the right thing to do.</li>
  <li>And there is <i>some</i> support for writing functions that are parameterized over types. (I recently used this feature in <a href="https://github.com/digikar99/numericals/commit/1ab2aee0c38bf11d950a0b218a4e7db13efa9294">numericals</a> to cut down on the number of functions needed from about 70 to 10.) Granted, this support is far from (and neither intended to be) something that <a href="https://github.com/coalton-lang/coalton">coalton</a> povides.</li>
  <li>And there is support for compiler-notes, aka notes emitted during compilation <i>of the specific function and/or line</i> to help you optimize the code.</li>
  <li>And there is support for ”<a href="https://github.com/digikar99/polymorphic-functions#wait-doesnt-pfs-use-of-aot-imply-2500-specialized-variants-as-sf-says">declaration propagation</a>”.</li>
  <li>And it respects declarations asking to optimize for debugging or for speed</li>
</ul>
<p dir="auto">And through this and CFFI, I have been able to <a href="https://digikar99.github.io/numericals/" rel="nofollow">optimize numericals for small as well as large arrays</a>. I have tested numericals on SBCL and CCL, and am using <a href="https://sleef.org/" rel="nofollow">Sleef</a> under-the-hood through CFFI. And it works. And it is performant. (And at least I find it convenient.)</p>
<p dir="auto">That said, except the first two points, all the rest of the points are beyond the ANSI standard, and even though cl-environments provides support for a number of implementations, I have run into issues on them. Thus, CLTL2 support needs polishing.</p>
<blockquote>
  <p dir="auto">Additionally, most of the language proper is not generic.</p>
</blockquote>
<p dir="auto">There are at least two projects <a href="https://alex-gutev.github.io/generic-cl/" rel="nofollow">generic-cl</a> and <a href="https://github.com/lisp-polymorph/">lisp-polymorph</a> that attempt to provide support for a generics based language. But yes, this will never be a “first class” solution; it might get the work done but the support might not be native. That said, implementing generics correctly doesn’t seem like an easy solved problem either; different languages seem to be working with different tradeoffs for the different varieties of generics they provide.</p>
<blockquote>
  <p dir="auto">User-defined types are merely type aliases for existing types.</p>
</blockquote>
<p dir="auto">Indeed, when I made a custom array class, I also had to come up with <a href="https://github.com/digikar99/extensible-compound-types">extensible-compound-types</a>. polymorphic-functions also plays nicely with this. So, users should be good to go.</p>
<p dir="auto">The bottom line, things aren’t as gloomy.</p>
<h2 dir="auto"><a id="user-content-the-points-not-mentioned" aria-hidden="true" href="#the-points-not-mentioned"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The points not mentioned</h2>
<h3 dir="auto"><a id="user-content-pmo-as-the-root-of-evil" aria-hidden="true" href="#pmo-as-the-root-of-evil"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>PMO as the root of evil</h3>
<p dir="auto">Beginner programmers are often advised to focus on writing readable code instead of attempting to prematurely optimize it at the cost of readability. I think this same advice also applies to compilers, which should focus on producing debuggable (and quickly compilable) code, and only <i>then</i> on performant code. But unfortunately, both <a href="https://julialang.org/" rel="nofollow">julia</a> and <a href="https://numcl.github.io/numcl/" rel="nofollow">numcl</a> (whose structure was motivated by julia’s JAOT) have focused on runtime performance at the cost of compilation performance.</p>
<p dir="auto">Granted, if I want to run the calculation for a day or week, it doesn’t matter whether I spend 30 seconds compiling the program or 1 second. However, more often than not, during development, I will be running a calculation for 2 seconds to test my code. And <i>then</i>, 30 seconds is too long a time! It is only <i>once</i> I have debugged my code, then it makes sense to compile it for performance and then run it. Julia and numcl abysmally fail here with the hiccups and first times to run. Granted things are improving, but they will never be as good as providing an option to ditch runtime performance optimization completely to focus on compile-time performance.</p>
<p dir="auto">The standard C compilers, as well as SBCL get this right. Common Lisp’s ANSI standard provides optimization declaration specifiers for <code>speed safety debug compilation-speed space</code> that suggest (but do not require :/) the compiler to optimize for that particular quality. SBCL puts this to use. C compilers also provide equivalent options. In their absence, I cannot imagine making julia or numcl <i>my</i> first choice of implementing a program; may be for some other people, the hiccups do not matter much, for me they do.</p>
<h3 dir="auto"><a id="user-content-dynamic-binding" aria-hidden="true" href="#dynamic-binding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Dynamic Binding</h3>
<p dir="auto">Julia does not have dynamic binding, aka looking up variable value from the place where the function was called, rather than from where the function was compiled. The reason cited for this is <i>performance</i>.</p>
<p dir="auto">However, dynamic binding is needed not only to simplify specifying local-but-global variables, but also for implementing the Condition System discussed previously. By putting performance above everything else, julia fails with respect to Common Lisp (actually, SBCL in particular) in terms of debugging as well as compilation-speed.</p>
<p dir="auto">EDIT: In response to <a href="https://news.ycombinator.com/item?id=32749813" rel="nofollow">a comment on hackernews</a> (thanks for pointing out!): I forgot to write - Yes Common Lisp does have lexical binding by default for local variables. It is only the global variables that are dynamically bound. In fact, ANSI standard makes no provision for global lexical variables; although a few implementations (SBCL, CCL, Lispworks) provide support for global lexical variables if required.</p>
<p dir="auto">What dynamic binding allows me to do is the following:</p>
<div dir="auto"><pre>CL-USER&gt; (in-package :dense-numericals.impl)
<span>#&lt;PACKAGE</span> <span><span>&#34;</span>DENSE-NUMERICALS.IMPL<span>&#34;</span></span>&gt;
IMPL&gt; (<span>let</span>* ((nu:<span>*array-element-type*</span> &#39;double-float)
             (a (nu:rand <span>5</span> <span>5</span>))
             (b (nu:rand <span>5</span> <span>5</span>)))
        (nu:add a b))
<span><span>;</span>; In less lispy terms:</span>
<span><span>;</span>; let nu.ARRAY-ELEMENT-TYPE := &#39;double-float</span>
<span><span>;</span>;     a := nu.rand(5, 5)</span>
<span><span>;</span>;     b := nu.rand(5, 5)</span>
<span><span>;</span>;   nu.add(a, b)</span>
<span>#&lt;STANDARD-DENSE-ARRAY</span> :ROW-MAJOR 5x5 DOUBLE-FLOAT
  (  <span>0.353</span>       <span>0.518</span>       <span>1.773</span>       <span>0.453</span>       <span>0.582</span>    )
  (  <span>0.619</span>       <span>1.072</span>       <span>0.458</span>       <span>0.696</span>       <span>0.840</span>    )
  (  <span>0.965</span>       <span>0.511</span>       <span>0.213</span>       <span>0.496</span>       <span>0.999</span>    )
  (  <span>0.973</span>       <span>1.104</span>       <span>1.294</span>       <span>1.203</span>       <span>0.519</span>    )
  (  <span>0.771</span>       <span>1.120</span>       <span>0.457</span>       <span>1.436</span>       <span>1.783</span>    )
 {1031A4DC63}&gt;
IMPL&gt; (<span>let</span>* ((nu:<span>*array-element-type*</span> &#39;single-float)
             (a (nu:rand <span>5</span> <span>5</span>))
             (b (nu:rand <span>5</span> <span>5</span>)))
        (nu:add a b))
<span><span>;</span>; In less lispy terms:</span>
<span><span>;</span>; let nu.ARRAY-ELEMENT-TYPE := &#39;single-float</span>
<span><span>;</span>;     a := nu.rand(5, 5)</span>
<span><span>;</span>;     b := nu.rand(5, 5)</span>
<span><span>;</span>;   nu.add(a, b)</span>
<span>#&lt;STANDARD-DENSE-ARRAY</span> :ROW-MAJOR 5x5 SINGLE-FLOAT
  (  <span>0.699</span>       <span>1.833</span>       <span>0.830</span>       <span>0.985</span>       <span>0.422</span>    )
  (  <span>1.058</span>       <span>0.996</span>       <span>1.372</span>       <span>1.143</span>       <span>0.760</span>    )
  (  <span>1.051</span>       <span>1.019</span>       <span>1.293</span>       <span>1.272</span>       <span>1.018</span>    )
  (  <span>0.819</span>       <span>0.735</span>       <span>0.160</span>       <span>1.431</span>       <span>0.805</span>    )
  (  <span>0.827</span>       <span>0.821</span>       <span>1.484</span>       <span>0.126</span>       <span>1.160</span>    )
 {1031A7F7D3}&gt;</pre></div>
<p dir="auto">Here, the <code>nu:*array-element-type*</code> is the dynamically bound variable. The function <code>nu:rand</code> is looking up its value while it is being called. In essence, I’m not required to supply the <code>type</code> argument every time.
  Of course, I can specify the <code>type</code> if I wanted to optimize it or override the global value.</p>
<div dir="auto"><pre>IMPL&gt; (<span>let</span>* ((nu:<span>*array-element-type*</span> &#39;single-float)	
             (a (nu:rand <span>5</span> <span>5</span> :type &#39;double-float))	
             (b (nu:rand <span>5</span> <span>5</span> :type &#39;double-float)))	
        (nu:add a b))
<span><span>;</span>; let nu.ARRAY-ELEMENT-TYPE := &#39;single-float</span>
<span><span>;</span>;     a := nu:rand(5, 5, type = &#39;double-float)</span>
<span><span>;</span>;     b := nu:rand(5, 5, type = &#39;double-float)</span>
<span><span>;</span>;   nu:add(a, b)</span>
<span>#&lt;STANDARD-DENSE-ARRAY</span> :ROW-MAJOR 5x5 DOUBLE-FLOAT
  (  <span>1.611</span>       <span>0.862</span>       <span>0.473</span>       <span>1.118</span>       <span>0.534</span>    )	
  (  <span>1.314</span>       <span>1.172</span>       <span>0.943</span>       <span>1.064</span>       <span>1.157</span>    )	
  (  <span>1.232</span>       <span>0.439</span>       <span>0.961</span>       <span>0.984</span>       <span>0.993</span>    )	
  (  <span>0.642</span>       <span>0.720</span>       <span>1.119</span>       <span>0.871</span>       <span>1.328</span>    )	
  (  <span>1.155</span>       <span>1.455</span>       <span>0.667</span>       <span>1.770</span>       <span>1.296</span>    )	
 {<span>10379E0843</span>}&gt;	</pre></div>
<h3 dir="auto"><a id="user-content-structural-editing" aria-hidden="true" href="#structural-editing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Structural editing</h3>
<p dir="auto">Why, after so many decades, are we still writing and editing line by line, instead of… instead of relying on its structure? See a perhaps experimental <a href="https://github.com/ethan-leba/tree-edit">tree-edit</a> for instance. <a href="https://www.youtube.com/watch?v=D6h5dFyyUX0" rel="nofollow">Here</a>’s another example using paredit. <a href="http://danmidwood.com/content/2014/11/21/animated-paredit.html" rel="nofollow">Here</a>’s another.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/5c2ac3531199974f2980f9c3e0dd726873d9a18a83a6ba7104d1d67a07fa5be1/687474703a2f2f64616e6d6964776f6f642e636f6d2f6173736574732f616e696d617465642d706172656469742f706172656469742d73706c6963652d6b696c6c696e672d666f72776172642e676966"><img src="https://camo.githubusercontent.com/5c2ac3531199974f2980f9c3e0dd726873d9a18a83a6ba7104d1d67a07fa5be1/687474703a2f2f64616e6d6964776f6f642e636f6d2f6173736574732f616e696d617465642d706172656469742f706172656469742d73706c6963652d6b696c6c696e672d666f72776172642e676966" alt="http://danmidwood.com/assets/animated-paredit/paredit-splice-killing-forward.gif" data-animated-image="" data-canonical-src="http://danmidwood.com/assets/animated-paredit/paredit-splice-killing-forward.gif"/></a></p>
<p dir="auto">Granted, this is a bit geeky, but once the initial learning curve is done, it does give you superpowers for the rest of your life. The lisp parentheses are a feature, not a bug, <i>once you are past the initial hiccups :/</i>.</p>
<p dir="auto">I am aware julia has a <code>--lisp</code> mode, but I have never found any documentation for it. So, I don’t agree that all the things in julia are well-documented either :).</p>

<h2 dir="auto"><a id="user-content-software-versioning-and-deployment" aria-hidden="true" href="#software-versioning-and-deployment"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Software versioning and Deployment</h2>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_versioning_and_deployment" rel="nofollow">Software Versioning and Deployment</a></p>
<blockquote>
  <p dir="auto">The Quicklisp dist is curated by the Quicklisp maintainer, who ensures that all software builds successfully (in isolation; no checks are done to ensure that a piece of software is compatible with other software in the same dist).</p>
</blockquote>
<p dir="auto"><del>All software builds successfully /together/.</del> EDIT: I was mistaken to think that quicklisp actually tests whether or not systems build <i>together</i>, but nope, quicklisp only ensures that each system builds individually. This still ensures that there are no compile-time dependency conflicts in a particular quicklisp dist since the same versions of all the dependencies are being used to load the libraries, but there can be other issues like (i) runtime dependency conflicts (ii) <a href="https://groups.google.com/g/quicklisp/c/-pgRyJlJrmc" rel="nofollow">local-nicknames conflicts in the quicklisp 2022-04-01 dist</a>. Thanks mfiano for pointing this out!</p>
<blockquote>
  <p dir="auto">Because the official Quicklisp dists are released once every month or two (which is an eternity in the software world), developers cannot push hot-fixes or address user-reported problems in a timely manner, unless they run their own dist and convince their users to use that, or convince their users to clone directly from upstream, and place it in a particular location on their filesystem that Quicklisp looks for to override dist versions.</p>
</blockquote>
<p dir="auto">Other than quicklisp, there also exists <a href="https://www.clpm.dev/" rel="nofollow">Common Lisp Package Manager (clpm)</a> that intends to provide project-specific contexts, and dependency versioning in the sense mfiano mentions it.</p>
<p dir="auto">There is an easier (= more similar to quicklisp that a new lisper is often recommended to start out with) alternative to clpm: <a href="https://ultralisp.org/" rel="nofollow">ultralisp</a>, builds every 5 minutes, but does not provide the “build together” guarantee. Adding repositories and even creating your own dists is as simple as a few clicks!</p>
<p dir="auto">But by and large, I agree about the culture that Common Lisp developers (myself included) rarely version their software, or more specifically about them not specifying their version dependencies: they do version their own library, but they rarely mention the version dependencies. For the defacto libraries, this works, your code will more than likely work even if you pick up a 5 year old library. For libraries in quicklisp, this too works because quicklisp already checks if or not the libraries build together. Where it does not work is (i) for bleeding-edge libraries (ii) you are working in a Common Lisp team, this latter seems to be Eric Timmon’s motivation for developing CLPM!</p>
<p dir="auto">Quicklisp also allows submission of github tags or releases (and perhaps gitlab as well), a specific ones, the “latest” ones, and perhaps even specific commits, and not just specific branches.</p>
<h2 dir="auto"><a id="user-content-documentation" aria-hidden="true" href="#documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Documentation</h2>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#documentation" rel="nofollow">Documentation</a></p>
<p dir="auto"><a href="https://rabbibotton.github.io/clog/clog-manual.html" rel="nofollow">Common Lisp Omnificient GUI</a> is an excellent non-example of a “Common Lisp project that isn’t well documented”. More lispers, especially those of us who aim to attract new developers, should follow the lead and make their documentation just as extensive. Many other defacto libraries also have fairly extensive documentation, but it can (i) certainly be more extensive (ii) be more newcomer friendly.</p>
<h2 dir="auto"><a id="user-content-software-quality" aria-hidden="true" href="#software-quality"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Software Quality</h2>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#software_quality" rel="nofollow">Software Quality</a></p>
<blockquote>
  <p dir="auto">This problem is recursive, in that we have many “50%” solutions to the same problems, and the next round of developers will create another set of solutions to add to the pile.</p>
  <p dir="auto">…</p>
  <p dir="auto">In my opinion, this is due to the language being incredibly malleable. It is usually much easier to re-implement an idea than it is to use/fix someone else’s implementation.</p>
</blockquote>
<p dir="auto">This is best visible by the presence of <a href="https://gist.github.com/digikar99/16066dbf24b8789c969ea58837e0fbef">10+ libraries for numerical/matrix computing in Common Lisp</a>, yet none of them as complete as someone coming from a R/Matlab/Julia background might want it to be. Even for something as simple as JSON, there are <a href="https://sabracrolleton.github.io/json-review" rel="nofollow">10+ libraries</a>.</p>
<p dir="auto">I myself have been guilty of this. The lisp community - if I assume it exists - needs to come up with better ways to tackle the issue. Just like standardization process in 1994 took an extensive amount of time (10 years?), an equivalent amount of effort (a week or a month or few) needs to be spent in evaluating the current options, and indicating why they are insufficient, and asking existing library developers if they are willing to incorporate your request. But alongside that, an effort needs to be made for cross-library compatibility. Because Common Lisp is highly malleable, it is also easy to come up with glue code, but someone needs to do the work!</p>
<h2 dir="auto"><a id="user-content-performance-1" aria-hidden="true" href="#performance-1"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Performance</h2>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#performance" rel="nofollow">Performance</a></p>
<p dir="auto">As discussed earlier, the only way I see of resolving the aspects of performance that OP raised concerns with is through CLTL2 (and CFFI and closer-mop). Currently, polymorphic-functions is being tested on SBCL, CCL, and ECL through continuous-integration. I only use on SBCL in my day-to-day work, so CCL and ECL support might not be as good.</p>
<h2 dir="auto"><a id="user-content-community" aria-hidden="true" href="#community"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Community</h2>
<p dir="auto">Reference: <a href="https://mfiano.net/posts/2022-09-04-from-common-lisp-to-julia/#community" rel="nofollow">Community</a></p>
<p dir="auto">This is a slightly weird topic. Common Lisp has a small community yes. But even in that small community, the users have <i>very</i> diverse use cases. There’s quilc using Common Lisp to develop Coalton and <a href="https://github.com/quil-lang/magicl">magicl</a> (a fairly reasonable and scientific computing library) to work on quantum computing. There’s kaveh808 and others using Common Lisp for developing <a href="https://github.com/kaveh808/kons-9">an extensible IDE for 3D production</a>. There’s <a href="https://lisp-journey.gitlab.io/about/" rel="nofollow">vindarel</a> and others using Common Lisp primarily for web development. There are some people like me who take an interest in Common Lisp for cognitive architectures like <a href="https://github.com/asmaloney/ACT-R">ACT-R</a>. I bet there are even diverse use cases. Just how are these people to collaborate. It’s the same circular problem that OP mentioned for Software Quality, that all these exist <i>because</i> Common Lisp provided features to cater to the needs of each of them, but providing those features already meant a steeper learning curve.</p>
<p dir="auto">I will disagree that lispers are unhelpful in general; some are, many are not. That’s just the internet. And even if you get into a niche, people will certainly try to help you when you ask for it. Just today morning, I woke up reading u/stylewarning implementing a magicl wrapper for LAPACK’s dgges soon after <a href="https://github.com/quil-lang/magicl/pull/180" data-hovercard-type="pull_request" data-hovercard-url="/quil-lang/magicl/pull/180/hovercard">a user requested for it</a>.</p>
<p dir="auto">Catering such a diverse user base requires a huge community, so that each niche has some or the other users. Perhaps in the late future, we will have more projects like <a href="https://github.com/ciel-lang/CIEL">CIEL is an Extended Lisp</a> cropping up, along the lines of emacs and linux distros, to cater to each of the niches.</p>
<p dir="auto">I will certainly not recommend anyone to learn Common Lisp <i>while trying to get into the niche at the same time</i>. That’s too much to learn in one shot. Along the same lines, I will also discourage anyone trying to learn Common Lisp and Emacs at the same time. First learn your niche, and may be then if you find that the language your niche uses <i>feels awkward</i>, try learning Common Lisp, it will be a much smoother experience. If you are embarking on decades long projects, I don’t think spending a month or two learning Emacs and Common Lisp will go wasted.</p>
<p dir="auto">To lispers and open source developers, of which I myself am one, I might also add that we ought to take our life into account while working on projects. We don’t want to burn out, we don’t want to go into debt. We want to work on our projects, we want to do it sustainably. And if you see yourself being unable to support your work for a while, it is okay, focus on your life before it gets out of hands. Take care to not burn out. Developers will come and go, Common Lisp will stay, your projects will be used and taken care of (and may be even built upon) years after you write them :).</p>

<p dir="auto">All these paragraphs might seem like I use Common Lisp as my daily driver. But because the people around me rely on Python, and because Python has vastly more libraries that Common Lisp, I am stuck with Python. However, sometimes, I also rely on <a href="https://github.com/bendudson/py4cl">py4cl</a>/<a href="https://github.com/digikar99/py4cl2">2</a> to use python libraries in Common Lisp in cases where performance is not a concern.</p>
<p dir="auto">I wanted to make the switch from Python to Julia, and attempted a course project in Julia as a replacement for Python. The unnecessarily-long-for-debugging compilation times certainly put me off. I think I do like the semantics of Julia better than Python, but the compilation times is a deal-breaker for me. Perhaps I might make the switch once this gets fixed in the upcoming years :).</p>
<p dir="auto">Although, for larger and long-term projects, I will perhaps still stick with Common Lisp; by the time Julia gets all the goodies necessary for wanting me switch to it from Common Lisp, we might have a Common Lisp implementation over Julia. There certainly already exists one over <a href="https://github.com/clasp-developers/clasp">C++ and LLVM</a> :D.</p>
</article>
  </div>

  </div>
</div></div>
  </body>
</html>
