<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.loicmathieu.fr/wordpress/en/informatique/java-21-quoi-de-neuf/">Original</a>
    <h1>Java 21: What’s New?</h1>
    
    <div id="readability-page-1" class="page"><div id="main" role="main">

									
<article id="post-1684">

	
	
	<!-- .entry-header -->

			<div>
				<p>Now that Java 21 is features complete (Rampdown Phase Two at the day of writing), it’s time to walk through all the functionalities that bring to us, developers, this new version.</p>
<p>This article is part of a series on <a href="https://www.loicmathieu.fr/wordpress/tag/whatsnew/">what’s new on the last versions of Java</a>, for those who wants to read the others, here are the links: <a href="https://www.loicmathieu.fr/wordpress/informatique/java-20-quoi-de-neuf/">Java 20</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-19-quoi-de-neuf/">Java 19</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-18-quoi-de-neuf/">Java 18</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-17-quoi-de-neuf/">Java 17</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-16-quoi-de-neuf/">Java 16</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-15-quoi-de-neuf/">Java 15</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-14-quoi-de-neuf/">Java 14</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-13-quoi-de-neuf/">Java 13</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-12-quoi-de-neuf/">Java 12</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-11-quoi-de-neuf/">Java 11</a>, <a href="https://www.loicmathieu.fr/wordpress/informatique/java-10-quoi-de-neuf/">Java 10,</a> and <a href="https://www.loicmathieu.fr/wordpress/informatique/les-nouveautes-de-java-9-pour-les-developeurs/">Java 9</a>.</p>
<p>Java 21 is the new Long Term Support (LTS) version , which means it will be supported for two years. Given the number of JEPs (Java Enhancement Proposals) it contains – no fewer than 15 – it’s clear that this is a version rich in new features. But perhaps the most important (not to say exciting) one is the finalization of virtual threads! Virtual threads are lightweight threads with low creation and scheduling costs, making it easier to write concurrent applications. We’ll have to wait for the ecosystem to support them, but virtual threads will make Java relevant for highly concurrent applications in memory-constrained environments.</p>
<h2>JEP 430 – String Templates (Preview)</h2>
<p>Many languages support string interpolation. String interpolation is a string literal containing expressions as well as text literals.</p>
<p>For example, in Kotlin, <code>&#34;$x plus $y equals ${x + y}&#34;</code> is a string containing the expressions <code>$x</code>, <code>$y</code>, and <code>${x + y}</code>, which will be replaced by their textual values. These values are said to be interpolated within the character string. This interpolation is carried out from the variables and enables operations between variables (in this case, an addition).</p>
<p>The problem with interpolation is that it’s dangerous as a global feature, because it doesn’t allow for validation or sanitization when constructing the final string. This exposes it, for example, to SQL or JavaScript injections.</p>
<p>In Java, String Templates offer string interpolation with validation and sanitization via a template processor.</p>
<p>A template processor takes a template, then interpolates the template to an object of a specific type; so from a template, you can interpolate a <code>String</code>, or a <code>PreparedStatement</code>, or a <code>JSONObject</code>, … As it is possible to have several processors, each can implement a validation step if required.</p>
<p>Here’s an example of how to use the String Template <code>STR</code>, which has no specific validation and can be used to replace string concatenation:</p>
<pre>String firstName = &#34;Loïc&#34;;
String lastName  = &#34;Mathieu&#34;;
String helloWorld  = STR.&#34;Hello \{firstName} \{lastName}&#34;;
</pre>
<p>In Java, expressions are defined by <code>\{expression}</code>, and calling a template processor is done via its name, in this case FMT, which is a constant of the <code>StringTemplate</code> interface that will have been previously imported via a static import.</p>
<p>There has been a lot of discussion around the choice of the expression format. Due to the existence of many libraries using $, # or {} as expression delimiters, the choice was for a format that is not valid outside String Templates: <code>String s = &#34;Hello \{firstName} \{lastName}&#34;</code> does not compile. This distinguishes String Templates from simple Strings.</p>
<p>The standard library includes three template processors:</p>
<ul>
<li><code>RAW</code>: processor that does not interpolate character strings, enables low-level manipulations.</li>
<li><code>STR</code>: processor that interpolates a character string to another character string via simple concatenation.</li>
<li><code>FMT</code>: processor that interpolates a character string to another character string, allowing expressions to be formatted via a <a title="Formatter API doc" href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/Formatter.html" target="_blank" rel="noopener">Formatter</a>, for example <code>FMT.&#34;%05d\{x} + %05d\{y} = %05d\{x + y}&#34;;</code></li>
</ul>
<p>You can create your own processors by implementing the <code>StringTemplate.Processor</code> interface.</p>
<p>More information in the <a title="JEP 430" href="https://openjdk.org/jeps/430" target="_blank" rel="noopener">JEP 430</a>.</p>
<h2>JEP 431 – Sequenced Collections</h2>
<p>Java’s Collection API has seen an addition in Java 21 of a magnitude not seen for many, many releases!</p>
<p>Java collections don’t have a type representing an ordered sequence of elements, Java 21 fills this gap by introducing the <code>SequencedCollection</code>, <code>SequencedSet</code> and <code>SequencedMap</code> interfaces. These interfaces provide methods for adding, modifying or deleting elements at the beginning or end of the collection, as well as for iterating over a collection in reverse order.</p>
<p>Here’s the <code>SequencedCollection</code> interface:</p>
<pre>interface SequencedCollection&lt;E&gt; extends Collection&lt;E&gt; {
    SequencedCollection&lt;E&gt; reversed();
    void addFirst(E);
    void addLast(E);
    E getFirst();
    E getLast();
    E removeFirst();
    E removeLast();
}
</pre>
<p>The <code>reversed()</code> method will return a view of the collection in reversed order; a modification to the original collection will impact the reversed view.</p>
<p><code>SequencedSet</code> is a set that is also a <code>SequencedCollection</code>, here is its interface:</p>
<pre>interface SequencedSet&lt;E&gt; extends Set&lt;E&gt;, SequencedCollection&lt;E&gt; {
    SequencedSet&lt;E&gt; reversed();
}
</pre>
<p><code>SequencedMap</code> is a map whose entries are ordered, here is its interface:</p>
<pre>interface SequencedMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
    SequencedMap&lt;K,V&gt; reversed();
    SequencedSet&lt;K&gt; sequencedKeySet();
    SequencedCollection&lt;V&gt; sequencedValues();
    SequencedSet&lt;Entry&lt;K,V&gt;&gt; sequencedEntrySet();
    V putFirst(K, V);
    V putLast(K, V);
    Entry&lt;K,V&gt; firstEntry();
    Entry&lt;K,V&gt; lastEntry();
    Entry&lt;K,V&gt; pollFirstEntry();
    Entry&lt;K,V&gt; pollLastEntry();
}
</pre>
<p>These new interfaces have been integrated into the existing Collection API class hierarchy.</p>
<p><img decoding="async" src="https://i0.wp.com/cr.openjdk.org/~smarks/collections/SequencedCollectionDiagram20220216.png?resize=640%2C356&amp;ssl=1" alt="Java Collection API hierarchy" width="640" height="356" data-recalc-dims="1"/></p>
<p>Note that some of the most widely used implementations of the Collection API: <code>ArrayList</code>, <code>LinkedList</code>, <code>LinkedHashMap</code> and <code>LinkedHashSet</code> are now sequential collections.</p>
<p>More information in the <a title="JEP 431" href="https://openjdk.org/jeps/431" target="_blank" rel="noopener">JEP 431</a>.</p>
<h2>JEP 443 – Unnamed Patterns and Variables Preview)</h2>
<p>This new feature of the Java language allows you to use <code>_</code> as an unnamed pattern or variable. The aim is to use <code>_</code> to denote a pattern or variable that is useless, the compiler will then make sure that the variable is really unused because it has no name.</p>
<p>Within Java’s pattern matching, <code>_</code> can be used as an unnamed pattern, for example in an instanceof: <code>instanceof Point(_, int y)</code>; or as an unnamed pattern variable, for example in an instanceof: <code>instanceof Point(int _, int y)</code> or in a switch: <code>case Box(GreenBall _)</code>.</p>
<p><code>_</code> can also be used to denote an unnamed variable that can neither be read nor written; as it has no name, several unnamed variables can be used in the same scope.</p>
<p>You can use an unnamed variable:</p>
<ul>
<li>As a local variable inside a statement,</li>
<li>As a resource inside a try-with-resource,</li>
<li>In a for loop header (basic or enhanced),</li>
<li>As an exception in the parameter of a catch block,</li>
<li>As a parameter of a lambda expression.</li>
</ul>
<p>Here are a few examples from JEP 443:</p>
<pre>// enhanced for loop
int acc = 0;
for (Order _ : orders) {
    if (acc &lt; LIMIT) { 
        ... acc++ ...
    }
}

// block statement 
Queue&lt;Integer&gt; q = ... // x1, y1, z1, x2, y2, z2, ...
while (q.size() &gt;= 3) {
   var x = q.remove();
   var y = q.remove();
   var _ = q.remove();
   ... new Point(x, y) ...
}

// catch block
String s = ...
try { 
    int i = Integer.parseInt(s);
    ... i ...
} catch (NumberFormatException _) { 
    System.out.println(&#34;Bad number: &#34; + s);
}

// try-with-resources
try (var _ = ScopedContext.acquire()) {
    ... no use of acquired resource ...
}

// lamdba parameter
stream.collect(Collectors.toMap(String::toUpperCase, _ -&gt; &#34;NODATA&#34;))
</pre>
<p>This feature, although it may seem small, is in fact a much-awaited feature that can greatly improve code readability and avoid possible bugs by clearly denoting that a variable should not be used. We can only regret that, for the moment, it is not possible to use <code>_</code> as a parameter of an overloaded method.</p>
<p>More information in the <a title="JEP 443" href="https://openjdk.org/jeps/443" target="_blank" rel="noopener">JEP 443</a>.</p>
<h2>JEP 445: Unnamed Classes and Instance Main Methods (Preview)</h2>
<p>The aim of this new feature is to make Java easier to learn and simpler to use for simple cases, such as writing a simple main method.</p>
<p>Let’s take a “Hello World” in Java as an example:</p>
<pre>public class HelloWorld { 
    public static void main(String[] args) { 
        System.out.println(&#34;Hello, World!&#34;);
    }
}
</pre>
<p>To write “Hello World” in the console, you need to know the principles of class, method, visibility and the static modifier, as well as the very specific signature of the main method in Java: the method that will be executed as the program’s entry point.</p>
<p>First change: enable a non-static (instance method), non-public main method with no parameters:</p>
<pre>class HelloWorld { 
    void main() { 
        System.out.println(&#34;Hello, World!&#34;);
    }
}
</pre>
<p>Second change: the introduction of unnamed classes:</p>
<pre>void main() {
    System.out.println(&#34;Hello, World!&#34;);
}
</pre>
<p>An unnamed class is a class in a .class file that has no class declaration and cannot be called by another class, but can contain methods and fields. It is contained in an unnamed package.</p>
<p>These two new features, although targeted at developers learning Java, can greatly facilitate the writing of small programs in Java by reducing the ceremony around writing the entry point of a Java program.</p>
<p>Discussions around this feature also covered the case of <code>System.out.println()</code> (as well as reading from the console) and possible simplifications. It’s possible that a future version of Java will include simplifications in this area.</p>
<p>More information in the <a title="JEP 445" href="https://openjdk.org/jeps/445" target="_blank" rel="noopener">JEP 445</a>.</p>
<h2>Features coming out of preview</h2>
<p>The following features comes out of preview (or incubator module) are now standard features:</p>
<ul>
<li><a title="JEP 440" href="https://openjdk.org/jeps/440" target="_blank" rel="noopener">JEP 440</a> – Record Patterns: enhance Java’s pattern matching with record patterns, which deconstruct a record into its attributes.</li>
<li><a title="JEP 441" href="https://openjdk.org/jeps/441" target="_blank" rel="noopener">JEP 441</a> – Pattern Matching for switch: allows you to make a switch on the type of a variable (including enum, record and array), and extract a local variable of the corresponding type.</li>
<li><a title="JEP 444" href="https://openjdk.org/jeps/444" target="_blank" rel="noopener">JEP 444</a> – Virtual Threads: sometimes also called green threads or lightweight threads; these are lightweight threads, with low creation and scheduling costs, which make it easier to write concurrent applications.</li>
</ul>
<p>For details on these, please refer to my previous articles.</p>
<h2>Features that remain in preview</h2>
<p>The following features remain in preview (or in the incubator module).</p>
<ul>
<li><a title="JEP 442" href="https://openjdk.org/jeps/442" target="_blank" rel="noopener">JEP 442</a> – Foreign Function &amp; Memory API (Third Preview): improvements following feedback from the preview. Native memory segments are now managed via a new <code>Arena</code> API.</li>
<li><a title="JEP-448" href="https://openjdk.org/jeps/448" target="_blank" rel="noopener">JEP-448</a> – Vector API: sixth incubation of this feature. This new version includes bugfixes and performance improvements.</li>
<li><a title="JEP 446" href="https://openjdk.org/jeps/446" target="_blank" rel="noopener">JEP 446</a> – Scoped Values (Preview): previously in incubation, enable the sharing of immutable data within and between threads.</li>
<li><a title="JEP 453" href="https://openjdk.org/jeps/453" target="_blank" rel="noopener">JEP 453</a> – Structured Concurrency (Preview): previously in incubation, a new API to simplify the writing of multi-threaded code by allowing multiple concurrent tasks to be treated as a single processing unit.</li>
</ul>
<p>For details on these, please refer to my previous articles.</p>
<h2>Miscellaneous</h2>
<p>Various additions to the JDK:</p>
<ul>
<li><code>Character.isEmoji()</code>, <code>Character.isEmojiPresentation()</code>, <code>Character.isEmojiModifier()</code>, <code>Character.isEmojiModifierBase()</code>, <code>Character.isEmojiComponent()</code>, <code>Character.isExtendedPictographic()</code>.</li>
<li><code>Math.clamp()</code> and <code>StrictMath.clamp()</code>: clamp a value between two bounds min and max.</li>
<li><code>StringBuilder.repeat()</code>: joint a character or string a certain number of times.</li>
<li><code>HttpCLient</code> now implements <code>AucoCloseable</code> and can therefore be used more easily in a try-with-resources block.</li>
<li><code>Locale.availableLocales()</code>: returns the list of installed locales.</li>
<li><code>Collections.shuffle(List, RandomGenerator)</code>: performs random permutations of the elements of a list with a <code>RandomGenerator</code>.</li>
<li><code>String.splitWithDelimiters()</code> and <code>Pattern.splitWithDelimiters()</code>: splits a string including delimiters.</li>
</ul>
<p>All the new JDK 21 APIs can be found in <a title="The Java Version Almanac – New APIs in Java 21" href="https://javaalmanac.io/jdk/21/apidiff/20/" target="_blank" rel="noopener">The Java Version Almanac – New APIs in Java 21</a>.</p>
<h2>Internal changes, performance, and security</h2>
<p>The ZGC Garbage Collector becomes generational, so it can separate the heap into several zones according to the age of the objects. To enable this feature set the command line option <code>-XX:+ZGenerational</code>. This Garbage Collector was created to support very large heaps (several terrabytes) with very low pauses (on the order of milliseconds). The addition of a generational heap enables it to support different workloads while consuming fewer resources. More information in the <a title="JEP 439" href="https://openjdk.org/jeps/439" target="_blank" rel="noopener">JEP 439</a>.</p>
<p>On the security front, Java now supports Key Encapsulation Mechanism (KEM), an encryption technique for securing symmetric keys using public-key cryptography. More information in the <a title="JEP 452" href="https://openjdk.org/jeps/452" target="_blank" rel="noopener">JEP 452</a>.</p>
<p>The Windows 32-bit port for x86 CPUs has been deprecated for removal in a future release. Windows 10, the last version of Windows supporting 32-bit architectures, will reach end-of-life in October 2025. Depreciating and then removing the Windows 32-bit port will simplify the Open JDK build and reduce its maintenance cost. More information in the <a title="JEP 449" href="https://openjdk.org/jeps/449" target="_blank" rel="noopener">JEP 449</a>.</p>
<p>Dynamic Java agent loading is now deprecated for removal. If used, it will display a WARNING in the JVM log. Java agent loading at application startup remains supported, it is only dynamic loading after application startup that is deprecated. The aim is to improve the integrity of the JVM, as an agent can modify the code of an application, loading it after JVM startup is a security risk. More information in the <a title="JEP 451" href="https://openjdk.org/jeps/451" target="_blank" rel="noopener">JEP 451</a>.</p>
<p>On the performance side, Per Minborg has made improvements in the conversion between primitives (long to int, for example) via the use of <code>VarHandle</code> in place of existing binary calculations. As these conversion operations are widely used within Java serialization, this one takes advantage of them and sees a performance improvement of almost 5%. Other JDK APIs and many libraries also use these conversions and will see their performance improve. More information in Per Minborg’s article: <a href="https://minborgsjavapot.blogspot.com/2023/01/java-21-performance-improvements.html" target="_blank" rel="noopener">Java 21: Performance Improvements Revealed</a>.</p>
<h2>Conclusion</h2>
<p>Given the high number of features included in Java 21, we can expect Java 22 to be a stabilization release. I hope that some features will be out of preview in Java 22 (which should be the case for the Foreign Function &amp; Memory API), particularly Scoped Values and Structured Concurrency, which complement Virtual Threads by making it easier to write concurrent applications.</p>
<p>To find all the changes in Java 21, refer to the <a title="release notes" href="https://jdk.java.net/21/release-notes" target="_blank" rel="noopener">release notes</a>.</p>


							</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article><!-- #post-## -->
				</div></div>
  </body>
</html>
