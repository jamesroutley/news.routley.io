<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://garden.bradwoods.io/notes/javascript/three-js/shaders/shaders-103-smoke">Original</a>
    <h1>Cigarette smoke effect using shaders</h1>
    
    <div id="readability-page-1" class="page"><div><div><div aria-hidden="true"><p><span><span>Brought to you by:</span></span></p><p><img alt="" fetchpriority="high" width="42" height="42" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/sponsors/nerv.svg"/></p><p><span><span>NERV</span><span> - <!-- -->God&#39;s in his Heaven, all&#39;s right with the world</span></span></p></div></div><section><div><div><p><img alt="Smoke" fetchpriority="high" width="300" height="300" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2Fpopular%2Fshaders103Smoke.webp&amp;w=384&amp;q=75 1x, /_next/image?url=%2Fimages%2Fpopular%2Fshaders103Smoke.webp&amp;w=640&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2Fimages%2Fpopular%2Fshaders103Smoke.webp&amp;w=640&amp;q=75"/></p></div><section><p><span><span>Planted: </span><time datetime="2026-01-05T00:00:00.000Z">Jan 2026</time></span></p><p><span><span>Status: </span></span><a tabindex="0" href="https://garden.bradwoods.io/about#aboutthisgarden"><span><span>seed</span></span></a></p><p aria-hidden="true"><span><span>Planted<!-- -->: </span><time datetime="2026-01-05T00:00:00.000Z">Jan 2026</time></span></p><p><span><span>Hits: </span>2</span></p><p><span><span>Intended Audience: </span>Creative coders and front-end developers familiar with three.js</span></p></section><p><span>How to make a cigarette smoke effect using shaders and three.js.<!-- --> If you&#39;re unfamiliar with shaders, see these <a tabindex="0" href="https://garden.bradwoods.io/notes/javascript/three-js/shaders"><span>notes</span></a> that cover the fundamentals. The effect:</span></p><section></section></div></section>
<section><div><h2><span><span><span>Scene</span></span></span></h2><section></section><p><span>First we render a three.js scene with a plane geometry wrapped in shader material:</span></p><!--$--><section><div><pre><p><span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>vertexShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>  void main() {</span></span></p><p><span><span>    // Final position</span></span></p><p><span><span>    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);</span></span></p><p><span><span>  }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>  void main() {</span></span></p><p><span><span>    // Final color</span></span></p><p><span><span>    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);</span></span></p><p><span><span>    #include &lt;tonemapping_fragment&gt;</span></span></p><p><span><span>    #include &lt;colorspace_fragment&gt;</span></span></p><p><span><span>  }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>side</span><span>:</span><span> </span><span>THREE</span><span>.</span><span>DoubleSide</span><span>,</span><span></span></span></p><p><span><span>  </span><span>wireframe</span><span>:</span><span> config</span><span>.</span><span>material</span><span>.</span><span>wireframe</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--></div></section>
<section><div><h2><span><span><span>Texture</span></span></span></h2><section></section><p><span>Perlin noise will provide the random values needed for the effect.
We load a Perlin noise texture and pass it into the fragment shader.</span></p><div><p><img alt="Perlin noise" loading="lazy" width="128" height="128" decoding="async" data-nimg="1" srcset="/_next/image?url=%2Fimages%2Fnotes%2Fsmoke%2FperlinNoise.png&amp;w=128&amp;q=75 1x, /_next/image?url=%2Fimages%2Fnotes%2Fsmoke%2FperlinNoise.png&amp;w=256&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2Fimages%2Fnotes%2Fsmoke%2FperlinNoise.png&amp;w=256&amp;q=75"/></p></div><!--$--><section><div><pre><p><span><span>const</span><span> textureLoader </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>TextureLoader</span><span>(</span><span>)</span><span>;</span><span></span></span></p><p><span><span></span><span>const</span><span> texture </span><span>=</span><span> textureLoader</span><span>.</span><span>load</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>textureURL</span><span>)</span><span>;</span><span></span></span></p><p><span><span></span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>uniforms</span><span>:</span><span> </span><span>{</span><span></span></span></p><p><span><span>    </span><span>uTexture</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>texture</span><span>)</span><span>,</span><span></span></span></p><p><span><span>  </span><span>}</span><span>,</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    uniform sampler2D uTexture;</span></span></p><p><span><span>    ...</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>...</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--><h3><span><span>Fragment UVs</span></span></h3><p><span>To sample the texture, we need the UV coords of each fragment.
We can pass the coords from the vertex to the fragment shader using a varying.
To confirm it&#39;s working, we use the UVs as the fragment&#39;s red and green value — resulting in a green-red gradient.
To see the effect, set <strong>state: uv</strong> in the controls.</span></p><div><p><img alt="UV colors" loading="lazy" width="372" height="376" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/notes/smoke/uVColor.svg"/></p></div><!--$--><section><div><pre><p><span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>vertexShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    varying vec2 vUv;</span></span></p><p><span><span>    void main() {</span></span></p><p><span><span>      // Final position</span></span></p><p><span><span>      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);</span></span></p><p><span><span>      // Varyings</span></span></p><p><span><span>      vUv = uv;</span></span></p><p><span><span>    }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    varying vec2 vUv;</span></span></p><p><span><span>    void main() {</span></span></p><p><span><span>      vec2 textureUv = vUv;</span></span></p><p><span><span>      gl_FragColor = vec4(vUv, 0.0, 1.0);</span></span></p><p><span><span>      ...      </span></span></p><p><span><span>    }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--><h3><span><span>Map texture to geometry</span></span></h3><p><span>To map the texture onto the material, we use <code>texture(uTexture, textureUv).r;</code>.
It reads the texture&#39;s color value at the given coordinates using the same coordinate space as the fragment shader:</span></p><div><p><img alt="UV colors" loading="lazy" width="424" height="268" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/notes/smoke/uVTexture.svg"/></p></div><p><span>Passing the current fragment&#39;s UV coordinates to <code>texture()</code> lets us map the texture onto the material pixel by pixel.
The function returns a normalized RGBA value. Since the texture is grayscale, all three color channels are equal, so we only need the red channel (<code>.r</code>).
We then assign it to the fragment&#39;s color:</span></p><!--$--><section><div><pre><p><span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>  uniform sampler2D uTexture;</span></span></p><p><span><span>  varying vec2 vUv;</span></span></p><p><span><span>  void main() {</span></span></p><p><span><span>    vec2 textureUv = vUv;</span></span></p><p><span><span>    // Texture</span></span></p><p><span><span>    float textureImpl = texture(uTexture, textureUv).r;</span></span></p><p><span><span>    gl_FragColor = vec4(textureImpl, textureImpl, textureImpl, 1.0);</span></span></p><p><span><span>    ...</span></span></p><p><span><span></span><span>`</span></span></p></pre></div></section><!--/$--><p><span>To see the effect, set <strong>state: texture</strong> in the controls (the texture stretches to fit the geometry).</span></p><h3><span><span>Sample size</span></span></h3><p><span>We don&#39;t have to use the whole texture.
<code>uTextureSampleWidth</code> and <code>uTextureSampleHeight</code> is added to enable selecting only a portion of the texture.</span></p><!--$--><section><div><pre><p><span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>  uniform sampler2D uTexture;</span></span></p><p><span><span>  uniform float uTextureSampleWidth;</span></span></p><p><span><span>  uniform float uTextureSampleHeight;</span></span></p><p><span><span>  varying vec2 vUv;</span></span></p><p><span><span>  void main() {</span></span></p><p><span><span>    vec2 textureUv = vUv;</span></span></p><p><span><span>    // Set texture sample size</span></span></p><p><span><span>    textureUv.x *= uTextureSampleWidth;</span></span></p><p><span><span>    textureUv.y *= uTextureSampleHeight;</span></span></p><p><span><span>    // Texture</span></span></p><p><span><span>    float textureImpl = texture(uTexture, textureUv).r;</span></span></p><p><span><span>    gl_FragColor = vec4(textureImpl, textureImpl, textureImpl, 1.0);</span></span></p><p><span><span>    ...</span></span></p><p><span><span></span><span>`</span></span></p></pre></div></section><!--/$--><h3><span><span>Mask</span></span></h3><p><span>Because smoke is translucent, we need to render the texture as a mask instead of an image.
If we change the fragment&#39;s color to white and use the texture&#39;s color value for the alpha channel, it will render the texture as white with varying opacity instead of shades of gray.</span></p><ul><li><span><span><span>▪</span> <!-- -->a white pixel in the texture (value: <code>1</code>) renders a fully opaque white pixel.</span></span></li><li><span><span><span>▪</span> <!-- -->a black pixel in the texture (value: <code>0</code>) renders a fully transparent pixel.</span></span></li><li><span><span><span>▪</span> <!-- -->gray pixels render something in between.</span></span></li></ul><p><span>Because where varying opacity, we need to set <code>transparent: true</code> in the material.
To see the effect, set <strong>state: mask</strong> in the controls.</span></p><!--$--><section><div><pre><p><span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    ...</span></span></p><p><span><span>    void main() {</span></span></p><p><span><span>      gl_FragColor = vec4(1.0, 1.0, 1.0, textureImpl);</span></span></p><p><span><span>      ...</span></span></p><p><span><span>    }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>transparent</span><span>:</span><span> </span><span>true</span><span>,</span><span></span></span></p><p><span><span>  </span><span>...</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--></div></section>
<section><div><h2><span><span><span>Animate</span></span></span></h2><section></section><p><span>To create a smoke rising animation, we set the texture to repeat itself vertically using:</span></p><!--$--><section><div><pre><p><span><span>texture</span><span>.</span><span>wrapT</span><span> </span><span>=</span><span> </span><span>THREE</span><span>.</span><span>RepeatWrapping</span><span>;</span></span></p></pre></div></section><!--/$--><p><span>The result is, when we translate the texture up, a copy of it will fill the space below.
We then pass the elapsed time into the shader to provide a continually increasing number and use it to continually lower the y-coord of the texture sample.
The creates the effect of the texture moving up.
<code>uSpeed</code> is added to control how fast this happens.</span></p><!--$--><section><div><pre><p><span><span>const</span><span> texture </span><span>=</span><span> textureLoader</span><span>.</span><span>load</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>textureURL</span><span>)</span><span>;</span><span></span></span></p><p><span><span>texture</span><span>.</span><span>wrapT</span><span> </span><span>=</span><span> </span><span>THREE</span><span>.</span><span>RepeatWrapping</span><span>;</span><span></span></span></p><p><span><span></span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>uniforms</span><span>:</span><span> </span><span>{</span><span></span></span></p><p><span><span>    </span><span>uTime</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>0</span><span>)</span><span>,</span><span></span></span></p><p><span><span>    </span><span>uSpeed</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>speed</span><span>)</span><span></span></span></p><p><span><span>    </span><span>...</span><span></span></span></p><p><span><span>  </span><span>}</span><span>,</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    uniform float uTime;</span></span></p><p><span><span>    uniform float uSpeed;</span></span></p><p><span><span>    ...</span></span></p><p><span><span>    void main() {</span></span></p><p><span><span>      // Animate</span></span></p><p><span><span>      textureUv.y -= uTime * uSpeed;</span></span></p><p><span><span>      // Texture</span></span></p><p><span><span>      float textureImpl = texture(uTexture, textureUv).r;</span></span></p><p><span><span>      ...</span></span></p><p><span><span>    }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>...</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span><span></span></span></p><p><span><span></span><span>const</span><span> clock </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Clock</span><span>(</span><span>)</span><span>;</span><span></span></span></p><p><span><span></span><span>function</span><span> </span><span>onFrame</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></span></p><p><span><span>  </span><span>const</span><span> elapsedTime </span><span>=</span><span> clock</span><span>.</span><span>getElapsedTime</span><span>(</span><span>)</span><span>;</span><span></span></span></p><p><span><span>  material</span><span>.</span><span>uniforms</span><span>.</span><span>uTime</span><span>.</span><span>value</span><span> </span><span>=</span><span> elapsedTime</span><span>;</span><span></span></span></p><p><span><span>  </span><span>...</span></span></p></pre></div></section><!--/$--></div></section>
<section><div><h2><span><span><span>Remap</span></span></span></h2><section></section><p><span>Currently, the effect isn&#39;t transparent enough to look like smoke.
The texture has very few black pixels — most are gray — which makes the smoke appear solid.
We can fix this by remapping the texture&#39;s color values using:</span></p><!--$--><section><div><pre><p><span><span>smoothstep</span><span>(</span><span>uRemapLow</span><span>,</span><span> uRemapHigh</span><span>,</span><span> textureImpl</span><span>)</span></span></p></pre></div></section><!--/$--><ul><li><span><span><span>▪</span> <code>uRemapLow</code> and <code>uRemapHigh</code> are values between 0 and 1.</span></span></li><li><span><span><span>▪</span> <code>textureImpl</code> is the texture&#39;s current pixel color value.</span></span></li></ul><p><span>The function works as follows:</span></p><ul><li><span><span><span>▪</span> <!-- -->If <code>textureImpl</code> &lt; <code>uRemapLow</code>, it returns 0 (black).</span></span></li><li><span><span><span>▪</span> <!-- -->If <code>textureImpl</code> &gt; <code>uRemapHigh</code>, it returns 1 (white).</span></span></li><li><span><span><span>▪</span> <!-- -->Values in between are mapped smoothly along a curve between 0 and 1.</span></span></li></ul><p><span>This allows us to turn dark grays into black and light grays into white while keeping a smooth transition between the two.</span></p><!--$--><section><div><pre><p><span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>uniforms</span><span>:</span><span> </span><span>{</span><span></span></span></p><p><span><span>    </span><span>uRemapLow</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>remap</span><span>.</span><span>low</span><span>)</span><span>,</span><span></span></span></p><p><span><span>    </span><span>uRemapHigh</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>remap</span><span>.</span><span>high</span><span>)</span><span></span></span></p><p><span><span>    </span><span>...</span><span></span></span></p><p><span><span>  </span><span>}</span><span>,</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    uniform float uRemapLow;</span></span></p><p><span><span>    uniform float uRemapHigh;</span></span></p><p><span><span>    ...  </span></span></p><p><span><span>    void main() {</span></span></p><p><span><span>      // Texture</span></span></p><p><span><span>      float textureImpl = texture(uTexture, textureUv).r;</span></span></p><p><span><span>      // Remap</span></span></p><p><span><span>      textureImpl = smoothstep(uRemapLow, uRemapHigh, textureImpl);</span></span></p><p><span><span>      ...</span></span></p><p><span><span>    }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>...</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--></div></section>
<section><div><h2><span><span><span>Edges</span></span></span></h2><section></section><p><span>Our smoke effect looks like wallpaper because the edges of the geometry are visible. We can fix this by fading out the texture near the edges using smoothstep.
For example, for the left edge:</span></p><!--$--><section><div><pre><p><span><span>float fadeEdges </span><span>=</span><span> </span><span>smoothstep</span><span>(</span><span>0.0</span><span>,</span><span> uEdgeX</span><span>,</span><span> vUv</span><span>.</span><span>x</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--><p><span>If we set <code>uEdgeX</code> = <code>0.4</code>, it:</span></p><ul><li><span><span><span>▪</span> <!-- -->returns 0 at <code>vUv.x = 0</code> (the very edge)</span></span></li><li><span><span><span>▪</span> <!-- -->returns 1 at <code>vUv.x &gt;= 0.4</code></span></span></li><li><span><span><span>▪</span> <!-- -->smoothly interpolates values between 0 and 1 for positions in between</span></span></li></ul><div><p><img alt="Edges calculation" loading="lazy" width="348" height="268" decoding="async" data-nimg="1" src="https://garden.bradwoods.io/images/notes/smoke/edges.svg"/></p></div><p><span>When this value is multiplied by the texture color value, it applies this additional level of opacity to the output:</span></p><!--$--><section><div><pre><p><span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>uniforms</span><span>:</span><span> </span><span>{</span><span></span></span></p><p><span><span>    </span><span>uEdgeX</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>edge</span><span>.</span><span>x</span><span>)</span><span>,</span><span></span></span></p><p><span><span>    </span><span>uEdgeY</span><span>:</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>Uniform</span><span>(</span><span>config</span><span>.</span><span>material</span><span>.</span><span>edge</span><span>.</span><span>y</span><span>)</span><span></span></span></p><p><span><span>    </span><span>...</span><span></span></span></p><p><span><span>  </span><span>}</span><span>,</span><span></span></span></p><p><span><span>  </span><span>fragmentShader</span><span>:</span><span> </span><span>`</span><span></span></span></p><p><span><span>    uniform float uEdgeX;</span></span></p><p><span><span>    uniform float uEdgeY;</span></span></p><p><span><span>    ...</span></span></p><p><span><span>    void main() {      </span></span></p><p><span><span>      // Remap</span></span></p><p><span><span>      textureImpl = smoothstep(uRemapLow, uRemapHigh, textureImpl);</span></span></p><p><span><span>      // Edges</span></span></p><p><span><span>      // left edge</span></span></p><p><span><span>      float fadeEdges = smoothstep(0.0, uEdgeX, vUv.x);</span></span></p><p><span><span>      // right edge</span></span></p><p><span><span>      fadeEdges *= smoothstep(1.0, 1.0 - uEdgeX, vUv.x);</span></span></p><p><span><span>      // top edge</span></span></p><p><span><span>      fadeEdges *= smoothstep(0.0, uEdgeY, vUv.y);</span></span></p><p><span><span>      // bottom edge</span></span></p><p><span><span>      fadeEdges *= smoothstep(1.0, 1.0 - uEdgeY, vUv.y);</span></span></p><p><span><span>      textureImpl *= fadeEdges;</span></span></p><p><span><span>      ...</span></span></p><p><span><span>    }</span></span></p><p><span><span>  </span><span>`</span><span>,</span><span></span></span></p><p><span><span>  </span><span>...</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--></div></section>
<section><div><h2><span><span><span>Twist</span></span></span></h2><section></section><p><span>To improve the effect, we twist the geometry around the y-axis.
Changing the geometry from a 2D plane to a 3D spiral.
This requires modifying vertex positions, not color, so we&#39;ll modify the vertex shader.</span></p><h3><span><span>Random value</span></span></h3><p><span>For each vertical position on the plane (<code>UV.y</code>), we want a random angle of twist that gradually changes as we go from bottom to top.
We do this by sampling a <code>1px</code> wide vertical slice of the texture.
<code>uTwistSampleX</code> is the x-position of the slice (it can be any value between <code>0</code> and <code>1</code>) and is the same for every vertex.</span></p><!--$--><section><div><pre><p><span><span>uniform float uTwistSampleX</span><span>;</span><span></span></span></p><p><span><span></span><span>void</span><span> </span><span>main</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></span></p><p><span><span>  float textureY </span><span>=</span><span> uv</span><span>.</span><span>y</span><span>;</span><span></span></span></p><p><span><span>  float textureValue </span><span>=</span><span> </span><span>texture</span><span>(</span><span>uTexture</span><span>,</span><span> </span><span>vec2</span><span>(</span><span>uTwistSampleX</span><span>,</span><span> textureY</span><span>)</span><span>)</span><span>.</span><span>r</span><span>;</span><span></span></span></p><p><span><span>  </span><span>...</span></span></p></pre></div></section><!--/$--><p><span>By taking advantage of the fact that the texture stretches to fit the geometry, we can control to how many twists there will be by changing the height of the slice.
The taller the slice, the more values, the more variations:</span></p><!--$--><section><div><pre><p><span><span>uniform float uTwistSampleHeight</span><span>;</span><span></span></span></p><p><span><span></span><span>void</span><span> </span><span>main</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></span></p><p><span><span>  float textureY </span><span>=</span><span> uv</span><span>.</span><span>y</span><span> </span><span>*</span><span> uTwistSampleHeight</span><span>;</span><span></span></span></p><p><span><span>  </span><span>...</span></span></p></pre></div></section><!--/$--><h3><span><span>Animation</span></span></h3><p><span>To animate the twists, we use the same technique as before: use elapsed time to continually lower the sample y-coord — making the twists rise:</span></p><!--$--><section><div><pre><p><span><span>uniform float uTime</span><span>;</span><span></span></span></p><p><span><span>uniform float uTwistSpeed</span><span>;</span><span></span></span></p><p><span><span></span><span>void</span><span> </span><span>main</span><span>(</span><span>)</span><span> </span><span>{</span><span></span></span></p><p><span><span>  float textureY </span><span>=</span><span> uv</span><span>.</span><span>y</span><span> </span><span>*</span><span> uTwistSampleHeight </span><span>-</span><span> uTime </span><span>*</span><span> uTwistSpeed</span><span>;</span><span></span></span></p><p><span><span>  </span><span>...</span></span></p></pre></div></section><!--/$--><h3><span><span>Position</span></span></h3><p><span>Finally, to get the new position for each vertex, we multiple the random value by a strength value (to increase or decrease the amount of twist).
Then modify the x and z values (because we&#39;re twisting around the y-axis).
<code>rotate2D</code> will take these values and a desired angle and return the new, twisted x and z values:</span></p><!--$--><section><div><pre><p><span><span>const</span><span> rotate2D </span><span>=</span><span> </span><span>`</span><span></span></span></p><p><span><span>  vec2 rotate2D(vec2 value, float angle) {</span></span></p><p><span><span>    float s = sin(angle);</span></span></p><p><span><span>    float c = cos(angle);</span></span></p><p><span><span>    mat2 m = mat2(c, s, -s, c);</span></span></p><p><span><span>    return m * value;</span></span></p><p><span><span>  }</span></span></p><p><span><span></span><span>`</span><span>;</span><span></span></span></p><p><span><span></span><span>...</span><span></span></span></p><p><span><span>float angle </span><span>=</span><span> textureValue </span><span>*</span><span> uTwistStrength</span><span>;</span><span></span></span></p><p><span><span>vec3 twistedPosition </span><span>=</span><span> position</span><span>;</span><span></span></span></p><p><span><span>twistedPosition</span><span>.</span><span>xz</span><span> </span><span>=</span><span> </span><span>rotate2D</span><span>(</span><span>twistedPosition</span><span>.</span><span>xz</span><span>,</span><span> angle</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--><h3><span><span>Occulsion</span></span></h3><p><span>Occulsion is the concept of one object blocking another from view.
If object A is closer to the camera than object B, A occludes B — B should not be visible.
By default, three.js enables depth writing to handle occlusion.
However, because our shader is rendering semi-transparent, overlapping fragments, we need to disable this because we want to see through each layer of smoke.
To disable, we set <code>depthWrite: false</code>.</span></p><!--$--><section><div><pre><p><span><span>const</span><span> material </span><span>=</span><span> </span><span>new</span><span> </span><span>THREE</span><span>.</span><span>ShaderMaterial</span><span>(</span><span>{</span><span></span></span></p><p><span><span>  </span><span>depthWrite</span><span>:</span><span> </span><span>false</span><span>,</span><span></span></span></p><p><span><span>  </span><span>...</span><span></span></span></p><p><span><span></span><span>}</span><span>)</span><span>;</span></span></p></pre></div></section><!--/$--></div></section>
<section></section><section><div><h2><span><span><span>Feedback</span></span></span></h2><p><span>Have any feedback about this note or just want to comment on the state of the economy?</span></p></div></section><section><div><div><h2><span><span><span>Where to next?</span></span></span></h2><div><div><svg preserveAspectRatio="none" viewBox="0 0 18 26" style="width:18px;height:100%;flex-shrink:0"><line x1="1" y1="0" x2="1" y2="26"></line></svg><div><div><svg viewBox="0 0 24 24" width="18px" height="18px"><title>Arrow pointing down</title><path d="M12,23.36L2.94,15h5.56V1h7V15h5.56l-9.06,8.36Zm-3.94-6.36l3.94,3.64,3.94-3.64h-2.44V3h-3v14h-2.44Z" vector-effect="non-scaling-stroke"></path></svg><p><span><span><span>YOU ARE HERE</span></span></span></p></div></div></div><p><img alt="A Johnny Cab pilot" loading="lazy" width="240" height="296" decoding="async" data-nimg="1" srcset="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FjohnnyCab.0b8d1185.webp&amp;w=256&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FjohnnyCab.0b8d1185.webp&amp;w=640&amp;q=75 2x" src="https://garden.bradwoods.io/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FjohnnyCab.0b8d1185.webp&amp;w=640&amp;q=75"/></p></div></div></div></section><section></section></div></div>
  </body>
</html>
