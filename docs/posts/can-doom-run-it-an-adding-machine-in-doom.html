<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.otterstack.com/posts/202212-doom-calculator/">Original</a>
    <h1>Can Doom Run It? An Adding Machine in Doom</h1>
    
    <div id="readability-page-1" class="page"><article><h2>Yes.</h2>
<p>For decades, we&#39;ve asked ourselves &#34;Can it run Doom?&#34;. Now we can finally make the ultimate punchline: &#34;Can Doom run it?&#34;</p>
<p>I demonstrate that it is possible to run any bounded computation in Doom, minus constraints on level size. I have not proven that Doom is Turing complete (see the section later in this article).</p>
<p>This works with the vanilla MS-DOS release of Doom 2 (v1.9). No mods or anything!</p>
<p>I love projects like these. I was inspired by the esoteric machines in other games such as <a href="https://www.youtube.com/watch?v=-BP7DhHTU-I" target="_blank" rel="noopener noreferrer nofollow">Minecraft</a> and <a href="https://www.youtube.com/watch?v=RQGa0DPwes0" target="_blank" rel="noopener noreferrer nofollow">RollerCoaster Tycoon</a>.</p>
<h2>Demonstration</h2>
<iframe src="https://www.youtube.com/embed/zZVCU-Z2UpM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
<h2>Source code</h2>
<p>If you&#39;re curious about how this works, I released the source code to build the map here:</p>
<p><a href="https://github.com/nukep/doom-calculator" target="_blank" rel="noopener noreferrer nofollow">https://github.com/nukep/doom-calculator</a></p>
<h2>Related projects</h2>
<p><em>Update (2022-12-23)</em>: I&#39;m reading online comments, and several folks have pointed out other equally impressive attempts that have been made to demonstrate computation in some Vanilla and non-Vanilla engines! I&#39;ll update this list periodically.</p>
<ul>
<li>Game of Life in BOOM: <a href="https://www.doomworld.com/forum/topic/131881-conways-game-of-life-in-boom/" target="_blank" rel="noopener noreferrer nofollow">https://www.doomworld.com/forum/topic/131881-conways-game-of-life-in-boom/</a></li>
<li>Doom in Doom: <a href="https://www.youtube.com/watch?v=c6hnQ1RKhbo" target="_blank" rel="noopener noreferrer nofollow">https://www.youtube.com/watch?v=c6hnQ1RKhbo</a> (technically it&#39;s an arbitrary code execution exploit, but still cool)</li>
<li><a href="https://calabi-yau.space/blog/doom.html" target="_blank" rel="noopener noreferrer nofollow">https://calabi-yau.space/blog/doom.html</a> (Logic gates using lifts in Vanilla Doom. I originally linked to them at the end of the article)</li>
<li>Voodoo script: <a href="https://doomwiki.org/wiki/Voodoo_script" target="_blank" rel="noopener noreferrer nofollow">https://doomwiki.org/wiki/Voodoo_script</a> (mostly BOOM and conveyor belt floors, but with some Vanilla Doom capabilities)</li>
</ul>
<h2>NAND: The universal logic gate</h2>
<p>My first exploration into this topic was to implement a <strong>NAND gate</strong>. If I could implement NAND, I knew I could implement anything.</p>
<p>NAND is a <a href="https://en.wikipedia.org/wiki/Logic_gate#Universal_logic_gates" target="_blank" rel="noopener noreferrer nofollow">universal logic gate</a>. In short, universal logic gates can be composed to create all possible logic gates.</p>
<p><strong>NAND truth table:</strong></p>

<p>e.g. if <strong>a</strong> is True and <strong>b</strong> is True, the result is False.</p>
<p>Specifically, NAND represents two on/off inputs, and one on/off output. If both inputs are on, then the output is off. If any of the inputs are off, then the output is on.</p>
<p>It turns out that from just a measley logic gate, you can combine NAND - you can feed NAND into other NANDs - and you can create any truth table. In effect, all bounded computations are possible.</p>
<p>My process to figuring out if this was workable in Doom was to play around with a Doom level editor - namely, SLADE. I just had to implement <em>one</em> NAND gate. After lots of experimentation with lifts, actions, teleporters, switches, doors, monsters, and even duplicate players, I found a system that was simple and robust.</p>
<h2>Binary Decision Diagrams</h2>
<p>A consequence of my findings was that my system could represent any boolean logic as described in a <strong>binary decision diagram</strong>.</p>
<p>We can represent NAND from earlier using a binary decision diagram.</p>
<p><img src="https://blog.otterstack.com/posts/202212-doom-calculator/bdd-nand.svg" loading="lazy"/></p>
<p>There are two nodes for variables a and b. The dotted lines represent off, or 0. The solid lines represent on, or 1.</p>
<p>If we start at &#34;a&#34; and &#34;a&#34; is 0, then we will go left and arrive at the result of &#34;1&#34; and our work is done.
But, if we start at &#34;a&#34; and &#34;a&#34; is 1, then we go right and we arrive at &#34;b&#34;.
If &#34;b&#34; is 0, then the result is &#34;1&#34;. If &#34;b&#34; is 1, then the result is &#34;0&#34;.</p>
<p>We could decide to chain NANDs together and create even more complex diagrams. But in my case, I decided not to merely chain NANDs together, because this doesn&#39;t create very efficient diagrams. In practice, we&#39;re better off chaining together other logic gates such as AND, OR, XOR, etc - or to directly convert a truth table to a diagram.</p>
<h2>As a Doom level</h2>
<p>Visual of a NAND gate (a=1, b=0):</p>
<p><img src="https://blog.otterstack.com/posts/202212-doom-calculator/doom-level-nand.gif" alt="" loading="lazy"/></p>
<p>Binary decision diagrams can be represented in Doom in a very straight forward manner.</p>
<p>A node becomes a small room, with two doors for 0 and 1. Root nodes have monsters in them.</p>
<p>An edge of a node becomes a teleportation from a teleporter behind a door to another room, if that door is to be opened.</p>
<p>The doors are opened by switches activated by the player. They can also be opened by other monsters (I explain why this is useful later).</p>
<p>I made the decision to represent 0 and 1 with <em>two</em> switches each. At first it might seem more logical to have a single switch for each variable. But I found it easier to be explicit about setting a variable to 0 or 1, and for the calculation to wait until they&#39;re set.</p>
<p>In the final calculator WAD, I <em>do</em> have individual switches for each digit, but this is nothing more than a visual illusion. These are secretly variables where the 0/1 pairs are split into two digits each: (0,1) -&gt; a; (2,3) -&gt; b; (4,5) -&gt; c; (6,7) -&gt; d; (8,9) -&gt; e. E.g. &#34;6&#34; means &#34;d=0&#34;, &#34;7&#34; means &#34;d=1&#34;.</p>
<h2>How do we add numbers with this?</h2>
<p>It can be difficult to imagine how <em>monsters teleporting to places</em> can represent addition. This is one of those problems that&#39;s easier to understand in smaller pieces going bottom-up.</p>
<p>We went from NAND, and then to binary decision diagrams. Next, let&#39;s try adding two <em>binary</em> digits.</p>
<p>There are two binary digits: 0 and 1.</p>
<p><strong>The rules for addition over binary digits are:</strong></p>
<div>







































<table><thead><tr><th>a</th><th>b</th><th>carry</th><th>sum</th><th>in other words</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0 + 0 = 0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0 + 1 = 1</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1 + 0 = 1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>1 + 1 = 0, carry the 1</td></tr></tbody></table></div>
<p>We can also decide to interpret the above rules as a truth table. This is known as a <strong>half-adder</strong>.</p>
<p>A half-adder is equivalent to the logic gates:</p>
<ul>
<li>carry = a and b</li>
<li>sum = a xor b</li>
</ul>
<p>This is great for adding two binary digits... but we want to add bigger numbers!</p>
<p>It&#39;s entirely valid to combine lots of half-adders together to create an adding machine. But in practice it&#39;s more efficient to implement distinct logic to <strong>add 3 bits</strong>: two numbers and a carry bit. This is known as a <strong>full-adder</strong>.</p>
<p>i.e. with three terms such as: &#34;1 + 0 + 1 = 0, carry the 1&#34;.</p>
<p>A full-adder is equivalent to the logic gates:</p>
<ul>
<li>carry = (a and b) or (b and c) or (c and a)</li>
<li>sum = a xor b xor c</li>
</ul>
<p>It&#39;s now possible to chain a half-adder with many full-adders to create an <strong>n-bit-adder</strong> (where n is how many bits we want). It works just like traditional addition: Add two numbers, then carry the 1 over to the left pair of digits, then add those, and so on.</p>
<p><strong>We&#39;re interested in adding numbers from 0 to 9</strong>. How do we represent that? It turns out we need at least 4 binary digits to represent the numbers from 0 to 9 (where 0 = 0000, and 9 = 1001). Therefore, we use a 4-bit-adder.</p>
<p>There&#39;s a major issue however, and it&#39;s that we want to display results in base 10, and not binary or hexadecimal.</p>
<p>We remedy this by conforming the results of a 4-bit binary adder. The resulting logic is known as a <strong>BCD adder</strong> (binary-coded decimal adder).</p>
<p>If the result is greater than 9, then add 6. Apply modulo 8 to it. Finally, set the carry bit.</p>
<p>This way, an operation like &#34;9 + 5 = 14&#34; would yield &#34;1001 + 0101 = 0100, carry the 1&#34;.</p>
<p><strong>BCD adder pseudocode</strong>:</p>
<pre><code>

zc,z3,z2,z1,z0 = cin + (a3,a2,a1,a0) + (b3,b2,b1,b0)


cout = zc <span>or</span> (z3 <span>and</span> z2) <span>or</span> (z3 <span>and</span> z1)


     s0 =       z0
cc1, s1 =       z1 + cout  
cc2, s2 = cc1 + z2 + cout  
_,   s3 = cc2 + z3         
</code></pre>
<p>The resulting (unoptimized) binary decision diagram looks like this (input variables are colored blue, temporary variables are colored yellow):</p>
<p><img src="https://blog.otterstack.com/posts/202212-doom-calculator/bcd-adder_opt.svg" loading="lazy"/></p>
<p><a href="https://blog.otterstack.com/posts/202212-doom-calculator/bcd-adder_opt.svg" target="_blank" rel="noopener noreferrer nofollow">Go here for a full version</a></p>
<p><strong>To recap: The above diagram represents adding two digits from 0 to 9, and getting a 0 to 9 digit with carry.</strong></p>
<p>There are multiple trees to facilitate this. Some will set variables whose sole purpose is to be used in other subsequent trees.</p>
<p>To visualize the above diagram with monsters and teleporters, the top of each tree (the root node) will have a monster in it. All non-root nodes will be destinations for monsters. There are 14 monsters in total, for 14 trees.</p>
<h2>Linking outputs to variables</h2>
<p>In order to compose diagrams from many smaller diagrams, it&#39;s useful to say &#34;this output should be a variable&#34;. You may have noticed that the BCD adder depends on this.</p>
<p>The version of this in a Doom level is &#34;a monster going through a teleporter should open other doors&#34;.</p>
<p>In vanilla Doom, monsters can&#39;t activate switches or remote-open doors. What I&#39;ve decided to do instead, is <strong>exploit a quirk in the Doom engine</strong>. All doors are associated with a <strong>sector</strong>. If a door <strong>shares a sector</strong> with another door, then the two doors will always open and close together. Monsters can&#39;t open remote doors, but they <em>can</em> open local doors. If that local door shares a sector with other doors, then monsters can remotely open doors!</p>
<p>So in place of a final destination, a monster teleports to a room with a single door that they&#39;re forced to keep open. That door shares a sector with one or more other doors that will then be opened.</p>
<p>There are various limitations to this quirk. For example, shared sectors must have the exact same floor and ceiling textures, as well as heights. Fortunately this doesn&#39;t impede functionality, so we&#39;re good with it. Many Doom level editors (such as SLADE) also try to &#34;unshare&#34; sectors if you try to edit distinct polygons, so if you&#39;re editing the map afterwards, it requires caution.</p>
<h2>Digit displays</h2>
<p>I figured that just showing binary values was too boring. I had to drive the point home and go big with showing actual numbers.</p>
<p>The way I approached the digit displays, was to create a truth table for each pixel of the display.</p>
<p>A number from 0 to 9 can be represented with 4 binary digits (0/1). For example, I&#39;ll take the pixel at <strong>row 1 column 2</strong> and show its truth table.
Note that for readability I&#39;m condensing 4 inputs into one column of the table.</p>
<div>








































































<table><thead><tr><th>bits 3210</th><th>out</th></tr></thead><tbody><tr><td>0000 (0)</td><td>1</td></tr><tr><td>0001 (1)</td><td>0</td></tr><tr><td>0010 (2)</td><td>1</td></tr><tr><td>0011 (3)</td><td>1</td></tr><tr><td>0100 (4)</td><td>0</td></tr><tr><td>0101 (5)</td><td>1</td></tr><tr><td>0110 (6)</td><td>1</td></tr><tr><td>0111 (7)</td><td>1</td></tr><tr><td>1000 (8)</td><td>1</td></tr><tr><td>1001 (9)</td><td>1</td></tr><tr><td>1010 (10)</td><td><em>undefined</em></td></tr><tr><td>1011 (11)</td><td><em>undefined</em></td></tr><tr><td>1100 (12)</td><td><em>undefined</em></td></tr><tr><td>1101 (13)</td><td><em>undefined</em></td></tr><tr><td>1110 (14)</td><td><em>undefined</em></td></tr><tr><td>1111 (15)</td><td><em>undefined</em></td></tr></tbody></table></div>
<p>This can be expressed as the following binary decision diagram:</p>
<p><img src="https://blog.otterstack.com/posts/202212-doom-calculator/bdd-digit-ex-1.svg" loading="lazy"/></p>
<p>There are binary values 10 thru 15 that are <em>undefined</em>, because we&#39;re not expected to encounter them. The algorithm I wrote to generate the diagram will assign arbitrary outputs for 10 thru 15, depending on which optimizes the diagram more. (in practice, for digits, &#34;bit 3=1&#34; just refers to 8 and 9. if 8 and 9 have the same result, we know the result for &#34;bit 3=1&#34;)</p>
<h2>Generating the level with code</h2>
<p>I didn&#39;t make the adding machine in a level editor. Doing it all manually would be extremely tedious and error-prone. So I wrote code!</p>
<p>The code to generate the WAD file is written in the programming language <strong>Clojure</strong>.</p>
<p>Lisp abides by the code-is-data philosophy, so it&#39;s quite intuitive to write tree structures as code.</p>
<p>We can represent the NAND gate from earlier using Lisp syntax.</p>
<pre><code>
(<span>a</span> <span>1</span>
   (<span>b</span> <span>1</span>
      <span>0</span>))
</code></pre>
<p>This is a tree data structure. It&#39;s composed of nested lists in the form of <code>(variable on-0 on-1)</code>.</p>
<p>We can also visualize this as a sideways tree that reads left-to-right:</p>
<p><img src="https://blog.otterstack.com/posts/202212-doom-calculator/nand-lisp.svg" loading="lazy"/></p>
<p>But the <strong>really really cool part</strong>, is that this works doubly as code. If a and b are functions that return the left or right form, you can actually execute this and get a result!</p>
<pre><code>
(<span>defn</span> <span>a</span> [left right] right)

(<span>defn</span> <span>b</span> [left right] left)

(<span>a</span> <span>1</span>
   (<span>b</span> <span>1</span>
      <span>0</span>))

</code></pre>
<p>We can implement more complex logic in a very succinct syntax:</p>
<pre><code>


(<span>cin</span> (<span>a</span> (<span>b</span> <span>0</span> <span>1</span>)
        (<span>b</span> <span>1</span> <span>0</span>))
     (<span>a</span> (<span>b</span> <span>1</span> <span>0</span>)
        (<span>b</span> <span>0</span> <span>1</span>)))


(<span>cin</span> (<span>a</span> <span>0</span>
        (<span>b</span> <span>0</span> <span>1</span>))
     (<span>a</span> (<span>b</span> <span>0</span> <span>1</span>)
        <span>1</span>))
</code></pre>
<p>The implementation of those functions depends on what you&#39;re trying to do. In my case for generating levels, all functions for variables emit an adjacency list for a graph, where the nodes are identified by auto-incrementing numbers.</p>
<p>Many binary decision diagrams are not trees, however, but graphs. Nodes in a binary decision diagram can have more than one parent. How do we express graphs?</p>
<p>This is actually a deceptively easy problem to solve. If we assert that all trees are immutable mathematical values, then we can say whether or not two trees are equivalent. Equivalent trees are deduplicated, effectively creating graphs in memory.</p>
<h2>Optimizing trees</h2>
<p>I use a variety of techniques to optimize trees:</p>
<ol>
<li>If a tree &#34;a&#34; points to trees &#34;b&#34; and &#34;c&#34; and b = c, then a = b = c</li>
<li>If a variable &#34;v&#34; is only used once anywhere, is in a root tree &#34;a&#34; and the tree points to trees &#34;b&#34; and &#34;c&#34;, then v.0 = b and v.1 = c</li>
<li>Remove all trees that don&#39;t eventually contribute to outputs (where monsters would show up).</li>
</ol>
<p>Optimization 3 was one I chose to implement using adjacency matrices. Where K is an adjacency matrix of trees to trees, I compute K^0 + K^1 + K^2 + ..., which gives us a final result of all reachable trees. The code for it is here: <a href="https://github.com/nukep/doom-calculator/blob/e3dd9c0c6de19830febd0d1f845befca70ad632d/src/doomcalc/tree.clj#L217" target="_blank" rel="noopener noreferrer nofollow">https://github.com/nukep/doom-calculator/blob/e3dd9c0c6de19830febd0d1f845befca70ad632d/src/doomcalc/tree.clj#L217</a></p>
<h2>Drawing the level</h2>
<p>Doom&#39;s level format is WAD. WAD officially stands for &#34;Where&#39;s All the Data?&#34; according to Tom Hall&#39;s &#34;Doom Bible&#34;.</p>
<p>Despite the game being 3D, Doom maps exist on a flat 2D cartesian plane. Height is achieved by defining variable floor and ceiling heights for polygonal shapes in the map (Doom calls these shapes &#34;sectors&#34;).</p>
<p>WAD is fortunately a very simple file format, so I was able to implement a WAD writer from scratch.</p>
<p>Because the levels are represented in 2D, routines to draw the level are similar to drawing vector graphics overall. E.g. &#34;draw line from a to b&#34;.</p>
<h2>Overcoming vanilla Doom quirks</h2>
<p>I noticed that monsters opening doors worked in GZDoom, but it <em>sometimes</em> didn&#39;t work in Chocolate Doom or the vanilla MS-DOS Doom.</p>
<p>To figure out why, I did what any sensibly sane person would do: Look at the Doom source code. (everything else I&#39;ve done has clearly been sane up to this point)</p>
<p>The official source code release for Doom from id Software can be found here: <a href="https://github.com/id-Software/DOOM" target="_blank" rel="noopener noreferrer nofollow">https://github.com/id-Software/DOOM</a></p>
<p>I Ctrl+F&#39;s some keywords such as &#34;open&#34; and &#34;door&#34;, and eventually stumbled across the code where monsters try to open doors on their own.</p>
<p>I started from the <code>P_Move()</code> function here: <a href="https://github.com/id-Software/DOOM/blob/77735c3ff0772609e9c8d29e3ce2ab42ff54d20b/linuxdoom-1.10/p_enemy.c#L272" target="_blank" rel="noopener noreferrer nofollow">https://github.com/id-Software/DOOM/blob/77735c3ff0772609e9c8d29e3ce2ab42ff54d20b/linuxdoom-1.10/p_enemy.c#L272</a></p>
<p>The procedure for monsters opening doors is the following, as pseudocode.
I left out a lot of ireelevant details.</p>
<pre><code>
<span>def</span> <span>P_Move</span>(<span>actor</span>):
    
    try_position = actor.position + actor.speed*actor.direction

    actor_moved = <span>False</span>

    
    spechit = []
    <span>for</span> each line within the actor radius <span>from</span> try_position:
        
        
        
        <span>if</span> line has no back face: <span>break</span>
        <span>if</span> line blocks players <span>or</span> monsters: <span>break</span>
        <span>if</span> line has a special action: spechit.push(line)

    <span>if</span> loop did <span>not</span> <span>break</span>:
    <span>if</span> new floor <span>is</span> within <span>24</span> units (<span>not</span> too high <span>or</span> low):
    <span>if</span> actor can fit <span>in</span> the room:
        move the actor to try_position
        actor_moved = <span>True</span>
        <span>for</span> each line <span>in</span> spechit, <span>in</span> reverse order:
            <span>if</span> actor walks over line: trigger line
        spechit = []

    <span>if</span> <span>not</span> actor_moved:
        <span>for</span> each line <span>in</span> spechit, <span>in</span> reverse order:
            use line
        spechit = []
</code></pre>
<p>These were the most important findings:</p>
<ul>
<li>The game searches for all special lines within the monster&#39;s radius, from where the monster is <em>trying</em> to go (not where it is).</li>
<li>There&#39;s a global array that&#39;s appended with special lines &#34;spechit&#34;. Up to 8 can be stored, but the game doesn&#39;t stop at 8 (possible buffer overflow).</li>
<li>Blockmaps are searched in column-major order (bottom-up, then left-right)</li>
<li>The iteration routine quits early if any line in reach of the monster has the &#34;block players&#34; or &#34;block players and monsters&#34; flag enabled.</li>
<li>It also quits early if it finds a wall with no back face (such as the outer edge of the map).</li>
</ul>
<p>To allow monsters to open door, we follow some <strong>rule-of-thumb restrictions</strong>:</p>
<ul>
<li>No lines with &#34;block players/monsters&#34; flags within monster radius+speed (for Pinky: 30.0 + 10.0 = 40.0 units)</li>
<li>No one-sided lines (such as the map perimeter) within monster radius+speed (40.0 units)</li>
<li>Keep any doors you don&#39;t want opened by a monster beyond monster radius+speed  (40.0 units)</li>
</ul>
<h2>Interactive Demo: Digit displays</h2>
<p><strong>Press one of the buttons below to simulate the digit display.</strong></p>
<p>This is true to what happens in the Doom map.</p>

</article></div>
  </body>
</html>
