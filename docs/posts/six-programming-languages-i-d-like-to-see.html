<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.email/hillelwayne/archive/six-programming-languages-id-like-to-see/">Original</a>
    <h1>Six programming languages I’d like to see</h1>
    
    <div id="readability-page-1" class="page"><div>
                
                    
                        <p>I got 1,000 words into “what, exactly, is software complexity” before remembering that this is supposed to be <em>less</em> effort than the blog. So instead I’m going to list some ideas I had for programming languages. I <em>think</em> all of these are technically doable, so it’s more a “nobody else wants this badly enough” thing. Also caveat these might all already exist; I just know the languages I know!</p>
<h3>A serious take on a contract-based language</h3>
<p>Contracts are predicates on the code, usually attached to functions and treated like assertion statements. The canonical example is withdrawing from a bank account:</p>
<div><pre><span></span><code>method withdraw(amnt: int)
requires amnt &lt;= self.balance
ensures self.balance &gt;= 0
{
  self.balance -= amnt;
}
</code></pre></div>

<p>The standard bearer for contracts <em>used</em> to be Eiffel, which people stopped caring about in the mid-90’s. Nowadays the only mainstream language to get serious about contracts is Clojure. Most languages have a contracts <em>library</em>, which mean the language doesn’t have affordances to use contracts well. Take the predicate <code>is_sorted(l)</code>:</p>
<div><pre><span></span><code>forall i, j in 0..len(l):
  i &lt; j =&gt; l[i] &lt;= l[j]
</code></pre></div>

<p>Most languages have <code>all</code> and <code>any</code> functions but they don’t allow quantifying over multiple elements, and basically no languages have an implication operator (because it’s near-useless for programming). I want to see a language integrate contracts into the syntax well. At the very least, dedicated syntax for preconditions, postconditions, and inline assertions. Also the ability to label and reuse predicates, and “orthogonal” contracts (postcondition A is only checked if precondition A’ was true). Stuff like that. </p>
<p>And tool integration! One of the coolest things Eiffel <em>sorta</em> did was use contracts to infer tests. If you have contracts, you can use a fuzzer to get integration tests for free. Clojure’s Spec does something kinda similar, I think.</p>
<h3>A language with semantic relations</h3>
<p>Inheritance and interfaces are relationships between classes. But what about relationships between <em>functions</em>? Take the following two functions:</p>
<div><pre><span></span><code><span>def</span> <span>window1</span><span>(</span><span>l</span><span>,</span> <span>n</span><span>):</span>
    <span>if</span> <span>len</span><span>(</span><span>l</span><span>)</span> <span>&lt;</span> <span>n</span><span>:</span>
        <span>return</span> <span>[]</span>
    <span>out</span> <span>=</span> <span>[]</span>
    <span>for</span> <span>intervals</span> <span>in</span> <span>range</span><span>(</span><span>len</span><span>(</span><span>l</span><span>)</span> <span>-</span> <span>(</span><span>n</span> <span>-</span> <span>1</span><span>)):</span>
        <span>window</span> <span>=</span> <span>l</span><span>[</span><span>intervals</span><span>:(</span><span>intervals</span><span>+</span><span>n</span><span>)]</span>
        <span>out</span><span>.</span><span>append</span><span>(</span><span>prod</span><span>(</span><span>window</span><span>))</span>
    <span>return</span> <span>out</span>

<span>def</span> <span>window2</span><span>(</span><span>l</span><span>,</span> <span>n</span><span>):</span>
    <span>if</span> <span>len</span><span>(</span><span>l</span><span>)</span> <span>&lt;</span> <span>n</span><span>:</span>
        <span>return</span> <span>[]</span>
    <span>out</span> <span>=</span> <span>[]</span>
    <span>val</span> <span>=</span> <span>prod</span><span>(</span><span>l</span><span>[</span><span>0</span><span>:</span><span>n</span><span>])</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>n</span><span>,</span> <span>len</span><span>(</span><span>l</span><span>)):</span>
        <span>out</span><span>.</span><span>append</span><span>(</span><span>val</span><span>)</span>
        <span>val</span> <span>*=</span> <span>(</span><span>l</span><span>[</span><span>i</span><span>]</span> <span>/</span> <span>l</span><span>[</span><span>i</span><span>-</span><span>n</span><span>])</span>
    <span>out</span><span>.</span><span>append</span><span>(</span><span>val</span><span>)</span>
    <span>return</span> <span>out</span>
</code></pre></div>

<p>These take the rolling products of a list <code>l</code>, so <code>window1([1, 2, 3, 4, 5], 2) == [2, 6, 12, 20]</code>. <code>window2</code> is an <em>optimized</em> version of <code>window1</code> and should have the same outputs for every input. I should be able to encode that in the language, and have the tooling generate checks showing the two are the same, and also run benchmarks testing if the optimized version actually is faster.</p>
<p>I can think of other relationships between stuff. <code>A&#39;</code> is an <em>instrumented</em> version of class A. <code>g</code> is an inverse of f such that <code>f(g(x)) == x</code>. <code>P&#39;</code> is an <em>ontological</em> subtype of <code>P</code> but not a <em>Liskov</em> subtype. UML had things like “traces” and “refines” and “generalizes”, there could be things there too. The point is I want to be able to express semantic relationships at the language level in a way that the program can leverage.</p>
<p>Would go nicely with contracts, too, as you could have relationships that preserve/transform/expand contracts. The usual one is that “inherited methods have less restrictive preconditions and more restrictive postconditions.” What else could we do?</p>
<h3>Everything is a Graph</h3>
<ul>
<li>Lisp: everything’s a list</li>
<li>Bash: everything’s a string</li>
<li>Smalltalk: everything’s an object</li>
<li>APL: everything’s an array</li>
</ul>
<p>Graphs are really common data structures but there hasn’t yet been an “everything’s a graph” language. In fact, almost no languages even have graphs <em>in their standard library</em>! I think that’s because graphs are an extremely complicated data structure. You know how annoying linked lists are? Graphs are 1000x worse.</p>
<p>Nonetheless, I wanna see someone try! Give me a language where key-value maps are emulated with directed bipartite graphs.</p>
<h3>A better calculator language</h3>
<p>I have a <a href="https://www.hillelwayne.com/post/j-notation/" target="_blank">love</a>/<a href="https://buttondown.email/hillelwayne/archive/the-jame-of-life/" target="_blank">hate</a> relationship with J. There’s so much about the language that drives me batty, but I stick with it because it’s the only language that gets remotely <em>close</em> to being a good desktop calculator. When doing quick computations for work projects, I care about two things. The first is the number of keystrokes. Here’s how to get the product of factorials of a list in python:<sup id="fnref:prod-factorials"><a href="#fn:prod-factorials">1</a></sup></p>
<div><pre><span></span><code><span>import</span> <span>math</span>
<span>prod</span><span>([</span><span>math</span><span>.</span><span>factorial</span><span>(</span><span>x</span><span>)</span> <span>for</span> <span>x</span> <span>in</span> <span>l</span><span>])</span>
</code></pre></div>

<p>No! Bad python! In J it’s just <code>*/ ! l</code>, quite literally an order of magnitude fewer keystrokes. When I’m trying out lots of different equations, keystokes matter a <em>lot</em>. J is very much “everything is an array”, though, which limits its potential as a calculator. You can’t work with strings, json, sets, or hash maps very well, date manipulation is terrible, you can barely do combinatorics problems, etc etc etc. I want a language that’s terse for everything. Maybe you could namespace operators.</p>
<p>The other feature I want for a calculator is built-in reactive programming, like an unholy combination of a textual programming language and Excel. I want to be able to do something sorta like this:</p>
<div><pre><span></span><code>input = 1

out1: input + 1
#out1 is now 2

input = 4
#out1 is now 5

out2: out1.replace(+, -)
#out2 is now 3

# let&#39;s pull an APL
input = 4 2
#out1 is 5 3
#out2 is 3 1
</code></pre></div>

<p>This would be absolutely hell to learn at first, but I’ve learned plenty of weird languages that promised a lot of power. Interactive computation is a common enough activity for me that I’d put a <em>lot</em> of time into learning something like this.</p>
<p>…Maybe I should just get real good with Excel.</p>
<h3>A <em>really</em> dynamically-typed language</h3>
<p>(Someone’s gonna tell me this is 100% smalltalk for sure)</p>
<p>Static types are great! There’s lots of cool stuff being done with static typed languages right now. Not so much with dynamic types, though. Most of the research and interest is in adding gradual typing to dynamic languages. I think there’s a lot of interesting experiments we can do with dynamic types. I mean, you can <em>generate new types at runtime</em>! Combine that with contracts and we can attach constraints to variables, like this: </p>
<div><pre><span></span><code>type Interval(x, y) &lt;: Int {
  x &lt;= self &lt;= y; 
}

var i: Interval(1, 10) = 3
i += 7 #ok
i += 1 #error!
</code></pre></div>

<p>How cool is that?! Now I don’t know how <em>useful</em> this would be (maybe it’s just syntactic sugar over classes), but it’s still <em>interesting</em> to me. I want to see what people do with it.</p>
<p>I also like the idea of modifying function definitions at runtime. I have these visions/nightmares of programs that take other programs as input and then let me run experiments on how the program behaves under certain changes to the source code. I want to write <em>metaprograms dammit</em></p>
<h3>A language designed around having first-class GUI support</h3>
<p>I miss VB6.</p>

                    
                
            </div></div>
  </body>
</html>
