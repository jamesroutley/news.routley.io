<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html">Original</a>
    <h1>Rust 1.65.0</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>The Rust team is happy to announce a new version of Rust, 1.65.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.</p>
<hr/>
<p>Before going into the details of the new Rust release, we&#39;d like to draw
attention to the tragic <a href="https://en.wikipedia.org/wiki/Death_of_Mahsa_Amini">death of Mahsa
Amini</a> and the death and
violent suppression of many others, by the religious morality police of Iran.
See <a href="https://en.wikipedia.org/wiki/Mahsa_Amini_protests">https://en.wikipedia.org/wiki/Mahsa_Amini_protests</a> for more details. We
stand in solidarity with the people in Iran struggling for human rights.</p>
<hr/>
<p>If you have a previous version of Rust installed via rustup, you can get 1.65.0
with:</p>
<pre><code>rustup update stable
</code></pre>
<p>If you don&#39;t have it already, you can <a href="https://www.rust-lang.org/install.html">get
<code>rustup</code></a> from the appropriate page on
our website, and check out the <a href="https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03">detailed release notes for
1.65.0</a>
on GitHub.</p>
<p>If you&#39;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (<code>rustup default beta</code>) or the nightly
channel (<code>rustup default nightly</code>). Please
<a href="https://github.com/rust-lang/rust/issues/new/choose">report</a> any bugs you
might come across!</p>
<h2><a href="#whats-in-1650-stable" aria-hidden="true" id="whats-in-1650-stable"></a>What&#39;s in 1.65.0 stable</h2>
<h3><a href="#generic-associated-types-gats" aria-hidden="true" id="generic-associated-types-gats"></a>Generic associated types (GATs)</h3>
<p>Lifetime, type, and const generics can now be defined on associated types, like so:</p>
<pre><code>trait Foo {
    type Bar&lt;&#39;x&gt;;
}
</code></pre>
<p>It&#39;s hard to put into few words just how useful these can be, so here are a
few example traits, to get a sense of their power:</p>
<pre><code>/// An `Iterator`-like trait that can borrow from `Self`
trait LendingIterator {
    type Item&lt;&#39;a&gt; where Self: &#39;a;

    fn next&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; Option&lt;Self::Item&lt;&#39;a&gt;&gt;;
}

/// Can be implemented over smart pointers, like `Rc` or `Arc`,
/// in order to allow being generic over the pointer type
trait PointerFamily {
    type Pointer&lt;T&gt;: Deref&lt;Target = T&gt;;

    fn new&lt;T&gt;(value: T) -&gt; Self::Pointer&lt;T&gt;;
}

/// Allows borrowing an array of items. Useful for
/// `NdArray`-like types that don&#39;t necessarily store
/// data contiguously.
trait BorrowArray&lt;T&gt; {
    type Array&lt;&#39;x, const N: usize&gt; where Self: &#39;x;

    fn borrow_array&lt;&#39;a, const N: usize&gt;(&amp;&#39;a self) -&gt; Self::Array&lt;&#39;a, N&gt;;
}
</code></pre>
<p>As you can see, GATs are quite versatile and enable a number
of patterns that are not currently able to be written. For more
information, check out the post announcing the
<a href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">push for stabilization</a>
published last year or the
<a href="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html">stabilization announcement post</a>
published last week. The former goes into a bit more depth
of a couple of the examples above, while the latter talks
about some of the known limitations of this stabilization.</p>
<p>More in depth reading can be found in the associated types
section of the <a href="https://doc.rust-lang.org/nightly/reference/items/associated-items.html#associated-types">nightly reference</a>
or the <a href="https://rust-lang.github.io/rfcs/1598-generic_associated_types.html">original RFC</a> (which was initially opened over 6.5 years ago!).</p>
<h3><a href="#let-else-statements" aria-hidden="true" id="let-else-statements"></a><code>let</code>-<code>else</code> statements</h3>
<p>This introduces a new type of <code>let</code> statement with a refutable pattern and a
diverging <code>else</code> block that executes when that pattern doesn&#39;t match.</p>
<pre><code>let PATTERN: TYPE = EXPRESSION else {
    DIVERGING_CODE;
};
</code></pre>
<p>Normal <code>let</code> statements can only use <em>irrefutable</em> patterns, statically known
to always match. That pattern is often just a single variable binding, but may
also unpack compound types like structs, tuples, and arrays. However, that was
not usable for conditional matches, like pulling out a variant of an enum --
until now! With <code>let</code>-<code>else</code>, a refutable pattern can match and bind variables
in the surrounding scope like a normal <code>let</code>, or else diverge (e.g. <code>break</code>,
<code>return</code>, <code>panic!</code>) when the pattern doesn&#39;t match.</p>
<pre><code>fn get_count_item(s: &amp;str) -&gt; (u64, &amp;str) {
    let mut it = s.split(&#39; &#39;);
    let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
        panic!(&#34;Can&#39;t segment count item pair: &#39;{s}&#39;&#34;);
    };
    let Ok(count) = u64::from_str(count_str) else {
        panic!(&#34;Can&#39;t parse integer: &#39;{count_str}&#39;&#34;);
    };
    (count, item)
}
assert_eq!(get_count_item(&#34;3 chairs&#34;), (3, &#34;chairs&#34;));
</code></pre>
<p>The scope of name bindings is the main thing that makes this different from
<code>match</code> or <code>if let</code>-<code>else</code> expressions. You could previously approximate these
patterns with an unfortunate bit of repetition and an outer <code>let</code>:</p>
<pre><code>    let (count_str, item) = match (it.next(), it.next()) {
        (Some(count_str), Some(item)) =&gt; (count_str, item),
        _ =&gt; panic!(&#34;Can&#39;t segment count item pair: &#39;{s}&#39;&#34;),
    };
    let count = if let Ok(count) = u64::from_str(count_str) {
        count
    } else {
        panic!(&#34;Can&#39;t parse integer: &#39;{count_str}&#39;&#34;);
    };
</code></pre>
<h3><a href="#break-from-labeled-blocks" aria-hidden="true" id="break-from-labeled-blocks"></a><code>break</code> from labeled blocks</h3>
<p>Plain block expressions can now be labeled as a <code>break</code> target, terminating
that block early. This may sound a little like a <code>goto</code> statement, but it&#39;s not
an arbitrary jump, only from within a block to its end. This was already
possible with <code>loop</code> blocks, and you may have seen people write loops that
always execute only once, just to get a labeled <code>break</code>.</p>
<p>Now there&#39;s a language feature specifically for that! Labeled <code>break</code> may also
include an expression value, just as with loops, letting a multi-statement
block have an early &#34;return&#34; value.</p>
<pre><code>let result = &#39;block: {
    do_thing();
    if condition_not_met() {
        break &#39;block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break &#39;block 2;
    }
    do_last_thing();
    3
};
</code></pre>
<h3><a href="#splitting-linux-debuginfo" aria-hidden="true" id="splitting-linux-debuginfo"></a>Splitting Linux debuginfo</h3>
<p>Back in Rust 1.51, the compiler team added support for <a href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#splitting-debug-information">split debug
information</a>
on macOS, and now this option is stable for use on Linux as well.</p>
<ul>
<li><code>-Csplit-debuginfo=unpacked</code> will split debuginfo out into multiple <code>.dwo</code>
DWARF object files.</li>
<li><code>-Csplit-debuginfo=packed</code> will produce a single <code>.dwp</code> DWARF package
alongside your output binary with all the debuginfo packaged together.</li>
<li><code>-Csplit-debuginfo=off</code> is still the default behavior, which includes DWARF
data in <code>.debug_*</code> ELF sections of the objects and final binary.</li>
</ul>
<p>Split DWARF lets the linker avoid processing the debuginfo (because it isn&#39;t in
the object files being linked anymore), which can speed up link times!</p>
<p>Other targets now also accept <code>-Csplit-debuginfo</code> as a stable option with their
platform-specific default value, but specifying other values is still unstable.</p>
<h3><a href="#stabilized-apis" aria-hidden="true" id="stabilized-apis"></a>Stabilized APIs</h3>
<p>The following methods and trait implementations are now stabilized:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/backtrace/struct.Backtrace.html"><code>std::backtrace::Backtrace</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.as_ref"><code>Bound::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/io/fn.read_to_string.html"><code>std::io::read_to_string</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_mut"><code>&lt;*const T&gt;::cast_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_const"><code>&lt;*mut T&gt;::cast_const</code></a></li>
</ul>
<p>Of particular note, the <code>Backtrace</code> API allows capturing a stack backtrace at
any time, using the same platform-specific implementation that usually serves
panic backtraces. This may be useful for adding runtime context to error types,
for example.</p>
<p>These APIs are now usable in const contexts:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from"><code>&lt;*const T&gt;::offset_from</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from"><code>&lt;*mut T&gt;::offset_from</code></a></li>
</ul>
<h3><a href="#compatibility-notes" aria-hidden="true" id="compatibility-notes"></a>Compatibility notes</h3>
<ul>
<li>As the final step of the <a href="https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html">RLS
deprecation</a>,
this release has replaced RLS with a small LSP server showing a deprecation
warning, advising users to migrate to <code>rust-analyzer</code>.</li>
</ul>
<h3><a href="#other-changes" aria-hidden="true" id="other-changes"></a>Other changes</h3>
<p>There are other changes in the Rust 1.65 release, including:</p>
<ul>
<li>MIR inlining is now enabled for optimized compilations. This provides a 3-10%
improvement in compiletimes for real world crates.</li>
<li>When scheduling builds, Cargo now sorts the queue of pending jobs to improve performance.</li>
</ul>
<p>Check out everything that changed in
<a href="https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03">Rust</a>,
<a href="https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-165-2022-11-03">Cargo</a>,
and <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-165">Clippy</a>.</p>
<h3><a href="#contributors-to-1650" aria-hidden="true" id="contributors-to-1650"></a>Contributors to 1.65.0</h3>
<p>Many people came together to create Rust 1.65.0.
We couldn&#39;t have done it without all of you.
<a href="https://thanks.rust-lang.org/rust/1.65.0/">Thanks!</a></p>

    </div></div>
  </body>
</html>
