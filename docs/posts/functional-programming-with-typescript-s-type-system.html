<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://desislav.dev/blog/tsfp/">Original</a>
    <h1>Functional Programming with TypeScript&#39;s Type System</h1>
    
    <div id="readability-page-1" class="page"><div>
      

<p>It has been shown multiple times that TypeScript&#39;s Type System is Turing Complete. In this blog post, we will explore some basic concepts for writing general-purpose functional programs entirely at the type-level.</p>
<h2 id="function-definition-and-application">Function Definition and Application</h2>

<p>The most basic components of functional programming are functions and function application. We will define a type <code>F</code>, which represents a function with an input argument <code>args</code> and an output <code>out</code> and define a type <code>apply</code> which takes a function extending <code>F</code> and a tuple of arguments <code>args</code> and computes the output of the function.</p>
<pre data-role="codeBlock" data-info="typescript"><span>interface</span> <span><span>F</span></span> <span>{</span> args<span>:</span> <span>unknown</span><span>;</span> out<span>:</span> <span>unknown</span><span>;</span> <span>}</span>
<span>type</span> <span>apply<span>&lt;</span>f <span>extends</span> <span>F</span><span>,</span> args<span>&gt;</span></span> <span>=</span> <span>(</span>f <span>&amp;</span> <span>{</span> <span>&#39;args&#39;</span><span>:</span> args <span>}</span><span>)</span><span>[</span><span>&#39;out&#39;</span><span>]</span>
</pre><p>This very simple yet powerful trick allows to dinamically override the arguments of functions with new ones passed to apply and exploit type-inference to compute the output. To define a new function, we can simply extend the <code>F</code> interface and override the output type by manipulating the <code>args</code> through conditional type inference.</p>


<p>For instance, let&#39;s define the natural numbers through Peano&#39;s representation and implement some basic arithmetic operations.</p>
<p>A natural number can be defined as either zero or a successor of another natural number:</p>
<pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>Zero</span>   <span>=</span> <span>{</span> kind<span>:</span> <span>&#34;zero&#34;</span> <span>}</span>
<span>type</span> <span>Suc<span>&lt;</span>n<span>&gt;</span></span> <span>=</span> <span>{</span> kind<span>:</span> <span>&#34;suc&#34;</span><span>,</span> n<span>:</span> n <span>}</span>
</pre><p>For instance, we can define <code>1</code> as <code>Suc&lt;Zero&gt;</code>, <code>2</code> as <code>Suc&lt;Suc&lt;Zero&gt;&gt;</code>, and so on.</p>
<p>Now we can define our first function, the addition:</p>
<pre data-role="codeBlock" data-info="typescript"><span>interface</span> <span>add</span> <span>extends</span> <span><span>F</span></span> <span>{</span> out<span>:</span> <span>this</span><span>[</span><span>&#39;args&#39;</span><span>]</span> <span>extends</span>

  <span>[</span><span>infer</span> a<span>,</span> <span>infer</span> b<span>]</span>     <span>?</span>
  a <span>extends</span> <span>Zero</span>         <span>?</span> b <span>:</span>
  a <span>extends</span> <span>Suc<span>&lt;</span><span>infer</span> n<span>&gt;</span></span> <span>?</span> Suc<span>&lt;</span>apply<span>&lt;</span>add<span>,</span> <span>[</span>n<span>,</span> b<span>]</span><span>&gt;&gt;</span> <span>:</span> 

  <span>never</span> <span>:</span> <span>never</span>
<span>}</span>
</pre><p>The function is defined by extending the generic function interface <code>F</code> and overriding the output type. In fact, <code>out</code> is defined as a conditional type based on the <code>args</code> tuple on which we can apply type inference to simulate pattern matching. In this case, we match on the parameter <code>a</code> and check wheter it is zero or a successor of another natural number. In case of zero, we simply return <code>b</code>, otherwise compute the result through recursive application.</p>
<p>Now we can use <code>apply</code> to actually compute addition on different parameters:</p>
<pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>x0</span> <span>=</span> apply<span>&lt;</span>add<span>,</span> <span>[</span>Zero<span>,</span> Zero<span>]</span><span>&gt;</span> 
<span>type</span> <span>x1</span> <span>=</span> apply<span>&lt;</span>add<span>,</span> <span>[</span>Suc<span>&lt;</span>Zero<span>&gt;</span><span>,</span> Zero<span>]</span><span>&gt;</span> 
<span>type</span> <span>x2</span> <span>=</span> apply<span>&lt;</span>add<span>,</span> <span>[</span>Suc<span>&lt;</span>Zero<span>&gt;</span><span>,</span> Suc<span>&lt;</span>Zero<span>&gt;</span><span>]</span><span>&gt;</span> 
<span>type</span> <span>x3</span> <span>=</span> apply<span>&lt;</span>add<span>,</span> <span>[</span>Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;</span><span>,</span> Suc<span>&lt;</span>Zero<span>&gt;</span><span>]</span><span>&gt;</span> 
</pre><p>Similarly, we define multiplication:</p>
<pre data-role="codeBlock" data-info="typescript"><span>interface</span> <span>mul</span> <span>extends</span> <span><span>F</span></span> <span>{</span> out<span>:</span> <span>this</span><span>[</span><span>&#39;args&#39;</span><span>]</span> <span>extends</span>

  <span>[</span><span>infer</span> a<span>,</span> <span>infer</span> b<span>]</span>     <span>?</span>
  a <span>extends</span> <span>Zero</span>         <span>?</span> Zero <span>:</span>
  a <span>extends</span> <span>Suc<span>&lt;</span><span>infer</span> n<span>&gt;</span></span> <span>?</span> apply<span>&lt;</span>add<span>,</span> <span>[</span>apply<span>&lt;</span>mul<span>,</span> <span>[</span>n<span>,</span> b<span>]</span><span>&gt;</span><span>,</span> b<span>]</span><span>&gt;</span> <span>:</span> 
  
  <span>never</span> <span>:</span> <span>never</span>
<span>}</span>
</pre><pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>y0</span> <span>=</span> apply<span>&lt;</span>mul<span>,</span> <span>[</span>Zero<span>,</span> Zero<span>]</span><span>&gt;</span> 
<span>type</span> <span>y1</span> <span>=</span> apply<span>&lt;</span>mul<span>,</span> <span>[</span>Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;</span><span>,</span> Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;</span><span>]</span><span>&gt;</span> 
       
</pre>

<p>We can also define higher-order functions in a very elegant way. For instance, let&#39;s define the <code>map</code> function that applies a given function <code>f</code> to each element of a list <code>args</code>.</p>
<pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>map<span>&lt;</span>f <span>extends</span> <span>F</span><span>,</span> args <span>extends</span> <span>unknown</span><span>[</span><span>]</span><span>&gt;</span></span> <span>=</span>
  args <span>extends</span> <span>[</span><span>]</span>                     <span>?</span> args <span>:</span>
  args <span>extends</span> <span>[</span><span>infer</span> x<span>,</span> <span>...</span><span>infer</span> xs<span>]</span> <span>?</span> <span>[</span>apply<span>&lt;</span>f<span>,</span> <span>[</span>x<span>]</span><span>&gt;</span><span>,</span> <span>...</span>map<span>&lt;</span>f<span>,</span> xs<span>&gt;</span><span>]</span> <span>:</span>
  <span>never</span><span>;</span>
</pre><p>For example, we can define a function that doubles a number and map a list of numbers to a list of the doubled numbers.</p>
<pre data-role="codeBlock" data-info="typescript"><span>interface</span> <span>double</span> <span>extends</span> <span><span>F</span></span> <span>{</span> out<span>:</span> <span>this</span><span>[</span><span>&#39;args&#39;</span><span>]</span> <span>extends</span> 
  <span>[</span><span>infer</span> a<span>]</span>                       <span>?</span> 
  apply<span>&lt;</span>mul<span>,</span> <span>[</span>a<span>,</span> Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;</span><span>]</span><span>&gt;</span> <span>:</span> 
  <span>never</span>
<span>}</span>
<span>type</span> <span>xs</span> <span>=</span> map<span>&lt;</span>double<span>,</span> <span>[</span>Zero<span>,</span> Suc<span>&lt;</span>Zero<span>&gt;</span><span>,</span> Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;</span><span>]</span><span>&gt;</span> 
       
</pre><p>Similarly, we can define the <code>fold</code> function as follows:</p>
<pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>fold<span>&lt;</span>f <span>extends</span> <span>F</span><span>,</span> b <span>extends</span> <span>unknown</span><span>,</span> args <span>extends</span> <span>unknown</span><span>[</span><span>]</span><span>&gt;</span></span> <span>=</span>
  args <span>extends</span> <span>[</span><span>]</span>                     <span>?</span> b <span>:</span>
  args <span>extends</span> <span>[</span><span>infer</span> x<span>,</span> <span>...</span><span>infer</span> xs<span>]</span> <span>?</span> fold<span>&lt;</span>f<span>,</span> apply<span>&lt;</span>f<span>,</span> <span>[</span>b<span>,</span> x<span>]</span><span>&gt;</span><span>,</span> xs<span>&gt;</span> <span>:</span> 
  <span>never</span>
</pre><p>For instance, we can use fold function to sum the elements of a list:</p>
<pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>r</span> <span>=</span> fold<span>&lt;</span>add<span>,</span> Zero<span>,</span> <span>[</span>Suc<span>&lt;</span>Zero<span>&gt;</span><span>,</span> Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;</span><span>,</span> Suc<span>&lt;</span>Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;&gt;</span><span>]</span><span>&gt;</span> 
         
</pre>

<p>As a more advanced example, let&#39;s implement the factorial function, which calculates the product of all positive integers up to a given number. We can define the function as follows:</p>
<pre data-role="codeBlock" data-info="typescript"><span>interface</span> <span>fact</span> <span>extends</span> <span><span>F</span></span> <span>{</span> out<span>:</span> <span>this</span><span>[</span><span>&#39;args&#39;</span><span>]</span> <span>extends</span> 
  <span>[</span><span>infer</span> a<span>]</span>              <span>?</span>
  a <span>extends</span> <span>Zero</span>         <span>?</span> Suc<span>&lt;</span>Zero<span>&gt;</span> <span>:</span>
  a <span>extends</span> <span>Suc<span>&lt;</span><span>infer</span> n<span>&gt;</span></span> <span>?</span> apply<span>&lt;</span>mul<span>,</span> <span>[</span>a<span>,</span> apply<span>&lt;</span>fact<span>,</span> <span>[</span>n<span>]</span><span>&gt;</span><span>]</span><span>&gt;</span> <span>:</span> 
  <span>never</span> <span>:</span> <span>never</span>
<span>}</span>
</pre><p>For instance, the factorial of <code>4</code> is <code>24</code>:</p>
<pre data-role="codeBlock" data-info="typescript"><span>type</span> <span>fac</span> <span>=</span> apply<span>&lt;</span>fact<span>,</span> <span>[</span>Suc<span>&lt;</span>Suc<span>&lt;</span>Suc<span>&lt;</span>Suc<span>&lt;</span>Zero<span>&gt;&gt;&gt;</span><span>&gt;</span><span>]</span><span>&gt;</span> 
        
</pre>

<p>We&#39;ve explored the power of TypeScript&#39;s type system by writing general-purpose programs entirely at the type-level. This exploration showcases TypeScript as a powerful tool for not only providing static typing for JavaScript but also for constructing type-level programs that can help catch errors and ensure semantical correctness at compile-time.</p>
<p>You can try out the code in the <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgGLIN7LlA5gZwC5kBXEAaxAHsB3EAbmSpLGLMtoeQF8AoMAJ4AHFHCFCANgIA8MZBAAekEABN8aADTY8+AHzIAvMgAUcgGSZkAchwErxW+u4BKANpXmYKwF1+wlABa0FTIoUZY5KAqxABEAF7BMTx+IsgAyiQI0iD64ciRqrH4mTFaIMQgyaCQsIiiKiryShCq6uhYnsRgABbA+O6OPk3Kary8oa6gMNDYWlMzAEbeoSsA-OPYwy1qyEFQISuHyKvIC8iEG3BbremZ0vNQyDnHt1likjJwDVquIFpLun0xDGoRAEAAbjMKhDoLw+IJUgoAAyGbDiKTSL4qH57KhaXHefQAeiJu2CKRQCgAjKj3hisT8Mllcbp8cFCcgSa9pCyKcgFAAmWnoz7fZCuJk84Ks7ksjlcyWSlm6PkKADMwo+mLFEruSulMv1+108tJir1d2VKuq0HgSGQAFsSBJrjt2kwWF1ev0bDohooRvgQeKHrNkKGlsdLq71LijocTnGLqErgHtupJaHnic6aLseLc9InRIfn9ToT-hzgaENmDIY9ofW4XyBCijIXizjgmz9qayfsWzT2yKi87GRbmQatObJ8aTfoNkcFRPpDOpXPAXyHWJZDHNNoCHv2NQ6K4OQZLjo92f47fbzmr8mD+o0zdJiBpo8FFoAHR-0MKPgywnK4hYwD8CgVsgf4-tuQiyFogEmuctYwlA9C8DatT2iozALBIKCvm6lidMgPR9AMfrLER6gbO+n7YMByCXCOnYFtOK7KlWzGgmhzYIpS6hGHB0i4SQ+EQF2+wcbOVCGpxBocouhxcq4uIyaulpTtya5GnJgImmMAnIDAVASCou40fuZxWcenBaI4R4UCeIBnrkl6HlZN53j5aynChKZXl5AG-v+H4zIBTGmeZCFolq4HigsiFQUh5w8U8fF8o8RjRRZDL9ni4p6fJWTFSVmmlVpG5KT5y6VfVFWNWVBnWuAtp1CZiBgHu7qkeRPqDNRzQ3HRoZwMsvlrNGVlxneJzFQFmxWZm4WPNmcUYmxoEOSOdpgKWhLcah9ZpXWsLwv4nUIJqGJ7eODVrla87pfGdVNSuukfV9D3fe9P3-X9jVPS1IOgyDvBAA">TypeScript Playground</a>.</p>

      </div></div>
  </body>
</html>
