<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.jviotti.com/2023/12/01/understanding-objective-c-by-transpiling-it-to-cpp.html">Original</a>
    <h1>Understanding Objective-C by transpiling it to C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div>

<article>
  <header>
    
    
    <time datetime="2023-12-01">Dec 01, 2023</time>
    
    <hr/>
  </header>

  <p>Apple heavily pushes for Swift as the programming language for its platforms.
However, Objective-C is not going anywhere yet. A 2023 study reveals that
<a href="https://blog.timac.org/2023/1019-state-of-swift-and-swiftui-ios17/"><em>“Objective-C is still at the core of iOS and is used directly or indirectly
by most
apps”</em></a>.
Also, most frameworks shipped on macOS (<a href="https://www.jviotti.com/2023/11/20/exploring-macos-private-frameworks.html">as we saw on a previous
post</a>)
are still written in Objective-C.</p>

<p>As you probably know, Objective-C is a superset of C. In fact, the <a href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C
runtime</a>
is a plain C library. An awesome trick that <a href="https://wojciechregula.blog">Wojciech
Reguła</a> recently introduced me to is to transpile
Objective-C to C++. This is a great way to learn more about the Objective-C
runtime, and how Objective-C works under the hood.</p>

<p>In this article, we will transpile an example Objective-C program to C++,
highlight some interesting parts of the generated code, and explore some of the
history and current status of this work on the <a href="https://llvm.org">LLVM</a>
project.</p>

<h2 id="example-transpiling-hello-world">Example: Transpiling “Hello World”</h2>

<p>Let’s look at an example, based on the following sample Objective-C program:</p>

<div><div><pre><code><span>// main.m</span>
<span>#import &lt;Foundation/Foundation.h&gt;
</span>
<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>@autoreleasepool</span> <span>{</span>
    <span>NSLog</span><span>(</span><span>@&#34;Hello World&#34;</span><span>);</span>
  <span>}</span>

  <span>return</span> <span>EXIT_SUCCESS</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>To transpile this Objective-C program to C++, we can use Clang’s
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-rewrite-objc"><code>-rewrite-objc</code></a>
option, along with the <code>-Wno-everything</code> option to quiet warnings that are
irrelevant for the sake of this post, and the <code>-fno-ms-extensions</code> to disable
Microsoft-specific extensions (more on this later):</p>

<div><div><pre><code><span>$ </span>xcrun clang main.m <span>-o</span> main.cc <span>-rewrite-objc</span> <span>-Wno-everything</span> <span>-fno-ms-extensions</span>
</code></pre></div></div>

<p>The <code>main.cc</code> output will be a pretty big C++ file (over 60k lines on my
system) that looks something like this:</p>

<div><div><pre><code><span>#ifndef __OBJC2__
#define __OBJC2__
#endif
</span><span>struct</span> <span>objc_selector</span><span>;</span> <span>struct</span> <span>objc_class</span><span>;</span>
<span>struct</span> <span>__rw_objc_super</span> <span>{</span>
	<span>struct</span> <span>objc_object</span> <span>*</span><span>object</span><span>;</span>
	<span>struct</span> <span>objc_object</span> <span>*</span><span>superClass</span><span>;</span>
	<span>__rw_objc_super</span><span>(</span><span>struct</span> <span>objc_object</span> <span>*</span><span>o</span><span>,</span> <span>struct</span> <span>objc_object</span> <span>*</span><span>s</span><span>)</span> <span>:</span> <span>object</span><span>(</span><span>o</span><span>),</span> <span>superClass</span><span>(</span><span>s</span><span>)</span> <span>{}</span>
<span>};</span>

<span>// ...</span>

<span>int</span> <span>main</span><span>()</span> <span>{</span>
  <span>/* @autoreleasepool */</span> <span>{</span> <span>__AtAutoreleasePool</span> <span>__autoreleasepool</span><span>;</span>
    <span>NSLog</span><span>((</span><span>NSString</span> <span>*</span><span>)</span><span>&amp;</span><span>__NSConstantStringImpl__var_folders_sy_wb_f149x2v9_j6xdhfrtr9c00000gn_T_main_fca8a5_mi_0</span><span>);</span>
  <span>}</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
<span>static</span> <span>struct</span> <span>IMAGE_INFO</span> <span>{</span> <span>unsigned</span> <span>version</span><span>;</span> <span>unsigned</span> <span>flag</span><span>;</span> <span>}</span> <span>_OBJC_IMAGE_INFO</span> <span>=</span> <span>{</span> <span>0</span><span>,</span> <span>2</span> <span>};</span>
</code></pre></div></div>

<p>Let’s explore some interesting parts of the resulting code, starting with a
simple one.</p>

<blockquote>
  <p>While we won’t showcase it in this article, <code>-rewrite-objc</code> can also be used
to transpile Objective-C++ to C++.</p>
</blockquote>

<h3 id="inspecting-nsstring-static-strings">Inspecting <code>NSString</code> static strings</h3>

<p>Here is our initial simple
<a href="https://developer.apple.com/documentation/foundation/1395275-nslog"><code>NSLog</code></a>
invocation:</p>



<p>Which the re-writer translated to:</p>

<div><div><pre><code><span>NSLog</span><span>((</span><span>NSString</span> <span>*</span><span>)</span><span>&amp;</span><span>__NSConstantStringImpl__var_folders_sy_wb_f149x2v9_j6xdhfrtr9c00000gn_T_main_6b2f4b_mii_0</span><span>);</span>
</code></pre></div></div>

<p>Our “Hello World” constant string is statically allocated as a <code>__NSConstantStringImpl</code>,</p>

<div><div><pre><code><span>static</span> <span>__NSConstantStringImpl</span> <span>__NSConstantStringImpl__var_folders_sy_wb_f149x2v9_j6xdhfrtr9c00000gn_T_main_6b2f4b_mii_0</span> <span>__attribute__</span> <span>((</span><span>section</span> <span>(</span><span>&#34;__DATA, __cfstring&#34;</span><span>)))</span> <span>=</span> <span>{</span><span>__CFConstantStringClassReference</span><span>,</span><span>0x000007c8</span><span>,</span><span>&#34;Hello World&#34;</span><span>,</span><span>11</span><span>};</span>
</code></pre></div></div>

<p>The <code>__NSConstantStringImpl</code> structure looks like this:</p>

<div><div><pre><code><span>struct</span> <span>__NSConstantStringImpl</span> <span>{</span>
  <span>int</span> <span>*</span><span>isa</span><span>;</span>
  <span>int</span> <span>flags</span><span>;</span>
  <span>char</span> <span>*</span><span>str</span><span>;</span>
<span>#if _WIN64
</span>  <span>long</span> <span>long</span> <span>length</span><span>;</span>
<span>#else
</span>  <span>long</span> <span>length</span><span>;</span>
<span>#endif
</span><span>};</span>
</code></pre></div></div>

<p>Cross-referencing this with the brace initialization of our
<code>__NSConstantStringImpl</code> instance, we can determine that the object <em>is a</em>
<code>__CFConstantStringClassReference</code>, that it has the flags <code>0x000007c8</code>, that
the actual string is <code>Hello World</code>, and that its length is 11. If you are
curious about the flags integer, the <code>CFString</code>
<a href="https://opensource.apple.com/source/CF/CF-550.42/CFString.c">implementation</a>,
part of the <a href="https://developer.apple.com/documentation/corefoundation?language=objc">Core
Foundation</a>
framework, tells us that it is an immutable, UTF-8 string that uses the default
allocator, and whose contents are not freed up.</p>

<p>The <code>(section (&#34;__DATA, __cfstring&#34;))</code> attribute specifies that the string must
be stored in the <code>__cfstring</code> section of the <code>__DATA</code> (read/write) segment of
the resulting
<a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/MachOOverview.html">Mach-O</a>
executable. To better understand this, let’s compile the “Hello World”
Objective-C program (in the usual way) and inspect it using the open-source
<a href="https://github.com/horsicq/XMachOViewer">MachOView</a> desktop application.</p>

<p><img src="https://www.jviotti.com/assets/images/posts/machoview-nsstring.png" alt="Inspecting `__DATA_CONST.__cfstring` and `__TEXT.__cstring` with MachOView"/></p>

<p>In this example, C string literals are stored at specific offsets of the
<code>__cstring</code> section of the <code>__TEXT</code> (read-only) segment, and the <code>CFString</code>
objects are stored in the <code>__cstring</code> section of the <code>__DATA_CONST</code> segment,
pointing back at the offset of the C strings.</p>

<blockquote>
  <p>Note that the Clang Objective-C to C++ re-writer does not add a <code>const</code>
qualifier to the <code>__NSConstantStringImpl</code> instance, resulting in the object
being stored in the <code>__DATA</code> segment, instead of the <code>__DATA_CONST</code> segment
as the normal Objective-C compilation process seems to do. We will touch on
why these differences exist later in the post.</p>
</blockquote>

<p>Even more interestingly, we can see the members of the <code>__NSConstantStringImpl</code>
structure being laid out in the executable. The first entry corresponds to the
<code>isa</code> offset, the second entry corresponds to the <code>flags</code> integer, the third
entry corresponds to the <code>str</code> C string offset (as we saw before), and the
fourth entry corresponds to the <code>length</code> of the string.</p>

<p><img src="https://www.jviotti.com/assets/images/posts/nsconstantstringimpl-macho-cfstring.png" alt="Mach-O example of `__NSConstantStringImpl`"/></p>

<p>Coming back to the generated C++ code, before invoking <code>NSLog</code>, the
<code>__NSConstantStringImpl</code> instance is treated as a cast to <code>NSString</code>, which is
defined as follows:</p>

<div><div><pre><code><span>// @class NSString;</span>
<span>#ifndef _REWRITER_typedef_NSString
#define _REWRITER_typedef_NSString
</span><span>typedef</span> <span>struct</span> <span>objc_object</span> <span>NSString</span><span>;</span>
<span>typedef</span> <span>struct</span> <span>{}</span> <span>_objc_exc_NSString</span><span>;</span>
<span>#endif
</span></code></pre></div></div>

<p>According to the above definition, <code>NSString</code> is an alias (<code>typedef</code>) to
<code>objc_object</code>, which according to the <a href="https://developer.apple.com/documentation/objectivec/id?language=objc">Objective-C
runtime</a>,
corresponds to a pointer to an arbitrary Objective-C object. That is,
<code>objc_object</code> equals the well-known <code>id</code> Objective-C type. In fact, the
generated C++ code defines <code>id</code> like this:</p>

<pre><code>typedef struct objc_class *Class;
struct objc_object {
    Class _Nonnull isa __attribute__((deprecated));
};
typedef struct objc_object *id;
</code></pre>

<h3 id="inspecting-autoreleasepool-blocks">Inspecting <code>@autoreleasepool</code> blocks</h3>

<p>Since the introduction of
<a href="https://clang.llvm.org/docs/AutomaticReferenceCounting.html">ARC</a> (Automatic
Reference Counting), the
<a href="https://developer.apple.com/documentation/foundation/nsautoreleasepool"><code>NSAutoReleasePool</code></a>
cannot be directly used, and was replaced by <code>@autoreleasepool</code> blocks.</p>

<p>If we take a look at the generated C++ code, we can see that Clang re-wrote the
<code>@autoreleasepool</code> block as follows:</p>

<div><div><pre><code><span>/* @autoreleasepool */</span> <span>{</span> <span>__AtAutoreleasePool</span> <span>__autoreleasepool</span><span>;</span>
  <span>NSLog</span><span>((</span><span>NSString</span> <span>*</span><span>)</span><span>&amp;</span><span>__NSConstantStringImpl__var_folders_sy_wb_f149x2v9_j6xdhfrtr9c00000gn_T_main_fca8a5_mi_0</span><span>);</span>
<span>}</span>
</code></pre></div></div>

<p>The key here is the <code>__AtAutoreleasePool</code> class, defined close to the beginning
of the generated file:</p>

<div><div><pre><code><span>struct</span> <span>__AtAutoreleasePool</span> <span>{</span>
  <span>__AtAutoreleasePool</span><span>()</span> <span>{</span><span>atautoreleasepoolobj</span> <span>=</span> <span>objc_autoreleasePoolPush</span><span>();}</span>
  <span>~</span><span>__AtAutoreleasePool</span><span>()</span> <span>{</span><span>objc_autoreleasePoolPop</span><span>(</span><span>atautoreleasepoolobj</span><span>);}</span>
  <span>void</span> <span>*</span> <span>atautoreleasepoolobj</span><span>;</span>
<span>};</span>
</code></pre></div></div>

<p>This is a C++ <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a> (Resource
Acquisition Is Initialization) wrapper over the <code>objc_autoreleasePoolPush</code> and
<code>objc_autoreleasePoolPop</code> private C functions of the runtime.</p>

<p>These functions are not covered by the Apple documentation, and are not
declared on the public headers of the Objective-C runtime, which you can
confirm with the following <code>grep(1)</code> command:</p>

<div><div><pre><code><span>$ </span><span>grep </span>objc_autorelease <span>$(</span>xcode-select <span>--print-path</span><span>)</span>/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/objc/<span>*</span>
</code></pre></div></div>

<p>In a <a href="https://www.jviotti.com/2023/11/20/exploring-macos-private-frameworks.html">previous
article</a>,
we explored how to extract the <code>dyld</code> shared cache of your system libraries.
Assuming your extracted cache is located at <code>$HOME/dyld-cache-arm64e</code>, you can
confirm <code>objc_autoreleasePoolPush</code> and <code>objc_autoreleasePoolPop</code> are globally
exposed symbols of <code>libobjc.A.dylib</code> using <code>nm(1)</code>:</p>

<div><div><pre><code><span>$ </span>nm <span>-g</span> <span>$HOME</span>/dyld-cache-arm64e/usr/lib/libobjc.A.dylib | <span>grep </span>objc_autorelease
00000001800a4afc T __objc_autoreleasePoolPop
00000001800a4b00 T __objc_autoreleasePoolPrint
00000001800a4af8 T __objc_autoreleasePoolPush
0000000180075850 T _objc_autorelease
00000001800739ec T _objc_autoreleasePoolPop
00000001800738ac T _objc_autoreleasePoolPush
0000000180076b8c T _objc_autoreleaseReturnValue
</code></pre></div></div>

<p>You can also find references to these functions in the TDB that declares
exported symbols for <code>libobjc.A.dylib</code>:</p>

<div><div><pre><code><span>$ </span><span>grep </span>objc_autorelease &lt; <span>$(</span>xcode-select <span>--print-path</span><span>)</span>/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/libobjc.A.tbd
           __objc_atfork_parent, __objc_atfork_prepare, __objc_autoreleasePoolPop,
           __objc_autoreleasePoolPrint, __objc_autoreleasePoolPush, __objc_beginClassEnumeration,
           _objc_allocateProtocol, _objc_autorelease, _objc_autoreleasePoolPop,
           _objc_autoreleasePoolPush, _objc_autoreleaseReturnValue, _objc_begin_catch,
</code></pre></div></div>

<p>Coming back to our generated code, these private functions that are not
declared in the Objective-C runtime headers are consumed like this:</p>

<div><div><pre><code><span>extern</span> <span>&#34;C&#34;</span> <span>__declspec</span><span>(</span><span>dllimport</span><span>)</span> <span>void</span> <span>*</span> <span>objc_autoreleasePoolPush</span><span>(</span><span>void</span><span>);</span>
<span>extern</span> <span>&#34;C&#34;</span> <span>__declspec</span><span>(</span><span>dllimport</span><span>)</span> <span>void</span> <span>objc_autoreleasePoolPop</span><span>(</span><span>void</span> <span>*</span><span>);</span>
</code></pre></div></div>

<h4 id="microsoft-extensions">Microsoft Extensions</h4>

<p>You might be puzzled by the seemingly Windows-specific <code>__declspec(dllimport)</code>
attribute.</p>

<p>Let’s dig a bit into it. I’m running AppleClang 1500.0.40.1 (Xcode 15.0.1),
which <a href="https://en.wikipedia.org/wiki/Xcode">corresponds to LLVM 16</a>. In LLVM
16, the Objective-C re-writer we are using is implemented in
<a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp"><code>clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp</code></a>.</p>

<blockquote>
  <p>You might have noted
<a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/Rewrite/RewriteObjC.cpp"><code>clang/lib/Frontend/Rewrite/RewriteObjC.cpp</code></a>,
which corresponds to the old
<a href="https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-rewrite-legacy-objc"><code>-rewrite-legacy-objc</code></a>
Clang option. That re-writer is deprecated and should not be used anymore.</p>
</blockquote>

<p>Taking a look into <code>RewriteModernObjC.cpp</code>, we can see that the re-writer has
various conditionals around <code>LangOpts.MicrosoftExt</code> for performing
Microsoft-specific rewrites. For example, lines <a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp#L5930-L5935">5930 to
5935</a>
contain the following logic:</p>

<div><div><pre><code><span>if</span> <span>(</span><span>LangOpts</span><span>.</span><span>MicrosoftExt</span><span>)</span> <span>{</span>
  <span>Preamble</span> <span>+=</span> <span>&#34;#define __OBJC_RW_DLLIMPORT extern </span><span>\&#34;</span><span>C</span><span>\&#34;</span><span> __declspec(dllimport)</span><span>\n</span><span>&#34;</span><span>;</span>
  <span>Preamble</span> <span>+=</span> <span>&#34;#define __OBJC_RW_STATICIMPORT extern </span><span>\&#34;</span><span>C</span><span>\&#34;\n</span><span>&#34;</span><span>;</span>
<span>}</span>
<span>else</span>
  <span>Preamble</span> <span>+=</span> <span>&#34;#define __OBJC_RW_DLLIMPORT extern</span><span>\n</span><span>&#34;</span><span>;</span>
</code></pre></div></div>

<p>As you might expect, this is the reason we initially passed the
<code>-fno-ms-extensions</code>. However, these Microsoft-specific conditionals are not
consistently handled at the moment. For example, you might find <em>FIXME</em>
comments like the one in lines <a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp#L1012-L1014">1012 to
1014</a>:</p>

<pre><code>// FIXME. Is this attribute correct in all cases?
Setr = &#34;\nextern \&#34;C\&#34; __declspec(dllimport) &#34;
&#34;void objc_setProperty (id, SEL, long, id, bool, bool);\n&#34;;
</code></pre>

<p>More specific to our case, the re-writer (incorrectly?) hardcodes
<code>__declspec(dllimport)</code> for <code>objc_autoreleasePoolPush</code> and
<code>objc_autoreleasePoolPop</code> in lines <a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp#L6045-L6046">6045 to
6046</a>:</p>

<div><div><pre><code>Preamble += &#34;extern \&#34;C\&#34; __declspec(dllimport) void * objc_autoreleasePoolPush(void);\n&#34;;
Preamble += &#34;extern \&#34;C\&#34; __declspec(dllimport) void objc_autoreleasePoolPop(void *);\n\n&#34;;
</code></pre></div></div>

<h2 id="is-objective-c-just-a-transpiler">Is Objective-C just a transpiler?</h2>

<p>If you got this far, you might be wondering how LLVM makes use of this
Objective-C re-writer. When you compile Objective-C, this re-writer <strong>is not</strong>
used.</p>

<p>Instead, LLVM has an Objective-C frontend that <em>directly</em> compiles to LLVM
<a href="https://llvm.org/docs/LangRef.html">IR</a> (Intermediate Representation), which
is transformed to machine code by the LLVM backend. You can peek into the
production-ready Objective-C frontend for LLVM 16 at
<a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/lib/CodeGen/CGObjC.cpp"><code>clang/lib/CodeGen/CGObjC.cpp</code></a>.</p>

<h2 id="limitations-of-the-re-writer">Limitations of the re-writer</h2>

<p>The fact that normal Objective-C compilation follows a different process
explains some inconsistencies we saw with the re-writer in this article, like
the fact that static strings are put in the <code>__DATA</code> segment instead of in the
<code>__DATA_CONST</code> segment and missing conditionals around Microsoft-specific
extensions and <code>dllimport</code>.</p>

<p>Apart from minor inconsistencies, the re-writer seems to have many other
issues. Unless you provide trivial examples that do not make use of the
<a href="https://developer.apple.com/documentation/foundation">Foundation</a> framework,
the generated C++ code does not compile. For example, while experimenting with
the “Hello World” program presented at the beginning of this chapter, I found
references to wrong structure names, some Objective-C <code>@property</code> declarations
not being re-written, invalid <code>typedef</code> aliases, and more.</p>

<p>If we take a detour into LLVM again, Clang’s
<a href="https://github.com/llvm/llvm-project/blob/llvmorg-16.0.0/clang/README.txt">README</a>
states that <em>“Clang is useful for a number of things beyond just compiling
code: we intend for Clang to be host to a number of different source-level
tools.”</em> Turns out that the Objective-C re-writer is just an side experiment
best-effort tool <a href="https://github.com/llvm/llvm-project/commit/e99c8329af75d6b556b620a335802bbfa6a4b7b8">started in
2007</a>
by <a href="https://nondot.org/sabre/">Chris Lattner</a>, creator of LLVM and Swift.</p>

<p>Over the last 15 years, this re-writer experiment had consistent casual
contributions and a growing <a href="https://github.com/llvm/llvm-project/tree/llvmorg-16.0.0/clang/test/Rewriter">end-to-end test
suite</a>.
Even if it is still not perfect, you can already learn many things about
Objective-C with it!</p>


  
</article>
</div></div>
  </body>
</html>
