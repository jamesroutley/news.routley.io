<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.mozilla.ai/wasm-agents-ai-agents-running-in-your-browser/">Original</a>
    <h1>WASM Agents: AI agents running in the browser</h1>
    
    <div id="readability-page-1" class="page"><div>

    <article>

        <header>

            
                <p>One of the main barriers to a wider adoption of open-source agents is the dependency on extra tools and frameworks that need to be installed before the agents can be run. In this post, we show how to write agents as HTML files, which can just be opened and run in a browser.</p>

            <div>
                <p><a href="https://blog.mozilla.ai/author/davide-eynard/">
                                <img src="https://blog.mozilla.ai/content/images/size/w160/2024/04/e8438c662e8cc46f.jpeg" alt="Davide Eynard"/>
                            </a>
                </p>
                <div>
                    
                    <p><time datetime="2025-07-03">Jul 3, 2025</time>
                            <span><span>—</span> 7 min read</span>
                    </p>
                </div>
            </div>

                <figure>
        <img srcset="/content/images/size/w320/2025/07/WASM-Agents.jpeg 320w,
                    /content/images/size/w600/2025/07/WASM-Agents.jpeg 600w,
                    /content/images/size/w960/2025/07/WASM-Agents.jpeg 960w,
                    /content/images/size/w1200/2025/07/WASM-Agents.jpeg 1200w,
                    /content/images/size/w2000/2025/07/WASM-Agents.jpeg 2000w" sizes="(max-width: 1200px) 100vw, 1120px" src="https://blog.mozilla.ai/content/images/size/w1200/2025/07/WASM-Agents.jpeg" alt="Wasm-agents: AI agents running in your browser"/>
            <figcaption><span>Louis Figuier/ </span><a href="https://pdimagearchive.org/images/2e162345-c461-43b8-ae72-29f7739a9712/" rel="noreferrer"><span>Beaumont Machine for Digging Tunnels in Soft Rock</span></a></figcaption>
    </figure>

        </header>

        <section>
            <p>One of the main barriers to a wider adoption and experimentation with open-source agents is the dependency on extra tools and frameworks that need to be installed before the agents can be run. In this post, we introduce the <a href="https://github.com/mozilla-ai/wasm-agents-blueprint?ref=blog.mozilla.ai"><u>Wasm agents blueprint</u></a>, aimed at showing how to write agents as HTML files, which can just be opened and run in a browser, without the need for any extra dependencies. This is still an experimental project, but we chose to share it early so that people can both test its capabilities and build new applications based on it.</p><h3 id="why">Why?</h3><p>While developing our <a href="https://github.com/mozilla-ai/agent-factory/?ref=blog.mozilla.ai"><u>agent-factory</u></a> tool, we have been wondering about ways to package an agent so it could be easily shared and executed on different systems. In the past, we addressed a similar problem with <a href="https://marimo.app/?ref=blog.mozilla.ai"><u>marimo</u></a>, both when trying to <a href="https://blog.mozilla.ai/taming-randomness-in-ml-models-with-hypothesis-testing-and-marimo/"><u>convey our thoughts with code examples</u></a> and when introducing <a href="https://blog.mozilla.ai/build-your-own-timeline-algorithm-a-blueprint-2/"><u>new tools for algorithmic timelines</u></a>. In both cases, the main advantage was that people could run code directly on their devices, more precisely inside their own browsers, thanks to the possibility of exporting marimo notebooks as standalone HTML files powered by <a href="https://webassembly.org/?ref=blog.mozilla.ai"><u>WebAssembly</u></a> and <a href="https://pyodide.org/?ref=blog.mozilla.ai"><u>Pyodide</u></a>.</p><p><strong>WebAssembly</strong> (Wasm) is a binary instruction format that allows code written in languages like C, C++, Rust, and Python to run at near-native speed in web browsers. <strong>Pyodide</strong> is a Python distribution for the browser that runs entirely in WebAssembly, enabling you to execute Python code and many of its libraries directly in web applications. As most of our agentic code is in Python, it was quite natural for us to think about adopting a similar solution: the result is a collection of simple, single-file agents that run in a browser tab, in an environment that is sandboxed by construction, and without the need to manually install extra libraries or development frameworks.</p><h3 id="how-it-works">How it works</h3><p>All our demos are standalone HTML files, which contain both the UI and the running code of an agent. If you look at their source code, you will see three calls to the <code>pyodide.runPythonAsync</code> command. They deal, respectively, with installing the required Python dependencies (with the <code>micropip</code>customisation Pyodide library); disabling traces (this is currently required only when running the openai-agents framework – you can find more information in the customization section below); and running the actual agent code. </p><p>The agent code is nothing more than a Python script that relies on the <a href="https://openai.github.io/openai-agents-python/?ref=blog.mozilla.ai"><u>openai-agents-python</u></a> library to run an AI agent backed by an LLM served via an OpenAI-compatible API. What this means is that while it runs with OpenAI out-of-the-box (using gpt-4o as a default model), you can also specify a different, self-hosted model, as long as it is compatible with the API. This includes, for instance, models served via <a href="https://huggingface.co/docs/text-generation-inference/main/en/reference/api_reference?ref=blog.mozilla.ai#openai-messages-api"><u>HuggingFace TGI</u></a>, <a href="https://docs.vllm.ai/?ref=blog.mozilla.ai"><u>vLLM</u></a>, or even <a href="https://ollama.com/?ref=blog.mozilla.ai"><u>Ollama</u></a> running locally on your computer.</p><h3 id="give-it-a-try">Give it a try</h3><p>If you want to try our agents, follow the <a href="https://github.com/mozilla-ai/wasm-agents-blueprint/blob/main/README.md?ref=blog.mozilla.ai"><u>setup instructions</u></a> in our GitHub repo. The TL/DR is: if you have a ready-to-use OpenAI API key, you can just paste it into the provided config.js file. If instead you want to try a local model, you should make sure that it is running and that you know the URL to access it. For example, if you want to run qwen3:8b on Ollama, you should first download the application, then the model (with Ollama pull qwen3:8b). After that, open one of the HTML files in your browser and follow the instructions provided: your agent should be up and running in a few seconds.</p><h3 id="what-can-i-do">What can I do?</h3><p>Our demos show some of the things you can do with Wasm agents, but I think we just scratched the surface of what one could do! So take these as just some examples you can start with, and play with them to test their capabilities, and learn how to build new applications with them. In the <code>/demos</code> directory, you will find the following HTML files:</p><ul><li><code>hello_agent.html</code>: This is a simple conversational agent with customizable instructions, useful for understanding the basics of WASM-based agents.</li><li><code>handoff_demo.html</code>: a multi-agent system that routes requests to specialized agents based on the characteristics of the prompt.</li><li><code>tool_calling.html</code>: A more advanced agent with built-in tools for (more or less) practical tasks. The <code>count_character_occurrences</code> tool addresses the famous &#34;How many Rs in strawberry?&#34; problem. The <code>visit_webpage</code> tool downloads web content and converts it to markdown, and can be used by the agent to seek up-to-date information about the question directly on the web.</li><li><code>ollama_local.html</code>: An agent which relies on local models served via Ollama, good for offline tasks or when you don’t want your information to leak to external AI services.</li></ul><p>NOTE: If you want to run tools that get information from some other server into your HTML page (e.g. the <code>visit_webpage</code> tool or the Ollama server itself), you need to make sure that CORS is enabled for those servers. For more information, refer to the <a href="https://github.com/mozilla-ai/wasm-agents-blueprint/blob/main/README.md?ref=blog.mozilla.ai#troubleshooting"><u>troubleshooting</u></a> section in our GitHub repository.</p><figure><img src="https://blog.mozilla.ai/content/images/2025/07/image_1.png" alt="" loading="lazy" width="1920" height="1137" srcset="https://blog.mozilla.ai/content/images/size/w600/2025/07/image_1.png 600w, https://blog.mozilla.ai/content/images/size/w1000/2025/07/image_1.png 1000w, https://blog.mozilla.ai/content/images/size/w1600/2025/07/image_1.png 1600w, https://blog.mozilla.ai/content/images/2025/07/image_1.png 1920w" sizes="(min-width: 720px) 720px"/><figcaption><span>An in-browser agent running with a self-hosted local model, accessing just the two URLs required to answer the user’s question.</span></figcaption></figure><h3 id="known-limitations">Known limitations</h3><p>We decided to share these demos very early because we are very excited about them, but we are aware that the examples we are sharing are still limited in scope. In particular:</p><ul><li><strong>We are limited to the openai-agents framework</strong>: OpenAI’s is just one of too many (which is the reason why we built <a href="https://github.com/mozilla-ai/any-agent?ref=blog.mozilla.ai"><u>any-agent</u></a>). The reason we chose it is because all of its dependencies were working with Pyodide. Still, we had to compromise on disabling agent traces (which are very useful to understand how an agent works) because they broke the interpreter. We tried other frameworks, but each came with its own caveats. For instance, <a href="https://huggingface.co/docs/smolagents/index?ref=blog.mozilla.ai"><u>smolagents</u></a> traces implementation works well in the browser, but the support for non-HuggingFace models is provided via <a href="https://github.com/BerriAI/litellm?ref=blog.mozilla.ai" rel="noreferrer">LiteLLM</a>, which is not supported by Pyodide.</li><li><strong>CORS, CORS everywhere</strong>: Code mixing information retrieved from different URLs is insecure by default and typically blocked by modern browsers. For this reason, as soon as you start enabling tools that retrieve web pages, or even a local inference engine, you will need to disable CORS (and remember to enable it again once you are done!).</li><li><strong>Assume an inference engine</strong>: We believe this is still a strong assumption for now, because if you want to use an open-source model, you will still have to go through an additional installation process. However, we believe there are projects, such as the <a href="https://firefox-source-docs.mozilla.org/toolkit/components/ml/extensions.html?ref=blog.mozilla.ai"><u>Firefox Webextension AI API</u></a>, which might make this step easier.</li><li><strong>Models are heavy</strong>: Not everyone can run large models, and we want to be mindful of that. The local example we provide might not work on your hardware. In that case, we’d suggest you play with smaller models / shorter context lengths (see next section).</li></ul><h3 id="customize-break-it"><s>Customize</s> Break it</h3><p>Following the previous section, we changed the title of this section accordingly 😁 and we suggest you to:</p><ul><li><strong>Learn how this works</strong>: All the code is there, and except for the OpenAI-based examples, everything runs on your computer. So run all the examples multiple times and play with their code until you are sure you know the basics.</li><li><strong>Play with prompts</strong>: Look at the example below to see how you can challenge an LLM and verify whether tool calling actually helps or not.</li><li><strong>Understand non-determinism</strong>: When asked multiple times, LLMs do not usually provide the same answer to the same question. Are all the answers correct? Likely not.</li><li><strong>Learn peculiarities of different models</strong>: If you can run self-hosted models with Ollama, play with different LLMs and learn which one works best for your case. For instance, does the thinking mode improve the model’s answers? (Hint: you can add <code>/think</code> or <code>/no_think</code> to explicitly enable/disable it on qwen3). Or, are all models good at tool calling? (Hint: <a href="https://ollama.com/blog/tool-support?ref=blog.mozilla.ai"><u>apparently not</u></a>, but which one is best?)</li><li><strong>Test the limits of the models… and your hardware</strong>: Saying “we use x and y, so we theoretically support any model” is (relatively) easy. <em>Actually, running</em> any model on your hardware is not as easy though. While I could run qwen3:8b with a (unnecessary) 40K tokens context-length on my M3 MacBook, I can barely run the 1.7b model with a much shorter context on a Raspberry Pi 5 with 8GB RAM, and it does not return a response in time unless I increase the agent’s timeout value. And don’t get me started with the 0.6b model, which produces a lot of thinking to eventually return wrong answers.</li><li><strong>Try other agentic frameworks</strong>: We believe there is definitely value in understanding which framework works best, and if it is worth helping with supporting Wasm versions of the libraries that currently do not run in browsers yet.</li><li><strong>Tools, tools, tools</strong>: There are definitely some limits to what can be run in a browser, and my assumption is that what made agents so trendy lately (namely, the possibility of empowering LLMs with tools) is going to be quite limited. I don’t see myself spinning up a new MCP server from a browser tab, but I am quite sure that there are already many things one could do <em>if only they could tinker with some simple, self-contained code</em>. Still, I’d like to see where things start breaking and what we can do within those limits.</li></ul><figure><img src="https://blog.mozilla.ai/content/images/2025/07/image_2.png" alt="" loading="lazy" width="1676" height="1610" srcset="https://blog.mozilla.ai/content/images/size/w600/2025/07/image_2.png 600w, https://blog.mozilla.ai/content/images/size/w1000/2025/07/image_2.png 1000w, https://blog.mozilla.ai/content/images/size/w1600/2025/07/image_2.png 1600w, https://blog.mozilla.ai/content/images/2025/07/image_2.png 1676w" sizes="(min-width: 720px) 720px"/><figcaption><span>Someone has decided to stress-test qwen3:8b on the strawberry problem... We are lucky that there is a tool it can call to do the counting for it!</span></figcaption></figure><h3 id="conclusions">Conclusions</h3><p>I personally do not know yet whether WebAssembly agents are a great idea or just a funny hack, but they resonate so much with so many concepts I (can I say we?) care about (owning our tools, being allowed to tinker with them, running things locally, protecting our data, even the good old <a href="http://davide.eynard.it/malawiki/PowerBrowsing.html?ref=blog.mozilla.ai"><u>powerbrowsing</u></a>!) that I believe not sharing them as soon as possible would have been a real shame. We’d be glad to know if you are having fun with them, and to learn what you learned. So please feel free to reach out on our <a href="https://discord.com/invite/ai-mozilla-1089876418936180786?ref=blog.mozilla.ai" rel="noreferrer">Discord</a>, on <a href="https://github.com/mozilla-ai/wasm-agents-blueprint?ref=blog.mozilla.ai" rel="noreferrer">GitHub</a>, or directly to me. In the meantime, have fun with your Wasm agents!</p>
        </section>

    </article>


</div></div>
  </body>
</html>
