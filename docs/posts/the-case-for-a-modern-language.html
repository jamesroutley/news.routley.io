<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jeang3nie.codeberg.page/case-for-modern-language-pt1/">Original</a>
    <h1>The case for a modern language</h1>
    
    <div id="readability-page-1" class="page"><div>
          <dic>
            
<div>
  
  <p>There is a difference of opinion among many programmers regarding the idea of
replacing <strong>C</strong>, either in newly wrritten code or else altogether. I find myself
coming down on the side that it makes little sense to try to replace a legacy
codebase, and still find <strong>C</strong> useful in some contexts (particularly in the
realm of microcontrollers). That said<span id="continue-reading"></span> I think a strong case can be
made for using one of the several more modern languages that have sprung up in
the systems programming space, at least for newly written code. I make no secret
that I love Rust and Zig both, for many similar reasons. But I also find Nim to
be impressive and have heard great things about Odin. There is, frankly, room for
more than one.</p>
<p>I&#39;m going to starrt this off with a small example, parsing a string into an
integer, because this is something that is very fundamental and must be done
for many command line programs just to parse some input. Let&#39;s look at <strong>Rust</strong>
first, for no particular reason.</p>
<pre data-lang="Rust"><code data-lang="Rust"><span>// pretend that this was passed in on the command line
</span><span>let</span><span> my_number_string </span><span>= </span><span>String</span><span>::from(</span><span>&#34;42&#34;</span><span>);
</span><span>// If we just want to bubble up errors
</span><span>let</span><span> my_number: </span><span>u8 </span><span>= &amp;</span><span>my_number_string.</span><span>parse</span><span>()</span><span>?</span><span>;
</span><span>assert_eq!</span><span>(my_number, </span><span>42</span><span>);
</span><span>// If we might like to panic!
</span><span>let</span><span> my_number: </span><span>u8 </span><span>= &amp;</span><span>my_number_string.</span><span>parse</span><span>().</span><span>unwrap</span><span>();
</span><span>assert_eq!</span><span>(my_number, </span><span>42</span><span>);
</span><span>// If we&#39;re a good Rustacean and check for errors before trying to use the data
</span><span>if let </span><span>Ok</span><span>(my_number: </span><span>u8</span><span>) </span><span>= &amp;</span><span>my_number_string.</span><span>parse</span><span>() {
</span><span>    </span><span>assert_eq!</span><span>(my_number, </span><span>42</span><span>);
</span><span>}
</span></code></pre>
<p>There&#39;s lots of ways that we can handle the error case. None of them are
particularly high friction, we can choose what fits or what we&#39;re comfortable
with, and the error handling strategy is ultimately pretty generic over the
entire standard library so you can just choose for yourself. The method can fail,
but it can&#39;t fail silently. If we choose to use <code>unwrap()</code>, the program very well
might panic if given garbage data, but we&#39;re not silently using the wrong data.
Cool. How about <strong>Zig</strong> then.</p>
<pre data-lang="Zig"><code data-lang="Zig"><span>const</span><span> std </span><span>= </span><span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);
</span><span>
</span><span>const</span><span> myNumberString </span><span>= </span><span>&#34;42&#34;</span><span>;
</span><span>// Bubble up the errors just like in Rust, third arg is the radix (10)
</span><span>const</span><span> myNumber </span><span>= </span><span>try</span><span> std.fmt.</span><span>parseInt</span><span>(u8, myNumberString, </span><span>10</span><span>);
</span><span>// But we can do better
</span><span>const</span><span> myOtherNumber </span><span>=</span><span> std.fmt.</span><span>parseInt</span><span>(u8, myNumberString, </span><span>10</span><span>) </span><span>catch </span><span>42</span><span>;
</span><span>// Or even better
</span><span>if </span><span>(std.fmt.</span><span>parseInt</span><span>(u8, myNumberString, </span><span>10</span><span>)) </span><span>|</span><span>val</span><span>| </span><span>{
</span><span>    </span><span>// do something with val
</span><span>    std.debug.</span><span>print</span><span>(</span><span>&#34;{d} is THE answer\n&#34;</span><span>, .{val});
</span><span>} </span><span>else </span><span>|</span><span>err</span><span>| </span><span>{
</span><span>    std.debug.</span><span>print</span><span>(</span><span>&#34;Error getting THE answer: {s}\n&#34;</span><span>, .{err});
</span><span>}
</span></code></pre>
<p>Ok then, the syntax is really different but we&#39;re using some really familiar
concepts here. One might cite parallel evolution here, the two languages have
functionally equivalent constructs. Now how &#39;bout good old <strong>C</strong>?</p>
<pre data-lang="C"><code data-lang="C"><span>#include </span><span>&lt;stdlib.h&gt; </span><span>// atoi
</span><span>
</span><span>char </span><span>*</span><span>forty_two </span><span>= </span><span>&#34;42&#34;</span><span>;
</span><span>int</span><span> i </span><span>= </span><span>atoi</span><span>(forty_two)</span><span>;
</span></code></pre>
<p>Are you cringing yet? You should be. You can pass literally anything to <code>atoi</code>
and it will probably give you what you want if the input is valid. If the input
isn&#39;t valid, tough, you have literally no way of knowing. Why does this function
exist at all, you might ask? And well you might. It exists because it became part
of the POSIX standard way back when a pdp7 was an advanced computer and nobody
has had the bollucks to say, go ahead and break the old code because this just
doesn&#39;t belong in there. There is of course a <em>better</em> way, well sort of better.
You&#39;ll see.</p>
<pre data-lang="C"><code data-lang="C"><span>#include </span><span>&lt;stdlib.h&gt; </span><span>// strtol
</span><span>
</span><span>char </span><span>*</span><span>forty_two </span><span>= </span><span>&#34;42&#34;</span><span>;
</span><span>long</span><span> i </span><span>= </span><span>strtol</span><span>(forty_two, </span><span>NULL</span><span>, </span><span>10</span><span>)</span><span>;
</span></code></pre>
<p>This is marginally better, but we never did check to see if we got what we think
that we got. And you&#39;ll see <code>strtol</code> used this way even in what are considered
<em>good</em> codebases sometimes, because this is the lowest friction way to use the
function, and we&#39;re all pretty lazy, but after all, it&#39;s better than <code>atoi</code>,
right? Well no, not if it&#39;s used like this it isn&#39;t. So how can we do better?</p>
<pre data-lang="C"><code data-lang="C"><span>#include </span><span>&lt;stdlib.h&gt; </span><span>// strtol
</span><span>#include </span><span>&lt;errno.h&gt;  </span><span>// errno, perror
</span><span>
</span><span>char </span><span>*</span><span>forty_two </span><span>= </span><span>&#34;42&#34;</span><span>;
</span><span>errno </span><span>= </span><span>0</span><span>; </span><span>// Initialize errno in case we tripped an error previously
</span><span>long</span><span> i </span><span>= </span><span>strtol</span><span>(forty_two, </span><span>NULL</span><span>, </span><span>10</span><span>)</span><span>;
</span><span>if </span><span>(errno </span><span>!= </span><span>0</span><span>)
</span><span>    </span><span>perror(</span><span>&#34;Error parsing integer from string: &#34;</span><span>)</span><span>;
</span></code></pre>
<p>Ok, so we&#39;re good now, right?</p>
<p>Right?</p>
<p>No. We&#39;re nowhere near good yet. We&#39;ve caught two of a number of error conditions
by checking errno, but it turns out that the only two errors which we have caught
are underflow and overflow. We could have passed in &#34;42b&#34; instead of just &#34;42&#34;
and it would have given us the exact same output as before without setting
<code>errno</code>. Confused yet? Don&#39;t worry, you&#39;ll be more confused later. Let&#39;s try
something else and really blow your mind.</p>
<pre data-lang="C"><code data-lang="C"><span>#include </span><span>&lt;stdlib.h&gt; </span><span>// strtol
</span><span>#include </span><span>&lt;errno.h&gt;  </span><span>// errno, perror
</span><span>
</span><span>char </span><span>*</span><span>one </span><span>= </span><span>&#34;one&#34;</span><span>;
</span><span>errno </span><span>= </span><span>0</span><span>; </span><span>// remember errno?
</span><span>
</span><span>long</span><span> i </span><span>= </span><span>strtol</span><span>(one, </span><span>NULL</span><span>, </span><span>10</span><span>)</span><span>;
</span><span>if </span><span>(errno </span><span>!= </span><span>0</span><span>)
</span><span>    </span><span>perror(</span><span>&#34;Error parsing integer from string: &#34;</span><span>)</span><span>;
</span><span>else
</span><span>    </span><span>printf(</span><span>&#34;</span><span>%i</span><span>\n&#34;</span><span>, i)</span><span>;
</span></code></pre>
<p>That code prints <code>0</code> to your terminal without any errors. So why is that, you
wonder? And how do we fix it? Do we check for <code>0</code> and consider that a failure?
If so, what if the string given to the function actually <em>was</em> &#34;0&#34;? Well remember
when I said that we&#39;re all pretty lazy? What&#39;s that <code>NULL</code> that we&#39;ve been
feeding to the function as the second parameter?</p>
<p>Ah, now we&#39;re asking the right question. That&#39;s a pointer. Maybe. If we pass it
something real, then we can use it.</p>
<pre data-lang="C"><code data-lang="C"><span>#include </span><span>&lt;stdlib.h&gt; </span><span>// strtol
</span><span>#include </span><span>&lt;errno.h&gt;  </span><span>// errno, perror
</span><span>
</span><span>char </span><span>*</span><span>one </span><span>= </span><span>&#34;one&#34;</span><span>;
</span><span>char </span><span>*</span><span>end;
</span><span>errno </span><span>= </span><span>0</span><span>; </span><span>// remember errno?
</span><span>long</span><span> i </span><span>= </span><span>strtol</span><span>(one, </span><span>&amp;</span><span>end, </span><span>10</span><span>)</span><span>;
</span><span>if </span><span>(errno </span><span>!= </span><span>0</span><span>) {
</span><span>    </span><span>perror</span><span>(</span><span>&#34;Error parsing integer from string: &#34;</span><span>)</span><span>;
</span><span>} </span><span>else if </span><span>(i </span><span>== </span><span>0 </span><span>&amp;&amp;</span><span> end </span><span>==</span><span> one) {
</span><span>   </span><span>fprintf</span><span>(stderr, </span><span>&#34;Error: invalid input: </span><span>%s</span><span>\n&#34;</span><span>, one)</span><span>;
</span><span>}
</span></code></pre>
<p>So if you look at the function signature for strtol, our second parameter is our
<em>entptr</em>, or the pointer we end on. This gets incremented for every valid
character, so now if we were to pass it that string &#34;one&#34; as above it will return
<code>0</code>, but by checking if the pointer has moved we can determine that it has not,
and so we know that we gave it garbage input. So we&#39;re good, right?</p>
<p>We&#39;re good, right?</p>
<p>Beuller...</p>
<p>Beuller...</p>
<p>No. No we&#39;re not good yet. Because we could pass it something like this:</p>
<pre data-lang="C"><code data-lang="C"><span>char </span><span>*</span><span>forty_two_bee </span><span>= </span><span>&#34;42b&#34;</span><span>;
</span><span>char </span><span>*</span><span>end;
</span><span>errno </span><span>= </span><span>0</span><span>; </span><span>// remember errno?
</span><span>
</span><span>long</span><span> i </span><span>= </span><span>strtol</span><span>(forty_two_bee, </span><span>&amp;</span><span>end, </span><span>10</span><span>)</span><span>;
</span></code></pre>
<p>This will return <code>0</code>, will not trip <code>errno</code> (remember <code>errno</code>?), and the pointer
has moved forward by two bytes. So our logic from the previous example would not
catch the pointer move. We also have to check and see what&#39;s at the pointer. And
because strings in <strong>C</strong> are the <code>char *</code> type, what we have a an array of bytes
that is null terminated. So our final check is that this character is null.</p>
<pre data-lang="C"><code data-lang="C"><span>#include </span><span>&lt;stdlib.h&gt;   </span><span>// strtol
</span><span>#include </span><span>&lt;errno.h&gt;    </span><span>// errno, perror
</span><span>#include </span><span>&lt;heathers.h&gt; </span><span>// f__kMeGently
</span><span>
</span><span>char </span><span>*</span><span>one </span><span>= </span><span>&#34;one&#34;</span><span>;
</span><span>char </span><span>*</span><span>end;
</span><span>errno </span><span>= </span><span>0</span><span>; </span><span>// remember errno?
</span><span>long</span><span> i </span><span>= </span><span>strtol</span><span>(one, </span><span>&amp;</span><span>end, </span><span>10</span><span>)</span><span>;
</span><span>if </span><span>(errno </span><span>!= </span><span>0</span><span>) {
</span><span>    </span><span>perror</span><span>(</span><span>&#34;Error parsing integer from string: &#34;</span><span>)</span><span>;
</span><span>} </span><span>else if </span><span>(i </span><span>== </span><span>0 </span><span>&amp;&amp;</span><span> end </span><span>==</span><span> one) {
</span><span>    </span><span>fprintf</span><span>(stderr, </span><span>&#34;Error: invalid input: </span><span>%s</span><span>\n&#34;</span><span>, one)</span><span>;
</span><span>} </span><span>else if </span><span>(i </span><span>== </span><span>0 </span><span>&amp;&amp; *</span><span>end </span><span>!= </span><span>&#39;\0&#39;</span><span>) {
</span><span>    </span><span>f__kMeGently(with_a_chainsaw)</span><span>;
</span><span>}
</span></code></pre>
<p>And that there is the <em>bare minimum</em> amount that you have to do in order to use
strtol safely. This is, and I can&#39;t stress this enough, a <em>horrible</em> interface.
Is there anything in there that&#39;s better? Well, if you&#39;re on <strong>BSD</strong> then the
OpenBSD folks had your back in 2004 with the release of OpenBSD 3.6, which came
with the shiny new <code>strtonum</code> function, which is itself just a wrapper around
the awful interface described above that is much more usable and, dare I say it,
sane? But alas, as with many things BSD even when thay do something that is
obviously better than Linux it just never really gets adopted there. And that
company from Redmond? Well they&#39;ve been happily overflowing buffers with C++ for
some decades now and are too busy patching and force-rebooting to have noticed
something that happened in a hobbyist operating system 18 years ago. It&#39;s not in
the POSIX standard. It made it into the other BSD&#39;s, and into
<a href="https://libbsd.freedesktop.org/wiki/">libbsd</a>, but unless you want to make your
C code non-portable best to not use it. Also, did I mention that it&#39;s just a
wrapper around that crap function <code>strtoll</code> to begin with? Have I mentioned that
<strong>BSD</strong> libc is in every way superior to glibc? But I digress..</p>
<h2 id="is-this-an-outlier">Is this an outlier?</h2>
<p>No. This is the sort of thing that <strong>C</strong> programmers have been living with for
decades. There are plenty of other examples. I don&#39;t, per se, dislike <strong>C</strong> so
much as I dislike the cruft that&#39;s accumulated around it and the fact that libc
looks and feels very much like it was hacked together by a bunch of random dudes
over the course of a few decades rather than being designed. Which is, of course,
exactly what happened. I have some other complaints about C that revolve around
the lack of any kind of official error handling strategy, the issue of <code>null</code> in
general, etc but what it really comes down to is that if we keep the language we
should at the very least modernize libc and standardize the other tooling around
the language somewhat.</p>
<p>This is turning into something that I don&#39;t think should be just one post. So I
think that it&#39;s probably time to call it for tonight, mark this as a part one and
pick things back up around the concept of language tooling in another post.</p>

  <p><span>2022-01-16</span>
</p></div>

        </dic></div></div>
  </body>
</html>
