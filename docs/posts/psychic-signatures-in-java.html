<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/">Original</a>
    <h1>Psychic Signatures in Java</h1>
    
    <div id="readability-page-1" class="page"><article id="post-3721">
	<!-- .entry-header -->

	
	
	<div>
		
<p>The long-running BBC sci-fi show <a href="https://en.wikipedia.org/wiki/Doctor_Who"><em>Doctor Who</em></a> has a recurring plot device where the Doctor manages to get out of trouble by showing an identity card which is actually completely blank. Of course, this being Doctor Who, the card is really made out of a special “<a href="https://tardis.fandom.com/wiki/Psychic_paper">psychic paper</a>“, which causes the person looking at it to see whatever the Doctor wants them to see: a security pass, a warrant, or whatever.</p>



<figure><a href="https://tardis.fandom.com/wiki/Psychic_paper?file=Psychic_paper_DW_Shakespeare_Code.jpg"><img loading="lazy" data-attachment-id="3723" data-permalink="https://neilmadden.blog/psychic_paper_dw_shakespeare_code/" data-orig-file="https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg" data-orig-size="700,401" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;1&#34;}" data-image-title="psychic_paper_dw_shakespeare_code" data-image-description="" data-image-caption="" data-medium-file="https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=300" data-large-file="https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=700" src="https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=700" alt="Doctor Who holding up a blank ID card with a badly superimposed image of Duke (the Java mascot) holding a glass of wine." width="630" height="360" srcset="https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=628 628w, https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=150 150w, https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg?w=300 300w, https://neilmadden.files.wordpress.com/2022/04/psychic_paper_dw_shakespeare_code.jpg 700w" sizes="(max-width: 709px) 85vw, (max-width: 909px) 67vw, (max-width: 984px) 61vw, (max-width: 1362px) 45vw, 600px"/></a><figcaption>“Looks legit to me. <a href="https://images.app.goo.gl/1cgL8VJRpaAGaEnm9">Hic!</a>“</figcaption></figure>



<p>It turns out that some recent releases of Java were vulnerable to a similar kind of trick, in the implementation of widely-used <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">ECDSA</a> signatures. If you are running one of the vulnerable versions then an attacker can easily forge some types of SSL certificates and handshakes (allowing interception and modification of communications), <a href="https://jwt.io/">signed JWTs</a>, <a href="https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language">SAML assertions</a> or <a href="https://en.wikipedia.org/wiki/OpenID#OpenID_Connect_(OIDC)">OIDC id tokens</a>, and even <a href="https://webauthn.guide/">WebAuthn</a> authentication messages. All using the digital equivalent of a blank piece of paper.</p>



<p>It’s hard to overstate the severity of this bug. If you are using ECDSA signatures for any of these security mechanisms, then an attacker can <em>trivially and completely bypass them</em> if your server is running any Java 15, 16, 17, or 18 version before the <a href="https://www.oracle.com/security-alerts/cpuapr2022.html">April 2022 Critical Patch Update (CPU)</a>. For context, almost all WebAuthn/FIDO devices in the real world (including Yubikeys<a href="#footnote-1">*</a>) use ECDSA signatures and many OIDC providers use ECDSA-signed JWTs.</p>



<p><strong>If you have deployed Java 15, Java 16, Java 17, or Java 18 in production then you should stop what you are doing and immediately update to install the fixes in the <a href="https://www.oracle.com/security-alerts/cpuapr2022.html">April 2022 Critical Patch Update</a>.</strong></p>



<p><strong>Update</strong>: the official announcement from Oracle also lists older versions of Java, including 7, 8 and 11. Although I’m not aware of the bug impacting those older implementations they did fix a similar bug in the (non-EC) DSA implementation at the same time, so it’s possible older versions are also impacted. There are also other security vulnerabilities reported in the same CPU, so (as always) it is worth upgrading even if you are running an older Java version. The <a href="https://openjdk.java.net/groups/vulnerability/advisories/2022-04-19">OpenJDK advisory</a> on the other hand lists only versions 15, 17, and 18 as affected by this specific issue (CVE-2022-21449).</p>



<p>Oracle have given this a CVSS score of 7.5, assigning no impact to Confidentiality or Availability. Internally, we at ForgeRock graded this <a href="https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H">a perfect 10.0</a> due to the wide range of impacts on different functionality in an access management context. ForgeRock customers can <a href="https://backstage.forgerock.com/knowledge/kb/article/a90257583">read our advisory about this issue</a> for further guidance.</p>



<h2>Background: ECDSA signatures</h2>



<p>ECDSA stands for the <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Elliptic Curve Digital Signature Algorithm</a>, and it is a widely used standard for signing all kinds of digital documents. Compared to the older RSA standard, elliptic curve keys and signatures tend to be much smaller for equivalent security, resulting in them being widely used in cases where size is at a premium. For example, the WebAuthn standard for two-factor authentication allows device manufacturers to choose from a wide range of signature algorithms, but in practice almost all of the devices manufactured to date support ECDSA signatures only (a notable exception being Windows Hello, which uses RSA signatures; presumably for compatibility with older <a href="https://support.microsoft.com/en-us/topic/what-is-tpm-705f241d-025d-4470-80c5-4feeb24fa1ee">TPM</a> hardware).</p>



<p>Without getting too much into the technical details, an ECDSA signature consists of two values, called <em>r</em> and <em>s</em>. To <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm#Signature_verification_algorithm">verify an ECDSA signature</a>, the verifier checks an equation involving <em>r</em>, <em>s</em>, the signer’s public key, and a hash of the message. If the two sides of the equation are equal then the signature is valid, otherwise it is rejected. </p>



<p>One side of the equation is <em>r</em> and the other side is multiplied by <em>r </em>and a value derived from <em>s</em>. So it would obviously be a really bad thing if <em>r</em> and <em>s</em> were both 0, because then you’d be checking that 0 = 0 ⨉ <em>[a bunch of stuff]</em>, which will be true regardless of the value of <em>[a bunch of stuff]</em>! And that bunch of stuff is the important bits like the message and the public key. This is why the very first check in the ECDSA verification algorithm is to ensure that <em>r</em> and <em>s</em> are both &gt;= 1.</p>



<p>Guess which check Java forgot?</p>



<p>That’s right. Java’s implementation of ECDSA signature verification didn’t check if r or s were zero, so you could produce a signature value in which they are both 0 (<a href="https://en.wikipedia.org/wiki/ASN.1">appropriately encoded</a>) and Java would accept it as a valid signature for any message and for any public key. The digital equivalent of a blank ID card.</p>



<p>Here’s an interactive jshell session showing the vulnerable implementation accepting a completely blank signature as valid for an arbitrary message and public key:</p>



<pre><code>|  Welcome to JShell -- Version 17.0.1
|  For an introduction type: /help intro
jshell&gt; <strong>import java.security.*</strong>
jshell&gt; <strong>var keys = KeyPairGenerator.getInstance(&#34;EC&#34;).generateKeyPair()</strong>
keys ==&gt; java.security.KeyPair@626b2d4a
jshell&gt; <strong>var blankSignature = new byte[64]</strong>
blankSignature ==&gt; byte[64] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ... , 0, 0, 0, 0, 0, 0, 0, 0 }
jshell&gt; <strong>var sig = Signature.getInstance(&#34;SHA256WithECDSAInP1363Format&#34;)</strong>
sig ==&gt; Signature object: SHA256WithECDSAInP1363Format&lt;not initialized&gt;
jshell&gt; <strong>sig.initVerify(keys.getPublic())</strong>
jshell&gt; <strong>sig.update(&#34;Hello, World&#34;.getBytes())</strong>
jshell&gt; <strong>sig.verify(blankSignature)</strong>
$8 ==&gt; true
// Oops, that shouldn&#39;t have verified...</code></pre>



<p>Note that the “InP1363Format” qualifier just makes it easier to demonstrate the bug. Signatures in ASN.1 DER format can be exploited in the same way, you just have to do a bit more fiddling with the encoding first, but note that JWTs and other formats do use the raw IEEE P1363 format.</p>



<h3>A few technical details</h3>



<p>If you go and look at the fine details of ECDSA on wikipedia, you’ll see that the right hand side of the equation is not multiplied by <em>s</em> but rather by its multiplicative inverse: <em>s</em><sup>-1</sup>. If you know a little maths, you may be thinking “won’t calculating this inverse result in a division by zero?” But in elliptic curve cryptography, this inverse is being calculated modulo a large number, <em>n</em>, and for the curves typically used in ECDSA, <em>n</em> is a prime number so we can use the <a href="https://en.wikipedia.org/wiki/Fermat&#39;s_little_theorem">Little Theorem</a> of Fermat (vandalizer of margins) to calculate the modular inverse:</p>



<p>x<sup>n</sup> = x<sup>1</sup> = x           (mod n)</p>



<p>This is very efficient, and it’s <a href="https://github.com/openjdk/jdk/blob/ec205f68a883cef6b98f26a06baf675f7da26928/src/java.base/share/classes/sun/security/util/math/IntegerModuloP.java#L158">exactly what Java does</a>. However, it is only valid for when x is not zero, as zero doesn’t have a multiplicative inverse. When x is zero then 0<sup>(n-2)</sup> = 0: garbage in, garbage out.</p>



<p>The fact that arithmetic is carried out modulo <em>n</em> is also why you need to check that <em>r</em> and <em>s</em> are both &lt;<em> n</em> too, because <em>n</em> = 0 (mod n) so setting<em> r</em> or <em>s</em> to <em>n</em> would have the same effect as setting them to 0.</p>



<p>Another check that should’ve saved Java is the check described in step 5 of the verification algorithm on Wikipedia: checking that a point calculated from <em>r</em> and <em>s</em> is not the “point at infinity”. If <em>r</em> and <em>s</em> are both zero, then the resulting point will in fact be the point at infinity and so this check will fail. But again, Java failed to perform this check.</p>



<h2>Why did you just find this now?</h2>



<p>You may be wondering why this is just coming to light now, when Java has had ECDSA support for a long time. Has it always been vulnerable?</p>



<p>No. This is a relatively recent bug introduced by a rewrite of the EC code from native C++ code to Java, <a href="https://bugs.openjdk.java.net/browse/JDK-8237218">which happened in the Java 15 release</a>. Although I’m sure that this rewrite has benefits in terms of memory safety and maintainability, it appears that experienced cryptographic engineers have not been involved in the implementation. The original C++ implementation<a href="https://github.com/openjdk/jdk/blob/jdk-15-ga/src/jdk.crypto.ec/share/native/libsunec/impl/ec.c#L956"> is not vulnerable to these bugs</a>, but the rewrite was. Neither implementation appears to have very good test coverage, and even the most cursory reading of the ECDSA spec would surely suggest testing that invalid r and s values are rejected. I am not at all confident that other bugs aren’t lurking in this code.</p>



<h2>What should we do about it?</h2>



<p>First of all, if you are using Java 15 or later then please go and update to the latest version to get the fix for this issue.</p>



<p>In general, cryptographic code is very tricky to implement correctly and public key signature algorithms are some of the trickiest. ECDSA is itself one of the most fragile algorithms, where <a href="https://eprint.iacr.org/2020/615">even a tiny amount of bias in one random value can allow complete recovery of your private key</a>. On the other hand, we now have excellent resources like <a href="https://github.com/google/wycheproof">Project Wycheproof</a> that provide test cases for known vulnerabilities. After I found this bug I updated a local copy of Wycheproof to run against Java 17 – it found this issue immediately. Hopefully the JDK team will adopt the Wycheproof test suite themselves to avoid any similar bugs slipping through the net in future.</p>



<p>If you are designing a protocol or application that you think needs to use digital signatures, consider if you really do – would a simpler mechanism work instead? Simple MAC algorithms like <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a> are incredibly hard to mess up compared to signature schemes. If you really need a signature then consider using a modern algorithm like <a href="https://www.rfc-editor.org/rfc/rfc8032.html">EdDSA</a> that avoids some of the pitfalls of ECDSA.</p>



<h2>Timeline</h2>



<p><em>11 Nov 2021</em> – Issue found and disclosed to OpenJDK vulnerability report email address.</p>



<p><em>11</em> <em>Nov 2021</em> – Determined <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=JDK-8237218">JDK change</a> that introduced the bug in Java 15.</p>



<p><em>12 Nov 2021</em> – Initial acknowledgement from Oracle.</p>



<p><em>18 Nov 2021</em> – Oracle confirms the bug and indicates it will be patched in a future Critical Patch Update (CPU). It is assigned tracking ID S1559193.</p>



<p><em>18 Nov 2021</em> – ForgeRock <a href="https://backstage.forgerock.com/knowledge/kb/article/a90257583">issues a security advisory</a> informing our customers not to deploy affected versions of Java into production.</p>



<p><em>14 Jan 2022</em> – Ask Oracle for status update. Told that the fix is targeting the April 2022 CPU, scheduled for 19th April.</p>



<p><em>25 Mar 2022</em> – Confirm again with Oracle that the fix will be in April CPU. Inform them that ForgeRock will proceed to full disclosure if the bug is not fixed by then.</p>



<p><em>19 Apr 2022</em> – Fix released by Oracle in April CPU.</p>



<p><em>19 Apr 2022</em> – Article published.</p>





<div>
	<!-- .author-avatar -->

	<div>
		

		<p>
			Security Architect at ForgeRock. Experienced software engineer with a PhD in computer science. Interested in application security, applied cryptography, logic programming and intelligent agents.			<a href="https://neilmadden.blog/author/neilmadden/" rel="author">
				View all posts by Neil Madden			</a>
		</p><!-- .author-bio -->
	</div><!-- .author-description -->
</div><!-- .author-info -->
	</div><!-- .entry-content -->

	<!-- .entry-footer -->
</article></div>
  </body>
</html>
