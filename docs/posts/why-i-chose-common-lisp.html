<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.djhaskin.com/blog/why-i-chose-common-lisp/">Original</a>
    <h1>Why I Chose Common Lisp</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            <h2 id="goodbye-clojure">Goodbye, Clojure</h2>
<p>After ~7 years, I was <em>done</em> with <a href="https://clojure.org/">Clojure</a>. I was writing a some
<a href="https://github.com/djha-skin/degasolv">CLI</a>
<a href="https://github.com/djha-skin/zic">apps</a>, and I <em>hated</em> how long they took to
start up. The community at large seemed not to care about this problem, except
for the <a href="https://github.com/babashka/babashka">babashka</a> folks. However, I spent
long, hard hours banging my head against
<a href="https://www.graalvm.org/latest/reference-manual/native-image/">native-image</a>
and it just wasn&#39;t working out. It was incredibly painful, and at the end of it,
I still didn&#39;t have standalone, fast-starting native executables. I decided that
that was a requirement for my main driving hobby language, and that Clojure didn&#39;t
have it. It was then that I decided to move on from Clojure.</p>
<h2 id="on-the-hunt-for-a-new-lisp">On the Hunt for a New Lisp</h2>
<p>I started shopping around for a new lisp to use after hours like I&#39;d done before
with my home projects. I had specific requirements in mind, though I didn&#39;t
actually list them when I started. I can list them now in hindsight, though:</p>
<ol>
<li>It must be easy to create standalone, fast-starting executables using a
   reasonable toolchain (to address my main concern with Clojure)</li>
<li><a href="https://blog.djhaskin.com/blog/emacs-users-im-okay-i-promise/">I can&#39;t use
   Emacs</a>, so
   it&#39;s got to be usable in Vim.</li>
<li>It must have good support for Windows and Mac, in addition just Linux/POSIX
   operating systems.</li>
<li>It would be nice if it allows plugging into some other, large-community
   imperative language, like Clojure does with Java.</li>
<li>It must have a reasonably fast runtime -- hopefully as good or better as
   Clojure&#39;s.</li>
<li>The language must have a strong multithreading story. It would be grand if
   whatever language it was didn&#39;t have a
   <a href="https://en.wikipedia.org/wiki/Global_interpreter_lock">GIL</a>, for example.</li>
<li>Must have a strong community.</li>
<li>Must have a good ecosystem, with at least the following libraries
   well-implemented, thus supporting my common use cases of making CLI tools:<ol>
<li>JSON parsing and serialization</li>
<li>Sqlite3 support</li>
<li>HTTP requests library </li>
<li>Would be nice if it had functional data structures like Clojure&#39;s (this
   ended up being less of an issue later)</li>
</ol>
</li>
</ol>
<p>I looked at <a href="https://www.scheme.org/">Scheme</a>, but that community seemed to
still be fractured over the
<a href="https://elmord.org/blog/?entry=20171001-r6rs-r7rs">r6rs</a>/<a href="https://groups.google.com/g/scheme-reports-wg2/c/xGd0_eeKmGI/m/q-xM5fbuAQAJ?pli=1">r7rs</a>
mess. Also, there wasn&#39;t <a href="https://akkuscm.org/packages/">a big enough ecosystem</a>
to suit my liking.</p>
<p>I&#39;d already tried <a href="https://racket-lang.org/">Racket</a> in school and didn&#39;t like it. The runtime was a bit
slow and bloated for my tastes.</p>
<p>I had seen <a href="https://lisp-lang.org/">lisp-lang.org</a> shared on <a href="https://news.ycombinator.com/item?id=28725958">the Orange
Site</a>. I was impressed with the
site. I came back to it later after I first saw it and thought, why not. Maybe
I&#39;ll give Common Lisp a shot.</p>
<h2 id="magic-happens-here">Magic Happens Here</h2>
<p>I will spare the reader the full narrative of my learning CL.
It was a rough ride learning the language. (I went about it the wrong way,
getting
<a href="https://www.amazon.com/Common-LISP-Language-Second-Steele/dp/1555580416/ref=sr_1_1?crid=2W8Y093RT5UQN&amp;dib=eyJ2IjoiMSJ9.ZDcuOzchQwO4txmVOLrlDRGU3K0TMYMsM0OMVdMocZUW_Wj2K3YYFfB8bATRFvKaR-Vz-P1ai5hpSAzE1q6Ii1FwQK7zu1d8vn3qa88EQCipfnbJoYsHbiNQKbl8NJBhuhZu410r8KXjyJNjG_gvC7r9TX_PSp6VDNLcalMgo4g9xI7m52SnG1BOdFxZ44tmKdn97DKpv0Oqw9ngYg_dDm5_6MUuPan0hPrbrMKcp58.H5QKWhJtzda3Xl9dXb_siYXClmIBIseqGTy3IKAkN-0&amp;dib_tag=se&amp;keywords=common+lisp+the+language&amp;qid=1736648071&amp;sprefix=common+lisp+the+language+%2Caps%2C146&amp;sr=8-1">CLtLv2</a>
for Christmas and reading through that. I eventually found the
<a href="https://clhs.lisp.se">HyperSpec</a> and started reading that as well.)</p>
<p>There were some weird things I didn&#39;t expect to find about CL. It&#39;s a
<em>standardized</em> language, more like C than Java that way. There are many
compilers, interpreters, and runtimes that implement that standard. There&#39;s even
<a href="https://github.com/roswell/roswell">a tool to help install them all and wrangle
them</a>. The most popular one <a href="https://blog.djhaskin.com/blog/common-lisp-community-survey-2024-results/">according to
the
community</a>
is <a href="https://www.sbcl.org/">SBCL</a>.</p>
<p>If I had heard about <a href="https://janet-lang.org/">Janet</a> when starting this hunt,
I might have stopped there and not gone on to CL. Nice syntax, small, fast
executables, <a href="https://janet-lang.org/docs/ffi.html">C FFI</a>, <a href="https://janet.guide/">a fun intro
book</a>. It checks all my boxes.</p>
<p>However, I&#39;m glad I did learn CL first, because I think I&#39;d miss the
<a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System">CLOS</a> and the
Conditions System, things I learned about later in my journey. Common Lisp is
just a bit of a stronger language.</p>
<h2 id="requirements-met">Requirements Met</h2>
<p>I found answers to all my questions, and decided my next lisp was going to be
Common Lisp. I&#39;ve been coding in it ever since. Here are the things I found:</p>
<ol>
<li><strong>Standalone Executables</strong>: there are lots of ways to do this in Common Lisp. I
   summarize my favorite way in <a href="https://blog.djhaskin.com/blog/release-common-lisp-on-your-first-day/">another blog
   post</a>.
   Start up times range from a fraction of a second to nearly instant, depending
   on if you compile the executable with compression or not. This is not a
   bolt-on feature; it&#39;s a first-class-citizen way to distribute Lisp programs.</li>
<li><strong>Vim Workflow</strong>: There are a lot of good ones here, but I eventually settled
   into <a href="https://blog.djhaskin.com/blog/developing-common-lisp-using-vim-with-tmux-or-conemu/">a Vim workflow of my
   own</a>.
   Readers may also be interested to know that <a href="https://blog.djhaskin.com/blog/experience-report-using-vs-code-alive-to-write-common-lisp/">I found VS Code perfectly
   usable</a>
   as a Common Lisp IDE.</li>
<li><strong>Windows/Mac/Linux Support</strong>: SBCL, a popular implementation and compiler for
   Common Lisp, supports The Big Three relatively well, as outlined in the
   blog post linked in point #1.</li>
<li><strong>Larger Imperative Ecosystem</strong>: Most implementations actually hook into the C
   programming language pretty well through the
   <a href="http://common-lisp.net/project/cffi">CFFI</a>. That works for me.</li>
<li><strong>Runtime Speed</strong>: SBCL is <a href="https://github.com/niklas-heer/speed-comparison">crazy
   fast</a>.</li>
<li><strong>Multithreading</strong>: While the Common Lisp standard does not make provisions
   for multithreading, all major implementations do support it and their
   differences are papered over with a library called
   <a href="https://sionescu.github.io/bordeaux-threads/">Bordeaux-Threads</a>. This
   library serves as an underpinning for the
   <a href="https://github.com/lmj/lparallel">lparallel</a> library, an excellent library
   for multithreading. There&#39;s also <a href="https://orthecreedence.github.io/cl-async/">cl-async</a> and <a href="https://orthecreedence.github.io/blackbird/">blackbird</a> for
   asynchronous programming and promises, respectively.</li>
<li><strong>Strong Community</strong>: I discovered the community as I did the rest of the
   language -- in fits and starts. A good summary of the community (as it was in
   2024) is summarized in the <a href="https://blog.djhaskin.com/blog/common-lisp-community-survey-2024-results/">Common Lisp Community Survey
         2024</a>.
         CL features prominently at the <a href="https://www.european-lisp-symposium.org/">European Lisp
         Symposium</a>. CL has a strong
         <a href="https://planet.lisp.org/">blogosphere</a> and
         <a href="https://www.reddit.com/r/Common_Lisp/">subreddit</a>.</li>
<li><strong>Ecosystem</strong>: The ecosystem is pretty great. Most folks use
   <a href="https://www.quicklisp.org/beta/">Quicklisp</a>, though I use
   <a href="https://github.com/ocicl/ocicl/releases">OCICL</a> for package management. The
   <a href="https://lispcookbook.github.io/cl-cookbook/">Common Lisp Cookbook</a>, the
   <a href="https://www.cliki.net">CLiki</a>, and <a href="https://github.com/CodyReichert/awesome-cl">Awesome
   CL</a> provide
   nice survey of available libraries and techniques. Here
   are some answers to those particular libary queries I had:<ol>
<li><strong>JSON</strong>: <a href="https://github.com/Zulu-Inuoe/jzon">jzon</a></li>
<li><strong>Sqlite3</strong>: <a href="https://cl-sqlite.common-lisp.dev/">cl-sqlite</a></li>
<li><strong>HTTP requests</strong>: <a href="https://github.com/fukamachi/dexador">dexador</a></li>
<li><strong>Functional Datastructures</strong>: <a href="https://fset.common-lisp.dev/">FSet</a>, <a href="https://github.com/danshapero/cl-hamt">cl-hamt</a></li>
</ol>
</li>
</ol>
<h2 id="new-friends-take-note">New Friends Take Note</h2>
<p>I wrote this blog post because I noticed that there have been more newcomers on
the <a href="https://discord.gg/HsxkkvQ">Common Lisp Discord</a> and they&#39;ve been asking the same questions I was
when I was first looking at the language. I wanted to lay down a bit of history
around why I came to Common Lisp, and how I acclimated to the language. I hope
it may be helpful to those new to or curious about Common Lisp.</p>
        </div></div>
  </body>
</html>
