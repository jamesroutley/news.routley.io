<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://googleprojectzero.blogspot.com/2024/10/from-naptime-to-big-sleep.html">Original</a>
    <h1>Using Large Language Models to Catch Vulnerabilities</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-7012551859253957583" itemprop="description articleBody">

 <p><span>Posted by the </span><span><a href="#bigsleepteam">Big Sleep team</a></span></p>
 <p><span>Introduction</span></p>
 <p><span>In our previous post, </span><span><a href="https://googleprojectzero.blogspot.com/2024/06/project-naptime.html">Project Naptime: Evaluating Offensive Security Capabilities of Large Language Models</a></span><span>, we introduced our framework for large-language-model-assisted vulnerability research and demonstrated its potential by improving the state-of-the-art performance on Meta&#39;s CyberSecEval2 benchmarks. Since then, Naptime has evolved into Big Sleep, a collaboration between Google Project Zero and Google DeepMind.</span></p>
 <p><span>Today, we&#39;re excited to share the first real-world vulnerability discovered by the Big Sleep agent</span><span>: an exploitable stack buffer underflow in </span><span><a href="https://sqlite.org/">SQLite</a></span><span>, a widely used open source database engine. We discovered the </span><span><a href="https://project-zero.issues.chromium.org/issues/372435124">vulnerability</a></span><span> and reported it to the developers in early October, who </span><span><a href="https://sqlite.org/src/info/41d58a014ce89356">fixed it</a></span><span> on the same day. Fortunately, we found this issue </span><span>before it appeared in an official release, so SQLite users were not impacted</span><span>.</span></p>
 <p><span>We believe this is the first public example of an AI agent finding a previously unknown exploitable memory-safety issue in widely used real-world software. Earlier this year at the DARPA AIxCC event, Team Atlanta </span><span><a href="https://team-atlanta.github.io/blog/post-asc-sqlite/">discovered a null-pointer dereference</a></span><span> in SQLite, which inspired us to use it for our testing to see if we could find a more serious vulnerability.</span></p>
 <p><span>We think that this work has tremendous defensive potential. Finding vulnerabilities in software before it&#39;s even released, means that there&#39;s no scope for attackers to compete: the vulnerabilities are fixed before attackers even have a chance to use them. Fuzzing has helped significantly, but we need an approach that can help defenders to find the bugs that are difficult (or impossible) to find by fuzzing, and we&#39;re hopeful that AI can narrow this gap. We think that this is a promising path towards finally turning the tables and achieving an asymmetric advantage for defenders.</span></p>
 <p><span>The vulnerability itself is quite interesting, along with the fact that the existing testing infrastructure for SQLite (both through OSS-Fuzz, and the project&#39;s own infrastructure) did not find the issue, so we did some further investigation.</span></p>
 <p><span>Methodology</span></p>
 <p><span>A key motivating factor for Naptime and now for Big Sleep has been the </span><span><a href="https://blog.google/threat-analysis-group/0-days-exploited-wild-2022/%23:~:text%3DOver%252040%2525%2520of%2520the%25200%252Ddays%2520discovered%2520were%2520variants%2520of%2520previously%2520reported%2520vulnerabilities">continued in-the-wild discovery</a></span><span> of exploits for variants of previously found and patched vulnerabilities. As this trend continues, it&#39;s clear that fuzzing is not succeeding at catching such variants, and that for attackers, manual variant analysis is a cost-effective approach.</span></p>
 <p><span>We also feel that this variant-analysis task is a better fit for current LLMs than the more general open-ended vulnerability research problem. By providing a starting point – such as the details of a previously fixed vulnerability – we remove a lot of ambiguity from vulnerability research, and start from a concrete, well-founded theory: &#34;This was a previous bug; there is probably another similar one somewhere&#34;.</span></p>
 <p><span>Our project is still in the research stage, and we are currently using small programs with known vulnerabilities to evaluate progress. Recently, we decided to put our models and tooling to the test by running our first extensive, real-world variant analysis experiment on SQLite. We collected a number of recent commits to the SQLite repository, manually removing trivial and documentation-only changes. We then adjusted the prompt to provide the agent with both the commit message and a diff for the change, and asked the agent to review the current repository (at </span><span><a href="https://sqlite.org/src/info/2f7eab381e167609">HEAD</a></span><span>) for related issues that might not have been fixed.</span></p>
 <p><span>Discovered Vulnerability</span></p>
 <p><span>The vulnerability is an interesting one where a special sentinel value </span><span>-1</span><span> is used in an (otherwise) index-typed field </span><span>iColumn</span><span>:</span></p>
 <p><span></span><span>7476:</span><span>   </span><span>struct</span><span> </span><span>sqlite3_index_constraint</span><span> </span><span>{</span></p>
 <p><span>7477:</span><span>      </span><span>int</span><span> </span><span>iColumn;</span><span>              </span><span>/*</span><span> </span><span>Column</span><span> </span><span>constrained.</span><span>  </span><span>-1</span><span> </span><span>for</span><span> </span><span>ROWID</span><span> </span><span>*/</span></p>
 <p><span>7478:</span><span>      </span><span>unsigned</span><span> </span><span>char</span><span> </span><span>op;</span><span>         </span><span>/*</span><span> </span><span>Constraint</span><span> </span><span>operator</span><span> </span><span>*/</span></p>
 <p><span>7479:</span><span>      </span><span>unsigned</span><span> </span><span>char</span><span> </span><span>usable;</span><span>     </span><span>/*</span><span> </span><span>True</span><span> </span><span>if</span><span> </span><span>this</span><span> </span><span>constraint</span><span> </span><span>is</span><span> </span><span>usable</span><span> </span><span>*/</span></p>
 <p><span>7480:</span><span>      </span><span>int</span><span> </span><span>iTermOffset;</span><span>          </span><span>/*</span><span> </span><span>Used</span><span> </span><span>internally</span><span> </span><span>-</span><span> </span><span>xBestIndex</span><span> </span><span>should</span><span> </span><span>ignore</span><span> </span><span>*/</span></p>
 <p><span>7481:</span><span>   </span><span>}</span><span> </span><span>*aConstraint;</span><span>            </span><span>/*</span><span> </span><span>Table</span><span> </span><span>of</span><span> </span><span>WHERE</span><span> </span><span>clause</span><span> </span><span>constraints</span><span> </span><span>*/</span></p>
 
 <p><span>This pattern creates a potential edge-case that needs to be handled by all code that uses the field, since the expectation would be that a valid column index is non-negative.</span></p>
 <p><span>The function </span><span><a href="https://sqlite.org/src/file?ci=2f7eab381e167609&amp;name=ext/misc/series.c&amp;ln=578-778">seriesBestIndex</a></span><span> failed to correctly handle this edge-case, resulting in a write into a stack buffer with a negative index when handling a query with a constraint on the </span><span>rowid</span><span> column. In the build that we provided to our agent, debug assertions were enabled, and this condition was checked by the assertion at line </span><span><a href="https://sqlite.org/src/file?ci=2f7eab381e167609&amp;name=ext/misc/series.c&amp;ln=706">706</a></span><span>:</span></p>
 <p><span></span><span>619</span><span> </span><span>static</span><span> </span><span>int</span><span> </span><span>seriesBestIndex(</span></p>
 <p><span>620</span><span>   </span><span>sqlite3_vtab</span><span> </span><span>*pVTab,</span></p>
 <p><span>621</span><span>   </span><span>sqlite3_index_info</span><span> </span><span>*pIdxInfo</span></p>
 <p><span>622</span><span> </span><span>){</span></p>
 <p><span>...</span></p>
 <p><span>630</span><span>   </span><span>int</span><span> </span><span>aIdx[7];</span><span>           </span><span>/*</span><span> </span><span>Constraints</span><span> </span><span>on</span><span> </span><span>start,</span><span> </span><span>stop,</span><span> </span><span>step,</span><span> </span><span>LIMIT,</span><span> </span><span>OFFSET,</span></p>
 <p><span>631</span><span>                          </span><span>**</span><span> </span><span>and</span><span> </span><span>value.</span><span>  </span><span>aIdx[5]</span><span> </span><span>covers</span><span> </span><span>value=,</span><span> </span><span>value&gt;=,</span><span> </span><span>and</span></p>
 <p><span>632</span><span>                          </span><span>**</span><span> </span><span>value&gt;,</span><span>  </span><span>aIdx[6]</span><span> </span><span>covers</span><span> </span><span>value&lt;=</span><span> </span><span>and</span><span> </span><span>value&lt;</span><span> </span><span>*/</span></p>
 <p><span>633</span><span>   </span><span>const</span><span> </span><span>struct</span><span> </span><span>sqlite3_index_constraint</span><span> </span><span>*pConstraint;</span></p>
 <p><span>...</span></p>
 <p><span>642</span><span>   </span><span>for(i=0;</span><span> </span><span>i&lt;pIdxInfo-&gt;nConstraint;</span><span> </span><span>i++,</span><span> </span><span>pConstraint++){</span></p>
 <p><span>643</span><span>     </span><span>int</span><span> </span><span>iCol;</span><span>    </span><span>/*</span><span> </span><span>0</span><span> </span><span>for</span><span> </span><span>start,</span><span> </span><span>1</span><span> </span><span>for</span><span> </span><span>stop,</span><span> </span><span>2</span><span> </span><span>for</span><span> </span><span>step</span><span> </span><span>*/</span></p>
 <p><span>644</span><span>     </span><span>int</span><span> </span><span>iMask;</span><span>   </span><span>/*</span><span> </span><span>bitmask</span><span> </span><span>for</span><span> </span><span>those</span><span> </span><span>column</span><span> </span><span>*/</span></p>
 <p><span>645</span><span>     </span><span>int</span><span> </span><span>op</span><span> </span><span>=</span><span> </span><span>pConstraint-&gt;op;</span></p>
 <p><span>...</span></p>
 <p><span>705</span><span>     </span><span>iCol</span><span> </span><span>=</span><span> </span><span>pConstraint-&gt;iColumn</span><span> </span><span>-</span><span> </span><span>SERIES_COLUMN_START;</span></p>
 <p><span>706</span><span>     </span><span>assert(</span><span> </span><span>iCol&gt;=0</span><span> </span><span>&amp;&amp;</span><span> </span><span>iCol&lt;=2</span><span> </span><span>);</span></p>
 <p><span>707</span><span>     </span><span>iMask</span><span> </span><span>=</span><span> </span><span>1</span><span> </span><span>&lt;&lt;</span><span> </span><span>iCol;</span></p>
 <p><span>...</span></p>
 <p><span>713</span><span>     </span><span>if(</span><span> </span><span>pConstraint-&gt;usable==0</span><span> </span><span>){</span></p>
 <p><span>714</span><span>       </span><span>unusableMask</span><span> </span><span>|=</span><span>  </span><span>iMask;</span></p>
 <p><span>715</span><span>       </span><span>continue;</span></p>
 <p><span>716</span><span>     </span><span>}else</span><span> </span><span>if(</span><span> </span><span>op==SQLITE_INDEX_CONSTRAINT_EQ</span><span> </span><span>){</span></p>
 <p><span>717</span><span>       </span><span>idxNum</span><span> </span><span>|=</span><span> </span><span>iMask;</span></p>
 <p><span>718</span><span>       </span><span>aIdx[iCol]</span><span> </span><span>=</span><span> </span><span>i;</span></p>
 <p><span>719</span><span>     </span><span>}</span></p>
 <p><span>720</span><span>   </span><span>}</span></p>
 
 <p><span>In a release build, however, this assertion is not present, and in our testing (this will vary depending on compiler and optimization level) the subsequent write at line </span><span><a href="https://sqlite.org/src/file?ci=2f7eab381e167609&amp;name=ext/misc/series.c&amp;ln=718">718</a></span><span> will write below the </span><span>aIdx</span><span> buffer, corrupting the least significant 32 bits of the </span><span>pConstraint</span><span> pointer, which will be dereferenced in the next iteration of the loop, leading to a likely exploitable condition.</span></p>
 <p><span>However, given this explanation of the vulnerability – it&#39;s not trivial (at least for us) as human researchers to understand precisely how to trigger it – clearly a constraint on the </span><span>ROWID</span><span> column would be a good starting point, but more detailed reading of the code would certainly be required. The agent already seems to know a lot more about SQLite than we do, so it can cut some corners!</span></p>
 <p><span>One common case of this is that the model would immediately use the </span><span>generate_series</span><span> virtual table when generating testcases. (We also saw cases where the model researched the available virtual tables first, but it&#39;s clearly able to apply pre-existing knowledge here). </span></p>
 <p><span>In this successful run based on Gemini 1.5 Pro, the seed commit was </span><span><a href="https://sqlite.org/src/info/1976c3f7e1fe77cf">[1976c3f7]</a></span><span>; which is a fairly large and non-obvious change. The bug found by our agent is only loosely related to the changes in the seed commit - this is not uncommon in manual variant analysis, understanding one bug in a codebase often leads a researcher to other problems.</span><span>italics </span><span>– all text in the </span><span>ASSISTANT</span><span> blocks comes directly from the agent.</span></p>
 <p><span>The agent produces a reasonable assessment of the changes in the diff, and uses this to form a starting point for research:</span></p>
 
 <p><span>ASSISTANT</span></p>
 <p><span><br/></span><span>The CL improves the handling of WHERE terms shared between OR branches in virtual table queries by introducing the </span><span>termFromWhereClause</span><span> function. This function retrieves a specific term from a WhereClause, considering nested clauses. Prior to this change, common terms were likely not handled correctly due to an incorrect mapping of term indices, potentially leading to inefficient query plans or incorrect results. The most likely vulnerability would involve incorrect handling of WHERE clause constraints within the </span><span>allocateIndexInfo</span><span> and </span><span>whereLoopAddVirtualOne</span><span> functions, where the CL has modified how constraint offsets are used with the new helper function. I&#39;ll first examine the </span><span>allocateIndexInfo</span><span> function.</span><span>. . .</span></p>
 
 <p><span>After a several (omitted) steps exploring the relevant code, the agent has formed a more concrete hypothesis and attempts to check it by running a modified version of the testcase from the patch, but this doesn&#39;t work since the testcase included in the patch relies on an extension that is not available in our configuration:</span></p>
 
 <p><span>TOOL</span><span>(debugger_run)</span></p>
 
 <p><span>The program exited without crashing or hitting the breakpoint. The exit code was 1.</span></p>
 <p><span>The output on STDERR was:</span></p>
 
 <p><span>Runtime error near line 2: no such module: tcl</span></p>
 <p><span>Parse error near line 3: no such table: x1</span><span><br/></span></p>
 <p><span><br/></span><span>ASSISTANT</span></p>
 <p><span><br/></span><span>The program terminated because the TCL module was not available. The tests rely on the TCL virtual table module, which needs to be enabled when compiling SQLite. The provided program input is based on the </span><span>bestindexC.test</span><span> file, which uses the TCL module to test virtual table best index selection.</span></p>
 
 <p><span>To fix this, the program input needs to be changed to use a different virtual table that does not require the TCL module. However, the vulnerability is related to virtual table query planning. So we still need a virtual table to trigger the issue.</span></p>
 
 <p><span>I will use the </span><span>code_browser_source</span><span> tool to search for examples of built-in virtual tables in SQLite. I&#39;ll then adapt the input to use one of these and set a breakpoint in </span><span>whereLoopAddVirtualOne</span><span> again.</span><span>. . .</span></p>
 
 <p><span>The agent adapts to this setback gracefully, recognises the steps it needs to take to fix the testcase, and a few steps later has retrieved all of the information it needs to build a testcase that reaches </span><span>whereLoopAddVirtualOne</span><span>:</span></p>
 
 <p><span>ASSISTANT</span></p>
 
 <p><span>The </span><span>sqlite3_create_module</span><span> function registers virtual table modules. The </span><span>shell.c</span><span> file contains several instances of this, including the </span><span>generate_series</span><span>, </span><span>fsdir</span><span>, </span><span>completion</span><span>, and </span><span>expert</span><span> modules. The json table also looks interesting. I&#39;ll focus on </span><span>generate_series</span><span> for now as a starting point. I&#39;ll try to craft a query that uses this module and might trigger incorrect constraint handling.</span></p>
 
 <p><span>. . .</span></p>
 <p><span><br/></span><span>Note above that during the original discovery and reproduction of the vulnerability, the agent was quite vague about the &#34;incorrect constraint handling&#34; that it&#39;s trying to trigger; and in this case the full trajectories read a little bit like a human researcher - starting out with one idea, thinking of a few other ones while investigating, and in the end producing a test case that reproduces a slightly different bug. In this case, when </span><span>whereLoopAddVirtualOne</span><span> is invoked on a </span><span>generate_series</span><span> table, we end  up in </span><span>seriesBestIndex</span><span>, where the constraint is indeed handled incorrectly.</span></p>
 <p><span>However, it&#39;s particularly interesting to see that once the program has crashed the model does a much better job of explaining things - while producing a root-cause analysis and a full crash report we can see the agent clearly crafting a testcase to trigger the specific, identified edge-case:</span><span><br/></span></p>
 <p><span>ASSISTANT</span></p>
 
 <p><span>The relevant field is </span><span>iColumn</span><span> inside the </span><span>sqlite3_index_constraint</span><span> struct. This field represents the column number of the constraint. To cause the assertion failure, we need a constraint on a column with index greater than </span><span>3</span><span> or smaller than </span><span>1</span><span>.</span></p>
 
 <p><span>Let&#39;s craft an SQL query that involves constraints on these columns. The </span><span>generate_series</span><span> table has columns named </span><span>value</span><span>, </span><span>start</span><span>, </span><span>step</span><span> and </span><span>stop</span><span>. The indexes are:</span></p>
 <p><span>- </span><span>value</span><span>: </span><span>0</span></p>
 <p><span>- </span><span>start</span><span>: </span><span>1</span></p>
 <p><span>- </span><span>step</span><span>: </span><span>2</span></p>
 <p><span>- </span><span>stop</span><span>: </span><span>3</span></p>
 
 <p><span>To trigger the bug, we can include a constraint on the ROWID. Constraints on the ROWID use </span><span>iColumn = -1</span><span>.</span></p>
 
 <p><span>Here is an example query:</span></p>
 
 <p><span>SELECT * FROM generate_series(1,10,1) WHERE ROWID = 1;</span></p>
 
 <p><span>This query should cause a crash in the </span><span>seriesBestIndex</span><span> function.</span><span>. . .</span></p>
 
 <p><span>At the end we get a clear and accurate summary of the issue that&#39;s almost ready to report directly!</span></p>
 <p><span>TOOL</span><span>(debugger_run)</span></p>
 
 <p><span>The program crashed: SIGABRT at :0.</span></p>
 <p><span>The output on STDERR was:</span></p>
 
 <p><span>sqlite3: src/shell.c:6816: int seriesBestIndex(sqlite3_vtab *, sqlite3_index_info *): Assertion `iCol&gt;=0 &amp;&amp;  iCol&lt;=2&#39; failed.</span></p>
 
 
 <p><span>ASSISTANT</span><span>(report_success)</span></p>
 <p><span></span><span>SELECT * FROM generate_series(1,10,1) WHERE ROWID = 1;</span><span> due to an assertion failure in function </span><span>seriesBestIndex</span><span>. </span><span>assert(iCol&gt;=0 &amp;&amp; iCol&lt;=2)</span><span> fails because the </span><span>iColumn</span><span> field in the </span><span>sqlite3_index_info</span><span> struct can contain values outside of the valid range for column indexes, such as </span><span>-1</span><span> when a constraint involves the ROWID.</span></p>
 
 <p><span>This leads to </span><span>iCol</span><span> being calculated as </span><span>-2</span><span>, causing the assertion to fail.</span></p>
 <h2 id="h.n8khgp4u0snd"><span>What about Fuzzing?</span></h2>
 <p><span>Given the apparent simplicity of the reproduction case, an obvious question arises: why wasn’t this bug discovered earlier by traditional fuzzing? The “simple” answer lies in the configuration of the fuzzing harnesses. The harness used by OSS-Fuzz isn&#39;t built with the </span><span>generate_series</span><span> extension enabled, and the alternative </span><span>fuzzingshell.c</span><span> harness contained an older version of the </span><span>seriesBestIndex</span><span> function, unaffected by the bug. Although the </span><span><a href="https://www.sqlite.org/afl/dir?ci=tip">SQLite AFL repo</a></span><span> contains a configuration for fuzzing the same CLI binary that we provided to the Big Sleep agent, it appears not to be widely used.</span></p>
 <p><span>To understand whether the bug is truly “shallow&#34;, we attempted to rediscover it through fuzzing. We followed the fuzzing instructions from the </span><span><a href="https://www.sqlite.org/afl/doc/trunk/README.md">SQLite documentation</a></span><span> and used the CLI target. We also verified that the fuzzing corpus contained the required </span><span>generate_series</span><span> and </span><span>rowid</span><span> keywords before launching an AFL run. However, the issue remained undiscovered after 150 CPU-hours of fuzzing.</span></p>
 <p><span>We then tried to simplify the task for the fuzzer by, for example, adding the necessary keywords to AFL&#39;s SQL dictionary. However, it seems the bug can only be quickly found if the corpus contains an example very close to the crashing input, as code coverage doesn&#39;t appear to be a reliable guide for this particular issue.</span></p>
 <p><span>Admittedly, AFL isn&#39;t the most suitable tool for a text-based format like SQL, where most inputs are syntactically invalid and will be rejected by the parser. Nevertheless, it&#39;s interesting to compare this result with </span><span><a href="https://lcamtuf.blogspot.com/2015/04/finding-bugs-in-sqlite-easy-way.html">Michal Zalewski’s blog post on fuzzing SQLite</a></span><span> from 2015. Back then, AFL was quite effective at uncovering bugs in SQLite; after years of fuzzing, it seems the tool has reached a natural saturation point. While our results so far seem minor in comparison to the dramatic step-change in effectiveness that came with the release of AFL, it&#39;s interesting to see that it has its own strengths and might be able to effectively uncover a </span><span>distinct</span><span> set of vulnerabilities.</span></p>
 <p><span>For the team this is a moment of validation and success - finding a vulnerability in a widely-used and well fuzzed open source project is </span><span>an exciting result! </span><span>When provided with the right tools, current LLMs can perform vulnerability research.</span></p>
 <p><span>However, we want to reiterate that these are highly experimental results</span><span>. The position of the Big Sleep team is that at present, it&#39;s likely that a target-specific fuzzer would be at least as effective (at finding vulnerabilities). </span></p>
 <p><span>We hope that in the future this effort will lead to a significant advantage to defenders - with the potential not only to find crashing testcases, but also to provide high-quality root-cause analysis, triaging and fixing issues could be much cheaper and more effective in the future. We aim to continue sharing our research in this space, keeping the gap between the public state-of-the-art and private state-of-the-art as small as possible. </span><span>The Big Sleep team will continue to work in this space, advancing Project Zero&#39;s mission of making 0-day hard.</span></p><h3 id="h.1tivp1wdbnt9"><span><a id="bigsleepteam">The Big Sleep Team</a></span></h3>
 <p><span>This isn&#39;t just a Project Zero effort any more, and everyone who has contributed to this effort is listed below</span><span> (names in alphabetical order)</span><span>:</span></p>
 <p><span>Miltos Allamanis, Martin Arjovsky, Charles Blundell, Lars Buesing, Mark Brand, Sergei Glazunov, Dominik Maier, Petros Maniatis, Guilherme Marinho, Henryk Michalewski, Koushik Sen, Charles Sutton, Vaibhav Tulsyan, Marco Vanotti, Theophane Weber, Dan Zheng</span></p>

</div></div>
  </body>
</html>
