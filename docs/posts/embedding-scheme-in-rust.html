<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raviqqe.com/doc/posts/stak/embedding-scheme-in-rust/">Original</a>
    <h1>Embedding Scheme in Rust</h1>
    
    <div id="readability-page-1" class="page"><article data-astro-cid-q7kxohas="">  
<p>Rust, as a compiled language, makes it challenging to modify the behavior of programs dynamically. In this article, we embed a small Scheme interpreter called <a href="https://github.com/raviqqe/stak">Stak Scheme</a> in Rust to dynamically change the behavior of a program without stopping the process.</p>
<p>You can find the following codes in this article at <a href="https://github.com/raviqqe/stak/tree/main/examples/hot-reload">the <code>examples/hot-reload</code> directory</a> in the Stak Scheme repository.</p>
<h2 id="table-of-contents"><a aria-hidden="true" tabindex="-1" href="#table-of-contents"><span></span></a>Table of contents</h2>
<ul>
<li><a href="#what-is-scheme">What is Scheme?</a></li>
<li><a href="#what-is-stak-scheme">What is Stak Scheme?</a></li>
<li><a href="#embedding-scheme-scripts-in-a-rust-program">Embedding Scheme scripts in a Rust program</a>
<ul>
<li><a href="#initializing-a-crate">Initializing a crate</a></li>
<li><a href="#adding-dependencies">Adding dependencies</a></li>
<li><a href="#preparing-the-http-server">Preparing the HTTP server</a></li>
<li><a href="#adding-a-build-script">Adding a build script</a></li>
<li><a href="#creating-an-http-request-handler-in-scheme">Creating an HTTP request handler in Scheme</a></li>
<li><a href="#hot-module-reloading">Hot module reloading</a></li>
</ul>
</li>
<li><a href="#conclusion">Conclusion</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#reference">Reference</a></li>
</ul>
<h2 id="what-is-scheme"><a aria-hidden="true" tabindex="-1" href="#what-is-scheme"><span></span></a>What is Scheme?</h2>
<p><a href="https://www.scheme.org/">Scheme</a> is a functional programming language and a Lisp dialect. It is known for its simple language specification and support of <a href="https://en.wikipedia.org/wiki/Continuation">the first-class continuation</a> as a language feature. <a href="https://small.r7rs.org/">The R7RS-small standard</a> is its latest specification available.</p>
<h2 id="what-is-stak-scheme"><a aria-hidden="true" tabindex="-1" href="#what-is-stak-scheme"><span></span></a>What is Stak Scheme?</h2>
<p><a href="https://github.com/raviqqe/stak">Stak Scheme</a> is a Scheme implementation compatible with <a href="https://small.r7rs.org/">the R7RS-small standard</a>. It is originally developed as a fork of <a href="https://github.com/udem-dlteam/ribbit">Ribbit Scheme</a>. Stak Scheme has the following features.</p>
<ul>
<li>A Scheme interpreter embeddable in Rust programs</li>
<li>Small memory footprint</li>
<li>Capability-based security
<ul>
<li>The Stak Scheme interpreter does not provide any external APIs (e.g. against operating systems) by default.</li>
<li>To enable such APIs for I/O, file systems, etc., you need to enable them on initialization of the interpreter’s virtual machines.</li>
</ul>
</li>
</ul>
<h2 id="embedding-scheme-scripts-in-a-rust-program"><a aria-hidden="true" tabindex="-1" href="#embedding-scheme-scripts-in-a-rust-program"><span></span></a>Embedding Scheme scripts in a Rust program</h2>
<p>In this example, we will write a program of an HTTP server in Rust and embed a Scheme script in it to change the behavior of the HTTP server dynamically.</p>
<h3 id="initializing-a-crate"><a aria-hidden="true" tabindex="-1" href="#initializing-a-crate"><span></span></a>Initializing a crate</h3>
<p>First, initialize the binary crate to create the HTTP server with the following command.</p>
<pre tabindex="0" data-language="sh"><code><span><span>cargo</span><span> init</span><span> http-server</span></span>
<span><span>cd</span><span> http-server</span></span></code></pre>
<h3 id="adding-dependencies"><a aria-hidden="true" tabindex="-1" href="#adding-dependencies"><span></span></a>Adding dependencies</h3>
<p>To add Stak Scheme as libraries to a Rust crate, execute the following commands in your terminal.</p>
<pre tabindex="0" data-language="sh"><code><span><span>cargo</span><span> add</span><span> stak</span></span>
<span><span>cargo</span><span> add</span><span> --build</span><span> stak-build</span></span>
<span><span>cargo</span><span> install</span><span> stak-compile</span></span></code></pre>
<p><a href="https://docs.rs/stak/">The <code>stak</code> crate</a> is a library that runs the Scheme interpreter from Rust. <a href="https://docs.rs/stak-build/">The <code>stak-build</code> crate</a> is a library that compiles Scheme scripts in <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code>build.rs</code> build scripts</a> (mentioned in the later section) so that you can embed them in Rust programs. The <code>stak-compile</code> command is a Scheme-to-bytecode compiler for Stak Scheme.</p>
<h3 id="preparing-the-http-server"><a aria-hidden="true" tabindex="-1" href="#preparing-the-http-server"><span></span></a>Preparing the HTTP server</h3>
<p>Next, let’s prepare an HTTP server written in Rust. In this example, we use Tokio’s HTTP library <a href="https://github.com/tokio-rs/axum"><code>axum</code></a>. First, add dependencies with the following commands.</p>
<pre tabindex="0" data-language="sh"><code><span><span>cargo</span><span> add</span><span> --features</span><span> rt-multi-thread</span><span> tokio</span></span>
<span><span>cargo</span><span> add</span><span> axum</span></span></code></pre>
<p>Then, add the following codes to <code>src/main.rs</code>.</p>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> axum</span><span>::</span><span>{</span><span>routing</span><span>::</span><span>post, serve, </span><span>Router</span><span>};</span></span>
<span><span>use</span><span> core</span><span>::</span><span>error</span><span>::</span><span>Error</span><span>;</span></span>
<span></span>
<span><span>#[tokio</span><span>::</span><span>main]</span></span>
<span><span>async</span><span> fn</span><span> main</span><span>() </span><span>-&gt;</span><span> Result</span><span>&lt;(), </span><span>Box</span><span>&lt;</span><span>dyn</span><span> Error</span><span>&gt;&gt; {</span></span>
<span><span>    serve</span><span>(</span></span>
<span><span>        tokio</span><span>::</span><span>net</span><span>::</span><span>TcpListener</span><span>::</span><span>bind</span><span>(</span><span>&#34;0.0.0.0:3000&#34;</span><span>)</span><span>.await?</span><span>,</span></span>
<span><span>        Router</span><span>::</span><span>new</span><span>()</span><span>.</span><span>route</span><span>(</span><span>&#34;/calculate&#34;</span><span>, </span><span>post</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>)),</span></span>
<span><span>    )</span></span>
<span><span>    .await?</span><span>;</span></span>
<span></span>
<span><span>    Ok</span><span>(())</span></span>
<span><span>}</span></span></code></pre>
<p>Send an HTTP request with the <code>curl</code> command to confirm that the server works correctly.</p>
<pre tabindex="0" data-language="sh"><code><span><span>cargo</span><span> run</span><span> &amp;</span></span>
<span><span>curl</span><span> -f</span><span> -X</span><span> POST</span><span> http://localhost:3000/calculate</span><span> # -&gt; Hello, world!</span></span>
<span><span>kill</span><span> %1</span></span></code></pre>
<h3 id="adding-a-build-script"><a aria-hidden="true" tabindex="-1" href="#adding-a-build-script"><span></span></a>Adding a build script</h3>
<p>Stak Scheme expects developers to add Scheme scripts with the <code>.scm</code> file extension in the <code>src</code> directory. Instead of embedding these script files directly in Rust programs, Stak Scheme compiles these files into <a href="https://en.wikipedia.org/wiki/Bytecode">bytecode</a> files first. To do so, add the following codes using the <code>stak-build</code> crate to the <code>build.rs</code> file.</p>
<pre tabindex="0" data-language="rust"><code><span><span>use</span><span> stak_build</span><span>::</span><span>{build_r7rs, </span><span>BuildError</span><span>};</span></span>
<span></span>
<span><span>fn</span><span> main</span><span>() </span><span>-&gt;</span><span> Result</span><span>&lt;(), </span><span>BuildError</span><span>&gt; {</span></span>
<span><span>    build_r7rs</span><span>()</span></span>
<span><span>}</span></span></code></pre>
<p>This will compile Scheme files into bytecode files stored in the <code>target</code> directory every time you run the <code>cargo build</code> command.</p>
<h3 id="creating-an-http-request-handler-in-scheme"><a aria-hidden="true" tabindex="-1" href="#creating-an-http-request-handler-in-scheme"><span></span></a>Creating an HTTP request handler in Scheme</h3>
<p>Next, add a Scheme script of an HTTP request handler in the <code>src</code> directory. Add the following codes to the <code>src/handler.scm</code> file.</p>
<pre tabindex="0" data-language="scheme"><code><span><span>(import</span></span>
<span><span>  (scheme base)</span></span>
<span><span>  (scheme read)</span></span>
<span><span>  (scheme write))</span></span>
<span></span>
<span><span>(</span><span>write</span><span> (</span><span>apply</span><span> +</span><span> (read)))</span></span></code></pre>
<p><code>read</code> is a procedure that parses an S-expression from the standard input. And, <code>write</code> is a procedure that writes out a value to the standard output. The <code>(apply + xs)</code> expression computes the sum of numbers in the list <code>xs</code>.</p>
<p>Next, to refer to and execute the script above from Rust, add the following codes to the <code>src/main.rs</code> file.</p>
<pre tabindex="0" data-language="rust"><code><span><span>// Other `use` statements...</span></span>
<span><span>use</span><span> axum</span><span>::</span><span>{</span><span>http</span><span>::</span><span>StatusCode</span><span>, response};</span></span>
<span><span>use</span><span> stak</span><span>::</span><span>{</span></span>
<span><span>    device</span><span>::</span><span>ReadWriteDevice</span><span>,</span></span>
<span><span>    file</span><span>::</span><span>VoidFileSystem</span><span>,</span></span>
<span><span>    include_module,</span></span>
<span><span>    module</span><span>::</span><span>{</span><span>Module</span><span>, </span><span>UniversalModule</span><span>},</span></span>
<span><span>    process_context</span><span>::</span><span>VoidProcessContext</span><span>,</span></span>
<span><span>    r7rs</span><span>::</span><span>{</span><span>SmallError</span><span>, </span><span>SmallPrimitiveSet</span><span>},</span></span>
<span><span>    time</span><span>::</span><span>VoidClock</span><span>,</span></span>
<span><span>    vm</span><span>::</span><span>Vm</span><span>,</span></span>
<span><span>};</span></span>
<span></span>
<span><span>// The `main` function, etc...</span></span>
<span></span>
<span><span>// Heap size for the Scheme interpreter.</span></span>
<span><span>const</span><span> HEAP_SIZE</span><span>:</span><span> usize</span><span> =</span><span> 1</span><span> &lt;&lt;</span><span> 16</span><span>;</span></span>
<span></span>
<span><span>// Import the Scheme script.</span></span>
<span><span>// This macro embeds bytecodes of the script in a resulting Rust program.</span></span>
<span><span>static</span><span> MODULE</span><span>:</span><span> UniversalModule</span><span> =</span><span> include_module!</span><span>(</span><span>&#34;handler.scm&#34;</span><span>);</span></span>
<span></span>
<span><span>async</span><span> fn</span><span> calculate</span><span>(input</span><span>:</span><span> String</span><span>) </span><span>-&gt;</span><span> response</span><span>::</span><span>Result</span><span>&lt;(</span><span>StatusCode</span><span>, </span><span>String</span><span>)&gt; {</span></span>
<span><span>    // Prepare buffers for in-memory stdout and stderr.</span></span>
<span><span>    let</span><span> mut</span><span> output </span><span>=</span><span> vec!</span><span>[];</span></span>
<span><span>    let</span><span> mut</span><span> error </span><span>=</span><span> vec!</span><span>[];</span></span>
<span></span>
<span><span>    run_scheme</span><span>(</span></span>
<span><span>        &amp;</span><span>MODULE</span><span>.</span><span>bytecode</span><span>(),</span></span>
<span><span>        input</span><span>.</span><span>as_bytes</span><span>(),</span></span>
<span><span>        &amp;mut</span><span> output,</span></span>
<span><span>        &amp;mut</span><span> error,</span></span>
<span><span>    )</span></span>
<span><span>    .</span><span>map_err</span><span>(</span><span>|</span><span>error</span><span>|</span><span> error</span><span>.</span><span>to_string</span><span>())</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    let</span><span> error </span><span>=</span><span> decode_buffer</span><span>(error)</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    Ok</span><span>(</span><span>if</span><span> error</span><span>.</span><span>is_empty</span><span>() {</span></span>
<span><span>        (</span><span>StatusCode</span><span>::</span><span>OK</span><span>, </span><span>decode_buffer</span><span>(output)</span><span>?</span><span>)</span></span>
<span><span>    } </span><span>else</span><span> {</span></span>
<span><span>        (</span><span>StatusCode</span><span>::</span><span>BAD_REQUEST</span><span>, error)</span></span>
<span><span>    })</span></span>
<span><span>}</span></span>
<span></span>
<span><span>/// Run a Scheme program.</span></span>
<span><span>fn</span><span> run_scheme</span><span>(</span></span>
<span><span>    bytecodes</span><span>:</span><span> &amp;</span><span>[</span><span>u8</span><span>],</span></span>
<span><span>    input</span><span>:</span><span> &amp;</span><span>[</span><span>u8</span><span>],</span></span>
<span><span>    output</span><span>:</span><span> &amp;mut</span><span> Vec</span><span>&lt;</span><span>u8</span><span>&gt;,</span></span>
<span><span>    error</span><span>:</span><span> &amp;mut</span><span> Vec</span><span>&lt;</span><span>u8</span><span>&gt;,</span></span>
<span><span>) </span><span>-&gt;</span><span> Result</span><span>&lt;(), </span><span>SmallError</span><span>&gt; {</span></span>
<span><span>    // Initialize heap memory for a Scheme virtual machine.</span></span>
<span><span>    // In this case, it is allocated on a stack on the Rust side.</span></span>
<span><span>    let</span><span> mut</span><span> heap </span><span>=</span><span> [</span><span>Default</span><span>::</span><span>default</span><span>(); </span><span>HEAP_SIZE</span><span>];</span></span>
<span><span>    // Initialize a virtual machine of the Scheme interpreter.</span></span>
<span><span>    let</span><span> mut</span><span> vm </span><span>=</span><span> Vm</span><span>::</span><span>new</span><span>(</span></span>
<span><span>        &amp;mut</span><span> heap,</span></span>
<span><span>        // Initialize primitives compliant with the R7RS standard.</span></span>
<span><span>        SmallPrimitiveSet</span><span>::</span><span>new</span><span>(</span></span>
<span><span>            ReadWriteDevice</span><span>::</span><span>new</span><span>(input, output, error),</span></span>
<span><span>            // Disable unused primitives, such as file systems, for security this time.</span></span>
<span><span>            VoidFileSystem</span><span>::</span><span>new</span><span>(),</span></span>
<span><span>            VoidProcessContext</span><span>::</span><span>new</span><span>(),</span></span>
<span><span>            VoidClock</span><span>::</span><span>new</span><span>(),</span></span>
<span><span>        ),</span></span>
<span><span>    )</span><span>?</span><span>;</span></span>
<span></span>
<span><span>    // Initialize a virtual machine with bytecodes.</span></span>
<span><span>    vm</span><span>.</span><span>initialize</span><span>(bytecodes</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>copied</span><span>())</span><span>?</span><span>;</span></span>
<span><span>    // Run the bytecodes on the virtual machine.</span></span>
<span><span>    vm</span><span>.</span><span>run</span><span>()</span></span>
<span><span>}</span></span>
<span></span>
<span><span>/// Convert a buffer of standard output or standard error into a string.</span></span>
<span><span>fn</span><span> decode_buffer</span><span>(buffer</span><span>:</span><span> Vec</span><span>&lt;</span><span>u8</span><span>&gt;) </span><span>-&gt;</span><span> response</span><span>::</span><span>Result</span><span>&lt;</span><span>String</span><span>&gt; {</span></span>
<span><span>    Ok</span><span>(</span><span>String</span><span>::</span><span>from_utf8</span><span>(buffer)</span><span>.</span><span>map_err</span><span>(</span><span>|</span><span>error</span><span>|</span><span> error</span><span>.</span><span>to_string</span><span>())</span><span>?</span><span>)</span></span>
<span><span>}</span></span></code></pre>
<p>Also, change the <code>main</code> function as follows.</p>
<pre tabindex="0" data-language="diff"><code><span><span>  #[tokio::main]</span></span>
<span><span>  async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {</span></span>
<span><span>      serve(</span></span>
<span><span>          tokio::net::TcpListener::bind(&#34;0.0.0.0:3000&#34;).await?,</span></span>
<span><span><span>-</span>         Router::new().route(&#34;/calculate&#34;, post(&#34;Hello, world!&#34;)),</span></span>
<span><span><span>+</span>         Router::new().route(&#34;/calculate&#34;, post(calculate)),</span></span>
<span><span>      )</span></span>
<span><span>      .await?;</span></span>
<span></span>
<span><span>      Ok(())</span></span>
<span><span>  }</span></span></code></pre>
<p>Send an HTTP request to see how it works.</p>
<pre tabindex="0" data-language="sh"><code><span><span>cargo</span><span> run</span><span> &amp;</span></span>
<span><span>curl</span><span> -f</span><span> -X</span><span> POST</span><span> --data</span><span> &#39;(1 2 3 4 5)&#39;</span><span> http://localhost:3000/calculate</span><span> # -&gt; 15</span></span>
<span><span>kill</span><span> %1</span></span></code></pre>
<p>You can see that the Rust program executed the Scheme script and it calculated the sum of numbers in the list you passed in in the HTTP request.</p>
<h3 id="hot-module-reloading"><a aria-hidden="true" tabindex="-1" href="#hot-module-reloading"><span></span></a>Hot module reloading</h3>
<p>JavaScript bundlers (e.g. Webpack and Vite) have a feature called <a href="https://webpack.js.org/concepts/hot-module-replacement/">Hot Module Reloading</a>. This functionality dynamically reflects modified source files’ contents to running programs, such as HTTP servers.</p>
<p>Stak Scheme provides the same functionality in its <code>stak</code> and <code>stak-build</code> libraries. By using it, you can dynamically change the behavior of Rust programs. First, enable the <code>hot-reload</code> feature for the <code>stak</code> crate in the <code>Cargo.toml</code> file.</p>
<pre tabindex="0" data-language="toml"><code><span><span>[</span><span>dependencies</span><span>]</span></span>
<span><span>stak = { version = </span><span>&#34;0.4.4&#34;</span><span>, features = [</span><span>&#34;hot-reload&#34;</span><span>] }</span></span></code></pre>
<p>Next, restart the HTTP server.</p>
<pre tabindex="0" data-language="sh"><code><span><span># Stop the server process if it is already running.</span></span>
<span><span>cargo</span><span> run</span><span> &amp;</span></span></code></pre>
<p>Use the <code>curl</code> command to confirm the sum is calculated right now.</p>
<pre tabindex="0" data-language="sh"><code><span><span>curl</span><span> -f</span><span> -X</span><span> POST</span><span> --data</span><span> &#39;(1 2 3 4 5)&#39;</span><span> http://localhost:3000/calculate</span><span> # -&gt; 15</span></span></code></pre>
<p>Next, change the codes in the <code>handler.scm</code> file to calculate the product of numbers instead of the sum.</p>
<pre tabindex="0" data-language="diff"><code><span><span><span>+</span> (write (apply + (read)))</span></span>
<span><span><span>-</span> (write (apply * (read)))</span></span></code></pre>
<p>Rebuild the Scheme script using the <code>cargo</code> command <strong>without restarting the server</strong>.</p>
<pre tabindex="0" data-language="sh"><code><span><span>cargo</span><span> build</span></span></code></pre>
<p>Again, check the result by sending an HTTP request via the <code>curl</code> command.</p>
<pre tabindex="0" data-language="sh"><code><span><span>curl</span><span> -f</span><span> -X</span><span> POST</span><span> --data</span><span> &#39;(1 2 3 4 5)&#39;</span><span> http://localhost:3000/calculate</span><span> # -&gt; 120</span></span></code></pre>
<p>Unlike before, we see that the product of numbers in the list is returned!</p>
<h2 id="conclusion"><a aria-hidden="true" tabindex="-1" href="#conclusion"><span></span></a>Conclusion</h2>
<ul>
<li>We’ve integrated Stak Scheme in a Rust program.</li>
<li>By using Stak Scheme, you can change the behavior of Rust programs dynamically.</li>
<li>Scheme is awesome!</li>
</ul>
<h2 id="acknowledgements"><a aria-hidden="true" tabindex="-1" href="#acknowledgements"><span></span></a>Acknowledgements</h2>
<p>I would like to give special thanks to <a href="https://github.com/yhara">yhara</a>, <a href="https://github.com/sisshiki1969">monochrome</a>, and the Zulip community of programming language processors for their help.</p>
<h2 id="reference"><a aria-hidden="true" tabindex="-1" href="#reference"><span></span></a>Reference</h2>
<ul>
<li>If you don’t care about memory footprints, standards compliance, etc., there are richer Scheme interpreters written in Rust.
<ul>
<li><a href="https://github.com/mattwparas/steel">mattwparas/steel</a></li>
<li><a href="https://github.com/volution/vonuvoli-scheme">volution/vonuvoli-scheme</a></li>
</ul>
</li>
<li>Lua and mruby are often used for similar purposes.
<ul>
<li><a href="https://github.com/mlua-rs/mlua">mlua-rs/mlua</a></li>
</ul>
</li>
<li>Although the purpose is slightly different, you can achieve something similar with a small WASM interpreter and a WASM compiler for an appropriate high-level language, including statically typed languages. However, you would need to write your own glue code.
<ul>
<li><a href="https://github.com/wasmi-labs/wasmi">wasmi-labs/wasmi</a></li>
</ul>
</li>
</ul>  </article></div>
  </body>
</html>
