<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rwmj.wordpress.com/2010/02/18/why-the-windows-registry-sucks-technically/">Original</a>
    <h1>Why the Windows Registry sucks technically (2010)</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>It’s quite popular to bash the Windows Registry in <a href="http://ubuntuforums.org/archive/index.php/t-136717.html">non-technical</a> or <a href="http://www.codinghorror.com/blog/2007/08/was-the-windows-registry-a-good-idea.html">lightly technical</a> terms.  I’ve just spent a couple of weeks reverse engineering the binary format completely for our <a href="http://libguestfs.org/hivex.3.html">hivex</a> library and <a href="http://libguestfs.org/hivexsh.1.html">shell</a> which now supports both reading and writing to the registry.  So now I can tell you why the Registry sucks from a technical point of view too.</p>
<p><b>1. It’s a half-arsed implementation of a filesystem</b></p>
<p>It’s often said that the Registry is a “monolithic file”, compared to storing configuration in lots of discrete files like, say, Unix does under <code>/etc</code>.  This misses the point: the Registry <i>is</i> a filesystem.  Sure it’s stored in a file, but so is ext3 if you choose to store it in a loopback mount.  The Registry binary format has all the aspects of a filesystem: things corresponding to directories, inodes, extended attributes etc.</p>
<p>The major difference is that this Registry filesystem format is half-arsed.  The format is badly constructed, fragile, endian-specific, underspecified and slow.  The format changes from release to release of Windows.  Parts are undocumented, seemingly to the Windows developers themselves (judging by the NT debug symbols that <a href="http://amnesia.gtisc.gatech.edu/~moyix/suzibandit.ltd.uk/MSc/">one paper</a> has reproduced).  Parts of the format waste space, while in other parts silly “optimizations” are made to save a handful of bytes (at the cost of making access much more complex).</p>
<p><b>2. Hello Microsoft programmers, a memory dump is <i>not</i> a file format</b></p>
<p>The format is essentially a dump of 32 bit C structures in a C memory heap.  This was probably done originally for speed, but it opens the format to all sorts of issues:</p>
<ol>
<li> You can hide stuff away in unused blocks.
</li><li> You can create registries containing unreachable blocks or loops or pointers outside the heap, and cause Windows to fail or hang (see point 3).
</li><li> It’s endian and wordsize specific.
</li><li> It depends on the structure packing of the original compiler circa 1992.
</li></ol>
<p><b>3. The implementation of reading/writing the Registry in Windows NT is poor</b></p>
<p>You might expect, given how critical the Registry is to Window’s integrity, that the people who wrote the code that loads it would have spent a bit of time thinking about checking the file for consistency, but apparently this is not done.</p>
<ol>
<li> All versions of Windows tested will simply ignore blocks which are not aligned correctly.
</li><li> Ditto, will ignore directory entries which are not in alphabetical order (it just stops reading at the first place it finds a subdirectory named B &gt; next entry A).
</li><li> Ditto, will ignore file entries which contain various sorts of invalid field.
</li></ol>
<p>The upshot of this is you can easily hide stuff in the Registry binary which is completely invisible to Windows, but will be apparent in other tools.  From the point of view of other tools (like our hivex tool) we <i>have</i> to write <i>exactly</i> the same bits that Windows would write, to be sure that Windows will be able to read it.  Any mistakes we make, even apparently innocuous ones, are silently punished.</p>
<p>Compare this to using an established filesystem format, where everyone knows the rules, and consistency (eg. fsck/chkdsk) matters.</p>
<p>Writing sucks too, because the programmers don’t correctly zero out fields, so you’ll find parts (particularly the Registry header) which contain random bits of memory, presumably kernel memory, dumped into the file.  I didn’t find anything interesting there yet …</p>
<p>I also found Registries containing unreachable blocks (and not, I might add, ones which I’d tried modifying).  I find it very strange that relatively newly created Windows 7 VMs which don’t have any sort of virus infection, have visible Registry corruption.</p>
<p><b>4. Types are not well specified</b></p>
<p>Each registry field superficially is <a href="http://en.wikipedia.org/wiki/Windows_Registry#Keys_and_values">typed</a>, so REG_SZ is a string, and REG_EXPAND_SZ is, erm, also a string.  Good, right?  No, because what counts as a “string” is not well-defined.  A string might be encoded in 7 bit ASCII, or UTF-16-LE.  The only way to know is to know what versions of Windows will use the registry.</p>
<p>Strings are also stored in REG_BINARY fields (in various encodings), but also raw binary data is stored in these fields.</p>
<p>Count yourself lucky if you only access official Microsoft fields though because some applications don’t confine themselves to the published types at all, and just use the type field for whatever they feel like.</p>
<p>And what’s up with having REG_DWORD (little-endian of course) and REG_DWORD_BIG_ENDIAN, and REG_QWORD, but <i>no</i> REG_QWORD_BIG_ENDIAN?</p>
<p><b>5. Interchange formats are not well specified</b></p>
<p>A critical part of installing many drivers is making registry edits, and for this a text format (<a href="http://en.wikipedia.org/wiki/Windows_Registry#.REG_files">.REG</a>) is used along with the REGEDIT program.  The thing is though that the .REG format is not well-specified in terms of backslash escaping.  You can find examples of .REG files that have both:</p>
<pre>&#34;Name&#34;=&#34;\Value&#34;
</pre>
<p>and</p>
<pre>&#34;Name&#34;=&#34;\\Value&#34;
</pre>
<p>In addition the encoding of strings is <i>again</i> not specified.  It seems to depend on the encoding of the actual .REG file, as far as anyone can tell.  eg. If your .REG file itself is UTF-16-LE, then REGEDIT will encode all strings you define this way.  Presumably if you transfer the .REG file to a system that changes the encoding, then you’ll get different results when you load the registry.</p>
<p><b>6. The Registry arrangement is a mess</b></p>
<p>Take a look at this <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.85.3567&amp;rep=rep1&amp;type=pdf">forensic view of interesting Registry keys (PDF)</a>.  List of mounted drives?  <code>HKEY_LOCAL_MACHINE\SYSTEM\MountedDevices</code>.  But what the user sees is stored in <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2\CPC\Volume\</code>.  Unless you mean USB devices which might be in the above list, or in <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\USBSTOR</code>.  And the entries in those lists are by no means obvious — <a href="http://www.insidetheregistry.com/regdatabase/browse.aspx?keyid=1030">containing impenetrable binary fields and strange Windows paths</a>.</p>
<p>If you <a href="http://www.eptuners.com/forensics/contents/examination.htm">browse through the Registry</a> some time you’ll see it’s a giant accreted mess of non-standardized, overlapping information stored in random places.  Some of it is configuration, much of it is runtime data.  This is a far cry from <code>/etc/<i>progname</i>.conf</code> in Linux.</p>
<p><b>7. The Registry is a filesystem</b></p>
<p>Back to point 1, the Registry is a half-assed, poor quality implementation of a filesystem.  Importantly, it’s <b>not a database</b>.  It should be a database!  It could benefit from indices to allow quick lookups, but instead we have to manually and linearly traverse it.</p>
<p>This leads to really strange Registry keys like:</p>
<pre>\ControlSet001\Control\CriticalDeviceDatabase\pci#ven_1af4&amp;dev_1001&amp;subsys_00000000
</pre>
<p>which are crying out to be implemented as indexed columns in a real database.</p>
<p><b>8. Security, ha ha, let’s pretend</b></p>
<p>Despite the fact that the Registry is just a plain file that you can modify using all sorts of external tools (eg. our <a href="http://libguestfs.org/hivexsh.1.html">hivex shell</a>), you can create “unreadable” and “unwritable” keys.  These are “secure” from the point of view of Windows, unless you just modify the Registry binary file directly.</p>
<p>Windows also uses an unhealthy dose of security-through-obscurity.  It hides password salts in the obscure “ClassName” field of the Registry key.  The “security” here relies entirely on the fact that the default Windows REGEDIT program cannot view or edit the ClassName of a key.  Anyone with a binary editor can get around this restriction trivially.</p>
<p><b>9. The Registry is obsolete, sorta</b></p>
<p>Well the good news is the Registry is obsolete.  The bad news is that Vista has <a href="http://www.computerperformance.co.uk/vista/vista_appdata.htm">introduced</a> another, incompatible way to store application data, in <code>AppData/Local</code> and <code>AppData/LocalLow</code> directories, but that Windows Vista and Windows 7 continue to rely on the Registry for all sorts of critical data, and it doesn’t look like this mess is going to go away any time soon.</p>
<p>* * *</p>
<p><b><a href="http://libguestfs.org/">libguestfs on Fedora</a></b> now provides the tools you need to manage the Registry in Windows virtual machines.  For more details, see <a href="http://libguestfs.org/hivexsh.1.html">hivexsh</a> and <a href="http://libguestfs.org/virt-win-reg.1.html">virt-win-reg</a> documentation.</p>
<h4>Update</h4>
<p>  Thanks to all who commented.  There is further discussion <a href="http://www.reddit.com/r/programming/comments/b3mr2/why_the_windows_registry_sucks_technically/">here on Reddit</a> and <a href="http://news.ycombinator.com/item?id=1134307">here on Hacker News</a> (including discussion of inaccuracies in what I wrote).  If you want to look at our analysis code, it’s <a href="http://git.annexia.org/?p=libguestfs.git;a=tree;f=hivex/tools;hb=HEAD">all here in our source repository</a>.  For further references on the Registry binary format, follow the links <a href="http://git.annexia.org/?p=libguestfs.git;a=blob;f=hivex/README;hb=HEAD">in the hivex README file</a>.</p>
			
			
				</div></div>
  </body>
</html>
