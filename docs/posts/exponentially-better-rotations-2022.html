<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://thenumb.at/Exponential-Rotations/">Original</a>
    <h1>Exponentially Better Rotations (2022)</h1>
    
    <div id="readability-page-1" class="page"><div>
    <p>If you’ve done any 3D programming, you’ve likely encountered the zoo of techniques and representations used when working with 3D rotations. Some of them are better than others, depending on the situation.</p>

<p><em>Based on <a href="http://15462.courses.cs.cmu.edu/">CMU 15-462</a> course materials by <a href="https://www.cs.cmu.edu/~kmcrane/">Keenan Crane</a>.</em></p>

<ul>
  <li><a href="#representations">Representations</a>
    <ul>
      <li><a href="#rotation-matrices">Rotation Matrices</a></li>
      <li><a href="#euler-angles">Euler Angles</a></li>
      <li><a href="#quaternions">Quaternions</a></li>
      <li><a href="#axisangle-rotations">Axis/Angle</a></li>
    </ul>
  </li>
  <li><a href="#the-exponential-and-logarithmic-maps">The Exponential and Logarithmic Maps</a>
    <ul>
      <li><a href="#axisangle-in-2d">Axis/Angle in 2D</a></li>
      <li><a href="#axisangle-in-3d">Axis/Angle in 3D</a></li>
      <li><a href="#averaging-rotations">Averaging Rotations</a></li>
      <li><a href="#quaternions-again">Quaternions (Again)</a></li>
    </ul>
  </li>
  <li><a href="#further-reading">Further Reading</a></li>
</ul>



<h2 id="rotation-matrices">Rotation Matrices</h2>

<p>Linear-algebra-wise, the most straightforward representation is an orthonormal 3x3 matrix (with positive determinant). The three columns of a rotation matrix specify where the x, y, and z axes end up after the rotation.</p>

<p>Rotation matrices are particularly useful for transforming points: just multiply! Even better, rotation matrices can be composed with any other linear transformations via matrix multiplication. That’s why we use rotation matrices when actually drawing things on screen: only one matrix multiplication is required to transform a point from world-space to the screen. However, rotation matrices are not so useful for actually working with <em>rotations</em>: because they don’t form a vector space, adding together two rotation matrices will not give you a rotation matrix back. For example, animating an object by linearly interpolating between two rotation matrices adds scaling:</p>





<table><tbody><tr>
<td>$$ R_0 = \begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix} $$</td>
<td id="matrix_interp_mj">$$ R(0.00) = \begin{bmatrix}\phantom{-}1.00&amp;\phantom{-}0.00&amp;\phantom{-}0.00\\\phantom{-}0.00&amp;\phantom{-}1.00&amp;\phantom{-}0.00\\\phantom{-}0.00&amp;\phantom{-}0.00&amp;\phantom{-}1.00\end{bmatrix} $$</td>
<td id="matrix_interp_m1">$$ R_1 = \begin{bmatrix}-1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;-1\end{bmatrix} $$</td>
</tr></tbody></table>

<h2 id="euler-angles">Euler Angles</h2>

<p>Another common representation is Euler angles, which specify three separate rotations about the x, y, and z axes (also known as pitch, yaw, and roll). The order in which the three component rotations are applied is an arbitrary convention—here we’ll apply x, then y, then z.</p>

<canvas id="euler"></canvas>
<table>
<tbody><tr><td>$$\theta_x$$</td><td></td></tr>
<tr><td>$$\theta_y$$</td><td></td><td></td></tr>
<tr><td>$$\theta_z$$</td><td></td></tr>
</tbody></table>

<p>Euler angles are generally well-understood and often used for authoring rotations. However, using them for anything else comes with some significant pitfalls. While it’s possible to manually create splines that nicely interpolate Euler angles, straightforward interpolation often produces undesirable results.</p>

<p>Euler angles suffer from <em>gimbal lock</em> when one component causes the other two axes of rotation to become parallel. Such configurations are called <em>singularities</em>. At a singularity, changing either of two ‘locked’ angles will cause the same output rotation. You can demonstrate this phenomenon above by pressing the ‘lock’ button and adjusting the x/z rotations (a quarter rotation about y aligns the z axis with the x axis).</p>

<p>Singularities break interpolation: if the desired path reaches a singularity, it gains a degree of freedom with which to represent its current position. Picking an arbitrary representation to continue with causes discontinuities in the interpolated output: even within an axis, interpolation won’t produce a constant angular velocity. That can be a problem if, for example, you’re using the output to drive a robot. Furthermore, since each component angle is cyclic, linear interpolation won’t always choose the shortest path between rotations.</p>

<canvas id="euler_interp"></canvas>


<table><tbody><tr>
<td>$$ \mathbf{\theta}_0 = \begin{bmatrix}0\\0\\0\end{bmatrix} $$</td>
<td id="euler_interp_mj">$$ \mathbf{\theta}(0.00) = \begin{bmatrix}\phantom{-}0.00\\\phantom{-}0.00\\\phantom{-}0.00\end{bmatrix} $$</td>
<td id="euler_interp_m1">$$ \mathbf{\theta}_1 = \begin{bmatrix}-3.14\\0.00\\-3.14\end{bmatrix} $$</td>
</tr></tbody></table>

<p>Thankfully, interpolation is smooth if the path doesn’t go through a singularity, so these limitations <em>can</em> be worked around, especially if you don’t need to represent ‘straight up’ and ‘straight down.’</p>

<h2 id="quaternions">Quaternions</h2>

<p>At this point, you might be expecting yet another article on quaternions—don’t worry, we’re not going to delve into hyper-complex numbers today. It suffices to say that unit quaternions are the standard tool for composing and interpolating rotations, since <a href="https://en.wikipedia.org/wiki/Slerp">spherical linear interpolation</a> (slerp) chooses a constant-velocity shortest path between any two quaternions. However, unit quaternions also don’t form a vector space, are unintuitive to author, and can be computationally costly to interpolate<a href="http://number-none.com/product/Hacking%20Quaternions/">*</a>. Further, there’s no intuitive notion of scalar multiplication, nor averaging.</p>

<p>But, they’re still fascinating! If you’d like to understand quaternions more deeply (or, perhaps, learn what they are in the first place), read <a href="https://eater.net/quaternions">this</a>.</p>

<canvas id="quat_interp"></canvas>


<table><tbody><tr>
<td>$$ Q_0 = \begin{bmatrix}1\\0\\0\\0\end{bmatrix}\ \ $$</td>
<td id="quat_interp_mj">$$ Q(0.00) = \begin{bmatrix}\phantom{-}1.00\\\phantom{-}0.00\\\phantom{-}0.00\\\phantom{-}0.00\end{bmatrix}\ \ $$</td>
<td id="quat_interp_m1">$$ Q_1 = \begin{bmatrix}0\\0\\1\\0\end{bmatrix} $$</td>
</tr></tbody></table>

<p>Note that since quaternions double-cover the space of rotations, sometimes \(Q(1)\) will go to \(-Q_1\).</p>

<h2 id="axisangle-rotations">Axis/Angle Rotations</h2>

<p>An axis/angle rotation is a 3D vector of real numbers. Its direction specifies the axis of rotation, and its magnitude specifies the angle to rotate about that axis. For convenience, we’ll write axis/angle rotations as \(\theta\mathbf{u}\), where \(\mathbf{u}\) is a unit-length vector and \(\theta\) is the rotation angle.</p>

<canvas id="axis_angle"></canvas>

<table>
<tbody><tr><td>$$\mathbf{u}_x$$</td><td></td></tr>
<tr><td>$$\mathbf{u}_y$$</td><td></td></tr>
<tr><td>$$\mathbf{u}_z$$</td><td></td></tr>
<tr><td>$$\theta$$</td><td></td></tr>
</tbody></table>

<p>Since axis/angle rotations are simply 3D vectors, they form a vector space: we can add, scale, and interpolate them to our heart’s content. Linearly interpolating between any two axis/angle rotations is smooth and imparts constant angular velocity. However, note that linearly interpolating between axis-angle rotations does not necessarily choose the shortest path: it depends on which axis/angle you use to specify the target rotation.</p>

<canvas id="axis_angle_interp"></canvas>


<table><tbody><tr>
<td>$$ \theta_0\mathbf{u}_0 = \begin{bmatrix}0\\0\\0\end{bmatrix}\ \ $$</td>
<td id="axis_angle_interp_mj">$$ \theta\mathbf{u}(0.00) = \begin{bmatrix}\phantom{-}0.00\\\phantom{-}0.00\\\phantom{-}0.00\end{bmatrix}\ \ $$</td>
<td id="axis_angle_interp_m1">$$ \theta_1\mathbf{u}_1 = \begin{bmatrix}0\\3.14\\0\end{bmatrix} $$</td>
</tr></tbody></table>

<p>Like quaternions, axis/angle vectors double-cover the space of rotations: sometimes \(\theta\mathbf{u}(1)\) will go to \((2\pi - \theta_1)(-\mathbf{u}_1)\).</p>



<p>Ideally, we could freely convert rotations between these diverse representations based on our use case. We will always want to get a rotation matrix out at the end, so we’ll consider matrices the ‘canonical’ form. Enter the <strong>exponential map</strong>: a function that takes a different kind of rotation object and gives us back an equivalent rotation matrix. The corresponding <strong>logarithmic map</strong> takes a rotation matrix and gives us back a rotation object. How these maps relate to the scalar <code>exp</code> and <code>log</code> functions will hopefully become clear later on.</p>

<p><img src="http://thenumb.at/assets/exp-rotations/map.png"/></p>

<p>Below, we’ll define an <code>exp</code> and <code>log</code> map translating between rotation matrices and axis/angle vectors. But first, to build up intuition, let us consider how rotations work in two dimensions.</p>

<h2 id="axisangle-in-2d">Axis/Angle in 2D</h2>

<p>In 2D, there’s only one axis to rotate around: the one pointing out of the plane. Hence, our ‘axis/angle’ rotations can be represented by just \(\theta\).</p>

<p>Given a 2D point \(\mathbf{p}\), how can we rotate \(\mathbf{p}\) by \(\theta\)? One way to visualize the transformation is by forming a coordinate frame in which the output is easy to describe. Consider \(\mathbf{p}\) and its quarter (\(90^\circ\)) rotation \(\mathcal{J}\mathbf{p}\):</p>

<p><img src="http://thenumb.at/assets/exp-rotations/2d_rot.svg"/></p>

<p>Using a bit of trigonometry, we can describe the rotated \(\mathbf{p}_\theta\) in two components:</p><p>

\[\begin{align*} \mathbf{p}_\theta &amp;= \mathbf{p}\cos\theta + \mathcal{J}\mathbf{p}\sin\theta \\
 &amp;= (\cos(\theta)\mathcal{I} + \sin(\theta)\mathcal{J})\mathbf{p} \end{align*}\]

</p><p>But, what actually are \(\mathcal{I}\) and \(\mathcal{J}\)? The former should take a 2D vector and return it unchanged: it’s the 2x2 identity matrix. The latter should be similar, but swap and negate the two components:</p><p>

\[\begin{align*} \mathcal{I} &amp;= \begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix} \\ \mathcal{J} &amp;= \begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix} \end{align*}\]

</p><p>Just to make sure we got \(\mathcal{J}\) right, let’s check what happens if we apply it twice (via \(\mathcal{J}^2\)):</p><p>

\[\mathcal{J}^2 = \begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix} = \begin{bmatrix}-1&amp;0\\0&amp;-1\end{bmatrix}\]

</p><p>We got \(\mathcal{J}^2 = -\mathcal{I}\), which is a 180-degree rotation. So, \(\mathcal{J}\) indeed represents 90-degree rotation.</p>

<p>Now, what does our transform look like?</p><p>

\[\begin{align*}
\mathbf{p}_\theta &amp;= (\cos(\theta)\mathcal{I} + \sin(\theta)\mathcal{J})\mathbf{p} \\
                  &amp;= \left(\cos(\theta)\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix} + \sin(\theta)\begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\right)\mathbf{p} \\
                  &amp;= \begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}\mathbf{p}
\end{align*}\]

</p><p>That’s the standard 2D rotation matrix. What a coincidence!</p>

<h3 id="complex-rotations">Complex Rotations</h3>

<p>If you’re familiar with complex numbers, you might notice that our first transform formula feels eerily similar to Euler’s formula, \(e^{ix} = \cos x + i\sin x\):</p><p>

\[\begin{align*}
\mathbf{p}_\theta &amp;= (\cos(\theta)\mathcal{I} + \sin(\theta)\mathcal{J})\mathbf{p} \\
e^{i\theta}p &amp;= (\cos(\theta) + i\sin(\theta))p
\end{align*}\]

</p><p><img src="http://thenumb.at/assets/exp-rotations/expi.svg"/></p>

<p>Where \(i\) and \(\mathcal{J}\) both play the role of a quarter turn. We can see that in complex arithmetic, multiplying by \(i\) in fact has that effect:</p><p>

\[\mathcal{J}\mathbf{p} = \begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix}\begin{bmatrix}a\\b\end{bmatrix} = \begin{bmatrix}-b\\a\end{bmatrix}\]

\[ip = i(a + bi) = ai + bi^2 = -b + ai\]

</p><p>So, there must be some connection to the exponential function here.</p>

<h3 id="the-2d-exponential-map">The 2D Exponential Map</h3>

<p>Recall the definition of the exponential function (or equivalently, its Taylor series):</p><p>

\[e^x = \sum_{k=0}^\infty \frac{x^k}{k!} = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \dots\]

</p><p>Using Euler’s formula, \(e^{i\theta}\) gave us a complex number representing a 2D rotation by \(\theta\). Can we do the same with \(e^{\theta\mathcal{J}}\)? If we plug a matrix into the above definition, the arithmetic still works out: 2x2 matrices certainly support multiplication, addition, and scaling. (More on matrix exponentiation <a href="https://www.youtube.com/watch?v=O85OWBJ2ayo">here</a>.)</p>

<p>Let \(\theta\mathcal{J} = A\) and plug it in:</p><p>

\[e^A = \sum_{k=0}^\infty \frac{A^k}{k!} = \mathcal{I} + A + \frac{A^2}{2!} + \frac{A^3}{3!} + \dots\]

</p><p>Let’s pull out the first four terms to inspect further:</p><p>

\[\begin{align*}
e^A &amp;= \mathcal{I} + A + \frac{1}{2!}A^2 + \frac{1}{3!}A^3 \\
    &amp;= \mathcal{I} + A\left(\mathcal{I} + \frac{1}{2}A\left(\mathcal{I} + \frac{1}{3}A\right)\right) \\
    &amp;= \mathcal{I} + A\left(\mathcal{I} + \frac{1}{2}A\begin{bmatrix}1&amp;\frac{-\theta}{3}\\\frac{\theta}{3}&amp;1\end{bmatrix}\right) \\
    &amp;= \mathcal{I} + A\begin{bmatrix}1-\frac{\theta^2}{6}&amp;\frac{-\theta}{2}\\\frac{\theta}{2}&amp;1-\frac{\theta^2}{6}\end{bmatrix} \\
    &amp;= \begin{bmatrix}1-\frac{\theta^2}{2}&amp;-\theta+\frac{\theta^3}{6}\\\theta-\frac{\theta^3}{6}&amp;1-\frac{\theta^2}{2}\end{bmatrix}
\end{align*}\]

</p><p>These entries look familiar. Recall the Taylor series that describe the functions \(\sin\) and \(\cos\):</p><p>

\[\begin{align*} \sin x &amp;= x - \frac{x^3}{3!} + \frac{x^5}{5!} - \dots  \\
\cos x &amp;= 1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \dots \end{align*}\]

</p><p>If we write out all the terms of \(e^A\), we’ll recover the expansions of \(\sin\theta\) and \(\cos\theta\)! Therefore:</p><p>

\[e^A = e^{\theta\mathcal{J}} = \begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}\]

</p><p>We’ve determined that the exponential function \(e^{\theta\mathcal{J}}\) converts our angle \(\theta\) into a corresponding 2D rotation matrix. In fact, we’ve proved a version of Euler’s formula with 2x2 matrices instead of complex numbers:</p><p>

\[\begin{align*} &amp;&amp; e^{\theta\mathcal{J}} &amp;= (\cos(\theta)\mathcal{I} + \sin(\theta)\mathcal{J})\\
    &amp;\implies&amp; \mathbf{p}_\theta &amp;= e^{\theta\mathcal{J}}\mathbf{p}
\end{align*}\]

</p><h3 id="the-2d-logarithmic-map">The 2D Logarithmic Map</h3>

<p>The logarithmic map should naturally be the inverse of the exponential:</p><p>

\[R = \exp(\theta\mathcal{J}) \implies \log(R) = \theta\mathcal{J}\]

</p><p>So, given \(R\), how can we recover \(\theta\mathcal{J}\)?</p><p>

\[\begin{align*}
&amp;&amp; R &amp;= \begin{bmatrix}\cos\theta&amp;-\sin\theta\\\sin\theta&amp;\cos\theta\end{bmatrix}\\
&amp;\implies&amp; \theta &amp;= \text{atan2}(R_{21},R_{11})\\
&amp;\implies&amp; \log(R) &amp;= \begin{bmatrix}0&amp;-\theta\\\theta&amp;0\end{bmatrix}
\end{align*}\]

</p><p>Note that in general, our exponential map is not injective. Clearly, \(\exp(\theta\mathcal{J}) = \exp((\theta + 2\pi)\mathcal{J})\), since adding an extra full turn will always give us back the same rotation matrix. Therefore, our logarithmic map can’t be surjective—we’ll define it as returning the <em>smallest</em> angle \(\theta\mathcal{J}\) corresponding to the given rotation matrix. Using \(\text{atan2}\) implements this definition.</p>

<h3 id="interpolation">Interpolation</h3>

<p>Consider two 2D rotation angles \(\theta_0\) and \(\theta_1\). The most obvious way to interpolate between these two rotations is to interpolate the angles and create the corresponding rotation matrix. This scheme is essentially a 2D version of axis-angle interpolation.</p><p>

\[\begin{align*} \theta(t) &amp;= (1-t)\theta_0 + t\theta_1\\
R_\theta(t) &amp;= \begin{bmatrix}\cos(\theta(t))&amp;-\sin(\theta(t))\\\sin(\theta(t))&amp;\cos(\theta(t))\end{bmatrix}
\end{align*}\]

</p><p>However, if \(\theta_0\) and \(\theta_1\) are separated by more than \(\pi\), this expression will take the long way around: it’s not aware that angles are cyclic.</p>

<canvas id="2d_angle_interp"></canvas>


<table><tbody><tr>
<td>$$ \theta_0 = 0\ \ $$</td>
<td id="2d_angle_interp_mj">$$ \theta(0.00) = 0.00\ \ $$</td>
<td id="2d_angle_interp_m1">$$ \theta_1 = 4.71 $$</td>
</tr></tbody></table>

<p>Instead, let’s devise an interpolation scheme based on our <code>exp</code>/<code>log</code> maps. Since we know the two rotation matrices \(R_0\), \(R_1\), we can express the rotation that takes us directly from the initial pose to the final pose: \(R_1R_0^{-1}\), i.e. first undo \(R_0\), then apply \(R_1\).</p>

<p>Using our logarithmic map, we can obtain the smallest angle that rotates from \(R_0\) to \(R_1\): \(\log(R_1R_0^{-1})\). Since \(\log\) gives us an axis-angle rotation, we can simply scale the result by \(t\) to perform interpolation. After scaling, we can use our exponential map to get back a rotation matrix. This matrix represents a rotation \(t\) of the way from \(R_0\) to \(R_1\).</p>

<p>Hence, our final parametric rotation matrix is \(R(t) = \exp(t\log(R_1R_0^{-1})))R_0\).</p><p>

\[\begin{align*} R(0) &amp;= \exp(0)R_0 = R_0\\
R(1) &amp;= \exp(\log(R_1R_0^{-1}))R_0 = R_1R_0^{-1}R_0 = R_1 \end{align*}\]

</p><canvas id="2d_exp_interp"></canvas>


<table><tbody><tr>
<td>$$ R_0 = \begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix} $$</td>
<td id="2d_exp_interp_mj">$$ R(0.00) = \begin{bmatrix}\phantom{-}1.00&amp;\phantom{-}0.00\\\phantom{-}0.00&amp;\phantom{-}1.00\end{bmatrix} $$</td>
<td id="2d_exp_interp_m1">$$ R_1 = \begin{bmatrix}0&amp;-1\\1&amp;0\end{bmatrix} $$</td>
</tr></tbody></table>

<p>Using <code>exp</code>/<code>log</code> for interpolation might seem like overkill for 2D—we could instead just check how far apart the angles are. But below, we’ll see how this interpolation scheme generalizes—without modification—to 3D, and in fact any number of dimensions.</p>

<h2 id="axisangle-in-3d">Axis/Angle in 3D</h2>

<p>We’re finally ready to derive an exponential and logarithmic map for 3D rotations. In 2D, our map arose from exponentiating \(\theta\mathcal{J}\), i.e. \(\theta\) times a matrix representing a counter-clockwise quarter turn about the axis of rotation. We will be able to do the same in 3D—but what transformation encodes a quarter turn about a 3D unit vector \(\mathbf{u}\)?</p>

<p>The cross product \(\mathbf{u}\times\mathbf{p}\) is typically defined as a vector normal to the plane containing both \(\mathbf{u}\) and \(\mathbf{p}\). However, we could also interpret \(\mathbf{u}\times\mathbf{p}\) as a quarter turn of the <em>projection</em> of \(\mathbf{p}\) into the plane with normal \(\mathbf{u}\), which we will call \(\mathbf{p}_\perp\):</p>

<p><img src="http://thenumb.at/assets/exp-rotations/crossu.svg"/></p>

<p>So, if we can compute the quarter rotation of \(\mathbf{p}_\perp\), it should be simple to recover the quarter rotation of \(\mathbf{p}\). Of course, \(\mathbf{p}=\mathbf{p}_\perp+\mathbf{p}_\parallel\), so we’ll just have to add back the parallel part \(\mathbf{p}_\parallel\). This is correct because a rotation about \(\mathbf{u}\) preserves \(\mathbf{p}_\parallel\):</p>

<p><img src="http://thenumb.at/assets/exp-rotations/crossu2.svg"/></p>

<p>However, “\(\mathbf{u} \times\)” is not a mathematical object we can work with. Instead, we can devise a matrix \(\mathbf{\hat{u}}\) that when multiplied with a a vector \(\mathbf{p}\), outputs the same result as \(\mathbf{u} \times \mathbf{p}\):</p><p>

\[\begin{align*}
\mathbf{u} \times \mathbf{p} &amp;= \begin{bmatrix} u_yp_z - u_zp_y \\ u_zp_x - u_xp_z \\ u_xp_y - u_yp_x \end{bmatrix} \\
 &amp;= \begin{bmatrix}0&amp;-u_z&amp;u_y\\u_z&amp;0&amp;-u_x\\-u_y&amp;u_x&amp;0\end{bmatrix}\begin{bmatrix}p_x\\p_y\\p_z\end{bmatrix} \\
 &amp;= \mathbf{\hat{u}}\mathbf{p}
\end{align*}\]

</p><p>We can see that \(\mathbf{\hat{u}}^T = -\mathbf{\hat{u}}\), so \(\mathbf{\hat{u}}\) is a <em>skew-symmetric</em> matrix. (i.e. it has zeros along the diagonal, and the two halves are equal but negated.) Note that in the 2D case, our quarter turn \(\mathcal{J}\) was also skew-symmetric, and sneakily represented the 2D cross product! We must be on the right track.</p>

<p>The reason we want to use axis/angle rotations in the first place is because they form a vector space. So, let’s make sure our translation to skew-symmetric matrices maintains that property. Given two skew-symmetric matrices \(A_1\) and \(A_2\):</p><p>

\[(A_1 + A_2)^T = A_1^T + A_2^T = -A_1 - A_2 = -(A_1 + A_2)\]

</p><p>Their sum is also a skew-symmetric matrix. Similarly:</p><p>

\[(cA)^T = c(A^T) = -cA\]

</p><p>Scalar multiplication also maintains skew-symmetry. The other vector space properties follow from the usual definition of matrix addition.</p>

<p>Finally, note that \(\mathbf{u} \times (\mathbf{u} \times (\mathbf{u} \times \mathbf{p})) = -\mathbf{u} \times \mathbf{p}\). Taking the cross product three times would rotate \(\mathbf{p}_\perp\) three-quarter turns about \(\mathbf{u}\), which is equivalent to a single negative-quarter turn. More generally, \(\mathbf{\hat{u}}^{k+2} = -\mathbf{\hat{u}}^k\) for any \(k&gt;0\). We could prove this by writing out all the terms, but the geometric argument is easier:</p>

<p><img src="http://thenumb.at/assets/exp-rotations/crossu3.svg"/></p>

<h3 id="the-3d-exponential-map">The 3D Exponential Map</h3>

<p>Given an axis/angle rotation \(\theta\mathbf{u}\), we can make \(\theta\mathbf{\hat{u}}\) using the above construction. What happens when we exponentiate it? Using the identity \(\mathbf{\hat{u}}^{k+2} = -\mathbf{\hat{u}}^k\):</p><p>

\[\begin{align*}
e^{\theta\mathbf{\hat{u}}} &amp;= \mathcal{I} + \theta\mathbf{\hat{u}} + \frac{1}{2!}\theta^2\mathbf{\hat{u}}^2 + \frac{1}{3!}\theta^3\mathbf{\hat{u}}^3 + \frac{1}{4!}\theta^4\mathbf{\hat{u}}^4 + \frac{1}{5!}\theta^5\mathbf{\hat{u}}^5 + \dots \\
&amp;= \mathcal{I} + \theta\mathbf{\hat{u}} + \frac{1}{2!}\theta^2\mathbf{\hat{u}}^2 - \frac{1}{3!}\theta^3\mathbf{\hat{u}} - \frac{1}{4!}\theta^4\mathbf{\hat{u}}^2 + \frac{1}{5!}\theta^5\mathbf{\hat{u}} + \dots \\
&amp;= \mathcal{I} + \left(\theta - \frac{1}{3!}\theta^3 + \frac{1}{5!}\theta^5 - \dots\right)\mathbf{\hat{u}} + \left(1 - \left(1 - \frac{1}{2!}\theta^2 + \frac{1}{4!}\theta^4 - \dots\right)\right)\mathbf{\hat{u}}^2 \\
&amp;= \mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2
\end{align*}\]

</p><p>In the last step, we again recover the Taylor expansions of \(\sin\theta\) and \(\cos\theta\). Our final expression is known as <em>Rodrigues’ formula</em>.</p>

<p>This formula is already reminiscent of the 2D case: the latter two terms are building up a 2D rotation in the plane defined by \(\mathbf{u}\). To sanity check our 3D result, let’s compute our transform for \(\theta = 0\):</p><p>

\[e^{0\mathbf{\hat{u}}}\mathbf{p} = (\mathcal{I} + 0\mathbf{\hat{u}} + (1-1)\mathbf{\hat{u}}^2)\mathbf{p} = \mathbf{p}\]

</p><p>Rotating by \(\theta = 0\) preserves \(\mathbf{p}\), so the formula works. Then compute for \(\theta = \frac{\pi}{2}\):</p><p>

\[\begin{align*} e^{\frac{\pi}{2}\mathbf{\hat{u}}}\mathbf{p} &amp;= (\mathcal{I} + 1\mathbf{\hat{u}} + (1-0)\mathbf{\hat{u}}^2)\mathbf{p} \\ &amp;= \mathbf{p} + \mathbf{\hat{u}}\mathbf{p} + \mathbf{\hat{u}}^2\mathbf{p} \\
&amp;= \mathbf{p} + \mathbf{u}\times\mathbf{p} + \mathbf{u}\times(\mathbf{u}\times\mathbf{p})\\
&amp;= (\mathbf{p}_\perp + \mathbf{p}_\parallel) + \mathbf{u}\times\mathbf{p} - \mathbf{p}_\perp\\
&amp;= \mathbf{u}\times\mathbf{p} + \mathbf{p}_\parallel
\end{align*}\]

</p><p>Above, we already concluded \(\mathbf{u}\times\mathbf{p} + \mathbf{p}_\parallel\) is a quarter rotation. So, our formula is also correct at \(\theta = \frac{\pi}{2}\). Then compute for \(\theta = \pi\):</p><p>

\[\begin{align*} e^{\pi\mathbf{\hat{u}}}\mathbf{p} &amp;= (\mathcal{I} + 0\mathbf{\hat{u}} + (1-(-1))\mathbf{\hat{u}}^2)\mathbf{p} \\
&amp;= \mathbf{p} + 2\mathbf{\hat{u}}^2\mathbf{p} \\
&amp;= (\mathbf{p}_\perp + \mathbf{p}_\parallel) - 2\mathbf{p}_\perp \\
&amp;= -\mathbf{p}_\perp + \mathbf{p}_\parallel
\end{align*}\]

</p><p><img src="http://thenumb.at/assets/exp-rotations/crossu4.svg"/></p>

<p>We end up with \(-\mathbf{p}_\perp + \mathbf{p}_\parallel\), which is a half rotation. Hence \(\theta = \pi\) is also correct.</p>

<p>So far, our formula checks out. Just to be sure, let’s prove that our 3D result is a rotation matrix, i.e. it’s orthonormal and has positive determinant. A matrix is orthonormal if \(A^TA = \mathcal{I}\), so again using \(\mathbf{\hat{u}}^{k+2} = -\mathbf{\hat{u}}^k\):</p><p>

\[\begin{align*}
&amp;\left(\mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2\right)^T\left(\mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2\right) \\
=&amp; \left(\mathcal{I}^T + \sin(\theta)\mathbf{\hat{u}}^T + (1-\cos(\theta))\left(\mathbf{\hat{u}}^T\right)^2\right)\left(\mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2\right) \\
=&amp;\ (\mathcal{I} - \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2)\left(\mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2\right) \\
=&amp;\ \mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2 - \sin(\theta)\mathbf{\hat{u}} - \sin^2(\theta)\mathbf{\hat{u}}^2 - \sin(\theta)(1-\cos(\theta))\mathbf{\hat{u}}^3 \\&amp;+ (1-\cos(\theta))\mathbf{\hat{u}}^2 + \sin(\theta)(1-\cos(\theta))\mathbf{\hat{u}}^3 + (1-\cos(\theta))^2\mathbf{\hat{u}}^4 \\
=&amp;\ \mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2 - \sin(\theta)\mathbf{\hat{u}} - \sin^2(\theta)\mathbf{\hat{u}}^2 + \sin(\theta)(1-\cos(\theta))\mathbf{\hat{u}} \\&amp;+ (1-\cos(\theta))\mathbf{\hat{u}}^2 - \sin(\theta)(1-\cos(\theta))\mathbf{\hat{u}} - (1-\cos(\theta))^2\mathbf{\hat{u}}^2\\
=&amp;\ \mathcal{I} + 2(1-\cos(\theta))\mathbf{\hat{u}}^2  - \sin^2(\theta)\mathbf{\hat{u}}^2 - (1-\cos(\theta))^2\mathbf{\hat{u}}^2\\
=&amp;\ \mathcal{I} + (-\sin^2(\theta) + 2(1-\cos(\theta)) - (1-\cos(\theta))^2)\mathbf{\hat{u}}^2\\
=&amp;\ \mathcal{I} + (-\sin^2(\theta)+1-\cos^2(\theta))\mathbf{\hat{u}}^2\\
=&amp;\ \mathcal{I} + (1-(\sin^2(\theta)+\cos^2(\theta)))\mathbf{\hat{u}}^2\\
=&amp;\ \mathcal{I}
\end{align*}\]

</p><p>Therefore, \(e^{\theta\mathbf{\hat{u}}}\) is orthonormal. We could show its determinant is positive (and therefore \(1\)) by writing out all the terms, but it suffices to argue that:</p>

<ul>
  <li>Clearly, \(\begin{vmatrix}\exp(0\mathbf{\hat{u}})\end{vmatrix} = \begin{vmatrix}\mathcal{I}\end{vmatrix} = 1\)</li>
  <li>There is no \(\theta\), \(\mathbf{\hat{u}}\) such that \(\begin{vmatrix}\exp(\theta\mathbf{\hat{u}})\end{vmatrix} = 0\), since \(\mathbf{\hat{u}}\) and \(\mathbf{\hat{u}}^2\) can never cancel out \(\mathcal{I}\).</li>
  <li>\(\exp\) is continuous with respect to \(\theta\) and \(\mathbf{\hat{u}}\)</li>
</ul>

<p>Therefore, \(\begin{vmatrix}\exp(0\mathbf{\hat{u}})\end{vmatrix}\) can never become negative. That means \(\exp(\theta\mathbf{\hat{u}})\) is a 3D rotation matrix!</p>

<h3 id="the-3d-logarithmic-map">The 3D Logarithmic Map</h3>

<p>Similarly to the 2D case, the 3D exponential map is not injective, so the 3D logarithmic map will not be surjective. Instead, we will again define it to return the <em>smallest magnitude</em> axis-angle rotation corresponding to the given matrix. Our exponential map gave us:</p><p>

\[R = \exp(\theta\mathbf{\hat{u}}) = \mathcal{I} + \sin(\theta)\mathbf{\hat{u}} + (1-\cos(\theta))\mathbf{\hat{u}}^2\]

</p><p>We can take the <a href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)">trace</a> (sum along the diagonal) of both sides:</p><p>

\[\operatorname{tr}(R) = \operatorname{tr}(\mathcal{I}) + \sin(\theta)\operatorname{tr}(\mathbf{\hat{u}}) + (1-\cos(\theta))\operatorname{tr}(\mathbf{\hat{u}}^2)\]

</p><p>Clearly \(\operatorname{tr}(\mathcal{I}) = 3\), and since \(\mathbf{\hat{u}}\) is skew-symmetric, its diagonal sum is zero. That just leaves \(\mathbf{\hat{u}}^2\):</p><p>

\[\mathbf{\hat{u}}^2 = \begin{bmatrix}-u_y^2-u_z^2&amp;u_xu_y&amp;u_xu_z\\u_xu_y&amp;-u_x^2-u_z^2&amp;u_yu_z\\u_xu_z&amp;u_yu_z&amp;-u_x^2-u_y^2\end{bmatrix}\]

</p><p>We can see \(\operatorname{tr}(\mathbf{\hat{u}}^2) = -2u_x^2-2u_y^2-2u_z^2 = -2\|\mathbf{u}\|^2 = -2\). (We originally defined \(\mathbf{u}\) as a unit vector.) Our final trace becomes:</p><p>

\[\begin{align*} &amp;&amp; \operatorname{tr}(R) &amp;= 3 + 0\sin(\theta) - 2(1-\cos(\theta)) \\ &amp;&amp;&amp;= 1 + 2\cos\theta \\
&amp;\implies&amp; \theta &amp;= \arccos\left(\frac{\operatorname{tr}(R)-1}{2}\right) \end{align*}\]

</p><p>That’s half of our logarithmic map. To recover \(\mathbf{\hat{u}}\), we can antisymmetrize \(R\). Recall \(\mathbf{\hat{u}}^T = -\mathbf{\hat{u}}\), and that \(\mathbf{\hat{u}}^2\) is symmetric (above).</p><p>

\[\begin{align*}
&amp;&amp; R - R^T &amp;= \mathcal{I} - \mathcal{I}^T + \sin(\theta)(\mathbf{\hat{u}}-\mathbf{\hat{u}}^T) + (1-\cos(\theta))(\mathbf{\hat{u}}^2-(\mathbf{\hat{u}}^2)^T) \\
&amp;&amp;&amp;= \sin(\theta)(\mathbf{\hat{u}}+\mathbf{\hat{u}}) + (1-\cos(\theta))(\mathbf{\hat{u}}^2-\mathbf{\hat{u}}^2) \\
&amp;&amp;&amp;= 2\sin(\theta)\mathbf{\hat{u}} \\
&amp;\implies&amp; \mathbf{\hat{u}} &amp;= \frac{1}{2\sin\theta}(R-R^T) \\
\end{align*}\]

</p><p>Finally, to get \(\mathbf{u}\), we can pull out the entries of \(\mathbf{\hat{u}}\), which we just derived:</p><p>

\[\mathbf{u} = \frac{1}{2\sin\theta}\begin{bmatrix}R_{32}-R_{23}\\ R_{13}-R_{31}\\R_{21}-R_{12}\end{bmatrix}\]

</p><p>We now have our full 3D logarithmic map!</p>

<h3 id="interpolation-1">Interpolation</h3>

<p>Now equipped with our 3D <code>exp</code> and <code>log</code> maps, we can use them for interpolation. The exact same formula as the 2D case still applies:</p><p>

\[R(t) = \exp(t\log(R_1R_0^{-1})))R_0\]

</p><canvas id="3d_exp_interp"></canvas>


<table><tbody><tr>
<td>$$ R_0 = \begin{bmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix} $$</td>
<td id="3d_exp_interp_mj">$$ R(0.00) = \begin{bmatrix}\phantom{-}1.00&amp;\phantom{-}0.00&amp;\phantom{-}0.00\\\phantom{-}0.00&amp;\phantom{-}1.00&amp;\phantom{-}0.00\\\phantom{-}0.00&amp;\phantom{-}0.00&amp;\phantom{-}1.00\end{bmatrix} $$</td>
<td id="3d_exp_interp_m1">$$ R_1 = \begin{bmatrix}-0.42&amp;-0.59&amp;-0.69\\0.51&amp;-0.79&amp;0.36\\-0.75&amp;-0.20&amp;0.63\end{bmatrix} $$</td>
</tr></tbody></table>

<p>Our interpolation scheme produces all the nice properties of axis/angle rotations—<strong>and</strong> chooses the shortest path every time. This wouldn’t look so smooth with Euler angles!</p>

<h2 id="averaging-rotations">Averaging Rotations</h2>

<p>However, we would have gotten an equally good interpolation scheme by just using quaternions instead of messing about with all this matrix math. Let’s consider something interesting we can <em>only</em> easily do with axis/angle rotations: averaging a set of rotation matrices.</p>

<p>The most straightforward method is to convert each matrix into an axis/angle rotation, average the resulting vectors, and convert back. That is certainly a valid strategy, but the resulting behavior won’t be very intuitive:</p>

<canvas id="rot_avg"></canvas>


<p>In particular, summing axis-angle vectors can result in “catastrophic cancellation.” An extreme example is averaging \(\begin{bmatrix}\pi&amp;0&amp;0\end{bmatrix}\) and \(\begin{bmatrix}-\pi&amp;0&amp;0\end{bmatrix}\), resulting in zero—which is clearly not representative of the two equivalent rotations.</p>

<p>To find an alternative, let’s first consider a slightly unconventional way of averaging points in the plane. The average of a set of points is the point that minimizes total squared distance to all others. Hence, there’s an optimization-based algorithm for finding it. Given \(x_0, \dots, x_n\), we can iterate the following procedure:</p>

<ul>
  <li>Pick an initial guess \(\bar{x} \in \mathbb{R}^2\) (can be one of the points).</li>
  <li>Repeat:
    <ul>
      <li>For each point, get its translation from the guess: \(\mathbf{u}_i \leftarrow x_i - \bar{x}\)</li>
      <li>Average the vectors: \(\mathbf{u} \leftarrow \frac{1}{n} \sum_{i=1}^n \mathbf{u}_i\)</li>
      <li>Step toward the average direction: \(\bar{x} \leftarrow \bar{x} + \tau\mathbf{u}\)</li>
    </ul>
  </li>
  <li>while \(\|\mathbf{u}\| &gt; \epsilon\).</li>
</ul>

<p><img src="http://thenumb.at/assets/exp-rotations/pointavg.svg"/></p>

<p>As we run this procedure, \(\bar{x}\) will converge to the average point. Of course, we could have just averaged the points directly, but we’ll be able to translate this idea to the rotational case rather nicely.</p>

<p>Our logarithmic map lets us convert rotation matrices to axis axis/angle rotations, which are themselves just 3D points. So, what if we use the point averaging algorithm on rotations \(R_0, \dots, R_n\)?</p>

<ul>
  <li>Pick an initial guess \(\bar{R} \in \mathbb{R}^{3\times3}\) (can be \(\mathcal{I}\)).</li>
  <li>Repeat:
    <ul>
      <li>For each matrix, get its axis/angle rotation from the guess: \(\mathbf{u}_i \leftarrow \log(R_i\bar{R}^{-1})\)</li>
      <li>Average the vectors: \(\mathbf{u} \leftarrow \frac{1}{n} \sum_{i=1}^n \mathbf{u}_i\)</li>
      <li>Step toward the average rotation: \(\bar{R} \leftarrow \exp(\tau\mathbf{u})\bar{R}\)</li>
    </ul>
  </li>
  <li>while \(\|\mathbf{u}\| &gt; \epsilon\).</li>
</ul>

<canvas id="karcher"></canvas>


<p>The result of this algorithm is formally known as the <em>Karcher mean</em>. Just like how the average point minimizes total squared distance from all other points, the Karcher mean is a rotation that minimizes squared <em>angular</em> distance from all other rotations. Therefore, it won’t be subject to catastrophic cancellation—we’ll always end up with a non-zero in-between rotation.</p>

<p>Try comparing the two averaging algorithms—randomizing will keep them in sync. While the results are often similar, the Karcher mean exhibits more consistent behavior.</p>

<h2 id="quaternions-again">Quaternions (Again)</h2>

<p><em>Warning: section assumes knowledge of quaternions</em></p>

<p>Okay, I couldn’t resist talking about quaternions at least a little bit, given how closely they’re related to axis/angle rotations. Just like how complex exponentiation turned out to be equivalent to (skew-symmetric) 2D matrix exponentiation, quaternion exponentiation is equivalent to (skew-symmetric) 3D matrix exponentiation.</p>

<p>In 2D, an axis/angle rotation was simply \(\theta\). We created a pure-imaginary complex number \(i\theta\) and exponentiated it:</p><p>

\[e^{i\theta} = \cos\theta + i\sin\theta\]

</p><p>We got back a complex number that when multiplied with a point, rotates it by \(\theta\). It’s always the case that \(\|\cos\theta + i\sin\theta\| = 1\), so 2D rotations can be represented as unit-norm complex numbers.</p>

<p>In 3D, an axis/angle rotation is a vector \(\mathbf{u}\) such that \(\|\mathbf{u}\| = \theta\). What happens if we create a pure-imaginary quaternion \(\mathbf{q} = u_x\mathbf{i} + u_y\mathbf{j} + u_z\mathbf{k}\) and exponentiate it, too?</p>

<p>To make evaluating \(e^\mathbf{q}\) easier, first derive the following using the quaternion <a href="https://en.wikipedia.org/wiki/Quaternion#Multiplication_of_basis_elements">multiplication rules</a>:</p><p>

\[\begin{align*}
\mathbf{q}^2 &amp;= (u_x\mathbf{i} + u_y\mathbf{j} + u_z\mathbf{k})(u_x\mathbf{i} + u_y\mathbf{j} + u_z\mathbf{k}) \\
             &amp;= u_x^2\mathbf{i}^2 + u_xu_y\mathbf{i}\mathbf{j} + u_xu_z\mathbf{i}\mathbf{k} + u_yu_x\mathbf{j}\mathbf{i} + u_y^2\mathbf{j}^2 + u_yu_z\mathbf{j}\mathbf{k} + u_zu_x\mathbf{k}\mathbf{i} + u_zu_y\mathbf{k}\mathbf{j} + u_z^2\mathbf{k}^2 \\
             &amp;= -u_x^2 + u_xu_y\mathbf{k} - u_xu_z\mathbf{j} - u_yu_x\mathbf{k} - u_y^2 + u_yu_z\mathbf{i} + u_zu_x\mathbf{j} - u_zu_y\mathbf{i} - u_z^2 \\
             &amp;= -u_x^2-u_y^2-u_z^2\\
             &amp;= -\|\mathbf{q}\|^2\\
             &amp;= -\theta^2
\end{align*}\]

</p><p>Which is highly reminiscent of the skew-symmetric matrix identity used above. Therefore…</p><p>

\[\begin{align*}
e^\mathbf{q} &amp;= 1 + \mathbf{q} + \frac{\mathbf{q}^2}{2!} + \frac{\mathbf{q}^3}{3!} + \frac{\mathbf{q}^4}{4!} + \frac{\mathbf{q}^5}{5!} + \dots \\
             &amp;= 1 + \frac{\theta\mathbf{q}}{\theta} - \frac{\theta^2}{2!} - \frac{\theta^3\mathbf{q}}{3!\theta} + \frac{\theta^4}{4!} + \frac{\theta^5\mathbf{q}}{5!\theta} \dots \\
             &amp;= \left(1 - \frac{\theta^2}{2!} + \frac{\theta^4}{4!} - \dots\right) + \frac{\mathbf{q}}{\theta}\left(\theta - \frac{\theta^3}{3!} + \frac{\theta^5}{5!} - \dots\right) \\
             &amp;= \cos\theta + \frac{\mathbf{q}}{\theta}\sin\theta \\
             &amp;\approx \cos\theta + \frac{\mathbf{u}}{\|\mathbf{u}\|}\sin\theta
\end{align*}\]

</p><p>Our result looks almost exactly like the 2D case, just with three imaginary axes instead of one. In 2D, our axis/angle rotation became a unit-norm complex number. In 3D, it became a unit-norm quaternion. Now we can use this quaternion to rotate 3D points! Pretty cool, right?</p>

<p>One advantage of using quaternions is how easy the exponential map is to compute—if you don’t need a rotation matrix, it’s a good option. The quaternion logarithmic map is similarly simple:</p><p>

\[\theta = \arccos(\Re(\mathbf{q})), \mathbf{u} = \frac{1}{\sin\theta}\Im(\mathbf{q})\]

</p><p>Finally, note that the way to rotate a point \(\mathbf{p}\) by a quaternion \(\mathbf{q}\) is by evaluating the conjugation \(\mathbf{q}\mathbf{p}\mathbf{q}^{-1}\), where \(\mathbf{p} = p_x\mathbf{i} + p_y\mathbf{j} + p_z\mathbf{k}\) is another pure-imaginary quaternion representing our point. The conjugation technically rotates the point by \(2\theta\) about \(\mathbf{u}\), but that’s easily accounted for by making \(\|\mathbf{u}\| = \frac{\theta}{2}\) in the beginning.</p>



<p>Made it this far? Well, there’s even more to learn about rotations.</p>

<p>Learn about quaternions <a href="https://eater.net/quaternions">here</a>, and why geometric algebra is more intuitive <a href="https://marctenbosch.com/quaternions/">here</a>.</p>

<p>Beyond understanding the four representations covered here (plus geometric algebra), it can be enlightening to learn about the algebraic structure underlying all 3D rotations: the group \(SO(3)\). I found <a href="https://www.youtube.com/watch?v=ACZC_XEyg9U">this video</a> to be a great resource: it explains \(SO(3)\) both intuitively and visually, demonstrating how it relates it to the group \(SU(2)\) as well as why quaternions and axis/angle rotations double-cover 3D rotation matrices.</p>

<p>The <a href="https://en.wikipedia.org/wiki/3D_rotation_group">wikipedia page on SO(3)</a> is also informative, though <em>very</em> math heavy. It touches on connections with axis/angle rotations, topology, \(SU(2)\), quaternions, and Lie algebra. It turns out the vector space of skew-symmetric matrices we derived above makes up \(\mathfrak{so}(3)\), the Lie algebra that corresponds to \(SO(3)\)—but I don’t know what that entails.</p>




  </div></div>
  </body>
</html>
