<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://leafo.net/guides/dsl-in-lua.html">Original</a>
    <h1>Writing a DSL in Lua (2015)</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p>DSLs, or domain specific languages, are programming languages that are designed
to implement a set of features specific to a particular problem or field. An
example could be <a href="https://www.gnu.org/software/make/">Make</a>, the build tool,
which is a specially designed language for combining commands and files while
managing dependencies.</p>




<p>A lot of modern programming languages have so much flexibility in their syntax
that it’s possible to build libraries that expose their own mini-languages
within the host language. The definition of DSL has broadened to include these
kinds of libraries.</p>

<p>In this guide we&#39;ll build a DSL for generating HTML. It looks like this:</p>

<pre><code><span></span><span>html</span> <span>{</span>
  <span>body</span> <span>{</span>
    <span>h1</span> <span>&#34;Welcome to my Lua site&#34;</span><span>,</span>
    <span>a</span> <span>{</span>
      <span>href</span> <span>=</span> <span>&#34;http://leafo.net&#34;</span><span>,</span>
      <span>&#34;Go home&#34;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code>
</pre>


<p>Before jumping in, here are some DSL building techniques:</p>

<h2 id="dropping-the-parenthesis">Dropping the parenthesis</h2>

<p>One of the cases for Lua as described in its <a href="http://www.lua.org/spe.html">initial public release</a> (1996) is
that it makes a good configuration language. That’s still true to this day, and
Lua is friendly to building DSLs.</p>

<p>A unique part about Lua’s syntax is parenthesis are optional in some scenarios
when calling functions. Terseness is important when building a DSL, and
removing superfluous characters is a good way to do that.</p>

<p>When calling a function that has a single argument of either a table literal or
a string literal, the parenthesis are optional.</p>

<pre><code><span></span><span>print</span> <span>&#34;hello&#34;</span> <span>--&gt; print(&#34;hello&#34;)</span>
<span>my_function</span> <span>{</span> <span>1</span><span>,</span><span>2</span><span>,</span><span>3</span> <span>}</span> <span>--&gt; my_function({1,2,3})</span>

<span>-- whitespace isn&#39;t needed, these also work:</span>

<span>print</span><span>&#34;hello&#34;</span> <span>--&gt; print(&#34;hello&#34;)</span>
<span>my_function</span><span>{</span> <span>1</span><span>,</span><span>2</span><span>,</span><span>3</span> <span>}</span> <span>--&gt; my_function({1,2,3})</span></code>
</pre>


<p>This syntax has very high precedence, the same as if you were using
parenthesis:</p>

<pre><code><span></span><span>tonumber</span> <span>&#34;1234&#34;</span> <span>+</span> <span>5</span> <span>-- &gt; tonumber(&#34;1234&#34;) + 5</span></code>
</pre>


<h2 id="chaining">Chaining</h2>

<p>Parenthesis-less invocation can be chained as long as each expression from the
left evaluates to a function (or a  callable table). Here’s some example syntax
for a hypothetical web routing framework:</p>

<pre><code><span></span><span>match</span> <span>&#34;/post-comment&#34;</span> <span>{</span>
  <span>GET</span> <span>=</span> <span>function</span> <span>()</span>
    <span>-- render the form</span>
  <span>end</span><span>,</span>

  <span>POST</span> <span>=</span> <span>function</span> <span>()</span>
    <span>-- save to database</span>
  <span>end</span>
<span>}</span></code>
</pre>


<p>If it’s not immediately obvious what’s going on, writing the parenthesis in
will clear things up. The precedence of the parenthesis-less invocation goes
from left to right, so the above is equivalent to:</p>

<pre><code><span></span><span>match</span><span>(</span><span>&#34;/post-comment&#34;</span><span>)({</span> <span>...</span> <span>})</span></code>
</pre>


<p>The pattern we would use to implement this syntax would look something like
this:</p>

<pre><code><span></span><span>local</span> <span>function</span> <span>match</span><span>(</span><span>path</span><span>)</span>
  <span>print</span><span>(</span><span>&#34;match:&#34;</span><span>,</span> <span>path</span><span>)</span>

  <span>return</span> <span>function</span><span>(</span><span>params</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;params:&#34;</span><span>,</span> <span>params</span><span>)</span>
    <span>-- both path and params are now availble for use here</span>
  <span>end</span>
<span>end</span></code>
</pre>


<p>Using a recursive function constructor it’s possible to make chaining work for
any length.</p>

<h2 id="using-function-environments">Using function environments</h2>

<p>When interacting with a Lua module you regularly have to bring any functions or
values into scope using <code>require</code>. When working with a DSL, it’s nice to have
all the functionality available without having to manually load anything.</p>

<p>One option would be to make all the functions and values global variables, but
it’s not recommended as it might interfere with other libraries.</p>

<p>A <em>function environment</em> can be used to change how a function resolves global
variable references within its scope. This can be used to automatically expose
a DSL’s functionality without polluting the regular global scope.</p>

<p>For the sake of this guide I&#39;ll assume that <code>setfenv</code> exists in the version of
Lua we&#39;re using. If you&#39;re using 5.2 or above you&#39;ll need to provide you own
implementation: <a href="https://leafo.net/guides/setfenv-in-lua52-and-above.html">Implementing setfenv in Lua 5.2, 5.3, and above</a></p>

<p>Here’s a function <code>run_with_env</code> that runs another function with a particular
environment.</p>

<pre><code><span></span><span>local</span> <span>function</span> <span>run_with_env</span><span>(</span><span>env</span><span>,</span> <span>fn</span><span>,</span> <span>...)</span>
  <span>setfenv</span><span>(</span><span>fn</span><span>,</span> <span>env</span><span>)</span>
  <span>fn</span><span>(...)</span>
<span>end</span></code>
</pre>


<p>The environment passed will represent the DSL:</p>

<pre><code><span></span><span>local</span> <span>dsl_env</span> <span>=</span> <span>{</span>
  <span>move</span> <span>=</span> <span>function</span><span>(</span><span>x</span><span>,</span><span>y</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;I moved to&#34;</span><span>,</span> <span>x</span><span>,</span> <span>y</span><span>)</span>
  <span>end</span><span>,</span>

  <span>speak</span> <span>=</span> <span>function</span><span>(</span><span>message</span><span>)</span>
    <span>print</span><span>(</span><span>&#34;I said&#34;</span><span>,</span> <span>message</span><span>)</span>
  <span>end</span>
<span>}</span>

<span>run_with_env</span><span>(</span><span>dsl_env</span><span>,</span> <span>function</span><span>()</span>
  <span>move</span><span>(</span><span>10</span><span>,</span> <span>10</span><span>)</span>
  <span>speak</span><span>(</span><span>&#34;I am hungry!&#34;</span><span>)</span>
<span>end</span><span>)</span></code>
</pre>


<p>In this trivial example the benefits might not be obvious, but typically your
DSL would be implemented in another module, and each place you invoke it is not
necessary to bring each function into scope manually, but rather activate the
whole sscope with <code>run_with_env</code>.</p>

<p>Function environments also let you dynamically generate methods on the fly.
Using the <code>__index</code> metamethod implemented as a function, any value can be
programmatically created. This is how the HTML builder DSL will be created.</p>

<h2 id="implementing-the-html-builder">Implementing the HTML builder</h2>

<p>Our goal is to make the following syntax work:</p>

<pre><code><span></span><span>html</span> <span>{</span>
  <span>body</span> <span>{</span>
    <span>h1</span> <span>&#34;Welcome to my Lua site&#34;</span><span>,</span>
    <span>a</span> <span>{</span>
      <span>href</span> <span>=</span> <span>&#34;http://leafo.net&#34;</span><span>,</span>
      <span>&#34;Go home&#34;</span>
    <span>}</span>
  <span>}</span>
<span>}</span></code>
</pre>


<p>Each HTML tag is represented by a Lua function that will return the HTML string
representing that tag with the correct attribute and content if necessary.</p>

<p>Although it would be possible to write code to generate all the HTML tag
builder functions ahead of time, a function <code>__index</code> metamethod will be used
to generate them on the fly.</p>

<p>In order to run code in the context of our DSL, it must be packaged into a
function. The <code>render_html</code> function will take that function and convert it to
a HTML string:</p>

<pre><code><span></span><span>render_html</span><span>(</span><span>function</span><span>()</span>
  <span>return</span> <span>div</span> <span>{</span>
    <span>img</span> <span>{</span> <span>src</span> <span>=</span> <span>&#34;http://leafo.net/hi&#34;</span> <span>}</span>
  <span>}</span>
<span>end</span><span>)</span> <span>-- &gt; &lt;div&gt;&lt;img src=&#34;http://leafo.net/hi&#34; /&gt;&lt;/div&gt;</span></code>
</pre>


<blockquote><p>The <code>img</code> tag is self-closing, it has no separate close tag. HTML calls these
“<a href="http://www.w3.org/TR/html-markup/syntax.html#void-elements">void
elements</a>”.
These will be treated differently in the implementation.</p></blockquote>

<p><code>render_html</code> might be implemented like this:</p>

<pre><code><span></span><span>local</span> <span>function</span> <span>render_html</span><span>(</span><span>fn</span><span>)</span>
  <span>setfenv</span><span>(</span><span>fn</span><span>,</span> <span>setmetatable</span><span>({},</span> <span>{</span>
    <span>__index</span> <span>=</span> <span>function</span><span>(</span><span>self</span><span>,</span> <span>tag_name</span><span>)</span>
      <span>return</span> <span>function</span><span>(</span><span>opts</span><span>)</span>
        <span>return</span> <span>build_tag</span><span>(</span><span>tag_name</span><span>,</span> <span>opts</span><span>)</span>
      <span>end</span>
    <span>end</span>
  <span>}))</span>

  <span>return</span> <span>fn</span><span>()</span>
<span>end</span></code>
</pre>


<p>The <code>build_tag</code> function is where all actual work is done. It takes the name of
the tag, and the attributes and content as a single table.</p>

<blockquote><p>This function could be optimized by caching the generated functions in the
environment table.</p></blockquote>

<p>The <a href="http://www.w3.org/TR/html-markup/syntax.html#void-elements">void
elements</a>, as
mentioned above, are defined as a simple set: </p>

<pre><code><span></span><span>local</span> <span>void_tags</span> <span>=</span> <span>{</span>
  <span>img</span> <span>=</span> <span>true</span><span>,</span>
  <span>-- etc...</span>
<span>}</span></code>
</pre>


<p>The most efficient way to concatenate strings in regular Lua is to accumulate
them into a table then call <code>table.concat</code>. Many calls to <code>table.insert</code>
could be used to append to this buffer table, but I prefer the following
function to allow multiple values to be appended at once:</p>

<pre><code><span></span><span>local</span> <span>function</span> <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>...)</span>
  <span>for</span> <span>i</span><span>=</span><span>1</span><span>,</span><span>select</span><span>(</span><span>&#34;#&#34;</span><span>,</span> <span>...)</span> <span>do</span>
    <span>table.insert</span><span>(</span><span>buffer</span><span>,</span> <span>(</span><span>select</span><span>(</span><span>i</span><span>,</span> <span>...)))</span>
  <span>end</span>
<span>end</span>

<span>-- example:</span>
<span>--   local buffer = {}</span>
<span>--   append_all(buffer, &#34;a&#34;, &#34;b&#34;, c)</span>
<span>-- buffer now is {&#34;a&#34;, &#34;b&#34;, &#34;c&#34;}</span></code>
</pre>


<blockquote><p><code>append_all</code> uses Lua’s built in function <code>select</code> to avoid any extra
allocations by querying the varargs object instead of creating a new table.</p></blockquote>

<p>Now the implementation of <code>build_tag</code>:</p>

<pre><code><span></span><span>local</span> <span>function</span> <span>build_tag</span><span>(</span><span>tag_name</span><span>,</span> <span>opts</span><span>)</span>
  <span>local</span> <span>buffer</span> <span>=</span> <span>{</span><span>&#34;&lt;&#34;</span><span>,</span> <span>tag_name</span><span>}</span>
  <span>if</span> <span>type</span><span>(</span><span>opts</span><span>)</span> <span>==</span> <span>&#34;table&#34;</span> <span>then</span>
    <span>for</span> <span>k</span><span>,</span><span>v</span> <span>in</span> <span>pairs</span><span>(</span><span>opts</span><span>)</span> <span>do</span>
      <span>if</span> <span>type</span><span>(</span><span>k</span><span>)</span> <span>~=</span> <span>&#34;number&#34;</span> <span>then</span>
        <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>&#34; &#34;</span><span>,</span> <span>k</span><span>,</span> <span>&#39;=&#34;&#39;</span><span>,</span> <span>v</span><span>,</span> <span>&#39;&#34;&#39;</span><span>)</span>
      <span>end</span>
    <span>end</span>
  <span>end</span>

  <span>if</span> <span>void_tags</span><span>[</span><span>tag_name</span><span>]</span> <span>then</span>
    <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>&#34; /&gt;&#34;</span><span>)</span>
  <span>else</span>
    <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>&#34;&gt;&#34;</span><span>)</span>
    <span>if</span> <span>type</span><span>(</span><span>opts</span><span>)</span> <span>==</span> <span>&#34;table&#34;</span> <span>then</span>
      <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>unpack</span><span>(</span><span>opts</span><span>))</span>
    <span>else</span>
      <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>opts</span><span>)</span>
    <span>end</span>
    <span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>&#34;&lt;/&#34;</span><span>,</span> <span>tag_name</span><span>,</span> <span>&#34;&gt;&#34;</span><span>)</span>
  <span>end</span>

  <span>return</span> <span>table.concat</span><span>(</span><span>buffer</span><span>)</span>
<span>end</span></code>
</pre>


<p>There are a couple interesting things here:</p>

<p>The <code>opts</code> argument can either be a string literal or a table.  When it’s a
table it takes advantage of the fact that Lua tables are both hash tables and
arrays at the same time. The hash table portion holds the attributes of the
HTML element, and the array portion holds the contents of the element.</p>

<p>Checking if the key in a <code>pairs</code> iteration is numeric is a quick way to
approximate isolating array like elements. It’s not perfect, but will work for
this case.</p>

<pre><code><span></span><span>for</span> <span>k</span><span>,</span><span>v</span> <span>in</span> <span>pairs</span><span>(</span><span>opts</span><span>)</span> <span>do</span>
  <span>if</span> <span>type</span><span>(</span><span>k</span><span>)</span> <span>~=</span> <span>&#34;number&#34;</span> <span>then</span>
    <span>-- access hash table key and values</span>
  <span>end</span>
<span>end</span></code>
</pre>


<p>When the content of the tag is inserted into the buffer for the table based
<code>opts</code>, the following line is used:</p>

<pre><code><span></span><span>append_all</span><span>(</span><span>buffer</span><span>,</span> <span>unpack</span><span>(</span><span>opts</span><span>))</span></code>
</pre>


<p>Lua’s built in function <code>unpack</code> converts the array values in a table to
varargs. This fits perfectly into the <code>append_all</code> function defined above.</p>

<blockquote><p><code>unpack</code> is <code>table.unpack</code> in Lua 5.2 and above.</p></blockquote>

<h2 id="closing">Closing</h2>

<p>This simple implementation of an HTML builder that should give you a good
introduction to building your own DSLs in Lua.</p>

<p>The HTML builder provided performs no HTML escaping. It’s not suitable for
rendering untrusted input. If you&#39;re looking for a way to enhance the builder
then try adding html escaping. For example: </p>

<pre><code><span></span><span>local</span> <span>unsafe_text</span> <span>=</span> <span>[[&lt;script type=&#34;text/javascript&#34;&gt;alert(&#39;hacked!&#39;)&lt;/script&gt;]]</span>

<span>render_html</span><span>(</span><span>function</span><span>()</span>
  <span>return</span> <span>div</span><span>(</span><span>unsafe_text</span><span>)</span>
<span>end</span><span>)</span>

<span>-- should not return a functional script tag:</span>
<span>-- &lt;div&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;alert(&#39;hacked!&#39;)&amp;lt;/script&amp;gt;&lt;/div&gt;</span></code>
</pre>

</div></div></div></div>
  </body>
</html>
