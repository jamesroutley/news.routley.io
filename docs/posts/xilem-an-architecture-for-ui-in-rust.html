<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://raphlinus.github.io/rust/gui/2022/05/07/ui-architecture.html">Original</a>
    <h1>Xilem: an architecture for UI in Rust</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p>Rust is an appealing language for building user interfaces for a variety of reasons, especially the promise of delivering both performance and safety. However, finding a good <em>architecture</em> is challenging. Architectures that work well in other languages generally don’t adapt well to Rust, mostly because they rely on shared mutable state and that is not idiomatic Rust, to put it mildly. It is sometimes asserted for this reason that Rust is a poor fit for UI. I have long believed that it is possible to find an architecture for UI well suited to implementation in Rust, but my previous attempts (including the current <a href="https://github.com/linebender/druid">Druid</a> architecture) have all been flawed. I have studied a range of other Rust UI projects and don’t feel that any of those have suitable architecture either.</p>

<p>This post presents a new architecture, which is a synthesis of existing work and a few new ideas. The goals include expression of modern reactive, declarative UI, in components which easily compose, and a high performance implementation. UI code written in this architecture will look very intuitive to those familiar with state of the art toolkits such as SwiftUI, Flutter, and React, while at the same time being idiomatic Rust.</p>

<p>The name “Xilem” is derived from <a href="https://en.wikipedia.org/wiki/Xylem">xylem</a>, a type of transport tissue in vascular plants, including trees. The word is spelled with an “i” in several languages including Romanian and Malay, and is a reference to <a href="https://xi-editor.io/">xi-editor</a>, a starting place for explorations into UI in Rust (now on hold).</p>

<p>Like most modern UI architectures, Xilem is based on a <em>view tree</em> which is a simple declarative description of the UI. For incremental update, successive versions of the view tree are <em>diffed,</em> and the results are applied to a widget tree which is more of a traditional retained-mode UI. Xilem also contains at heart an incremental computation engine with precise change propagation, specialized for UI use.</p>

<p>The most innovative aspect of Xilem is event dispatching based on an <em>id path,</em> at each stage providing mutable access to app state. A distinctive feature is Adapt nodes (an evolution of the lensing concept in Druid) which facilitate composition of components. By routing events <em>through</em> Adapt nodes, subcomponents have access to a different mutable state reference than the parent.</p>

<h2 id="a-quick-tour-of-existing-architectures">A quick tour of existing architectures</h2>

<p>This architecture is designed to address limitations and problems with the existing state of the art, both the current <a href="https://github.com/linebender/druid">Druid</a> architecture and other attempts. It’s a little hard to understand some of the motivation without some knowledge of those architectures. That said, a full survey of reactive UI architectures would be quite a long work; this section can only touch the highlights.</p>

<p>The existing Druid architecture has some nice features, but we consistently see people struggle with common themes.</p>

<ul>
  <li>There is a big difference between creating static widget hierarchies and dynamically updating them.</li>
  <li>The app data must have a <a href="https://docs.rs/druid/latest/druid/trait.Data.html">Data</a> bound, which implies cloning and equality testing. Interior mutability is effectively forbidden.</li>
  <li>The “lens” mechanism is confusing and it is not easy to implement complex binding patterns.</li>
  <li>We never figured out how to integrate async in a compelling way.</li>
  <li>There is an environment mechanism but it is not efficient and doesn’t support fine-grained change propagation.</li>
</ul>

<p>Another common architecture is immediate mode GUI, both in a relatively pure form and in a modified form. It is popular in Rust because it doesn’t require shared mutable state. It also benefits from overall system simplicity. However, the model is oversimplified in a number of ways, and it is difficult to do sophisticated layout and other patterns that are easier in retained widget systems. There are also numerous papercuts related to sometimes rendering stale state. (I experimented with a retained widget backend emulating an immediate mode API in the “crochet” architecture experiment and concluded that the result was not compelling). The popular <a href="https://github.com/emilk/egui">egui</a> crate is solidly an implementation of immediate mode, and <a href="https://github.com/makepad/makepad">makepad</a> is also based on it, though it differs in some important ways.</p>

<p>A particularly common architecture for UI in Rust is <a href="https://guide.elm-lang.org/architecture/">The Elm Architecture</a>, which also does not require shared mutable state. Rather, to support interactions from the UI, gestures and other related UI actions creates <em>messages</em> which are then sent to an <code>update</code> method which takes central app state. <a href="https://iced.rs/">Iced</a>, <a href="https://github.com/antoyo/relm">relm</a>, and <a href="https://github.com/vizia/vizia">Vizia</a> all use some form of this architecture. Generally it works well, but the need to create an explicit message type and dispatch on it is verbose, and the Elm architecture does not support cleanly factored components as well as some other architures. The <a href="https://guide.elm-lang.org/webapps/structure.html">Elm documentation</a> specifically warns against components, saying, “actively trying to make components is a recipe for disaster in Elm.”</p>

<p>Lastly, there are a number of serious attempts to port React patterns to Rust, of which I find <a href="https://dioxuslabs.com/">Dioxus</a> most promising. These rely on interior mutability and other patterns that I think adapt poorly to Rust, but definitely represent a credible alternative to the ideas presented here. I think we will have to build some things and see how well they work out.</p>

<h2 id="synchronized-trees">Synchronized trees</h2>

<p>The Xilem architecture is based around generating trees and keeping them synchronized. In that way it is a refinement of the ideas described in my previous blog post, <a href="https://raphlinus.github.io/ui/druid/2019/11/22/reactive-ui.html">Towards a unified theory of reactive UI</a>.</p>

<p>In each “cycle,” the app produces a view tree, from which rendering is derived. This tree has fairly short lifetime; each time the UI is updated, a new tree is generated. From this, a widget tree is built (or rebuilt). The view tree is retained only long enough to assist in event dispatching and then be diffed against the next version, at which point it is dropped. The widget tree, by contrast, persists across cycles. In addition to these two trees, there is a third tree containing <em>view state,</em> which also persists across cycles. (The view state serves a very similar function as React hooks)</p>

<p>Of existing UI architectures, the view tree most strongly resembles that of SwiftUI - nodes in the view tree are plain value objects. They also contain callbacks, for example specifying the action to be taken on clicking a button. Like SwiftUI, but somewhat unusually for UI in more dynamic languages, the view tree is statically typed, but with a typed-erased escape hatch (Swift’s AnyView) for instances where strict static typing is too restrictive.</p>

<p>The Rust expression of these trees is instances of the <code>View</code> trait, which has two associated types, one for view state and one for the associated widget. The state and widgets are <em>also</em> statically typed. The design relies <em>heavily</em> on the type inference mechanisms of the Rust compiler. In addition to inferring the type of the view tree, it also uses associated types to deduce the type of the associated state tree and widget tree, which are known at compile time. In almost every other comparable system (SwiftUI being the notable exception), these are determined at runtime with a fair amount of allocation, downcasting, and dynamic dispatch.</p>

<h2 id="a-worked-example">A worked example</h2>

<p>We’ll use the classic counter as a running example. It’s very simple but will give insight into how things work under the hood. For people who want to follow along with the code, check the idiopath directory of the <a href="https://github.com/linebender/druid/pull/2183">idiopath branch</a> (in the Druid repo); running <code>cargo doc --open</code> there will reveal a bunch of Rustdoc.</p>

<p>Here’s the application.</p>

<div><div><pre><code><span>fn</span> <span>app</span><span>(</span><span>count</span><span>:</span> <span>&amp;</span><span>mut</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>impl</span> <span>View</span><span>&lt;</span><span>u32</span><span>&gt;</span> <span>{</span>
    <span>v_stack</span><span>((</span>
        <span>format!</span><span>(</span><span>&#34;Count: {}&#34;</span><span>,</span> <span>count</span><span>),</span>
        <span>button</span><span>(</span><span>&#34;Increment&#34;</span><span>,</span> <span>|</span><span>count</span><span>|</span> <span>*</span><span>count</span> <span>+=</span> <span>1</span><span>),</span>
    <span>))</span>
<span>}</span>
</code></pre></div></div>

<p>This was carefully designed to be clean and simple. A few notes about this code, then we’ll get in to what happens downstream to actually build and run the UI.</p>

<p>This function is run whenever there are significant changes (more on that later). It takes the current app state (in this case a single number, but in general app state can be anything), and returns a view tree. The exact type of the view tree is not specified, rather it uses the <a href="https://doc.bccnsoft.com/docs/rust-1.36.0-docs-html/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html">impl Trait</a> feature to simply assert that it’s something that implments the View trait (parameterized on the type of the app state). The full type happens to be:</p>

<div><div><pre><code><span>VStack</span><span>&lt;</span><span>u32</span><span>,</span> <span>(),</span> <span>(</span><span>String</span><span>,</span> <span>Button</span><span>&lt;</span><span>u32</span><span>,</span> <span>(),</span> <span>{</span><span>anonymous</span> <span>function</span> <span>of</span> <span>type</span> <span>for</span> <span>&lt;</span><span>&#39;a</span><span>&gt;</span> <span>FnMut</span><span>(</span><span>&amp;</span><span>&#39;a</span> <span>mut</span> <span>u32</span><span>)</span> <span>-&gt;</span> <span>()}</span><span>&gt;</span><span>)</span><span>&gt;</span>
</code></pre></div></div>

<p>For such a simple example, this is not too bad (other than the callback), but would get annoying quickly.</p>

<p>Another observation is that three nodes of this tree implement the View trait: VStack and its two children String and Button. Yes, that’s an ordinary Rust string, and it implements the View trait. So will colors and shapes (following SwiftUI; implementation is planned in the prototype but not complete).</p>

<p>The view tree returned by the app logic can be visualized as a block diagram:</p>

<p><img src="https://blogs.fsfe.org/assets/xilem_view.svg" alt="Box diagram showing view hierarchy"/></p>

<p>The type of the associated widget is <code>widget::VStack</code>. Purely as a pragmatic implementation detail, we’ve chosen to type-erase the children of containers. Among other things, this avoids excessive monomorphization. If we wanted fully-typed widget trees, the architecture would support that, and indeed an earlier prototype chose that approach.</p>

<h3 id="identity-and-id-paths">Identity and id paths</h3>

<p>A specific detail when building the widget tree is assigning a <em>stable identity</em> to each view. These concepts are explained pretty well in the <a href="https://developer.apple.com/videos/play/wwdc2021/10022/">Demystify SwiftUI</a> talk. As in SwiftUI, stable identity can be based on <em>structure</em> (views in the same place in the view tree get to keep their identity across runs), or an <em>explicit key.</em> To illustrate the latter, assume a list container, and that two of the elements in the list are swapped. That might play an animation of the visual representations of those two elements changing places.</p>

<p>The idea of assigning stable identities is quite standard in declarative UI (it’s also present in basically all non-toy immediate mode GUI implementations), but Xilem adds a distinctive twist, the use of <em>id path</em> rather than a single id. The id path of a widget is the sequence of all ids on the path from the root to that widget in the widget tree. Thus, the id path of the button in the above is <code>[1, 3]</code>, while the label is <code>[1, 2]</code> and the stack is just <code>[1]</code>.</p>

<p>To continue our running example, given the view tree, the build step produces an associated view state tree as well as a widget tree. Here, we’ve annotated the view tree with ids, and also shown how ids and id paths are stored in the newly built structures. Most importantly, the view state for the VStack contains the ids of the child nodes, and the Button widget contains its id path, which is <code>[1, 3]</code>.</p>

<p><img src="https://blogs.fsfe.org/assets/xilem_expanded.svg" alt="Box diagram showing view hierarchy"/></p>

<p>As it turns out, neither text labels nor buttons require any special view state other than what’s retained in the widget, so those view states are just (), the unit type. Of course, other view nodes may require more associated state, in which case the type would be something other than the unit type.</p>

<details>
<summary>Advanced topic: does id identify view or widget?</summary>

In writing this explanation, I realized there is some ambiguity whether the id identifies a node in the view tree, or one in the widget tree. In many cases, there is a 1:1 correspondence between the two, so the distinction is not important. In addition, it&#39;s certainly possible to construct a widget tree so that the id of each node is provided during the method call that constructs that widget, and if so, it&#39;s more than reasonable to use the Xilem ids as generated during the reconciliation process. However, that&#39;s not required, and the identity of widgets could be from a disjoint space from Xilem ids assigned to views.

Further, it&#39;s possible to have a view node that doesn&#39;t directly correspond to a widget. That happens with holders of async futures, environment getters, and potentially other nodes that have reason to receive events. In those cases, ids are associated with views, not widgets. It&#39;s important to be clear, though, that the *lifetime* of an id is persistent across multiple cycles, while the lifetime of nodes in the view tree is shorter.

Thus, the most accurate description of Xilem ids is this: they are *persistent* identifiers that correspond to either structural or explicit identity of nodes in the view tree.
</details>

<h3 id="event-propagation">Event propagation</h3>

<p>Now let’s click that button. Raw platform events such as mouse movement and keystrokes are handled by the UI infrastructure, and don’t necessarily result in events propagated to the app logic. For example, the mouse can hover over the button (changing the appearance to a hover state), or the window can be resized, and that will all be handled without involving the app. But clicking the button <em>does</em> generate an event to be dispatched to the app.</p>

<p>Obviously the goal will be to run that callback and increment the count, but the details of how that happens are subtly different than most declarative UI systems. Probably the “standard” way to do this would be to attach the callback to the button, and have it capture a reference to the chunk of state it mutates. Again, in most declarative systems but not Xilem, setting the new state would be done using some variant of the <a href="https://en.wikipedia.org/wiki/Observer_pattern">observer pattern</a>, for example some kind of <code>setState</code> or other “setter” function to not only update the value but also notify downstream dependencies that it had changed, in this case re-rendering the label.</p>

<p>This standard approach works poorly in Rust, though it can be done (see in particular the <a href="https://dioxuslabs.com/">Dioxus</a> system for an example of one of the most literal transliterations of React patterns, including observer-based state updating, into Rust). The problem is that it requires <em>shared mutable</em> access to that state, which is clunky at best in Rust (it requires interior mutability). In addition, because Rust doesn’t have built-in syntax for getters and setters, invoking the notification mechanism also requires some kind of explicit call (though perhaps macros or other techniques can be used to hide it or make it less prominent).</p>

<details>
<summary>Advanced topic: comparison with Elm</summary>

The observer pattern is not the *only* way event propagation works in declarative UI. Another very important and influential pattern is [The Elm Architecture], which, being based on a pure functional language, also does not require shared mutable state. Thus, it is also used successfully as the basis of several Rust UI toolkits, notably Iced.

In Elm, app state is centralized (this is also a fairly popular pattern in React, using state management packages such as Redux), and events are given to the app through an `update` call. Dispatching is a three-stage process. First, the user defines a *message* type enumerating the various actions that are (globally) possible to trigger through the UI. Second, the UI element *maps* the event type into this user-defined type, identifying which action is desired. Third, the `update` method dispatches the event, delegating if needed to a child handler. Some people like the explicitness of this approach, but it is unquestionably more verbose than a single callback that manipulates state directly, as in React or SwiftUI.
</details>

<p>So what does Xilem do instead? The view tree is also parameterized on the <em>app state,</em> which can be any type. This idea is an evolution of Druid’s existing architecture, which also offers mutable access to app state to UI callbacks, but removes some of the limitations. In particular, Druid requires app state to be clonable and diffable, a stumbling block for many new users.</p>

<p>When an event is generated, it is annotated with the path of the UI element that originated it. In the case of the button, <code>[1, 3]</code>, and this is sent to the app logic for dispatching. In the case of a button click, there is no <em>payload,</em> but for a slider it would be the numeric slider value, or for a text input it would be the string.</p>

<p>Event dispatching starts at the root of the view tree, and calls to the <code>event</code> method on the <code>View</code> trait also contain a mutable borrow of the app state. In this example, the root view node is VStack. It examines the id path of the event, consults its associated view state, and decides that the event should be dispatched to the second child, as the id of that child (3) matches the corresponding id in the id path of the event. It recursively calls <code>event</code> on that child, which is the button. That is a <em>leaf node,</em> meaning there are no further ids in the id path, and the button handles that event by calling its callback, passing in the mutable borrow of app state that was propagated through the <code>event</code> traversal. That callback in turn just increments the count value.</p>

<p>Note that the UI framework retains the view tree a “fairly short” time - long enough to do any event dispatching that’s needed, and also for diffing (see below), but not longer than that.</p>

<h3 id="re-rendering">Re-rendering</h3>

<p>After clicking the button and running the callback, the app state consists of the number 1, formerly 0. The app logic function is run, producing a new view tree, and this time the string value is “Count: 1” rather than “Count: 0”. The challenge is then to update the widget tree with the new data.</p>

<p>As is completely standard in declarative UI, it is done by diffing the old view tree against the new one, in this case calling the <code>rebuild</code> method on the <code>View</code> trait. This method compares the data, updates the associated widget if there are any changes, and also traverses into children. The view tree is retained <em>just</em> long enough to do event propagation and to be diffed against the next iteration of the view tree, at which point it is dropped. At any point in time, there are at most two copies of the view tree in existence.</p>

<p>In the simplest case, the app builds the full view tree, and that is diffed in full against the previous version. However, as UI scales, this would be inefficient, so there are <em>other</em> mechanisms to do finer grained change propagation, as described below.</p>

<h2 id="components">Components</h2>

<p>The above is the basic architecture, enough to get started. Now we will go into some more advanced techniques.</p>

<p>It would be very limiting to have a single “app state” type throughout the application, and require all callbacks to express their state mutations in terms of that global type. So we won’t do that.</p>

<p>The main tool for stitching together components is the <code>Adapt</code> view node. This node is so named because it adapts between one app state type and another, using a closure that takes mutable access to the parent state, and calls into a child (through a “thunk”, which is just a callback for continuing the propagation to child nodes) with a mutable reference to the child state. We can then define a “component” in the Xilem world as a body of code that outputs a view tree with a different app state type than its parent component.</p>

<p>In the simple case where the child component operates independently of the parent, the adapt node is a couple lines of code. It is also an attachment point for richer interactions - the closure can manipulate the parent state in any way it likes. Event handling callbacks of the child component are also allowed to return an arbitrary type (unit by default), for propagation of data upward in the tree, including to parent components.</p>

<p>In Elm terminology, the Adapt node is similar to <a href="https://package.elm-lang.org/packages/elm/html/latest/Html#map">Html map</a>, though it manipulates mutable references to state, as opposed to being a pure functional mapping between message types. It is also quite similar to the “lens” concept from the existing Druid architecture, and has some resemblance to <a href="https://developer.apple.com/documentation/swiftui/binding">Binding</a> in SwiftUI as well.</p>

<h2 id="finer-grained-change-propagation-memoizing">Finer grained change propagation: memoizing</h2>

<p>Going back to the counter, every time the app logic is called, it allocates a string for the label, even if it’s the same value as before. That’s not too bad if it’s the only thing going on, but as the UI scales it is potentially wasted work.</p>

<p>Ron Minsky has <a href="https://signalsandthreads.com/building-a-ui-framework/#1523">stated</a> “hidden inside of every UI framework is some kind of incrementalization framework.” Xilem unapologetically contains at its core a lightweight change propagation engine, similar in scope to the attribute graph of SwiftUI, but highly specialized to the needs of UI, and in particular with a lightweight approach to <em>downward</em> propagation of dependencies, what in React would be stated as the flow of props into components.</p>

<p>In this particular case, that incremental change propagation is best represented as a <em>memoization</em> node, yet another implementation of the View trait. A memoization node takes a data value (which supports both <code>Clone</code> and equality testing) and a closure which accepts that same data type. On rebuild, it compares the data value with the previous version, and only runs the closure if it has changed. The signature of this node is very similar to <a href="https://guide.elm-lang.org/optimization/lazy.html">Html.Lazy</a> in Elm.</p>

<p>Comparing a number is extremely cheap (especially because all this happens with static typing, so no boxing or downcasting is needed), but the cost of equality comparison is a valid concern for larger, aggregate data structures. Here, immutable data structures (adapted from the existing Druid architecture) can work very well.</p>

<p>Let’s say there’s a parent object that contains all the app state, including a sizable child component. The type would look something like this:</p>

<div><div><pre><code><span>#[derive(Clone)]</span>
<span>struct</span> <span>Parent</span> <span>{</span>
    <span>stuff</span><span>:</span> <span>Stuff</span><span>,</span>
    <span>child</span><span>:</span> <span>Arc</span><span>&lt;</span><span>Child</span><span>&gt;</span><span>,</span>
<span>}</span>
</code></pre></div></div>

<p>And at the top of the tree we can use a memoize node with type <code>Arc&lt;Parent&gt;</code>, and the equality comparison <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html#method.ptr_eq">pointer equality</a> on the <code>Arc</code> rather than a deep traversal into the structure (as might be the case with a derived <code>PartialEq</code> impl). The child component attaches with both a Memoize and an Adapt node.</p>

<p>The details of the Adapt node are interesting. Here’s a simple approach:</p>

<div><div><pre><code><span>adapt</span><span>(</span>
    <span>|</span><span>data</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Arc</span><span>&lt;</span><span>Parent</span><span>&gt;</span><span>,</span> <span>thunk</span><span>|</span> <span>thunk</span><span>.call</span><span>(</span><span>&amp;</span><span>mut</span> <span>Arc</span><span>::</span><span>make_mut</span><span>(</span><span>data</span><span>)</span><span>.child</span><span>),</span>
    <span>child_view</span><span>(</span><span>...</span><span>)</span> <span>// which has Arc&lt;Child&gt; as its app data type</span>
<span>)</span>
</code></pre></div></div>

<p>Whenever events propagate into the child, <code>make_mut</code> creates a copy of the parent struct, which will then not be pointer-equal to the version stored in the memoize node. If such events are relatively rare, or if they nearly always end up mutating the child state, then this approach is reasonable. However, it is possible to be even finer grain:</p>

<div><div><pre><code><span>adapt</span><span>(</span>
    <span>|</span><span>data</span><span>:</span> <span>&amp;</span><span>mut</span> <span>Arc</span><span>&lt;</span><span>Parent</span><span>&gt;</span><span>,</span> <span>thunk</span><span>|</span> <span>{</span>
        <span>let</span> <span>mut</span> <span>child</span> <span>=</span> <span>data</span><span>.child</span><span>.clone</span><span>();</span>
        <span>thunk</span><span>.call</span><span>(</span><span>&amp;</span><span>mut</span> <span>child</span><span>),</span>
        <span>if</span> <span>!</span><span>Arc</span><span>::</span><span>ptr_eq</span><span>(</span><span>&amp;</span><span>data</span><span>.child</span><span>,</span> <span>&amp;</span><span>child</span><span>)</span> <span>{</span>
            <span>Arc</span><span>::</span><span>make_mut</span><span>(</span><span>data</span><span>)</span><span>.child</span> <span>=</span> <span>child</span><span>;</span>
        <span>}</span>
    <span>},</span>
    <span>child_view</span><span>(</span><span>...</span><span>)</span> <span>// which has Arc&lt;Child&gt; as its app data type</span>
<span>)</span>
</code></pre></div></div>

<p>This logic propagates the change up from the child object to the parent object in the app state <em>only if</em> the child state has actually changed.</p>

<p>The above illustrates how to make the pattern work for structure fields (and is very similar to the “lensing” technique in the existing Druid architecture), but similar ideas will work for collections. Basically you need immutable data structures that support pointer equality and cheap, sparse diffing. I talk about that in some detail in my talk <a href="https://www.youtube.com/watch?v=DSuX-LIAU-I">A Journey Through Incremental Computation</a> (<a href="https://docs.google.com/presentation/d/1opLymkreSTFfxygjzSLYI_uH7j1YFfE6DLl8RfCiw7E/edit">slides</a>), with a focus on text layout and a list component. Also note that the <a href="https://docs.rs/druid-derive/latest/druid_derive/">druid_derive</a> crate automates generation of these lenses for Druid, and no doubt a similar approach would work for adapt/memoize in Xilem. For now, though, I’m seeing how far we can get just using vanilla Rust and not relying on macros. I think all this is a fruitful direction for future work.</p>

<p>Also to note: while immutable data structures work <em>well</em> in the Xilem architecture, they are not absolutely required. The <code>View</code> trait itself can be implemented by anyone, as long as the <code>build</code>, <code>rebuild</code>, and <code>event</code> methods have correct implementation; change propagation is especially the domain of the <code>rebuild</code> method.</p>

<h2 id="type-erasure">Type erasure</h2>

<p>This section is optional but contains some interesting bits on advanced use of the Rust type system.</p>

<p>Having the view tree (and associated view state and widget tree) be fully statically typed has some advantages, but the types can become quite large, and there are cases where it is important to <em>erase</em> the type, providing functionality very similar to <a href="https://developer.apple.com/documentation/swiftui/anyview">AnyView</a> in SwiftUI.</p>

<p>For a simple trait, the standard approach would be <code>Box&lt;dyn Trait&gt;</code>, which boxes up the trait implementation and uses dynamic dispatch. However, this approach will not work with Xilem’s View trait, because that trait is not <a href="https://huonw.github.io/blog/2015/01/object-safety/">object-safe</a>. There are actually two separate problems - first, the trait has associated types, and second, the <code>rebuild</code> method takes the previous view tree for diffing purposes as a <code>Self</code> parameter; though the contents of the view trees might differ, the type remains constant.</p>

<p>Fortunately, though simply <code>Box&lt;dyn View&gt;</code> is not possible due to the View trait not being object-safe, there is a pattern (due to David Tolnay) for <a href="https://github.com/dtolnay/erased-serde#how-it-works">type erasure</a>. You can look at the code for details, but the gist of it is a separate trait (<code>AnyView</code>) with <code>Any</code> in place of the associated type, and a blanket implementation (<code>impl&lt;T&gt; AnyView for T where T: View</code>) that does the needed downcasting.</p>

<p>The details of type erasure in Xilem took a fair amount of iteration to get right (special thanks to Olivier Faure and Manmeet Singh for earlier prototypes). An <a href="https://github.com/linebender/druid/pull/1669">earlier iteration</a> of this architecture used the Any/downcast pattern everywhere, and I also see that pattern for associated state in <a href="https://github.com/audulus/rui">rui</a> and <a href="https://docs.rs/iced_pure/latest/iced_pure/">iced_pure</a>, even though the main view object is statically typed.</p>

<p>In the SwiftUI community, <code>AnyView</code> is <a href="https://www.swiftbysundell.com/articles/avoiding-anyview-in-swiftui/">frowned on</a>, but it is still useful to have it. While <code>impl Trait</code> is a powerful tool to avoid having to write out explicit types, it doesn’t work in all cases (specifically as the return type for trait methods), though there is <a href="https://github.com/rust-lang/rust/issues/63063">work to fix that</a>. There is an additional motivation for type erasure, namely language bindings.</p>

<h3 id="language-bindings-for-dynamic-languages">Language bindings for dynamic languages</h3>

<p>As part of this exploration, I wanted to see if Python bindings were viable. This goal is potentially quite challenging, as Xilem is fundamentally a (very) strongly typed architecture, and Python is archetypally a loosely typed language. One of the limitations of the existing Druid architecture I wanted to overcome is that there was no satisfying way to create Python bindings. As another negative data point, no dynamic language bindings for SwiftUI have emerged in the approximately 3 years since its introduction.</p>

<p>Yet I was able to create a fairly nice looking proof of concept for Xilem Python bindings. Obviously these bindings rely heavily on type erasure. The essence of the integration is <code>impl View for PyObject</code>, where the main instance is a Python wrapper around <code>Box&lt;dyn AnyView&gt;</code> as stated above. In addition, <code>PyObject</code> serves as the type for both app state and messages in the Python world; an <code>Adapt</code> node serves to interface between these and more native Rust types. Lastly, to make it all work we need <code>impl ViewSequence for PyTuple</code> so that Python tuples can serve as the children of containers like VStack, for building view hierarchies.</p>

<p>I should emphasize, this is a <a href="https://github.com/linebender/druid/pull/2185">proof of concept</a>. To do a polished set of language bindings is a fairly major undertaking, with care needed to bridge the impedance mismatch, and especially to provide useful error messages when things go wrong. Even so, it seems promising, and, if nothing else, serves to demonstrate the flexibility of the architecture.</p>

<h2 id="async">Async</h2>

<p>The interaction between async and UI is an extremely deep topic and likely warrants a blog post of its own. Even so, I wanted to explore it in the Xilem prototype. Initial prototyping indicates that it can work, and that the integration can be fine grained.</p>

<p>Async and change propagation for UI have some common features, and the Xilem approach has parallels to <a href="https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html">Rust’s async ecosystem</a>. In particular, the id path in Xilem is roughly analogous to the “waker” abstraction in Rust async - they both identify the “target” of the notification change.</p>

<p>In fact, in the prototype integration, the waker provided to the Future trait is a thin wrapper around an id path, as well as a callback to notify the platform that it should wake the UI thread if it is sleeping. Somewhat unusually for Rust async, each <code>View</code> node holding a future calls <code>poll</code> on it itself; in some respects, a future-holding view is like a tiny executor of its own. A UI built with Xilem does not provide its own reactor, but rather relies on existing work such as <a href="https://tokio.rs/">tokio</a> (which was used for the prototype).</p>

<p>We refer the interested reader to <a href="https://github.com/linebender/druid/pull/2184">the prototype code</a> for more details. Clearly this is an area that deserves to be explored much more deeply.</p>

<h2 id="environment">Environment</h2>

<p>A standard feature of declarative UI is a dynamically scoped <em>environment</em> or <em>context</em> in which child nodes can retrieve information, usually in some form of key/value format, from ancestors somewhere higher up in the tree. Most Rust UI architectures have this (including existing Druid), but you should ask: is there fine-grained change propagation, or does it have to rebuild all children when <em>any</em> environment key changes?</p>

<p>We have a design for this, not fully implemented yet. The <code>Cx</code> structure threaded through the reconciliation process gains an environment, which is a map from key to (subscribers, value) tuples. The subscribers field is a set of id paths (of child nodes). There are then two <code>View</code> nodes, one for setting an environment value, which is then available to descendants, and one for retrieving that value. Let’s look at the <code>build</code> and <code>rebuild</code> methods for both of those nodes, the setter first.</p>

<p>The associated state of the setter is the value and the subscriber set. On <code>build</code> it creates that state, with the subscriber set empty. On <code>rebuild</code> it compares the new value with that stored in the state (these values must be equality-comparable), and, if they differ, sends a notification to each of the subscribers in the subscriber set, using the id path to dispatch those notifications. In both cases, it recurses to the child node, then pops the key from the environment stack in <code>Cx</code> before it returns (here, “pop” means either removing the key from the environment map, or setting the value to what it was before traversing into the setter node, depending on that previous value).</p>

<p>In the <code>build</code> case, it fetches the value and subscriber set from the environment map, and <em>adds</em> itself to that subscriber set. In either the <code>build</code> or <code>rebuild</code> case, it retrieves the value and calls the closure for its child view tree, passing in the value retrieved from the environment. Note that the “subscriber set” concept is an adaptation of the classic observer pattern to the Xilem architecture.</p>

<p>One reason this hasn’t been prototyped is that the implementation details are fairly different depending on whether reconciliation can be multithreaded (a note on that below). It’s possible to do but requires an immutable map data structure to avoid high cloning cost, as well as interior mutability for the subscription set.</p>

<p>We have a similar prototype of a <code>useState</code> mechanism, but not enough data on its usefulness to say for sure whether it carries its weight. Such a mechanism does not seem to be needed in the Elm architecture.</p>

<h2 id="other-topics">Other topics</h2>

<p>So far, I haven’t deeply explored styling and theming. These operations also potentially ride on an incremental change propagation system, especially because dynamic changes to the style or theme may propagate in nontrivial ways to affect the final appearance.</p>

<p>Another topic I’m <em>very</em> interested to explore more fully is accessibility. I <em>expect</em> that the retained widget tree will adapt nicely to accessibility work such as Matt Campbell’s [AccessKit], but of course you never know for sure until you actually try it.</p>

<p>An especially difficult challenge in UI toolkits is sparse scrolling, where there is the illusion of a very large number of child widgets in the scroll area, but in reality only a small subset of the widgets outside the visible viewport are materialized. I am hopeful that the tight coupling between view and associated widget, as well as a lazy callback-driven creation of widgets, will help with this, but again, we won’t know for sure until it’s built.</p>

<p>Another very advanced topic is the ability to exploit parallelism (multiple threads) to reduce latency of the UI. The existing Druid architecture threads a mutable context to almost all widget methods, basically precluding any useful parallelism. In the Xilem architecture, creation of the View tree itself can easily be multithreaded, and I <em>think</em> it’s also possible to do multithreaded reconciliation. The key to that is to make the <code>Cx</code> object passed to the <code>build</code> and <code>rebuild</code> methods <code>Clone</code>, which I think is possible. Again, actually realizing performance gains from this approach is a significant challenge.</p>

<h2 id="prospects">Prospects</h2>

<p>The work presented in this blog post is conceptual, almost academic, though it is forged from attempts to build real-world UI in Rust. It comes to you at an early stage; we haven’t <em>yet</em> built up real UI around the new architecture. Part of the motivation for doing this writeup is so we can gather feedback on whether it will actually deliver on its promise.</p>

<p>One way to test that would be to try it in other domains. There are quite a few projects that implement reactive UI ideas over a TUI, and it would also be interesting to try the Xilem architecture on top of Web infrastructure, generating DOM nodes in place of the associated widget tree.</p>

<p>I’d like to thank a large number of people, though of course the mistakes in this post are my own. The Xilem architecture takes a lot of inspiration from Olivier’s <a href="https://github.com/PoignardAzur/panoramix">Panoramix</a> and Manmeet’s <a href="https://github.com/Maan2003/olma">olma</a> explorations, as well as Taylor Holliday’s <a href="https://github.com/audulus/rui">rui</a>. Jan Pochyla provided useful feedback on early versions, and conversations with the entire Druid crew on <a href="https://xi.zulipchat.com/">xi.zulipchat.com</a> were also informative. Ben Saunders provided valuable insight regarding Rust’s async ecosystem.</p>

<p>Discuss on <a href="https://news.ycombinator.com/item?id=31297550">Hacker News</a> and <a href="https://www.reddit.com/r/rust/comments/ukk1p4/xilem_an_architecture_for_ui_in_rust/">/r/rust</a>.</p>


  </div></div>
  </body>
</html>
