<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://horstmann.com/unblog/2023-09-19/index.html">Original</a>
    <h1>Java 21: The Nice, the Meh, and the Momentous</h1>
    
    <div id="readability-page-1" class="page">
    <blockquote><p>When Java 17 was released in 2021 as a “long term support” version, I wrote <a href="https://horstmann.com/unblog/2021-09-14/index.html">an article</a> dissecting its features and came to the conclusion that it had a few nice features, but none that were compelling reasons to upgrade. Except one: tens of thousands of bug fixes. </p>
      <p>Java 21 was released today, as another “long term support” release. How does it rate on the momentousness scale? Read on for an unbiased opinion.</p>
    </blockquote>
    <p><img src="https://horstmann.com/unblog/2023-09-19/gbu.jpeg" alt=".jpeg" loading="lazy"/></p>

    <h2>The Momentousness Ratings</h2>

    <p>Every six months, there is a new Java release. Ever so often (currently, every two years), Oracle labels a release as “long term support”, and Java users wonder whether they should upgrade. In theory, <a href="https://foojay.io/almanac/jdk-21/">other JDK distributors</a> could offer “long term support” for other releases, but it seems everyone is following Oracle&#39;s lead.</p>
    <p>Should you upgrade?</p>
    <p>Here are the major features of Java 21. I omit preview and incubator features (which you are surely not going to use in production), JVM internals, highly specialized features such as <a href="https://openjdk.org/jeps/452">this one</a>, and deprecations.</p>
    
    <table><tbody><tr><th>Feature</th>
        <th>Example</th>
        <th>Momentousness rating</th>
        <th>Why care?</th>
      </tr>
      <tr><td>Pattern matching for <code>switch</code></td>
        <td>
        <pre>Employee e = . . .;
String description = switch (e) {
   case Executive exec when exec.getTitle().length() &gt;= 20 -&gt;
      &#34;An executive with an impressive title&#34;;
   case Executive __ -&gt; &#34;An executive&#34;;
   case Manager m -&gt; {
      m.setBonus(10000);
      yield &#34;A manager who just got a bonus&#34;;
   }
   default -&gt; &#34;A lowly employee with a salary of &#34; + e.getSalary();
};
</pre></td>
        <td>Nice</td>
        <td>It&#39;s better than chains of <code>if/else/else</code> with <code>instanceof</code>. Do you do that often? The JDK source has over 5 million LOC with about a thousand <code>instanceof</code> preceded by <code>else</code>.</td>
      </tr>
      <tr><td>Record Patterns</td>
        <td>
        <pre>String description = switch (p)
   {
      case Point(var x, var y) when x == 0 &amp;&amp; y == 0 -&gt; &#34;origin&#34;;
      case Point(var x, var __) when x == 0 -&gt; &#34;on x-axis&#34;;
      case Point(var __, var y) when y == 0 -&gt; &#34;on y-axis&#34;;
      default -&gt; &#34;not on either axis&#34;;
   };
</pre></td>
        <td>Nice</td>
        <td>How many records are in your codebase? (The Java 21 API has <a href="https://docs.oracle.com/en/java/javase/21/docs/api/allclasses-index.html">two</a>.)</td>
      </tr>
      <tr><td>Sequenced Collections</td>
        <td>
        <pre>List&lt;String&gt; words = ...;
String lastWord = words.getLast();
for (String word : words.reversed()) System.out.println(word);
</pre></td>
        <td>Nice</td>
        <td>Good to have, but you wouldn&#39;t upgrade for that.</td>
      </tr>
      <tr><td>Virtual threads</td>
        <td>
        <pre>try {
   var response = client.send(request, HttpResponse.BodyHandlers.ofString()); 
   for (URL url : getImageURLs(response.body())) {
      saveImage(getImage(url));
   }
}
catch (...) { ... }
</pre></td>
        <td>Momentous</td>
        <td>No more async gobbledygook!
        <pre>client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
   .thenApply(HttpResponse::body)
   .thenApply(this::getImageURLs)
   .thenCompose(this::getImages)
   .thenAccept(this::saveImages)
   .exceptionally(this::ohNoes);
</pre></td>
      </tr>
      <tr><td><a href="https://javaalmanac.io/jdk/21/apidiff/17/">Miscellaneous new methods</a></td>
        <td><pre>&#34;Hello, World!&#34;.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html#splitWithDelimiters(java.lang.String,int)">splitWithDelimiters</a>
      (&#34;\\pP\\s*&#34;, -1)
  // [&#34;Hello&#34;, &#34;, &#34;, &#34;World&#34;, &#34;!&#34;, &#34;&#34;]
</pre></td>
        <td>Meh</td>
        <td>Good that the API keeps evolving in small ways, but the changes are pretty minor.</td>
      </tr>
      <tr><td><a href="https://bugs.openjdk.org/browse/JDK-8309268?jql=project%20%3D%20JDK%20AND%20statusCategory%20%3D%20Done%20%20AND%20fixVersion%20%3E%3D%2018%20AND%20fixVersion%20%3C%3D%2021%20ORDER%20BY%20updated%20DESC">Over 10,000 bug fixes</a></td>
          <td><a href="https://bugs.openjdk.org/browse/JDK-8054022">Bug JDK-8054022</a> HttpURLConnection timeouts with Expect: 100-Continue and no chunking</td>
          <td>Count me in!</td>
          <td>Unless you are sure that none of them might impact you, shouldn&#39;t you upgrade?</td>
      </tr>
    </tbody></table>

    <p>Let&#39;s look at these features in more detail.</p>

    <h2>Virtual Threads</h2>
    <p><a href="https://horstmann.com/unblog/2023-06-27/index.html">Virtual threads</a> are a big deal. Similar to generics, lambda expressions, and modules, they solve a major problem for which the language has otherwise no good alternative. If you have the problem that they are designed to solve, you will have a powerful motivation to upgrade.</p>
    <p>Here is the problem. If you write applications that process many more concurrent requests than available platform threads, you currently have two unappealing choices:</p>
    <ul><li>Use a synchronous programming style and accept that throughput is limited by the number of platform threads</li>
      <li>Use an asynchronous or “reactive” programming style</li>
    </ul>
    <p>What is wrong with an asynchronous programming style? You have to structure your program as chunks of callbacks. You need library support for sequencing, branches, loops, and exception handling, instead of using the features that are built into Java. Debugging is more challenging since the debugger cannot show you a complete execution history when it stops at a breakpoint. Not convinced? Make one of your junior programmers read through the documentation of <a href="https://projectreactor.io/docs/core/release/reference">Project Reactor</a> and then assign a simple task, such as loading a web page and then loading all images in it. </p>
    <p>Of course, virtual threads are not appropriate for all concurrent programming. They only work for tasks that spend most of their time waiting for network I/O. This is the situation in many business applications where much of the request processing consists of calls to the database and external services.</p>
    <p>Interestingly, there is <a href="https://horstmann.com/unblog/2023-06-27/index.html">very little to learn</a> in order to use virtual threads. You just use them like regular threads. In most scenarios, you simply configure your application framework to invoke your business logic on virtual threads, and watch throughput increase.</p>
    <p>One idiom is worth learning. To run multiple tasks in parallel, use a <em>local</em> instance of <code>ExecutorService</code>:</p>
    <pre>try (var service = Executors.newVirtualThreadPerTaskExecutor()) {
   Future&lt;T1&gt; f1 = service.submit(callable1);
   Future&lt;T2&gt; f2 = service.submit(callable2);
   result = combine(f1.get(), f2.get());
}
</pre>
    <p>Obtaining the result with <code>get</code> is a blocking call, but so what, blocking is cheap with virtual threads.</p>
    <p><a href="https://openjdk.org/jeps/453">Structured Concurrency</a>, a preview feature in Java 21, simplifies error handling and makes it easier to harvest the results of multiple concurrent requests.</p>
    <p>There are a few caveats:</p>
    <ul><li>In the past, a thread pool didn&#39;t just throttle the incoming requests but also the concurrent resources that your app consumed. If you now accept many more incoming requests, you may need other ways to manage resource consumption.</li>
      <li>One resource that deserves particular attention is thread locals. With many more threads than before, do you really want many more thread locals? Or are there more appropriate mechanisms to achieve whatever you wanted to achieve with thread locals? Your framework provider needs to think this through, and if you actively use thread locals, so should you. A <a href="https://openjdk.org/jeps/446">lighter-weight alternative</a> is in preview.</li>
      <li>Virtual threads do not yet work well with blocking calls inside <code>synchronized</code> methods or blocks. The remedy is to rewrite the offending code with <code>java.util.concurrent</code> locks. Be sure that the providers of your framework, database driver, and so on, update their code to work well with virtual threads. Quite a few already did.</li>
    </ul>
 

    <h2>Pattern Matching</h2>
    <p>Many functional languages have some form of pattern matching that makes it convenient to work with “algebraic data types”, which in Java are implemented with sealed hierarchies and record classes.</p>
    <p>Java has chosen to extend the syntax for <code>instanceof</code> and <code>switch</code> for pattern matching, in order to leverage existing programmer knowledge. These extensions have been in preview until Java 20 and are now in their final form.</p>
    <p>Are you using sealed hierarchies and records in your code base? Then pattern matching is appealing. Here is an example, a simple JSON hierarchy:</p>
    <pre>sealed interface JSONValue permits JSONArray, JSONObject, JSONPrimitive {}

final class JSONArray extends ArrayList&lt;JSONValue&gt; implements JSONValue {}

final class JSONObject extends HashMap&lt;String, JSONValue&gt; implements JSONValue {}

sealed interface JSONPrimitive extends JSONValue
   permits JSONNumber, JSONString, JSONBoolean, JSONNull {}

final record JSONNumber(double value) implements JSONPrimitive {}

final record JSONString(String value) implements JSONPrimitive {}

enum JSONBoolean implements JSONPrimitive {
   FALSE, TRUE;
}

enum JSONNull implements JSONPrimitive {
   INSTANCE;
}

</pre>
    <p><img src="https://horstmann.com/unblog/2023-09-19/json.png" alt=".png" loading="lazy"/></p>
    <p>Now you can process JSON values like this:</p>

<pre>JSONPrimitive p = . . .;
double value = switch (p) {
   case JSONString(var v) when v.matches(&#34;-?(0|[1-9]\\d*)(\\.\\d+)?([eE][+-]?\\d+)?&#34;) -&gt;
      Double.parseDouble(v);
   case JSONString __ -&gt; Double.NaN;
   case JSONNumber(var v) -&gt; v;
   case JSONBoolean.TRUE -&gt; 1;
   case JSONBoolean.FALSE, JSONNull.INSTANCE -&gt; 0;
}
</pre>
    <p>Note the following:</p>
    <ul><li>This is a <code>switch</code> expression that yields a value</li>
      <li>The compiler checks that the <code>switch</code> is exhaustive</li>
      <li>The pattern <code>JSONString(var v)</code> binds the variable <code>v</code> to the component of the record</li>
      <li>The <code>when</code> clause restricts a match to a Boolean condition</li>
      <li>With <a href="https://openjdk.org/jeps/445">JEP 445</a>, you will be able to use <code>case JSONString _</code>, with a single underscore, to indicate that you do not need the variable binding. But that is still a preview feature.</li>
      <li>Since Java 14, you can have multiple constants in a single <code>case</code></li>
    </ul>
    <p>All this is certainly nicer than the <code>instanceof</code> and casting that one might do right now with Jackson. But you might want to hold off switching to a new JSON hierarchy until Java gives us <a href="https://openjdk.org/jeps/8277163">value classes</a>.</p>
    <p>In general, pattern matching is more useful in contexts that are designed for pattern matching. Today&#39;s use cases are perhaps not all that compelling, but it is an investment in the future.</p>
    <h2>Sequenced Collections</h2>
    <p>When you have a <code>Collection</code>, how do you get the first element? With a <code>List</code>, it&#39;s <code>list.get(0)</code>, but in general, you&#39;d call <code>collection.iterator().next()</code>. Except with a stack or queue it is <code>peek</code>, with a deque <code>getFirst</code>, and the <code>SortedSet</code> interface has <code>first</code>. And what about the last element?</p>
    <p>And how do you visit the elements in reverse order? <code>Deque</code> and <code>NavigableSet</code> have a handy <code>descendingIterator</code>. For lists, you iterate backwards, starting from the last element.</p>
    <p><a href="https://openjdk.org/jeps/431">JEP 431</a> cleans up this situation with a <code>SequencedCollection</code> interface. It has these methods:</p>
    <pre>E getFirst();
E getLast();
void addFirst(E);
void addLast(E);
E removeFirst();
E removeLast();
SequencedCollection&lt;E&gt; reversed();
</pre>
    <p>The first six methods are the same as in the <code>Deque</code> interface, which is now a subinterface.</p>
    <p>There is also a <code>SequencedSet</code>, where <code>reversed</code> yiels a set, and a <code>SequencedMap</code>, with methods to get and put the first and last entry, and with sequenced views for the keys, values, and entries.</p>
    <p>This figure, by Stuart Marks, shows the change in the collections hierarchy.</p>
    <p><img src="https://cr.openjdk.org/~smarks/collections/SequencedCollectionDiagram20220216.png" alt=".png" loading="lazy"/></p>
    <p>TL;DR Reverse iteration over a list, deque, tree set, or tree map is now more uniform. Getting the first and laste element too. That&#39;s nice. Obviously not momentous.</p>

    <h2>Should You Upgrade?</h2>
    <p>When Java 17 was released, I opined that none of its features were momentous enough to warrant upgrading, and one was downright ugly. Still, upgrading was a no-brainer: tens of thousands of bug fixes. </p>
    <p>Of course you should upgrade again to Java 21. Because, lots of bug fixes.</p>
    <p>And this time there is a truly momentous feature: virtual threads. If you are contemplating the use of reactive programming, or you are already unhappily doing so, you definitely want to check them out.</p>

    <h2>Also Nice</h2>
    <p>Oracle now has an <a href="https://dev.java/playground/">online “playground”</a> for testing Java snippets. Check it out!</p>
    

    
    
    <!-- You can specify a per page discussion id on the next line, if your URLs might change. -->
    
    
  

</div>
  </body>
</html>
