<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://8chananon.github.io/tut/scraping1.html">Original</a>
    <h1>Show HN: Web Scraping with Your Web Browser: Why Not?</h1>
    
    <div id="readability-page-1" class="page">

<hr/><p>

You can find plenty of tutorials on the Internet about the art of web scraping (for example,
<a href="https://medium.com/@joerosborne/intro-to-web-scraping-build-your-first-scraper-in-5-minutes-1c36b5c4b110">here</a>
and <a href="https://www.jcchouinard.com/web-scraping/">here</a>) and the first things you will learn about are Python and
Beautiful Soup. There is no tutorial on web scraping with Javascript in a web browser though you will find browser
extensions that claim to do it all without any need for coding (this only works for simplistic and unprotected websites).
So the question is: can you write a web scraper in your browser? The answer is: YES, you can! So why is nobody doing it?
</p><p>
Web scraping has a long history, even pre-dating the advent of Javascript in its current incarnation. Though Javascript was
first introduced by Netscape in 1995, it would take another decade for it to mature into a language suitable for much more
than managing the presentation of a web page. Python was introduced in 1991 and was a fairly mature language from the start.
Due to simple inertia, it remains the predominant tool for web scraping. Over the past several years, Node.js has seen
rising interest and there are tools written in Javascript for Node.js but still nothing for web browsers.
</p><p>
One of the issues is what is called CORS (Cross-Origin Resource Sharing) which is a set of protocols which may forbid or
allow access to a web resource by Javascript. There are two possible workarounds: a browser extension or a proxy server.
The first choice is fairly limited since some security restrictions still apply. The latter choice is more flexible but
requires the presence of an external resource. Python gets around the CORS limitations because the web browser is not
involved. Unfortunately, this also means that additional support is required in order to parse HTML or JSON and perhaps
even to execute Javascript in cases where a resource is protected by obfuscation.
</p><p>
In the early days, such issues were easily resolved but the web has changed and everything has gotten more complicated. This
is where headless browsers come in, at which point one must begin wondering if it would be better to just write the web
scraper in the web browser in the first place. A headless browser is simply a browser (usually Google Chrome) with no
graphical interface coupled with a controller like Puppeteer or Selenium. The Python app can send commands to the browser
in order to make it behave like a normal user. This technique certainly has its limits.
</p><p>
How do we go about writing a web scraper in the browser? First of all, I need to quickly get the issue of the proxy
server out of the way. For the code examples in this article, I will be using a remote proxy server. This is good enough for
simple use cases. For heavy lifting, however, a local proxy server is the only choice. An example of some heavy lifting is
executing Javascript in an <i>iframe</i> under a fake domain.

</p><hr/><p>

<b><b_>Bypassing the browser restrictions with a proxy server</b_></b>
</p><p>
You can choose between using a local proxy or a remote proxy. In the latter case, your options are extremely limited to the
point where there may be no option at all, depending on what you need to accomplish. You could certainly host your own proxy
in the cloud somewhere but why bother? That option is only useful if you need to share the proxy with others for some
reason. What does the proxy server need to do?
</p><p>
<g_>1 -</g_> set the Access-Control-Allow-Origin response header to the value &#34;*&#34;</p><p>
These are the minimum requirements. The first one is essential and might be sufficient. However, some resources may be
blocked if the Referer is not correctly set (this is often the cause of the 403 error). It may also be necessary to set a
special header such as <g_>x-requested-from</g_>. For simplicity, the proxy should support setting the headers via the URL
(perhaps in addition to some other method like a configuration file).
</p><p>
<g_>3 -</g_> OPTIONS pre-flight auto-complete</p><p>
The OPTIONS pre-flight is emitted by the web browser for POST requests or when certain headers are set by Javascript. Since
the destination might reject the request, it is important for the proxy server to be able to auto-respond. Some response
headers may be problematic, such as cache directives or <n_>x-frame-options</n_>. Sometimes, you will need to intercept
and transmit cookies. The last requirement involves TLS handshake fingerprinting, which is something that few servers
actually do, aside from Cloudflare (that&#39;s a tough topic which I won&#39;t be covering in this article).
</p><p>
It is important to distinguish between two modes of proxy interaction: direct and transparent. By <g_>direct</g_>, I mean
that the web scraping app communicates directly with the proxy server as it would communicate with any server, using the
proxy&#39;s domain name (such as &#34;localhost&#34;). The URL would contain a command and a destination URL. The <g_>transparent</g_>
mode of interaction is only possible by configuring the browser&#39;s proxy settings so that all HTTP requests go through the
proxy. This mode will be discussed in my next article.

</p><hr/><p>

<b><b_>Scraping a website with just a few lines of code</b_></b>
</p><p>
Let me be clear about this. You won&#39;t be needing to drag in a third-party package in order to satisfy the claim of &#34;just a
few lines of code&#34;. The claim is all too common and it is facetious because it always turns out that you need to install
a bunch of cumbersome tools with a long learning curve. I&#39;m saying a few lines of code because it is literally true. Your
web browser is perfectly capable of parsing arbitrary data structures of the sort that you will find on the Internet. That
is the browser&#39;s first job, after all. You can parse HTML as text or as a fully-rendered DOM. You can parse JSON and you can
even watch a video. The browser is built for this, unlike Python or Node.js or whatever.
</p><p>
After you have done the work of scraping a website, you can then use the browser to visualize the data with some HTML and
CSS. You could do this in the form of a fully functional app or you could just display the raw data in a <i>div</i> (as we
will be doing here). No third-party cruft is required. Of course, you will be doing some programming in Javascript so you
should do some research if you&#39;re not already comfortable with this. I confess that I don&#39;t qualify as an expert. For that
reason, you can rest assured that the code that I present here will be clean and simple.
</p><p>
First of all, I want you to download this <a href="https://8chananon.github.io/tut/scraper.htm" download="">small template</a> which contains HTML and CSS
along with some example Javascript. Save it on your desktop and then open the app in your browser. It&#39;s just a simple page
with an input line, two buttons and a display area for text messages. Open up the source code and study it for a while.
The main area of interest is this block of Javascript:
</p><pre>var scrape = async () =&gt;
{
  var m, n, resp, data, count = 0; print (&#34;&#34;);

  var url = &#34;https://rumble.com/-playlists/htmx/get-playlist-details?playlist_id=&#34;;
  url = proxy + url + line.value.split (&#34;/&#34;).pop() + &#34;&amp;page_size=10&amp;extended=1&amp;page_num=&#34;;

  for (m = 1; m &lt;= 5; m++) try
  {
    print (&#34;-- Loading page &#34; + m + &#34; --&#34;);

    resp = await fetch (url + m); if (resp.status != 200) throw (&#34;&#34;);
    data = await resp.text();

    data = data.split (&#39;class=&#34;videostream thumbnail__grid-item&#34;&#39;);
    if (data.length &lt; 2) break;  // print (data [1]); break;

    for (n = 1; n &lt; data.length; n++)
    {
      count++; print (pullstring (data [n], &#39;title=&#34;&#39;, &#39;&#34;&#39;));
    }
  }
  catch { print (&#34;Error&#34;); break; }

  print (&#34;Found &#34; + count + &#34; videos&#34;);
}
</pre>
Aside from a function called <g_>pullstring</g_>, that is the whole of the scraper code. I devised <g_>pullstring</g_>
years ago and it has proven to be invaluable to the point that it should be a native part of Javascript. You will be seeing
it a lot in my code. All it does is pull the text found in between two search tokens. It is great for parsing HTML and it
avoids the trouble of rendering the HTML to a DOM. You could DOMify the HTML if you want but I&#39;ve never found this to be
necessary. The HTML is divided into sections using <g_>split</g_> with a class name as the search token. Then the code steps
through the array to extract the data. In this example, I&#39;m just grabbing the title of the video but you can easily
modify the code to extract the date, view count and playing time.
<p>
Let&#39;s run the app. As you can see, it involves Rumble so you need to go to <a href="https://rumble.com">the site</a> and
find a channel with a playlist. Copy the playlist link to the app and press &#34;Go&#34;. There&#39;s not much more that I can say about
it. Play with the app for a while before continuing to the next experiment.

</p><hr/><p>

<b><b_>Converting HTML to DOM</b_></b>
</p><p>
Although I have already stated that rendering the HTML to a DOM (Document Object Model) is not usually necessary, it can
sometimes be helpful in hard cases so I&#39;ll discuss that now. First, you will need to augment the app&#39;s HTML with this:
</p><pre>&lt;div id=&#34;dom&#34; style=&#34;display:none&#34;&gt;&lt;/div&gt;
</pre>
It doesn&#39;t matter where you put it because it will be invisible. We&#39;re going to use it to host the new DOM which we will
create from the HTML in order to study it. Next, modify your scraper code so it looks like this:
<pre>var scrape = async () =&gt;
{
  var m, n, resp, data, count = 0; print (&#34;&#34;);

  var vids, dom = new DOMParser(), doc = document.getElementById (&#34;dom&#34;);

  var url = &#34;https://rumble.com/-playlists/htmx/get-playlist-details?playlist_id=&#34;;
  url = proxy + url + line.value.split (&#34;/&#34;).pop() + &#34;&amp;page_size=10&amp;extended=1&amp;page_num=&#34;;

  for (m = 1; m &lt;= 5; m++) try
  {
    print (&#34;-- Loading page &#34; + m + &#34; --&#34;);

    resp = await fetch (url + m); if (resp.status != 200) throw (&#34;&#34;);
    data = await resp.text();

    data = dom.parseFromString (data, &#34;text/html&#34;);
    doc.innerHTML = &#34;&#34;; doc.appendChild (data.body); break;

    vids = data.querySelectorAll (&#34;.videostream&#34;); if (!vids.length) break;

    for (n = 0; n &lt; vids.length; n++)
    {
      doc = vids [n].querySelector (&#34;.thumbnail__title&#34;); count++; print (doc.title);
    }
  }
  catch { print (&#34;Error&#34;); break; }

  print (&#34;Found &#34; + count + &#34; videos&#34;);
}
</pre>
Not much different from the original. Now load a playlist from Rumble. The code will render the HTML to a DOM on the first
pass and then quit. Open your browser&#39;s developer tools and inspect the app&#39;s own DOM to find the special <i>div</i> you
inserted. Inside the <i>div</i> should be the new DOM. Browse through it. The code sample is already configured to do the
same thing it did before: it will print a list of the video titles. Delete or comment out the line beginning with
&#34;doc.innerHTML&#34; and run the app again. Play with it for a while.
<p>
What we&#39;ve done here is pretty amazing compared to the lengths you would need to go through to get the same result in
a non-browser environment. And it really is &#34;just a few lines of code&#34;. So why not scrape the web with your browser?

</p><hr/><p>

<b><b_>Where to go from here</b_></b>
</p><p>
After reading the above, some of you might be tempted to say to yourself: But, of course, this is all pretty obvious, isn&#39;t
it? It doesn&#39;t seem to be, judging from the prevailing advice being generously handed out to questioners on Internet forums
like Reddit, not to mention the countless YouTube videos. It seems ironic to me that people are using the web browser to
discuss web scraping without ever considering the possibility that the browser could be the very tool that can do the job.
Perhaps it is the inertia generated by the many developers who have an economic stake in this. Web scraping is big business,
both for the tool developers and the companies that consume the scraped data.
</p><p>
At this point, I want to clarify that I&#39;m not suggesting that the browser is a sufficient tool for web scraping on a grand
scale, though I&#39;m not sure why that wouldn&#39;t be feasible. Think about those bot farms driven by hundreds of cell phones
cabled together and maybe it&#39;s not such a wild idea. Consider that the browser can multi-task so it&#39;s certainly capable of
running multiple apps that could be scraping the net 24 hours a day.
</p><p>
In any case, that&#39;s not where I&#39;m coming from. My use case for web scraping consists primarily of extracting video links
from websites for the purpose of playing the videos on my own terms, either in the browser or with an external player. I
don&#39;t normally care about scraping playlists on Rumble or anywhere else though I&#39;ve actually already done that for the
<a href="https://8chananon.github.io/dl/j6-rumble.htm">January 6 videos</a> uploaded by the U.S. Congress. It was not a hard thing to code and it&#39;s
just a single file with no third-party addons whatsoever. I&#39;m guessing that my point is made.
</p><p>
The next phase is to install and use a local proxy server. The remote server is fine for simple use cases (like Rumble) but
it quickly hits a barrier such as that posed by YouTube which blocks data center IP addresses. Of course, there is the
80-kiloton elephant in the room known as Cloudflare. Yes, Cloudflare can be dealt with easily and I&#39;ll show you that in the
next article. The trick involves letting the browser solve the bot challenge and then using the proxy to capture the
cookie (it may or may not be feasible to completely automate the task).
</p><p>
What else do you get? How about the ability to read and write files on the local disk? This is one big reason why the web
browser has not been popular for web scraping. Where do you put the data? You also get a websocket service which could
be pretty darn useful if you have multiple apps that need to talk to each other. You could use the browser facility called
<g_>postMessage</g_> but it has tight security restrictions.
</p><p>
If you&#39;re at all serious about web scraping, whether for personal or professional reasons, you should carefully consider
what I&#39;ve discussed here. Go to my main web page, check out the interesting apps and install the local proxy server.
Till next time.

</p><hr/><p>

<a href="https://8chananon.github.io">My website</a> -
<a href="https://github.com/8chananon">My GitHub repository</a>
<span><r_>September 28, 2024</r_></span>



</p>


</div>
  </body>
</html>
