<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.os2museum.com/wp/this-code-smells-of-desperation/">Original</a>
    <h1>Code Smells of Desperation</h1>
    
    <div id="readability-page-1" class="page"><div>
						
<p>A few weeks ago I had the questionable pleasure of diving into the math exception handler of WIN87EM.DLL, the Windows 3.1 math emulator and FPU support library. Actually WIN87EM.DLL appears to have been first shipped with Windows 3.0, and the version in Windows 3.1 is more or less identical. The version shipped with Windows 3.11 is byte for byte identical to the one in Windows 3.1.</p>



<p>The main function of WIN87EM.DLL is, as the name suggests, an x87 floating-point emulator. It appears to be an outgrowth of the math emulation packages shipped with many Microsoft languages. But even on a system with x87 hardware, WIN87EM.DLL has some work to do.</p>



<p>Namely WIN87EM.DLL intercepts math errors (exceptions). Depending on the system type, WIN87EM.DLL hooks either NMI vector 2 (PC and PC/XT) or IRQ 13 (PC/AT and compatibles).</p>



<p>The math interrupt handler in WIN87EM.DLL is very, <em>very</em> strange. It bears all the hallmarks of code that was written, rewritten, rewritten again, hacked, tweaked, modified, and eventually beaten into submission even if the author(s) had no real idea <em>why</em> it finally worked.</p>



<p>Now, x87 math error handing is a very tricky subject where numerous details changed over FPU and CPU generations, and Intel had a fair share of bugs in this area. But the code in WIN87EM.DLL looks very much like the result of changes made in desperation until it worked <em>somehow</em>, even though the changes made little or no sense.</p>



<h3>What WIN87EM.DLL Does</h3>



<p>The IRQ 13 handler in WIN87EM.DLL performs the following steps:</p>



<ul>
<li>Disable interrupts (CLI)</li>



<li>PUSH and POP the AX register 70 times, maybe it will slow things down</li>



<li>Write zero to I/O port F0h to clear the PC/AT FPU error latch</li>



<li>Mask a selection of interrupts</li>



<li>Write an EOI to the master interrupt controller (but not slave)</li>



<li>Execute the FNSTSW instruction to store the FPU status word (but only that)</li>



<li>PUSH and POP the AX register 16 times, because speed kills</li>



<li>Write zero to I/O port F0h again, in case it didn’t work the first time</li>



<li>Execute the FNCLEX instruction to clear pending FPU exceptions</li>



<li>Write zero to I/O port F0h again, because third time’s the charm</li>



<li>PUSH and POP the AX register 16 times, because it was so much fun last time</li>



<li>Execute the FNCLEX instruction again, just to be really sure</li>



<li>PUSH and POP the AX register 16 times, because it’s the thing to do</li>



<li>Write zero to I/O port F0h again, because three times might not have been enough</li>



<li>Finally jump to code that doesn’t look crazy</li>
</ul>



<p>The not so crazy looking code executes FNSTENV to store the FPU environment, swaps in the previously saved status word (which was subsequently changed by FNCLEX), examines the code at the stored FPU error pointer to see if instruction prefixes should be skipped (that is where things may crash), enables interrupts with STI, and finally jumps to common code that’s executed on both PCs and ATs and handles the actual math error.</p>



<p>All in all, the math error interrupt handler in WIN87EM.DLL makes very little sense. I am extremely doubtful that, for example, writing to I/O port F0h four times does anything useful, or that executing FNCLEX twice is better than doing it once. However, it is entirely possible that the extra time it takes might do something. Likewise the slowdown loops that push and pop AX are very unlikely to be necessary, but may have done something seemingly useful on some particular system.</p>



<p>The code really does look like a desperate attempt to make things work, and there is some possibility that it is the result of trying to support broken hardware. Other similar error handlers I looked at don’t appear nearly as convoluted and are much more “by the book”.</p>



<p>We’ll probably never know why the code ended up so crazy, but we can speculate.</p>
											</div><div><p>
							This entry was posted in <a href="https://www.os2museum.com/wp/category/bugs/" rel="category tag">Bugs</a>, <a href="https://www.os2museum.com/wp/category/microsoft/" rel="category tag">Microsoft</a>, <a href="https://www.os2museum.com/wp/category/pc-architecture/" rel="category tag">PC architecture</a>, <a href="https://www.os2museum.com/wp/category/x87/" rel="category tag">x87</a>. Bookmark the <a href="https://www.os2museum.com/wp/this-code-smells-of-desperation/" title="Permalink to This Code Smells of Desperation" rel="bookmark">permalink</a>.													</p></div></div>
  </body>
</html>
