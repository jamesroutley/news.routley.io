<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/">Original</a>
    <h1>How we applied fuzzing techniques to cURL</h1>
    
    <div id="readability-page-1" class="page"><article id="post-106652">
	<!-- .entry-header -->

	<div>
		<p><em>By Shaun Mirani</em></p>
<p>Near the end of 2022, Trail of Bits was hired by the Open Source Technology Improvement Fund (OSTIF) to <a href="https://daniel.haxx.se/blog/2022/12/21/the-2022-curl-security-audit/">perform a security assessment</a> of the <a href="https://curl.se/">cURL</a> file transfer command-line utility and its library, <a href="https://curl.se/libcurl/">libcurl</a>. The scope of our engagement included a code review, a threat model, and the subject of this blog post: an engineering effort to analyze and improve cURL’s fuzzing code.</p>
<p>We’ll discuss several elements of this process, including how we identified important areas of the codebase lacking coverage, and then modified the fuzzing code to hit these missed areas. For example, by setting certain libcurl options during fuzzer initialization and introducing new seed files, we doubled the line coverage of the HTTP Strict Transport Security (HSTS) handling code and quintupled it for the <code>Alt-Svc</code> header. We also expanded the set of fuzzed protocols to include WebSocket and enabled the fuzzing of many new libcurl options. We’ll conclude this post by explaining some more sophisticated fuzzing techniques the cURL team could adopt to increase coverage even further, bring fuzzing to the cURL command line, and reduce inefficiencies intrinsic to the current test case format.</p>
<h3>How is cURL fuzzed?</h3>
<p><a href="https://google.github.io/oss-fuzz/">OSS-Fuzz</a>, a free service provided by Google for open-source projects, serves as the continuous fuzzing infrastructure for cURL. It supports C/C++, Rust, Go, Python, and Java codebases, and uses the coverage-guided libFuzzer, AFL++, and Honggfuzz fuzzing engines. <a href="https://daniel.haxx.se/blog/2022/07/01/5-years-on-oss-fuzz/">OSS-Fuzz adopted cURL on July 1, 2017</a>, and the incorporated code lives in the <code><a href="https://github.com/curl/curl-fuzzer">curl-fuzzer</a></code> repository on GitHub, which was our focus for this part of the engagement.</p>
<p>The repository contains the code (setup scripts, test case generators, harnesses, etc.) and corpora (the sets of initial test cases) needed to fuzz cURL and libcurl. It’s designed to fuzz individual <em>targets</em>, which are protocols supported by libcurl, such as HTTP(S), WebSocket, and FTP. curl-fuzzer downloads the latest copy of cURL and its dependencies, compiles them, and builds binaries for these targets against them.</p>
<p>Each target takes a specially structured input file, processes it using the appropriate calls to libcurl, and exits. Associated with each target is a corpus directory that contains interesting seed files for the protocol to be fuzzed. These files are structured using a custom type-length-value (TLV) format that encodes not only the raw protocol data, but also specific fields and metadata for the protocol. For example, the fuzzer for the HTTP protocol includes options for the version of the protocol, custom headers, and whether libcurl should follow redirects.</p>
<h3>First impressions: HSTS and Alt-Svc</h3>
<p>We’d been tasked with analyzing and improving the fuzzer’s coverage of libcurl, the library providing curl’s internals. The obvious first question that came to mind was: what does the current coverage look like? To answer this, we wanted to peek at the latest coverage data given in the reports periodically generated by OSS-Fuzz. After some poking around at the URL for the publicly accessible oss-fuzz-coverage Google Cloud Storage bucket, we were able to find the coverage reports for cURL (for future reference, you can get there through the <a href="https://oss-fuzz-introspector.storage.googleapis.com/index.html">OSS-Fuzz introspector page</a>). <a href="https://storage.googleapis.com/oss-fuzz-coverage/curl/reports/20220928/linux/src/curl/lib/report.html">Here’s a report</a> from September 28, 2022, at the start of our engagement.</p>
<p>Reading the report, we quickly noticed that several source files were receiving almost no coverage, including some files that implemented security features or were responsible for handling untrusted data. For instance, hsts.c, which provides functions for parsing and handling the <code><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security">Strict-Transport-Security</a></code> response header, had only 4.46% line coverage, 18.75% function coverage, and 2.56% region coverage after over five years on OSS-Fuzz:</p>
<p><img decoding="async" data-attachment-id="106672" data-permalink="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/image_1-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?fit=1792%2C54&amp;ssl=1" data-orig-size="1792,54" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image_1" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?fit=300%2C9&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?fit=690%2C21&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?resize=690%2C21&amp;ssl=1" alt="" width="690" height="21" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?resize=1024%2C31&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?resize=300%2C9&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?resize=768%2C23&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?resize=1536%2C46&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?resize=1200%2C36&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?w=1792&amp;ssl=1 1792w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_1.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p>The file responsible for processing the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Svc">Alt-Svc</a> response header, altsvc.c, was similarly coverage-deficient:</p>
<p><img decoding="async" data-attachment-id="106674" data-permalink="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/image_2-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?fit=1794%2C54&amp;ssl=1" data-orig-size="1794,54" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image_2" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?fit=300%2C9&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?fit=690%2C21&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?resize=690%2C21&amp;ssl=1" alt="" width="690" height="21" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?resize=1024%2C31&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?resize=300%2C9&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?resize=768%2C23&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?resize=1536%2C46&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?resize=1200%2C36&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?w=1794&amp;ssl=1 1794w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_2.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p>An investigation of the fuzzing code revealed why these numbers were so low. The first problem was that the corpora directory was missing test cases that included the <code>Strict-Transport-Security</code> and <code>Alt-Svc</code> headers, which meant there was no way for the fuzzer to quickly jump into testing these regions of the codebase for bugs; it would have to use coverage feedback to construct these test cases by itself, which is usually a slow(er) process.</p>
<p>The second issue was that the fuzzer never set the <code><a href="https://curl.se/libcurl/c/CURLOPT_HSTS.html">CURLOPT_HSTS</a></code> option, which instructs libcurl to use an HSTS cache file. As a result, HSTS was never enabled during runs of the fuzzer, and most code paths in <code>hsts.c</code> were never hit.</p>
<p>The final impediment to achieving good coverage of HSTS was an issue with its specification, which tells user agents to ignore the <code>Strict-Transport-Security</code> header when sent over unencrypted HTTP. However, this creates a problem in the context of fuzzing: from the perspective of our fuzzing target, which never stood up an actual TLS connection, every connection was unencrypted, and <code>Strict-Transport-Security</code> was always ignored. For <code>Alt-Svc</code>, libcurl already included a <a href="https://github.com/curl/curl/blob/72652c0613d37ce18e99cca17a42887f12ad43da/lib/http.c#L3735-L3740">workaround</a> to relax the HTTPS requirement for debug builds when a certain environment variable was set (although curl-fuzzer did not set this variable). So, resolving this issue was just a matter of adding a similar feature for HSTS to libcurl and ensuring that curl-fuzzer set all necessary environment variables.</p>
<p>Our changes to address these issues were as follows:</p>
<ol>
<li>We added seed files for <code>Strict-Transport-Security</code> and <code>Alt-Svc</code> to curl-fuzzer (<a href="https://github.com/curl/curl-fuzzer/commit/ee7fad2a2869ea3030c1b8d471ff90f51411a5ee">ee7fad2</a>).</li>
<li>We enabled <code>CURLOPT_HSTS</code> in curl-fuzzer (<a href="https://github.com/curl/curl-fuzzer/commit/0dc42e4a8f3ec6a6e7074536cd821e18e10243d4#diff-f50315868d5149f08fd9d32ba6606b3c1f92c29f50801d8921bc586e23bcf3e3R205">0dc42e4</a>).</li>
<li>We added a check to allow debug builds of libcurl to bypass the HTTPS restriction for HSTS when the <code>CURL_HSTS_HTTP</code> environment variable is set, and we set the <code>CURL_HSTS_HTTP</code> and <code>CURL_ALTSVC_HTTP</code> environment variables in curl-fuzzer (<a href="https://github.com/curl/curl/commit/6efb6b1e772934da9f3bc0d5dba5420da14ce587">6efb6b1</a> and <a href="https://github.com/curl/curl-fuzzer/commit/937597c51ecdc7a4140737bfb1e8ed7f24eb4397">937597c</a>).</li>
</ol>
<p>The day after our changes were merged upstream, OSS-Fuzz <a href="https://storage.googleapis.com/oss-fuzz-coverage/curl/reports/20221016/linux/src/curl/lib/report.html">reported</a> a significant bump in coverage for both files:</p>
<p><img decoding="async" data-attachment-id="106675" data-permalink="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/image_3-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?fit=1794%2C54&amp;ssl=1" data-orig-size="1794,54" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image_3" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?fit=300%2C9&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?fit=690%2C21&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?resize=690%2C21&amp;ssl=1" alt="" width="690" height="21" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?resize=1024%2C31&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?resize=300%2C9&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?resize=768%2C23&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?resize=1536%2C46&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?resize=1200%2C36&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?w=1794&amp;ssl=1 1794w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_3.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p><img loading="lazy" decoding="async" data-attachment-id="106676" data-permalink="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/image_4-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?fit=1790%2C54&amp;ssl=1" data-orig-size="1790,54" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image_4" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?fit=300%2C9&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?fit=690%2C21&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?resize=690%2C21&amp;ssl=1" alt="" width="690" height="21" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?resize=1024%2C31&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?resize=300%2C9&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?resize=768%2C23&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?resize=1536%2C46&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?resize=1200%2C36&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?w=1790&amp;ssl=1 1790w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_4.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p>A little over a year of fuzzing later (on <a href="https://storage.googleapis.com/oss-fuzz-coverage/curl/reports/20240129/linux/src/curl/lib/report.html">January 29, 2024</a>), our three fixes had doubled the line coverage for <code>hsts.c</code> and nearly quintupled it for <code>altsvc.c</code>:</p>
<p><img loading="lazy" decoding="async" data-attachment-id="106677" data-permalink="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/image_5-3/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?fit=1999%2C63&amp;ssl=1" data-orig-size="1999,63" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image_5" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?fit=300%2C9&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?fit=690%2C22&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?resize=690%2C22&amp;ssl=1" alt="" width="690" height="22" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?resize=1024%2C32&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?resize=300%2C9&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?resize=768%2C24&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?resize=1536%2C48&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?resize=1200%2C38&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?w=1999&amp;ssl=1 1999w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_5.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<p><img loading="lazy" decoding="async" data-attachment-id="106678" data-permalink="https://blog.trailofbits.com/2024/03/01/toward-more-effective-curl-fuzzing/image_6-2/" data-orig-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?fit=1999%2C56&amp;ssl=1" data-orig-size="1999,56" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="image_6" data-image-description="" data-image-caption="" data-medium-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?fit=300%2C8&amp;ssl=1" data-large-file="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?fit=690%2C20&amp;ssl=1" src="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?resize=690%2C20&amp;ssl=1" alt="" width="690" height="20" srcset="https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?resize=1024%2C29&amp;ssl=1 1024w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?resize=300%2C8&amp;ssl=1 300w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?resize=768%2C22&amp;ssl=1 768w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?resize=1536%2C43&amp;ssl=1 1536w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?resize=1200%2C34&amp;ssl=1 1200w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?w=1999&amp;ssl=1 1999w, https://i0.wp.com/blog.trailofbits.com/wp-content/uploads/2024/02/image_6.png?w=1380&amp;ssl=1 1380w" sizes="(max-width: 690px) 100vw, 690px" data-recalc-dims="1"/></p>
<h3>Sowing the seeds of bugs</h3>
<p>Exploring curl-fuzzer further, we saw a number of other opportunities to boost coverage. One low-hanging fruit we spotted was the set of seed files found in the corpora directory. While libcurl supports numerous protocols (<a href="https://curl.se/docs/features.html">some</a> of which surprised us!) and features, not all of them were represented as seed files in the corpora. This is important: as we alluded to earlier, a comprehensive set of initial test cases, touching on as much major functionality as possible, acts as a shortcut to attaining coverage and significantly cuts down on the time spent fuzzing before bugs are found.</p>
<p>The functionality we created new seed files for, with the hope of promoting new coverage, included (<code><a href="https://github.com/curl/curl-fuzzer/commit/ee7fad2a2869ea3030c1b8d471ff90f51411a5ee">ee7fad2</a></code>):</p>
<ul>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_LOGIN_OPTIONS.html">CURLOPT_LOGIN_OPTIONS</a></code>: Sets protocol-specific login options for IMAP, LDAP, POP3, and SMTP</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_XOAUTH2_BEARER.html">CURLOPT_XOAUTH2_BEARER</a></code>: Specifies an OAuth 2.0 Bearer Access Token to use with HTTP, IMAP, LDAP, POP3, and SMTP servers</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_USERPWD.html">CURLOPT_USERPWD</a></code>: Specifies a username and password to use for authentication</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_USERAGENT.html">CURLOPT_USERAGENT</a></code>: Specifies the value of the User-Agent header</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256.html">CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256</a></code>: Sets the expected SHA256 hash of the remote server for an SSH connection</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_HTTPPOST.html">CURLOPT_HTTPPOST</a></code>: Sets POST request data. curl-fuzzer had been using only the <code>CURLOPT_MIMEPOST</code> option to achieve this, while the similar but deprecated <code>CURLOPT_HTTPPOST</code> option wasn’t exercised. We also added support for this older method.</li>
</ul>
<p>Certain other CURLOPTs, as with CURLOPT_HSTS in the previous section, made more sense to set globally in the fuzzer’s initialization function. These included:</p>
<ul>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_COOKIEFILE.html">CURLOPT_COOKIEFILE</a></code>: Points to a filename to read cookies from. It also enables fuzzing of the cookie engine, which parses cookies from responses and includes them in future requests.</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_COOKIEJAR.html">CURLOPT_COOKIEJAR</a></code>: Allows fuzzing the code responsible for saving in-memory cookies to a file</li>
<li><code><a href="https://curl.se/libcurl/c/CURLOPT_CRLFILE.html">CURLOPT_CRLFILE</a></code>: Specifies the certificate revocation list file to read for TLS connections</li>
</ul>
<h3>Where to go from here</h3>
<p>As we started to understand more about curl-fuzzer’s internals, we drew up several strategic recommendations to improve the fuzzer’s efficacy that the timeline of our engagement didn’t allow us to implement ourselves. We presented these recommendations to the cURL team in our <a href="https://github.com/trailofbits/publications/blob/b01cf46259ff4cc601b06466af92fb5837aa6c3d/reviews/2022-12-curl-securityreview.pdf">final report</a>, and expand on a few of them below.</p>
<h4>Dictionaries</h4>
<p><a href="https://llvm.org/docs/LibFuzzer.html#dictionaries">Dictionaries</a> are a feature of libFuzzer that can be especially useful for the text-based protocols spoken by libcurl. The dictionary for a protocol is a file enumerating the strings that are interesting in the context of the protocol, such as keywords, delimiters, and escape characters. Providing a dictionary to libFuzzer may increase its search speed and lead to the faster discovery of new bugs.</p>
<p>curl-fuzzer already takes advantage of this feature <a href="https://github.com/curl/curl-fuzzer/blob/4f046b3b1cf2f4f6c06b7256472a5a45a507d621/ossconfig/http.dict">for the HTTP target</a>, but currently supplies no dictionaries for the numerous other protocols supported by libcurl. We recommend that the cURL team create dictionaries for these protocols to boost the fuzzer’s speed. This may be a good use case for an LLM; ChatGPT can generate a starting point dictionary in response to the following prompt (replace <code></code> with the name of the target protocol):</p>
<p><span><code>A dictionary can be used to guide the fuzzer. A dictionary is passed as a file to the fuzzer. The simplest input accepted by libFuzzer is an ASCII text file where each line consists of a quoted string. Strings can contain escaped byte sequences like &#34;\xF7\xF8&#34;. Optionally, a key-value pair can be used like hex_value=&#34;\xF7\xF8&#34; for documentation purposes. Comments are supported by starting a line with #. Write me an example dictionary file for a &lt;PROTOCOL&gt; parser.</code></span></p>
<h4>argv fuzzing</h4>
<p>During our first engagement with curl, one of us joked, “Have we tried <code>curl AAAAAAAAAA…</code> yet?” There turned out to be a lot of wisdom behind this quip; it spurred us to fuzz curl’s command-line interface (CLI), which yielded multiple vulnerabilities (see our blog post, <a href="https://blog.trailofbits.com/2023/02/14/curl-audit-fuzzing-libcurl-command-line-interface/">cURL audit: How a joke led to significant findings</a>).</p>
<p>This CLI fuzzing was performed using AFL++’s <code><a href="https://github.com/AFLplusplus/AFLplusplus/blob/c0c985a2781f84313db80eea3662ec88fb264292/utils/argv_fuzzing/argv-fuzz-inl.h">argv-fuzz-inl.h</a></code> header file. The header defines macros that allow a target program to build the <code>argv</code> array containing command-line arguments from fuzzer-provided data on standard input. We recommend that the cURL team use this feature from AFL++ to continuously fuzz cURL’s CLI (implementation details can be found in the blog post linked above).</p>
<h4>Structure-aware fuzzing</h4>
<p>One of curl-fuzzer’s weaknesses is intrinsic to the way it currently structures its inputs, which is with a custom Type-length-value (TLV) format. A TLV scheme (or something similar) can be useful for fuzzing a project like libcurl, which supports a wealth of global and protocol-specific options and parameters that need to be encoded in test cases.</p>
<p>However, the brittleness of this binary format makes the fuzzer inefficient. This is because libFuzzer has no idea about the structure that inputs are supposed to adhere to. curl-fuzzer expects input data in a strict format: a 2-byte field for the record type (of which only 52 were valid at the time of our engagement), a 4-byte field for the length of the data, and finally the data itself. Because libFuzzer doesn’t take this format into account, most of the mutations it generates wind up being invalid at the TLV-unpacking stage and <a href="https://github.com/curl/curl-fuzzer/blob/9e099a0ed0252c609eb3c99afe44b0d8c6993ad8/curl_fuzzer.cc#L62-L65">have to be thrown out</a>. Google’s fuzzing guidance <a href="https://github.com/google/fuzzing/blob/58c45f6314520b2432252eaf767a7a7967916326/docs/split-inputs.md#type-length-value">warns</a> about using TLV inputs for this reason.</p>
<p>As a result, the coverage feedback used to guide mutations toward interesting code paths performs much worse than it would if we dealt only with raw data. In fact, libcurl may contain bugs that will never be found with the current naive TLV strategy.</p>
<p>So, how can the cURL team address this issue while keeping the flexibility of a TLV format? Enter <a href="https://github.com/google/fuzzing/blob/458f6edca28e780dea246b4eab655eb63d0c4cdd/docs/structure-aware-fuzzing.md#structure-aware-fuzzing-with-libfuzzer">structure-aware fuzzing</a>.</p>
<p>The idea with structure-aware fuzzing is to assist libFuzzer by writing a <em>custom mutator</em>. At a high level, the custom mutator’s job comprises just three steps:</p>
<ol>
<li>Try to unpack the input data coming from libFuzzer as a TLV.</li>
<li>If the data can’t be parsed into a valid TLV, instead of throwing it away, return a syntactically correct dummy TLV. This can be anything, as long as it can be successfully unpacked.</li>
<li>If the data does constitute a valid TLV, mutate the fields parsed out in step 1 by calling the <code>LLVMFuzzerMutate</code> function. Then, serialize the mutated fields and return the resultant TLV.</li>
</ol>
<p>With this approach, no time is wasted discarding inputs because every input is valid; the mutator only ever creates correctly structured TLVs. Performing mutations at the level of the decoded data (rather than at the level of the encoding scheme) allows better coverage feedback, which leads to a faster and more effective fuzzer.</p>
<p>An <a href="https://github.com/curl/curl-fuzzer/issues/32">open issue</a> on curl-fuzzer proposes several changes, including an implementation of structure-aware fuzzing, but there hasn’t been any movement on it since 2019. We strongly recommend that the cURL team revisit the subject, as it has the potential to significantly improve the fuzzer’s ability to find bugs.</p>
<h3>Our 2023 follow-up</h3>
<p>At the end of 2023, we had the chance to revisit cURL and its fuzzing code in another <a href="https://ostif.org/curl-audit-complete/">audit supported by OSTIF</a>. Stay tuned for the highlights of our follow-up work in a future blog post.</p>

			</div><!-- .entry-content -->

	
</article></div>
  </body>
</html>
