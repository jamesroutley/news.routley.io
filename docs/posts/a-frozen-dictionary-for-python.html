<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/SubscriberLink/1047238/25c270b077849dc0/">Original</a>
    <h1>A “frozen” dictionary for Python</h1>
    
    <div id="readability-page-1" class="page"><div>
<blockquote>
<div>
<h3>Welcome to LWN.net</h3>
<p>
The following subscription-only content has been made available to you 
by an LWN subscriber.  Thousands of subscribers depend on LWN for the 
best news from the Linux and free software communities.  If you enjoy this 
article, please consider <a href="https://lwn.net/subscribe/">subscribing to LWN</a>.  Thank you
for visiting LWN.net!
</p></div>
</blockquote>

<p>
Dictionaries are ubiquitous in Python code; they are the data structure of
choice for a wide variety of tasks.  But dictionaries are mutable, which
makes them problematic for sharing data in concurrent code.  Python has
added various concurrency features to the language over the last decade or
so—<a href="https://lwn.net/Articles/726600/">async</a>, <a href="https://lwn.net/Articles/947138/">free threading without the global interpreter lock</a>
(GIL), and <a href="https://lwn.net/Articles/941090/">independent subinterpreters</a>—but users must work out their own
solution for an immutable dictionary that can be safely shared by
concurrent code.  There are existing modules that could be used, but a recent proposal, <a href="https://peps.python.org/pep-0814/">PEP 814</a> (&#34;Add frozendict
built-in type&#34;), looks to bring the feature to the language itself.
</p>

<p>
Victor Stinner <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854">announced
the PEP</a> that he and Donghee Na have authored in a post to the PEPs
category of the <a href="https://discuss.python.org/">Python discussion
forum</a> on November 13.  The idea has come up before, including in <a href="https://peps.python.org/pep-0416/">PEP 416</a>, which has essentially
the same title as 814 and was authored by Stinner back in 2012.  It was
rejected by Guido van Rossum at the time, in part due to its target: a <a href="https://lwn.net/Articles/574215/">Python sandbox</a> that never
really panned out.
</p>

<h4><tt>frozendict</tt></h4>

<p>
The idea is fairly straightforward: add <tt>frozendict</tt> as a new
immutable type to the
language&#39;s <a href="https://docs.python.org/3/library/builtins.html#module"><tt>builtins</tt>
module</a>.  As Stinner put it:
</p><blockquote>
We expect <tt>frozendict</tt> to be safe by design, as it prevents any unintended modifications. This addition benefits not only CPython&#39;s standard library, but also third-party maintainers who can take advantage of a reliable, immutable dictionary type.
</blockquote>


<p>
While <tt>frozendict</tt> has a lot in common with the <a href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict"><tt>dict</tt></a>
built-in type, it is <a href="https://peps.python.org/pep-0814/#inherit-from-dict">not a subclass of <tt>dict</tt></a>; instead, it
is a subclass of the base <a href="https://docs.python.org/3/library/functions.html#object"><tt>object</tt></a>
type.  The <tt>frozendict()</tt> constructor can be used to create one in
various ways:
</p><pre>    fd = frozendict()           # empty
    fd = frozendict(a=1, b=2)   # frozen { &#39;a&#39; : 1, &#39;b&#39; : 2 }
    d = { &#39;a&#39; : 1, &#39;b&#39; : 2 }
    fd = frozendict(d)          # same
    l = [ ( &#39;a&#39;, 1 ), ( &#39;b&#39;, 2 ) ]
    fd = frozendict(l)          # same
    fd2 = frozendict(fd)        # same
    assert d == fd == fd2       # True
</pre>


<p>
As with dictionaries, the keys for a <tt>frozendict</tt> must be immutable,
thus <a href="https://docs.python.org/3/glossary.html#term-hashable">hashable</a>,
but the values may or may not be.  For example, a list is a legitimate type
for a value in either type of dictionary, but it is mutable, making the
dictionary as a whole (frozen or not) mutable.  However, if all of the
values stored in a <tt>frozendict</tt> are immutable, it is also immutable,
so it can be hashed and used in places where that is required
(e.g. dictionary keys, set elements, or entries in a <a href="https://docs.python.org/3/library/functools.html#functools.lru_cache"><tt>functools.lru_cache</tt></a>).
</p>

<p>
As might be guessed, based on the last line of the example above, frozen
dictionaries that are hashable can be compared for equality with other
dictionaries of either type.  In addition, neither the <a href="https://docs.python.org/3/library/functions.html#hash"><tt>hash()</tt></a>
value nor the equality test depend on the insertion order of the
dictionary, though that order is preserved in a frozen dictionary (as it is
in the regular variety).  So:
</p><pre>    d = { &#39;a&#39; : 1, &#39;b&#39; : 2 }
    fd = frozendict(d)
    d2 = { &#39;b&#39; : 2, &#39;a&#39; : 1 }
    fd2 = frozendict(d2)
    assert d == d2 == fd == fd2

    # frozendict unions work too, from the PEP
    &gt;&gt;&gt; frozendict(x=1) | frozendict(y=1)
    frozendict({&#39;x&#39;: 1, &#39;y&#39;: 1})
    &gt;&gt;&gt; frozendict(x=1) | dict(y=1)
    frozendict({&#39;x&#39;: 1, &#39;y&#39;: 1})
</pre><p>
For the unions, a new frozen dictionary is created in both cases; the
&#34;</p><tt>|=</tt><p>&#34; union-assignment operator also works by generating a new
</p><tt>frozendict</tt><p> for the result.
</p>

<p>
Iteration over a <tt>frozendict</tt> works as expected; the type implements
the <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Mapping"><tt>collections.abc.Mapping</tt></a>
abstract base class, so <tt>.items()</tt> returns an iterable of key-value
tuples, while <tt>.keys()</tt> and <tt>.values()</tt> provide the keys and
values of the frozen dictionary.
For the most part, a
<tt>frozendict</tt> acts like a <tt>dict</tt> that cannot change; the
specific differences between the two are <a href="https://peps.python.org/pep-0814/#differences-between-dict-and-frozendict">listed
in the PEP</a>.  It also contains a <a href="https://peps.python.org/pep-0814/#possible-candidates-for-frozendict-in-the-stdlib">lengthy
list</a> of places in the standard library where a <tt>dict</tt> could be switched to a
<tt>frozendict</tt> to &#34;<q>enhance safety and prevent unintended modifications</q>&#34;.
</p>

<h4>Discussion</h4>

<p>
The reaction to the PEP was generally positive, with the usual suggestions
for tweaks and more substantive additions to the proposal.  Stinner kept
the discussion focused on the proposal at hand for the most part.  One part
of the proposal was troubling to some: converting a <tt>dict</tt> to a
<tt>frozendict</tt> was described as an O(n) shallow copy.  Daniel F
Moisset <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/19">thought</a>
that it would make sense to have an in-place transformation that could be
O(1) instead.  He proposed adding a <tt>.freeze()</tt> method that would
essentially just change the type of a <tt>dict</tt> object to
<tt>frozendict</tt>. 
</p>

<p>
However, changing the type of an existing object is fraught with peril, as Brett
Cannon <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/20">described</a>:

</p><blockquote>
But now you have made that dictionary frozen for everyone who holds a reference to it, which means side-effects at a distance in a way that could be unexpected (e.g. context switch in a thread and now suddenly you&#39;re going to get an exception trying to mutate what was a dict a microsecond ago but is now frozen). That seems like asking for really nasty debugging issues just to optimize some creation time.
</blockquote>



<p>
The PEP is not aimed at performance, he continued, but is meant to help
&#34;<q>lessen bugs in concurrent code</q>&#34;.  Moisset <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/23">noted</a>,
that dictionaries can already change in unexpected ways via
<a href="https://docs.python.org/3/library/stdtypes.html#dict.clear"><tt>.clear()</tt></a>
or <a href="https://docs.python.org/3/library/stdtypes.html#dict.update"><tt>.update()</tt></a>,
thus the debugging issues already exist.  He recognized that the
authors may not want to tackle that as part of the PEP, but wanted to try
to ensure that an O(1) transformation was not precluded in the future.
</p>

<p>
Cannon&#39;s <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/47">strong
objection</a> is to changing the type of the object directly.  <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/24">Ben
Hsing</a> and <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/48">&#34;Nice
Zombies&#34;</a> proposed ways to construct a new <tt>frozendict</tt> without
requiring the shallow copy—thus O(1)—by either moving the hash table to a
newly created <tt>frozendict</tt>, while clearing the dictionary, or by
using a copy-on-write scheme for the table.  As Steve Dower <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/58">noted</a>,
that optimization can be added later as long as the PEP does not specify
that the operation <i>must</i> be O(n), which would be a silly thing to do,
but that it sometimes happens &#34;<q>because it makes people stop
complaining</q>&#34;, he said in a footnote.  In light of the discussion, the
PEP <a href="https://peps.python.org/pep-0814/#method-to-convert-dict-to-frozendict">specifically
defers</a> that optimization to a later time, suggesting that it could also
be done for other frozen types (<a href="https://docs.python.org/3/library/stdtypes.html#tuple"><tt>tuple</tt></a>
and <a href="https://docs.python.org/3/library/stdtypes.html#frozenset"><tt>frozenset</tt></a>),
perhaps by resurrecting <a href="https://peps.python.org/pep-0351/">PEP
351</a> (&#34;The freeze protocol&#34;).
</p>

<p>
On December 1, Stinner <a href="https://discuss.python.org/t/pep-814-add-frozendict-built-in-type/104854/89">announced</a>
that the PEP had been <a href="https://github.com/python/steering-council/issues/325">submitted to
the steering council</a> for pronouncement.  Given that Na is on the
council, though will presumably recuse himself from deciding on this PEP,
he probably has a pretty good sense for how it might be received by the group.
So it seems likely that the PEP has a good chance of being approved.  The
availability of the
free-threaded version of the language (i.e. without the GIL) means that more
multithreaded Python programs are being created, so having a safe way to share
dictionaries 
between threads will be a boon.
</p></div></div>
  </body>
</html>
