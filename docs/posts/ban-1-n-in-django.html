<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://suor.github.io/blog/2023/03/26/ban-1-plus-n-in-django/">Original</a>
    <h1>Ban 1&#43;N in Django</h1>
    
    <div id="readability-page-1" class="page"><div><p>I always thought of 1+N as a thing that you just keep in your head, catch on code reviews or via performance regressions. This worked well for a long time, however, the less control we have over our SQL queries the more likely it will sneak through those guards.</p>

<!--more-->


<h2>A small history dive</h2>

<p>This used to be very visible and meant almost “do not perform SQL queries in a cycle”:</p>

<figure><figcaption><span></span></figcaption><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td><pre><code><span><span>books</span> <span>=</span> <span>c</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT id, title, author_id FROM books&#34;</span><span>)</span><span>.</span><span>fetchall</span><span>()</span>  <span># 1</span>
</span><span><span>for</span> <span>id</span><span>,</span> <span>title</span><span>,</span> <span>author_id</span> <span>in</span> <span>books</span><span>:</span>
</span><span>    <span>c</span><span>.</span><span>execute</span><span>(</span><span>&#34;SELECT full_name FROM authors WHERE id=?&#34;</span><span>,</span> <span>[</span><span>author_id</span><span>])</span>  <span># +N</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>With ORM and lazy loading this became a little bit less obvious:</p>

<figure><figcaption><span></span></figcaption><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
</pre></td><td><pre><code><span><span>books</span> <span>=</span> <span>Book</span><span>.</span><span>objects</span><span>.</span><span>filter</span><span>(</span><span>...</span><span>)</span>  <span># 1</span>
</span><span><span>for</span> <span>book</span> <span>in</span> <span>books</span><span>:</span>
</span><span>    <span>print</span><span>(</span><span>f</span><span>&#34;Book title: {book.title}, author: {book.author.full_name}&#34;</span><span>)</span>  <span># +N</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>With something so innocent as an attribute access making an SQL query, it’s much easier to miss it. Especially when this code spreads out, the ORM objects are passed to templates, which also have loops and sure they can do attribute access.</p>

<p>As project grows, as its database schema becomes more complicated, as your team grows too, this keeps adding up. And magic also adds up. One particular mention should be a GraphQL library, which resolves onto ORM automatically.</p>

<h2>Back to the present</h2>

<p>I tumbled on a couple of 1+Ns while reading a project code for an unrelated reason and it got me thinking – do I ever want Django to do that lazy loading stuff? And the answer was never. This was a misfeature for me, the need for such thing is quite circumstantial, usually when you load a list of things you need the same data about all of them, so it doesn’t make sense to lazy load extra data for each object separately. Either eager load or batch lazy load, the latter Django does not do.</p>

<p>So, anyway, if I don’t need this than I might as well prohibit it, which turned out to be quite easy to do:</p>

<figure><figcaption><span></span></figcaption><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
</pre></td><td><pre><code><span><span>from</span> <span>django.db.models.query_utils</span> <span>import</span> <span>DeferredAttribute</span>
</span><span>
</span><span>
</span><span><span>def</span> <span>_DeferredAttribute_get</span><span>(</span><span>self</span><span>,</span> <span>instance</span><span>,</span> <span>cls</span><span>=</span><span>None</span><span>):</span>
</span><span>    <span>if</span> <span>instance</span> <span>is</span> <span>None</span><span>:</span>
</span><span>        <span>return</span> <span>self</span>
</span><span>    <span>data</span> <span>=</span> <span>instance</span><span>.</span><span>__dict__</span>
</span><span>    <span>field_name</span> <span>=</span> <span>self</span><span>.</span><span>field</span><span>.</span><span>attname</span>
</span><span>    <span>if</span> <span>field_name</span> <span>in</span> <span>data</span><span>:</span>
</span><span>        <span>return</span> <span>data</span><span>[</span><span>field_name</span><span>]</span>
</span><span>
</span><span>    <span># Raise an exception to prevent an SQL query</span>
</span><span>    <span>attr</span> <span>=</span> <span>f</span><span>&#34;{instance.__class__.__name__}.{field_name}&#34;</span>
</span><span>    <span>message</span> <span>=</span> <span>f</span><span>&#34;Lazy fetching of {attr} may cause 1+N issue&#34;</span>
</span><span>    <span>raise</span> <span>LookupError</span><span>(</span><span>message</span><span>)</span>
</span><span>
</span><span><span>DeferredAttribute</span><span>.</span><span>__get__</span> <span>=</span> <span>_DeferredAttribute_get</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>This way 1+N will blow up instead. Great, we’ll catch it during tests. The thing is, however, if 1+Ns were passing our defences before they will probably continue now and this will explode in production. With this in mind, a flood guard and some explanations it transforms into:</p>

<figure><figcaption><span></span></figcaption><div><table><tbody><tr><td><pre><span>1</span>
<span>2</span>
<span>3</span>
<span>4</span>
<span>5</span>
<span>6</span>
<span>7</span>
<span>8</span>
<span>9</span>
<span>10</span>
<span>11</span>
<span>12</span>
<span>13</span>
<span>14</span>
<span>15</span>
<span>16</span>
<span>17</span>
<span>18</span>
<span>19</span>
<span>20</span>
<span>21</span>
<span>22</span>
<span>23</span>
<span>24</span>
<span>25</span>
<span>26</span>
<span>27</span>
<span>28</span>
<span>29</span>
<span>30</span>
<span>31</span>
<span>32</span>
<span>33</span>
<span>34</span>
<span>35</span>
<span>36</span>
<span>37</span>
<span>38</span>
</pre></td><td><pre><code><span><span>import</span> <span>logging</span>
</span><span><span>import</span> <span>os</span>
</span><span><span>from</span> <span>django.db.models.query_utils</span> <span>import</span> <span>DeferredAttribute</span>
</span><span>
</span><span><span>logger</span> <span>=</span> <span>logging</span><span>.</span><span>getLogger</span><span>(</span><span>__name__</span><span>)</span>
</span><span><span>attrs_seen</span> <span>=</span> <span>set</span><span>()</span>
</span><span>
</span><span>
</span><span><span>def</span> <span>_DeferredAttribute_get</span><span>(</span><span>self</span><span>,</span> <span>instance</span><span>,</span> <span>cls</span><span>=</span><span>None</span><span>):</span>
</span><span>    <span>from</span> <span>django.conf</span> <span>import</span> <span>settings</span>  <span># monkeys go early, settings might not be available yet</span>
</span><span>
</span><span>    <span>if</span> <span>instance</span> <span>is</span> <span>None</span><span>:</span>
</span><span>        <span>return</span> <span>self</span>
</span><span>    <span>data</span> <span>=</span> <span>instance</span><span>.</span><span>__dict__</span>
</span><span>    <span>field_name</span> <span>=</span> <span>self</span><span>.</span><span>field</span><span>.</span><span>attname</span>
</span><span>
</span><span>    <span># Normally this accessor won&#39;t be called if field_name is in __dict__,</span>
</span><span>    <span># we need this part so that DeferredAttribute descendants with __set__ play nice.</span>
</span><span>    <span>if</span> <span>field_name</span> <span>in</span> <span>data</span><span>:</span>
</span><span>        <span>return</span> <span>data</span><span>[</span><span>field_name</span><span>]</span>
</span><span>
</span><span>    <span># If it&#39;s not there already then prevent an SQL query or at least notify we are doing smth bad</span>
</span><span>    <span>attr</span> <span>=</span> <span>f</span><span>&#34;{instance.__class__.__name__}.{field_name}&#34;</span>
</span><span>    <span># Only trigger this check once per attr to not flood Sentry with identical messages</span>
</span><span>    <span>if</span> <span>attr</span> <span>not</span> <span>in</span> <span>attrs_seen</span><span>:</span>
</span><span>        <span>attrs_seen</span><span>.</span><span>add</span><span>(</span><span>attr</span><span>)</span>
</span><span>        <span>message</span> <span>=</span> <span>f</span><span>&#34;Lazy fetching of {attr} may cause 1+N issue&#34;</span>
</span><span>        <span># We stop in DEBUG mode and if inside tests but let production to proceed.</span>
</span><span>        <span># Using LookupError instead of AttributeError here to prevent higher level &#34;handling&#34; this.</span>
</span><span>        <span>if</span> <span>settings</span><span>.</span><span>DEBUG</span> <span>or</span> <span>&#34;PYTEST_CURRENT_TEST&#34;</span> <span>in</span> <span>os</span><span>.</span><span>environ</span><span>:</span>
</span><span>            <span>raise</span> <span>LookupError</span><span>(</span><span>message</span><span>)</span>
</span><span>        <span>else</span><span>:</span>
</span><span>            <span>logger</span><span>.</span><span>exception</span><span>(</span><span>message</span><span>)</span>
</span><span>
</span><span>    <span># Proceed normally</span>
</span><span>    <span>return</span> <span>_DA_get_original</span><span>.</span><span>original</span><span>(</span><span>self</span><span>,</span> <span>instance</span><span>,</span> <span>cls</span><span>)</span>
</span><span>
</span><span><span>_DA_get_original</span><span>,</span> <span>DeferredAttribute</span><span>.</span><span>__get__</span> <span>=</span> <span>DeferredAttribute</span><span>.</span><span>__get__</span><span>,</span> <span>_DeferredAttribute_get</span>
</span></code></pre></td></tr></tbody></table></div></figure>


<p>Which is ready to be used as is. Simply need to put or import it somewhere.</p>

<p><strong>P.S.</strong> A small bonus – how I tried to <a href="https://gist.github.com/Suor/af424c3501792dba6fcf907506987571">make ChatGPT write this post</a> for me. It was mostly failure :), but refactoring the code sample was done nicely.</p>
</div></div>
  </body>
</html>
