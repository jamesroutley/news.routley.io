<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://amontalenti.com/2024/06/19/backups-restic-rclone">Original</a>
    <h1>Linux backup workflow for hackers with restic, rclone, Backblaze B2</h1>
    
    <div id="readability-page-1" class="page"><article id="post-4785">
	
	<!-- .entry-header -->

	<div>
		<p>In 2017, CrashPlan was one of the most popular full-computer offsite/cloud backup tools for consumers. It had millions of paid users, usually paying around $10/month for a few terabytes of offsite storage.</p>
<p>But then… “On August 22, 2017, Code42 announced they were shutting down CrashPlan for Home, effective in October 2018. They were not accepting new subscriptions but would maintain existing subscriptions until the end of their existing subscription period, at which point the backups would be purged.”</p>
<p>Picking a backup tool is hard. If you outsource your backups to a commercial entity, you have to be convinced that entity will stand the test of time — and won’t undergo dramatic business model shifts — since, after all, your backup scheme is supposed to follow you around for life.</p>
<p>This is an ideal software category in which to choose open source software — plus a highly durable, interoperable, and financially-well-supported cloud storage option.</p>
<p>Thankfully, as of 2018 or so, I have this open source software + interoperable cloud storage solution working on my main Linux development machine. I’ve been using it for 5+ years and since I’m very happy with it, I’d like to share it with you all here.</p>
<div><p><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2024/06/restic-logo.png"/></p>
<p><small>The </small><small><a href="https://restic.net">restic</a></small><small> logo sets the tone for how you should think about backups!</small>
</p></div>
<p>As a hacker (that is, as a <a href="https://paulgraham.com/gba.html">playful programmer</a>), you inevitably have important files on your desktop that don’t get automatically backed up some other way. Yes, you probably have your source repos backed up in GitHub or Gitlab, and you probably have your phone backed up in Apple iCloud or Google One. Maybe you are even organized enough to have digital copies of your personal records, usually in DOCX or PDF format, in Dropbox or Google Drive, assuming you trust the data privacy policies of these providers.</p>
<p>But you still have millions of other files on your desktop computers that include: artifacts not checked into source control (or not yet pushed to remote); operating system and application configuration; photographs and videos from your non-phone camera gear; screencasts and Zoom/GMeet video recordings; paranoia-driven backups of data exfiltrated from cloud providers like Gmail and Google Drive; and so on. Perhaps you even have sensitive/important medical or tax/financial records that you’ve been nervous to stick in a cloud data store.</p>
<p>This post will cover a setup that works well in practice, while also having some interesting technical properties worth discussing.</p>

<p>Though I primarily run Linux, I don’t only run Linux. Specifically, I have a Mac Mini that I use for access to Adobe software (Photoshop, Acrobat), Microsoft software (Office), as well as a handful of proprietary macOS-only apps (e.g. Screenflow, MacWhisper). I also used to run Windows 10 as a media PC — I’m a film lover with a small collection of ripped DVDs of old classic films and their extra DVD commentary, and I used this ancient piece of ultra-reliable Windows-only software, DVDShrink, for this purpose. (This media PC was also the last remaining device in my world with an optical disk drive, now a hardware relic!) I’ve been winding down that usage of Windows 10 just to reduce the number of OSes in my life, but I still had to keep it backed up while it was running.</p>
<p>As a result, I’ve had to set up a solid backup workflow across every major desktop operating system. Obviously, solid open source software is harder to come by on macOS and Windows; as a result, for those platforms, I’ll discuss an “indie” software tool which has some open source components.</p>
<p>I’ll cover Linux backup workflows at the end, but, to start off, I’ll describe what I do on macOS and Windows, because I think it’ll be easy to understand before we introduce the Linux tooling that is 100% open source.</p>
<p>Here’s a preview of what’s in this post. These links jump ahead in case you want to skip the macOS and Windows sections.</p>
<ul>
<li><a href="#macos">macOS backups for hackers</a> (Time Machine + Arq + Backblaze B2)</li>
<li><a href="#windows">Windows backups for hackers</a> (Arq + Arq + Backblaze B2)</li>
<li><a href="#linux">Linux backups for hackers</a> (<code>restic</code> + <code>rclone</code> + Backblaze B2)</li>
<li><a href="#examples">Examples of </a><a href="#examples"><code>restic</code></a><a href="#examples"> usage</a></li>
<li><a href="#rclone">Using </a><a href="#rclone"><code>rclone</code></a><a href="#rclone"> to get </a><a href="#rclone"><code>restic</code></a><a href="#rclone"> repos offsite</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="macos">macOS backups for hackers</h2>
<p>If you use macOS and want to keep all your files backed up, I can give you a simple recommendation. Get a nice USB3 SSD, like the <a href="https://amzn.to/3Vm1Q1j">Samsung T7</a> or <a href="https://amzn.to/3WSGABb">Samsung T7 Shield</a>. I particularly like the latter drives with the rubber “shield” if you ever have to travel with them. They grip to more surfaces and feel safer when thrown in a gadget bag.</p>
<p>Pick your Samsung (or equivalent) USB drive storage size using the formula of 2x your local disk — if your MacBook or Mac Mini has 1TB of SSD storage, get a 2TB USB3 SSD. If you have 2TB of built-in storage, get a 4TB drive.</p>
<p>If you have more than 2TB of built-in storage, and you plan to actually use it for backup-worthy files, you are a bit of a packrat and may need an NAS instead of a USB3 drive. You could buy a larger mechanical disk drive, but this will be bigger, noisier, heavier, less portable. I like to keep everything in SSDs now that the price points are affordable. On macOS, a trick you can use is to buy a couple of SSD drives and <a href="https://support.apple.com/guide/disk-utility/overview-of-creating-disk-sets-dskufd8dce72/mac">play around with concatenated disk sets (JBOD)</a>.</p>
<p>Use <a href="https://support.apple.com/en-us/104984">Apple Time Machine</a> to create a local backup of your disk onto the external storage via USB, and leave it connected all the time. The above Samsung drives are silent and have discrete indicator lights in the back of the drive near where the cable comes out. Just in case you’re sensitive to superfluous office sounds and lights, like I am. This is a solid setup.</p>
<p>Note also that you can format the drive with an APFS container with two partitions — a Time Machine partition and a Spillover partition. The way APFS works, the Time Machine partition will automatically grow to use all available space, while the Spillover partition just provides a “scratch” area with any remaining space. This is a nice special feature of APFS and you may as well take advantage of it.</p>
<p>Next: set up a paid account with <a href="https://www.backblaze.com/sign-up/cloud-storage">Backblaze B2</a>. You’ll need a credit card here, and to set up 2FA security. At the time of this writing, their pricing is $6 per terabyte of cloud storage per month, you can see <a href="https://www.backblaze.com/cloud-storage/pricing">their pricing page</a> for the latest details on that. But it’s where you will store your files off-site in the cloud, and it plugs in to the next tool.</p>
<p>Next: Pay for <a href="https://arqbackup.com/pricing/">Arq 7</a>. At the time of writing, this about $50 per computer, but a 5-computer “family pack” is available for about $80. You can also support the developer with a $25/year support plan.</p>
<p>I said “Arq 7” intentionally: <a href="https://www.arqbackup.com/documentation/arq7/English.lproj/arq7ArqPremium.html">Arq 7 is the version where you bring your own cloud storage</a>, not Arq Premium, which bundles its own cloud storage. Plug in Backblaze B2 API key and secret into Arq 7. Now you have offsite cloud backups, too.</p>
<p>At that point, between Time Machine and Arq (with the Backblaze B2 backend), you have a <strong>3-2-1 backup</strong> scheme fully operational.</p>
<p><img decoding="async" width="60%" src="https://amontalenti.com/wordpress/wp-content/uploads/2024/06/321_backup.png"/>
</p>
<p>Namely, you now have 3 copies of your files: the original, a copy locally on the USB3 drive via Time Machine (including a full version history); a copy offsite via Arq (including a full version history), stored in a Backblaze B2 bucket folder. Your on-site backups are encrypted, your off-site backups are encrypted. Your backup procedure is 100% incremental, and low on day-to-day resource usage. Your bytes are protected. Huzzah!</p>
<h2 id="windows">Windows backups for hackers</h2>
<p>You can replicate this setup on Windows, minus Time Machine. The trick for Windows is to pay for Arq 7, once again, but set up <a href="https://www.arqbackup.com/documentation/arq7/English.lproj/storageLocations.html">two storage locations</a>: the local USB3 SSD as an “external drive”, and the Backblaze B2 bucket folder as the “offsite location.”</p>
<p>Essentially, Arq’s style of backup is similar to Time Machine, anyway. It’s snapshot-based and deduplicated. But on macOS, due to the convenience of Time Machine’s integration with the OS, you are better off using Time Machine directly. Especially since Time Machine makes Apple hardware transitions on macOS especially easily e.g. moving from an old Intel Mac Mini to a newer Mac Mini M1/M2, you can do this by pointing the machine at a recent Time Machine backup of the old machine on your external USB3 drive.</p>
<p>One important thing about Arq is that it taps into the right operating system technology to ensure its backup procedure is sound. Specifically: “By default Arq creates an APFS snapshot (on macOS) or a VSS snapshot (on Windows) and uses that snapshot as the source for creating a backup record. The advantage is that Arq is backing up your files as of a point in time, instead of backing up files that are changing.” This is important because sometimes when you run a backup, the state of your filesystem is changing, and naive backup implementations can stick inconsistent filesystem state in your backup repository, because the filesystem will have changed between when the backup started and when it finished. APFS and VSS snapshots address this.</p>
<h2>Is Arq open enough?</h2>
<p>The short answer is no. It’s not F/OSS. And only small bits of it are open source.</p>
<p>If you’re a Linux user, you’ll soon bask in the warm glow of the 100% free and open source <code>restic</code> implementation. But Arq is probably “good enough” for your proprietary OS machines. Especially if they play secondary roles in your hacker life vs your Linux machines. Arq is an indie app developed for Windows and macOS. It started its life on macOS, where it is a popular offsite backup product. You can read <a href="https://www.arqbackup.com/about/">Stefan’s story here</a>.</p>
<p>How about Backblaze? Well, short of running your own data center somewhere, it’s pretty much impossible to make your offsite backup system open source. Perhaps the closest is <a href="https://rsync.net/">rsync.net</a>, which does deserve an honorable mention for its hacker ethos.</p>
<p>But, for my offsite backup, I care more that the company will stand the test of time, and that it is, at least, <em>interoperable</em>. Backblaze is a publicly-traded company (NASDAQ symbol: BLZE; IPO happened in Nov 2021) with a multi-decade history, 100% focused on off-site cloud backup. They’ve been running Backblaze B2 atop their massive disk storage data centers as a cheap alternative to Amazon S3 for almost 10 years. It’s a rock-solid service. Their <a href="https://www.backblaze.com/blog/?s=storage+pod">blog also has some great write-ups</a> of their “Storage Pod” design.</p>
<div><p><img decoding="async" src="https://amontalenti.com/wordpress/wp-content/uploads/2024/06/backblaze-data-center.webp"/><small></small></p>
<p><small>Photograph inside a Backblaze data center, showing their “Storage Pod” design for big RAIDs of spinning rust. They deal with the heat and noise so you don’t have to do so yourself!</small>
</p></div>
<p>Though Backblaze isn’t open source, B2 is <a href="https://www.backblaze.com/docs/cloud-storage-s3-compatible-api">Amazon S3-compatible</a>. That means it plugs in to a ton of open source tooling automatically, such as AWS boto and the AWS S3 CLI. What’s more, the popular <a href="https://rclone.org">rclone</a> UNIX utility has a very performant, stable, and optimized implementation of Backblaze B2 as a backend. Backblaze themselves also provide <a href="https://www.backblaze.com/docs/cloud-storage-command-line-tools">the b2 CLI</a>, implemented in Python, which can access your cloud files.</p>
<p>Though Arq isn’t open source, the developer has made an effort to document the <a href="https://www.arqbackup.com/docs/arqcloudbackup/English.lproj/dataFormat.html">Arq 7 backup data format</a>. What’s more, they have made an effort to make available a macOS command-line tool for restoring backups in this Arq format, called <a href="https://github.com/arqbackup/arq_restore">arq_restore, which you can find on GitHub here</a>. This is all to say: the developer has made the decision to make the “polished experience” of Arq a proprietary and paid experience, so that he can build a lifestyle business around it. But he has made a strong effort to make sure you have a way to recover your data should the company go under, especially with just a little effort from the open source community of users.</p>
<h2>Arq’s design advantages</h2>
<p>What’s so good about Arq anyway? You can check out Arq’s <a href="https://www.arqbackup.com/index.html">features page</a>, but I’ll summarize my favorites:</p>
<ul>
<li>snapshot-based point-in-time backups</li>
<li>automatic chunk-based deduplication</li>
<li>automatic <code>LZ4</code> compression</li>
<li>chunk-based deduplication used as basis for efficient incremental backups</li>
<li>repository data format is designed to be upload-friendly to remote cloud locations (not too many files and folders)</li>
<li>backup repositories are encrypted at rest, only unlockable with a master password</li>
<li>backup process can be tuned to use fewer resources (fewer CPUs, less upload bandwidth)</li>
<li>can restore single files, folders, or whole backups</li>
</ul>
<p>Let’s now move to Linux.</p>
<h2 id="linux">Linux backups for hackers</h2>
<p>Though Arq doesn’t exist on Linux, many open source alternatives abound. I have used many over the years, including <code>rsync</code>, <code>rclone</code>, <code>rdiff-backup</code>, and <code>borg</code>. But, the one that really captured my heart a few years back, and that will be my go-to for as long as it is available, <a href="https://restic.net/">is </a><a href="https://restic.net/"><code>restic</code></a>.</p>
<p>Basically, <code>restic</code> has all the features Arq has. But unlike Arq, because it’s targeted at Linux users, it’s used entirely from the command line. And since it’s open source to the core, you can understand exactly how it all works.</p>
<h2>The key features of <code>restic</code></h2>
<ul>
<li><a href="https://github.com/restic/restic">open source</a> and written in Go (BSD 2-Clause “Simplified” License)</li>
<li>since it uses Go, a single pinned/versioned <code>restic</code> binary can always be backed up along with your backup repository</li>
<li>innovative <a href="https://restic.net/blog/2015-09-12/restic-foundation1-cdc/">content-defined chunking</a> algorithm, which is also abstracted into <a href="https://github.com/restic/chunker">its own simple Go library</a></li>
<li><a href="https://restic.readthedocs.io/en/stable/">extensive documentation and manual via ReadTheDocs</a></li>
<li><a href="https://forum.restic.net">solid community via Discourse forum</a></li>
<li>snapshot-based point-in-time backups using <code>restic backup</code></li>
<li>automatic chunk-based deduplication (built-in to <a href="https://restic.readthedocs.io/en/stable/100_references.html#repository-format">file format</a> via CDC algorithm above)</li>
<li>automatic <a href="https://en.wikipedia.org/wiki/Zstd"><code>zstd</code></a><a href="https://en.wikipedia.org/wiki/Zstd"> compression</a> (controllable per-run, can be turned off for already-compressed files, like JPGs)</li>
<li>chunk-based deduplication used as basis for efficient incremental backups</li>
<li>repository data format is designed to be upload-friendly to remote cloud locations (not too many files and folders)</li>
<li>backup repositories are encrypted at rest, only unlockable with a master password</li>
<li>backup process can be tuned to use fewer resources (fewer CPUs, less upload bandwidth)</li>
<li>written in a highly parallel fashion to take advantage of all of your local CPU cores efficiently, if you just want a full backup to happen quickly</li>
<li>many command-line flags for including/excluding file systems, handling edge cases of different mounted filesystems (such as how to deal with inodes), and so on</li>
<li>can restore single files, folders, or whole backups</li>
<li>can use <code>restic mount</code> to create <a href="https://wiki.archlinux.org/title/FUSE">a FUSE mount point</a> of your backup repository, which then allows you to access the full backup filesystem for any point-in-time snapshot, direct in your file manager or shell</li>
</ul>
<p>Though <code>restic</code> also has a number of cloud backends built-in, including one for Backblaze B2, I don’t personally use those. I use <code>restic</code> only to create the equivalent of “Time Machine” repositories on my Linux machine(s). That is, a USB3 SSD that has a <code>restic</code> repo with regularly-run snapshot backups of my main machine.</p>
<p>Since we’re talking about Linux and hackers, you might wonder whether one’s filesystem choice has an impact on one’s backup methodology. I personally run <a href="https://wiki.archlinux.org/title/ext4">ext4</a> everywhere in my Linux environment: on my desktop developer machine, on my backup drives, and so on. It’s rock solid and simple. But, a lot of folks experiment these days with <a href="https://wiki.archlinux.org/title/ZFS">zfs</a> and <a href="https://wiki.archlinux.org/title/btrfs">btrfs</a>, two filesystems that have snapshotting features built-in. I use these filesystems too, but only on servers, never on my own personal machine.</p>
<p>If you do use zfs or btrfs on your desktop machine, my main piece of advice is to just use ext4 for your backup drives that store your <code>restic</code> repo. I personally think of restic as almost being like “zfs-style snapshot backups in userspace, for any arbitrary filesystem(s).” Since restic has its own concept of chunk-based deduplication and snapshotting in its repo format, may as well keep its underlying filesystem simple and ensure every byte of your backup drive is used actually storing your efficiently-packed restic repository data.</p>
<p>Also, you might think btrfs and zfs snapshots would let you create a snapshot of your filesystem and then backup <em>that</em> rather than your current live filesystem state. That’s a good idea, but it’s still <a href="https://github.com/restic/restic/issues/3557">an open issue on restic for something like this to be built-in</a>. There’s a proposal about how you could script it with ZFS in <a href="https://cyounkins.medium.com/correct-backups-require-filesystem-snapshots-23062e2e7a15">this nice article on the snapshotting problem for backups</a>.</p>
<p>For now, the best idea is to run your <code>restic</code> backups during a time when your computer isn’t actively used, and to shut down background tasks when running your backup. If you are paranoid about inconsistent filesystem state for desktop applications, you could even shut down your entire X11 or Wayland server when running the backup, to ensure no desktop programs are writing files while your backup is running.</p>
<h2 id="rclone">Using <code>rclone</code> to get restic repos offsite</h2>
<p>The restic repository format ensures that every time you run <code>restic backup</code>, it’ll only store new data incrementally into your repository, which speeds up repeated backups dramatically.</p>
<p>To get the third copy of my files off-site to the cloud (to Backblaze B2), I simply <a href="https://rclone.org/commands/rclone_sync/">use </a><a href="https://rclone.org/commands/rclone_sync/"><code>rclone sync</code></a> to copy the entire restic repository up to a Backblaze B2 bucket folder.</p>
<p>When <code>rclone sync</code> is used against a <code>restic</code> repo source and a Backblaze B2 bucket destination, the <code>rclone</code> uploads are also efficiently incremental. It’ll do a rather speedy scan of the local <code>restic</code> repo, do a remote listing of the files in the Backblaze B2 repository, and only upload the new “chunks.” Thus, if a <code>restic backup</code> added, say, 15GB of new data to your backup repository, you’ll see <code>rclone sync</code> doing only 15GB worth of chunk uploading on its next run.</p>
<p>My reasoning for splitting these two processes — <code>restic backup</code> and <code>rclone sync</code> — is that I run the local <code>restic backup</code> procedure more frequently than my offsite <code>rclone sync</code> cloud upload. So I’m OK with them being separate processes, and, what’s more, <a href="https://rclone.org/docs/"><code>rclone</code></a><a href="https://rclone.org/docs/"> offers a different set of handy options</a> for either optimizing (or <a href="https://rclone.org/docs/#bwlimit-bandwidth-spec">intentionally throttling</a>) the cloud-based uploads to Backblaze B2.</p>
<p>So, all together now. Similarly to macOS, for Linux, I have a 3-2-1 backup scheme where I have the local copy of my files on an ext4 filesystem in my internal drive, an extra copy in a local <code>restic</code> repo on an ext4 filesystem living on an external USB3 SSD, and then a final extra copy by virtue of <code>rclone</code> shipping that repo to a Backblaze B2 bucket folder.</p>
<p>All with 100% incremental backups, encryption, compression, deduplication, snapshots built into the open source core, thanks mainly to <code>restic</code>.</p>
<h2>Edge case: photography backups</h2>
<p>I have one more Linux backup workflow, as well. This centers around my Canon 5D3 and R7 photography hardware, and the resulting JPG/CR2/CR3, as well as MP4/MOV files.</p>
<p>For these, I dump all the SD card and CompactFlash media from the cameras into a 2TB USB3 SSD. I then create a <code>restic</code> repo on a 4TB USB3 SSD <em>just for the deduplicated snapshots of these photos/videos</em>. And then I use <code>rclone</code> to copy that repo up to a separate Backblaze B2 backup folder, just for the photos/videos again. Since I know this backup only contains photos/videos produced by Canon hardware, I know that everything is already maximally compressed.</p>
<p>As a result, I <a href="https://restic.readthedocs.io/en/latest/047_tuning_backup_parameters.html#compression">flip off compression</a> on this <code>restic</code> repo, since that wastes a lot of CPU cycles for close to no storage savings.</p>
<p>This is yet another reason I am happy to have split up <code>restic</code> local backups from <code>rclone</code> offsite backups. Because, when I’m traveling on photography trips with limited internet, I bring my laptop and 2x photo SSDs along, but I don’t necessarily have high-speed uplinks available for offsite backups. So I’ll do a photo/video dump onto one SSD, a <code>restic</code> backup onto the second SSD, and then I’ll just “do my best” to get that second SSD’s <code>restic</code> repo shipped to Backblaze B2 via <code>rclone</code> — but, maybe I won’t get to that until I’m fully home from travel, with faster internet access again.</p>
<p>In this “while traveling” edge case, my 3-2-1 setup degrades into a 3-3-0, that is, 3 copies of the data, 3 of them local, 0 offsite (the original SD/CF flash media serves as one copy, the SSD drive for photo/video dumps serves as another, and the restic SSD drive for the unified photo/video backup repository serves as a third). It then switches back to 3-2-1 when I get home, where I upload the <code>restic</code> repo with <code>rclone</code>, and then I clean up the SD/CF flash media, to prep it for the next trip.</p>
<p>Also, for strange reasons related to device compatibility, my photos/videos end up stored on FAT32-formatted drives. FAT32 is an ancient filesystem with major limitations, such as 2TB drives and 8.3 filenames. But its main benefit is that it works nearly everywhere. Inside my Canon cameras, old and new. Old versions of Windows, old versions of macOS, every version of Linux, Android, and iOS. Some day soon, <a href="https://en.wikipedia.org/wiki/ExFAT">exFAT</a> will replace it, but there are still some small corners of the computing world where exFAT isn’t supported. For example, <a href="https://www.esper.io/blog/android-dessert-bites-27-exfat-on-pixel-532176849">exFAT only came to Android devices in 2022</a>, mainly due to patent issues.</p>
<p>For backing up FAT32, I <a href="https://restic.readthedocs.io/en/latest/040_backup.html#file-change-detection">turn off </a><a href="https://restic.readthedocs.io/en/latest/040_backup.html#file-change-detection"><code>restic</code></a><a href="https://restic.readthedocs.io/en/latest/040_backup.html#file-change-detection">’s inode-based file scanning approach</a>, since FAT32 doesn’t have the concept of an inode. But it works wonderfully and speedily anyway, even against FAT32.</p>
<p>Note: though the source filesystem is FAT32 in this case, I always use ext4 as the filesystem on which the restic repo is stored. Remember: <code>restic</code> doesn’t store files, only binary chunks, indices, and metadata, from which a filesystem “view” is recreated on-demand, via snapshots, restores, and mounts. So you want to use a more reliable filesystem, like ext4, to store the restic repo itself.</p>
<h2 id="examples">Examples of <code>restic</code> usage</h2>
<p>In one shell session, to make a repo and make a backup.</p>

<div><div><pre>❯ tree home
home
├── Documents
├── Downloads
└── Pictures
 
❯ mkdir restic-repo
 
❯ ls
home  restic-repo
 
❯ restic init --repo restic-repo
created restic repository 516b735669 at restic-repo
 
Please note that knowledge of your password is required to access
the repository. Losing your password means that your data is
irrecoverably lost.
 
❯ restic backup home --repo restic-repo
repository 516b7356 opened (version 2, compression level auto)
no parent snapshot found, will read all files
 
Files:           0 new,     0 changed,     0 unmodified
Dirs:            4 new,     0 changed,     0 unmodified
Added to the repository: 1.452 KiB (755 B stored)
 
processed 0 files, 0 B in 0:00
snapshot ea45dc65 saved</pre></div></div>

<p>Then, inspect the backup’s state:</p>

<div><div><pre>❯ restic snapshots --repo restic-repo
repository 516b7356 opened (version 2, compression level auto)
ID        Time                 Paths
----------------------------------------------------
ea45dc65  2024-06-19 10:43:47  /home/am/example/home
----------------------------------------------------
1 snapshots</pre></div></div>

<p>Then, create a FUSE mount of the backup repo:</p>

<div><div><pre>❯ mkdir restic-mount
 
❯ restic mount restic-mount --repo restic-repo
repository 516b7356 opened (version 2, compression level auto)
Now serving the repository at restic-mount
Use another terminal to browse the contents of this folder.
When finished, quit with Ctrl-c or umount the mountpoint.</pre></div></div>

<p>Finally, with the mount point being served from one terminal, inspect it from another terminal with <code>ls</code>:</p>

<div><div><pre>❯ ls restic-mount
hosts  ids  snapshots  tags
 
❯ ls restic-mount/snapshots/latest
home
 
❯ ls restic-mount/snapshots/latest/home
Documents  Downloads  Pictures
 
❯ ls restic-mount/snapshots/
2024-06-19T10:43:47-04:00  latest
 
❯ ls restic-mount/ids
ea45dc65</pre></div></div>

<p>You can then kill the <code>restic mount</code> proces. Then, to upload that repo offsite, with an <code>rclone</code> remote called <code>b2</code> (for Backblaze B2) configured, it’s as simple as:</p>

<div><div><pre>rclone sync restic-repo b2:restic-repo</pre></div></div>

<h2 id="conclusion">Conclusion</h2>
<p>Arq 7 is good software, on macOS and Windows, for backups. But it’s paid and proprietary. The indie dev behind it has made a strong effort to open up as much of it as he could while maintaining his business model.</p>
<p>Backblaze B2 is a great SaaS for off-site data storage. It’s cheaper than Amazon S3, but compatible with Amazon S3. It’s plugged in to a lot of UNIX backup tools already, like <code>rclone</code>.</p>
<p><code>restic</code> is an absolutely magical piece of open source Linux software written in Go. It’s free as in free beer, and free as in freedom.</p>
<p>It’s rock-solid and has all the features you need to get your backup workflow handled. I think of it as “ZFS implemented in userspace.” You get repos, snapshots, tags, chunk-based deduplication. You get tuneable compression, performance, pruning, as well. What’s not to love?</p>
<p>Hackers don’t need to live in fear of losing their data. These open (<code>restic</code>, <code>rclone</code>), or nearly-open (Arq), tools can help. Interoperability is also important in your backup approach, which his why Backblaze B2 is a good approach for your offsite backup, it being interoperable with S3 protocols/tools/APIs. Scriptability is of the ultimate importance for backups, and <code>restic</code> + <code>rclone</code> + Backblaze B2 give you the ultimate in scriptability.</p>
<p>Paranoia is also important in backups. “Hope is not a strategy.” These tools all have the right amount of paranoia built right in.</p>
<p>Though setting up a backup workflow you stick to is important to recovering from a disaster scenario, another important thing to remember is to test your backup restores. Human error, forgotten keys, and bitrot can just as much ruin a backup strategy as forgetfulness or a poor tooling architecture can.</p>
<p>Do your backups every day and week, but do a backup restore check <em>at least</em> once a year, on March 31, which is <a href="https://www.worldbackupday.com">World Backup Day</a>. My approach is to restore a single random file from a single random snapshot from the last few months. And to do this from a clean boot of Ubuntu 20.04 / 24.04 LTS, off a USB jump drive “startup disk,” downloading the tools I need, like <code>restic</code>, right then and there from the clean Linux environment.</p>
<p>But you can be even more paranoid than that by, say, restoring a <em>full</em> backup to a formatted old computer or formatted old disk drive.</p>
<p>May your bytes be forever recoverable!</p>
<hr/>
<div><p><strong>For future posts:</strong> I didn’t cover all the technical details I find fascinating about <code>restic</code>. Some areas I could go in a future article are:</p>
<ul>
<li>How restic pruning works</li>
<li>How restic locking works</li>
<li>Running restic as a dedicated <code>restic</code> user</li>
<li>My <code>irestic</code> set of shell scripts around restic</li>
<li>how zstd compression works</li>
<li>restic encryption and decryption</li>
<li>restic snapshot and tag use cases</li>
<li>restic restore approaches</li>
<li>Using <code>restic find</code></li>
<li>Using <code>restic ls</code> with tools like <code>fzf</code></li>
<li>bonus: cron, runitor, and healthchecks.io</li>
</ul>
</div>
	</div><!-- .entry-content -->

	
	<!-- .entry-footer -->

</article></div>
  </body>
</html>
