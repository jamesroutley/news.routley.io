<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.micahlerner.com/2021/07/14/unix-shell-programming-the-next-50-years.html">Original</a>
    <h1>Unix Shell Programming: The Next 50 Years</h1>
    
    <div id="readability-page-1" class="page"><article>
<section>
<header>
<a href="https://www.micahlerner.com/">
<h3>micahlerner.com</h3>
</a>
</header>
</section>

<h4>Published July 14, 2021</h4>
<h5>
Found something wrong?
<a href="https://github.com/mlerner/mlerner.github.io/edit/master/_posts/2021-07-14-unix-shell-programming-the-next-50-years.md">Submit a pull request!</a>
</h5>
<section>
<p><a href="https://sigops.org/s/conferences/hotos/2021/papers/hotos21-s06-greenberg.pdf">Unix Shell Programming: The Next 50 Years</a></p>
<p>This week’s paper won the distinguished presentation award at HotOS 2021, and discusses the potential for future innovation in the tool that many use every day - the shell!<label for="hn"></label><span>A previous submission of this paper on <a href="https://news.ycombinator.com/item?id=27378444">Hacker News</a> elicited a number of strong reactions. One reaction was the assertion that there are in fact modern shells - <a href="https://elv.sh/">Elvish</a> features most prominently. While I think several of the comments on the original posting are in the right direction, my takeaway from this paper was that modern shells could take advantage of exciting advances in other areas of systems research (in particular, data flow and transparent parallelization of computation). </span></p>
<p>It not only proposes a way forward to address (what the authors view) as the shell’s sharp edges, but also references a number of other interesting papers that I will publish paper reviews of over the next few weeks - the gist of several of the papers are mentioned further on in this article:</p>
<ul>
<li><a href="https://dl.acm.org/doi/10.1145/3447786.3456228">PaSh: light-touch data-parallel shell processing</a></li>
<li><a href="https://www.usenix.org/conference/atc20/presentation/raghavan">POSH: A Data-Aware Shell</a></li>
<li><a href="https://www.usenix.org/conference/atc19/presentation/fouladi">From Laptop to Lambda: Outsourcing Everyday Jobs to Thousands of Transient Functional Containers</a></li>
</ul>
<h2 id="the-good-the-bad-and-the-ugly">The good, the bad, and the ugly</h2>
<p>In <em>Unix Shell Programming: The Next 50 Years</em>, the authors argue that while the shell is a powerful tool, it can be improved for modern users and workflows. To make this argument, the paper first considers “the good, the bad, and the ugly” of shells in order to outline what should (or should not) change in shells going forward.</p>
<p>The paper identifies four <em>good</em> components of modern shells:</p>
<ul>
<li><em>Universal composition</em>: The shell already prioritizes chaining small programs working in concert (which can be written in many different languages), according to the Unix philosophy.</li>
<li><em>Stream processing</em>: The shell is well structured to perform computation that flows from one command to another through pipes (for example, using xargs). The paradigm of stream processing is an active area of research outside of the shell and shows up in modern modern distributed systems like <a href="https://flink.apache.org/">Apache Flink</a> or <a href="https://spark.apache.org/streaming/">Spark Streaming</a>.</li>
<li><em>Unix-native</em>: “The features and abstractions of the shell are well suited to the Unix file system and file-based abstractions. Unix can be viewed as a naming service, mapping strings to longer strings, be it data files or programs”</li>
<li><em>Interactive</em>: A REPL-like environment for interacting with your system translates into user efficiency.</li>
</ul>
<p>Next - four <em>bad</em> features are detailed, with the note that, “It’s hard to imagine ‘addressing’ these characteristics without turning the shell into something it isn’t; it’s hard to get the good of the shell without these bad qualities”<label for="wordexp"></label><span>As an example, the paper links to <a href="https://cs.pomona.edu/~michael/papers/px2018.pdf">previous research</a> that word expansion (“the conversion of user input into…a command and its arguments”) make up a significant portion of user commands. </span>:</p>
<ul>
<li><em>Too arbitrary</em>: Almost any command can be executed as part of a shell pipeline<label for="shelltetris"></label><span><a href="https://www.unix.com/shell-programming-and-scripting/174525-tetris-game-based-shell-script-new-algorithm.html">Shell tetris</a>! </span>. While this flexibility is useful for interacting with many different components (each of which may be in a different language), the arbitrariness of a shell makes formalizing a shell’s behavior significantly more difficult.</li>
<li><em>Too dynamic</em>: Shell behavior can depend on runtime execution state, making analysis of shell scripts more difficult (analysis techniques could be helpful for determining undesirable outcomes of shell scripts before running them).</li>
<li><em>Too obscure</em>: There is a 300 page specification for the <a href="https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/utilities/V3_chap02.html#tag_18_12">POSIX shell</a>, in addition to <a href="http://get.posixcertified.ieee.org/testsuites.html">test suites</a>. Unfortunately, the authors found multiple issues with common shells, and even with the test suites themselves! The undefined nature of what a shell is actually supposed to do in specific situations means that it is hard to make guarantees about correctness<label for="smoosh"></label><span><a href="https://mgree.github.io/papers/popl2020_smoosh.pdf">One of the author’s papers</a> goes more in-depth on the question of ‘What is the POSIX shell?’ </span>.</li>
</ul>
<p>Lastly, four <em>ugly</em> components are detailed:</p>
<ul>
<li><em>Error proneness</em>: There aren’t checks to prevent a user from making mistakes (which could have drastic conditions). <a href="https://www-uxsup.csx.cam.ac.uk/misc/horror.txt">Unix/Linux Horror Stories</a> has some good ones (or bad, if you were the person making the mistake!).</li>
<li><em>Performance doesn’t scale</em>: the shell isn’t set up to parallelize trivially parallelize problems across many cores or machines (which would be very helpful in a modern environment)<label for="gg"></label><span>If this is interesting to you, predominantly all of the papers in the series discuss with this problem. </span>.</li>
<li><em>Redundant recomputation</em>: If a developer makes a change to a shell script, they will have to rerun it in its entirety (unless they are a shell wizard and have gone out of their way to ensure that their script does not do so, while potentially making operations idempotent).</li>
<li><em>No support for contemporary deployments</em>: Similar to the 2nd point - most shell scripts aren’t designed to take advantage of multiple machines, nor of cloud deployments.</li>
</ul>
<h2 id="enabling-the-shell-to-move-forward">Enabling the shell to move forward</h2>
<p>The paper next argues that two sets of recent academic research are enabling the shell to move forward: <em>formalizing the shell</em> and <em>annotation languages</em>.</p>
<p>Recent work on <em>formalizing the shell</em> is detailed in <a href="https://mgree.github.io/papers/popl2020_smoosh.pdf">Executable Formal Semantics for the POSIX Shell</a>, which has two major components: <em>Smoosh</em> and <em>libdash</em> - the artifacts for <a href="https://github.com/mgree/smoosh">both are open source</a>.</p>
<p><em>Smoosh</em> is an executable shell specification written in <a href="https://dl.acm.org/doi/10.1145/2692915.2628143">Lem</a><label for="Smoosh"></label><span>Which can then be translated to different formats, including proof languages like Coq </span>. A shell specification written in code (versus the extensive written specification) meant that the aforementioned paper was able to test various shells for undefined behavior, in the process finding several bugs in implementation (not to mention, bugs in the test suite for the POSIX shell specification!)<label for="smoosh"></label><span>Another interesting feature of <em>Smoosh</em> is that it provides two interfaces to interact with the OS - one actually invokes syscalls, whereas the other mode simulates syscalls (and is used for <a href="https://www.cs.umd.edu/~mwh/se-tutorial/symbolic-exec.pdf">symbolic execution</a>). This vaguely reminds me of the testing system used in <a href="https://www.micahlerner.com/2021/06/12/foundationdb-a-distributed-unbundled-transactional-key-value-store.html">FoundationDB</a>, covered in a previous paper review. </span>. <em>libdash</em> transforms shell scripts from (or to) abstract syntax trees, and is used by <em>Smoosh</em>.</p>
<p><em>Annotation languages</em> can allow users to specify how a command runs, in addition to possible inputs and outputs. Strictly specifying a command allows for it to be included as a step (with inputs and outputs) in a data flow graph, enabling more advanced functionality - for example, deciding to divide the inputs of a step across many machines, perform computation in parallel, then coalescing the output. If this type of advanced functionality sounds interesting to you, stay tuned! I’ll be reading about the two papers that fall into this category (PaSH &amp; POSH) over the next few weeks.</p>
<p>After discussing these two research areas, the paper discusses a new project from the authors, called Jash (Just Another SHell). It can act as a shim between the user and the actual execution of a shell command. Eventually, Jash seems like it could implement functionality similar to an execution engine or query planner, evaluating commands at runtime and deciding how to perform the requested work (providing feedback to the user if the script will produce unintended side effects).</p>
<h2 id="the-future">The future</h2>
<p>The paper outlines five functionalities for the future of the shell:</p>
<ul>
<li><em>Distribution</em>: in the context of a shell, this means building a system capable of scaling beyond a single machine (for example, inserting compute resources at different stages of a shell command’s execution to parallelize) - all three of the papers in this series dive deep on this idea.</li>
<li><em>Incremental support</em>: if a shell script is changed slightly, but can reuse previous computation, a shell could strive to do so.<label for="dd"></label><span>The paper cites <a href="https://github.com/TimelyDataflow/differential-dataflow">Differential Dataflow</a>, which is related to another paper I have had on the backlog for a while - <a href="http://sigops.org/s/conferences/sosp/2013/papers/p439-murray.pdf">Naiad: A Timely Dataflow System</a>. </span></li>
<li><em>Heuristic support</em>: While transforming a shell script into a data flow graph can be facilitated by <em>annotation languages</em>, it would be costly to annotate every shell command. Ideally, the annotation of commands could be performed automatically (or with the support of automation).</li>
<li><em>User support</em>: A shell should take advantage of modern features like language servers. A formal specification for interacting with the shell can theoretically simplify interactions with the shell.</li>
<li><em>Formal support</em>: The paper cites how formalization has helped C “tool authors and standards writers”, in particular with respect to undefined behavior. Diving deep on this, I found a <a href="https://people.csail.mit.edu/nickolai/papers/wang-undef.pdf">few</a> helpful papers that discuss undefined C behavior - in particular <a href="https://blog.regehr.org/archives/1520">this one</a> from Pascal Cuoq and John Regehr).</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>The shell is an integral part of systems, and this paper makes a case for revisiting the shell’s sharp edges, while revamping its functionality for modern use cases. I’m excited to keep diving deep on this topic - this is the first post in a series I’m doing! If you enjoyed it (or otherwise have suggestions), find me on <a href="https://twitter.com/micahlerner">Twitter</a>. Until next time.</p>

</section>
<section>
Found something wrong?
<a href="https://github.com/mlerner/mlerner.github.io/edit/master/_posts/2021-07-14-unix-shell-programming-the-next-50-years.md">Submit a pull request!</a>
</section>
</article></div>
  </body>
</html>
