<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://daniel.haxx.se/blog/2024/10/30/eighteen-years-of-abi-stability/">Original</a>
    <h1>Eighteen Years of ABI Stability</h1>
    
    <div id="readability-page-1" class="page"><div>
		
<p>Exactly eighteen years ago today, on October 30 2006, we shipped <a href="https://curl.se/ch/7.16.0.html">curl 7.16.0</a> that among a whole slew of new features and set of bugfixes bumped the libcurl SONAME number from 3 to 4.</p>



<h2>ABI breakage</h2>



<p>This bump meant that libcurl 7.16.0 was not binary compatible with the previous releases. Users could not just easily and transparently bump up to this version from the previous, but they had to check their use of libcurl and in some cases adjust source code.</p>



<p>This was not the first ABI breakage in the curl project, but at this time our use base was larger than at any of the previous bumps and this time people complained about the pains and agonies such a break brought them.</p>



<h2>We took away FTP features</h2>



<p>In the 7.16.0 release we removed a few FTP related features and their associated options. Before this release, you could use curl to do “third party” transfers over FTP, and in this release you could no longer do that. That is a feature when the client (curl) connects to server A and instructs that server to communicate with server B and do file transfers among themselves, without sending data to and from the client.</p>



<p>This is an FTP feature that was not implemented well in curl and it was poorly tested. It was also a feature that barely no FTP server allowed and subsequently this was not used by many users. We ripped it out.</p>



<h2>A near pitchfork situation</h2>



<p>Because so few people used the removed features, barely anyone actually noticed the ABI breakage. It remained theoretical to most users and I believe that detail only made people more upset over the SONAME bump because they did not even see the necessity: we just made their lives more complicated for no benefit (to them).</p>



<p>The Debian project even decided to override our decision <em>“no, that is not an ABI breakage”</em> and added a local patch in their build that lowered the SONAME number back to 3 again in their builds. A patch they would stick to for many years to come.</p>



<p>The obvious friction this bump caused, even when in reality it actually did not affect many users and the loud feedback we received, made a huge impact on me. It had not previously dawned on me exactly how important this was.</p>



<p>I decided there and then to do the utmost to never go through this again. To put ABI compatibility at the top of the priority list. Make it one of the most fundamental key properties of libcurl.</p>



<p><strong>Do. Not. Break. The. ABI</strong></p>



<p>(we don’t break the API either)</p>



<h2>A never-breaking ABI</h2>



<p>The decision was initially made to avoid the negativity the bump brought, but I have since over time much more come to appreciate the upsides.</p>



<p><em>Application authors everywhere can always and without risk keep upgrading to the latest libcurl.</em></p>



<p>It sounds easy and simple, but the impact is huge. The examples, the documentation, the applications, everything can just always upgrade and continue. As libcurl over time has become even more popular and compared to 2006, used in many magnitudes more installations, it has grown into an even more important aspect of the curl life. Possibly <em>the</em> single most important properly of curl.</p>



<p>There is a small caveat here and that is that we occasionally of course have bugs and regressions, so when I say that users can always upgrade, that is true in the sense that we have not broken the ABI since. We have however had a few regressions that sometimes have triggered some users to downgrade again or wait a little longer for the next release that has the bug fixed.</p>



<p>When we took that decision in 2006 we had less than 50,000 lines of product code. Today we are approaching 180,000 lines.</p>



<h2>Effects of never breaking ABI</h2>



<p>We know that once we adopt a change, we are stuck with it for decades to come. It makes us double-check every knot before we accept new changes.</p>



<p>Once accepted and shipped, we keep supporting code and features that we otherwise could have reconsidered and perhaps removed. Sometimes we think of a better way to do something <em>after</em> the initial merge, but by then it is too late to change. We can then always introduce new and better ways to do things, but we have to keep supporting the old way as well.</p>



<p>A most fundamental effect is that we can never shrink the list of options we support. We can never actually rename something. Doing new things and features consistently over this long time is hard if not impossible, as we learn new things and paradigms vary through the decades.</p>



<h2>How</h2>



<p>The primary way we maintain this is by manual code view and code inspection of every change. Followed of course by a large range of tests that make sure that assumptions remain.</p>



<p>Occasionally we have (long) discussions around subtle details when someone proposes a change that potentially might be considered an ABI break. Or not.</p>



<p>What exactly is covered by <em>ABI compatibility</em> is not always straight forward or easy to have carved in stone. In particular since the project can be built and run on such a wide range of systems and architectures.</p>



<h2>Deprecating</h2>



<p>We <em>can</em> still remove functionality if the conditions are right.</p>



<p>Some features and options are documented and work in a way so that something is <em>requested</em> or <em>asked for</em> and libcurl then tries to satisfy that ask. Like for example libcurl once supported HTTP/1 pipelining like that.</p>



<p>libcurl still provides the option to enable pipelining and applications can still ask for it so it is still ABI and API compatible, but a modern libcurl simply will never do it because that functionality has been removed.</p>



<p>Example two: we dropped support for NPN a few years back. NPN being a TLS extension called Next Protocol Negotiation that was used briefly in the early days of HTTP/2 development before ALPN was introduced and replaced NPN.  Virtually nothing requires NPN anymore, and users can still set the option asking for it, but it will never actually happen over the wire.</p>



<p>Furthermore, a typical libcurl build involves multiple third party libraries that provide features it needs. For things like TLS, SSH, compression and binary HTTP protocol management. Over the years, we have removed support for several such libraries and introduced support for new, in ways that was never visible in the API or ABI. Some users just had to switch to building curl with different helper libraries.</p>



<p>In reality, libcurl is typically more stable than most existing servers and URLs. The libcurl examples you wrote in 2006 can still be built with the modern libcurl, but the servers and URLs you used back then most probably cannot be used anymore.</p>



<h2>If no one can spot it, it did not happen</h2>



<p>As blunt as it may sound, it has came down to this fundamental statement several times to judge if a change is an ABI breakage or not:</p>



<p><em>If no one can spot an ABI change, it is not an ABI change</em></p>



<p>Of course what makes it harder than it sounds is that it is extremely difficult to actually know if someone will notice something ahead of time. libcurl is used in so ridiculously many installations and different setups, second-guessing whatever everyone does and wants is darned close to impossible.</p>



<p>Adding to the challenge is the crazy long upgrade cycles some of our users seem to sport. It is not unusual to see questions appear on the mailing lists from users bumping from curl versions from eight or ten years ago. The fact that we have not  heard users comment on a particular change might just mean that they are still stuck on ancient versions.</p>



<p>Getting frustrated comments from users today about a change we landed five years ago is hard to handle.</p>



<h2>Forwards compatible</h2>



<p>I should emphasize that all this means that users can always upgrade to a <em>later</em> release. It does not necessarily mean that they can switch back to an older version without problems. We do add new features over time and if you start using a new feature, the application of course will not work, or even still compile, if you would switch to a libcurl version from before that feature was added.</p>



<h2>How long is never</h2>



<p>What I have laid out here is our plan and ambition. We have managed to stick to this for eighteen years now and there is no particular known blockers in the known future either.</p>



<p>I cannot rule out that we might at some point in the future run into an obstacle so huge or complicated that we will be forced to do the unthinkable. To break the ABI. But until we see absolutely no other way forward, it is not going to happen.</p>
	</div></div>
  </body>
</html>
