<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jeremymorrell.dev/blog/minimal-js-tracing/">Original</a>
    <h1>OpenTelemetry Tracing in &lt; 200 lines of code</h1>
    
    <div id="readability-page-1" class="page"><article> <p>Developers tend to treat tracing as deep magic, and OpenTelemetry is no exception. OpenTelemetry may be even
<em>more</em> mysterious given how many concepts your are exposed to even with
<a href="https://github.com/open-telemetry/opentelemetry-js/blob/9c30124e764e08bd6ccf8dbfbe426a8531c20352/examples/basic-tracer-node/index.js">beginning examples</a>.
<a href="#footnote-1" id="footnote-ref-1" data-footnote-ref="true" aria-describedby="footnote-label"><code>[1]</code></a></p>
<p>It also doesn‚Äôt help that as part of building a mature, battle-tested tracing library, the code itself tends to become
more and more cryptic over time, contorting itself to avoid edge-cases, work across many environments, and optimize
code paths to avoid impacting performance of its host applications. <a href="https://github.com/open-telemetry/opentelemetry-js-contrib/blob/12adb4354f09ade438cd96340bdfd1f715b5fed3/plugins/node/opentelemetry-instrumentation-express/src/instrumentation.ts#L153-L327">Auto-instrumentation is particularly prone to
inscrutibility</a> as it seeks to auto-magically wrap code that may never have been intended to be wrapped or extended.</p>
<p>It‚Äôs no wonder then that most developers approach tracing libraries as unknownable black boxes. We add them to our
applications, cross our fingers, and hope they give us useful information when the pager goes off at 2am.</p>
<p>They are likely a lot simpler than you expect! Once you peel back the layers, I find a useful mental model of tracing
looks like ‚Äúfancy logging‚Äù combined with ‚Äúcontext propagation‚Äù a.k.a ‚Äúpassing some IDs around‚Äù.</p>
<h3 id="logs">Logs</h3>
<p>Developers tend to be very comfortable with logs. We start off with ‚ÄúHello world!‚Äù, and they stay with us forever after.
We reach for them to add <code>console.log(&#34;potato&#34;)</code> to see if our code is even being run (even though the debugger is
like <em>right there</em>).</p>
<p>Logs are useful! Though hopefully someone comes along and convinces you that your logs should always be structured as sets of key / value pairs.</p>
<blockquote><p lang="en" dir="ltr">If you make one New Year‚Äôs resolution related to modernizing your infrastructure and preparing for the brave new world of distributed systems, I suggest this:</p>‚Äî Charity Majors (@mipsytipsy) <a href="https://twitter.com/mipsytipsy/status/951272678345687040?ref_src=twsrc%5Etfw">January 11, 2018</a></blockquote> 
<p>It‚Äôs nice to have some consistency in your logs: make sure each one has a consistently-formatted timestamp or includes a field like
‚Äúname‚Äù so you can easily find them when searching. You probably have found yourself writing a helper function like this in your projects:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>log</span><span>(</span><span>&#34;user-authenticated&#34;</span><span>, { userId, remaingingRateLimit });</span></span>
<span></span>
<span><span>// ...</span></span>
<span></span>
<span><span>function</span><span> log</span><span>(</span><span>name</span><span>, </span><span>attributes</span><span> =</span><span> {}) {</span></span>
<span><span>  console.</span><span>log</span><span>(</span></span>
<span><span>    JSON</span><span>.</span><span>format</span><span>({</span></span>
<span><span>      name,</span></span>
<span><span>      timestamp: </span><span>new</span><span> Date</span><span>().</span><span>getTime</span><span>(),</span></span>
<span><span>      ...</span><span>attributes,</span></span>
<span><span>    })</span></span>
<span><span>  );</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="js"><code><span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1725845013447</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;user-authenticated&#34;</span><span>, </span><span>&#34;userId&#34;</span><span>: </span><span>&#34;1234&#34;</span><span>, </span><span>&#34;remaingingRateLimit&#34;</span><span>: </span><span>100</span><span> }</span></span>
<span></span></code></pre>
<p>You might also have written something to help track how long some sub-task takes:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>logTiming</span><span>(</span><span>&#34;query-user-info&#34;</span><span>, () </span><span>=&gt;</span><span> {</span></span>
<span><span>  db.</span><span>fetchUserInfo</span><span>();</span></span>
<span><span>});</span></span>
<span></span>
<span><span>// ....</span></span>
<span></span>
<span><span>function</span><span> logTiming</span><span>(</span><span>name</span><span>, </span><span>attributes</span><span> =</span><span> {}, </span><span>lambda</span><span>) {</span></span>
<span><span>  let</span><span> startTime </span><span>=</span><span> new</span><span> Date</span><span>().</span><span>getTime</span><span>();</span></span>
<span></span>
<span><span>  // run some subtask</span></span>
<span><span>  lambda</span><span>();</span></span>
<span></span>
<span><span>  let</span><span> durationMs </span><span>=</span><span> new</span><span> Date</span><span>().</span><span>getTime</span><span>() </span><span>-</span><span> startTime;</span></span>
<span><span>  log</span><span>(name, { durationMs, </span><span>...</span><span>attributes });</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<pre tabindex="0" data-language="js"><code><span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1725845013447</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;query-user-info&#34;</span><span>, </span><span>&#34;durationMs&#34;</span><span>: </span><span>12</span><span> }</span></span>
<span></span></code></pre>
<p>If so, congrats! You‚Äôre halfway to re-inventing trace spans.</p>
<h2 id="spans-are-fancy-log-lines">Spans are ‚ú®fancy‚ú® log lines</h2>
<p>A trace is built-up of spans. The example below shows a single trace with 4 different spans:</p>
<p><img src="https://jeremymorrell.dev/_astro/trace-example.CjGDJS25_1rbk53.webp" alt="A Honeycomb screenshot of a trace waterfall" width="1930" height="318" loading="lazy" decoding="async"/></p>
<p>You can think of a span as a collection of key / value pairs, much like a log line, with a few required fields.
Spans must have:</p>
<ul>
<li>a name</li>
<li>a timestamp</li>
<li>a duration</li>
<li>a set of IDs: trace ID, span ID, and a parent span ID. More about these later</li>
</ul>
<p>All other fields can be added as additional keys and values in an <code>attributes</code> map.</p>
<p>In code this might look something like this:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>let</span><span> span </span><span>=</span><span> new</span><span> Span</span><span>(</span><span>&#34;api-req&#34;</span><span>);</span></span>
<span><span>let</span><span> resp </span><span>=</span><span> await</span><span> api</span><span>(</span><span>&#34;get-user-limits&#34;</span><span>);</span></span>
<span><span>span.</span><span>setAttributes</span><span>({ responseCode: resp.code });</span></span>
<span><span>span.</span><span>End</span><span>();</span></span>
<span><span>console.</span><span>log</span><span>(span);</span></span>
<span></span>
<span><span>// ...</span></span>
<span></span>
<span><span>class</span><span> Span</span><span> {</span></span>
<span><span>  constructor</span><span>(</span><span>name</span><span>, </span><span>context</span><span> =</span><span> {}, </span><span>attributes</span><span> =</span><span> new</span><span> Map</span><span>()) {</span></span>
<span><span>    this</span><span>.startTime </span><span>=</span><span> new</span><span> Date</span><span>().</span><span>getTime</span><span>();</span></span>
<span><span>    this</span><span>.traceID </span><span>=</span><span> context.traceID </span><span>??</span><span> crypto.</span><span>randomBytes</span><span>(</span><span>16</span><span>).</span><span>toString</span><span>(</span><span>&#34;hex&#34;</span><span>);</span></span>
<span><span>    this</span><span>.parentSpanID </span><span>=</span><span> context.spanID </span><span>??</span><span> undefined</span><span>;</span></span>
<span><span>    this</span><span>.spanID </span><span>=</span><span> crypto.</span><span>randomBytes</span><span>(</span><span>8</span><span>).</span><span>toString</span><span>(</span><span>&#34;hex&#34;</span><span>);</span></span>
<span><span>    this</span><span>.name </span><span>=</span><span> name;</span></span>
<span><span>    this</span><span>.attributes </span><span>=</span><span> attributes;</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  setAttributes</span><span>(</span><span>keyValues</span><span>) {</span></span>
<span><span>    for</span><span> (</span><span>let</span><span> [key, value] </span><span>of</span><span> Object.</span><span>entries</span><span>(keyValues)) {</span></span>
<span><span>      this</span><span>.attributes.</span><span>set</span><span>(key, value);</span></span>
<span><span>    }</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  end</span><span>() {</span></span>
<span><span>    this</span><span>.durationMs </span><span>=</span><span> new</span><span> Date</span><span>().</span><span>getTime</span><span>() </span><span>-</span><span> this</span><span>.startTime;</span></span>
<span><span>  }</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>This output would be:</p>
<pre tabindex="0" data-language="plaintext"><code><span><span>Span {</span></span>
<span><span>  startTime: 1722436476271,</span></span>
<span><span>  traceID: &#39;cfd3fd1ad40f008fea72e06901ff722b&#39;,</span></span>
<span><span>  parentSpanID: undefined,</span></span>
<span><span>  spanID: &#39;6b65f0c5db08556d&#39;,</span></span>
<span><span>  name: &#39;api-req&#39;,</span></span>
<span><span>  attributes: Map(0) {</span></span>
<span><span>    &#34;responseCode&#34;: 200</span></span>
<span><span>  },</span></span>
<span><span>  durationMs: 3903</span></span>
<span><span>}</span></span>
<span><span></span></span></code></pre>
<p>which we could format as an equivalent log line:</p>
<pre tabindex="0" data-language="json"><code><span><span>{</span></span>
<span><span>  &#34;startTime&#34;</span><span>: </span><span>1722436476271</span><span>,</span></span>
<span><span>  &#34;traceID&#34;</span><span>: </span><span>&#34;cfd3fd1ad40f008fea72e06901ff722b&#34;</span><span>,</span></span>
<span><span>  &#34;spanID&#34;</span><span>: </span><span>&#34;6b65f0c5db08556d&#34;</span><span>,</span></span>
<span><span>  &#34;name&#34;</span><span>: </span><span>&#34;api-req&#34;</span><span>,</span></span>
<span><span>  &#34;responseCode&#34;</span><span>: </span><span>200</span><span>,</span></span>
<span><span>  &#34;durationMs&#34;</span><span>: </span><span>3903</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<h2 id="traces-are-collections-of-spans">Traces are collections of spans</h2>
<p>If you want to see all of the logs from a particular request, you have likely done something like:</p>
<pre tabindex="0" data-language="javascript"><code><span><span>// generate a request id and inherit one from your platform</span></span>
<span><span>let</span><span> requestID </span><span>=</span><span> req.headers[</span><span>&#34;X-REQUEST-ID&#34;</span><span>];</span></span>
<span><span>// ...</span></span>
<span><span>log</span><span>(</span><span>&#34;api-request-start&#34;</span><span>, { requestID });</span></span>
<span><span>let</span><span> resp </span><span>=</span><span> await</span><span> apiRequest</span><span>();</span></span>
<span><span>log</span><span>(</span><span>&#34;api-request-end&#34;</span><span>, { requestID });</span></span>
<span></span></code></pre>
<p>which would allow you to search for a particular request id to see what happened while that particular request was executed:</p>
<pre tabindex="0" data-language="json"><code><span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1722436476271</span><span>, </span><span>&#34;requestID&#34;</span><span>: </span><span>&#34;1234&#34;</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;fetch-user-permissions&#34;</span><span> }</span></span>
<span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1722436476321</span><span>, </span><span>&#34;requestID&#34;</span><span>: </span><span>&#34;1234&#34;</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;api-request-start&#34;</span><span> }</span></span>
<span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1722436476345</span><span>, </span><span>&#34;requestID&#34;</span><span>: </span><span>&#34;1234&#34;</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;api-request-end&#34;</span><span> }</span></span>
<span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1722436476431</span><span>, </span><span>&#34;requestID&#34;</span><span>: </span><span>&#34;1234&#34;</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;update-db-record&#34;</span><span> }</span></span>
<span><span>{ </span><span>&#34;timestamp&#34;</span><span>: </span><span>1722436476462</span><span>, </span><span>&#34;requestID&#34;</span><span>: </span><span>&#34;1234&#34;</span><span>, </span><span>&#34;name&#34;</span><span>: </span><span>&#34;create-email-job&#34;</span><span> }</span></span>
<span></span></code></pre>
<p>Tracing execution like this can get you surprisingly far! But we can do better.</p>
<p>Trace spans have 3 different IDs that make up the Trace Context. The first two are really simple:</p>
<ul>
<li><strong>Span ID</strong>: a random ID for each span</li>
<li><strong>Trace ID</strong>: a random ID that multiple spans can share</li>
</ul>
<p>The last one is a little more complicated:</p>
<ul>
<li><strong>Parent Span ID</strong>: the Span ID that was the active span when this span was created</li>
</ul>
<p>The Parent Span ID is what allows a system to create a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>
out of each trace once it has received each individual span. When rendered as a tree this results in
the waterfall view we all know and love, but it‚Äôs important to remember that this is only one possible
visualization of the data.</p>
<p><img src="https://jeremymorrell.dev/_astro/trace-example.CjGDJS25_1rbk53.webp" alt="A Honeycomb screenshot of a trace waterfall" width="1930" height="318" loading="lazy" decoding="async"/></p>
<h2 id="existing-in-the-context">Existing in the context</h2>
<p>Our context only really needs two values: the trace id, and the id of the current span. When
we create a new span, we can inherit the <code>spanID</code> if one exists, generate a new <code>spanID</code>,
and set the new context.</p>
<pre tabindex="0" data-language="js"><code><span><span>let</span><span> context </span><span>=</span><span> {</span></span>
<span><span>  traceID: </span><span>&#34;cfd3fd1ad40f008fea72e06901ff722b&#34;</span><span>,</span></span>
<span><span>  spanID: </span><span>&#34;6b65f0c5db08556d&#34;</span><span>,</span></span>
<span><span>};</span></span>
<span></span></code></pre>
<p>We need some way of passing this context around our application. We could do this manually:</p>
<pre tabindex="0" data-language="js"><code><span><span>let</span><span> { span, newContext } </span><span>=</span><span> new</span><span> Span</span><span>(</span><span>&#34;api-req&#34;</span><span>, oldContext);</span></span>
<span></span></code></pre>
<p>Indeed, this is <a href="https://github.com/open-telemetry/opentelemetry-go/blob/b37e8a9860f03b78baf2c3ca0edcbc6c7f8fd969/example/namedtracer/main.go#L65">how it is done in the official Go SDK</a> however in most languages
this is done implicitly and handled automatically by the library. In Ruby or Python you can use a thread
local variable, but in Node you would use <a href="https://nodejs.org/api/async_context.html#class-asynclocalstorage">AsyncLocalStorage</a>.</p>
<p>At this point it helps to wrap our span creation in a helper function:</p>
<pre tabindex="0" data-language="js"><code><span><span>import</span><span> { AsyncLocalStorage } </span><span>from</span><span> &#34;node:async_hooks&#34;</span><span>;</span></span>
<span></span>
<span><span>let</span><span> asyncLocalStorage </span><span>=</span><span> new</span><span> AsyncLocalStorage</span><span>();</span></span>
<span><span>// start with an empty context</span></span>
<span><span>asyncLocalStorage.</span><span>enterWith</span><span>({ traceID: </span><span>undefined</span><span>, spanID: </span><span>undefined</span><span> });</span></span>
<span></span>
<span><span>async</span><span> function</span><span> startSpan</span><span>(</span><span>name</span><span>, </span><span>lambda</span><span>) {</span></span>
<span><span>  let</span><span> ctx </span><span>=</span><span> asyncLocalStorage.</span><span>getStore</span><span>();</span></span>
<span><span>  let</span><span> span </span><span>=</span><span> new</span><span> Span</span><span>(name, ctx, </span><span>new</span><span> Map</span><span>());</span></span>
<span><span>  await</span><span> asyncLocalStorage.</span><span>run</span><span>(span.</span><span>getContext</span><span>(), lambda, span);</span></span>
<span><span>  span.</span><span>end</span><span>();</span></span>
<span><span>  console.</span><span>log</span><span>(span);</span></span>
<span><span>}</span></span>
<span></span>
<span><span>startSpan</span><span>(</span><span>&#34;parent&#34;</span><span>, </span><span>async</span><span> (</span><span>parentSpan</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>  parentSpan.</span><span>setAttributes</span><span>({ outerSpan: </span><span>true</span><span> });</span></span>
<span><span>  startSpan</span><span>(</span><span>&#34;child&#34;</span><span>, </span><span>async</span><span> (</span><span>childSpan</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>    childSpan.</span><span>setAttributes</span><span>({ outerSpan: </span><span>false</span><span> });</span></span>
<span><span>  });</span></span>
<span><span>});</span></span>
<span></span></code></pre>
<p>And with that we have the core of our tracing library done! üéâ</p>
<pre tabindex="0" data-language="js"><code><span><span>Span {</span></span>
<span><span>  startTime</span><span>: </span><span>1725850276756</span><span>,</span></span>
<span><span>  traceID</span><span>: </span><span>&#39;b8d002c2f6ae1291e0bd29c9791c9756&#39;</span><span>,</span></span>
<span><span>  parentSpanID</span><span>: </span><span>&#39;50f527cbf40230c3&#39;</span><span>,</span></span>
<span><span>  name</span><span>: </span><span>&#39;child&#39;</span><span>,</span></span>
<span><span>  attributes</span><span>: </span><span>Map</span><span>(</span><span>1</span><span>) { </span><span>&#39;outerSpan&#39;</span><span> =&gt;</span><span> false</span><span> },</span></span>
<span><span>  spanID</span><span>: </span><span>&#39;8037a93b6ed25c3a&#39;</span><span>,</span></span>
<span><span>  durationMs</span><span>: </span><span>11.087375000000002</span></span>
<span><span>}</span></span>
<span><span>Span {</span></span>
<span><span>  startTime</span><span>: </span><span>1725850276744</span><span>,</span></span>
<span><span>  traceID</span><span>: </span><span>&#39;b8d002c2f6ae1291e0bd29c9791c9756&#39;</span><span>,</span></span>
<span><span>  parentSpanID</span><span>: </span><span>undefined</span><span>,</span></span>
<span><span>  name</span><span>: </span><span>&#39;parent&#39;</span><span>,</span></span>
<span><span>  attributes</span><span>: </span><span>Map</span><span>(</span><span>1</span><span>) { </span><span>&#39;outerSpan&#39;</span><span> =&gt;</span><span> true</span><span> },</span></span>
<span><span>  spanID</span><span>: </span><span>&#39;50f527cbf40230c3&#39;</span><span>,</span></span>
<span><span>  durationMs</span><span>: </span><span>26.076625</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Our tracing library is perfectly usable even at <a href="https://github.com/jmorrell/minimal-nodejs-otel-tracer/blob/5ff45161aa2d6c0c6d0a41139803d54a2f88829d/simple_tracer.js">under 60 LoC</a>
but it has 2 big drawbacks:</p>
<ul>
<li>We have to manually add it everywhere</li>
<li>It also is restricted to a single system. We do not have a mechanism for passing the trace
context between any two systems in our larger service.</li>
</ul>
<p>Let‚Äôs fix that!</p>
<h2 id="going-distributed">Going distributed</h2>
<p>Distributed tracing sounds scary and intimidating, but it generally means that tracing
context can be passed around between systems so that you can track what operation kicked off
what other operation, and that all of this data gets reported to the same place at the end.</p>
<p>Whenever we make an HTTP call to another system, we need to pass along the Trace ID and the
Current Span ID. We could add these two fields to all of our HTTP payloads manually but
there‚Äôs a <a href="https://www.w3.org/TR/trace-context/">W3C standard</a> for how to encode this into
an HTTP header so that it gets sent as metadata for every request. The <code>traceparent</code> header
looks like:</p>
<pre tabindex="0" data-language="log"><code><span><span>00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01</span></span>
<span></span></code></pre>
<p>There is a full specification to digest and implement here, but for our purposes today we can ignore
most of this and think of it as conforming to this format:</p>
<pre tabindex="0" data-language="log"><code><span><span>00</span><span>-{ Trace ID}-{ Parent Span ID }-</span><span>01</span></span>
<span></span></code></pre>
<p>which allows us to parse and serialize our trace context with some simple functions:</p>
<pre tabindex="0" data-language="js"><code><span><span>let</span><span> getTraceParent</span><span> =</span><span> (</span><span>ctx</span><span>) </span><span>=&gt;</span><span> `00-${</span><span>ctx</span><span>.</span><span>traceID</span><span>}-${</span><span>ctx</span><span>.</span><span>spanID</span><span>}-01`</span><span>;</span></span>
<span></span>
<span><span>let</span><span> parseTraceParent</span><span> =</span><span> (</span><span>header</span><span>) </span><span>=&gt;</span><span> ({</span></span>
<span><span>  traceID: header.</span><span>split</span><span>(</span><span>&#34;-&#34;</span><span>)[</span><span>1</span><span>],</span></span>
<span><span>  spanID: header.</span><span>split</span><span>(</span><span>&#34;-&#34;</span><span>)[</span><span>2</span><span>],</span></span>
<span><span>});</span></span>
<span></span></code></pre>
<p>We need to be sure to add it to our outgoing requests, and parse it on any incoming requests.
Instrumentation helps with that.</p>
<h2 id="wrap-stuff-in-other-stuff">Wrap stuff in other stuff</h2>
<p><em>Instrumentation</em> is a fancy term for ‚Äúwrap some other code in our code so we can track stuff‚Äù. Real
tracing libraries sometimes go to extreme lengths to make wrapping built-in or popular libraries
happen behind the scenes when you configure the library. We‚Äôre not going to be doing that.</p>
<p>Instead we‚Äôll provide some <a href="https://hono.dev/docs/guides/middleware">middleware</a> for the
<a href="https://hono.dev/">Hono</a> web framework that the user can manually add.</p>
<pre tabindex="0" data-language="js"><code><span><span>async</span><span> function</span><span> honoMiddleware</span><span>(</span><span>c</span><span>, </span><span>next</span><span>) {</span></span>
<span><span>  // check the incoming request for the traceparent header</span></span>
<span><span>  // if it exists parse and inherit the trace context</span></span>
<span><span>  let</span><span> context </span><span>=</span><span> EMPTY_CONTEXT</span><span>;</span></span>
<span><span>  if</span><span> (c.req.</span><span>header</span><span>(</span><span>&#34;traceparent&#34;</span><span>)) {</span></span>
<span><span>    context </span><span>=</span><span> parseTraceParent</span><span>(c.req.</span><span>header</span><span>(</span><span>&#34;traceparent&#34;</span><span>));</span></span>
<span><span>  }</span></span>
<span></span>
<span><span>  // set the context and wrap the whole req / res operation in a span</span></span>
<span><span>  await</span><span> setContext</span><span>(context, </span><span>async</span><span> () </span><span>=&gt;</span><span> {</span></span>
<span><span>    await</span><span> startSpan</span><span>(</span><span>`${</span><span>c</span><span>.</span><span>req</span><span>.</span><span>method</span><span>} ${</span><span>c</span><span>.</span><span>req</span><span>.</span><span>path</span><span>}`</span><span>, </span><span>async</span><span> (</span><span>span</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      // Before we let our app handle the request, let&#39;s pull some info about</span></span>
<span><span>      // it off and add it to our trace.</span></span>
<span><span>      span.</span><span>setAttributes</span><span>({</span></span>
<span><span>        &#34;http.request.method&#34;</span><span>: c.req.method,</span></span>
<span><span>        &#34;http.request.path&#34;</span><span>: c.req.path,</span></span>
<span><span>      });</span></span>
<span></span>
<span><span>      // let our app handle the request</span></span>
<span><span>      await</span><span> next</span><span>();</span></span>
<span></span>
<span><span>      // Pull information about how our app responded</span></span>
<span><span>      span.</span><span>setAttributes</span><span>({</span></span>
<span><span>        &#34;http.response.status_code&#34;</span><span>: c.res.status,</span></span>
<span><span>      });</span></span>
<span><span>    });</span></span>
<span><span>  });</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>We also need to handle making outgoing HTTP calls and making sure we attach the <code>traceparent</code>
header. There is no built-in concept of middleware for the built-in <code>fetch</code> command, so instead
we‚Äôre going to wrap it like a javascript burrito. We‚Äôll have to do this ourselves, but it‚Äôs not
so bad, <a href="https://github.com/open-telemetry/opentelemetry-js/blob/9c30124e764e08bd6ccf8dbfbe426a8531c20352/experimental/packages/opentelemetry-instrumentation-fetch/src/fetch.ts#L304">especially compared to what doing it for real looks like</a>.</p>
<pre tabindex="0" data-language="js"><code><span><span>// pass the original function into our wrapping logic</span></span>
<span><span>function</span><span> patchFetch</span><span>(</span><span>originalFetch</span><span>) {</span></span>
<span><span>  // return a function with the same signature, but that executes our logic too</span></span>
<span><span>  return</span><span> async</span><span> function</span><span> patchedFetch</span><span>(</span><span>resource</span><span>, </span><span>options</span><span> =</span><span> {}) {</span></span>
<span><span>    // generate and add the traceparent header</span></span>
<span><span>    let</span><span> ctx </span><span>=</span><span> getContext</span><span>();</span></span>
<span></span>
<span><span>    if</span><span> (</span><span>!</span><span>options.headers) {</span></span>
<span><span>      options.headers </span><span>=</span><span> {};</span></span>
<span><span>    }</span></span>
<span><span>    options.headers[</span><span>&#34;traceparent&#34;</span><span>] </span><span>=</span><span> getTraceParent</span><span>(ctx);</span></span>
<span></span>
<span><span>    // run the underlying fetch function, but wrap it in a span and</span></span>
<span><span>    // pull out some info while we&#39;re at it</span></span>
<span><span>    let</span><span> resp;</span></span>
<span><span>    await</span><span> startSpan</span><span>(</span><span>&#34;fetch&#34;</span><span>, </span><span>async</span><span> (</span><span>span</span><span>) </span><span>=&gt;</span><span> {</span></span>
<span><span>      span.</span><span>setAttributes</span><span>({ </span><span>&#34;http.url&#34;</span><span>: resource });</span></span>
<span><span>      resp </span><span>=</span><span> await</span><span> originalFetch</span><span>(resource, options);</span></span>
<span><span>      span.</span><span>setAttributes</span><span>({ </span><span>&#34;http.response.status_code&#34;</span><span>: resp.status });</span></span>
<span><span>    });</span></span>
<span></span>
<span><span>    // pass along fetch&#39;s response. It&#39;s like we were never here</span></span>
<span><span>    return</span><span> resp;</span></span>
<span><span>  };</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p><a href="https://github.com/jmorrell/minimal-nodejs-otel-tracer/blob/5ff45161aa2d6c0c6d0a41139803d54a2f88829d/index.js">Here‚Äôs</a> a quick little app
to show off our tracer in action.</p>
<h2 id="lets-send-this-to-honeycomb">Let‚Äôs send this to Honeycomb</h2>
<p>We can log out our spans to the terminal, but that‚Äôs not a great user experience. Before we look
at OpenTelemetry, I think it‚Äôs instructive to look at <a href="https://docs.honeycomb.io/api/tag/Events#operation/createEvents">Honeycomb‚Äôs Event‚Äôs API</a>.
Before <a href="https://honeycomb.io/">Honeycomb</a> went all-in on OpenTelemetry they had a much simpler
just-send-us-JSON approach. They no longer recommend it, but we can still use this API today
for our toy project.</p>
<p>You can see the full exporter code <a href="https://github.com/jmorrell/minimal-nodejs-otel-tracer/blob/5ff45161aa2d6c0c6d0a41139803d54a2f88829d/honeycomb-exporter.js">here</a>,
but the logic for building the payload is the interesting bit:</p>
<pre tabindex="0" data-language="js"><code><span><span>// literally put all of the data together in one big json blob... like a log line!</span></span>
<span><span>// and then POST it to their API</span></span>
<span><span>function</span><span> spanToHoneycombJSON</span><span>(</span><span>span</span><span>) {</span></span>
<span><span>  return</span><span> {</span></span>
<span><span>    ...</span><span>Object.</span><span>fromEntries</span><span>(globalAttributes),</span></span>
<span><span>    ...</span><span>Object.</span><span>fromEntries</span><span>(span.attributes),</span></span>
<span><span>    name: span.name,</span></span>
<span><span>    trace_id: span.traceID,</span></span>
<span><span>    span_id: span.spanID,</span></span>
<span><span>    parent_span_id: span.parentSpanID,</span></span>
<span><span>    start_time: span.startTime,</span></span>
<span><span>    duration_ms: span.durationMs,</span></span>
<span><span>  };</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>Since we‚Äôre not using a standard format you do have to tell Honeycomb which field maps to Trace ID, Span ID,
etc in the dataset configuration, but this is all the data needed to build up the trace waterfall!</p>
<p><img src="https://jeremymorrell.dev/_astro/honeycomb-events-trace.DaOklNq9_1IiUjy.webp" alt="Honeycomb trace waterfall view" width="2490" height="1814" loading="lazy" decoding="async"/></p>
<h2 id="wheres-the-opentelemetry">Where‚Äôs the OpenTelemetry?</h2>
<p>So we have our <del>fancy logs</del> tracing set up, and instrumentation and context propagation
are actually pretty simple, but OpenTelemetry is a big, complicated standard! Have you
read through <a href="https://opentelemetry.io/docs/specs/otel/trace/sdk/">the specification</a>!?</p>
<p>And‚Ä¶ that‚Äôs not wrong. OpenTelemetry is a big project, however we only need one small
part of it for our purposes. When you install an OpenTelemetry SDK for your langauge
it emits data in the <a href="https://opentelemetry.io/docs/specs/otlp/">OpenTelemetry Protocol (OTLP)</a>.
Every OpenTelemetry SDK in every language emits OTLP. The <a href="https://github.com/open-telemetry/opentelemetry-collector">OpenTelemetry
Collector</a> is a collection of
tools for receiving OTLP, transforming OTLP, translating other formats to OTLP.
You could say OTLP is kind of a big deal.</p>
<p>OTLP has <a href="https://github.com/open-telemetry/opentelemetry-proto/blob/6f589125b0b7d708c9b0f32916378182ac1e123d/opentelemetry/proto/trace/v1/trace.proto#L86">its own protobuf specification</a>
so you can efficiently compress telemetry data into a binary message that will be the same
across any platform, OS, or CPU architecture. We could generate a JavaScript module to
parse and emit these protobuf messages from the <code>.proto</code> files, but that sounds like
too much work.</p>
<p>Protobuf also defines a <a href="https://opentelemetry.io/docs/specs/otlp/#json-protobuf-encoding">JSON mapping</a> as part
of the spec, and the specification repo has <a href="https://github.com/open-telemetry/opentelemetry-proto/blob/6f589125b0b7d708c9b0f32916378182ac1e123d/examples/trace.json">a handy example for us to start from</a>, so let‚Äôs keep it simple instead.</p>
<p>Generating this payload is a bit more complicated than Honeycomb‚Äôs old events format. There are some
new terms like ‚Äúresource‚Äù and ‚Äúscope‚Äù, and we have to massage the attributes a bit. However if you
squint, you can see that it‚Äôs all the same data. <a href="https://github.com/jmorrell/minimal-nodejs-otel-tracer/blob/5ff45161aa2d6c0c6d0a41139803d54a2f88829d/tracer.js#L107-L179">Full version here</a></p>
<pre tabindex="0" data-language="js"><code><span><span>function</span><span> spanToOTLP</span><span>(</span><span>span</span><span>) {</span></span>
<span><span>  return</span><span> {</span></span>
<span><span>    resourceSpans: [</span></span>
<span><span>      {</span></span>
<span><span>        resource: {</span></span>
<span><span>          attributes: </span><span>toAttributes</span><span>(Object.</span><span>fromEntries</span><span>(globalAttributes)),</span></span>
<span><span>        },</span></span>
<span><span>        scopeSpans: [</span></span>
<span><span>          {</span></span>
<span><span>            scope: {</span></span>
<span><span>              name: </span><span>&#34;minimal-tracer&#34;</span><span>,</span></span>
<span><span>              version: </span><span>&#34;0.0.1&#34;</span><span>,</span></span>
<span><span>              attributes: [],</span></span>
<span><span>            },</span></span>
<span><span>            spans: [</span></span>
<span><span>              {</span></span>
<span><span>                traceId: span.traceID,</span></span>
<span><span>                spanId: span.spanID,</span></span>
<span><span>                parentSpanId: span.parentSpanID,</span></span>
<span><span>                name: span.name,</span></span>
<span><span>                startTimeUnixNano: span.startTime </span><span>*</span><span> Math.</span><span>pow</span><span>(</span><span>10</span><span>, </span><span>6</span><span>),</span></span>
<span><span>                endTimeUnixNano:</span></span>
<span><span>                  (span.startTime </span><span>+</span><span> span.elapsedMs) </span><span>*</span><span> Math.</span><span>pow</span><span>(</span><span>10</span><span>, </span><span>6</span><span>),</span></span>
<span><span>                kind: </span><span>2</span><span>,</span></span>
<span><span>                attributes: </span><span>toAttributes</span><span>(Object.</span><span>fromEntries</span><span>(span.attributes)),</span></span>
<span><span>              },</span></span>
<span><span>            ],</span></span>
<span><span>          },</span></span>
<span><span>        ],</span></span>
<span><span>      },</span></span>
<span><span>    ],</span></span>
<span><span>  };</span></span>
<span><span>}</span></span>
<span></span></code></pre>
<p>However the power of standards means that we‚Äôre no longer limited to just one vendor. We can now send this to any service that accepts OpenTelemetry!</p>
<p><a href="https://honeycomb.io/">Honeycomb</a> still works, of course.</p>
<p><img src="https://jeremymorrell.dev/_astro/honeycomb-otel-trace.BKZRMlZy_2nl6Mq.webp" alt="A Honeycomb screenshot of a trace waterfall" width="2970" height="1412" loading="lazy" decoding="async"/></p>
<p><a href="https://baselime.io/">Baselime</a> too!</p>
<p><img src="https://jeremymorrell.dev/_astro/baselime-trace.BiwEmaJ5_1NBeYh.webp" alt="A Baselime screenshot of a trace waterfall" width="1752" height="700" loading="lazy" decoding="async"/></p>
<p>We can visualize our telemetry locally using <a href="https://github.com/CtrlSpice/otel-desktop-viewer">otel-desktop-viewer</a>!</p>
<p><img src="https://jeremymorrell.dev/_astro/otel-desktop-viewer-trace.BNYaiaaR_1h40fM.webp" alt="OTel desktop viewer trace waterfall" width="3000" height="1354" loading="lazy" decoding="async"/></p>
<p>We can even render our data in the terminal with <a href="https://github.com/ymtdzzz/otel-tui"><code>otel-tui</code></a></p>
<p><img src="https://jeremymorrell.dev/_astro/otel-tui-trace.BFXJsSO2_8cUDt.webp" alt="A trace rendered in the terminal" width="2426" height="1331" loading="lazy" decoding="async"/></p>
<h2 id="thats-it">That‚Äôs it!?</h2>
<p>That‚Äôs it! In <a href="https://github.com/jmorrell/minimal-nodejs-otel-tracer/blob/ad35d40e3255715b7fb69bcd367f66f1e5cd2a57/tracer.js">181 lines of code</a> we‚Äôve implemented tracing, trace context propagation, instrumentation, and exported it in a standard format that any vendor or tool should be able
to accept. Thanks to the magic of üåàstandardsüåà.</p>
<h2 id="is-this-you-know-legal">Is this‚Ä¶ you know‚Ä¶ legal?</h2>
<p>If you were paying attention, there are a lot of <a href="https://opentelemetry.io/docs/specs/otel/">OpenTelemetry specifications</a> around
how an OpenTelemetry SDK should be structured and behave. Our little library doesn‚Äôt do almost any of that. This is just for
learning but one could imagine a simplified non-compliant SDK such as <a href="https://github.com/evanderkoogh/otel-cf-workers">this one for Cloudflare
Workers</a>. It emits OTLP but doesn‚Äôt conform to all of the SDK specifications.
How should we think about this?</p>
<p>At the <a href="https://events.linuxfoundation.org/open-telemetry-community-day/">OTel Community Day</a> last June, OpenTelemetry cofounder
<a href="https://twitter.com/tedsuo">Ted Young</a> was asked a similar question. I wrote down his answer as best as I could. Lightly paraphrased:</p>
<blockquote>
<p>We don‚Äôt care about the spec. We care about that the black box participates in tracing and emits OTLP and semantic conventions. The true spec is the data.</p>
</blockquote>
<p>I take that to mean, while official SDKs are expected to follow the spec, it‚Äôs reasonable for other implementations
to deviate as long as an outside observer cannot tell the difference from the behavior. Our little library does‚Äôt quite
pass due to the shortcuts taken in parsing the <code>traceparent</code> header, but it would not take much more code to fix this.</p>
<p>If OpenTelemetry continues to be successful I expect OTLP, the ability to emit and receive it, will get built into everything:
your IDE tooling, the platform you deploy on, the framework on which you are building, even hardware. Some day your internet-connected
dryer will almost certainly speak OTLP, if it doesn‚Äôt already.</p>
<h2 id="hold-on-why-is-opentelemetry-js-so-much-bigger">Hold on‚Ä¶ why is <a href="https://github.com/open-telemetry/opentelemetry-js">opentelemetry-js</a> so much bigger?</h2>
<p>If we can build a functional tracer in under 200 lines, why does the official JavaScript SDK have so much more code?</p>
<p>It might help to go over a non-exhaustive list of things the offical SDK handles that our little learning library doesn‚Äôt:</p>
<ul>
<li>Buffer and batch outgoing telemetry data in a more efficient format. Don‚Äôt send one-span-per-http request in production. Your vendor will want to have words.</li>
<li><a href="https://github.com/open-telemetry/opentelemetry-js?tab=readme-ov-file#supported-runtimes">Work in both the browser and in Node environments</a></li>
<li>Gracefully handle errors, wrap this library around your core functionality at your own peril</li>
<li>Be incredibly configurable. Need to do something that isn‚Äôt bog standard? You can probably make it happen</li>
<li>Automagically wrap common libraries in robust, battle-tested instrumentation</li>
<li>Optimized for performance when used in your code‚Äôs tight loops</li>
<li>Conform to <a href="https://opentelemetry.io/docs/concepts/semantic-conventions/">semantic conventions</a></li>
<li>Support two whole other types of telemetry: metrics and logging</li>
</ul>
<p>And more! I hope this post has given you a better mental model for the work happening under all of the production hardening and
extensibility that tends to build up on these libraries when they have to be used in the real world. A library that can reliably
work across most places we deploy JavaScript and meet a very broad range of user needs is highly non-trivial.</p>
<p>But tracing? We know that‚Äôs just ‚ú®fancy logging‚ú® right?</p>
<p>All code for this post can be found <a href="https://github.com/jmorrell/minimal-nodejs-otel-tracer">at <code>jmorrell/minimal-nodejs-otel-tracer</code> on Github</a>.</p>
<hr/>
<p><a href="#footnote-ref-1" id="footnote-1"><code>[1]</code></a> Count the concepts in this <a href="https://github.com/open-telemetry/opentelemetry-js/blob/9c30124e764e08bd6ccf8dbfbe426a8531c20352/examples/basic-tracer-node/index.js">simple example</a></p>
<ol>
<li><code>Tracer</code></li>
<li><code>TracerProvider</code></li>
<li><code>SpanExporter</code></li>
<li><code>SpanProcessor</code></li>
<li><code>Resource</code></li>
<li><code>Attribute</code></li>
<li><code>Event</code></li>
<li><code>Span</code></li>
<li><code>Context</code></li>
<li>Both an API <strong>and</strong> and SDK</li>
<li>Semantic Conventions</li>
</ol>
<p>This is intimidating to even senior developers. OpenTelemetry knows this learning curve is a problem and has spun up <a href="https://github.com/open-telemetry/community/blob/ed572bd319edf1092e8e21808307f2eb0424a631/projects/developer_experience.md">a new SIG</a>
to work on improving the developer experience.</p> </article></div>
  </body>
</html>
