<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/">Original</a>
    <h1>Reverse Engineering the Prom for the SGI O2</h1>
    
    <div id="readability-page-1" class="page"><article>
    <h2>Reverse Engineering the PROM for the SGI O2</h2>
  <p>Since the early 2000s, the potential for upgrading the CPU in the <a href="https://en.wikipedia.org/wiki/SGI_O2">Silicon Graphics O2</a> with a 900 MHz RM7900 has been blocked by the inability to modify the PROM firmware. To that end, I built <a href="https://github.com/mattst88/ip32prom-decompiler">ip32prom-decompiler</a>, a program that decompiles the PROM into sources that can be reassembled into a bit-identical image. The decompiler goes to great lengths to produce assembly that is understandable and modifiable by replacing known constants, recognizing and replacing memory addresses with labels, inserting comments and function descriptions, marking function bounds, and many other niceties. In this article I&#39;ll describe the process of reverse engineering the structure and contents of the PROM so that I could build the decompiler.</p>
  <h2 id="background">Background</h2>
  <p>The Silicon Graphics O2 is a Unix workstation with a MIPS CPU.</p>
  <p>There are two families of CPUs available for the O2:</p>
  <ul>
    <li>in-order <a href="https://en.wikipedia.org/wiki/R5000">R5000</a> / RM7000 CPUs, from 180-350 MHz
    </li>
    <li>out-of-order <a href="https://en.wikipedia.org/wiki/R10000">R10000</a> / <a href="https://en.wikipedia.org/wiki/R12000">R12000</a> CPUs, from 150-400 MHz
    </li>
  </ul>
  <p>In the early 2000s, members of the Nekochan community replaced the 300 MHz RM5200 and 350 MHz RM7000A CPUs with a faster 600 MHz RM7000C model. The 600 MHz CPU, though in-order, is faster than the out-of-order 400 MHz R12000 CPU in most cases.</p>
  <p>This modification is documented by <a href="http://www.sgidepot.co.uk/">SGI Depot</a> in the article <a href="http://www.sgidepot.co.uk/o2cpumod.html">Upgrading an O2 to 600MHz (and beyond!)</a>. While replacing a BGA-mounted CPU takes significant tooling and expertise, the modification does not require any firmware or software changes.</p>
  <h2 id="the-problem">The Problem</h2>
  <p>As the title (&#34;Upgrading an O2 to 600MHz (and beyond!)&#34;) of the article might suggest, there were hopes of further upgrades. The article notes</p>
  <blockquote>
    <p>Meanwhile, Joe unfortunately did not have any success with the PMC 866Mhz CPU - apparently it is not quite as compatible with R5200 as PMC thought. Meanwhile, any ideas about a 900 are somewhat hampered by the need to have a distinctly modified IP32 PROM image, which would need some assistance from SGI. Who knows if they would be willing to help; one can but ask!</p>
    <p>Watch this space!!</p>
  </blockquote>
  <p>The 900 MHz CPU referred to is the RM7900 from PMC-Sierra. The RM7900 uses a newer E9000 CPU core but in a 304-pin BGA package compatible with earlier RM7000 CPUs. It is not clear to me what the 866 MHz CPU is — I can find no evidence of an 866 MHz MIPS CPU, RM7000 or otherwise.</p>
  <p>Presumably any attempts to use an RM7900 failed without support in the O2&#39;s PROM firmware.</p>
  <p>At the time, Silicon Graphics still existed and there remained some faint hope for access to the source code of the PROM — the boot firmware — but today Silicon Graphics is long gone and with it the source code for the PROM. (as well as any concerns about legal issues from reverse engineering!)</p>
  <h2 id="the-partial-solution">The (partial) Solution</h2>
  <p>I reverse engineered the PROM firmware and wrote a program to decompile it into modifiable assembly (<code>.S</code>) files. The assembly files can be reassembled into a bit-identical PROM image, thus verifying that the decompilation was accurate.</p>
  <p>With the PROM firmware now decompiled into modifiable assembly, the &#34;distinctly modified IP32 PROM image&#34; needed for RM7900 support is possible — no assistance from SGI required.</p>
  <h3 id="external-annotations">External Annotations</h3>
  <p>The assembly files are made more comprehensible with various annotations and other improvements to readability.</p>
  <table>
    <thead>
      <tr>
        <th>Filename</th>
        <th>Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://github.com/mattst88/ip32prom-decompiler/blob/main/annotations/labels.json">labels.json</a></td>
        <td>Named addresses for branch targets and data</td>
      </tr>
      <tr>
        <td><a href="https://github.com/mattst88/ip32prom-decompiler/blob/main/annotations/comments.json">comments.json</a></td>
        <td>Per-instruction documentation</td>
      </tr>
      <tr>
        <td><a href="https://github.com/mattst88/ip32prom-decompiler/blob/main/annotations/functions.json">functions.json</a></td>
        <td>Function boundaries and descriptions</td>
      </tr>
      <tr>
        <td><a href="https://github.com/mattst88/ip32prom-decompiler/blob/main/annotations/operands.json">operands.json</a></td>
        <td>Instruction operand replacements</td>
      </tr>
      <tr>
        <td><a href="https://github.com/mattst88/ip32prom-decompiler/blob/main/annotations/relocations.json">relocations.json</a></td>
        <td>Code that executes at different addresses than stored</td>
      </tr>
      <tr>
        <td><a href="https://github.com/mattst88/ip32prom-decompiler/blob/main/annotations/bss.json">bss.json</a></td>
        <td>Named BSS (uninitialized data) symbols</td>
      </tr>
    </tbody>
  </table>
  <p>The resulting assembly:</p>
  <table>
    <tbody><tr>
      <th>Without improvements</th>
      <th>With improvements</th>
    </tr>
    <tr>
      <td>
        <pre><code>



L_0xbfc019b0:
    lui     $t1, 0xbfc0
    lui     $t0, 0xa000
    addiu   $t1, $t1, 0x19c8
    or      $t0, $t0, $t1
    jr      $t0
    nop



L_0xbfc019c8:
    mtc0    $zero, 5
    mtc0    $zero, 29
    addiu   $t1, $zero, 0x23
    nop
    mfc0    $t0, $t7
    andi    $t0, $t0, 0xff00
    srl     $t0, $t0, 8
    beq     $t0, $t1, 0xbfc01ae4
    nop
    addiu   $t1, $zero, 0x28
    beq     $t0, $t1, 0xbfc01ae4
    nop
    addiu   $t1, $zero, 0x27
    bne     $t0, $t1, 0xbfc01bbc
    nop
    addiu   $t0, $zero, 0x2f
    lui     $t1, 0x1000
L_0xbfc01a0c:
    addiu   $at, $zero, 0x1fff
    not     $t2, $at
    and     $t2, $t2, $t1
    lui     $at, 0x8000
    mtc0    $t0, 0
    or      $t2, $t2, $at
    mtc0    $t2, 10
    srl     $at, $t1, 0xc
    sll     $at, $at, 6
    ori     $at, $at, 0x11
    mtc0    $at, 2
    addiu   $t2, $at, 0x40
    mtc0    $at, 3
    addi    $t0, $t0, -1
    addiu   $t1, $t1, -0x2000
    bgtz    $t0, 0xbfc01a0c
    tlbwi
    mfc0    $t0, $s0
    addiu   $at, $zero, -0x1001
    and     $t0, $t0, $at
    addiu   $at, $zero, -9
    and     $t0, $t0, $at
    mtc0    $t0, 16
    mfc0    $t0, $s0
    srl     $t0, $t0, 9
    addiu   $t1, $zero, 0x1000
    andi    $t0, $t0, 7
    sllv    $t0, $t1, $t0
    addi    $t0, $t0, -0x20
    lui     $t1, 0x8000
    addu    $t2, $t0, $t1
L_0xbfc01a88:
    cache   0, ($t2)
    addi    $t0, $t0, -0x20
    bgez    $t0, 0xbfc01a88
    addu    $t2, $t0, $t1
    mfc0    $t0, $s0
    srl     $t0, $t0, 6
    addiu   $t1, $zero, 0x1000
    andi    $t0, $t0, 7
    sllv    $t0, $t1, $t0
    addi    $t0, $t0, -0x20
    lui     $t1, 0x8000
    lui     $at, 0x1000
L_0xbfc01ab8:
    addu    $at, $at, $t0
    srl     $at, $at, 0xc
    sll     $at, $at, 8
    mtc0    $at, 29
    addu    $t2, $t0, $t1
    addi    $t0, $t0, -0x20
    cache   9, ($t2)
    bgez    $t0, 0xbfc01ab8
    lui     $at, 0x1000
    jr      $ra
    nop
[...]</code></pre>
      </td>
      <td>
        <pre><code>/* Function tlb_init_uncached_trampoline [0xbfc019b0 - 0xbfc019c8)
 *
 * Jump to tlb_init through uncached KSEG1
 */
tlb_init_uncached_trampoline: /* 0xbfc019b0 */
    lui     $t1, %hi(tlb_init)
    lui     $t0, HI(KSEG1)
    addiu   $t1, $t1, %lo(tlb_init)
    or      $t0, $t0, $t1
    jr      $t0     # Jump to (KSEG1 | tlb_init)
     nop

/* Function tlb_init [0xbfc019c8 - 0xbfc01d98)
 */
tlb_init: /* 0xbfc019c8 */
    mtc0    $zero, $CP0_PAGEMASK
    mtc0    $zero, $CP0_TAGHI
    li      $t1, PRID_IMP_R5000
    nop
    mfc0    $t0, $CP0_PRID
    andi    $t0, $t0, PRID_IMP_MASK
    srl     $t0, $t0, PRID_IMP_SHIFT
    beq     $t0, $t1, tlb_r5k_init
     nop
    li      $t1, PRID_IMP_NEVADA
    beq     $t0, $t1, tlb_r5k_init
     nop
    li      $t1, PRID_IMP_RM7000
    bne     $t0, $t1, tlb_r10k_init
     nop
    li      $t0, RM7000_NUM_TLB_ENTRIES-1
    lui     $t1, HI(0x0fffe000)
tlb_rm7k_write_tlb_loop: /* 0xbfc01a0c */
    li      $at, PAGE_OFFSET_MASK
    not     $t2, $at
    and     $t2, $t2, $t1
    lui     $at, HI(KSEG0)
    mtc0    $t0, $CP0_INDEX
    or      $t2, $t2, $at
    mtc0    $t2, $CP0_ENTRYHI
    srl     $at, $t1, PAGE_SHIFT
    sll     $at, $at, ENTRYLO_PFN_SHIFT
    ori     $at, $at, (ENTRYLO_G|ENTRYLO_C_UNCACHED)
    mtc0    $at, $CP0_ENTRYLO0
    addiu   $t2, $at, 1 &lt;&lt; ENTRYLO_PFN_SHIFT
    mtc0    $at, $CP0_ENTRYLO1
    addi    $t0, $t0, -1
    addiu   $t1, $t1, LO(0x0fffe000)
    bgtz    $t0, tlb_rm7k_write_tlb_loop
     tlbwi
    mfc0    $t0, $CP0_CONFIG
    li      $at, ~RM7K_CONF_TE
    and     $t0, $t0, $at
    li      $at, ~CONF_CU
    and     $t0, $t0, $at
    mtc0    $t0, $CP0_CONFIG
    mfc0    $t0, $CP0_CONFIG
    srl     $t0, $t0, CONF_IC_SHIFT
    li      $t1, 0x1000
    andi    $t0, $t0, CONF_CACHE_SIZE_MASK
    sllv    $t0, $t1, $t0
    addi    $t0, $t0, -CACHE_LINE_SIZE
    lui     $t1, HI(KSEG0)
    addu    $t2, $t0, $t1
tlb_rm7k_inv_l1i_loop: /* 0xbfc01a88 */
    cache   (CACHE_TYPE_L1I|INDEX_WRITEBACK_INV), 0($t2)
    addi    $t0, $t0, -CACHE_LINE_SIZE
    bgez    $t0, tlb_rm7k_inv_l1i_loop
     addu   $t2, $t0, $t1
    mfc0    $t0, $CP0_CONFIG
    srl     $t0, $t0, CONF_DC_SHIFT
    li      $t1, 0x1000
    andi    $t0, $t0, CONF_CACHE_SIZE_MASK
    sllv    $t0, $t1, $t0
    addi    $t0, $t0, -CACHE_LINE_SIZE
    lui     $t1, HI(KSEG0)
    lui     $at, 0x1000
tlb_rm7k_inv_l1d_loop: /* 0xbfc01ab8 */
    addu    $at, $at, $t0
    srl     $at, $at, PAGE_SHIFT
    sll     $at, $at, RM7K_TAGHI_PTAG_SHIFT
    mtc0    $at, $CP0_TAGHI
    addu    $t2, $t0, $t1
    addi    $t0, $t0, -CACHE_LINE_SIZE
    cache   (CACHE_TYPE_L1D|INDEX_STORE_TAG), 0($t2)
    bgez    $t0, tlb_rm7k_inv_l1d_loop
     lui    $at, 0x1000
    jr      $ra
     nop
[...]</code></pre>
      </td>
    </tr>
  </tbody></table>
  <h2 id="reverse-engineering-the-ip32-prom">Reverse engineering the IP32 PROM</h2>
  <p>When I began this process, I knew only a tiny bit about firmware or the MIPS instruction set. I knew even less about the initialization process for MIPS CPUs.</p>
  <h3 id="first-steps">First steps</h3>
  <p>A <a href="https://marc.info/?t=109461690400001&amp;r=1&amp;w=2">mailing list post</a> in 2004 about the topic dissuaded others from reverse engineering the IP32 PROM due to the difficulty.</p>
  <blockquote>
    <p>Modifying the binary is most assuredly way more difficult than gaining access to ip32PROM source and modifying it directly (and solving license issues). The level of change to the binary needed to make the ip32PROM detect a new CPU would require extremely detailed knowledge of the binary format the ip32PROM is in, SGI O2 systems, and how the PROM even functions. I&#39;d wager a guess that a super-skilled SGI engineer might possibly pull this off, given enough caffeine.</p>
  </blockquote>
  <p>I read this and wondered, how difficult could it actually be? It didn&#39;t seem like firmware from 1996 would be terribly complex.</p>
  <p>I found a 512 KiB binary dump of the last version of the O2&#39;s PROM:</p>
  <pre><code>$ md5sum ip32prom.rev4.18.bin
c9725e036052cf1f3e6258eb9bc687fa  ip32prom.rev4.18.bin</code></pre>
  <p>And disassembled it:</p>
  <pre><code>$ mips64-unknown-linux-gnu-objdump -D -b binary -m mips -EB ip32prom.rev4.18.bin | head

ip32prom.rev4.18.bin:     file format binary


Disassembly of section .data:

00000000 &lt;.data&gt;:
       0:       10000011        b       0x48
       4:       00000000        nop
       8:       53484452        beql    k0,t0,0x11154</code></pre>
  <p>The first two instructions looked legitimate, but the third looked unlikely to be a real instruction.</p>
  <p>Further inspection of the disassembly indicated that there were real functions:</p>
  <pre><code>[...]
    152c:       03e00008        jr      ra
    1530:       00000000        nop
    1534:       90820000        lbu     v0,0(a0)
    1538:       00001825        move    v1,zero
    153c:       24840001        addiu   a0,a0,1
    1540:       10400006        beqz    v0,0x155c
    1544:       00000000        nop
    1548:       90820000        lbu     v0,0(a0)
    154c:       24840001        addiu   a0,a0,1
    1550:       24630001        addiu   v1,v1,1
    1554:       5440fffd        bnezl   v0,0x154c
    1558:       90820000        lbu     v0,0(a0)
    155c:       03e00008        jr      ra
    1560:       00601025        move    v0,v1
[...]</code></pre>
  <p>The <code>jr</code> and <code>nop</code> at <code>152c</code> and <code>1530</code> end a function, and the <code>lbu</code> at <code>1534</code> starts a new function by loading from the <code>a0</code> (argument 0) register. The <code>jr</code> and <code>move</code> at <code>155c</code> and <code>1560</code> return from the function and copy a value into <code>v0</code> which holds the return value. (This function is <code>strlen</code>).</p>
  <p><code>strings</code> showed meaningful data as well:</p>
  <pre><code>$ strings ip32prom.rev4.18.bin | head -n2
SHDR
sloader</code></pre>
  <p>I recognized that the first string (&#34;SHDR&#34;) matched the odd looking instruction from the initial disassembly:</p>
  <pre><code>       8:       53484452        beql    k0,t0,0x11154</code></pre>
  <p><code>0x53484452</code> is &#34;SHDR&#34;.</p>
  <h3 id="shdr">SHDR</h3>
  <p>Could this stand for section/segment header? What info was contained in the header?</p>
  <pre><code>       0:   10000011    b   0x48
       4:   00000000    nop
       8:   53484452    # &#34;SHDR&#34;
       c:   00004000    # unknown data
      10:   07030100    # unknown data
      14:   736c6f61    # unknown data
      18:   64657200    # unknown data
      1c:   00000000    # unknown data
      20:   00000000    # unknown data
      24:   00000000    # unknown data
      28:   00000000    # unknown data
      2c:   00000000    # unknown data
      30:   00000000    # unknown data
      34:   312e3000    # unknown data
      38:   00000000    # unknown data
      3c:   8cb4693c    # unknown data
      40:   00000000    # unknown data
      44:   00000000    # unknown data
      48:   100000d7    b   0x3a8
      4c:   00000000    nop
[...]
     3a8:   401a6000    mfc0    k0,$12
     3ac:   001ad402    srl     k0,k0,0x10
     3b0:   335a0018    andi    k0,k0,0x18
     3b4:   235affe8    addi    k0,k0,-24
[...]</code></pre>
  <h4 id="shdr-size">SHDR size</h4>
  <p>The header appeared to be bounded by a branch+delay slot in [0x00, 0x08) and [0x48, 0x50). These two chained branches lead to valid-looking code at <code>0x3a8</code>.</p>
  <p>That meant that the SHDR size was 72 bytes (including 8 bytes for the branch and delay slot before the &#34;SHDR&#34; <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic number</a>).</p>
  <h4 id="strings">Strings</h4>
  <p>Interpreting the unknown data as ASCII found some additional strings:</p>
  <ul>
    <li><code>736c6f61646572</code> is <code>&#34;sloader&#34;</code>. It&#39;s followed by 25 zero bytes (null terminator included), so this could be the name of the section in a 32-byte field.</li>
    <li><code>312e30</code> is <code>&#34;1.0&#34;</code>. It&#39;s followed by 5 zero bytes (null terminator included), so this could be the version of the section in an 8-byte field.</li>
  </ul>
  <p>That left bytes [0x0c, 0x14), [0x3c, 0x48) unknown.</p>
  <p>The four bytes in [0x0c, 0x10) looked like they might be a single element, but I didn&#39;t know what <code>0x00004000</code> (16384) was.</p>
  <p>The four bytes in [0x10, 0x14) were <code>7310</code>. The length of the string <code>&#34;sloader&#34;</code> is <code>7</code>, and the length of the string <code>&#34;1.0&#34;</code> is <code>3</code>. These were probably the string lengths of the name and version fields. I didn&#39;t know what the <code>1</code> or <code>0</code> bytes meant.</p>
  <p>I had no idea what the data in [0x3c, 0x48) was.</p>
  <p>I found that there were 5 instances of &#34;SHDR&#34; in the binary dump. The table contains the name and version in each header and their lengths (which matched the actual strings!).</p>
  <table>
    <thead>
      <tr>
        <th>Offset</th>
        <th>Name</th>
        <th>Name Len</th>
        <th>Version</th>
        <th>Version Len</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>0x00000000</code></td>
        <td>sloader</td>
        <td>7</td>
        <td>1.0</td>
        <td>3</td>
      </tr>
      <tr>
        <td><code>0x00004000</code></td>
        <td>env</td>
        <td>3</td>
        <td>1.0</td>
        <td>3</td>
      </tr>
      <tr>
        <td><code>0x00004400</code></td>
        <td>post1</td>
        <td>5</td>
        <td>1.0</td>
        <td>3</td>
      </tr>
      <tr>
        <td><code>0x00009200</code></td>
        <td>firmware</td>
        <td>8</td>
        <td>4.18</td>
        <td>4</td>
      </tr>
      <tr>
        <td><code>0x00069200</code></td>
        <td>version</td>
        <td>7</td>
        <td>4.18</td>
        <td>4</td>
      </tr>
    </tbody>
  </table>
  <h4 id="section-length">Section length</h4>
  <p>I recognized that the <code>env</code> section started at <code>0x00004000</code> — the same as the unknown [0x0c, 0x10) bytes in the <code>sloader</code> header. Was it the offset of the next SHDR? Or maybe the length of the current section?</p>
  <p>Adding the unknown value to the offset of the current SHDR:</p>
  <table>
    <thead>
      <tr>
        <th>Offset</th>
        <th>Section</th>
        <th>[0x0c, 0x10)</th>
        <th>Offset + unknown</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>0x00000000</code></td>
        <td>sloader</td>
        <td><code>0x00004000</code></td>
        <td><code>0x00004000</code></td>
      </tr>
      <tr>
        <td><code>0x00004000</code></td>
        <td>env</td>
        <td><code>0x00000400</code></td>
        <td><code>0x00004400</code></td>
      </tr>
      <tr>
        <td><code>0x00004400</code></td>
        <td>post1</td>
        <td><code>0x00004d44</code></td>
        <td><code>0x00009144</code></td>
      </tr>
      <tr>
        <td><code>0x00009200</code></td>
        <td>firmware</td>
        <td><code>0x0005fffc</code></td>
        <td><code>0x000691fc</code></td>
      </tr>
      <tr>
        <td><code>0x00069200</code></td>
        <td>version</td>
        <td><code>0x00000388</code></td>
        <td><code>0x00069588</code></td>
      </tr>
    </tbody>
  </table>
  <p>These unknown values looked to be the length of the current section, but maybe needed to be rounded up to the next <code>0x100</code>?</p>
  <h4 id="checksum">Checksum</h4>
  <p>During this part of the investigation, I noticed that at the end of each section there was a bogus instruction, often preceded by a lot of zeros that looked to be padding.</p>
  <pre><code>[start of &#34;sloader&#34; section]
       0:   10000011    b   0x48
       4:   00000000    nop
       8:   53484452    # &#34;SHDR&#34; for sloader
[...]
[a lot of zeros — padding]
    3ffc:   15d0fa4f    bne t6,s0,0x293c        # Bogus instruction
[end of &#34;sloader&#34; section]

[start of &#34;env&#34; section]
    4000:   00000000    nop
    4004:   00000000    nop
    4008:   53484452    # &#34;SHDR&#34; for env
[...]
    43fc:   eba16bb0    swc2    $1,27568(sp)    # Bogus instruction
[end of &#34;env&#34; section]

[start of &#34;post1&#34; section]
    4400:   10000011    b   0x4448
    4404:   00000000    nop
    4408:   53484452    # &#34;SHDR&#34; for post1
[...]
    9140:   6c91c641    ldr s1,-14783(a0)       # Bogus instruction
[end of &#34;post1&#34; section]
    9144:   00000000    nop
[a lot of zeros — padding]

[start of &#34;firmware&#34; section]
    9200:   10000011    b   0x9248
    9204:   00000000    nop
    9208:   53484452    # &#34;SHDR&#34; for firmware
[...]
   691f8:   d1c38847    lld v1,-30649(t6)       # Bogus instruction
[end of &#34;firmware&#34; section]
   691fc:   00000000    nop

[start of &#34;version&#34; section]
   69200:   7f454c46    .word   0x7f454c46 # WTF?
   69204:   01020100    .word   0x1020100  # WTF?
   69208:   53484452    # &#34;SHDR&#34; for version
[...]
[a lot of zeros — padding]
   69584:   108fedea    beq a0,t7,0x64d30       # Bogus instruction
[end of &#34;version&#34; section]
   69588:   00000000    nop
[a lot of zeros — padding]
   69600:
[a lot of ones — padding]</code></pre>
  <p>Those bogus instructions each end at the offset calculated by the SHDR start + the section length. They end the section. Could they be checksums for the section? If they&#39;re checksums, how are they calculated?</p>
  <table>
    <thead>
      <tr>
        <th>Section</th>
        <th>Checksum</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>sloader</td>
        <td><code>0x15d0fa4f</code></td>
      </tr>
      <tr>
        <td>env</td>
        <td><code>0xeba16bb0</code></td>
      </tr>
      <tr>
        <td>post1</td>
        <td><code>0x6c91c641</code></td>
      </tr>
      <tr>
        <td>firmware</td>
        <td><code>0xd1c38847</code></td>
      </tr>
      <tr>
        <td>version</td>
        <td><code>0x108fedea</code></td>
      </tr>
    </tbody>
  </table>
  <h4 id="shdr-checksum">SHDR checksum</h4>
  <p>The SHDRs had some weird looking numbers towards the ends as well. Might they be checksums as well?</p>
  <table>
    <thead>
      <tr>
        <th>Section</th>
        <th>SHDR checksum</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>sloader</td>
        <td><code>0x8cb4693c</code></td>
      </tr>
      <tr>
        <td>env</td>
        <td><code>0x131811ae</code></td>
      </tr>
      <tr>
        <td>post1</td>
        <td><code>0xc516c9e5</code></td>
      </tr>
      <tr>
        <td>firmware</td>
        <td><code>0x82b4a297</code></td>
      </tr>
      <tr>
        <td>version</td>
        <td><code>0x012d56b7</code></td>
      </tr>
    </tbody>
  </table>
  <h4 id="section-type">Section type</h4>
  <p>The remaining unknown bytes in the SHDRs were [0x12, 0x14), [0x40, 0x48). Their values for each SHDR are:</p>
  <table>
    <thead>
      <tr>
        <th>Section</th>
        <th>0x12</th>
        <th>0x13</th>
        <th>[0x40, 0x44)</th>
        <th>[0x44, 0x48)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>sloader</td>
        <td>1</td>
        <td>0</td>
        <td><code>0x00000000</code></td>
        <td><code>0x00000000</code></td>
      </tr>
      <tr>
        <td>env</td>
        <td>0</td>
        <td>0</td>
        <td><code>0x4175746f</code></td>
        <td><code>0x4c6f6164</code></td>
      </tr>
      <tr>
        <td>post1</td>
        <td>1</td>
        <td>0</td>
        <td><code>0x00000000</code></td>
        <td><code>0x00000000</code></td>
      </tr>
      <tr>
        <td>firmware</td>
        <td>3</td>
        <td>0</td>
        <td><code>0x81000000</code></td>
        <td><code>0x00048e70</code></td>
      </tr>
      <tr>
        <td>version</td>
        <td>0</td>
        <td>8</td>
        <td><code>0x00000000</code></td>
        <td><code>0x00000000</code></td>
      </tr>
    </tbody>
  </table>
  <p>From the names and small sizes of <code>env</code> and <code>version</code> I guessed that they did not contain code. <code>sloader</code>, <code>post1</code>, and <code>firmware</code> definitely did include code, and their SHDRs&#39; initial instructions branched over their SHDRs to more code.</p>
  <table>
    <thead>
      <tr>
        <th>Section</th>
        <th>Entry instructions</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>sloader</td>
        <td>branch over SHDR</td>
      </tr>
      <tr>
        <td>env</td>
        <td>nop</td>
      </tr>
      <tr>
        <td>post1</td>
        <td>branch over SHDR</td>
      </tr>
      <tr>
        <td>firmware</td>
        <td>branch over SHDR</td>
      </tr>
      <tr>
        <td>version</td>
        <td>
          unknown<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>
        </td>
      </tr>
    </tbody>
  </table>
  <p><code>strings</code> confirmed that <code>env</code> and <code>version</code> were almost entirely ASCII data. In fact, <code>0x4175746f</code> / <code>0x4c6f6164</code> are ASCII for <code>Auto</code> / <code>Load</code>.</p>
  <p>I suspected that the value in byte <code>0x12</code> was the section type, with the lowest bit indicating whether the section was code (<code>1</code>) or data (<code>0</code>).</p>
  <p>The <code>sloader</code>, <code>post1</code>, and <code>firmware</code> sections began with branch instructions that jump over the SHDR. The <code>env</code> section began with two <code>nop</code> instructions. The <code>version</code> section began with data that I only came to understand much later.</p>
  <p>The byte at <code>0x13</code> is <code>0</code> in all SHDRs other than <code>version</code>. This is padding to a 4-byte boundary.</p>
  <h4 id="trailing-8-bytes">Trailing 8 bytes</h4>
  <p>I didn&#39;t figure out what the trailing 8 bytes were until much later in the process, but here&#39;s what I did know at this point.</p>
  <ul>
    <li><code>env</code> didn&#39;t seem to have these bytes — as stated before the bytes immediately following <code>env</code>&#39;s SHDR are actual data that fit with the rest of the data in the section.</li>
    <li><code>version</code> contained zeros for these bytes, but the next 12 bytes were as well so it wasn&#39;t certain whether they were metadata or actual data.</li>
    <li><code>sloader</code> and <code>post1</code> contained zeros in these bytes, but their initial branch instructions jumped just past these fields. It seemed pretty clear that they were some metadata.</li>
    <li><code>firmware</code> was the only one that seemed to clearly contain some meaningful metadata here (<code>0x81000000</code> / <code>0x00048e70</code>). Like <code>sloader</code> and <code>post1</code>, the initial branch instruction jumped just past these fields.</li>
  </ul>
  <p>These findings seemed to correlate with the values in byte <code>0x12</code>.</p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>0x12</th>
        <th>[0x40, 0x44)</th>
        <th>[0x44, 0x48)</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>sloader</td>
        <td>1</td>
        <td><code>0x00000000</code></td>
        <td><code>0x00000000</code></td>
      </tr>
      <tr>
        <td>env</td>
        <td>0</td>
        <td>N/A</td>
        <td>N/A</td>
      </tr>
      <tr>
        <td>post1</td>
        <td>1</td>
        <td><code>0x00000000</code></td>
        <td><code>0x00000000</code></td>
      </tr>
      <tr>
        <td>firmware</td>
        <td>3</td>
        <td><code>0x81000000</code></td>
        <td><code>0x00048e70</code></td>
      </tr>
      <tr>
        <td>version</td>
        <td>0</td>
        <td>N/A</td>
        <td>N/A</td>
      </tr>
    </tbody>
  </table>
  <p>It seemed that if the lowest bit in byte <code>0x12</code> was set that the 8 bytes would be present, and the second bit indicated something about the metadata?</p>
  <h4 id="summary">Summary</h4>
  <table>
    <thead>
      <tr>
        <th>Bytes</th>
        <th>Field</th>
        <th>sloader</th>
        <th>env</th>
        <th>post1</th>
        <th>firmware</th>
        <th>version</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>[0x00-0x08)</td>
        <td>Entry instructions</td>
        <td>branch over SHDR</td>
        <td>nop</td>
        <td>branch over SHDR</td>
        <td>branch over SHDR</td>
        <td>
          unknown<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>
        </td>
      </tr>
      <tr>
        <td>[0x08-0x0c)</td>
        <td>Magic number</td>
        <td>&#34;SHDR&#34;</td>
        <td>&#34;SHDR&#34;</td>
        <td>&#34;SHDR&#34;</td>
        <td>&#34;SHDR&#34;</td>
        <td>&#34;SHDR&#34;</td>
      </tr>
      <tr>
        <td>[0x0c-0x10)</td>
        <td>Section Length</td>
        <td>16384</td>
        <td>1024</td>
        <td>19780</td>
        <td>393212</td>
        <td>904</td>
      </tr>
      <tr>
        <td>[0x10-0x11)</td>
        <td>Name Length</td>
        <td>7</td>
        <td>3</td>
        <td>5</td>
        <td>8</td>
        <td>7</td>
      </tr>
      <tr>
        <td>[0x11-0x12)</td>
        <td>Version Length</td>
        <td>3</td>
        <td>3</td>
        <td>3</td>
        <td>4</td>
        <td>4</td>
      </tr>
      <tr>
        <td>[0x12-0x13)</td>
        <td>Section Type</td>
        <td>1</td>
        <td>0</td>
        <td>1</td>
        <td>3</td>
        <td>0</td>
      </tr>
      <tr>
        <td>[0x13-0x14)</td>
        <td>Padding</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>
          8<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>
        </td>
      </tr>
      <tr>
        <td>[0x14-0x34)</td>
        <td>Name String</td>
        <td>&#34;sloader&#34;</td>
        <td>&#34;env&#34;</td>
        <td>&#34;post1&#34;</td>
        <td>&#34;firmware&#34;</td>
        <td>&#34;version&#34;</td>
      </tr>
      <tr>
        <td>[0x34-0x3c)</td>
        <td>Version String</td>
        <td>&#34;1.0&#34;</td>
        <td>&#34;1.0&#34;</td>
        <td>&#34;1.0&#34;</td>
        <td>&#34;4.18&#34;</td>
        <td>&#34;4.18&#34;</td>
      </tr>
      <tr>
        <td>[0x3c-0x40)</td>
        <td>SHDR Checksum</td>
        <td><code>0x8cb4693c</code></td>
        <td><code>0x131811ae</code></td>
        <td><code>0xc516c9e5</code></td>
        <td><code>0x82b4a297</code></td>
        <td><code>0x012d56b7</code></td>
      </tr>
      <tr>
        <td>[0x40-0x44)</td>
        <td>Metadata #1</td>
        <td><code>0x00000000</code></td>
        <td>N/A</td>
        <td><code>0x00000000</code></td>
        <td><code>0x81000000</code></td>
        <td>N/A</td>
      </tr>
      <tr>
        <td>[0x44-0x48)</td>
        <td>Metadata #2</td>
        <td><code>0x00000000</code></td>
        <td>N/A</td>
        <td><code>0x00000000</code></td>
        <td><code>0x00048e70</code></td>
        <td>N/A</td>
      </tr>
      <tr>
        <td>[end]</td>
        <td>Section Checksum</td>
        <td><code>0x15d0fa4f</code></td>
        <td><code>0xeba16bb0</code></td>
        <td><code>0x6c91c641</code></td>
        <td><code>0xd1c38847</code></td>
        <td><code>0x108fedea</code></td>
      </tr>
    </tbody>
  </table>
  <h3 id="identifying-code">Identifying Code</h3>
  <h4 id="how">How</h4>
  <p>With the SHDRs mostly understood, I moved on to trying to understand the code.</p>
  <p>It was evident that the code sections also included strings and other data. How could I programmatically identify what was code and what was data?</p>
  <p>I turned to the <a href="https://www.capstone-engine.org/">Capstone disassembler</a> — a small library with a simple interface capable of disassembling a large number of architectures&#39; instruction sets, including MIPS.</p>
  <p>In short, the <em>decompiler</em> part of the project began here with a program that essentially performed a breadth-first search of the code. It processed instructions, beginning with the first branch instruction in a code section, discovering more code in the process. If an address was reachable by a branch then it must be code and the program could search it for further branch targets.</p>
  <p>The results were promising but unimpressive. Only around 10% of the binary was identified as code.</p>
  <h4 id="relative-jumps-versus-nearly-absolute-jumps">Relative jumps versus (nearly) absolute jumps</h4>
  <p>I discovered that there were a number of reasons for this, with the most salient being that I didn&#39;t understand <em>jump</em> instructions. While <em>branch</em> instructions are relative, <em>jump</em> instructions provide a (nearly) absolute jump target.</p>
  <p>For example, the unconditional branch instruction (<code>b</code>) here jumps <code>0x48</code> / 72 bytes, regardless of its location in memory.</p>
  <pre><code>       0:       10000011        b       0x48</code></pre>
  <p>The jump-and-link (<code>jal</code>) instruction (used for function calls) provides the low 28-bits of the jump target (26-bits encoded, shifted left by 2) with the high 4-bits coming from its own address in memory.</p>
  <pre><code>     6e0:       0ff0023c        jal     0xfc008f0</code></pre>
  <p>This meant that the <code>0xfc008f0</code> target was missing the high 4-bits, and without those I couldn&#39;t find the function it was calling.</p>
  <p>I realized I didn&#39;t actually know where execution began.</p>
  <p>I picked up a copy of <a href="https://www.oreilly.com/library/view/see-mips-run/9780120884216/">See MIPS Run</a> and found it to be an invaluable resource in this process. In it I found:</p>
  <blockquote>
    <p>The CPU responds to reset by starting to fetch instructions from <code>0xBFC0.0000</code>. This is physical address <code>0x1FC0.0000</code> in the uncached kseg1 region.</p>
  </blockquote>
  <p>I&#39;d answered an important question (and discovered that I didn&#39;t have any idea about MIPS&#39; different memory regions — another thing I&#39;d need to learn).</p>
  <p>With this knowledge in hand, I disassembled the binary again but this time with the <code>--adjust-vma=0xbfc00000</code> flag. The two instructions from earlier now disassembled as:</p>
  <pre><code>bfc00000:       10000011        b       0xbfc00048</code></pre>
  <pre><code>bfc006e0:       0ff0023c        jal     0xbfc008f0</code></pre>
  <p>A small change to the decompiler to tell Capstone the starting address resulted in it finding a lot more code.</p>
  <h3 id="visualizing-binary-structure">Visualizing binary structure</h3>
  <p>Around this time, I recognized visualizing the binary structure could be useful.</p>
  <p>I added support for emitting images in the simplest format I could find — <a href="https://en.wikipedia.org/wiki/X_PixMap">XPM</a>.</p>
  <p>Here&#39;s what the <code>post1</code> structure looked like:</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/post1-initial.png" alt="post1 initial structure"/>
  <p>Each row contained 128 pixels, with each representing a 4-byte chunk of the binary image. 4-byte chunks work well because MIPS instructions are 4 bytes and are always naturally aligned.</p>
  <p>Red is code. Blue is header and checksum. Black is <code>0x00000000</code>. White is <code>0xffffffff</code>. Gray is unknown.</p>
  <p>What was in the unknown areas?</p>
  <h3 id="identifying-strings">Identifying Strings</h3>
  <p><code>strings</code> indicated there was plenty of ASCII data in the binary, so I wrote some code to find it. It wasn&#39;t hard, but there were lots of corner cases to discover one by one.</p>
  <p>The string data in <code>sloader</code>, <code>post1</code>, and <code>firmware</code> is always aligned to a 4-byte boundary. This was very convenient for finding the starting points and fit well with the existing visualization support.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/post1-with-strings.png" alt="post1 structure with strings"/>
  <p>Green is ASCII data.</p>
  <h3 id="statically-unreachable-functions">Statically-unreachable functions</h3>
  <p>I could see valid instructions in the remaining unknown data. The functions hadn&#39;t been found for three reasons:</p>
  <ul>
    <li>called via a jump table</li>
    <li>called via a constructed address</li>
    <li>actually dead code</li>
  </ul>
  <p>I added the annotation system for providing external information about the firmware and added the functions&#39; addresses to functions.json. These labels would prepopulate the code discovery queue.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/post1-with-annotations.png" alt="post1 structure with annotations"/>
  <h3 id="virtual-subsection">Virtual Subsection</h3>
  <p>The remaining large chunk of unknown data was code. But when I added annotations for the functions&#39; addresses, code discovery failed because the functions contained jumps to addresses that were outside of the ROM. For example:</p>
  <pre><code>$ mips64-unknown-linux-gnu-objdump -b binary -m mips -EB --adjust-vma=0xbfc00000 -D -d ip32prom.rev4.18.bin \
    | grep &#39;jal.*0xb000&#39; \
    | head
bfc072a0:   0c0010e1    jal 0xb0004384
bfc072c0:   0c0011f4    jal 0xb00047d0
bfc072d8:   0c001125    jal 0xb0004494
bfc072f0:   0c0011f4    jal 0xb00047d0
bfc07300:   0c001125    jal 0xb0004494
bfc0731c:   0c0011f4    jal 0xb00047d0
bfc07330:   0c0011f4    jal 0xb00047d0
bfc07554:   0c0011f4    jal 0xb00047d0
bfc075fc:   0c0011f4    jal 0xb00047d0
bfc0763c:   0c0011f4    jal 0xb00047d0</code></pre>
  <p>It turns out (after a lot of assembly reading), the <code>post1</code> section contains a blob of code that is copied to RAM and executed at a different address (<code>0xa0004000</code>). Adding support for dealing with this was a lot of work.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/post1-with-subsection.png" alt="post1 structure with virtual subsection"/>
  <h3 id="unreachable-code">Unreachable Code</h3>
  <p>There were a few stray pixels in the middle of the code sections. The <code>nop</code> instruction on MIPS is <code>0x00000000</code>, so I knew that the black pixels were <code>nop</code> instructions — typically padding between functions. The <code>.int 0x00000000</code> in this snippet is an unreachable padding <code>nop</code>.</p>
  <pre><code>F_0xbfc05098: /* 0xbfc05098 */
    cache   (CACHE_TYPE_L1I|INDEX_WRITEBACK_INV), 0($a0)
    nop
    jr      $ra
     nop
    .int    0x00000000</code></pre>
  <p>But there were also bits of unknown data in the middle of code. Here&#39;s an example from <code>post1.S</code>:</p>
  <pre><code>    beql    $t6, $t8, L_0xbfc05824
     addiu  $v1, $s1, 2
    b       L_0xbfc05894
     ori    $v0, $v1, 0x100
    .int    0x26230002
L_0xbfc05824: /* 0xbfc05824 */
    lbu     $t2, 2($s0)</code></pre>
  <p>Whatever the instruction was, it was definitely unreachable since it occurred after an unconditional branch.</p>
  <p>I added a pass that inspected unknown data in the middle of code sections and marked them as code with an <code>unreachable</code> comment.</p>
  <pre><code>    beql    $t6, $t8, L_0xbfc05824
     addiu  $v1, $s1, 2
    b       L_0xbfc05894
     ori    $v0, $v1, 0x100
    addiu   $v1, $s1, 2     # unreachable
L_0xbfc05824: /* 0xbfc05824 */
    lbu     $t2, 2($s0)</code></pre>
  <p>It seems pretty clear that these unreachable instructions were the result of a compiler optimization that filled branch delay slots. The same <code>addiu $v1, $s1, 2</code> instruction can be seen a few lines above in the delay slot of the <code>beql</code> instruction. Leaving these dead instructions behind looks like a (minor) compiler bug to me.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/post1-with-unreachable-code.png" alt="post1 structure with unreachable code"/>
  <h3 id="accessed-memory">Accessed memory</h3>
  <p>I added a pass that marked memory addresses that were accessed by load and store instructions in yellow.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/post1.png" alt="post1 final structure"/>
  <h3 id="remaining-mysteries">Remaining mysteries</h3>
  <h4 id="firmware-section"><code>firmware</code> section</h4>
  <p>The <code>firmware</code> section accounts for 91% of the used portion of the PROM image (384 KiB of 422 KiB), and despite the success of decompiling the code in <code>sloader</code> and <code>post1</code>, the <code>firmware</code> section was still looking very sad. Here are the first 8 rows of the structure, with the rest not looking much different.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/firmware-sad.png" alt="firmware structure with wrong VMA"/>
  <p>Looking at the small amount of successfully discovered code showed a <code>jal</code> instruction to an unknown address.</p>
  <pre><code>L_0xbfc092a4: /* 0xbfc092a4 */
    move    $a0, $s0
    jal     0xb1000370
     move   $a1, $s1
    b       L_0xbfc092a4
     nop</code></pre>
  <p>Absolute jumps like <code>jal</code> compose their target using the top four bits of their own address, which until now I&#39;d assumed was <code>0xb</code> (from <code>0xbfc00000</code>). Clearly this must not be the case.</p>
  <p>The <code>firmware</code> section is the only section with the <code>0x2</code> bit set in the section type field. I&#39;d <a href="#trailing-8-bytes">previously identified</a> that this bit seemed related to the presence of meaningful-looking data in the 8 bytes immediately following the SHDR.</p>
  <p>The first four bytes were <code>0x81000000</code>. Maybe it was the address the code was expected to execute from?</p>
  <p>This theory had merit for a few reasons:</p>
  <ul>
    <li>the low 28 bits of <code>jal</code>&#39;s jump target were <code>0x1000370</code>, which would work when executing from <code>0x81000000</code>.</li>
    <li>a virtual address of <code>0x81000000</code> is within the <code>kseg0</code> <a href="https://en.wikipedia.org/wiki/Virtual_address_space">virtual address space</a>. <code>kseg0</code> is unmapped (virtual addresses are simply translated to physical addresses by dropping the high 3-bits), so it doesn&#39;t require initializing the TLB. It&#39;s also (configurably) cached, which is probably desirable for the core part of the firmware.
    </li>
    <li>the physical memory location would therefore be <code>0x01000000</code>, or 16 MiB — within the O2&#39;s minimum memory configuration of 32 MiB.</li>
  </ul>
  <p>I tried disassembling the <code>firmware</code> section with <code>--adjust-vma=0x81000000</code>. The <code>jal</code> now looked like</p>
  <pre><code>810000a8:       0c4000dc        jal     0x81000370</code></pre>
  <p>and better yet, at <code>0x81000370</code> there appeared to be a function.</p>
  <pre><code>[...]
8100035c:       27bd0018        addiu   sp,sp,24
81000360:       03e00008        jr      ra
81000364:       00000000        nop
        ...
81000370:       27bdffd8        addiu   sp,sp,-40
81000374:       afb00018        sw      s0,24(sp)
81000378:       00808025        move    s0,a0
8100037c:       afbf001c        sw      ra,28(sp)
81000380:       afa5002c        sw      a1,44(sp)
81000384:       0c4013a6        jal     0x81004e98
[...]</code></pre>
  <p>The second four-byte value was <code>0x00048e70</code> / <code>298608</code>. I didn&#39;t recognize that this was the length until I happened to notice something odd:</p>
  <pre><code>[...]
81048e70:       81048e70        lb      a0,-29072(t0)
81048e74:       0000b290        .word   0xb290
[...]</code></pre>
  <p>The data at location <code>0x81048e70</code> was its own address?</p>
  <p>Spidey senses tingling, I looked at what was at <code>0x81048e70</code> + <code>0xb290</code> + <code>8</code> (the size of this header) = <code>0x81054108</code>.</p>
  <pre><code>81054108:       81054100        lb      a1,16640(t0)
8105410c:       0000bee0        .word   0xbee0</code></pre>
  <p>And again at <code>0x81054100</code> + <code>0xbee0</code> + <code>16</code> (the size of two headers) = <code>0x8105fff0</code>.</p>
  <pre><code>8105fff0:       81000000        lb      zero,0(t0)
8105fff4:       00000000        nop</code></pre>
  <p>This time, however, we were at the very end of the section. The remaining 8-bytes of the section were the checksum (<code>0xd1c38847</code>) and four bytes of zeros to pad to a 256-byte boundary.</p>
  <pre><code>8105fff8:       d1c38847        lld     v1,-30649(t6)
8105fffc:       00000000        nop</code></pre>
  <p>So these pairs appeared to be an address and length with the last pair as a sentinel value with a length of zero.</p>
  <p>Inspecting the contents of each of these subsections showed clear differences. The first subsection was code. The second was primarily strings with what looked to be jump tables (sequences of pointers into the code&#39;s virtual memory area). The third was more difficult. It still had some strings. It still had some pointers to the code. But whereas all the memory accesses to the second subsection were loads, there were loads and stores to the third.</p>
  <p>It became apparent that these were the <code>.text</code>, <code>.rodata</code>, and (read-write) <code>.data</code> sections.</p>
  <table>
    <thead>
      <tr>
        <th>Subsection</th>
        <th>Load Address</th>
        <th>Length</th>
        <th>Content</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>.text</code></td>
        <td><code>0x81000000</code></td>
        <td><code>0x00048e70</code></td>
        <td>Executable code</td>
      </tr>
      <tr>
        <td><code>.rodata</code></td>
        <td><code>0x81048e70</code></td>
        <td><code>0x0000b290</code></td>
        <td>Read-only data (strings, tables)</td>
      </tr>
      <tr>
        <td><code>.data</code></td>
        <td><code>0x81054100</code></td>
        <td><code>0x0000bee0</code></td>
        <td>Read-write initialized data</td>
      </tr>
      <tr>
        <td>sentinel</td>
        <td><code>0x81000000</code></td>
        <td><code>0x00000000</code></td>
        <td>Zero length terminates parsing</td>
      </tr>
    </tbody>
  </table>
  <p>Presumably the <code>firmware</code> section was written in C, compiled to a static ELF binary, and then had its sections extracted and repacked into a simple but custom format.</p>
  <h4 id="checksum-1">Checksum</h4>
  <p>If the ultimate goal of the project was to make modifying the PROM possible, I&#39;d need to be able to recalculate the checksums.</p>
  <p>Fortunately it wasn&#39;t too hard to find the function that verified the checksum in <code>sloader</code>.</p>
  <pre><code>is_section_checksum_valid: /* 0xbfc01874 */
    lw      $t6, SHDR_OFFSET_SECTION_LEN($a0)   # $t6 = Load the length of the section
    [...]

    addiu   $v1, $a0, SHDR_SIZE                 # $v1 = address of end of SHDR
    addu    $a1, $a0, $t6                       # $a1 = address of end of section

    [...]

    move    $v0, $v1                            # $v0 = address of data to be checksummed

    [...]

     move   $a2, $zero                          # $a2 = checksum

    [...]

checksum_main_loop: /* 0xbfc018c4 */
    lw      $t9, 0($v0)                         # $t9 = word[0]
    lw      $t0, 4($v0)                         # $t0 = word[1]
    lw      $t1, 8($v0)                         # $t1 = word[2]
    addu    $a2, $a2, $t9                       # checksum += word[0]
    lw      $t2, 0xc($v0)                       # $t2 = word[3]
    addu    $a2, $a2, $t0                       # checksum += word[1]
    addiu   $v0, $v0, 0x10                      # word += 16
    addu    $a2, $a2, $t1                       # checksum += word[2]
    bne     $v0, $a1, checksum_main_loop        # branch while not at end
     addu   $a2, $a2, $t2                       # checksum += word[3]
checksum_done: /* 0xbfc018ec */
    jr      $ra
     sltiu  $v0, $a2, 1                         # return checksum == 0</code></pre>
  <p>A plain old <a href="https://en.wikipedia.org/wiki/Checksum#Sum_complement">two&#39;s complement checksum</a> — add all the 32-bit words and negate, such that when the stored checksum is added the result is zero.</p>
  <p>I verified that the SHDR checksum is calculated the same way. A funny implication is that the section checksum calculation doesn&#39;t need to consider the contents of the SHDR, because a valid checksum for the SHDR necessarily means that its contribution would be 0. We see this taken advantage of in <code>is_section_checksum_valid</code> by skipping the SHDR.</p>
  <h4 id="version-shdr"><code>version</code> SHDR</h4>
  <p>The <code>version</code> section&#39;s SHDR had three oddities compared with the others.</p>
  <ol>
    <li>the initial bytes looked like garbage</li>
    <li>the padding byte contained <code>8</code></li>
    <li>there was data after the <code>&#34;version&#34;</code> string in the 32-byte name field</li>
  </ol>
  <h5 id="initial-bytes">Initial bytes</h5>
  <p>The section didn&#39;t seem important for my purposes, so it wasn&#39;t until I was implementing support for recognizing addresses constructed by <code>li</code> + <code>addiu</code>/<code>ori</code> pairs that I discovered what the initial bytes were.</p>
  <p>Some values constructed weren&#39;t addresses but other useful values:</p>
  <ul>
    <li><code>133333000</code> — a clock frequency</li>
    <li><code>31536000</code> — the number of seconds in 365 days</li>
    <li><code>0x53484452</code> — the &#34;SHDR&#34; magic value</li>
  </ul>
  <p>This made me wonder if the initial bytes (<code>0x7f454c46</code>, <code>0x01020100</code>) could be magic numbers.</p>
  <p>A quick search revealed that <code>0x7f454c46</code> was the magic number for ELF binaries (<code>&#34;\x7fELF&#34;</code>). <code>file</code> on the extracted <code>version</code> section confirmed, and I felt a bit silly for not realizing this sooner.</p>
  <pre><code>$ file version.bin
version.bin: ELF 32-bit MSB MIPS, MIPS-II (SYSV)</code></pre>
  <p>I looked up the structure of the ELF header, and found that the initial 16 bytes were the <code>e_ident</code> field.</p>
  <div id="cb25">
    <pre><code><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span>#define EI_NIDENT </span><span>(</span><span>16</span><span>)</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span>typedef</span> <span>struct</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span>{</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span>unsigned</span> <span>char</span> e_ident<span>[</span>EI_NIDENT<span>];</span> <span>/* Magic number and other info */</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span>[...]</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span>}</span> Elf32_Ehdr<span>;</span></span></code></pre>
  </div>
  <p>It contained the ELF magic number and the <code>0x01020100</code> value, which I decoded as:</p>
  <div id="cb26">
    <pre><code><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>Ehdr<span>-&gt;</span>e_ident<span>[</span>EI_CLASS<span>]</span>   <span>=</span> ELFCLASS32<span>;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>Ehdr<span>-&gt;</span>e_ident<span>[</span>EI_DATA<span>]</span>    <span>=</span> ELFDATA2MSB<span>;</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>Ehdr<span>-&gt;</span>e_ident<span>[</span>EI_VERSION<span>]</span> <span>=</span> EV_CURRENT<span>;</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>Ehdr<span>-&gt;</span>e_ident<span>[</span>EI_OSABI<span>]</span>   <span>=</span> ELFOSABI_NONE<span>;</span></span></code></pre>
  </div>
  <p>The remaining bytes in <code>e_ident</code> are ABI version (byte 8) and padding (9..15). These bytes contained the <code>&#34;SHDR&#34;</code> magic number and the section length.</p>
  <h5 id="value-in-padding-byte">Value in padding byte</h5>
  <p>With the recognition that the SHDR and ELF header were overlaid, I checked what was in the ELF header at this address.</p>
  <table>
    <tbody><tr>
      <th></th>
      <th colspan="2">SHDR</th>
      <th colspan="2">ELF</th>
    </tr>
    <tr>
      <th>Bytes</th>
      <th>Field</th>
      <th>Interpretation</th>
      <th>Field</th>
      <th>Interpretation</th>
    </tr>
    <tr>
      <td>0x12</td>
      <td>Section Type</td>
      <td><code>0</code>, <code>SECTION_TYPE_DATA</code></td>
      <td rowspan="2"><code>e_machine</code></td>
      <td rowspan="2">(<code>0x08</code>, <code>EM_MIPS</code>)</td>
    </tr>
    <tr>
      <td>0x13</td>
      <td>Padding</td>
      <td><code>8</code></td>
    </tr>
  </tbody></table>
  <p>A perfect fit.</p>
  <h5 id="data-after-version-name-string">Data after <code>&#34;version&#34;</code> name string</h5>
  <p>Decoding the stray data in the name string was trivial at this point.</p>
  <pre><code>Ehdr-&gt;e_phoff     = 0x00000000;
Ehdr-&gt;e_shoff     = 0x00000244;
Ehdr-&gt;e_flags     = EF_MIPS_ARCH_2 | EF_MIPS_NOREORDER | EF_MIPS_PIC;
Ehdr-&gt;e_ehsize    = 52;
Ehdr-&gt;e_phentsize = 0;
Ehdr-&gt;e_phnum     = 0;
Ehdr-&gt;e_shentsize = 40;
Ehdr-&gt;e_shnum     = 8;
Ehdr-&gt;e_shstrndx  = 7;</code></pre>
  <h3 id="conclusion">Conclusion</h3>
  <p>Reverse engineering the IP32 PROM turned out to be more tractable than the author of the mailing list post thought.</p>
  <p>The firmware&#39;s structure — SHDRs, subsection headers, checksums — was relatively straightforward (in hindsight, at least), but it took small incremental steps over a long period of time to fully unmask.</p>
  <p>Visualization was particularly helpful, not just for understanding but also providing motivation and a progress bar of sorts.</p>
  <p>For a 512 KiB firmware image from 1996, the main challenge wasn&#39;t complexity but instead the sheer number of small details to get right.</p>
  <h3 id="next-steps">Next steps</h3>
  <p>With the structure of the PROM fully understood, work turned to improving the decompiler&#39;s output.</p>
  <p>The decompiler now produces assembly source files that reassemble into a bit-identical copy of the original ROM image — a strong confirmation that the PROM has been correctly understood. Today, with BSS variable names, function labels, and comments annotating the output, the firmware is sufficiently readable to understand its hardware initialization and boot process.</p>
  <p>My hope is that this work is an important step towards a new CPU upgrade in the Silicon Graphics O2.</p>
  <h4 id="current-prom-structure">Current PROM structure</h4>
  <p>Here&#39;s the full structure of the PROM image, as generated by the decompiler at the time of this writing.</p>
  <p>Red is code. Blue is header and checksum. Green is ASCII data. Yellow is accessed memory. Black is <code>0x00000000</code>. White is <code>0xffffffff</code>. Gray is unknown.</p>
  <img src="https://mattst88.com/blog/2026/02/08/Reverse_Engineering_the_PROM_for_the_SGI_O2/prom.png" alt="prom structure"/>
  
    <p><time datetime="2026-02-08">08 February 2026</time> – Tags: <a href="https://mattst88.com/tag/mips">mips</a> <a href="https://mattst88.com/tag/reverse-engineering">reverse-engineering</a> <a href="https://mattst88.com/tag/sgi">sgi</a></p>
   </article></div>
  </body>
</html>
