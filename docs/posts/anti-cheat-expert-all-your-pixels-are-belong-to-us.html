<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://invlpg.dev/post/ace_screenshots/">Original</a>
    <h1>Anti-Cheat Expert: all your pixels are belong to us</h1>
    
    <div id="readability-page-1" class="page"><div class="page">

            

            <section>
    
    <div>
        <p>ACE, or better known as Anti-Cheat Expert is, as the name suggests, an anti-cheat made by the tech giant Tencent.
In today’s digital age, the line between ensuring fair play in online gaming and safeguarding personal privacy is becoming increasingly blurred.
That’s why I took a look into ACE and, to be honest, the findings didn’t completely shock me.</p>

<p>Now, why did I look into said anti-cheat, and why exactly should it become a public concern?
As a gaming enthusiast, I really enjoyed the extraction shooter Escape From Tarkov; however, after the recent events, I was looking out for an alternative.
</p>

<p>Gamers like them, security researchers find them interesting, and cheaters hate them.
Recently, people started talking about anti-cheat more and more on social media, stating their concerns for privacy.
This was led by a prime example called <a href="https://support-valorant.riotgames.com/hc/en-us/articles/360046160933-What-is-Vanguard"><strong>Vanguard</strong></a> made by <a href="https://www.riotgames.com/en"><strong>Riot Games</strong></a>.
The outcry started because Riot Games is Tencent owned, a chinese company and we all know that China loves your data.
Turns out, they dumped fuel on the fire. Researchers who found out that Vanguard was taking screenshots of the game it was protecting appeared to believe it was capturing the whole screen with wreckless abandon.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> This was later debunked by <a href="https://revers.engineering/"><strong>daax</strong></a> a security researcher - <a href="https://twitter.com/daaximus/status/1786224313223323726"><strong>View Tweet</strong></a>.</p>
</blockquote>
<p>Now what if I told you that there actually is a Chinese-owned anti-cheat that is taking screens of your entire main screen? That’s how we come to Anti-Cheat Expert.</p>

<p>ACE is, as already mentioned, a Chinese-owned anti-cheat, which has several usermode and kernelmode components.
3 drivers, 9 DLLs… we’re not going to name them all.
You can check the bottom of the article.
It even has the facilities to be loaded at boot, this however is not used in Arena Breakout: Infinite.
I heard from all sides that ACE is a privacy concern overall, and some even labeled it a <a href="https://en.wikipedia.org/wiki/Remote_desktop_software#RAT"><strong>RAT</strong></a>.
</p>

<p>Anti-Cheats usually use the game’s <a href="https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types"><strong>HWND</strong></a> (their window handle) to take screenshots.
ACE, however, wants to be the middle child in the anti-cheat family; instead of taking a screenshot of only the game, or at least of only the game’s window size, it takes a screenshot of the entire display! Noice.
Now, words are just words if you can’t prove what you are saying. The following code is taken directly out of the binary.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span><span>if</span> (GetVersion() <span>&gt;=</span> <span>0x80000000</span> <span>||</span>(result <span>=</span> check_window_station(), result <span>&lt;=</span> <span>0</span>))  
</span></span><span><span>{  
</span></span><span><span>    hdcSrc <span>=</span> CreateDCW(<span>L</span><span>&#34;DISPLAY&#34;</span>, <span>0</span>, <span>0</span>, <span>0</span>);  
</span></span><span><span>    CompatDC <span>=</span> CreateCompatibleDC(hdcSrc);  
</span></span><span><span>    HorizontalRes <span>=</span> GetDeviceCaps(hdcSrc, HORZRES);  
</span></span><span><span>    VerticalRes <span>=</span> GetDeviceCaps(hdcSrc, VERTRES);  
</span></span><span><span>    CompatibleBitmap <span>=</span> CreateCompatibleBitmap(hdcSrc, HorizontalRes, <span>16</span>);  
</span></span><span><span>    v5 <span>=</span> SelectObject(CompatDC, CompatibleBitmap);  
</span></span><span><span>    GetObjectW(CompatibleBitmap, <span>32</span>, <span>&amp;</span>pv);  
</span></span><span><span>    v6 <span>=</span> v15 <span>*</span> v14 <span>*</span> v16;  
</span></span><span><span>    v7 <span>=</span> sub_180002D80(v6, <span>&#34;.</span><span>\\</span><span>crypto</span><span>\\</span><span>rand</span><span>\\</span><span>rand_win.c&#34;</span>, <span>719</span>, v7);  
</span></span><span><span>    <span>if</span> ( v7 )  
</span></span><span><span>    {  
</span></span><span><span>        v8 <span>=</span> VerticalRes <span>-</span> <span>16</span>;  
</span></span><span><span>        <span>for</span> ( y1 <span>=</span> <span>0</span>; y1 <span>&lt;</span> v8; y1 <span>+=</span> <span>16</span> )
</span></span><span><span>        {
</span></span><span><span>            BitBlt(CompatDC, <span>0</span>, <span>0</span>, HorizontalRes, <span>16</span>, hdcSrc, <span>0</span>, y1, <span>0xCC0020</span>);
</span></span><span><span>            GetBitmapBits(CompatibleBitmap, v6, v7);
</span></span><span><span>            v10 <span>=</span> sub_18000B8F0();
</span></span><span><span>            sub_18000B6B0(v7, v6, v17, <span>0</span>, v10, <span>0</span>);
</span></span><span><span>            sub_180011820(v17, <span>0x14</span>);
</span></span><span><span>        }
</span></span><span><span>
</span></span><span><span>        sub_180003030(v7);
</span></span><span><span>    }  
</span></span><span><span>
</span></span><span><span>    v11 <span>=</span> SelectObject(CompatDC, v5);  
</span></span><span><span>    DeleteObject(v11);  
</span></span><span><span>    DeleteDC(CompatDC);  
</span></span><span><span>    <span>return</span> <span>DeleteDC</span>(DCW);  
</span></span><span><span>}
</span></span></code></pre></div><p>In the following, I will dissect the code piece by piece to hopefully make it understandable for everyone reading.</p>
<p><code>if ( GetVersion() &gt;= 0x80000000 || (result = check_window_station(), result &lt;= 0) )</code></p>
<p>The function starts off with checking if the current Windows version is NT, 2000, or XP.
Most machines will fail this check, hence the second check for the <a href="https://learn.microsoft.com/en-us/windows/win32/winstation/window-stations"><strong>Window Station</strong></a>.
If the Window Station name does not contain the substring <a href="https://learn.microsoft.com/en-us/windows/win32/winstation/window-station-and-desktop-creation"><strong>“Service-0x”</strong></a> the function proceeds.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>hdcSrc <span>=</span> CreateDCW(<span>L</span><span>&#34;DISPLAY&#34;</span>, <span>0</span>, <span>0</span>, <span>0</span>);
</span></span><span><span>CompatDC <span>=</span> CreateCompatibleDC(hdcSrc);
</span></span></code></pre></div><p>After successfully passing the entry check, the function now tries to create a device context handle for the primary monitor.
Once the device context handle has been acquired, it then tries to create a <a href="https://learn.microsoft.com/en-us/windows/win32/gdi/memory-device-contexts"><strong>memory device context</strong></a>, that is compatible with the specified device context.
Something I found quite peculiar is that this function does minimal error checking.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>HorizontalRes <span>=</span> GetDeviceCaps(hdcSrc, HORZRES);  
</span></span><span><span>VerticalRes <span>=</span> GetDeviceCaps(hdcSrc, VERTRES);
</span></span></code></pre></div><p>Now that the function has acquired the necessary contexts, it proceeds with getting the horizontal, and vertical resolutions of the display.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>CompatibleBitmap <span>=</span> CreateCompatibleBitmap(hdcSrc, HorizontalRes, <span>16</span>);
</span></span></code></pre></div><p>Creating a compatible bitmap is the primary building block to getting the actual bits of the screenshot taken.
It does this by providing the device context, the width of the display, and the height 16.
The height in this case plays a special role, as we will find out in a bit.</p>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>v8 <span>=</span> VerticalRes <span>-</span> <span>16</span>;
</span></span><span><span><span>for</span> ( y1 <span>=</span> <span>0</span>; y1 <span>&lt;</span> v8; y1 <span>+=</span> <span>16</span> )
</span></span></code></pre></div><p>v8 holds the height of your display - 16, here we start to eventually notice a pattern.
In the for loop, we start at y = 0 and incrementally add 16 to y as long as y is smaller than v8.
Usually, screenshots are taken with your display width and height at once, or at least the game’s window width and height.
In this case, ACE took a special route; this loop is reminiscent of old CRT <a href="https://en.wikipedia.org/wiki/Raster_scan"><strong>raster scanning</strong></a> patterns by screenshotting the whole width of your display at once; but only 16 pixels in height per iteration.</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> I was made aware that this could also be used as a low FPS stream.</p>
</blockquote>
<div><pre tabindex="0"><code data-lang="cpp"><span><span>BitBlt(CompatDC, <span>0</span>, <span>0</span>, HorizontalRes, <span>16</span>, hdcSrc, <span>0</span>, y1, <span>0xCC0020</span>);
</span></span><span><span>GetBitmapBits(CompatibleBitmap, v6, v7);
</span></span></code></pre></div><p><a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-bitblt"><strong>BitBlt</strong></a> is the WinGDI function that actually grabs the pixels off of your screen.
Here we can see it being called with the memory DC, a height of 16, x always at 0, and the current y value labeled y1.
For further processing, <a href="https://learn.microsoft.com/en-us/windows/win32/api/wingdi/nf-wingdi-getbitmapbits"><strong>GetBitmapBits</strong></a> is called to acquire the actual bits of the screenshot taken; it then stores them in v7.</p>
<p><em>Compile-Ready Implementation – <a href="https://gist.github.com/koyzdev/7aa8abaeb566ddf9aeb65f86d894b978"><strong>View</strong></a></em></p>
<blockquote>
<p><strong><em>NOTE:</em></strong> The sub_X functions are all related to OpenSSL and somewhat obfuscated.
It’s a combination of mutation and OpenSSL being the most obscurely written piece of work I’ve ever seen.</p>
</blockquote>

<p>The whole function seems dubious at best; and during my testing, it was never invoked. However, just its presence was mildly alarming.</p>
<p>The function could very likely be only used in certain situations, e.g., when a cheater triggered certain detections, a player was reported for cheating, etc. Worth mentioning is that the function is being referenced in other parts of the binary; hence, I wouldn’t categorize it as dead code.
</p>

<p>Usermode:</p>
<ul>
<li>ACE-ATS64.dll</li>
<li>ACE-CSI64.dll</li>
<li>ACE-DFS64.dll</li>
<li>ACE-DRV64.dll</li>
<li>ACE-IDS64.dll</li>
<li>ACE-Trace.dll</li>
<li>ACE-Safe.dll</li>
<li>ACE-SSC64.dll</li>
<li>ACE-Base64.dll</li>
</ul>
<p>Kernelmode:</p>
<ul>
<li>ACE-Base.sys</li>
<li>ACE-BOOT.sys</li>
<li>ACE-SSC-DRV64.sys</li>
</ul>

    </div>
    

            </section>

            <section>
                <div>
<div>
    

<p>a blog about exploring reverse engineering, hypervisor development and software programming.</p>
</div>



</div>
                <hr/>
                <div>
    <p>ACE and their screenshot shenanigans</p>
    
        <p>
            By koyz, 
            2024-06-07
        </p>
    

    

                </div>
            </section>

            

        </div></div>
  </body>
</html>
