<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ianthehenry.com/posts/janet-for-mortals/">Original</a>
    <h1>Janet for Mortals (2023)</h1>
    
    <div id="readability-page-1" class="page"><article>

<div><p>I wrote a book.</p>
<p>It’s called <a href="https://janet.guide/"><em>Janet for Mortals</em></a>, and it’s free, and it’s on the internet, and you can read it right now.</p>
<p>And you <em>should</em> read it right now, instead of reading this blog post, because this blog post is not very interesting if you haven’t read the book. Heck, this blog post is not very interesting even if you <em>have</em> read the book. This blog post is a thinly-veiled promotion for my book to slip into my newsletter and RSS feed, with just enough additional content to pad it out to the length of a real post.</p>
<p>The book is about <a href="https://janet-lang.org/">Janet</a>, a programming language that <a href="https://ianthehenry.com/posts/janet-game/">I have written about before</a>. I’ve been using Janet a lot lately, and I’ve been having a lot of fun with it, and I think that more people should know about it so that they can have fun with it too. People like you.</p>
<p>I’m not really going to talk much about <em>why</em> you should read the book, or even why you should care about Janet in the first place – that will come in a later post. Instead, this is going to be a short retrospective of what it was like to write my first technical book.</p>
<hr/>
<p>We’ll start with some numbers.</p>
<p>It took me twenty weeks to write the book, working in my spare time. I had originally estimated twelve weeks, which turned out to be a really good guess for how long I spent <em>writing</em> the book, but I didn’t account for how much time I would spend working on book-adjacent coding side quests.</p>
<p>The final book is pretty short: 44k words of English prose, if you don’t count any of the code snippets. I tried to find an example of a famous book with a similar word count to put that number in perspective, and the best I can do is <em>The Great Gatsby</em>, which clocks in at 47k words. It’s right on the border between novella- and novel-length, but it’s less than half as long as <a href="https://ianthehenry.com/posts/how-to-learn-nix/">my series of posts about Nix</a>, which is sort of terrifying.</p>
<p>But writing English words was only a fraction of the work. Over the course of those five months, I also spent a lot of time on:</p>
<ul>
<li><a href="https://janet.guide/">the website itself</a></li>
<li><a href="https://github.com/ianthehenry/jimmy"><code>jimmy</code></a>, bindings to a C++ library of persistent data structures</li>
<li><a href="https://toodle.studio">Toodle.Studio</a>, an interactive turtle graphics playground</li>
<li><a href="https://github.com/ianthehenry/cmd"><code>cmd</code></a>, a command-line argument parsing library</li>
<li><a href="https://github.com/ianthehenry/judge"><code>judge</code></a>, an inline snapshot testing framework</li>
<li><a href="https://github.com/ianthehenry/to-do"><code>to do</code></a>, a command-line todo list manager</li>
</ul>
<p>These things are not very interesting by themselves, but this blog post just exists to promote the book, so I’m going to reflect on them now. You are welcome to stop reading at any point and <a href="https://janet.guide/">go read the actual book instead</a>.</p>
<h2 id="the-website-2-weeks">The Website (2 weeks)</h2>
<p>The most interesting thing about <em>Janet for Mortals</em> is that it has a built-in repl. At any point you can press escape and pull it up, and it’s docked to the bottom of the page, just out of the way of the text. I’m sure that it’s not the first programming book to include a repl like this, but I’ve never actually seen it done before.</p>
<p>The editor portion of the repl is <a href="https://codemirror.net/">CodeMirror</a>, which I had used previously in <a href="https://ianthehenry.com/posts/janet-for-mortals/bauble.studio/">Bauble</a>. CodeMirror doesn’t know anything about Janet out of the box, but I had already implemented some basic <a href="https://ianthehenry.com/posts/janet-for-mortals/github.com/ianthehenry/codemirror-lang-janet">language support</a> when I wrote Bauble.</p>
<p>But I skipped a lot of the Janet language when I was writing the grammar for Bauble, like <code>``multi`backtick`quoted``</code> strings, because they didn’t really matter in Bauble’s constrained DSL. But they mattered for the book, so I had to spend time figuring out how to implement them.</p>
<p>But fleshing out the CodeMirror grammar (or more precisely, the <a href="https://lezer.codemirror.net/docs/guide/">Lezer</a> grammar that CodeMirror uses) had an unexpected side effect: it let me re-use the grammar to do syntax highlighting for the code snippets in the book itself.</p>
<p><em>Janet for Mortals</em> is just a static site, but no static site generators that I know of know how to highlight Janet code. For a long time the book was entirely black-and-white, which I don’t mind, but I knew I needed to add some color before I released it upon an unsuspecting public – I think Janet’s syntax is pretty unfamiliar to most people reading the book, and anything to make it look friendlier helps.</p>
<p>So I knew that I’d have to roll my own syntax highlighter of some kind, and I ended up just writing a simple static site generator in <a href="https://github.com/apenwarr/redo"><code>redo</code></a>, which was not a very good fit, but… well, least bad choice that I know of. The meat of the generator is written in JavaScript, so that I could plug in the Lezer grammar for free, but it’s all tied together by a fragile web of shell.</p>
<p>I used <a href="https://github.com/remarkjs/remark">Remark</a> to implement the parsing of the book’s source, and it was nice how much control I had over the generated output. I even added a simple extension to label code blocks, which was pretty easy.</p>
<p>I also re-used Remark in the client itself, as part of the repl. The docstrings in the Janet standard library are written in Markdown, and I’m actually parsing and rendering them to HTML on the fly as part of the repl autocomplete.</p>
<p>I spent a long time getting the repl autocomplete working well – because this book was written for newcomers to the Janet language, I thought that the help-as-you-type would be really useful for people trying to follow along in the repl.</p>
<p>Autocomplete works by dynamically querying the Janet environment via WebAssembly at repl startup. This means if you define a new symbol with a docstring, it won’t actually appear in the autocomplete output, but I think that’s… fine. I could re-generate the autocompletions after every command is run, but… I don’t think there’s much value in that.</p>
<p>The most interesting part of the repl is probably the <code>(report)</code> function, which takes a string and POSTs it to a simple web server that sticks it into a SQLite database for me to peruse later. It’s not really any different than a comment box, but I feel like there’s something fun about doing it from the repl. I’m really glad that I added it – it’s been fun reading people’s feedback, and I’ve fixed quite a few errors because of it. I’m sad that I didn’t implement any way to respond, though!</p>
<p>The backend for reports is <em>not</em> written in Janet; it’s a tiny Haskell application that just listens for POST requests and sticks them into a SQLite database.</p>
<p>There are people using Janet to make websites, but I am not one of them: the primary thing I want out of a web server is security, and I just don’t think Janet or its HTTP libraries are “battle-tested” enough for me to connect them to the internet.</p>
<p>I also just think the idea of using a dynamically-typed interpreted language to build a web service is crazy, when there are optimizing compilers <em>right there</em>, but that’s a whole other conversation.</p>
<h2 id="jimmy-1-week"><code>jimmy</code> (1 week)</h2>
<p>I spent a little bit of time writing bindings to <a href="https://github.com/arximboldi/immer">immer</a>, a library of persistent data structures. I never finished them, and probably won’t, at least not until I have a use for them. But as a demonstration of how to interop with C++ code from Janet, I think it was successful.</p>
<h2 id="httpstoodlestudio-2-weeks"><a href="https://toodle.studio">https://toodle.studio</a> (2 weeks)</h2>
<p>Last year I wrote a little art playground called <a href="https://bauble.studio/">Bauble</a>. It was my first time embedding Janet in the browser, and I had a pretty tough time figuring out how to do that.</p>
<p>There weren’t a lot of resources back then about embedding Janet <em>period</em>, and doing it in the browser added an extra layer of difficulty. I’d never used WebAssembly or Emscripten before, or even TypeScript, and it turns out there are no tutorials on how to write TypeScript Emscripten WebAssembly Janet bindings, so I spent a while figuring out how all the pieces worked together.</p>
<p>And I’m glad I did, because I think the final product is really neat: it’s a website that is <em>not written in JavaScript</em>. I mean, a lot of it is. The UI is, still. But the actual application logic is all Janet.</p>
<p>I thought that that was a really useful superpower of Janet, and I wanted to make the technique more accessible. In fact this was a big motivation for writing this book about Janet – I wanted people to know that this was <em>possible</em> in the first place, and I wanted to make it easier to get started with it.</p>
<p>But <em>Janet for Mortals</em> doesn’t talk about Bauble at all. Bauble is actually not very interesting from an interop perspective: Bauble is completely stateless, and basically uses Janet to implement a pure function from strings to strings (they’re… pretty complicated strings; Bauble is a Janet-to-GLSL compiler, but they are strings nonetheless). I didn’t think it was a very good showcase for everything you can do with Janet, so I briefly considered talking about how I implemented the repl in the book, but I decided that that was far too boring. So I wrote <a href="https://toodle.studio/">Toodle.Studio</a> – an obvious fork of Bauble – instead.</p>
<p>Toodle.Studio <em>seems</em> a lot simpler than Bauble, but the interop with JavaScript is much more involved. Toodle.Studio has to execute long-running Janet programs asynchronously over time. It has to think about memory management, as the JavaScript code retains multiple references to the same Janet values. It has to pass complex nested data structures to and from Janet, going through C++ as an intermediary. It does a very simple version of all of these things, but it’s a pretty good showcase for the techniques.</p>
<p>But the most interesting part of Toodle.Studio isn’t the interop or the memory management. The most interesting part of Toodle.Studio is the logo.</p>
<p>I wasn’t really planning on making a logo – this is a demo project for a book, after all – but sadly I had no choice. When I was getting ready to release the website, I showed it to my partner, because it’s rare that I work on something comprehensible to normal human beings. I thought she’d like it, but she was <em>aghast</em>.</p>
<p>“You said you were working on turtle graphics,” she said. “Where are the turtles?”</p>
<p>I tried to explain that the turtles aren’t <em>really</em> turtles, that it’s like a flea circus, and the turtles are metaphors – but she was having none of it. The lack of turtles was a base betrayal, so I had to spend a day or so <a href="https://gist.github.com/ianthehenry/612c980f0db04ea3c2ccab2741475870">modeling a cute animated turtle in Bauble</a> to act as the logo. And making its eyes follow the mouse, of course.</p>
<p>Relationship repaired. The logo wound up being my favorite part of the site, and it was fun to get a chance to use Bauble to make something “real.”</p>
<h2 id="cmd-2-weeks"><code>cmd</code> (2 weeks)</h2>
<p>One of the things that I spent the most time on, oddly enough, was a command-line argument parsing library. The library itself only gets, like, three paragraphs of screen time in the book, but it was very important to me that it exist before the book came out, so that I could unambiguously claim that “Janet is an excellent scripting language.” Before <code>cmd</code>, that was still true, but the phrasing was more “Janet is a great choice for scripting and writing CLI tools, except that the argument parsing is kind of janky, sorry, but hey at least it’s better than Bash.”</p>
<p><code>cmd</code> was heavily inspired by <a href="https://ocaml.org/p/core/latest/doc/Core/Command/Param/index.html"><code>Core.Command</code></a>, which is the best command-line argument parsing library that I have ever used. I’m extremely spoiled by how easy it makes writing CLIs, and I wanted to replicate that experience in Janet. <code>cmd</code> is definitely not as good as <code>Core.Command</code> – types, my goodness, types make everything so much easier – but it has 95% of the features I care about, and the concise notation makes it more pleasant to use in ad-hoc scripts.</p>
<p>One thing that I miss, though, is that <code>Core.Command</code> autogenerates Bash completion functions. I want to add that to <code>cmd</code> one day – the API is designed so that that will be <em>possible</em> to do. But… so many projects, so little time.</p>
<h2 id="judge-1-week"><code>judge</code> (1 week)</h2>
<p><code>judge</code> was <a href="https://ianthehenry.com/posts/janet-game/judging-janet/">one of the first things that I wrote in Janet</a>, all the way back in 2021. I think that it worked pretty well considering that I didn’t know anything about Janet when I wrote it, but now I do, so I rewrote it from scratch. Not only is the API much nicer to use now, but the implementation is way simpler – and easier to make changes to.</p>
<p>The main differences between Judge v1 and Judge v2 are that tests can now appear inside regular source files, not just the <code>test/</code> directory, and I added the <code>test-macro</code> and <code>test-stdout</code> helpers, which are <em>extremely</em> useful. <a href="https://blog.janestreet.com/the-joy-of-expect-tests/">The OCaml equivalent of <code>test-stdout</code></a> is pretty much the only way that I write tests professionally, because OCaml doesn’t really have a way to embed arbitrary data in source code, so we turn everything into a string.</p>
<p>After publishing the book – which <a href="https://janet.guide/testing-and-debugging/">has a whole chapter on testing with Judge</a> – I had a chance to spend a little more time improving Judge, and I finally added an <code>--interactive</code> mode, which I’ve been wanting for a long time. And since I’m not spending all my time working on this book anymore, I’ve actually had a few opportunities to <em>use</em> the new Judge, and I gotta say: it’s nice. It’s really nice. I know I can’t impress upon you just how nice it is in this post – it really needs a demo, and I’m too lazy to record one right now – but I’m very happy with how it feels to use it to write Janet.</p>
<h2 id="to-do-2-hours"><code>to do</code> (2 hours)</h2>
<p>I picked this project to highlight for <a href="https://janet.guide/scripting/">the scripting chapter</a>, because it’s a non-trivial thing that I had done in Bash before, and actually found it pretty painful. Parsing multi-line text with Sed is not fun, and trying to do date manipulation with <code>date</code> in a way that works the same on macOS and Linux is… basically impossible, as far as I can tell. I quickly ran into the limits of my patience, and gave up on the idea some years ago.</p>
<p>It was really fun to return to this with the full power of PEGs and <a href="https://github.com/andrewchambers/janet-sh"><code>sh</code></a> and <a href="https://github.com/ianthehenry/cmd"><code>cmd</code></a> at my disposal. I immediately surpassed all of features of my original Bash todo list, and was able to add quite a few more (like <code>fzf</code> multi-select – good luck constructing null-terminated strings in Bash).</p>
<p>The book covers a very simplified version of the app – it can’t schedule tasks for the future, and there’s no concept of “skipping” tasks. Those features are important for <em>my</em> todo list workflow, but they are probably not important for <em>your</em> todo list workflow, so the book only discusses the core functionality of adding things to a list and crossing them off. I think that it makes a good starting point to run with and make your own – paired with <a href="https://github.com/ianthehenry/zsh-autoquoter"><code>zsh-autoquoter</code></a>, it’s actually a surprisingly useful app!</p>
<hr/>
<p>If you put all of these projects together, I was writing code for almost half the time that I spent working on the book. Eight out of twenty weeks, plus some periods where I was doing both at once.</p>
<p>I didn’t really budget for that going into this. I thought that I’d improve Judge, and I thought that I’d write an argument parser. But I thought that writing an argument parser would be <em>way easier</em> than it actually was. And I thought that I’d just talk about Bauble – it never occurred to me that I’d write <em>another</em> art playground just because Bauble was <em>too easy</em>.</p>
<p>So that’s the story of writing the book. Or really, everything <em>but</em> writing the book. All the other things. The writing itself isn’t that interesting. I wrote it in Markdown, in Sublime Text, which is my favorite editor for writing long-form prose. I have nothing interesting to say about that part.</p>
<p>Two new versions of Janet came out while I was writing the book, and I did have to go back and update the chapters on debugging and native modules to keep up with changes to the language. I plan on keeping the book up to date with the latest Janet release – we’ll see how long I can keep that up.</p>
<hr/>
<p>I haven’t done much to promote the book yet. I <a href="https://news.ycombinator.com/item?id=35386405">submitted it to Hacker News</a>, and I <a href="https://lobste.rs/s/duwkz7">submitted it to Lobsters</a>, and I wrote <a href="https://twitter.com/ianthehenry/status/1641797578739306499">a very half-hearted tweet about it</a>. The reception was pretty much as good as I could have hoped for: it was on the Hacker News front page all day, and even held the number one spot for a while.</p>
<p>What does that actually mean? Well, according my Nginx access logs, I got:</p>
<ul>
<li>30,025 unique visitors on Friday</li>
<li>9,568 unique visitors on Saturday</li>
<li>3,777 unique visitors on Sunday</li>
</ul>
<p>Those numbers don’t mean very much, though. Those are just people who clicked on a link – the number of people who actually <em>read</em> the book is much, much smaller.</p>
<p>I don’t actually know how much smaller exactly, because I don’t have any client-side behavior-tracking analytics on the site. But I can sort of try to guess, by looking at my access logs. It seems like retention is not great:</p>
<ul>
<li>Chapter One had 22% as many visitors as the home page.</li>
<li>Chapter Two had 20% as many visitors as Chapter One.</li>
<li>Chapter Three had 69% as many visitors as Chapter Two.</li>
<li>Chapters Four and Nine, “<a href="https://janet.guide/pegular-expressions/">Pegular Expressions</a>” and “<a href="https://janet.guide/xenofunctions/">Xenofunctions</a>,” had more visitors than Chapter Three.</li>
</ul>
<p>I’m guessing that last bit is because people clicked on those chapters to see what they were about, which just goes to show that unique visitor count is not a very dependable metric.</p>
<p>My best attempt at answering the question “how many people are actually reading the book” is 387, as of the end of the launch weekend. So far 387 unique IP addresses have loaded five or more distinct chapters, which is probably a decent proxy for the metric I care about.</p>
<p>I really had no expectations for what these numbers would be before I launched the book. It’s a big time commitment to read a weird book about a programming language you’ve barely heard of, and 387 seems simultaneously low (compared to, say, any blog post) and high (I don’t think <em>I’ve</em> ever read a book off a HN link). But it’s more than zero!</p>
<p>Alright, I think that’s enough. I’ll close with some fun facts:</p>
<ul>
<li>
<p>The Janet language is named after an immortal being in <a href="https://en.wikipedia.org/wiki/The_Good_Place"><em>The Good Place</em></a> who helps mortals navigate the afterlife, hence the title.</p>
</li>
<li>
<p>The chapter with the fewest visits is currently “Testing and Debugging,” despite being the third-to-last chapter. This does not surprise me at all, but I think it’s a shame: the last three chapters are by far the most interesting in the book, and the style of testing described in that chapter is one of the biggest productivity upgrades that I have personally experienced in my engineering career.</p>
</li>
<li>
<p>So far I’ve received 494 reports from the built-in repl reporting feature. Most of these were of the “hey nice book” or “testing” variety, but I’ve gotten several dozen typo reports, clarification requests, or otherwise useful comments through it as well.</p>
</li>
<li>
<p>The most interesting report was just “you should listen to this song: <a href="https://www.youtube.com/watch?v=46i3LbIbbhI">https://www.youtube.com/watch?v=46i3LbIbbhI</a>.” No context, no explanation, and I have no way to reply for clarification. But… thanks! It’s a good song. I’m into it.</p>
</li>
<li>
<p>A few people asked me questions without including any kind of contact info, so I have no way to answer them. I hope that they found peace, wherever they are. I’m not ignoring you. I just… I only implemented an extremely primitive one-way feedback function.</p>
</li>
<li>
<p>I’m going to plug the book one last time.</p>
</li>
</ul>
<p>With feeling: <em><a href="https://janet.guide/">Janet for Mortals</a>!</em> Out now! The first infinity visitors get their copy for free!</p></div>
</article></div>
  </body>
</html>
