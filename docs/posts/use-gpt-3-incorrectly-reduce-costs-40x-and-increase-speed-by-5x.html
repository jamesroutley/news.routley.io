<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.buildt.ai/blog/incorrectusage">Original</a>
    <h1>Use GPT-3 incorrectly: reduce costs 40x and increase speed by 5x</h1>
    
    <div id="readability-page-1" class="page"><div id="siteWrapper">
      
        
      

      













      <main id="page" role="main">
        
          <article data-page-sections="63daf57772bc814cc05cac92" id="sections">
  
  
    
    


  


<section data-test="page-section" data-section-theme="" data-section-id="63daf57772bc814cc05cac94" data-controller="SectionWrapperController" data-current-styles="{
&#34;imageOverlayOpacity&#34;: 0.15,
&#34;backgroundWidth&#34;: &#34;background-width--full-bleed&#34;,
&#34;sectionHeight&#34;: &#34;section-height--medium&#34;,
&#34;horizontalAlignment&#34;: &#34;horizontal-alignment--center&#34;,
&#34;verticalAlignment&#34;: &#34;vertical-alignment--middle&#34;,
&#34;contentWidth&#34;: &#34;content-width--wide&#34;,
&#34;sectionAnimation&#34;: &#34;none&#34;,
&#34;backgroundMode&#34;: &#34;image&#34;
}" data-current-context="{
&#34;video&#34;: {
&#34;playbackSpeed&#34;: 0.5,
&#34;filter&#34;: 1,
&#34;filterStrength&#34;: 0,
&#34;zoom&#34;: 0,
&#34;videoSourceProvider&#34;: &#34;none&#34;
},
&#34;backgroundImageId&#34;: null,
&#34;backgroundMediaEffect&#34;: null,
&#34;divider&#34;: null,
&#34;typeName&#34;: &#34;blog-basic-grid&#34;
}" data-animation="none">
  
  
  <div>
    <div>
      
      
      
      
      
      
      <div data-content-field="main-content" data-item-id="">
  <article id="article-">
  
    <div>
      

      <div>
        <div><div data-layout-label="Post Body" data-type="item" id="item-63e17cf1ff2cc8787d0aabc1"><div><div><div data-block-type="2" id="block-e28f46e8e051af38b295"><div>

<p>We’ve been using the OpenAI foundational models for a while now at Buildt, they are amazingly powerful and this has been well documented across the internet, particularly with the advent of ChatGPT which has garnered 100x more attention than GPT-3 did before it. However with these models, and their applications to our problem: codebase search, understanding and augmentation; we found an obvious barrier: latency and cost. The larger models (particularly the <code>davinci</code> family) obviously produce the highest quality outputs, but are the slowest and most expensive to run.</p><p>For a good search experience you need speed, this is clear when you see Google taking 100s of milliseconds to index millions of webpages, and the story is the same for codebase search. We found that one of the largest time draws on a single search was the LLM layer producing an output (we use LLMs to augment our search to allow you to search for what your code <em>is</em> rather than what it does, e.g. ‘find me my slowest recursive functions’). According to Alex Gravely, one of the creators of Github’s Copilot, there is a 1% drop in completions for every additional 10ms of latency. This logic applies to search too so it was an immediate priority to move away from large models like <code>davinci</code> to smaller ones like <code>ada</code> and <code>babbage</code>.</p>


</div></div><div data-block-type="5" id="block-yui_3_17_2_1_1675731049143_6405"><div>
































  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-src="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/524e8bd7-2fcf-4018-9943-e703aa4f3245/comparison.png" data-image="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/524e8bd7-2fcf-4018-9943-e703aa4f3245/comparison.png" data-image-dimensions="2000x831" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="63e1a14d0c65f62955007d14" data-type="image"/>
                
            </p>
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1675731049143_6748"><p>Our solution is simple, generate a moderately sized corpus of completions made by davinci for a given task, and fine-tune a model like babbage to do the same task. If done correctly you can get near-identical completions (or at least 90% similarity) at a <strong>40x </strong>lower price and around 4-5x better latency. You can go one-better than this, if you’re willing to invest a little time, you can introduce a human into the loop too: we recently did this to fine-tune a babbage model to competently identify characteristics in code, so I got ChatGPT to create me a basic web UI to allow us to easily review and improve the identification which davinci had carried out; fundamentally you’re never going to get like-for-like performance out of a smaller model so making the completions better than the model you’re trying to mimic means you’ll at least be closer when the training is complete.</p></div><div data-block-type="5" id="block-yui_3_17_2_1_1675731049143_8751"><div>
































  

    
  
    <div data-test="image-block-inline-outer-wrapper">

      

      
        <figure>
          
        
        

        
          
            
          <div data-animation-role="image">
            <p><img data-src="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/1675731178051-XVRJGLGEOZ9W40TIP297/chat-gpt.jpeg" data-image="https://images.squarespace-cdn.com/content/v1/63dac39a0ea2353d0e132a36/1675731178051-XVRJGLGEOZ9W40TIP297/chat-gpt.jpeg" data-image-dimensions="2644x3024" data-image-focal-point="0.5,0.5" alt="" data-load="false" data-image-id="63e1a19427113231ca7f1707" data-type="image"/>
                
            </p>
          </div>
        
          
        

        
      
        </figure>
      

    </div>
  


  


</div></div><div data-block-type="2" id="block-yui_3_17_2_1_1675731049143_9671"><div>

<p>One of the questions I get the most about this technique is: how many examples do I need? The answer I’m afraid is ‘it depends’. As a rule of thumb, if you’re just trying to standardise the format of a prosaic output then you can get away with a couple hundred examples, if you’re doing logical reasoning, then you’re going to need at least 1000, and if you’re doing DSL work then multiple thousands. These sizes can often be a hurdle, but with the approach of using a larger model to produce the synthetic dataset it suddenly becomes a lot more manageable, particularly as those models get better.</p><p>There are many use cases for this approach; if you have a prompt which does the same job over and over, then you may as well use this technique to speed it up and make it cheaper. I’ve been asked about maintenance of this approach, particularly regarding what happens if the structure of the output you want changes. We built an internal finetuning pipeline which automates this entire process, you have your underlying <code>davinci-003</code> prompt which we then use to generate <strong><em>n</em></strong> synthetic examples, which you then format and then pass into the OpenAI finetune API which will spit out a fine-tuned model. This way it’s a one-click operation to update a fine-tuned model if you want to change the output of your prompt.</p><p>I’m always happy to chat about this subject, you can find me on Twitter <a href="https://twitter.com/AlistairPullen">@AlistairPullen</a> and all of what I’ve described above is in our code search tool Buildt which is available on the VSCode extension marketplace here: <a href="https://bit.ly/buildtvscode">https://bit.ly/buildtvscode</a></p>


</div></div></div></div></div></div>

        

        
        
          
        
      </div>

      
    </div>
  
</article>

</div>
    </div>
  </div>
  
</section>

  
</article>


          
            
              

            
          
        
      </main>
      

      
        
      
    </div></div>
  </body>
</html>
