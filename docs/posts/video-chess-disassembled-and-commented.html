<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nanochess.org/video_chess.html">Original</a>
    <h1>Video Chess disassembled and commented</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><img src="https://nanochess.org/img/video_chess_corner.png" width="25%"/></p>
<p>
    Since I discovered Video Chess for the Atari 2600, I found it pretty impressive. However, I believed the game implemented extra RAM memory, but more recently I discovered it worked using only the 128 bytes of memory available, and with a 4K ROM cartridge. That&#39;s an impressive achievement for such a small game console, also the rumor of a bug triggered me to reverse engineer this game to see how it works.
</p>
<p>
    Video Chess was developed by Larry Wagner and Bob Whitehead, and released by Atari in 1979. Although the original game is greater than 4K and a bank-switching PCB was created, the final released game was optimized to use only a 4K ROM cartridge.
</p>
<p>
    Video Chess also has the distinction of displaying eight different objects on a screen row using a technique known as <i>Venetian Blinds</i>, where the odd row of the screen would show four chesspieces, and the even row of the screen would show other four chesspieces. This technique allows the Atari 2600 to exceed its own limit of 3 figures per screen row. I won&#39;t discuss this technique as it is a video display trick, and in this article I&#39;ll concentrate in the AI (Artificial Intelligence) code.
</p>
<p><i>Disclaimer: Video Chess is property of their respective owners, and the disassembled code and comments authored by myself are purely for historical and educative purposes.</i>
</p>
<div><p><img src="https://nanochess.org/img/video_chess.png" width="50%"/></p></div>
<h2>Reverse engineering (1st day)</h2>
<p>
    I&#39;ve used the <a href="https://stella-emu.github.io/">Stella emulator</a> to get a preliminary disassembly of Video Chess. It was a great help to start analyzing it, and I&#39;ve documented each line of assembler code as I passed over the instructions.
</p>
<p>
    Let us remember the Atari 2600 uses the 6507 processor (a reduced pin equivalent of the 6502 processor). The execution of Video Chess starts at the address $f000.
</p>
<p>
    The first thing I found was the representation of the pieces on the chessboard. It was relatively easy as it is the second thing the game does on booting (the first thing is resetting the internal 128 bytes of RAM).
</p>
<p>
    Atari&#39;s Video Chess uses this representation for the pieces on the chessboard:
</p>
<ul>
    <li>$06 = Pawn (3 points)</li>
    <li>$05 = Rook (15 points)</li>
    <li>$04 = Knight (9 points)</li>
    <li>$03 = Bishop (9 points)</li>
    <li>$02 = Queen (27 points)</li>
    <li>$01 = King (66 points)</li>
    <li>Bit 3 = Side (0=Black, 1=White)</li>
</ul>
<p>
    The chessboard itself is located at the addresses $80 to $bf (one byte for each square). It is common the idiom LDA $80,X to access a square, where X contains a value from 0 to 63 for the 64 squares on the chessboard. The contents of each square is located in the bits 3-0 of the byte, while the upper bits 7-4 are used to save other data in a clever way.
</p>

<table>
    <tbody><tr>
        <td>$80</td><td>$81</td>
        <td>$82</td><td>$83</td>
        <td>$84</td><td>$85</td>
        <td>$86</td><td>$87</td>
    </tr>
    <tr>
        <td>$88</td><td>$89</td>
        <td>$8a</td><td>$8b</td>
        <td>$8c</td><td>$8d</td>
        <td>$8e</td><td>$8f</td>
    </tr>
    <tr>
        <td>$90</td><td>$91</td>
        <td>$92</td><td>$93</td>
        <td>$94</td><td>$95</td>
        <td>$96</td><td>$97</td>
    </tr>
    <tr>
        <td>$98</td><td>$99</td>
        <td>$9a</td><td>$9b</td>
        <td>$9c</td><td>$9d</td>
        <td>$9e</td><td>$9f</td>
    </tr>
    <tr>
        <td>$a0</td><td>$a1</td>
        <td>$a2</td><td>$a3</td>
        <td>$a4</td><td>$a5</td>
        <td>$a6</td><td>$a7</td>
    </tr>
    <tr>
        <td>$a8</td><td>$a9</td>
        <td>$aa</td><td>$ab</td>
        <td>$ac</td><td>$ad</td>
        <td>$ae</td><td>$af</td>
    </tr>
    <tr>
        <td>$b0</td><td>$b1</td>
        <td>$b2</td><td>$b3</td>
        <td>$b4</td><td>$b5</td>
        <td>$b6</td><td>$b7</td>
    </tr>
    <tr>
        <td>$b8</td><td>$b9</td>
        <td>$ba</td><td>$bb</td>
        <td>$bc</td><td>$bd</td>
        <td>$be</td><td>$bf</td>
    </tr>
</tbody></table>
<p>RAM address for each chessboard square.</p>
<p>
    After this, I found the game reset buttons and level selection (variable $ea contains a value from 0 to 7), followed by the joystick movement handling and button press.
</p>
<p>
    The chessboard setup directed me to a piece of code looking for kings on the chessboard, and a distance calculation between the two kings, and between the center of the chessboard and the Atari&#39;s king.
</p>
<h2>A stack of movements (2nd day)</h2>
<p>
    I had a brief moment of confussion with the game level selection, instead it was the chessboard edit mode, as it incremented by one the content of the square to cycle each piece.
</p>
<p>
    After identifying this code, it was easy to uncover the routine doing a movement over the chessboard. Also I could uncover the way it saved the board state while analyzing each movement.
</p>
<p>
    Before doing each movement, the game saves the current chessboard state using a simulated stack located in the same addresses as the board:
</p>
<ul>
    <li>$80-$8c = Upper nibble contains bit 7 of ram_B4, and bits 5-4 contains the bits 5-4 of the source square number.</li>
    <li>$8d-$99 = Upper nibble contains the content of the source square.</li>
    <li>$9a-$a6 = Upper nibble contains the content of the target square.</li>
    <li>$a7-$b3 = Upper nibble contains the lower nibble of the source square number.</li>
    <li>$ef-$fb = Copy of the movement counter (ram_D8).</li>
    <li>$c0-$cc = Current movement score (without sign, so $7f is -1 and $81 is +1)</li>
    <li>$d4 = Source square number for current movement.</li>
    <li>$d5 = Target square number for current movement.</li>
    <li>$d6 = Current piece in evaluation ($01-$06).</li>
    <li>$d7 = Content of target square ($00-$0f).</li>
    <li>$d8 = Movement counter.</li>
    <li>$da = Current board score (incremental).</li>
    <li>$dc = Current score for kings distance.</li>
    <li>$e3 = Current side playing ($01 = Black, $ff = White).</li>
</ul>
<p>
    The Select button doesn&#39;t select directly the analysis depth, instead it refers to a table located at $fff5:
</p>
<ul>
    <li>Game 1 - $02</li>
    <li>Game 2 - $12</li>
    <li>Game 3 - $13</li>
    <li>Game 4 - $23</li>
    <li>Game 5 - $24</li>
    <li>Game 6 - $34</li>
    <li>Game 7 - $56</li>
    <li>Game 8 - $00</li>
</ul>    
<p>
    The lower nibble is saved at ram_D2 (maximum depth), and the upper nibble is saved at ram_D9 (full analysis depth). While ram_D0 contains the current analysis depth ($00 at start). 
</p>
<p>
    The next step was marking the code that scores movements. Video Chess is able to castle but only on the king side. The search doesn&#39;t consider castling on player&#39;s side, except to validate movements.
</p>
<p>
    Marking each discovered variable made the code to start looking more legible. I found a piece of code setting the current analysis square as 64 (an invalid origin square), and following the trail I discovered the $fa66 subroutine does the analysis of a chessboard.
</p>
<ul>
    <li>ram_D3 = Frame counter (low-byte).</li>
    <li>ram_F1 = Frame counter (high-byte).</li>
</ul>
<h2>No trees or nodes (3rd day)</h2>
<p>
    So far there is nothing like trees and nodes, although of course we can consider the stack as a tree with a single branch.
</p>
<p>
    Video Chess starts analyzing the board from the bottom-right corner, and once it finds an own piece, it saves the current state in the simulated stack, does the movement, and starts another board analysis with the opposite side (and very probably starting a recursive deeper analysis), once this is finished, it reverts the movement using the information on the stack, and continues where it was.
</p>
<p>
    Getting to discover how the cursor behaves with the chessboard was another challenge:
</p>
<ul>
    <li>ram_F3:
        <ul>
            <li>$00 - Cursor moving (static X on current position)</li>
            <li>$01 - Piece selected (static X on origin, blinking piece on current position)</li>
            <li>$80 - Piece moving (erased on origin, blinking piece on current position)</li>
            <li>$c0 - Does chessboard search (same as $80 but with counter in ram_F4 to blink first and then search)</li>
        </ul>
    </li>
    <li>ram_E5 = En passant state (origin square of en passant pawn) or $80 if invalid.</li>
</ul>
<p>
    Once I revealed enough code, I could discover some obscure code that handles castling validation just after calculating material for the chessboard. The bits come out easily:
</p>
<ul>
    <li>ram_82 = bit 6 = 1 = Black king moved.</li>
    <li>ram_83 = bit 6 = 1 = White king moved.</li>
    <li>ram_84 = bit 6 = 1 = Black queen-side rook moved.</li>
    <li>ram_85 = bit 6 = 1 = Black king-side rook moved.</li>
    <li>ram_86 = bit 6 = 1 = White queen-side rook moved.</li>
    <li>ram_87 = bit 6 = 1 = White king-side rook moved.</li>
    <li>ram_88 = bit 6 = 1 = Black unable to castle queen-side.</li>
    <li>ram_89 = bit 6 = 1 = Black unable to castle king-side.</li>
    <li>ram_8A = bit 6 = 1 = White unable to castle queen-side.</li>
    <li>ram_8B = bit 6 = 1 = White unable to castle king-side.</li>
</ul>
<p>
And finally I still couldn&#39;t understand how it entered the analysis phase until I revised the display code instruction by instruction, and in the same routine where it removed the cursor from the chessboard and read the joystick, it has a small check of ram_F3 bit 6 to jump into the board search code at $f574.
</p>
<p>
The board search code just keeps running, and it only updates the video background color with no attempt to keep the video synchronization.
</p>
<p>
The variable ram_F5 signals if the current move is valid or invalid. Video Chess continuously checks for valid movement as the player displaces the cursor over the chessboard.
</p>
<p>
The one thing that really makes difficult the reverse engineering of this game is the fact that memory bytes are reused as some paths of code are executed for display, but not when doing the &#34;thinking&#34;. For example, ram_CC is reused as a graphic byte, black material score, king to find, and temporary variable for square distance.
</p>
<p>
The movement generator was one of these special pieces of codes that works, but the understanding of how it works was pretty hard to achieve. The movement table contains all the possible offsets for a piece movement. For example, the queen can move in eight directions, and in each direction it can move seven squares, so the table has the following numbers for going to the left: $99, $98, $97, $96, $95, $94, $93, and $92.
</p>
<p>
However, the queen is defined as having 64 movements, because when it is finished exploring a &#34;ray&#34; it reduces the counter by a multiple of 8 (faster than a multiple of 7).
</p>
<p>
Also the displacements in the movement table are in BCD (Binary-Coded-Decimal) numbers, and before adding the displacement, it converts the square number (0-63) to a BCD number using this piece of code:
</p>
<pre><small>    lda ram_D4  ; 00xxxyyy
    and #$38    ; 00xxx000 extract row.
    adc ram_D4  ; 0xxx0yyy add row itself and combine with column.
</small></pre><p>
The same day I found the colors for the display:
</p><ul>
<li>ram_E1 = Color for background.</li>
<li>ram_E0 = Color for chessboard.</li>
<li>ram_DF = Color for white pieces.</li>
<li>ram_DE = Color for black pieces.</li>
</ul>
<h2>Where&#39;s the bug?</h2>
<p>
Level 6 and level 7 of Video Chess are infamous because people says that the Atari sometimes move two pieces at the same time. However, I couldn&#39;t find a screenshot or movement list that could prove this asseveration.
</p>
<p>
My first suspicion was the ram_EF stack as it can contain up to thirteen bytes of data covering $ef to $fb addresses, and this stack in particular contains the movement counter for the current chess piece.
</p>
<p>
Given the processor stack pointer starts at $ff, we only need a path in code that does three JSR instructions to overwrite the $fa and $fb addresses, or a path that does two JSR instructions and a PHA/PHP instruction to overwrite $fb.
</p>
<p>
Why this could cause a problem? Because when restoring a move, it depends on the content of the ram_EF stack to restore ram_D8 and in turn recreate the target square number to return the chess piece to its right place. A failure doing this would cause the chess piece to stay where it moved, essentially duplicating it on the chessboard.
</p>
<p>
The tree of calls however disrupted my &#34;smart&#34; thinking. There are no stack overruns:
</p>
<pre><small>
	Entry point
	Lf574
		<b>; Level 1 call</b>
			<b>; Level 2 call</b>
		jsr Lfa66
			jsr Lfb91
		jsr Lfb91
		jsr Lfbb6	; This call happens outside of analysis.
			php
				jsr Lfe9c
				jsr Lfe9c
			plp
			pha/pla
		jsr Lfd4d
		jsr Lfa95
			jsr Lfb91
			jsr Lfd4d
			jsr Lfb91
		jsr Lfe71
		jsr Lfe6f
		jsr Lfe9c
		jsr Lfd65
</small></pre>
<p>
    Also a research of the paths used to add movements to the stack doesn&#39;t reveal any simulated stack overflow. So unless I can come across a position that triggers the bug, it is currently only a legend. It could have been an electrical glitch, or a buggy RAM that created the legend.
</p>
<h2>Later analysis</h2>
<p>
Even when most of the code operation has been discovered, some later analysis still revealed the inner workings of other variables:
</p>
<ul>
<li>
ram_b4 bit 7 clear means to generate all the moves, set means to generate all the moves to empty squares.</li>
<li> 
ram_B7 bit 7 set means to only find pieces but don&#39;t generate a move, and setting it to zero means to find piece and generate the first move.</li>
<li>
ram_E2 bit 7 set means the game has just started, and bit 7 clear means it is in the middlegame. Bit 6 set means the white king is alone.</li>
<li>
    ram_E4 a count of half-moves made both by computer and player.
</li>
<li>
    ram_81 bit 6 signals white is not able to respond to black (stalemate) because on every move the white king is captured. It is used just before Lf99e, probably to avoid doing stalemate of an alone white king.
</li>
</ul>
<p>
    Finally, Lf9ab is in charge of doing alpha-beta cut to avoid researching movements that aren&#39;t improving the current depth and position.
</p>
<h2>Conclusion</h2>
<p>
    The board initialization pattern triggered a glitch in my mind because I was sure I saw something before. I went to my personal library to retrieve my copy of &#34;Sargon: A computer chess program&#34;, and I could confirm it: In the board initialization pattern, Video Chess has an amazingly similar instruction order in comparison to the Sargon chess program. Probably the author of Video Chess read the book, I only can think it was a kind of homage as there is no other similar code.
</p>
<div><p><img src="https://nanochess.org/img/sargon_source.jpg" width="50%"/></p></div>
<pre><small>	;
	; Chessboard setup
	;
    ldx     #$07                    ; X = $07 for eight columns.
Lf2b6
    lda     Lfef2,x                 ; Read corresponding piece.        
    sta     ram_80,x                ; Put in top of the board.        
    eor     #$08                    ; Switch side.
    sta     ram_B8,x                ; Put in bottom of the board.
    lda     #$8e                    ; Unmoved white pawn.        
    sta     ram_B0,x                ; Put at 2nd row.
    lda     #$46                    ; Unmoved black pawn.
    sta     ram_88,x                ; Put at 7th row.
    sty     ram_90,x                ; Clear square at 6th row.
    sty     ram_98,x                ; Clear square at 5th row. 
    sty     ram_A0,x                ; Clear square at 4th row.
    sty     ram_A8,x                ; Clear square at 3rd row.
    dex                             ; Count column.
    bpl     Lf2b6                   ; Jump if not negative.
</small></pre>
<p>Video Chess code for chessboard initialization.</p>
<p>
    Video Chess is pretty impressive by the fact it has a full-depth analysis, and a quiescense search if it detects a changing position (see LF71c).
</p>
<p>
    Also it has a king opposition score to try to corner the adversary king, and it is triggered by the detection of the white king alone (see LF7c1).</p>
<p>
    Furthermore, it detects when there is few material on board, and <i>increases</i> the analysis depth in a kind of interesting endgame enhancement (see just before Lf448).
</p>
<p>
    All these things make Video Chess an impressive <i>tour de force</i> for the year 1979.
</p>
<h2>Downloads</h2>
<ul>
    <li><a href="https://nanochess.org/archive/video_chess.asm">Disassembled and commented assembler code of Video Chess for Atari VCS/2600</a> (131.91 kb).</li>
</ul>
<p>The disassembled and commented source code for Video Chess can be re-assembled to a binary file equivalent to the original game. You need to use <a href="https://dasm-assembler.github.io/">dasm</a> with this command line:</p>
<pre><small>dasm video_chess.asm -ovideo_chess.bin -f3
</small></pre>
<h2>Related links</h2>
<ul>
<li><a href="https://forums.atariage.com/topic/138228-video-chess-level-7/">The thread that incited me to disassemble Video Chess</a>.</li>
<li>Interested on learning 6502 assembler and programming games for Atari 2600? Get my book <a href="https://www.lulu.com/spotlight/nanochess">Programming Games for Atari 2600</a>.</li>
</ul>
<p>Last modified: Jun/21/2023</p>
</div></div>
  </body>
</html>
