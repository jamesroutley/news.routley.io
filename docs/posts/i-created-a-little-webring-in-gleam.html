<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://erikarow.land/notes/gleam-webring">Original</a>
    <h1>I created a little webring in Gleam</h1>
    
    <div id="readability-page-1" class="page"><section id="I-created-a-little-webring-in-Gleam">

<p>Recently, my friends have been building cool web 1.0 features for their websites, such as <a href="https://proclamations.nebcorp-hias.com/sundries/hitman/">this hit counter</a>. 
Inspired by web 1.0, 
I decided to create a web ring for me and my friends.</p>
<section id="What-is-a-webring">
<h2>What is a webring?</h2>
<p>A webring is a way of adding discoverability for sites in the ring.</p>
<p>On a technical level, it’s a doubly linked list of websites<label for="fn1"></label><span><span>Diagram made with <a href="https://mermaid.live/">mermaid.live</a></span></span>:</p>
<p><img alt="webring example with three websites all pointing to each other" src="https://strudel.cc/webring.svg"/></p>
<p>Each website links to the next and previous website in the linked list, 
creating a “ring” of websites that are all connected.</p>
<p>In theory, it’s possible to literally link to the next site in the ring, but this quickly becomes impractical as member sites join or leave the ring. The solution is to write a little webring service:</p>
</section>
<section id="How-do-you-run-a-webring-service">
<h2>How do you run a webring service?</h2>
<p>Instead of having member sites link directly to each other, a webring service can handle routing each “next” and “previous” link to the appropriate place.</p>
<p>At its core, this service consists of three things:</p>
<ol>
<li>
A way to identify where someone accessing the service is in the ring.
</li>
<li>
A <code>/previous</code> endpoint to route people to the previous ring member.
</li>
<li>
A <code>/next</code> endpoint to route people to the next ring member.
</li>
</ol>
<p>The endpoints can be powered by a simple HTTP 303 “See Other” redirect<label for="fn2"></label><span><span>Read more about that <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections">here</a> on the MDN documentation.</span></span>, so the hard part is figuring out where you are in the ring and what next and previous member sites are.</p>
<section id="Where-are-you-ringing-from">
<h3>Where are you ringing from?</h3>
<p>I’ve seen a few different ways to keep track of which member site the webring is being accessed from<label for="fn3"></label><span><span>Another thing I considered was a <code>from=&lt;website&gt;</code> query parameter, but then I would have to worry about appropriately escaping web domains.</span></span>:</p>
<ul>
<li>
An integer member number
</li>
<li>
A short hash id
</li>
<li>
Emojis<label for="fn4"></label><span><span>Here’s a <a href="https://martymcgui.re/2023/04/26/bad-web-dev-ideas-emoji-as-ids-in-urls/">blog post</a> from the person who runs the Indieweb Ring about why Emoji IDs are problematic in practice.</span></span>
</li>
</ul>
<p>Of these, I decided to use short hash ids, unique to each member site. I chose to use a SHA256 hash of the members URL, converted to padded, URL-safe base64 with a known salt<label for="fn5"></label><span><span>Therefore, each member site only has to keep track of its own hash_id, and it’s designed not to change as members join or leave the ring.</span></span>:</p>
<pre><code>fn hash(string) {
  {string &lt;&gt; &#34;salty salt&#34;}
  |&gt; bit_array.from_string()
  |&gt; glesha.hash(glesha.Sha256)
  |&gt; bit_array.base64_url_encode(True)
  |&gt; string.slice(0, 16)
}
</code></pre>
<p>I’ll come back to how I used these hashes in a moment. First, we need to know who our neighbors in the ring are!</p>
</section>
<section id="Ringing-my-neighbors">
<h3>Ringing my neighbors</h3>
<p>Starting from a list of member URLs, how do I turn them into a ring?<label for="fn6"></label><span><span>It turns out that neither of the popular webrings that first come to my mind solve this problem.</span><span><a href="https://xn--sr8hvo.ws/">An Indieweb Webring</a> just picks a random link every time as detailed at the bottom of <a href="https://martymcgui.re/2023/04/26/bad-web-dev-ideas-emoji-as-ids-in-urls/">this blog post</a>.</span><span><a href="https://webring.xxiivv.com/">Devine’s webring</a> just links to the index. This is nice because it means you only need to have one symbol/link on your website instead of <code>previous/next</code> links.</span></span></p>
<p>One thing I considered was using Zippers<label for="fn7"></label><span><span>Thanks to my friend Hayleigh for suggesting I think about Zippers.</span></span>, a functional programming technique for traversing data structures such as lists and trees.<label for="fn8"></label><span><span>Sourceror, an AST manipulation library for Elixir uses Zippers, and has <a href="https://hexdocs.pm/sourceror/zippers.html">an excellent guide</a> to them.</span></span></p>
<p>However, I don’t care so much about traversing the list quickly, so much as finding the immediate neighbors of each member. This reminded me of the <a href="https://hexdocs.pm/gleam_stdlib/gleam/list.html#window"><code>list.window</code></a> function in the Gleam standard library.</p>
<p>In particular, this example looks close to what I need:</p>
<pre><code>window([1,2,3,4,5], 3)
// -&gt; [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
</code></pre>
<p>This function is missing the neighbors for <code>1</code> and <code>5</code>, but otherwise is doing what I need.
Looking at the implementation gives us this:</p>
<pre><code>fn do_window(
  acc: List(List(a)), 
  l: List(a), 
  n: Int
) -&gt; List(List(a)) {
  let window = take(l, n)

  case length(window) == n {
    True -&gt; 
      do_window([window, ..acc], drop(l, 1), n)
    False -&gt; acc
  }
}
</code></pre>
<p>This function is asking: “Starting at the current element, what are the next <code>n-1</code> elements after it?”
Returning the list if there aren’t enough elements. But I tack on the first few elements when <code>length(window) &lt; n</code> I’ll get what I need.
With some optimizations to avoid <code>length</code> (which is an <code>O(n)</code> check in Gleam’s Erlang target), I get:</p>
<pre><code>fn do_window(acc, l, original) {
  let window = list.take(l, 3)

  case window {
    [a, b, c, ..] -&gt;
      do_window(
        [
          Row(
            b, 
            hash(b), 
            previous: a, 
            next: c
          ), 
        ..acc
        ], 
        list.drop(l, 1), 
        original
      )
    ... // omitted
    [] -&gt; acc
  }
}
</code></pre>
<p>Since I’m already traversing the list, I go ahead and save the hash of each member while I’m there.</p>
<p>Now that I’ve computed all the neighbors, I can cache them into a Sqlite database. 
Member links are going to be read far more often than there will be changes in membership, so this caching is useful. 
It also allows us to index the field with the hash, giving us a faster than <code>O(n)</code> read time for links.</p>
</section>
<section id="Constellation">
<h3>Constellation</h3>
<p>All together I’ve separated this caching logic into its own project: <a href="https://git.kittencollective.com/erika/constellation">Constellation</a>.
This is just a webring for me and my friends, so I’m okay with manually running Constellation when I need to change membership.</p>
<p>Constellation reads from a <code>members.txt</code> that contains one member URL per line, computes the hashes and neighbors, and then creates a <code>members.db</code> which I can <code>rsync</code> to my server for use with the web service.</p>
<p>Now how does that web service work?</p>
</section>
</section>
<section id="A-Gleaming-Webring-Service">
<h2>A Gleaming Web(ring) Service</h2>
<p>Gleam’s web framework is <a href="https://hexdocs.pm/wisp/">Wisp</a> which proved quite capable for my little webring.</p>
<p>There are a number of examples in the Wisp repo. My webring is only a little more than a fancy router, so I started from the routing example.<label for="fn9"></label><span><span>Literally, you can see in <a href="https://git.kittencollective.com/erika/ring/commit/ba8d256143a7bb76e7ee7ef7a5e578cb5ca4212b">my second commit</a> that I forgot to change the readme.</span></span></p>
<p>Gleam doesn’t have any macros, which makes routing exactly pattern matching. Or as the comment in the example puts it:</p>
<blockquote>
<p>Wisp doesn’t have a special router abstraction, instead we recommend using
regular old pattern matching. This is faster than a router, is type safe,
and means you don’t have to learn or be limited by a special DSL.</p>
</blockquote>
<p>That gives my webring a router that looks like this<label for="fn10"></label><span><span>Since routing is just pattern matching, even complex web applications in Gleam use nested case statements or functions that contain fine grained pattern matching.</span></span>:</p>
<pre><code>pub fn handle_request(req: Request) -&gt; Response {
  use req &lt;- web.middleware(req)

  case wisp.path_segments(req) {
    [hash, &#34;previous&#34;] -&gt; handle_previous(hash)
    [hash, &#34;next&#34;] -&gt; handle_next(hash)

    _ -&gt; wisp.not_found()
  }
}
</code></pre>
<p><code>handle_previous</code> looks like this:</p>
<pre><code>fn handle_previous(hash) {
  let db_path = &#34;members.db&#34;
  use conn &lt;- sqlight.with_connection(db_path)

  let previous =
    sqlight.query(
      &#34;select previous from ring where hash = ?&#34;,
      on: conn,
      with: [sqlight.text(hash)],
      expecting: dynamic.element(0, dynamic.string),
    )

  case previous {
    Ok([previous_link]) -&gt; 
      wisp.redirect(previous_link)
    _ -&gt; wisp.not_found()
  }
}
</code></pre>
<p>There’s a lot going on in this function.</p>
<p>We have a <code>use</code> statement, which allows the function to close the database connection when it’s done.<label for="fn11"></label><span><span>Here’s the <a href="https://tour.gleam.run/advanced-features/use-sugar/">language tour</a> section on use sugar for more explanation.</span></span></p>
<p>Sqlite doesn’t know anything about Gleam types, so I use <code>sqlight.text</code> to let Sqlite know what type I’m passing in.</p>
<p>Gleam is statically typed, but we don’t know what type we’re going to get from the database<label for="fn12"></label><span><span>Especially with Sqlite, the authors of <a href="https://sqlite.org/flextypegood.html">The Advantages of Flexible Typing</a>.</span></span>. 
The <code>dynamic</code> module from the standard library allows us to 
write a simple parser to convert what the database returns into types that Gleam understands.<label for="fn13"></label><span><span>I <a href="https://git.kittencollective.com/erika/ring/commit/c7d629645c15798e0f4652eaddef22f41984b597">initially</a> wrote more boilerplate than I needed, but I realized that I could simplify the parsers.</span></span></p>
<p>Wisp has a built in function <a href="https://hexdocs.pm/wisp/wisp.html#redirect"><code>wisp.redirect</code></a> that handles the HTTP 303 redirects that I need.</p>
</section>
<section id="Up-And-Running">
<h2>Up And Running</h2>
<p>That’s it, after a similar <code>handle_next</code> function, I put up the service behind <a href="https://caddyserver.com/">Caddy</a> on a small server. If everything is working correctly, then it should be linked at the bottom of this article.<label for="fn14"></label><span><span>For Desktop users, it should also be under my intro blurb at the top-left of the article.</span></span></p>
<p>The source code for the web service is <a href="https://git.kittencollective.com/erika/ring">here</a>. Special thanks to Joe and Sara for inspiring me to write a webring. Here’s to making the internet a little cozier.</p>
</section>
<section id="Extra-Goodies">
<h2>Extra Goodies</h2>
<p>At this point in the explanation, the webring does everything it needs in order to be a <code>ring</code>, but we added a few extra features to make it shine:</p>
<section id="Random-Endpoint">
<h3>Random Endpoint</h3>
<p>Shortly after I got the webring up and running, I got a feature (and pull!) request to add a “random” feature.</p>
<p>Adding it to the router was simple:</p>
<pre><code>pub fn handle_request(req: Request) -&gt; Response {
  use req &lt;- web.middleware(req)

  case wisp.path_segments(req) {
    [] -&gt; home_page(req)

    [&#34;random&#34;] -&gt; handle_random() // One line!

    [hash, &#34;previous&#34;] -&gt; handle_previous(hash)
    [hash, &#34;next&#34;] -&gt; handle_next(hash)

    _ -&gt; wisp.not_found()
  }
}
</code></pre>
<p>And the <code>handle_random</code> function itself takes advantage of Sqlite’s <code>ORDER BY RANDOM()</code>:</p>
<pre><code>select next from ring order by random() limit 1
</code></pre>
<p>Otherwise the redirection works exactly the same as <code>handle_previous</code>.</p>
</section>
<section id="A-Lustrous-Home-Page">
<h3>A Lustrous Home Page</h3>
<p>I wanted to have something for people to see when they navigated to <a href="https://webring.club">https://webring.club</a>, the root domain of my webring.</p>
<p>Getting the members was a simple <code>select member from ring</code> SQL query:</p>
<pre><code>let db_path = &#34;members.db&#34;
use conn &lt;- sqlight.with_connection(db_path)
let members =
  sqlight.query(
    &#34;select member from ring order by member asc&#34;,
    on: conn,
    with: [],
    expecting: dynamic.element(0, dynamic.string),
  )
</code></pre>
<p>I chose to use <a href="https://hexdocs.pm/lustre/">Lustre</a> for html templating.<label for="fn15"></label><span><span>I wrote about Lustre for interactive frontend before in <a href="https://strudel.cc/notes/gleam-vite">Embedding Gleam in my blog with Vite</a>. Lustre also offers backend templating.</span></span> Lustre’s elements are just functions, so I can use them in a <code>list.map</code> over the members:</p>
<pre><code>let members =
  result.unwrap(members, [])
  |&gt; list.map(fn(member) {
    html.li(
      [], 
      [html.a(
          [attribute.href(member)], 
          [html.text(member)]
       )]
    )
  })

let html =
  html.body([], [
    html.h1(
      [], 
      [html.text(&#34;The Constellation Webring&#34;)]
    ),
    html.ul([], members),
  ])
  |&gt; element.to_document_string_builder()
</code></pre>
</section>
</section>
</section></div>
  </body>
</html>
