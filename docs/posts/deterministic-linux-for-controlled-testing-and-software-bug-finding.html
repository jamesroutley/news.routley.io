<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://developers.facebook.com/blog/post/2022/11/22/hermit-deterministic-linux-testing/">Original</a>
    <h1>Deterministic Linux for controlled testing and software bug-finding</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p>If you&#39;ve used emulators for older platforms, you probably experienced a level of precise control over software execution that we lack on contemporary platforms. For example, if you play 8-bit video games emulated on your modern console, you are able to suspend and rewind gameplay, and when you resume, that incoming creature or projectile will predictably appear in the same spot because any randomness plays out deterministically within the emulator.</p><p>Yet, as a software engineer, when your multithreaded service crashes under transient conditions, or when your test is flaky, you don&#39;t have these luxuries. Everything the processor and operating system contributes to your program&#39;s execution—thread scheduling, random numbers, virtual memory addresses, unique identifiers—constitutes an unrepeatable, unique set of implicit inputs. Standard test-driven methodologies control for <i>explicit</i> program inputs, but they don&#39;t attempt to control these implicit ones.</p><p>Since 2020, our team within <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fengineering.fb.com%2Fcategory%2Fdeveloper-tools%2F&amp;h=AT2xMnlVZ9RVK4r644XZycs5T51favy9koayJ1TgqC1PuBHpTABTAfvP4TZTOQh4j5RvoLGs2J0FmkysEqg4XmIxV16z2R8_2exKonu2Rd3DkvTdUvcvcW5a6eaerlilntOhpBeM8DVfbqvT" rel="nofollow" target="_blank" data-lynx-mode="hover">DevInfra</a> has worked to tackle this hard problem at its root: the pervasive nondeterminism in the interface between applications and the operating system. We&#39;ve built the first practical <i>deterministic operating system </i>called Hermit (see endnote on prior art). Hermit is not a new kernel—instead it&#39;s an emulation layer on top of the Linux kernel. In the same way that <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.winehq.org%2F&amp;h=AT0FoEkIhEJhrbkTlSNpp-Ft9Z9xpX0wEROI6MIPpQzrBK_MCwlWQdvpXWvA343C_9eGPS2_pJJqIbhz4BsxQwAE0GUl6rgebNh9cV3JtiF1jJ9jExaXZHRmrr51uCCXOXQu1S12tB2QUyoS" rel="nofollow" target="_blank" data-lynx-mode="hover">Wine</a> translates Windows system calls to POSIX ones, Hermit intercepts system calls and translates them from the Deterministic Linux abstraction to the underlying vanilla Linux OS. </p><p>Details on sources of and solutions for nondeterminism can be found in our paper, “<a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F3373376.3378519&amp;h=AT0fabM24A9ZkBQJ-jJD-ZlkgHdM5cA_35gVsBh3VQTTN7Aq-BwRRUEBZKCmo3jHBTB4rl6MrWML0JzU9rmPx3qxnL5zd9yle9xDmdYarmortDpxXQylUlB3etB3dfR-ZxoQIRJRkJAsxL3x" rel="nofollow" target="_blank" data-lynx-mode="hover">Reproducible Containers,” published in ASPLOS &#39;20</a>, which showcased an earlier version of our system. We&#39;ve open-sourced the new <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Ffacebookexperimental%2Fhermit&amp;h=AT2gWMxtFnvP2axbxDl8y9BqZw0vhUa0I2cPGLbv3TFluTk5izXa4OkwH2frkZUcDiiGTK2i7tresfyfJS6L9-y7ywThd8t09WheQbPyUgDOVEGl3CVF_q7zcrmNOlCU1t0iy5bEf0SUFvbP" rel="nofollow" target="_blank" data-lynx-mode="hover">Hermit system</a> and the underlying program-instrumentation <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Ffacebookexperimental%2Freverie&amp;h=AT1uSxNP2RZodySwLYPRaGhz3yEDB9c1UHyZVAr2wfV9UXDTmVz_QsyHelzLN-HlVnC76CPm3EXmPtrr6U8iN46A2SFatczg4Q6ms_F0KX9neCEmfFEC3-Q2vUXIHBFsLh8T3VM1Ui3-ABYR" rel="nofollow" target="_blank" data-lynx-mode="hover">framework named Reverie</a>.</p><h2 id="u_0_3u_ef">Example Applications</h2><p>Now we explore some of the applications Hermit can be used for, and the role [non]determinism plays. In the next section, we go deeper into how Hermit works.</p><h3 id="u_0_3w_DB">Flaky tests</h3><p>First, flaky tests. They&#39;re a problem for every company. <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Ftesting.googleblog.com%2F2016%2F05%2Fflaky-tests-at-google-and-how-we.html&amp;h=AT0CUs8X2wBNA9rwgT2aozulUZzQjbaBzct3_YIINmoUFH4WY--4QS7KvqZjWUc4yK9bhTaAWsIcftP9TF5Za1BndNGTPitn77txvHIajl9i-kzaG7UKGoz9tX-KBNiR5mTIaXBINbqa_0VF" rel="nofollow" target="_blank" data-lynx-mode="hover">Google</a>, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdl.acm.org%2Fdoi%2Fabs%2F10.1145%2F3377813.3381370&amp;h=AT2VSaFm8NmVHoMtxy5K2_dO8CHf02dW7hrxZTMOPPGZbeAAUKIbg8EDghDHzuqPN0c6EUK6GbP4oNN39icoDFeKBKRXgace8vShQ7KLDzGT8CLRqwcsUHRMs2ZqWqdMGRYffJeSkygOxwZ4" rel="nofollow" target="_blank" data-lynx-mode="hover">Apple</a>, <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fpublication%2Fempirically-detecting-false-test-alarms-using-association-rules%2F&amp;h=AT1KFMKqHq2Sc465LQdXZgE84xGedXjo3e1xIWrTm-gDVdjZuw4waw7zmOisXlHMvqbd48ClftKIje_zuDuTccIFzED4mTf1-v2BHFv5sC0-kW6DgjmdqdXBwC2cIXNUxbwLGhdZxA4eQb0g" rel="nofollow" target="_blank" data-lynx-mode="hover">Microsoft</a> and <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fengineering.fb.com%2F2020%2F12%2F10%2Fdeveloper-tools%2Fprobabilistic-flakiness%2F&amp;h=AT1Y6F16PraRrm8E4w34ucHXZo0ZY-RHUfBmVEyr-Ny9Nw7BcUuzbk8ZmotcpsnUlGwTdeaaIOQZp-p_IM_O8QIz7VQRi8rj8jJYs0SGHZ1B9kp49eDDffgLd3JRxxZmJXNvm5OA3KiYMo83" rel="nofollow" target="_blank" data-lynx-mode="hover">Meta</a> have all published their experiences with flaky tests at scale. Fundamentally, the cause of flakiness is that test functions don&#39;t <i>really</i> have the signatures that appear in the source code. An engineer might think they&#39;re testing a function from a certain input type to output type, for example:</p><pre>test : Fn(Input) -&gt; Output;
</pre><p>Indeed, unless we&#39;re doing <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2FBurntSushi%2Fquickcheck&amp;h=AT2tpfu_tfE3XTQipZuAehJHiccsnwAfgajOrluFBrXOdFYDB9cHGR95pGusPo1h78XJoUFSSDU9k-zy8Uiw9SlhdNZYDNYw5dp76afYQzDzfiv2BOK3WBgH5papau0ymChsPv7WD0R4bQ_W" rel="nofollow" target="_blank" data-lynx-mode="hover">property-based testing</a>, then for unit tests it’s even simpler. (The input is empty, and the output is boolean.) Unfortunately, in reality, most tests may be affected by system conditions and even external network interactions, so test functions have a <i>true</i> signature more like the following:</p><pre>test : Fn(Input, ThreadSchedule, RNG, NetworkResponses) -&gt; Output;
</pre><p>The problem is that most of these parameters are outside of engineers’ control. The test harness and test code, running on a host machine, is at the mercy of the operating system and any external services.</p><p><img src="https://scontent-sjc3-1.xx.fbcdn.net/v/t39.2365-6/315534985_806341527141231_5402062711219706046_n.png?_nc_cat=100&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=MYMnJ98YxggAX90NCQz&amp;_nc_ht=scontent-sjc3-1.xx&amp;oh=00_AfA3kQNkcbgorliQLflzRNdr_eqqdF8vPpnj7hpJCjmCJA&amp;oe=63834379" alt=""/></p><p><i>Caption: Irreproducible, implicit inputs from the operating system can affect test outcomes.</i></p><p>That&#39;s where Hermit comes in. Hermit’s job is to create a containerized software environment where every one of the implicit inputs (pictured above) is a repeatable function of the container state or the container configuration, including command line flags. For example, when the application requests the time, we provide a deterministic time that is a function of program progress only. When an application thread blocks on I/O, it resumes at a deterministic point relative to other threads.</p><p>Hermit’s guarantee is that any program run by Hermit (without external networking) runs an identical execution—irrespective of the time and place it is run—yielding an identical stream of instructions and complete memory states at the time of each instruction. This means if you run your network-free regression test under Hermit, it is guaranteed not to be flaky:</p><pre>hermit run ./testprog
</pre><p>Further, Hermit allows us to not merely explore a <i>single</i> repeatable execution of a program, but to systematically navigate the landscape of possible executions. Let’s look at how to control one specific feature: pseudo-random number generation (PRNG). Of course, for determinism, when the application requests random bytes from the operating system, we provide repeatable pseudo-random ones. To run a program with <i>different</i> PRNG seeds, we simply use a different <code>--rng-seed</code> parameter:</p><pre>hermit run --rng-seed=1 prog
hermit run --rng-seed=2 prog
</pre><p>In this case, it doesn&#39;t matter what language <code>prog</code> is written in, or what random number generator library it uses, it must ultimately ask the operating system for <i>entropy</i>, at which point it will receive repeatable pseudo-random inputs.</p><p>It is the same for thread scheduling: Hermit takes a command line seed to control thread interleaving. Hermit is unique in being able to reproducibly generate schedules for full Linux programs, not merely record ones that happen in nature. It generates schedules via established <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F2858651&amp;h=AT2epeZwnu5YtOchJg3eRmX6PgZMSrxmpma0v4NxDitFJkGmulJcWQr3_1rMSl7vJGNEbE8n5I7pJIKfzIxvD5d0ly8cjF7m5rqGmAtuz5JvEKKcLvtGKou-_ij_MLr4SZpyyLuM90vpA1C5" rel="nofollow" target="_blank" data-lynx-mode="hover">randomized strategies</a>, designed to exercise concurrency bugs. Alternatively, full thread schedules can be passed explicitly in as input files, which can be derived by capturing and modifying a schedule from a previous run. We&#39;ll return to this in the next section.</p><p>There is an upshot to making all these implicit influences explicit. Engineers dealing with flaky programs can steer execution as they desire, to achieve the following goals:</p><ul><li><b>Regression testing:</b> Use settings that keep the test passing.</li><li><b>Stress testing:</b> Randomize settings to find bugs more effectively.</li><li><b>Diagnosis:</b> Vary inputs systematically to find which implicit inputs cause flakiness.</li></ul><h3 id="u_0_3y_5f">Pinpointing a general class of concurrency bugs </h3><p>As mentioned above, we can vary inputs to find what triggers a failure, and we can control schedules explicitly. Hermit builds on these basic capabilities to analyze a concurrency bug and pinpoint the root cause. First, Hermit searches through random schedules, similar to rr chaos mode. Once Hermit finds failing and passing schedules, it can analyze the schedules further to identify pairs of <i>critical events</i> that run in parallel and where flipping the order of those events causes the program to fail. These bugs are sometimes called ordering violations or race conditions (including but not limited to data races).</p><p>Many engineers use race detectors such as <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fclang.llvm.org%2Fdocs%2FThreadSanitizer.html&amp;h=AT2xDIC62n-UAH0nk_w2N7QVA0KxiJfV7f1OBCjmxaQs1rpDSyCKIL0z3GHNarPhop9NQ3G0rgn72a27_twVQbb4vlTeOD_JiaXStJr_uGK49t_6SH0wD6tEXBeKiDBJtLBdzoFHyWPdYmxG" rel="nofollow" target="_blank" data-lynx-mode="hover">ThreadSanitizer</a> or <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgo.dev%2Fdoc%2Farticles%2Frace_detector&amp;h=AT2nUE4uXoee5PaTdbDkq1danqSCOvgPpHlrqPW48AHFooU7eyX_7p8vAQ62-93Gdkql8Y2KUiwPYss2ibgKUtQ_O8P5zhcp74exBjUvN35PdUgtFezGemoBF8qzFOLZaM70SljhWvO3-Wyb" rel="nofollow" target="_blank" data-lynx-mode="hover">go run -race</a>. Normally, however, a race detector requires compile-time support, is language-specific and works only to detect <i>data races</i>, specifically data races on memory (not files, pipes, etc.). What if, instead, we have a race between a client program written in Python, connecting to a server written in C++, where the client connects before the server has bound the socket? This nondeterministic failure is an instance of the &#34;Async Await&#34; flakiness category, as defined by an <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fmir.cs.illinois.edu%2Flamyaa%2Fpublications%2Ffse14.pdf&amp;h=AT1jWyt6TwXno3RfGCwfH8weKokHecQHSXUCbWpuZxrPFXEWRXStKJMruq6Sfx7CEMSS4qtMG3iitPJ9yXPpe_KIEo90GGhEHlEIO2nv-FMwp7QYgxso4ikdhiVrrWbsOUKEwUoSxQARyr4m" rel="nofollow" target="_blank" data-lynx-mode="hover">empirical analysis and classification of flaky tests</a>.</p><p>By building on a deterministic operating system abstraction, we can explicitly vary the schedule to empirically find those critical events and print their stack traces. We start by using randomized scheduling approaches to generate a cloud of samples within the space of possible schedules:</p><p><img src="https://scontent-sjc3-1.xx.fbcdn.net/v/t39.2365-6/316082783_1852323795102953_5982282201560813297_n.png?_nc_cat=101&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=G0HkEFOwEmkAX8tmF_U&amp;_nc_ht=scontent-sjc3-1.xx&amp;oh=00_AfC7_jIarxrhk-96p3RXjGpTh2CSjQ4B6DmKhzP2axaoew&amp;oe=638154E8" alt=""/></p><p><i>Caption: A visualization of the (exponential) space of possible thread schedules, generated by different Hermit seeds. With the space organized by edit distance, the closest red and green dots correspond to the minimum edit distance observed between a passing and failing schedule.</i></p><p>We can organize this space by treating the thread schedules literally as strings, representing sequential scheduling histories. For example, with two threads A &amp; B, &#34;AABBA&#34; could be an event history. The distance between points is the edit distance between strings (actually, a weighted edit distance preferring swaps over insertion or deletion). We can then take the closest pair of passing and failing schedules and then study it further. In particular, we can bisect between those schedules, following the minimum edit distance path between them, as visualized below.</p><p><img src="https://scontent-sjc3-1.xx.fbcdn.net/v/t39.2365-6/315836201_1187870138808563_4373368812059769872_n.png?_nc_cat=105&amp;ccb=1-7&amp;_nc_sid=ad8a9d&amp;_nc_ohc=W07xViC92xsAX-zgDyF&amp;_nc_ht=scontent-sjc3-1.xx&amp;oh=00_AfCeWExXR39e6u5BCpkFxka1L_3ugFAA_cMtah3HvqzXZA&amp;oe=63828491" alt=""/></p><p><i>Caption: A binary search between passing and failing schedules, probing points in between until it finds adjacent schedules that differ by a single transposition, a <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDamerau%25E2%2580%2593Levenshtein_distance&amp;h=AT060S-UCNOpOfsodBwMq-AB05j_JkI6phO09RBzYAmB0oxkbcWG_Dg0dlmNURvWrJCviHB5Cx2Qqx14emznFaxq9IhGhyKDZSTju9_PiiidzAwHWywjQMtXcogrdlgC0CHH4cbU2mzEmIVR" rel="nofollow" target="_blank" data-lynx-mode="hover">Damerau-Levenshtein distance</a> of one.</i></p><p>At this point, we&#39;ve reduced the bug to <i>adjacent</i> events in the thread schedule, where flipping their order makes the difference between passing and failing. We report the stack traces of these events as a cause of flakiness. (Indeed, it is only <i>a</i> single cause because there <i>may</i> be others if flakiness is overdetermined.)</p><h2 id="u_0_40_GM">Challenges and how it works</h2><p>Here, we&#39;ll cover a bit about how Hermit works, emphasizing pieces that are different from our <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdl.acm.org%2Fdoi%2F10.1145%2F3373376.3378519&amp;h=AT0H0mYZ7AO88quFlx124Erez3da0Kj6gLjmoMqfvppiKIlvhjkBeAmbI7Bkqyr3kftOHEvmiTZkkKOnYbhzmaV2qoS7nc4I-qEtOLHuOS1_xnD4P2bFp471I7FFjiMgeE0ETjwyzWTNZ5SX" rel="nofollow" target="_blank" data-lynx-mode="hover">prototype</a> from ASPLOS ’20. The basic scenario is the same, which is that we set out to build a <i>user space</i> determinization layer, not allowing ourselves the liberty of modifying the Linux kernel or using any privileged instructions.</p><h3 id="u_0_42_Yt">Challenge 1: Interposing between operating system and application</h3><p>Unfortunately, on Linux there is not a standard, efficient, complete method to interpose between user-space applications and the operating system. So we&#39;ve built a completely <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Ffacebookexperimental%2Freverie&amp;h=AT1JRal6hVxbviqd_6w0tGgnH3f129x97qGs95E6tKQOpiLYAEAjiWS8oyZxmrGQurip5tjN5eHTD9YjVTKLT6FNWpEMlHPnPH8VTnUm5EqlkL4djtOQJRutaU-LSfUzb1kSose4netL2CMA" rel="nofollow" target="_blank" data-lynx-mode="hover">new program sandboxing framework in Rust</a>, called Reverie, that abstracts away the backend—how program sandboxing is implemented. Reverie provides a high-level Rust API to register <i>handlers</i>: callbacks on the desired events. The user writes a Reverie <i>tool</i> that observes guest events and maintains its own state. </p><p>Reverie is not just for <i>observing</i> events. When you write a Reverie handler, you are writing a <b>snippet of operating system code</b>. You intercept a syscall, and you <i>become</i> the operating system, updating the guest and tool state as you like, injecting zero or more system calls to the underlying Linux operating system and finally returning control to the guest. These handlers are async, and they run on the popular Rust <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Ftokio.rs%2F&amp;h=AT2uQZjIW6aOQinw8ndpaCIbZIev_ps3xrjggmo5HKO-XgveYoOF88nV6eqPnXdvWtHT_PjAidkYhCYTUaqhr1bCf97VSwOAhuve4DRIWRohlEl1kihwTft3MNWCAqVkm-Jw6mYqZreSaY4_" rel="nofollow" target="_blank" data-lynx-mode="hover">tokio framework</a>, interleaving with each other as multiple guest threads block and continue.</p><p>The reference Reverie backend uses the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman2%2Fptrace.2.html&amp;h=AT3t0tTGX_Hfzvr1HpKlxn6cAi_WLIAR4hPwjApi8BO-ZCsCMgd-j7wCOE2ijrxkFEDXIrjdPyBzOjq_ZcqNIjl2urp53ZwmhcFyqadas4f3ZFxHyMeByObWEQJGfFEt3_hVuEIFwfntX3nS" rel="nofollow" target="_blank" data-lynx-mode="hover">ptrace</a> system call for guest event interception, and a more advanced backend uses in-memory program instrumentation. In fact, Reverie is the only program instrumentation library that abstracts away whether instrumentation code is running in a central place (its own process), or <i>inside</i> the guest processes themselves via injected code.</p><h3 id="u_0_44_1H">Challenge 2: Inter-thread synchronization</h3><p>Consider communication through sockets and pipes <i>within</i> the reproducible container. This is an area where our earlier prototype mainly used the strategy of converting blocking operations to non-blocking ones, and then polling them at deterministic points in time within a sequential execution. Because we run in user space, we don&#39;t have a direct way to ask the kernel whether a blocking operation has completed, so attempting a non-blocking version of the syscall serves as our polling mechanism. </p><p>Hermit builds on this strategy and includes a sophisticated scheduler with thread priorities and multiple randomization points for exploring &#34;chaos mode&#34; paths through the code. This same scheduler implements a back-off strategy for polling operations to make it more efficient.</p><p>Hermit also goes beyond polling, implementing some inter-thread communication entirely inside Hermit. By including features like a built-in <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fman7.org%2Flinux%2Fman-pages%2Fman2%2Ffutex.2.html&amp;h=AT2Ui2ueTc4f_TSk3cMepSeIQMC1K5z39uN34IbKyBDGeufke7-F1dhU2d6JYNrQO7fN7B5q_6CBHh_gxfhhkA9uxmOY2myuepVlrYh8tQjbW9mkMyGMH4ABySbkzlBIDLgRbGA7dCDpYb1A" rel="nofollow" target="_blank" data-lynx-mode="hover">futex</a> implementation, Hermit takes a small step closer to behaving like an operating system kernel. But Hermit is still vastly simpler than Linux and passes most of the heavy lifting on to Linux itself.</p><p>For specific features that Hermit implements directly, it never passes those system calls through to Linux. In the case of futexes, for example, it is hard or impossible to come up with a series of raw futex syscalls to issue to the kernel and achieve a deterministic outcome. Subtleties include spurious wake-ups (without the futex value changing), the nondeterministic selection of threads to wake, and the ineradicable moment in time after Hermit issues a blocking syscall to Linux, but before we know for sure if Linux has acted on it. </p><p>These issues are avoided entirely by intercepting each futex call and updating the Hermit scheduler’s own state precisely and deterministically. The underlying Linux scheduler still runs everything, physically, but Hermit’s own scheduler takes precedence, deciding which thread to unblock next.</p><h3 id="u_0_46_wZ">Challenge 3: Large and complex binaries</h3><p>Meta has no shortage of large and challenging binaries that use recent features of the Linux kernel. Nevertheless, after a couple of years of development, Hermit runs thousands of different programs deterministically today. This includes more than 90 percent of test binaries we run it on.</p><h2 id="u_0_48_ml">Other applications</h2><p>While flaky tests and concurrency bugs are where we&#39;ve invested most heavily, there are many other applications which we will briefly outline below:</p><ul><li><p><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Freproducible-builds.org%2F&amp;h=AT1MPllKG0wum5VqYDpGwcQwfdEgT-2X51QkGzgOr2TUbqAN2nuEqQROOeBswFyQ68eEOiD2TdsD3n3w6J9EQ8Nce8WsQQv_L6R3yRtkmS0JGJcY9NsxfbMDQ-sBvO6yuqJoHgN3lEiWhsv5" rel="nofollow" target="_blank" data-lynx-mode="hover">Reproducible Builds</a>: which are part of a secure software supply chain that removes the need to trust binary packages and their servers. Our earlier prototype was used for this purpose and presented at the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Freproducible-builds.org%2Ffiles%2FReproducibleSummit5EventDocumentation.pdf&amp;h=AT2pocuJOfVsDYUvHfr2UGcPUmBHlojxHaXU9FbeLrcJCHQnWzH30OFlNrDCNtjk4SvxH3Fn9Xv1d6c8hwnKkh8n_bInktJyj7MwDYw-W6Z4_nQRUZ43bzMrF8uIigP7UHLiBI8x6JGYrW6M" rel="nofollow" target="_blank" data-lynx-mode="hover">Reproducible Builds Summit in 2019</a>.</p></li><li><p>Reproducible Debugging: which has the same benefits <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.replay.io%2F&amp;h=AT3bOh_cUPxejpjNGKdW4URIRMGQ2QLt8Yjho1CxeHmksPi-msSKDtLe-9msyG5uLakG1K-nbAn8fcCQHhsWMZdY2CGqBksQ04tiu7ax_nDk8PMOW4WsQeojW3B-QYRXUmcEyfWISIbv5zfmuCWmvzGEsSzk4A" rel="nofollow" target="_blank" data-lynx-mode="hover">as </a><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Flearn.microsoft.com%2Fen-us%2Fwindows-hardware%2Fdrivers%2Fdebugger%2Ftime-travel-debugging-overview&amp;h=AT2dcXeJZPcAHQ_mLWAMGXs2ClaFAXkRpWTf7Lpkh-oT_OURx0KCChT6GbUIZpNjycrftclkEbRPJKe8qtRz81WBtBBhkacOAVO9k7WKaysT1zwPNgcsa0WdjdJyK-wC0Yfuj7crW9U1Mzfc" rel="nofollow" target="_blank" data-lynx-mode="hover">traditional </a><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Frr-project.org%2F&amp;h=AT1NkX4Hsm9o7gTy6ydlwTvk3h8nCHaJv2vtm2CwVEwBiyW3a8YIxd-R5o855Jkvq22Sw0OgYzDTvaOtxi_c_lrbRD_R2SC42nP-mDFiYrJAHY1tMHckCv7Rxyx48SBhzP7_B-T2P8_zPQVX" rel="nofollow" target="_blank" data-lynx-mode="hover">replay </a><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fundo.io%2Fsolutions%2Fproducts%2Flive-recorder%2F&amp;h=AT2qxPjDUrYRIWO9_P_gGRVLef4k6uGRmOFdOOgybVQqUz83lQIZo442FDl6OZdQWhL3WONCZzTnyH4muVBE4aLincpzEdRYFUSedjc3Jvaif1dE-15yD-H6-ODhLhOcLFFb9mqf1rZ1F0Rp" rel="nofollow" target="_blank" data-lynx-mode="hover">debugging </a>. Indeed Hermit supports attaching GDB or LLDB to any deterministic execution.</p></li><li><p><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FState_machine_replication&amp;h=AT3ZHIH6hUQP4mjwmcEx9LkEL76wtQ7tgdVnvNwY41v1RSaDbiWckGfNydIlygJ0AaiHeg9XFQsVYvGzn7wWEtbiLBcxDkM6EbWGlKiM-zVLnw-MGXMikjudKCYhrVyLmb6hK73nPcSkabkA" rel="nofollow" target="_blank" data-lynx-mode="hover">Replicated state machines</a>: which provide fault tolerance in distributed systems, and require determinism. There are even <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Fmicrosoft%2FAMBROSIA&amp;h=AT2LjKU_yvkf168B3iO2SHgDRWsC0XS-aLv1_TOV7iNjVOC4kDmun4vF0QMRlwBD81W_fA7tCvLXU07kslC2DpnUSz8LvbSwiZbqknVNyOWNTmquEt0qvOOmFRPniGVLOWtZTP5bm2gPQf-B" rel="nofollow" target="_blank" data-lynx-mode="hover">microservices frameworks that completely abstract away machine failures</a>, provided that determinism can be <i>ensured</i> or <i>assumed</i>.</p></li><li><p>Smart contracts: which are normally written in specialized languages that are <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fethereum.stackexchange.com%2Fquestions%2F3557%2Fwhy-do-smart-contract-languages-need-to-be-deterministic&amp;h=AT318ix22mjSoSOXY1tx_HaZi7pwERL_hxDp_8NVRI6sCMuSLdE4JYxXU6EIfg0Ad8Io9bg9a2NjE8ix7HkunV_qcfPsGRQRi8Ammw8mXVKuSF1d7j3AYiP8FdDojRuTPrUGmjz4lNGHiNQS" rel="nofollow" target="_blank" data-lynx-mode="hover">constrained to be deterministic</a>. Reproducible containers could make it possible to run traditional software “on chain” with the same assurance of distributed replicability.</p></li></ul><p>There&#39;s more than we can explore on our own! That is why we&#39;re excited to open up these possibilities for the community at large.</p><h2 id="u_0_4a_uR">Conclusion</h2><p>Repeatable execution of software is an important capability for debugging, auditability and the other applications described above. Nevertheless, it&#39;s been treated as an afterthought in the technology stacks we all depend on—left as the developer’s responsibility to create &#34;good enough&#34; repeatability for stable tests or a reproducible bug report. </p><p>Hermit, as a reproducible container, provides a glimpse of what it would be like if the system stack provided <i>repeatability as an abstraction</i>: a guarantee the developer could rely upon, just like memory isolation or type safety. We&#39;ve only scratched the surface of what is possible with this foundational technology. We hope you’ll check out the <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fgithub.com%2Ffacebookexperimental%2Fhermit&amp;h=AT0m_FO2ucit44VGWc2IQqoWLiEh1XDBci9iGYczLDi3N5Pfam_tGPnzVmvAODL0XX5Hdb8vSKnG2qfRpYruqMuo2O4MwxCoHUIqy3WGrsC3VITC8v4XlUSpYOc79q4CJGTIN37c9z_chVXy" rel="nofollow" target="_blank" data-lynx-mode="hover">open source GitHub repo</a> and help us apply and evolve Hermit.</p><p><b>Note on prior Art:</b> Earlier academic research on <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fdedis.cs.yale.edu%2F2010%2Fdet%2F&amp;h=AT3PxSg9dxYxJtOFUMHACSAJcXDQ4mp90E9r0YvIVBbB0zxdcHS-JrUgz8rKfCqVs4cNEvfNIvXIX6degmbGD4SyYdtCeXsXe4eK_qUZ5392HwcBPTtiCmLF-t3XPbslZSYYhkplGnocHyf9" rel="nofollow" target="_blank" data-lynx-mode="hover">Determinator</a> and <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fstatic.usenix.org%2Fevent%2Fosdi10%2Ftech%2Ffull_papers%2FBergan.pdf&amp;h=AT3resYoqv-We7oHHmPYeE52BmG9yLtUFy0OowM8ifaS7I2lv-vbWqrQgRXVvHCmy0RHc3tQkXMNJNTGK6cBDI2exT39pb24QK-VSNAR21cwgTdP3fUPn4G4Imp-2JGVYYurE8cce-WzRdeX" rel="nofollow" target="_blank" data-lynx-mode="hover">dOS</a> represents exploratory work in this area over a decade ago. But these systems were, respectively, a small educational OS and an experimental fork of Linux. Neither was designed as a maintainable mechanism for people to run real software deterministically in practice.</p><p>To learn more about Meta Open Source, visit our <a href="https://opensource.facebook.com/" target="_blank">open source site</a>, subscribe to our <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCCQY962PmHabTjaHv2wJzfQ&amp;h=AT0X3pnYDpkchEy95Dq7xvP0fB70a1_miVquRNky93VqKkl5MDV7tn393ilT7_REA1Kwo14VBszrk8X_bvoNSrT76JGtFk-HlNBNmni4ak5jbZGgXu_yeQuw3U7kasWEeMuleUtVqM1W8Voq" rel="nofollow" target="_blank" data-lynx-mode="hover">YouTube channel</a>, or follow us on <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Ftwitter.com%2FmetaOpenSource&amp;h=AT20Vl37ayJz03lv_Ve-hlZnz7zNCe2Sf-fXZvOrfZp34-Nty-yRuXvBBqG8LA_l06Wk2jQFgNWZiAEC9pgAxVHtCe6ztXTEbZkkhWkGc0Q0-qIwHao8nPqNyYKzvUFeARdNc9dDD1IW4nKQ" rel="nofollow" target="_blank" data-lynx-mode="hover">Twitter</a>, <a href="https://www.facebook.com/MetaOpenSource" target="_blank">Facebook</a> and <a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.linkedin.com%2Fshowcase%2Fmeta-open-source&amp;h=AT0pYPvSZJkJruZBS2g5pbxPy7u-WErVgKagpdv_z0iaJhds44gH5ocFODGvXXNoZa6dfAEWcAN0x0EqzaH4_nLW3uqGTzk1uPJpd1wqD2tP3H7wwLnzkhKUBMMPS4WMcQf4tVkSUH-OUt9U" rel="nofollow" target="_blank" data-lynx-mode="hover">LinkedIn</a>.</p></div></div></div></div></div>
  </body>
</html>
