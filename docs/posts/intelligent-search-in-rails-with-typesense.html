<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://avohq.io/blog/intelligent-search-in-rails-with-typesense">Original</a>
    <h1>Intelligent Search in Rails with Typesense</h1>
    
    <div id="readability-page-1" class="page"><div data-behavior="table-of-contentable">
          <div data-reading-progress-target="content">
            <div>
                <p><img src="https://d2g0xdrrde9ln1.cloudfront.net/k6qwlszk9l67jf3o87wnyzhl1f8u"/></p>
            </div>
            <p>Search is one of the most ubiquitous features: almost every application needs some form of search at some point.</p>

<p>Luckily, in the Rails realm, we have many established options that allow us to add the feature, from using a simple <code>search</code> scope with an <code>ILIKE</code> query to more complex options like <code>pgsearch</code> or even options like Elastic Search with the available adapters.</p>

<p>In this article, we will learn <strong>how to add intelligent search in Rails using the Typesense gem</strong> to show the power of Typesense as a search engine and the simplicity of its integration into Rails.</p>

<p>Let&#39;s start by understanding what Typesense is:</p>

<h2>What is Typesense?</h2>

<p>Typesense is a typo-tolerant search engine that&#39;s optimized for instant, typically under 50ms, search.</p>

<p>Initially, when we think about search in Rails applications, we think about a layer on top of our database that&#39;s able to search records that exist in our database using the query criteria provided by the user.</p>

<p><a href="https://docs.avohq.io/3.0/search.html" target="_blank">Ransack</a>, the library Avo uses to handle search is a good example of this: it&#39;s built on top of Active Record and it can search and filter results in our database with some configuration.</p>

<p>On the other hand, an alternative like Typesense is more akin to Elastic Search or Algolia than it is to Ransack or PGSearch: we create an index with records from our database or external data and then we use Typesense to query that index which produces the results.</p>

<p>However, unlike Elastic Search, Typesense comes with sensible defaults for every config parameter which means it works out-of-the-box for most use cases.</p>

<p>The other advantage it has over database search is that it&#39;s very performant: it can handle many concurrent search queries per second while returning results fast.</p>

<div>
  
  <p>Because of the way it&#39;s designed, Typesense should never be used as the primary data store of our application. It is meant to store a copy of the data which should be in our database.</p>
</div>

<h3>Typesense concepts</h3>

<p>The first concept to understand is that we interact with Typesense using a client which is, essentially, a wrapper around the calls we can make to the Typesense API that we can self-host or to the Typesense cloud API.</p>

<p>The following are useful concepts to know:</p>

<ul>
<li>
<strong>Document:</strong> In Typesense, a document is roughly equivalent to a table row. In the case of a movie application, an individual movie can be a document in Typesense. A thing to note is that documents don&#39;t have to map at all to our application data. For example, if we have a <code>Movie</code> and a <code>Genre</code> model, we could simply condense everything into a single document that represents the movie but also has information about the genre.</li>
<li>
<strong>Collection:</strong> a collection is a group of related documents.  A collection has to have a name and a description of the fields that will be indexed. An application can have many collections. However, we have to consider that as Typesense keeps data in memory, as we index more data, the memory needed to run Typesense increases.</li>
<li>
<strong>Schema:</strong> it&#39;s the shape of the data we want to index for a given collection. It&#39;s basically a hash with a <code>name</code> attribute, a <code>fields</code> key that contains the fields and types for each one of them and a <code>default_sorting_field</code> attribute that we use to tell Typesense how to sort the documents for any given search term.</li>
<li>
<strong>Node:</strong> a node is an instance of Typesense that contains a replica of the dataset. For production use cases, it&#39;s recommendable to run at least 3 nodes to tolerate node failure and avoid service disruption.</li>
<li>
<strong>Cluster:</strong> it&#39;s a group of nodes, used for high availability. When we deploy to Typesense Cloud, we can get a cluster configured out of the box. Otherwise, we need to set it up on our own.</li>
</ul>

<h2>What we will build</h2>

<p>To show how Typesense works, we will build a simple Rails application able to list movies and we will add an instant search bar that allows us to search in our database.</p>

<p>Instead of using data from a gem like Faker, we will generate movie data using AI so the results are realistic.</p>

<p>The final result looks like the following:</p>

<figure>
  
</figure>

<h2>Application Setup</h2>

<p>The first thing we need to do is to install Typesense. We can do it using Docker or locally using Homebrew. For the sake of this tutorial let&#39;s use Homebrew:</p>
<div>
<pre><code>brew <span>install </span>typesense/tap/typesense-server@29.0
brew services start typesense-server@29.0
</code></pre>
</div>
<p>After this, Typesense should be running at the port 8108 so we can test it with the following command:</p>
<div>
<pre><code>curl http://localhost:8108/health
</code></pre>
</div>
<p>We should get <code>{&#34;ok&#34;:true}</code> as a response which means the installation was successful and that we can integrate Typesense into our application.</p>

<div>
  
  <p>Please note that, when installed with Homebrew or using the Mac binary, Typesense only works with MacOS Ventura (13.x) and above.</p>
</div>

<p>The next step is to create our Rails application:</p>
<div>
<pre><code>rails new typesense <span>--css</span><span>=</span>tailwind <span>--javascript</span><span>=</span>esbuild
</code></pre>
</div>
<p>I used AI to generate a dataset of 200 movies where each movie looks like this:</p>
<div>
<pre><code><span>  </span><span>{</span><span>
    </span><span>&#34;id&#34;</span><span>:</span><span> </span><span>&#34;1&#34;</span><span>,</span><span>
    </span><span>&#34;title&#34;</span><span>:</span><span> </span><span>&#34;The Shawshank Redemption&#34;</span><span>,</span><span>
    </span><span>&#34;year&#34;</span><span>:</span><span> </span><span>1994</span><span>,</span><span>
    </span><span>&#34;director&#34;</span><span>:</span><span> </span><span>&#34;Frank Darabont&#34;</span><span>,</span><span>
    </span><span>&#34;rating&#34;</span><span>:</span><span> </span><span>9.3</span><span>,</span><span>
    </span><span>&#34;runtime&#34;</span><span>:</span><span> </span><span>142</span><span>,</span><span>
    </span><span>&#34;description&#34;</span><span>:</span><span> </span><span>&#34;Two imprisoned men bond over a number of years, finding solace and eventual redemption through acts of common decency.&#34;</span><span>
  </span><span>}</span><span>,</span><span>
</span></code></pre>
</div>
<p>To associate movies with their movie genres, we need a <code>Movie</code> a <code>Genre</code> and a <code>MovieGenre</code> models. Let&#39;s start by creating them, starting with the <code>Movie</code> model:</p>
<div>
<pre><code>bin/rails generate model Movie title year:integer director rating:decimal runtime:integer description:text
</code></pre>
</div>
<p>Now, for the <code>Genre</code> model:</p>
<div>
<pre><code>bin/rails generate model Genre name description:text
</code></pre>
</div>
<p>Lastly, the <code>MovieGenre</code> join model:</p>
<div>
<pre><code>bin/rails generate model MovieGenre movie:references genre:references
</code></pre>
</div>
<p>Now for the models:</p>
<div>
<pre><code><span># app/models/movie.rb</span>
<span>class</span> <span>Movie</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span>validates</span> <span>:title</span><span>,</span> <span>presence: </span><span>true</span>

  <span>has_many</span> <span>:movie_genres</span>
  <span>has_many</span> <span>:genres</span><span>,</span> <span>through: :movie_genres</span>
<span>end</span>

<span># app/models/genre.rb</span>
<span>class</span> <span>Genre</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span>has_many</span> <span>:movie_genres</span>
  <span>has_many</span> <span>:movies</span><span>,</span> <span>through: :movie_genres</span>
<span>end</span>

<span># app/models/movie_genre.rb</span>
<span>class</span> <span>MovieGenre</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span>belongs_to</span> <span>:movie</span>
  <span>belongs_to</span> <span>:genre</span>
<span>end</span>
</code></pre>
</div>
<p>Finally, we create a seed file where we can take the movie data generated with AI and have it in our database. If you want to use the same data as I did, feel free to download it from the <a href="https://github.com/erozas/typesense-rails/blob/main/app/data/movies.json" target="_blank" rel="nofollow">application repository.</a></p>

<p>The seed file looks like this:</p>
<div>
<pre><code><span>MovieGenre</span><span>.</span><span>destroy_all</span>
<span>Movie</span><span>.</span><span>destroy_all</span>
<span>Genre</span><span>.</span><span>destroy_all</span>

<span>genres_file</span> <span>=</span> <span>Rails</span><span>.</span><span>root</span><span>.</span><span>join</span><span>(</span><span>&#39;app&#39;</span><span>,</span> <span>&#39;data&#39;</span><span>,</span> <span>&#39;genres.json&#39;</span><span>)</span>
<span>genres</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>File</span><span>.</span><span>read</span><span>(</span><span>genres_file</span><span>))</span>

<span>puts</span> <span>&#34;Creating genres...&#34;</span>
<span>genre_objects</span> <span>=</span> <span>{}</span>
<span>genres</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>genre_data</span><span>|</span>
  <span>genre</span> <span>=</span> <span>Genre</span><span>.</span><span>create!</span><span>(</span><span>genre_data</span><span>)</span>
  <span>genre_objects</span><span>[</span><span>genre</span><span>.</span><span>name</span><span>]</span> <span>=</span> <span>genre</span>
  <span>puts</span> <span>&#34;Created genre: </span><span>#{</span><span>genre</span><span>.</span><span>name</span><span>}</span><span>&#34;</span>
<span>end</span>

<span>movies_file</span> <span>=</span> <span>Rails</span><span>.</span><span>root</span><span>.</span><span>join</span><span>(</span><span>&#39;app&#39;</span><span>,</span> <span>&#39;data&#39;</span><span>,</span> <span>&#39;movies.json&#39;</span><span>)</span>
<span>movies_data</span> <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>File</span><span>.</span><span>read</span><span>(</span><span>movies_file</span><span>))</span>

<span>puts</span> <span>&#34;Creating movies...&#34;</span>
<span>movies_data</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>movie_data</span><span>|</span>
  <span>movie</span> <span>=</span> <span>Movie</span><span>.</span><span>create!</span><span>(</span>
    <span>title: </span><span>movie_data</span><span>[</span><span>&#39;title&#39;</span><span>],</span>
    <span>year: </span><span>movie_data</span><span>[</span><span>&#39;year&#39;</span><span>],</span>
    <span>director: </span><span>movie_data</span><span>[</span><span>&#39;director&#39;</span><span>],</span>
    <span>rating: </span><span>movie_data</span><span>[</span><span>&#39;rating&#39;</span><span>],</span>
    <span>runtime: </span><span>movie_data</span><span>[</span><span>&#39;runtime&#39;</span><span>],</span>
    <span>description: </span><span>movie_data</span><span>[</span><span>&#39;description&#39;</span><span>]</span>
  <span>)</span>

  <span>movie_data</span><span>[</span><span>&#39;genre&#39;</span><span>].</span><span>each</span> <span>do</span> <span>|</span><span>genre_name</span><span>|</span>
    <span>genre</span> <span>=</span> <span>genre_objects</span><span>[</span><span>genre_name</span><span>]</span>
    <span>if</span> <span>genre</span>
      <span>MovieGenre</span><span>.</span><span>create!</span><span>(</span><span>movie: </span><span>movie</span><span>,</span> <span>genre: </span><span>genre</span><span>)</span>
    <span>else</span>
      <span>puts</span> <span>&#34;Warning: Genre &#39;</span><span>#{</span><span>genre_name</span><span>}</span><span>&#39; not found for movie &#39;</span><span>#{</span><span>movie</span><span>.</span><span>title</span><span>}</span><span>&#39;&#34;</span>
    <span>end</span>
  <span>end</span>

  <span>puts</span> <span>&#34;Created movie: </span><span>#{</span><span>movie</span><span>.</span><span>title</span><span>}</span><span> (</span><span>#{</span><span>movie</span><span>.</span><span>year</span><span>}</span><span>)&#34;</span>
<span>end</span>

<span>puts</span> <span>&#34;Seed completed!&#34;</span>
<span>puts</span> <span>&#34;Created </span><span>#{</span><span>Genre</span><span>.</span><span>count</span><span>}</span><span> genres&#34;</span>
<span>puts</span> <span>&#34;Created </span><span>#{</span><span>Movie</span><span>.</span><span>count</span><span>}</span><span> movies&#34;</span>
<span>puts</span> <span>&#34;Created </span><span>#{</span><span>MovieGenre</span><span>.</span><span>count</span><span>}</span><span> movie-genre associations&#34;</span>
</code></pre>
</div>
<p>Finally, let&#39;s display the list of movies in the root view to make sure we have everything in place:</p>

<div data-controller="light-box">        <p><img data-light-box-target="image" data-action="click-&gt;light-box#show" src="https://i.postimg.cc/pTGFjjf3/movie-list.webp" alt="Movie list displayed" title=""/>  </p></div>

<p>Now, we can start the Typesense integration:</p>

<h2>Integrating Typesense</h2>

<p>The first thing we need to do is install the Typesense Ruby gem:</p>
<div>
<pre><code>bundle add typesense <span>&amp;&amp;</span> bundle <span>install</span>
</code></pre>
</div>
<p>The next step is to configure the Typesense client using an initializer where we instantiate a new client defining a single host node and adding the default API key which is <code>xyz</code></p>
<div>
<pre><code><span># config/initializers/typesense.rb</span>
<span>TYPESENSE_CLIENT</span> <span>=</span> <span>Typesense</span><span>::</span><span>Client</span><span>.</span><span>new</span><span>(</span>
  <span>nodes: </span><span>[</span>
    <span>{</span>
      <span>host: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_HOST&#39;</span><span>,</span><span>&#39;localhost&#39;</span><span>),</span>
      <span>port: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_PORT&#39;</span><span>,</span><span>&#39;8108&#39;</span><span>),</span>
      <span>protocol: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_PROTOCOL&#39;</span><span>,</span><span>&#39;http&#39;</span><span>)</span>
    <span>}</span>
  <span>],</span>
  <span>api_key: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_API_KEY&#39;</span><span>,</span><span>&#39;xyz&#39;</span><span>),</span>
  <span>log_level: :info</span><span>,</span>
  <span>connection_timeout_seconds: </span><span>2</span><span>,</span>
<span>)</span>
</code></pre>
</div>
<p>This provides us with access to a global <code>TYPESENSE_CLIENT</code> variable that we can use to interact with the API using the gem.</p>

<p>Now, the next thing we have to do is create a collection using the movie data we have in the database. We start by creating a <code>Typesense</code> model and add the <code>create_schema</code> class method to generate our desired schema:</p>
<div>
<pre><code><span>class</span> <span>TypesenseService</span>
  <span>def</span> <span>self</span><span>.</span><span>create_schema</span>
    <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>.</span><span>create</span><span>(</span>
      <span>name: </span><span>&#34;movies&#34;</span><span>,</span>
      <span>fields: </span><span>[</span>
        <span>{</span> <span>name: </span><span>&#39;movie_id&#39;</span><span>,</span> <span>type: </span><span>&#39;int32&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;title&#39;</span><span>,</span> <span>type: </span><span>&#39;string&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;year&#39;</span><span>,</span> <span>type: </span><span>&#39;int32&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;director&#39;</span><span>,</span> <span>type: </span><span>&#39;string&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;rating&#39;</span><span>,</span> <span>type: </span><span>&#39;float&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;runtime&#39;</span><span>,</span> <span>type: </span><span>&#39;int32&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;description&#39;</span><span>,</span> <span>type: </span><span>&#39;string&#39;</span> <span>},</span>
        <span>{</span> <span>name: </span><span>&#39;genres&#39;</span><span>,</span> <span>type: </span><span>&#39;string[]&#39;</span> <span>},</span>
      <span>],</span>
      <span>default_sorting_field: </span><span>&#39;movie_id&#39;</span>
    <span>)</span>
  <span>end</span> 

  <span>def</span> <span>self</span><span>.</span><span>delete_schema</span>
    <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>.</span><span>delete</span><span>(</span><span>name: </span><span>&#34;movies&#34;</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>This will create a <code>movies</code> collection with the schema we provided, containing all the fields we deem pertinent to search the collection later.</p>

<h3>Indexing documents</h3>

<p>The next step is to index every movie we have in our database, to achieve this, we will add an <code>index_movies</code> method to the service class that&#39;s in charge of adding each movie as a document to the <code>movies</code> collection:</p>
<div>
<pre><code><span>class</span> <span>TypesenseService</span>
  <span>def</span> <span>self</span><span>.</span><span>index_movies</span>
    <span>Movie</span><span>.</span><span>all</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>movie</span><span>|</span>
      <span>movie</span> <span>=</span> <span>serialize_movie</span><span>(</span><span>movie</span><span>)</span>
      <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>.</span><span>create</span><span>(</span><span>movie</span><span>)</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>self</span><span>.</span><span>index_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>serialized_movie</span> <span>=</span> <span>serialize_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>.</span><span>create</span><span>(</span><span>serialized_movie</span><span>)</span>
  <span>end</span>

  <span>private</span>

  <span>def</span> <span>self</span><span>.</span><span>serialize_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>{</span>
      <span>id: </span><span>movie</span><span>.</span><span>id</span><span>.</span><span>to_s</span><span>,</span>
      <span>title: </span><span>movie</span><span>.</span><span>title</span><span>,</span>
      <span>year: </span><span>movie</span><span>.</span><span>year</span><span>,</span>
      <span>director: </span><span>movie</span><span>.</span><span>director</span><span>,</span>
      <span>rating: </span><span>movie</span><span>.</span><span>rating</span><span>.</span><span>to_f</span><span>,</span>
      <span>runtime: </span><span>movie</span><span>.</span><span>runtime</span><span>,</span>
      <span>description: </span><span>movie</span><span>.</span><span>description</span><span>,</span>
      <span>genres: </span><span>movie</span><span>.</span><span>genre_list</span><span>,</span>
    <span>}</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>We have to make sure that every field matches the <code>type</code> we assigned to the collection when we created it. That&#39;s why we need to call <code>.to_f</code> on the <code>rating</code> and we have to add the <code>genre_list</code> method to the <code>Movie</code> class and make it return an array of strings that represent the movie&#39;s genres:</p>
<div>
<pre><code><span># app/models/movie.rb</span>
<span>class</span> <span>Movie</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span># Rest of the code</span>
  <span>def</span> <span>genre_list</span>
    <span>genres</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:name</span><span>)</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>Now, after we run <code>TypesenseService.index_movies</code> in the Rails console, we should be able to search records without issues:</p>

<h3>Basic search</h3>

<p>To perform a basic search with Typesense, we need to call the <code>search</code> method on the <code>documents</code> property for a given collection and pass a hash containing at least two keys: a <code>q</code> which is the search term and a <code>query_by</code> which represents the fields we want Typesense to query.</p>

<p>For example, let&#39;s say we want to search for movies with the term <code>god</code> in the title:</p>
<div>
<pre><code><span>query_hash</span> <span>=</span> <span>{</span><span>q: </span><span>&#34;god&#34;</span><span>,</span> <span>query_by: </span><span>&#34;title&#34;</span><span>}</span>
<span>results</span> <span>=</span> <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>.</span><span>search</span><span>(</span><span>query_hash</span><span>)</span>
</code></pre>
</div>
<p>After calling this, the <code>results</code> variable is populated with a hash that contains the following keys:</p>

<ul>
<li>
<strong>found:</strong> an integer that represents the amount of results that match with our query.</li>
<li>
<strong>hits:</strong> an array of hashes with the actual hits or matches.</li>
<li>
<strong>out_of:</strong> the total amount of documents in the collection we retrieved from.</li>
<li>
<strong>page:</strong> the current page that comes from Typesense pagination.</li>
<li>
<strong>request_params:</strong> a hash that contains the params used to perform the request to Typesense&#39;s API. It includes the <code>collection_name</code>, the <code>q</code> which is the query, the <code>first_q</code> which represents the first query in multi-query requests and <code>per_page</code> which represents the amount of results that each page should contain.</li>
<li>
<strong>search<em>time</em>ms:</strong> the time it took to perform the search in milliseconds.</li>
</ul>

<p>Currently, the <code>hits</code> array is what we need to give user feedback about the search result.</p>

<p>The <code>hit</code> hash has 5 keys but, for our immediate needs, we only need to work with 2 of them:</p>

<ul>
<li>
<strong>document:</strong> the actual document with the shape we indexed it with.</li>
<li>
<strong>highlights:</strong> a list of highlights that match our query term in the fields we&#39;re searching against. In our case, as we&#39;re only using the <code>title</code> field it&#39;s a single match against the word <code>god</code> in the <code>title</code>.</li>
</ul>

<p>An actual result with real data looks like this:</p>
<div>
<pre><code><span>{</span><span>&#34;document&#34;</span><span>=&gt;</span>
  <span>{</span><span>&#34;description&#34;</span><span>=&gt;</span><span>&#34;In the slums of Rio, two kids&#39; paths diverge as one struggles to become a photographer and the other a kingpin.&#34;</span><span>,</span>
   <span>&#34;director&#34;</span><span>=&gt;</span><span>&#34;Fernando Meirelles&#34;</span><span>,</span>
   <span>&#34;genres&#34;</span><span>=&gt;</span><span>[</span><span>&#34;Crime&#34;</span><span>,</span> <span>&#34;Drama&#34;</span><span>],</span>
   <span>&#34;id&#34;</span><span>=&gt;</span><span>&#34;31&#34;</span><span>,</span>
   <span>&#34;movie_id&#34;</span><span>=&gt;</span><span>30</span><span>,</span>
   <span>&#34;rating&#34;</span><span>=&gt;</span><span>8.5</span><span>,</span>
   <span>&#34;runtime&#34;</span><span>=&gt;</span><span>130</span><span>,</span>
   <span>&#34;title&#34;</span><span>=&gt;</span><span>&#34;City of God&#34;</span><span>,</span>
   <span>&#34;year&#34;</span><span>=&gt;</span><span>2002</span><span>},</span>
 <span>&#34;highlight&#34;</span><span>=&gt;</span><span>{</span><span>&#34;title&#34;</span><span>=&gt;</span><span>{</span><span>&#34;matched_tokens&#34;</span><span>=&gt;</span><span>[</span><span>&#34;God&#34;</span><span>],</span> <span>&#34;snippet&#34;</span><span>=&gt;</span><span>&#34;City of &lt;mark&gt;God&lt;/mark&gt;&#34;</span><span>}},</span>
 <span>&#34;highlights&#34;</span><span>=&gt;</span><span>[{</span><span>&#34;field&#34;</span><span>=&gt;</span><span>&#34;title&#34;</span><span>,</span> <span>&#34;matched_tokens&#34;</span><span>=&gt;</span><span>[</span><span>&#34;God&#34;</span><span>],</span> <span>&#34;snippet&#34;</span><span>=&gt;</span><span>&#34;City of &lt;mark&gt;God&lt;/mark&gt;&#34;</span><span>}],</span>
 <span>&#34;text_match&#34;</span><span>=&gt;</span><span>578730123365187705</span><span>,</span>
 <span>&#34;text_match_info&#34;</span><span>=&gt;</span>
  <span>{</span><span>&#34;best_field_score&#34;</span><span>=&gt;</span><span>&#34;1108091338752&#34;</span><span>,</span> <span>&#34;best_field_weight&#34;</span><span>=&gt;</span><span>15</span><span>,</span> <span>&#34;fields_matched&#34;</span><span>=&gt;</span><span>1</span><span>,</span> <span>&#34;num_tokens_dropped&#34;</span><span>=&gt;</span><span>0</span><span>,</span> <span>&#34;score&#34;</span><span>=&gt;</span><span>&#34;578730123365187705&#34;</span><span>,</span> <span>&#34;tokens_matched&#34;</span><span>=&gt;</span><span>1</span><span>,</span> <span>&#34;typo_prefix_score&#34;</span><span>=&gt;</span><span>0</span><span>}</span>
<span>}</span>
</code></pre>
</div>
<p>We now understand how basic search works out of the box but let&#39;s learn how to integrate it into our application:</p>

<h2>Integrating search</h2>

<p>The first step is to define a route and a controller we can use to perform our search. Let&#39;s start with the route:</p>
<div>
<pre><code><span># config/routes.rb</span>
<span>Rails</span><span>.</span><span>application</span><span>.</span><span>routes</span><span>.</span><span>draw</span> <span>do</span>
  <span># Rest of the routes</span>
  <span>get</span> <span>&#34;search&#34;</span><span>,</span> <span>to: </span><span>&#34;search#index&#34;</span>
<span>end</span>
</code></pre>
</div>
<p>In theory, we could define a <code>MoviesController</code> and handle search conditionally in the <code>index</code> method but, as the partial or JSON view we might end up using for search might differ from a regular movie, let&#39;s keep it separate in a <code>SearchController</code>:</p>
<div>
<pre><code><span># app/controllers/search_controller.rb</span>
<span>class</span> <span>SearchController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span>def</span> <span>index</span>
    <span>@movies</span> <span>=</span> <span>[]</span>
    <span>query</span> <span>=</span> <span>params</span><span>[</span><span>:query</span><span>]</span>

    <span>if</span> <span>query</span><span>.</span><span>present?</span>
      <span>results</span> <span>=</span> <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>.</span><span>search</span><span>(</span>
        <span>q: </span><span>query</span><span>,</span>
        <span>query_by: </span><span>&#34;title,description&#34;</span><span>,</span>
        <span>page: </span><span>params</span><span>[</span><span>:page</span><span>]</span> <span>||</span> <span>1</span><span>,</span>
        <span>per_page: </span><span>params</span><span>[</span><span>:per_page</span><span>]</span> <span>||</span> <span>10</span>
      <span>)</span>

      <span>@movies</span> <span>=</span> <span>results</span><span>[</span><span>&#34;hits&#34;</span><span>].</span><span>map</span> <span>do</span> <span>|</span><span>hit</span><span>|</span>
        <span>{</span>
          <span>title: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;title&#34;</span><span>],</span>
          <span>year: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;year&#34;</span><span>],</span>
          <span>director: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;director&#34;</span><span>],</span>
          <span>rating: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;rating&#34;</span><span>],</span>
          <span>runtime: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;runtime&#34;</span><span>],</span>
          <span>description: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;description&#34;</span><span>],</span>
          <span>genres: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;genres&#34;</span><span>]</span>
        <span>}</span>
      <span>end</span>
    <span>end</span>

    <span>respond_to</span> <span>do</span> <span>|</span><span>format</span><span>|</span>
      <span>format</span><span>.</span><span>html</span>
      <span>format</span><span>.</span><span>json</span> <span>{</span> <span>render</span> <span>json: </span><span>@movies</span><span>.</span><span>to_json</span><span>,</span> <span>status: :ok</span> <span>}</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>The process here is divided into three parts:</p>

<ul>
<li>
<strong>The search:</strong> we&#39;re doing something similar to what we already did before by performing a search with the query present in the params looking in the <code>title</code> and <code>description</code> of the documents.</li>
<li>
<strong>Serializing:</strong> we serialize the results by reading from every search “hit” and transforming that into a Ruby hash that we use in the view.</li>
<li>
<strong>Controller response:</strong> we respond to HTML and JSON responses.</li>
</ul>

<p>After adding a basic form:</p>
<div>
<pre><code><span>&lt;div</span> <span>class=</span><span>&#34;max-w-screen-lg mx-auto pt-6 pb-16&#34;</span><span>&gt;</span>
  <span>&lt;div</span> <span>class=</span><span>&#34;mb-6&#34;</span><span>&gt;</span>
    <span>&lt;%=</span> <span>form_with</span> <span>url: </span><span>search_index_path</span><span>,</span> <span>method: :get</span><span>,</span> <span>local: </span><span>false</span> <span>do</span> <span>|</span><span>form</span><span>|</span> <span>%&gt;</span>
      <span>&lt;%=</span> <span>form</span><span>.</span><span>text_field</span> <span>:query</span><span>,</span> 
        <span>placeholder: </span><span>&#34;Search movies...&#34;</span><span>,</span> 
        <span>class: </span><span>&#34;w-full px-4 py-2 border border-gray-300 rounded-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500 outline-none&#34;</span><span>,</span>
        <span>value: </span><span>params</span><span>[</span><span>:query</span><span>]</span>
      <span>%&gt;</span>
    <span>&lt;%</span> <span>end</span> <span>%&gt;</span>
  <span>&lt;/div&gt;</span>

  <span>&lt;div</span> <span>class=</span><span>&#34;w-full&#34;</span><span>&gt;</span>
    <span>&lt;%=</span> <span>render</span> <span>&#34;search/results&#34;</span><span>,</span> <span>results: </span><span>@movies</span> <span>||</span> <span>[]</span> <span>%&gt;</span>
  <span>&lt;/div&gt;</span>
<span>&lt;/div&gt;</span>
</code></pre>
</div>
<p>And a <code>results</code> partial:</p>
<div>
<pre><code><span>&lt;%</span> <span>if</span> <span>results</span><span>.</span><span>empty?</span> <span>%&gt;</span>
  <span>&lt;div</span> <span>class=</span><span>&#34;py-8 text-center&#34;</span><span>&gt;</span>
    <span>&lt;div</span> <span>class=</span><span>&#34;text-gray-400 text-6xl mb-4&#34;</span><span>&gt;</span>🔍<span>&lt;/div&gt;</span>
    <span>&lt;p</span> <span>class=</span><span>&#34;text-gray-500 text-lg&#34;</span><span>&gt;</span>No movies found<span>&lt;/p&gt;</span>
    <span>&lt;p</span> <span>class=</span><span>&#34;text-gray-400 text-sm mt-2&#34;</span><span>&gt;</span>Try searching for a different title or keyword<span>&lt;/p&gt;</span>
  <span>&lt;/div&gt;</span>
<span>&lt;%</span> <span>else</span> <span>%&gt;</span>
  <span>&lt;div&gt;</span>
    <span>&lt;div</span> <span>class=</span><span>&#34;text-sm text-gray-600&#34;</span><span>&gt;</span>
      Found <span>&lt;%=</span> <span>results</span><span>.</span><span>length</span> <span>%&gt;</span> movie<span>&lt;%=</span> <span>&#39;s&#39;</span> <span>if</span> <span>results</span><span>.</span><span>length</span> <span>!=</span> <span>1</span> <span>%&gt;</span>
    <span>&lt;/div&gt;</span>

    <span>&lt;ul</span> <span>class=</span><span>&#34;divide-y divide-gray-200&#34;</span><span>&gt;</span>
      <span>&lt;%</span> <span>results</span><span>.</span><span>each</span> <span>do</span> <span>|</span><span>movie</span><span>|</span> <span>%&gt;</span>
        <span>&lt;li</span> <span>class=</span><span>&#34;bg-white py-4&#34;</span><span>&gt;</span>
          <span>&lt;div</span> <span>class=</span><span>&#34;flex justify-between items-start&#34;</span><span>&gt;</span>
            <span>&lt;h2</span> <span>class=</span><span>&#34;font-bold text-gray-900&#34;</span><span>&gt;</span><span>&lt;%=</span> <span>movie</span><span>[</span><span>:title</span><span>]</span> <span>%&gt;</span><span>&lt;/h2&gt;</span>
            <span>&lt;span</span> <span>class=</span><span>&#34;text-blue-900 text-sm font-medium&#34;</span><span>&gt;</span>
              <span>&lt;%=</span> <span>movie</span><span>[</span><span>:year</span><span>]</span> <span>%&gt;</span>
            <span>&lt;/span&gt;</span>
          <span>&lt;/div&gt;</span>

          <span>&lt;div</span> <span>class=</span><span>&#34;mt-1 mb-3&#34;</span><span>&gt;</span>
            <span>&lt;p</span> <span>class=</span><span>&#34;text-gray-600 text-sm leading-relaxed&#34;</span><span>&gt;</span><span>&lt;%=</span> <span>movie</span><span>[</span><span>:description</span><span>]</span> <span>%&gt;</span><span>&lt;/p&gt;</span>
          <span>&lt;/div&gt;</span>

          <span>&lt;%</span> <span>if</span> <span>movie</span><span>[</span><span>:genres</span><span>]</span> <span>&amp;&amp;</span> <span>movie</span><span>[</span><span>:genres</span><span>].</span><span>any?</span> <span>%&gt;</span>
            <span>&lt;div</span> <span>class=</span><span>&#34;mt-3 flex flex-wrap gap-2&#34;</span><span>&gt;</span>
              <span>&lt;%</span> <span>movie</span><span>[</span><span>:genres</span><span>].</span><span>each</span> <span>do</span> <span>|</span><span>genre</span><span>|</span> <span>%&gt;</span>
                <span>&lt;span</span> <span>class=</span><span>&#34;bg-gray-100 text-gray-700 text-xs px-2 py-1 rounded-full&#34;</span><span>&gt;</span>
                  <span>&lt;%=</span> <span>genre</span> <span>%&gt;</span>
                <span>&lt;/span&gt;</span>
              <span>&lt;%</span> <span>end</span> <span>%&gt;</span>
            <span>&lt;/div&gt;</span>
          <span>&lt;%</span> <span>end</span> <span>%&gt;</span>
        <span>&lt;/li&gt;</span>
      <span>&lt;%</span> <span>end</span> <span>%&gt;</span>
    <span>&lt;/ul&gt;</span>
  <span>&lt;/div&gt;</span>
<span>&lt;%</span> <span>end</span> <span>%&gt;</span>
</code></pre>
</div>
<p>This produces the following result:</p>

<figure>
  
</figure>

<p>We now have a working search integration with Rails but we can do better: let&#39;s add the ability to highlight search results:</p>

<h3>Highlighting results</h3>

<p>Typesense gives us the ability to highlight results out of the box by accessing the pre-formatted <code>snippet</code> attribute on the <code>highlights</code> attribute for a hit.</p>

<p>Let&#39;s start by adding a <code>highlight</code> attribute to our result hash:</p>
<div>
<pre><code><span>class</span> <span>SearchController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span>def</span> <span>index</span>
    <span># Rest of the code</span>
    <span>if</span> <span>query</span><span>.</span><span>present?</span>
      <span># Code to fetch results</span>

      <span>@movies</span> <span>=</span> <span>results</span><span>[</span><span>&#34;hits&#34;</span><span>].</span><span>map</span> <span>do</span> <span>|</span><span>hit</span><span>|</span>
        <span>{</span>
          <span>title: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;title&#34;</span><span>],</span>
          <span>year: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;year&#34;</span><span>],</span>
          <span>director: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;director&#34;</span><span>],</span>
          <span>rating: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;rating&#34;</span><span>],</span>
          <span>runtime: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;runtime&#34;</span><span>],</span>
          <span>description: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;description&#34;</span><span>],</span>
          <span>genres: </span><span>hit</span><span>[</span><span>&#34;document&#34;</span><span>][</span><span>&#34;genres&#34;</span><span>],</span>
          <span>highlight: </span><span>hit</span><span>[</span><span>&#34;highlight&#34;</span><span>],</span>
        <span>}</span>
      <span>end</span>      
    <span>end</span>
    <span># Response cod</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>If we then access the <code>result[:highlight]</code> property, we will get a hash that looks like the following:</p>
<div>
<pre><code><span>&#34;description&#34;</span><span>=&gt;</span><span>{</span><span>&#34;matched_tokens&#34;</span><span>=&gt;</span><span>[</span><span>&#34;Lebowski&#34;</span><span>],</span> <span>&#34;snippet&#34;</span><span>=&gt;</span><span>&#34;Ultimate LA slacker Jeff </span><span>\&#34;</span><span>The Dude</span><span>\&#34;</span><span> &lt;mark&gt;Lebowski&lt;/mark&gt;, mistaken for a millionaire of the same name, seeks restitution for a rug ruined by debt collectors.&#34;</span><span>},</span> <span>&#34;title&#34;</span><span>=&gt;</span><span>{</span><span>&#34;matched_tokens&#34;</span><span>=&gt;</span><span>[</span><span>&#34;Lebowski&#34;</span><span>],</span> <span>&#34;snippet&#34;</span><span>=&gt;</span><span>&#34;The Big &lt;mark&gt;Lebowski&lt;/mark&gt;&#34;</span><span>}}</span>
</code></pre>
</div>
<p>Here, we get a match for the term <code>Lebowski</code> on the <code>title</code> and the <code>description</code> fields so that&#39;s why the hash has two keys corresponding to each field.</p>

<p>However, we don&#39;t have the guarantee that a match will happen against the title and the description so we need to keep that in mind.</p>

<p>When it comes to displaying the highlighted text, we can use the <code>snippet</code> attribute as it gives us the HTML we can use directly.</p>

<p>So let&#39;s modify our <code>title</code>:</p>
<div>
<pre><code># Accessing the snippet for the title or the title itself
<span>&lt;h2</span> <span>class=</span><span>&#34;font-bold text-gray-900&#34;</span><span>&gt;</span><span>&lt;%=</span> <span>sanitize</span> <span>movie</span><span>[</span><span>:highlight</span><span>].</span><span>fetch</span><span>(</span><span>&#34;title&#34;</span><span>,</span> <span>{}).</span><span>fetch</span><span>(</span><span>&#34;snippet&#34;</span><span>,</span> <span>movie</span><span>[</span><span>:title</span><span>])</span> <span>%&gt;</span><span>&lt;/h2&gt;</span>
</code></pre>
</div>
<p>And doing the same for the <code>description</code>:</p>
<div>
<pre><code><span>&lt;p</span> <span>class=</span><span>&#34;text-gray-600 text-sm leading-relaxed&#34;</span><span>&gt;</span><span>&lt;%=</span> <span>sanitize</span> <span>movie</span><span>[</span><span>:highlight</span><span>].</span><span>fetch</span><span>(</span><span>&#34;description&#34;</span><span>,</span> <span>{}).</span><span>fetch</span><span>(</span><span>&#34;snippet&#34;</span><span>,</span> <span>movie</span><span>[</span><span>:description</span><span>])</span> <span>%&gt;</span><span>&lt;/p&gt;</span>
</code></pre>
</div>
<p>You might notice that, even if not overly complex, we introduced some logic into our result view so let&#39;s extract this into a <a href="https://avohq.io/glossary/helpers" target="_blank">helper</a>:</p>
<div>
<pre><code><span># app/helpers/search_helper.rb</span>
<span>module</span> <span>SearchHelper</span>
  <span>def</span> <span>highlighted_field</span><span>(</span><span>result</span><span>,</span> <span>field</span><span>)</span>
    <span>result</span><span>[</span><span>:highlight</span><span>].</span><span>fetch</span><span>(</span><span>field</span><span>,</span> <span>{}).</span><span>fetch</span><span>(</span><span>&#34;snippet&#34;</span><span>,</span> <span>result</span><span>[</span><span>field</span><span>.</span><span>to_sym</span><span>])</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>This produces the following result:</p>

<figure>
  
</figure>

<h2>Keeping data in sync</h2>

<p>We learned how to create a collection and index documents into it. This is handy but our data would hardly be static so let&#39;s add methods to add, remove and update individual records to our <code>movies</code> collection.</p>
<div>
<pre><code><span>class</span> <span>TypesenseService</span>
  <span># Rest of the code</span>
  <span>def</span> <span>self</span><span>.</span><span>update_movie</span><span>(</span><span>id</span><span>,</span> <span>fields</span><span>)</span>
    <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>[</span><span>id</span><span>.</span><span>to_s</span><span>].</span><span>update</span><span>(</span><span>fields</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>self</span><span>.</span><span>upsert_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>serialized_movie</span> <span>=</span> <span>serialize_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>.</span><span>upsert</span><span>(</span><span>serialized_movie</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>self</span><span>.</span><span>delete_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>TYPESENSE_CLIENT</span><span>.</span><span>collections</span><span>[</span><span>&#34;movies&#34;</span><span>].</span><span>documents</span><span>[</span><span>movie</span><span>.</span><span>id</span><span>.</span><span>to_s</span><span>].</span><span>delete</span>
  <span>end</span>

  <span>private</span>

  <span>def</span> <span>self</span><span>.</span><span>serialize_movie</span><span>(</span><span>movie</span><span>)</span>
    <span>{</span>
      <span>id: </span><span>movie</span><span>.</span><span>id</span><span>.</span><span>to_s</span><span>,</span>
      <span>title: </span><span>movie</span><span>.</span><span>title</span><span>,</span>
      <span>year: </span><span>movie</span><span>.</span><span>year</span><span>,</span>
      <span>director: </span><span>movie</span><span>.</span><span>director</span><span>,</span>
      <span>rating: </span><span>movie</span><span>.</span><span>rating</span><span>.</span><span>to_f</span><span>,</span>
      <span>runtime: </span><span>movie</span><span>.</span><span>runtime</span><span>,</span>
      <span>description: </span><span>movie</span><span>.</span><span>description</span><span>,</span>
      <span>genres: </span><span>movie</span><span>.</span><span>genre_list</span><span>,</span>
    <span>}</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>Now, let&#39;s create a new movie and test that our method to index individual movies is working:</p>
<div>
<pre><code><span>movie</span> <span>=</span> <span>Movie</span><span>.</span><span>create!</span><span>(</span>
  <span>title: </span><span>&#34;Moonlight&#34;</span><span>,</span>
  <span>year: </span><span>2016</span><span>,</span>
  <span>director: </span><span>&#34;Barry Jenkins&#34;</span><span>,</span>
  <span>rating: </span><span>7.4</span><span>,</span>
  <span>runtime: </span><span>111</span><span>,</span>
  <span>description: </span><span>&#34;A young African-American man grapples with his identity and sexuality while experiencing the everyday struggles of childhood, adolescence, and burgeoning adulthood.&#34;</span>
<span>)</span>

<span>TypesenseService</span><span>.</span><span>index_movie</span><span>(</span><span>movie</span><span>)</span>
</code></pre>
</div>
<p>Now, if we search for the movie, we should get a result back:</p>

<div data-controller="light-box">        <p><img data-light-box-target="image" data-action="click-&gt;light-box#show" src="https://i.postimg.cc/qMpfJFqt/indexing-new-movie.webp" alt="Adding a document to the index" title=""/>  </p></div>

<p>To test updating (changing some fields) or upserting (creating or updating a movie) let&#39;s change the name to <strong>Moonlight Sonata</strong> in the console and update the document:</p>
<div>
<pre><code><span>movie</span> <span>=</span> <span>Movie</span><span>.</span><span>find_by</span><span>(</span><span>title: </span><span>&#34;Moonlight&#34;</span><span>)</span>
<span>movie</span><span>.</span><span>update</span><span>(</span><span>title: </span><span>&#34;Moonlight Sonata&#34;</span><span>)</span>
</code></pre>
</div>
<p>If we perform the search now, the result should be the same which means we have to update the index:</p>
<div>
<pre><code><span>TypesenseService</span><span>.</span><span>update_movie</span><span>(</span><span>movie</span><span>.</span><span>id</span><span>,</span> <span>title: </span><span>movie</span><span>.</span><span>title</span><span>)</span>
</code></pre>
</div>
<p>Now, if we search the term <code>moonlight</code> we should get the updated version returned:</p>

<div data-controller="light-box">        <p><img data-light-box-target="image" data-action="click-&gt;light-box#show" src="https://i.postimg.cc/q762pJSx/updated-index-search-with-typesense.webp" alt="Updating the Typesense index" title=""/>  </p></div>

<p>We can also use the <code>upsert</code> method and pass the movie instance:</p>
<div>
<pre><code><span>movie</span><span>.</span><span>update</span><span>(</span><span>title: </span><span>&#34;Moonlight II&#34;</span><span>)</span>
<span>TypesenseService</span><span>.</span><span>upsert_movie</span><span>(</span><span>movie</span><span>)</span>
</code></pre>
</div>
<p>Which should update the index correctly:</p>

<div data-controller="light-box">        <p><img data-light-box-target="image" data-action="click-&gt;light-box#show" src="https://i.postimg.cc/Gpz90ZhD/upsert-method-with-typesense.webp" alt="Upsert method with Typesense" title=""/>  </p></div>

<p>If we need to delete a movie from the index we can do it with the <code>delete_movie</code> method:</p>
<div>
<pre><code><span>TypesenseService</span><span>.</span><span>delete_movie</span><span>(</span><span>movie</span><span>)</span>
</code></pre>
</div>
<p>We then search for the same term and we should get no results:</p>

<div data-controller="light-box">        <p><img data-light-box-target="image" data-action="click-&gt;light-box#show" src="https://i.postimg.cc/52QNK6ZF/delete-document-from-typesense-index.webp" alt="Delete a document from Typesense index" title=""/>  </p></div>

<p>With this in place, let&#39;s add the appropriate methods to callbacks so our index is updated when we perform CRUD operations:</p>

<h3>Callbacks</h3>

<p>To keep things in sync, we should make sure we&#39;re adding new movies to the index, updating the index when a movie is updated and removing it from the index when it&#39;s deleted.</p>

<p>The following code does the trick:</p>
<div>
<pre><code><span>class</span> <span>Movie</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span># Rest of the code</span>
  <span>after_create_commit</span> <span>:index_movie</span> <span>do</span>
    <span>TypesenseService</span><span>.</span><span>index_movie</span><span>(</span><span>self</span><span>)</span>
  <span>end</span>

  <span>after_update_commit</span> <span>:update_movie</span> <span>do</span>
    <span>TypesenseService</span><span>.</span><span>update_movie</span><span>(</span><span>self</span><span>.</span><span>id</span><span>,</span> <span>self</span><span>.</span><span>attributes</span><span>)</span>
  <span>end</span>

  <span>after_destroy_commit</span> <span>:delete_movie</span> <span>do</span>
    <span>TypesenseService</span><span>.</span><span>delete_movie</span><span>(</span><span>self</span><span>)</span>
  <span>end</span>  
<span>end</span>
</code></pre>
</div>
<p>Let&#39;s add a new movie to test that everything is working:</p>
<div>
<pre><code><span>movie</span> <span>=</span> <span>Movie</span><span>.</span><span>create!</span><span>(</span>
  <span>title: </span><span>&#34;Donnie Darko&#34;</span><span>,</span>
  <span>year: </span><span>2001</span><span>,</span>
  <span>director: </span><span>&#34;Richard Kelly&#34;</span><span>,</span>
  <span>rating: </span><span>8.0</span><span>,</span>
  <span>runtime: </span><span>113</span><span>,</span>
  <span>description: </span><span>&#34;After narrowly escaping a bizarre accident, a troubled teenager is plagued by visions of a man in a large rabbit suit who manipulates him to commit a series of
crimes.&#34;</span>
<span>)</span>
</code></pre>
</div>
<p>Now, if we search for the movie we should get the result without manually adding the document to the index.</p>

<div data-controller="light-box">        <p><img data-light-box-target="image" data-action="click-&gt;light-box#show" src="https://i.postimg.cc/c1vN7627/indexing-document-in-a-rails-callback.webp" alt="Indexing a Typesense document in a Rails callback" title=""/>  </p></div>

<p>Up to this point, we have a working search feature with Rails but you might be thinking: the <code>TypesenseService</code> class is pretty tied to the <code>Movie</code> model and that accessing the <code>TYPESENSE_CLIENT</code> in the controller is a bit verbose and unnecessary.</p>

<p>We could improve that by making the service class more abstract and adding a <code>searchable</code> callback to add a <code>search</code> method to any model that includes it.</p>

<p>However, to achieve this, we will use the <code>typesense-rails</code> gem which helps us handle everything for us:</p>

<h2>Using the typesense-rails gem</h2>

<p>This gem is a fork of the <code>algolia-rails</code> gem, adapted to work with Typesense while keeping similar functionality and API.</p>

<p>Some of the features it has are:</p>

<ul>
<li>Automatic indexing with callbacks.</li>
<li>It supports multiple pagination backends like Pagy, Kaminari and WillPaginate.</li>
<li>Support for faceted search.</li>
<li>Support for nested associations.</li>
<li>Attribute customization and serialization.</li>
<li>Support for multiple and single way synonyms.</li>
</ul>

<p>Please note that at the time of writing this, the gem doesn&#39;t have a final release and its current version is <code>1.0.0.rc1</code>.</p>

<p>Let&#39;s start by removing <code>typesense-ruby</code> and installing <code>typesense-rails</code>:</p>
<div>
<pre><code><span># Gemfile</span>
<span>gem</span> <span>&#39;typesense-rails&#39;</span><span>,</span> <span>&#39;~&gt; 1.0.0.rc1&#39;</span>
</code></pre>
</div>
<p>As <code>typesense-ruby</code> is a dependency of the gem, our search feature should still be working but let&#39;s start by changing the initializer:</p>
<div>
<pre><code><span># config/initializers/typesense.rb</span>
<span>Typesense</span><span>.</span><span>configuration</span> <span>=</span> <span>{</span>
  <span>nodes: </span><span>[{</span>
    <span>host: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_HOST&#39;</span><span>,</span><span>&#39;localhost&#39;</span><span>),</span>
    <span>port: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_PORT&#39;</span><span>,</span><span>&#39;8108&#39;</span><span>),</span>
    <span>protocol: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_PROTOCOL&#39;</span><span>,</span><span>&#39;http&#39;</span><span>)</span>
  <span>}],</span>
  <span>api_key: </span><span>ENV</span><span>.</span><span>fetch</span><span>(</span><span>&#39;TYPESENSE_API_KEY&#39;</span><span>,</span><span>&#39;xyz&#39;</span><span>),</span>
  <span>connection_timeout_seconds: </span><span>2</span><span>,</span>
  <span>log_level: :info</span>
<span>}</span>
</code></pre>
</div>
<p>To start configuring it, let&#39;s remove the callbacks, include the <code>Typesense</code> module and define its configuration within the model:</p>
<div>
<pre><code><span># app/models/movie.rb</span>
<span>class</span> <span>Movie</span> <span>&lt;</span> <span>ApplicationRecord</span>
  <span>include</span> <span>Typesense</span>

  <span># Validations and associations</span>

  <span>typesense</span> <span>do</span>
    <span>attributes</span> <span>:title</span><span>,</span> <span>:description</span><span>,</span> <span>:year</span>

    <span># Dynamic attribute</span>
    <span>attribute</span> <span>:genres</span> <span>do</span>
      <span>genres</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>:name</span><span>)</span>
    <span>end</span>

    <span>default_sorting_field</span> <span>:rating</span>

    <span>predefined_fields</span> <span>[</span>
      <span>{</span><span>name: </span><span>&#39;title&#39;</span><span>,</span> <span>type: </span><span>&#39;string&#39;</span><span>},</span>
      <span>{</span><span>name: </span><span>&#39;description&#39;</span><span>,</span> <span>type: </span><span>&#39;string&#39;</span><span>},</span>
      <span>{</span><span>name: </span><span>&#39;year&#39;</span><span>,</span> <span>type: </span><span>&#39;int32&#39;</span><span>},</span>
      <span>{</span><span>name: </span><span>&#39;genres&#39;</span><span>,</span> <span>type: </span><span>&#39;string[]&#39;</span><span>}</span>
     <span>]</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>We&#39;re configuring the same things we configured before but within the model instead of using a service class.</p>

<p>Now, to test that everything&#39;s working, let&#39;s delete the <code>movies</code> collection and index it using the <code>reindex</code> method that comes with <code>typesense-rails</code>:</p>
<div>
<pre><code><span>TypesenseService</span><span>.</span><span>delete_schema</span>
<span>Movie</span><span>.</span><span>reindex</span>
</code></pre>
</div>
<p>The gem defines a <code>search</code> method that we can use to replace what we have in the controller while achieving the same result.</p>

<p>It receives the query, the fields that we want to search against and any extra search params for things like pagination or faceted search.</p>

<p>An example of its use:</p>
<div>
<pre><code><span>Movie</span><span>.</span><span>search</span><span>(</span><span>&#34;lebowski&#34;</span><span>,</span> <span>&#34;title,description&#34;</span><span>,</span> <span>{</span><span>page: </span><span>params</span><span>[</span><span>:page</span><span>],</span> <span>per_page: </span><span>2</span><span>})</span>
</code></pre>
</div>
<p>Which produces the following:</p>
<div>
<pre><code><span># =&gt;</span>
<span>[</span><span>#&lt;Movie:0x000000012aa5b060</span>
  <span>id: </span><span>121</span><span>,</span>
  <span>title: </span><span>&#34;The Big Lebowski&#34;</span><span>,</span>
  <span>year: </span><span>1998</span><span>,</span>
  <span>director: </span><span>&#34;Joel Coen&#34;</span><span>,</span>
  <span>rating: </span><span>0.79e1</span><span>,</span>
  <span>runtime: </span><span>117</span><span>,</span>
  <span>description: </span><span>&#34;Ultimate LA slacker Jeff </span><span>\&#34;</span><span>The Dude</span><span>\&#34;</span><span> Lebowski, mist...&#34;</span><span>,</span>
  <span>created_at: </span><span>&#34;2025-10-05 00:14:50.184423000 +0000&#34;</span><span>,</span>
  <span>updated_at: </span><span>&#34;2025-10-05 00:14:50.184423000 +0000&#34;</span><span>&gt;</span><span>]</span>
</code></pre>
</div>
<p>As you can see, it returns an instance of a <code>Movie</code> instead of an array of hits so we don&#39;t actually have to map that to a hash like we did before.</p>

<p>This means that we can have the following code in the controller:</p>
<div>
<pre><code><span>class</span> <span>SearchController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span>def</span> <span>index</span>
    <span>query</span> <span>=</span> <span>params</span><span>[</span><span>:query</span><span>]</span> <span>||</span> <span>&#34;&#34;</span>
    <span>@movies</span> <span>=</span> <span>[]</span>

    <span>if</span> <span>query</span><span>.</span><span>present?</span>
      <span>@movies</span> <span>=</span> <span>Movie</span><span>.</span><span>search</span><span>(</span><span>query</span><span>,</span> <span>&#34;title, description&#34;</span><span>,</span> <span>{</span>
        <span>page: </span><span>params</span><span>[</span><span>:page</span><span>]</span> <span>||</span> <span>1</span><span>,</span>
        <span>per_page: </span><span>params</span><span>[</span><span>:per_page</span><span>]</span> <span>||</span> <span>2</span>
      <span>})</span>
    <span>end</span>

    <span>respond_to</span> <span>do</span> <span>|</span><span>format</span><span>|</span>
      <span>format</span><span>.</span><span>html</span>
      <span>format</span><span>.</span><span>json</span> <span>{</span> <span>render</span> <span>json: </span><span>@movies</span><span>.</span><span>to_json</span><span>,</span> <span>status: :ok</span> <span>}</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>This produces the same result as before but with a much simpler code surface:</p>

<figure>
  
</figure>

<p>Now that we have everything working as before, let&#39;s add pagination using the Pagy gem:</p>

<h3>Pagination</h3>

<p>Luckily for us, the <code>typesense-rails</code> gem comes with built-in support for pagination.</p>

<p>Let&#39;s start by installing Pagy:</p>
<div>
<pre><code>bundle add pagy <span>&amp;&amp;</span> bundle <span>install</span>
</code></pre>
</div>
<p>The next step is to define the pagination engine in our Typesense initializer:</p>
<div>
<pre><code><span># config/initializers/typesense.rb</span>
<span>Typesense</span><span>.</span><span>configuration</span> <span>=</span> <span>{</span>
  <span># Rest of the config</span>
  <span>pagination_backend: :pagy</span>
<span>}</span>
</code></pre>
</div>
<p>Then, we require the Pagy backend module in our application controller:</p>
<div>
<pre><code><span>class</span> <span>ApplicationController</span> <span>&lt;</span> <span>ActionController</span><span>::</span><span>Base</span>
  <span>include</span> <span>Pagy</span><span>::</span><span>Backend</span>
<span>end</span>
</code></pre>
</div>
<p>And the Pagy frontend module in the application helper:</p>
<div>
<pre><code><span>module</span> <span>ApplicationHelper</span>
  <span>include</span> <span>Pagy</span><span>::</span><span>Frontend</span>
<span>end</span>
</code></pre>
</div>
<p>The next step is to define the <code>@pagy</code> variable in the controller:</p>
<div>
<pre><code><span>class</span> <span>SearchController</span> <span>&lt;</span> <span>ApplicationController</span>
  <span>def</span> <span>index</span>
    <span>@pagy</span><span>,</span> <span>@movies</span> <span>=</span> <span>Movie</span><span>.</span><span>search</span><span>(</span><span>params</span><span>[</span><span>:query</span><span>],</span> <span>&#34;title, description&#34;</span><span>,</span> <span>{</span>
      <span>per_page: </span><span>params</span><span>[</span><span>:per_page</span><span>]</span> <span>||</span> <span>2</span><span>,</span>
      <span>page: </span><span>params</span><span>[</span><span>:page</span><span>]</span> <span>||</span> <span>1</span>
    <span>})</span>

    <span>respond_to</span> <span>do</span> <span>|</span><span>format</span><span>|</span>
      <span>format</span><span>.</span><span>html</span>
      <span>format</span><span>.</span><span>json</span> <span>{</span> <span>render</span> <span>json: </span><span>@movies</span><span>.</span><span>to_json</span><span>,</span> <span>status: :ok</span> <span>}</span>
    <span>end</span>
  <span>end</span>
<span>end</span>
</code></pre>
</div>
<p>Then, we render the pagination component provided by Pagy if there is more than 1 page in the results:</p>
<div>
<pre><code><span>&lt;div</span> <span>class=</span><span>&#34;w-full&#34;</span><span>&gt;</span>
  <span>&lt;%=</span> <span>render</span> <span>&#34;search/results&#34;</span><span>,</span> <span>results: </span><span>@movies</span> <span>%&gt;</span>
  <span>&lt;%=</span><span>=</span> <span>pagy_nav</span><span>(</span><span>@pagy</span><span>)</span> <span>if</span> <span>@pagy</span><span>.</span><span>pages</span> <span>&gt;</span> <span>1</span> <span>%&gt;</span>
<span>&lt;/div&gt;</span>
</code></pre>
</div>
<p>And adding the Pagy CSS for Tailwind:</p>
<div>
<pre><code><span>/* app/assets/stylesheets/application.tailwind.css */</span>
<span>@import</span> <span>&#34;tailwindcss&#34;</span><span>;</span>

<span>.pagy</span> <span>{</span>
  <span>@apply</span> <span>flex</span> <span>space-x-1</span> <span>font-semibold</span> <span>text-sm</span> <span>text-gray-500;</span>
  <span>a</span><span>:</span><span>not</span><span>(.</span><span>gap</span><span>)</span> <span>{</span>
    <span>@</span><span>apply</span> <span>block</span> <span>rounded-lg</span> <span>px-3</span> <span>py-1</span> <span>bg-gray-200</span><span>;</span>
    <span>&amp;:hover</span> <span>{</span>
      <span>@apply</span> <span>bg-gray-300;</span>
    <span>}</span>
    <span>&amp;</span><span>:not</span><span>([</span><span>href</span><span>])</span> <span>{</span> <span>/* disabled links */</span>
      <span>@apply</span> <span>text-gray-300</span> <span>bg-gray-100</span> <span>cursor-default;</span>
    <span>}</span>
    <span>&amp;</span><span>.current</span> <span>{</span>
      <span>@apply</span> <span>text-white</span> <span>bg-gray-400;</span>
    <span>}</span>
  <span>}</span>
  <span>label</span> <span>{</span>
    <span>@apply</span> <span>inline-block</span> <span>whitespace-nowrap</span> <span>bg-gray-200</span> <span>rounded-lg</span> <span>px-3</span> <span>py-0.5;</span>
    <span>input</span> <span>{</span>
      <span>@apply</span> <span>bg-gray-100</span> <span>border-none</span> <span>rounded-md;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
</div>
<p>We then get pagination without having to do any extra work:</p>

<figure>
  
</figure>

<h2>Sorting</h2>

<p>We can determine the way results are sorted using the <code>sort_by</code> attribute and passing the field and the sorting criteria.</p>

<p>Let&#39;s add the ability to sort by the <code>year</code> of the movie in descending order.</p>
<div>
<pre><code><span>@pagy</span><span>,</span> <span>@movies</span> <span>=</span> <span>Movie</span><span>.</span><span>search</span><span>(</span><span>params</span><span>[</span><span>:query</span><span>],</span> <span>&#34;title, description&#34;</span><span>,</span> <span>{</span>
  <span>per_page: </span><span>params</span><span>[</span><span>:per_page</span><span>]</span> <span>||</span> <span>2</span><span>,</span>
  <span>page: </span><span>params</span><span>[</span><span>:page</span><span>]</span> <span>||</span> <span>1</span><span>,</span>
  <span>sort_by: </span><span>&#34;year:desc&#34;</span>
<span>})</span>
</code></pre>
</div>
<p>As you can imagine, this query sorts the results by the year a given movie was published in descending order:</p>

<figure>
  
</figure>

<p>We can modify this to show movies in ascending order by year with <code>sort_by: &#39;year:asc&#39;</code> and we can also make this configurable as long as it&#39;s useful for our users.</p>

<div>
  
  <p>Please note that for a field to be used for sorting, it needs to define <code>sort: true</code> in the collection schema.</p>
</div>

<h2>Summary</h2>

<p>Search is a requirement for most web and native applications nowadays. But not every approach to search is created equal: some of them are more “intelligent” than others.</p>

<p>For example, database-backed search using solutions like Ransack or pg_search are excellent choices for simple search, which should cover most applications, especially when starting out.</p>

<p>Solutions like Typesense, Meilisearch, Elastic Search are nice options as they allow us to detach search from the database and move it into an index that&#39;s more performant, redundant and can be fine tuned to achieve fast and sensible results.</p>

<p>In this article we showcased <strong>how to integrate Typesense into a Rails application</strong> by using the <code>typesense-ruby</code> gem which is a wrapper around the Typesense API.</p>

<p>Typesense uses a separate index of collections which are a list of related documents that we can query with different degrees of granularity.</p>

<p>The service offers simple, intelligent search by default and has a lot of nice and advanced features we can use to help our users find what they&#39;re looking for more efficiently.</p>

<p>We learned how to integrate Typesense, how to perform instant search with highlighting, how to keep data in sync between our application&#39;s records and the Typesense index and how to add advanced search features like typo tolerance or vector search.</p>

<p>All in all, Typesense is a very convenient service that we can self-host or use their paid cloud service if it makes sense for our business while also having the peace of knowing the library is open source.</p>

<p>I hope this article helps you integrate intelligent search with Typesense in your next Rails application.</p>

<p>Have a good one and happy coding!</p>

            <br/>
            
          </div>
        </div></div>
  </body>
</html>
