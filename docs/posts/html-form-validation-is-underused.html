<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://expressionstatement.com/html-form-validation-is-heavily-underused">Original</a>
    <h1>HTML Form Validation is underused</h1>
    
    <div id="readability-page-1" class="page"><div><article>HTML Forms have powerful validation mechanisms, but they are heavily underused. In fact, not many people even know much about them. Is this because of some flaw in their design? Let’s explore.<!-- -->
<h2 id="attributes-methods-and-properties">Attributes, methods, and properties</h2>
<p>It’s easy to disallow empty inputs by adding
a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/required"><code>required</code></a> attribute:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>&lt;</span><span>input</span><span> required</span><span>=</span><span>{</span><span>true</span><span>}</span><span> /&gt;</span></span></code></pre></figure>
<p>Beyond that, there is a bunch of other ways that you can add constraints to your input. Precisely, there are three ways to do it:</p>
<ul>
<li>Using specific <code>type</code> attribute values, such as <code>&#34;email&#34;</code>, <code>&#34;number&#34;</code>, or <code>&#34;url&#34;</code></li>
<li>Using other input attributes that create constraints, such as <code>&#34;pattern&#34;</code> or <code>&#34;maxlength&#34;</code></li>
<li><strong>Using the <code>setCustomValidity</code> DOM method of the input</strong></li>
</ul>
<p>The last one is the most powerful as it allows to create arbitrary validation logic and handle
complex cases.
Do you notice how it differs from the first two techniques? The first two are defined with <em>attributes</em>, but <code>setCustomValidity</code>
is a <em>method</em>.</p>
<p>Here’s a great write-up that explains the differences between DOM attributes and properties: <a href="https://jakearchibald.com/2024/attributes-vs-properties/">https://jakearchibald.com/2024/attributes-vs-properties/</a></p>
<h2 id="the-nuance-of-an-imperative-api">The nuance of an imperative API</h2>
<p>The fact that <code>setCustomValidity</code> API is exposed only as a method and doesn’t have an attribute equivalent
leads to some terrible ergonomics. I’ll show you with an example.</p>
<p>But first, a very quick intro to how this API works:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>// Make input invalid</span></span>
<span data-line=""><span>input</span><span>.</span><span>setCustomValidity</span><span>(</span><span>&#34;Any text message&#34;</span><span>)</span><span>;</span></span></code></pre></figure>
<p>This would make input <em>invalid</em> and the browser will show the reason as “Any text message”.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>// Remove custom constraints and make input valid</span></span>
<span data-line=""><span>input</span><span>.</span><span>setCustomValidity</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span></code></pre></figure>
<p>Passing an empty string makes the input <em>valid</em> (unless other constraints are applied).</p>
<p>That’s pretty much it! Now let’s apply this knowledge.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>&lt;</span><span>input</span></span>
<span data-line=""><span>  name</span><span>=</span><span>&#34;example&#34;</span></span>
<span data-line=""><span>  placeholder</span><span>=</span><span>&#34;...&#34;</span></span>
<span data-line=""><span>  onChange</span><span>=</span><span>{(</span><span>event</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>    const</span><span> input </span><span>=</span><span> event</span><span>.</span><span>currentTarget</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>    if</span><span> (input</span><span>.</span><span>value </span><span>===</span><span> &#34;&#34;</span><span>) </span><span>{</span></span>
<span data-line="" data-highlighted-line=""><span>      input</span><span>.</span><span>setCustomValidity</span><span>(</span><span>&#34;Custom message: input is empty&#34;</span><span>)</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>    }</span><span> else</span><span> {</span></span>
<span data-line="" data-highlighted-line=""><span>      input</span><span>.</span><span>setCustomValidity</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>    }</span></span>
<span data-line=""><span>  }}</span></span>
<span data-line=""><span>/&gt;</span></span></code></pre></figure>
<p>This kind of looks like we’re done and this code should be enough to accomplish the task.
But try to see it in action:</p>

<p>It may seem to work, but there’s just one important edge case: the input is
in a valid state <em>initially</em>. If you reset the component and press the “submit”
button, the form submission will go through.
But surely, before we ever touch the input, it is empty, and therefore must be invalid.
But we only ever do something when the input value <em>changes</em>.</p>
<p>How can we fix this?</p>
<p>Let’s execute some code when the component mounts:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line="" data-highlighted-line=""><span>import</span><span> {</span><span> useRef</span><span>,</span><span> useLayoutEffect </span><span>}</span><span> from</span><span> &#34;react&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> Form</span><span>()</span><span> {</span></span>
<span data-line="" data-highlighted-line=""><span>  const</span><span> ref </span><span>=</span><span> useRef</span><span>()</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>  useLayoutEffect</span><span>(</span><span>()</span><span> =&gt;</span><span> {</span></span>
<span data-line="" data-highlighted-line=""><span>    // Make input invalid on initial render if it&#39;s empty</span></span>
<span data-line="" data-highlighted-line=""><span>    const</span><span> input </span><span>=</span><span> ref</span><span>.</span><span>current</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>    const</span><span> empty </span><span>=</span><span> input</span><span>.</span><span>value </span><span>!==</span><span> &#34;&#34;</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>    input</span><span>.</span><span>setCustomValidity</span><span>(empty </span><span>?</span><span> &#34;Initial message: input is empty&#34;</span><span> :</span><span> &#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line="" data-highlighted-line=""><span>  },</span><span> [])</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> (</span></span>
<span data-line=""><span>    &lt;</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>input</span></span>
<span data-line=""><span>        ref</span><span>=</span><span>{</span><span>ref</span><span>}</span></span>
<span data-line=""><span>        name</span><span>=</span><span>&#34;example&#34;</span></span>
<span data-line=""><span>        onChange</span><span>=</span><span>{(</span><span>event</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>          const</span><span> input </span><span>=</span><span> event</span><span>.</span><span>currentTarget</span><span>;</span></span>
<span data-line=""><span>          if</span><span> (input</span><span>.</span><span>value </span><span>===</span><span> &#34;&#34;</span><span>) </span><span>{</span></span>
<span data-line=""><span>            input</span><span>.</span><span>setCustomValidity</span><span>(</span><span>&#34;Custom message: input is empty&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>          }</span><span> else</span><span> {</span></span>
<span data-line=""><span>            input</span><span>.</span><span>setCustomValidity</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>          }</span></span>
<span data-line=""><span>        }}</span></span>
<span data-line=""><span>      /&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>button</span><span>&gt;</span><span>Submit</span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span data-line=""><span>    &lt;/</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>  )</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>

<p>Great! Now everything works as expected. But at what cost?</p>
<h2 id="the-boilerplate-problem">The boilerplate problem</h2>
<p>Let’s look at our clumsy way to validate the initial value:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>const</span><span> ref </span><span>=</span><span> useRef</span><span>()</span><span>;</span></span>
<span data-line=""><span>useLayoutEffect</span><span>(</span><span>()</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>  // Make input invalid on initial render if it&#39;s empty</span></span>
<span data-line=""><span>  const</span><span> input </span><span>=</span><span> ref</span><span>.</span><span>current</span><span>;</span></span>
<span data-line=""><span>  const</span><span> empty </span><span>=</span><span> input</span><span>.</span><span>value </span><span>!==</span><span> &#34;&#34;</span><span>;</span></span>
<span data-line=""><span>  input</span><span>.</span><span>setCustomValidity</span><span>(empty </span><span>?</span><span> &#34;Initial message: input is empty&#34;</span><span> :</span><span> &#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>},</span><span> [])</span><span>;</span></span></code></pre></figure>
<p>Ugh! Wouldn’t want to write that one each time. Let’s think about what’s wrong with this.</p>
<ul>
<li>The validation logic is duplicated between the onChange handler and the initial render phase</li>
<li>The initial validation is not co-located with the input, so we’re losing code cohesion.
It’s fragile: if you update validation logic, you might forget to update code in both places.</li>
<li>The <code>useRef</code> + <code>useLayouEffect</code> + <code>onChange</code> combo is just too much ceremony,
especially when a form has a lot of inputs. And it gets even more confusing if only some of those inputs use <code>customValidity</code></li>
</ul>
<p>This is what happens when you deal with a purely imperative API in a declarative component.</p>
<blockquote>
<p>Unlike validation attributes, <code>CustomValidity</code> is a purely imperative API.
In other words, there’s no input attribute that we can use to set custom validity.</p>
</blockquote>
<p>In fact, I would argue that this is <strong>the main reason for poor adoption of native form validation</strong>. If the API is cumbersome, sometimes it just does not matter how powerful it is.</p>
<h2 id="the-missing-part">The missing part</h2>
<p>In essence, this is the attribute we need:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="html" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="html" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>&lt;</span><span>input</span><span> custom-validity</span><span>=</span><span>&#34;error message&#34;</span><span> /&gt;</span></span></code></pre></figure>
<p>In a declarative framework, this would allow to define input validations in a very powerful way:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>function</span><span> Form</span><span>()</span><span> {</span></span>
<span data-line=""><span>  const</span><span> [</span><span>value</span><span>,</span><span> setValue</span><span>]</span><span> =</span><span> useState</span><span>()</span><span>;</span></span>
<span data-line=""><span>  const</span><span> handleChange</span><span> =</span><span> (</span><span>event</span><span>)</span><span> =&gt;</span><span> setValue</span><span>(event</span><span>.</span><span>target</span><span>.</span><span>value)</span><span>;</span></span>
<span data-line=""><span>  return</span><span> (</span></span>
<span data-line=""><span>    &lt;</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>input</span></span>
<span data-line=""><span>        name</span><span>=</span><span>&#34;example&#34;</span></span>
<span data-line=""><span>        value</span><span>=</span><span>{</span><span>value</span><span>}</span></span>
<span data-line=""><span>        onChange</span><span>=</span><span>{</span><span>handleChange</span><span>}</span></span>
<span data-line="" data-highlighted-line=""><span>        custom-validity</span><span>=</span><span>{</span><span>value</span><span>.</span><span>length </span><span>?</span><span> &#34;Fill out this field&#34;</span><span> :</span><span> &#34;&#34;</span><span>}</span></span>
<span data-line=""><span>      /&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>button</span><span>&gt;</span><span>Submit</span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span data-line=""><span>    &lt;/</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>  )</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Pretty cool! In my opinion, at least. Though you can rightfully argue that this accomplishes only what
the existing <code>required</code> attribute is already capable of. Where’s the “power”?</p>
<p>Let me show you, but first, since there’s no actual <code>custom-validity</code> currently
in the <a href="https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#the-constraint-validation-api">HTML Spec</a>,
let’s implement it in userland.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>function</span><span> Input</span><span>({</span><span> customValidity</span><span>,</span><span> ...</span><span>props</span><span> })</span><span> {</span></span>
<span data-line=""><span>  const</span><span> ref </span><span>=</span><span> useRef</span><span>()</span><span>;</span></span>
<span data-line=""><span>  useLayoutEffect</span><span>(</span><span>()</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>    if</span><span> (customValidity </span><span>!=</span><span> null</span><span>) </span><span>{</span></span>
<span data-line=""><span>      const</span><span> input </span><span>=</span><span> ref</span><span>.</span><span>current</span><span>;</span></span>
<span data-line=""><span>      input</span><span>.</span><span>setCustomValidity</span><span>(customValidity)</span><span>;</span></span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>  },</span><span> [customValidity])</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> &lt;</span><span>input</span><span> ref</span><span>=</span><span>{</span><span>ref</span><span>}</span><span> {</span><span>...</span><span>props</span><span>}</span><span> /&gt;</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>This will work well for our demo purposes.</p>
<h2 id="the-power">The power</h2>
<p>Now we’ll explore which non-trivial cases this design can help solve.</p>
<p>In real-world apps, validation often gets more complex than local checks.
Imagine a username input that should be <strong>valid only if the username is not taken</strong>.
This would require async calls to your server and an intermediary state: the form
should not be valid while the check is in progress.
Let’s see how our abstraction can handle this.</p>

<p>Play around with this example. It uses the <code>required</code> to prevent empty inputs. But then it relies on <code>customValidity</code> to mark input as invalid during the loading state and based on the response.</p>
<h3 id="implementation">Implementation</h3>
<p>First, we create an async function to check whether the username is unique that imitates a server request with a delay.</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="js" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>export</span><span> async</span><span> function</span><span> verifyUsername</span><span>(</span><span>userValue</span><span>)</span><span> {</span></span>
<span data-line=""><span>  // imitate network delay</span></span>
<span data-line=""><span>  await</span><span> new</span><span> Promise</span><span>(</span><span>(</span><span>r</span><span>)</span><span> =&gt;</span><span> setTimeout</span><span>(r</span><span>,</span><span> 3000</span><span>))</span><span>;</span></span>
<span data-line=""><span>  const</span><span> value </span><span>=</span><span> userValue</span><span>.</span><span>trim</span><span>()</span><span>.</span><span>toLowerCase</span><span>()</span><span>;</span></span>
<span data-line=""><span>  if</span><span> (value </span><span>===</span><span> &#34;bad input&#34;</span><span>) </span><span>{</span></span>
<span data-line=""><span>    throw</span><span> new</span><span> Error</span><span>(</span><span>&#34;Bad Input&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>  }</span></span>
<span data-line=""><span>  const</span><span> validationMessage </span><span>=</span><span> value </span><span>===</span><span> &#34;taken&#34;</span><span> ?</span><span> &#34;Username is taken&#34;</span><span> :</span><span> &#34;&#34;</span><span>;</span></span>
<span data-line=""><span>  return</span><span> {</span><span> validationMessage </span><span>};</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Next, we’ll create a controlled form component and use <a href="https://tanstack.com/query/latest">react-query</a> to manage to server request when the input value changes:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>import</span><span> {</span><span> useState </span><span>}</span><span> from</span><span> &#34;react&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> useQuery </span><span>}</span><span> from</span><span> &#34;@tanstack/react-query&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> verifyUsername </span><span>}</span><span> from</span><span> &#34;./verifyUsername&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> Input </span><span>}</span><span> from</span><span> &#34;./Input&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> Form</span><span>()</span><span> {</span></span>
<span data-line=""><span>  const</span><span> [</span><span>value</span><span>,</span><span> setValue</span><span>]</span><span> =</span><span> useState</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>  const</span><span> {</span><span> data</span><span>,</span><span> isLoading</span><span>,</span><span> isError </span><span>}</span><span> =</span><span> useQuery</span><span>(</span><span>{</span></span>
<span data-line=""><span>    queryKey</span><span>:</span><span> [</span><span>&#34;verifyUsername&#34;</span><span>,</span><span> value]</span><span>,</span></span>
<span data-line=""><span>    queryFn</span><span>:</span><span> ()</span><span> =&gt;</span><span> verifyUsername</span><span>(value)</span><span>,</span></span>
<span data-line=""><span>    enabled</span><span>:</span><span> Boolean</span><span>(value)</span><span>,</span></span>
<span data-line=""><span>  }</span><span>)</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> (</span></span>
<span data-line=""><span>    &lt;</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>Input</span></span>
<span data-line=""><span>        name</span><span>=</span><span>&#34;username&#34;</span></span>
<span data-line=""><span>        required</span><span>=</span><span>{</span><span>true</span><span>}</span></span>
<span data-line=""><span>        value</span><span>=</span><span>{</span><span>value</span><span>}</span></span>
<span data-line=""><span>        onChange</span><span>=</span><span>{(</span><span>event</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>          setValue</span><span>(event</span><span>.</span><span>currentTarget</span><span>.</span><span>value)</span><span>;</span></span>
<span data-line=""><span>        }}</span></span>
<span data-line=""><span>      /&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>button</span><span>&gt;</span><span>Submit</span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span data-line=""><span>    &lt;/</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>  )</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>Great! We have the setup in place. It consists of two crucial parts:</p>
<ul>
<li>Verification request state managed by <code>useQuery</code></li>
<li>Our custom <code>&lt;Input /&gt;</code> component that is capable of taking the <code>customValidity</code> prop</li>
</ul>
<p>Let’s put those pieces together:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>import</span><span> {</span><span> useState </span><span>}</span><span> from</span><span> &#34;react&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> useQuery </span><span>}</span><span> from</span><span> &#34;@tanstack/react-query&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> verifyUsername </span><span>}</span><span> from</span><span> &#34;./verifyUsername&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> Input </span><span>}</span><span> from</span><span> &#34;./Input&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> Form</span><span>()</span><span> {</span></span>
<span data-line=""><span>  const</span><span> [</span><span>value</span><span>,</span><span> setValue</span><span>]</span><span> =</span><span> useState</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>  const</span><span> {</span><span> data</span><span>,</span><span> isLoading</span><span>,</span><span> isError </span><span>}</span><span> =</span><span> useQuery</span><span>(</span><span>{</span></span>
<span data-line=""><span>    queryKey</span><span>:</span><span> [</span><span>&#34;verifyUsername&#34;</span><span>,</span><span> value]</span><span>,</span></span>
<span data-line=""><span>    queryFn</span><span>:</span><span> ()</span><span> =&gt;</span><span> verifyUsername</span><span>(value)</span><span>,</span></span>
<span data-line=""><span>    enabled</span><span>:</span><span> Boolean</span><span>(value)</span><span>,</span></span>
<span data-line=""><span>  }</span><span>)</span><span>;</span></span>
<span data-line=""> </span>
<span data-line="" data-highlighted-line=""><span>  const</span><span> validationMessage </span><span>=</span><span> data</span><span>?.</span><span>validationMessage</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>  return</span><span> (</span></span>
<span data-line=""><span>    &lt;</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>Input</span></span>
<span data-line=""><span>        name</span><span>=</span><span>&#34;username&#34;</span></span>
<span data-line=""><span>        required</span><span>=</span><span>{</span><span>true</span><span>}</span></span>
<span data-line="" data-highlighted-line=""><span>        customValidity</span><span>=</span><span>{</span></span>
<span data-line="" data-highlighted-line=""><span>          isLoading</span></span>
<span data-line="" data-highlighted-line=""><span>            ?</span><span> &#34;Verifying username...&#34;</span></span>
<span data-line="" data-highlighted-line=""><span>            :</span><span> isError</span></span>
<span data-line="" data-highlighted-line=""><span>            ?</span><span> &#34;Could not verify&#34;</span></span>
<span data-line="" data-highlighted-line=""><span>            :</span><span> validationMessage</span></span>
<span data-line="" data-highlighted-line=""><span>        }</span></span>
<span data-line=""><span>        value</span><span>=</span><span>{</span><span>value</span><span>}</span></span>
<span data-line=""><span>        onChange</span><span>=</span><span>{(</span><span>event</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>          setValue</span><span>(event</span><span>.</span><span>currentTarget</span><span>.</span><span>value)</span><span>;</span></span>
<span data-line=""><span>        }}</span></span>
<span data-line=""><span>      /&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>button</span><span>&gt;</span><span>Submit</span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span data-line=""><span>    &lt;/</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>  )</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>That’s it! We’re describing the whole async validation flow, including
loading, error and success states, <em>in one attribute</em>. You can go back to see <a href="#example-async-username">the result</a> again if you wish</p>
<h3 id="one-more">One more</h3>
<p>This one will be shorter, but also interesting, because it covers dependent input
fields. Let’s implement a form that requires to repeat the entered password:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><code data-language="jsx" data-theme="catppuccin-macchiato catppuccin-frappe"><span data-line=""><span>import</span><span> {</span><span> useState </span><span>}</span><span> from</span><span> &#34;react&#34;</span><span>;</span></span>
<span data-line=""><span>import</span><span> {</span><span> Input </span><span>}</span><span> from</span><span> &#34;./Input&#34;</span><span>;</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> ConfirmPasswordForm</span><span>()</span><span> {</span></span>
<span data-line=""><span>  const</span><span> [</span><span>password</span><span>,</span><span> setPassword</span><span>]</span><span> =</span><span> useState</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line=""><span>  const</span><span> [</span><span>confirmedPass</span><span>,</span><span> setConfirmedPass</span><span>]</span><span> =</span><span> useState</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>;</span></span>
<span data-line=""> </span>
<span data-line="" data-highlighted-line=""><span>  const</span><span> matches </span><span>=</span><span> confirmedPass </span><span>===</span><span> password</span><span>;</span></span>
<span data-line=""><span>  return</span><span> (</span></span>
<span data-line=""><span>    &lt;</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>Input</span></span>
<span data-line=""><span>        type</span><span>=</span><span>&#34;password&#34;</span></span>
<span data-line=""><span>        name</span><span>=</span><span>&#34;password&#34;</span></span>
<span data-line=""><span>        required</span><span>=</span><span>{</span><span>true</span><span>}</span></span>
<span data-line=""><span>        value</span><span>=</span><span>{</span><span>password</span><span>}</span></span>
<span data-line=""><span>        onChange</span><span>=</span><span>{(</span><span>event</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>          setPassword</span><span>(event</span><span>.</span><span>currentTarget</span><span>.</span><span>value)</span><span>;</span></span>
<span data-line=""><span>        }}</span></span>
<span data-line=""><span>      /&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>Input</span></span>
<span data-line=""><span>        type</span><span>=</span><span>&#34;password&#34;</span></span>
<span data-line=""><span>        name</span><span>=</span><span>&#34;confirmedPassword&#34;</span></span>
<span data-line=""><span>        required</span><span>=</span><span>{</span><span>true</span><span>}</span></span>
<span data-line=""><span>        value</span><span>=</span><span>{</span><span>confirmedPass</span><span>}</span></span>
<span data-line="" data-highlighted-line=""><span>        customValidity</span><span>=</span><span>{</span><span>matches </span><span>?</span><span> &#34;&#34;</span><span> :</span><span> &#34;Password must match&#34;</span><span>}</span></span>
<span data-line=""><span>        onChange</span><span>=</span><span>{(</span><span>event</span><span>)</span><span> =&gt;</span><span> {</span></span>
<span data-line=""><span>          setConfirmedPass</span><span>(event</span><span>.</span><span>currentTarget</span><span>.</span><span>value)</span><span>;</span></span>
<span data-line=""><span>        }}</span></span>
<span data-line=""><span>      /&gt;</span></span>
<span data-line=""><span>      &lt;</span><span>button</span><span>&gt;</span><span>Submit</span><span>&lt;/</span><span>button</span><span>&gt;</span></span>
<span data-line=""><span>    &lt;/</span><span>form</span><span>&gt;</span></span>
<span data-line=""><span>  )</span><span>;</span></span>
<span data-line=""><span>}</span></span></code></pre></figure>
<p>You can try it out:</p>

<h2 id="conclusion">Conclusion</h2>
<p>I hope I’ve been able to show you how <code>setCustomValidity</code> can cover
validation needs of all kinds.</p>
<p>But the real power comes from great APIs.</p>
<p>And hopefully, you are now equipped with one of those.</p>
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<!-- -->
<div><p><img src="https://pbs.twimg.com/profile_images/826440416371302400/HosO7Uze_400x400.jpg" alt=""/></p></div></article></div></div>
  </body>
</html>
