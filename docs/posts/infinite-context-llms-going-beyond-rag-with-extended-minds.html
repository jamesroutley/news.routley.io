<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.normalcomputing.ai/posts/2023-09-12-supersizing-transformers/supersizing-transformers.html">Original</a>
    <h1>Infinite Context LLMs: Going Beyond RAG with Extended Minds</h1>
    
    <div id="readability-page-1" class="page"><div id="quarto-document-content">




<p>Today’s popularized large language models are optimized for the task of producing sequences of tokens that look like they could’ve been present in the training corpus. This is quite distinct from the ways in which LLMs are wielded in such user interfaces as <a href="https://chat.openai.com/?model=gpt-4">ChatGPT</a> or <a href="https://www.perplexity.ai/">Perplexity.ai</a>, where users expect the model to perform complex reasoning tasks and faithfully retrieve factual, topical information. If we hope to use the model as a general reasoning agent and not as a stochastic parrot, we need to provide it with any relevant data at inference time, rather than rely on (1) the salient data having appeared in the training corpus and (2) the model being able to recall said data. Further, surfacing references or citations that highlight which content the model used during its generation is crucial for building applications that truly augment human workflows.</p>
<p>This has prompted much development on methods colloquially referred to as “retrieval”<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Or, methods that help LLMs make use of pertinent documents. <strong>In context learning</strong>, or placing the relevant documents in the context window before the prompt, is the obvious first step. However, in many cases we’re faced with documents longer than the context window of the model. <strong>RAG</strong><a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a> attempts to sidestep this by selecting the best subset of documents to include alongside the user’s query. While often effective, RAG is fundamentally limited by the need for a separate search engine. We can’t, for instance, ask the model questions which require synthesizing the entire set of documents. Further, since the retrieval happens before the generation, the best we can do r.e. explainability is report which text was included in the prompt itself. This says nothing about what text the model actually used during generation.</p>
<p>Finetuning<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a> seeks to extend the length of the context window itself. Running even a few epochs of training can be a non-trivial undertaking for today’s large models, even with a dedicated ML team. Further, these methods doesn’t contribute to the model’s interpretability. Other methods<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a> suggest structural changes to the model. Many of these are exciting, but most require training from scratch or fine-tuning, making them difficult to leverage with pre-trained models.</p>
<p>In this post, we propose and <a href="https://huggingface.co/normalcomputing">open source</a> <strong>extended mind transformers</strong>, which generalize RAG internally. This simple mathematical generalization buys us the performance gains (and more) of RAG, as well as introducing net-new generation controls and granular <em>causal</em> citations. We also get the best of both worlds when it comes to ease of use: seamless integrations (everything is internal to the model), and no fine-tuning required!</p>
<div>
<figure>
<p><img src="https://storage.googleapis.com/normal-blog-artifacts/extended-mind-transformers/otto.png"/></p>
<figcaption>Credits: <span data-cites="patrick-blog">Buchen (<a href="#ref-patrick-blog" role="doc-biblioref">2018</a>)</span></figcaption>
</figure>
</div>
<section id="aesthetics-for-extended-mind-transformers">
<h2 data-anchor-id="aesthetics-for-extended-mind-transformers">Aesthetics for Extended Mind Transformers</h2>
<p>As motivation, we provide context from the Philosophy of Mind which served as inspiration for the naming convention and methodology. In <span data-cites="clark-chalmers">Clark and Chalmers (<a href="#ref-clark-chalmers" role="doc-biblioref">1998</a>)</span> “The Extended Mind”, they present the thesis that external information which is constantly and immediately accessible, and automatically endorsed should be considered part of the memory. And further, that this extension should be considered part of the mind. They term this idea <strong>active externalism</strong>. The story of Otto functions as an intuition pump:</p>
<blockquote>
<p>“[L]ike many Alzheimer’s patients, [Otto] relies on information in the environment to help structure his life. Otto carries a notebook around with him everywhere he goes. When he learns new information, he writes it down. When he needs some old information, he looks it up. For Otto, his notebook plays the role usually played by a biological memory. … The information in the notebook functions just like information constituting an ordinary non-occurrent belief; it just happens that this information lies beyond the skin.”<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
</blockquote>
<p>In this piece, we present active externalism for LLMs, a mechanism for bolstering the memory of transformers aesthetically inspired by the Extended Mind Thesis. We call transformers which implement active externalism, extended mind transformers.</p>
</section>
<section id="extended-mind-transformers">
<h2 data-anchor-id="extended-mind-transformers">Extended Mind Transformers</h2>
<section id="definition">
<h3 data-anchor-id="definition">Definition</h3>
<p>Our proposed method, which closely resembles the work of <span data-cites="wu2022memorizing">Wu et al. (<a href="#ref-wu2022memorizing" role="doc-biblioref">2022</a>)</span><a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>, is a simple change to the self-attention mechanism. In addition to the causal self-attention integral to transformers, we also allow each query token to attend to a fixed number of “external memories”. These memories are stored in a non-differentiable cache. The choice of which memories to attend to is made using cosine similarity within each decoder layer and attention head. More precisely, our attention computation is described by:</p>
<p><span>\[
\operatorname{softmax}\left(\frac{Q(K_{R}\oplus K_{L})^{T}}{\sqrt{d}}\right) \times \left(V_{R} \oplus V_{L}\right)
\]</span></p>
<p>Where <span>\((K_{L}, V_{L})\)</span> are key-value pairs from local context, and <span>\((K_{R}, V_{R})\)</span> are key-value pairs from external memories, and <span>\(\oplus\)</span> refers to tensor concatenation. We mask the attention weights such that each query token can only attend to its own retrieved keys, and not those retrieved by previous or following query tokens. In the experiments we present below we use models trained with linear biases rather than positional encodings. When we apply these linear biases to our attention weights, we assign the same index to all retrieved memories.<a href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<p>Importantly, <strong>active externalism retrieves memories exactly</strong> - it doesn’t summarize or otherwise dampen memories except through the linear biases.</p>
<p>We generate the external memories (key-value pairs) once, and then pass the representations to each decoder layer in an analogous fashion to passing previous “cached” key-values<a href="#fn8" id="fnref8" role="doc-noteref"><sup>8</sup></a>. In order to speed up the top-k cosine similarity computation we can use a vector database designed exactly for this purpose<a href="#fn9" id="fnref9" role="doc-noteref"><sup>9</sup></a>.</p>
<p>We argue that this way of attending to external memories or beliefs is the natural and optimal generalization of methods like RAG, and closely mimics the kind of relationship Otto has with his notebook. The information is constantly and immediately accessible, automatically endorsed, and reliably referenced. We set a similarity threshold such that we always reference our external memories (for every generated token, within all decoder layers), but discard keys that don’t meet some low similarity threshold<a href="#fn10" id="fnref10" role="doc-noteref"><sup>10</sup></a> to avoid confusing the model with irrelevant information.</p>
<p>Active externalism is not conceptually difficult to implement, but does require getting familiar with a particular model’s implementation since details like the way key-value pairs are stored and read into the self-attention computation need to be hijacked.</p>
</section>
</section>
<section id="benchmark-results">
<h2 data-anchor-id="benchmark-results">Benchmark Results</h2>
<section id="perplexity-experiments">
<h3 data-anchor-id="perplexity-experiments">Perplexity Experiments</h3>
<p>We use perplexity as a metric for model performance. Perplexity is a measure of uncertainty of the model over each generated token, closely related to our cross-entropy loss function. For a full explanation of perplexity as a metric, we suggest checking out this excellent <a href="https://thegradient.pub/understanding-evaluation-metrics-for-language-models/">post</a>.</p>
<p>We show results below for perplexity experiments on the Wikitext-103 benchmark<a href="#fn11" id="fnref11" role="doc-noteref"><sup>11</sup></a> using Mosaic’s MPT-7b model. We use a stride of 512 tokens in our perplexity experiments, meaning each token is conditioned on at least 512 previous tokens, given that there are indeed 512 tokens to condition on.</p>
<p>Our active externalism method batches each sequence into chunks of increasing length (x-axis), and attends to tokens previous to the last 2048 (max sequence length) as external memories. We show results for varying k, where k is the number of memories we retrieve per query token. We compare active externalism to two baseline methods. The “truncated” baseline simply throws out any tokens previous to the last 2048 during perplexity computations, and the “naive” method which uses all input-length tokens, no matter how long the sequences become.</p>
<p>In the case of the naive method, we observe exactly the phenomenon active externalism seeks to ameliorate: after sequences exceed lengths greater than 2-3k tokens, the performance quickly drops off (in this case, perplexity blows up).</p>
<div>
<figure>
<p><img src="https://storage.googleapis.com/normal-blog-artifacts/extended-mind-transformers/naive.png"/></p>
<figcaption>Perplexity results for Naive and Extended Mind MTP-7b, using a stride length of 512 tokens. Documents are batched into lengths of “Input Length” and we report average PPL on Y-Axis.</figcaption>
</figure>
</div>
<p>While we can see that active externalism provides clear benefits over simply doing local attention, in the case of the truncated benchmark. Even more exciting, perplexity continues to decrease as we increase the number of retrieved memories per query token.</p>
<div>
<figure>
<p><img src="https://storage.googleapis.com/normal-blog-artifacts/extended-mind-transformers/truncated.png"/></p>
<figcaption>Perplexity results for Truncated and Extended Mind MTP-7b, using a stride length of 512 tokens. Documents are batched into lengths of “Input Length” and we report average PPL on Y-Axis.</figcaption>
</figure>
</div>
</section>
<section id="retrieval-experiments">
<h3 data-anchor-id="retrieval-experiments">Retrieval Experiments</h3>
<p>We also measure performance on retrieval benchmarks, and compare with RAG and simple baselines. Our dataset is a modified version of the recently released <a href="https://huggingface.co/datasets/abacusai/WikiQA-Free_Form_QA">Long context WikiQA benchmark</a> from Abacus.AI.</p>
<p>Our goal is to measure retrieval abilities over varying document lengths, but we also want to control for facts memorized during training, so we edit the dataset by changing the labeled answers to realistic but wrong answers. I.e, we replace every instance of “Lee Hazlewood” with “Terry Allen” in the Wikipedia entry for the song “These Boots Were Made For Walking”, and then ask the model to produce the songwriter’s name, with the <em>correct</em> answer now being “Terry Allen”.</p>
<p>Our intention is to measure the model’s ability to prioritize in context or in memory facts over those it memorized during training. Again, we feel this is an important ability if we’re asking LLMs to be reasoning agents in an evolving world.</p>
<p>In the results below, baseline receives no context at all for the question (we ask it point-blank), RAG selects the best ~2-3k tokens out of the document to include in-context<a href="#fn12" id="fnref12" role="doc-noteref"><sup>12</sup></a>, and active externalism puts the entire document in memory and uses it as Otto uses his notebook.</p>
<div>
<figure>
<p><img src="https://storage.googleapis.com/normal-blog-artifacts/extended-mind-transformers/retrieval.png"/></p>
<figcaption>Retrieval Benchmark Results, by Document Length<a href="#fn13" id="fnref13" role="doc-noteref"><sup>13</sup></a></figcaption>
</figure>
</div>
<p>We see that while RAG methods drop off with input length, active externalism continues to be effective. While models finetuned to use longer contexts do currently outperform active externalism on some long-range retrieval tasks, active externalism appears to be a more effective way to do retrieval over long contexts for smaller models.</p>
<p>Where active externalism clearly outperforms RAG in large models is precisely where the model has <a href="https://arxiv.org/pdf/2205.10770.pdf">memorized before overfitting</a>. Or, the model’s weights encode factual information even as the model’s performance on test data<a href="#fn14" id="fnref14" role="doc-noteref"><sup>14</sup></a> continues to improve. Depending on your application, this could be seen as a strength or shortcoming. Certainly when we use LLMs as reasoning agents, this is a shortcoming.</p>
<p>Using active externalism also appears to eliminate some reliance on prompting. Whereas usually we’d need to include some examples of the kind of responses we hope to observe in the prompt (or use a “chat” model which has been RLHF’ed), we observe experimentally that this isn’t necessary when using active externalism.</p>
</section>
</section>
<section id="impact-on-reasoning-engine">
<h2 data-anchor-id="impact-on-reasoning-engine">Impact on reasoning engine</h2>
<p>We discuss two important consequences of active externalism on the LLM’s ability as a reasoning agent: uncertainty awareness and abstraction levers.</p>
<p>If we prompt the model with a question it’s unsure about<a href="#fn15" id="fnref15" role="doc-noteref"><sup>15</sup></a>, it may not respond in a way that’s transparent about that uncertainty. Active externalism provides a new method for revealing when a model is uncertain about its answer.</p>
<p>Let’s look at an example. We load our model easily from huggingface, and pass a paragraph from Wikipedia’s entry on Grothendieck as external memories.</p>
<div data-execution_count="1">
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1"></a><span>import</span> transformers</span>
<span id="cb1-2"><a href="#cb1-2"></a><span>from</span> transformers <span>import</span> AutoTokenizer, AutoModelForCausalLM</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>wikipedia <span>=</span> <span>&#34;&#34;&#34;Alexander Grothendieck (/ˈɡroʊtəndiːk/; German pronunciation: [ˌalɛˈksandɐ ˈɡʁoːtn̩ˌdiːk] (listen); French: [ɡʁɔtɛndik]; 28 March 1928 – 13 November 2014) was a stateless (and then, since 1971, French) mathematician who became the leading figure in the creation of modern algebraic geometry.[7][8] His research extended the scope of the field and added elements of commutative algebra, homological algebra, sheaf theory, and category theory to its foundations, while his so-called &#34;relative&#34; perspective led to revolutionary advances in many areas of pure mathematics.[7][9] He is considered by many to be the greatest mathematician of the twentieth century.[10][11]</span></span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span>Grothendieck began his productive and public career as a mathematician in 1949. In 1958, he was appointed a research professor at the Institut des hautes études scientifiques (IHÉS) and remained there until 1970, when, driven by personal and political convictions, he left following a dispute over military funding. He received the Fields Medal in 1966 for advances in algebraic geometry, homological algebra, and K-theory.[12] He later became professor at the University of Montpellier[1] and, while still producing relevant mathematical work, he withdrew from the mathematical community and devoted himself to political and religious pursuits (first Buddhism and later, a more Christian vision).[13] In 1991, he moved to the French village of Lasserre in the Pyrenees, where he lived in seclusion, still working tirelessly on mathematics and his philosophical and religious thoughts until his death in 2014.[14]</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span>&#34;&#34;&#34;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>tokenizer <span>=</span> AutoTokenizer.from_pretrained(<span>&#39;EleutherAI/gpt-neox-20b&#39;</span>)</span>
<span id="cb1-10"><a href="#cb1-10"></a>memory_ids <span>=</span> tokenizer(wikipedia, return_tensors<span>=</span><span>&#39;pt&#39;</span>)[<span>&#39;input_ids&#39;</span>]</span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a>model <span>=</span> AutoModelForCausalLM.from_pretrained(<span>&#34;normalcomputing/extended-mind-mpt-7b&#34;</span>, external_memories<span>=</span>memory_ids, trust_remote_code<span>=</span><span>True</span>)</span></code></pre></div>
</div>
<p>Now, let’s ask the model a question we know is answered (albeit a little obscurely) in the above paragraph without using active externalism. We can achieve this by setting the parameter <code>model.use_active_externalism = False</code> or simply passing <code>topk=0</code>. Hint: the correct answer is 1971.</p>
<div data-execution_count="3">
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1"></a>prompt <span>=</span> <span>&#34;When did Alexander Grothendieck get his French citizenship?&#34;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>input_ids <span>=</span> tokenizer(prompt, return_tensors<span>=</span><span>&#39;pt&#39;</span>)[<span>&#39;input_ids&#39;</span>]</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>50</span>, topk<span>=</span><span>0</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span>print</span>(<span>&#39;Baseline Generation: &#39;</span>, tokenizer.decode(out[<span>0</span>]))</span></code></pre></div>
<div>
<pre><code>Baseline Generation:  When did Alexander Grothendieck get his French citizenship?
I am trying to find out when Alexander Grothendieck got his French citizenship. I know that he was born in Germany and that he got his French citizenship in the late 1950s. I am trying to find out when he got his</code></pre>
</div>
</div>
<p>Now let’s enable active externalism, slowly cranking up the number of memories each query token is allowed to attend to using the <code>topk</code> parameter.</p>
<div data-execution_count="4">
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>15</span>, topk<span>=</span><span>5</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span>print</span>(<span>&#39;Generation for k=5: &#39;</span>, tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>15</span>, topk<span>=</span><span>6</span>)</span>
<span id="cb4-5"><a href="#cb4-5"></a><span>print</span>(<span>&#39;Generation for k=6: &#39;</span>,tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span>
<span id="cb4-6"><a href="#cb4-6"></a></span>
<span id="cb4-7"><a href="#cb4-7"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>20</span>, topk<span>=</span><span>7</span>)</span>
<span id="cb4-8"><a href="#cb4-8"></a><span>print</span>(<span>&#39;Generation for k=7: &#39;</span>,tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span>
<span id="cb4-9"><a href="#cb4-9"></a></span>
<span id="cb4-10"><a href="#cb4-10"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>15</span>, topk<span>=</span><span>8</span>)</span>
<span id="cb4-11"><a href="#cb4-11"></a><span>print</span>(<span>&#39;Generation for k=8: &#39;</span>,tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>20</span>, topk<span>=</span><span>30</span>)</span>
<span id="cb4-14"><a href="#cb4-14"></a><span>print</span>(<span>&#39;Generation for k=30: &#39;</span>,tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span></code></pre></div>
<div>
<pre><code>Generation for k=5:  A: I think he got it in the early 1960s.
Generation for k=6:  A: I think he got it in the early 1970s.
Generation for k=7:  A: He was born in France, and he was naturalized in 1971.
&lt;|endoftext|&gt;
Generation for k=8:  A: I think he got it in 1971.
&lt;|endoftext|&gt;Q
Generation for k=30:  A: He was born in Germany, and became a French citizen in 1971.</code></pre>
</div>
</div>
<p>Not only did the model produce the correct answer, but it also expressed increasing certainty about its answer. This evolution of generations signals the model’s original uncertainty.</p>
<p>In cases where the model is certain about the answer, the generations are stable as we increase k over the external context.</p>
<div data-execution_count="5">
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1"></a>prompt <span>=</span> <span>&#34;What was did Alexander Grothendieck&#39;s profession?&#34;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>input_ids <span>=</span> tokenizer(prompt, return_tensors<span>=</span><span>&#39;pt&#39;</span>)[<span>&#39;input_ids&#39;</span>]</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>25</span>, topk<span>=</span><span>0</span>)</span>
<span id="cb6-5"><a href="#cb6-5"></a><span>print</span>(<span>&#39;Baseline Generation: &#39;</span>, tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>15</span>, topk<span>=</span><span>2</span>)</span>
<span id="cb6-8"><a href="#cb6-8"></a><span>print</span>(<span>&#39;Generation for k=2: &#39;</span>, tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>15</span>, topk<span>=</span><span>8</span>)</span>
<span id="cb6-11"><a href="#cb6-11"></a><span>print</span>(<span>&#39;Generation for k=8: &#39;</span>, tokenizer.decode(out[<span>0</span>][input_ids.size(<span>-</span><span>1</span>):]).strip())</span></code></pre></div>
<div>
<pre><code>Baseline Generation:  What was did Alexander Grothendieck&#39;s profession?
Alexander Grothendieck was a French mathematician
Generation for k=2:  Alexander Grothendieck was a mathematician.

What
Generation for k=8:  A: He was a mathematician.
&lt;|endoftext|&gt;Q: What</code></pre>
</div>
</div>
<p>A natural extension of this principle might look like the development of a metric based on similarity or attention weight which could communicate this uncertainty in a more compact form, work currently under development at Normal.</p>
<p>The parameter <code>topk</code> also serves as a useful lever for the level of abstraction in the model’s output. E.g., the extent to which we’d like the model to synthesize the memories vs. quote verbatim from the source. We see this clearly in question-answering tasks over code. We show an example using the chat model here, which is best equipped to handle more free form question-answering tasks.</p>
<div data-execution_count="6">
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1"></a>code_snippet <span>=</span> <span>&#34;&#34;&#34;def sieve_of_eratosthenes(limit):</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span>    sieve = [True] * (limit + 1)</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span>    sieve[0] = sieve[1] = False</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span>    primes = []</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span>    </span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span>    for current in range(2, int(limit**0.5) + 1):</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span>        if sieve[current]:</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span>            primes.append(current)</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span>            for multiple in range(current*current, limit + 1, current):</span></span>
<span id="cb8-10"><a href="#cb8-10"></a><span>                sieve[multiple] = False</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span>    </span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span>    for num in range(int(limit**0.5) + 1, limit + 1):</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span>        if sieve[num]:</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span>            primes.append(num)</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span>    </span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span>    return primes</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span>&#34;&#34;&#34;</span></span>
<span id="cb8-18"><a href="#cb8-18"></a>tokenizer <span>=</span> AutoTokenizer.from_pretrained(<span>&#39;EleutherAI/gpt-neox-20b&#39;</span>)</span>
<span id="cb8-19"><a href="#cb8-19"></a>memory_ids <span>=</span> tokenizer(code_snippet, return_tensors<span>=</span><span>&#39;pt&#39;</span>)[<span>&#39;input_ids&#39;</span>]</span>
<span id="cb8-20"><a href="#cb8-20"></a></span>
<span id="cb8-21"><a href="#cb8-21"></a>model <span>=</span> AutoModelForCausalLM.from_pretrained(<span>&#34;normalcomputing/extended-mind-mpt-7b-chat&#34;</span>, external_memories<span>=</span>memory_ids, trust_remote_code<span>=</span><span>True</span>)</span></code></pre></div>
</div>
<p>We ask the model to recall what our function does, first with a small <code>topk</code>.</p>
<div data-execution_count="8">
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1"></a>prompt <span>=</span>  <span>&#34;What does the function sieve_of_eratosthenes do?&#34;</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>input_ids <span>=</span> tokenizer(prompt, return_tensors<span>=</span><span>&#39;pt&#39;</span>)[<span>&#39;input_ids&#39;</span>]</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>100</span>, topk<span>=</span><span>2</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a><span>print</span>(tokenizer.decode(out[<span>0</span>]))</span></code></pre></div>
<div>
<pre><code>What does the function sieve_of_eratosthenes do?
The function sieve_of_eratosthenes is a Python function that implements the Sieve of Eratosthenes algorithm to generate all prime numbers up to a given limit.

The Sieve of Eratosthenes is a simple algorithm that generates all prime numbers up to a given limit. It works by creating a list of all integers from 2 to the given limit, and then iteratively marking the multiples of each prime number as composite (not prime).</code></pre>
</div>
</div>
<p>We see that with a small <code>topk</code> the model abstracts away the details from the code, providing a natural language description of what the code does. Now let’s try with a larger <code>topk</code>.</p>
<div data-execution_count="9">
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1"></a>out <span>=</span> model.generate(input_ids, max_length<span>=</span>input_ids.size(<span>-</span><span>1</span>)<span>+</span><span>100</span>, topk<span>=</span><span>14</span>)</span>
<span id="cb11-2"><a href="#cb11-2"></a><span>print</span>(tokenizer.decode(out[<span>0</span>]))</span></code></pre></div>
<div>
<pre><code>What does the function sieve_of_eratosthenes do?(limit):
        primes.append(True)
        for i in range(2, int(limit**0.5) + 1):
            if sieve[i]:
                break
        else:
            for i in range(2, int(limit**0.5) + 1):
                if i % 2 == 0:
                    sieve[i] = False
    
    return primes
```

This implementation of the S</code></pre>
</div>
</div>
<p>Now the model outputs much closer to verbatim code, while abstracting away some variable names. This is the kind of nuanced stylistic choice is very hard to achieve using naive prompting and RAG methods without developing many point solutions specific to the data and prompt. More importantly, this kind of experiment gives us small clues into how the model actually reasons over these key-value pairs. At Normal, we hope to combine work on mechanistic interpretability methods with extended mind transformers, building a unified system for understanding how models store facts and reason over them.</p>
</section>
<section id="explainability">
<h2 data-anchor-id="explainability">Explainability</h2>
<p>Clark and Chalmers write in their paper: “By embracing an active externalism, we allow a more natural explanation of all sorts of actions”, and indeed this is true for our active externalism as well. Using attention weights, we can highlight which memories were used during each generation step. Here we highlight the memories used when generating the correct token “1971”. Since we retrieve memories per layer, per head, we display the mode.</p>
<div>
<figure>
<p><img src="https://storage.googleapis.com/normal-blog-artifacts/extended-mind-transformers/explainability.png"/></p>
<figcaption>Tokens retrieved during the generation of token “1971”</figcaption>
</figure>
</div>
<p>Simple methods like this are just the beginning, but granular citations, in fact causal citations at all, are currently impossible using methods like RAG. The best we can get is highlighting those sections that were chosen to include in context. Using self-attention weights can perhaps buy you something, but this is unwieldy data and it’s explanatory power has been <a href="https://arxiv.org/abs/1902.10186">questioned</a>.</p>
</section>
<section id="creating-external-memories">
<h2 data-anchor-id="creating-external-memories">Creating external memories</h2>
<p>There are many interesting hyperparameters to discuss related to active externalism. Alternative masking strategies, restricting active externalism to some subset of decoder layers, and evaluating the role model size plays are all important discussions. We leave most of the discussion for more technical forthcoming papers. But we felt it was important to mention briefly the hyperparameters used in generating the external memories. We create our external memories (at each layer) by passing those external contexts through our model, just like inference. Then we save the internal representations the model generated, and attend to them later. If our external memories are longer than the model’s maximum sequence length, we’ll usually want to generate our representations using a stride. This ensures that all tokens are conditioned on at least stride-length number of previous tokens. Intuitively, all our memories will have “seen” some reasonable amount of context. However, there are situations where increased context may not be aligned with the model’s <em>best</em> representation of the data. For instance, representations of numerical or log-type data may benefit from using a smaller sequence or stride length.</p>
</section>
<section id="summary">
<h2 data-anchor-id="summary">Summary</h2>
<p>At Normal, we believe that there remains a wealth of opportunity to uncover by approaching today’s fractured, albeit proliferative, Enterprise AI landscape from a first principles point of view – even, and arguably especially, where early consensus has begun to form. We strongly believe that interdisciplinary perspectives and research are essential for advancing the field, a fundamentally and historically cross-sectional and constantly evolving discipline.</p>
<p>In “The Extended Mind” Clark and Chalmers conjecture: “In the distant future we may be able to plug various modules into our brain to help us out: a module for extra short-term memory when we need it.”</p>
<p>While this remains a distant goal for humans, we propose a method for achieving exactly this kind of short-term memory boost for LLMs. We’ve shown how a simple and natural extension of the self-attention mechanism for LLMs enables SoTa performance on retrieval tasks over long documents, uncertainty awareness, abstraction levers, granular explainability, and perhaps even given us some insight into the way these models reason internally.</p>
</section>
<section id="whats-next">
<h2 data-anchor-id="whats-next">What’s next</h2>
<p>We’re excited to extend these methods to models that use rotary and relative position encodings.</p>
<p>Making causal citations an out-of-the-box feature is also high on our list.</p>
<p>Distilling the information from the joint evolution of generations and choices of k into an uncertainty metric is another area we’re investing in.</p>
<p>Finally, continuing to develop and run comprehensive benchmarks will be crucial for building a robust understanding of the benefits provided by active externalism.</p>
</section>
<section id="references">
<h2 data-anchor-id="references">References</h2>
<div id="refs" role="list">

<p>
Burtsev, Mikhail S., Yuri Kuratov, Anton Peganov, and Grigory V. Sapunov. 2021. <span>“Memory Transformer.”</span> <a href="https://arxiv.org/abs/2006.11527">https://arxiv.org/abs/2006.11527</a>.
</p>
<div id="ref-clark-chalmers" role="listitem"><p>
Clark, Andy, and David Chalmers. 1998. <span>“The Extended Mind.”</span> <em>Analysis 58</em>, no. 1: 7–19. <a href="http://www.jstor.org/stable/3328150">http://www.jstor.org/stable/3328150</a>.
</p></div>
<p>
Liu, Nelson F., Kevin Lin, John Hewitt, Ashwin Paranjape, Michele Bevilacqua, Fabio Petroni, and Percy Liang. 2023. <span>“Lost in the Middle: How Language Models Use Long Contexts.”</span> <a href="https://arxiv.org/abs/2307.03172">https://arxiv.org/abs/2307.03172</a>.
</p>
<p>
Martins, Pedro Henrique, Zita Marinho, and André F. T. Martins. 2022. <span>“<span>\(\infty\)</span>-Former: Infinite Memory Transformer.”</span> <a href="https://arxiv.org/abs/2109.00301">https://arxiv.org/abs/2109.00301</a>.
</p>
<p>
Press, Ofir, Noah A. Smith, and Mike Lewis. 2022. <span>“Train Short, Test Long: Attention with Linear Biases Enables Input Length Extrapolation.”</span> <a href="https://arxiv.org/abs/2108.12409">https://arxiv.org/abs/2108.12409</a>.
</p>
<p>
Sukhbaatar, Sainbayar, Edouard Grave, Guillaume Lample, Herve Jegou, and Armand Joulin. 2019. <span>“Augmenting Self-Attention with Persistent Memory.”</span> <a href="https://arxiv.org/abs/1907.01470">https://arxiv.org/abs/1907.01470</a>.
</p>
<p>
Vaswani, Ashish, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N. Gomez, Lukasz Kaiser, and Illia Polosukhin. 2023. <span>“Attention Is All You Need.”</span> <a href="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a>.
</p>
<p>
Wu, Yuhuai, Markus N. Rabe, DeLesley Hutchins, and Christian Szegedy. 2022. <span>“Memorizing Transformers.”</span> <a href="https://arxiv.org/abs/2203.08913">https://arxiv.org/abs/2203.08913</a>.
</p>
</div>


</section>


<div id="quarto-appendix"><section id="footnotes" role="doc-endnotes"><h2>Footnotes</h2>

<ol>
<li id="fn1"><p>Indeed, retrieval has thus far become a <a href="https://www.sequoiacap.com/article/generative-ai-act-two/">table stakes</a> part of the modeling stack for building LLM apps.<a href="#fnref1" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><strong>RAG</strong>, a popular method for tackling the short context length of LLMs in application settings, attempts to identify the most salient information in a long text for a given query or task, such that the long context can be cut down to “fit in memory”. This is accomplished using a choice of sentence embedding that’s usually external to the model, chunking the long text and comparing with the query vector using a similarity or distance metric. Many <a href="[https://python.langchain.com/docs/integrations/retrievers]">open sourced projects</a> have made implementing such a strategy easier, and the success of <a href="https://www.forbes.com/sites/adrianbridgwater/2023/05/19/the-rise-of-vector-databases/?sh=4472652914a6">“vector databases”</a> demonstrates the rapid adoption of such methods.<a href="#fnref2" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Although there’s no technical reason we can’t throw an arbitrarily long sequence into context, performance using today’s models will drop off quickly after we exceed the sequence length the model saw during training. This inability to generalize is largely due to the use of positional embeddings. While originally (in <span data-cites="vaswani2023attention">Vaswani et al. (<a href="#ref-vaswani2023attention" role="doc-biblioref">2023</a>)</span>) only applied once at the beginning of the encoder/decoder stack, in today’s GPT-style transformers positional encodings are usually incorporated at the bottom of each decoder layer. These are unique constants which are either added or multiplied to hidden states in order to encode the index of each token in the sequence. Unless the model is trained further to expect a wider range of positional values, these new tokens quickly become out of distribution. Even given an infinitely long context, faithfully retrieving facts from very long sequences remains a challenge. Recent experiments show that models still struggle to use all the information provided in the larger context window - often forgetting things in the middle in particular, as they show in <span data-cites="liu2023lost">Liu et al. (<a href="#ref-liu2023lost" role="doc-biblioref">2023</a>)</span>.<a href="#fnref3" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>The architecture described in <span data-cites="martins2022inftyformer">Martins, Marinho, and Martins (<a href="#ref-martins2022inftyformer" role="doc-biblioref">2022</a>)</span> continuously compresses long text inputs such that the text always fits in memory. This has the obvious advantage of supporting input sequences of “infinite” length, but the weakness of summarizing the past such that it necessarily contains less detail. A coarse-grained/RAG analog to this might be using the language model itself to iteratively summarize past inputs and then passing the summary into context. In <span data-cites="sukhbaatar2019augmenting">Sukhbaatar et al. (<a href="#ref-sukhbaatar2019augmenting" role="doc-biblioref">2019</a>)</span>, the authors suggest replacing the feed-forward mechanism in each decoder layer with another attention block, and interpret this “unified mechanism” as an aggregation of global and contextual information. The creative contributors in <span data-cites="burtsev2021memory">Burtsev et al. (<a href="#ref-burtsev2021memory" role="doc-biblioref">2021</a>)</span> propose introducing a <code>[mem]</code> token which they hope the model will learn to leverage as space for storing global information. They implement various decoder architectures which attempt to enforce this with varying strictness. Folks at <a href="https://www.mosaicml.com/blog/mpt-7b">Mosaic</a> have combatted the lack of generalizing position encodings by using attention with linear biases (as presented by <span data-cites="press2022train">Press, Smith, and Lewis (<a href="#ref-press2022train" role="doc-biblioref">2022</a>)</span>).<a href="#fnref4" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><span data-cites="clark-chalmers">Clark and Chalmers (<a href="#ref-clark-chalmers" role="doc-biblioref">1998</a>)</span><a href="#fnref5" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>While the authors of this paper believe the model needs to be trained from scratch or at least fine-tuned to be able to make sense of the extra retrieved tokens, we show that using models trained with ALiBi can make sense of these external key-value pairs innately. While they use a non-differentiable cache on one layer, we cache on every decoder layer.<a href="#fnref6" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>I.e., the model interprets those retrieved memories as being some constant distance away from the tokens it considers local context. For simplicity’s sake, we choose this constant index to be that directly following the last in-context index. I.e. if we pass the model a sequence of 1200 tokens, the memories in context will all be assigned position 1201. Certainly there’s room to experiment here - for instance you might choose to bias weights closer to the beginning of the memories more than those toward the end - but we find this is a reasonable and effective choice. We hypothesize that these methods will be effective for models trained with relative positional encodings as well, and will pursue this end in future work.<a href="#fnref7" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>a popular mechanism for speeding up inference, as a GPT-style transformer’s output only depends on the previous inputs<a href="#fnref8" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>We support using <a href="https://github.com/facebookresearch/faiss">FAISS</a> in our implementation<a href="#fnref9" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>We find .25 to be a good choice.<a href="#fnref10" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>https://developer.ibm.com/exchanges/data/all/wikitext-103/<a href="#fnref11" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>We use OpenAI’s Ada embeddings, and chunk our document into sequences of 500 tokens with no overlap. We order the documents such that the most similar content is closest to the prompt.<a href="#fnref12" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Each split has on average 200 samples, with more samples in the 2k split and fewer as documents become longer.<a href="#fnref13" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>Usually, as measured by cross-entropy<a href="#fnref14" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>Unsure in an epistemic way, i.e. the model didn’t observe this fact during training/can’t infer from the context<a href="#fnref15" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section><h2>Reuse</h2></section></div></div></div>
  </body>
</html>
