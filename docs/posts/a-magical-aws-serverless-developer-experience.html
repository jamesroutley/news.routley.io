<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://journal.plain.com/posts/2022-02-08-a-magical-aws-serverless-developer-experience/">Original</a>
    <h1>A magical AWS serverless developer experience</h1>
    
    <div id="readability-page-1" class="page"><div><div><p>A common question developers bring up when wanting to develop serverless and cloud native applications is: <strong>what will the developer experience be like?</strong>
It is an important question as a good developer experience with a quick feedback loop results in happier and more productive developers who are able to ship features rapidly.</p>
<p>Since we‚Äôre building Plain to be intentionally small, an outstanding developer experience is a must.
We need to make sure that the few engineers that we do hire can make the most impact by delivering product features quickly while maintaining a high quality.</p>
<p>We had the opportunity to think about how to solve this problem in 2021 as Plain is built from scratch.
When we were deciding our general tech stack, the experience of making changes on a daily basis played a large role in the decision-making, as well as how we‚Äôll be able to build a successful business in the next 5 to 10 years without needing to do foundational replatforms.
This meant being able to run our services at scale at a low cost without needing to have a whole department just looking after a homegrown infrastructure.</p>
<p>The rationale behind these decisions definitely requires its own separate post, but we ended up deciding to go <strong>all-in on serverless</strong> and cloud native, <strong>full-stack TypeScript</strong>, and using <strong>AWS as our cloud provider</strong>, due to its maturity and popularity. We decided that using proprietary AWS services is an acceptable lock-in as there‚Äôs high value gained compared to the likelihood of switching cloud providers.
I‚Äôve definitely seen companies spend huge amounts of effort trying to be cloud-agnostic, without actually realizing any tangible benefit from it.</p>
<h2>What‚Äôs unique about serverless development</h2>
<p>There are some unique aspects to developing and testing serverless applications.
One of the main differences is that you end up using a lot of cloud services and aim to offload as much responsibility to serverless solutions as possible.</p>
<p>In the case of AWS Lambda this means that you typically end up using API Gateway, DynamoDB, SQS, SNS, S3, EventBridge, ElastiCache, etc. to build your application.
Using so many services involves a lot of configuration, permissions, and infrastructure that needs to be developed, tested, and deployed.
If you only focus on testing your lambda code then you‚Äôre skipping a large part of your feature.
Examples that you might encounter if you don‚Äôt verify your infrastructure:</p>
<ul>
<li>missing an S3 trigger to SQS or a Lambda function</li>
<li>missing an EventBridge rule to route events to the right targets</li>
<li>missing a Lambda IAM role update to use a new AWS service</li>
<li>incorrect CORS or authorizer configuration in API Gateway</li>
</ul>
<p>One of the most important questions to answer is: <strong>when do you want to find out about these mistakes?</strong></p>
<ol>
<li>While writing and running your tests?</li>
<li>While working on a feature and the developer manually trying out their feature?</li>
<li>In your Continuous Integration run via some E2E integration test suite?</li>
<li>In a shared deployed environment, such as dev or staging?</li>
<li>Or in the worst case scenario: in production?</li>
</ol>
<p>We decided to do it as soon as possible: <strong>while writing and running tests</strong>.
What this means is that the debate of ‚Äúshould you mock cloud dependencies or embrace the cloud‚Äù was not really a question.
Having our Lambdas use AWS mocks or some localhost emulation still leaves a lot to be desired in terms of ‚Äúwill it actually work‚Äù when deployed.
Gareth McCumskey‚Äôs <a href="https://dev.to/garethmcc/why-local-development-for-serverless-is-an-anti-pattern-1d9b">Why local development for serverless is an anti-pattern</a> blog post captures the &#34;emulate vs. use the cloud&#34; debate quite well, and I‚Äôd highly recommend reading it.</p>
<p>The largest implication of developing against the cloud is the need for internet access to effectively write code. While this might be an unacceptable trade-off to some companies or people, for us as a remote-first company, we require internet access to communicate with our colleagues therefore there would be very few times when people didn‚Äôt have network connectivity.</p>
<p>With the general principle that we want to be developing against the cloud and not trying to build a local developer experience, we set out evaluating various tools and technologies to find out what works for us.</p>
<h2>The üåà magical üåà stack</h2>
<!-- https://giphy.com/gifs/bob-esponja-BIA2rRLTq0ibe -->
<figure>
  <img src="https://media.giphy.com/media/BIA2rRLTq0ibe/giphy.gif" alt="SpongeBob SquarePants drawing a rainbow with his hands"/>
  <figcaption><a href="https://giphy.com/gifs/bob-esponja-BIA2rRLTq0ibe" target="_blank" rel="nofollow">via GIPHY</a></figcaption>
</figure>
<p>So what does our magical AWS serverless developer experience look like? At a high level the following make up the key components:</p>
<ul>
<li>Every developer has their own personal AWS account</li>
<li>AWS CDK to develop our infrastructure and Serverless Stack (SST) to get a very quick feedback loop</li>
<li>Writing significantly more integration tests than unit tests</li>
<li>Full-stack TypeScript</li>
</ul>
<p>Adopting these technologies and practices yields a pretty brilliant developer experience.</p>
<h2>Personal AWS accounts</h2>
<p>When going full serverless, each developer having their own personal sandbox AWS account is a must.
As previously mentioned, to build most features it‚Äôs not enough to write the code, there‚Äôs a lot of infrastructure that needs to be developed, changed, and tested.
Having personal AWS accounts allows each developer to experiment and develop without impacting any other engineer or a shared environment like development or staging.
Combined with our strong infrastructure as code use, this allows everyone to have their clone of the production environment.</p>
<p>You might be thinking: <strong>isn‚Äôt that expensive</strong>?
Won‚Äôt we be paying hundreds of dollars to AWS? <strong>Nope</strong>‚Äînot with serverless solutions!
The genuinely serverless solutions are all pay per usage, so if your AWS account has zero activity, for example through the night and weekend when engineers aren‚Äôt working, then you won‚Äôt pay a dime.
There are a few exceptions to this, such as S3 storage, DynamoDB storage, RDS storage, Route53 hosted zone, etc. costs, but they tend to be minimal.</p>
<p>For example, Plain‚Äôs January bill for our 7 developer accounts was a total of $150‚Äîpennies compared to the developer velocity we gain by everyone having their clone of production.
Typically, the largest cost for each developer is our relational database: Amazon Aurora Serverless v1 PostgreSQL.
It automatically scales up when it receives requests during development and down to zero after 30 minutes of inactivity.</p>
<figure>
  <img src="https://journal.plain.com/0ea73190598972690d1dfd64311f6526/2022-02-08-aws-bill-overview.png" alt="Screenshot of AWS bill for 7 developer accounts"/>
<figcaption>
The total bill for each developer account‚Äôs AWS usage.
</figcaption>
</figure>
<figure>
  <img src="https://journal.plain.com/6b31ac713488dfac11b5f1ec15f66e7d/2022-02-08-aws-bill-details.png" alt="Breakdown of one AWS account‚Äôs usage"/>
<figcaption>
Breakdown of my AWS account‚Äôs usage</figcaption>
</figure>
<h2>AWS CDK and SST</h2>
<p>With all of our features considerably depending on cloud resources, having our infrastructure defined as code and version controlled is a hard requirement.
We initially looked at tools like Terraform, Pulumi, Serverless Framework, AWS SAM, but they either required us to learn new programming or templating languages, or the developer experience of the full feature lifecycle wasn‚Äôt up to our expectations.</p>
<p>Back in March 2021, we stumbled upon <a href="https://serverless-stack.com/">Serverless Stack (SST)</a> when it was still version 0.9.11.
What sold us instantly was their live lambda reloading feature and being built on AWS CDK. SST and AWS CDK support TypeScript natively, so it nicely fits into our fullstack TypeScript desire.</p>
<p><a href="https://docs.serverless-stack.com/live-lambda-development">Live lambda development</a> allowed us to write our Lambda code and have our integration tests run using live AWS services with a 2-3 second feedback loop. SST replaces your lambda with a shim that proxies down all Lambda invocations via Websockets to your local developer machine, which can invoke other AWS services and returns with a response. The local runtime uses the AWS Lambda execution role‚Äôs permissions to make AWS API calls to real services, so we were quite confident that the change would work when deployed to production.
Overall this meant that we caught infrastructure issues extremely quickly compared to mocking or emulation.</p>
<figure>
  <img src="https://journal.plain.com/881a4814a13da40406a97c64ba437724/2022-02-08-sst-live-lambda-development-architecture.png" alt="Live lambda development architecture overview"/>
<figcaption>
Live lambda development architecture overview. (<a href="https://docs.serverless-stack.com/live-lambda-development" target="_blank">Source: docs.serverless-stack.com</a>)
</figcaption>
</figure>
<p>The implication of this setup is that we can do genuine full-stack development easily.
We can point our React frontend application to a personal AWS account‚Äôs deployed API Gateway URL and change both the frontend and backend at the same time with both codebases live reloading.
Given that everything is deployed and using the same AWS services that the production environment uses, our frontend application completely works without needing workarounds.</p>
<p>While it was slightly risky to choose to build our backend stack on a (at that time) relatively unknown tool, we knew that we had the AWS CDK escape hatch. If we ever encounter something that SST doesn‚Äôt support or we don‚Äôt like, we could instead use a very mature AWS CDK construct. This gave us the best balance between a fantastic developer experience by SST with the maturity, feature richness, and first party support of AWS CDK.</p>
<p>Serverless Stack also has some incredible features like:</p>
<ul>
<li>Dropping break points into your Lambda code and debugging in your local IDE. This is helped by the <code>--increase-timeout</code> flag which increases all Lambda timeouts to 15 minutes. If you‚Äôre interested in this check out the <a href="https://docs.serverless-stack.com/live-lambda-development#debugging-with-visual-studio-code">docs</a> or <a href="https://www.youtube.com/watch?v=2w4A06IsBlU">this video</a>.</li>
<li><a href="https://docs.serverless-stack.com/live-lambda-development#watching-infrastructure-changes">Detecting infrastructure changes</a> and prompting you to deploy them, i.e. getting as close to live reload as possible. Deployments still take a bit of time as it‚Äôs Cloudformation under the hood.</li>
<li>A web based console (<a href="https://docs.serverless-stack.com/packages/cli#console">SST Console</a>) to visualize your stacks, Lambdas, S3 buckets, as well as the ability to replay individual Lambda events.</li>
<li><a href="https://docs.serverless-stack.com/advanced/cross-stack-references#automatic-export-injection">Auto-exporting removed Cloudformation stack outputs</a>: we ran into this multiple times before and it was a pain as we sometimes noticed too late.</li>
<li>An ever-growing <a href="https://docs.serverless-stack.com/">library of constructs</a></li>
</ul>
<p>SST‚Äôs <a href="https://serverless-stack.com/slack">Slack community</a> has also been very helpful whenever we encountered issues, had questions, or feature requests. <a href="https://twitter.com/fanjiewang">Frank</a>, <a href="https://twitter.com/jayair">Jay</a>, <a href="https://twitter.com/thdxr">Dax</a>, and the community are always happy to help. I‚Äôd highly recommend giving SST a try as it‚Äôs hard to find anything that works so well.</p>
<h2>Testing</h2>
<p>Early on we had an ambition of having full confidence in our test suite.
If our CI goes green then it should be safe to deploy that change to production‚Äîwhich is exactly what we do on merge to the main branch.
To achieve this we decided to focus our testing efforts on a robust integration test suite rather than unit testing individual lambda functions or small code blocks.
This may seem like bad practice or going against the conventional testing pyramid.
But when we encounter step-change innovation, such as serverless, it‚Äôs important to question existing practices to see if those practices still make sense.</p>
<p>To be absolutely clear: <strong>we do write unit tests where it makes sense</strong>.
Where we have some business logic or calculation then we do write an exhaustive unit test suite.
An example is our core customer state machine having a unit test for all possible states and state transitions.
But unit testing things like SQL queries, AWS API calls, or our GraphQL requests is definitely off the table as it yields little real-world assurance.
What you end up testing is a lot of implementation detail and maintaining high quality mocks or emulation is a lot of effort that is rarely worth it.</p>
<p>To put it in numbers, our current test suite ratio is about 30% unit tests and 70% integration test cases.</p>
<blockquote data-lang="en" data-dnt="true"><p lang="en" dir="ltr">2 unit tests. 0 integration tests <a href="https://t.co/V2Z9F4G1sJ">pic.twitter.com/V2Z9F4G1sJ</a></p>‚Äî DEV Community üë©‚Äçüíªüë®‚Äçüíª (@ThePracticalDev) <a href="https://twitter.com/ThePracticalDev/status/687672086152753152?ref_src=twsrc%5Etfw">January 14, 2016</a></blockquote> 
<p>Our integration tests are designed and written in a way in which they‚Äôll be reasonably quick and test for behaviour and not for implementation. What this means is that we try to avoid asserting on internal implementation details, such as the data stored in DynamoDB or RDS. Instead we focus on verifying externally (from the Lambda‚Äôs point of view) visible behaviour, such as API responses or events being published. For our events, we draw the line at testing only that an event has been published and not asserting all downstream consumers. We write separate integration tests for each consumer. It also requires us to maintain sensible domain boundaries in our code to make sure that each domain can be tested independently.</p>
<figure>
  <img src="https://journal.plain.com/2151975361bb9d80b6b40d4050e953d1/2022-02-08-integration-testing-architecture.png" alt="Integration testing architecture"/>
<figcaption>
Integration test boundaries
</figcaption>
</figure>
<p>This way of writing tests also has the benefit of being able to be run against shared environments. We currently have a full integration test suite running against our development environment on post-deploy merge to main and on a schedule to detect flaky tests. There‚Äôs nothing stopping us from also running these exact same tests in our production environment as well. In theory, we could delete 100% of our code, rewrite all of our Lambdas in Delphi and as long as our integration test suite passes we could ship it to production. (Note: we‚Äôve yet to try this and don‚Äôt plan on it anytime soon).</p>
<p>A typical GraphQL API integration test for a query or mutation roughly does the following:</p>
<ol>
<li>Request a user from a pool of authenticated users (we ran into some quotas and limits with our identity provider)</li>
<li>Create a new workspace so that there‚Äôs a clean state</li>
<li>Set up the state for the test, such as create a customer, send a chat message, etc.</li>
<li>Make the GraphQL query</li>
<li>Assert the GraphQL response</li>
<li>In the case of mutations: assert any events that should have been published</li>
</ol>
<div data-language="typescript"><pre><code><span>describe</span><span>(</span><span>&#39;create issue mutation&#39;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>it</span><span>(</span><span>&#39;should create an issue&#39;</span><span>,</span> <span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    
    <span><span>const</span></span> testWorkspace <span>=</span> <span>await</span> testData<span>.</span><span>newWorkspace</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> ctx <span>=</span> <span>await</span> testData<span>.</span><span>testAggregateContext</span><span>(</span><span>{</span> testWorkspace <span>}</span><span>)</span><span>;</span>
    <span>const</span> issueType <span>=</span> <span>await</span> issueAggregate<span>.</span><span>createIssueType</span><span>(</span>ctx<span>,</span> <span>{</span>
      publicName<span>:</span> <span>&#39;Run of the mill issues&#39;</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>
    <span>const</span> customer <span>=</span> <span>await</span> customerAggregate<span>.</span><span>createCustomer</span><span>(</span>ctx<span>,</span> factories<span>.</span><span>newCustomer</span><span>(</span><span>)</span><span>)</span><span>;</span>

    
    <span>const</span> res <span>=</span> <span>await</span> testWorkspace<span>.</span>owner<span>.</span>graphqlClient<span>.</span><span>request</span><span>(</span><span>CREATE_ISSUE_GQL_MUTATION</span><span>,</span> <span>{</span>
      input<span>:</span> <span>{</span> issueTypeId<span>:</span> issueType<span>.</span>id<span>,</span> customerId<span>:</span> customer<span>.</span>id <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>

    
    
    <span>expect</span><span>(</span>res<span>)</span><span>.</span><span>toStrictEqual</span><span>(</span><span>{</span>
      createIssue<span>:</span> <span>{</span>
        issue<span>:</span> <span>{</span>
          id<span>:</span> jestExpecters<span>.</span><span>isId</span><span>(</span><span>&#39;i&#39;</span><span>)</span><span>,</span>
          issueType<span>:</span> <span>{</span> id<span>:</span> issueType<span>.</span>id <span>}</span><span>,</span>
          customer<span>:</span> <span>{</span> id<span>:</span> customer<span>.</span>id <span>}</span><span>,</span>
          status<span>:</span> IssueStatus<span>.</span>Open<span>,</span>
          issueKey<span>:</span> <span>&#39;I-1&#39;</span><span>,</span>
        <span>}</span><span>,</span>
        error<span>:</span> <span>null</span><span>,</span>
      <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>

    
    <span>await</span> testEvents<span>.</span><span>expectEvents</span><span>(</span>testWorkspace<span>,</span> <span>[</span>
      jestExpecters<span>.</span><span>standardEventStructure</span><span>(</span><span>{</span>
        actor<span>:</span> testWorkspace<span>.</span>owner<span>,</span>
        payload<span>:</span> <span>{</span>
          eventType<span>:</span> <span>&#39;domain.issue.issue_created&#39;</span><span>,</span>
          version<span>:</span> <span>1</span><span>,</span>
          issue<span>:</span> res<span>.</span>createIssue<span>.</span>issue<span>,</span>
        <span>}</span><span>,</span>
      <span>}</span><span>)</span><span>,</span>
    <span>]</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></code></pre></div>
<p>A typical EventBridge event listener integration test would:</p>
<ol>
<li>Set up any required state (this is highly dependent on the exact Lambda)</li>
<li>Publish an EventBridge event onto a bus</li>
<li>Wait and expect the side effects, which could be:
<ol>
<li>Another EventBridge event being published</li>
<li>State in a datastore being updated (i.e. in DynamoDB, RDS, S3)</li>
</ol>
</li>
</ol>
<p>If you‚Äôve ever written any integration test you must be screaming in your head: running all this must be <strong>so</strong> slow!
They are definitely slower than unit tests, but not unbearably slow.
Since all the services we use are serverless, and we make sure our integration tests have 0 shared state we‚Äôre capable of running all of our tests in parallel.
We haven‚Äôt gone to this degree of optimisation, but for example our CI with a parallelism of 40 <strong>runs 656 test cases across 110 test suites in a bit under 2 minutes</strong> exhaustively integration testing every corner of our application.</p>
<figure>
  <img src="https://journal.plain.com/3bb570d99455ebb773f1ef0e87140051/2022-02-08-integration-test-suite-timings.png" alt="Integration testing architecture"/>
<figcaption>
Integration test suite results from our CI
</figcaption>
</figure>
<p>Integration test flakiness is another thing we actively tackle by running our tests on a schedule during the work week.
If we ever get a test failure, we jump on the issue and track down the root cause of it.
This also involved rethinking and restructuring how we test certain things, like GraphQL subscriptions, in a way which is robust and reliable.</p>
<p>We only just dipped our toes into our integration testing setup, this topic is definitely worthy of its own post.
That said, given that our API is a key part of our product, having every GraphQL query and mutation integration tested is crucial.
We think the trade-off of having a slightly slower test suite and a much higher confidence that the feature or change will work correctly is worth it.</p>
<h2>Full-stack TypeScript</h2>
<p>While using full-stack TypeScript isn‚Äôt strictly necessary to have a great developer experience on AWS, it really makes our team much more effective. The ability to move between the frontend, backend, and infrastructure code without having to learn a different language is invaluable to every member of the team.</p>
<p>You still need to learn the AWS services when developing backend code, but this is natural when working with anything. You likewise need to understand CSS / HTML to develop frontend web applications. With SST and CDK in TypeScript, after you‚Äôve figured out what AWS services you‚Äôd like to use the TypeScript types and the editor‚Äôs autocomplete guide you in defining the correct infrastructure.</p>
<p>We have most of our backend codebase in a single monorepo and use a handful of libraries such as <a href="https://pnpm.io/">pnpm</a>, <a href="https://github.com/colinhacks/zod">zod</a>, <a href="https://github.com/true-myth/true-myth">true-myth</a>, <a href="https://swc.rs/">swc</a> to make our code even better to work with, but more on that in a future post!</p>
<h2>Putting it all together</h2>
<p>So what does this look like in practice? Let‚Äôs take a look at what making a change looks like:</p>
<figure>
  <video autoplay="" loop="" muted="" playsinline="" controls="" width="100%">
    <source src="/6aaa177f246ed13a5b4ee85fc182fe81/2022-02-08-demo-development-loop.mp4" type="video/mp4"/>
    Your browser does not support the video tag.
  </video>
</figure>
<p>In this example we created a workspace in Plain via our core GraphQL API. This verified that E2E the API call works:</p>
<ul>
<li>User fetched a valid JWT from our identity provider</li>
<li>AWS API Gateway handled the GraphQL request and verified the validity of the JWT</li>
<li>The GraphQL Lambda created a new workspace in our Aurora Serverless PostgreSQL database and published an event to EventBridge
<ul>
<li>This verified that the Lambda has the correct IAM permissions to read/write from PostgreSQL and publish to EventBridge</li>
</ul>
</li>
<li>A successful response was returned to the client</li>
</ul>
<h2>Conclusion</h2>
<p>Combining these technologies and practices means we can focus on shipping features:</p>
<ul>
<li>In isolation without impacting other engineers due to everyone having their own AWS account.</li>
<li>With a quick feedback loop using live AWS services knowing that it will work when deployed, thanks to SST and live lambda development</li>
<li>Easily develop serverless infrastructure with CDK</li>
<li>Have high confidence in correctness, thanks to our integration testing</li>
<li>Not having to learn a different programming or templating language when switching between frontend, backend and infrastructure.</li>
</ul>
<p>Could it be better? There‚Äôs definitely room for improvement, but I think this is already quite üåà magical üåà!
If you have any questions or know of ways we can make our stack even better, get in touch with us on Twitter at <a href="https://twitter.com/builtwithplain">@builtwithplain</a> or me at <a href="https://twitter.com/akoskrivachy">@akoskrivachy</a>.</p>
<p>If you‚Äôre interested in working with our üåà magical üåà tech stack check out our current opening on <a href="https://www.plain.com/jobs/">Plain‚Äôs Jobs page</a>.</p></div></div></div>
  </body>
</html>
