<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.charityapi.org/post/improving-postgres-text-search-speed-7x-on-millions-of-records">Original</a>
    <h1>Improving Postgres Text Search Speed</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><div><p>CharityAPI.org is a simple API for nonprofit data lookup; the API the IRS should have built. In May we received customer feedback that our search was extremely slow for some queries. Upon investigation, we agreed with the customer and set about to improve search speed. CharityAPI.org stores approximately 1.5 million organizations in our main Postgres table of nonprofits, and we didn’t want to reach for Elastic Search yet, so we dug into the Postgres documentation to see if we could squeeze some more performance out of Postgres alone. We’re pleased to share that we increased our search speed by 760% so customers can get their data faster and delight their users with performant search. </p><p>When we investigated our customer feedback, we found that while most searches returned in under 50ms,  the slowest 10% of calls to our charity search API endpoint took 15 seconds. Yikes. We can improve that. </p><p><strong>First iteration: Add and query a tsvector field on the organizations table</strong></p><p>Postgres offers search based on a tsvector type, which permits one to convert text to a tokenized vector type that is <a href="https://www.postgresql.org/docs/current/textsearch-controls.html#TEXTSEARCH-RANKING">optimized for search</a>. On our organizations table, we already have a field called “searchable_fields” where we place text we want associated with the record for search results, so we defined the new tsvector field “searchable_document” to be derived from the searchable_fields column. We also used GIN to build an index on the field. In Ecto, that migration looks like this: </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/613176fb95fac737820f7841/62f6eb1958cd9b2d7e383157_image4.png" loading="lazy" alt=""/></p></figure><p>We then created a job that ensured all organizations had their organization_search index record properly created and updated. </p><p>‍</p><p>We updated our search query to search the new index table and join on organizations like so: </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/613176fb95fac737820f7841/62f6eb3d992cf47562c7f523_image1.png" loading="lazy" alt=""/></p></figure><p>This query using join was 76% slower than our naive implementation <em>without the organization_search </em>index table. We regressed.</p><div> 
<table>
<tbody><tr>
	<td>Version</td>
  <td>Iterations Per Second</td>
</tr>
<tr>
	<td>Querying “organizations.searchable_document”, without the organization_search index table.</td>
  <td>0.29 IPS</td>
</tr> 
<tr>
	<td>Querying organization_search.searchable_document, joining on organizations.</td>
  <td>.0678 IPS (76% slower)</td>
</tr>
</tbody></table></div><p><strong>Final Iteration: 2 Queries: First on the organization_search table to retrieve organization IDs, then query organizations for those IDs.</strong> </p><p>Since searching organizations_search and joining on organizations was slow, we wondered if omitting the join could possibly be faster even if it meant executing two queries. We refactored our search logic into two queries; one to collect the organization IDs and the second to retrieve those from the organizations table. </p><figure class="w-richtext-align-fullwidth w-richtext-figure-type-image"><p><img src="https://uploads-ssl.webflow.com/613176fb95fac737820f7841/62f6ee1ce2632b75c6e8f901_image2.png" loading="lazy" alt=""/></p></figure><p>A key gotcha that tripped us up: when querying with a list of primary keys, Postgres will not return the records in the same order as the IDs provided in a “where … in” clause. That means if you asked for the organizations where IDs were in [1, 3, 5], the results could be org3, org5, org1. The way to ensure order is to use the “WITH ORDINALITY” function in Postgres (<a href="https://stackoverflow.com/questions/59826383/elixir-ecto-query-preserving-order-of-output">source</a>) as we did here. When we first tested this version, with the unordered results problem, search was absurdly fast but when we checked the quality of results we noticed the result order made zero sense which led us to realize our mistake. </p><div> 
<table>
<tbody><tr>
	<td>Version</td>
  <td>Iterations Per Second</td>
</tr>
<tr>
	<td>Querying “organizations.searchable_document”</td>
  <td>0.28 to 0.51</td>
</tr>
<tr>
	<td>Querying “organization_search.searchable_document” for IDs in order, then a second search on “organizations” for those IDs.</td>
  <td>0.89 (230% faster)</td>
</tr>
</tbody></table></div><p>Crazy: two queries is 230% faster than our previous improvement, and significantly faster than trying to join in one query. </p><p>We ran both in production side-by-side for a while to ensure we continued to see similar numbers on live traffic and no qualitative drop in search quality, and once satisfied we promoted our newest logic to be the main search execution path. </p><p>Search speed for queries that have to hit Postgres are now consistently resolving in under 1 second, even for the slowest 1% of searches. We ran searches against prod from a few locations over a few days, and all results were extremely similar. </p><div> 
<table>
<tbody><tr>
	<td>Run</td>
  <td>IPS</td>
  <td>Average</td>
  <td>Deviation</td>
  <td>Median</td>
  <td>1% Slowest</td>
</tr>
<tr>
	<td>1</td>
  <td>0.95</td>
  <td>1.05s</td>
  <td>+/- 6%</td>
  <td>1.06s</td>
  <td>1.11s</td>
</tr>
<tr>
	<td>2</td>
  <td>1.07</td>
  <td>0.93s</td>
  <td>+/- 2.69%</td>
  <td>0.94s</td>
  <td>0.95s</td>
</tr>
<tr>
	<td>3</td>
  <td>1.14</td>
  <td>0.87s</td>
  <td>+/- 8.2%</td>
  <td>0.85s</td>
  <td>0.97s</td>
</tr>
</tbody></table></div><p>When we permit cache hits, we see average speeds double, while the slowest (hitting Postgres) are around 1.2 seconds.</p><div> 
<table>
<tbody><tr>
	<td>IPS</td>
  <td>Average</td>
  <td>Deviation</td>
  <td>Median</td>
  <td>1% Slowest</td>
</tr>
<tr>
	<td>1.14</td>
  <td>0.51s</td>
  <td>+/- 54.21%</td>
  <td>0.42s</td>
  <td>1.284s</td>
</tr>
</tbody></table></div><p>Our AppSignal application monitoring graphs reflect the improvement; the slowest 10% of queries could take as long as 15 seconds without caching prior to the upgrade, but now the slowest decile of queries is under 2 seconds; a huge improvement. </p><p>We’re extremely happy to deliver much more performant search for our API customers, and to do it all within Postgres without introducing another dependency. </p><p>‍</p><div> 
<table>
<tbody><tr>
	<td>Previous IPS</td>
  <td>Current IPS</td>
  <td>Change</td>
</tr>
<tr>
	<td>0.132</td>
  <td>1.14</td>
  <td>+763%</td>
</tr>
</tbody></table></div><p>Checkout our <a href="https://docs.charityapi.org">Docs</a> or <a href="https://api.charityapi.org/signup">Signup</a> to get an API key and begin querying all of the IRS data about nonprofits on CharityAPI.org. CharityAPI.org is relied on for millions of API calls a month by companies that need accurate nonprofit data.</p><p>‍</p><p>Photo by <a href="https://unsplash.com/@parrish?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Parrish Freeman</a> on <a href="https://unsplash.com/s/photos/geometric-pattern?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p></div></div></div></div></div>
  </body>
</html>
