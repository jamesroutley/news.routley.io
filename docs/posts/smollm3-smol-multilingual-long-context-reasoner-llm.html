<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://huggingface.co/blog/smollm3">Original</a>
    <h1>Smollm3: Smol, multilingual, long-context reasoner LLM</h1>
    
    <div id="readability-page-1" class="page"><div><div>
					

					
					
					
					
					

					<!-- HTML_TAG_START -->
<p>Small language models are becoming increasingly important as users seek capable models that can be deployed efficiently. The community has produced a fascinating range of capable small models, each pushing the boundaries of what&#39;s possible at this scale. With SmolLM3, we&#39;re excited to contribute a new competitive fully open 3B model:</p>
<ul>
<li>Base model: <a href="https://hf.co/HuggingFaceTB/SmolLM3-3B-Base">https://hf.co/HuggingFaceTB/SmolLM3-3B-Base</a></li>
<li>Instruct and reasoning model: <a href="https://hf.co/HuggingFaceTB/SmolLM3-3B">https://hf.co/HuggingFaceTB/SmolLM3-3B</a></li>
</ul>
<p><strong>SmolLM3 sits in the efficiency sweet spot.</strong> Our 3B model outperforms Llama-3.2-3B and Qwen2.5-3B while staying competitive with larger 4B alternatives (Qwen3 &amp; Gemma3). Beyond the performance numbers, we&#39;re sharing exactly how we built it using public datasets and training frameworks.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(17).png" alt=""/><br/>
</p>

<p>Model summary:</p>
<ul>
<li><strong>3B model</strong> trained on 11T tokens, SoTA at the 3B scale and competitive with 4B models</li>
<li><strong>Instruct model</strong> with <strong>dual mode reasoning,</strong> supporting <code>think</code>/<code>no_think</code> modes</li>
<li><strong>Multilingual support</strong> for 6 languages: English, French, Spanish, German, Italian, and Portuguese</li>
<li><strong>Long context</strong> up to 128k with NoPE and using YaRN</li>
</ul>
<p><strong>The complete recipe:</strong> We&#39;re releasing SmolLM3 with our engineering blueprint. It includes architecture details, exact data mixtures showing how we progressively boost performance across domains in a three-stage pretraining approach, and the methodology for building a hybrid reasoning model. Usually, achieving these results would require months of reverse engineering. Instead, we&#39;re providing the full methodology.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/smollm3-whiteprint.png" alt=""/><br/>
</p>

<p>Whether you&#39;re building your own models or want to understand what drives performance at this scale, this blueprint shows the engineering story behind competitive 3B performance.</p>
<p>Let’s have a look at the pretraining stage.</p>

<p>SmolLM3 both changed the architecture and data mixture over its predecessors. Let’s have a look at the architecture and training configurations first!</p>
<h2>
	<a id="architecture-and-training-details" href="#architecture-and-training-details">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Architecture and training details</strong>
	</span>
</h2>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(18).png" alt=""/><br/>
</p>

<p>SmolLM3 follows a transformer decoder architecture with tied embedding similar to SmolLM2, building on Llama architecture with some key modifications optimized for efficiency and long context performance.</p>
<p><strong>Grouped Query Attention (GQA):</strong> We replaced multi-head attention with grouped-query attention using 4 groups. Our ablations on a 3B model trained with 100B tokens from <a href="https://huggingface.co/datasets/HuggingFaceFW/fineweb-edu">FineWeb-Edu</a> showed that GQA matches the performance of multi-head attention while significantly reducing the KV cache size during inference.</p>
<p><strong>NoPE:</strong> We implemented NoPE from &#34;<a href="https://huggingface.co/papers/2501.18795">RoPE to NoRoPE and Back Again: A New Hybrid Attention Strategy</a>&#34; (Yang et al., 2025), selectively removing rotary position embeddings from every 4th layer. This approach improves long context performance without affecting short context capabilities, as confirmed by our ablations.</p>
<p><strong>Intra-Document Masking:</strong> During training, we use attention masking to ensure tokens from different documents in the same training sequence don&#39;t attend to each other. Similar to Llama 3, this helps with faster and more stable long context training while maintaining short context performance.</p>
<p><strong>Training Stability:</strong> Following OLMo 2, we remove weight decay from embedding layers to improve training stability. This modification contributed to more stable training dynamics, with embedding norms naturally stabilizing at healthier values during training without impacting overall performance in our ablations.</p>
<p>All these changes were validated through ablations using the same 3B architecture trained on 100B tokens from FineWeb-Edu, ensuring each modification either improved performance or maintained it while offering other benefits.</p>
<p>Training Configuration: We use a global batch size of 2.36M tokens with 4096 sequence length, a learning rate of 2e-4, and the AdamW optimizer (beta1: 0.9, beta2: 0.95) with weight decay of 0.1 and gradient clipping of 1. We use the WSD (Warmup-Stable-Decay) scheduler, with 2000  warmup steps, and a linear decay to 0 in the final 10% training steps. We use <a href="https://github.com/huggingface/nanotron">nanotron</a> framework for the training, <a href="https://github.com/huggingface/datatrove">datatrove</a> for data processing and <a href="https://github.com/huggingface/lighteval">lighteval</a> for evaluation. The model was trained on 384 H100 GPUs for 24 days. You can see the distributed training setup in the following figure.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(19).png" alt=""/><br/>
</p>

<p>In addition to architecture changes we also ablated and improved the training recipe. Let’s have a closer look.</p>
<h2>
	<a id="data-mixture-and-training-stages" href="#data-mixture-and-training-stages">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Data mixture and training stages</strong>
	</span>
</h2>
<p>Following SmolLM2&#39;s multi-stage approach, we train SmolLM3 on 11.2T tokens using a three-stage training strategy that mixes web, math, and code data with evolving proportions. We conducted extensive ablations on 3B models trained on 50B to 100B tokens to determine the data mixture and ratios.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(20).png" alt=""/><br/>
</p>

<p>The pretraining consists of these stages, also shown in the figure above:</p>
<ul>
<li><strong>Stage 1: Stable phase (0T → 8T tokens)</strong> This foundation stage establishes strong general capabilities with our core dataset mixture:<ul>
<li>Web: 85% (12% multilingual) - FineWeb-Edu, DCLM, FineWeb2 and FineWeb2-HQ</li>
<li>Code: 12% - The Stack v2 (16 programming languages), StarCoder2 pull requests, Jupyter and Kaggle notebooks, GitHub issues, and StackExchange.</li>
<li>Math: 3% - FineMath3+ and InfiWebMath3+</li>
</ul>
</li>
<li><strong>Stage 2: Stable phase (8T → 10T tokens)</strong> We introduce higher quality math and code datasets while maintaining good web coverage:<ul>
<li>Web: 75% (12% Multilingual)</li>
<li>Code: 15% - Adding Stack-Edu</li>
<li>Math: 10% - Introducing FineMath4+, InfiWebMath4+, and MegaMath (including Qwen Q&amp;A, Pro synthetic rewrites, and text-code interleaved blocks)</li>
</ul>
</li>
<li><strong>Stage 3: Decay Phase (10T → 11.1T tokens)</strong> The final stage further upsamples math and code data<ul>
<li>Web: 63% (12% Multilingual)</li>
<li>Code: 24% - upsampling of high-quality code data</li>
<li>Math: 13% - upsampling math data and introducing instruction and reasoning datasets such as OpenMathReasoning</li>
</ul>
</li>
</ul>
<p>With these stages and mixtures we achieved very competitive performance for the base model. More on that in the evaluation section. The nanotron training configs with exact data weights can be found <a href="https://huggingface.co/datasets/HuggingFaceTB/smollm3-configs">here</a>. We will also share our training logs along with intermediate checkpoints.</p>
<p>After the main pretraining we improved the model in a mid-training stage for long context and reasoning.</p>

<p>We call the long context adaptation and reasoning adaption “mid-training”. They are much shorter than the main pretraining but still somewhat general and aimed at improving the model in those two domains. Let’s first have a look at long context training.</p>
<h2>
	<a id="long-context-extension" href="#long-context-extension">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Long Context extension</strong>
	</span>
</h2>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(21).png" alt=""/><br/>
</p>

<p>After the main pretraining, we trained SmolLM3 on an additional 100B tokens to extend its context length. We sequentially extended the context window in two stages for 50B tokens each: first transitioning from 4k to 32k context with RoPE theta increased to 1.5M, then from 32k to 64k context with RoPE theta increased to 5M. Both stages upsampled math, code, and reasoning data. During ablations, we found that upsampling specific long context data such as code repositories, books, and long web pages (beyond the naturally long samples in our mixture) didn&#39;t further boost performance on RULER and HELMET benchmarks. Using NoPE and training on the decay mixture with longer sequences and increased RoPE theta values was sufficient to achieve competitive long context performance up to 64k. </p>
<p>Following Qwen2.5, we use YARN to extrapolate beyond the training context length. During inference, the model can handle up to  128k context (2x extension beyond the 64k training length).</p>
<h2>
	<a id="reasoning-mid-training" href="#reasoning-mid-training">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Reasoning Mid-training</strong>
	</span>
</h2>
<p>After extending the context length of the model, we trained it at a mid-training stage to incorporate reasoning capabilities. The main difference between the mid-training stage and the pre- and post-training stages is that we targeted a general capability without yet focusing on a specific domain. In our case, we wanted to train the model to reason without targeting a particular domain, such as mathematics or computer code.</p>
<p>Our mid-training dataset contained 35B tokens sourced from Open Thought’s <a href="https://huggingface.co/datasets/open-thoughts/OpenThoughts3-1.2M">OpenThoughts3-1.2M</a> and a subset from NVIDIA’s <a href="https://huggingface.co/datasets/nvidia/Llama-Nemotron-Post-Training-Dataset">Llama-Nemotron-Post-Training-Dataset-v1.1</a> with reasoning traces from R1. We used the ChatML chat template and <a href="https://huggingface.co/docs/trl/main/en/reducing_memory_usage#packing">wrapped packing</a> to avoid providing too much structure to the model. We trained the model for 4 (~140B tokens) epochs and used the checkpoint for subsequent SFT stages.</p>

<p>The release of reasoning models like <a href="https://arxiv.org/abs/2501.12948">DeepSeek R1</a> and <a href="https://arxiv.org/abs/2505.09388">Qwen3</a> has demonstrated the powerful capabilities that emerge when models can engage in explicit reasoning. However, the community still lacks fully open recipes with public datasets to build dual instruction models that support both reasoning and non-reasoning modes. Most existing approaches involve complex reinforcement learning processes and proprietary datasets, making it difficult for researchers to reproduce and build upon these results.</p>
<p>In this section, we explain how we tackled these challenges and share our complete recipe for building a dual instruction model. We detail how we balance performance between reasoning and non-reasoning modes through a carefully designed training pipeline that includes mid-training for general reasoning capabilities, supervised fine-tuning with synthetic data generation, and alignment using Anchored Preference Optimization (APO) - a recent variant of DPO.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(22).png" alt=""/><br/>
</p>

<h2>
	<a id="building-the-chat-template" href="#building-the-chat-template">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Building the Chat Template</strong>
	</span>
</h2>
<p>Before diving into the training methodology, it&#39;s essential to establish how users interact with our dual-mode model. The chat template serves as the interface that enables seamless switching between reasoning and non-reasoning modes, and its design directly impacts both our training data format and model behavior. SmolLM3&#39;s chat template allows users to control the reasoning mode during a conversation. Users can activate reasoning or non-reasoning modes by including the <code>/think</code> and <code>/no_think</code> flags, respectively, in the system prompt. In non-reasoning mode, we pre-fill the model&#39;s response with empty think blocks, similar to Qwen3, to ensure direct answers without explicit reasoning.</p>
<p>SmolLM3 supports tool calling, and its chat template incorporates two distinct sections for tool descriptions: XML Tools and Python Tools. This specific categorization proved beneficial in our experiments for the model&#39;s accurate interpretation of tool definitions in each format. </p>
<p>The chat template provides a default system message for both reasoning modes, along with a metadata section that includes the date, knowledge cut-off date, and current reasoning mode. Users can replace the default system message by providing one with the <code>system</code> role. The metadata section can be excluded by using the <code>/system_override</code> flag in the system prompt, offering flexibility for specific use cases.</p>
<h2>
	<a id="supervised-finetuning" href="#supervised-finetuning">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Supervised Finetuning</strong>
	</span>
</h2>
<p>Following the reasoning mid-training stage, where we trained the model on 140B tokens of general reasoning data, we proceed with Supervised Finetuning (SFT) to incorporate capabilities in across both reasoning and non-reasoning modes for math, code, general reasoning, instruction following, multilinguality, and tool calling. Training a dual-mode model requires carefully balancing the data mixture to maintain strong performance in both modes across all target domains. To evaluate SmolLM3’s performance throughout training, we tracked the following domains: math, code, general reasoning, instruction following, and multilinguality.</p>
<p>The primary challenge we encountered when building the reasoning mode dataset was the scarcity of datasets containing reasoning traces for certain domains. To address this gap, we generated synthetic data by prompting <a href="https://huggingface.co/Qwen/Qwen3-32B">Qwen3-32B</a> in reasoning mode with prompts from existing non-reasoning datasets. This allowed us to improve performance in domains where the model initially struggled in reasoning mode, such as multi-turn conversations, multilinguality, and everyday conversations.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(23).png" alt=""/><br/>
</p>

<p>Our final data mixture was the result of extensive ablations examining the optimal ratio of reasoning to non-reasoning tokens and the composition within each mode. The resulting SFT dataset contains 1.8B tokens: 1B in non-reasoning mode and 0.8B in reasoning mode, comprising 12 non-reasoning datasets and 10 datasets with reasoning traces. We trained for 4 epochs (~8B tokens) using <a href="https://github.com/huggingface/trl/pull/3521">BFD (best-fit decreasing) packing</a> with the loss masked on user turns and the results from tool calls.</p>
<p>We will release this data mixture along with our full training scripts to enable the community to reproduce and build upon our work.</p>
<h2>
	<a id="off-policy-model-alignment-with-anchored-preference-optimization-apo" href="#off-policy-model-alignment-with-anchored-preference-optimization-apo">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Off-policy model alignment with Anchored Preference Optimization (APO)</strong>
	</span>
</h2>
<p>After the SFT step, we performed a round of model alignment using a combination of the <a href="http://allenai/llama-3.1-tulu-3-8b-preference-mixture">Tulu3 preference dataset</a> for non-reasoning mode and new synthetic preference pairs for reasoning mode, that we generated from Qwen3-32B and Qwen3-0.6B. To ensure full coverage of all domains in the non-thinking dataset, we generated complementing thinking mode preference pairs. We selected generations from Qwen3-32B as “chosen” and responses from Qwen3-0.6B as “rejected” for alignment with Anchored Preference Optimization.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(24).png" alt=""/><br/>
</p>

<p><a href="https://arxiv.org/abs/2408.06266">Anchored Preference Optimization</a> (APO) is a variant of <a href="https://arxiv.org/abs/2305.18290">Direct Preference Optimization</a> (DPO) that provides a more stable optimization objective. In DPO, the reward function  r_θ(x,y) measures the log-ratio of the probability of sequence during training compared to model at the start of training, the reference model:</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(25).png" alt=""/><br/>
</p>

<p>Here  β controls how much the model being optimized can change relative to the reference model. The DPO loss optimizes triplets of prompts x, chosen y_w and rejected y_l responses:</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(26).png" alt=""/><br/>
</p>

<p>The APO objective has been shown to be more stable, and we also observed higher downstream performance in our internal ablations.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(27).png" alt=""/><br/>
</p>

<p>While downstream evaluations showed improvements across mathematics, science, instruction following, coding, chat, and multilingual tasks, we observed performance degradation on long context benchmarks like RULER. We traced this degradation back to the reasoning mid-training stage, where the focus on reasoning capabilities impacted long context performance. Additionally, the APO training data was limited to 24k tokens since the vast majority of our reasoning dataset fell below this length. </p>
<p>To mitigate this performance drop, we explored model merging as a solution.</p>
<h2>
	<a id="model-merging" href="#model-merging">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Model Merging</strong>
	</span>
</h2>
<p>Model merging is a popular and powerful technique that allows combining the strengths of different models without the computational overhead of ensembling or the need for additional training. We used the <a href="https://github.com/arcee-ai/mergekit">MergeKit</a> library to perform the model merging, as it includes several merging methods, including linear and non-linear merging.</p>
<p>Our merging recipe consists of two steps:</p>
<ol>
<li>Take each APO checkpoint and create a model “soup”.</li>
<li>Combine the model soup with a mid-training checkpoint that has strong long-content performance. A linear merge with weights of 0.9 and 0.1 for the APO model soup and mid-training checkpoint, respectively, achieved the best performance. We were able to recover the base model’s RULER score on contexts up to 128k tokens.</li>
</ol>
<p>The resulting model is the checkpoint we are releasing today. It maintains performance across a wide range of tasks. So let’s turn the the evaluation result both of this model as well as the base model. </p>

<p>We evaluate base models and the instruct model both in reasoning and non-reasoning mode. Let’s first cover the base model’s performance!</p>
<h2>
	<a id="base-model" href="#base-model">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Base model</strong>
	</span>
</h2>
<p>The plot below shows SmolLM3&#39;s win rate across 12 popular benchmarks evaluating knowledge, reasoning, math, and coding capabilities. SmolLM3 consistently outperforms other 3B models and achieves competitive performance with larger 4B models including Qwen3-4B and Gemma3-4B.</p>
<p>Evaluation benchmarks used for the win rate: HellaSwag, ARC, Winogrande, CommonsenseQA, MMLU-CF, MMLU Pro CF, PIQA, OpenBookQA, GSM8K, MATH, HumanEval+, MBPP+</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(28).png" alt=""/><br/>
</p>

<p>SmolLM3 achieves first or second place on knowledge and reasoning benchmarks (HellaSwag, ARC, BoolQ), demonstrating strong performance in these core capabilities. Math and coding performance is competitive within the 3B class. Long-context performance on Ruler 64k shows the model can handle extended sequences effectively.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(33).png" alt=""/><br/>
</p>

<p>The model demonstrates strong multilingual performance across five major European languages when evaluated on multilingual benchmarks including Global MMLU, MLMM HellaSwag, Flores-200, Belebele, testing knowledge, commonsense reasoning, text understanding, and translation. This shows SmolLM3 maintains consistent performance beyond English.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(30).png" alt=""/><br/>
</p>

<p>In summary, the base model shows very strong performance across many domains. Let’s see how this translates to the instruct model’s performance. </p>
<h2>
	<a id="dual-instruct--reasoning-model" href="#dual-instruct--reasoning-model">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Dual Instruct / Reasoning model</strong>
	</span>
</h2>
<p>Since SmolLM3 has both an instruct and reasoning mode we need to evaluate the model in both modes and compare to models with same capabilities. </p>
<h3>
	<a id="no-extending-thinking-evaluation" href="#no-extending-thinking-evaluation">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		No extending thinking evaluation
	</span>
</h3>
<p>We evaluate SmolLM3 against other 3B non-reasoning models and compare it to Qwen3 reasoning models in no thinking mode across multiple benchmarks. As shown in the performance chart, SmolLM3 outperforms other 3B non-reasoning models including Llama3.2 3B Instruct and Qwen2.5 3B Instruct and sits at an efficiency sweet spot between reasoning models, significantly outperforming Qwen3 1.7B while getting close to the 4B model performance at a lower computational cost.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(31).png" alt=""/><br/>
</p>

<p>So the instruct model sits right at the pareto front of perfomance and cost. Let’s see how the reasoning model does!</p>
<h3>
	<a id="extending-thinking-evaluation" href="#extending-thinking-evaluation">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		Extending thinking evaluation
	</span>
</h3>
<p>When evaluating SmolLM3&#39;s reasoning capabilities with extended thinking enabled, the model shows substantial improvements across most benchmarks compared to its non-reasoning counterpart. We observe notable gains in challenging tasks like AIME 2025 (36.7% vs 9.3%), competitive programming on LiveCodeBench (30.0% vs 15.2%), and graduate-level reasoning on GPQA Diamond (41.7% vs 35.7%).</p>
<p>While Qwen3 4B generally achieves the highest scores across both thinking and non-thinking modes, SmolLM3 demonstrates competitive performance within the 3B parameter class, particularly excelling in mathematical reasoning and complex problem-solving tasks. The model&#39;s dual-mode capability allows users to choose between faster inference without reasoning or more thorough analysis with extended thinking.</p>
<p>
 <img src="https://huggingface.co/datasets/HuggingFaceTB/images/resolve/main/smollm3/image%20(32).png" alt=""/><br/>
</p>

<p>So the last question is: how can you use the model?</p>

<p>The modeling code for SmolLM3 is available in transformers <code>v4.53.0</code>, so make sure to upgrade your transformers version. You can also load the model with the latest <code>vllm</code> which uses transformers as a backend.</p>
<p><code>pip install -U transformers</code></p>
<pre><code><span>from</span> transformers <span>import</span> AutoModelForCausalLM, AutoTokenizer

model_name = <span>&#34;HuggingFaceTB/SmolLM3-3B&#34;</span>
device = <span>&#34;cuda&#34;</span> <span># for GPU usage or &#34;cpu&#34; for CPU usage</span>

<span># load the tokenizer and the model</span>
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(
    model_name,
).to(device)

<span># prepare the model input</span>
prompt = <span>&#34;Give me a brief explanation of gravity in simple terms.&#34;</span>
messages_think = [
    {<span>&#34;role&#34;</span>: <span>&#34;user&#34;</span>, <span>&#34;content&#34;</span>: prompt}
]

text = tokenizer.apply_chat_template(
    messages_think,
    tokenize=<span>False</span>,
    add_generation_prompt=<span>True</span>,
)
model_inputs = tokenizer([text], return_tensors=<span>&#34;pt&#34;</span>).to(model.device)

<span># Generate the output</span>
generated_ids = model.generate(**model_inputs, max_new_tokens=<span>32768</span>)

<span># Get and decode the output</span>
output_ids = generated_ids[<span>0</span>][<span>len</span>(model_inputs.input_ids[<span>0</span>]) :]
<span>print</span>(tokenizer.decode(output_ids, skip_special_tokens=<span>True</span>))
</code></pre>
<blockquote>
<p>We recommend setting <code>temperature=0.6</code> and <code>top_p=0.95</code> in the sampling parameters.</p>
</blockquote>
<h3>
	<a id="enabling-and-disabling-extended-thinking-mode" href="#enabling-and-disabling-extended-thinking-mode">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Enabling and Disabling Extended Thinking Mode</strong>
	</span>
</h3>
<p>We enable extended thinking by default, so the example above generates the output with a reasoning trace. For choosing between enabling, you can provide the <code>/think</code> and <code>/no_think</code> flags through the system prompt as shown in the snippet below for extended thinking disabled. The code for generating the response with extended thinking would be the same except that the system prompt should have <code>/think</code> instead of <code>/no_think</code>.</p>
<pre><code>prompt = <span>&#34;Give me a brief explanation of gravity in simple terms.&#34;</span>
messages = [
    {<span>&#34;role&#34;</span>: <span>&#34;system&#34;</span>, <span>&#34;content&#34;</span>: <span>&#34;/no_think&#34;</span>},
    {<span>&#34;role&#34;</span>: <span>&#34;user&#34;</span>, <span>&#34;content&#34;</span>: prompt}
]

text = tokenizer.apply_chat_template(
    messages,
    tokenize=<span>False</span>,
    add_generation_prompt=<span>True</span>,
)
</code></pre>
<h3>
	<a id="agentic-usage" href="#agentic-usage">
		<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" width="1em" height="1em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 256"><path d="M167.594 88.393a8.001 8.001 0 0 1 0 11.314l-67.882 67.882a8 8 0 1 1-11.314-11.315l67.882-67.881a8.003 8.003 0 0 1 11.314 0zm-28.287 84.86l-28.284 28.284a40 40 0 0 1-56.567-56.567l28.284-28.284a8 8 0 0 0-11.315-11.315l-28.284 28.284a56 56 0 0 0 79.196 79.197l28.285-28.285a8 8 0 1 0-11.315-11.314zM212.852 43.14a56.002 56.002 0 0 0-79.196 0l-28.284 28.284a8 8 0 1 0 11.314 11.314l28.284-28.284a40 40 0 0 1 56.568 56.567l-28.285 28.285a8 8 0 0 0 11.315 11.314l28.284-28.284a56.065 56.065 0 0 0 0-79.196z" fill="currentColor"></path></svg></span>
	</a>
	<span>
		<strong>Agentic Usage</strong>
	</span>
</h3>
<p>SmolLM3 supports tool calling! Just pass your list of tools under the argument <code>xml_tools</code> (for standard tool-calling), or <code>python_tools</code> (for calling tools like python functions in a <code>&lt;code&gt;</code> snippet).</p>
<pre><code><span>from</span> transformers <span>import</span> AutoModelForCausalLM, AutoTokenizer

checkpoint = <span>&#34;HuggingFaceTB/SmolLM3-3B&#34;</span>

tokenizer = AutoTokenizer.from_pretrained(checkpoint)
model = AutoModelForCausalLM.from_pretrained(checkpoint)

tools = [
    {
        <span>&#34;name&#34;</span>: <span>&#34;get_weather&#34;</span>,
        <span>&#34;description&#34;</span>: <span>&#34;Get the weather in a city&#34;</span>,
        <span>&#34;parameters&#34;</span>: {<span>&#34;type&#34;</span>: <span>&#34;object&#34;</span>, <span>&#34;properties&#34;</span>: {<span>&#34;city&#34;</span>: {<span>&#34;type&#34;</span>: <span>&#34;string&#34;</span>, <span>&#34;description&#34;</span>: <span>&#34;The city to get the weather for&#34;</span>}}}}
]

messages = [
    {
        <span>&#34;role&#34;</span>: <span>&#34;user&#34;</span>,
        <span>&#34;content&#34;</span>: <span>&#34;Hello! How is the weather today in Copenhagen?&#34;</span>
    }
]

inputs = tokenizer.apply_chat_template(
    messages,
    enable_thinking=<span>False</span>, <span># True works as well, your choice!</span>
    xml_tools=tools,
    add_generation_prompt=<span>True</span>,
    tokenize=<span>True</span>,
    return_tensors=<span>&#34;pt&#34;</span>
)

outputs = model.generate(inputs)
<span>print</span>(tokenizer.decode(outputs[<span>0</span>]))
</code></pre>

<p>We release SmolLM3, a small, long-context, multilingual, reasoner with up to 128k context. In addition to the model checkpoint we release the full training recipe including pre-training, mid-training, post-training, and synthetic data generation as well as the datasets (coming shortly). We hope this model proves useful to the community and the recipe will allow other groups to improve upon it.</p>

<ul>
<li>Models collection with quantized checkpoints: <a href="https://huggingface.co/collections/HuggingFaceTB/smollm3-686d33c1fdffe8e635317e23">Link</a></li>
<li>SmolLM GitHub repo with pretraining configs and evaluation code: <a href="https://github.com/huggingface/smollm">https://github.com/huggingface/smollm</a></li>
<li>Our HuggingFace org: <a href="https://huggingface.co/HuggingFaceTB">https://huggingface.co/HuggingFaceTB</a></li>
</ul>
<!-- HTML_TAG_END --></div></div></div>
  </body>
</html>
