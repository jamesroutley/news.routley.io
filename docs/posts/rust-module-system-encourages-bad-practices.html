<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dmitryfrank.com/articles/rust_module_system_encourages_bad_practices">Original</a>
    <h1>Rust Module System Encourages Bad Practices</h1>
    
    <div id="readability-page-1" class="page"><div>
          <!-- TOC START -->

<!-- TOC END -->


<div>

<p>
Note that I&#39;m not gonna be saying that it&#39;s confusing, hard to understand etc. Those things would be subjective; in this article I&#39;m gonna be talking about purely objective matters.
</p>

<p>
Also note that it&#39;s not a tutorial on how Rust module system works; I&#39;m assuming the reader is already familiar with it.
</p>

</div>

<h2 id="rustcrates_and_modules">Rust: Crates and Modules</h2>
<div>

<p>
I like Rust-the-language a lot; I spent enormous amount of time in my life debugging memory corruption bugs in C, and so I&#39;m fascinated by the ideas behind Rust, which gives us an incredible level of memory safety without compromising performance. That&#39;s very unique. However, there&#39;s one thing in Rust that really bothers me: the design of crates and modules.
</p>

<p>
As you probably know, the unit of compilation in Rust is a crate. Crates can depend on other crates, and that dependency graph must be acyclic, i.e. two crates can&#39;t depend on each other. That makes total sense: this is what allows crates to be compiled independently, potentially in parallel, etc.
</p>

<p>
Crate can contain one or more modules, and if at least one module has changed since the last build, the whole crate needs to be rebuilt (because, again, the unit of compilation is a crate). To be fair, let me mention that there is “incremental compilation”, which does somewhat help with cases when a single module was changed out of a hundred, but it&#39;s by no means 100 times faster than compiling the crate from scratch. At most, it&#39;s about 30-40% (so 0.3-0.4 times) faster, and so it means that as crate grows in size, compilation and re-compilation of that crate becomes significantly slower.
</p>

<p>
<em>“Oh but you should split your project in multiple crates”</em>, I hear someone saying now. And yeah I don&#39;t disagree: I definitely should, and I do. That&#39;s not my problem with Rust. My problem is that instead of encouraging numerous reasonably-sized crates, Rust encourages big crates instead. Let me explain.
</p>

<p>
Modules within a crate can be organized as a tree: a module can contain submodules, and every submodule can in turn contain their sub-submodules, etc. So on the surface it seems to be neatly organized. And all those modules can use each other in whatever way: unlike crates, cyclic dependencies between modules within a crate are not a problem, so e.g. a module <code>A</code> can use a sub-submodule <code>A/B/C</code>, which also in turn uses <code>A</code>. Those two features literally promote adding more and more modules to a crate, since it&#39;s very convenient (cyclic deps are allowed, no need to think about it) and looks seemingly neat (organized as a tree).
</p>

<p>
That thing alone is enough to dislike it: it&#39;s just too easy for a crate to grow. But unfortunately, Rust doesn&#39;t stop here: other than making it too easy to inflate a crate to unreasonable sizes, it also makes it too hard to create a new crate! As you know, creating a crate is kind of a big deal, with a separate <code>Cargo.toml</code> file, with all its dependencies and their versions specified explicitly. Maintaining that does add noticeable maintenance burden, so one would naturally refrain from having too many crates.
</p>

<p>
You might have noticed that when I&#39;m talking about modules being organized as a tree, I say that it <em>seems</em> to be neatly organized. Because the dependencies are acyclic there, modules aren&#39;t actually organized, this tree structure merely provides an illusion, while underneath there is likely a dependency mess, and there can be hundreds of files in that mess, and Rust seemingly encourages that; otherwise why would we need modules to be organized in a tree in the first place.
</p>

<p>
For comparison, let&#39;s take a look at how Go goes about this problem.
</p>

</div>

<h2 id="comparing_to_packages_in_go">Comparing to Packages in Go</h2>
<div>

<p>
In Go, instead of crates and modules, we have packages and files. In a sense, the design of those is actually similar:
</p>
<ul>
<li><p> In Go, unit of compilation is a package (just like a crate in Rust)</p>
</li>
<li><p> Go packages can depend on other Go packages, and that dependency graph must be asyclic (just like with crates in Rust)</p>
</li>
<li><p> Go files within a package can use things from other files within a package, and those dependencies between files can be cyclic (just like with modules in Rust)</p>
</li>
</ul>

<p>
So as you see, there are quite a lot of similarities. Go can compile our packages in parallel due to acyclic dependency graph, and since the unit of compilation is a package, there is the same principle (albeit less prominent) that the bigger a package is, the longer it will take to compile. However the experience of using them is significantly different:
</p>
<ul>
<li><p> A Go package is literally a single directory in the filesystem, without subdirectories (a subdirectory would be just a separate package); so even though one could technically create a huge package with hundreds of files, it&#39;s just not convenient to have this many files in a single directory. So there is a certain mental barrier which would prevent one from creating a huge package, we would naturally seek to split things up;</p>
</li>
<li><p> Creating a new Go package is a total no-brainer: again, a package is just a directory, so all we need to do is to create a directory. Dependencies are only specified in a project root, in the <code>go.mod</code> file, so there is no overhead in creating a package at all. Just create a directory.</p>
</li>
</ul>

<p>
As we can tell at this point, those choices actually turn out to be pretty wise: in those subtle ways, Go encourages us to keep our packages reasonably sized, by making big packages inconvenient to work with, and by making it super easy to create new packages.
</p>

<p>
And we can also notice that Rust reverses both points! As explained above:
</p>
<ul>
<li><p> A Rust crate can contain hundreds and hundreds of modules hidden within a directory tree, thus it feels very natural to do it, and</p>
</li>
<li><p> Creating a new Rust crate requires maintaining a separate <code>Cargo.toml</code> file, which adds burden and so it&#39;s natural to avoid it.</p>
</li>
</ul>

</div>

<h2 id="conclusion">Conclusion</h2>
<div>

<p>
So while Go encourages having reasonably sized packages, Rust unfortunately encourages huge crates.
</p>

<p>
It becomes even more ironic if we consider that regardless of all that, Rust is just inherently slower to compile. Don&#39;t get me wrong here btw: it definitely makes sense that Rust compiler takes more time than Go, at least because its borrow-checker needs to do a lot of work which Go simply doesn&#39;t do. So yeah, <em>of course</em> Rust is inherently slower to compile, and its borrow-checker is probably the main reason of why Rust is so awesome. 
</p>

<p>
But then knowing about it, it would only make sense to mitigate that inherent slowness wherever we can, and yet Rust does the opposite. Instead of mitigating the slowness, the design of crates and modules emphasizes it even more. So in the end, Rust encourages devs to do things which will make them suffer, for no good reason.
</p>

<p>
And even regardless of compile times, from my experience, having to split software components up properly in an acyclic dependency graph results in better-designed systems. One could say that Rust crates and modules are more flexible than Go packages and files - yeah that&#39;s true, but here by restricting what we can do, Go enforces better code organization in practice. In fact, Rust community itself likes to brag that by restricting what we can do in safe Rust, we end up with better software - I agree here, and I think it&#39;d make sense to take a similar approach with dependency management as well.
</p>






</div>


        </div></div>
  </body>
</html>
