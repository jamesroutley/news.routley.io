<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://dataswamp.org/~solene/2022-10-05-linux-nilfs-filesystem.html">Original</a>
    <h1>Linux NILFS file system: automatic continuous snapshots</h1>
    
    <div id="readability-page-1" class="page"><div>
<article id="20221005">
  <header>
  
    
    <p>Written by <em>Sol√®ne</em>, on 05 October 2022.</p>
    
  </header>
  
<p>Today, I&#39;ll share about a special Linux file system that I really enjoy.  It&#39;s called NILFS and has been imported into Linux in 2009, so it&#39;s not really a new player, despite being stable and used in production it never got popular.
</p>
<p>In this file system, there is a unique system of continuous checkpoint creation.  A checkpoint is a snapshot of your system at a given point in time, but it can be deleted automatically if some disk space must be reclaimed.  A checkpoint can be transformed into a snapshot that will never be removed.
</p>
<p>This mechanism works very well for workstations or file servers on which redundancy is nonexistent, and on which backups are done every day/weeks which give room for unrecoverable mistakes.
</p>
<p><a href="https://nilfs.sourceforge.io/en/index.html">NILFS project official website</a></p>
<p><a href="https://en.wikipedia.org/wiki/NILFS">Wikipedia page about NILFS</a></p>

<p>As NILFS is a Copy-On-Write file system (CoW), which mean when you make a change to a file, the original chunk on the disk isn&#39;t modified but a new chunk is created with the new content, this play well with making an history of the files.
</p>
<p>From my experience, it performs very well on SSD devices on a desktop system, even during heavy I/O operation.
</p>
<p>The continuous checkpoint creation system may be very confusing, so I&#39;ll explain how to learn about this mechanism and how to tame it.
</p>

<p>The concept of a garbage collector may appear given for most people, but if it doesn&#39;t speak to you, let me give a quick explanation.  In computer science, a garbage collector is a task that will look at unused memory and make it available again.
</p>
<p>On NILFS, as a checkpoint is created every few seconds, used data is never freed and one would run out of disk pretty quickly.  But here is the <code>nilfs_cleanerd</code> program, the garbage collector, that will look at the oldest checkpoint and delete them to reclaim the disk space under certain condition.  Its default strategy is trying to keep checkpoints as long as possible, until it needs to make some room to avoid issues, it may not suit a workload creating a lot of files and that&#39;s why it can be tuned very precisely.  For most desktop users, the defaults should work fine.
</p>
<p>The garbage collector is automatically started on a volume upon mount.  You can use the command <code>nilfs-clean</code> to control that daemon, reload its configuration, stop it etc...
</p>
<p>When you delete a file on a NILFS file system, it doesn&#39;t free up any disk space because it&#39;s still available in a previous checkpoint, you need to wait for the according checkpoints to be removed to have some space freed.
</p>

<p>As the output of <code>df</code> for a NILFS filesystem will give you the real data used on the disk for your data AND the snapshots/checkpoints, it can&#39;t be used to know how much free disk is available/used.
</p>
<p>In order to figure the current disk usage (without accounting older checkpoints/snapshots), we will use the command lscp to look at the number of blocks contained in the most recent checkpoint.  On Linux, a block is 4096 bytes, we can then turn the total in bytes into gigabytes by dividing three time by 1024 (bytes -&gt; kilobytes -&gt; megabytes -&gt; gigabytes).
</p>
<pre><code>lscp | awk &#39;END { print $(NF-1)*4096/1024/1024/1024 }&#39;
</code></pre>
<p>This number is the current size of what you have on the partition.
</p>

<p>It&#39;s possible to create a snapshot of your current system state using the command <code>mkcp</code>.
</p>
<pre><code>mkcp --snapshot
</code></pre>
<p>Or you can turn a checkpoint into a snapshot using the command chcp.
</p>
<pre><code>chcp ss /dev/sda1 28579
</code></pre>
<p>The opposite operation (snapshot to checkpoint) can be done using <code>chcp cp</code>.
</p>

<p>Let&#39;s say you deleted an important in-progress work, you don&#39;t have any backup and no way to retrieve it, fortunately you are using NILFS and a checkpoint was created every few seconds, so the files are still there and at reach!
</p>
<p>The first step is to pause the garbage collector to avoid losing the files: <code>nilfs-clean --suspend</code>.  After this, we can think slowly about the next steps without having to worry.
</p>
<p>The next step is to list the checkpoints using the command <code>lscp</code> and look at the date/time in which the files still existed and preferably in their latest version, so the best is to get just before the deletion.
</p>
<p>Then, we can mount the checkpoint (let&#39;s say number 12345 for the example) on a different directory using the following command:
</p>
<pre><code>mount -t nilfs2 -r -o cp=12345 /dev/sda1 /mnt
</code></pre>
<p>If it went fine, you should be able to browse the data in <code>/mnt</code> to recover your files.
</p>
<p>Once you finished recovering your files, umount <code>/mnt</code> and resume the garbage collector with <code>nilfs-clean --resume</code>.
</p>

<p>Here is a list of extra pieces you may want to read to learn more about nilfs2:
</p>
<ul>

  <li>nilfs_cleanerd and nilfs_cleanerd.conf man pages to tune the garbage collector</li>
  <li>man pages for lscp / mkcp / rmcp / chcp to manage snapshots and checkpoints manually</li>

</ul></article>
</div></div>
  </body>
</html>
