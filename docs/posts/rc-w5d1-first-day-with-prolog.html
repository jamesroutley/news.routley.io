<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://payments.posthaven.com/rc-w5d1-first-day-with-prolog">Original</a>
    <h1>RC W5D1 - First day with Prolog</h1>
    
    <div id="readability-page-1" class="page"><div id="post_body_1953289">
    
      <div><p> On occasion I start working on something but then forget the reason I got started in the first place. This time at RC, I find it <a href="https://payments.posthaven.com/rc-w1d5-haskell">helpful</a> to go back to SICP to answer the questions like “why learn Prolog?”.</p><p><a href="https://sarabander.github.io/sicp/html/4_002e3.xhtml#g_t4_002e3">Section 4.3</a> of SICP is on non-deterministic computing, which involves building an ‘automatic search’ into the evaluator. Here expressions can have more than one possible value, so the evaluator chooses a possible value and checks if requirements are met. If not, the evaluator tries out new choices or backtracks to an earlier state where there are choices. The evaluation either end successfully or fails when there are no more choices.</p><p>What’s new here is the notion of ‘requirements being met’. In other words, declaring the desired state and getting the evaluator to find it rather than declaring the exact steps. It’s Day 1, but what comes to mind is querying a database. Instead of instructions, the user declares relations.</p><p>Prolog first appeared in 1972. I became more intrigued when I learned Datalog is a successor (how they relate will have to be a different post).</p><p>Perhaps it’s helpful to look an example, here from <a href="https://sarabander.github.io/sicp/html/4_002e3.xhtml#g_t4_002e3_002e2">section 4.3.2</a>.</p><blockquote><p>Baker, Cooper, Fletcher, Miller, and Smith live on different floors of an apartment house that  contains only five floors. Baker does not live on the top floor. Cooper does not live on the bottom floor. Fletcher does not live on either the top or the bottom floor. Miller lives on a higher floor than does Cooper, Smith does not live on a floor adjacent to Fletcher’s. Fletcher does not live on a floor adjacent to Cooper’s. Where does everyone live?</p></blockquote><p>The Prolog <a href="https://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem#Plain_Prolog_version">solution</a> on Rosetta Code is compact. Symbols are denoted with quotes, variables are uppercased. Chelsea Troy has a modified (to be non-deterministic) Scheme solution <a href="https://chelseatroy.com/2019/12/09/sicp-7-nondeterministic-programming/">here</a>.</p><p><code>select([A|As],S) :- select(A,S,S1), select(As,S1).</code></p><p><code>select([],_). </code></p><p><code>dinesmans(X) :-</code></p><p><code>    %% Baker, Cooper, Fletcher, Miller, and Smith on different floors </code></p><p><code>    %% of an apartment house with five floors. </code></p><p><code>    select([Baker,Cooper,Fletcher,Miller,Smith],[1,2,3,4,5]),</code></p><p><code>    %% Baker does not live on the top floor. </code></p><p><code>    Baker =\= 5,</code></p><p><code>    %% Cooper does not live on the bottom floor.</code></p><p><code>    Cooper =\= 1,</code></p><p><code>    %% Fletcher does not live on either the top or the bottom floor.</code></p><p><code>    Fletcher =\= 1, Fletcher =\= 5,</code></p><p><code>    %% Miller lives on a higher floor than does Cooper. </code></p><p><code>    Miller &gt; Cooper,</code></p><p><code>    %% Smith does not live on a floor adjacent to Fletcher&#39;s.</code></p><p><code>    1 =\= abs(Smith - Fletcher),</code></p><p><code>    %% Fletcher does not live on a floor adjacent to Cooper&#39;s.</code></p><p><code>    1 =\= abs(Fletcher - Cooper),</code></p><p><code>    %% Where does everyone live?</code></p><p><code>    X = [&#39;Baker&#39;(Baker), &#39;Cooper&#39;(Cooper), &#39;Fletcher&#39;(Fletcher), </code></p><p><code>         &#39;Miller&#39;(Miller), &#39;Smith&#39;(Smith)].</code></p><p><code>main :-  bagof( X, dinesmans(X), L ) </code></p><p><code>         -&gt; maplist( writeln, L), nl, write(&#39;No more solutions.&#39;) </code></p><p><code>         ;  write(&#39;No solutions.’).</code></p><p>Verse and Mercury are functional logic languages; Mercury even calls <a href="https://news.ycombinator.com/item?id=13295152">itself</a> &#39;Prolog meets Haskell’. Details will follow in later posts.</p></div>
    
  </div></div>
  </body>
</html>
