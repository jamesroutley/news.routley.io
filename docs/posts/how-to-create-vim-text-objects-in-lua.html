<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/vim-create-text-objects/">Original</a>
    <h1>How to Create Vim Text-Objects in Lua</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2022/vim_text_object/vim_text_object.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/vim_text_object/vim_text_object.jpg" alt="Vim text object: operator-pending mapping and character selection"/></picture><p>“You don’t get it. Vim is like a language! You’ll speak Vim when you write! When you go to the market! You’ll speak Vim with your cat! When you think, it will be the Word of Vim™ in your head! You’ll see! It will change your life!”</p><p>This is the kind of argument any Vim hippy would sing to the poor heretics, trying to convert them to The Eternal Editor. A hippy like me, who’s now writing an article about one of the main component of this “language”, the <em>text-object</em>. Repeat after me: glory to the text-object!</p><p>It’s powerful to use them, that’s true; but we can do better. We could create new text-objects, like a god creating life! We could shape the Chaos to bring order in the galaxy!</p><p>The Greek god <a href="https://en.wikipedia.org/wiki/Hephaestus" target="_blank" rel="noopener">Hephaestus</a> created the fire in his legendary forge. Like him, we also need some tools to create our own text-objects. What on Earth can we use? Vimscript?</p><p>With Neovim, we can use Lua to customize our favorite editor; we can also <a href="https://gist.github.com/leolord/bb51bdee3f199c2a6cfe2d57a42a2c26" target="_blank" rel="noopener">compile Vim with Lua support</a>. To me, one of the best way to learn how to customize Vim is to take already written functions in Vimscript and transform them in Lua.</p><p>The benefits:</p><ol><li>If you don’t know Vimscript, analyzing the code to transform it in Lua will show you useful functions you can use for more customization. It’s essential for harnessing Vim’s power.</li><li>If you don’t know Lua, you can learn it this way, too. It’s a great programming language, used by many other tools, like the fantastic <a href="https://www.youtube.com/watch?v=-S8-a_YS6tc" target="_blank" rel="noopener">Pandoc</a> for example.</li><li>You’ll get a deeper understanding how Vim works, allowing your to improve your workflow.</li></ol><p>So let’s taste the power of Vimscript functions combined with Lua constructs, by implementing useful text-objects. More specificaly, we’ll see in this article:</p><ul><li>The general principles governing text-objects.</li><li>How to create a text-object representing a line.</li><li>How to create text-objects delimited by a pair of characters, like two commas.</li><li>How to create a very useful - and quite universal - text-object matching some level of indentation.</li></ul><p>The text-objects we’ll create are inspired by other authors from The Great Internet™. You’ll find the sources of this inspiration at the end of the article.</p><p>I assume here that you’re somehow proficient with Vim. If you don’t understand what’s happening in this article, you can look at my <a href="https://thevaluable.dev/vim-commands-beginner/">series of articles to learn Vim</a>. Also:</p><p>If it’s the first time you write some Lua, I would encourage you to customize things further by modifying the examples we’ll see in this article. To use the correct syntax, you should keep a quick reference on side, like <a href="https://learnxinyminutes.com/docs/lua/" target="_blank" rel="noopener">this one</a>.</p><p>Are you ready to dive into Vimscript, Lua, and text-objects? I’m sure you are! Let’s go!</p><h2 id="whats-a-text-object">What’s a Text-Object?</h2><p>Before jumping into Vim to create our new delightful text-objects, let’s first do what any developer should do when she needs to solve a problem: thinking. Let’s <a href="https://thevaluable.dev/single-responsibility-principle-revisited/#decomposition">decompose</a> what a text-object is:</p><ol><li>Text-objects are NORMAL mode keystrokes using two keys; the first one can only be an “a” (for “<code>a</code>round”) or an “i” (for “<code>i</code>nside”).</li><li>A text-object represents a specific string of characters, with a beginning and an end.</li><li>It can only be used after an operator, or after switching to VISUAL mode character-wise (using “v” in NORMAL mode).</li><li>The operator will act on the text-object, VISUAL mode will select the text-object itself.</li><li>To apply an operator on some text-objects, the cursor doesn’t have to be on the text-object itself. In that case, the operator will act on the <em>next</em> text-object of the line.</li></ol><p>If you never heard of the rule 5, it can change your life, and bring you glory and fortune in a couple of days. Nothing less! If you type <code>di(</code> in NORMAL mode, and your cursor is <em>before</em> a pair of parentheses, you’ll move inside them. The operator <code>d</code> will then delete everything inside. Neat!</p><p>As I was saying just above, a text-object can begin with an “a” or an “i”. I understand text-objects beginning with “a” as “<code>a</code>round”, even if Vim’s help will refer to them as the indefinite article <code>a</code>, like <code>d</code>elete <code>a</code> <code>w</code>ord. I prefer “around” because this kind of text-objects often include some characters around the “inside” text-object. It’s a good mnemonic to remember the difference between the two.</p><p>Motions are looking a lot like text-objects, but they’re not the same. Using an operator before a motion will perform an action from the cursor position to the end result of the motion. A text-object doesn’t necessarily start at the cursor position; that’s the biggest difference.</p><p>For example, <code>daw</code> will <code>d</code>elete <code>a</code>round a <code>w</code>ord, whatever the letter of the word your cursor is on. Using a motion, <code>dw</code> will delete from the cursor position to the next <code>w</code>ord.</p><p>Now that we explored the problem space, let’s enter the solution space. To create a text-object with a start and an end, we could simply:</p><ol><li>Select the characters we want.</li><li>Apply whatever operator on the selection.</li></ol><p>That’s great, because Vim has some mapping allowing us to do that easily.</p><div><div><ul><li><code>:help text-object</code></li><li><code>:help motion</code></li></ul></div></div><h2 id="the-operator-pending-mapping">The Operator-Pending Mapping</h2><h3 id="basics">Basics</h3><p>When we hit an operator in NORMAL mode (like <code>d</code>, <code>y</code>, or <code>c</code>, for example), we switch silently to the OPERATOR-PENDING mode. It’s in this mode that we’ll input our motion (or text-object) we want to operate on. Then, we switch back to NORMAL mode, automagically.</p><p>To define new text-objects (or motions) which can be used in OPERATOR-PENDING mode, you can use an operator-pending mapping: <code>omap</code> or, if you don’t want a recursive mapping, <code>onoremap</code>. Thanks to them, we only need to worry about selecting the characters included in our text-objects; we don’t care about the operators themselves.</p><h3 id="the-line-our-new-text-object">The Line: Our New Text-Object</h3><p>Let’s now create the first text-object of this article: a line.</p><ul><li>The text-object <code>al</code> (“<code>a</code>round the <code>l</code>ine) will delete everything, including the possible indentations at the beginning.</li><li>The text-object <code>il</code> (<code>i</code>nside the <code>l</code>ine) won’t delete the indentation.</li></ul><p>Here’s a first mapping for <code>il</code>:</p><div><pre><code data-lang="vim"><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>il</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> $<span>v</span>^<span>&lt;</span><span>cr</span><span>&gt;</span><span>
</span></code></pre></div><p>In case you’re not sure what that means, here are some explanations:</p><table><tbody><tr><td><code>&lt;silent&gt;</code></td><td>Don’t echo the Ex-command executed in the command-line window.</td></tr><tr><td><code>&lt;c-u&gt;</code></td><td>Delete everything already written in COMMAND-LINE mode (like the selection markers <code>&#39;&lt;,&#39;&gt;</code> for example).</td></tr><tr><td><code>normal!</code></td><td>This Ex-command allow executing NORMAL mode keystrokes.</td></tr><tr><td><code>$v^</code></td><td>Go to the end of the line, switch to VISUAL mode, and select till the beginning of the line (without the eventual white spaces).</td></tr></tbody></table><p>For example, if you hit <code>yil</code> or <code>dil</code>, your operators <code>y</code>ank and <code>d</code>elete will operate on our new text-object. If we only want to select it, we need another mapping for VISUAL mode:</p><div><pre><code data-lang="vim"><span>xnoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>il</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> $<span>v</span>^<span>&lt;</span><span>cr</span><span>&gt;</span><span>
</span></code></pre></div><p>You can now hit <code>vil</code> and admire the potential of your infinite skills.</p><p>We have now the “inside” version of our text-object; what about the “around” one?</p><div><pre><code data-lang="vim"><span>xnoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>al</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> $<span>v0</span><span>&lt;</span><span>cr</span><span>&gt;</span><span>
</span><span></span><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>al</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> $<span>v0</span><span>&lt;</span><span>cr</span><span>&gt;</span><span>
</span></code></pre></div><p>These mappings follow the same principles, except that we select everything this time, including the eventual whitespaces at the beginning of the line. We could also use <code>V</code> instead of <code>$v0</code>.</p><h2 id="the-missing-text-objects">The Missing Text-Objects</h2><p>Our new text-objects are great, but we can do better. This time, we’ll create a whole series, delimited by different pair of characters.</p><h3 id="between-two-characters">Between Two Characters</h3><p>It’s easy to delete a pair of parentheses: <code>a(</code>, <code>a)</code>, or even <code>ab</code> are there for you. As always, there are some “inside” variants, too. But what about deleting everything between two dots? Between two hyphens? Between two commas?</p><p>What about creating text-objects delimited by these characters: <code>,</code>,<code>.</code>,<code>;</code>,<code>:</code>,<code>+</code>,<code>-</code>,<code>=</code>,<code>~</code>,<code>_</code>,<code>*</code>,<code>#</code>,<code>/</code>,<code>|</code>,<code>\</code>,<code>&amp;</code>,<code>$</code>,<code>?</code>?</p><p>To solve this problem, we could look at a simple example:</p><pre><code>Hello, how are you, you?
</code></pre><p>If we want to change the characters between the two commas, we could:</p><ol><li>Move the cursor to the first comma.</li><li>Select everything till the second comma.</li><li>Whether including the commas in the selection or not will be the difference between the “around” and the “inside” text-object.</li></ol><p>This scenario requires our cursor to be between the two commas, at least for now. We’ll improve this soon.</p><p>To move our cursor to the first or second comma, we can use <code>f</code>, <code>F</code>, <code>t</code>, and <code>T</code> in NORMAL mode. Here’s a possible solution:</p><div><pre><code data-lang="vim"><span>xnoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>i</span><span>,</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> <span>T</span><span>,</span><span>vt</span><span>,&lt;</span><span>cr</span><span>&gt;</span><span>
</span><span></span><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>i</span><span>,</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> <span>T</span><span>,</span><span>vt</span><span>,&lt;</span><span>cr</span><span>&gt;</span><span>
</span><span></span><span>xnoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>a</span><span>,</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> <span>F</span><span>,</span><span>ft</span><span>,&lt;</span><span>cr</span><span>&gt;</span><span>
</span><span></span><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>a</span><span>,</span> :<span>&lt;</span><span>c</span><span>-</span><span>u</span><span>&gt;</span><span>normal</span><span>!</span> <span>F</span><span>,</span><span>ft</span><span>,&lt;</span><span>cr</span><span>&gt;</span><span>
</span></code></pre></div><p>We could repeat these mappings for every character we want to include. But it would be quite difficult to read and maintain. Taking some inspiration from a Zsh snippet I’ve already covered in <a href="https://thevaluable.dev/zsh-install-configure-mouseless/#adding-text-objects">this article</a>, we could:</p><ol><li>Loop through all the different characters.</li><li>Loop through all the different modes we want to map (OPERATOR-PENDING mode and VISUAL mode).</li><li>Create the different mappings for each iteration.</li></ol><p>Here’s a possible implementation in Vimscript:</p><div><pre><code data-lang="vim"><span>let</span> <span>s</span>:<span>chars</span> <span>=</span> [ <span>&#39;_&#39;</span><span>,</span> <span>&#39;.&#39;</span><span>,</span> <span>&#39;:&#39;</span><span>,</span> <span>&#39;,&#39;</span><span>,</span> <span>&#39;;&#39;</span><span>,</span> <span>&#39;&lt;bar&gt;&#39;</span><span>,</span> <span>&#39;/&#39;</span><span>,</span> <span>&#39;&lt;bslash&gt;&#39;</span><span>,</span> <span>&#39;*&#39;</span><span>,</span> <span>&#39;+&#39;</span><span>,</span> <span>&#39;%&#39;</span><span>,</span> <span>&#39;`&#39;</span><span>,</span> <span>&#39;?&#39;</span> ]<span>
</span><span></span><span>for</span> <span>char</span> <span>in</span> <span>s</span>:<span>chars</span><span>
</span><span></span>    <span>for</span> <span>mode</span> <span>in</span> [ <span>&#39;xnoremap&#39;</span><span>,</span> <span>&#39;onoremap&#39;</span> ]<span>
</span><span></span>        <span>execute</span> <span>printf</span><span>(</span><span>&#39;%s &lt;silent&gt; i%s :&lt;C-u&gt;normal! T%svt%s&lt;CR&gt;&#39;</span><span>,</span> <span>mode</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>)</span><span>
</span><span></span>        <span>execute</span> <span>printf</span><span>(</span><span>&#39;%s &lt;silent&gt; a%s :&lt;C-u&gt;normal! F%svf%s&lt;CR&gt;&#39;</span><span>,</span> <span>mode</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>)</span><span>
</span><span></span>    <span>endfor</span><span>
</span><span></span><span>endfor</span><span>
</span></code></pre></div><p>I like to use Vimscript for simple configurations, but as soon as I need to reach for loops or conditionals (I hate the equality-operators-mess in Vimscript), I switch to Lua. If you use Neovim, or if you have Vim compiled with Lua, you can use the following:</p><div><pre><code data-lang="lua"><span>function</span> <span>basic_text_objects</span><span>()</span>
    <span>local</span> <span>chars</span> <span>=</span> <span>{</span> <span>&#39;_&#39;</span><span>,</span> <span>&#39;.&#39;</span><span>,</span> <span>&#39;:&#39;</span><span>,</span> <span>&#39;,&#39;</span><span>,</span> <span>&#39;;&#39;</span><span>,</span> <span>&#39;|&#39;</span><span>,</span> <span>&#39;/&#39;</span><span>,</span> <span>&#39;</span><span>\\</span><span>&#39;</span><span>,</span> <span>&#39;*&#39;</span><span>,</span> <span>&#39;+&#39;</span><span>,</span> <span>&#39;%&#39;</span><span>,</span> <span>&#39;`&#39;</span><span>,</span> <span>&#39;?&#39;</span> <span>}</span>
    <span>for</span> <span>_</span><span>,</span><span>char</span> <span>in</span> <span>ipairs</span><span>(</span><span>chars</span><span>)</span> <span>do</span>
        <span>for</span> <span>_</span><span>,</span><span>mode</span> <span>in</span> <span>ipairs</span><span>({</span> <span>&#39;x&#39;</span><span>,</span> <span>&#39;o&#39;</span> <span>})</span> <span>do</span>
            <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#34;i&#34;</span> <span>..</span> <span>char</span><span>,</span> <span>string.format</span><span>(</span><span>&#39;:&lt;C-u&gt;normal! T%svt%s&lt;CR&gt;&#39;</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>),</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
            <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#34;a&#34;</span> <span>..</span> <span>char</span><span>,</span> <span>string.format</span><span>(</span><span>&#39;:&lt;C-u&gt;normal! F%svf%s&lt;CR&gt;&#39;</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>),</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
        <span>end</span>
    <span>end</span>
<span>end</span>

<span>return</span> <span>{</span>
    <span>basic_text_objects</span> <span>=</span> <span>basic_text_objects</span>
<span>}</span>
</code></pre></div><p>I would advise you to keep your Lua scrips in a <code>lua/&lt;namespace&gt;</code> folder; <code>&lt;namespace&gt;</code> could be your username, or anything else you’d like. For example, my scripts are in <code>$XDG_CONFIG_HOME/nvim/lua/hypnos</code>.</p><p>Then, you can call directly your new functions in your vimrc. If it’s a Vimscript file, you’ll need the prefix <code>lua</code> as follows:</p><div><pre><code data-lang="vim"><span>lua</span> <span>require</span><span>(</span><span>&#39;&lt;namespace&gt;/text_objects&#39;</span><span>)</span>.<span>basic_text_objects</span><span>()</span><span>
</span></code></pre></div><h3 id="to-the-next-text-object">To The Next Text-Object</h3><p>Right now, we need our cursor between the two characters to act on our new text-objects. It would also be nice to be able to operate on the first pair of these characters when our cursor is <em>before</em> them. As we saw above in this article, it’s already what we can do with parenthesis or quotes.</p><p>Let’s consider the following example:</p><pre><code>She felt, suddenly, deeply in love with Vim.
</code></pre><p>We could try to end up on the first comma of the pair whether the cursor is before them or between them. From there, we would select everything till the second comma. Here’s a possible mapping:</p><div><pre><code data-lang="vim"><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span> <span>i</span><span>,</span> :<span>&lt;</span><span>C</span><span>-</span><span>u</span><span>&gt;</span><span>silent</span><span>!</span> <span>normal</span><span>!</span> <span>f</span><span>,</span><span>F</span><span>,</span><span>lvt</span><span>,&lt;</span><span>cr</span><span>&gt;</span><span>
</span></code></pre></div><p>Let’s imagine that the cursor is on the first <code>d</code> of <code>suddenly</code>, between the commas.</p><ol><li><code>f,</code> - Move to the second comma.</li><li><code>F,</code> - Move to the first comma.</li><li><code>l</code> - Move one character to the right (on the space after the comma).</li><li><code>vt,</code> - Visually select everything till the next comma.</li></ol><p>Now, let’s imagine that our cursor is on the <code>S</code> of <code>She</code>, before the commas.</p><ol><li><code>f,</code> - Move to the first comma.</li><li><code>F,</code> - There is no comma before the cursor to be found, so the Ex-command <code>normal!</code> fails.</li><li><code>l</code> - Move one character to the right (on the space after the comma).</li><li><code>vt,</code> - Visually select everything till the next comma</li></ol><p>Note that the Ex-command <code>normal!</code> fails at the second step. By default, it would stop there, not executing the steps 3 and 4. That’s why we add the Ex-command <code>:silent!</code> here; it will force <code>normal!</code> to execute till the end.</p><p>For the “around” text-object, we can follow the same principles. The only difference: we also select the two commas.</p><div><pre><code data-lang="vim"><span>onoremap</span> <span>a</span><span>,</span> :<span>&lt;</span><span>C</span><span>-</span><span>u</span><span>&gt;</span><span>silent</span><span>!</span> <span>normal</span><span>!</span> <span>f</span><span>,</span><span>F</span><span>,</span><span>vf</span><span>,&lt;</span><span>cr</span><span>&gt;</span><span>
</span></code></pre></div><p>Here’s the final result, in Lua:</p><div><pre><code data-lang="lua"><span>function</span> <span>basic_text_objects</span><span>()</span>
    <span>local</span> <span>chars</span> <span>=</span> <span>{</span> <span>&#39;_&#39;</span><span>,</span> <span>&#39;.&#39;</span><span>,</span> <span>&#39;:&#39;</span><span>,</span> <span>&#39;,&#39;</span><span>,</span> <span>&#39;;&#39;</span><span>,</span> <span>&#39;|&#39;</span><span>,</span> <span>&#39;/&#39;</span><span>,</span> <span>&#39;</span><span>\\</span><span>&#39;</span><span>,</span> <span>&#39;*&#39;</span><span>,</span> <span>&#39;+&#39;</span><span>,</span> <span>&#39;%&#39;</span><span>,</span> <span>&#39;`&#39;</span><span>,</span> <span>&#39;?&#39;</span> <span>}</span>
    <span>for</span> <span>idx</span><span>,</span><span>char</span> <span>in</span> <span>ipairs</span><span>(</span><span>chars</span><span>)</span> <span>do</span>
        <span>for</span> <span>idx</span><span>,</span><span>mode</span> <span>in</span> <span>ipairs</span><span>({</span> <span>&#39;x&#39;</span><span>,</span> <span>&#39;o&#39;</span> <span>})</span> <span>do</span>
            <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#34;i&#34;</span> <span>..</span> <span>char</span><span>,</span> <span>string.format</span><span>(</span><span>&#39;:&lt;C-u&gt;silent! normal! f%sF%slvt%s&lt;CR&gt;&#39;</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>),</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
            <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#34;a&#34;</span> <span>..</span> <span>char</span><span>,</span> <span>string.format</span><span>(</span><span>&#39;:&lt;C-u&gt;silent! normal! f%sF%svf%s&lt;CR&gt;&#39;</span><span>,</span> <span>char</span><span>,</span> <span>char</span><span>),</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
        <span>end</span>
    <span>end</span>
<span>end</span>
</code></pre></div><p>Keep in mind that it’s a naive approach. First, making the <code>normal!</code> command fails feels a bit like a hack. Additionally, it’s quite difficult to understand. That said, sometimes a hack is good enough to answer our needs and move forward. I wouldn’t use that in a plugin which could be used by others, but for my own use it’s good enough.</p><p>Each time we’ve created our text-objects, we first stated the problem, and then tried to find a way toward a solution. That’s a good iterative approach, but it also means that our text-objects might not cover all the possible scenario. We can still improve things afterward, if we see that our text-objects don’t behave as expected in specific situations.</p><p>This is different from installing a plugin: you often have no idea how it works, and you can’t modify them iteratively to answer your specific needs.</p><h2 id="text-objects-based-on-indentations">Text-Objects Based On Indentations</h2><p>Let’s create one more text-object, more complex this time. It can be useful for any developer.</p><h3 id="the-basics">The Basics</h3><p>If you look at the text-objects already available in vanilla Vim, their boundaries are based on specific characters. There are other important elements you’ll find in most codebases which can be used for a text-object: indentations.</p><p>Here’s how to select our new text-objects:</p><ol><li>Get the starting indentation of the current line. This will be the indentation of reference we’ll compare every other line to.</li><li>Move up line by line, as long as the indentation is equal or higher to the starting indentation.</li><li>Stop when the next line doesn’t fulfill the rule 2 anymore, and begin VISUAL mode line-wise.</li><li>Move down till the indentation is equal or higher to the starting indentation.</li></ol><p>It means that our text-objects include all the lines having the same indentation as the one you start with, or higher. Since the behavior is more complex than other text-objects we’ve created, let’s implement a function we’ll call in our mappings:</p><div><pre><code data-lang="vim"><span>function</span><span>!</span> <span>IndentTextObject</span><span>()</span><span>
</span><span></span>  <span>let</span> <span>startindent</span> <span>=</span> <span>indent</span><span>(</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>))</span><span>
</span><span></span><span>
</span><span>  &#34; Move up till we are at the top of the buffer</span><span>
</span><span></span><span>  &#34; or till the indentation is less than the starting one</span><span>
</span><span></span>  <span>let</span> <span>prevline</span> <span>=</span> <span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span><span>
</span><span></span>  <span>while</span> <span>prevline</span> <span>&gt;</span> <span>0</span> &amp;&amp; <span>indent</span><span>(</span><span>prevline</span><span>)</span> <span>&gt;=</span> <span>startindent</span><span>
</span><span></span>    <span>-</span><span>
</span><span></span>    <span>let</span> <span>prevline</span> <span>=</span> <span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span><span>
</span><span></span>  <span>endwhile</span><span>
</span><span></span><span>
</span><span>  &#34; Begin linewise-visual selection</span><span>
</span><span></span>  <span>normal</span><span>!</span> <span>0</span>V<span>
</span><span></span><span>
</span><span>  &#34; Move down till we are at the bottom of the buffer</span><span>
</span><span></span><span>  &#34; or till the indentation is less than the starting one</span><span>
</span><span></span>  <span>let</span> <span>nextline</span> <span>=</span> <span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span><span>
</span><span></span>  <span>let</span> <span>lastline</span> <span>=</span> <span>line</span><span>(</span><span>&#39;$&#39;</span><span>)</span><span>
</span><span></span>  <span>while</span> <span>nextline</span> <span>&lt;=</span> <span>lastline</span> &amp;&amp; <span>indent</span><span>(</span><span>nextline</span><span>)</span> <span>&gt;=</span> <span>startindent</span><span>
</span><span></span>    <span>+</span><span>
</span><span></span>    <span>let</span> <span>nextline</span> <span>=</span> <span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span><span>
</span><span></span>  <span>endwhile</span><span>
</span><span></span><span>endfunction</span><span>
</span><span>
</span><span></span><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span><span>ai</span> :<span>&lt;</span><span>C</span><span>-</span><span>U</span><span>&gt;</span><span>call</span> <span>IndentTextObject</span><span>()&lt;</span><span>CR</span><span>&gt;</span><span>
</span><span></span><span>onoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span><span>ii</span> :<span>&lt;</span><span>C</span><span>-</span><span>U</span><span>&gt;</span><span>call</span> <span>IndentTextObject</span><span>()&lt;</span><span>CR</span><span>&gt;</span><span>
</span><span></span><span>xnoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span><span>ai</span> :<span>&lt;</span><span>C</span><span>-</span><span>U</span><span>&gt;</span><span>call</span> <span>IndentTextObject</span><span>()&lt;</span><span>CR</span><span>&gt;</span><span>
</span><span></span><span>xnoremap</span> <span>&lt;</span><span>silent</span><span>&gt;</span><span>ii</span> :<span>&lt;</span><span>C</span><span>-</span><span>U</span><span>&gt;</span><span>call</span> <span>IndentTextObject</span><span>()&lt;</span><span>CR</span><span>&gt;</span><span>
</span></code></pre></div><p>Again, I always prefer using Lua when things get slightly complex:</p><div><pre><code data-lang="lua"><span>function</span> <span>select_indent</span><span>()</span>
    <span>local</span> <span>start_indent</span> <span>=</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>))</span>
    <span>local</span> <span>prev_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span>

    <span>while</span> <span>prev_line</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>prev_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span> <span>do</span>
        <span>vim.cmd</span><span>(</span><span>&#39;-&#39;</span><span>)</span>
        <span>prev_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span>
    <span>end</span>

    <span>vim.cmd</span><span>(</span><span>&#39;normal! 0V&#39;</span><span>)</span>

    <span>local</span> <span>next_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span>
    <span>local</span> <span>last_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;$&#39;</span><span>)</span>
    <span>while</span> <span>next_line</span> <span>&lt;=</span> <span>last_line</span> <span>and</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>next_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span> <span>do</span>
        <span>vim.cmd</span><span>(</span><span>&#39;+&#39;</span><span>)</span>
        <span>next_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span>
    <span>end</span>
<span>end</span>

<span>function</span> <span>indent_text_objects</span><span>()</span>
    <span>for</span> <span>_</span><span>,</span><span>mode</span> <span>in</span> <span>ipairs</span><span>({</span> <span>&#39;x&#39;</span><span>,</span> <span>&#39;o&#39;</span> <span>})</span> <span>do</span>
        <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#39;ii&#39;</span><span>,</span> <span>&#39;:&lt;c-u&gt;lua select_indent()&lt;cr&gt;&#39;</span><span>,</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
        <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#39;ai&#39;</span><span>,</span> <span>&#39;:&lt;c-u&gt;lua select_indent()&lt;cr&gt;&#39;</span><span>,</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
    <span>end</span>
<span>end</span>

<span>return</span> <span>{</span>
    <span>indent_text_objects</span> <span>=</span> <span>indent_text_objects</span><span>,</span>
<span>}</span>
</code></pre></div><p>The core of the functions are the two <code>while</code> loops. They will:</p><ol><li>Move the cursor up till the previous line has less indentation than the starting one.</li><li>Begin VISUAL mode line-wise (with <code>normal! 0V</code>) and go down line by line, selecting the ones at the same level of indentation or higher.</li></ol><p>Note that we use the Ex-command <code>-</code> and <code>+</code> to move up and down. Yes, they’re Ex-command: try <code>:+</code> for example. You could also use <code>normal! k</code> or <code>normal! &lt;up&gt;</code>.</p><h3 id="improving-the-implementation">Improving the Implementation</h3><p>Our little function works great, but it shows quickly its limits. Perhaps the most obvious: the “inside” and “around” text-objects have the exact same behavior. Horror and damnation!</p><p>Let’s say that the “around” the text-object should select two more lines, the first lines having fewer indentations when we move up and down.</p><p>To illustrate, consider the following code. The symbol “┃” represents the cursor:</p><div><pre><code data-lang="lua"><span>-- Comment</span>
<span>function</span> <span>super_function</span><span>()</span>
 <span>┃</span>  <span>if</span> <span>true</span> <span>then</span>
       <span>print</span><span>(</span><span>&#39;youpi&#39;</span><span>)</span>
       <span>print</span><span>(</span><span>&#39;wuhu&#39;</span><span>)</span>
    <span>end</span>
<span>end</span>
<span>-- Comment</span>
</code></pre></div><p>Hitting <code>dii</code> would delete the whole <code>if</code> block but let everything else untouched. Hitting <code>dai</code> would delete everything, except the two comments.</p><p>From there, we have two solutions:</p><ol><li>Create two different functions: one for the “around” text-object, one for the “inside”.</li><li>Pass a boolean flag to use the “around” or “inside” text-object in the same function.</li></ol><p>If we go with the first solution, we would have almost identical functions; it’s likely we would need to change both each time we want to improve our text-objects. So let’s go with the second solution. That said, if there are too many conditionals creeping in because there are more and more differences between the two text-objects, I would definitely split the function.</p><p>Here’s a possible implementation:</p><div><pre><code data-lang="lua"><span>function</span> <span>select_indent</span><span>(</span><span>around</span><span>)</span>
    <span>local</span> <span>start_indent</span> <span>=</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>))</span>
    <span>local</span> <span>prev_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span>

    <span>while</span> <span>prev_line</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>prev_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span> <span>do</span>
        <span>vim.cmd</span><span>(</span><span>&#39;-&#39;</span><span>)</span>
        <span>prev_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span>
    <span>end</span>
    <span>if</span> <span>around</span> <span>then</span>
        <span>vim.cmd</span><span>(</span><span>&#39;-&#39;</span><span>)</span>
    <span>end</span>

    <span>vim.cmd</span><span>(</span><span>&#39;normal! 0V&#39;</span><span>)</span>

    <span>local</span> <span>next_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span>
    <span>local</span> <span>last_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;$&#39;</span><span>)</span>
    <span>while</span> <span>next_line</span> <span>&lt;=</span> <span>last_line</span> <span>and</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>next_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span> <span>do</span>
        <span>vim.cmd</span><span>(</span><span>&#39;+&#39;</span><span>)</span>
        <span>next_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span>
    <span>end</span>
    <span>if</span> <span>around</span> <span>then</span>
        <span>vim.cmd</span><span>(</span><span>&#39;+&#39;</span><span>)</span>
    <span>end</span>
<span>end</span>

<span>function</span> <span>indent_text_objects</span><span>()</span>
    <span>for</span> <span>_</span><span>,</span><span>mode</span> <span>in</span> <span>ipairs</span><span>({</span> <span>&#39;x&#39;</span><span>,</span> <span>&#39;o&#39;</span> <span>})</span> <span>do</span>
        <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#39;ii&#39;</span><span>,</span> <span>&#39;:&lt;c-u&gt;lua select_indent()&lt;cr&gt;&#39;</span><span>,</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
        <span>vim.api</span><span>.</span><span>nvim_set_keymap</span><span>(</span><span>mode</span><span>,</span> <span>&#39;ai&#39;</span><span>,</span> <span>&#39;:&lt;c-u&gt;lua select_indent(true)&lt;cr&gt;&#39;</span><span>,</span> <span>{</span> <span>noremap</span> <span>=</span> <span>true</span><span>,</span> <span>silent</span> <span>=</span> <span>true</span> <span>})</span>
    <span>end</span>
<span>end</span>

<span>return</span> <span>{</span>
    <span>indent_text_objects</span> <span>=</span> <span>indent_text_objects</span><span>,</span>
<span>}</span>
</code></pre></div><p>Next, we could ignore the blank lines. Right now, we don’t really care about them; but they will inevitably stop our moves up and down because their level of indentation will always be less than the starting one. That is, if your cursor wasn’t on a line without indentation from the start, in which case you would select the entire buffer.</p><p>We can define a blank line as a line only containing white space (spaces, tabs, and newlines). To find out if the previous or next line is indeed blank, we could use a regex:</p><div><pre><code data-lang="lua"><span>local</span> <span>blank_line_pattern</span> <span>=</span> <span>&#39;^%s*$&#39;</span>
</code></pre></div><p>Regexes in Lua are a bit odd: where you would have <code>\s</code> for representing white spaces in many other regex engines, you have <code>%s</code> in Lua.</p><p>We now need to verify at each iteration if the next line is blank. We could create a small function for that:</p><div><pre><code data-lang="lua"><span>local</span> <span>prev_blank_line</span> <span>=</span> <span>function</span><span>(</span><span>line</span><span>)</span> <span>return</span> <span>string.match</span><span>(</span><span>vim.fn</span><span>.</span><span>getline</span><span>(</span><span>line</span><span>),</span> <span>blank_line_pattern</span><span>)</span> <span>end</span>
</code></pre></div><p>We also need to modify the conditions for our two while loops. For example:</p><div><pre><code data-lang="lua"><span>while</span> <span>prev_line</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>(</span><span>prev_blank_line</span><span>(</span><span>prev_line</span><span>)</span> <span>or</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>prev_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span><span>)</span> <span>do</span>
</code></pre></div><p>A last detail which might suits you. When your cursor is on a blank line while summoning your text-object with your agile fingers, you could ignore the keystroke. If you find the idea appealing, you could add the following before the first while loop:</p><div><pre><code data-lang="lua"><span>if</span> <span>string.match</span><span>(</span><span>vim.fn</span><span>.</span><span>getline</span><span>(</span><span>&#39;.&#39;</span><span>),</span> <span>blank_line_pattern</span><span>)</span> <span>then</span>
    <span>return</span>
<span>end</span>
</code></pre></div><p>We’ve now patched the most obvious defects of our text-object. But we can do better! What about being able to give a count to select lower levels of indentation?</p><p>For example, <code>dai</code> would work as it does now, but <code>d2ai</code> would select a lower level of indentation, and <code>d3ai</code> would select even more.</p><p>To do so, we simply need to increase our starting indentation depending on the count given. Right now, we only know what’s the level of indentation of the current line with our variable <code>start_indent</code>, but we don’t know the <em>amount</em> of indentations for each level.</p><p>To get this information, we can look at the value of the option <code>shiftwidth</code>.</p><p>Here’s the implementation:</p><div><pre><code data-lang="lua"><span>local</span> <span>start_indent</span> <span>=</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>))</span>
<span>if</span> <span>vim.v</span><span>.</span><span>count</span> <span>&gt;</span> <span>0</span> <span>then</span>
    <span>start_indent</span> <span>=</span> <span>start_indent</span> <span>-</span> <span>vim.o</span><span>.</span><span>shiftwidth</span> <span>*</span> <span>(</span><span>vim.v</span><span>.</span><span>count</span> <span>-</span> <span>1</span><span>)</span>
    <span>if</span> <span>start_indent</span> <span>&lt;</span> <span>0</span> <span>then</span>
        <span>start_indent</span> <span>=</span> <span>0</span>
    <span>end</span>
<span>end</span>
</code></pre></div><p>You might wonder about the calculation:</p><div><pre><code data-lang="lua"><span>start_indent</span> <span>=</span> <span>start_indent</span> <span>-</span> <span>vim.o</span><span>.</span><span>shiftwidth</span> <span>*</span> <span>(</span><span>vim.v</span><span>.</span><span>count</span> <span>-</span> <span>1</span><span>)</span>
</code></pre></div><p>First, <code>vim.v.count</code> is the count given to the text-object. In Vimscript, it would be <code>v:count</code>.</p><p>Regarding the calculation itself, we need to multiply the count given by the amount of indentations per level (the <code>shiftwidth</code> option), and subtract it to the indentations of the current line. It gives us the amount of indentations one level above.</p><p>We decide that a count of <code>1</code> shouldn’t change anything (<code>dai</code> is the same as <code>d1ai</code>), that’s why we subtract <code>1</code> from the count. We also verify if our starting indentation is lower than 0, which could happen if we enter a count on a line without any indentation. In that case, We force the starting indentation to 0.</p><p>Here’s the final function:</p><div><pre><code data-lang="lua"><span>function</span> <span>select_indent</span><span>(</span><span>around</span><span>)</span>
    <span>local</span> <span>start_indent</span> <span>=</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>))</span>
    <span>local</span> <span>blank_line_pattern</span> <span>=</span> <span>&#39;^%s*$&#39;</span>

    <span>if</span> <span>string.match</span><span>(</span><span>vim.fn</span><span>.</span><span>getline</span><span>(</span><span>&#39;.&#39;</span><span>),</span> <span>blank_line_pattern</span><span>)</span> <span>then</span>
        <span>return</span>
    <span>end</span>

    <span>if</span> <span>vim.v</span><span>.</span><span>count</span> <span>&gt;</span> <span>0</span> <span>then</span>
        <span>start_indent</span> <span>=</span> <span>start_indent</span> <span>-</span> <span>vim.o</span><span>.</span><span>shiftwidth</span> <span>*</span> <span>(</span><span>vim.v</span><span>.</span><span>count</span> <span>-</span> <span>1</span><span>)</span>
        <span>if</span> <span>start_indent</span> <span>&lt;</span> <span>0</span> <span>then</span>
            <span>start_indent</span> <span>=</span> <span>0</span>
        <span>end</span>
    <span>end</span>

    <span>local</span> <span>prev_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span>
    <span>local</span> <span>prev_blank_line</span> <span>=</span> <span>function</span><span>(</span><span>line</span><span>)</span> <span>return</span> <span>string.match</span><span>(</span><span>vim.fn</span><span>.</span><span>getline</span><span>(</span><span>line</span><span>),</span> <span>blank_line_pattern</span><span>)</span> <span>end</span>
    <span>while</span> <span>prev_line</span> <span>&gt;</span> <span>0</span> <span>and</span> <span>(</span><span>prev_blank_line</span><span>(</span><span>prev_line</span><span>)</span> <span>or</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>prev_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span><span>)</span> <span>do</span>
        <span>vim.cmd</span><span>(</span><span>&#39;-&#39;</span><span>)</span>
        <span>prev_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>-</span> <span>1</span>
    <span>end</span>
    <span>if</span> <span>around</span> <span>then</span>
        <span>vim.cmd</span><span>(</span><span>&#39;-&#39;</span><span>)</span>
    <span>end</span>

    <span>vim.cmd</span><span>(</span><span>&#39;normal! 0V&#39;</span><span>)</span>

    <span>local</span> <span>next_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span>
    <span>local</span> <span>next_blank_line</span> <span>=</span> <span>function</span><span>(</span><span>line</span><span>)</span> <span>return</span> <span>string.match</span><span>(</span><span>vim.fn</span><span>.</span><span>getline</span><span>(</span><span>line</span><span>),</span> <span>blank_line_pattern</span><span>)</span> <span>end</span>
    <span>local</span> <span>last_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;$&#39;</span><span>)</span>
    <span>while</span> <span>next_line</span> <span>&lt;=</span> <span>last_line</span> <span>and</span> <span>(</span><span>next_blank_line</span><span>(</span><span>next_line</span><span>)</span> <span>or</span> <span>vim.fn</span><span>.</span><span>indent</span><span>(</span><span>next_line</span><span>)</span> <span>&gt;=</span> <span>start_indent</span><span>)</span> <span>do</span>
        <span>vim.cmd</span><span>(</span><span>&#39;+&#39;</span><span>)</span>
        <span>next_line</span> <span>=</span> <span>vim.fn</span><span>.</span><span>line</span><span>(</span><span>&#39;.&#39;</span><span>)</span> <span>+</span> <span>1</span>
    <span>end</span>
    <span>if</span> <span>around</span> <span>then</span>
        <span>vim.cmd</span><span>(</span><span>&#39;+&#39;</span><span>)</span>
    <span>end</span>
<span>end</span>
</code></pre></div><p>That’s it! We’ve created a wonderful text-object with the power of our linked spirits. It’s with joy and proud that I dub you Godly Blacksmith of the Text-Object©.</p><h2 id="mapping-a-lua-function">Mapping a Lua Function</h2><p>Till now, we’ve used some Vimscript strings to map our Lua functions to our new text-objects. Neovim 0.7, which came out a couple of days before this article was published, allows us to directly map Lua functions without using any Vimscript.</p><p>You can try to look at <code>:help vim.keymap.set</code> for example to improve our code even further.</p><h2 id="the-power-of-the-text-object">The Power of the Text-Object</h2><p>As always, coming up with new ideas of text-objects depend on your needs. I always prefer solving the pain points I notice when writing in Vim, instead of trying to come up with ideas of improvements out of nothing. For example, I always wanted to have a text-object to manipulate functions; at the same time, I wanted something which could work with most programming languages. Having a text-object based on indentation levels is the best compromise to me.</p><p>So, what did we see in this article?</p><ul><li>When you hit an operator in NORMAL mode, you switch to OPERATOR-PENDING mode. From there, you can give a motion or a text-object to operate on what your want.</li><li>A text-object is only a set of characters which can be acted upon, using operators.</li><li>It’s easy to build basic text-objects thanks to the operator-pending mappings, <code>omap</code> and <code>onoremap</code>.</li><li>It’s easier to write a function when you need more complex text-objects. You can then rely on the rich set of Vimscript functions to move your cursor and select what you want.</li><li>Vimscript is a language with many weird design decisions. I prefer using Lua as soon as my data flow goes on multiple branches.</li></ul><p>Do you want more articles where we use Vimscript and Lua, to improve your customization power in Vim? Don’t hesitate to give your thoughts, feedback, and improvements in the comment section. Like, share, and love.</p></section></article></div></div>
  </body>
</html>
