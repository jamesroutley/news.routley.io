<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.jakubkonka.com/2022/03/16/hcs-zig.html">Original</a>
    <h1>Hot-code reloading on macOS/arm64 with Zig</h1>
    
    <div id="readability-page-1" class="page"><div id="post">
  

<p>Hot-code reloading, or hot-code swapping, is the ability of the compiler to allow you, the developer, to make
changes to your program appear instantaneously while the program is already running. Typically, compilers
utilise the idea of dynamic library hot swapping (for native targets such as macOS) where your program (logic) is
compiled and linked down to a dynamic library (shared object) which is then managed and reloaded by
a small loader program running side-by-side <sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup>. Note that both programs, the dynamic library and the loader,
do not share the same address space.</p>

<p>In Zig <sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>, we would like to try something else. Instead of having your program managed by a running side-by-side
loader program, what if the compiler would “simply” update the memory of the running process? You will most
inevitably think I have gone completely crazy, which given the current state of global affairs is not unthinkable,
but hear me out.</p>

<p>Here’s my claim. We can pull it off using the self-hosted Zig compiler (also known as <em>stage2</em> compiler). We can pull
it off on Linux <sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> and macOS (Windows coming soon TM), and here’s how. The self-hosted Zig compiler is a
little bit special since it couples very tighly with our in-house linker <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>. This gives it special powers which
effectively mean we can completely bypass the idea of creating relocatable object files for Zig modules in favour
of writing the already-relocated declarations/symbols directly into the final binary. I will refer to this concept
as incremental compilation but some prefer to call it in-place binary patching, or incremental linking.
Either way, the point is, the compiler does not generate any intermediate relocatable object files.</p>

<h3 id="from-incremental-compilation">From incremental compilation…</h3>

<p>Hmm, OK, Jakub, whatever you mean. How about an example to illustrate what you mean? Sure thing, just one more
sentence of explanation before we dive into the problem of incremental compilation. The granularity at which the compiler
works is scoped down to single declaration, aka <em>decl</em> or simply <em>symbol</em>, which is then incrementally allocated space
in the virtual memory and a file offset, and written to the binary file (there’s a couple more things that actually happen here
such as resolving relocations, if any, but you get the point). This allows us to update only those symbols that
actually changed in an incremental fashion.</p>

<p>OK, example time! Consider the following Zig code</p>

<div><div><pre><code><span>// example.zig</span>

<span>pub</span> <span>fn</span> <span>main</span><span>()</span> <span>void</span> <span>{</span>
    <span>var</span> <span>x</span><span>:</span> <span>u32</span> <span>=</span> <span>1</span><span>;</span>
    <span>_</span> <span>=</span> <span>bar</span><span>();</span> <span>// This is so that we force the compiler to generate bar before addToBar in the address space.</span>
    <span>const</span> <span>y</span> <span>=</span> <span>addToBar</span><span>(</span><span>x</span><span>);</span>
    <span>assert</span><span>(</span><span>y</span> <span>==</span> <span>11</span><span>);</span>
<span>}</span>

<span>fn</span> <span>addToBar</span><span>(</span><span>x</span><span>:</span> <span>u32</span><span>)</span> <span>u32</span> <span>{</span>
    <span>const</span> <span>y</span> <span>=</span> <span>bar</span><span>();</span>
    <span>return</span> <span>x</span> <span>+</span> <span>y</span><span>;</span>
<span>}</span>

<span>fn</span> <span>bar</span><span>()</span> <span>u32</span> <span>{</span>
    <span>return</span> <span>10</span><span>;</span>
<span>}</span>

<span>fn</span> <span>assert</span><span>(</span><span>ok</span><span>:</span> <span>bool</span><span>)</span> <span>void</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>ok</span><span>)</span> <span>unreachable</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>In order to put Zig into incremental compilation mode, we will use a special flag <code>--watch</code> like so</p>

<div><div><pre><code><span>$</span><span> </span>zig build-exe example.zig <span>--watch</span>
<span>(zig) 
</span></code></pre></div></div>

<p>By this point, the compiler created a fully functional binary that we can run from disk. However, since
<code>--watch</code> flag puts the compiler in the REPL mode, we can update-and-run directly from the REPL loop</p>

<div><div><pre><code><span>(zig) update-and-run
(zig)
</span></code></pre></div></div>

<p>In this case, no output is good news as this means we didn’t hit the assert. Let’s tweak the assert
to something false though just to test that everything is working as expected</p>

<div><div><pre><code><span>// ...</span>
<span>assert</span><span>(</span><span>y</span> <span>==</span> <span>12</span><span>);</span>
<span>// ...</span>
</code></pre></div></div>

<p>and then retry update-and-run in the REPL</p>

<div><div><pre><code><span>(zig) update-and-run
warning: process aborted abnormally
(zig) 
</span></code></pre></div></div>

<p>Hmm, right, so assertion was correctly triggered in this case, and the compiler reported that the binary
did not exit cleanly, just as we expected.</p>

<p>OK, but how any of this lend itself towards hot-code reloading in Zig? Right, let’s do another tweak to the
source where we change the definition of <code>bar</code> to something longer so that the linker will be forced to move
the symbol to a new location in the file and virtual memory</p>

<div><div><pre><code><span>fn</span> <span>bar</span><span>()</span> <span>u32</span> <span>{</span>
    <span>assert</span><span>(</span><span>true</span><span>);</span>
    <span>assert</span><span>(</span><span>true</span><span>);</span>
    <span>assert</span><span>(</span><span>true</span><span>);</span>
    <span>assert</span><span>(</span><span>true</span><span>);</span>
    <span>return</span> <span>10</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>Let’s update-and-run</p>

<div><div><pre><code><span>(zig) update-and-run
(zig)
</span></code></pre></div></div>

<p>So far so good. If we now analyse the before and after of the update-and-run step, we will note that <code>bar</code> was moved
from its initial address in virtual memory of <code>0x1000010c0</code> to <code>0x100001178</code> since it grew too big to be accomodated
in its original place. I will stop here for a second and pull up a “printout” from a debugging tool <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup> I wrote to
aid in visualising changes to the binary between incremental updates</p>

<p><img src="http://www.jakubkonka.com/images/hcs/example_bar_moved.png" alt="bar-moved"/></p>

<p>There are two columns in the picture: the left hand side depicts the contents of the virtual memory before the next
incremental update, and the right hand side depicts the contents after the incremental update. I have purposefully
highlighted the symbol <code>bar</code> which, as predicted, has been moved in memory from <code>0x1000010c0</code> to <code>0x100001178</code>
since it grew too big to fit its current placeholder (<em>NB Zig’s incremental MachO linker does insert some
padding between symbols so that they can grow without necessitating the move, however in this case, we purposefully
grew the contents of <code>bar</code> enough to trigger the move and reallocation in virtual memory</em>).</p>

<p>But what about any caller of <code>bar</code>? Did any symbol calling <code>bar</code> need a full rewrite? The short answer is no. Why,
you ask? Let’s pull up another view of the changes to the virtual memory contents of the file between updates, and
in particular, let us zoom in on <code>addToBar</code></p>

<p><img src="http://www.jakubkonka.com/images/hcs/example_addtobar_unchanged.png" alt="addtobar-unchanged"/></p>

<p>The contents of the highlighted <code>addToBar</code> depicts any relocation to any other symbol within the binary image.
Note that <code>addToBar</code> doesn’t make a direct reference to <code>bar</code>; instead, it references a mysterious cell in the
global offset table (GOT) denoted here as section <code>__DATA_CONST,__got</code>. The cell is located at an address <code>0x100054028</code>.
Let’s pull up its contents in both views</p>

<p><img src="http://www.jakubkonka.com/images/hcs/example_bar_got_cell.png" alt="bar-got-cell"/></p>

<p>Note that both cells in both views still point to <code>bar</code> <strong>but</strong> the cell on the left hand side points to <code>bar</code>
at its original address of <code>0x1000010c0</code>, while the cell on the right hand side to its new address after the move,
<code>0x100001178</code>. In other words, in order to preserve the integrity of the calls, all the linker had to tweak
was to update the target address of <code>bar</code> in its GOT cell. There was no need to touch any other symbol which
called <code>bar</code> as every reference to it is done via the GOT table. This mechanism lends itself really well
to hot-code reloading as it minimises the number of changes the linker has to do to the binary, and it will
be the cornerstone for our hot-code reloading solution. Let’s get right to it then!</p>

<h3 id="to-hot-code-reloading">…to hot-code reloading…</h3>

<p>Before we go on, I will point out that in the rest of this post, I will mainly focus on Mach and macOS specific
bits to get the ball rolling with respect to hot-code reloading with the Zig compiler. One additional bit 
required to actually get it all pieced together into a working solution is to roll out some mechanism for communicating
with the compiler while in the hot-code reloading mode as communicating via stdio will be unavailable as we will be
piping the output of the hot-code reloaded child process (our binary) via the compiler. Therefore, one could for
instance communicate via a socket, and this is precisely how both Andrew Kelley <sup id="fnref:3:1" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> has done in his Linux proof-of-concept
and I have done in my macOS proof-of-concept. Anyhow, in what follows, I will assume we already have the necessary infrastructure
to do this.</p>

<blockquote>
  <p>I should also mention that if you would like to browse, and more importantly, play with a working
version of the Zig compiler with hot-code reloading enabled on macOS, you can find the relevant source code
in <code>hcs-macos</code> branch in the main Zig’s repo on GitHub <sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup>.</p>
</blockquote>

<p>First things first, we need to turn off address space layout randomisation (ASLR) for the child process (<em>NB this is
actually not true, and we can successfully perform hot-code reloading with ASLR on. If you’re interested in this
bit, scroll down to the next section</em>). On macOS, to do this from the user space, we need to utilise the <code>posix_spawn</code>
family of functions for spawning and executing a child process. In particular, we are interested in this function</p>

<div><div><pre><code><span>int</span>
<span>posix_spawnp</span><span>(</span><span>pid_t</span> <span>*</span><span>restrict</span><span>,</span> <span>const</span> <span>char</span> <span>*</span><span>restrict</span> <span>file</span><span>,</span> <span>const</span> <span>posix_spawn_file_actions_t</span> <span>*</span><span>file_actions</span><span>,</span>
             <span>const</span> <span>posix_spawnattr_t</span> <span>*</span><span>restrict</span> <span>attrp</span><span>,</span> <span>char</span> <span>*</span><span>const</span> <span>argv</span><span>[</span><span>restrict</span><span>],</span> <span>char</span> <span>*</span><span>const</span> <span>envp</span><span>[</span><span>restrict</span><span>]);</span>
</code></pre></div></div>

<p>In order to request ASLR off from the OS, we need to pass an attribute object <code>posix_spawnattr_t</code>  with
flags containing <code>_POSIX_SPAWN_DISABLE_ASLR = 0x100</code>. In Zig, I have made sure there are nice wrappers for
this, so all we need to do is</p>
<div><div><pre><code><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span>
<span>const</span> <span>darwin</span> <span>=</span> <span>std</span><span>.</span><span>os</span><span>.</span><span>darwin</span><span>;</span>
<span>const</span> <span>posix_spawn</span> <span>=</span> <span>std</span><span>.</span><span>os</span><span>.</span><span>posix_spawn</span><span>;</span>

<span>// ...</span>

<span>var</span> <span>attr</span> <span>=</span> <span>try</span> <span>posix_spawn</span><span>.</span><span>Attr</span><span>.</span><span>init</span><span>();</span>
<span>defer</span> <span>attr</span><span>.</span><span>deinit</span><span>();</span>
<span>const</span> <span>flags</span><span>:</span> <span>u16</span> <span>=</span> <span>darwin</span><span>.</span><span>POSIX_SPAWN_SETSIGDEF</span> <span>|</span> <span>darwin</span><span>.</span><span>POSIX_SPAWN_SETSIGMASK</span> <span>|</span> <span>darwin</span><span>.</span><span>_POSIX_SPAWN_DISABLE_ASLR</span><span>;</span>
<span>try</span> <span>attr</span><span>.</span><span>set</span><span>(</span><span>flags</span><span>);</span>

<span>const</span> <span>pid</span> <span>=</span> <span>try</span> <span>posix_spawnp</span><span>(</span><span>exe_path</span><span>,</span> <span>null</span><span>,</span> <span>attr</span><span>,</span> <span>null</span><span>,</span> <span>null</span><span>);</span>
</code></pre></div></div>

<p>(<em>NB actually, since a few days ago, you don’t even need to use the <code>posix_spawn</code>
primitives at all, as spawning a child process on macOS will by default use this mechanism for you.</em>)</p>

<p>And that’s it, the child process will now be put at its static addressing (if possible of course).</p>

<p>Having spawned the process and obtained its PID, we can now use it to open a Mach port to the child process
which we can then use to update the child process’ memory, inquire about the base address where it was mapped to, etc.
In order to open the Mach port, we need to use this Mach kernel function</p>

<div><div><pre><code><span>kern_return_t</span>
<span>task_for_pid</span><span>(</span><span>mach_port_name_t</span> <span>target_tport</span><span>,</span> <span>pid_t</span> <span>pid</span><span>,</span> <span>mach_port_name_t</span> <span>*</span><span>t</span><span>);</span>
</code></pre></div></div>

<p>The first argument is the Mach port handle for the parent process, and it can be obtained via an extern global variable</p>

<div><div><pre><code><span>extern</span> <span>mach_port_t</span> <span>mach_task_self_</span><span>;</span>
</code></pre></div></div>

<p>the middle argument is the PID of the spawned child process, and the final argument is the receiver for the handle
to the opened Mach port. There is one caveat to using this (very) low-level API: it requires elevated privileges. This
is fine for the purposes of our proof-of-concept but definitely a no-go for production use of hot-code reloading mode.
One way of overcoming this, although please note I haven’t done a lot of investigation on it yet, is to bake in
the necessary entitlements into the compiler binary itself <sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup>. To the best of my knowledge, this is how LLVM’s
<code>lldb</code> does it too. On the topic of debuggers, I am not sure if you noticed yet, but the hot-code reloading approach
I describe here is a close cousin of how debuggers work, and if you are curious about how different bits come together,
I invite you to study <code>lldb</code>’s source code which is openly available <sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">8</a></sup>.</p>

<p>As with <code>posix_spawn</code>, I have created a couple of wrappers around Mach ports, and so the above process boils down to</p>

<div><div><pre><code><span>const</span> <span>std</span> <span>=</span> <span>@import</span><span>(</span><span>&#34;std&#34;</span><span>);</span>
<span>const</span> <span>darwin</span> <span>=</span> <span>std</span><span>.</span><span>os</span><span>.</span><span>darwin</span><span>;</span>

<span>var</span> <span>task</span> <span>=</span> <span>try</span> <span>darwin</span><span>.</span><span>machTaskForPid</span><span>(</span><span>pid</span><span>);</span>
</code></pre></div></div>

<p>Having obtained a handle to the Mach port for communicating with the child process, we can now turn to
where the actual magic is happening: the linker. Whenever the linker is requested to perform in-place binary
patching as we analysed in the first section of this blog post, while writing the updated symbol to file, we
use the obtained Mach port to at the same time write the updated contents directly to mapped memory of the running
process. We need to be careful though, as writing to the executable segment will generally fail unless we purposefully
change the current protection attributes of the segment. Thus, the approach is as follows:</p>

<blockquote>
  <p>check if the segment is writable</p>
</blockquote>

<blockquote>
  <p>if yes, simply write to it an offset</p>
</blockquote>

<blockquote>
  <p>if not</p>
</blockquote>

<blockquote>
  <blockquote>
    <p>temporarily set the protection attributes to allow writing to it</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>write to the segment at an offset</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>reset the protection attributes to their original level</p>
  </blockquote>
</blockquote>

<p>Since we control the linker, we do not have to actively check if the segment is writable as we control its
protection attributes. In order to change the mapped segment’s attributes, we need to use the kernel function</p>

<div><div><pre><code><span>kern_return_t</span>
<span>mach_vm_protect</span><span>(</span><span>vm_map_t</span> <span>target_task</span><span>,</span> <span>mach_vm_address_t</span> <span>address</span><span>,</span> <span>mach_vm_size_t</span> <span>size</span><span>,</span> 
                <span>boolean_t</span> <span>set_maximum</span><span>,</span> <span>vm_prot_t</span> <span>new_protection</span><span>);</span>
</code></pre></div></div>

<p>As before, Zig features nice abstraction for this, so this can be done as follows using the obtained <code>task</code> via
<code>machTaskForPid(pid: pid_t) MachError!MachTask</code></p>

<div><div><pre><code><span>try</span> <span>task</span><span>.</span><span>setCurrProtection</span><span>(</span><span>addr</span><span>,</span> <span>len</span><span>,</span> <span>std</span><span>.</span><span>c</span><span>.</span><span>PROT</span><span>.</span><span>READ</span> <span>|</span> <span>std</span><span>.</span><span>c</span><span>.</span><span>PROT</span><span>.</span><span>WRITE</span> <span>|</span> <span>std</span><span>.</span><span>c</span><span>.</span><span>PROT</span><span>.</span><span>COPY</span><span>);</span>
</code></pre></div></div>

<p>Notice the funky looking protection flag <code>std.c.PROT.COPY = @as(vm_prot_t, 0x10)</code> which is defined as <code>VM_PROT_COPY</code>
in Apple’s libc. According to the definition, this flag can be used to force request write permissions on a mapped
entry. Setting this flag marks the mapped entry as “needing copy” and effectively copying the object using copy-on-write
mechanics, and adding <code>VM_PROT_WRITE</code> permission to the maximum protections for the associated entry (<em>NB an apt reader
might wonder why bother with updating the protection if we control the linker and can set the segment’s initial
and maximum protection attributes to be writable. Well, as it turns out, on arm64 macOS, the <code>VM_PROT_WRITE</code> protection
permission is not respected for the executable segment, therefore, there is no other way of achieving this than with
the use of <code>VM_PROT_COPY</code> flag.</em>).</p>

<p>Writing into a mapped memory region is fairly straightforward, and can be achieved with the following kernel
function</p>

<div><div><pre><code><span>kern_return_t</span>
<span>mach_vm_write</span><span>(</span><span>vm_map_t</span> <span>target_task</span><span>,</span> <span>mach_vm_address_t</span> <span>address</span><span>,</span> <span>vm_offset_t</span> <span>data</span><span>,</span> <span>mach_msg_type_number_t</span> <span>data_cnt</span><span>);</span>
</code></pre></div></div>

<p>In Zig, this becomes</p>

<div><div><pre><code><span>const</span> <span>nwritten</span> <span>=</span> <span>try</span> <span>task</span><span>.</span><span>writeMem</span><span>(</span><span>addr</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>);</span>
</code></pre></div></div>

<p>Putting it all together, we got a routine that looks more or less like this</p>

<div><div><pre><code><span>const</span> <span>sym</span><span>:</span> <span>nlist_64</span> <span>=</span> <span>//...</span>
<span>var</span> <span>buf</span><span>:</span> <span>[</span><span>LEN</span><span>]</span><span>u8</span> <span>=</span> <span>//...</span>

<span>if</span> <span>(</span><span>!</span><span>seg</span><span>.</span><span>isWriteable</span><span>())</span> <span>{</span>
    <span>try</span> <span>task</span><span>.</span><span>setCurrProtection</span><span>(</span><span>sym</span><span>.</span><span>n_value</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>);</span>
<span>}</span>
<span>defer</span> <span>if</span> <span>(</span><span>!</span><span>seg</span><span>.</span><span>isWriteable</span><span>())</span> <span>{</span>
    <span>task</span><span>.</span><span>setCurrProtection</span><span>(</span><span>sym</span><span>.</span><span>n_value</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>)</span> <span>catch</span> <span>{};</span>
<span>}</span>
<span>// Here, we would resolve relocations (if any)</span>
<span>try</span> <span>resolveRelocs</span><span>(</span><span>sym</span><span>.</span><span>n_value</span><span>);</span>
<span>const</span> <span>nwritten</span> <span>=</span> <span>try</span> <span>task</span><span>.</span><span>writeMem</span><span>(</span><span>sym</span><span>.</span><span>n_value</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>);</span>
</code></pre></div></div>

<p>That’s pretty much it!</p>

<p>Now here’s an exciting bonus question: can this be done without disabling ASLR? The answer is yes!</p>

<h3 id="with-aslr-on">…with ASLR on!</h3>

<p>I mean, if the debuggers can do it, so can we, right? With the ASLR back in the picture, we need to issue an additional
kernel call to inquire about the base address for the mapped binary image. To do this, we need the following function</p>

<div><div><pre><code><span>kern_return_t</span>
<span>mach_vm_region_recurse</span><span>(</span><span>vm_map_t</span> <span>target_task</span><span>,</span> <span>mach_vm_address_t</span> <span>*</span><span>address</span><span>,</span> <span>mach_vm_size_t</span> <span>*</span><span>size</span><span>,</span>
                       <span>natural_t</span> <span>*</span><span>nesting_depth</span><span>,</span> <span>vm_region_recurse_info_t</span> <span>info</span><span>,</span> <span>mach_msg_type_number_t</span> <span>*</span><span>info_cnt</span><span>);</span>
</code></pre></div></div>

<p>Note that the variable <code>address</code> is passed by pointer. This is because after the call completes, <code>address</code> will receive
the value of the base address for the mapped image. We will then use this value to calculate the required slide
value for each non-PC-relative relocation. In other words, with this we are effectively turning our linker into
a dynamic linker!</p>

<p>Taking our snippet from above, we will end up with something like this</p>

<div><div><pre><code><span>const</span> <span>pagezero_vmsize</span><span>:</span> <span>u64</span> <span>=</span> <span>0x100000000</span><span>;</span>
<span>const</span> <span>sym</span><span>:</span> <span>nlist_64</span> <span>=</span> <span>//...</span>
<span>var</span> <span>buf</span><span>:</span> <span>[</span><span>LEN</span><span>]</span><span>u8</span> <span>=</span> <span>//...</span>

<span>const</span> <span>slide</span><span>:</span> <span>u64</span> <span>=</span> <span>slide</span><span>:</span> <span>{</span>
    <span>const</span> <span>info</span> <span>=</span> <span>try</span> <span>task</span><span>.</span><span>getRegionSubmapInfo</span><span>(</span><span>sym</span><span>.</span><span>n_value</span><span>,</span> <span>buf</span><span>.</span><span>len</span><span>,</span> <span>0</span><span>,</span> <span>.</span><span>short</span><span>);</span>
    <span>const</span> <span>slide</span> <span>=</span> <span>info</span><span>.</span><span>base_addr</span> <span>-</span> <span>pagezero_vmsize</span><span>;</span>
    <span>break</span> <span>:</span><span>slide</span> <span>slide</span><span>;</span>
<span>};</span>
<span>if</span> <span>(</span><span>!</span><span>seg</span><span>.</span><span>isWriteable</span><span>())</span> <span>{</span>
    <span>try</span> <span>task</span><span>.</span><span>setCurrProtection</span><span>(</span><span>sym</span><span>.</span><span>n_value</span> <span>+</span> <span>slide</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>);</span>
<span>}</span>
<span>defer</span> <span>if</span> <span>(</span><span>!</span><span>seg</span><span>.</span><span>isWriteable</span><span>())</span> <span>{</span>
    <span>task</span><span>.</span><span>setCurrProtection</span><span>(</span><span>sym</span><span>.</span><span>n_value</span> <span>+</span> <span>slide</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>)</span> <span>catch</span> <span>{};</span>
<span>}</span>
<span>// Here, we would resolve relocations (if any)</span>
<span>// For any non-PC-relative pointer value, resolve and slide</span>
<span>try</span> <span>resolveRelocs</span><span>(</span><span>sym</span><span>.</span><span>n_value</span><span>,</span> <span>slide</span><span>);</span>
<span>const</span> <span>nwritten</span> <span>=</span> <span>try</span> <span>task</span><span>.</span><span>writeMem</span><span>(</span><span>sym</span><span>.</span><span>n_value</span> <span>+</span> <span>slide</span><span>,</span> <span>&amp;</span><span>buf</span><span>,</span> <span>.</span><span>aarch64</span><span>);</span>
</code></pre></div></div>

<p>Note that we subtract the size of <code>__PAGEZERO</code> segment from the returned base address to get the slide value. Then,
for any relocation that is non-PC-relative and is a pointer, we relocate the pointer value and add the slide value.
This is equivalent to what <code>dyld</code> would do for all rebase opcodes encoded as part of the “rebase info” subsection of
<code>LC_DYLD_INFO_ONLY</code> load command.</p>

<h3 id="demo">Demo!</h3>

<video width="100%" controls="">
  <source src="/images/hcs/hotcode-arm64.mov" type="video/mp4"/>
</video>

<p><em>Demo captured on M1 MacBook Air, macOS 12.2.1, latest Zig self-hosted compiler with patch from <code>hcs-macos</code> branch.</em> <sup id="fnref:6:1" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup></p>

<h3 id="references">References</h3>



</div></div>
  </body>
</html>
