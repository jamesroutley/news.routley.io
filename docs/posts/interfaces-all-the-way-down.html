<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jjain.substack.com/p/interfaces-all-the-way-down">Original</a>
    <h1>Interfaces all the way down</h1>
    
    <div id="readability-page-1" class="page"><div><div><article><div class=""><div><div dir="auto"><p>”If you want to succeed, get extremely good at designing interfaces.” That was the advice I got when I asked my manager at an internship how to move up the ranks from junior to senior to staff engineer. Every other skill, he said, will soon follow. His advice contradicted my idea that a great senior dev should learn better communication or management. When asked why, his reasoning was simple. A junior dev might handle the interface between a few methods of a class—the choice of parameters, their names, and return values. As an engineer moves up the ranks, they become responsible for progressively larger interfaces—entire classes within a service, the API between services, the public facing API, and even widely distributed SDKs. High quality interfaces mean people will appreciate your work, approach you for help, and trust you with larger tasks. </p><p><span>I’ve since doubled down on perfecting the craft of interface design, and, as a result, a plethora of related code cleanliness principles appeared. A different mentor of mine recommended I read </span><em>A Philosophy of Software Design</em><span> by John Ousterhout. In researching the book, I came across a talk Ousterhout gave at Google about this philosophy:</span></p><div id="youtube2-bmSAYlu0NcY" data-attrs="{&#34;videoId&#34;:&#34;bmSAYlu0NcY&#34;,&#34;startTime&#34;:null,&#34;endTime&#34;:null}" data-component-name="Youtube2ToDOM"><p><iframe src="https://www.youtube-nocookie.com/embed/bmSAYlu0NcY?rel=0&amp;autoplay=0&amp;showinfo=0&amp;enablejsapi=0" frameborder="0" loading="lazy" gesture="media" allow="autoplay; fullscreen" allowautoplay="true" allowfullscreen="true" width="728" height="409"></iframe></p></div><p>He claims the most important concept in all of computer science is problem decomposition—breaking down a complex task into pieces that can be built relatively independently. Maintaining independence between components can be a monumental task, if the interfaces between them are poorly constructed. Dependencies begin to stretch across boundaries between components, building tech debt. Eventually, developer velocity slows to a crawl as the system loses its modularity.</p><p><span>Designing the best interface is a challenging and sometimes impossible task in a world of ever-changing requirements. However, spending just a few extra minutes can get you most of the way there without significantly slowing down your productivity. Often I’ll start by asking myself a few questions to ensure I create a robust interface. </span><em>What other parts of the system rely on this component? How might this change over time as the project grows? How can I unit test this independently? How can I change the internals of the component without affecting other parts of the codebase? </em><span>These questions can be a great litmus test for robustness, but they don’t offer the entire suite of benefits a well-designed interface can provide.</span></p><p><span>The best interfaces will take into account its most important end users: other developers. And since these developers are human (for now), we can draw inspiration from traditional design fields to learn how to best suit their behaviors. I have much to learn in this field, but I’ve found Don Norman’s </span><em>The Design of Everyday Things </em><span>to be great start. Norman covers many aspects of human-centered design in his book, but most examples tie into his major design principles: discoverability, affordances, signifiers, constraints, mappings, feedback, and conceptual models. In the context of software development, these principles have very real applications.</span></p><div><figure><a target="_blank" href="https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png" data-component-name="Image2ToDOM" rel="nofollow ugc noopener"><div><picture><source type="image/webp" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 1456w" sizes="100vw"/><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png" width="912" height="548" data-attrs="{&#34;src&#34;:&#34;https://substack-post-media.s3.amazonaws.com/public/images/50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png&#34;,&#34;fullscreen&#34;:null,&#34;imageSize&#34;:null,&#34;height&#34;:548,&#34;width&#34;:912,&#34;resizeWidth&#34;:null,&#34;bytes&#34;:129650,&#34;alt&#34;:null,&#34;title&#34;:null,&#34;type&#34;:&#34;image/png&#34;,&#34;href&#34;:null,&#34;belowTheFold&#34;:false,&#34;topImage&#34;:true,&#34;internalRedirect&#34;:null}" alt="" srcset="https://substackcdn.com/image/fetch/w_424,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 424w, https://substackcdn.com/image/fetch/w_848,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 848w, https://substackcdn.com/image/fetch/w_1272,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 1272w, https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F50cdb57b-fb08-4aaf-a11e-cf3ff92da9df_912x548.png 1456w" sizes="100vw" fetchpriority="high"/></picture></div></a></figure></div><p>Think about what happens every time the developer hits the “.” after an object name and the IDE suggests possible autocompletions (shown above). The method names, signatures, and docstrings all influence the conceptual model formed in a user’s mind. Great product designs require no manual, and similarly, great interfaces need no documentation. Imagine having to read a manual on how to use a coffee mug.</p><p>All in all, interface design is closely tied to countless other programming principles like information hiding and abstraction. Still, I’ve found that extensive care in crafting interfaces allows the software to “write itself.” Once you’ve outlined the basic structure for a part of your system, all that’s left is to string together the lines of code that implement its functionality—a mindless task for many veteran programmers.</p><p><span>p.s. I’ve created a new project that lets you write stories with strangers, I’d love if you checked it out: </span><a href="https://strand.jinay.dev/" rel="nofollow ugc noopener">strand.jinay.dev</a></p></div></div></div></article></div></div></div>
  </body>
</html>
