<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thevaluable.dev/complexity_metrics_application/">Original</a>
    <h1>Measuring Software Complexity at the Command Line</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><section><picture>
<source srcset="https://thevaluable.dev/images/2022/complexity_metrics_application/measure_to_answer_questions.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/complexity_metrics_application/measure_to_answer_questions.jpg" alt="Should we rebuild everything too complex?"/></picture><p>This is the third article of my series about complexity metrics:</p><p>I began a new job last January. New job means new colleagues, new offices, new business domain, and new codebases.</p><p>It wasn’t the first time I changed job. It’s quite common for developers nowadays to jump from company to company. But it doesn’t change the fact that, in these situations, we need to adapt to basically everything. It’s quite tiring; that’s why having some process to overcome this period more easily is always welcome.</p><p>To get a quick overview of a new codebase, I like to use simple metrics we’ve already seen in this series of article. They can give us some assumptions about the complexity of the codebase, what developer seems to have some knowledge about it, and the general mood of the project.</p><p>It also allows us to see quickly how honest the developers were during the job interview, and to see if they have an accurate view of their own systems.</p><p>First, it’s useful to come up with questions which could be partially answered by some metrics. As I was saying in the <a href="https://thevaluable.dev/complexity-metrics-software/" target="_blank" rel="noopener">first article of this series</a>, if there is no question, there is nothing to answer; so there is no need to measure.</p><p>In this article, I’ll show this process using two open source projects:</p><ul><li><a href="https://github.com/Phantas0s/devdash" target="_blank" rel="noopener">DevDash</a></li><li><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">Kubernetes</a></li></ul><p>For each project, we’ll measure:</p><ul><li>How long the project has been around.</li><li>The development activity per year.</li><li>Who could answer our questions.</li><li>How big the project is (in terms of lines of code).</li><li>The aggregation of churn and a complexity metric to uncover the hotspots of complexity.</li><li>The Git comments, to get the general mood of the project, and to see what are the most important domain concepts.</li></ul><p>We’ll use some basic GNU command line tools to measure all these points.</p><p>Our goal is to get some useful assumptions about the codebase; they’re not absolute truths. We can then use our experience and our intuition to dig deeper, by looking at the code itself.</p><p>It’s useful to write a summary of these assumptions somewhere, to keep the ideas at hand when we have to modify the new codebase. The sections “In a Nutshell” would be these summaries.</p><p>With all these important points out of the way, let’s begin the analysis.</p><h2 id="analyzing-devdash">Analyzing Devdash</h2><p>First, we’ll look at the open source project <a href="https://github.com/Phantas0s/devdash" target="_blank" rel="noopener">Devdash</a>. I would recommend you to follow along by cloning the project and running all the commands you’ll see in this article. Even better: you can come up with your own questions and try to modify the different commands to answer them.</p><p>Also, don’t hesitate to share what you’ve found useful to measure in the comment section.</p><p>To get the results you’ll see in this article, you’ll need to rewind your Git history to match the time period when these measures were done. For that, you can run the following command at the root of the project:</p><div><pre><code data-lang="sh">git checkout <span>$(</span>git rev-list -n <span>1</span> --before<span>=</span><span>&#34;2022-04-21&#34;</span> master<span>)</span><span>`</span>
</code></pre></div><h3 id="code-ageism-how-old-is-devdash">Code Ageism: How Old is Devdash?</h3><p>Looking at the age of the entire codebase is a good introduction to its possible complexity. So let’s ask our first question: how old is the codebase?</p><p>Let’s print the first and last commit using Git’s history:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span><span>&#34;format:%cd %h %s&#34;</span>  --date<span>=</span>short --reverse <span>\
</span><span></span>    <span>|</span> awk <span>&#39;NR == 1 {print} END {print}&#39;</span>
</code></pre></div><p>First, we get Git’s logs with the following information:</p><ul><li><code>%cd</code> - Committer date.</li><li><code>%h</code> - Short commit hash.</li><li><code>%s</code> - Subject (first 50 characters of a commit message).</li></ul><p>We use GNU awk here to filter the logs, only printing the first and last one. A line is a “record” in awk terminology; printing the record when the Number of Record is equals to one prints the first line. I’ve written an <a href="https://themouseless.dev/posts/awk-guide-examples-mouseless/" target="_blank" rel="noopener">introductory article about awk</a> if you want to know more about this fantastic tool.</p><p>Here’s the result:</p><div><pre><code data-lang="text">2018-08-06 c176d6b [master] First commit
2021-10-26 d8b871c Merge branch &#39;master&#39; of github.com:Phantas0s/devdash
</code></pre></div><p>We can already come up with a couple of assumptions here:</p><p>The first comment “First commit” seems to indicate that we have indeed all the commits for the project. Some (old) projects switch VCS (Version Control System) during development, sometimes losing all the commits created beforehand. If we mine the Git commits to find some answers, it’s important to know if we have access to all of them.</p><p>Second, Devdash is not around for a long time: a bit more than 4 years at the time this article was written. It’s not a green field project, but I wouldn’t expect much complexity either. If further analysis prove the contrary, asking questions related to the history of the project can give us more useful information.</p><p>Third, the project didn’t change much, lately. We could think of two different explanations:</p><ol><li>It’s abandoned.</li><li>It’s stable enough and it answers most needs for now.</li></ol><p>If it’s abandoned, we can ask ourselves if the system is still used, or even if it still works. If it’s stable enough, it might be the sign of a healthy project, maybe maintained by individual(s) (or a company) who knows when to stop implementing features.</p><p>All in all, since the project wasn’t modified for a while, dependencies might be out of date. If it’s the case, they should be updated as soon as possible, or it could lead to security problems. The more we wait for updating dependencies, the more difficult it is to update them safely, without breaking parts of the codebase.</p><p>For example, I remember a project which used a version of a framework released more than 10 years ago. Nobody took the time to bump it to the next version. When you’re relying on a framework deprecated for a decade, it’s unlikely to update it without rewriting most of your application.</p><p>Security holes are no joke.</p><h3 id="number-of-commits-overtime">Number of Commits Overtime</h3><p>We know for how long the project is around, but we don’t know the activity on the project itself. So let’s ask the following question: when was the project mostly implemented? It’s likely that bugs and complexity were introduced during the most active periods.</p><p>Let’s run the following to get the count of commits per year:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span><span>&#34;format:%ad %h %s&#34;</span> --date<span>=</span>short --reverse <span>\
</span><span></span>    <span>|</span> awk <span>&#39;{print $1}&#39;</span> <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{FS=&#34;-&#34;} {print $1}&#39;</span> <span>\
</span><span></span>    <span>|</span> sort -n <span>\
</span><span></span>    <span>|</span> uniq -c <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{print &#34;commits&#34;,&#34;year&#34;} {print}&#39;</span>
</code></pre></div><p>We use awk here again, first to get the date of each commit, then to get the year only, and finally to add some headers to the output.</p><p>If you want to output a CSV instead, to edit it in a spreadsheet editor for example, you can use the CLI sed to delete the indentation. Then, we use the command tr to replace the spaces with comma:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span><span>&#34;format:%ad %h %s&#34;</span> --date<span>=</span>short --reverse <span>\
</span><span></span>    <span>|</span> awk <span>&#39;{print $1}&#39;</span> <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{FS=&#34;-&#34;} {print $1}&#39;</span> <span>\
</span><span></span>    <span>|</span> sort -n <span>\
</span><span></span>    <span>|</span> uniq -c <span>\
</span><span></span>    <span>|</span> sed <span>&#39;s/^\s*//&#39;</span> <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{print &#34;commits&#34;,&#34;year&#34;} {print}&#39;</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;,&#39;</span>
</code></pre></div><p>Here’s the output:</p><pre><code data-lang="csv">commits,year
18,2018
194,2019
78,2020
52,2021
</code></pre><p>It seems that the developers were most active in 2019 and 2020. These years will be our reference to determine what part of the project changed the most. We could also look at the period from the creation of the project till now, but it might be too much data to analyze. It would work for a project of this size, however.</p><h3 id="asking-questions">Asking Questions</h3><p>When we’ll go more into the details of the project and look at the code, it’s very likely that we’ll have some questions. The best would be to find the developers who were the most involved in the project and ask them directly, if we can.</p><p>Let’s get the number of commits per author with this simple command line:</p><div><pre><code data-lang="sh">git shortlog --after<span>=</span>2018-12-31 --before<span>=</span>2021-01-01 -sn --all
</code></pre></div><p>We limit the results to the time range we’ve defined: between 2019 and 2020. Also, the option <code>-s</code> only display a summary of the count of commits, and <code>-n</code> sort the output by number of commit (instead of ordering alphabetically by author’s name).</p><p>Here’s the result:</p><div><pre><code data-lang="text">   156  Matthieu
    89  matthieu
    32  Matthieu Cneude
</code></pre></div><p>It looks like this “Matthieu” guy is the only developer on the project. Incidentally, he’s also the author of the article you’re reading! What a coincidence.</p><p>So, if you have a question, just ask me.</p><h3 id="project-size-the-lines-of-code">Project Size: The Lines of Code</h3><p>It’s time to look at the complexity of the project, by trying to answer this question: how big the project is, and, therefore, how complex it might be?</p><p>As I’ve already described in the <a href="https://thevaluable.dev/complexity-metrics-software/">very first article in this series</a>, any complexity metric we can get from a snapshot of a codebase is more or less as accurate as counting the project’s lines of code.</p><p>I know what you might think: “Counting lines of code to measure the complexity? Or you crazy, or just dumb? It won’t show anything! And I don’t want developers to write one-liners impossible to understand, just for the codebase to appear less complex!”</p><p>I believe that developers would only try to lower the complexity this way only if the company culture has a good amount of toxicity. Nobody should use the count of line of source code (SLOC) to judge developers, or to have any definitive opinion on anything. The point is to give a direction. Some clues about what’s happening in the codebase, without reading every single file.</p><p>Let’s see how we can use this count of source code useful. First, we need to install a CLI tool which can count SLOC for many languages: <a href="https://github.com/AlDanial/cloc" target="_blank" rel="noopener">cloc</a>.</p><p>Let’s run the following in the root of the project:</p><p>Here’s the result:</p><div><pre><code data-lang="text">github.com/AlDanial/cloc v 1.92  T=0.11 s (714.0 files/s, 133306.2 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Go                              49           1429            298           8499
JSON                            14              0              0           3712
YAML                            11             11              7            461
Markdown                         3             85              0            219
Bourne Shell                     2              5              4             19
-------------------------------------------------------------------------------
SUM:                            79           1530            309          12910
-------------------------------------------------------------------------------
</code></pre></div><p>The first obvious observation: it’s a small Go project. The size is not surprising, since it was developed only by one person in two years.</p><p>What’s more surprising is the cheer amount of JSON and YAML in there. A quick recursive search for JSON files, thanks to the command <code>ls **/*.json</code>, show that they’re mostly fixtures for unit tests. Doing the same for YAML files shows that most of them are in the <code>example</code> folder.</p><p>It seems that Devdash can be configured using YAML in different ways. Looking quickly at the files (<code>cat $(ls **/*.yml)</code>), we can see that the configuration is quite flexible. In my experience, anything flexible bring also a cheer amount of complexity, because there are many use cases the code needs to cover.</p><p>The JSON files are used as fixtures, maybe the responses from some APIs. Request to external APIs are important indicators too, because we don’t control the result we get from them. It’s an external coupling which can bring a lot of communication overhead with the maintainers of the API. In short, and in my experience: it can be painful.</p><h3 id="calculating-churn">Calculating Churn</h3><p>As we saw <a href="https://thevaluable.dev/complexity-metrics-environment/">in the second part of this series of article</a>, it seems that code churn is the best indicator of complexity and possible bugs overtime. It doesn’t measure a snapshot of the codebase anymore, but analyze the codebase overtime.</p><p>Intuitively, it makes sense: when the code change, bugs creep in. It’s not only the code; as we hinted above, if any external dependency (APIs, libraries…) change, it can also introduce bugs.</p><p>So let’s ask: what parts of the codebase change the most? Therefore, what parts of the codebase seem to gather the most complexity?</p><p>In the <a href="https://thevaluable.dev/complexity-metrics-environment/">previous article</a>, I came up with a command which outputs how many times each file changed, aggregated with its size in SLOC. Let’s reuse it for our purposes; I modified it slightly to add the time period of interest for both the Git and the cloc commands.</p><div><pre><code data-lang="sh">awk <span>&#39;{files[$1]=(files[$1]?files[$1]FS$2:$2)} END { for (i in files) print files[i],i }&#39;</span> <span>\
</span><span></span>    <span>=(</span>git log --after<span>=</span>2018-12-31 --before<span>=</span>2021-01-01 --pretty<span>=</span><span>&#39;&#39;</span> --date<span>=</span>short --numstat <span>\
</span><span></span>        <span>|</span> awk <span>&#39;{print $3}&#39;</span> <span>\
</span><span></span>        <span>|</span> sort <span>\
</span><span></span>        <span>|</span> uniq -c <span>\
</span><span></span>        <span>|</span> sort -rn <span>\
</span><span></span>        <span>|</span> awk <span>&#39;{ print &#34;./&#34; $2,$1 }&#39;</span><span>)</span> <span>\
</span><span></span>    <span>=(</span>cloc ./ --by-file --quiet --csv <span>\
</span><span></span>        <span>|</span> awk -F <span>&#39;,&#39;</span> <span>&#39;NR &gt; 2 { print $2,$5 }&#39;</span> <span>\
</span><span></span>        <span>|</span> head -n -1<span>)</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;,&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;/^.*,.*,.*$/!d&#39;</span> <span>\
</span><span></span>    <span>|</span> sort -rg <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{print &#34;CHANGES,LINES,FILENAME&#34;} {print}&#39;</span>
</code></pre></div><p>Here are the first lines of output:</p><pre><code data-lang="csv">CHANGES,LINES,FILENAME
62,86,./README.md
46,436,./internal/ga_widget.go
42,208,./internal/project.go
32,458,./internal/tui.go
22,116,./CHANGELOG.md
20,326,./internal/github_widget.go
</code></pre><p>We have now the most complex files which change the most often. We don’t really care about the markdown files <code>README.md</code> and <code>CHANGELOG.md</code>, but the other files are interesting. It seems that <code>internal/ga_widget.go</code>, <code>internal/project.go</code> and <code>internal/tui.go</code> are the files which changed the most.</p><p>From there, we should make sure that:</p><ul><li>These files are well tested. Do they have some sort of automatic tests?</li><li>These files are understandable for a newcomer. If not, asking questions to the main developer of the project at the time could be useful.</li></ul><p>In short, if we have to modify these files at one point, we should be careful doing so. Monitoring them from time to time can be useful too, to see if the complexity increase. If it does, splitting them to improve their readability could be a good refactoring to do.</p><h3 id="git-comments-mood-and-domain-concepts">Git Comments: Mood and Domain Concepts</h3><p>Let’s ask two more questions to get a first high-level picture of the project:</p><ul><li>What are the most important domain concepts of this project?</li><li>Did the developers spend their time maintaining the project, or adding new functionalities?</li></ul><p>We can look at the different Git comments to begin to answer these questions. The following command is also from the <a href="https://thevaluable.dev/complexity-metrics-environment/">previous article of this series</a>:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span>format:<span>&#39;%s&#39;</span> --after<span>=</span>2018-12-31 --before<span>=</span>2021-01-01 --after<span>=</span>2018-12-31 --before<span>=</span>2021-01-01 <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;\n&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;s/.*/\L&amp;/&#39;</span> <span>\
</span><span></span>    <span>|</span> sort <span>\
</span><span></span>    <span>|</span> uniq -c <span>\
</span><span></span>    <span>|</span> sort -rg <span>\
</span><span></span>    <span>|</span> head -n <span>100</span>
</code></pre></div><p>The output shows us the frequency of Git comment’s words. There are more <code>add</code> than <code>fix</code> words, which already give us some information: more features have been added, less fix might have been needed.</p><p>We can also output all the words without aggregating them, and put them into a word cloud generator, to visualize the result. Let’s run the following:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span>format:<span>&#39;%s&#39;</span> --after<span>=</span>2018-12-31 --before<span>=</span>2021-01-01 <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;\n&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;s/.*/\L&amp;/&#39;</span>
</code></pre></div><p>We can then use a word cloud generator like <a href="https://monkeylearn.com/word-cloud" target="_blank" rel="noopener">this online tool</a>. Additionally, it will filter the data, throwing away useless common words. Here’s the result:</p><picture>
<source srcset="https://thevaluable.dev/images/2022/complexity_metrics_application/devdash_word_cloud.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/complexity_metrics_application/devdash_word_cloud.png" alt="Word cloud for the project Devdash"/></picture><p>We can see here that the term “widget” is often used. You’ll notice that some of the files which changed the most and had the most complexity were about “widget”, too. It seems that this concept is central for Devdash’s domain.</p><p>There’s also the word “github” repeated quite often. Does Devdash call a Github API? Is it only some noise? As you can see, answering questions often bring more questions. These are not crucial for now, but they might be relevant later.</p><p>A last reassuring trend: it seems that the README was often modified, which could mean that an emphasis was made to write good documentation.</p><p>It’s also reassuring to see domain concepts in comments; it’s what we should fine. If there are more words related to bugs or maintenance, the project might be difficult to maintain.</p><h3 id="in-a-nutshell">In a Nutshell</h3><p>Thanks to our commands, we have now more information about this project:</p><ol><li>It’s a young project which was mostly implemented in 2019 and 2020. Not much happened in 2021 or even this year (2022).</li><li>It is implemented and maintained by one developer.</li><li>It’s a small Go project manipulating widgets, an important domain concept.</li><li>It seems that it call a cheer number of external APIs we don’t control, which could lead to problems down the road.</li><li>The configuration files for Devdash look flexible and highly customizable, again a potential source of complexity in the codebase itself.</li></ol><p>I would write this summary somewhere, and refer to it for the first changes I might need to do in the codebase. I would also add the files which have the biggest aggregation of line of code and churn to this summary.</p><p>We’ve uncovered important information about the project without beginning to read the code. The next step would be to look at the structure of the project, and have a glimpse at the biggest files which change most often.</p><p>Of course, you can adapt all these measures (and what to measure) depending on the task at hand.</p><h2 id="analyzing-kubernetes">Analyzing Kubernetes</h2><p>Let’s now switch gear and look at a bigger project: <a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">Kubernetes</a>. As with Devdash, you can rewind the Git history if you want to follow along, and get the same results as the ones in this article. Simply run the following command:</p><div><pre><code data-lang="sh">git checkout <span>$(</span>git rev-list -n <span>1</span> --before<span>=</span><span>&#34;2022-04-21&#34;</span> master<span>)</span>
</code></pre></div><p>We’ll try to answer the same questions we asked for Devdash, and see how things differ when analyzing a bigger project like Kubernetes.</p><h3 id="code-ageism-how-old-is-kubernetes">Code Ageism: How Old is Kubernetes?</h3><p>Let’s display the first and last commit of the project with the following command:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span><span>&#34;format:%ad %h %s&#34;</span> --date<span>=</span>short --reverse <span>\
</span><span></span>    <span>|</span> awk <span>&#39;NR == 1 {print} END {print}&#39;</span>
</code></pre></div><p>Here’s the output:</p><div><pre><code data-lang="text">2014-06-06 2c4b3a562ce First commit
2022-04-15 a750d8054a6 Merge pull request #109487 from alculquicondor/disable-job-tracking
</code></pre></div><p>First, it seems that we indeed have all the commits of the project. Second, Kubernetes is around for quite some time: 8 years already!</p><p>We can also see that the project changed recently. The last commit was a couple of days ago.</p><h3 id="number-of-commits-overtime-1">Number of Commits Overtime</h3><p>Let’s now look at the activity throughout the years with the command:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span><span>&#34;format:%ad %h %s&#34;</span> --date<span>=</span>short --reverse <span>\
</span><span></span>    <span>|</span> awk <span>&#39;{print $1}&#39;</span> <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{FS=&#34;-&#34;} {print $1}&#39;</span> <span>\
</span><span></span>    <span>|</span> sort -n <span>|</span> uniq -c <span>\
</span><span></span>    <span>|</span>  sed <span>&#39;s/^\s*//&#39;</span> <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{print &#34;commits&#34;,&#34;year&#34;} {print}&#39;</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;,&#39;</span>
</code></pre></div><p>Here the result:</p><div><pre><code data-lang="text">commits,year
4577,2014
18248,2015
18786,2016
18378,2017
13452,2018
13860,2019
9633,2020
8911,2021
1878,2022
</code></pre></div><p>The activity was very high from 2015 to 2019, and began to decline slowly from 2018 on. In comparison, not as many commits were created this year.</p><p>From there, we can decide to measure what happened in 2021. It would allow us to get the most recent activities while having a big enough sample, hopefully to limit the false positives in our results. We could also analyze both the year 2020 and 2021; that’s what we’ll do for every other measurements.</p><h3 id="asking-questions-1">Asking Questions</h3><p>Let’s now get the number of commits per author:</p><div><pre><code data-lang="sh">git shortlog -sn --after<span>=</span><span>&#34;2020-12-31&#34;</span> --all
</code></pre></div><p>Here are the biggest contributors to Kubernetes:</p><div><pre><code data-lang="text">5470  Kubernetes Prow Robot
372  Jordan Liggitt
239  Anago GCB
200  Antonio Ojea
185  Tim Hockin
</code></pre></div><p>The first contributor is not human; let’s ignore it. Then, Jordan Liggitt and Anago GCB might be the people who can answer our questions. To get their email, we can add the option <code>--email</code> to the command above.</p><h3 id="project-size-the-lines-of-code-1">Project Size: The Lines of Code</h3><p>Now that we have some basic information about the project, let’s look at the codebase itself. We can again compute the source line of code with <code>cloc</code> at the root of the project:</p><p>The command will take quite some time to complete because of the size of the project. Here’s the first lines of output:</p><div><pre><code data-lang="text">Language                      files          blank        comment           code
--------------------------------------------------------------------------------
Go                            14879         500624         947818        3811811
JSON                            448              3              0         890831
YAML                           1295            678           1208         132809
Markdown                        465          20157              0          71196
Bourne Shell                    334           6349          12339          31217
</code></pre></div><p>A lot of Go in there! That’s normal, Kubernetes is primarily a Go project. There’s a lot of JSON and YAML, too. For what?</p><p>If we run a couple of commands, we’ll see that they are mostly used for testing:</p><ul><li><code>find . -name &#34;*.json&#34; | wc -l</code> - 585 JSON files.</li><li><code>find . -name &#34;*.json&#34; | grep -F &#34;test&#34; | wc -l</code> - 509 JSON files which have the word <code>test</code> in their paths.</li><li><code>find . -name &#34;*.yaml&#34; | wc -l</code> - 3704 YAML files.</li><li><code>find . -name &#34;*.yaml&#34; | grep -F &#34;test&#34; | wc -l</code> - 3523 YAML files which have the word <code>test</code> in their paths.</li></ul><p>We can also see that there are many Bash scripts in there. Let’s run the following command to see from what part of the project they come from:</p><div><pre><code data-lang="sh">find . -name <span>&#34;*.sh&#34;</span> <span>|</span> awk <span>&#39;BEGIN{FS=&#34;/&#34;} {print $2}&#39;</span> <span>|</span> sort <span>|</span> uniq -c <span>|</span> sort -rg
</code></pre></div><p>The result:</p><div><pre><code data-lang="text">136 hack
 81 test
 40 cluster
 33 staging
 29 vendor
 13 build
  3 third_party
  1 plugin
  1 pkg
</code></pre></div><p>It seems that these Bash scripts are primarily in the <code>hack</code> directory. If we look at this directory, we’ll see that it contains mostly Bash scripts, for many purposes.</p><p>Here are two assumptions we can make from there:</p><ol><li>The name <code>hack</code> doesn’t inspire confidence. These scripts might go around some problems or limitations the developers have.</li><li>Whatever we need to do in this codebase, we might need to run (or modify) these Bash scripts. Additionally, it doesn’t seem that these <a href="https://www.youtube.com/watch?v=WWZ5IfpXuac" target="_blank" rel="noopener">scripts are unit tested</a>.</li></ol><p>Looking at the scripts’ names, it seems that we can divide them in two categories:</p><ol><li>The “verify” scripts.</li><li>The “update” scripts.</li></ol><p>The first category might be linked to some kind of test. These assumptions are reinforced by the fact that the <code>test</code> directory is the second one containing the most Bash scripts.</p><p>The second category is more worrying; these scripts might need to run in some specific situations. We should definitely write that in our project’s summary.</p><h3 id="calculating-churn-1">Calculating Churn</h3><p>If we look at the aggregation of churn and complexity per file, it might be better to limit our analysis to some part of the project. Otherwise, it will timeout. The cost of a huge codebase!</p><p>In Go Projects, a big part of the logic is implemented, most of the time, in the <code>pkg</code> directory. So let’s analyse it:</p><div><pre><code data-lang="sh">awk <span>&#39;{files[$1]=(files[$1]?files[$1]FS$2:$2)} END { for (i in files) print files[i],i }&#39;</span> <span>\
</span><span></span>    <span>=(</span>git log --after<span>=</span><span>&#34;2020-12-31&#34;</span> --pretty<span>=</span><span>&#39;&#39;</span> --date<span>=</span>short --numstat ./pkg <span>\
</span><span></span>        <span>|</span> awk <span>&#39;{print $3}&#39;</span> <span>\
</span><span></span>        <span>|</span> sort <span>\
</span><span></span>        <span>|</span> uniq -c <span>\
</span><span></span>        <span>|</span> sort -rn <span>\
</span><span></span>        <span>|</span> awk <span>&#39;{ print &#34;./&#34; $2,$1 }&#39;</span><span>)</span> <span>\
</span><span></span>    <span>=(</span>cloc ./pkg --by-file --quiet --csv <span>\
</span><span></span>        <span>|</span> awk -F <span>&#39;,&#39;</span> <span>&#39;NR &gt; 2 { print $2,$5 }&#39;</span> <span>\
</span><span></span>        <span>|</span> head -n -1<span>)</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;,&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;/^.*,.*,.*$/!d&#39;</span> <span>\
</span><span></span>    <span>|</span> sort -rg <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{print &#34;CHANGES,LINES,FILENAMES&#34;} {print}&#39;</span>
</code></pre></div><p>Here are the first lines of the output:</p><pre><code data-lang="csv">CHANGES,LINES,FILENAMES
220,260,./pkg/features/kube_features.go
71,1104,./pkg/proxy/iptables/proxier.go
69,1587,./pkg/kubelet/kubelet.go
64,5448,./pkg/apis/core/validation/validation.go
55,5725,./pkg/proxy/iptables/proxier_test.go
52,18914,./pkg/apis/core/validation/validation_test.go
52,1738,./pkg/apis/core/types.go
51,1600,./pkg/proxy/ipvs/proxier.go
50,11237,./pkg/registry/core/service/storage/storage_test.go
39,359,./pkg/scheduler/scheduler.go
38,1472,./pkg/kubelet/kubelet_pods.go
36,1261,./pkg/controller/job/job_controller.go
35,749,./pkg/kubelet/cm/container_manager_linux.go
34,38833,./pkg/generated/openapi/zz_generated.openapi.go
33,359,./pkg/scheduler/scheduler_test.go
31,3034,./pkg/controller/job/job_controller_test.go
31,1686,./pkg/volume/util/operationexecutor/operation_generator.go
31,1656,./pkg/scheduler/framework/plugins/defaultpreemption/default_preemption_test.go
30,2192,./pkg/kubelet/kubelet_test.go
</code></pre><p>We can already see that some file have many lines of code. The output is sorted here by the number of changes, but we could also sort by the number of line. To do so, replace <code>sort -rg \</code> at the end of the command with <code>sort -t &#39;,&#39; -k2 -rg \</code>.</p><p>First, the file <code>kube_feature.go</code> seems to be logically coupled with a lot of things: it’s not very big, but it changes very often, compared to the other files. It could be some sort of configuration file.</p><p>Next, the files in <code>apis/core</code> seem quite complex, especially <code>validation.go</code>. Hopefully, it seems to be tested as well thanks to the huge <code>validation_test.go</code> (the biggest file in the whole codebase). With a test file of this size, our hope is that the tests are well defined, commented, and not coupled to one another.</p><p>The other files which seem to change often are the ones from the <code>/pkg/kubelet</code> package. They might be logically coupled if they change together. The same could be said about the files in <code>pkg/proxy</code> or <code>pkg/apis</code>. If I would need to work on these files, I would do more analysis on the <code>kubelet</code> package to understand better the logical dependencies.</p><p>All and all, I would have expected more changes on a codebase that size. It seems to me that the changes are not happening only on the same files: it’s a good sign. It means that there is no “god files” which gather all the logic.</p><p>As I said, the Bash scripts can be a little worrying (huge Bash scripts are often a pain), especially when they’re all in some weirdly named “hack” directory. So it might be worthwhile to also analyze them:</p><div><pre><code data-lang="sh">awk <span>&#39;{files[$1]=(files[$1]?files[$1]FS$2:$2)} END { for (i in files) print files[i],i }&#39;</span> <span>\
</span><span></span>    <span>=(</span>git log --after<span>=</span><span>&#34;2020-12-31&#34;</span> --pretty<span>=</span><span>&#39;&#39;</span> --date<span>=</span>short --numstat ./hack <span>\
</span><span></span>        <span>|</span> awk <span>&#39;{print $3}&#39;</span> <span>\
</span><span></span>        <span>|</span> sort <span>\
</span><span></span>        <span>|</span> uniq -c <span>\
</span><span></span>        <span>|</span> sort -rn <span>\
</span><span></span>        <span>|</span> awk <span>&#39;{ print &#34;./&#34; $2,$1 }&#39;</span><span>)</span> <span>\
</span><span></span>    <span>=(</span>cloc ./hack --by-file --quiet --csv <span>\
</span><span></span>        <span>|</span> awk -F <span>&#39;,&#39;</span> <span>&#39;NR &gt; 2 { print $2,$5 }&#39;</span> <span>\
</span><span></span>        <span>|</span> head -n -1<span>)</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;,&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;/^.*,.*,.*$/!d&#39;</span> <span>\
</span><span></span>    <span>|</span> sort -rg <span>\
</span><span></span>    <span>|</span> head -n <span>30</span> <span>\
</span><span></span>    <span>|</span> awk <span>&#39;BEGIN{print &#34;CHANGES,LINES,FILENAMES&#34;} {print}&#39;</span>
</code></pre></div><p>Here’s the first lines of the output:</p><pre><code>CHANGES,LINES,FILENAMES
27,609,./hack/lib/golang.sh
24,947,./hack/local-up-cluster.sh
20,170,./hack/make-rules/test-e2e-node.sh
9,594,./hack/lib/util.sh
</code></pre><p>I would keep an eye on the two first files, because of their rate of change and their size. If they continue to grow overtime, it might be a good idea to split them, to make them more understandable.</p><h3 id="git-comments-mood-and-domain-concepts-1">Git Comments: Mood and Domain Concepts</h3><p>Last stop: the Git comments. Let’s run the following command:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span>format:<span>&#39;%s&#39;</span> --after<span>=</span><span>&#34;2020-12-31&#34;</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;\n&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;s/.*/\L&amp;/&#39;</span> <span>\
</span><span></span>    <span>|</span> sort <span>\
</span><span></span>    <span>|</span> uniq -c <span>\
</span><span></span>    <span>|</span> sort -rg <span>\
</span><span></span>    <span>|</span> head -n <span>100</span>
</code></pre></div><p>There’s quite a lot of noise in the result. In general, the bigger the project is, the more noise we’ll have in our results. It’s important to keep that in mind, because more noise potentially mean false positives and wrong assumptions.</p><p>We can try to visualize these words using a word cloud, to see more clearly in this mess. Let’s plug in the result of the following commands:</p><div><pre><code data-lang="sh">git log --pretty<span>=</span>format:<span>&#39;%s&#39;</span> --after<span>=</span><span>&#34;2020-12-31&#34;</span> <span>\
</span><span></span>    <span>|</span> tr <span>&#39; &#39;</span> <span>&#39;\n&#39;</span> <span>\
</span><span></span>    <span>|</span> sed <span>&#39;s/.*/\L&amp;/&#39;</span>
</code></pre></div><p>We could also filter the words we don’t find interesting for our analysis, by piping the command above to something like <code>grep -Ev &#34;merge|pull|from&#34;</code>, for example. These words are likely to be from Git itself, not really from the developers.</p><p>Then, let’s plug the output <a href="https://monkeylearn.com/word-cloud" target="_blank" rel="noopener">in this tool</a>. Here’s a possible result:</p><picture>
<source srcset="https://thevaluable.dev/images/2022/complexity_metrics_application/kubernetes_word_cloud_cleaned.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2022/complexity_metrics_application/kubernetes_word_cloud_cleaned.png" alt="Word cloud for the Kubernetes project"/></picture><p>First, the team of Kubernetes seem to speak about tests quite often. It correlates well with the other analysis we’ve done. That’s always good news.</p><p>Looking at the important domain concepts, <code>kubelet</code> seems quite important (as we already saw when we analyzed the aggregation of complexity and churn at the file level), as well as <code>node</code>, <code>pod</code>, <code>metric</code>, <code>proxy</code>, and <code>scheduler</code>. If you know a bit how Kubernetes work, it makes sense.</p><p>The cheer amount of <code>fix</code> is a bit alarming, but it also makes sense that a tool as big as Kubernetes need quite some maintenance. It’s not a greenfield project anymore.</p><h3 id="in-a-nutshell-1">In a Nutshell</h3><p>It’s already more difficult to get useful information from a bigger project like Kubernetes, but it’s also difficult to do anything in this kind of project without <em>any</em> information. In that context, the measurements we did can be really useful.</p><p>Let’s try to make our summary:</p><ol><li>Kubernetes is a very well known project going on for 8 years, which might explain its size.</li><li>The activity on the project began to slow down in 2018, and even more in 2020.</li><li>It’s mainly written in Golang, with a lot of fixtures in JSON and YAML for the tests.</li><li>It includes a cheer number of bash scripts, mostly for “verifying” and “updating” things, and for tests. We should dive more (reading code, asking questions) to know in what context we might need to use or to change them.</li><li>In general, it seems that there are many tests. It’s fortunate, for a project of this size!</li><li>The churn indicates that a couple of packages are often changed: <code>apis/core</code>, <code>pkg/proxy</code>, <code>pkg/apis</code>, and <code>pkg/kubelet</code>. There might be some logical coupling going on there.</li><li>The git comments show us important domain concepts, like <code>kubelet</code>, <code>node</code>, <code>pod</code>, <code>metric</code>…</li></ol><p>Again, I would write that somewhere and use it as reference for any change I need to do in Kubernetes. I would add to the summary the biggest files which change most often, too, or maybe what seems to be the most changed packages.</p><h2 id="do-we-need-to-know-everything">Do We Need to Know Everything?</h2><p>It can be difficult to measure everything we want only using basic CLI tools, but they’re great to quickly get some useful information about a codebase. The results can give us interesting clues what to be careful about, especially if we need to modify the system.</p><p>From there, it could be useful to use other tools to get even more information if we need to answer more questions. My favorite tool for that is another CLI, <a href="https://github.com/adamtornhill/code-maat" target="_blank" rel="noopener">code-maat</a>. For example, it can give more useful information about logical coupling, and perform analysis on bigger entities than files.</p><p>It’s important to understand that measuring, by itself, is far from being enough in many situations. We can only make educated assumptions from our measuring. Then, we can use our experience and tacit knowledge to confirm what we need to do, and set our priorities right.</p><p>So, what did we see in this article?</p><ul><li>The longer a system is around, the more complex it might be. Looking at the age of the codebase can already give us a little idea.</li><li>Looking at the number of commits per year can give us a glimpse of the codebase’s activity.</li><li>Asking questions to the main developers of a codebase can be an effective way to dig deeper. We can find this information in Git’s history directly.</li><li>According to many studies, static complexity metrics are more or less correlated to the source lines of code (SLOC). Looking at the size of the project can offer us another glimpse of its complexity.</li><li>Again, according to some studies, churn (amount of code added and deleted) is one of the best metric to get the possible hotspots of complexity. It allows us to have a more precise idea <em>where</em> the complexity might be.</li><li>Mining Git comments can also give us useful information, even if there might also be a lot of noise in there.</li></ul><p>As much as I like code-maat, I find it a bit clunky to install and use (especially since I always need to first create a file with Git output before using it). I’m thinking more and more about developing a CLI tool which could calculate important metrics. The metrics would be more or less “important” according to studies, my experience, and the experience of others.</p><p>What do you think about that? What metrics would be useful for you? The comment section is waiting for your input.</p></section></article></div></div>
  </body>
</html>
