<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://media.ccc.de/b/congress/2025">Original</a>
    <h1>39th Chaos Communication Congress Videos</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
            <p><strong>TLDR: you should leave a comment, either spam or not, so I can test how well this system works!</strong></p>
<p>I really appreciate <a href="[Mataroa — Blogging platform for minimalists](https://mataroa.blog/)">Mataroa</a>, the blogging platform this post is on. It&#39;s easy to use, basically free, very performant, and looks different than Substack. </p>
<p>But there&#39;s one thing that annoys me a bit: the comment moderation system. Moderation is a famously tricky problem, so Mataroa leaves it up to the writer to individually approve or deny every comment. It&#39;s a reasonable system, but I also have to deal with hundreds of comments that look like this:</p>
<p><img alt="Screenshot 2025-12-27 154634.png" src="https://mataroa.blog/images/75acea18.png"/></p>
<p>Like, what even is this? I understand the spam comments which are clear SEO attempts. But really, random strings of characters? Is someone messing with me? Is the CIA trying to send me a message? Are there just bots on the internet who are literally spamming every form they can find with lowercase consonants?</p>
<p>Anyways, I&#39;ve let my comment backlog build up, and I wanted to build a system to take care of the obvious spam. My basic goal was to have an AI model classify every comment: the system would delete clear spam while it would email me the potentially useful comments for me to make the final decision.</p>

<p>The first decision I needed to make was how I was going to run the system.  I could write a python script and figure out how to run it daily (or hourly), but I ended up using <a href="[script.google.com](https://script.google.com/)">Google Apps Scripts</a> instead, a JavaScript variant which has tight integrations with Google&#39;s web apps.</p>
<p>When I started this project, Mataroa&#39;s <a href="[Mataroa API](https://mataroa.blog/api/docs/)">API</a> didn&#39;t let me control comment requests. (More on that later). But, every time someone submitted a comment, Mataroa would send me an email with links to approve or delete the comment. So I decided to try to use my email as a de-facto comment-moderation API. Google Script has a Gmail integration that doesn&#39;t require me to go through OAuth, so it was the natural choice. </p>
<p>I had a solid plan of attack, I thought: I would set up a Google Scripts trigger to run a script every hour which would</p>
<ol>
<li>Search my inbox for any emails from <code>notifications@mataroa.blog</code>.</li>
<li>Scrape each email for the comment.</li>
<li>Use an LLM API to classify whether the comment was easy spam.</li>
<li>Delete the comment, or forward it to another email for me to double-check.</li>
</ol>
<p>Steps 1 through 3 were quite straightforward. Step 4 was not.</p>

<p>Mataroa sends me every comment request via the email <code>notifications@mataroa.blog</code>, so the first step was to collect all the requests into one place. I needed to search through my inbox for emails <code>notifications@mataroa.blog</code> and then turn each email into a comment.</p>
<p>Luckily, Google Scripts had good tools for this, given that I use a Gmail account for Mataroa. Scripts is a JavaScript variant which includes built-in APIs for connected Google products like Google Docs, Google Calendar, or Google Sheets. In the case of Gmail, the API is the <code>GmailApp</code> object. </p>
<p>Searching is very easy: just use the <code>GmailApp.search</code> with the search term that I would use in the Gmail interface itself. In this case, I&#39;m looking for every single email from <code>notifications@mataroa.blog</code> that isn&#39;t in the trash:</p>
<div><pre><span></span><span>function</span><span> firstPassOnComment() {</span>
<span>  </span><span>const</span><span> threads </span><span>=</span><span> GmailApp.search(</span><span>&#39;from:notifications@mataroa.blog&#39;</span><span>);</span>
<span>  threads.forEach(emailThread =&gt; {</span>
<span>    messages </span><span>=</span><span> emailThread.getMessages();</span>
<span>    messages.forEach(email =&gt; {</span>
<span>          processEmail(email);</span>
<span>    });</span>
<span>  });</span>
<span>}</span>
</pre></div>

<p>There is one wrinkle, though. The search results return email threads rather than individual emails. But that&#39;s easy to deal with: all I need to do is get each message from the threads.</p>
<p>This code is making an important decision: deal with comments one at a time. Because each comment requires a distinct LLM call, they will take at least a couple seconds to process. If I were processing hundreds of comment requests an hour, I would want to send multiple LLM calls at once. Since there&#39;s only a couple a day right now, I prefer the simplicity of dealing with each comment one at a time. </p>

<p>After I&#39;ve gotten every single message, I need to process them into a format I can deal with programmatically. Eventually, I send the comment content and the post title to the LLM, so I need to extract both of those. I also want the comment ID, for later.</p>
<p>If I was going to write the script today, I would get both of these from Mataroa&#39;s API. At the time, though, all I had was the emails. Luckily they come in a structured format:</p>
<div><pre><span></span>Someone commented on your post: POST TITLE  

This comment is pending review, currenly visible only to you.  

Comment follows:  

TEXT OF THE COMMENT

---  
See comment:  
https://liquidbrain.mataroa.blog/blog/the-noticing-game/#comment-COMMENTID

Approve:  
https://liquidbrain.mataroa.blog/blog/the-noticing-game/comments/COMMENTID/approve/

Delete:  
https://liquidbrain.mataroa.blog/blog/the-noticing-game/comments/COMMENTID/delete/
</pre></div>

<p>Assuming this format would stay fixed, I wrote three helper functions to get the <code>POST TITLE</code>, <code>TEXT OF THE COMMENT</code>, and <code>COMMENTID</code> respectively:</p>
<div><pre><span></span><span>function</span><span> getPostTitle(message) {</span>
<span>  </span><span>const</span><span> body </span><span>=</span><span> message.getBody();</span>
<span>  </span><span>const</span><span> startMarker </span><span>=</span><span> </span><span>&#34;Someone commented on your post: &#34;</span><span>;</span>
<span>  </span><span>const</span><span> startIndex </span><span>=</span><span> body.indexOf(startMarker) </span><span>+</span><span> startMarker.length;</span>
<span>  </span><span>const</span><span> endIndex </span><span>=</span><span> body.indexOf(</span><span>&#34;This comment is pending review&#34;</span><span>);</span>
<span>  </span><span>const</span><span> title </span><span>=</span><span> body.substring(startIndex, endIndex).trim();</span>
<span>  </span><span>return</span><span> title;</span>
<span>}</span>

<span>function</span><span> getCommentContent(email) {</span>
<span>  </span><span>const</span><span> body </span><span>=</span><span> email.getBody()</span>
<span>  </span><span>const</span><span> startOfCommentIndex </span><span>=</span><span> body.indexOf(</span><span>&#34;Comment follows:&#34;</span><span>) </span><span>+</span><span> </span><span>20</span>
<span>  </span><span>const</span><span> endOfCommentIndex </span><span>=</span><span> body.length </span><span>-</span><span> body.split(</span><span>&#34;&#34;</span><span>).reverse().join(</span><span>&#34;&#34;</span><span>).lastIndexOf(</span><span>&#34;---&#34;</span><span>) </span><span>-</span><span> </span><span>4</span>
<span>  </span><span>const</span><span> comment </span><span>=</span><span> body.substring(startOfCommentIndex,endOfCommentIndex)</span>
<span>  </span><span>return</span><span> comment;</span>
<span>}</span>

<span>function</span><span> getCommentIDFromEmail(email) {</span>
<span>  </span><span>const</span><span> body </span><span>=</span><span> email.getBody();</span>
<span>  </span><span>let</span><span> parts </span><span>=</span><span> body.split(</span><span>&#34;/&#34;</span><span>)</span>
<span>  </span><span>return</span><span> parts[parts.length</span><span>-</span><span>3</span><span>];</span>
<span>}</span>
</pre></div>

<p>If you read through the code blocks, you might notice that I&#39;m not using regular expressions to extract text content, but am instead using rather ugly code to split up the email text. I made this choice for two reasons. First, I didn&#39;t really want to learn about regular expressions for the project nor use AI to write them (see Appendix). Second, I have no control over the comment text, so I need to be careful to write code which does not depend on the content of the comment at all.</p>
<p>For instance, the <code>getCommentContent</code> function figures out the first occurrence of <code>Comment follows:</code> and the last occurence of <code>---</code>; these do not depend on the comment content as the rest of the email structure is fixed.</p>

<p>My <code>processEmail</code> function begins by scraping the email and then calling a <code>moderateComment</code> function. But how am I moderating the comments?</p>
<p>Current LLMs (Large Language Models) are quite good at this type of task, especially since the stakes are pretty low: if an attacker tricks my moderation system, I still need to manually approve the comment. So I decided I wanted to try setting up a prompt system. I chose Gemini Flash because it&#39;s very cheap but offers good performance.</p>
<h2 id="calling-the-llm">Calling the LLM</h2>
<p>If I was working in regular JavaScript or in Python, I could make LLM requests through a nice interface. However, Google Scripts does not offer this functionality built-in.<sup id="fnref:1"><a href="#fn:1">1</a></sup> To use a Gemini model, I&#39;d need to make an API request itself. Luckily, Google offered some sample code in a demo, and I&#39;ve done this before <a href="https://liquidbrain.net/blog/gemini-transcription-shortcut/">myself</a>.</p>
<p>There&#39;s a lot of boilerplate code I won&#39;t explain, but the basic steps were to a) make a prompt containing the comment and instructions to classify it b) create a JSON object that contained the prompt and response settings I wanted c) make a fetch request using Google Script&#39;s <code>UrlFetchApp</code> d) parsing the response.</p>
<p>I made a couple of decisions along the way. First, I chose to use a structured response: all I needed from the LLM to respond <code>True</code> or <code>False</code> to whether the post is spam. Knowing the exact format of the output makes including it in a pipeline much easier. Second, I set the thinking budget to <code>-1</code> (which prevents the model from producing thinking tokens) to keep costs down.</p>

<p>This ended up being the most difficult part of the whole project. It was only solved after I left a  <a href="https://github.com/mataroablog/mataroa/issues/102">issue</a> on the Mataroa GitHub.</p>
<p>As I&#39;ve mentioned before, Mataroa had no comments API when I started this project. One could delete buttons manually by navigating to a delete page and pressing a button, so I thought to automate this process using HTTP requests.</p>
<p>The crucial part of the delete page used this HTML:</p>
<div><pre><span></span><span>&lt;</span><span>main</span> <span>class</span><span>=</span><span>&#34;delete&#34;</span><span>&gt;</span> 
<span>&lt;</span><span>h1</span><span>&gt;</span>Are you sure you want to delete this comment?<span>&lt;/</span><span>h1</span><span>&gt;</span> 
<span>&lt;</span><span>p</span><span>&gt;</span>COMMENT CONTENT <span>&lt;/</span><span>p</span><span>&gt;</span> 
<span>&lt;</span><span>form</span> <span>method</span><span>=</span><span>&#34;post&#34;</span><span>&gt;</span> 
<span>&lt;</span><span>input</span> <span>type</span><span>=</span><span>&#34;hidden&#34;</span> <span>name</span><span>=</span><span>&#34;csrfmiddlewaretoken&#34;</span> <span>value</span><span>=</span><span>&#34;CSRFTOKENVALUE&#34;</span><span>&gt;</span> 
<span>&lt;</span><span>input</span> <span>type</span><span>=</span><span>&#34;submit&#34;</span> <span>value</span><span>=</span><span>&#34;Confirm delete&#34;</span> <span>class</span><span>=</span><span>&#34;type-danger&#34;</span><span>&gt;</span> 
<span>&lt;/</span><span>form</span><span>&gt;</span> 
<span>&lt;/</span><span>main</span><span>&gt;</span>
</pre></div>

<p>The first challenge was reaching this page in the first page. If I made a fetch request for <code>https://liquidbrain.mataroa.blog/blog/the-noticing-game/comments/COMMENTID/delete/</code>, I would get a &#34;permission denied&#34; request because I didn&#39;t give authentication information. However, I was able to extract a working <code>sessionid</code> token by opening the delete page in the browser and going to web tools. Using the <code>sessionid</code> let me access the page.<sup id="fnref:2"><a href="#fn:2">2</a></sup></p>
<p>The second challenge was triggering the form. Using developer tools, I was able to figure out the network call that clicking the delete button trigger. When I tried to replicate that network call, however, I got a 403 permission denied error. Even after playing around with the request parameters and other debugging, I wasn&#39;t able to figure out how to get around the server&#39;s security measures.</p>
<h2 id="requesting-an-mataroa-feature">Requesting an Mataroa feature</h2>
<p>After spending 30 minutes on this, I started to feel that this whole process was too hacky and unlikely to succeed. What I really needed was a programmatic way to delete comments. If I couldn&#39;t do it in a hacky way, I&#39;d have to request an addition to the API.</p>
<p>I posted a feature request on the Mataroa GitHub for API access to comments. A month later, the project developer <a href="https://github.com/sirodoht">Theodore Keloglou</a> added the feature to the <a href="https://mataroa.blog/api/docs/">API</a>, for which I&#39;m very grateful. The resulting code was much simpler!</p>
<div><pre><span></span><span>function</span><span> deleteComment(id) {</span>
<span>  </span><span>const</span><span> commentURL </span><span>=</span><span> </span><span>`https://mataroa.blog/api/comments/${</span><span>id</span><span>}/`</span>
<span>  </span><span>let</span><span> response </span><span>=</span><span> UrlFetchApp.fetch(commentURL, {</span>
<span>    method</span><span>:</span><span> </span><span>&#39;delete&#39;</span><span>,</span>
<span>    </span><span>&#39;headers&#39;</span><span>:</span><span> {</span>
<span>      </span><span>&#39;Authorization&#39;</span><span>:</span><span> </span><span>`Bearer ${</span><span>mataroaAPIKey</span><span>}`</span>
<span>    },</span>
<span>  });</span>
<span>}</span>
</pre></div>

<p>I did learn one tricky detail about making Fetch requests. I initially forgot to include the trailing slash in the <code>commentURL</code> which turned my DELETE HTTP request into a POST request. I was really confused why this was happening — I initially thought it was a restriction by Google Script — but everything worked after I added the trailing slash in.</p>

<p>The last step was to delete the spam comments and forward the rest. Again, with Google Script&#39;s built-in features, this was mercifully easy:</p>
<div><pre><span></span><span>if</span><span> (isSpam) {</span>
<span>    deleteComment(commentID);</span>
<span>    console.log(</span><span>`deleted comment ${</span><span>commentID</span><span>}`</span><span>)</span>
<span>    email.moveToTrash();</span>
<span>  } </span><span>else</span><span> {</span>
<span>    console.log(</span><span>`WILL FORWARD to personal email ${</span><span>commentID</span><span>}`</span><span>);</span>
<span>    email.forward(emailToSendTo);</span>
<span>    email.moveToTrash();</span>
<span>  }</span>
</pre></div>

<p>After all that work, I was finally able to test the script. (I&#39;d been testing individual functions for a while).</p>
<p>I decided not to write programmatic tests for this project because a) I don&#39;t know if Google Script has a good testing framework b) it seemed more difficult to simulate deleting a comment than to check whether the script actually deleted comments appropriately. Luckily, the previous five and a half months had given me a lot of spam comments to look at.</p>
<p>I needed to check four main functionalities:</p>
<ol>
<li>Could the script classify comments correctly? </li>
<li>Could the script delete and forward comments as necessary? </li>
<li>Did the whole system work once? </li>
<li>Did the whole system work when running every hour? And I needed to follow that order because once I deleted a comment, I couldn&#39;t revert the change.</li>
</ol>
<p>For each, I made the obvious choices. For (1), I had the code print out what the moderation decision would be and manually checked if that was reasonable. So far, the system has been 100% right in its judgements. (2) I took individual spam comments and checked if my script successfully deleted them. (3) I ran the script on my whole backlog, now with deletions and forwards. </p>
<p>(4) required a little bit more work. Google Scripts allows one to run a script every hour using a time-based trigger, which is how I&#39;m currently deploying it. But I wanted to make sure the trigger was working. So after I had completed testing steps (1)-(3), I populated several spam and non-spam comments on the blog, waited an hour, and checked whether the script worked.</p>
<p>It did, so I set the trigger and let it run. It&#39;s been going for a week now without any errors.</p>

<p>This project is already looking to be one of my most useful.<sup id="fnref:3"><a href="#fn:3">3</a></sup> I cleared through my entire ~100 comment backlog, which included several genuine comments that I had missed. In the week since I&#39;ve finished it, it&#39;s been chugging along still removing spam comments. And if I blog more in the new year, this might end up being a really useful piece of infrastructure for my blog. </p>
<p>The system also doesn&#39;t seem to cost that much: in December, I spent $0.50 on API calls, even after working through the entire comment backlog several times. I expect to spend less than $5 next year on this commenting system.</p>
<p>More importantly, coding this project was fun. I&#39;ve gotten a lot less time to code since I&#39;ve started working as a journalist at <a href="https://www.understandingai.org/">Understanding AI</a>, and I&#39;ve missed the feeling of getting to play around with a computer and build stuff that I will use. This was a small side project, but I still had fun.</p>
<p>As part of having fun, I didn&#39;t have AI write any of the code. I&#39;ve <a href="https://liquidbrain.net/blog/learning-coding-ai/">written</a> previously about how I use LLMs in personal coding projects, particularly those where I&#39;m trying to become a better programmer. Generally, I think I&#39;m still at the state where I learn more by coding (almost) everything by hand. So for this project, I decided to use no LLM-generated code, which was especially doable given how small the project is (~140 lines of code). However, I did lean heavily on assistance from Claude (if you&#39;re curious, here are my two chats where I worked on this projects: <a href="https://claude.ai/share/97c989c0-f1de-48b1-9ddd-87aabcfddbc4">first</a>, <a href="https://claude.ai/share/798dadac-497b-4f7f-8238-6aa38c793f7f">second</a>).</p>
<p>I definitely learned more from writing the code myself, and it was a lot of fun, but I&#39;m still a little conflicted whether this was the right choice. The process took a lot more time than it would have otherwise. And, as someone in a primarily non-technical role where my coding needs are generally throwaway scripts, I probably should improve at using Claude Code or other coding agents because ultimately efficiency is a higher priority at work.</p>
<p>But anyways: I think this project was a success. If you&#39;d like to support this success: drop me a comment below! Feel free to try to trick the LLM into including an obviously bad comment!<sup id="fnref:4"><a href="#fn:4">4</a></sup></p>
<h2 id="notes">Notes</h2>

        </div></div>
  </body>
</html>
