<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://probablydance.com/2025/02/08/why-does-integer-addition-approximate-float-multiplication/">Original</a>
    <h1>Why Does Integer Addition Approximate Float Multiplication?</h1>
    
    <div id="readability-page-1" class="page"><div id="post-11807">
	<div>
		<h3>Why Does Integer Addition Approximate Float Multiplication?</h3>		<h4>by <span>Malte Skarupke</span></h4>

				<div>
			
<p>Here is a rough approximation of float multiplication (<a href="https://arxiv.org/abs/2410.00907">source</a>):</p>


<div><pre title="">float rough_float_multiply(float a, float b) {
    constexpr uint32_t bias = 0x3f76d000;
    return bit_cast&lt;float&gt;(bit_cast&lt;uint32_t&gt;(a) + bit_cast&lt;uint32_t&gt;(b) - bias);
}
</pre></div>


<p>We’re casting the floats to ints, adding them, adjusting the exponent, and returning as float. If you think about it for a second you will realize that since the float contains the exponent, this won’t be too wrong: You can multiply two numbers by adding their exponents. So just with the exponent-addition you will be within a factor of 2 of the right result. But this will actually be much better and get within 7.5% of the right answer. Why?</p>



<figure><a href="https://probablydance.com/wp-content/uploads/2025/02/custom_multiply-3.png"><img data-attachment-id="11852" data-permalink="https://probablydance.com/2025/02/08/why-does-integer-addition-approximate-float-multiplication/custom_multiply/" data-orig-file="https://probablydance.com/wp-content/uploads/2025/02/custom_multiply-3.png" data-orig-size="943,530" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="custom_multiply" data-image-description="" data-image-caption="" data-medium-file="https://probablydance.com/wp-content/uploads/2025/02/custom_multiply-3.png?w=300" data-large-file="https://probablydance.com/wp-content/uploads/2025/02/custom_multiply-3.png?w=650" width="650" height="365" src="https://probablydance.com/wp-content/uploads/2025/02/custom_multiply-3.png?w=650" alt=""/></a></figure>



<p>It’s not the magic number. Even if you only adjust the exponent (subtract 127 to get it back into range after the addition) you get within 12.5% of the right result. There is also a mantissa offset in that constant which helps a little, but 12.5% is surprisingly good as a default.</p>



<p>I should also say that the above fails catastrophically when you overflow or underflow the exponent. I think the source paper doesn’t handle that, even though underflowing is really easy by doing e.g. 0.5 * 0. It’s probably fine to ignore overflow, so here is a version that just handles underflow:</p>


<div><pre title="">float custom_multiply(float a, float b) {
    constexpr uint32_t sign_bit = 0x8000&#39;0000;
    constexpr uint32_t exp_offset =    0b0&#39;01111111&#39;0000000&#39;00000000&#39;00000000;
    constexpr uint32_t mantissa_bias = 0b0&#39;00000000&#39;0001001&#39;00110000&#39;00000000;
    constexpr uint32_t offset = exp_offset - mantissa_bias;
    uint32_t bits_a = std::bit_cast&lt;uint32_t&gt;(a);
    uint32_t bits_b = std::bit_cast&lt;uint32_t&gt;(b);
    uint32_t c = (bits_a &amp; ~sign_bit) + (bits_b &amp; ~sign_bit);
    if (c &lt;= offset)
        c = 0;
    else
        c -= offset;
    c |= ((bits_a ^ bits_b) &amp; sign_bit);
    return std::bit_cast&lt;float&gt;(c);
}
</pre></div>


<p>Clang compiles this to a branchless version that doesn’t perform too far off from float multiplication. Is this ever worth using? The <a href="https://arxiv.org/abs/2410.00907">paper</a> talks about using this to save power, but that’s probably not worth it for a few reasons:</p>



<ol>
<li>Most of the power-consumption comes from moving bits around, the actual float multiplication is a small power drain compared to loading the float and saving the result</li>



<li>You wouldn’t be able to use tensor cores</li>



<li>I don’t think you can actually be faster than float multiplication because there are so many edge cases to handle</li>
</ol>



<p>It feels close to being worth it though, so I wouldn’t be surprised if someone found a use case.</p>



<p>But there is still the question of why this works so well. The mantissa is not stored in log-space, it’s just stored in plain old linear space where addition does not do multiplication. But lets think about how to get the exponent from the mantissa.</p>



<p>In general how do you get the remaining exponent-fraction from the remaining bits? This is easier to think about for integers where you can get the log2 by determining the highest set bit:</p>



<p>log2(20) = log2(0b10100) ~= highest_set_bit(0b10100) = 4</p>



<p>The actual correct value is log2(20)=4.322. The question we need to answer is: How do you get the remaining exponent-fraction, 0.322 from the remaining bits, 0b0100?</p>



<p>To make this work for any number of bits we should normalize the remaining bits into the range 0 to 1, which in this case means doing the division 0b0100/float(1 &lt;&lt; 4)=0.25. (in general you divide by the highest set bit, which you already had to calculate for the previous step)</p>



<p>After we brought the numbers into the range from 0 to 1, you can get the remaining exponent fraction with log2(1+x). In this case it’s log2(1+0.25) = 0.322.</p>



<p>If you plot y=log2(1+x) for the range from 0 to 1 you will find that it doesn’t deviate too far from y=x. So if you just want an approximate solution you might as well skip this step.</p>



<figure><a href="https://probablydance.com/wp-content/uploads/2025/02/log2.png"><img data-attachment-id="11823" data-permalink="https://probablydance.com/2025/02/08/why-does-integer-addition-approximate-float-multiplication/log2/" data-orig-file="https://probablydance.com/wp-content/uploads/2025/02/log2.png" data-orig-size="867,713" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;0&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;0&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;0&#34;,&#34;iso&#34;:&#34;0&#34;,&#34;shutter_speed&#34;:&#34;0&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="log2" data-image-description="" data-image-caption="" data-medium-file="https://probablydance.com/wp-content/uploads/2025/02/log2.png?w=300" data-large-file="https://probablydance.com/wp-content/uploads/2025/02/log2.png?w=650" width="300" height="246" src="https://probablydance.com/wp-content/uploads/2025/02/log2.png?w=300" alt=""/></a></figure>



<p>And then the mantissa is already interpreted as a fraction on floats, so you also don’t have to divide. So the whole operation cancels out and you can just add.</p>



<p>You still need to handle</p>



<ol>
<li>The sign bit</li>



<li>Overflowing mantissa</li>



<li>Overflowing exponent</li>



<li>Underflowing exponent</li>
</ol>



<p>Number 1 and 2 also work out naturally using addition because of how floats are represented:</p>



<ul>
<li>Since the sign bit is the highest bit, overflow is ignored so addition is the same as xor, which is what you want</li>



<li>When the mantissa overflows you end up increasing the exponent, which is what you want. (e.g. 1.5 * 1.5 = 2.25, which has a higher base-2 exponent)</li>
</ul>



<p>Number 3 can be ignored for most floats you care about.</p>



<p>Number 4 is the one that required me to write that more complicated version of the code. It’s really easy to underflow the exponent, which will wrap around and give you large numbers instead. In neural networks lots of activation functions like to return 0 or close to 0 and when you multiply with that you will underflow the initial function and get very wrong results. So you need to handle underflow. I have not found an elegant way of doing it because you only have a few cycles to work in, otherwise you might as well use float multiplication.</p>



<p>The last open question is that mantissa-adjustment: You can see in the graph above that the approximation y=x is never too big, so by default you will always bias towards 0. But you can add a little bias to the mantissa to shift the whole line up. I tried a few analytic ways to arrive at a good constant, but they all gave terrible results when I actually tried this on a bunch of floats. So I just tried many different constants and stuck with the one that gave the least error on 10,000 randomly generated test floats.</p>



<p>So even though this is probably not useful and I haven’t found a really elegant way of doing it, it’s still neat how the whole thing almost works out as a one-liner because so many things cancel out once you approximate y=log2(1+x) as y=x.</p>
					</div>
	</div>
	
</div></div>
  </body>
</html>
