<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.pspaul.de/posts/ancient-monkey-pwning-a-17-year-old-version-of-spidermonkey/">Original</a>
    <h1>Ancient Monkey: Pwning a 17-Year-Old Version of SpiderMonkey</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
    <p><img src="https://blog.pspaul.de/posts/ancient-monkey-pwning-a-17-year-old-version-of-spidermonkey/hero.png" alt=""/></p>
<p>Last year, <a href="https://infosec.exchange/@swapgs" target="_blank" rel="noopener">@swapgs</a> and I found a fun bug in the popular enterprise VPN solution <a href="https://www.zscaler.com/de/products-and-solutions/zscaler-client-connector" target="_blank" rel="noopener">Zscaler</a>. The VPN client was using the <a href="https://github.com/manugarg/pacparser" target="_blank" rel="noopener">pacparser</a> library to decide which HTTP requests should be proxied. The decision was made based on a pre-configured <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file" target="_blank" rel="noopener">Proxy Auto-Configuration (PAC)</a> file which contains JavaScript code.</p>
<p><a href="https://github.com/manugarg/pacparser/security/advisories/GHSA-62q6-v997-f7v9" target="_blank" rel="noopener">The bug</a> allowed us to escape from a string and execute arbitrary JavaScript in the context of the PAC file. We noticed that pacparser was using a <a href="https://github.com/manugarg/pacparser/tree/c4ac28b6c621b8c94f9db40e77e2ea7aee707933/src/spidermonkey" target="_blank" rel="noopener">17 year old version of SpiderMonkey</a> (Firefox’s JS engine), but we didn’t have the chance to develop a full exploit at the time. Instead, we just reported the vulnerability, suggesting that code execution is likely possible.</p>
<p>Fast forward to this year. When preparing Hack.lu CTF 2024, I noticed we were low on pwn challenges, so I decided to dust off my pwning skills (I’m usually a web player) and give this bug a try!</p>
<h2 id="A-Promising-SpiderMonkey-Bug"><a href="#A-Promising-SpiderMonkey-Bug" title="A Promising SpiderMonkey Bug"></a>A Promising SpiderMonkey Bug</h2><p>I started by searching the Mozilla bugtracker for a suitable bug. I found a few that were working in pacparser’s version of SpiderMonkey, including one that sounded quite interesting:</p>
<p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=398085" target="_blank" rel="noopener">Crash with large switch statement [@ js_Interpret]</a></p>
<p>When reading through the comments, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=398085#c17" target="_blank" rel="noopener">this one</a> sums up the bug pretty well:</p>
<blockquote>
<p>Switch statements in large functions is quite broken. In this testcase the switch can’t be reached but its mere presence causes the emitter to generate the wrong bytecode for the ‘if’ statement. It should be ‘ifeqx 32804’, but it is ‘ifeq 14’ instead.</p>
<p>With this trick an attacker could get the engine to execute arbitrary bytecodes so this might be security sensitive?</p>
</blockquote>
<p>When a function’s total bytecode is too long, jumps get messed up. The following code will cause the first <code>if</code> to make a short jump (11 bytes) instead of jumping to the end of the block:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>function</span> <span>trigger</span>(<span>a</span>) </span>{</span></pre></td></tr></tbody></table></figure>
<p>Such a misaligned jump can be used to execute arbitrary bytecode by jumping into the literal portion of a <code>UINT24</code> instruction:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>0000</span>: <span>56</span> <span>00</span> <span>00</span>      GETVAR <span>0</span>          </span></pre></td></tr></tbody></table></figure>
<p>The <code>IFEQ</code> jump at <code>0000b</code> will jump <code>0xb</code> (11) bytes, landing at <code>0016</code>. Since the <code>UINT24</code> instruction starts at <code>0015</code>, this is a misaligned jump. SpiderMonkey will then try to run the next byte (<code>0x41</code>), which corresponds to the <code>THIS</code> instruction.</p>
<p>With this, we can execute arbitrary byte code but we’re limited to 3 bytes. Most instructions are either 1 or 3 bytes long. We can run longer sequences of 1-byte instructions by using the first 2 bytes for instructions and setting the last byte to the <code>IFEQ</code> or <code>IFNE</code> opcodes. Since <code>IFEQ</code> and <code>IFNE</code> are 3-byte instructions, they will consume the 2 bytes after.</p>
<p>When writing JavaScript like <code>0x000007,0x000007,0x000007</code>, the resulting bytecode assembly looks like this:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>0000</span>: bc <span>00</span> <span>00</span> <span>07</span>   UINT24 <span>0x000007</span></span></pre></td></tr></tbody></table></figure>
<p>However, when using the misaligned jump, the following VM instructions are executed:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span>0000</span>: bc                       </span></pre></td></tr></tbody></table></figure>
<p>By cleverly selecting <code>IFEQ</code> or <code>IFNE</code> so that the branch is never taken, we can succesfully skip the <code>51 bc</code> bytes from the original <code>POP</code> and <code>UINT24</code> instructions. Instead of <code>NOP</code>s, we can use arbitrary 1-byte instructions, making a very long chain if necessary.</p>
<h2 id="Memory-Corruption"><a href="#Memory-Corruption" title="Memory Corruption"></a>Memory Corruption</h2><p>Arbitrary bytecode execution is cool and all, but to do anything meaningful we want to corrupt some memory. For this, I had to look around a bit and see which instructions do interesting stuff.</p>
<p>After a while, I realized that <code>POP</code>/<code>POP2</code> might be just what I was looking for. They decrement the VM’s stack pointer and do not check if they underflow the stack:</p>
<figure><figcaption><span>jsinterp.c</span><a href="https://github.com/manugarg/pacparser/blob/c4ac28b6c621b8c94f9db40e77e2ea7aee707933/src/spidermonkey/js/src/jsinterp.c#L2349-L2355" target="_blank" rel="noopener">source</a></figcaption><table><tbody><tr><td><pre><span>2349</span></pre></td><td><pre><span>BEGIN_CASE(JSOP_POP)</span></pre></td></tr></tbody></table></figure>
<p>When inspecting the memory around <code>sp</code>, I noticed that the stack frame object lives directly beneath. It contains some interesting things, including a lot of pointers:</p>
<figure><figcaption><span>jsinterp.h</span><a href="https://github.com/manugarg/pacparser/blob/c4ac28b6c621b8c94f9db40e77e2ea7aee707933/src/spidermonkey/js/src/jsinterp.h#L60-L84" target="_blank" rel="noopener">source</a></figcaption><table><tbody><tr><td><pre><span>60</span></pre></td><td><pre><span><span><span>struct</span> <span>JSStackFrame</span> {</span></span></pre></td></tr></tbody></table></figure>
<p>By chaining a bunch of <code>POP2</code>s, we can make the stack pointer point to <code>&amp;fp-&gt;argv</code>. Next time we push something to the stack, we will overwrite <code>fp-&gt;argv</code>. We can then read from and write to <code>fp-&gt;argv</code> using the <code>GETARG</code> and <code>SETARG</code> instructions:</p>
<figure><figcaption><span>jsinterp.c</span><a href="https://github.com/manugarg/pacparser/blob/c4ac28b6c621b8c94f9db40e77e2ea7aee707933/src/spidermonkey/js/src/jsinterp.c#L4599-L4613" target="_blank" rel="noopener">source</a></figcaption><table><tbody><tr><td><pre><span>4599</span></pre></td><td><pre><span>BEGIN_CASE(JSOP_GETARG)</span></pre></td></tr></tbody></table></figure>
<p>We can control <code>slot</code> for these instructions, which is a <code>uint16_t</code> read from the bytecode. This means that we can now read <code>ptr[slot]</code> and write <code>ptr[slot] = val</code>. The only problem is that the stack frame gets corrupted along the way, crashing the VM when returning from the current function. I didn’t investigate why exactly this happens or if I could prevent it. Instead, I just started calling a callback function instead of returning:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>function</span> <span>pwn</span>(<span>a, cb</span>) </span>{</span></pre></td></tr></tbody></table></figure>
<h2 id="Building-an-addrof-Primitive"><a href="#Building-an-addrof-Primitive" title="Building an addrof Primitive"></a>Building an <code>addrof</code> Primitive</h2><p>In this SpiderMonkey version, JavaScript values can be one of multiple types. The value is tagged with a type-specific masked to allow the VM to know the type before using the value. These are the possible types with their masks:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Mask</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>JSObject*</code></td>
<td><code>0b000</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>0b001</code></td>
</tr>
<tr>
<td><code>double*</code></td>
<td><code>0b010</code></td>
</tr>
<tr>
<td><code>JSString*</code></td>
<td><code>0b100</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td><code>0b110</code></td>
</tr>
</tbody>
</table>
<p>As an example, when the value is an object, it will be the raw pointer to the object (<code>obj_ptr &amp; 0b000</code>). When the value is an integer, it will be stored as <code>(int_val &lt;&lt; 1) | 1</code>. When the value is a double or a string, it is a pointer masked with the corresponding mask value.</p>
<p>To convert a raw pointer to a value that can be handled in the JavaScript world, we need to either turn it into an int or a double, or somehow write it into the char array of a string. Ints don’t fit well because we can’t just set the least significant bit to 1. Strings are also inconvenient because we would have to remove the pointer mask to get the char array pointer.</p>
<p>Doubles can be more helpful for us, which becomes clear when we look at them in memory. A value like <code>0x55d9ab4b8c62</code> is identified as a double since it has a <code>2</code> as the least significant hex digit. To access the value, the VM would remove the mask, resulting in <code>0x55d9ab4b8c60</code>, and read the 8 bytes at that address. The bytes <code>3d0ad7a370bd2a40</code> correspond to the IEEE-754 floating point encoding of <code>13.37</code>:</p>
<pre>0x55d9ab4b8c60:  <span>3d 0a d7 a3  70 bd 2a 40</span>   00 00 00 00  00 00 00 00
0x55d9ab4b8c70:  40 00 00 00  00 00 00 c0   80 8c 4b ab  d9 55 00 00
</pre>

<p>However, with our pointer write primitive, we can only write to the double pointer <em>without removing the tag</em> (<code>0x55d9ab4b8c62</code>). This would result in accessing the following memory:</p>
<pre>0x55d9ab4b8c60:  3d 0a <span>d7 a3  70 bd 2a 40   00 00</span> 00 00  00 00 00 00
0x55d9ab4b8c70:  40 00 00 00  00 00 00 c0   80 8c 4b ab  d9 55 00 00
</pre>

<p>Doing such a misaligned write would only overwrite the upper 6 bytes of the double value and “lose” the upper 2 bytes of the value being written since it’s written outside of the double value. Pointers are 8 bytes on 64-bit machines, but they actually only hold 48 bits of information, which is 6 bytes.</p>
<p>This nice coincidence allows us to write a pointer to the misaligned (tagged) double pointer and still have all the relevant bits inside the double value! Writing a pointer of <code>0x0000414141414141</code> to a double would look like this:</p>
<pre>0x55d9ab4b8c60:  3d 0a <span>41 41  41 41 41 41   00 00</span> 00 00  00 00 00 00
0x55d9ab4b8c70:  40 00 00 00  00 00 00 c0   80 8c 4b ab  d9 55 00 00
</pre>

<p>Back in the JavaScript world, we can read the double and manually convert it to its byte representation, resulting in <code>3d0a414141414141</code>. By removing the first 2 bytes and converting from little-endian, we get the original pointer of <code>0x414141414141</code>. Therefore, our <code>addrof</code> primitive can implemented like this:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span><span><span>function</span> <span>addrof</span>(<span>a, double, ptr, cb</span>) </span>{</span></pre></td></tr></tbody></table></figure>
<p>The callback then has to convert the double to its byte representation, for example using <a href="https://gist.github.com/Manouchehri/f4b41c8272db2d6423fa987e844dd9ac" target="_blank" rel="noopener">this JS IEEE-754 implementation</a>.</p>
<h2 id="Leaking-Interesting-Stuff"><a href="#Leaking-Interesting-Stuff" title="Leaking Interesting Stuff"></a>Leaking Interesting Stuff</h2><p>From now on, we just have to do the regular pwn work™. First, we leak the base address of the binary in memory by reading a function pointer. This quite easy with our pointer deref primitive and <code>addrof</code>. All JS objects contain a struct of function pointers in <code>obj-&gt;map-&gt;ops</code>:</p>
<p><img src="https://blog.pspaul.de/posts/ancient-monkey-pwning-a-17-year-old-version-of-spidermonkey/jsobj.svg" alt="JSObject structure"/></p>
<p>By reading the <code>lookupProperty</code> function pointer of a regular JS object, we get the address of the <code>js_LookupProperty</code> function inside the binary. From there, we can calculate the base address by subtracting the function’s offset.</p>
<p>To get the libc base address, we can read one of the global offset table (GOT) entries. All of them are resolved because full RelRO is enabled on the binary. From there we can calculate the address of the <code>system()</code> function which we’ll use to get a shell later.</p>
<h2 id="Getting-a-Shell"><a href="#Getting-a-Shell" title="Getting a Shell"></a>Getting a Shell</h2><p>To hijack the control flow, we can overwrite and call a function pointer. The <code>ops</code> pointers of JS objects are good candidates for this, but the problem is that we don’t fully control the call arguments. Looking at the actual functions, we can see that all of them expect a context pointer as their first argument:</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>JS_HasProperty(JSContext *cx, JSObject *obj, <span>const</span> <span>char</span> *name, JSBool *foundp);</span></pre></td></tr></tbody></table></figure>
<p>Lucky for us, the context object is the same during the runtime of binary and it is stored in the binary’s <code>.bss</code> section:</p>
<pre>0013e1b0  uint64_t myip = 0x0
0013e1b8  uint64_t rt = 0x0
0013e1c0  <span>uint64_t cx = 0x0</span>
0013e1c8  uint64_t global = 0x0
0013e1d0  uint32_t didFirstChecks.0 = 0x0
</pre>

<p>The object itself lives on the heap, so we can leak its address and write to its location to control what the first argument passed to the <code>ops</code> functions points to. To get a shell, we will overwrite the <code>getProperty()</code> function pointer with <code>system()</code> and write our shell command to <code>*cx</code>.</p>
<p>To write arbitrary data, we could use a double value like before, but we can go for a simpler way here. Since ints are shifted and masked with <code>1</code>, we can use it to create a short byte sequence that has the LSB of the first byte set.</p>
<p>For a shell, we can write <code>&#34;sh\x00&#34;</code> as the value, which is <code>736800</code> in raw bytes, or <code>0x6873</code> as a little-endian integer. To accomodate for the value tagging, we have to use the right-shifted value in the JS world (<code>0x3439</code>). In memory, the value will again be our desired byte sequence due to the value tagging (<code>73680000</code>).</p>
<p>With everything in place, we can get our shell by simply accessing <code>obj.x</code>. This JS expression will cause the <code>x</code> property of <code>obj</code> to be retrieved via <code>obj-&gt;map-&gt;ops-&gt;getProperty(cx, ...)</code>. Since the <code>getProperty</code> operation was overwritten with libc’s <code>system()</code> and <code>cx</code> now points to <code>&#34;sh\x00&#34;</code>, this is equivalent to calling <code>system(&#34;sh&#34;)</code> and gives us a shell!</p>
<figure><table><tbody><tr><td><pre><span>1</span></pre></td><td><pre><span>[*] &#39;./pactester&#39;</span></pre></td></tr></tbody></table></figure>
<h2 id="Summary"><a href="#Summary" title="Summary"></a>Summary</h2><p>All of this took me roughly one week to figure out, during which I learned a ton! I attributed most of this time to me not being a regular pwner, but maybe I overestimated how much time can be saved with experience. After the CTF, I realized that I probably should have given more hints to the players because the challenge was only solved once, and the player used different bugs.</p>
<p>If I would create the challenge again, I would give the bug ticket as a hint so people don’t have to find it themselves and can focus on pwning instead. I think the challenge would have been more approachable that way, since the bug allows executing arbitrary bytecode, giving players much more to play around with.</p>
<p>Anyways, I hope you enjoyed this writeup, maybe you also learned a thing or two. It’s interesting how some missing mitigations made exploitation easier (e.g., no constant blinding) while some missing features made it less convenient (e.g., no WASM <code>rwx</code> pages). Maybe I have to create another challenge for next year to have an excuse for learning modern JS engine pwning?</p>
<h2 id="Final-Exploit"><a href="#Final-Exploit" title="Final Exploit"></a>Final Exploit</h2><details></details>

<details></details>

  </div></div>
  </body>
</html>
