<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://unskilled.blog/posts/preemption-in-go-an-introduction/">Original</a>
    <h1>Introduction to Golang Preemption Mechanisms</h1>
    
    <div id="readability-page-1" class="page"><div>
	<article>
		
		

		<section>
			<p>In my post about <a href="https://unskilled.blog/posts/lets-dive-a-tour-of-sync.pool-internals/">the <code>sync.Pool</code> internals</a>, I briefly touched on preemption, but I didn’t explain what it really is about. Let’s fix that.</p>
<p>If you are in France, like me, you just completed your income tax declaration. If the go runtime is the tax administration, cpu-time is money, and preemption would be a letter of reminder. Or a bailiff banging on your door if you’ve been naughty.</p>
<h2 id="what-is-preemption">What is preemption?</h2>
<p>Preemption is one of the ways the go runtime ensures fairness. It distributes the time between all goroutines, so that no goroutine can take all the cpu resources and starve the others. Not only other goroutines could starve, but scheduling could also be delayed, so this could derail into serious problems.</p>
<p>Preemption as we know it today was first introduced in go 1.2, back in 2013. Before that, the go runtime was not preemptive, meaning that it would not enforce time distribution fairness. The whole stuff would rely on the goroutines to play by the rules. It was a time where we could trust each others, we didn’t need to lock our doors, and children could go out all day without parents knowing what they were up to. Ah, the good old days… Where was I again? Oh yes, the go runtime.</p>
<p>So a goroutine could suck up all the cpu-time, starve the others, and delay new ones, until it explicitly gave up control, such as by calling <code>runtime.Gosched()</code> or during I/O operations.</p>
<p>And here’s preemption coming to the rescue. It occurs at so-called “safe-points”, which are places in the code where we know for sure that we can take over control flow from a goroutine without getting into trouble. What I mean by that is that we don’t want to preempt goroutines anytime, but only at places where it is easy to stop them - think about it - what if I suddenly stopped you while taking a dump? It would have been easier to have stopped you before, or after, but not in the middle of it. Not sure about the analogy, but you got it.</p>
<p>The first step towards preemption is using blocked safe-points. These safe-points happens either during deschudling, or when a goroutine is blocked on synchronization primitives, or on a system call. The goroutine is just hanging there doing nothing, so of course it can be preempted. But this is not enough! What if a goroutine does not stop processing stuff, such as crunching numbers?</p>
<h2 id="synchronous-preemption">Synchronous preemption</h2>
<p>Synchronous preemption happens when a goroutine checks for a preemption request: the go runtime communicates its intent to preempt a goroutine, the goroutine “sees” the request and bails out. But there’s something interesting in how this is implemented.</p>
<p>As you may already know, a function begins with a prologue, and ends with an epilogue. These two parts are added by the compiler to do various stuff, preparing and finalizing the function call. In the prologue, there’s a stack bound check, which is a complicated way of saying that we check that there’s enough space on the stack for this call.</p>
<p>Let’s take a look at this engineering masterpiece:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>if</span> <span>sum</span><span>(</span><span>10</span><span>,</span> <span>10</span><span>)</span> <span>!=</span> <span>20</span> <span>{</span>
</span></span><span><span>		<span>panic</span><span>(</span><span>&#34;earth must be flat&#34;</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>sum</span><span>(</span>a<span>,</span> b <span>int</span><span>)</span> <span>int</span> <span>{</span>
</span></span><span><span>	<span>var</span> s <span>int</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> a <span>&gt;</span> <span>0</span> <span>{</span>
</span></span><span><span>		s<span>++</span>
</span></span><span><span>		a<span>--</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>if</span> b <span>&gt;</span> <span>0</span> <span>{</span>
</span></span><span><span>		s<span>++</span>
</span></span><span><span>		b<span>--</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> s <span>==</span> <span>0</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>0</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> s <span>+</span> <span>sum</span><span>(</span>a<span>,</span> b<span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>That’s how the cool kids do it. Now, let’s have a look at what the compiler spits out when confronted with this level of quality, using <code>go tool compile -S</code>:</p>
<div><pre tabindex="0"><code data-lang="asm"><span><span><span>00000</span> <span>CMPQ</span>    <span>SP</span><span>,</span> <span>16</span><span>(</span><span>R14</span><span>)</span>
</span></span><span><span><span>00000</span> <span>TEXT</span>    <span>main.sum</span><span>(</span><span>SB</span><span>),</span> <span>ABIInternal</span><span>,</span> <span>$32-16</span>
</span></span><span><span><span>00004</span> <span>PCDATA</span>  <span>$0</span><span>,</span> <span>$-2</span>
</span></span><span><span><span>00004</span> <span>JLS</span>     <span>89</span>
</span></span><span><span><span>00006</span> <span>PCDATA</span>  <span>$0</span><span>,</span> <span>$-1</span>
</span></span><span><span><span>00006</span> <span>PUSHQ</span>   <span>BP</span>
</span></span><span><span><span>00007</span> <span>MOVQ</span>    <span>SP</span><span>,</span> <span>BP</span>
</span></span><span><span><span>00010</span> <span>SUBQ</span>    <span>$24</span><span>,</span> <span>SP</span>
</span></span><span><span><span>00014</span> <span>FUNCDATA</span>        <span>$0</span><span>,</span> <span>gclocals</span><span>·</span><span>g2BeySu</span><span>+</span><span>wFnoycgXfElmcg</span><span>==</span><span>(</span><span>SB</span><span>)</span>
</span></span><span><span><span>00014</span> <span>FUNCDATA</span>        <span>$1</span><span>,</span> <span>gclocals</span><span>·</span><span>g2BeySu</span><span>+</span><span>wFnoycgXfElmcg</span><span>==</span><span>(</span><span>SB</span><span>)</span>
</span></span><span><span><span>00014</span> <span>FUNCDATA</span>        <span>$5</span><span>,</span> <span>main.sum.arginfo1</span><span>(</span><span>SB</span><span>)</span>
</span></span><span><span><span>00014</span> <span>FUNCDATA</span>        <span>$6</span><span>,</span> <span>main.sum.argliveinfo</span><span>(</span><span>SB</span><span>)</span>
</span></span><span><span><span>00014</span> <span>PCDATA</span>  <span>$3</span><span>,</span> <span>$1</span>
</span></span><span><span><span>00014</span> <span>LEAQ</span>    <span>-</span><span>1</span><span>(</span><span>AX</span><span>),</span> <span>CX</span>
</span></span><span><span><span>00018</span> <span>LEAQ</span>    <span>-</span><span>1</span><span>(</span><span>BX</span><span>),</span> <span>DX</span>
</span></span><span><span><span>00022</span> <span>TESTQ</span>   <span>AX</span><span>,</span> <span>AX</span>
</span></span><span><span><span>00025</span> <span>SETGT</span>   <span>SIB</span>
</span></span><span><span><span>00029</span> <span>CMOVQGT</span> <span>CX</span><span>,</span> <span>AX</span>
</span></span><span><span><span>00033</span> <span>MOVBLZX</span> <span>SIB</span><span>,</span> <span>CX</span>
</span></span><span><span><span>00037</span> <span>LEAQ</span>    <span>1</span><span>(</span><span>CX</span><span>),</span> <span>SI</span>
</span></span><span><span><span>00041</span> <span>TESTQ</span>   <span>BX</span><span>,</span> <span>BX</span>
</span></span><span><span><span>00044</span> <span>CMOVQGT</span> <span>SI</span><span>,</span> <span>CX</span>
</span></span><span><span><span>00048</span> <span>CMOVQGT</span> <span>DX</span><span>,</span> <span>BX</span>
</span></span><span><span><span>00052</span> <span>TESTQ</span>   <span>CX</span><span>,</span> <span>CX</span>
</span></span><span><span><span>00055</span> <span>JNE</span>     <span>65</span>
</span></span><span><span><span>00057</span> <span>XORL</span>    <span>AX</span><span>,</span> <span>AX</span>
</span></span><span><span><span>00059</span> <span>ADDQ</span>    <span>$24</span><span>,</span> <span>SP</span>
</span></span><span><span><span>00063</span> <span>POPQ</span>    <span>BP</span>
</span></span><span><span><span>00064</span> <span>RET</span>
</span></span><span><span><span>00065</span> <span>MOVQ</span>    <span>CX</span><span>,</span> <span>main.s</span><span>+</span><span>16</span><span>(</span><span>SP</span><span>)</span>
</span></span><span><span><span>00070</span> <span>PCDATA</span>  <span>$1</span><span>,</span> <span>$0</span>
</span></span><span><span><span>00070</span> <span>CALL</span>    <span>main.sum</span><span>(</span><span>SB</span><span>)</span>
</span></span><span><span><span>00075</span> <span>MOVQ</span>    <span>main.s</span><span>+</span><span>16</span><span>(</span><span>SP</span><span>),</span> <span>CX</span>
</span></span><span><span><span>00080</span> <span>ADDQ</span>    <span>CX</span><span>,</span> <span>AX</span>
</span></span><span><span><span>00083</span> <span>ADDQ</span>    <span>$24</span><span>,</span> <span>SP</span>
</span></span><span><span><span>00087</span> <span>POPQ</span>    <span>BP</span>
</span></span><span><span><span>00088</span> <span>RET</span>
</span></span><span><span><span>00089</span> <span>NOP</span>
</span></span><span><span><span>00089</span> <span>PCDATA</span>  <span>$1</span><span>,</span> <span>$-1</span>
</span></span><span><span><span>00089</span> <span>PCDATA</span>  <span>$0</span><span>,</span> <span>$-2</span>
</span></span><span><span><span>00089</span> <span>MOVQ</span>    <span>AX</span><span>,</span> <span>8</span><span>(</span><span>SP</span><span>)</span>
</span></span><span><span><span>00094</span> <span>MOVQ</span>    <span>BX</span><span>,</span> <span>16</span><span>(</span><span>SP</span><span>)</span>
</span></span><span><span><span>00099</span> <span>CALL</span>    <span>runtime.morestack_noctxt</span><span>(</span><span>SB</span><span>)</span>
</span></span><span><span><span>00104</span> <span>PCDATA</span>  <span>$0</span><span>,</span> <span>$-1</span>
</span></span><span><span><span>00104</span> <span>MOVQ</span>    <span>8</span><span>(</span><span>SP</span><span>),</span> <span>AX</span>
</span></span><span><span><span>00109</span> <span>MOVQ</span>    <span>16</span><span>(</span><span>SP</span><span>),</span> <span>BX</span>
</span></span><span><span><span>00114</span> <span>JMP</span>     <span>0</span>
</span></span></code></pre></div><p>The first instruction <code>CMPQ SP, 16(R14)</code> compares the stack pointer with the stack guard. Then at <code>00004</code>, there’s a conditional jump <code>JLS 89</code> which says that we should jump at 89 if the stack pointer was greater than or equal to the stack guard, which would indicate that there’s not enough space in the stack for this call.
Then, between <code>00089</code> and <code>00099</code>, we save <code>AX</code> and <code>BX</code> onto the stack so that we do not lose them later on, and call <code>runtime.morestack_noctxt</code>.</p>
<p>This <code>runtime.morestack_noctxt</code> is more or less the same as <code>runtime.morestack</code>which is implemented using assembly, and in the end, it calls <code>runtime.newstack</code> - just trust me on this.</p>
<p><code>runtime.newstack</code>’s job is to allocate a bigger stack, and relocate the old one onto it. Let’s have a quick look at it:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>newstack</span><span>()</span> <span>{</span>
</span></span><span><span>    <span>[</span><span>...</span><span>]</span>
</span></span><span><span>    stackguard0 <span>:=</span> atomic<span>.</span><span>Loaduintptr</span><span>(</span><span>&amp;</span>gp<span>.</span>stackguard0<span>)</span>
</span></span><span><span>    preempt <span>:=</span> stackguard0 <span>==</span> stackPreempt
</span></span><span><span>	<span>if</span> preempt <span>{</span>
</span></span><span><span>		<span>if</span> <span>!</span><span>canPreemptM</span><span>(</span>thisg<span>.</span>m<span>)</span> <span>{</span>
</span></span><span><span>			<span>// Let the goroutine keep running for now.
</span></span></span><span><span><span></span>			<span>// gp-&gt;preempt is set, so it will be preempted next time.
</span></span></span><span><span><span></span>			gp<span>.</span>stackguard0 <span>=</span> gp<span>.</span>stack<span>.</span>lo <span>+</span> stackGuard
</span></span><span><span>			<span>gogo</span><span>(</span><span>&amp;</span>gp<span>.</span>sched<span>)</span> <span>// never return
</span></span></span><span><span><span></span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>[</span><span>...</span><span>]</span>
</span></span><span><span>
</span></span><span><span>    <span>if</span> preempt <span>{</span>
</span></span><span><span>		<span>[</span><span>...</span><span>]</span>
</span></span><span><span>		<span>// Act like goroutine called runtime.Gosched.
</span></span></span><span><span><span></span>		<span>gopreempt_m</span><span>(</span>gp<span>)</span> <span>// never return
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>[</span><span>...</span><span>]</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>And here it is: <code>newstack</code> contains code related to preemption. It checks if the stack guard was equal to <code>stackPreempt</code>, which is <code>0xfffffade</code>, in which case it fixes the stack guard and preempt right now, calling <code>gopreempt_m</code>, which will act as if the goroutine itself called <code>runtime.Gosched()</code>.</p>
<p>This is how the runtime forces preemption at the next function prologue: it poisons the stackguard of the goroutine it wants to preempt, and waits for the next function prologue to fail, as <code>SP</code> is always greater than <code>0xfffffade</code>. Using that trick, we ensure that the goroutine is at a safe-point, in a function prologue. It also does not cost a dime: should the runtime not have preempted the goroutine, the stack bound check would have happened anyway.</p>
<p>But what if the <code>sum</code> function was crunching number in a tight loop, maybe with a couple inlined functions and other optimizations? There would not be any function prologue to check against the stack guard. The stack bound check technique is a letter of reminder - now we need to call the bailiff.</p>
<h2 id="asynchronous-preemption">Asynchronous preemption</h2>
<p>Asynchronous preemption is a more recent addition to the go runtime. It was introduced in go 1.14, in 2020, to fix tight loop preemption, which was getting worse with compiler optimizations getting better. It works by sending a <code>SIGURG</code> signal to the thread where the goroutine is running:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>// preemptM sends a preemption request to mp. This request may be
</span></span></span><span><span><span>// handled asynchronously and may be coalesced with other requests to
</span></span></span><span><span><span>// the M. When the request is received, if the running G or P are
</span></span></span><span><span><span>// marked for preemption and the goroutine is at an asynchronous
</span></span></span><span><span><span>// safe-point, it will preempt the goroutine. It always atomically
</span></span></span><span><span><span>// increments mp.preemptGen after handling a preemption request.
</span></span></span><span><span><span></span><span>func</span> <span>preemptM</span><span>(</span>mp <span>*</span>m<span>)</span> <span>{</span>
</span></span><span><span>	<span>// On Darwin, don&#39;t try to preempt threads during exec.
</span></span></span><span><span><span></span>	<span>// Issue #41702.
</span></span></span><span><span><span></span>	<span>if</span> GOOS <span>==</span> <span>&#34;darwin&#34;</span> <span>||</span> GOOS <span>==</span> <span>&#34;ios&#34;</span> <span>{</span>
</span></span><span><span>		execLock<span>.</span><span>rlock</span><span>()</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> mp<span>.</span>signalPending<span>.</span><span>CompareAndSwap</span><span>(</span><span>0</span><span>,</span> <span>1</span><span>)</span> <span>{</span>
</span></span><span><span>		<span>if</span> GOOS <span>==</span> <span>&#34;darwin&#34;</span> <span>||</span> GOOS <span>==</span> <span>&#34;ios&#34;</span> <span>{</span>
</span></span><span><span>			pendingPreemptSignals<span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>
</span></span><span><span>		<span>// If multiple threads are preempting the same M, it may send many
</span></span></span><span><span><span></span>		<span>// signals to the same M such that it hardly make progress, causing
</span></span></span><span><span><span></span>		<span>// live-lock problem. Apparently this could happen on darwin. See
</span></span></span><span><span><span></span>		<span>// issue #37741.
</span></span></span><span><span><span></span>		<span>// Only send a signal if there isn&#39;t already one pending.
</span></span></span><span><span><span></span>		<span>signalM</span><span>(</span>mp<span>,</span> sigPreempt<span>)</span> <span>// sigPreempt is SIGURG
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> GOOS <span>==</span> <span>&#34;darwin&#34;</span> <span>||</span> GOOS <span>==</span> <span>&#34;ios&#34;</span> <span>{</span>
</span></span><span><span>		execLock<span>.</span><span>runlock</span><span>()</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>On the other side, in the thread, a signal handler listens for it:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>sighandler</span><span>(</span>sig <span>uint32</span><span>,</span> info <span>*</span>siginfo<span>,</span> ctxt unsafe<span>.</span>Pointer<span>,</span> gp <span>*</span>g<span>)</span> <span>{</span>
</span></span><span><span>	<span>[</span><span>...</span><span>]</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> sig <span>==</span> sigPreempt <span>&amp;&amp;</span> debug<span>.</span>asyncpreemptoff <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>!</span>delayedSignal <span>{</span>
</span></span><span><span>		<span>// Might be a preemption signal.
</span></span></span><span><span><span></span>		<span>doSigPreempt</span><span>(</span>gp<span>,</span> c<span>)</span>
</span></span><span><span>		<span>// Even if this was definitely a preemption signal, it
</span></span></span><span><span><span></span>		<span>// may have been coalesced with another signal, so we
</span></span></span><span><span><span></span>		<span>// still let it through to the application.
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>    <span>[</span><span>...</span><span>]</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// doSigPreempt handles a preemption signal on gp.
</span></span></span><span><span><span></span><span>func</span> <span>doSigPreempt</span><span>(</span>gp <span>*</span>g<span>,</span> ctxt <span>*</span>sigctxt<span>)</span> <span>{</span>
</span></span><span><span>	<span>// Check if this G wants to be preempted and is safe to
</span></span></span><span><span><span></span>	<span>// preempt.
</span></span></span><span><span><span></span>	<span>if</span> <span>wantAsyncPreempt</span><span>(</span>gp<span>)</span> <span>{</span>
</span></span><span><span>		<span>if</span> ok<span>,</span> newpc <span>:=</span> <span>isAsyncSafePoint</span><span>(</span>gp<span>,</span> ctxt<span>.</span><span>sigpc</span><span>(),</span> ctxt<span>.</span><span>sigsp</span><span>(),</span> ctxt<span>.</span><span>siglr</span><span>());</span> ok <span>{</span>
</span></span><span><span>			<span>// Adjust the PC and inject a call to asyncPreempt.
</span></span></span><span><span><span></span>			ctxt<span>.</span><span>pushCall</span><span>(</span>abi<span>.</span><span>FuncPCABI0</span><span>(</span>asyncPreempt<span>),</span> newpc<span>)</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>// Acknowledge the preemption.
</span></span></span><span><span><span></span>	gp<span>.</span>m<span>.</span>preemptGen<span>.</span><span>Add</span><span>(</span><span>1</span><span>)</span>
</span></span><span><span>	gp<span>.</span>m<span>.</span>signalPending<span>.</span><span>Store</span><span>(</span><span>0</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> GOOS <span>==</span> <span>&#34;darwin&#34;</span> <span>||</span> GOOS <span>==</span> <span>&#34;ios&#34;</span> <span>{</span>
</span></span><span><span>		pendingPreemptSignals<span>.</span><span>Add</span><span>(</span><span>-</span><span>1</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Here, <code>doSigPreempt</code> checks if we are at an asynchronous safe-point, and forces the goroutine to get into a call to <code>asyncPreempt</code>. Here is <code>asyncPreempt</code>:</p>
<div><pre tabindex="0"><code data-lang="go"><span><span><span>// asyncPreempt saves all user registers and calls asyncPreempt2.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// When stack scanning encounters an asyncPreempt frame, it scans that
</span></span></span><span><span><span>// frame and its parent frame conservatively.
</span></span></span><span><span><span>//
</span></span></span><span><span><span>// asyncPreempt is implemented in assembly.
</span></span></span><span><span><span></span><span>func</span> <span>asyncPreempt</span><span>()</span>
</span></span><span><span>
</span></span><span><span><span>//go:nosplit
</span></span></span><span><span><span></span><span>func</span> <span>asyncPreempt2</span><span>()</span> <span>{</span>
</span></span><span><span>	gp <span>:=</span> <span>getg</span><span>()</span>
</span></span><span><span>	gp<span>.</span>asyncSafePoint <span>=</span> <span>true</span>
</span></span><span><span>	<span>if</span> gp<span>.</span>preemptStop <span>{</span>
</span></span><span><span>		<span>mcall</span><span>(</span>preemptPark<span>)</span>
</span></span><span><span>	<span>}</span> <span>else</span> <span>{</span>
</span></span><span><span>		<span>mcall</span><span>(</span>gopreempt_m<span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	gp<span>.</span>asyncSafePoint <span>=</span> <span>false</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>As said in the comments, <code>asyncPreempt</code> spills all registers to save the context, and gets into <code>asyncPreempt2</code>, which in turn goes into <code>gopreempt_m</code>, that will act as if the goroutine just called <code>runtime.Gosched()</code>.</p>
<p>If we simplify things a little, we can say that when the runtime requests synchronous preemption and poisons the stack guard, it also prepares for asynchronous preemption. The goroutine has <a href="https://golang.org/cl/21503">around 10 microseconds</a> to get preempted, or the SIGURG signal will be sent to its thread.</p>
<p>I hope this cleared things up a little. Now go have fun!</p>

		</section>

		
		<!-- begin comments //-->
		
        
        <!-- end comments //-->
	</article>
</div></div>
  </body>
</html>
