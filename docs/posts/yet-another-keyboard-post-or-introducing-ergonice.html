<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://val.packett.cool/blog/ergonice/">Original</a>
    <h1>Yet another keyboard post, or, introducing ErgoNICE</h1>
    
    <div id="readability-page-1" class="page"><p>I made a custom split mechanical keyboard! Because it&#39;s me, this involved things like contributing to a PCB design tool and discovering a ridiculously optimized way to read a keyboard matrix.</p><div>
		<p>A whole decade ago (wow!) I read a blog post called “<a href="https://stevelosh.com/blog/2012/10/a-modern-space-cadet/">A Modern Space Cadet</a>”
and… well, started caring about keyboards.
I’ve adopted quite a few of the software tricks right there and then: shifts-as-parens and
capslock-as-control-and-escape.</p>
<p>The hardware part—the whole mechanical keyboard thing—took me a couple years to get to.
I was only using a MacBook Air when the post came out, but eventually as I got a desktop,
I had purchased my first mech which was a Leopold with original Cherry MX Brown switches.
I’ve used it for several years, but eventually I found myself wanting more.
Specifically, clicky switches and the ergonomics of the split form factor.
In 2020 I purchased <a href="https://a.aliexpress.com/_dVJsSpR">this AliExpress split keyboard</a> from a manufacturer
called “Spider Island”. I’ve <a href="https://github.com/qmk/qmk_firmware/pull/9900">ported QMK to it</a>, because of course.
It felt like a nice upgrade at the time, though the clone MX Blue switches weren’t the highest quality (as in, a couple
started having weird phantom actuations) and the SATA cable connection between the halves being flaky was annoying.</p>
<p>Around the end of 2021 I was looking at higher quality split options like the <a href="https://dygma.com/products/dygma-raise">Dygma Raise</a>
and the <a href="https://www.zsa.io/moonlander/">ZSA Moonlander</a> and… decided that I was too weird for either of them
and would rather spend money on fabrication and parts for something fully custom.
I think <a href="https://www.youtube.com/watch?v=UKfeJrRIcxw">this video</a> might have been the final inspiration.</p>
<p>So, I started thinking about what I actually wanted and came up with this list of requirements:</p>
<ul>
<li>column-staggered layout like the famous <a href="https://www.ergodox.io/">ErgoDox</a></li>
<li>nice clicky switches (after some YouTube-watching the choice was clear: <a href="https://www.youtube.com/watch?v=JaU3GkBKyNQ">Kailh Box Jade</a>!)</li>
<li>“floating key” enclosure design (why is that the common term anyway? I always wanted to call it “borderless”! because it doesn’t have a border, come on!)</li>
<li>for connections: USB Type-C to the host, anything reliable between the halves</li>
</ul>
<p>And a list of extra “wants”:</p>
<ul>
<li>volume control knob (easy)</li>
<li>pins for connecting external buttons like a big red panic button or a <a href="https://hackaday.com/2012/06/21/building-a-clutch-for-vim/">vim pedal</a></li>
<li>a magnetic connector for add-on modules like trackballs, like on the <a href="https://ultimatehackingkeyboard.com/">UHKB</a>?</li>
<li>a 3.3V TTL output-only serial port header, for a “teletype mode” i.e. directly typing into the UART of something like an RPi?</li>
<li>maybe analog input on WASD keys for gaming too?</li>
</ul>
<p>Spoiler alert: I didn’t successfully implement all the experimental stuff :)
But I’m really happy with the result!</p>
<figure>
	<picture>
		<source type="image/avif" srcset="ergonice-result.avif"/>
		<img alt="End result, the keyboard in its full glory" src="https://val.packett.cool/blog/ergonice/ergonice-result.jpg" width="5643" height="2665" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>So, here’s how we got there…</p>
<h2 id="learning-pcb-design" tabindex="-1"><a href="#learning-pcb-design"><span>Learning PCB design</span></a></h2>
<p>The first thing you need to make a PCB-based keyboard is, well, being able to design PCBs!
So I watched <a href="https://www.youtube.com/watch?v=C7-8nUU6e3E">a KiCad tutorial on YouTube</a> to learn and…
did not start using KiCad. Because you see, I have a terminal case of hipster-ism :)
So I started to play around with the far less popular <a href="https://horizon-eda.org/">Horizon EDA</a> instead and it was an absolute dream.
What a beautiful, coherent, smart piece of software.</p>
<p>Before actually going for the full keyboard, I’ve decided to make a proof-of-concept: a little dev board
basically containing what would be the brain of the keyboard (I picked the STM32L1 family because it was
less affected by the chip shortage and, you know, power-saving sounds good) and pins.
Tiny boards are a lot cheaper to manufacture, so if something went wrong, it wouldn’t be <em>that</em> much of a loss.
So I designed it, uploaded it to JLCPCB, paid some money and… success! It worked perfectly!</p>

<p>I called this board <a href="https://codeberg.org/valpackett/ferrispark">Ferrispark</a> as a reference to Ferris the Rust mascot
and Digispark, the board whose form factor (18×29 mm) this one fits in.
With that little thingy in hand, it was possible to experiment with firmware stuff while waiting for the keyboard PCB to be manufactured and shipped.
But first…</p>
<h2 id="layout" tabindex="-1"><a href="#layout"><span>Layout</span></a></h2>
<p>Unlike “normal” keyboards that come with boring standard ANSI/ISO layouts, enthusiast keyboards are very diverse,
and with a fully custom build possibilities are truly endless. One can <a href="https://www.youtube.com/watch?v=5RN_4PQ0j1A">try to get away with very few keys</a>
or <a href="https://twitter.com/Foone/status/1489430212768985089">make an unhinged meme board</a> or whatever.
But I was after something practical, tailored to my habits, based on ergonomic innovations but not <em>too</em> different from standard layouts.</p>
<p>So I opened <a href="http://www.keyboard-layout-editor.com/">everyone’s favorite non-FOSS (boo) layout editor web app</a>, loaded the Ergodox preset,
removed all the unassigned keys surrounding the core clusters, and started adding keys that made sense to me.</p>
<p>The first thing I added was <em>two</em> columns on the right side that kinda just bring back the punctuation as it is on ANSI.
This felt really important to me because it’s not just about keeping the habits regarding the <code>{[&lt;:;&#39;&#34;&gt;]}</code> stuff.
Some non-Latin scripts such as <a href="https://en.wikipedia.org/wiki/JCUKEN">Cyrillic</a> have a lot of letters, so those two columns have actual letters on them when typing those.
Coming up with alternatives (like chords) for <em>that</em> seemed like more of a nightmare than just for punctuation.
By the way, I added these columns without shifting them down, so they ended up as a 3-wide ortholinear grid cluster on the right end of the layout —
I quickly realized that it would be a good fit for a numpad on an alternate layer too!</p>
<p>Then I started adding modifiers and other miscellaneous keys. I’ve added shifts where my fingers expect them to be
(since I use shifts-as-parentheses, the “just one shift key” idea from minimalist boards is really not for me).
For the thumb clusters, I’ve added the most important text actions—Space, Tab, Backspace, Return—as large keys.
I’ve added a dedicated actual Compose key because I use one. Then I started noticing that the key count was climbing up.
Dangerously close to a funny number, even. So I’ve added four extra “macro” keys, some really extra stuff like “menu”,
and ended up with exactly 69 keys. That instantly solved the hard problem of naming things: the board was called “ErgoNICE” from that point on! :)
Here’s how the layout looks:</p>
<figure>
	<picture>
		<img alt="ErgoNICE layout illustration" src="https://val.packett.cool/blog/ergonice/layout.svg" width="941" height="394.83" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>(This is the <em>physical</em> layout, so you see QWERTY here. I actually type on <a href="https://colemak.com/">Colemak</a> though!)</p>
<h2 id="pcbs" tabindex="-1"><a href="#pcbs"><span>PCBs</span></a></h2>
<p>Before actually designing the PCB, I started looking at existing keyboard designs (nearly all in KiCad), importing various parts
into Horizon, purchasing extra components like the rotary volume knob and headphone jacks on AliExpress and modeling them in Horizon,
and otherwise doing various preparations.</p>
<p>Keyboard PCBs aren’t rocket science. There are basically two ways to connect the keyswitches to the MCU: <a href="http://blog.komar.be/how-to-make-a-keyboard-the-matrix/">in a matrix</a>
and directly. With a compact split keyboard, direct is more feasible than ever, you don’t even need <em>that</em> huge of a microcontroller,
so I actually saw that solution in one of the designs I was looking at. But my choice of MCU was somewhat limited by the chip shortage,
and my board wasn’t <em>that</em> compact, and I wasn’t looking forward to routing all the direct connections with just 2 layers
(which was the limit for non-green boards on JLCPCB and I just <em>waaaanted</em> a black one even though it won’t be visible),
so the obvious decision was to go with a matrix with diodes on every switch.</p>
<p>The other decision I made early on was that the left half would contain the microcontroller and would be assembled by JLCPCB with a ton of SMD parts,
while the right one I would entirely hand-solder at home, using parts I already owned when possible.
And that would be… through-hole diodes and the <a href="https://www.digikey.com/en/products/detail/microchip-technology/MCP23017-E-SP/894272">MCP23017-E/SP</a>
input/output expander. Yeah, <em>the DIP package variant</em>. Because that’s what I purchased about 10 years ago (!) from
an Arduino stuff store when I was first experimenting with electronics. How convenient!</p>
<p>Speaking of diodes, something I saw and really liked was this <a href="https://github.com/keebio/Keebio-Parts.pretty/blob/c7ae3b44674679f4d767767c002fed1eacd414a1/Diode-Hybrid-Back.kicad_mod">footprint for either a surface-mount or through-hole diode</a>.
However you can’t just import that straightforwardly into Horizon. KiCad is fine with multiple pads/holes sharing a name, and
will just collapse them into one pad. Horizon is a lot more strict: each pad must have its own unique name, and if you want to construct something fancy like that,
you need to do it inside of a padstack. Thankfully, Horizon’s parametric padstack system is extremely capable. It’s based on a little
stack-based scripting language for repositioning everything based on whatever logic you want. However it was missing the ability
to reposition holes from the script, so I’ve had to <a href="https://github.com/horizon-eda/horizon/pull/644">add it</a>, and then:</p>
<figure>
	<picture>
		<source type="image/avif" srcset="padstack.avif"/>
		<img alt="TH-and-SMD padstack loaded in Horizon EDA" src="https://val.packett.cool/blog/ergonice/padstack.jpg" width="2400" height="1536" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>So. Anyway. Actual keyboard design time. You can view <a href="https://val.packett.cool/blog/ergonice/ergonice-sch.pdf">the full schematic as a PDF here</a>.
There’s not that much to say: it contains the aforementioned matrix (well, two of them, left and right), the microcontroller and everything it requires,
the USB-C connector with <a href="https://hackaday.com/2019/07/16/exploring-the-raspberry-pi-4-usb-c-issue-in-depth/">correctly separated</a> CC resistors,
TRRS audio connectors, various pin connectors (debug header, extras like external buttons),
the rotary knob with required circuitry… oh, and a bunch of various protection. Even though I’ve noticed that various
DIY keyboard designs don’t seem to do much of it, I was really into the idea of extra safety, so I put resistors on all the external-facing pins,
transistors for reverse polarity protection on power inputs, a USBLC6 IC on the USB lines, and so on.</p>
<figure>
	<picture>
		<img alt="ErgoNICE schematic loaded in Horizon EDA" src="https://val.packett.cool/blog/ergonice/ergonice-eda-sch.png" width="2400" height="1536" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>Layout started with feeding the JSON output of the keyboard-layout-editor website to another website, <a href="http://www.keyboardcad.com/">Keyboard CAD Assistant</a>.
It produces DXF files that are supposed to be used for cutting a plate on a CNC router, but I actually needed it for the PCB.
I’ve imported the DXF into Horizon EDA, drew polygons with diagonals over each key square, and got precise centers of each key —
exactly what’s necessary to position the keyswitches!</p>
<p>Then I drew the outlines of the halves, positioned all the other components, routed the tracks… everything as expected.
Routing can be quite fun, especially when the EDA tool looks this nice (this is the “Rust” color scheme, ha):</p>
<figure>
	<picture>
		<source type="image/avif" srcset="ergonice-eda-pcb.avif"/>
		<img alt="ErgoNICE board loaded in Horizon EDA" src="https://val.packett.cool/blog/ergonice/ergonice-eda-pcb.png" width="2400" height="1536" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>After getting pretty confident that the board was correct (the design rules check in Horizon is pretty helpful!) I’ve sent it off to manufacturing.
A couple weeks later, I received the exciting notification from the post office. The long-awaited package from China!</p>

<p>Here’s a comparison with the 3D preview in Horizon. The real thing always looks amazing!</p>

<p>If you want to play around with the PCB design files in Horizon EDA yourself, it’s in <a href="https://codeberg.org/valpackett/ergonice/src/branch/trunk/pcb-ergonice">the <code>pcb-ergonice</code> directory in the repo</a>.
And in the <a href="https://codeberg.org/valpackett/ergonice/releases/tag/r1">release downloads</a>, there is an export with Gerber files and BOM/CPL for assembly.
Disclaimer: the revision 1 which is published there is slightly different from the revision 0 which I physically have built. Keep reading to see the bug that I fixed there!</p>
<h3 id="analog-input" tabindex="-1"><a href="#analog-input"><span>Analog input?</span></a></h3>
<p>Analog keys are a pretty fun thing for gaming, allowing you to <a href="https://www.youtube.com/watch?v=1WNI-f6QDPQ">move slowly in CS for example</a>.
I stumbled upon <a href="https://alltrons.com/analog-keyboard-technology/">these people here</a> that were trying to commercially sell add-on flex PCBs
for adding the capability to an otherwise normal keyboard and began wondering if it’s possible to just DIY it.
It seems to be a bit of a scary topic because they have a patent in some jurisdictions, but who would go after a non-commercial personal project?
So, their technique is just using a <a href="https://www.ti.com/product/LDC1614">Texas Instruments inductance to digital converter</a> with a PCB coil.
Luckily, these chips were easily available on JLCPCB’s assembly service (though not cheap), so I just went ahead with the experiment.
That is, I designed a little “evaluation board”, suspiciously shaped to fit under the keyboard PCB’s WASD cluster and connect to it using 2.54mm headers :)</p>
<p>The interesting part of the design process is of course the PCB coils. TI provides <a href="https://webench.ti.com/wb5/LDC/#/spirals">an online tool</a> for generating them.
It supports some export… into a couple commercial EDA tools. But I found a way get the results into Horizon. Get this:
export as an EAGLE project, open that in KiCad, export the coil as SVG, clean it up in Inkscape (merge into one SVG path), export as DXF R12,
and finally import into Horizon with a downscaling factor of 10000 because reasons. Oof, it’s there! But we can’t connect anything to it,
because it’s just lines, not tracks. And somehow they’re not even all connected.</p>
<p>Naturally, this was an opportunity to dig into Horizon EDA’s codebase and <a href="https://github.com/horizon-eda/horizon/pull/639">add some new tools</a>!
This was a very enjoyable experience, and with some quick feedback from the author of Horizon I split one of the tools into two, and here they are:
“select connected lines”, “merge duplicate junctions”, and “lines to tracks”. With Horizon becoming this much better, the board was easy to make.
This is how it looked:</p>

<p>To try it out, I wrote a <a href="https://codeberg.org/valpackett/ldc1x1x">Rust embedded-hal driver for the LDC1x1x chips</a> and
an <a href="https://codeberg.org/valpackett/freebsd-embedded-hal">embedded-hal implementation for FreeBSD userspace APIs</a>
so that I could test it directly on my PC with a CP2112 USB-to-I²C adapter, just piping the output from a demo program into
<a href="https://github.com/mogenson/ploot">ploot</a>.</p>
<p>What I’ve found is that while the stream of numbers was indeed correlated with how far the key was pushed down,
it was not good. Whether I was catching the movement of the finger or the spring was pretty confusing, especially
when under the actual keyboard PCB. The fact that the switches of my choice have a click bar might’ve been a negative impact,
the distance to the switch from behind of the PCB was probably a problem, and the large 4-layer coil probably wasn’t quite compensating
for that (or was it actually just bad?).</p>
<p>Either way, I couldn’t attach it to the keyboard because it turns out I’ve made a silly mistake in the schematic:
I forgot to connect one of the columns to the microcontroller :D
So I ended up running a bodge wire to one of the holes intended for the LDC board:</p>
<figure>
	<picture>
		<img alt="ErgoNICE left side PCB with bodge wire" src="https://val.packett.cool/blog/ergonice/ergonice-pcb-bodge.jpg" width="1269" height="685" loading="lazy" decoding="async"/>
	</picture>
</figure>
<h2 id="case" tabindex="-1"><a href="#case"><span>Case</span></a></h2>
<p>There are many ways to make a keyboard enclosure, but as I was into 3D printing, that question was already answered.
How convenient that a split keyboard fits well into the dimentions of an Ender 3 build plate!
I’ve been using <a href="https://github.com/realthunder/FreeCAD">realthunder’s FreeCAD fork</a> for modeling 3D printed parts,
so that’s what I used for this one as well.
Of course FreeCAD’s UI is clunky and its core is <a href="https://github.com/realthunder/FreeCAD/issues?q=fillet+crash">crashy</a>,
but I’d rather not involve proprietary software in this project.
Having CAD files in an open format is that valuable to me.
And before someone starts preaching code-CAD like cadquery to me:
sorry, I love sketching with a mouse and hate school-style math too much :D</p>
<p>I started out with exporting a 3D model of the boards and components on them as a STEP file from Horizon and importing it into FreeCAD.
In the file, everything was cleanly separated out, i.e. each component was its own body. However due to format limitations
every instance of the same part (e.g. every switch) is its own independent body, which takes up a lot of space on disk.
I wrote a Python script in FreeCAD that would take the currently selected bodies and replace all of them except the first one
with a link to the first one, removing the duplication of actual 3D model data. (Sadly I lost that script by now, but it was tiny.)</p>
<p>With a model of the boards, it wasn’t too hard to make an enclosure around them. The enclosure has two main parts.
The plate is a flat extrusion that gets permanently attached between top of the PCB and the bottom halves of the switches.
The tray is the rest of the enclosure, attached to the plate with screws.
In addition there are tenting wedges that attach to the bottom of the tray, and the actual knob that goes on the rotary encoder.
This is how it all looks in FreeCAD:</p>

<p>Here’s a look into the tray from the above. I’ve added these supports underneath each key for extra rigidity.
Otherwise it’s… not that remarkable?</p>
<figure>
	<picture>
		<source type="image/avif" srcset="ergonice-case-cad-tray.avif"/>
		<img alt="ErgoNICE tray in FreeCAD" src="https://val.packett.cool/blog/ergonice/ergonice-case-cad-tray.png" width="2391" height="1245" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>I printed the parts on a heavily modified Ender 3 Pro out of dark gray sparkly PETG.
It turned out pretty well! Everything fit together easily, the tolerances for things like the space for the key switches
were exactly right, it looks very decent for a DIY object.
Again, this is how it looks:</p>
<figure>
	<picture>
		<source type="image/avif" srcset="ergonice-result.avif"/>
		<img alt="End result, the keyboard in its full glory" src="https://val.packett.cool/blog/ergonice/ergonice-result.jpg" width="5643" height="2665" loading="lazy" decoding="async"/>
	</picture>
</figure>
<p>If you want to play around with the source model, it’s <a href="https://codeberg.org/valpackett/ergonice/src/branch/trunk/case">all of that XML in the <code>case</code> directory</a>
stored in the repo, saved using the version-control-friendly “save as directory” functionality of realthunder’s FreeCAD.
And in the <a href="https://codeberg.org/valpackett/ergonice/releases/tag/r1">release downloads</a>, there’s an archive with STL and STEP exports.</p>
<h2 id="firmware" tabindex="-1"><a href="#firmware"><span>Firmware</span></a></h2>
<p>Now that everything is put together physically, we need to put software on the tiny little computer that runs the keyboard
(it’s computers all the way down!).</p>
<p>The most common way to get some keyboard firmware going is to use a popular project like <a href="https://qmk.fm/">QMK</a> (a classic
that started on AVR and added Arm later) or <a href="https://zmk.dev/">ZMK</a> (popular with Bluetooth, based on a whole RTOS called Zephyr and
configured with <a href="https://www.devicetree.org/">flattened device trees</a>).
But of course, “common way” means it’s not what I’m going to do.</p>
<h3 id="rust-on-stm32l1" tabindex="-1"><a href="#rust-on-stm32l1"><span>Rust on STM32L1</span></a></h3>
<p>I like <a href="https://www.rust-lang.org/">the Rust programming language</a> quite a lot and it’s, like, good for embedded so <em>of course</em> I’m going to use it here.
Naturally, I’m not the only one doing so: I was quite happy to discover that there was already a library called
<a href="https://github.com/TeXitoi/keyberon">Keyberon</a> for handling all the uhh… keyboarding.</p>
<p>Now, how does the Rust ecosystem for STM32 look like?
Unlike the C world where you interact with one monolithic SDK (either the vendor-provided one or <a href="https://libopencm3.org/">libopencm3</a>)
there is a lot more code sharing and integration due to the magic of package management.
The “libopencm3” of Rust is spread over a variety of crates: the center of that vague “SDK” is
interface crates like <a href="https://github.com/rust-embedded/embedded-hal">embedded-hal</a> and <a href="https://github.com/rust-embedded-community/usb-device">usb-device</a>,
and there are both drivers that <em>use</em> those interfaces and microcontroller support crates such as the <a href="https://github.com/stm32-rs">stm32-rs</a> ones that <em>implement</em> them.
There is however the “parallel ecosystems” thing too, but not because of vendors: the rather standalone world here is
<a href="https://embassy.dev/">Embassy</a>, an <code>async</code> embedded framework.</p>
<p>And in fact, because stm32-rs’s <code>stm32l1xx-hal</code> is not actively maintained, I’ve considered using Embassy for the project.
I played around with it, <a href="https://github.com/embassy-rs/embassy/pull/579">fixing some STM32L1 initialization code</a> and stuff,
but ultimately ended up just <a href="https://github.com/stm32-rs/stm32l1xx-hal/pull/14">forking <code>stm32l1xx-hal</code></a>, adding USB support and I²C timeouts and of course fixing bugs.</p>
<p>With a reasonable HAL crate and Keyberon in hand, it’s pretty straightforward to put the pieces together.
But I didn’t do anything in the straightforward way because I can get kinda obsessed with efficiency :)</p>
<h3 id="stm32-hardware-magic" tabindex="-1"><a href="#stm32-hardware-magic"><span>STM32 Hardware Magic</span></a></h3>
<p>The cool thing to do for efficiency in embedded development is to let hardware do things as much as possible instead of software.</p>
<p>The first opportunity to leverage nice STM32 peripherals is of course the volume knob: the hardware timers have the
ability to read a rotary encoder instead of, well, counting time.
As long as you connect the encoder to a pair of pins that do correspond to a timer, which I did as
I knew this beforehand, at the PCB design stage.
So in the code, grabbing the timer for this purpose is as simple as:</p>
<pre><code><span>let</span> <span>knob_cnt</span> = cx.device.TIM2.<span>qei</span>((gpioa.pa0, gpioa.pa1), &amp;<span>mut</span> rcc);
</code></pre>
<p>And when polling all the things, we simply check if the count has increased or decreased since the previous
time we did that, and by how much.
Depending on that, we press-and-release a designated key position in the layout,
where we place volume up / volume down keys on the main layer and other fun stuff on other layers
(e.g. I made it so that Fn+knob is scroll up / scroll down, just for fun).</p>
<pre><code><span>let</span> <span>knob_now</span> = cx.local.knob_cnt.<span>count</span>() <span>as</span> <span>i16</span>;
<span>let</span> <span>knob_row</span> = <span>if</span> knob_now &gt; *cx.local.knob_last { <span>1</span> } <span>else</span> { <span>0</span> };
<span>for</span> <span>_</span> <span>in</span> <span>0</span>..(knob_now - *cx.local.knob_last).<span>abs</span>() / <span>2</span> {
    handle_event::<span>spawn</span>(layout::Event::<span>Press</span>(knob_row, (LCOLS + RCOLS) <span>as</span> <span>u8</span>)).<span>unwrap</span>();
    handle_event::<span>spawn</span>(layout::Event::<span>Release</span>(knob_row, (LCOLS + RCOLS) <span>as</span> <span>u8</span>)).<span>unwrap</span>();
}
*cx.local.knob_last = knob_now;
</code></pre>
<p>Now, how about something more advanced? But what is left there to automate?
Well, of course, the actual reading of the keyboard matrix! It’s a common thing, there should be hardware solutions!
And there are. There are ICs that do keyboard matrix scanning (usually I/O expanders with that functionality),
the Programmable I/O peripheral of the RP2040 might be promising for this application,
of course cool things can be done with FPGAs (you can make a microcontroller with your own key scanner peripheral
like in the <a href="https://github.com/esden/icekeeb">icekeeb</a> project).
But it turns out our little STM32 already has a great tool for the job!</p>
<p>Because… it can DMA between memory and banks of GPIO pins, triggered by a timer.
When I was thinking about the DMA capabilities, I was wondering if someone has already done what I wanted to do and yes!
<a href="https://summivox.wordpress.com/2016/06/03/keyboard-matrix-scanning-and-debouncing/">This 2016 blog post</a> describes
exactly how to do it. (With some bonus big-brain thoughts on key debouncing.)
This part of the post sounded somewhat worrying:</p>
<blockquote>
<p>Allocate all row output pins on one GPIO port and all column input pins on another GPIO port</p>
</blockquote>
<p>as I have <em>not</em> done that on my PCB. But well, I quickly realized that I could extend this idea to work
with pins arbitrarily scattered across both of the two pin banks, just by using more timers.
But my job was slightly easier as only columns (outputs in my design) were in both banks, A and B,
while rows (inputs) only were in bank B.</p>
<details>
<summary>Here&#39;s how the Rust magic for that looks</summary>
<p>To generate the bit patterns, I used a <code>const fn</code>:</p>
<pre><code><span>const</span> <span>fn</span> <span>gen_gpio</span>&lt;<span>const</span> N: <span>usize</span>&gt;(pins: [<span>i32</span>; N]) <span>-&gt;</span> [<span>u32</span>; N] {
    <span>let</span> <span>mut </span><span>result</span>: [<span>u32</span>; N] = [<span>0</span>; N];
    <span>let</span> <span>mut </span><span>p</span> = <span>0</span>;
    <span>while</span> p &lt; N {
        <span>if</span> pins[p] &gt;= <span>0</span> { result[p] = <span>1</span> &lt;&lt; pins[p]; }
        p += <span>1</span>;
    }
    result
}

<span>static</span> <span>mut</span> IN_GPIOB: [[<span>u32</span>; LCOLS]; <span>2</span> * BOUNCES] = [[<span>69</span>; LCOLS]; <span>2</span> * BOUNCES];
<span>static</span> OUT_GPIOA: [<span>u32</span>; LCOLS] = <span>gen_gpio</span>([-<span>1</span>, -<span>1</span>, -<span>1</span>, -<span>1</span>, -<span>1</span>,  <span>8</span>, -<span>1</span>]);
<span>static</span> OUT_GPIOB: [<span>u32</span>; LCOLS] = <span>gen_gpio</span>([ <span>1</span>, <span>12</span>, <span>13</span>, <span>14</span>, <span>15</span>, -<span>1</span>,  <span>0</span>]);
</code></pre>
<p>Okay, not that cool, it’s a rather verbose way to avoid writing <code>1 &lt;&lt;</code> everywhere, but I’m a big fan of
compile-time function execution.
But more to the point, the memory layout already explains how the DMA setup works.
On every tick, the next output configuration will be selected across both GPIO ports (activating the next column)
and the next readout of the inputs (well, of all the inputs on bank B) will be put into memory.</p>
<p>For configuring the DMA engines, which don’t have friendly wrappers in the HAL crate,
I wrote <a href="https://codeberg.org/valpackett/ergonice/src/commit/e3c0f93648354c8abb4ec118c95ed4e913308600/fw/src/dma_scan.rs">a macro</a>
wrapping the raw hardware register writes to make it look decent like so:</p>
<pre><code>dma_chan! { dma1: 
    cndtr1 [LCOLS]     cmar1 [&amp;OUT_GPIOB <span>as</span> *<span>const</span> _]
    cpar1 [gpiob_odr]  ccr1 [mem2per nointr]
};
dma_chan! { dma1: 
    cndtr2 [LCOLS]     cmar2 [&amp;OUT_GPIOA <span>as</span> *<span>const</span> _]
    cpar2 [gpioa_odr]  ccr2 [mem2per nointr]
};
dma_chan! { dma1: 
    cndtr3 [LCOLS * BOUNCES * <span>2</span>]  cmar3 [&amp;<span>mut</span> IN_GPIOB <span>as</span> *<span>mut</span> _]
    cpar3 [gpiob_idr]             ccr3 [per2mem intr]
};
</code></pre>
<p>So, the output channels just cycle through the very short 7-element arrays, enabling only one column at a time.
The input reading channel is the interesting one.
The <code>* 2</code> in the array length is related to DMA double buffering.
See, the engine can interrupt the CPU both when it goes through the entire array and wraps around,
and right in the middle of the array. This allows the CPU and the DMA engine to avoid stepping on each other’s feet:
on the half interrupt we read the first half of the memory, and on the full interrupt we read the second one.
And yeah, each half contains a few readouts in a row, to be fed into a debouncer.
This is how it’s done, converting the raw GPIO readout bytes into a matrix for Keyberon:</p>
<pre><code><span>static</span> ROW_GPIOS: [<span>u32</span>; ROWS]  = <span>gen_gpio</span>([<span>4</span>, <span>5</span>, <span>6</span>, <span>7</span>, <span>2</span>]);
<span>let</span> <span>is_half</span> = dma1.isr.<span>read</span>().<span>htif3</span>().<span>bit</span>();
<span>let</span> <span>scans</span> = <span>unsafe</span> {
    &amp;IN_GPIOB[<span>if</span> is_half {
        <span>0</span>..BOUNCES
    } <span>else</span> {
        BOUNCES..<span>2</span> * BOUNCES
    }]
};
<span>for</span> <span>scan</span> <span>in</span> scans {
    <span>let</span> <span>mut </span><span>mat</span> = [[<span>false</span>; LCOLS]; ROWS];
    <span>for</span> (c, colscan) <span>in</span> scan.<span>iter</span>().<span>enumerate</span>() {
        <span>for</span> (r, rowmask) <span>in</span> ROW_GPIOS.<span>iter</span>().<span>enumerate</span>() {
            mat[r][c] = (colscan &amp; rowmask) != <span>0</span>;
        }
    }
    <span>for</span> <span>ev</span> <span>in</span> cx.local.debouncer_l.<span>events</span>(matrix::<span>PressedKeys</span>(mat)) {
        handle_event::<span>spawn</span>(ev.<span>transform</span>(left2global)).<span>unwrap</span>();
    }
}
</code></pre>
</details>
<p>And… it works! Now, of course I haven’t measured any efficiency gains versus doing everything the basic software way :D
But having fun with the implementation was the point more than anything.</p>
<p>The entire source of the firmware is in <a href="https://codeberg.org/valpackett/ergonice/src/branch/trunk/fw">the <code>fw</code> directory in the repo</a>.</p>
<h3 id="things-not-done" tabindex="-1"><a href="#things-not-done"><span>Things not done</span></a></h3>
<p>Of course the end result ended up less ambitious than the initial project.
Out of the initial list of ideas, the analog input fell out at the PCB stage, while
the extra peripheral (trackball/etc.) support kinda fell out at the case design stage.
The “teletype mode” via the output-only serial port header only fell out here at the firmware stage though,
with potential to come back and add it someday.</p>
<p>However there’s another thing I was rather interested in but didn’t get to try in the firmware, and that is
<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/hid/selective-suspend-for-hid-over-usb-devices">USB Selective Suspend</a>
which should allow the microcontroller to go to sleep for idle periods.
This isn’t easy to accomplish, but it seems like resuming the USB connection after sleep on the STM32L1 series might be possible.</p>
<h2 id="p.s.personal-note" tabindex="-1"><a href="#p.s.personal-note"><span>P.S. Personal note</span></a></h2>
<p>Hi, you might remember me as that <code>unrelenting.technology</code> person
who’s done things with <a href="https://val.packett.cool/contrib/freebsd/">FreeBSD</a>, <a href="https://val.packett.cool/contrib/firefox/">Firefox</a>, and <a href="https://val.packett.cool/contrib/wayland/">Wayland</a>,
was involved with the <a href="https://indieweb.org/User:Unrelenting.technology">IndieWeb</a>,
has published relatively popular Rust crates like <a href="https://crates.io/crates/systemstat">systemstat</a> and a whole bunch of other things.</p>
<p>This post could’ve been published many months ago, as the keyboard was completed in February 2022.
However, just a couple days after I finished the work, the world has… changed around me. For the worse.
The dictator of my country has launched a military invasion into a neighboring country. War.
War is horrifying. Of course being in the aggressor country is not like having a missile hit your house,
but living under what’s basically a fascist military dictatorship isn’t so amazing either.
I was afraid that I could be forced to fight or to work for the war effort, that the borders could be closed
and I would be stuck in there for an indefinite period of time, that the global internet could be disconnected
and I wouldn’t be able to speak with the only people I love.
Meanwhile, my gender journey was taking me from “it would be nice to change things about my body someday”
to “oops actually I kinda just have some dysphoria” and yeah, no better time and place to deal with that, right.</p>
<p>Now that I’m out of there, I don’t have an income anymore. So, I’ve opened <a href="https://www.patreon.com/valpackett">a Patreon page</a>.
I’m not asking for charity due to my situation, but rather for funding for my work on free software.
If you liked this post and how every time I work on a project like this I end up contributing all around the FOSS ecosystem,
if you want to see things like an atomic image-based FreeBSD derivative come to life (a bit of a spoiler for the next blog post?)…
any level of support would be appreciated.</p>
<p>Thanks, Val &lt;3</p>

	</div></div>
  </body>
</html>
