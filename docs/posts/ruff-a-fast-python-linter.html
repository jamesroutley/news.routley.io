<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/930487/">Original</a>
    <h1>Ruff: A Fast Python Linter</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Please consider subscribing to LWN</b><p>Subscriptions are the lifeblood of LWN.net.  If you appreciate this
       content and would like to see more of it, your subscription will
       help to ensure that LWN continues to thrive.  Please visit
       <a href="https://lwn.net/subscribe/">this page</a> to join up and keep LWN on
       the net.</p></div>
           </center>
           
<p>Linters are tools that analyze a program&#39;s source code to detect various
problems such as syntax errors, programming mistakes, style violations, and
more. They are important for maintaining code quality and
readability in a project, as well as for catching bugs early in the
development cycle. Last year, a new Python linter appeared: <a href="https://beta.ruff.rs/docs/">Ruff</a>. It&#39;s fast, written in <a href="https://www.rust-lang.org">Rust</a>, and in less than a year it has
been adopted by some high-profile projects, including <a href="https://fastapi.tiangolo.com">FastAPI</a>, <a href="https://pandas.pydata.org">Pandas</a>, and <a href="https://scipy.org">SciPy</a>. 
</p>

<p>Linting tools are often part of an integrated development
environment, used in 
<a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">pre-commit</a>
hooks, or as part of continuous-integration (CI) pipelines. Some popular
linters for 
Python include <a href="https://pylint.readthedocs.io">Pylint</a>, <a href="https://flake8.pycqa.org">Flake8</a>, <a href="https://github.com/PyCQA/pyflakes">Pyflakes</a>, and <a href="https://pycodestyle.pycqa.org">pycodestyle</a> (formerly called
pep8), which are all written in Python as well. Each linter checks whether
the code violates a list of rules. Ruff 
reimplements a lot of the rules that are defined by these other popular Python
linters, and combines them into one tool.
</p>

<h4>Orders of magnitude faster</h4>

<p>In August 2022, Charlie Marsh <a href="https://notes.crmarsh.com/python-tooling-could-be-much-much-faster">announced
Ruff</a>, which he called &#34;an extremely fast Python linter, written in
Rust&#34;. He showed how Ruff is 150 times faster than Flake8 on macOS when
linting the Python files in the CPython code base, 75 times faster
than pycodestyle, and 50 
times faster than Pyflakes and Pylint. While the exact speed gains aren&#39;t
that important (and Ruff has become even faster since then), it&#39;s clear that
it&#39;s orders of magnitudes faster than its competitors, as Marsh
explained: 
</p>

<blockquote>
<p>Even a conservative 25x is the difference between ~real-time
feedback (~300-500ms) and sitting around for 12+ seconds. With
a 150x speed-up, it&#39;s ~300-500ms vs. 75 seconds. If you edit
a single file in CPython and re-run 
ruff, it&#39;s 60ms total, increasing the speed-up by another order of
magnitude.
</p>
</blockquote>

<p>In his example, Marsh touches on Ruff&#39;s
caching. When re-running Ruff on a code base, it only lints the files that
have been changed since the previous run. In contrast, Flake8 re-lints all
of the
files every time, except when running it in a wrapper such as <a href="https://pypi.org/project/flake8-cached/">flake8-cached</a>. 
</p>

<p>The gist of his message is: when linting a code base happens almost
instantaneously, there&#39;s really no reason to not do it. This means that more
developers will add the linter to their pre-commit or CI configuration. So
speed is not just a nice-to-have, but is an essential element of improving code
quality. 
</p>

<p>One reason why Ruff is faster than the alternatives is that it&#39;s
compiled into machine code instead of running in an interpreter. However, a
second reason for its speed is that it runs all of its checks in a single pass
over the code. Marsh contrasts this with how Flake8 works: 
</p>

<blockquote>
<p>Flake8 is really a wrapper around other tools, like pyflakes and
pycodestyle. When you run Flake8, both pyflakes and pycodestyle are reading
every file from disk, tokenizing the code, and traversing the tree (I might
be wrong on some of the details, but you get the idea). If you then use
autoflake to automatically fix some of your lint violations, you&#39;re running
pycodestyle yet again. How many times, in your pre-commit hooks, do you
read your source code from disk, parse it, and traverse the parse tree? 
</p>
</blockquote>

<p>Ruff uses <a href="https://rustpython.github.io">RustPython</a>&#39;s
abstract syntax tree (AST) parser. For every file, Ruff generates the AST
exactly once, traverses all the nodes in the tree, applying the linter
rules in a single pass as it goes. 
</p>

<h4>Ruff rules</h4>

<p>Ruff has over 500 <a href="https://beta.ruff.rs/docs/rules/">built-in
rules</a>, many of them inspired by popular tools such as Flake8, <a href="https://pycqa.github.io/isort/">isort</a>, and <a href="https://pypi.org/project/pyupgrade/">pyupgrade</a>,  as well as
including <a href="https://beta.ruff.rs/docs/rules/#ruff-specific-rules-ruf">some of 
its own rules</a>. There&#39;s a
category for each of these linters, and each category comes with a
collection of rules. By default, Ruff enables all rules from the F category
(Pyflakes) and a subset of the E (Flake8&#39;s errors) category. Ruff also
reimplements some of the functionality in the most popular Flake8 plugins as
well as in other 
code-quality tools.  
</p>

<p>For its configuration, Ruff uses <a href="https://beta.ruff.rs/docs/configuration/#using-pyprojecttoml"><tt>pyproject.toml</tt></a>. The
various categories of rules can be enabled and/or configured in this
file. For example, this snippet of the configuration enables the rules from
four linters, ignores two specific rules, and enforces the <a href="https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings">Google
style for docstrings</a>: 
</p>

<pre>    [tool.ruff]
    select = [
      &#34;ANN&#34;,     # flake8-annotations
      &#34;D&#34;,       # pydocstyle
      &#34;E&#34;,       # pycodestyle
      &#34;F&#34;,       # Pyflakes
    ]
    ignore = [
      &#34;ANN101&#34;,  # missing-type-self
      &#34;D107&#34;,    # undocumented-public-init
    ]

    [tool.ruff.pydocstyle]
    convention = &#34;google&#34;
</pre>

<p>For strict linting, <tt>select = [&#34;ALL&#34;]</tt> enables all built-in
linters. On most code bases, this will result in a lot of errors, but
specific categories or rules can be ignored, as seen in the example
configuration above. Alternatively, individual violations for specific
rule codes can be ignored by adding <tt># noqa: {code}</tt> at
the end of a line 
in the source file. 
</p>

<p>Not all of the rules of the original tools are reimplemented in
Ruff. The documentation has a <a href="https://beta.ruff.rs/docs/faq/#how-does-ruff-compare-to-flake8">comparison
with Flake8</a>, with <a href="https://beta.ruff.rs/docs/faq/#how-does-ruff-compare-to-pylint">Pylint</a>,
and a list of implemented <a href="https://beta.ruff.rs/docs/faq/#which-tools-does-ruff-replace">Flake8
plugins</a>. Ruff also supports import sorting <a href="https://beta.ruff.rs/docs/faq/#how-does-ruffs-import-sorting-compare-to-isort">comparable
to isort</a>, as well as linting <a href="https://beta.ruff.rs/docs/faq/#does-ruff-support-numpy-or-google-style-docstrings">docstrings</a>
based on various conventions. 
</p>

<p>Contrary to the popular Flake8, Ruff doesn&#39;t support plugins. So users
who want to extend the linter need to get their code accepted into Ruff&#39;s
repository. There&#39;s <a href="https://github.com/charliermarsh/ruff/issues/283">a GitHub issue about
plugins</a>, with <a href="https://github.com/charliermarsh/ruff/issues/283#issuecomment-1403025627">a
comment by Marsh</a> that adding support for plugins is not a top priority
now because he 
considers the unification of multiple tools into Ruff as a feature, not a
bug. But this means that developers who want to enforce their own quirky rules,
that won&#39;t be accepted into Ruff because they&#39;re too
specialized, will need to run another tool. 
</p>

<h4>Using Ruff</h4>

<p>Despite being written in Rust, Ruff can simply be installed with
<tt>pip install ruff</tt>, at least if there&#39;s a wheel built for
the
environment. This is based on the <a href="https://www.maturin.rs">Maturin</a> project that allows building and
publishing Rust binaries as Python packages. Most users shouldn&#39;t even
notice that 
Ruff isn&#39;t written in Python. Ruff supports any Python version from 3.7
onward. 
</p>

<p>Running Ruff manually is as easy as executing
<tt>ruff check src/</tt> 
when the Python files are in the <tt>src</tt> directory. It then shows a
list of files with lines and columns where the linter finds an error,
followed by a code and short description of the rule. For example:
</p><pre>    def is_uint16(number: int) -&gt; bool:
	 &#34;&#34;&#34;Check whether a number is a 16-bit unsigned integer.&#34;&#34;&#34;
	 return isinstance(number, int) and 0 &lt;= number &lt;= 0xFFFF
</pre><p>
With the Pylint refactor rules enabled, </p><tt>ruff check</tt><p> gave me
the following warning: 
</p><pre>    src/bluetooth_numbers/utils.py:192:55: PLR2004 Magic value used in 
    comparison, consider replacing 65535 with a constant variable
</pre><p>
I found that complaint to be overly pedantic, so I silenced it by adding
</p><tt># noqa: PLR2004</tt><p> to the end of the </p><tt>return</tt><p>
statement. 
</p>

<p>
A command like
<tt>ruff rule PLR2004</tt> shows some more information about a
specific 
rule. For some rules, the information provides a clear
example. Unfortunately, for many others the information is rather sparse,
only telling the developer what is not allowed, but not why or how to solve
the problem. Often there&#39;s a reference to the original project the rule is
derived 
from, so searching that project&#39;s home page or repository can help. 
</p>

<p>There&#39;s also a <tt>--watch</tt> option that continuously re-runs the
linter when source files change. Ruff designates some errors as fixable: it
can resolve them automatically when running <tt>ruff check</tt> with the
<tt>--fix</tt> option. Some examples of these fixable errors are things
like unused 
imports or invalid unescaped characters in strings. 
</p>

<p>Most projects benefit from using a configuration file for Ruff, where
specific linters and/or rules are enabled. For some of my own Python
projects, I was able to migrate from a combination of isort, pyupgrade,
Pylint, and Flake8 (with a lot of plugins) to Ruff with a short
configuration file. 
</p>

<p>
What worked for me to get strict linting—all rules enabled—for
my relatively small Python projects was to look at the violations rule by
rule. Pick a rule that the code violates a lot, restrict the output to only
this rule with:

</p><pre>    $ ruff check --select RULECODE src
</pre><p>
Then fix the
issues one by one or add a </p><tt># noqa: RULECODE</tt><p> comment where
needed. If none of the violations for a rule seem relevant, add it to the
ignore list. Then run Ruff again without restrictions, pick another rule,
look into that one, and so on, until there 
are no violations left. 
</p>

<p>Apart from running Ruff manually, users can also <a href="https://beta.ruff.rs/docs/editor-integrations/">integrate the linter
directly into their code editor</a> (e.g. Visual Studio Code, Vim, Neovim,
Emacs) or 
it can be
used <a href="https://beta.ruff.rs/docs/editor-integrations/#language-server-protocol-official">with
the language server protocol</a> for any tool that supports it.
The linter can be used as a <a href="https://beta.ruff.rs/docs/usage/#pre-commit">pre-commit hook</a> or
as a <a href="https://beta.ruff.rs/docs/usage/#github-action">GitHub
action</a> as well. 
</p>

<h4>Ruff-like developer tools</h4>

<p>In his announcement of Ruff, Marsh had already hinted at the
possibilities of other Python developer tools using the same approach as
Ruff: 
</p>

<blockquote>
<p>The question I keep asking myself is: could we take the Ruff model and
apply it to other tooling? You could probably give autoformatters (like
Black and isort) the same treatment. But what about type checkers? I&#39;m not
sure! Mypy is already compiled with mypyc, and so is much faster than pure
Python; and Pyright is written in Node. It&#39;s something I&#39;d like to put to
the test.
</p>
</blockquote>

<p>In mid-April, Marsh <a href="https://astral.sh/blog/announcing-astral-the-company-behind-ruff">announced</a> that
he has started a company, <a href="https://astral.sh">Astral</a>, to continue
building high-performance developer tools for the Python ecosystem: 
</p>

<blockquote>
<p>Some of the things we build will look like natural extensions of Ruff
(e.g., an autoformatter); others will diverge from the static analysis
theme. But our North Star is pretty simple: make the Python ecosystem more
productive by building tools people love to use — tools that feel fast,
robust, intuitive, and integrated.
</p>
</blockquote>

<p>What won&#39;t change, according to Marsh, is the open-source and permissively
licensed nature of Ruff (which has an MIT license) and other tools that
will be created by Astral. 
</p>

<h4>Conclusion</h4>

<p>For developers who are now using Flake8 with various plugins, Pylint, isort,
pyupgrade, and many other tools to check their code quality, migrating
to Ruff can greatly simplify their development environment. Not only does this
result in fewer dependencies, it also makes linting the code base faster. <a href="https://black.readthedocs.io">Black</a> for code formatting, Ruff for
linting, and <a href="https://mypy-lang.org">mypy</a> for type checking
seems to be the sweet spot for many projects these days. It remains to be seen
whether the Astral team will create a code formatter and type
checker to complement Ruff. 
</p></div></div>
  </body>
</html>
