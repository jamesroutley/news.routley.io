<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tgmatos.github.io/allocators-are-for-monkeys-with-typewriters/">Original</a>
    <h1>I was surprised by how simple an allocator is</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
                



<h2 id="">
<img src="https://tgmatos.github.io/processed_images/monkey.c9ea9ce0ce59ee69.png"/>
</h2>

<ol>
<li><a href="https://tgmatos.github.io/allocators-are-for-monkeys-with-typewriters/#introduction">Introduction</a></li>
<li><a href="https://tgmatos.github.io/allocators-are-for-monkeys-with-typewriters/#memory-allocators">Memory allocators</a></li>
<li><a href="https://tgmatos.github.io/allocators-are-for-monkeys-with-typewriters/#buddy-system">Buddy system</a>
<ol>
<li><a href="https://tgmatos.github.io/allocators-are-for-monkeys-with-typewriters/#allocation">Allocation</a></li>
<li><a href="https://tgmatos.github.io/allocators-are-for-monkeys-with-typewriters/#deallocation">Deallocation</a></li>
</ol>
</li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>Recently I was looking at an issue on <a href="https://github.com/microsoft/mimalloc/">mimalloc</a>, a &#34;<em>state-of-the-art</em>&#34; memory allocator developed by Microsoft. <a href="https://github.com/microsoft/mimalloc/issues/53#issuecomment-622976237">The issue</a> was quite simple, developers wanted a way to preallocate a piece of memory and use it as mimalloc&#39;s heap. Seeing that <em>mimalloc</em> does not offer this feature, I thought:</p>
<blockquote>
<p>&#34;<em>how hard can it be to write a memory allocator to manage a preallocated region?</em>&#34;.</p>
</blockquote>
<p>The answer to this question is:</p>
<blockquote>
<p>&#34;<em>given enough time, even a monkey with a typewriter can write a memory allocator</em>&#34;.</p>
</blockquote>
<p>The implementation is around 163 LoC and very straightforward.</p>

<img src="https://tgmatos.github.io/processed_images/mimalloc_issue.9f94d875f9e73f88.png"/>
<h2 id="memory-allocators">Memory allocators</h2>
<p>To write a memory allocator, we first need to understand what an allocator does. An allocator is &#34;<em>a component of a programming language or runtime system that is responsible for managing the allocation and deallocation of memory during program execution</em>&#34;. Roughly speaking, a custom allocator needs to provide a way for the developer to allocate, deallocate and reallocate memory from the operating system.</p>
<p>The C standard library provides <code>malloc/free/resize</code> (<em>C11 introduced <a href="https://en.cppreference.com/w/c/memory/aligned_alloc">aligned_alloc</a> and C23 introduced <a href="https://en.cppreference.com/w/c/memory/free_sized">free_sized</a> and <a href="https://en.cppreference.com/w/c/memory/free_aligned_sized">free_aligned_sized</a></em>), then a custom allocator will need to provide the same (<em>or nearly</em>) the same interface for easy integration with already existing code.</p>
<h2 id="memory-fragmentation">Memory Fragmentation</h2>
<p>One of the problems an allocator tries to solve is memory fragmentation. Memory fragmentation happens when the memory is split into small unused blocks throughout a memory chunk, making larger allocations harder because there is fewer contiguous memory available to allocate.</p>
<img src="https://tgmatos.github.io/images/memory_fragmentation.svg"/>
<p>Since memory is allocated in chunks, sometimes the real size allocated by the allocator is bigger than the requested size, and the unused memory left is wasted. This is called <strong>internal fragmentation</strong>. <strong>External fragmentation</strong> &#34;arises when free memory is separated into small blocks and is interspersed by allocated memory&#34;.</p>
<p>There are a lot of methods an allocator can use to minimize memory fragmentation. General purpose ones do it by creating different allocation buckets based on the allocation size. So if an allocation of 512 bytes is requested, the allocator will use a bucket for small allocations, preventing that 512 bytes are wasted in the memory when big allocations happen.</p>
<h2 id="buddy-system">Buddy system</h2>
<p>There are various allocation techniques, and one of the simplest and most reliable is the buddy allocation, which is the one I implemented. It is widely used in the industry, and it is the one used by the Linux kernel to handle page allocations (<em>albeit a modified version</em>).</p>
<p>The way it works is by dividing a contiguous memory chunk into two smaller chunks of memory, each a power of two (<em>hence the &#34;buddy&#34;</em>), until a small enough size is reached, and then returning this memory to the user.</p>
<h3 id="allocation">Allocation</h3>
<p>As an example, suppose the programmer requested a 16KB memory chunk, and the size of the whole memory block is 256KB. It will do:</p>
<ol>
<li>Requested size is smaller than the chunk size, it will split the 256KB chunk into two 128KB chunk.</li>
<li>Requested size is smaller than the current chunk size, first 128KB chunk is split in two 64KB chunk.</li>
<li>Requested size is smaller than the current chunk size, first 64KB chunk is split in two 32KB chunks.</li>
<li>Requested size is smaller than the current chunk size, first 32KB chunk is split in two 16KB chunks.</li>
<li>Requested size is equals the chunk size. Return it to the user.</li>
</ol>
<p>Here is the representation of this allocation:
<img src="https://tgmatos.github.io/images/buddy_allocator_internal.svg"/></p>
<p>And that is it, just split the memory until the requested size is <code>&lt;=</code> than the current chunk size. The disadvantage of this technique is that it has internal fragmentation since the returned chunk can be smaller than the requested size and so the unused memory is wasted.</p>
<h3 id="deallocation">Deallocation</h3>
<p>To deallocate the memory is straightforward, just mark the chunk received by the <code>free</code> function as unused and check if its buddy is also unused, if it is, just coalesce it into a bigger chunk.</p>
<p>Suppose the previous 16KB memory chunk allocated is being freed, it would be like this:
<img src="https://tgmatos.github.io/images/buddy_allocator_free.svg"/></p>
<h3 id="resize">Resize</h3>
<p>The resize part is also simple to implement, and it stays as a exercise for the reader.</p>
<h3 id="conclusion">Conclusion</h3>
<p>After spending some time reading and implementing an allocator, I was surprised by how simple an allocator is. Even general purpose allocators like <em>mimalloc</em> is only a few thousand lines of code and most of that code is (<em>probaly</em>) just dealing with multithread.</p>
<p>The code for my implementation can be found here: <a href="https://github.com/tgmatos/imalloc">tgmatos/imalloc</a></p>
<p>I would have loved to delve more into the internals of an allocator, the techniques general purpose allocators use and everything, but I have neither the time nor the proficiency (<em>yet</em>) to write an article about it. I will probably do it in the future, but for now my plan is to just implement a way for mimalloc to use preallocated memory.</p>






            </div></div>
  </body>
</html>
