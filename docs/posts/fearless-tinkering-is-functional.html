<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://heneli.dev/blog/fearless-tinkering-is-functional">Original</a>
    <h1>Fearless Tinkering is Functional</h1>
    
    <div id="readability-page-1" class="page"><div><p><em>Is functional programming worth learning? This series is the sales pitch I wish I had received when first being introduced to the world of functions.</em></p><details open=""><summary>Table of Contents</summary></details><p>ü™ù</p><p>Sometimes functional programming gets a bad rap. Critics from industry cite a laundry list of issues, including a lack of commercial validation, high barrier of entry, sparse library catalog, poor documentation, unfamiliar academic culture, and dismal entry-level job market. Advocates counter <a target="_blank" rel="noopener noreferrer" href="https://blog.janestreet.com/why-ocaml/">with</a> <a target="_blank" rel="noopener noreferrer" href="https://discord.com/blog/how-discord-scaled-elixir-to-5-000-000-concurrent-users">a</a> <a target="_blank" rel="noopener noreferrer" href="https://blog.replit.com/nix">number</a> <a target="_blank" rel="noopener noreferrer" href="https://serokell.io/blog/haskell-in-production-meta">of</a> <a target="_blank" rel="noopener noreferrer" href="https://www.pagerduty.com/blog/tag/elixir/">success</a> <a target="_blank" rel="noopener noreferrer" href="https://serokell.io/blog/haskell-in-production-mercury">stories</a> and appeals pointing <a target="_blank" rel="noopener noreferrer" href="https://elixir-lang.org/blog/2022/10/05/my-future-with-elixir-set-theoretic-types/">to</a> <a target="_blank" rel="noopener noreferrer" href="https://blog.janestreet.com/oxidizing-ocaml-locality/">ongoing</a> <a target="_blank" rel="noopener noreferrer" href="https://haskell.foundation/projects/">improvements</a>. ‚Äú<a target="_blank" rel="noopener noreferrer" href="https://www.amazon.com/Production-Haskell-Succeeding-Industry/dp/B0BTNVFR2N">Things</a> <em><a target="_blank" rel="noopener noreferrer" href="https://zero-to-nix.com/">really</a> <a target="_blank" rel="noopener noreferrer" href="https://pijul.org/posts/2023-05-23-nest-a-new-hope/">are</a></em> <a target="_blank" rel="noopener noreferrer" href="https://fsharp.org/mentorship/">getting</a> <a target="_blank" rel="noopener noreferrer" href="https://leanpub.com/fp-made-easier">better</a>!‚Äù Deserved or otherwise, skepticism is hard to overcome.</p><p>It‚Äôs certainly never been the case that a functional language was the de facto industry standard like Java, Python, and JavaScript have been. By choice<sup><a href="#user-content-fn-1" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-1">1</a></sup> or by fate, the lack of mainstream adoption has had predictable costs on functional ecosystems. When 10,000 new programmers are learning an imperative language to every individual learning a functional one, can a functional approach really compete?<sup><a href="#user-content-fn-2" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-2">2</a></sup></p><p>My answer is yes. While they have merit, none of the above critiques are inherent. In fact, I‚Äôll argue that the functional paradigm already has best-in-class discoverability and experimentation thanks to <strong>fearless tinkering</strong>.<sup><a href="#user-content-fn-3" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-3">3</a></sup></p><h2 id="fearless-in-theory"><a href="#fearless-in-theory" aria-hidden="true" tabindex="-1"><span></span></a>Fearless in Theory</h2><hr/><h3 id="fear-and-complexity"><a href="#fear-and-complexity" aria-hidden="true" tabindex="-1"><span></span></a>Fear and Complexity</h3><p>There‚Äôs an endless list of things that invoke fear in programmers, such as:</p><div><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>clocks</td><td>rolling upgrades</td><td>concurrency</td><td>bit rot</td></tr><tr><td>far out deadlines</td><td>service alerts</td><td>tech debt</td><td>stale builds</td></tr><tr><td>nondeterminism</td><td>replication</td><td>ambiguous requirements</td><td>hardware faults</td></tr><tr><td>software rewrites</td><td>network partitions</td><td>scope creep</td><td>security</td></tr></tbody></table></div><p>Each of these areas can be terrifying on their own. To make matters worse, software rarely contains just a single source of horror. Very simple programs written by very thoughtful programmers can host a multitude.</p><p>Without the right tools, conquering these fears can feel impossible. How can one produce trustworthy software with untrustrworthy tools? Some adopt a defensive programming style, but institutionalizing apprehension isn&#39;t an end in itself. What use is an infinite roll of duct tape when a ship takes water? If tape can‚Äôt solve the first leak, should one patch the next, or accept fate and lose hope in the voyage? Does a decision even matter when the ship is already sinking? Maybe swimming to shore and joining a new boat would suffice‚Ä¶ at least until that crew wants to tape their leaks. By then, that too will be someone else‚Äôs problem. The cognitive burden of faulty software is real and difficult to remedy. Programming is a social exercise, and teams will burn out accommodating learned helplessness.</p><p>Most fears boil down to uncertainty about <strong>complexity</strong>. As Fred Brooks explained in <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/No_Silver_Bullet">No Silver Bullet</a>, there exists <strong>essential complexity</strong> that cannot be avoided and <strong>accidental complexity</strong> that can.<sup><a href="#user-content-fn-4" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-4">4</a></sup> <a target="_blank" rel="noopener noreferrer" href="https://github.com/papers-we-love/papers-we-love/blob/2eb8d21/design/out-of-the-tar-pit.pdf">Out of the Tar Pit</a> followed up by diagnosing <strong>state</strong>, <strong>control flow</strong>, and <strong>code volume</strong> as the most frequent culprits underlying accidental complexity. The nature of complexity is festering and exponential, so tackling root causes is always better than addressing symptoms. Put another way, preventing leaks by addressing the inherent structural deficiencies of a ship‚Äôs build is favorable to being skilled at plugging holes.</p><p><strong>Fearless tinkering</strong> is the ability to engage a domain and confidently reason about it while unencumbered by accidental complexity. Whether the domain is concurrency, software upgrades, or something else, a fearless tinkerer can rely on the structural guarantees of their context to safely explore their domain and target the essential complexity of the task at hand. A fearless tinkerer sails a ship where entire classes of leakage are rendered an impossibility. What kinds of leaks are prevented? How are they decided? As discussed in the following sections, these guarantees are determined by the algebra of one‚Äôs program.</p><h3 id="on-functional-programming"><a href="#on-functional-programming" aria-hidden="true" tabindex="-1"><span></span></a>On Functional Programming</h3><p>The functional style encourages transformation-based workflows over state-based workflows. To motivate this approach, functional languages offer an assortment<sup><a href="#user-content-fn-5" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-5">5</a></sup> of party tricks:<sup><a href="#user-content-fn-6" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-6">6</a></sup></p><div><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Referential Transparency</td><td>Pure Functions</td><td>Immutability</td><td>Declarative Programming</td></tr><tr><td>First-Class Functions</td><td>Higher-Order Functions</td><td>Pattern Matching</td><td>Tail Call Elimination</td></tr><tr><td>Compositionality</td><td>Managed Effects</td><td>Algebraic Datatypes</td><td>Expression-Oriented Programming</td></tr><tr><td>Recursive Datatypes</td><td>Equational Reasoning</td><td></td><td></td></tr></tbody></table></div><p>Functional programming doesn‚Äôt solve complexity but helps one meet it by surfacing its roots. To do this, functional languages deliver battle-tested approaches to the state, control flow, and volume.</p><p>Functional languages <em><u>make stateful complexity explicit</u></em>. By pairing immutable defaults with performant and easy-to-use APIs, functional languages minimize the need for mutable state. Introducing any mutable state thus becomes an intentional and highly visible action. Given the elimination of destructive updates, compilers are empowered to reward programmers with greater <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Fold_%28higher-order_function%29">expressiveness</a> and <a target="_blank" rel="noopener noreferrer" href="https://en.wikipedia.org/wiki/Software_transactional_memory">safety</a> at less cost. Some functional languages make explicit their ‚Äúeffects‚Äù with types, creating a distinction that allows separate reasoning of ‚Äúeffect-free‚Äù and ‚Äúeffectful‚Äù code.</p><p>With a greater reliance on <em><u>declarative constructs</u></em> (expressions) over <em><u>imperative ones</u></em> (statements), functional languages eliminate a number of control flow complexities. Jump-based statements that break compositionality are replaced with expressions that can be substituted for their value. Bigger programs can be faithfully decomposed into smaller ones. This allows for <a target="_blank" rel="noopener noreferrer" href="https://www.inner-product.com/posts/fp-what-and-why/">local reasoning</a> on individual parts to hold up when global reasoning is needed about the whole. Thanks to the sole determination of a function‚Äôs outputs on its inputs, purely functional programming creates an experience where ‚Äúwhat you see is what you get.‚Äù</p><p><em><u>Compositionality</u></em> also addresses program volume in functional languages. Programs and their domains can be <em><u>mechanically decomposed</u></em> into their essential concepts. For instance, programmers can collapse verbose wrangling and glue-code into neat reusable patterns using higher-order functions and composition. Typed functional languages use various flavors of polymorphism to replace infinitely-many functions over one domain with an economy of functions over infinite domains. Typed functional languages also reduce cognitive volume by offloading the rote calculations of dynamism onto the programmer‚Äôs better-suited counterpart in computers. As elaborated in the following section, relegating implementation details to the relevant semantic layer makes declarative APIs naturally terse. <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/HCuCKeK1l6g">Judicious</a> use of abstraction capabilities assists in uncovering rock-solid, lean foundations for APIs and broader ecosystems.</p><p>Armed with the properties of functional languages, programmers can reclaim their cognitive sovereignty and fearlessly explore software in action.</p><h3 id="ideas-over-implementation-details"><a href="#ideas-over-implementation-details" aria-hidden="true" tabindex="-1"><span></span></a>Ideas over Implementation Details</h3><blockquote><p>Declare it. Answer how with what. Break the causal chain and unshackle from the past. The world is simply what you say it is.</p><ul><li>a sage functional programmer, probably</li></ul></blockquote><p>If language is a tool for thought, then one should value dialects enabling natural communication. Blunted alternatives that intersperse anything meaningful with robotic recitations of language internals or error-prone adaptations to outside alterations are frustrating to tolerate. A language that yields such fragile mental models is ill-fit for real-world scenarios like context-switching, requirements evolution, and the eventuality of a system‚Äôs growth beyond what can be kept in one‚Äôs head. The essential complexity programmers face is already challenging enough.</p><p>When the business calls for an algorithm to determine how many users visited their website last week, no one‚Äôs first thought should have to be about for-loops, heap allocations, hashing strategies, logic gates, or cosmic rays. No, an API that‚Äôs better suited for immediate communication might yield something like:</p><div><pre><code><span>all_users <span>-</span><span>&gt;</span> <span>filter_by</span><span>(</span><span>visited_since</span><span>(</span><span>-</span><span>7</span> days<span>)</span><span>)</span> <span>-</span><span>&gt;</span> <span>count</span><span>(</span><span>)</span>
</span></code></pre></div><p>All users, filtered by those who visited in the last seven days, counted</p><p>Declarative programming simplifies the act of learning because it a) meets one at their layer of abstraction and b) lets one focus solely on what‚Äôs in front of them. A well-designed declarative API lays out all the vocabulary and structure one should need, such that formulating solutions through sentences is as natural as placing blocks in a game of Tetris. Learners can focus on describing the place they actually care about instead of the windy road taken to get there. By only necessitating the specification of a goal state, programmers are unburdened by the interconnected history of their model&#39;s state transitions.</p><h3 id="constraints-liberate"><a href="#constraints-liberate" aria-hidden="true" tabindex="-1"><span></span></a>Constraints Liberate</h3><blockquote><p>Freedom at one level leads to restriction at another. A constraint at one level leads to freedom and power at another level.</p><ul><li>R√∫nar Bjarnason @ Scala World 2015, <a target="_blank" rel="noopener noreferrer" href="https://youtu.be/GqmsQeSzMdw">Constraints liberate, Liberties constrain</a></li></ul></blockquote><p>Observing the underlying properties of a program is the key to unlocking its simplification. Pure functions are simple because of the numerous constraints imposed on them. The restriction of mapping input sets onto output sets eases the discovery of additional relationships in one‚Äôs program. Employing popular <a target="_blank" rel="noopener noreferrer" href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">functional</a> <a target="_blank" rel="noopener noreferrer" href="https://kowainik.github.io/posts/haskell-mini-patterns#phantom-type-parameters">techniques</a> to prune superfluous code paths can make further invariants lurking in our programs more apparent. By building an arsenal of common operations with associated constraints, one can unlock a valuable toolkit of powers to call upon in various programming situations.</p><p>One could rightly object that the need to learn new mathematical abstractions is trading one kind of complexity for another. In practice, there are but a small handful of core abstractions that programmers will typically run into and are thus worth their collective weight.<sup><a href="#user-content-fn-7" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-7">7</a></sup> Learning frequently occurring abstractions is useful for formalizing one&#39;s understanding of the domains they characterize. The major benefit of learning said abstractions is that once you‚Äôve understood them, you‚Äôve understood them for all their applications.</p><div><table><thead><tr><th scope="col">Property</th><th scope="col">Disallows</th><th scope="col">Power</th><th scope="col">Example</th></tr></thead><tbody><tr><th scope="row">Functional Purity</th><td><div><pre><code><span><span>log4Info</span><span>(</span>msg<span>)</span><span>:</span>
</span><span>    <span>upload_ssn</span><span>(</span><span>)</span>
</span><span>    <span>return</span> <span>‚Äúinfo</span><span>:</span> ‚Äù <span>+</span> msg
</span></code></pre></div></td></tr></tbody><caption>Performs side-effect</caption><tbody><tr><td>Fearlessly execute, reproduce, and cache</td><td>Haskell</td></tr><tr><th scope="row">Immutable</th><td><div><pre><code><span><span>f</span><span>(</span>x<span>)</span><span>:</span>
</span><span>  global <span>+=</span> x
</span><span>  <span>return</span> global
</span><span>
</span><span><span>&gt;&gt;&gt;</span> <span>f</span><span>(</span><span>5</span><span>)</span>
</span><span><span>5</span>
</span><span><span>&gt;&gt;&gt;</span> <span>f</span><span>(</span><span>5</span><span>)</span>
</span><span><span>10</span>
</span></code></pre></div></td></tr></tbody><caption><code>global</code> changes its value</caption><tbody><tr><td>Fearlessly rollback and share dependencies</td><td>Nix</td></tr><tr><th scope="row"><p>Associative:</p><p><code>(A &lt;&gt; B) &lt;&gt; C == A &lt;&gt; (B &lt;&gt; C)</code></p></th><td><div><pre><code><span><span>&gt;&gt;&gt;</span> <span>average</span><span>(</span><span>1</span><span>,</span> <span>average</span><span>(</span><span>2</span><span>,</span> <span>3</span><span>)</span><span>)</span>
</span><span><span>1.75</span>
</span><span><span>&gt;&gt;&gt;</span> <span>average</span><span>(</span><span>average</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>,</span> <span>3</span><span>)</span>
</span><span><span>2.25</span>
</span></code></pre></div></td></tr></tbody><caption>Left-to-right evaluation is different from right-to-left</caption><tbody><tr><td>Fearlessly parallelize and rebalance operations</td><td>MapReduce</td></tr><tr><th scope="row"><p>Commutative:</p><p><code>A &lt;&gt; B == B &lt;&gt; A</code></p></th><td><div><pre><code><span><span>&gt;&gt;&gt;</span> wells_fargo<span>.</span><span>make_transations</span><span>(</span><span>[</span>
</span><span>  <span>deposit</span><span>(</span>$200<span>)</span><span>,</span>
</span><span>  <span>withdraw</span><span>(</span>$100<span>)</span><span>,</span>
</span><span>  <span>withdraw</span><span>(</span>$100<span>)</span>
</span><span><span>]</span><span>)</span>
</span><span><span>&gt;&gt;&gt;</span> wells_fargo<span>.</span><span>show_activity</span><span>(</span><span>)</span>
</span><span><span>Transaction</span> <span>Log</span><span>:</span>
</span><span>  <span>-</span><span>100</span><span>,</span> <span>-</span><span>25</span> <span>(</span>overdraw fee<span>)</span><span>,</span>
</span><span>  <span>+</span><span>200</span><span>,</span>
</span><span>  <span>-</span><span>100</span><span>,</span> <span>-</span><span>25</span> <span>(</span>overdraw fee<span>)</span>
</span><span><span>Current</span> <span>Balance</span><span>:</span> <span>-</span>$50
</span></code></pre></div></td></tr></tbody><caption>Reordering changes result</caption><tbody><tr><td>Fearlessly reorder executions</td><td>Pijul</td></tr><tr><th scope="row"><p>Transitive:<sup><a href="#user-content-fn-8" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-8">8</a></sup></p><p><code>F: A -&gt; B</code>, </p></th><td><div><pre><code><span><span>neg_to_bool</span><span>(</span>x<span>:</span> int<span>)</span> <span>-</span><span>&gt;</span> <span>Union</span><span>[</span>int<span>,</span> bool<span>]</span><span>:</span>
</span><span>    <span>if</span> x <span>&lt;</span> <span>0</span><span>:</span> <span>return</span> <span>False</span>
</span><span>    <span>else</span><span>:</span> <span>return</span> x
</span><span>
</span><span><span>square</span><span>(</span>a<span>:</span> int<span>)</span> <span>-</span><span>&gt;</span> int<span>:</span>
</span><span>    <span>return</span> a <span>*</span> a
</span><span>
</span><span><span>&gt;&gt;&gt;</span> <span>square</span><span>(</span><span>neg_to_bool</span><span>(</span><span>-</span><span>10</span><span>)</span><span>)</span>
</span><span><span>**</span><span>*</span> error<span>!</span>
</span></code></pre></div></td></tr></tbody><caption>Non-composable as <code>square</code> can&#39;t accept booleans</caption><tbody><tr><td>Fearlessly link and delegate</td><td>Relational Databases</td></tr><tr><th scope="row"><p>Join-Semilattice:</p><p><code>Associative: (A &lt;&gt; B) &lt;&gt; C == A &lt;&gt; (B &lt;&gt; C)</code></p><p><code>Commutative: A &lt;&gt; B == B &lt;&gt; A</code></p><p><code>Idempotent: A &lt;&gt; A == A</code></p></th><td><div><pre><code><span>$ git merge develop
</span><span><span>Auto</span><span>-</span>merging index<span>.</span><span>html</span>
</span><span><span>CONFLICT</span> <span>(</span>content<span>)</span><span>:</span> <span>...</span>
</span><span><span>CONFLICT</span> <span>(</span>modify<span>/</span><span>delete</span><span>)</span><span>:</span> <span>...</span>
</span><span><span>Automatic</span> merge failed<span>;</span>
</span><span>
</span><span>$ cat index<span>.</span><span>html</span>
</span><span><span>&lt;&lt;</span><span>&lt;&lt;</span><span>&lt;&lt;</span><span>&lt;</span> <span>HEAD</span>
</span><span>  <span><span><span>&lt;</span>h1</span><span>&gt;</span></span><span>Fearless Tinkering is Functional</span><span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
</span><span><span>===</span><span>===</span><span>=</span>
</span><span>  <span><span><span>&lt;</span>h1</span><span>&gt;</span></span><span>Fearless Tinkering is Algebraic</span><span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
</span><span><span>&gt;&gt;&gt;</span><span>&gt;&gt;&gt;</span><span>&gt;</span> develop
</span></code></pre></div></td></tr></tbody><caption>Permits conflicts when synchronizing</caption><tbody><tr><td>Fearlessly update and collaborate</td><td>Electric SQL</td></tr><tr><th scope="row"><p>Invertible:</p><p>A <code>&lt;&gt;</code> <code>id</code> == A</p><p>=&gt; A <code>&lt;&gt;</code> A<sup>-1</sup> == <code>id</code></p><p>=&gt; A<sup>-1</sup> <code>&lt;&gt;</code> A == <code>id</code></p></th><td><div><pre><code><span>from_list <span>=</span> lambda input<span>:</span> <span>set</span><span>(</span>input<span>)</span>
</span><span>to_list <span>=</span> lambda input<span>:</span> <span>list</span><span>(</span>input<span>)</span>
</span><span>
</span><span><span>&gt;&gt;&gt;</span> x <span>=</span> <span>[</span><span>&#39;foo&#39;</span><span>,</span> <span>&#39;bar&#39;</span><span>,</span> <span>&#39;bar&#39;</span><span>]</span>
</span><span><span>&gt;&gt;&gt;</span> x <span>==</span> <span>to_list</span><span>(</span><span>from_list</span><span>(</span>x<span>)</span><span>)</span>
</span><span><span>False</span>
</span><span>
</span></code></pre></div></td></tr></tbody><caption>Roundtrip failure</caption><tbody><tr><td>Fearlessly revert and swap domains</td><td>Optics, Deriving-Via</td></tr><tr><th scope="row">Finite + Enumerable</th><td><div><pre><code><span><span>is_odd</span><span>(</span>x<span>:</span> int<span>)</span> <span>-</span><span>&gt;</span> bool<span>:</span>
</span><span>    <span>if</span> x <span>==</span> <span>0</span><span>:</span> <span>False</span>
</span><span>    <span>if</span> x <span>==</span> <span>1</span><span>:</span> <span>True</span>
</span><span>    <span>if</span> x <span>==</span> <span>2</span><span>:</span> <span>False</span>
</span><span>    <span>if</span> x <span>==</span> <span>17</span><span>:</span> <span>True</span>
</span><span>
</span><span><span>&gt;&gt;&gt;</span> <span>is_odd</span><span>(</span><span>10000</span><span>)</span>
</span><span><span>**</span><span>*</span> error<span>!</span>
</span></code></pre></div></td></tr></tbody><caption>Missed edge case from non-exhaustive handling of inputs</caption><tbody><tr><td>Fearlessly pattern match</td><td>Rust&#39;s <code>Result</code> &amp; <code>Option</code></td></tr></tbody><caption>Figure 1: A small sampling of properties and the powers they grant.</caption></table></div><h2 id="to-be-continued"><a href="#to-be-continued" aria-hidden="true" tabindex="-1"><span></span></a>To Be Continued...</h2><p>That&#39;s all for now! The next two parts of this article will continue with examples of functional programming in practice. Then, we&#39;ll discuss how exploiting one&#39;s underlying algebra allows any technology to create fearless experiences. Lastly, the final article will introduce several promising functional technologies on the horizon and speculate about their fearless futures.<sup><a href="#user-content-fn-9" aria-describedby="footnote-label" data-footnote-ref="true" id="user-content-fnref-9">9</a></sup></p><p>‚úåÔ∏è</p><p><em>Thanks to Aaron Sewall and others for reviewing drafts of this article.</em></p></div><div><div><p>Something incorrect? Addition to propose? Please file an</p><!-- --> <p><a target="_blank" rel="nofollow" href="https://github.com/hkailahi/heneli.dev/issues">issue</a>. Comment to add? Join the discussion below by authorizing Giscus or commenting directly on the</p><!-- --> <p><a target="_blank" rel="nofollow" href="https://github.com/hkailahi/heneli.dev/discussions">Github Discussion</a>. Off-topic remarks, unfunny jokes, weirdly overfamiliar internet-speak, and bootlicking will be moved</p><!-- --> <p><a target="_blank" rel="nofollow" href="https://news.ycombinator.com/">here</a>.</p></div></div></div>
  </body>
</html>
