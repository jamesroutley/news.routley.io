<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ergaster.org/posts/2025/10/29-vscode-to-helix/">Original</a>
    <h1>From VS Code to Helix</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-2q5oecfc=""> <nav><ol><li><a href="#automation-is-a-double-edged-sword">Automation is a double-edged sword</a></li><li><a href="#why-i-feared-using-helix">Why I feared using Helix</a></li><li><a href="#what-helped">What Helped</a><ol><li><a href="#just-do-it">Just Do It</a></li><li><a href="#better-docs">Better docs</a></li></ol></li><li><a href="#getting-the-most-of-markdown-and-astro-in-helix">Getting the most of Markdown and Astro in Helix</a><ol><li><a href="#markdown">Markdown</a></li><li><a href="#astro">Astro</a></li><li><a href="#yaml">YAML</a></li></ol></li><li><a href="#is-it-worth-it">Is it worth it?</a></li></ol></nav><p>I created the website you’re reading with VS Code. Behind the scenes I use Astro, a static site generator that gets out of the way while providing nice conveniences.</p>
<p>Using VS Code was a no-brainer: everyone in the industry seems to at least be familiar with it, every project can be opened with it, and most projects can get enhancements and syntactic helpers in a few clicks. In short: VS Code is free, easy to use, and widely adopted.</p>
<p>A Rustacean colleague kept singing <a href="https://helix-editor.com/">Helix</a>’s praises. I discarded it because he’s much smarter than I am, and I only ever use vim when I need to fiddle with files on a server. I like when things “Just Work” and didn’t want to bother learning how to use Helix nor how to configure it.</p>
<p>Today it has become my daily driver. Why did I change my mind? What was preventing me from using it before? And how difficult was it to get there?</p>
<h2 id="automation-is-a-double-edged-sword"><a href="#automation-is-a-double-edged-sword">Automation is a double-edged sword</a></h2>
<p>Automation and technology make work easier, this is why we produce technology in the first place. But it also means you grow more dependent on the tech you use. If the tech is produced transparently by an international team or a team you trust, it’s fine. But if it’s produced by a single large entity that can screw you over, it’s dangerous.</p>
<p>VS Code might be open source, but in practice it’s produced by Microsoft. Microsoft has a problematic relationship to consent and is shoving AI products down everyone’s throat. I’d rather use tools that respect me and my decisions, and I’d rather not get my tools produced by already monopolistic organizations.</p>
<p>Microsoft is also based in the USA, and the political climate over there makes me want to depend as little as possible on American tools. I know that’s a long, uphill battle, but we have to start somewhere.</p>
<p>I’m not advocating for a ban against American tech in general, but for more balance in our supply chain. I’m also not advocating for European tech either: I’d rather get open source tools from international teams competing in a race to the top, rather than from teams in a single jurisdiction. What is happening in the USA could happen in Europe too.</p>
<h2 id="why-i-feared-using-helix"><a href="#why-i-feared-using-helix">Why I feared using Helix</a></h2>
<p>I’ve never found vim particularly pleasant to use but it’s everywhere, so I figured I might just get used to it. But one of the things I never liked about vim is the number of moving pieces. By default, vim and neovim are very bare bones. They can be extended and completely modified with plugins, but I really don’t like the idea of having extremely customize tools.</p>
<p>I’d rather have the same editor as everyone else, with a few knobs for minor preferences. I am subject to choice paralysis, so making me configure an editor before I’ve even started editing is the best way to tank my productivity.</p>
<p>When my colleague told me about Helix, two things struck me as improvements over vim.</p>
<ol>
<li><strong>Helix’s philosophy is that everything should work out of the box.</strong> There are a few configs and themes, but everything should work similarly from one Helix to another. All the language-specific logic is handled in Language Servers that implement the <a href="https://en.wikipedia.org/wiki/Language_Server_Protocol">Language Server Protocol</a> standard.</li>
<li><strong>In Helix, first you select text, and then you perform operations onto it.</strong> So you can visually tell what is going to be changed before you apply the change. It fits my mental model much better.</li>
</ol>
<p>But there are major drawbacks to Helix too:</p>
<ol>
<li><strong>After decades of vim, I was scared to re-learn everything.</strong> In practice this wasn’t a problem at all because of the very visual way Helix works.</li>
<li><strong>VS Code “Just Works”, and Helix sounded like more work than the few clicks from VS Code’s extension store.</strong> This is true, but not as bad as I had anticipated.</li>
</ol>
<p>After a single week of usage, Helix was already very comfortable to navigate. After a few weeks, most of the wrinkles have been ironed out and I use it as my primary editor. So how did I overcome those fears?</p>
<h2 id="what-helped"><a href="#what-helped">What Helped</a></h2>
<h3 id="just-do-it"><a href="#just-do-it">Just Do It</a></h3>
<p><strong>I tried Helix.</strong> It can sound silly, but the very first step to get into Helix was not to overthink it. I just installed it on my mac with <code>brew install helix</code> and gave it a go. I was not too familiar with it, so I looked up <a href="https://docs.helix-editor.com/usage.html">the official documentation</a> and noticed there was a tutorial.</p>
<p>This tutorial alone is what convinced me to try harder. It’s an interactive and well written way to learn how to move and perform basic operations in Helix. I quickly learned how to move around, select things, surround them with braces or parenthesis. I could <em>see</em> what I was about to do before doing it. This has been epiphany. Helix just worked the way I wanted.</p>
<p><img alt="A screenshot of the Helix tutorial open in a terminal. It mostly consists of text in a 80 character wide column. As the user reads the text, they learn new commands to move around and edit text." loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 1520px) 1520px, 100vw" data-astro-image="constrained" width="1520" height="1044" src="https://ergaster.org/_astro/helix-tutor.ke2dVx7w_WV66I.webp" srcset="/_astro/helix-tutor.ke2dVx7w_1YfIWi.webp 640w, /_astro/helix-tutor.ke2dVx7w_Z1tbanv.webp 750w, /_astro/helix-tutor.ke2dVx7w_ZUIAxz.webp 828w, /_astro/helix-tutor.ke2dVx7w_1n4RrQ.webp 1080w, /_astro/helix-tutor.ke2dVx7w_1WMsvp.webp 1280w, /_astro/helix-tutor.ke2dVx7w_WV66I.webp 1520w"/></p>
<p>Better: I could get things done faster than in VS Code after a few minutes of learning. Being a lazy person, I never bothered looking up VS Code shortcuts. Because the learning curve for Helix is slightly steeper, you <em>have</em> to learn those shortcuts that make moving around feel so easy.</p>
<p>Not only did I quickly get used to Helix key bindings: my vim muscle-memory didn’t get in the way at all!</p>
<h3 id="better-docs"><a href="#better-docs">Better docs</a></h3>
<p>The built-in tutorial is a very pragmatic way to get started. You get results fast, you learn hands on, and it’s not that long. But if you want to go further, you have to look for docs. Helix <a href="https://docs.helix-editor.com/">has officials docs</a>. They seem to be fairly complete, but they’re also impenetrable as a new user. They focus on what the editor supports and not on what I will want to do with it.</p>
<p>After a bit of browsing online, I’ve stumbled upon <a href="https://helix-nikita-revencos-projects.vercel.app/start-here/basics">this third-party documentation website</a>. The domain didn’t inspire me a lot of confidence, but the docs are really good. They are clearly laid out, use-case oriented, and they make the most of Astro Starlight to provide a great reading experience. The author <a href="https://github.com/helix-editor/helix/pull/12127#issuecomment-2525902615">tried to upstream these docs, but that won’t happen</a>. It looks like they are upstreaming their docs to the current website. I hope this will improve the quality of upstream docs eventually.</p>
<p>After learning the basics and finding my way through the docs, it was time to ensure Helix was set up to help me where I needed it most.</p>
<h2 id="getting-the-most-of-markdown-and-astro-in-helix"><a href="#getting-the-most-of-markdown-and-astro-in-helix">Getting the most of Markdown and Astro in Helix</a></h2>
<p>In my free time, I mostly use my editor for three things:</p>
<ol>
<li>Write notes in markdown</li>
<li>Tweak my website with Astro</li>
<li>Edit yaml to faff around my Kubernetes cluster</li>
</ol>
<p>Helix is a “stupid” text editor. It doesn’t know much about what you’re typing. But it supports Language Servers that implement the Language Server Protocol. Language Servers understand the document you’re editing. They explain to Helix what you’re editing, whether you’re in a TypeScript function, typing a markdown link, etc. With that information, Helix and the Language Server can provide code completion hints, errors &amp; warnings, and easier navigation in your code.</p>
<p>In addition to Language Servers, Helix also supports plugging code formatters. Those are pieces of software that will read the document and ensure that it is consistently formatted. It will check that all indentations use spaces and not tabs, that there is a consistent number of space when indenting, that brackets are on the same line as the function, etc. In short: it will make the code pretty.</p>
<h3 id="markdown"><a href="#markdown">Markdown</a></h3>
<p>Markdown is not really a programming language, so it might seem surprising to configure a Language Server for it. But if you remember what we said earlier, Language Servers can provide code completion, which is useful when creating links for example. <a href="https://github.com/artempyanykh/marksman">Marksman</a> does exactly that!</p>
<p>Since Helix <a href="https://docs.helix-editor.com/lang-support.html">is pre-configured to use marksman for markdown files</a> we only need to install marksman and make sure it’s in our <code>PATH</code>. Installing it with homebrew is enough.</p>

<p>We can check that Helix is happy with it with the following command</p>
<div><figure><pre data-language="console"><code><div><p><span>$ hx --health markdown</span></p></div><div><p><span>Configured language servers:</span></p></div><div><p><span><span>  </span></span><span>✓ marksman: /opt/homebrew/bin/marksman</span></p></div><div><p><span>Configured debug adapter: None</span></p></div><div><p><span>Configured formatter: None</span></p></div><div><p><span>Tree-sitter parser: ✓</span></p></div><div><p><span>Highlight queries: ✓</span></p></div><div><p><span>Textobject queries: ✘</span></p></div><div><p><span>Indent queries: ✘</span></p></div></code></pre></figure></div>
<p>But Language Servers can also help Helix display errors and warnings, and “code suggestions” to help fix the issues. It means Language Servers are a perfect fit for… grammar checkers! Several grammar checkers exist. The most notable are:</p>
<ul>
<li><a href="https://ltex-plus.github.io/ltex-plus/">LTEX+</a>, the Language Server used by <a href="https://languagetool.org/">Language Tool</a>. It supports several languages must is quite resource hungry.</li>
<li><a href="https://writewithharper.com/">Harper</a>, a grammar checker Language Server developed by Automattic, the people behind WordPress, Tumblr, WooCommerce, Beeper and more. Harper only support English and its variants, but they intend to support more languages in the future.</li>
</ul>
<p>I mostly write in English and want to keep a minimalistic setup. Automattic is well funded, and I’m confident they will keep working on Harper to improve it. Since grammar checker LSPs can easily be changed, I’ve decided to go with Harper for now.</p>
<p><img alt="A screenshot of Helix. The cursors is on the word &#34;place&#34; with a typo. The word is underlined. On the top right there is a warning message asking if the user intended to write the word like this." loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 1520px) 1520px, 100vw" data-astro-image="constrained" width="1520" height="1044" src="https://ergaster.org/_astro/helix-grammar-error.QcORNFVo_25IkSu.webp" srcset="/_astro/helix-grammar-error.QcORNFVo_VCrV1.webp 640w, /_astro/helix-grammar-error.QcORNFVo_Z2hdkPy.webp 750w, /_astro/helix-grammar-error.QcORNFVo_u8pfW.webp 828w, /_astro/helix-grammar-error.QcORNFVo_q8NWf.webp 1080w, /_astro/helix-grammar-error.QcORNFVo_ZtntcY.webp 1280w, /_astro/helix-grammar-error.QcORNFVo_25IkSu.webp 1520w"/></p>
<p>To install it, homebrew does the job as always:</p>

<p>Then I edited my <code>~/.config/helix/languages.toml</code> to add Harper as a secondary Language Server in addition to marksman</p>
<div><figure><pre data-language="toml"><code><div><p><span>[</span><span>language-server</span><span>.</span><span>harper-ls</span><span>]</span></p></div><div><p><span>command = </span><span>&#34;harper-ls&#34;</span></p></div><div><p><span>args = [</span><span>&#34;--stdio&#34;</span><span>]</span></p></div><div></div><div></div><div><p><span>[[</span><span>language</span><span>]]</span></p></div><div><p><span>name = </span><span>&#34;markdown&#34;</span></p></div><div><p><span>language-servers = [</span><span>&#34;marksman&#34;</span><span>, </span><span>&#34;harper-ls&#34;</span><span>]</span></p></div></code></pre></figure></div>
<p>Finally I can add a markdown linter to ensure my markdown is formatted properly. Several options exist, and <a href="https://github.com/DavidAnson/markdownlint">markdownlint</a> is one of the most popular. My colleagues recommended the new kid on the block, a <em>Blazing Fast</em> equivalent: <a href="https://github.com/rvben/rumdl">rumdl</a>.</p>
<p>Installing rumdl was pretty simple on my mac. I only had to add the repository of the maintainer, and install rumdl from it.</p>
<div><figure><pre data-language="console"><code><div><p><span>$ brew tap rvben/rumdl</span></p></div><div><p><span>$ brew install rumdl</span></p></div></code></pre></figure></div>
<p>After that I added a new <code>language-server</code> to my <code>~/.config/helix/languages.toml</code> and added it to the language servers to use for the markdown <code>language</code>.</p>
<div><figure><pre data-language="toml"><code><div><p><span>[</span><span>language-server</span><span>.</span><span>rumdl</span><span>]</span></p></div><div><p><span>command = </span><span>&#34;rumdl&#34;</span></p></div><div><p><span>args = [</span><span>&#34;server&#34;</span><span>]</span></p></div><div></div><div><p><span>[...]</span></p></div><div></div><div></div><div><p><span>[[</span><span>language</span><span>]]</span></p></div><div><p><span>name = </span><span>&#34;markdown&#34;</span></p></div><div><p><span>language-servers = [</span><span>&#34;marksman&#34;</span><span>, </span><span>&#34;harper-ls&#34;</span><span>, </span><span>&#34;rumdl&#34;</span><span>]</span></p></div><div><p><span>soft-wrap.enable = </span><span>true</span></p></div><div><p><span>text-width = </span><span>80</span></p></div><div><p><span>soft-wrap.wrap-at-text-width = </span><span>true</span></p></div></code></pre></figure></div>
<p>Since my website already contained a <code>.markdownlint.yaml</code> I could import it to the rumdl format with</p>
<div><figure><pre data-language="console"><code><div><p><span>$ rumdl import .markdownlint.yaml</span></p></div><div><p><span>Converted markdownlint config from &#39;.markdownlint.yaml&#39; to &#39;.rumdl.toml&#39;</span></p></div><div><p><span>You can now use: rumdl check --config .rumdl.toml .</span></p></div></code></pre></figure></div>
<p>You might have noticed that I’ve added a little quality of life improvement: soft-wrap at 80 characters.</p>
<p>Now if you add this to your own <code>config.toml</code> you will notice that the text is completely left aligned. This is not a problem on small screens, but it rapidly gets annoying on wider screens.</p>
<p>Helix doesn’t support centering the editor. There is <a href="https://github.com/helix-editor/helix/pull/9838">a PR tackling the problem</a> but it has been stale for most of the year. The maintainers are overwhelmed by the number of PRs making it their way, and it’s not clear if or when this PR will be merged.</p>
<p>In the meantime, a workaround exists, with a few caveats. It is possible to add spaces to the left gutter (the column with the line numbers) so it pushes the content towards the center of the screen.</p>
<p><img alt="A screenshot of Helix editing markdown. The column is 80 character wide and centered in the screen." loading="lazy" decoding="async" fetchpriority="auto" sizes="(min-width: 3408px) 3408px, 100vw" data-astro-image="constrained" width="3408" height="2110" src="https://ergaster.org/_astro/helix-zen-mode.Aup4KvDq_1tEuBf.webp" srcset="/_astro/helix-zen-mode.Aup4KvDq_dgVBO.webp 640w, /_astro/helix-zen-mode.Aup4KvDq_1AMJeD.webp 750w, /_astro/helix-zen-mode.Aup4KvDq_Z17PUS3.webp 828w, /_astro/helix-zen-mode.Aup4KvDq_1iPz5z.webp 1080w, /_astro/helix-zen-mode.Aup4KvDq_1q994v.webp 1280w, /_astro/helix-zen-mode.Aup4KvDq_Z1SYODT.webp 1668w, /_astro/helix-zen-mode.Aup4KvDq_1D8XxE.webp 2048w, /_astro/helix-zen-mode.Aup4KvDq_Z2fWAsQ.webp 2560w, /_astro/helix-zen-mode.Aup4KvDq_1tEuBf.webp 3408w"/></p>
<p>To figure out how many spaces are needed, you need to get your terminal width with <code>stty</code></p>

<p>In my case, when in full screen, my terminal is 243 characters wide. I need to remove the content column with from it, and divide everything by 2 to get the space needed on each side. In my case for a 243 character wide terminal with a text width of 80 characters:</p>

<p>As is, I would add 203 spaces to my left gutter to push the rest of the gutter and the content to the right. But the gutter itself has a width of 4 characters, that I need to remove from the total. So I need to subtract them from the total, which leaves me with <code>76</code> characters to add.</p>
<p>I can open my <code>~/.config/helix/config.toml</code> to add a new key binding that will automatically add or remove those spaces from the left gutter when needed, to shift the content towards the center.</p>
<div><figure><pre data-language="toml"><code><div><p><span>[</span><span>keys</span><span>.</span><span>normal</span><span>.</span><span>space</span><span>.</span><span>t</span><span>]</span></p></div><div><p><span>z = </span><span>&#34;:toggle gutters.line-numbers.min-width 76 3&#34;</span></p></div></code></pre></figure></div>
<p>Now when in normal mode, pressing <kbd>Space</kbd> then <kbd>t</kbd> then <kbd>z</kbd> will add/remove the spaces. Of course this workaround only works when the terminal runs in full screen mode.</p>
<h3 id="astro"><a href="#astro">Astro</a></h3>
<p>Astro works like a charm in VS Code. The team behind it provides <a href="https://github.com/withastro/language-tools?tab=readme-ov-file#astrojslanguage-server">a Language Server</a> and a <a href="https://github.com/withastro/language-tools?tab=readme-ov-file#astrojsts-plugin">TypeScript plugin</a> to enable code completion and syntax highlighting.</p>
<p>I only had to install those globally with</p>
<div><figure><pre data-language="console"><code><div><p><span>$ pnpm install -g @astrojs/language-server typescript @astrojs/ts-plugin</span></p></div></code></pre></figure></div>
<p>Now we need to add a few lines to our <code>~/.config/helix/languages.toml</code> to tell it how to use the language server</p>
<div><figure><pre data-language="toml"><code><div><p><span>[</span><span>language-server</span><span>.</span><span>astro-ls</span><span>]</span></p></div><div><p><span>command = </span><span>&#34;astro-ls&#34;</span></p></div><div><p><span>args = [</span><span>&#34;--stdio&#34;</span><span>]</span></p></div><div><p><span>config = { typescript = { tsdk = </span><span>&#34;/Users/thibaultmartin/Library/pnpm/global/5/node_modules/typescript/lib&#34;</span><span> }}</span></p></div><div></div><div><p><span>[[</span><span>language</span><span>]]</span></p></div><div><p><span>name = </span><span>&#34;astro&#34;</span></p></div><div><p><span>scope = </span><span>&#34;source.astro&#34;</span></p></div><div><p><span>injection-regex = </span><span>&#34;astro&#34;</span></p></div><div><p><span>file-types = [</span><span>&#34;astro&#34;</span><span>]</span></p></div><div><p><span>language-servers = [</span><span>&#34;astro-ls&#34;</span><span>]</span></p></div></code></pre></figure></div>
<p>We can check that the Astro Language Server can be used by helix with</p>
<div><figure><pre data-language="console"><code><div><p><span>$ hx --health astro</span></p></div><div><p><span>Configured language servers:</span></p></div><div><p><span><span>  </span></span><span>✓ astro-ls: /Users/thibaultmartin/Library/pnpm/astro-ls</span></p></div><div><p><span>Configured debug adapter: None</span></p></div><div><p><span>Configured formatter: None</span></p></div><div><p><span>Tree-sitter parser: ✓</span></p></div><div><p><span>Highlight queries: ✓</span></p></div><div><p><span>Textobject queries: ✘</span></p></div><div><p><span>Indent queries: ✘</span></p></div></code></pre></figure></div>
<p>I also like to get a formatter to automatically make my code consistent and pretty for me when I save a file. One of the most popular code formaters out there is <a href="https://prettier.io/">Prettier</a>. I’ve decided to go with the fast and easy formatter <a href="https://dprint.dev/">dprint</a> instead.</p>
<p>I installed it with</p>

<p>Then in the projects I want to use dprint in, I do</p>

<p>I might edit the <code>dprint.json</code> file to my liking. Finally, I configure Helix to use dprint globally for all Astro projects by appending a few lines in my <code>~/.config/helix/languages.toml</code>.</p>
<div><figure><pre data-language="toml"><code><div><p><span>[[</span><span>language</span><span>]]</span></p></div><div><p><span>name = </span><span>&#34;astro&#34;</span></p></div><div><p><span>scope = </span><span>&#34;source.astro&#34;</span></p></div><div><p><span>injection-regex = </span><span>&#34;astro&#34;</span></p></div><div><p><span>file-types = [</span><span>&#34;astro&#34;</span><span>]</span></p></div><div><p><span>language-servers = [</span><span>&#34;astro-ls&#34;</span><span>]</span></p></div><div><p><span>formatter = { command = </span><span>&#34;dprint&#34;</span><span>, args = [</span><span>&#34;fmt&#34;</span><span>, </span><span>&#34;--stdin&#34;</span><span>, </span><span>&#34;astro&#34;</span><span>]}</span></p></div><div><p><span>auto-format = </span><span>true</span></p></div></code></pre></figure></div>
<p>One final check, and I can see that Helix is ready to use the formatter as well</p>
<div><figure><pre data-language="console"><code><div><p><span>$ hx --health astro</span></p></div><div><p><span>Configured language servers:</span></p></div><div><p><span><span>  </span></span><span>✓ astro-ls: /Users/thibaultmartin/Library/pnpm/astro-ls</span></p></div><div><p><span>Configured debug adapter: None</span></p></div><div><p><span>Configured formatter:</span></p></div><div><p><span><span>  </span></span><span>✓ /opt/homebrew/bin/dprint</span></p></div><div><p><span>Tree-sitter parser: ✓</span></p></div><div><p><span>Highlight queries: ✓</span></p></div><div><p><span>Textobject queries: ✘</span></p></div><div><p><span>Indent queries: ✘</span></p></div></code></pre></figure></div>
<h3 id="yaml"><a href="#yaml">YAML</a></h3>
<p>For yaml, it’s simple and straightforward: Helix is preconfigured to use <code>yaml-language-server</code> as soon as it’s in the PATH. I just need to install it with</p>
<div><figure><pre data-language="console"><code><div><p><span>$ brew install yaml-language-server</span></p></div></code></pre></figure></div>
<h2 id="is-it-worth-it"><a href="#is-it-worth-it">Is it worth it?</a></h2>
<p><strong>Helix really grew on me. I find it particularly easy and fast to edit code with it.</strong> It takes a tiny bit more work to get the language support than it does in VS Code, but it’s nothing insurmountable. There is a slightly steeper learning curve than for VS Code, but I consider it to be a good thing. It forced me to learn how to move around and edit efficiently, because there is no way to do it inefficiently. Helix remains intuitive once you’ve learned the basics.</p>
<p>I am a GNOME enthusiast, and I adhere to the same principles: <strong>I like when my apps work out of the box, and when I have little to do to configure them.</strong> This is a strong stance that often attracts a vocal opposition. I like products that follow those principles better than those who don’t.</p>
<p>With that said, Helix sometimes feels like it is maintained by one or two people who have a strong vision, but who struggle to onboard more maintainers. As of writing, Helix has more than 350 PRs open. Quite a few bring interesting features, but the maintainers don’t have enough time to review them.</p>
<p>Those 350 PRs mean there is a lot of energy and goodwill around the project. <strong>People are willing to contribute. Right now, all that energy is gated, resulting in frustration</strong> both from the contributors who feel like they’re working in the void, and the maintainers who feel like there at the receiving end of a fire hose.</p>
<p><strong>A solution to make everyone happier without sacrificing the quality of the project would be to work on a Contributor Ladder.</strong> CHAOSS’ Dr Dawn Foster published <a href="https://fastwonderblog.com/2025/08/12/governance-part-3-new-contributors-and-pathways-to-leadership/">a blog post about it</a>, listing interesting resources at the end.</p> </div></div>
  </body>
</html>
