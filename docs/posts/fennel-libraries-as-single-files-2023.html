<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://andreyor.st/posts/2023-08-27-fennel-libraries-as-single-files/">Original</a>
    <h1>Fennel libraries as single files (2023)</h1>
    
    <div id="readability-page-1" class="page"><article>
    <p>I’m pleased to announce that most of my libraries for fennel are now shipped as single files!
It was a long-standing issue with Fennel for me, as there was no clear way to ship both macros and functions in the same file, but after some experimentation, I figured out a way.
After a bit of testing with my new library for <a href="https://gitlab.com/andreyorst/async.fnl" target="_blank">asynchronous programming</a> I can say that it works well enough to be used in most other libraries.
Although the implementation is a bit rough and manual, that’s what I’ll try to describe here today.</p>
<p>But first, let’s talk modules.
This will be a long post, so buckle up.</p>
<h2 id="modules-in-various-programming-languages">Modules in various programming languages</h2>
<p>I find it fascinating that a lot of languages have some kind of a module system, yet most of them hide it from the user behind some special keywords and don’t allow us to operate on modules as we can do with other objects.
Lua is not one of these languages - its module system is ingenious and yet very simple.
First, let’s look at some other languages so you can understand what I’m getting at.</p>
<p>For example, here’s Elixir, a language I sometimes tinker with.
I’m using an interactive elixir shell, but it’ll be the same even if I were to put this module into a file:</p>
<div><pre tabindex="0"><code data-lang="elixir"><span><span>iex(1)&gt; <span>defmodule</span> <span>Lib</span> <span>do</span>
</span></span><span><span>...(1)&gt;   <span>def</span> foo(), <span>do</span>: <span>&#34;foo&#34;</span>
</span></span><span><span>...(1)&gt;   <span>def</span> bar(), <span>do</span>: <span>&#34;bar&#34;</span>
</span></span><span><span>...(1)&gt; <span>end</span>
</span></span><span><span>{<span>:module</span>, <span>Lib</span>,
</span></span><span><span> &lt;&lt;70, 79, 82, 49, 0, 0, 5, 180, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 169,
</span></span><span><span>   0, 0, 0, 18, 10, 69, 108, 105, 120, 105, 114, 46, 70, 111, 111, 8, 95, 95,
</span></span><span><span>   105, 110, 102, 111, 95, 95, 10, 97, 116, ...&gt;&gt;, {<span>:bar</span>, 0}}
</span></span><span><span>iex(2)&gt; <span>Lib</span>
</span></span><span><span><span>Lib</span>
</span></span><span><span>iex(3)&gt; <span>Lib</span>.foo()
</span></span><span><span><span>&#34;foo&#34;</span>
</span></span></code></pre></div><p>You can see that after the module was defined, we can see a tuple with some keywords, the module symbol, and other stuff.
If we try to examine <code>Lib</code> in the shell it just prints <code>Lib</code>.
Yet, we can call the function <code>foo</code> from this module via the dot syntax: <code>Lib.foo()</code></p>
<p>If we try to inspect what <code>Lib</code> actually is, we can see that it has a bunch of information but, at least to me, this tells almost nothing of substance:</p>
<div><pre tabindex="0"><code data-lang="elixir"><span><span>iex(4)&gt; i <span>Lib</span>
</span></span><span><span><span>Term</span>
</span></span><span><span>  <span>Lib</span>
</span></span><span><span><span>Data</span> type
</span></span><span><span>  <span>Atom</span>
</span></span><span><span><span>Module</span> bytecode
</span></span><span><span>  []
</span></span><span><span><span>Source</span>
</span></span><span><span>  iex
</span></span><span><span><span>Version</span>
</span></span><span><span>  [249975233796634777878553557963106734802]
</span></span><span><span><span>Compile</span> options
</span></span><span><span>  [<span>:no_spawn_compiler_process</span>, <span>:from_core</span>, <span>:no_core_prepare</span>, <span>:no_auto_import</span>]
</span></span><span><span><span>Description</span>
</span></span><span><span>  <span>Call</span> <span>Lib</span>.module_info() to access metadata.
</span></span><span><span><span>Raw</span> representation
</span></span><span><span>  <span>:&#34;Elixir.Lib&#34;</span>
</span></span><span><span><span>Reference</span> modules
</span></span><span><span>  <span>Module</span>, <span>Atom</span>
</span></span><span><span><span>Implemented</span> protocols
</span></span><span><span>  <span>IEx.Info</span>, <span>Inspect</span>, <span>List.Chars</span>, <span>String.Chars</span>
</span></span></code></pre></div><p>Let’s look at another language, that I don’t often tinker with, but a lot of other people do - Python.
This time I’ll put this into a file, as I don’t know the shell capabilities of Python, and if it is possible to do stuff like in Elixir.
Here’s the same module:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span><span># lib.py</span>
</span></span><span><span><span>def</span> <span>foo</span> ():
</span></span><span><span>    <span>return</span> <span>&#34;foo&#34;</span>
</span></span><span><span>
</span></span><span><span><span>def</span> <span>bar</span> ():
</span></span><span><span>    <span>return</span> <span>&#34;bar&#34;</span>
</span></span></code></pre></div><p>Now, if we <code>import</code> it, we can at least see some indication of what <code>lib</code> is when we try to inspect it:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>&gt;&gt;&gt; <span>import</span> <span>lib</span>
</span></span><span><span>&gt;&gt;&gt; lib
</span></span><span><span>&lt;module <span>&#39;lib&#39;</span> <span>from</span> <span>&#39;/tmp/lib.py&#39;</span>&gt;
</span></span><span><span>&gt;&gt;&gt; lib.foo()
</span></span><span><span><span>&#39;foo&#39;</span>
</span></span></code></pre></div><p>What is this <code>&lt;module &#39;lib&#39; from &#39;/tmp/lib.py&#39;&gt;</code> thing actually?
Python defines different keywords for working with modules, like <code>from</code>, <code>import</code>, <code>as</code>, and maybe others, as well as a special set of functions to query the module, like <code>dir</code>.
But the module itself is probably some kind of an object:</p>
<div><pre tabindex="0"><code data-lang="python"><span><span>&gt;&gt;&gt; <span>type</span>(lib)
</span></span><span><span>&lt;<span>class</span> <span>&#39;</span><span>module</span><span>&#39;&gt;</span>
</span></span></code></pre></div><p>Here’s another language, that I know better than Python or Elixir - Clojure.
In Clojure, similar to Elixir, you can define modules in the REPL, so let’s do this:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>user&gt;</span> (<span>ns </span><span>lib</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>lib&gt;</span> (<span>defn </span><span>foo</span> [] <span>&#34;foo&#34;</span>)
</span></span><span><span>#<span>&#39;lib/foo</span>
</span></span><span><span><span>lib&gt;</span> (<span>defn </span><span>bar</span> [] <span>&#34;bar&#34;</span>)
</span></span><span><span>#<span>&#39;lib/bar</span>
</span></span><span><span><span>lib&gt;</span> (<span>in-ns </span><span>&#39;user</span>)
</span></span><span><span>#<span>namespace</span>[<span>user</span>]
</span></span><span><span><span>user&gt;</span> (<span>require</span> <span>&#39;lib</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>user&gt;</span> (<span>lib/foo</span>)
</span></span><span><span><span>&#34;foo&#34;</span>
</span></span></code></pre></div><p>Once again, we can see that the namespace is some kind of <code>#namespace[user]</code> thingy.
If we try to reference the namespace as is in the REPL, we get an error:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>user&gt;</span> <span>lib</span>
</span></span><span><span><span>Syntax</span> <span>error</span> <span>compiling</span> <span>at</span> (<span>*cider-repl</span> <span>blog/posts</span><span>:localhost:44133</span>(<span>clj</span>)<span>*</span><span>:0:0</span>)<span>.</span>
</span></span><span><span><span>Unable</span> <span>to</span> <span>resolve </span><span>symbol</span><span>:</span> <span>lib</span> <span>in</span> <span>this</span> <span>context</span>
</span></span></code></pre></div><p>However, Clojure provides us with a set of <code>ns-*</code> functions to work with namespaces.
For instance, we can get all interned symbols of the namespace as a map:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>user&gt;</span> (<span>ns-interns </span><span>&#39;lib</span>)
</span></span><span><span>{<span>bar</span> #<span>&#39;lib/bar</span>, <span>foo</span> #<span>&#39;lib/foo</span>}
</span></span></code></pre></div><p>We can even go back to the <code>lib</code> module, define a private function, return to the <code>user</code> module, and inspect the <code>lib</code> module again:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>user&gt;</span> (<span>in-ns </span><span>&#39;lib</span>)
</span></span><span><span>#<span>namespace</span>[<span>lib</span>]
</span></span><span><span><span>lib&gt;</span> (<span>defn </span>^<span>:private</span> <span>baz</span> [] <span>&#34;baz&#34;</span>)
</span></span><span><span>#<span>&#39;lib/baz</span>
</span></span><span><span><span>lib&gt;</span> (<span>in-ns </span><span>&#39;user</span>)
</span></span><span><span>#<span>namespace</span>[<span>user</span>]
</span></span><span><span><span>user&gt;</span> (<span>ns-interns </span><span>&#39;lib</span>)
</span></span><span><span>{<span>baz</span> #<span>&#39;lib/baz</span>, <span>bar</span> #<span>&#39;lib/bar</span>, <span>foo</span> #<span>&#39;lib/foo</span>}
</span></span><span><span><span>user&gt;</span> (<span>ns-publics </span><span>&#39;lib</span>)
</span></span><span><span>{<span>bar</span> #<span>&#39;lib/bar</span>, <span>foo</span> #<span>&#39;lib/foo</span>}
</span></span></code></pre></div><p>Yet, modules are something hidden from us, we usually don’t operate on them directly.</p>
<p>So that brings us to Fennel, and therefore Lua.
I will demonstrate things in Fennel just for better clarity, as it provides better inspection capabilities.</p>
<p>What separates Lua runtime from the rest is that its modules are <em>just tables</em>.
When we’re writing a library, or just a module in our application, the module is just a file on the file system, and at the end of that file the last statement returns a table (or a function):</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;; lib.fnl</span>
</span></span><span><span>(<span>fn </span><span>foo</span> [] <span>&#34;foo&#34;</span>)
</span></span><span><span>(<span>fn </span><span>bar</span> [] <span>&#34;bar&#34;</span>)
</span></span><span><span>(<span>fn </span><span>baz</span> [] <span>&#34;baz&#34;</span>)
</span></span><span><span>
</span></span><span><span>{<span>:foo</span> <span>foo</span>
</span></span><span><span> <span>:bar</span> <span>bar</span>}
</span></span></code></pre></div><p>In this case, the table holds references to local functions, and thus the <code>baz</code> function is completely private.
When we require this module with the <code>require</code> function it somehow finds the file of this module on disc, loads it, evaluates the top level, and returns the table, which we just then store in a variable, same as any other value:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>lib</span> (<span>require </span><span>&#34;lib&#34;</span>))
</span></span><span><span><span>&gt;&gt;</span> (<span>lib.foo</span>)
</span></span><span><span><span>&#34;foo&#34;</span>
</span></span></code></pre></div><p>If we try to reference <code>lib</code> here, we’ll see that it is just a table, nothing special:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> <span>lib</span>
</span></span><span><span>{<span>:bar</span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfecd350&gt;</span>
</span></span><span><span> <span>:foo</span> #<span>&lt;function</span><span>: </span>0<span>x55f4cff20610&gt;</span>}
</span></span><span><span><span>&gt;&gt;</span> (<span>getmetatable </span><span>lib</span>)
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>We can check if it has a metatable that hides some module-related trickery, but it’s not.
It’s a plain ol’ Lua table.</p>
<h2 id="lua-module-system">Lua module system</h2>
<p>But Lua doesn’t stop there.
I mentioned that <code>require</code> evaluates the top level, so if we put something like <code>(print &#34;hi!&#34;)</code> into a module, and require it, we’ll see the text being printed:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;; qux.fnl</span>
</span></span><span><span>(<span>fn </span><span>qux</span> [] <span>&#34;qux&#34;</span>)
</span></span><span><span>(<span>print </span><span>&#34;hi!&#34;</span>)
</span></span><span><span>{<span>:qux</span> <span>qux</span>}
</span></span></code></pre></div><p>Here’s how it looks in the Fennel REPL:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require </span><span>:qux</span>)
</span></span><span><span><span>hi!</span>
</span></span><span><span>{<span>:qux</span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfe7a1e0&gt;</span>}	<span>&#34;./qux.fnl&#34;</span>
</span></span></code></pre></div><p>But if we do a second <code>require</code> the print won’t happen:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require </span><span>:qux</span>)
</span></span><span><span>{<span>:qux</span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfe7a1e0&gt;</span>}
</span></span></code></pre></div><p>This is because while the modules are plain tables, the <code>require</code> function is actually smarter than just read+eval.
Module loading process in Lua ensures that modules are only loaded once, and are cached in a special <code>package</code> table.</p>
<h3 id="package-dot-loaded-caching-module-definitions"><code>package.loaded</code> - caching module definitions</h3>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> <span>package.loaded.qux</span>
</span></span><span><span>{<span>:qux</span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfe7a1e0&gt;</span>}
</span></span></code></pre></div><p>So each time we call <code>(require :something)</code> it first looks if <code>package.loaded.something</code> exists, and if it is, it just returns the value from there.
This way, we can unload any module, just by setting a key in the <code>package.loaded</code> to <code>nil</code>, and then <code>require</code> will re-evaluate our module.
Fennel actually provides a REPL command for that, called <code>reload</code>.</p>
<p>However, it’s still not that simple.
Lua’s <code>require</code> is actually extensible.
If the module was not found in the <code>package.loaded</code> the next place <code>require</code> checks is <code>package.preload</code>.</p>
<h3 id="package-dot-preload-preloading-modules-via-anonymous-functions"><code>package.preload</code> - preloading modules via anonymous functions</h3>
<p>This table stores modules in a similar way, except instead of storing tables, it stores functions that when called will load a module.</p>
<p>We can utilize this in the REPL:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>fn </span><span>package.preload.my-lib</span> []
</span></span><span><span>     (<span>print </span><span>&#34;loading my-lib&#34;</span>)
</span></span><span><span>     (<span>fn </span><span>hello</span> [<span>name</span>]
</span></span><span><span>       (<span>.. </span><span>&#34;hi &#34;</span> <span>name</span> <span>&#34;!&#34;</span>))
</span></span><span><span>     {<span>:hello</span> <span>hello</span>})
</span></span><span><span>#<span>&lt;function</span><span>: </span>0<span>x55f4d4a23d50&gt;</span>
</span></span><span><span><span>&gt;&gt;</span> <span>package.preload.my-lib</span>
</span></span><span><span>#<span>&lt;function</span><span>: </span>0<span>x55f4d4a23d50&gt;</span>
</span></span></code></pre></div><p>I’ve created a function in that table, that when called will signal that the module is loaded, define a local function, and return a table, referencing that function.
So it’s essentially the same as the file approach, except it is stored in a function, which execution is delayed until someone tries to <code>require</code> the module.
Lua was meant to be able to work in filesystem-less environments, and this is one of the solutions for storing libraries.</p>
<p>When we <code>require</code> the <code>my-lib</code> module, we see the <code>loading my-lib</code> message, but instead of providing a second value with the file from where the module was read, the value is <code>:preload:</code>:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require </span><span>:my-lib</span>)
</span></span><span><span><span>loading</span> <span>my-lib</span>
</span></span><span><span>{<span>:hello</span> #<span>&lt;function</span><span>: </span>0<span>x55f4d4a4ecf0&gt;</span>}	<span>&#34;:preload:&#34;</span>
</span></span></code></pre></div><p>This indicates that the library was indeed loaded from the <code>package.preload</code> table.
We can then use it as normal:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>my-lib</span> (<span>require </span><span>:my-lib</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>my-lib.hello</span> <span>&#34;Bob&#34;</span>)
</span></span><span><span><span>&#34;hi Bob!&#34;</span>
</span></span></code></pre></div><p>This already gives us some power, and Fennel utilizes <code>package.preload</code> to provide fully self-contained AOT-compiled Lua files that can be shipped without any external dependencies.
Yet, there’s a final step in this system that we can discuss.</p>
<h3 id="package-dot-searchers-extending-the-module-system"><code>package.searchers</code> - extending the module system</h3>
<p>If the module was found neither in the <code>package.loaded</code> nor in the <code>package.preload</code>, the <code>require</code> function starts using special <code>package.searchers</code>:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> <span>package.searchers</span>
</span></span><span><span>[#<span>&lt;function</span><span>: </span>0<span>x55f4cfc8b930&gt;</span>
</span></span><span><span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfc8b970&gt;</span>
</span></span><span><span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfc8b9b0&gt;</span>
</span></span><span><span> #<span>&lt;function</span><span>: </span>0<span>x55f4cfc8b9f0&gt;</span>
</span></span><span><span> #<span>&lt;function</span><span>: </span>0<span>x55f4cff32450&gt;</span>]
</span></span></code></pre></div><p>It’s another table in the <code>package</code> table, that stores a list of functions, that will try to find and load the given module by their own means.
Let’s write our own:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>table.insert</span>
</span></span><span><span>    <span>package.searchers</span>
</span></span><span><span>    (<span>fn </span>[<span>mod</span>]
</span></span><span><span>      (<span>io.write </span><span>&#34;searching &#34;</span> <span>mod</span> <span>&#34; with a custom searcher\n&#34;</span>)
</span></span><span><span>      (<span>fn </span><span>loader</span> []
</span></span><span><span>        (<span>fn </span><span>bye</span> [<span>name</span>]
</span></span><span><span>          (<span>: </span><span>&#34;bye %s&#34;</span> <span>:format</span> <span>name</span>))
</span></span><span><span>        {<span>:bye</span> <span>bye</span>})
</span></span><span><span>      (<span>values </span><span>loader</span> <span>mod</span>)))
</span></span></code></pre></div><p>This searcher function in our case will work for any module regardless of its existence, so by doing this we kinda broke the loading mechanism.
Still, this might be useful in some sandboxing scenarios.
Alternatively, this mechanism can be used if the environment you run Lua in doesn’t have a real file system, so finding a module requires some trickery, and thus you can extend the general <code>require</code> mechanism.
What our function does is not as complicated - it’s similar to what we did in the <code>preload</code> example, except what makes it different is that it basically allows us to do whatever we want before this <code>loader</code> function is given back to the runtime.</p>
<p>We can see it works:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require </span><span>:asdf</span>)
</span></span><span><span><span>searching</span> <span>asdf</span> <span>with</span> <span>a</span> <span>custom</span> <span>searcher</span>
</span></span><span><span>{<span>:bye</span> #<span>&lt;function</span><span>: </span>0<span>x55ec3e592ae0&gt;</span>}	<span>&#34;asdf&#34;</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>require </span><span>:qwer</span>)
</span></span><span><span><span>searching</span> <span>qwer</span> <span>with</span> <span>a</span> <span>custom</span> <span>searcher</span>
</span></span><span><span>{<span>:bye</span> #<span>&lt;function</span><span>: </span>0<span>x55ec3e529460&gt;</span>}	<span>&#34;qwer&#34;</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>require </span><span>:asdf</span>)
</span></span><span><span>{<span>:bye</span> #<span>&lt;function</span><span>: </span>0<span>x55ec3e592ae0&gt;</span>}
</span></span><span><span><span>&gt;&gt;</span>
</span></span></code></pre></div><p>And that it obeys the same caching rules.</p>
<p>This <code>package.searchers</code> table is the sole reason why Fennel works as seamlessly as it is.
Setting up Fennel’s package searcher means that when we’re trying to <code>require</code> some <code>module</code> if there is a <code>module.fnl</code> file on the <code>FENNEL_PATH</code>, Fennel will compile this module, and then load it as a normal Lua module.
If you want to implement your own Lua-based language, this is definitely the place to embed your compiler.</p>
<p>Now that you have an idea of how modules work in Lua, let’s discuss the main topic of this post - single-file Fennel libraries, and complications related to it.</p>
<h2 id="fennel-libraries-with-macros">Fennel libraries with macros</h2>
<p>A library in Fennel obeys the exact same rules as a Lua library, except the Fennel compiler adds some steps to the whole process of library loading.
As I explained in the <a href="#package-dot-searchers-extending-the-module-system">searchers topic</a>, the compiler is invoked on the module file before it is given to the Lua runtime.
This means, that when we’re loading a Fennel file, it first gets compiled to Lua, and only then it is loaded.
This works well up until we introduce compile-time features into our modules - mainly macros.</p>
<p>If we look back at Clojure and Elixir examples, I didn’t use macros in the modules - let’s fix this:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>lib&gt;</span> (<span>defmacro </span><span>unless</span> [<span>test </span>&amp; <span>body</span>] `(<span>when-not </span>~<span>test </span>~@<span>body</span>))
</span></span><span><span>#<span>&#39;lib/my-do</span>
</span></span><span><span><span>lib&gt;</span> <span>unless</span>
</span></span><span><span><span>Syntax</span> <span>error</span> <span>compiling</span> <span>at</span> (<span>*cider-repl</span> <span>blog/posts</span><span>:localhost:44133</span>(<span>clj</span>)<span>*</span><span>:0:0</span>)<span>.</span>
</span></span><span><span><span>Can</span><span>&#39;t</span> <span>take </span><span>value</span> <span>of</span> <span>a</span> <span>macro</span><span>:</span> #<span>&#39;lib/unless</span>
</span></span><span><span><span>lib&gt;</span> (<span>ns-interns </span><span>&#39;lib</span>)
</span></span><span><span>{<span>baz</span> #<span>&#39;lib/baz</span>, <span>bar</span> #<span>&#39;lib/bar</span>, <span>unless</span> #<span>&#39;lib/unless</span>, <span>foo</span> #<span>&#39;lib/foo</span>}
</span></span></code></pre></div><p>If we try to take a value of the macro, we get an error, as macros are a compile-time construct.
Yet, it is referenced in the <code>ns-intern</code> as a var.
And we can go back to the <code>user</code> module, and use our macro from there:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>lib&gt;</span> (<span>in-ns </span><span>&#39;user</span>)
</span></span><span><span>#<span>namespace</span>[<span>user</span>]
</span></span><span><span><span>user&gt;</span> (<span>lib/unless</span> <span>true</span> (<span>println </span><span>&#34;this should never be printed&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>In Elixir, it is similar, as you also can provide a macro in your module, and upon requiring the module you can use a macro from it.
Here’s an example macro from the <a href="https://elixir-lang.org/getting-started/meta/macros.html#our-first-macro" target="_blank">docs</a>:</p>
<div><pre tabindex="0"><code data-lang="elixir"><span><span>iex(2)&gt; <span>defmodule</span> <span>Unless</span> <span>do</span>
</span></span><span><span>...(2)&gt;   <span>defmacro</span> <span>unless</span>(clause, <span>do</span>: expression) <span>do</span>
</span></span><span><span>...(2)&gt;     <span>quote</span> <span>do</span>
</span></span><span><span>...(2)&gt;       <span>if</span>(!<span>unquote</span>(clause), <span>do</span>: <span>unquote</span>(expression))
</span></span><span><span>...(2)&gt;     <span>end</span>
</span></span><span><span>...(2)&gt;   <span>end</span>
</span></span><span><span>...(2)&gt; <span>end</span>
</span></span><span><span>{<span>:module</span>, <span>Unless</span>,
</span></span><span><span> &lt;&lt;70, 79, 82, 49, 0, 0, 6, 72, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 191,
</span></span><span><span>   0, 0, 0, 20, 13, 69, 108, 105, 120, 105, 114, 46, 85, 110, 108, 101, 115,
</span></span><span><span>   115, 8, 95, 95, 105, 110, 102, 111, 95, 95, ...&gt;&gt;, {<span>:unless</span>, 2}}
</span></span><span><span>iex(3)&gt; <span>Unless</span>.<span>unless</span> <span>true</span>, <span>do</span>: <span>IO</span>.puts <span>&#34;this should never be printed&#34;</span>
</span></span><span><span>this should never be printed
</span></span><span><span>** (<span>UndefinedFunctionError</span>) function <span>Unless</span>.macro_unless/2 is undefined <span>or</span> private.
</span></span><span><span>      <span>However</span>, there is a macro with the same name <span>and</span> arity.
</span></span><span><span>      <span>Be</span> sure to <span>require</span> <span>Unless</span> <span>if</span> you intend to invoke this macro
</span></span><span><span>    <span>Unless</span>.<span>unless</span>(<span>true</span>, [<span>do</span>: <span>:ok</span>])
</span></span><span><span>    iex:3: (file)
</span></span></code></pre></div><p>Except, we can’t use this macro right away - unlike in Clojure, we need to <code>require</code> the module:</p>
<div><pre tabindex="0"><code data-lang="elixir"><span><span>iex(3)&gt; <span>require</span> <span>Unless</span>
</span></span><span><span><span>Unless</span>
</span></span><span><span>iex(4)&gt; <span>Unless</span>.<span>unless</span> <span>true</span>, <span>do</span>: <span>IO</span>.puts <span>&#34;this should never be printed&#34;</span>
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>Because Elixir’s macros are entirely Elixir’s concept, BEAM knows nothing about them, and thus you can use them only in Elixir, and it explains why the shell requires some additional steps.
Perhaps these can be automated, as Clojure can do it without any additional <code>require</code> calls, but I don’t know for sure how it is done in Clojure or in Elixir.</p>
<p>I’m bringing Elixir and Clojure here because both languages are hosted on their respective runtimes - Erlang’s BEAM and JVM.
Fennel is similarly hosted on Lua, but on the other hand, is different from these two when it comes to macros.</p>
<p>Let’s add the <code>unless</code> macro to the <code>lib.fnl</code> module:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;; lib.fnl</span>
</span></span><span><span>(<span>fn </span><span>foo</span> [] <span>&#34;foo&#34;</span>)
</span></span><span><span>(<span>fn </span><span>bar</span> [] <span>&#34;bar&#34;</span>)
</span></span><span><span>(<span>macro </span><span>unless</span> [<span>test</span> <span>...</span>]
</span></span><span><span>  `(<span>when </span>(<span>not </span><span>,</span><span>test</span>) <span>,</span><span>...</span>))
</span></span><span><span>{<span>:foo</span> <span>foo</span> <span>:bar</span> <span>bar</span> <span>:unless</span> <span>unless</span>}
</span></span></code></pre></div><p>Trying to load this module, however, will result in a compile error:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>local </span><span>lib</span> (<span>require </span><span>:lib</span>))
</span></span><span><span><span>./lib.fnl</span><span>:5:27</span> <span>Compile</span> <span>error</span><span>: </span><span>tried</span> <span>to</span> <span>reference</span> <span>a</span> <span>macro </span><span>without</span> <span>calling</span> <span>it</span>
</span></span><span><span>
</span></span><span><span>{<span>:foo</span> <span>foo</span> <span>:bar</span> <span>bar</span> <span>:unless</span> <span>unless</span>}
</span></span><span><span><span>* </span><span>Try</span> <span>renaming</span> <span>the</span> <span>macro </span><span>so</span> <span>as</span> <span>not </span><span>to</span> <span>conflict</span> <span>with</span> <span>locals.</span>
</span></span></code></pre></div><p>We can’t simply export our macro alongside our functions.
What should we do then?</p>
<p>The fennel language <a href="https://fennel-lang.org/reference#macros" target="_blank">reference</a> suggests that macros can’t be referenced and exported alongside functions
And that <code>macro</code> is supposed to be used only as file-local macros, and thus these can’t be exported.
Additionally to that, when writing <a href="https://fennel-lang.org/reference#macros-define-several-macros" target="_blank">macros</a>, we can’t access any surrounding code.
The reference section then says that in order to export macros we can put them into a separate module and use <code>import-macros</code> to import them to the arbitrary code.</p>
<p>The whole macro system in Fennel is not as advanced as in other lisps or as in Elixir, but it gets the job done, it just requires some squats to be done.</p>
<h3 id="macro-modules">Macro modules</h3>
<p>A macro module is exactly the same as an ordinary Fennel module - it shares the same file extension, same syntax, but is meant to be used in conjunction with <code>import-macros</code> or <code>require-macros</code> specials.
To write a macro module we can simply put our <code>unless</code> macro into a separate file, replacing <code>macro</code> with <code>fn</code>:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;; unless.fnl</span>
</span></span><span><span>(<span>fn </span><span>unless</span> [<span>test</span> <span>...</span>]
</span></span><span><span>  `(<span>when </span>(<span>not </span><span>,</span><span>test</span>) <span>,</span><span>...</span>))
</span></span><span><span>
</span></span><span><span>{<span>:unless</span> <span>unless</span>}
</span></span></code></pre></div><p>That’s right, in Fennel, macros are ordinary functions running in a compiler environment, and now we actually can export them as an ordinary table.
The compiler environment defines additional functions that we can use in macros, such as <code>quote</code> and <code>unquote</code> which we’re using here in the forms of <code>`</code> and <code>,</code>.
Now we can require this module with <code>import-macros</code>:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>import-macros </span><span>Unless</span> <span>:unless</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>Unless.unless</span> <span>true</span> (<span>print </span><span>&#34;this should never be printed&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>Unless.unless</span> <span>false</span> (<span>print </span><span>&#34;this should be printed&#34;</span>))
</span></span><span><span><span>this</span> <span>should</span> <span>be</span> <span>printed</span>
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>There’s also another special that can import macros from a module: <code>require-macros</code>.
Unlike <code>import-macros</code> it doesn’t put macros in a binding, instead, it pollutes the current scope with all of the macros from the module:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require-macros </span><span>:unless</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>unless</span> <span>true</span> (<span>print </span><span>&#34;this should be printed&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>So <code>(import-macros name module)</code> is much like <code>(local name (require module))</code> but for macro modules, and it uses <code>require-macros</code> underneath.</p>
<h3 id="import-macros-and-require"><code>import-macros</code> and <code>require</code></h3>
<p>Speaking of the relationship between <code>import-macros</code> and <code>require</code>, they indeed work similarly.
Fennel’s developers understood that Lua’s module system is very flexible and decided to make a similar interface for macros.</p>
<p>You couldn’t see it, but in the previous example, when I called <code>require-macros</code> on the <code>unless</code> module again, it didn’t re-read the module from disk.
Instead, it used the same technique of caching, much like <code>package.loaded</code> but instead, it uses <code>fennel.macro-loaded</code> to store macros.
We can see that by requiring Fennel in the REPL and inspecting the table:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>fennel</span> (<span>require </span><span>:fennel</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> <span>fennel.macro-loaded</span>
</span></span><span><span>{<span>:unless</span> {<span>:unless</span> #<span>&lt;function</span><span>: </span>0<span>x56224adc40a0&gt;</span>}}
</span></span></code></pre></div><p>We can even do the same thing as with the <code>package.loaded</code>, and set the <code>unless</code> module to <code>nil</code> with <code>(set fennel.macro-loaded.unless nil)</code>
If we then add some side-effecting code, like <code>(print &#34;macros!&#34;)</code> to the module, and require it again, we’ll see that Fennel will re-read our module:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>set </span><span>fennel.macro-loaded.unless</span> <span>nil</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>import-macros </span><span>Unless</span> <span>:unless</span>)
</span></span><span><span><span>macros!</span>
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>import-macros </span><span>Unless</span> <span>:unless</span>)
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>But only once, much like with ordinary <code>require</code>.</p>
<p>Similarly to Lua, Fennel provides its own table with searcher functions for macros:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> <span>fennel.macro-searchers</span>
</span></span><span><span>[#<span>&lt;function</span><span>: </span>0<span>x56224ac5a740&gt;</span> #<span>&lt;function</span><span>: </span>0<span>x56224ac5a7f0&gt;</span>]
</span></span></code></pre></div><p>So the system is extremely similar, the only thing it lacks is something akin to <code>package.preload</code> but for macros.
With that in mind let me introduce you to the library problem.</p>
<h3 id="the-library-problem">The library problem</h3>
<p>Let’s imagine, we want to write a library that provides you with a lot of functions, and with some convenience macros that remove some boilerplate.
In reality, almost anything can be done without macros, but macros are great for writing code that you don’t want to write yourself.
So let’s say we want to add polymorphic dispatch to Fennel by adding multimethods.</p>
<p>Let’s write the functions first:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>multi</span> [<span>dispatch-fn</span>]
</span></span><span><span>  (<span>let </span>[<span>methods</span> {}]
</span></span><span><span>    (<span>setmetatable</span>
</span></span><span><span>     {<span>:add-method</span> (<span>fn </span>[<span>dispatch-val</span> <span>fn1</span>]
</span></span><span><span>                    (<span>tset </span><span>methods</span> <span>dispatch-val</span> <span>fn1</span>))
</span></span><span><span>      <span>:get-method</span> (<span>fn </span>[<span>dispatch-val</span>]
</span></span><span><span>                    (<span>. </span><span>methods</span> <span>dispatch-val</span>))
</span></span><span><span>      <span>:remove-method</span> (<span>fn </span>[<span>dispatch-val</span>]
</span></span><span><span>                       (<span>tset </span><span>methods</span> <span>dispatch-val</span> <span>nil</span>))}
</span></span><span><span>     {<span>:__call</span> (<span>fn </span>[<span>self</span> <span>...</span>]
</span></span><span><span>                (<span>let </span>[<span>method</span> (<span>self.get-method</span> (<span>dispatch-fn</span> <span>...</span>))]
</span></span><span><span>                  (<span>method</span> <span>...</span>)))})))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>add-method</span> [<span>multi</span> <span>dispatch-val</span> <span>method</span>]
</span></span><span><span>  (<span>multi.add-method</span> <span>dispatch-val</span> <span>method</span>))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>get-method</span> [<span>multi</span> <span>dispatch-val</span>]
</span></span><span><span>  (<span>multi.get-method</span> <span>dispatch-val</span>))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>remove-method</span> [<span>multi</span> <span>dispatch-val</span>]
</span></span><span><span>  (<span>multi.remove-method</span> <span>dispatch-val</span>))
</span></span><span><span>
</span></span><span><span>{<span>:multi</span> <span>multi</span>
</span></span><span><span> <span>:add-method</span> <span>add-method</span>
</span></span><span><span> <span>:get-method</span> <span>get-method</span>
</span></span><span><span> <span>:remove-method</span> <span>remove-method</span>}
</span></span></code></pre></div><p>The idea is simple.
We create an object with the function <code>multi</code> and give it a <code>dispatch-fn</code> - the function it will invoke with the arguments to determine what method it needs to call.
If there is a method, it will be called with the same arguments as the <code>dispatch-fn</code> functions.
I also provided convenience functions that provide some abstraction over the inner implementation of the multimethod object.
Let’s try it:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>mult</span> (<span>require </span><span>:multimethods</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>local </span><span>interact</span> (<span>mult.multi</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>))))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>mult.add-method</span> <span>interact</span> <span>&#34;bunny lion&#34;</span> (<span>fn </span>[<span>bunny</span> <span>lion</span>] <span>&#34;bunny runs away&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>mult.add-method</span> <span>interact</span> <span>&#34;lion bunny&#34;</span> (<span>fn </span>[<span>lion</span> <span>bunny</span>] <span>&#34;lion eats bunny&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>mult.add-method</span> <span>interact</span> <span>&#34;lion lion&#34;</span> (<span>fn </span>[<span>lion1</span> <span>lion2</span>] <span>&#34;lions fight&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>mult.add-method</span> <span>interact</span> <span>&#34;bunny bunny&#34;</span> (<span>fn </span>[<span>bunny1</span> <span>bunny2</span>] <span>&#34;bunnies mate&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>interact</span> {<span>:type</span> <span>&#34;bunny&#34;</span>} {<span>:type</span> <span>&#34;lion&#34;</span>})
</span></span><span><span><span>&#34;bunny runs away&#34;</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>interact</span> {<span>:type</span> <span>&#34;lion&#34;</span>} {<span>:type</span> <span>&#34;bunny&#34;</span>})
</span></span><span><span><span>&#34;lion eats bunny&#34;</span>
</span></span></code></pre></div><p>I opted for a simple example, where I just get the <code>type</code> field of each object and concatenate them into a string.
Then we dispatch on that string.</p>
<p>The library is now complete, but it’s a bit tedious to type all of these anonymous functions every time, let’s add an interface similar to how Clojure does this.
We’ll add two macros <code>defmulti</code>, which given a name and a dispatch fn will create a local variable by itself, and <code>defmethod</code> which will act the same as <code>add-method</code> except it will construct the anonymous function for us.
We start by creating the macro module:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>defmulti</span> [<span>name</span> <span>dispatch-fn</span>]
</span></span><span><span>  `(<span>local </span><span>,</span><span>name</span> (<span>mult.multi</span> <span>,</span><span>dispatch-fn</span>)))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>defmethod</span> [<span>name</span> <span>dispatch-val</span> <span>...</span>]
</span></span><span><span>  `(<span>mult.add-method</span> <span>,</span><span>name</span> <span>,</span><span>dispatch-val</span> (<span>fn </span><span>,</span><span>...</span>)))
</span></span><span><span>
</span></span><span><span>{<span>:defmulti</span> <span>defmulti</span>
</span></span><span><span> <span>:defmethod</span> <span>defmethod</span>}
</span></span></code></pre></div><p>We already have the multimethod itself, so let’s try our <code>defmethod</code> macro:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require-macros </span><span>:multimethod-macros</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>defmethod</span> <span>interact</span> <span>&#34;ship rock&#34;</span> [<span>ship</span> <span>_rock</span>] (<span>.. </span><span>ship.name</span> <span>&#34; sinks&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>interact</span> {<span>:type</span> <span>&#34;ship&#34;</span> <span>:name</span> <span>&#34;Wasa&#34;</span>} {<span>:type</span> <span>&#34;rock&#34;</span>})
</span></span><span><span><span>&#34;Wasa sinks&#34;</span>
</span></span></code></pre></div><p>It works, but did you notice the problem?
Let’s try this again, but instead, let’s call our library something else in the REPL:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>mmethods</span> (<span>require </span><span>:multimethods</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>require-macros </span><span>:multimethod-macros</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>defmulti</span> <span>interact</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>)))
</span></span><span><span><span>unknown</span><span>:2:?</span> <span>Compile</span> <span>error</span><span>: </span><span>unknown</span> <span>identifier</span><span>: </span><span>mult</span>
</span></span></code></pre></div><p>Looking into the macroexpansion of <code>defumilti</code> we see that it does exactly what we told it:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>macrodebug </span>(<span>defmulti</span> <span>interact</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>))))
</span></span><span><span>(<span>local </span><span>interact</span> (<span>mult.multi</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>))))
</span></span></code></pre></div><p>Except, the <code>mult</code> is nowhere to be found.</p>
<p>So, here’s the problem - we need to reuse functions from our function module in the macro module.
Unfortunately, there’s literally no way to do it without making some assumptions about the module name.
Instead of using available binding in the macro, we can require the library because it’s cached:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>defmulti</span> [<span>name</span> <span>dispatch-fn</span>]
</span></span><span><span>  `(<span>local </span><span>,</span><span>name</span> (<span>let </span>[<span>mmethods#</span> (<span>require </span><span>:multimethods</span>)]
</span></span><span><span>                  (<span>mmethods#.multi</span> <span>,</span><span>dispatch-fn</span>))))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>defmethod</span> [<span>name</span> <span>dispatch-val</span> <span>...</span>]
</span></span><span><span>  `(<span>let </span>[<span>mmethods#</span> (<span>require </span><span>:multimethods</span>)]
</span></span><span><span>     (<span>mmethods#.add-method</span> <span>,</span><span>name</span> <span>,</span><span>dispatch-val</span> (<span>fn </span><span>,</span><span>...</span>))))
</span></span><span><span>
</span></span><span><span>{<span>:defmulti</span> <span>defmulti</span>
</span></span><span><span> <span>:defmethod</span> <span>defmethod</span>}
</span></span></code></pre></div><p>With this change, everything starts working:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>mmethods</span> (<span>require </span><span>:multimethods</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>require-macros </span><span>:multimethod-macros</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>defmethod</span> <span>interact</span> <span>&#34;ship rock&#34;</span> [<span>ship</span> <span>_rock</span>] (<span>.. </span><span>ship.name</span> <span>&#34; sinks&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>interact</span> {<span>:type</span> <span>&#34;ship&#34;</span> <span>:name</span> <span>&#34;Wasa&#34;</span>} {<span>:type</span> <span>&#34;rock&#34;</span>})
</span></span><span><span><span>&#34;Wasa sinks&#34;</span>
</span></span></code></pre></div><p>But there’s another problem - what if the user of our library doesn’t like that the module file name is <code>multimethods.fnl</code> and wants to rename it?
Suppose they already have their own multimethods module and want to try out ours alongside it, so they rename it to <code>aorst-multimethods.fnl</code>.
Required macros will suddenly stop working because in our macros we hardcoded the <code>multimethods</code> module name.</p>
<h4 id="init-dot-fnl-and-init-macros-dot-fnl"><code>init.fnl</code> and <code>init-macros.fnl</code></h4>
<p>One solution to this problem is to use Lua’s other hidden module mechanic, related to how the searchers work.</p>
<p>In Lua, we can load a file by giving <code>require</code> a module name that matches that file, like <code>require &#34;foo&#34;</code> will probably load the <code>foo.lua</code> file.
However, we can also load a directory in the same way - instead of creating <code>foo.lua</code> we can create a directory <code>foo</code> and write the contents of <code>foo.lua</code> into <code>foo/init.lua</code>.
Then, calling <code>require &#34;foo&#34;</code> will seamlessly load code from <code>init.lua</code>, but it will look like we’re loaded a directory.</p>
<p>Fennel supports the same thing for ordinary modules with <code>init.fnl</code>, but in addition to that, it also supports this for macro modules with <code>init-macros.fnl</code>.
We can re-implement our multimethod library this way, but we’ll change how we require the library in the macros:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;; multimethods-lib/init-macros.fnl</span>
</span></span><span><span>(<span>local </span><span>lib-module</span> <span>...</span>) <span>;; for relative require</span>
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>defmulti</span> [<span>name</span> <span>dispatch-fn</span>]
</span></span><span><span>  `(<span>local </span><span>,</span><span>name</span> (<span>let </span>[<span>mmethods#</span> (<span>require </span><span>,</span><span>lib-module</span>)]
</span></span><span><span>                  (<span>mmethods#.multi</span> <span>,</span><span>dispatch-fn</span>))))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>defmethod</span> [<span>name</span> <span>dispatch-val</span> <span>...</span>]
</span></span><span><span>  `(<span>let </span>[<span>mmethods#</span> (<span>require </span><span>,</span><span>lib-module</span>)]
</span></span><span><span>     (<span>mmethods#.add-method</span> <span>,</span><span>name</span> <span>,</span><span>dispatch-val</span> (<span>fn </span><span>,</span><span>...</span>))))
</span></span><span><span>
</span></span><span><span>{<span>:defmulti</span> <span>defmulti</span>
</span></span><span><span> <span>:defmethod</span> <span>defmethod</span>}
</span></span></code></pre></div><p>This trick is called relative-require.
It’s quite common in Lua, but I decided to use it when I was trying to ship huge libraries with lots of macros and inner modules.</p>
<p>When the module is loaded, Lua passes the module name to the module as an argument.
This <code>(local lib-module ...)</code> captures it in the <code>lib-module</code> variable, and then we can refer to it in our macros.
If we now look at what our macros expand to, we’ll see that they use the module name correctly:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>mmethods</span> (<span>require </span><span>:multimethods-lib</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>require-macros </span><span>:multimethods-lib</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>macrodebug </span>(<span>defmulti</span> <span>interact</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>))))
</span></span><span><span>(<span>local </span><span>interact</span>
</span></span><span><span>  (<span>let </span>[<span>mmethods_2_auto</span> (<span>require </span><span>&#34;multimethods-lib&#34;</span>)]
</span></span><span><span>    (<span>mmethods_2_auto.multi</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>)))))
</span></span><span><span><span>nil</span>
</span></span></code></pre></div><p>Now our macros are unbound from the library name itself.
However, shipping library in this way is not that great.
For example, here’s how one of my libraries that uses this technique looks if you peek into the library root:</p>
<div><pre tabindex="0"><code data-lang="text"><span><span>.
</span></span><span><span>├── CHANGELOG.md
</span></span><span><span>├── CODE_OF_CONDUCT.md
</span></span><span><span>├── CONTRIBUTING.md
</span></span><span><span>├── doc/
</span></span><span><span>├── fennel-test/
</span></span><span><span>├── impl/
</span></span><span><span>├── init.fnl
</span></span><span><span>├── init-macros.fnl
</span></span><span><span>├── LICENSE
</span></span><span><span>├── Makefile
</span></span><span><span>├── README.md
</span></span><span><span>└── tests/
</span></span></code></pre></div><p>Basically, it’s the project’s root, and if you want to use this library, the easiest way is to just git-clone the project and require it.
But it means that there are lots of unrelated files, and there’s no way to know what files are related unless the project has some kind of manifest, which is not the case for Fennel projects.
It would be much better if you could just grab only the <code>init.fnl</code> file, name it however you want, and require both macros and functions from it.</p>
<h4 id="require-as-include">Require-as-include</h4>
<p>Fennel has a feature that can do almost that.
For multi-file libraries, we can AOT compile all of the Fennel code into Lua, and the compiler will inject all of the dependencies in an interesting way.
It does so by tracking what modules we <code>require</code> and splicing them into the code by using <code>package.preload</code> trick I’ve described way earlier in this post:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>foo</span> []
</span></span><span><span>  <span>&#34;some-lib&#39;s foo&#34;</span>)
</span></span><span><span>
</span></span><span><span>{<span>: </span><span>foo</span>}
</span></span></code></pre></div><div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>local </span><span>some-lib</span> (<span>require </span><span>:some-lib</span>))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>my-foo</span> []
</span></span><span><span>  (<span>some-lib.foo</span>))
</span></span><span><span>
</span></span><span><span>{<span>:my-foo</span> <span>my-foo</span>}
</span></span></code></pre></div><p>If we call <code>fennel --require-as-include -c my-lib.fnl</code>, we’ll get the following code:</p>
<div><pre tabindex="0"><code data-lang="lua"><span><span><span>local</span> some_lib
</span></span><span><span>package.preload[<span>&#34;some-lib&#34;</span>] = package.preload[<span>&#34;some-lib&#34;</span>] <span>or</span> <span>function</span>(...)
</span></span><span><span>  <span>local</span> <span>function</span> <span>foo</span>()
</span></span><span><span>    <span>return</span> <span>&#34;some-lib&#39;s foo&#34;</span>
</span></span><span><span>  <span>end</span>
</span></span><span><span>  <span>return</span> {foo = foo}
</span></span><span><span><span>end</span>
</span></span><span><span>some_lib = require(<span>&#34;some-lib&#34;</span>)
</span></span><span><span><span>local</span> <span>function</span> <span>my_foo</span>()
</span></span><span><span>  <span>return</span> some_lib.foo()
</span></span><span><span><span>end</span>
</span></span><span><span><span>return</span> {[<span>&#34;my-foo&#34;</span>] = my_foo}
</span></span></code></pre></div><p>As can be seen, the whole module definition of <code>some-lib</code> was included in the file as an entry in the <code>package.preload</code>.
In the later code, it is required and used as normal.</p>
<p>However, this doesn’t work with macros, as there is no <code>fennel.macro-preloaded</code> or something similar.
And for a long enough time, I wasn’t sure if it was possible to mimic this behavior at compile time.
But then I remembered that we indeed have the module name at compile time, as clearly shown in the relative-require example.</p>
<h3 id="mimicking-preload-behavior-for-macros">Mimicking preload behavior for macros</h3>
<p>Here’s what I came up with:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>eval-compiler</span>
</span></span><span><span>  (<span>local </span><span>lib-module</span> <span>...</span>)
</span></span><span><span>
</span></span><span><span>  (<span>fn </span><span>defmulti</span> [<span>name</span> <span>dispatch-fn</span>]
</span></span><span><span>    `(<span>local </span><span>,</span><span>name</span>
</span></span><span><span>       (<span>let </span>[<span>mmethods#</span> (<span>require </span><span>,</span><span>lib-module</span>)]
</span></span><span><span>         (<span>mmethods#.multi</span> <span>,</span><span>dispatch-fn</span>))))
</span></span><span><span>
</span></span><span><span>  (<span>fn </span><span>defmethod</span> [<span>name</span> <span>dispatch-val</span> <span>...</span>]
</span></span><span><span>    `(<span>let </span>[<span>mmethods#</span> (<span>require </span><span>,</span><span>lib-module</span>)]
</span></span><span><span>       (<span>mmethods#.add-method</span> <span>,</span><span>name</span> <span>,</span><span>dispatch-val</span> (<span>fn </span><span>,</span><span>...</span>))))
</span></span><span><span>
</span></span><span><span>  (<span>tset </span><span>macro-loaded</span> <span>lib-module</span>
</span></span><span><span>        {<span>:defmulti</span> <span>defmulti</span>
</span></span><span><span>         <span>:defmethod</span> <span>defmethod</span>}))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>multi</span> [<span>dispatch-fn</span>]
</span></span><span><span>  (<span>let </span>[<span>methods</span> {}]
</span></span><span><span>    (<span>setmetatable</span>
</span></span><span><span>     {<span>:add-method</span> (<span>fn </span>[<span>dispatch-val</span> <span>fn1</span>]
</span></span><span><span>                    (<span>tset </span><span>methods</span> <span>dispatch-val</span> <span>fn1</span>))
</span></span><span><span>      <span>:get-method</span> (<span>fn </span>[<span>dispatch-val</span>]
</span></span><span><span>                    (<span>. </span><span>methods</span> <span>dispatch-val</span>))
</span></span><span><span>      <span>:remove-method</span> (<span>fn </span>[<span>dispatch-val</span>]
</span></span><span><span>                       (<span>tset </span><span>methods</span> <span>dispatch-val</span> <span>nil</span>))}
</span></span><span><span>     {<span>:__call</span> (<span>fn </span>[<span>self</span> <span>...</span>]
</span></span><span><span>                (<span>let </span>[<span>method</span> (<span>self.get-method</span> (<span>dispatch-fn</span> <span>...</span>))]
</span></span><span><span>                  (<span>method</span> <span>...</span>)))})))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>add-method</span> [<span>multi</span> <span>dispatch-val</span> <span>method</span>]
</span></span><span><span>  (<span>multi.add-method</span> <span>dispatch-val</span> <span>method</span>))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>get-method</span> [<span>multi</span> <span>dispatch-val</span>]
</span></span><span><span>  (<span>multi.get-method</span> <span>dispatch-val</span>))
</span></span><span><span>
</span></span><span><span>(<span>fn </span><span>remove-method</span> [<span>multi</span> <span>dispatch-val</span>]
</span></span><span><span>  (<span>multi.remove-method</span> <span>dispatch-val</span>))
</span></span><span><span>
</span></span><span><span>{<span>:multi</span> <span>multi</span>
</span></span><span><span> <span>:add-method</span> <span>add-method</span>
</span></span><span><span> <span>:get-method</span> <span>get-method</span>
</span></span><span><span> <span>:remove-method</span> <span>remove-method</span>}
</span></span></code></pre></div><p>Finally, we can require our library and macros from the same module, and it doesn’t have to be a directory!
Here’s how it looks:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>local </span><span>mm</span> (<span>require </span><span>:combined-multimethods</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>require-macros </span><span>:combined-multimethods</span>)
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>defmulti</span> <span>interact</span> (<span>fn </span>[<span>a</span> <span>b</span>] (<span>.. </span><span>a.type</span> <span>&#34; &#34;</span> <span>b.type</span>)))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>defmethod</span> <span>interact</span> <span>&#34;ship rock&#34;</span> [<span>ship</span> <span>_rock</span>] (<span>.. </span><span>ship.name</span> <span>&#34; sinks&#34;</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>interact</span> {<span>:type</span> <span>&#34;ship&#34;</span> <span>:name</span> <span>&#34;Wasa&#34;</span>} {<span>:type</span> <span>&#34;rock&#34;</span>})
</span></span><span><span><span>&#34;Wasa sinks&#34;</span>
</span></span></code></pre></div><p>So, it’s a combination of techniques, but what exactly is <code>eval-compiler</code> doing here?</p>
<p>If you look closely at <code>evel-compiler</code> body, you’ll see that instead of exporting the table at the end of the scope we simply set it to the <code>macro-loaded</code> table.
We use the module name which was set to <code>combined-multimethods</code> when the module was required, and thus the <code>macro-loaded.combined-multimethods</code> now stores the table with macro definitions.
Then, when <code>require-macros</code> looks up the macro module <code>combined-multimethods</code>, it sees that it was already loaded, and simply returns it without trying to find a file with these macros.
Alternatively, we could define a macro-searcher that, given a specific <code>module-name</code> would do the same thing, loading macros while avoiding trying to find a file, but it’s more work for almost no benefit over what we have here already.</p>
<h4 id="preprocessor-as-include">Preprocessor-as-include</h4>
<p>There’s still a problem though.
What if we want to write a library, that uses another library, that uses macros in this way?</p>
<p>One such example is my <a href="https://gitlab.com/andreyorst/fennel-cljlib" target="_blank">cljlib</a> library I keep re-implementing every few months or so.
In that library I also wanted to ship macros and functions in the same module, but here’s a problem - this library depends on other libraries, namely <a href="https://gitlab.com/andreyorst/lazy-seq" target="_blank">lazy-seq</a> and <a href="https://gitlab.com/andreyorst/itable" target="_blank">itable</a>.
While <code>itable</code> doesn’t provide any macros, <code>lazy-seq</code> does, and <code>cljlib</code> re-uses these macros.</p>
<p>Before some recent changes I made to both <code>lazy-seq</code> and <code>cljlib</code> you had to fiddle with <code>FENNEL_PATH</code> and <code>FENNEL_MACRO_PATH</code> in order to use <code>cljlib</code>, and you had to check out the full repository with submodules.
I feel like this is way too much work for most people, and I don’t want anyone to suffer that much, so I changed it to use the trick above and embedded other libraries into it by manually writing the <code>package.preload</code> trick instead of relying on <code>--require-as-include</code> flag.
Here’s how it looks in the <code>src/cljlib.fnl</code> file:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>;;; itable</span>
</span></span><span><span>(<span>set </span><span>package.preload.itable</span>
</span></span><span><span>  (<span>or </span><span>package.preload.itable</span>
</span></span><span><span>      (<span>fn </span>[<span>...</span>]
</span></span><span><span><span>;;;###include itable/src/itable.fnl</span>
</span></span><span><span>        )))
</span></span><span><span>
</span></span><span><span><span>;;; lazy-seq</span>
</span></span><span><span>(<span>set </span><span>package.preload.lazy-seq</span>
</span></span><span><span>  (<span>or </span><span>package.preload.lazy-seq</span>
</span></span><span><span>      (<span>fn </span>[<span>...</span>]
</span></span><span><span><span>;;;###include lazy-seq/lazy-seq.fnl</span>
</span></span><span><span>        )))
</span></span><span><span>
</span></span><span><span><span>;;; cljlib</span>
</span></span><span><span>(<span>eval-compiler</span>
</span></span><span><span>  (<span>local </span><span>lib-name</span> (<span>or </span><span>...</span> <span>:cljlib</span>))
</span></span><span><span>  <span>;; macros ...</span>
</span></span><span><span>  )
</span></span><span><span><span>;; functions ...</span>
</span></span></code></pre></div><p>These <code>;;;###include path</code> comments are nothing special from the perspective of Fennel, but I made a small <code>build.fnl</code> script for the library that takes care of them:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>spit-lib</span> [<span>path</span> <span>to</span>]
</span></span><span><span>  (<span>with-open </span>[<span>lib</span> (<span>io.open </span><span>path</span>)]
</span></span><span><span>    (<span>each </span>[<span>line</span> (<span>lib</span><span>:lines</span>)]
</span></span><span><span>      <span>;; patching compile-time variable used to store macro module</span>
</span></span><span><span>      <span>;; name because when loafing the combined file it will always</span>
</span></span><span><span>      <span>;; equal the main module and will break macros in vendored</span>
</span></span><span><span>      <span>;; libraries.</span>
</span></span><span><span>      (<span>case</span> (<span>line</span><span>:match</span> <span>&#34;%(local lib%-name %(or %.%.%. (.*)&#34;</span>)
</span></span><span><span>        <span>name</span> (<span>to</span><span>:write</span> (<span>.. </span><span>&#34;(local lib-name (or &#34;</span> <span>name</span> <span>&#34;\n&#34;</span>))
</span></span><span><span>        <span>_</span> (<span>to</span><span>:write</span> <span>line</span> <span>&#34;\n&#34;</span>)))))
</span></span><span><span>
</span></span><span><span>(<span>with-open </span>[<span>cljlib</span> (<span>io.open </span><span>&#34;./cljlib.fnl&#34;</span> <span>:w</span>)]
</span></span><span><span>  (<span>let </span>[<span>main</span> (<span>io.open </span><span>&#34;src/cljlib.fnl&#34;</span>)]
</span></span><span><span>    (<span>each </span>[<span>line</span> (<span>main</span><span>:lines</span>)]
</span></span><span><span>      (<span>case</span> (<span>line</span><span>:match</span> <span>&#34;;;;###include (.*)&#34;</span>)
</span></span><span><span>        (<span>path</span>) (<span>spit-lib</span> <span>path</span> <span>cljlib</span>)
</span></span><span><span>        <span>_</span> (<span>cljlib</span><span>:write</span> <span>line</span> <span>&#34;\n&#34;</span>)))))
</span></span></code></pre></div><p>It is meant to be used only for development, the library is pre-built and ready for anyone to grab.
What’s interesting about this script is that it also patches the library it includes.
This was a pain to figure out.</p>
<p>You see, in the <code>lazy-seq</code> library I’m using the same <code>eval-compiler</code> trick, and it in turn uses the <code>(local lib-name (or ... :lazy-seq))</code> trick.
However, when this library is spliced into our main file as is, when we load this file as <code>(require :cljlib)</code>, the <code>...</code> becomes <code>&#34;cljlib&#34;</code>, and the <code>lazy-seq</code> library, included in this file will write its macros into <code>macro-loaded.cljlib</code> instead of supposed <code>macro-loaded.lazy-seq</code>.
This can’t be worked around, as this happens way before <code>package.preload.lazy-seq</code> runs, so the <code>...</code> provided by the function in that table is never used by <code>eval-compiler</code>.
The only way to delay the <code>eval-compiler</code> is to put it into the file or use the searcher that will evaluate this block of code by itself which is way too tricky.</p>
<p>So I made a hack, that while splicing the library code scans for any occurrences of the <code>(local lib-name (or ...</code> pattern, and replaces it with the name used in the <code>or</code> expression, without checking <code>...</code>.
This way, the <code>(local lib-name (or ... :lazy-seq))</code> becomes <code>(local lib-name (or :lazy-seq))</code> in the final version of <code>cljlib.fnl</code>.
Of course, it is extremely finicky, as even an introduction of a newline between <code>lib-name</code> and <code>(or ...)</code> expression will break this.
Changing <code>lib-name</code> to something else will also break this down.</p>
<p>But even with this kind of monkey-patching it works well enough, as I control what code goes in both libraries, and the user doesn’t need to think about it at all.
All that is needed to do is just to grab the <code>cljlib.fnl</code> from the repo root and put it into the project.
I’ve updated <a href="https://gitlab.com/andreyorst/fenneldoc" target="_blank">Fenneldoc</a> to use the newer version of <code>cljlib</code> and was pleased to see that it still works.</p>
<h2 id="fixing-macros-in-fennel">Fixing macros in Fennel</h2>
<p>Even with the ability to ship macros in the same file as functions, I find it weird that Fennel’s macro system has all sorts of other limitations.</p>
<p>Firstly, the inability to use functions defined alongside macros is really bad.
This is one of the reasons we have to do all these squats with relative-require stuff and require the library itself from the macro.
Which in turn makes us more error-prone, if some weird environment will not set the module args (<code>...</code>) properly.</p>
<p>Another thing is that macros can’t use other macros unless they’re defined in a separate module, or in the <code>eval-compiler</code> trick I was featuring in this post.
If you define a macro with the <code>macro</code> special, it must be self-contained.
Otherwise, you have to move it somewhere.
I mean, it’s weird that Fennel has a proper implementation of macros sitting in the compiler, but for some reason <code>macro</code> and <code>macros</code> specials don’t use it.</p>
<p>What I think would fix all this mess is this:</p>
<p>First, we need to ditch macro modules completely.
They’re inferior to ordinary fennel modules and only make things complicated.</p>
<p>Next, we need to make it so the <code>macro</code> special sets the macro in the <code>macro-loaded</code> entry of the current module, much like I manually do in the <code>eval-compiler</code> block.</p>
<p>And lastly, when compiling the module to Lua, just load the module at compile time as a whole!
This way not only macros will be able to use other macros, but they’ll also be able to use other ordinary functions at compile time!</p>
<p>The only problem left is how to make it so the generated code can use definitions from the library.
And I think I know the way, and it’s similar to how Clojure handles things.</p>
<p>So basically, same as in Clojure, macros can only use public definitions.
What this means is that these definitions are in the <code>packagr.loaded</code> by the time we’ve required the library.
Therefore, the backquote can safely fully qualify any unqualified symbol in the calling position!</p>
<p>In other words, the macro <code>bar</code> from this file:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span>(<span>fn </span><span>foo</span> [<span>val</span>] <span>val</span>)
</span></span><span><span>
</span></span><span><span>(<span>macro </span><span>bar</span> [<span>expr</span>]
</span></span><span><span>  `(<span>foo</span> <span>,</span><span>expr</span>))
</span></span><span><span>
</span></span><span><span>{<span>:foo</span> <span>foo</span>}
</span></span></code></pre></div><p>After macroexpanding will become:</p>
<div><pre tabindex="0"><code data-lang="fennel"><span><span><span>&gt;&gt;</span> (<span>require-macros </span>(<span>doto </span><span>:lib</span> <span>require</span>))
</span></span><span><span><span>nil</span>
</span></span><span><span><span>&gt;&gt;</span> (<span>macrodebug </span>(<span>bar</span> (<span>+ </span>1 2 3)))
</span></span><span><span>(<span>package.loaded.lib.foo</span> (<span>+ </span>1 2 3))
</span></span></code></pre></div><p>And will work just fine, as it can reach <code>foo</code>, as it is already in the <code>package.loaded</code> by that time.
Which is similar to what Clojure does:</p>
<div><pre tabindex="0"><code data-lang="clojure"><span><span><span>user&gt;</span> (<span>defn </span><span>foo</span> [<span>val</span>] <span>val</span>)
</span></span><span><span>#<span>&#39;user/foo</span>
</span></span><span><span><span>user&gt;</span> (<span>defmacro </span><span>bar</span> [<span>expr</span>] `(<span>foo</span> ~<span>expr</span>))
</span></span><span><span>#<span>&#39;user/bar</span>
</span></span><span><span><span>user&gt;</span> (<span>macroexpand </span>&#39;(<span>bar</span> (<span>+ </span>1 2 3)))
</span></span><span><span>(<span>user/foo</span> (<span>+ </span>1 2 3))
</span></span></code></pre></div><p>And as the final change, we need to make that the <code>fennel.searcher</code> properly sets up <code>macro-loaded</code> in order to ditch the awkward <code>(doto :lib require)</code> thing.</p>
<p>Anyhow, that’s all I got for today.
I know that I’m writing a lot of devlog posts about my small game dev marathon, so I try to write some posts in-between so that my blog doesn’t become too focused on one topic.
Hope that this was an interesting read!</p>

  </article></div>
  </body>
</html>
