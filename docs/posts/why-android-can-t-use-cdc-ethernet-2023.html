<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jordemort.dev/blog/why-android-cant-use-cdc-ethernet/">Original</a>
    <h1>Why Android can&#39;t use CDC Ethernet (2023)</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><p>If you just want the answer to the question posed in the title, click the TLDR below and then move on with your day. Otherwise, buckle in, we‚Äôre going debugging; this post is mostly about my thought process and techniques I used to arrive at the answer rather than the answer itself.</p><details><summary><b>TLDR:</b> Just tell me why CDC Ethernet doesn&#39;t work on Android</summary></details><p>Android contains support for USB ethernet adapters. There‚Äôs even menus for them!</p><p><img src="https://jamiepalatnik.com/images/android-cdc/connection-settings.jpg" alt="Android connection settings, with &#39;Ethernet&#39; greyed out" title="Android connection settings, with &#39;Ethernet&#39; greyed out"/></p><p>This means that if you very carefully select a USB Ethernet adapter that you know has a chipset compatible with your Android device, you can plug it in and these settings will spring to life. How do you know what chipsets are compatible with your phone?</p><p>Hearsay!</p><p>I‚Äôm not entirely kidding. If the company that you bought your phone from sells a USB ethernet adapter as an accessory to it, you have a pretty good chance of that one working. Otherwise, it‚Äôs hit-or-miss; phone manufacturers rarely, if ever, publish lists of supported Ethernet adapters. The best you‚Äôre going to get is finding a forum post from someone that has the same phone as you saying that they bought a particular adapter that worked, and hoping you can find the same thing to buy.</p><p>Or is it?</p><p><img src="https://jamiepalatnik.com/images/android-cdc/i-know-this.jpg" alt="This is a Linux system... I know this" title="This is a Linux system... I know this"/></p><p>As you may know, if you dig deep beneath Android‚Äôs Googly carapace, you‚Äôll find a Linux kernel. To build the Linux kernel, you must first configure it. This configuration determines what features and hardware the resulting kernel will support. Thus, the list of Ethernet adapters supported by your phone will more-or-less correspond to those selected in the kernel configuration for your phone, although it‚Äôs possible (but unlikely) that your phone‚Äôs manufacturer doesn‚Äôt ship all of the drivers that they build, or that they build additional third-party drivers separately.</p><p>So, in order to figure out what Ethernet adapters your phone supports, you‚Äôre going to want to find your phone‚Äôs kernel configuration. How do we do that?</p><h3 id="first-enable-usb-debugging-and-install-adb">First, enable USB debugging and install ADB</h3><p>If you‚Äôd like to follow along with this blog post, you‚Äôre going to need enable USB debugging and to install ADB (Android Debug Bridge) ‚Äî this is a command-line tool that is used by developers to interact with Android devices. In this post, we will be using it to run shell commands on a phone.</p><p>There‚Äôs good documentation elsewhere on how to do these things so I‚Äôm not going to waste time by rewriting it poorly. Instead, have some links:</p><ol><li>First, <a href="https://developer.android.com/studio/debug/dev-options#Enable-debugging">enable USB debugging</a> on your phone</li><li><a href="https://www.xda-developers.com/install-adb-windows-macos-linux/">Install ADB</a> on your computer</li><li>Run <code>adb shell</code>, which will give you a shell prompt on the phone.</li></ol><p><img src="https://jamiepalatnik.com/images/android-cdc/im-in.jpg" alt="I&#39;m in" title="I&#39;m in"/></p><p>Congratulations, you can now run commands on your phone. Type <code>exit</code> and press enter when you‚Äôre ready to exit the ADB shell.</p><p>Next, we need to switch things up so that ADB connects to the phone over the network, instead of via USB. We need to do this because we‚Äôre going to try plugging some network adapters into the phone‚Äôs USB port, so we can‚Äôt also use the port for debugging.</p><p>With your phone connected to your computer via USB:</p><ol><li>Connect your phone to the same network as your computer via wifi</li><li>Figure out your phone‚Äôs IP address - you can do this by digging around the Settings app, or you can try <code>adb shell ifconfig wlan0</code></li><li>With the phone still connected via USB, run <code>adb tcpip 5555</code></li><li>Disconnect the USB cable from the phone</li><li>Reconnect to the phone by running <code>adb connect YOUR_PHONE_IP:5555</code> (replacing YOUR_PHONE_IP with the IP address from the phone)</li><li>Try <code>adb shell</code> to make sure it still works</li></ol><p>Once you have ADB working over the network, you can proceed with trying to figure out what version of the kernel your Android device is running.</p><h3 id="if-you-have-a-newer-phone">If you have a newer phone‚Ä¶</h3><p>These days, Google publishes an <a href="https://source.android.com/docs/core/architecture/kernel/android-common">Android Common Kernel</a>, which downstream phone manufacturers are required to derive their kernels from. The source to this kernel is hosted in a <a href="https://android.googlesource.com/kernel/common/">Git repository at googlesource.com</a>.</p><p>If your phone shipped with Android 11 or later, you have something called a <a href="https://source.android.com/docs/core/architecture/kernel/generic-kernel-image">GKI kernel</a> - in this case, Google builds the kernel and the phone manufacturer puts all of their model-specific secret sauce into kernel modules. In this case, you can find the configuration that Google is using by navigating to the appropriate branch of the kernel repository, and looking at the file <code>arch/$ARCH/configs/gki_defconfig</code>, where <code>$ARCH</code> is the processor architecture of your phone. For example, if your phone has a 64-bit ARM processor (and it almost certainly does) then you will find this configuration at <a href="https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/arch/arm64/configs/gki_defconfig"><code>arch/arm64/configs/gki_defconfig</code></a>.</p><h3 id="how-do-i-find-out-for-sure-what-kernel-version-and-processor-architecture-my-phone-has">How do I find out for sure what kernel version and processor architecture my phone has?</h3><p>Now that we have the ability to run shell commands on the phone, we can turn to good old <a href="https://man7.org/linux/man-pages/man2/uname.2.html"><code>uname</code></a> to discover the kernel version and architecture that‚Äôs currently running.</p><ol><li>Go back and <a href="#first-enable-usb-debugging-and-install-adb">enable USB debugging and install ADB</a>, if you haven‚Äôt arleady</li><li>Run <code>uname -a</code> on the phone, either by running <code>adb shell</code> and then running <code>uname -a</code>, or all in one go by running <code>adb shell uname -a</code>.</li></ol><p>You should get output something like this:</p><pre is:raw="" tabindex="0"><code><span><span>Linux localhost 4.19.113-26203352 #1 SMP PREEMPT Tue Apr 18 16:05:51 KST 2023 aarch64 Toybox</span></span></code></pre><p>You‚Äôll the kernel version in the third field and the architecture in the second-to-last; you‚Äôll have to make an educated guess about which branch or tag in Google‚Äôs kernel repository corresponds to the one running on your phone.</p><h3 id="what-if-i-have-an-older-phone">What if I have an older phone?</h3><p>If you have an older phone, then you‚Äôre in the same boat as me; I have an iPhone as a daily driver, but I keep a Samsung Galaxy s20 around as an Android testbed. Unfortunately, the s20 shipped with Android 10, which is the version just before all of this standardized kernel stuff from Google became required. Even though the s20 has since been upgraded to Android 13, Google doesn‚Äôt require phone manufacturers to update the kernel along with the Android version, and so Samsung didn‚Äôt; it still runs a kernel based on Linux 4.19.</p><p>In this case, you need to get the kernel configuration from your phone manufacturer, so you‚Äôd better hope they‚Äôre actually doing regular source releases. Samsung does do this; you can find sources for their phones at <a href="https://opensource.samsung.com/uploadList?menuItem=mobile&amp;classification1=mobile_phone">opensource.samsung.com</a>.</p><p>Once you have the sources for your device, you‚Äôre going to have to dig around a bit to figure out what kernel config. The sources I obtained for my phone from Samsung included a <code>Kernel.tar.gz</code>; inside of this archive was a Linux kernel source tree, along with a few additions. One of those additions was a shell script called <code>build_kernel.sh</code>, which goes a little something like this:</p><pre is:raw="" tabindex="0"><code><span><span>#!/bin/bash</span></span>
<span></span>
<span><span>export</span><span> </span><span>ARCH</span><span>=</span><span>arm64</span></span>
<span><span>mkdir</span><span> </span><span>out</span></span>
<span></span>
<span><span>BUILD_CROSS_COMPILE</span><span>=</span><span>$(</span><span>pwd</span><span>)/toolchain/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-</span></span>
<span><span>KERNEL_LLVM_BIN</span><span>=</span><span>$(</span><span>pwd</span><span>)/toolchain/llvm-arm-toolchain-ship/10.0/bin/clang</span></span>
<span><span>CLANG_TRIPLE</span><span>=</span><span>aarch64-linux-gnu-</span></span>
<span><span>KERNEL_MAKE_ENV</span><span>=</span><span>&#34;DTC_EXT=$(</span><span>pwd</span><span>)/tools/dtc CONFIG_BUILD_ARM64_DT_OVERLAY=y&#34;</span></span>
<span></span>
<span><span>make</span><span> </span><span>-j8</span><span> </span><span>-C</span><span> </span><span>$(</span><span>pwd</span><span>)</span><span> </span><span>O=$(</span><span>pwd</span><span>)/out</span><span> </span><span>$KERNEL_MAKE_ENV</span><span> </span><span>ARCH=arm64</span><span> </span><span>CROSS_COMPILE=</span><span>$BUILD_CROSS_COMPILE</span><span> </span><span>REAL_CC=</span><span>$KERNEL_LLVM_BIN</span><span> </span><span>CLANG_TRIPLE=</span><span>$CLANG_TRIPLE</span><span> </span><span>vendor/x1q_usa_singlex_defconfig</span></span>
<span></span>
<span><span>make</span><span> </span><span>-j8</span><span> </span><span>-C</span><span> </span><span>$(</span><span>pwd</span><span>)</span><span> </span><span>O=$(</span><span>pwd</span><span>)/out</span><span> </span><span>$KERNEL_MAKE_ENV</span><span> </span><span>ARCH=arm64</span><span> </span><span>CROSS_COMPILE=</span><span>$BUILD_CROSS_COMPILE</span><span> </span><span>REAL_CC=</span><span>$KERNEL_LLVM_BIN</span><span> </span><span>CLANG_TRIPLE=</span><span>$CLANG_TRIPLE</span></span>
<span></span>
<span><span>cp</span><span> </span><span>out/arch/arm64/boot/Image</span><span> </span><span>$(</span><span>pwd</span><span>)/arch/arm64/boot/Image</span></span></code></pre><p>If you squint at this long enough, you‚Äôll spot a reference to something that looks like a kernel config: <code>vendor/x1q_usa_singlex_defconfig</code>. There isn‚Äôt a subdirectory called <code>vendor</code> in the root of the archive, so I used <code>find</code> to figure out exactly where the file lives:</p><pre is:raw="" tabindex="0"><code><span><span>$ find . -name x1q_usa_singlex_defconfig</span></span>
<span><span>./arch/arm64/configs/vendor/x1q_usa_singlex_defconfig</span></span></code></pre><p>Aha, there it is, deeply nested in a subdirectory.</p><h3 id="finding-the-kernel-config-sounds-hard-is-there-an-easier-way">Finding the kernel config sounds hard, is there an easier way?</h3><p>There might be, if you‚Äôre lucky! Give this a shot:</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell zcat /proc/config.gz</span></span></code></pre><p>If you‚Äôre lucky, and your phone manufacturer has enabled the relevant kernel option, then a compressed copy of the configuration that your kernel was compiled with is available at <code>/proc/config.gz</code>. If this is the case, you‚Äôll have a large amount of output streaming to your terminal. You probably want to redirect it somewhere so you can peruse it at your leisure:</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell zcat /proc/config.gz &gt; my_kernel_config</span></span></code></pre><p>If you‚Äôre unlucky, you‚Äôll see something like this:</p><pre is:raw="" tabindex="0"><code><span><span>zcat: /proc/config.gz: No such file or directory</span></span></code></pre><p>In this case, there is no easy way out; you‚Äôll have to refer to the sources your phone‚Äôs kernel was built from.</p><h3 id="what-does-a-kernel-configuration-look-like">What does a kernel configuration look like?</h3><p>In case you‚Äôre interested, here is the kernel configuration for my Galaxy s20: <a href="https://gist.github.com/jordemort/bb9f15028dce9854f9bfd4e750522e48"><code>x1q_usa_singlex_defconfig</code></a></p><p>Your kernel configuration should look very similar to this, but not identical, unless you have the same phone that I do.</p><h3 id="ok-i-have-the-kernel-configuration-for-my-phone-what-now">OK, I have the kernel configuration for my phone, what now?</h3><p>For the purpose of determining which USB Ethernet adapters the kernel supports, most of the configuration variables that we are interested will start with <code>USB_NET</code>, so just <code>grep</code> the kernel configuration for that string:</p><pre is:raw="" tabindex="0"><code><span><span>$ grep USB_NET my_kernel_config</span></span>
<span><span>CONFIG_USB_NET_DRIVERS=y</span></span>
<span><span>CONFIG_USB_NET_AX8817X=y</span></span>
<span><span>CONFIG_USB_NET_AX88179_178A=y</span></span>
<span><span>CONFIG_USB_NET_CDCETHER=y</span></span>
<span><span>CONFIG_USB_NET_CDC_EEM=y</span></span>
<span><span>CONFIG_USB_NET_CDC_NCM=y</span></span>
<span><span># CONFIG_USB_NET_HUAWEI_CDC_NCM is not set</span></span>
<span><span>... and so on ...</span></span></code></pre><p>Look for a <code>CONFIG_USB_NET_something</code> that looks like it relates to the chipset of the adapter you want to use. The best news is if it is set to <code>y</code>; that means the driver is built-in to your kernel and that your phone‚Äôs kernel definitely supports that chipset. If it‚Äôs set to <code>m</code>, that‚Äôs still <em>probably</em> good news; that means that the driver was compiled as a module when your kernel was built, and that the module is likely loadable on your phone unless your phone‚Äôs manufacturer specifically left it out. If you see <code>is not set</code>, then that is the worst news; the driver was neither built-in to your kernel, nor was it compiled as a module, so it‚Äôs likely not available for you to use.</p><p>If you‚Äôre having trouble figuring out which configuration items correspond to which chipsets, have a look at <a href="https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/drivers/net/usb/Kconfig"><code>drivers/net/usb/Kconfig</code></a> in your kernel tree. This file will contain extended descriptions of each configuration item.</p><p>Unfortunately, to figure out which chipset a particular adapter uses, you‚Äôre mostly back to hearsay; few manufacturers of USB Ethernet adapters explicitly advertise which chipset they use.</p><h3 id="so-whats-this-about-cdc-ethernet-and-why-should-i-care">So what‚Äôs this about CDC Ethernet and why should I care?</h3><p>CDC stands for <a href="https://en.wikipedia.org/wiki/USB_communications_device_class">Communications Device Class</a>. This is a set of interrelated standards that manufacturers of USB devices can follow; among them are a trio of standards called EEM (Ethernet Emulation Model), ECM (Ethernet Control Model), and NCM (Network Control Model) that can be used to build USB Ethernet adapters. Most of the difference between these three standards is a matter of complexity; EEM is the simplest to implement and is easy to support on underpowered devices, but may not result in the best performance. ECM is more complex to implement for both the USB host and the device, but promises better performance than EEM; NCM is a successor to ECM that promises even higher speeds. Many devices implement more than one of these protocols, and leave it up to the host operating system to communicate with the device using the one that it prefers.</p><p>The point of these standards is that, assuming manufacturers follow them, operating systems can provide a single common driver that works with a variety of drivers. You generally don‚Äôt need special drivers for USB keyboards or mice because of the <a href="https://en.wikipedia.org/wiki/USB_human_interface_device_class">USB HID</a> standard; the USB CDC standard attempts to accomplish the same for USB networking devices.</p><p>One particularly fun thing is that Linux implements both the host and the device side of the CDC Ethernet standards. That means that if you have hardware with a <a href="https://en.wikipedia.org/wiki/USB_On-The-Go">USB OTG</a> port, which is common on the Raspberry Pi and other small ARM devices, you can tell the kernel to use that port to <a href="https://learn.adafruit.com/turning-your-raspberry-pi-zero-into-a-usb-gadget/ethernet-gadget">pretend to be an Ethernet adapter</a>. This creates a USB network interface on the host that is directly connected to an interface on the guest; this lets you build cool things like embedded routers, firewalls, and VPN gateways that look like just another Ethernet adapter to the host.</p><p>Linux, as well as Windows and macOS (but not iOS) include drivers for CDC Ethernet devices. Unfortunately, none of this works on Android devices, despite Android being based on Linux. Why is Android like this?</p><h3 id="based-on-the-kernel-configuration-android-appears-to-support-cdc">Based on the kernel configuration, Android <em>appears</em> to support CDC</h3><p>Let‚Äôs have another look at our kernel config, and grep for USB_NET_CDC:</p><pre is:raw="" tabindex="0"><code><span><span>$ grep USB_NET_CDC my_kernel_config</span></span>
<span><span>CONFIG_USB_NET_CDCETHER=y</span></span>
<span><span>CONFIG_USB_NET_CDC_EEM=y</span></span>
<span><span>CONFIG_USB_NET_CDC_NCM=y</span></span>
<span><span>... and so on ...</span></span></code></pre><p>Here we can see that Samsung has built support for all 3 CDC Ethernet standards into their kernel (<code>CONFIG_USB_NET_CDCETHER</code> corresponds to ECM). Google‚Äôs GKI kernels are somewhat less generous and appear to leave out ECM and NCM, but still include support for EEM as a module.</p><p>I‚Äôve got a device with an OTG port that I‚Äôve configured as an Ethernet gadget. It works when I plug it into my Mac. It works when I plug it into my Ubuntu desktop. It even works when I plug it into my Windows game machine (actually the same computer as the Ubuntu desktop, booted off of a different drive <span aria-label="grinning face with smiling eyes" role="img">üòÅ</span>). It doesn‚Äôt work at all when I plug it into my Galaxy s20. The Ethernet settings are still greyed out:</p><p><img src="https://jamiepalatnik.com/images/android-cdc/grey-ethernet.jpg" alt="&#39;Ethernet&#39; greyed out" title="&#39;Ethernet&#39; greyed out"/></p><p>Let‚Äôs grab a shell on the phone and dig in a bit.</p><p>The Linux kernel exposes information about itself in a pseudo-filesystem called <a href="https://en.wikipedia.org/wiki/Sysfs">sysfs</a> - this looks like a directory tree full of files, but reading the files actually gets you information about the current state of the kernel.</p><p>Among other things, sysfs contains a directory named <code>/sys/class/net</code>, which contains one entry for every network interface that the kernel is aware of. Let‚Äôs connect our Ethernet gadget to the phone and see if anything shows up there:</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell ls /sys/class/net</span></span>
<span><span>... lots of output ...</span></span>
<span><span>usb0</span></span>
<span><span>wlan0</span></span></code></pre><p>Could <code>usb0</code> be the gadget? Let‚Äôs use <code>ifconfig</code> to check it out:</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell ifconfig usb0</span></span>
<span><span>usb0      Link encap:UNSPEC    Driver cdc_eem</span></span>
<span><span>          BROADCAST MULTICAST  MTU:1500  Metric:1</span></span>
<span><span>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span></span>
<span><span>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span></span>
<span><span>          collisions:0 txqueuelen:1000</span></span>
<span><span>          RX bytes:0 TX bytes:0</span></span></code></pre><p>That certainly looks like our gadget. Too bad the interface is down. Unfortunately, the Ethernet settings on the phone are still greyed out:</p><p><img src="https://jamiepalatnik.com/images/android-cdc/grey-ethernet.jpg" alt="&#39;Ethernet&#39; greyed out" title="&#39;Ethernet&#39; greyed out"/></p><p>Let‚Äôs unplug the gadget and make sure <code>usb0</code> goes away when we do:</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell ls /sys/class/net | grep usb</span></span>
<span><span>$ # no output</span></span></code></pre><p>Yep, it‚Äôs gone.</p><p>It looks like we‚Äôre using EEM mode. In addition to the <code>g_ether</code> module, Linux also includes a thing called <a href="https://docs.kernel.org/usb/gadget_configfs.html">configfs</a> that can be used to create custom gadgets. Let‚Äôs try one that only supports ECM and see if that works:</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell ls /sys/class/net | grep usb</span></span>
<span><span>usb0</span></span>
<span><span>$ adb shell ifconfig usb0</span></span>
<span><span>usb0      Link encap:UNSPEC    Driver cdc_ether</span></span>
<span><span>          BROADCAST MULTICAST  MTU:1500  Metric:1</span></span>
<span><span>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span></span>
<span><span>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span></span>
<span><span>          collisions:0 txqueuelen:1000</span></span>
<span><span>          RX bytes:0 TX bytes:0</span></span></code></pre><p><img src="https://jamiepalatnik.com/images/android-cdc/grey-ethernet.jpg" alt="&#39;Ethernet&#39; greyed out" title="&#39;Ethernet&#39; greyed out"/></p><p>It‚Äôs still detected, but it‚Äôs still down. Will NCM fare any better?</p><pre is:raw="" tabindex="0"><code><span><span>$ adb shell ls /sys/class/net | grep usb</span></span>
<span><span>usb0</span></span>
<span><span>$ adb shell ifconfig usb0</span></span>
<span><span>usb0      Link encap:UNSPEC    Driver cdc_ncm</span></span>
<span><span>          BROADCAST MULTICAST  MTU:1500  Metric:1</span></span>
<span><span>          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span></span>
<span><span>          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span></span>
<span><span>          collisions:0 txqueuelen:1000</span></span>
<span><span>          RX bytes:0 TX bytes:0</span></span></code></pre><p><img src="https://jamiepalatnik.com/images/android-cdc/grey-ethernet.jpg" alt="&#39;Ethernet&#39; greyed out" title="&#39;Ethernet&#39; greyed out"/></p><p>No, it will not.</p><h3 id="so-why-doesnt-cdc-work-on-android">So why doesn‚Äôt CDC work on Android?</h3><p>At this point, we‚Äôve more-or-less established that everything is fine on the kernel level. I‚Äôm pretty sure that if I wanted to, I could root this phone, manually configure the interface with <code>ifconfig</code>, and it would pass traffic just fine. That means the problem must be somewhere in the stack of software above the kernel.</p><p>If this was a regular Linux system, this is the point where I‚Äôd start poking at systemd-networkd, or NetworkManager, or ifupdown, depending on the particulars. This is not a regular Linux system, though; it‚Äôs an Android device, and none of that stuff exists here. What do I know about how Android configures network interfaces?</p><p><strong>NOTHING.</strong> I know nothing about how Android configures network interfaces. How do we figure this out?</p><p>Well, Android is at least sort of open source; many of the good bits are closed behind the veil of something called ‚ÄúGoogle Play Services‚Äù but maybe there‚Äôs enough in the sources that are released to figure this out.</p><p>To play along with this bit, you‚Äôll need to <a href="https://source.android.com/docs/setup/download/downloading">download the source to Android</a>. This is a whole process on its own, so I‚Äôll leave you to Google‚Äôs documentation for this, except to note that you‚Äôll need a special tool called <code>repo</code>. This seems to be meant to make it easier to download sources from multiple Git repositories at once; sometimes it feels like I‚Äôm the only person that actually likes <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git submodules</a>. There are a lot of sources to download, so start this process and then go knock off a few shrines in Zelda while it wraps up.</p><p>I figure that searching for the string <code>Ethernet</code> is probably a good starting point. Because there is so much source to go through, I‚Äôm going to skip vanilla <code>grep</code> this time and enlist the aid of <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a>. There‚Äôs a lot of configuration files and other clutter in the Android sources, as well as most of a Linux distro, but I know that any code that we‚Äôre going to care about here is likely written in Java, so I‚Äôm going to restrict <code>rg</code> to searching in Java files:</p><pre is:raw="" tabindex="0"><code><span><span>$ rg -t java Ethernet</span></span>
<span><span>... SO MUCH OUTPUT ...</span></span></code></pre><p>At this point, there‚Äôs not much else to do but look at the files where we‚Äôve got hits and try to figure out what part of the code we can blame for our problem. Fortunately for you, I‚Äôve saved you the trouble. After reading a bunch of Android code, I‚Äôm certain that our culprit is <a href="https://android.googlesource.com/platform/packages/modules/Connectivity/+/refs/heads/master/service-t/src/com/android/server/ethernet/EthernetTracker.java"><code>EthernetTracker.java</code></a>. This appears to be a service that listens on a <a href="https://docs.kernel.org/userspace-api/netlink/intro.html">Netlink</a> socket and receives notifications from the kernel about new network interfaces. The EthernetTracker contains a method that determines if an Ethernet interface is ‚Äúvalid‚Äù; if it is valid, the EthernetTracker reports to the rest of the system that an interface is available, and the Settings app allows the interface to be configured. If an interface is not valid, then the EthernetTracker simply ignores it.</p><p>How does the EthernetTracker determine if an interface is valid?</p><pre is:raw="" tabindex="0"><code><span><span>private</span><span> </span><span>boolean</span><span> </span><span>isValidEthernetInterface</span><span>(</span><span>String</span><span> iface) {</span></span>
<span><span>    </span><span>return</span><span> </span><span>iface</span><span>.</span><span>matches</span><span>(mIfaceMatch) || </span><span>isValidTestInterface</span><span>(iface);</span></span>
<span><span>}</span></span></code></pre><p>With a regex, of course.</p><p>Where does this regex come from?</p><pre is:raw="" tabindex="0"><code><span><span>// Interface match regex.</span></span>
<span><span>mIfaceMatch = </span><span>mDeps</span><span>.</span><span>getInterfaceRegexFromResource</span><span>(mContext);</span></span></code></pre><p>It comes from a method called <code>getInterfaceRegexFromResource</code>. Where does that method get it from?</p><pre is:raw="" tabindex="0"><code><span><span>public</span><span> </span><span>String</span><span> </span><span>getInterfaceRegexFromResource</span><span>(</span><span>Context</span><span> context) {</span></span>
<span><span>    </span><span>final</span><span> </span><span>ConnectivityResources</span><span> </span><span>resources</span><span> = </span><span>new</span><span> </span><span>ConnectivityResources</span><span>(context);</span></span>
<span><span>    </span><span>return</span><span> </span><span>resources</span><span>.</span><span>get</span><span>().</span><span>getString</span><span>(</span></span>
<span><span>        </span><span>com</span><span>.</span><span>android</span><span>.</span><span>connectivity</span><span>.</span><span>resources</span><span>.</span><span>R</span><span>.</span><span>string</span><span>.</span><span>config_ethernet_iface_regex</span><span>);</span></span>
<span><span>}</span></span></code></pre><p>There‚Äôs actually a nice comment at the top of the file that explains this:</p><pre is:raw="" tabindex="0"><code><span><span>/**</span></span>
<span><span> * Tracks Ethernet interfaces and manages interface configurations.</span></span>
<span><span> *</span></span>
<span><span> * &lt;p&gt;Interfaces may have different {@link android.net.NetworkCapabilities}. This mapping is defined</span></span>
<span><span> * in {@code config_ethernet_interfaces}. Notably, some interfaces could be marked as restricted by</span></span>
<span><span> * not specifying {@link android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED} flag.</span></span>
<span><span> * Interfaces could have associated {@link android.net.IpConfiguration}.</span></span>
<span><span> * Ethernet Interfaces may be present at boot time or appear after boot (e.g., for Ethernet adapters</span></span>
<span><span> * connected over USB). This class supports multiple interfaces. When an interface appears on the</span></span>
<span><span> * system (or is present at boot time) this class will start tracking it and bring it up. Only</span></span>
<span><span> * interfaces whose names match the {@code config_ethernet_iface_regex} regular expression are</span></span>
<span><span> * tracked.</span></span>
<span><span> *</span></span>
<span><span> * &lt;p&gt;All public or package private methods must be thread-safe unless stated otherwise.</span></span>
<span><span> */</span></span></code></pre><p>Let‚Äôs go back to ripgrep to see if we can skip to finding out what <code>config_ethernet_iface_regex</code> is:</p><pre is:raw="" tabindex="0"><code><span><span>$ rg config_ethernet_iface_regex</span></span>
<span><span>...</span></span>
<span><span></span></span>
<span><span>frameworks/base/core/res/res/values/config.xml</span></span>
<span><span>410:    &lt;string translatable=&#34;false&#34; name=&#34;config_ethernet_iface_regex&#34;&gt;eth\\d&lt;/string&gt;</span></span>
<span><span></span></span>
<span><span>...</span></span>
<span><span></span></span>
<span><span>packages/modules/Connectivity/service/ServiceConnectivityResources/res/values/config.xml</span></span>
<span><span>170:    &lt;string translatable=&#34;false&#34; name=&#34;config_ethernet_iface_regex&#34;&gt;eth\\d&lt;/string&gt;</span></span>
<span><span></span></span>
<span><span>...</span></span></code></pre><p>‚Ä¶and there it is. The default value of <code>config_ethernet_iface_regex</code> is <code>eth\d</code>; in regex parlance, that means the literal string <code>eth</code>, followed by a digit.</p><p>The kernel on the phone calls our CDC Ethernet gadget <code>usb0</code>. This doesn‚Äôt start with the string <code>eth</code>, so EthernetTracker ignores it. Unfortunately, this setting is not user-configurable, although you can hack it by rooting the phone.</p><p>It really is that silly; an entire USB device class brought low by a bum regex.</p><h3 id="is-it-a-bug">Is it a bug?</h3><p>I can‚Äôt tell if this is intentional or not; it feels like an oversight by Google, since even the newest GKI kernels apparently go out of their way to include support for EEM adapters, but because the interface name doesn‚Äôt match the regex, the kernel‚Äôs support for EEM adapters is unusable. This puts you in a rather perverse situation when shopping for USB Ethernet adapters to use with Android; instead of looking for devices that implement the CDC standards, you need to explicitly <em>AVOID</em> the standards-based devices and look for something that is supported with a vendor/chipset-specific driver.</p><h3 id="thanks-for-playing">Thanks for playing!</h3><p>I hope you enjoyed going on this journey with me, or even better that I saved you from duplicating my efforts. Perhaps if I am feeling feisty, I will try to figure out how to submit a patch to Android to change that regex to <code>(eth|usb)\d</code> in the next few weeks. If a real Android dev or someone at Google reads this and beats me to the punch, I owe you the beverage of your choice.</p></div></div>
  </body>
</html>
