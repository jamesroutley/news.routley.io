<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.jfo.click/makin-wavs-with-zig">Original</a>
    <h1>Makin&#39; wavs with Zig</h1>
    
    <div id="readability-page-1" class="page"><div><p>I&#39;ve been gearing up to do some audio programming and more generally learn
about digital signal processing. As a first exercise, I decided to revisit a
simple program I wrote while trying out rust a few years ago. <a href="https://blog.jfo.click/how-rust-do/">I blogged about
that here</a>. There is, of course, a lot of Rust specific
information in that post, but if you&#39;d like background on the <code>.wav</code> format it
is specified <a href="https://blog.jfo.click/how-rust-do/#writingthewaves">here</a>.</p>
<p>In short, the rationale for writing <code>.wav</code> is this: it&#39;s a very flexible but
straightforward format whose data section, when the header is configured
as I have done, consists of nothing more than a series of byte-wide samples
with no compression or interpolation.</p>
<p>Translating the rust program to zig directly was pretty straightforward, naively it looks like this.</p>

<pre><code><span>const</span> std = <span>@import</span>(<span>&#34;std&#34;</span>);
<span>const</span> File = std.fs.File;
<span>const</span> sin = std.math.sin;

<span>const</span> SAMPLE_RATE: <span>u32</span> = <span>44100</span>;
<span>const</span> CHANNELS: <span>u32</span> = <span>1</span>;
<span>const</span> HEADER_SIZE: <span>u32</span> = <span>36</span>;
<span>const</span> SUBCHUNK1_SIZE: <span>u32</span> = <span>16</span>;
<span>const</span> AUDIO_FORMAT: <span>u16</span> = <span>1</span>;
<span>const</span> BIT_DEPTH: <span>u32</span> = <span>8</span>;
<span>const</span> BYTE_SIZE: <span>u32</span> = <span>8</span>;
<span>const</span> PI: <span>f64</span> = <span>3.14159265358979323846264338327950288</span>;

<span><span>fn</span> <span>write_u16</span></span>(n: <span>u16</span>, file: File) !<span>void</span> {
    <span>const</span> arr = [_]<span>u8</span>{ <span>@truncate</span>(<span>u8</span>, n), <span>@truncate</span>(<span>u8</span>, n &gt;&gt; <span>8</span>) };
    _ = <span>try</span> file.write(arr[<span>0.</span>.]);
}

<span><span>fn</span> <span>write_u32</span></span>(n: <span>u32</span>, file: File) !<span>void</span> {
    <span>const</span> arr = [_]<span>u8</span>{ <span>@truncate</span>(<span>u8</span>, n), <span>@truncate</span>(<span>u8</span>, n &gt;&gt; <span>8</span>), <span>@truncate</span>(<span>u8</span>, n &gt;&gt; <span>16</span>), <span>@truncate</span>(<span>u8</span>, n &gt;&gt; <span>24</span>) };
    _ = <span>try</span> file.write(arr[<span>0.</span>.]);
}

<span><span>fn</span> <span>write_header</span></span>(seconds: <span>u32</span>, file: File) !<span>void</span> {
    <span>const</span> numsamples: <span>u32</span> = SAMPLE_RATE * seconds;
    _ = <span>try</span> file.write(<span>&#34;RIFF&#34;</span>);
    <span>try</span> write_<span>u32</span>(HEADER_SIZE + numsamples, file);
    _ = <span>try</span> file.write(<span>&#34;WAVEfmt &#34;</span>);
    <span>try</span> write_<span>u32</span>(SUBCHUNK1_SIZE, file);
    <span>try</span> write_<span>u16</span>(AUDIO_FORMAT, file);
    <span>try</span> write_<span>u16</span>(<span>@truncate</span>(<span>u16</span>, CHANNELS), file);
    <span>try</span> write_<span>u32</span>(SAMPLE_RATE, file);
    <span>try</span> write_<span>u32</span>(SAMPLE_RATE * CHANNELS * (BIT_DEPTH / BYTE_SIZE), file);
    <span>try</span> write_<span>u16</span>(<span>@truncate</span>(<span>u16</span>, (CHANNELS * (BIT_DEPTH / BYTE_SIZE))), file);
    <span>try</span> write_<span>u16</span>(<span>@truncate</span>(<span>u16</span>, BIT_DEPTH), file);
    _ = <span>try</span> file.write(<span>&#34;data&#34;</span>);
    <span>try</span> write_<span>u32</span>(numsamples * CHANNELS * (BIT_DEPTH / BYTE_SIZE), file);
}

<span><span>fn</span> <span>sine_wave</span></span>(seconds: <span>u32</span>, file: File, freq: <span>f64</span>) !<span>void</span> {
    <span>var</span> idx: <span>u32</span> = <span>0</span>;
    <span>while</span> (idx &lt; seconds * SAMPLE_RATE) {
        <span>const</span> sample = ((sin(((<span>@intToFloat</span>(<span>f64</span>, idx) * <span>2.0</span> * PI) / <span>@intToFloat</span>(<span>f64</span>, SAMPLE_RATE)) * freq) + <span>1.0</span>) / <span>2.0</span>) * <span>255.0</span>;
        <span>const</span> arr = [_]<span>u8</span>{<span>@floatToInt</span>(<span>u8</span>, sample)};
        _ = <span>try</span> file.write(arr[<span>0.</span>.]);
        idx += <span>1</span>;
    }
}

<span>pub</span> <span><span>fn</span> <span>main</span></span>() !<span>void</span> {
    <span>const</span> cwd = std.fs.cwd();
    <span>var</span> file = <span>try</span> cwd.createFile(<span>&#34;sine.wav&#34;</span>, .{});
    <span>try</span> write_header(<span>3</span>, file);
    <span>try</span> sine_wave(<span>3</span>, file, <span>440.0</span>);
    _ = file.close();
}
</code></pre>
<p>I&#39;ve implemented a simple little set of helper functions to write <code>u32</code> and
<code>u64</code> to the output. I believe there are better ways to do that, but this works
fine. Much of this is really pretty close to the <a href="https://github.com/jfo/rav/blob/3e5db5f9cdbd1a3458ad166175b9c64626bc7e8c/src/main.rs">rust
source</a>,
maybe surprisingly so.</p>
<h2 id="a-bug-story">A bug story</h2>
<p>The hardest part about this was testing it, for reasons almost completely
unrelated to the code. I had originally defined <code>PI</code> as:</p>

<pre><code><span>const</span> PI: <span>f64</span> = <span>3.1415</span>
</code></pre>
<p>This is more than enough precision for this use case, and will produce a sine
wave at the desired frequency when plugged into the function in the example
above.</p>
<p><em>but...</em></p>
<p>what it will <em>not</em> do is produce a byte by byte facsimile of the rust version&#39;s
output. I would not expect it to do this and that&#39;s fine also,</p>
<p><em>but</em>...</p>
<p>as I was continually building and running the binary for this program I was
trying to open the resulting <code>.wav</code> file in an audio player, and it just
wouldn&#39;t work!  It would just skip over it and not make any noise at all. I
found this strange because even if the math was wrong I would expect some awful
noise to come out, but I assumed that the file was malformed and something was
wrong with the header.</p>
<p>When comparing the rust program&#39;s output byte for byte with the zig version&#39;s,
they seemed very different for inscrutable reasons!</p>

<ol>
<li>The <code>data</code> section in the zig version was 4x too long (suspicious)</li>
<li>The bytes were all different!</li>
<li>As I said, it wouldn&#39;t play!</li>
</ol>
<p>The first one was a real bug in the code, as I was initially trying to write
<code>f32</code>&#39;s into the data section instead of <code>u8</code>&#39;s... whoops! But that still left
the other two problems.</p>

<ol>
<li>The bytes were all different!</li>
<li>As I said, it wouldn&#39;t play!</li>
</ol>
<p>The fact that the bytes were different made it hard to debug the output, and
there was a lot of headscratcing about that, maybe my write functions were
wrong, or writing big endian or something? No, tested in isolation they were
doing as I expected.</p>
<p>Ah, I&#39;m not using the <em>exact</em> same PI as <a href="https://github.com/jfo/rav/blob/3e5db5f9cdbd1a3458ad166175b9c64626bc7e8c/src/main.rs#L6">rust was though!</a></p>

<pre><code><span>use</span> std::f64::consts::PI;
</code></pre>
<p>What is that <a href="https://github.com/rust-lang/rust/blob/af7ab3447079fddc51c6c7749b160d24769f7c16/library/core/src/num/f32.rs#L272"><em>exactly</em></a>?</p>

<pre><code><span>pub</span> <span>const</span> PI: <span>f32</span> = <span>3.14159265358979323846264338327950288_f32</span>;
</code></pre>
<p>So, replacing my weak, sad 4 digits of PI PI with that beefy boi solved problem
number 2, but the resulting <code>.wav</code> file <em>still</em> wouldn&#39;t play, despite being
<em>byte for byte identical</em> to the rust program&#39;s output. What gives??</p>
<p>You might be surprised to learn that I was trying to play this file in Apple
Music. I wouldn&#39;t normally have done that, but I was pairing with someone so
expediency was key, and I haven&#39;t played that many wav files on that computer
so I hadn&#39;t reset the default program for the format to quicktime or something
like that. I mean what&#39;s the big deal, Apple Music can play wav&#39;s, right?</p>
<p>Yeah, sure it can! You just double click on the file and Music imports the file
and... then when you try to play the same file later it just... wait, plays the
<em>imported</em> version of the file it had <em>already imported</em> the first time you
played it?</p>
<p>Each attempt to write this wav file had one thing in common. The headers were
all identical. I thought initially that there was something wrong with the
header and that&#39;s why the file wouldn&#39;t play. I was right, at the time! When I
was writing 4x the data (as floats instead of bytes) to the data section, the
line that writes the expected data size was mismatched to what was actually in
the data section:</p>

<pre><code>    <span>try</span> write_<span>u16</span>(<span>@truncate</span>(<span>u16</span>, (CHANNELS * (BIT_DEPTH / BYTE_SIZE))), file);
</code></pre>
<p>So the first time I tried to play the file in music, it cached it but the
version it cached was corrupt, or rather, malformed, so the player didn&#39;t even
attempt to play back the garbage I had written.</p>
<p>Once I fixed the issue, first with the bytes writing correctly (which despite
not being identical to the rust version was perfectly fine and sounded fine!)
and then with the identical output, it should have played normally, but since
the <em>header</em> was identical, Apple Music happily expected the cached version to
be the same, so it just kept trying to play that corrupted version.</p>
<p>I played it in quicktime and it worked as expected! Simple, right?</p>
<h2 id="just-the-worst-type-of-bug-you-know-">Just, the worst type of bug, you know?</h2>
<p>This was like an hour and a half of debugging. I started with the assumption
that I was doing something wrong in the translated code, and I was but that was
only 1/3 of the issue. We kept staring at the <code>sine</code> function and that gnarly
expression that computes the sample value... surely if there&#39;s something wrong
in a program it must be in the most obviously complicated spot, right? Without
being able to hear the output properly, those assumptions just hung on as we
poked and prodded.</p>
<p>What&#39;s the moral of this dumb story?</p>
<p>Bugs are most insidious when the interact with other bugs and your assumptions
around how the program is running. I hesitate to call the byte mismatching a
&#34;bug&#34; but it made it harder to discern what was actually problematic, which had
nothing to do with the code at all but rather with how it was being invoked and
tested! None of these issues in isolation was all that bad or complex, but put
them together and it became an infuriating head scratcher!</p>
</div></div>
  </body>
</html>
