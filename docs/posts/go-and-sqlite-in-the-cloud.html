<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.golang.dk/articles/go-and-sqlite-in-the-cloud">Original</a>
    <h1>Go and SQLite in the Cloud</h1>
    
    <div id="readability-page-1" class="page"><div id="top"><div><p><img src="https://www.golang.dk/images/articles/go-and-sqlite-in-the-cloud.png" alt="A digital drawing of a Gopher storing stuff in a database."/></p><p>Why SQLite and Go in the cloud are a great match, getting started, best practices, and more.</p><p>Last updated November 2022 for Go 1.19.</p><h2>Why SQLite and Go?</h2><p>I love the intersection of the cloud and &#34;boring&#34; old technologies. <a href="https://www.sqlite.org/index.html">SQLite</a> and the cloud is a perfect example of this. SQLite has been around forever, runs on literally billions of devices (it‚Äôs in space!) and is super robust and well-tested. You probably have it running on the phone in your pocket already.</p><p>SQLite is currently in something of a renaissance, because it‚Äôs increasingly being used on the . Have a look at <a href="https://blog.cloudflare.com/introducing-d1/">Cloudflare‚Äôs D1</a>, or what <a href="https://fly.io/blog/all-in-on-sqlite-litestream/">fly.io are doing with SQLite, Litestream, and LiteFS</a>.</p><p>But even if you‚Äôre not doing anything fancy and just have a service running somewhere, with a persistent disk attached, SQLite could be worth another look instead of the usual Postgres/MySQL central server setup.</p><p>Why? Because it‚Äôs just <em>so crazy fast</em>, conceptually and practically simple, but still covers the needs of (I‚Äôd wager) most of the web apps out there. It has , full SQL support, great tooling, and did I say it was fast? We‚Äôre talking microseconds instead of milliseconds for queries.</p><p>Convinced to try it out? In this article, I‚Äôll show you:</p><ul><li>how to set up an app with SQLite and Go, with idiomatic, production-ready, best-practice code;</li><li>how to test your app efficiently;</li><li>some Go-specific data modelling best practices; and</li><li>how to deploy it all to the cloud.</li></ul><p>What I won‚Äôt show you this time is how to do distributed SQLite across several nodes in the cloud edge. <a href="https://www.golang.dk/articles/distributed-sqlite-with-litefs">Check out my article on distributed SQLite with LiteFS for that</a>, which builds on this article. I also won‚Äôt show you how to use SQL.</p><p>This is a living document. Got any comments, questions, or suggestions? <a href="mailto:markus@golang.dk">Send me an email</a> or <a href="https://hachyderm.io/@markus">find me on Mastodon</a>.</p><p>Let‚Äôs go!</p><h2>The Go SQLite app</h2><p>The app is a tiny web app with a blog, where articles can be created, viewed, and searched.</p><p><img src="https://www.golang.dk/images/articles/sqlite-app.png" alt="A screenshot of the sqlite-app web app, showing an article search."/></p><p>I‚Äôll show you the relevant parts of the app on this page. Check out <a href="https://github.com/maragudk/sqlite-app">all the code of the sqlite-app on Github</a>, and <a href="https://sqlite-app.fly.dev/">poke around the online demo here</a>. If you want to follow along, clone the repo, run <code>make migrate-up start</code> and then go to <a href="http://localhost:8080">localhost:8080</a>. Try it, I‚Äôll wait.</p><p>The output should look something like this:</p><pre><code>$ make migrate-up start
go run ./cmd/migrate up
2022/11/03 12:28:57 database.go:61: Connecting to database at file:app.db?_journal=WAL&amp;_timeout=5000&amp;_fk=true
2022/11/03 12:28:57 database.go:69: Setting connection pool options ( max open connections: 1 , max idle connections: 1 , connection max lifetime: 0s , connection max idle time: 0s )
2022/11/03 12:28:57 main.go:41: Migrated up
go run -tags fts5 ./cmd/server
2022/11/03 12:29:18 main.go:20: Starting
2022/11/03 12:29:18 database.go:61: Connecting to database at file:app.db?_journal=WAL&amp;_timeout=5000&amp;_fk=true
2022/11/03 12:29:18 database.go:69: Setting connection pool options ( max open connections: 5 , max idle connections: 5 , connection max lifetime: 1h0m0s , connection max idle time: 1h0m0s )
2022/11/03 12:29:18 server.go:60: Starting
2022/11/03 12:29:18 server.go:64: Listening on http://localhost:8080</code></pre><h3>The database</h3><p>The storage to SQLite is handled in the <code>Database</code> struct. It‚Äôs constructed with a database URL, a few connection parameters, and a logger. Have a look at the code, and we‚Äôll go through it:</p><pre><p>sql/database.go</p><code>package sql

import (
	&#34;context&#34;
	&#34;embed&#34;
	&#34;io&#34;
	&#34;io/fs&#34;
	&#34;log&#34;
	&#34;time&#34;

	&#34;github.com/jmoiron/sqlx&#34;
	&#34;github.com/maragudk/migrate&#34;
	_ &#34;github.com/mattn/go-sqlite3&#34;
)

type Database struct {
	DB                    *sqlx.DB
	url                   string
	maxOpenConnections    int
	maxIdleConnections    int
	connectionMaxLifetime time.Duration
	connectionMaxIdleTime time.Duration
	log                   *log.Logger
}

type NewDatabaseOptions struct {
	URL                   string
	MaxOpenConnections    int
	MaxIdleConnections    int
	ConnectionMaxLifetime time.Duration
	ConnectionMaxIdleTime time.Duration
	Log                   *log.Logger
}

// NewDatabase with the given options.
// If no logger is provided, logs are discarded.
func NewDatabase(opts NewDatabaseOptions) *Database {
	if opts.Log == nil {
		opts.Log = log.New(io.Discard, &#34;&#34;, 0)
	}

	// - Set WAL mode (not strictly necessary each time because it&#39;s persisted in the database, but good for first run)
	// - Set busy timeout, so concurrent writers wait on each other instead of erroring immediately
	// - Enable foreign key checks
	opts.URL += &#34;?_journal=WAL&amp;_timeout=5000&amp;_fk=true&#34;

	return &amp;Database{
		url:                   opts.URL,
		maxOpenConnections:    opts.MaxOpenConnections,
		maxIdleConnections:    opts.MaxIdleConnections,
		connectionMaxLifetime: opts.ConnectionMaxLifetime,
		connectionMaxIdleTime: opts.ConnectionMaxIdleTime,
		log:                   opts.Log,
	}
}

func (d *Database) Connect() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	d.log.Println(&#34;Connecting to database at&#34;, d.url)

	var err error
	d.DB, err = sqlx.ConnectContext(ctx, &#34;sqlite3&#34;, d.url)
	if err != nil {
		return err
	}

	d.log.Println(&#34;Setting connection pool options (&#34;,
		&#34;max open connections:&#34;, d.maxOpenConnections,
		&#34;, max idle connections:&#34;, d.maxIdleConnections,
		&#34;, connection max lifetime:&#34;, d.connectionMaxLifetime,
		&#34;, connection max idle time:&#34;, d.connectionMaxIdleTime,
		&#34;)&#34;)
	d.DB.SetMaxOpenConns(d.maxOpenConnections)
	d.DB.SetMaxIdleConns(d.maxIdleConnections)
	d.DB.SetConnMaxLifetime(d.connectionMaxLifetime)
	d.DB.SetConnMaxIdleTime(d.connectionMaxIdleTime)

	return nil
}

// ‚Ä¶</code></pre><p>First, the imports. I‚Äôm using the Go SQLite database driver from <a href="https://github.com/mattn/go-sqlite3">github.com/mattn/go-sqlite3</a>, which basically uses the official SQLite C library directly, wired up to be easy to use from Go.</p><div><p>In order to be able to compile your program, you need a C compiler installed. I won‚Äôt go into details with how this is done. Start at <a href="https://go.dev/blog/cgo">the Cgo blog intro</a> if you‚Äôre stuck.</p></div><p>Another import is <a href="https://github.com/jmoiron/sqlx">github.com/jmoiron/sqlx</a>, which is an excellent SQL helper library which makes querying the database much easier.</p><p>After that, it gets interesting in <code>NewDatabase</code>. We set three options for the SQL driver as URL query parameters:</p><ol><li><p><strong>_journal=WAL</strong> means we set the journal mode to <a href="https://sqlite.org/wal.html">WAL</a> (Write-Ahead Log). What‚Äôs a journal mode? It‚Äôs about how SQLite handles writing data to disk safely.</p><p>The default journal mode in SQLite is a so-called <a href="https://sqlite.org/lockingv3.html#rollback">rollback journal</a>, which means that changes are written directly to the main database file, and the old data is kept in the rollback journal in a separate file. When data is written, readers are blocked, and when data is read, writers are blocked!</p><p>Because of this, we use the WAL journal mode instead, where readers don‚Äôt block writers and writers don‚Äôt block readers. (Writers still block writers, though, because write access is serialized. See below.) As the name implies, the WAL receives all new writes, and readers can keep reading from the main database file. (Readers also read from the WAL once changes are committed, but that‚Äôs a detail we don‚Äôt need to consider right now.)</p><p>Note: The WAL journal mode is actually persisted to the database file the first time it‚Äôs opened like this, but to keep things simple, we just set the option every time. It‚Äôs just a no-op then.</p></li><li><p><strong>_timeout=5000</strong> sets a busy timeout to 5000 milliseconds, or 5 seconds. <a href="https://www.sqlite.org/isolation.html">There can only be one writer at a time in SQLite</a>, so if another writer wants concurrent access, it would normally be blocked and return an error. If the busy timeout is set, the writer will instead wait up to that timeout for write access, and only then return an error. So it‚Äôs a good idea to set this if you ever think you will have concurrent writes, and of course in web apps, you will.</p></li><li><p><strong>_fk=true</strong> enables <a href="https://sqlite.org/foreignkeys.html">foreign key checking</a>. <em>Why do I need to enable that explicitly?!</em>, you might rightfully ask. The answer is, for backwards compatibility with older versions of SQLite. This can also be set at compile-time, but better safe than sorry here, in my opinion. Referential integrity FTW.</p></li></ol><p>After that, the <code>Connect</code> method actually establishes the connection using the <code>sqlite3</code> driver name and the database URL passed into the struct. It sets a few sane connection options, logs them, and that‚Äôs it.</p><h3>The schema</h3><p>In order to save our articles and make them searchable, we‚Äôll contruct an <code>articles</code> table and an <code>articles_fts</code> virtual table.</p><pre><p>sql/migrations/1667384958-articles.up.sql</p><code>create table articles (
  id integer primary key,
  title text not null,
  content text not null,
  created text not null default (strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;)),
  updated text not null default (strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;))
) strict;

create index articles_created_idx on articles (created);

create trigger articles_updated_timestamp after update on articles begin
  update articles set updated = strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;) where id = old.id;
end;
</code></pre><p>We want an automatically generated ID for our articles. In SQLite, in order to have an explicit, auto-incrementing integer primary key, the type has to be <code>integer primary key</code> (NOT <code>int primary key</code>, then it won‚Äôt work üôÑ), so that‚Äôs what we use here.</p><p>I‚Äôve added create and update timestamps here as strings (the <code>text</code> type). Why not write <code>default current_timestamp</code> instead? Because it‚Äôs not <em>quite</em> the format we should all be using, namely ISO8601/RFC3339. <code>select current_timestamp</code> outputs something like 2022-12-07 19:12:34, which lacks the <code>T</code> separator, has no timezone info, and has no sub-second precision.</p><p><code>strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;)</code> almost matches the format given in the Go stdlib at <code>time.RFC3339Nano</code>, except it‚Äôs millisecond precision. Because mixing timestamps with different precisions with a timezone suffix doesn‚Äôt sort correctly chronologically (for example <code>2022-11-11T12:34:56.000Z</code> sorts <em>after</em> <code>2022-11-11T12:34:56.000000001Z</code>), we use our own time format called <code>rfc3339Milli</code> later. We‚Äôll use that for parsing and serializing time in Go code.</p><p>We‚Äôre also adding an index on the creation time for good measure, and a trigger to update the <code>updated</code> timestamp automatically after update. Nifty!</p><p>Waaaait, what‚Äôs that <code>strict</code> keyword? It‚Äôs a usage of the relatively new <a href="https://www.sqlite.org/stricttables.html">strict tables</a> feature (from 2021). Normally, even though you can declare types on table columns in SQLite, by default the types are not enforced on insert/update and you can insert whatever you like. The <code>strict</code> keyword restricts this, which is arguably more aligned with how we use the database in Go. Unfortunately, you need to remember to write this after each <code>create table</code> declaration in every migration you ever write, instead of it being a global feature you can enable (like foreign key support). Somebody should write a linter for that (you? üòâ).</p><p>Onto the full text search virtual table:</p><pre><p>sql/migrations/1667395622-fts.up.sql</p><code>create virtual table articles_fts
  using fts5(title, content, tokenize = porter, content = &#39;articles&#39;, content_rowid = &#39;id&#39;);

create trigger articles_after_insert after insert on articles begin
  insert into articles_fts (rowid, title, content) values (new.id, new.title, new.content);
end;

create trigger articles_fts_after_update after update on articles begin
  insert into articles_fts (articles_fts, rowid, title, content) values(&#39;delete&#39;, old.id, old.title, old.content);
  insert into articles_fts (rowid, title, content) values (new.id, new.title, new.content);
end;

create trigger articles_fts_after_delete after delete on articles begin
  insert into articles_fts (articles_fts, rowid, title, content) values(&#39;delete&#39;, old.id, old.title, old.content);
end;

</code></pre><p>Here, we use the <a href="https://www.sqlite.org/fts5.html">FTS5</a> extension to create a virtual table that will hold our full-text search indexes. I want to have indexes on the article title and content, so that‚Äôs what I‚Äôm declaring here. You can pass in a few settings, which I‚Äôve done to set the text tokenizer to <a href="https://www.sqlite.org/fts5.html#porter_tokenizer">porter</a> (which does word stemming). I‚Äôve also enabled <a href="https://www.sqlite.org/fts5.html#external_content_tables">external content tables</a>, which means that the virtual table won‚Äôt hold a copy of the source data, but refer it to the <code>articles</code> table. The column to join on is set by the <code>content_rowid</code> option.</p><p>Full-text search indexes are not kept up to date automatically, so the insert/update/delete triggers are used for that. The syntax for deleting an old row is a bit weird (basically insert a row with a <code>delete</code> string), but that‚Äôs how it is.</p><h3>The query methods</h3><p>The app uses a few methods on <code>Database</code> to create, read, and search articles:</p><pre><p>sql/articles.go</p><code>package sql

import (
	&#34;context&#34;
	&#34;database/sql&#34;
	&#34;errors&#34;
	&#34;strings&#34;

	&#34;github.com/maragudk/sqlite-app/model&#34;
)

// GetTOC of all articles with no content.
func (d *Database) GetTOC(ctx context.Context) ([]model.Article, error) {
	var as []model.Article
	err := d.DB.SelectContext(ctx, &amp;as, `select id, title from articles order by created desc`)
	return as, err
}

// CreateArticle with title and content, ignoring any ID or timestamps.
func (d *Database) CreateArticle(ctx context.Context, a model.Article) error {
	a.Title = strings.ReplaceAll(a.Title, &#34;‚êü&#34;, &#34;&#34;)
	a.Content = strings.ReplaceAll(a.Content, &#34;‚êü&#34;, &#34;&#34;)
	_, err := d.DB.NamedExecContext(ctx, `insert into articles (title, content) values (:title, :content)`, a)
	return err
}

// GetArticle by ID, returning nil if no such ID exists.
// If search is not empty, highlight the given search query in the title and content.
func (d *Database) GetArticle(ctx context.Context, id int, search string) (*model.Article, error) {
	var a model.Article

	query := `select * from articles where id = ?`
	var args []any
	args = append(args, id)

	if search != &#34;&#34; {
		query = `
			select
				a.id,
				highlight(articles_fts, 0, &#39;‚êü&#39;, &#39;‚êü&#39;) title,
				highlight(articles_fts, 1, &#39;‚êü&#39;, &#39;‚êü&#39;) content,
				a.created,
				a.updated
			from articles a
				join articles_fts af on (af.rowid = a.id)
			where id = ? and articles_fts match ?`
		args = append(args, escapeSearch(search))
	}

	if err := d.DB.GetContext(ctx, &amp;a, query, args...); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return &amp;a, nil
}

// SearchArticles with the given search query. Matches in titles are highlighted with the unit separator character ‚êü.
// Matches in content return a snippet of the content, also highlighted with the unit separator character ‚êü.
// Results are ordered by the internal rank of fts5.
// See https://www.sqlite.org/fts5.html
func (d *Database) SearchArticles(ctx context.Context, search string) ([]model.Article, error) {
	var as []model.Article
	query := `
		select
			a.id,
			highlight(articles_fts, 0, &#39;‚êü&#39;, &#39;‚êü&#39;) title,
			snippet(articles_fts, 1, &#39;‚êü&#39;, &#39;‚êü&#39;, &#39;&#39;, 8) content,
			a.created,
			a.updated
		from articles a
			join articles_fts af on (af.rowid = a.id)
		where articles_fts match ?
		order by rank`
	err := d.DB.SelectContext(ctx, &amp;as, query, escapeSearch(search))
	return as, err
}

func escapeSearch(s string) string {
	s = strings.ReplaceAll(s, `&#34;`, `&#34;&#34;`)
	return `&#34;` + s + `&#34;`
}
</code></pre><p>Let‚Äôs start with the most interesting method. <code>SearchArticles</code> selects from the <code>articles</code> table and the <code>articles_fts</code> virtual table. For the title, the optional search query is used to highlight relevant terms, delimited by the unit separator character <code>‚êü</code>. (In the HTML views, that character is later replaced by a <code>&lt;mark&gt;</code> tag.) Similarly, for the article content we fetch a highlighted snippet with a maximum of 8 context words.</p><p>To make this work, we‚Äôre using the <code>match</code> operator on the <code>articles_fts</code> table. We could just use the equality operator, but I think this makes it more clear that it‚Äôs a search.</p><p>Finally, the search is ordered by the special <code>rank</code> column, which orders results by some measure of relevancy.</p><p><code>GetArticle</code> is pretty similar when a search query is given, except it returns the whole highlighted content instead of just a snippet. When no search query is given, it just returns all the article data verbatim.</p><p><code>CreateArticle</code> makes sure our highlight separator character isn‚Äôt in the input text, and otherwise just saves the article. Remember, the fts index is updated via triggers.</p><p>Finally, <code>GetTOC</code> gets just the article IDs and titles, ordered by creation date.</p><p>And voila, that‚Äôs basically all you need to create, read, and search articles.</p><h3>The model</h3><p>You may have noticed the <code>model</code> package above. Here‚Äôs our model:</p><pre><p>sql/articles.go</p><code>package model

import (
	&#34;database/sql/driver&#34;
	&#34;time&#34;

	&#34;github.com/maragudk/errors&#34;
)

type Article struct {
	ID      int
	Title   string
	Content string
	Created Time
	Updated Time
}

type Time struct {
	T time.Time
}

// rfc3339Milli is like time.RFC3339Nano, but with millisecond precision, and fractional seconds do not have trailing
// zeros removed.
const rfc3339Milli = &#34;2006-01-02T15:04:05.000Z07:00&#34;

// Value satisfies driver.Valuer interface.
func (t *Time) Value() (driver.Value, error) {
	return t.T.UTC().Format(rfc3339Milli), nil
}

// Scan satisfies sql.Scanner interface.
func (t *Time) Scan(src any) error {
	if src == nil {
		return nil
	}

	s, ok := src.(string)
	if !ok {
		return errors.Newf(&#34;error scanning time, got %+v&#34;, src)
	}

	parsedT, err := time.Parse(rfc3339Milli, s)
	if err != nil {
		return err
	}

	t.T = parsedT.UTC()

	return nil
}
</code></pre><p>The <code>Article</code> struct holds all our data. Because we want control of how the timestamps are (de)serialized, we‚Äôve added a custom <code>Time</code> struct, which has methods that satisfy the <code>driver.Valuer</code> and <code>sql.Scanner</code> interfaces. That way, we know that any time format in our database always matches <code>rfc3339Milli</code> in UTC.</p><div><div id="888829eca2962abd6e8fae9359e14131274c6a08f7041c9ee983886b05f5c8b8-title"><div><p>Bonus: mattn/go-sqlite3 and time</p></div></div><div id="888829eca2962abd6e8fae9359e14131274c6a08f7041c9ee983886b05f5c8b8-content"><p>The SQLite driver actually has some time (de)serializing code built in, but it doesn‚Äôt work in strict mode. That‚Äôs because strict mode enforces the use of only the data types <code>int</code>, <code>integer</code>, <code>real</code>, <code>text</code>, <code>blob</code>, and <code>any</code>, whereas the driver supports time parsing if the type is set to <code>datetime</code> (which <a href="https://www.sqlite.org/datatype3.html#affinity_name_examples">is actually just an alias for <code>numeric</code></a>).</p><p>Confused? Me too. That‚Äôs one more reason to stick to strict mode.</p></div></div><p>Why am I using incrementing integers for IDs here? Because it‚Äôs easy. Sometimes you want something like string UUIDs instead, for example if you don‚Äôt want to show how many of something you have (e.g. users, purchases, that slightly embarassing plush frog collection). In that case, take a look at <a href="https://github.com/google/uuid">github.com/google/uuid</a>, which also has SQL (de)serialization built it.</p><h3>Testing</h3><p>How do we know this works and keeps working? Tests!</p><pre><p>sql/articles_test.go</p><code>package sql_test

import (
	&#34;context&#34;
	&#34;testing&#34;
	&#34;time&#34;

	&#34;github.com/stretchr/testify/require&#34;

	&#34;github.com/maragudk/sqlite-app/model&#34;
	&#34;github.com/maragudk/sqlite-app/sqltest&#34;
)

func TestDatabase_GetTOC(t *testing.T) {
	t.Run(&#34;gets all articles with only id and title reverse chronological order&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Foo&#34;,
			Content: &#34;Bar&#34;,
		})
		require.NoError(t, err)

		err = db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Baz&#34;,
			Content: &#34;Boo&#34;,
		})
		require.NoError(t, err)

		as, err := db.GetTOC(context.Background())
		require.NoError(t, err)
		require.Len(t, as, 2)
		require.Equal(t, 2, as[0].ID)
		require.Equal(t, &#34;Baz&#34;, as[0].Title)
		require.Equal(t, &#34;&#34;, as[0].Content)

		require.Equal(t, 1, as[1].ID)
	})
}

func TestDatabase_CreateArticle(t *testing.T) {
	t.Run(&#34;discards the unit separator character in title and content&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Foo‚êü&#34;,
			Content: &#34;Bar‚êü&#34;,
		})
		require.NoError(t, err)

		a, err := db.GetArticle(context.Background(), 1, &#34;&#34;)
		require.NoError(t, err)
		require.NotNil(t, a)
		require.Equal(t, &#34;Foo&#34;, a.Title)
		require.Equal(t, &#34;Bar&#34;, a.Content)
	})
}

func TestDatabase_GetArticle(t *testing.T) {
	t.Run(&#34;gets an article&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Foo&#34;,
			Content: &#34;Bar&#34;,
		})
		require.NoError(t, err)

		a, err := db.GetArticle(context.Background(), 1, &#34;&#34;)
		require.NoError(t, err)
		require.NotNil(t, a)
		require.Equal(t, 1, a.ID)
		require.Equal(t, &#34;Foo&#34;, a.Title)
		require.Equal(t, &#34;Bar&#34;, a.Content)
		require.WithinDuration(t, time.Now(), a.Created.T, time.Second)
		require.WithinDuration(t, time.Now(), a.Updated.T, time.Second)
	})

	t.Run(&#34;returns nil on no such id&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		a, err := db.GetArticle(context.Background(), 1, &#34;&#34;)
		require.NoError(t, err)
		require.Nil(t, a)
	})

	t.Run(&#34;highlights substrings if search given&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;The Foo Bar&#34;,
			Content: &#34;Foo Bar Foo&#34;,
		})
		require.NoError(t, err)

		a, err := db.GetArticle(context.Background(), 1, &#34;foo&#34;)
		require.NoError(t, err)
		require.NotNil(t, a)
		require.Equal(t, &#34;The ‚êüFoo‚êü Bar&#34;, a.Title)
		require.Equal(t, &#34;‚êüFoo‚êü Bar ‚êüFoo‚êü&#34;, a.Content)
	})
}

func TestDatabase_SearchArticles(t *testing.T) {
	db := sqltest.CreateDatabase(t)
	err := db.CreateArticle(context.Background(), model.Article{
		Title:   &#34;The Foo is great&#34;,
		Content: &#34;I wish that bar was also, but who am I to complain?&#34;,
	})
	require.NoError(t, err)

	err = db.CreateArticle(context.Background(), model.Article{
		Title:   &#34;Bar me up a notch&#34;,
		Content: &#34;Boo ya.&#34;,
	})
	require.NoError(t, err)

	t.Run(&#34;searches article titles and content and highlights and makes snippets&#34;, func(t *testing.T) {
		as, err := db.SearchArticles(context.Background(), &#34;bar&#34;)
		require.NoError(t, err)
		require.Len(t, as, 2)

		require.Equal(t, &#34;‚êüBar‚êü me up a notch&#34;, as[0].Title)
		require.Equal(t, &#34;Boo ya.&#34;, as[0].Content)
		require.Equal(t, &#34;The Foo is great&#34;, as[1].Title)
		require.Equal(t, &#34;I wish that ‚êübar‚êü was also, but who&#34;, as[1].Content)
	})
}
</code></pre><p>The tests themselves are pretty unremarkable, but have a quick read.</p><p>What makes this work is in the <code>sqltest</code> helper package:</p><pre><p>sqltest/database.go</p><code>package sqltest

import (
	&#34;context&#34;
	&#34;testing&#34;

	&#34;github.com/maragudk/env&#34;

	&#34;github.com/maragudk/sqlite-app/sql&#34;
)

// CreateDatabase for testing.
func CreateDatabase(t *testing.T) *sql.Database {
	t.Helper()

	_ = env.Load(&#34;../.env-test&#34;)

	db := sql.NewDatabase(sql.NewDatabaseOptions{
		URL:                env.GetStringOrDefault(&#34;DATABASE_URL&#34;, &#34;:memory:&#34;),
		MaxOpenConnections: 1,
		MaxIdleConnections: 1,
	})
	if err := db.Connect(); err != nil {
		t.Fatal(err)
	}

	if err := db.MigrateUp(context.Background()); err != nil {
		t.Fatal(err)
	}

	return db
}
</code></pre><p>Each test gets its own in-memory database that‚Äôs automatically deleted after the test run! And it‚Äôs super fast! All tests in the repo run in under 1 second on my machine, and that‚Äôs just beautiful. It very much matches Go‚Äôs philosophy of tools being fast. (Can you tell I really love this?)</p><h3>The rest</h3><p>I‚Äôm not going to show you the rest of the app code, as it‚Äôs not very specific to SQLite. Just know that the HTTP server, routes, and HTTP handlers are in the <code>http</code> package, and the HTML views are in the (you guessed it) <code>html</code> package. I haven‚Äôt added tests for these, but probably would in a real production app. If you‚Äôd like to try, I would start with the <code>NewArticle</code> handler.</p><h2>Deploying to the cloud</h2><p>Web apps are just more fun if they don‚Äôt just run locally, and I‚Äôll show you how easy it is to get this app running in the cloud. Let‚Äôs give <a href="https://fly.io">fly.io</a> a spin. Sign up for an account with them if you don‚Äôt have one already, and install the Fly CLI. Then, running <code>fly launch</code> will give you something like this:</p><pre><code>$ fly launch
An existing fly.toml file was found for app sqlite-app
? Would you like to copy its configuration to the new app? Yes
Creating app in /Users/markus/Developer/my-sqlite-app
Scanning source code
Detected a Dockerfile app
? Create .dockerignore from 1 .gitignore files? No
? Choose an app name (leave blank to generate one): my-sqlite-app
? Select Organization: Markus (personal)
? Choose a region for deployment: Frankfurt, Germany (fra)
Created app my-sqlite-app in organization personal
Wrote config file fly.toml
? Would you like to set up a Postgresql database now? No
? Would you like to deploy now? No
Your app is ready! Deploy with flyctl deploy</code></pre><p>Make sure to say yes to copying the existing configuration, because I‚Äôve made it easy for you. It‚Äôs just a standard configuration, but makes sure to mount the persistent volume we‚Äôll create in a minute and sets the <code>DATABASE_URL</code> environment variable to use it.</p><p>Pick any region close to you. Just make sure to remember your choice, because you want the volume to be in the same region.</p><p>Answer no to setting up a Postgres database (haha), and also no to deploying. We need the volume first, so set it up with <code>fly vol create</code>:</p><pre><code>$ fly vol create data -s 1
? Select region: Frankfurt, Germany (fra)
        ID: vol_gez1nvxypen4mxl7
      Name: data
       App: my-sqlite-app
    Region: fra
      Zone: d7f9
   Size GB: 1
 Encrypted: true
Created at: 04 Nov 22 10:09 UTC</code></pre><p>Now, run <code>fly deploy</code>, and the Fly builder will build your Docker image, deploy it to your selected region, and start it up!</p><p>There‚Äôs only one more thing to do: run the migrations. Do that with a POST request to the <code>/migrate/up</code> path using your favourite tool. Mine‚Äôs <a href="https://httpie.io">HTTPie</a>:</p><pre><code>$ http post https://my-sqlite-app.fly.dev/migrate/up
HTTP/1.1 200 OK
content-length: 0
date: Fri, 04 Nov 2022 10:18:37 GMT
fly-request-id: 01GH12CM0MR0Z50E8GDNY916Y7-fra
server: Fly/c86be2f07 (2022-11-03)
via: 1.1 fly.io</code></pre><p>And voila, your web app powered by SQLite is now in the cloud! Congratulations. Have a celebratory coffee and cookie. You deserve it. üòÑ</p><p>Are there any downsides to this approach? Yes. Every time you deploy, fly.io has to take your app offline for a few seconds, because two containers can‚Äôt have the same persistent volume attached at once. For many web apps, it‚Äôs perfectly fine to be offline for a few seconds once in a while. But if not, look out for the distributed SQLite things happening in the space. üòé</p><h2>Resources</h2><p>This article wouldn‚Äôt have been possible without these excellent resources (in no particular order):</p><ul><li><a href="https://fly.io/blog/all-in-on-sqlite-litestream/">&#34;I‚Äôm All-In on Server-Side SQLite&#34; by Ben Johnson</a></li><li><a href="https://www.youtube.com/watch?v=XcAYkriuQ1o">&#34;Building Production Applications Using Go &amp; SQLite&#34; from GopherCon 2021, also by Ben Johnson</a></li><li><a href="https://www.sqlite.org/index.html">The official SQLite documentation</a></li><li><a href="https://crawshaw.io/blog/one-process-programming-notes">&#34;One process programming notes (with Go and SQLite)&#34; by David Crawshaw</a></li></ul><div><h2>About</h2><p>I‚Äôm Markus ü§ì‚ú®. I‚Äôm passionate about simple &amp; boring but useful software. So we can build the things that actually matter.</p><p>Want to learn Go web and cloud development? <a href="https://www.golang.dk/">I‚Äôve got online Go courses</a>! üòé</p><p>Need someone to do it for you? <a href="https://www.maragu.dk">I do software consulting</a>.</p><p>Enjoyed this? Want my newsletter? No spam. Instant unsubscribe any time.</p><p><img src="https://www.golang.dk/images/markus.jpg" alt="Picture of Markus, the author."/></p></div></div></div></div>
  </body>
</html>
