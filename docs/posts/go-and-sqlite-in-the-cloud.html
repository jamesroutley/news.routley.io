<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.golang.dk/articles/go-and-sqlite-in-the-cloud">Original</a>
    <h1>Go and SQLite in the Cloud</h1>
    
    <div id="readability-page-1" class="page"><div id="top"><div><p><img src="https://www.golang.dk/images/articles/go-and-sqlite-in-the-cloud.png" alt="A digital drawing of a Gopher storing stuff in a database."/></p><p>Why SQLite and Go in the cloud are a great match, getting started, best practices, and more.</p><p>Last updated November 2022 for Go 1.19.</p><h2>Why SQLite and Go?</h2><p>I love the intersection of the cloud and &#34;boring&#34; old technologies. <a href="https://www.sqlite.org/index.html">SQLite</a> and the cloud is a perfect example of this. SQLite has been around forever, runs on literally billions of devices (it’s in space!) and is super robust and well-tested. You probably have it running on the phone in your pocket already.</p><p>SQLite is currently in something of a renaissance, because it’s increasingly being used on the . Have a look at <a href="https://blog.cloudflare.com/introducing-d1/">Cloudflare’s D1</a>, or what <a href="https://fly.io/blog/all-in-on-sqlite-litestream/">fly.io are doing with SQLite, Litestream, and LiteFS</a>.</p><p>But even if you’re not doing anything fancy and just have a service running somewhere, with a persistent disk attached, SQLite could be worth another look instead of the usual Postgres/MySQL central server setup.</p><p>Why? Because it’s just <em>so crazy fast</em>, conceptually and practically simple, but still covers the needs of (I’d wager) most of the web apps out there. It has , full SQL support, great tooling, and did I say it was fast? We’re talking microseconds instead of milliseconds for queries.</p><p>Convinced to try it out? In this article, I’ll show you:</p><ul><li>how to set up an app with SQLite and Go, with idiomatic, production-ready, best-practice code;</li><li>how to test your app efficiently;</li><li>some Go-specific data modelling best practices; and</li><li>how to deploy it all to the cloud.</li></ul><p>What I won’t show you this time is how to do distributed SQLite across several nodes in the cloud edge. <a href="https://www.golang.dk/articles/distributed-sqlite-with-litefs">Check out my article on distributed SQLite with LiteFS for that</a>, which builds on this article. I also won’t show you how to use SQL.</p><p>This is a living document. Got any comments, questions, or suggestions? <a href="mailto:markus@golang.dk">Send me an email</a> or <a href="https://hachyderm.io/@markus">find me on Mastodon</a>.</p><p>Let’s go!</p><h2>The Go SQLite app</h2><p>The app is a tiny web app with a blog, where articles can be created, viewed, and searched.</p><p><img src="https://www.golang.dk/images/articles/sqlite-app.png" alt="A screenshot of the sqlite-app web app, showing an article search."/></p><p>I’ll show you the relevant parts of the app on this page. Check out <a href="https://github.com/maragudk/sqlite-app">all the code of the sqlite-app on Github</a>, and <a href="https://sqlite-app.fly.dev/">poke around the online demo here</a>. If you want to follow along, clone the repo, run <code>make migrate-up start</code> and then go to <a href="http://localhost:8080">localhost:8080</a>. Try it, I’ll wait.</p><p>The output should look something like this:</p><pre><code>$ make migrate-up start
go run ./cmd/migrate up
2022/11/03 12:28:57 database.go:61: Connecting to database at file:app.db?_journal=WAL&amp;_timeout=5000&amp;_fk=true
2022/11/03 12:28:57 database.go:69: Setting connection pool options ( max open connections: 1 , max idle connections: 1 , connection max lifetime: 0s , connection max idle time: 0s )
2022/11/03 12:28:57 main.go:41: Migrated up
go run -tags fts5 ./cmd/server
2022/11/03 12:29:18 main.go:20: Starting
2022/11/03 12:29:18 database.go:61: Connecting to database at file:app.db?_journal=WAL&amp;_timeout=5000&amp;_fk=true
2022/11/03 12:29:18 database.go:69: Setting connection pool options ( max open connections: 5 , max idle connections: 5 , connection max lifetime: 1h0m0s , connection max idle time: 1h0m0s )
2022/11/03 12:29:18 server.go:60: Starting
2022/11/03 12:29:18 server.go:64: Listening on http://localhost:8080</code></pre><h3>The database</h3><p>The storage to SQLite is handled in the <code>Database</code> struct. It’s constructed with a database URL, a few connection parameters, and a logger. Have a look at the code, and we’ll go through it:</p><pre><p>sql/database.go</p><code>package sql

import (
	&#34;context&#34;
	&#34;embed&#34;
	&#34;io&#34;
	&#34;io/fs&#34;
	&#34;log&#34;
	&#34;time&#34;

	&#34;github.com/jmoiron/sqlx&#34;
	&#34;github.com/maragudk/migrate&#34;
	_ &#34;github.com/mattn/go-sqlite3&#34;
)

type Database struct {
	DB                    *sqlx.DB
	url                   string
	maxOpenConnections    int
	maxIdleConnections    int
	connectionMaxLifetime time.Duration
	connectionMaxIdleTime time.Duration
	log                   *log.Logger
}

type NewDatabaseOptions struct {
	URL                   string
	MaxOpenConnections    int
	MaxIdleConnections    int
	ConnectionMaxLifetime time.Duration
	ConnectionMaxIdleTime time.Duration
	Log                   *log.Logger
}

// NewDatabase with the given options.
// If no logger is provided, logs are discarded.
func NewDatabase(opts NewDatabaseOptions) *Database {
	if opts.Log == nil {
		opts.Log = log.New(io.Discard, &#34;&#34;, 0)
	}

	// - Set WAL mode (not strictly necessary each time because it&#39;s persisted in the database, but good for first run)
	// - Set busy timeout, so concurrent writers wait on each other instead of erroring immediately
	// - Enable foreign key checks
	opts.URL += &#34;?_journal=WAL&amp;_timeout=5000&amp;_fk=true&#34;

	return &amp;Database{
		url:                   opts.URL,
		maxOpenConnections:    opts.MaxOpenConnections,
		maxIdleConnections:    opts.MaxIdleConnections,
		connectionMaxLifetime: opts.ConnectionMaxLifetime,
		connectionMaxIdleTime: opts.ConnectionMaxIdleTime,
		log:                   opts.Log,
	}
}

func (d *Database) Connect() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	d.log.Println(&#34;Connecting to database at&#34;, d.url)

	var err error
	d.DB, err = sqlx.ConnectContext(ctx, &#34;sqlite3&#34;, d.url)
	if err != nil {
		return err
	}

	d.log.Println(&#34;Setting connection pool options (&#34;,
		&#34;max open connections:&#34;, d.maxOpenConnections,
		&#34;, max idle connections:&#34;, d.maxIdleConnections,
		&#34;, connection max lifetime:&#34;, d.connectionMaxLifetime,
		&#34;, connection max idle time:&#34;, d.connectionMaxIdleTime,
		&#34;)&#34;)
	d.DB.SetMaxOpenConns(d.maxOpenConnections)
	d.DB.SetMaxIdleConns(d.maxIdleConnections)
	d.DB.SetConnMaxLifetime(d.connectionMaxLifetime)
	d.DB.SetConnMaxIdleTime(d.connectionMaxIdleTime)

	return nil
}

// …</code></pre><p>First, the imports. I’m using the Go SQLite database driver from <a href="https://github.com/mattn/go-sqlite3">github.com/mattn/go-sqlite3</a>, which basically uses the official SQLite C library directly, wired up to be easy to use from Go.</p><div><p>In order to be able to compile your program, you need a C compiler installed. I won’t go into details with how this is done. Start at <a href="https://go.dev/blog/cgo">the Cgo blog intro</a> if you’re stuck.</p></div><p>Another import is <a href="https://github.com/jmoiron/sqlx">github.com/jmoiron/sqlx</a>, which is an excellent SQL helper library which makes querying the database much easier.</p><p>After that, it gets interesting in <code>NewDatabase</code>. We set three options for the SQL driver as URL query parameters:</p><ol><li><p><strong>_journal=WAL</strong> means we set the journal mode to <a href="https://sqlite.org/wal.html">WAL</a> (Write-Ahead Log). What’s a journal mode? It’s about how SQLite handles writing data to disk safely.</p><p>The default journal mode in SQLite is a so-called <a href="https://sqlite.org/lockingv3.html#rollback">rollback journal</a>, which means that changes are written directly to the main database file, and the old data is kept in the rollback journal in a separate file. When data is written, readers are blocked, and when data is read, writers are blocked!</p><p>Because of this, we use the WAL journal mode instead, where readers don’t block writers and writers don’t block readers. (Writers still block writers, though, because write access is serialized. See below.) As the name implies, the WAL receives all new writes, and readers can keep reading from the main database file. (Readers also read from the WAL once changes are committed, but that’s a detail we don’t need to consider right now.)</p><p>Note: The WAL journal mode is actually persisted to the database file the first time it’s opened like this, but to keep things simple, we just set the option every time. It’s just a no-op then.</p></li><li><p><strong>_timeout=5000</strong> sets a busy timeout to 5000 milliseconds, or 5 seconds. <a href="https://www.sqlite.org/isolation.html">There can only be one writer at a time in SQLite</a>, so if another writer wants concurrent access, it would normally be blocked and return an error. If the busy timeout is set, the writer will instead wait up to that timeout for write access, and only then return an error. So it’s a good idea to set this if you ever think you will have concurrent writes, and of course in web apps, you will.</p></li><li><p><strong>_fk=true</strong> enables <a href="https://sqlite.org/foreignkeys.html">foreign key checking</a>. <em>Why do I need to enable that explicitly?!</em>, you might rightfully ask. The answer is, for backwards compatibility with older versions of SQLite. This can also be set at compile-time, but better safe than sorry here, in my opinion. Referential integrity FTW.</p></li></ol><p>After that, the <code>Connect</code> method actually establishes the connection using the <code>sqlite3</code> driver name and the database URL passed into the struct. It sets a few sane connection options, logs them, and that’s it.</p><h3>The schema</h3><p>In order to save our articles and make them searchable, we’ll contruct an <code>articles</code> table and an <code>articles_fts</code> virtual table.</p><pre><p>sql/migrations/1667384958-articles.up.sql</p><code>create table articles (
  id integer primary key,
  title text not null,
  content text not null,
  created text not null default (strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;)),
  updated text not null default (strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;))
) strict;

create index articles_created_idx on articles (created);

create trigger articles_updated_timestamp after update on articles begin
  update articles set updated = strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;) where id = old.id;
end;
</code></pre><p>We want an automatically generated ID for our articles. In SQLite, in order to have an explicit, auto-incrementing integer primary key, the type has to be <code>integer primary key</code> (NOT <code>int primary key</code>, then it won’t work 🙄), so that’s what we use here.</p><p>I’ve added create and update timestamps here as strings (the <code>text</code> type). Why not write <code>default current_timestamp</code> instead? Because it’s not <em>quite</em> the format we should all be using, namely ISO8601/RFC3339. <code>select current_timestamp</code> outputs something like 2022-12-07 19:12:34, which lacks the <code>T</code> separator, has no timezone info, and has no sub-second precision.</p><p><code>strftime(&#39;%Y-%m-%dT%H:%M:%fZ&#39;)</code> almost matches the format given in the Go stdlib at <code>time.RFC3339Nano</code>, except it’s millisecond precision. Because mixing timestamps with different precisions with a timezone suffix doesn’t sort correctly chronologically (for example <code>2022-11-11T12:34:56.000Z</code> sorts <em>after</em> <code>2022-11-11T12:34:56.000000001Z</code>), we use our own time format called <code>rfc3339Milli</code> later. We’ll use that for parsing and serializing time in Go code.</p><p>We’re also adding an index on the creation time for good measure, and a trigger to update the <code>updated</code> timestamp automatically after update. Nifty!</p><p>Waaaait, what’s that <code>strict</code> keyword? It’s a usage of the relatively new <a href="https://www.sqlite.org/stricttables.html">strict tables</a> feature (from 2021). Normally, even though you can declare types on table columns in SQLite, by default the types are not enforced on insert/update and you can insert whatever you like. The <code>strict</code> keyword restricts this, which is arguably more aligned with how we use the database in Go. Unfortunately, you need to remember to write this after each <code>create table</code> declaration in every migration you ever write, instead of it being a global feature you can enable (like foreign key support). Somebody should write a linter for that (you? 😉).</p><p>Onto the full text search virtual table:</p><pre><p>sql/migrations/1667395622-fts.up.sql</p><code>create virtual table articles_fts
  using fts5(title, content, tokenize = porter, content = &#39;articles&#39;, content_rowid = &#39;id&#39;);

create trigger articles_after_insert after insert on articles begin
  insert into articles_fts (rowid, title, content) values (new.id, new.title, new.content);
end;

create trigger articles_fts_after_update after update on articles begin
  insert into articles_fts (articles_fts, rowid, title, content) values(&#39;delete&#39;, old.id, old.title, old.content);
  insert into articles_fts (rowid, title, content) values (new.id, new.title, new.content);
end;

create trigger articles_fts_after_delete after delete on articles begin
  insert into articles_fts (articles_fts, rowid, title, content) values(&#39;delete&#39;, old.id, old.title, old.content);
end;

</code></pre><p>Here, we use the <a href="https://www.sqlite.org/fts5.html">FTS5</a> extension to create a virtual table that will hold our full-text search indexes. I want to have indexes on the article title and content, so that’s what I’m declaring here. You can pass in a few settings, which I’ve done to set the text tokenizer to <a href="https://www.sqlite.org/fts5.html#porter_tokenizer">porter</a> (which does word stemming). I’ve also enabled <a href="https://www.sqlite.org/fts5.html#external_content_tables">external content tables</a>, which means that the virtual table won’t hold a copy of the source data, but refer it to the <code>articles</code> table. The column to join on is set by the <code>content_rowid</code> option.</p><p>Full-text search indexes are not kept up to date automatically, so the insert/update/delete triggers are used for that. The syntax for deleting an old row is a bit weird (basically insert a row with a <code>delete</code> string), but that’s how it is.</p><h3>The query methods</h3><p>The app uses a few methods on <code>Database</code> to create, read, and search articles:</p><pre><p>sql/articles.go</p><code>package sql

import (
	&#34;context&#34;
	&#34;database/sql&#34;
	&#34;errors&#34;
	&#34;strings&#34;

	&#34;github.com/maragudk/sqlite-app/model&#34;
)

// GetTOC of all articles with no content.
func (d *Database) GetTOC(ctx context.Context) ([]model.Article, error) {
	var as []model.Article
	err := d.DB.SelectContext(ctx, &amp;as, `select id, title from articles order by created desc`)
	return as, err
}

// CreateArticle with title and content, ignoring any ID or timestamps.
func (d *Database) CreateArticle(ctx context.Context, a model.Article) error {
	a.Title = strings.ReplaceAll(a.Title, &#34;␟&#34;, &#34;&#34;)
	a.Content = strings.ReplaceAll(a.Content, &#34;␟&#34;, &#34;&#34;)
	_, err := d.DB.NamedExecContext(ctx, `insert into articles (title, content) values (:title, :content)`, a)
	return err
}

// GetArticle by ID, returning nil if no such ID exists.
// If search is not empty, highlight the given search query in the title and content.
func (d *Database) GetArticle(ctx context.Context, id int, search string) (*model.Article, error) {
	var a model.Article

	query := `select * from articles where id = ?`
	var args []any
	args = append(args, id)

	if search != &#34;&#34; {
		query = `
			select
				a.id,
				highlight(articles_fts, 0, &#39;␟&#39;, &#39;␟&#39;) title,
				highlight(articles_fts, 1, &#39;␟&#39;, &#39;␟&#39;) content,
				a.created,
				a.updated
			from articles a
				join articles_fts af on (af.rowid = a.id)
			where id = ? and articles_fts match ?`
		args = append(args, escapeSearch(search))
	}

	if err := d.DB.GetContext(ctx, &amp;a, query, args...); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, nil
		}
		return nil, err
	}
	return &amp;a, nil
}

// SearchArticles with the given search query. Matches in titles are highlighted with the unit separator character ␟.
// Matches in content return a snippet of the content, also highlighted with the unit separator character ␟.
// Results are ordered by the internal rank of fts5.
// See https://www.sqlite.org/fts5.html
func (d *Database) SearchArticles(ctx context.Context, search string) ([]model.Article, error) {
	var as []model.Article
	query := `
		select
			a.id,
			highlight(articles_fts, 0, &#39;␟&#39;, &#39;␟&#39;) title,
			snippet(articles_fts, 1, &#39;␟&#39;, &#39;␟&#39;, &#39;&#39;, 8) content,
			a.created,
			a.updated
		from articles a
			join articles_fts af on (af.rowid = a.id)
		where articles_fts match ?
		order by rank`
	err := d.DB.SelectContext(ctx, &amp;as, query, escapeSearch(search))
	return as, err
}

func escapeSearch(s string) string {
	s = strings.ReplaceAll(s, `&#34;`, `&#34;&#34;`)
	return `&#34;` + s + `&#34;`
}
</code></pre><p>Let’s start with the most interesting method. <code>SearchArticles</code> selects from the <code>articles</code> table and the <code>articles_fts</code> virtual table. For the title, the optional search query is used to highlight relevant terms, delimited by the unit separator character <code>␟</code>. (In the HTML views, that character is later replaced by a <code>&lt;mark&gt;</code> tag.) Similarly, for the article content we fetch a highlighted snippet with a maximum of 8 context words.</p><p>To make this work, we’re using the <code>match</code> operator on the <code>articles_fts</code> table. We could just use the equality operator, but I think this makes it more clear that it’s a search.</p><p>Finally, the search is ordered by the special <code>rank</code> column, which orders results by some measure of relevancy.</p><p><code>GetArticle</code> is pretty similar when a search query is given, except it returns the whole highlighted content instead of just a snippet. When no search query is given, it just returns all the article data verbatim.</p><p><code>CreateArticle</code> makes sure our highlight separator character isn’t in the input text, and otherwise just saves the article. Remember, the fts index is updated via triggers.</p><p>Finally, <code>GetTOC</code> gets just the article IDs and titles, ordered by creation date.</p><p>And voila, that’s basically all you need to create, read, and search articles.</p><h3>The model</h3><p>You may have noticed the <code>model</code> package above. Here’s our model:</p><pre><p>sql/articles.go</p><code>package model

import (
	&#34;database/sql/driver&#34;
	&#34;time&#34;

	&#34;github.com/maragudk/errors&#34;
)

type Article struct {
	ID      int
	Title   string
	Content string
	Created Time
	Updated Time
}

type Time struct {
	T time.Time
}

// rfc3339Milli is like time.RFC3339Nano, but with millisecond precision, and fractional seconds do not have trailing
// zeros removed.
const rfc3339Milli = &#34;2006-01-02T15:04:05.000Z07:00&#34;

// Value satisfies driver.Valuer interface.
func (t *Time) Value() (driver.Value, error) {
	return t.T.UTC().Format(rfc3339Milli), nil
}

// Scan satisfies sql.Scanner interface.
func (t *Time) Scan(src any) error {
	if src == nil {
		return nil
	}

	s, ok := src.(string)
	if !ok {
		return errors.Newf(&#34;error scanning time, got %+v&#34;, src)
	}

	parsedT, err := time.Parse(rfc3339Milli, s)
	if err != nil {
		return err
	}

	t.T = parsedT.UTC()

	return nil
}
</code></pre><p>The <code>Article</code> struct holds all our data. Because we want control of how the timestamps are (de)serialized, we’ve added a custom <code>Time</code> struct, which has methods that satisfy the <code>driver.Valuer</code> and <code>sql.Scanner</code> interfaces. That way, we know that any time format in our database always matches <code>rfc3339Milli</code> in UTC.</p><div><div id="888829eca2962abd6e8fae9359e14131274c6a08f7041c9ee983886b05f5c8b8-title"><div><p>Bonus: mattn/go-sqlite3 and time</p></div></div><div id="888829eca2962abd6e8fae9359e14131274c6a08f7041c9ee983886b05f5c8b8-content"><p>The SQLite driver actually has some time (de)serializing code built in, but it doesn’t work in strict mode. That’s because strict mode enforces the use of only the data types <code>int</code>, <code>integer</code>, <code>real</code>, <code>text</code>, <code>blob</code>, and <code>any</code>, whereas the driver supports time parsing if the type is set to <code>datetime</code> (which <a href="https://www.sqlite.org/datatype3.html#affinity_name_examples">is actually just an alias for <code>numeric</code></a>).</p><p>Confused? Me too. That’s one more reason to stick to strict mode.</p></div></div><p>Why am I using incrementing integers for IDs here? Because it’s easy. Sometimes you want something like string UUIDs instead, for example if you don’t want to show how many of something you have (e.g. users, purchases, that slightly embarassing plush frog collection). In that case, take a look at <a href="https://github.com/google/uuid">github.com/google/uuid</a>, which also has SQL (de)serialization built it.</p><h3>Testing</h3><p>How do we know this works and keeps working? Tests!</p><pre><p>sql/articles_test.go</p><code>package sql_test

import (
	&#34;context&#34;
	&#34;testing&#34;
	&#34;time&#34;

	&#34;github.com/stretchr/testify/require&#34;

	&#34;github.com/maragudk/sqlite-app/model&#34;
	&#34;github.com/maragudk/sqlite-app/sqltest&#34;
)

func TestDatabase_GetTOC(t *testing.T) {
	t.Run(&#34;gets all articles with only id and title reverse chronological order&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Foo&#34;,
			Content: &#34;Bar&#34;,
		})
		require.NoError(t, err)

		err = db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Baz&#34;,
			Content: &#34;Boo&#34;,
		})
		require.NoError(t, err)

		as, err := db.GetTOC(context.Background())
		require.NoError(t, err)
		require.Len(t, as, 2)
		require.Equal(t, 2, as[0].ID)
		require.Equal(t, &#34;Baz&#34;, as[0].Title)
		require.Equal(t, &#34;&#34;, as[0].Content)

		require.Equal(t, 1, as[1].ID)
	})
}

func TestDatabase_CreateArticle(t *testing.T) {
	t.Run(&#34;discards the unit separator character in title and content&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Foo␟&#34;,
			Content: &#34;Bar␟&#34;,
		})
		require.NoError(t, err)

		a, err := db.GetArticle(context.Background(), 1, &#34;&#34;)
		require.NoError(t, err)
		require.NotNil(t, a)
		require.Equal(t, &#34;Foo&#34;, a.Title)
		require.Equal(t, &#34;Bar&#34;, a.Content)
	})
}

func TestDatabase_GetArticle(t *testing.T) {
	t.Run(&#34;gets an article&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;Foo&#34;,
			Content: &#34;Bar&#34;,
		})
		require.NoError(t, err)

		a, err := db.GetArticle(context.Background(), 1, &#34;&#34;)
		require.NoError(t, err)
		require.NotNil(t, a)
		require.Equal(t, 1, a.ID)
		require.Equal(t, &#34;Foo&#34;, a.Title)
		require.Equal(t, &#34;Bar&#34;, a.Content)
		require.WithinDuration(t, time.Now(), a.Created.T, time.Second)
		require.WithinDuration(t, time.Now(), a.Updated.T, time.Second)
	})

	t.Run(&#34;returns nil on no such id&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		a, err := db.GetArticle(context.Background(), 1, &#34;&#34;)
		require.NoError(t, err)
		require.Nil(t, a)
	})

	t.Run(&#34;highlights substrings if search given&#34;, func(t *testing.T) {
		db := sqltest.CreateDatabase(t)

		err := db.CreateArticle(context.Background(), model.Article{
			Title:   &#34;The Foo Bar&#34;,
			Content: &#34;Foo Bar Foo&#34;,
		})
		require.NoError(t, err)

		a, err := db.GetArticle(context.Background(), 1, &#34;foo&#34;)
		require.NoError(t, err)
		require.NotNil(t, a)
		require.Equal(t, &#34;The ␟Foo␟ Bar&#34;, a.Title)
		require.Equal(t, &#34;␟Foo␟ Bar ␟Foo␟&#34;, a.Content)
	})
}

func TestDatabase_SearchArticles(t *testing.T) {
	db := sqltest.CreateDatabase(t)
	err := db.CreateArticle(context.Background(), model.Article{
		Title:   &#34;The Foo is great&#34;,
		Content: &#34;I wish that bar was also, but who am I to complain?&#34;,
	})
	require.NoError(t, err)

	err = db.CreateArticle(context.Background(), model.Article{
		Title:   &#34;Bar me up a notch&#34;,
		Content: &#34;Boo ya.&#34;,
	})
	require.NoError(t, err)

	t.Run(&#34;searches article titles and content and highlights and makes snippets&#34;, func(t *testing.T) {
		as, err := db.SearchArticles(context.Background(), &#34;bar&#34;)
		require.NoError(t, err)
		require.Len(t, as, 2)

		require.Equal(t, &#34;␟Bar␟ me up a notch&#34;, as[0].Title)
		require.Equal(t, &#34;Boo ya.&#34;, as[0].Content)
		require.Equal(t, &#34;The Foo is great&#34;, as[1].Title)
		require.Equal(t, &#34;I wish that ␟bar␟ was also, but who&#34;, as[1].Content)
	})
}
</code></pre><p>The tests themselves are pretty unremarkable, but have a quick read.</p><p>What makes this work is in the <code>sqltest</code> helper package:</p><pre><p>sqltest/database.go</p><code>package sqltest

import (
	&#34;context&#34;
	&#34;testing&#34;

	&#34;github.com/maragudk/env&#34;

	&#34;github.com/maragudk/sqlite-app/sql&#34;
)

// CreateDatabase for testing.
func CreateDatabase(t *testing.T) *sql.Database {
	t.Helper()

	_ = env.Load(&#34;../.env-test&#34;)

	db := sql.NewDatabase(sql.NewDatabaseOptions{
		URL:                env.GetStringOrDefault(&#34;DATABASE_URL&#34;, &#34;:memory:&#34;),
		MaxOpenConnections: 1,
		MaxIdleConnections: 1,
	})
	if err := db.Connect(); err != nil {
		t.Fatal(err)
	}

	if err := db.MigrateUp(context.Background()); err != nil {
		t.Fatal(err)
	}

	return db
}
</code></pre><p>Each test gets its own in-memory database that’s automatically deleted after the test run! And it’s super fast! All tests in the repo run in under 1 second on my machine, and that’s just beautiful. It very much matches Go’s philosophy of tools being fast. (Can you tell I really love this?)</p><h3>The rest</h3><p>I’m not going to show you the rest of the app code, as it’s not very specific to SQLite. Just know that the HTTP server, routes, and HTTP handlers are in the <code>http</code> package, and the HTML views are in the (you guessed it) <code>html</code> package. I haven’t added tests for these, but probably would in a real production app. If you’d like to try, I would start with the <code>NewArticle</code> handler.</p><h2>Deploying to the cloud</h2><p>Web apps are just more fun if they don’t just run locally, and I’ll show you how easy it is to get this app running in the cloud. Let’s give <a href="https://fly.io">fly.io</a> a spin. Sign up for an account with them if you don’t have one already, and install the Fly CLI. Then, running <code>fly launch</code> will give you something like this:</p><pre><code>$ fly launch
An existing fly.toml file was found for app sqlite-app
? Would you like to copy its configuration to the new app? Yes
Creating app in /Users/markus/Developer/my-sqlite-app
Scanning source code
Detected a Dockerfile app
? Create .dockerignore from 1 .gitignore files? No
? Choose an app name (leave blank to generate one): my-sqlite-app
? Select Organization: Markus (personal)
? Choose a region for deployment: Frankfurt, Germany (fra)
Created app my-sqlite-app in organization personal
Wrote config file fly.toml
? Would you like to set up a Postgresql database now? No
? Would you like to deploy now? No
Your app is ready! Deploy with flyctl deploy</code></pre><p>Make sure to say yes to copying the existing configuration, because I’ve made it easy for you. It’s just a standard configuration, but makes sure to mount the persistent volume we’ll create in a minute and sets the <code>DATABASE_URL</code> environment variable to use it.</p><p>Pick any region close to you. Just make sure to remember your choice, because you want the volume to be in the same region.</p><p>Answer no to setting up a Postgres database (haha), and also no to deploying. We need the volume first, so set it up with <code>fly vol create</code>:</p><pre><code>$ fly vol create data -s 1
? Select region: Frankfurt, Germany (fra)
        ID: vol_gez1nvxypen4mxl7
      Name: data
       App: my-sqlite-app
    Region: fra
      Zone: d7f9
   Size GB: 1
 Encrypted: true
Created at: 04 Nov 22 10:09 UTC</code></pre><p>Now, run <code>fly deploy</code>, and the Fly builder will build your Docker image, deploy it to your selected region, and start it up!</p><p>There’s only one more thing to do: run the migrations. Do that with a POST request to the <code>/migrate/up</code> path using your favourite tool. Mine’s <a href="https://httpie.io">HTTPie</a>:</p><pre><code>$ http post https://my-sqlite-app.fly.dev/migrate/up
HTTP/1.1 200 OK
content-length: 0
date: Fri, 04 Nov 2022 10:18:37 GMT
fly-request-id: 01GH12CM0MR0Z50E8GDNY916Y7-fra
server: Fly/c86be2f07 (2022-11-03)
via: 1.1 fly.io</code></pre><p>And voila, your web app powered by SQLite is now in the cloud! Congratulations. Have a celebratory coffee and cookie. You deserve it. 😄</p><p>Are there any downsides to this approach? Yes. Every time you deploy, fly.io has to take your app offline for a few seconds, because two containers can’t have the same persistent volume attached at once. For many web apps, it’s perfectly fine to be offline for a few seconds once in a while. But if not, look out for the distributed SQLite things happening in the space. 😎</p><h2>Resources</h2><p>This article wouldn’t have been possible without these excellent resources (in no particular order):</p><ul><li><a href="https://fly.io/blog/all-in-on-sqlite-litestream/">&#34;I’m All-In on Server-Side SQLite&#34; by Ben Johnson</a></li><li><a href="https://www.youtube.com/watch?v=XcAYkriuQ1o">&#34;Building Production Applications Using Go &amp; SQLite&#34; from GopherCon 2021, also by Ben Johnson</a></li><li><a href="https://www.sqlite.org/index.html">The official SQLite documentation</a></li><li><a href="https://crawshaw.io/blog/one-process-programming-notes">&#34;One process programming notes (with Go and SQLite)&#34; by David Crawshaw</a></li></ul><div><h2>About</h2><p>I’m Markus 🤓✨. I’m passionate about simple &amp; boring but useful software. So we can build the things that actually matter.</p><p>Want to learn Go web and cloud development? <a href="https://www.golang.dk/">I’ve got online Go courses</a>! 😎</p><p>Need someone to do it for you? <a href="https://www.maragu.dk">I do software consulting</a>.</p><p>Enjoyed this? Want my newsletter? No spam. Instant unsubscribe any time.</p><p><img src="https://www.golang.dk/images/markus.jpg" alt="Picture of Markus, the author."/></p></div></div></div></div>
  </body>
</html>
