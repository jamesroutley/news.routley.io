<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.juliensobczak.com/inspect/2022/05/30/anki-srs.html">Original</a>
    <h1>Anki SRS Algorithm : Spaced repetition explained with code</h1>
    
    <div id="readability-page-1" class="page">
  <!-- Custom loader -->



  <!-- Navigation -->

  <nav id="mainNav">

    
    
    
    
    

    
  </nav>


  <header>
  <!-- see https://www.elastic.co/blog/elasticsearch-5-0-0-released -->
  
  
</header>

<section>

  <div>

    <article>

      <div>
      <div>
<blockquote>
<p>Humans more easily remember or learn items when they are studied a few times over a long period of time (spaced presentation), rather than studied repeatedly in a short period of time.</p>
</blockquote>

</div>
<p>Forgetting is key to learning. Forgetting is what separates what is useful and what is not. Sometimes, we want to make a piece of knowledge stick in memory despite what our memory thinks. Spaced Repetition is an effective solution to this problem and Anki is the most popular OSS tool to help you.</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Tip"></i>
</td>
<td>
<p>What You Will Learn</p>
<div>
<ul>
<li>
<p>What is the history of SRS algorithms.</p>
</li>
<li>
<p>How Anki SRS algorithm is implemented.</p>
</li>
<li>
<p>How Anki SRS algorithm differs from other known implementations.</p>
</li>
<li>
<p>How Anki SRS algorithm can be improved.</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div>
<table>
<tbody><tr>
<td>
<i title="Caution"></i>
</td>
<td>
The Anki source code is published under <a href="https://www.gnu.org/licenses/agpl-3.0.en.html">AGPL v3</a>. The code presented in this article has been slightly adapted for learning and readability purposes.
</td>
</tr>
</tbody></table>
</div>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
<p>Prerequisites</p>
<p>I assume that you have used Anki before. All code examples use the Python language, mainly because Anki was implemented only in Python until recently, and also because it’s a great language for novice programmers. You don’t need to have a solid understanding of the language to follow the article as the code uses basic Python syntax.</p>
</td>
</tr>
</tbody></table>
</div>
<div>
<h2 id="srs_primer">SRS Primer</h2>
<div>
<p>The role of any Spaced Repetition System (SRS) algorithm is to determine what the user should review now, or say differently when must happen the next review for every remembered item. <strong>The goal of any implementation is to counteract the effect of the forgetting curve</strong>:</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/forgetting-curve.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/forgetting-curve.png" alt="forgetting curve" width="750"/></a>
</p>
</div>
<p>As soon as we learn or review a piece of knowledge, the decay begins. SRS algorithms need to determine the optimal interval between two reviews to ensure we haven’t completely forgotten it (memory retention = 0%) while trying to limit as much as possible the number of reviews. In practice, most algorithms use 10% for the forgetting index (= 90% of items are remembered correctly) so that we don’t have too many items to review again while keeping the number of reviews close to optimal.</p>
<p>The details of the different algorithms differ greatly between systems. We will start by reviewing the most popular ones in history before introducing Anki’s solution.</p>
<div>
<h3 id="the_leitner_system_1970">The Leitner System (1970-)</h3>
<p>If <a href="https://en.wikipedia.org/wiki/Hermann_Ebbinghaus">Hermann Ebbinghaus</a> is credited for the initial research behind SRS, the <a href="https://en.wikipedia.org/wiki/Leitner_system">Leiter System</a> is often quoted as the first algorithm. This system uses a physical box as depicted by the following illustration:</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/Leitner-original.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/Leitner-original.png" alt="Leitner original" width="500"/></a>
</p>
</div>
<p>Here is a small Python program implementing the logic behind the original Leitner system:</p>
<div>
<div>
<pre><code data-lang="python"><span>from</span> <span>queue</span> <span>import</span> <span>Queue</span>
<span>import</span> <span>random</span>

CARDS_PER_CM = <span>5</span>

BOX = [
    Queue(<span>1</span>  * CARDS_PER_CM),
    Queue(<span>2</span>  * CARDS_PER_CM),
    Queue(<span>5</span>  * CARDS_PER_CM),
    Queue(<span>8</span>  * CARDS_PER_CM),
    Queue(<span>14</span> * CARDS_PER_CM),
]

<span>def</span> <span>add</span>(card, i):
    BOX[i].put(card)
    <span>if</span> BOX[i].full():
        study()

<span>def</span> <span>review</span>(card):
    <span>return</span> random.choice([<span>True</span>, <span>True</span>, <span>True</span>, <span>False</span>])

<span>def</span> <span>study</span>():
    <span>for</span> index, partition <span>in</span> <span>enumerate</span>(BOX):
        <span>if</span> partition.full():
            
            print(f<span><span>&#34;</span><span>Time to study partition {index + 1}!</span><span>&#34;</span></span>)

            cards_to_review = []
            <span>while</span> <span>not</span> partition.empty():
                cards_to_review.append(partition.get())

            <span>for</span> card <span>in</span> cards_to_review:
                answer = review(card)
                new_index = <span>None</span>
                <span>if</span> answer <span>and</span> index + <span>1</span> &lt; <span>len</span>(BOX):
                    
                    new_index = index + <span>1</span>
                <span>elif</span> <span>not</span> answer <span>and</span> index - <span>1</span> &gt; <span>0</span>:
                    
                    new_index = <span>0</span>
                <span>else</span>:
                    
                    new_index = index
                add(card, new_index)

<span>if</span> __name__ == <span><span>&#34;</span><span>__main__</span><span>&#34;</span></span>:

    
    <span>for</span> i <span>in</span> <span>range</span>(<span>140</span>):
        add(<span><span>&#34;</span><span>New Card</span><span>&#34;</span></span>, <span>0</span>)

    
    study()</code></pre>
</div>
</div>
<p>The original Leitner system cannot really be considered a spaced repetition system. There is no concept of an (optimum) interval. The system simply prioritizes which items to review based on the available physical space in each partition.</p>
<p>An alternative method using three boxes where incorrect answers are only moved back to the previous box is often privileged:</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/Leitner-modern.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/Leitner-modern.png" alt="Leitner modern" width="700"/></a>
</p>
</div>
<p>Here is a program implementing this new logic:</p>
<div>
<div>
<pre><code data-lang="python"><span>from</span> <span>queue</span> <span>import</span> <span>Queue</span>
<span>import</span> <span>random</span>
<span>from</span> <span>datetime</span> <span>import</span> <span>datetime</span>, <span>timedelta</span>

A = <span>0</span>
B = <span>1</span>
C = <span>2</span>
SYSTEM = [
    Queue(), 
    Queue(), 
    Queue(), 
]


<span>def</span> <span>add</span>(card, i):
    <span><span>&#34;&#34;&#34;</span><span>Add a new card in the Leitner system.</span><span>&#34;&#34;&#34;</span></span>
    SYSTEM[i].put(card)

<span>def</span> <span>review</span>(card):
    <span><span>&#34;&#34;&#34;</span><span>Answer a single card.</span><span>&#34;&#34;&#34;</span></span>
    <span>return</span> random.choice([<span>True</span>, <span>True</span>, <span>True</span>, <span>False</span>])

<span>def</span> <span>study_box</span>(number):
    <span><span>&#34;&#34;&#34;</span><span>Review all cards in a box.</span><span>&#34;&#34;&#34;</span></span>
    cards_to_review = []
    <span>while</span> <span>not</span> SYSTEM[number].empty():
        cards_to_review.append(SYSTEM[number].get())

    <span>for</span> card <span>in</span> cards_to_review:
        answer = review(card)
        new_number = <span>None</span>
        <span>if</span> answer <span>and</span> number &lt; C:
            
            new_number = number + <span>1</span>
        <span>elif</span> <span>not</span> answer <span>and</span> number &gt; A:
            
            new_number = number - <span>1</span>
        <span>else</span>:
            
            new_number = number
        add(card, new_number)

<span>def</span> <span>study</span>(day):
    <span><span>&#34;&#34;&#34;</span><span>Study the box according the week day.</span><span>&#34;&#34;&#34;</span></span>
    weekday = day.weekday()
    <span>if</span> weekday == <span>0</span>: 
        study_box(A)
    <span>elif</span> weekday == <span>1</span>: 
        study_box(A)
        study_box(B)
    <span>elif</span> weekday == <span>2</span>: 
        study_box(A)
    <span>elif</span> weekday == <span>3</span>: 
        study_box(A)
    <span>elif</span> weekday == <span>4</span>: 
        study_box(A)
        study_box(B)
    <span>elif</span> weekday == <span>5</span>: 
        study_box(A)
    <span>elif</span> weekday == <span>6</span>: 
        study_box(A)
        study_box(C)

<span>if</span> __name__ == <span><span>&#34;</span><span>__main__</span><span>&#34;</span></span>:

    
    <span>for</span> i <span>in</span> <span>range</span>(<span>140</span>):
        add(<span><span>&#34;</span><span>New Card</span><span>&#34;</span></span>, <span>0</span>)

    
    <span>for</span> i <span>in</span> <span>range</span>(<span>10</span>):
        day = datetime.today() - timedelta(days=<span>10</span> - i)
        study(day)</code></pre>
</div>
</div>
<p>The modern Leitner system assigns intervals to the different boxes. Variants exist with more boxes but for this system to be considered a spaced repetition system, we would need a lot more boxes to have longer and longer intervals between reviews.</p>
</div>
<div>
<h3 id="sm_0_1985">SM-0 (1985)</h3>
<p>Algorithms are precise instructions to carry out. As we have seen with the Leitner system, algorithms don’t have to be executed on computers at all. We can manually perform what a computer does, except we will need a lot more time. The first version of the SuperMemo Algorithm was also thought to be executed manually.</p>

<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/sm-0.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/sm-0.png" alt="sm 0" width="800"/></a>
</p>
</div>
<p>Although the algorithm was designed to be executed manually, we can still capture the logic using code:</p>
<div>
<div>
<pre><code data-lang="python"><span>import</span> <span>random</span>
<span>from</span> <span>datetime</span> <span>import</span> <span>date</span>, <span>timedelta</span>
<span>from</span> <span>queue</span> <span>import</span> <span>Queue</span>





TABLE_REPETITION_INTERVALS = [<span>4</span>] 
<span>for</span> i <span>in</span> <span>range</span>(<span>1</span>, <span>15</span>): 
    prev = TABLE_REPETITION_INTERVALS[i - <span>1</span>]
    next = <span>int</span>(prev * <span>1.7</span>)
    TABLE_REPETITION_INTERVALS.append(<span>next</span>)


DATABOOK = []



SCHEDULE_BOOK = {} 


<span>def</span> <span>review_question</span>(question, repetitions):
    <span><span>&#34;&#34;&#34;</span><span>
</span><span>    Randomly answer a question.</span><span>
</span><span>    The chance of answering correctly increases with the number of repetitions.</span><span>
</span><span>    </span><span>&#34;&#34;&#34;</span></span>
    <span>return</span> random.choice([<span>True</span>] * repetitions * <span>4</span> + [<span>False</span>])


<span>class</span> <span>Page</span>:

    <span>def</span> <span>__init__</span>(<span>self</span>, questions, answers):
        
        <span>self</span>.questions = questions
        
        <span>self</span>.answers = answers
        
        
        
        <span>self</span>.repetitions = []

    <span>def</span> <span>review</span>(<span>self</span>):
        remaining_questions = Queue(<span>self</span>.questions)

        
        iteration = <span>1</span>
        
        U = <span>0</span>
        <span>while</span> <span>not</span> remaining_questions.empty():

            questions_to_review = []
            <span>while</span> <span>not</span> remaining_questions.empty():
                questions_to_review.append(remaining_questions.get())

            <span>for</span> question <span>in</span> questions_to_review:
                <span>if</span> <span>not</span> review_question(question, iteration): <i data-value="1"></i><b>(1)</b>
                    
                    remaining_questions.append(question)
                    <span>if</span> iteration == <span>1</span>:
                        U += <span>1</span>
            iteration += <span>1</span>

        <span>self</span>.repetitions.append({
            <span><span>&#34;</span><span>No</span><span>&#34;</span></span>: <span>len</span>(<span>self</span>.repetitions) + <span>1</span>,
            <span><span>&#34;</span><span>Dat</span><span>&#34;</span></span>: <span>str</span>(date.today()),
            <span><span>&#34;</span><span>U</span><span>&#34;</span></span>: U,
        })


<span>if</span> __name__ == <span><span>&#34;</span><span>__main__</span><span>&#34;</span></span>:
    
    DATABOOK.append(Page(
        questions=[<span><span>&#34;</span><span>Question 1</span><span>&#34;</span></span>, <span><span>&#34;</span><span>Question 2</span><span>&#34;</span></span>, <span><span>&#34;</span><span>Question 3</span><span>&#34;</span></span>],
        answers=[<span><span>&#34;</span><span>Answer 1</span><span>&#34;</span></span>, <span><span>&#34;</span><span>Answer 2</span><span>&#34;</span></span>, <span><span>&#34;</span><span>Answer 3</span><span>&#34;</span></span>],
    ))
    page_number = <span>len</span>(DATABOOK) - <span>1</span>

    
    now = date.today()
    <span>for</span> interval <span>in</span> TABLE_REPETITION_INTERVALS:
        review_date = <span>str</span>(now + timedelta(days=interval))
        <span>if</span> review_date <span>not</span> <span>in</span> SCHEDULE_BOOK:
            SCHEDULE_BOOK[review_date] = []
        print(f<span><span>&#34;</span><span>Page {page_number} to review on {review_date}</span><span>&#34;</span></span>)
        SCHEDULE_BOOK[review_date] = [page_number]

    
    <span>for</span> i <span>in</span> <span>range</span>(<span>365</span>):
        day = <span>str</span>(now + timedelta(days=i))
        <span>if</span> <span>not</span> day <span>in</span> SCHEDULE_BOOK:
            
            <span>continue</span>
        
        <span>for</span> page <span>in</span> SCHEDULE_BOOK[day]:
            print(f<span><span>&#34;</span><span>Reviewing page {page} on {day}</span><span>&#34;</span></span>)
            DATABOOK[page].review()</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The grade of the answer does not influence the next interval. Difficult items are reviewed again the same day but the next intervals are fixed and determined with a factor 1.7 when creating the page.</td>
</tr>
</tbody></table>
</div>
<p>The SM-0 algorithm can be challenging in practice for different reasons:</p>
<div>
<ul>
<li>
<p><strong>All items on a given page are reviewed at the same time</strong>. For hard-to-remember items (items that require more than 3 reviews on a given day to be recalled), SM-0 recommends duplicating them on a new page in your book. These items will be reviewed more frequently, and some will maybe be duplicated again if still too hard to remember.</p>
</li>
<li>
<p><strong>The intervals are determined using an estimation of the average case</strong> (x1.7) but the ideal intervals depend on the complexity and your familiarity with the subject. You probably need shorter intervals for science subjects like Mathematics for example.</p>
</li>
<li>
<p>Last but not least, executing the algorithm manually works, but is far from being a smooth learning experience…​</p>
</li>
</ul>
</div>
<p>Enter the computer.</p>
</div>
<div>
<h3 id="sm_2_1987">SM-2 (1987)</h3>
<p>Unlike physical systems where cards are grouped in the same box/partition/page and are reviewed collectively, digital systems consider each item separately. For example, the SuperMemo algorithm called <a href="https://www.supermemo.com/en/archives1990-2015/english/ol/sm2">SM-2</a> assigns a specific level of difficulty to every card and determines the appropriate intervals between repetitions using this specific value (called the E-Factor).</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/sm-2.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/sm-2.png" alt="sm 2" width="800"/></a>
</p>
</div>
<p>Now, the same logic but implemented as code:</p>
<div>
<div>
<pre><code data-lang="python"><span>import</span> <span>random</span>
<span>from</span> <span>datetime</span> <span>import</span> <span>date</span>, <span>timedelta</span>
<span>from</span> <span>queue</span> <span>import</span> <span>Queue</span>

<span>def</span> <span>grade</span>(question, repetitions):
    
    choices = [<span>0</span>] * <span>1</span> * repetitions + [<span>1</span>] * <span>2</span> * repetitions + \
              [<span>2</span>] * <span>3</span> * repetitions + [<span>3</span>] * <span>4</span> * repetitions + \
              [<span>4</span>] * <span>5</span> * repetitions + [<span>5</span>] * <span>6</span> * repetitions
    <span>return</span> random.choice(choices)


I1 = <span>1</span>
I2 = <span>6</span>
MIN_EF = <span>1.3</span> <i data-value="1"></i><b>(1)</b>

<span>class</span> <span>Item</span>:

    <span>def</span> <span>__init__</span>(<span>self</span>, question, answer):
        <span>self</span>.question = question
        <span>self</span>.answer = answer
        <span>self</span>.EF = <span>2.5</span> <i data-value="2"></i><b>(2)</b>
        <span>self</span>.I = I1
        <span>self</span>.next_review = date.today() + timedelta(days=<span>self</span>.I)
        <span>self</span>.repetitions = <span>0</span>

    <span>def</span> <span>review</span>(<span>self</span>, day, q):
        <span>self</span>.EF = <span>max</span>(<span>self</span>.EF+(<span>0.1</span>-(<span>5</span>-q)*(<span>0.08</span>+(<span>5</span>-q)*<span>0.02</span>)), MIN_EF) <i data-value="3"></i><b>(3)</b>
        <span>if</span> q &lt; <span>3</span>:
            <span>self</span>.I = I1
        <span>elif</span> <span>self</span>.I == I1:
            <span>self</span>.I = I2
        <span>else</span>:
            <span>self</span>.I = <span>round</span>(<span>self</span>.I * <span>self</span>.EF)
        <span>self</span>.next_review = day + timedelta(days=<span>self</span>.I)
        <span>self</span>.repetitions += <span>1</span>
        <span>return</span> q &lt; <span>4</span>

<span>if</span> __name__ == <span><span>&#34;</span><span>__main__</span><span>&#34;</span></span>:
    
    items = []
    <span>for</span> i <span>in</span> <span>range</span>(<span>1</span>, <span>100</span>):
        items.append(Item(f<span><span>&#34;</span><span>Q{i}</span><span>&#34;</span></span>, f<span><span>&#34;</span><span>A{i}</span><span>&#34;</span></span>))

    
    
    <span>for</span> i <span>in</span> <span>range</span>(<span>365</span>):
        day = date.today() + timedelta(days=i)

        items_to_review = Queue()
        <span>for</span> item <span>in</span> items:
            <span>if</span> item.next_review == day:
                items_to_review.put(item)

        <span>while</span> <span>not</span> items_to_review.empty():
            item = items_to_review.get()
            q = grade(item.question, item.repetitions + <span>1</span>)
            <span>if</span> <span>not</span> item.review(day, q): <i data-value="4"></i><b>(4)</b>
                items_to_review.put(item)</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The E-Factor never goes down lower than 1.3. SuperMemo found out that items having lower E-Factors were repeated annoyingly often when the root cause was usually their formulation and not the review process. We will see how Anki manages such cards later. These items must often be reformulated to conform to the <a href="https://supermemo.guru/wiki/Minimum_information_principle">minimum information principle</a>.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The E-Factor is always initialized to the same difficulty value. It will decrease for bad grades and increase for good grades.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>Unlike SM-0, the grades (= item difficulty) influence the factor used to determine the next interval.</td>
</tr>
<tr>
<td><i data-value="4"></i><b>4</b></td>
<td>Like SM-0, difficult items are reviewed again the same day.</td>
</tr>
</tbody></table>
</div>
<p>The SM-2 algorithm, while relatively basic, remains popular even today as you will discover in the rest of this article.</p>
</div>
</div>
</div>
<div>
<h2 id="anki_algorithm">Anki Algorithm</h2>
<div>

<div>
<blockquote>
<p>&#34;The SM-2 algorithm, created for SuperMemo in the late 1980s, forms the basis of the spaced repetition methods employed in the program. Anki’s implementation of the algorithm has been modified to allow priorities on cards and to show flashcards in order of their urgency.</p>
</blockquote>
<p>
— Wikipedia
</p>
</div>
<p>Anki source code includes different versions of its SRS algorithm (called <em>Scheduler</em>). All got inspiration from SM-2. The <a href="https://faqs.ankiweb.net/the-anki-2.1-scheduler.html">V2</a> is in use since 2018 even if the <a href="https://faqs.ankiweb.net/the-2021-scheduler.html">V3</a> is looming. For this article, we can ignore the details between these versions. Check the source code on GitHub if you are interested in the differences between the <a href="https://github.com/ankitects/anki/blob/2.1.49/pylib/anki/scheduler/v1.py">V1</a>, <a href="https://github.com/ankitects/anki/blob/2.1.49/pylib/anki/scheduler/v2.py">V2</a>, or <a href="https://github.com/ankitects/anki/blob/2.1.49/pylib/anki/scheduler/v3">V3</a>.</p>
<p>We will analyze the V2.1 scheduler as it is the version I’m familiar with. We will use the <a href="https://github.com/ankitects/anki/blob/2.1.10/anki/schedv2.py">version 2.10.0</a> of Anki Desktop to ignore recent refactorings (the rewrite of backend code in Rust, the introduction of Protocol Buffer messages, the factorization of common code among scheduler versions using inheritance, etc.). This will help us keep the code easy to grasp.</p>

<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/anki-terminology.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/anki-terminology.png" alt="anki terminology" width="750"/></a>
</p>
</div>
<p>As outlined by the schema, we will focus on the core abstractions (Collection, Note, Card) that affects how the SRS algorithm works. In addition, cards in Anki are scheduled differently according to their state:</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/anki-workflow.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/anki-workflow.png" alt="anki workflow" width="700"/></a>
</p>
</div>
<p>Here is an overview of the Anki algorithm:</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/anki-srs.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/anki-srs.png" alt="anki srs" width="750"/></a>
</p>
</div>
<p>The use of separate new/review queues tries to remediate a common complaint with the standard SM-2 algorithm is that repeated failings of a card cause the card to get stuck in &#34;low interval hell&#34; (also known as &#34;ease hell&#34;). <a href="https://faqs.ankiweb.net/what-spaced-repetition-algorithm.html#review-cards">In Anki</a>, the initial acquisition process does not influence the ease factor.</p>
<div>
<h3 id="part_1_settings">Part 1: Settings</h3>
<p>Unlike previous systems, Anki is highly configurable. Not all settings affect the SRS algorithm. Here are the default setting values used by Anki that will be used:</p>
<div>
<div>
<pre><code data-lang="python">
NEW_CARDS_DISTRIBUTE = <span>0</span>
NEW_CARDS_LAST = <span>1</span>
NEW_CARDS_FIRST = <span>2</span>


STARTING_FACTOR = <span>2500</span>


colConf = {
    <span><span>&#39;</span><span>newSpread</span><span>&#39;</span></span>: NEW_CARDS_DISTRIBUTE,
    <span><span>&#39;</span><span>collapseTime</span><span>&#39;</span></span>: <span>1200</span>, <i data-value="1"></i><b>(1)</b>
}


deckConf = {
    <span><span>&#39;</span><span>new</span><span>&#39;</span></span>: { <i data-value="2"></i><b>(2)</b>
        <span><span>&#39;</span><span>delays</span><span>&#39;</span></span>: [<span>1</span>, <span>10</span>],
        <span><span>&#39;</span><span>ints</span><span>&#39;</span></span>: [<span>1</span>, <span>4</span>],
        <span><span>&#39;</span><span>initialFactor</span><span>&#39;</span></span>: STARTING_FACTOR,
        <span><span>&#39;</span><span>perDay</span><span>&#39;</span></span>: <span>20</span>,
    },
    <span><span>&#39;</span><span>rev</span><span>&#39;</span></span>: { <i data-value="2"></i><b>(2)</b>
        <span><span>&#39;</span><span>perDay</span><span>&#39;</span></span>: <span>200</span>,
        <span><span>&#39;</span><span>ease4</span><span>&#39;</span></span>: <span>1.3</span>,
        <span><span>&#39;</span><span>maxIvl</span><span>&#39;</span></span>: <span>36500</span>,
        <span><span>&#39;</span><span>hardFactor</span><span>&#39;</span></span>: <span>1.2</span>,
    },
    <span><span>&#39;</span><span>lapse</span><span>&#39;</span></span>: { <i data-value="3"></i><b>(3)</b>
        <span><span>&#39;</span><span>delays</span><span>&#39;</span></span>: [<span>10</span>],
        <span><span>&#39;</span><span>mult</span><span>&#39;</span></span>: <span>0</span>,
        <span><span>&#39;</span><span>minInt</span><span>&#39;</span></span>: <span>1</span>,
        <span><span>&#39;</span><span>leechFails</span><span>&#39;</span></span>: <span>8</span>,
    },
}</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>If there is no more card to review now but the next card in learning is in less than <code>collapseTime</code> seconds, show it now.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The settings differ based on the queue where a card belongs. For example, when learning (<code>new</code>) cards, the delay is increased by graduating steps whereas the delay is multiplied by a given factor for review (<code>rev</code>) cards. The meaning of individual settings will become clearer when we will detail the logic.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>When you forget a review card, it is said to have &#34;lapsed&#34;, and the card must be relearnt. The default behavior for lapsed reviews is to reset the interval (<code>minInt</code>) to 1 (i.e. make it due tomorrow) and put it in the learning queue for a refresher (<code>delays</code>) in 10 minutes.</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h3 id="part_2_model">Part 2: Model</h3>
<p>Let’s begin with the model. Anki stores cards in an SQLite database. In this tutorial, we will mimic the same model but we will store the cards directly in memory inside the collection object. We will also ignore decks completely as they mostly allow reviewing different cards using different settings or at different times but don’t profoundly change how Anki works.</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Collection</span>:

    <span>def</span> <span>__init__</span>(<span>self</span>, id=<span>None</span>):
        d = datetime.datetime.today()
        d = datetime.datetime(d.year, d.month, d.day)
        
        <span>self</span>.crt = <span>int</span>(time.mktime(d.timetuple()))
        
        <span>self</span>.cards = []
        <span>self</span>.sched = Scheduler(<span>self</span>) <i data-value="1"></i><b>(1)</b>

    <span>def</span> <span>addNote</span>(<span>self</span>, note):
        <span>self</span>.cards.append(Card(note))

<span>class</span> <span>Note</span>:

    <span>def</span> <span>__init__</span>(<span>self</span>):
        <span>self</span>.id = intId() <i data-value="2"></i><b>(2)</b>
        <span>self</span>.tags = []

    <span>def</span> <span>addTag</span>(<span>self</span>, tag):
        <span>if</span> <span>not</span> tag <span>in</span> <span>self</span>.tags:
            <span>self</span>.tags.append(tag)

<span>class</span> <span>Card</span>:

    <span>def</span> <span>__init__</span>(<span>self</span>, note, id=<span>None</span>):
        <span>self</span>.id = intId() <i data-value="2"></i><b>(2)</b>
        <span>self</span>.note = note
        
        <span>self</span>.crt = intTime()
        
        <span>self</span>.type = <span>0</span>
        
        
        
        
        
        <span>self</span>.queue = <span>0</span>
        
        <span>self</span>.ivl = <span>0</span>
        
        
        
        <span>self</span>.factor = <span>0</span>
        
        <span>self</span>.reps = <span>0</span>
        
        
        <span>self</span>.lapses = <span>0</span>
        
        
        
        
        <span>self</span>.left = <span>0</span>
        
        
        
        
        <span>self</span>.due = <span>self</span>.id</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The <code>Scheduler</code> implementation will be the main topic of the remaining of this section.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The identifiers are initialized using a helper function <code>intId()</code> which uses the current time and ensures two successive calls return different values. Here is the definition:</td>
</tr>
</tbody></table>
</div>
<div>
<div>
<pre><code data-lang="python"><span>import</span> <span>time</span>

<span>def</span> <span>intId</span>():
    <span><span>&#34;&#34;&#34;</span><span>Returns a unique integer identifier.</span><span>&#34;&#34;&#34;</span></span>
    t = intTime(<span>1000</span>)
    
    <span>while</span> intTime(<span>1000</span>) == t:
        time.sleep(<span>1</span>)
    <span>return</span> t

<span>def</span> <span>intTime</span>(scale=<span>1</span>):
    <span><span>&#34;</span><span>The time in integer seconds. Pass scale=1000 to get milliseconds.</span><span>&#34;</span></span>
    <span>return</span> <span>int</span>(time.time()*scale)</code></pre>
</div>
</div>
<p>The <code>Scheduler</code> is the largest class that will be covered. A scheduler in Anki is an object supporting two methods:</p>
<div>
<ul>
<li>
<p><code>getCard()</code>: Returns the next card to review</p>
</li>
<li>
<p><code>answerCard(card, ease)</code>: Updates the card after an answer (<code>ease</code>: <code>0</code> for &#34;Again&#34;, <code>1</code> for &#34;Hard&#34;, <code>2</code> for &#34;Good&#34;, and <code>3</code> for &#34;Easy&#34;)</p>
</li>
</ul>
</div>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>__init__</span>(<span>self</span>, col):
        
        <span>self</span>.col = col
        
        <span>self</span>.queueLimit = <span>50</span>
        
        <span>self</span>.reportLimit = <span>1000</span>
        
        <span>self</span>.reps = <span>0</span>
        
        <span>self</span>.today = <span>self</span>._daysSinceCreation() <i data-value="1"></i><b>(1)</b>
        
        <span>self</span>.dayCutoff = <span>self</span>._dayCutoff() <i data-value="2"></i><b>(2)</b>
        
        <span>self</span>._lrnCutoff = <span>0</span> <i data-value="3"></i><b>(3)</b>
        <span>self</span>.reset()</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The attribute <code>today</code> represents the number of days since the collection creation. It is used when searching for review cards where the attribute <code>due</code> represents the number of days relative to it. The value is initialized like this:
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_daysSinceCreation</span>(<span>self</span>):
        startDate = datetime.datetime.fromtimestamp(<span>self</span>.col.crt)
        <span>return</span> <span>int</span>((time.time() - time.mktime(startDate.timetuple())) // <span>86400</span>)
        </code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The attribute <code>dayCutoff</code> represents the timestamp of the beginning of the next day. Anki allows customizing at which hour a day ends. Here, we simply use midnight:
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_dayCutoff</span>(<span>self</span>):
        date = datetime.datetime.today()
        date = date.replace(hour=<span>0</span>, minute=<span>0</span>, second=<span>0</span>, microsecond=<span>0</span>)
        <span>if</span> date &lt; datetime.datetime.today():
            date = date + datetime.timedelta(days=<span>1</span>)
        stamp = <span>int</span>(time.mktime(date.timetuple()))
        <span>return</span> stamp</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>The attribute <code>_lrnCutoff</code> is related to the setting <code>collapseTime</code> (also called the learn ahead limit). The method <code>_updateLrnCutoff()</code> is used to initialize it and update it:
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_updateLrnCutoff</span>(<span>self</span>, force):
        nextCutoff = intTime() + <span>self</span>.col.colConf[<span><span>&#39;</span><span>collapseTime</span><span>&#39;</span></span>]
        <span>if</span> nextCutoff - <span>self</span>._lrnCutoff &gt; <span>60</span> <span>or</span> force:
            <span>self</span>._lrnCutoff = nextCutoff
            <span>return</span> <span>True</span>
        <span>return</span> <span>False</span></code></pre>
</div>
</div></td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h3 id="part_3_queues_management">Part 3: Queues Management</h3>
<p>The method <code>reset()</code> present in the last line of the `Scheduler’s constructor initializes the queues managed by Anki:</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>reset</span>(<span>self</span>):
        <span>self</span>._resetLrn()
        <span>self</span>._resetRev()
        <span>self</span>._resetNew()

    
    

    <span>def</span> <span>_resetNew</span>(<span>self</span>):
        <span>self</span>._newQueue = [] <i data-value="1"></i><b>(1)</b>
        <span>self</span>._updateNewCardRatio() <i data-value="2"></i><b>(2)</b>

    <span>def</span> <span>_fillNew</span>(<span>self</span>):
        <span>if</span> <span>self</span>._newQueue:
            <span>return</span> <span>True</span>
        lim = <span>min</span>(<span>self</span>.queueLimit, deckConf[<span><span>&#34;</span><span>new</span><span>&#34;</span></span>][<span><span>&#34;</span><span>perDay</span><span>&#34;</span></span>])
        <span>self</span>._newQueue = <span>list</span>(<span>filter</span>(<span>lambda</span> card: card.queue == <span>0</span>,
            <span>self</span>.col.cards)) <i data-value="3"></i><b>(3)</b>
        <span>self</span>._newQueue.sort(key=<span>lambda</span> card: card.due)
        <span>self</span>._newQueue = <span>self</span>._newQueue[:lim]
        <span>if</span> <span>self</span>._newQueue:
            <span>return</span> <span>True</span>

    <span>def</span> <span>_updateNewCardRatio</span>(<span>self</span>):
        <span>if</span> colConf[<span><span>&#39;</span><span>newSpread</span><span>&#39;</span></span>] == NEW_CARDS_DISTRIBUTE:
            <span>if</span> <span>self</span>._newQueue:
                newCount = <span>len</span>(<span>self</span>._newQueue)
                revCount = <span>len</span>(<span>self</span>._revQueue)
                <span>self</span>.newCardModulus = (
                    (newCount + revCount) // newCount)
                
                <span>if</span> revCount:
                    <span>self</span>.newCardModulus = <span>max</span>(<span>2</span>, <span>self</span>.newCardModulus)
                <span>return</span>
        <span>self</span>.newCardModulus = <span>0</span> 


    
    

    <span>def</span> <span>_resetLrn</span>(<span>self</span>):
        <span>self</span>._updateLrnCutoff(force=<span>True</span>)
        <span>self</span>._lrnQueue = [] <i data-value="1"></i><b>(1)</b>

    <span>def</span> <span>_fillLrn</span>(<span>self</span>):
        <span>if</span> <span>self</span>._lrnQueue:
            <span>return</span> <span>True</span>
        cutoff = intTime() + colConf[<span><span>&#39;</span><span>collapseTime</span><span>&#39;</span></span>]
        <span>self</span>._lrnQueue = <span>list</span>(<span>filter</span>(<span>lambda</span> card: card.queue == <span>1</span> <span>and</span>
            card.due &lt; cutoff, <span>self</span>.col.cards)) <i data-value="4"></i><b>(4)</b>
        <span>self</span>._lrnQueue.sort(key=<span>lambda</span> card: card.id)
        <span>self</span>._lrnQueue = <span>self</span>._lrnQueue[:<span>self</span>.reportLimit]
        <span>return</span> <span>self</span>._lrnQueue

    
    

    <span>def</span> <span>_resetRev</span>(<span>self</span>):
        <span>self</span>._revQueue = [] <i data-value="1"></i><b>(1)</b>

    <span>def</span> <span>_fillRev</span>(<span>self</span>):
        <span>if</span> <span>self</span>._revQueue:
            <span>return</span> <span>True</span>
        lim = <span>min</span>(<span>self</span>.queueLimit, <span>self</span>.col.deckConf[<span><span>&#34;</span><span>rev</span><span>&#34;</span></span>][<span><span>&#34;</span><span>perDay</span><span>&#34;</span></span>])
        <span>self</span>._revQueue = <span>list</span>(<span>filter</span>(<span>lambda</span> card: card.queue == <span>2</span> <span>and</span>
            card.due &lt;= <span>self</span>.today, <span>self</span>.col.cards)) <i data-value="5"></i><b>(5)</b>
        <span>self</span>._revQueue.sort(key=<span>lambda</span> card: card.due)
        <span>self</span>._revQueue = <span>self</span>._revQueue[:lim]

        <span>if</span> <span>self</span>._revQueue:
            r = random.Random()
            r.seed(<span>self</span>.today)
            r.shuffle(<span>self</span>._revQueue)
            <span>return</span> <span>True</span></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>By default, the queues are empty. Anki defers their filling until a card is retrieved.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The method <code>_updateNewCardRatio()</code> determines the frequency for new cards (only when new cards are spread among other cards). For example, if there are 50 review cards and 10 new cards, the ratio will be 5 so that a new card is returned after every 5 review cards. The attribute <code>reps</code> present in <code>Scheduler</code> keeps the current number of reviewed cards for the current study session and will be useful when using the ratio <code>_newCardModulus</code> to determine if the next card must be a new card or a review card.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>Anki searches for all cards in the queue <code>0</code> (= <code>new</code>) and sorts them by their due date before returning the first N cards based on the current daily limit.</td>
</tr>
<tr>
<td><i data-value="4"></i><b>4</b></td>
<td>Anki searches for all cards in the queue <code>1</code> (= <code>lrn</code>) that are due and sorts them by timestamp as the id is initialized from the creation timestamp</td>
</tr>
<tr>
<td><i data-value="5"></i><b>5</b></td>
<td>Anki searches for all cards in the queue <code>2</code> (= <code>rev</code>) that are due and sorts them by the due date before returning the first N shuffled cards based on the current daily limit.</td>
</tr>
</tbody></table>
</div>
<p>The logic to initialize the queues is ready but will be executed in the next step when retrieving a card to study.</p>
</div>
<div>
<h3 id="part_4_card_retrieving">Part 4: Card Retrieving</h3>
<p>The main method is the method <code>getCard()</code>.</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>getCard</span>(<span>self</span>):
        card = <span>self</span>._getCard()
        <span>if</span> card:
            <span>self</span>.reps += <span>1</span>
            <span>return</span> card</code></pre>
</div>
</div>
<p>This method delegates to <code>_getCard()</code> and simply increases the counter of studied cards except when the study session is completed.</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_getCard</span>(<span>self</span>): <i data-value="1"></i><b>(1)</b>
        <span><span>&#34;</span><span>Return the next due card or None.</span><span>&#34;</span></span>

        
        c = <span>self</span>._getLrnCard()
        <span>if</span> c:
            <span>return</span> c

        
        <span>if</span> <span>self</span>._timeForNewCard():
            c = <span>self</span>._getNewCard()
            <span>if</span> c:
                <span>return</span> c

        
        c = <span>self</span>._getRevCard()
        <span>if</span> c:
            <span>return</span> c

        
        c = <span>self</span>._getNewCard()
        <span>if</span> c:
            <span>return</span> c

        
        <span>return</span> <span>self</span>._getLrnCard(collapse=<span>True</span>)


    
    

    <span>def</span> <span>_getNewCard</span>(<span>self</span>):
        <span>if</span> <span>self</span>._fillNew(): <i data-value="2"></i><b>(2)</b>
            <span>return</span> <span>self</span>._newQueue.pop()

    <span>def</span> <span>_timeForNewCard</span>(<span>self</span>):
        <span><span>&#34;</span><span>True if it&#39;s time to display a new card when distributing.</span><span>&#34;</span></span>
        <span>if</span> <span>not</span> <span>self</span>._newQueue:
            <span>return</span> <span>False</span>
        <span>if</span> colConf[<span><span>&#39;</span><span>newSpread</span><span>&#39;</span></span>] == NEW_CARDS_LAST:
            <span>return</span> <span>False</span>
        <span>elif</span> colConf[<span><span>&#39;</span><span>newSpread</span><span>&#39;</span></span>] == NEW_CARDS_FIRST:
            <span>return</span> <span>True</span>
        <span>elif</span> <span>self</span>.newCardModulus:
            <span>return</span> <span>self</span>.reps <span>and</span> <span>self</span>.reps % <span>self</span>.newCardModulus == <span>0</span>


    
    

    <span>def</span> <span>_getLrnCard</span>(<span>self</span>, collapse=<span>False</span>):
        <span>if</span> <span>self</span>._fillLrn(): <i data-value="2"></i><b>(2)</b>
            <span>return</span> <span>self</span>._lrnQueue.pop()

    
    

    <span>def</span> <span>_getRevCard</span>(<span>self</span>):
        <span>if</span> <span>self</span>._fillRev(): <i data-value="2"></i><b>(2)</b>
            <span>return</span> <span>self</span>._revQueue.pop()</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>By default, Anki shows cards in a well-defined order:
<div>
<ol>
<li>
<p>New cards when <code>newSpread == NEW_CARDS_FIRST</code></p>
</li>
<li>
<p>Learning cards that are due</p>
</li>
<li>
<p>New cards when <code>newSpread == NEW_CARDS_DISTRIBUTE</code> (default)</p>
</li>
<li>
<p>Review cards</p>
</li>
<li>
<p>New cards when <code>newSpread == NEW_CARDS_LAST</code></p>
</li>
</ol>
</div></td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The methods <code>_fillXXX()</code> return <code>True</code> when a queue is not empty, in which case, we simply have to pop an element from it.</td>
</tr>
</tbody></table>
</div>
<p>The queues are now initialized when retrieving the first card in each of them. This works great for the current session but when a new day begins, Anki must reinitialize the queues because other cards may have reached their due date.</p>
<div>
<div>
<pre><code data-lang="python"><table><tbody><tr>
  <td><pre>1
2
3
<strong>4</strong>
5
6
7
8
<strong>9</strong>
<strong>10</strong>
<strong>11</strong>
<strong>12</strong>
<strong>13</strong>
<strong>14</strong>
15
<strong>16</strong>
<strong>17</strong>
<strong>18</strong>
<strong>19</strong>
20
21
<strong>22</strong>
23
24
25
26
</pre></td>
  <td><pre><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>reset</span>(<span>self</span>):
        <span>self</span>._updateCutoff() <i data-value="1"></i><b>(1)</b>
        <span>self</span>._resetLrn()
        <span>self</span>._resetRev()
        <span>self</span>._resetNew()

    <span>def</span> <span>_updateCutoff</span>(<span>self</span>):
        
        <span>self</span>.today = <span>self</span>._daysSinceCreation()
        
        <span>self</span>.dayCutoff = <span>self</span>._dayCutoff()
        <span>return</span> stamp

    <span>def</span> <span>_checkDay</span>(<span>self</span>):
        
        <span>if</span> time.time() &gt; <span>self</span>.dayCutoff:
            <span>self</span>.reset()

    <span>def</span> <span>getCard</span>(<span>self</span>):
        <span>self</span>._checkDay() <i data-value="2"></i><b>(2)</b>
        card = <span>self</span>._getCard()
        <span>if</span> card:
            <span>self</span>.reps += <span>1</span>
            <span>return</span> card
</pre></td>
</tr></tbody></table></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The method <code>_updateCutoff()</code> is called every time the queues are reset (= once a day). When this happens, it means a new day began and therefore the day limit must be refreshed too.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The method <code>_checkDay()</code> is called every time we retrieve a new card to study. This way, if we have passed the current day, the queue will be reset before returning the next card.</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h3 id="part_5_card_updating">Part 5: Card Updating</h3>
<p>Now that we have a method to empty the list of cards to study, we will turn our attention to the core part of the SRS algorithm. Every time we study a card, the card must be rescheduled. In short, we need to update the attribute <code>due</code> (= the next review date) of the card but the logic varies according to its current state (ex: the current queue, ease factor, and interval).</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>answerCard</span>(<span>self</span>, card, ease):
        <span>assert</span> <span>1</span> &lt;= ease &lt;= <span>4</span>
        <span>assert</span> <span>0</span> &lt;= card.queue &lt;= <span>4</span>

        card.reps += <span>1</span>

        <span>if</span> card.queue == <span>0</span>:
            <span>self</span>._answerNewCard(card, ease)
        <span>elif</span> card.queue <span>in</span> [<span>1</span>, <span>3</span>]:
            <span>self</span>._answerLrnCard(card, ease)
        <span>elif</span> card.queue == <span>2</span>:
            <span>self</span>._answerRevCard(card, ease)
        <span>else</span>:
            <span>assert</span> <span>0</span></code></pre>
</div>
</div>
<p>We will detail each case separately.</p>
</div>
<div>
<h3 id="part_5_1_answering_new_cards">Part 5.1: Answering New Cards</h3>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_answerNewCard</span>(<span>self</span>, card, ease):
        
        card.queue = <span>1</span> <i data-value="1"></i><b>(1)</b>
        card.type = <span>1</span> <i data-value="2"></i><b>(2)</b>
        
        card.left = <span>self</span>._startingLeft(card) <i data-value="3"></i><b>(3)</b>

    <span>def</span> <span>_startingLeft</span>(<span>self</span>, card):
        conf = <span>self</span>._lrnConf(card)
        tot = <span>len</span>(conf[<span><span>&#39;</span><span>delays</span><span>&#39;</span></span>])
        tod = <span>self</span>._leftToday(conf[<span><span>&#39;</span><span>delays</span><span>&#39;</span></span>], tot)
        <span>return</span> tot + tod*<span>1000</span>

    <span>def</span> <span>_leftToday</span>(<span>self</span>, delays, left, now=<span>None</span>):
        <span><span>&#34;</span><span>The number of steps that can be completed by the day cutoff.</span><span>&#34;</span></span>
        <span>if</span> <span>not</span> now:
            now = intTime()
        delays = delays[-left:]
        ok = <span>0</span>
        <span>for</span> i <span>in</span> <span>range</span>(<span>len</span>(delays)):
            now += delays[i]*<span>60</span>
            <span>if</span> now &gt; <span>self</span>.dayCutoff:
                <span>break</span>
            ok = i
        <span>return</span> ok+<span>1</span></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>Anki simply updates the attribute <code>queue</code> to move a card to a different queue. When the destination queue will be reset (ex: for tomorrow’s session), the card will be automatically inserted into it.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The attribute <code>type</code> is similar to the attribute <code>queue</code> (they share the same values <code>0</code>, <code>1</code>, and <code>2</code>). In practice, the attributes <code>queue</code> and <code>type</code> may differ for example after a lapse. When pressing &#34;Again,&#34; on a review card, the card will be moved back to the learning back (<code>queue = 1</code>) but the type will be unchanged (<code>type = 2</code>) to remember the card was previously a review card. This will be useful when graduating the card back to the review queue after relearning.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>The attribute <code>left</code> is particular. The numeric format keeps two pieces of information: how many times the card will be reviewed today, and how many steps before graduation. The methods <code>_startingLeft</code> and <code>_leftToday</code> implement this logic. You can safely ignore the details.</td>
</tr>
</tbody></table>
</div>
<p>So, when answering a new card, the card is automatically promoted to the learning queue.</p>
</div>
<div>
<h3 id="part_5_2_answering_learning_cards">Part 5.2: Answering Learning Cards</h3>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_answerLrnCard</span>(<span>self</span>, card, ease):
        conf = <span>self</span>._lrnConf(card) <i data-value="1"></i><b>(1)</b>

        
        <span>if</span> ease == <span>4</span>:
            <span>self</span>._rescheduleAsRev(card, conf, <span>True</span>)
        
        <span>elif</span> ease == <span>3</span>:
            
            <span>if</span> (card.left%<span>1000</span>)-<span>1</span> &lt;= <span>0</span>:
                <span>self</span>._rescheduleAsRev(card, conf, <span>False</span>)
            <span>else</span>:
                <span>self</span>._moveToNextStep(card, conf)
        <span>elif</span> ease == <span>2</span>:
            <span>self</span>._repeatStep(card, conf)
        <span>else</span>:
            
            <span>self</span>._moveToFirstStep(card, conf)

    <span>def</span> <span>_lrnConf</span>(<span>self</span>, card):
        <span>if</span> card.type == <span>2</span>:
            <span>return</span> <span>self</span>.col.deckConf[<span><span>&#34;</span><span>lapse</span><span>&#34;</span></span>]
        <span>else</span>:
            <span>return</span> <span>self</span>.col.deckConf[<span><span>&#34;</span><span>new</span><span>&#34;</span></span>]</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The settings differ according to if the card comes from the review or new queue. For example, the steps are different after a lapse than when learning a new card for the first time.</td>
</tr>
</tbody></table>
</div>
<p>We will detail what happens depending on which button was pressed when answering the card.</p>
<div>
<h4 id="after_pressing_again">After pressing &#34;Again&#34;…​</h4>
<div>
<div>
<pre><code data-lang="python"><span>self</span>._moveToFirstStep(card, conf)</code></pre>
</div>
</div>
<p>The card is moved back to the first step:</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_moveToFirstStep</span>(<span>self</span>, card, conf):
        card.left = <span>self</span>._startingLeft(card) <i data-value="1"></i><b>(1)</b>

        
        <span>if</span> card.type == <span>3</span>:
            <span>self</span>._updateRevIvlOnFail(card, conf) <i data-value="2"></i><b>(2)</b>

        <span>return</span> <span>self</span>._rescheduleLrnCard(card, conf) <i data-value="3"></i><b>(3)</b>

    <span>def</span> <span>_updateRevIvlOnFail</span>(<span>self</span>, card, conf):
        card.ivl = <span>self</span>._lapseIvl(card, conf)

    <span>def</span> <span>_lapseIvl</span>(<span>self</span>, card, conf):
        ivl = <span>max</span>(<span>1</span>, conf[<span><span>&#39;</span><span>minInt</span><span>&#39;</span></span>], <span>int</span>(card.ivl*conf[<span><span>&#39;</span><span>mult</span><span>&#39;</span></span>]))
        <span>return</span> ivl

    <span>def</span> <span>_rescheduleLrnCard</span>(<span>self</span>, card, conf, delay=<span>None</span>):
        
        <span>if</span> delay <span>is</span> <span>None</span>:
            delay = <span>self</span>._delayForGrade(conf, card.left)

        card.due = <span>int</span>(time.time() + delay)
        card.queue = <span>1</span>
        <span>return</span> delay

    <span>def</span> <span>_delayForGrade</span>(<span>self</span>, conf, left): <i data-value="4"></i><b>(4)</b>
        left = left % <span>1000</span>
        delay = conf[<span><span>&#39;</span><span>delays</span><span>&#39;</span></span>][-left]
        <span>return</span> delay*<span>60</span></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>We restore the attribute <code>left</code> as if the card were new.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>We process lapses differently. By default, we reset the attribute <code>ivl</code> to <code>1</code> (next review in one day).</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>The card due date is determined by adding the next step to the current date. The card remains in the learning queue (<code>1</code>).</td>
</tr>
<tr>
<td><i data-value="4"></i><b>4</b></td>
<td>The method <code>_delayForGrade()</code> is a helper method to get the next step interval. The method extracts the number of remaining steps from the attribute <code>left</code> (Ex: <code>1002</code> ⇒ 2 remaining steps) and uses the setting <code>delay</code> to find the matching delay (Ex: <code>1m 10m 1d</code> ⇒ next study in <code>10m</code>).</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h4 id="after_pressing_hard">After pressing &#34;Hard&#34;…​</h4>
<div>
<div>
<pre><code data-lang="python"><span>self</span>._repeatStep(card, conf)</code></pre>
</div>
</div>
<p>The current card step is repeated. This means the attribute <code>left</code> is unchanged. We still have the same number of remaining steps before graduation. The difference is that the card will be rescheduled in a delay slightly longer than the previous one. We average the last and next delays (Ex: <code>1m 10m 20m</code> and we are at the step 2 ⇒ repeat in <code>15m</code>).</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_repeatStep</span>(<span>self</span>, card, conf):
        delay = <span>self</span>._delayForRepeatingGrade(conf, card.left)
        <span>self</span>._rescheduleLrnCard(card, conf, delay=delay) <i data-value="1"></i><b>(1)</b>

    <span>def</span> <span>_delayForRepeatingGrade</span>(<span>self</span>, conf, left):
        
        delay1 = <span>self</span>._delayForGrade(conf, left)
        delay2 = <span>self</span>._delayForGrade(conf, left-<span>1</span>)
        avg = (delay1+<span>max</span>(delay1, delay2))//<span>2</span>
        <span>return</span> avg</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>We reuse the method <code>_rescheduleLrnCard()</code> introduced just before to update the card’s due date.</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h4 id="after_pressing_good">After pressing &#34;Good&#34;…​</h4>
<div>
<div>
<pre><code data-lang="python">
<span>if</span> (card.left%<span>1000</span>)-<span>1</span> &lt;= <span>0</span>:
    <span>self</span>._rescheduleAsRev(card, conf, <span>False</span>)
<span>else</span>:
    <span>self</span>._moveToNextStep(card, conf)</code></pre>
</div>
</div>
<p>The decision depends on if there are remaining steps or not:</p>
<p><em>Case 1</em>: If we have finished the last step, the card is graduated to the learning queue:</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_rescheduleAsRev</span>(<span>self</span>, card, conf, early):
        lapse = card.type == <span>2</span>

        <span>if</span> lapse:
            <span>self</span>._rescheduleGraduatingLapse(card) <i data-value="1"></i><b>(1)</b>
        <span>else</span>:
            <span>self</span>._rescheduleNew(card, conf, early) <i data-value="2"></i><b>(2)</b>

    <span>def</span> <span>_rescheduleGraduatingLapse</span>(<span>self</span>, card):
        card.due = <span>self</span>.today+card.ivl
        card.type = card.queue = <span>2</span>

    <span>def</span> <span>_rescheduleNew</span>(<span>self</span>, card, conf, early):
        card.ivl = <span>self</span>._graduatingIvl(card, conf, early)
        card.due = <span>self</span>.today+card.ivl
        card.factor = conf[<span><span>&#39;</span><span>initialFactor</span><span>&#39;</span></span>]
        card.type = card.queue = <span>2</span>

    <span>def</span> <span>_graduatingIvl</span>(<span>self</span>, card, conf, early):
        <span>if</span> card.type <span>in</span> (<span>2</span>,<span>3</span>):
            <span>return</span> card.ivl
        <span>if</span> <span>not</span> early: <i data-value="3"></i><b>(3)</b>
            
            ideal =  conf[<span><span>&#39;</span><span>ints</span><span>&#39;</span></span>][<span>0</span>]
        <span>else</span>:
            
            ideal = conf[<span><span>&#39;</span><span>ints</span><span>&#39;</span></span>][<span>1</span>]
        <span>return</span> ideal</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>When a lapse is graduated, we add the previous interval to the current date to determine the due date.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>When a new card is graduated, we initialize the two key attributes relative to the SRS algorithm: the ease factor and the interval. These fields will be necessary to determine the next due date for review cards.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>When graduating a new card, the initial interval will be different if we are completed all steps (&#34;Good&#34;) or if we have pressed (&#34;Easy&#34;) to immediately graduate the card (1 vs 4 days by default).</td>
</tr>
</tbody></table>
</div>
<p><em>Case 2</em>: If there are remaining steps:</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_moveToNextStep</span>(<span>self</span>, card, conf):
        
        left = (card.left % <span>1000</span>) - <span>1</span>
        card.left = <span>self</span>._leftToday(conf[<span><span>&#39;</span><span>delays</span><span>&#39;</span></span>], left)*<span>1000</span> + left <i data-value="1"></i><b>(1)</b>

        <span>self</span>._rescheduleLrnCard(card, conf)</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The attribute <code>left</code> is updated to decrement the number of remaining steps and to recalculate the number of studies until the next day.</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h4 id="after_pressing_easy">After pressing &#34;Easy&#34;…​</h4>
<div>
<div>
<pre><code data-lang="python"><span>self</span>._rescheduleAsRev(card, conf, <span>True</span>)</code></pre>
</div>
</div>
<p>The card is graduated to the review queue similarly to when we complete every step. The only exception is that the initial interval will be larger as explained in the previous point.</p>
</div>
</div>
<div>
<h3 id="part_5_3_answering_review_cards">Part 5.3: Answering Review Cards</h3>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

   <span>def</span> <span>_answerRevCard</span>(<span>self</span>, card, ease):
        <span>if</span> ease == <span>1</span>:
            <span>self</span>._rescheduleLapse(card)
        <span>else</span>:
            <span>self</span>._rescheduleRev(card, ease)</code></pre>
</div>
</div>
<div>
<h4 id="after_pressing_again_2">After pressing &#34;Again&#34;…​</h4>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_rescheduleLapse</span>(<span>self</span>, card):
        conf = <span>self</span>.col.deckConf[<span><span>&#34;</span><span>lapse</span><span>&#34;</span></span>]

        card.lapses += <span>1</span> <i data-value="1"></i><b>(1)</b>
        card.factor = <span>max</span>(<span>1300</span>, card.factor-<span>200</span>) <i data-value="2"></i><b>(2)</b>

        suspended = <span>self</span>._checkLeech(card, conf) <i data-value="3"></i><b>(3)</b>

        <span>if</span> <span>not</span> suspended:
            card.type = <span>2</span>
            delay = <span>self</span>._moveToFirstStep(card, conf) <i data-value="4"></i><b>(4)</b>
        <span>else</span>:
            
            <span>self</span>._updateRevIvlOnFail(card, conf) <i data-value="5"></i><b>(5)</b>
            delay = <span>0</span>

        <span>return</span> delay

    
    

    <span>def</span> <span>_checkLeech</span>(<span>self</span>, card, conf):
        <span>if</span> card.lapses &gt;= conf[<span><span>&#39;</span><span>leechFails</span><span>&#39;</span></span>]:
            
            f = card.note
            f.addTag(<span><span>&#34;</span><span>leech</span><span>&#34;</span></span>)
            
            card.queue = -<span>1</span>
            <span>return</span> <span>True</span></code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The number of lapses for this card is increased.</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The ease factor is reduced by 0.2 (but no lower than 1.3 as recommended by SM-2).</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>If the number of lapses reaches the value of the setting <code>leechFails</code>, the card is marked as a leech. A tag is added to the note and the card is moved to the queue <code>-1</code> (= suspended). The card will therefore be ignored when filling the different queue as no method <code>_fillXXX()</code> considers cards in the queue <code>-1</code>.</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h4 id="after_pressing_hard_good_easy">After pressing &#34;Hard,&#34; &#34;Good,&#34; &#34;Easy&#34;…​</h4>
<p>The card will be rescheduled in an &#34;ideal&#34; number of days. In practice, most cards reside in the learning queue, and the &#34;Again&#34; button is pressed rarely. This means the core logic of the Anki SRS algorithm is determined by the following methods.</p>
<div>
<div>
<pre><code data-lang="python"><span>class</span> <span>Scheduler</span>:

    <span>def</span> <span>_rescheduleRev</span>(<span>self</span>, card, ease):
        
        <span>self</span>._updateRevIvl(card, ease) <i data-value="1"></i><b>(1)</b>

        
        card.factor = <span>max</span>(<span>1300</span>, card.factor+[-<span>150</span>, <span>0</span>, <span>150</span>][ease-<span>2</span>]) <i data-value="2"></i><b>(2)</b>
        card.due = <span>self</span>.today + card.ivl

    <span>def</span> <span>_updateRevIvl</span>(<span>self</span>, card, ease):
        card.ivl = <span>self</span>._nextRevIvl(card, ease)

    
    

    <span>def</span> <span>_nextRevIvl</span>(<span>self</span>, card, ease): <i data-value="3"></i><b>(3)</b>
        <span><span>&#34;</span><span>Next review interval for CARD, given EASE.</span><span>&#34;</span></span>
        delay = <span>self</span>._daysLate(card)
        conf = <span>self</span>.col.deckConf[<span><span>&#34;</span><span>rev</span><span>&#34;</span></span>]
        fct = card.factor / <span>1000</span>
        hardFactor = conf.get(<span><span>&#34;</span><span>hardFactor</span><span>&#34;</span></span>, <span>1.2</span>)
        <span>if</span> hardFactor &gt; <span>1</span>:
            hardMin = card.ivl
        <span>else</span>:
            hardMin = <span>0</span>
        ivl2 = <span>self</span>._constrainedIvl(card.ivl * hardFactor, conf, hardMin)
        <span>if</span> ease == <span>2</span>:
            <span>return</span> ivl2

        ivl3 = <span>self</span>._constrainedIvl((card.ivl + delay // <span>2</span>) * fct, conf, ivl2)
        <span>if</span> ease == <span>3</span>:
            <span>return</span> ivl3

        ivl4 = <span>self</span>._constrainedIvl(
            (card.ivl + delay) * fct * conf[<span><span>&#39;</span><span>ease4</span><span>&#39;</span></span>], conf, ivl3)
        <span>return</span> ivl4

    <span>def</span> <span>_daysLate</span>(<span>self</span>, card):
        <span><span>&#34;</span><span>Number of days later than scheduled.</span><span>&#34;</span></span>
        <span>return</span> <span>max</span>(<span>0</span>, <span>self</span>.today - card.due)

    <span>def</span> <span>_constrainedIvl</span>(<span>self</span>, ivl, conf, prev):
        ivl = <span>max</span>(ivl, prev+<span>1</span>, <span>1</span>)
        ivl = <span>min</span>(ivl, conf[<span><span>&#39;</span><span>maxIvl</span><span>&#39;</span></span>])
        <span>return</span> <span>int</span>(ivl)</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The attribute <code>ivl</code> determines the next due date (we add it to the current date to determine the value of the attribute <code>due</code>).</td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The ease factor is changed by removing 0.15 for &#34;Hard&#34; cards or by adding 0.15 for &#34;Easy&#34; cards. The ease factor is left unchanged for &#34;Good&#34; cards. Only their intervals will be changed to increase the period between studies.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>The method <code>_nextRevIvl()</code> determine the next interval:
<div>
<ul>
<li>
<p>&#34;Hard&#34;: the current interval is multiplied by the value of the hard interval (1.2 by default).</p>
</li>
<li>
<p>&#34;Good&#34;: the current interval is multiplied by the current ease (+ a bonus if the card was late).</p>
</li>
<li>
<p>&#34;Easy&#34;: the current interval is multiplied by the current ease times the easy bonus (1.3 by default) (+ a bonus if the card was late).</p>
</li>
</ul>
</div></td>
</tr>
</tbody></table>
</div>
<p><strong>We are done</strong> 🎉. The complete code is available in the <a href="https://github.com/julien-sobczak/anki-srs-under-the-hood/blob/main/anki/schedv2_minimal_v3.py">companion GitHub repository</a>. A more complete <a href="https://github.com/julien-sobczak/anki-srs-under-the-hood/blob/main/anki/schedv2_annotated.py">annotated version</a> is also available in the same repository including two additional features described next.</p>
</div>
</div>
<div>
<h3 id="bonus_day_boundaries">Bonus: Day Boundaries</h3>
<p><a href="https://docs.ankiweb.net/deck-options.html?#day-boundaries">Anki treats small steps and steps that cross a day boundary differently</a>. With small steps, the cards are shown as soon as the delay has passed, in preference to other due cards in review. This is done so that you can answer the card as closely to the calculated delay as possible. In contrast, if the interval crosses a day boundary, it is automatically converted to days.</p>
<p>In the implementation, the code splits the learning queue into two distinct queues: sub-day learning and day learning.</p>
<div>
<div>
<pre><code data-lang="python">

<span>def</span> <span>_resetLrn</span>(<span>self</span>):
    <span>self</span>._lrnQueue = []
    <span>self</span>._lrnDayQueue = [] <i data-value="1"></i><b>(1)</b>



<span>def</span> <span>_rescheduleLrnCard</span>(<span>self</span>, card, conf, delay=<span>None</span>):
    
    <span>if</span> delay <span>is</span> <span>None</span>:
        delay = <span>self</span>._delayForGrade(conf, card.left)

    card.due = <span>int</span>(time.time() + delay)
    
    <span>if</span> card.due &lt; <span>self</span>.dayCutoff: <i data-value="2"></i><b>(2)</b>
        card.queue = <span>1</span>
    <span>else</span>:
        
        
        ahead = ((card.due - <span>self</span>.dayCutoff) // <span>86400</span>) + <span>1</span>
        card.due = <span>self</span>.today + ahead
        card.queue = <span>3</span>



<span>def</span> <span>_getCard</span>(<span>self</span>):
    
    c = <span>self</span>._getLrnCard() <i data-value="3"></i><b>(3)</b>
    <span>if</span> c:
        <span>return</span> c

    
    <span>if</span> <span>self</span>._timeForNewCard():
        c = <span>self</span>._getNewCard()
        <span>if</span> c:
            <span>return</span> c

    
    c = <span>self</span>._getRevCard()
    <span>if</span> c:
        <span>return</span> c

    
    c = <span>self</span>._getLrnDayCard() <i data-value="3"></i><b>(3)</b>
    <span>if</span> c:
        <span>return</span> c

    
    c = <span>self</span>._getNewCard()
    <span>if</span> c:
        <span>return</span> c

    
    <span>return</span> <span>self</span>._getLrnCard(collapse=<span>True</span>)</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The previous queue is split into two queues:
<div>
<ul>
<li>
<p><code>_lrnQueue</code> (<code>queue == 1</code>) = sub-day learning queue</p>
</li>
<li>
<p><code>_lrnDayQueue</code> (<code>queue == 3</code>) = day learning queue</p>
</li>
</ul>
</div></td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>Learning cards are rescheduled in the sub-day queue <code>1</code> when the next review is planned before the end of the day review session. The due date is the number of seconds until the next review. Otherwise, the card is rescheduled in the day learning queue <code>3</code> and the delay is the number of days until the next review.</td>
</tr>
<tr>
<td><i data-value="3"></i><b>3</b></td>
<td>Sub-day learning cards are prioritized first to be sure to review them as close as their delay in seconds. Day learning cards are reviewed last since their delay in days tolerates more flexibility (reviewing them the next day is not as bad as for sub-day learning cards).</td>
</tr>
</tbody></table>
</div>
</div>
<div>
<h3 id="bonus_fuzzing">Bonus: Fuzzing</h3>
<p>When you select an ease button on a review card, <a href="https://docs.ankiweb.net/studying.html#fuzz-factor">Anki also applies a small amount of random “fuzz”</a> to prevent cards that were introduced at the same time and given the same ratings from sticking together and always coming up for review on the same day.</p>
<p>Here is the code:</p>
<div>
<div>
<pre><code data-lang="python"><span>def</span> <span>_fuzzedIvl</span>(<span>self</span>, ivl): <i data-value="1"></i><b>(1)</b>
    <span>min</span>, max = <span>self</span>._fuzzIvlRange(ivl)
    <span>return</span> random.randint(<span>min</span>, <span>max</span>)

<span>def</span> <span>_fuzzIvlRange</span>(<span>self</span>, ivl):
    <span>if</span> ivl &lt; <span>2</span>:
        <span>return</span> [<span>1</span>, <span>1</span>]
    <span>elif</span> ivl == <span>2</span>:
        <span>return</span> [<span>2</span>, <span>3</span>]
    <span>elif</span> ivl &lt; <span>7</span>: <i data-value="2"></i><b>(2)</b>
        fuzz = <span>int</span>(ivl*<span>0.25</span>)
    <span>elif</span> ivl &lt; <span>30</span>: <i data-value="2"></i><b>(2)</b>
        fuzz = <span>max</span>(<span>2</span>, <span>int</span>(ivl*<span>0.15</span>))
    <span>else</span>: <i data-value="2"></i><b>(2)</b>
        fuzz = <span>max</span>(<span>4</span>, <span>int</span>(ivl*<span>0.05</span>))
    
    fuzz = <span>max</span>(fuzz, <span>1</span>)
    <span>return</span> [ivl-fuzz, ivl+fuzz]</code></pre>
</div>
</div>
<div>
<table>
<tbody><tr>
<td><i data-value="1"></i><b>1</b></td>
<td>The function <code>_fuzzedIvl()</code> is only called for intervals greater than one day. For sub-day learning cards introduced in the previous point, fuzzing is also applied up to 5 minutes:
<div>
<div>
<pre><code data-lang="python">maxExtrax = <span>min</span>(<span>300</span>, <span>int</span>(delay*<span>0.25</span>))
fuzz = random.randrange(<span>0</span>, maxExtra)</code></pre>
</div>
</div></td>
</tr>
<tr>
<td><i data-value="2"></i><b>2</b></td>
<td>The fuzz factor is reduced but the fuzzing increases as intervals become larger.</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div>
<h2 id="a_better_anki_srs_algorithm">A Better Anki SRS Algorithm?</h2>
<div>
<p>The <a href="http://www.supermemo.com/english/ol/sm2.htm">SM-2 algorithm</a>, on which Anki is based, was released in 1987 in SuperMemo 1.0. It was revised several times since:</p>

<p>Each version iterates over deficiencies of the previous one.
You can find a <a href="https://supermemo.guru/wiki/History_of_SuperMemo_algorithm">short summary</a> of the main changes or a (very) <a href="https://www.supermemo.com/fr/articles/history">long summary</a> of the history of SuperMemo. The short version is probably too terse to understand the improvements, and the long version is probably too detailed to understand everything. (It took me more than 5 hours to read it but it was worth the reading!)</p>
<div>
<blockquote>
<p>SuperMemo 2 was great. Its simple algorithm has survived in various mutations to this day in popular apps such as Anki or Mnemosyne. However, the algorithm was dumb in the sense that there was no way of modifying the function of optimum intervals. The findings of 1985 were set in stone. Memory complexity and stability increase were expressed by the same single number: E-factor. It is a bit like using a single lever in a bike to change gears and the direction of driving.</p>
</blockquote>

</div>
<p>From a high-level perspective, the main motivation for every version is to determine better optimal intervals (= the ideal periods between reviews of a single card) so that the forgetting index is close to 10% (= recall of 90% is acceptable).</p>
<p>From a low-level perspective, several approaches were experimented by SuperMemo. The first major version (SM-2) introduced the ease factor to capture the difficulty of an item (the lower the ease factor = the more difficult = the shorter the interval). The ease factor was multiplied by the previous interval to determine the next interval.</p>
<p>The successive iterations become more and more elaborate by adding new dimensions, in particular, what is called by SuperMemo the <a href="https://supermemo.guru/wiki/Two_component_model_of_memory">two-component model</a>: <strong>stability</strong> and <strong>retrievability</strong> (in complement to <strong>difficulty</strong> represented by the E-Factor). Stability tells you how long a piece of knowledge can last in memory. Retrievability tells you how easy it is to recall a piece of knowledge. These notions may appear similar but they aren’t. &#34;If you take two memories right after a review, one with a short optimum interval, and the other with a long optimum interval, the memory status of the two must differ,&#34; declares Piotr Wozniak, &#34;Both can be recalled perfectly (maximum retrievability) and they also need to differ in how long they can last in memory (different stability).&#34;</p>
<p>What follows is an example of the optimum factors (OF) matrix used in SM-4/SM-5. The matrix ignores the retrievability dimension, which was introduced in SM-6.</p>
<div>
<p><a href="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/sm-5-matrix.png"><img src="https://www.juliensobczak.com/posts_resources/2022-05-30-anki-srs/sm-5-matrix.png" alt="sm 5 matrix" width="700"/></a>
</p>
</div>
<p>A two-dimensional matrix is easier to represent but the logic is similar with more dimensions. Initially, the matrix was defined based on prior measurements in SuperMemo. After each answer, the grade tells SuperMemo how well the interval &#34;performed.&#34; If the grade is low, the interval was too long. If the grade is high, the interval was too short. The entry in the matrix is updated in consequence and matrix smoothing is applied (= if a value increases, a smaller increase can be beneficial to neighbors too).</p>
<p>The two-component model of long-term memory still represents the foundation of SuperMemo since its introduction in SM-4 in 1989. <a href="http://super-memory.com/articles/kowal.htm">Piotr Wozniak was pessimistic about a better, faster, and more effective algorithm</a> as soon as 1994. The versions of the algorithm that appeared after that didn’t introduce a breakthrough improvement like SuperMemo did when it abandoned the SM-2 algorithm in 1989, the same algorithm that keeps popping up in new applications.</p>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
<p>&#34;New&#34; Applications</p>
<div>
<p>Many applications relying on SRS appeared in popular app stores more or less recently: <a href="https://quizlet.com/">Quizlet</a>, <a href="https://www.memrise.com/">Memrise</a>, <a href="https://www.duolingo.com/">Duolingo</a>, <a href="https://www.lingodeer.com/">LingoDeer</a>, <a href="https://www.brainscape.com/">Brainscape</a>, <a href="https://lingvist.com/">Lingvist</a>, <a href="https://chegg.com">Chegg</a>, <a href="https://www.remnote.com/">RemNote</a>, <a href="https://mochi.cards/">Mochi</a>, <a href="https://www.memcode.com/">Memcode</a>, …​</p>
</div>
<div>
<ul>
<li>
<p><a href="https://mochi.cards/docs/#spaced-repetition"><em>Mochi</em>&#39;s algorithm</a> is very simple. The card interval is doubled after each correct answer, and cut in half otherwise.</p>
</li>
<li>
<p><a href="https://memrise.zendesk.com/hc/en-us/articles/360015889057-How-does-the-spaced-repetition-system-work-"><em>Memrise</em>&#39;s algorithm</a> is similar to <em>Mochi</em>&#39;s. The card interval increases using the following steps: 4 hours, 12 hours, 24 hours, 6 days, 12 days, 48 days, 96 days, and 6 months. Any wrong answer moves back the card to the first interval.</p>
</li>
<li>
<p><a href="https://quizlet.com/blog/spaced-repetition-for-all-cognitive-science-meets-big-data-in-a-procrastinating-world">Quizlet’s algorithm</a> has known several iterations. The first implementation simply repeats all the questions you got wrong. The second implementation is similar to Anki where the card interval increases by approximately 2.2 and wrong answers reset the interval to one day. The next implementation relies on machine learning and uses the millions of answers to determine the recall probability, which is the chance you answer correctly. This allows, for example, to reduce the interval for words with irregular spellings when learning a foreign language.</p>
</li>
<li>
<p><a href="https://blog.duolingo.com/how-we-learn-how-you-learn/"><em>Duolingo</em>&#39;s algorithm</a> is similar to Quizlet. Duolingo has millions of students who generate billions of statistics about language learning every day. Like Quizlet, Duolingo uses machine learning to predict how likely you are to remember any given word at any time. This is represented by the strength meter (still strong, pretty good, time to practice, overdue) below every lesson.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=IwaoV-C9az8&amp;ab_channel=RemNote">RemNote’s algorithm</a> is customizable like Anki and most settings will look familiar to Anki users, especially after following this tutorial.</p>
</li>
<li>
<p><a href="https://news.ycombinator.com/item?id=23948541">Memcode’s algorithm</a> also uses SM-2.</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<p>In my opinion, <strong>Anki is not perfect but there is no need to focus too much on optimizing it</strong>:</p>
<div>
<ul>
<li>
<p><strong>Adding more dimensions</strong>? What if you review inadvertently a card, for example when explaining the idea to a coworker. No algorithm can exploit this and postpone the next review. <strong>No algorithm will ever be perfect</strong>.</p>
</li>
<li>
<p><strong>Using machine learning</strong>? Applying the lessons from other learners is great for common datasets. For example, if most French users have trouble learning a particular English word, chances are future French users will need shorter intervals too. But what about custom-edited cards about subjects such as science, management, and parenting. What about your interest in any of these subjects. We remember more easily what passionates us. <strong>Machine learning excels when there are patterns but learning is profoundly a personal, unique experience</strong>.</p>
</li>
</ul>
</div>
<p>Therefore, <strong>I think we should focus more on optimizing our practices rather than the tools</strong>. Here are two key practices:</p>
<div>
<ul>
<li>
<p><strong>Devote time to understand</strong>. Learning is a 3-steps process: encoding, storage, and retrieval. Anki helps to store information for a longer period by reviewing it (&#34;use it or lose it&#34;). But Anki is dependent on how good the encoding happened. You cannot learn something you haven’t understood first. Therefore, you must devote (a lot of) time <a href="https://www.juliensobczak.com/write/2018/12/01/10-rules-for-better-flashcards.html">writing your own flashcards</a>. <strong>A poor encoding process will make the best SRS algorithm useless.</strong></p>
</li>
<li>
<p><strong>Devote time to learn</strong>. Trying Anki is easy. Sticking to it is hard. Many users quickly abandon Anki probably because its benefits can only be visible after several years of making it a habit. And everyone knows changing habits is hard, otherwise <em>Atomic Habits</em> would not be the #1 best-selling book on Amazon last year. <strong>A lack of motivation will make the best SRS algorithm useless.</strong></p>
</li>
</ul>
</div>
<p>One last important thing,</p>
<div>
<blockquote>
<p>Learning is one of the most enjoyable things in the world.</p>
</blockquote>
<p>
— Piotr Wozniak
</p>
</div>
<div>
<table>
<tbody><tr>
<td>
<i title="Note"></i>
</td>
<td>
<p>To Remember</p>
<div>
<ul>
<li>
<p><strong>A Spaced Repetition System (SRS) counteracts the effect of the forgetting curve</strong>. Memory decay is inevitable but can be influenced.</p>
</li>
<li>
<p><strong>SRS systems can be implemented with or without a computer</strong>. The Leitner system remains popular.</p>
</li>
<li>
<p><strong>SRS systems often target a retention close to 90%</strong> (= 10% of cards are wrongly answered).</p>
</li>
<li>
<p><strong>SuperMemo</strong> introduced the first <strong>SRS algorithm running on a computer</strong> (SM-2).</p>
</li>
<li>
<p><strong>SM-2 continues to be used by most applications</strong> including Anki, despite having been abandoned in SuperMemo three decades ago.</p>
</li>
<li>
<p><strong>Anki makes the SM-2 highly configurable</strong> and uses different queues to manage cards differently based on if they are new, in learning, or simply in review.</p>
</li>
<li>
<p><strong>Most algorithms use the item difficulty</strong> (known as the ease factor) to determine optimal intervals. SuperMemo goes well beyond and also uses memory stability and memory retrievability.</p>
</li>
<li>
<p><strong>Recent SRS applications rely on machine learning</strong> to exploit the specificities of the learning materials (ex: English words with irregular syntax) and to use the information collected from their massive dataset of users to tune their algorithm. SuperMemo never chose this approach.</p>
</li>
<li>
<p><strong>The perfect SRS algorithm will never exist</strong>. No algorithm can determine if you are passionate about a subject, or if you review by chance the content of a card at work during a discussion with a coworker (in which case an &#34;ideal&#34; algorithm must postpone the next review).</p>
</li>
<li>
<p><strong>Creating great flashcards and making reviewing them a habit have probably a far bigger impact</strong> than any improvement in the SRS algorithm you use.</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div>
<h2 id="additional_links">Additional Links</h2>
<div>
<div>
<ul>
<li>
<p>The <a href="https://faqs.ankiweb.net/what-spaced-repetition-algorithm.html">Anki Website</a> explains succinctly the main differences between its algorithm and SM-2.</p>
</li>
<li>
<p><a href="https://github.com/ankidroid/Anki-Android/wiki/Database-Structure">Anki Database Structure</a>: The most up-to-date guide to the Anki internal database schema, which was more than useful during the writing of this article.</p>
</li>
<li>
<p><a href="https://web.archive.org/web/20200926103540/https://massimmersionapproach.com/table-of-contents/anki/low-key-anki/the-ease-factor-problem/">The Ease Factor Problem</a>: Interesting insight about the impact of changing the ease factor after a lapse.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=1XaJjbCSXT0">A great video</a> to introduce most of the notions covered in the Anki section.</p>
</li>
<li>
<p>Last but not least, <a href="https://www.supermemo.com/en/articles/history">the true history of spaced repetition</a>: An extensive coverage of the subject by Piotr Wozniak. A reference.</p>
</li>
</ul>
</div>
</div>
</div>
      </div>

      <div>
  <p><img src="https://www.juliensobczak.com/img/me.jpg"/></p><p><strong>About the author</strong></p>
  <p>Julien Sobczak works as a software developer for Scaleway, a French cloud provider. He is a passionate reader who likes to see the world differently to measure the extent of his ignorance. His main areas of interest are productivity (doing less and better), human potential, and everything that contributes in being a better person (including a better dad and a better developer).</p>
  <p><a href="https://fr.linkedin.com/in/julien-sobczak-56780a91">Read Full Profile</a>
</p></div>

    </article>

  </div>
</section>



<section id="recommendations">
  
</section>



  
<section id="labels">
  
</section>

  

  <div id="easter-egg">
  
  <p><img id="spongebob" src="https://www.juliensobczak.com/img/easter-egg/spongebob.png" width="20%"/>
  </p>
</div>
  <!-- Font Awesome CDN -->
<!-- <script src="https://kit.fontawesome.com/d54861fcaa.js" crossorigin="anonymous"></script> -->


<!-- Masonry effect -->
<!-- <script src="https://unpkg.com/colcade@0/colcade.js"></script> -->


<!-- Custom logic -->





</div>
  </body>
</html>
