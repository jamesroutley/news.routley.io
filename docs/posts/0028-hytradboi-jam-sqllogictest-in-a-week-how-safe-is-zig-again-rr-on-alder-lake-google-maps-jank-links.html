<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://scattered-thoughts.net/log/0028/">Original</a>
    <h1>0028: HYTRADBOI jam, sqllogictest in a week, how safe is zig again, rr on alder lake, google maps jank, links</h1>
    
    <div id="readability-page-1" class="page"><article>
  <h2 id="hytradboi-jam">HYTRADBOI jam</h2>
<p>The jam results are now up at <a href="https://www.hytradboi.com/jam">hytradboi.com/jam</a>. I haven&#39;t had a chance to read through all of them yet but it looks like there were some neat projects.</p>
<h2 id="sqllogictest-in-a-week">sqllogictest in a week</h2>
<p>For <a href="https://github.com/jamii/hytradboi-jam-2022">my own jam project</a>, I tried to make a sql frontend that could pass <a href="https://www.sqlite.org/sqllogictest/doc/trunk/about.wiki">sqllogictest</a>. </p>
<p>In sport and in music there&#39;s a kind of training where you try to push a skill to it&#39;s maximum along some dimension to see where you break down first. It&#39;s a way of finding bottlenecks that can be improved. That&#39;s kind of what I had in mind.</p>
<p>Sqllogictest is one of the smaller test suites from sqlite and it doesn&#39;t have great coverage of the sql language. But it&#39;s a test suite I&#39;m very familiar with because it was the first test suite that we tried to pass at materialize, and it also mostly tests generic sql rather than any particular dialect or interface. So it&#39;s well suited to a speed challenge.</p>
<p>I tried to roughly categorize the things I noted.</p>
<p><strong>Mechanical</strong>. </p>
<p>Typing is still a bottleneck. I make a lot of errors. Correcting the errors sometimes breaks my concentration, and then take a while to recover what I was doing. I&#39;m particularly bad around special characters. Some of this is caused by my new laptop having a slightly different keyboard layout. It might be worth spending a few minutes a day working on typing exercises, focused on the keys that are in different places or have different shapes on my new keyboard.</p>
<p>I spend a lot of time looking up definitions of functions or types. I&#39;ve been avoiding adding support for <a href="https://github.com/zigtools/zls">zls</a> to my editor because it doesn&#39;t handle comptime code and I assumed something better would come along eventually once the new self-hosted zig compiler was finished. But in practice most of the things I look up are static globals. So zls support is near the top of my todo list now.</p>
<p>My test workflow worked well. I have a process runner in my editor that auto-completes from my bash history and restarts the process on every save. I used this to run a tiny, manually edited subset of the tests so I could jump to errors easily in the editor. Then in a real terminal I ran the full tests. </p>
<p>Running full tests took up to 20 minutes by the end, so for the last two days I ended up having two branches of work in parallel in two different sway workspaces. I would code/debug on one while the tests ran on the other. This avoided long waits.</p>
<p>I worked pretty long hours with few breaks. This was probably not optimal. But I&#39;m not sure yet where the sweet spot is for different kinds of work. A lot of this challenge was mechanical - code that I mostly just typed out more-or-less-correctly first try. But parts of parsing were tricky and could have done with a clear head and more planning time.</p>
<p><strong>Strategic</strong>.</p>
<p>I stuck with the bnf for a long time because the other alternative was hand-writing a parser. Just transcribing <a href="https://github.com/MaterializeInc/materialize/tree/bf0f641e0337c50765336e9cc1adc29ae7455dc0/src/sql-parser">the materialize parser</a> would require typing 5 characters per second for 24 straight hours - definitely not a viable jam strategy. But this is a classic false binary. Once I realized that the bnf was also not viable I immediately had the idea to write a grammar and parser generator using the recursive descent + commit parsing style that I&#39;m most familiar with. I could have saved ~3 days by spending a little more time on day one generating alternatives.</p>
<p>I invested a few hours in adding some debugging tools to the parser. This was more than paid for itself - I did have a lot of parser bugs and they would have been painful to solve otherwise.</p>
<p>When working on the bnf, and for the first half-day working on the new parser, I tried to use a parsing technique that I wasn&#39;t very familiar with. I also didn&#39;t work through a proof that it was correct. This was also before I had invested time in debugging tools. As a result, I spent a lot of time trying to debug failures with very little visibility into the parsing process. I think I worked like this because of the time pressure, but it was false economy - if I had spent an hour or two thinking through the memoization algorithm on paper I probably would have gotten the caching key correct and saved several days of debugging.</p>
<p>I tweaked the test runner to print the test sql, filename and error code on every failure. I wrote the result of each run into a file and poke at it with ripgrep, cut, sort/uniq etc to prioritize which feature to work on next. The test coverage of sqllogictest is very skewed so this made a big difference to my final score.</p>
<p>It would have been nice to be able to store more details error information in a database for more complex queries about usage. I should maybe invest some time in a very ergonomic interface to eg sqlite aimed at these kinds of adhoc debugging uses.</p>
<p>Rather than try to fix slow queries I added cpu/memory limits to the evaluator. If I hadn&#39;t done this, I don&#39;t think I would have been able to even complete a test run before the end of the week, which would have meant total failure.</p>
<p><strong>Architectural</strong>.</p>
<p>I really like the final parser. The code is as easy to understand as hand-written parsers that I&#39;ve worked with before but the grammar is significantly denser which makes it easier to read and to modify. I didn&#39;t end up needing any custom parse actions, but they would be easy to add by switching on the comptime-known rulename in <a href="https://github.com/jamii/hytradboi-jam-2022/blob/615e0cae9980ce29219660cac6fcbd782c56fed6/lib/sql/Parser.zig#L79"><code>Parser.parse</code></a>. I was also able to <a href="https://github.com/jamii/hytradboi-jam-2022/blob/615e0cae9980ce29219660cac6fcbd782c56fed6/lib/sql/GrammarParser.zig#L106">detect accidental left-recursion</a> at compile-time whereas in hand-written parsers I would only find out when the fuzzer stack-overflows.</p>
<p>Early on in the parse I made tokens implicit to save having to declare them separately. This was a terrible idea. I spent much more time debugging typos than I saved by not typing out what ended up being a list of 30 words.</p>
<p>For the ast I tried to enable both static and dynamic typing. The main data stored in the parser is:</p>
<pre data-lang="zig"><code data-lang="zig"><span>// AST nodes
</span><span>nodes</span><span>:</span><span> u.</span><span>ArrayList</span><span>(Node)</span><span>,
</span><span>// For each node, the location in the source code that it came from
</span><span>node_ranges</span><span>:</span><span> u.</span><span>ArrayList</span><span>([</span><span>2</span><span>]usize)</span><span>,
</span></code></pre>
<p>The nodes themselves are just a giant enum with one case for each rule in the grammar:</p>
<pre data-lang="zig"><code data-lang="zig"><span>pub const </span><span>Node </span><span>= </span><span>union</span><span>(</span><span>enum</span><span>) {
</span><span>    select</span><span>: </span><span>select</span><span>,
</span><span>    </span><span>...
</span><span>}</span><span>;
</span></code></pre>
<p>But the payloads in this enum are structs with static types:</p>
<pre data-lang="zig"><code data-lang="zig"><span>pub const </span><span>select </span><span>= </span><span>struct </span><span>{
</span><span>    distinct_or_all</span><span>: </span><span>NodeId</span><span>(distinct_or_all)</span><span>,
</span><span>    result_columns</span><span>: </span><span>NodeId</span><span>(result_columns)</span><span>,
</span><span>    from</span><span>: </span><span>NodeId</span><span>(from)</span><span>,
</span><span>    where</span><span>: </span><span>NodeId</span><span>(where)</span><span>,
</span><span>    group_by</span><span>: </span><span>NodeId</span><span>(group_by)</span><span>,
</span><span>    having</span><span>: </span><span>NodeId</span><span>(having)</span><span>,
</span><span>    window</span><span>: </span><span>NodeId</span><span>(window)</span><span>,
</span><span>    order_by</span><span>: </span><span>NodeId</span><span>(order_by)</span><span>,
</span><span>    limit</span><span>: </span><span>NodeId</span><span>(limit)</span><span>,
</span><span>}</span><span>;
</span></code></pre>
<p>Those <code>NodeId</code> types are just integer references into the <code>nodes</code> array, but in a <a href="https://github.com/jamii/hytradboi-jam-2022/blob/615e0cae9980ce29219660cac6fcbd782c56fed6/lib/sql/Parser.zig#L31">statically-typed wrapper</a>. So <code>select.from.get(p)</code> returns a <code>from</code> struct, but <code>p.nodes.items[select.from.id]</code> returns a <code>Node</code>. </p>
<p>I really liked this combination. When working through a particular chunk of the tree I got static types, but I could also just use the union tags and the raw integer ids to do generic traversals (eg <a href="https://github.com/jamii/hytradboi-jam-2022/blob/615e0cae9980ce29219660cac6fcbd782c56fed6/lib/sql/Parser.zig#L290">printing the parse tree</a>). The usual alternative is some <a href="https://github.com/MaterializeInc/materialize/blob/b8bb32ab1f8e00b4c932b071c59e14e08e2bd681/src/sql/src/plan/expr.rs#L231-L319">visitor pattern</a> but I find that inversion of control pretty clunky.</p>
<p>I took an experimental approach to name resolution in the planner. This is one of the tricky parts of sql because sql&#39;s scoping rules are <a href="https://www.scattered-thoughts.net/writing/select-wat-from-sql/">bonkers</a>. </p>
<p>In materialize we had a single pass that went from the sql ast to a high-level IR that referred to columns by position. Each function in the pass would take an ast node and some context, and return an ir node and a scope object representing what names were available in that object. There were two difficulties with this:</p>
<ol>
<li>SQLs scoping rules are incredibly entangled with it&#39;s syntax, so the scope object had to become increasingly complicated to reflect all the parts of sql syntax that affect name resolution.</li>
<li>The optimizer running on the IR wanted to move nodes around and change them, but it had to be very careful not to change the position of any columns, or add or remove any columns, lest it break the position-based references elsewhere in the IR.</li>
</ol>
<p>For the jam I tried to separate out the layers a bit more. The rough steps were:</p>
<ol>
<li>Translate the sql ast to a high-level IR that retains the syntactic structure.</li>
<li>Assign a unique id to each scalar or table expression that produces new columns.</li>
<li>For each anonymous expression (eg in <code>ON</code>, <code>GROUP BY</code>, <code>ORDER BY</code>), move it into a <code>map</code> node with a unique id and replace the original with a reference to that id.</li>
<li>For each column reference (eg <code>foo</code>, <code>foo.bar</code>, <code>foo.*</code>, <code>*</code>), find the expression that creates that column and replace the column reference with the unique id of that expression. Crucially, we still have all the important syntactic features in the IR itself so we don&#39;t have to make a separate scope object to mirror those features.</li>
<li>At this point the IR only refers to columns by unique id. If I had an optimizer, it would run at this point and not have to worry about keeping track of columns.</li>
<li>Finally, just before execution, make a pass through the IR to pick a layout and replace column ids with physical position.</li>
</ol>
<p>I was in a rush so steps 1-3 were fused together, but I think it would have been better to separate them. Step 4 is <a href="https://github.com/jamii/hytradboi-jam-2022/blob/615e0cae9980ce29219660cac6fcbd782c56fed6/lib/sql/Planner.zig#L1070-L1269">here</a>. Step 6 is <a href="https://github.com/jamii/hytradboi-jam-2022/blob/615e0cae9980ce29219660cac6fcbd782c56fed6/lib/sql/Planner.zig#L1271-L1378">here</a>.</p>
<p>This worked well for the subset of sql that I implemented. The main missing feature is correlated subqueries / lateral joins - I&#39;d have to implement those too to be sure that it&#39;s a good architecture.</p>
<p><strong id="zig">Zig.</strong></p>
<p>For context: I generally enjoy working with zig and I&#39;ve found it a practical choice for the kinds of problems I often work on. Many of the nice things in the architecture section were dependent on zig&#39;s excellent metaprogramming. I&#39;m sharing all the nits below in the hopes that it is useful feedback. Certainly not as complaints and or demands.</p>
<p>I spend a lot of time doing basic iter/collection stuff like removing duplicates from an array. The stdlib isn&#39;t very fleshed out yet and it&#39;s not clear whether that&#39;s where collection utils will go anyway. In the meantime, it might make sense to start adding these to my <code>util.zig</code> that I copy-paste between projects.</p>
<p>I had three bugs related to memory safety:</p>
<ol>
<li>
<p>In the parser I held onto a hashmap entry in the cache, invalidated it with a recursive call to parse and then wrote to the entry value_ptr. In the rare cases where the hashmap was resized in the recursive call, this write was lost and I was very confused about why certain deeply nested sql expressions failed to parse. This was not caught by the GPA or by any of the safety checks. I haven&#39;t thought of a runtime check I could add. I think my mitigation in future will be to only hold hashmap entries in very small blocks of code, if at all.</p>
</li>
<li>
<p>The parser/planner/evaluator and the database used two separate arenas. Once, I forgot to clone a table name from the evaluator before inserting it into the database. The resulting UAF wasn&#39;t detecte by the GPA because of the intervening ArenaAllocator. It manifested as allowing a table to be created twice which produced very confusing errors in downstream tests. If there was a cheap test of arena ownership I could have added asserts to the database methods. I think this might be possible with the existing arena allocator.</p>
</li>
<li>
<p>When initializing an array of column references I put a <code>break</code> in the wrong place. Sometimes this left parts of the array uninitialized until they blew up downstream math. I <a href="https://github.com/jamii/hytradboi-jam-2022/commit/1128e6b9bb18bde2d88d6823115b13d05c52c602">fixed</a> this by switching to a syntactic pattern that makes it impossible to leave entries uninitialized. </p>
</li>
</ol>
<p>In rust I would have made 3. even harder to mess up by passing a closure: <code>alloc_array(len, |i| ...)</code> but in zig this would be far too verbose:</p>
<pre data-lang="zig"><code data-lang="zig"><span>alloc_array</span><span>(len</span><span>,</span><span> table_def.columns</span><span>, </span><span>(</span><span>struct </span><span>{
</span><span>   </span><span>fn </span><span>f</span><span>(</span><span>columns</span><span>:</span><span> []</span><span>const Column</span><span>, </span><span>i</span><span>: </span><span>usize</span><span>) </span><span>ColumnName </span><span>{
</span><span>      </span><span>return </span><span>...</span><span>;
</span><span>   }).f)
</span></code></pre>
<p>Many collection utils would also be much less verbose with closures. There is a <a href="https://github.com/ziglang/zig/issues/6965">proposal</a> for second-class closures (closures which can only be passed as arguments, but not stored on the stack or heap). This would solve most of the usecases I have for closures without the full complexity of closure memory management.</p>
<p>I had several bugs caused by forgotting to handle a field of a large struct, or by adding a field and then not handling it everywhere it was used. While zig has exhaustive compiler-checked switchs for enums/unions, there is no equivalent exhaustive destructuring of structs and no ergonomic way to approximate it with metaprogramming. (I left a comment on the relevant issue in the zig repo.)</p>
<p>During the jam I didn&#39;t even bother returning diagnostics for most errors because maintaing a separate pathway from the error itself is extra work and, ironically, error-prone. I&#39;m hopeful for <a href="https://github.com/ziglang/zig/issues/2647">error payloads</a>, although it&#39;s not obvious how the various design issues can be neatly resolved.</p>
<p>Zig has <code>defer</code> and <code>errdefer</code>. I found myself often occasionally wanting <code>noerrdefer</code>. It&#39;s common to have some nested logic like:</p>
<pre data-lang="zig"><code data-lang="zig"><span>{
</span><span>    thing.</span><span>push</span><span>()</span><span>;
</span><span>    </span><span>...</span><span>lots of code</span><span>...
</span><span>    thing.</span><span>pop</span><span>()</span><span>;
</span><span>}
</span></code></pre>
<p>(<a href="https://github.com/jamii/preimp/blob/901b30998ee39ac82cbf2745d98c6aedf92f613e/native/native.zig#L501-L528">Here</a> is a particulary nested example.)</p>
<p>It&#39;s easy to mess up that pairing and so I&#39;m often tempted to turn it into:</p>
<pre data-lang="zig"><code data-lang="zig"><span>{
</span><span>    thing.</span><span>push</span><span>()</span><span>;
</span><span>    </span><span>defer</span><span> thing.</span><span>pop</span><span>()</span><span>;
</span><span>    </span><span>...</span><span>lots of code</span><span>...
</span><span>}
</span></code></pre>
<p>But during the jam in most cases it was not correct or even possible to <code>thing.pop()</code> if an error was thrown - only if the block was exited succesfully. I found a <a href="https://github.com/ziglang/zig/issues/8190">related issue</a> that was closed as &#39;completed&#39; but I&#39;m not sure what the actual resolution was.</p>
<p>The parser generator has several steps:</p>
<ol>
<li>grammar.txt -&gt; rules</li>
<li>rules -&gt; ast</li>
<li>rules -&gt; parser</li>
</ol>
<p>In theory it&#39;s possible to do all of these at comptime. 1 I decided would be best left until there is a <a href="https://github.com/ziglang/zig/issues/1291">ComptimeAllocator</a> available. 2 should be possible using @Type but I ran into segfaults in both stage1 and stage2 (the old and new zig compilers) and couldn&#39;t find a way around. Sadly I didn&#39;t check in the code, but I often cause crashes when I get ambitious with @Type so I can probably make an independent repro. Now that stage2 is near release this might be a good time for me to try some compiler development and track down the bug.</p>
<p><strong>Overall</strong>.</p>
<p>I enjoyed the jam challenge a lot. I learned a lot more in a week than I usually do in a month. It was not a sustainable effort (~70 hours), so I can&#39;t work like that all the time. But I think there is probably value in regularly challenging myself in this way. Maybe every 3-4 months, to give me time to act on the lessons from each challenge before attempting another.</p>
<p>Something that maybe wasn&#39;t clear from the outside is that on Friday morning I was pretty sure I was going to fail miserably. I kept working at it because success at the problem itself was not the point. The point is to stretch my comfort zone, which requires spending a lot of time in the uncomfortable probably-going-to-fail zone. That&#39;s not something I really understood when I was younger. </p>
<h2 id="how-safe-is-zig-again">how safe is zig again</h2>
<p>I rewrote <a href="https://www.scattered-thoughts.net/writing/how-safe-is-zig/">this article</a> yet again. I focused it even more on actual examples, specific scenarios and lived experiences. I also tried to avoid </p>
<p>It&#39;s hopefully clear that there is a complex set of tradeoffs here and that as the author I&#39;m not staking a position but instead tentatively feeling out the territory.</p>
<h2 id="rr-on-alder-lake">rr on alder lake</h2>
<p>The <a href="https://github.com/rr-debugger/">rr</a> in stable nixos doesn&#39;t work on alder lake, but 5.6.0 works.</p>
<pre data-lang="nix"><code data-lang="nix"><span> (</span><span>pkgs</span><span>.</span><span>rr</span><span>.</span><span>overrideAttrs </span><span>(</span><span>finalAttrs</span><span>: </span><span>previousAttrs</span><span>: </span><span>rec </span><span>{
</span><span>        </span><span>version </span><span>= </span><span>&#34;5.6.0&#34;</span><span>;
</span><span>        </span><span>src </span><span>= </span><span>fetchFromGitHub </span><span>{
</span><span>            </span><span>owner </span><span>= </span><span>&#34;mozilla&#34;</span><span>;
</span><span>            </span><span>repo </span><span>= </span><span>&#34;rr&#34;</span><span>;
</span><span>            </span><span>rev </span><span>= </span><span>version</span><span>;
</span><span>            </span><span>sha256 </span><span>= </span><span>&#34;H39HPkAQGubXVQV3jCpH4Pz+7Q9n03PrS70utk7Tt2k=&#34;</span><span>;
</span><span>        }</span><span>;
</span><span>    }))
</span></code></pre>
<p>The E cores apparently don&#39;t have perf counters, so you need to use <code>rr record --bind-to-cpu=0</code>. </p>
<p>I also learned that rr <a href="https://github.com/rr-debugger/rr/issues/2613">doesn&#39;t yet support</a>.</p>
<h2 id="goole-maps-jank">goole maps jank</h2>
<p>On google maps you can drag intermediate points to change the route. If you share the result with someone and they open it in the browser they will see the altered route. But if they open it in the mobile app they will only see the original route.</p>
<p><a href="https://www.google.com/maps/dir/Main+Street-Science+World,+Vancouver,+BC+V6A+4G5/Craffles,+Davie+Street,+Vancouver,+BC/Earnest+Ice+Cream+%7C+Quebec+St.,+Quebec+Street,+Vancouver,+BC/149+E+4th+Ave,+Vancouver,+BC/@49.2906899,-123.1641181,13z/am=t/data=!3m2!4b1!5s0x548673df60820821:0xe8e66127fe627e3!4m51!4m50!1m30!1m1!1s0x5486716418ba8c37:0x5cfe76622b9771ea!2m2!1d-123.10035!2d49.273172!3m4!1m2!1d-123.1094306!2d49.2843792!3s0x5486717837087f5f:0xade402ffdaaa8f19!3m4!1m2!1d-123.1218252!2d49.2905697!3s0x548671845c853d39:0xaa20496fcc91aa00!3m4!1m2!1d-123.1353254!2d49.2968772!3s0x5486718be918938d:0x6fb9be218ddfefd!3m4!1m2!1d-123.1410567!2d49.3134627!3s0x548671fa66ae4807:0x64359ed8198add60!3m4!1m2!1d-123.1362682!2d49.2768455!3s0x548673d2bc218dad:0x2a2c09fee83d9f7a!1m5!1m1!1s0x54867351abc5d7ad:0x5091dd791bde6838!2m2!1d-123.1247095!2d49.2759468!1m5!1m1!1s0x54867160547153bf:0xc0ef31dc28e9564f!2m2!1d-123.1029334!2d49.2688082!1m5!1m1!1s0x548671607a673579:0xa290a08725d62447!2m2!1d-123.1015494!2d49.2673316!3e2">Example</a></p>
<p>I learned this by taking someone on a significantly longer walk than they realized they were signing up for.</p>
<h2 id="links">links</h2>
<p><a href="https://www.val-lang.dev/">Val</a> feels like an attempt to marry the best parts of swift and rust.</p>
<p><a href="https://arxiv.org/pdf/2202.04522.pdf">Constructing and Analyzing the LSM Compaction Design Space</a>. An excellent systematic mapping of the design space and the implications of each axis.</p>
<p>Recent versions of gtk changed the default behaviour of the file picker to always start at &#39;recent files&#39;. Here is how to <a href="https://unix.stackexchange.com/questions/133998/show-file-system-instead-of-places-in-gtk-file-chooser">change it back</a>.</p>
<p><a href="https://jasonpargin.substack.com/p/stop-telling-me-humanity-is-doomed">https://jasonpargin.substack.com/p/stop-telling-me-humanity-is-doomed</a></p>
<blockquote>
<p>The fantasy, the &#34;blue pill&#34;, is that you&#39;re one of the few enlightened souls in a world of mindless, sleepwalking drones and that your dark pessimism is proof of your superiority. The &#34;red pill&#34; truth is that everyone around you is just as important and that most of them are trying their best. The brutal reality no one wants to face isn&#39;t that there&#39;s some thrilling secret war being fought, but that the mindless hours Neo spent in that cubicle produced work that probably made other people&#39;s lives better.</p>
</blockquote>
<blockquote>
<p>[..] But if I&#39;m right and the world has steadily improved over the centuries because of the strenuous efforts of billions of people, it means you are saddled with a tremendous responsibility to give back.</p>
</blockquote>
<p><a href="https://tis.so/divide-by-less">https://tis.so/divide-by-less</a></p>
<blockquote>
<p>If [...] an intervention was a great help for 5% of people and irrelevant for the other 95%, your job isn&#39;t to open a Jupyter notebook and run a significance test to figure out if that intervention is &#39;real science&#39;; it&#39;s to figure out what language describes the commonalities of that 5% such that anyone reading along at home will know if it&#39;s worth trying for them. Our modern conception of science often gets this exactly backwards: by &#39;removing outliers&#39; and bounding findings in some scoring system, effects that are obviously ginormous when you see them in front of you get dully labeled as &#39;failure to replicate&#39; because you picked a lot of people it wasn&#39;t true for also.</p>
</blockquote>

</article></div>
  </body>
</html>
