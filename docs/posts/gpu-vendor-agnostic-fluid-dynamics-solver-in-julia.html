<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://b-fg.github.io/2023/05/07/waterlily-on-gpu.html">Original</a>
    <h1>GPU vendor-agnostic fluid dynamics solver in Julia</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody"><p><a href="https://github.com/weymouth/WaterLily.jl">WaterLily.jl</a> is a simple and fast fluid simulator written in pure Julia. It solves the unsteady incompressible 2D or 3D <a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes equations</a> on a Cartesian grid.
The pressure Poisson equation is solved with a <a href="https://en.wikipedia.org/wiki/Multigrid_method">geometric multigrid</a> method.
Solid boundaries are modelled using the <a href="https://eprints.soton.ac.uk/369635/">Boundary Data Immersion Method</a>.</p>

<p><a href="https://github.com/weymouth/WaterLily.jl/releases/tag/v1.0.0">v1.0</a> has ported the solver from a serial CPU execution to a backend-agnostic execution including multi-threaded CPU and GPU from different vendors (NVIDIA and AMD) thanks to <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> (KA).
We have also recently published an extended abstract preprint with benchmarking details regarding this port (see <a href="https://arxiv.org/abs/2304.08159">arXiv</a>).
In this post, we will review our approach to port the code together with the challenges we have faced.</p>

<h3 id="introducing-kernelabstractionsjl">Introducing KernelAbstractions.jl</h3>

<p>The main ingredient of this port is the <a href="https://juliagpu.gitlab.io/KernelAbstractions.jl/api/#KernelAbstractions.@kernel"><code>@kernel</code></a> macro from KA.
This macro takes a function definition and converts it into a kernel specialised for a given backend. KA can work with CUDA, ROCm, oneAPI, and Metal backends.</p>

<p>As example, consider the divergence operator for a 2D vector field $\vec{u}=(u, v)$.
In the finite-volume method (FVM) and using a Cartesian (uniform) grid with unit cells, this is defined as</p><p>

\[\begin{align}
\sigma=\unicode{x2230}(\nabla\cdot\vec{u})\,\mathrm{d}V = \unicode{x222F}\vec{u}\cdot\hat{n}\,\mathrm{d}S\rightarrow \sigma_{i,j} = (u_{i+1,j} - u_{i,j}) + (v_{i,j+1} - v_{i,j}),
\end{align}\]

</p><p>where $i$ and $j$ are the indices of the discretised staggered grid:</p>

<p><img src="https://aaronstrick.com/assets/images/2023-07-05-waterlily-on-gpu/divergence.svg#center" alt="staggered grid" width="40%"/></p>

<p>In WaterLily, we define loops based on the <code>CartesianIndex</code> such that <code>I=(i,j,...)</code>, thus writing an n-dimensional solver in a very straight-forward way.
With this, to compute the divergence of a 2D vector field we can use</p>
<div><div><pre><code><span>δ</span><span>(</span><span>d</span><span>,</span><span>::</span><span>CartesianIndex</span><span>{</span><span>D</span><span>})</span> <span>where</span> <span>{</span><span>D</span><span>}</span> <span>=</span> <span>CartesianIndex</span><span>(</span><span>ntuple</span><span>(</span><span>j</span> <span>-&gt;</span> <span>j</span><span>==</span><span>d</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>,</span> <span>D</span><span>))</span>
<span>@inline</span> <span>∂</span><span>(</span><span>a</span><span>,</span><span>I</span><span>::</span><span>CartesianIndex</span><span>{</span><span>D</span><span>},</span><span>u</span><span>::</span><span>AbstractArray</span><span>{</span><span>T</span><span>,</span><span>n</span><span>})</span> <span>where</span> <span>{</span><span>D</span><span>,</span><span>T</span><span>,</span><span>n</span><span>}</span> <span>=</span> <span>u</span><span>[</span><span>I</span><span>+</span><span>δ</span><span>(</span><span>a</span><span>,</span><span>I</span><span>),</span><span>a</span><span>]</span> <span>-</span> <span>u</span><span>[</span><span>I</span><span>,</span><span>a</span><span>]</span>
<span>inside</span><span>(</span><span>a</span><span>)</span> <span>=</span> <span>CartesianIndices</span><span>(</span><span>ntuple</span><span>(</span><span>i</span><span>-&gt;</span> <span>2</span><span>:</span><span>size</span><span>(</span><span>a</span><span>)[</span><span>i</span><span>]</span><span>-</span><span>1</span><span>,</span> <span>ndims</span><span>(</span><span>a</span><span>)))</span>

<span>N</span> <span>=</span> <span>(</span><span>10</span><span>,</span> <span>10</span><span>)</span> <span># domain size</span>
<span>σ</span> <span>=</span> <span>zeros</span><span>(</span><span>N</span><span>)</span> <span># scalar field</span>
<span>u</span> <span>=</span> <span>rand</span><span>(</span><span>N</span><span>...</span><span>,</span> <span>length</span><span>(</span><span>N</span><span>))</span> <span># 2D vector field with ghost cells</span>

<span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>),</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
    <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>where a loop for each dimension <code>d</code> and each Cartesian index <code>I</code> is used.
The function <code>δ</code> provides a Cartesian step in the direction <code>d</code>, for example <code>δ(1, 2)</code> returns <code>CartesianIndex(1, 0)</code> and <code>δ(2, 3)</code> returns <code>CartesianIndex(0, 1, 0)</code>.
This is used in the derivative function <code>∂</code> to implement the divergence equation as described above.
<code>inside(σ)</code> provides the <code>CartesianIndices</code> of <code>σ</code> excluding the ghost elements, <em>ie.</em> a range of Cartesian indices starting at <code>(2, 2)</code> and ending at <code>(9, 9)</code> when <code>size(σ) == (10, 10)</code>.</p>

<p>Note that the divergence operation is independent for each <code>I</code>, and this is great because it means we can parallelize it!
This is where KA comes into place.
To be able to generate the divergence operator using KA, we need to write the divergence kernel which is just the divergence operator written in KA style.</p>

<p>We define the divergence kernel <code>_divergence!</code> and a wrapper <code>divergence!</code> as follows</p>
<div><div><pre><code><span>using</span> <span>KernelAbstractions</span><span>:</span> <span>get_backend</span><span>,</span> <span>@index</span><span>,</span> <span>@kernel</span>

<span>@kernel</span> <span>function</span><span> _divergence!</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>,</span> <span>@Const</span><span>(</span><span>I0</span><span>))</span>
    <span>I</span> <span>=</span> <span>@index</span><span>(</span><span>Global</span><span>,</span> <span>Cartesian</span><span>)</span>
    <span>I</span> <span>+=</span> <span>I0</span>
    <span>σ_sum</span> <span>=</span> <span>zero</span><span>(</span><span>eltype</span><span>(</span><span>σ</span><span>))</span>
    <span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>)</span>
        <span>σ_sum</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span>
    <span>end</span>
    <span>σ</span><span>[</span><span>I</span><span>]</span> <span>=</span> <span>σ_sum</span>
<span>end</span>
<span>function</span><span> divergence!</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>)</span>
    <span>R</span> <span>=</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
    <span>_divergence!</span><span>(</span><span>get_backend</span><span>(</span><span>σ</span><span>),</span> <span>64</span><span>)(</span><span>σ</span><span>,</span> <span>u</span><span>,</span> <span>R</span><span>[</span><span>1</span><span>]</span><span>-</span><span>oneunit</span><span>(</span><span>R</span><span>[</span><span>1</span><span>]),</span> <span>ndrange</span><span>=</span><span>size</span><span>(</span><span>R</span><span>))</span>
<span>end</span>
</code></pre></div></div>
<p>Note that in the <code>_divergence!</code> kernel we operate again using Cartesian indices by calling <code>@index(Global, Cartesian)</code> from the KA <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/api/#KernelAbstractions.@index"><code>@index</code></a> macro.
The range of Cartesian indices is given by the <code>ndrange</code> argument in the wrapper function where we pass the <code>inside(σ)</code> Cartesian indices range, and the backend is inferred with the <code>get_backend</code> method.
Also note that we pass an additional (constant) argument <code>I0</code> which provides the offset index to apply to the indices given by <code>@index</code> naturally starting on <code>(1,1,...)</code>.
Using a workgroup size of <code>64</code> (size of the group of threads acting in parallel, see <a href="https://juliagpu.github.io/KernelAbstractions.jl/stable/quickstart/#Terminology-1">terminology</a>), KA will parallelize over <code>I</code> by multi-threading in CPU or GPU.
In this regard, we just need to change the array type of <code>σ</code> and <code>u</code> from <code>Array</code> (CPU backend) to <code>CuArray</code> (NVIDIA GPU backend) or <code>ROCArray</code> (AMD GPU backend), and KA will specialise the kernel for the desired backend</p>
<div><div><pre><code><span>using</span> <span>CUDA</span><span>:</span> <span>CuArray</span>

<span>N</span> <span>=</span> <span>(</span><span>10</span><span>,</span> <span>10</span><span>)</span>
<span>σ</span> <span>=</span> <span>zeros</span><span>(</span><span>N</span><span>)</span> <span>|&gt;</span> <span>CuArray</span>
<span>u</span> <span>=</span> <span>rand</span><span>(</span><span>N</span><span>...</span><span>,</span> <span>length</span><span>(</span><span>N</span><span>))</span> <span>|&gt;</span> <span>CuArray</span>

<span>divergence!</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>)</span>
</code></pre></div></div>

<h3 id="automatic-loop-and-kernel-generation">Automatic loop and kernel generation</h3>

<p>As a stencil-based CFD solver, WaterLily heavily uses <code>for</code> loops to iterate over the n-dimensional arrays.
To automate the generation of such loops, the macro <code>@loop</code> is defined</p>
<div><div><pre><code><span>macro</span><span> loop</span><span>(</span><span>args</span><span>...</span><span>)</span>
    <span>ex</span><span>,</span><span>_</span><span>,</span><span>itr</span> <span>=</span> <span>args</span>
    <span>op</span><span>,</span><span>I</span><span>,</span><span>R</span> <span>=</span> <span>itr</span><span>.</span><span>args</span>
    <span>@assert</span> <span>op</span> <span>∈</span> <span>(</span><span>:</span><span>(</span><span>∈</span><span>),</span><span>:</span><span>(</span><span>in</span><span>))</span>
    <span>return</span> <span>quote</span>
        <span>for</span> <span>$</span><span>I</span> <span>∈</span> <span>$</span><span>R</span>
            <span>$</span><span>ex</span>
        <span>end</span>
    <span>end</span> <span>|&gt;</span> <span>esc</span>
<span>end</span>
</code></pre></div></div>
<p>This macro takes an expression such as <code>@loop &lt;expr&gt; over I ∈ R</code> where <code>R</code> is a <code>CartesianIndices</code> range, and produces the loop <code>for I ∈ R &lt;expr&gt; end</code>.
For example, the serial divergence operator could now be simply defined using</p>
<div><div><pre><code><span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>)</span>
    <span>@loop</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>which generates the <code>I ∈ inside(σ)</code> loop automatically.</p>

<p>Even though this could be seen as small improvement (if any), the nice thing about writing loops using this approach is that the computationally-demanding part of the code can be abstracted out of the main workflow.
For example, it is easy to add performance macros such as <code>@inbounds</code> and/or <code>@fastmath</code> to each loop by changing the quote block in the <code>@loop</code> macro</p>
<div><div><pre><code><span>macro</span><span> loop</span><span>(</span><span>args</span><span>...</span><span>)</span>
    <span>ex</span><span>,</span><span>_</span><span>,</span><span>itr</span> <span>=</span> <span>args</span>
    <span>op</span><span>,</span><span>I</span><span>,</span><span>R</span> <span>=</span> <span>itr</span><span>.</span><span>args</span>
    <span>@assert</span> <span>op</span> <span>∈</span> <span>(</span><span>:</span><span>(</span><span>∈</span><span>),</span><span>:</span><span>(</span><span>in</span><span>))</span>
    <span>return</span> <span>quote</span>
        <span>@inbounds</span> <span>for</span> <span>$</span><span>I</span> <span>∈</span> <span>$</span><span>R</span>
            <span>@fastmath</span> <span>$</span><span>ex</span>
        <span>end</span>
    <span>end</span> <span>|&gt;</span> <span>esc</span>
<span>end</span>
</code></pre></div></div>
<p>And, even nicer, we can also use this approach to automatically generate KA kernels for every loop in the code!
To do so, we modify <code>@loop</code> to generate the KA kernel using <code>@kernel</code> and the wrapper function that sets the backend and the workgroup size</p>
<div><div><pre><code><span>macro</span><span> loop</span><span>(</span><span>args</span><span>...</span><span>)</span>
    <span>ex</span><span>,</span><span>_</span><span>,</span><span>itr</span> <span>=</span> <span>args</span>
    <span>_</span><span>,</span><span>I</span><span>,</span><span>R</span> <span>=</span> <span>itr</span><span>.</span><span>args</span><span>;</span> <span>sym</span> <span>=</span> <span>[]</span>
    <span>grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>)</span>     <span># get arguments and replace composites in `ex`</span>
    <span>setdiff!</span><span>(</span><span>sym</span><span>,[</span><span>I</span><span>])</span> <span># don&#39;t want to pass I as an argument</span>
    <span>@gensym</span> <span>kern</span>      <span># generate unique kernel function name</span>
    <span>return</span> <span>quote</span>
        <span>@kernel</span> <span>function</span><span> $kern</span><span>(</span><span>$</span><span>(</span><span>rep</span><span>.</span><span>(</span><span>sym</span><span>)</span><span>...</span><span>),</span><span>@Const</span><span>(</span><span>I0</span><span>))</span> <span># replace composite arguments</span>
            <span>$</span><span>I</span> <span>=</span> <span>@index</span><span>(</span><span>Global</span><span>,</span><span>Cartesian</span><span>)</span>
            <span>$</span><span>I</span> <span>+=</span> <span>I0</span>
            <span>$</span><span>ex</span>
        <span>end</span>
        <span>$</span><span>kern</span><span>(</span><span>get_backend</span><span>(</span><span>$</span><span>(</span><span>sym</span><span>[</span><span>1</span><span>])),</span><span>64</span><span>)(</span><span>$</span><span>(</span><span>sym</span><span>...</span><span>),</span><span>$</span><span>R</span><span>[</span><span>1</span><span>]</span><span>-</span><span>oneunit</span><span>(</span><span>$</span><span>R</span><span>[</span><span>1</span><span>]),</span><span>ndrange</span><span>=</span><span>size</span><span>(</span><span>$</span><span>R</span><span>))</span>
    <span>end</span> <span>|&gt;</span> <span>esc</span>
<span>end</span>
<span>function</span><span> grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>::</span><span>Expr</span><span>)</span>
    <span>ex</span><span>.</span><span>head</span> <span>==</span> <span>:.</span> <span>&amp;&amp;</span> <span>return</span> <span>union!</span><span>(</span><span>sym</span><span>,[</span><span>ex</span><span>])</span>      <span># grab composite name and return</span>
    <span>start</span> <span>=</span> <span>ex</span><span>.</span><span>head</span><span>==:</span><span>(</span><span>call</span><span>)</span> <span>?</span> <span>2</span> <span>:</span> <span>1</span>              <span># don&#39;t grab function names</span>
    <span>foreach</span><span>(</span><span>a</span><span>-&gt;</span><span>grab!</span><span>(</span><span>sym</span><span>,</span><span>a</span><span>),</span><span>ex</span><span>.</span><span>args</span><span>[</span><span>start</span><span>:</span><span>end</span><span>])</span>   <span># recurse into args</span>
    <span>ex</span><span>.</span><span>args</span><span>[</span><span>start</span><span>:</span><span>end</span><span>]</span> <span>=</span> <span>rep</span><span>.</span><span>(</span><span>ex</span><span>.</span><span>args</span><span>[</span><span>start</span><span>:</span><span>end</span><span>])</span> <span># replace composites in args</span>
<span>end</span>
<span>grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>::</span><span>Symbol</span><span>)</span> <span>=</span> <span>union!</span><span>(</span><span>sym</span><span>,[</span><span>ex</span><span>])</span>        <span># grab symbol name</span>
<span>grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>)</span> <span>=</span> <span>nothing</span>
<span>rep</span><span>(</span><span>ex</span><span>)</span> <span>=</span> <span>ex</span>
<span>rep</span><span>(</span><span>ex</span><span>::</span><span>Expr</span><span>)</span> <span>=</span> <span>ex</span><span>.</span><span>head</span> <span>==</span> <span>:.</span> <span>?</span> <span>Symbol</span><span>(</span><span>ex</span><span>.</span><span>args</span><span>[</span><span>2</span><span>]</span><span>.</span><span>value</span><span>)</span> <span>:</span> <span>ex</span>
</code></pre></div></div>

<p>The helper functions <code>grab!</code> and <code>rep</code> allow to extract the arguments required by the expression <code>ex</code> and the Cartesian index range that will be passed to the kernel.</p>

<p>The code generated by <code>@loop</code> and <code>@kernel</code> can be explored using <code>@macroexpand</code>. For example, for <code>d=1</code></p>
<div><div><pre><code><span>@macroexpand</span> <span>@loop</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>1</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
</code></pre></div></div>
<p>we can observe that the code for both CPU and GPU kernels is produced:</p>
<details>
<summary>Generated code</summary>
<pre>@macroexpand @loopKA σ[I] += ∂(1, I, u) over I ∈ inside(σ)
quote
    begin
        function var&#34;cpu_##kern#339&#34;(__ctx__, σ, u, I0; )
            let I0 = (KernelAbstractions.constify)(I0)
                $(Expr(:aliasscope))
                begin
                    var&#34;##N#341&#34; = length((KernelAbstractions.__workitems_iterspace)(__ctx__))
                    begin
                        for var&#34;##I#340&#34; = (KernelAbstractions.__workitems_iterspace)(__ctx__)
                            (KernelAbstractions.__validindex)(__ctx__, var&#34;##I#340&#34;) || continue
                            I = KernelAbstractions.__index_Global_Cartesian(__ctx__, var&#34;##I#340&#34;)
                            begin
                                I += I0
                                σ[I] += ∂(1, I, u)
                            end
                        end
                    end
                end
                $(Expr(:popaliasscope))
                return nothing
            end
        end
        function var&#34;gpu_##kern#339&#34;(__ctx__, σ, u, I0; )
            let I0 = (KernelAbstractions.constify)(I0)
                if (KernelAbstractions.__validindex)(__ctx__)
                    begin
                        I = KernelAbstractions.__index_Global_Cartesian(__ctx__)
                        I += I0
                        σ[I] += ∂(1, I, u)
                    end
                end
                return nothing
            end
        end
        begin
            if !($(Expr(:isdefined, Symbol(&#34;##kern#339&#34;))))
                begin
                    $(Expr(:meta, :doc))
                    var&#34;##kern#339&#34;(dev) = begin
                            var&#34;##kern#339&#34;(dev, (KernelAbstractions.NDIteration.DynamicSize)(), (KernelAbstractions.NDIteration.DynamicSize)())
                        end
                end
                var&#34;##kern#339&#34;(dev, size) = begin
                        var&#34;##kern#339&#34;(dev, (KernelAbstractions.NDIteration.StaticSize)(size), (KernelAbstractions.NDIteration.DynamicSize)())
                    end
                var&#34;##kern#339&#34;(dev, size, range) = begin
                        var&#34;##kern#339&#34;(dev, (KernelAbstractions.NDIteration.StaticSize)(size), (KernelAbstractions.NDIteration.StaticSize)(range))
                    end
                function var&#34;##kern#339&#34;(dev::Dev, sz::S, range::NDRange) where {Dev, S &lt;: KernelAbstractions.NDIteration._Size, NDRange &lt;: KernelAbstractions.NDIteration._Size}
                    if (KernelAbstractions.isgpu)(dev)
                        return (KernelAbstractions.construct)(dev, sz, range, var&#34;gpu_##kern#339&#34;)
                    else
                        return (KernelAbstractions.construct)(dev, sz, range, var&#34;cpu_##kern#339&#34;)
                    end
                end
            end
        end
    end
    (var&#34;##kern#339&#34;(get_backend(σ), 64))(σ, u, (inside(σ))[1] - oneunit((inside(σ))[1]), ndrange = size(inside(σ)))
end
</pre></details>

<p>The best feature we achieve when modifying <code>@loop</code> to produce KA kernels is that the divergence operator remains the same as before using KA</p>
<div><div><pre><code><span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>)</span>
    <span>@loop</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>This exact approach is what has allowed WaterLily to have the same LOC as before using KA, just around 800!</p>

<h3 id="benchmarking">Benchmarking</h3>

<p>Now that we have all the items in place, we can benchmark the speedup achieved by KA compared to the serial execution using <a href="https://github.com/JuliaCI/BenchmarkTools.jl">BenchmarkTools.jl</a>.
Let’s now gather all the code we have used and create a small benchmarking MWE (see below or <a href="https://aaronstrick.com/assets/codes/WaterLily_on_GPU.zip">download it here</a>).
In this code showcase, we will refer to the serial CPU execution as “serial”, the multi-threaded CPU execution as “CPU”, and the GPU execution as “GPU”:</p>
<div><div><pre><code><span>using</span> <span>KernelAbstractions</span><span>:</span> <span>get_backend</span><span>,</span> <span>synchronize</span><span>,</span> <span>@index</span><span>,</span> <span>@kernel</span><span>,</span> <span>@groupsize</span>
<span>using</span> <span>CUDA</span><span>:</span> <span>CuArray</span>
<span>using</span> <span>BenchmarkTools</span>

<span>δ</span><span>(</span><span>d</span><span>,</span><span>::</span><span>CartesianIndex</span><span>{</span><span>D</span><span>})</span> <span>where</span> <span>{</span><span>D</span><span>}</span> <span>=</span> <span>CartesianIndex</span><span>(</span><span>ntuple</span><span>(</span><span>j</span> <span>-&gt;</span> <span>j</span><span>==</span><span>d</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>,</span> <span>D</span><span>))</span>
<span>@inline</span> <span>∂</span><span>(</span><span>a</span><span>,</span><span>I</span><span>::</span><span>CartesianIndex</span><span>{</span><span>D</span><span>},</span><span>u</span><span>::</span><span>AbstractArray</span><span>{</span><span>T</span><span>,</span><span>n</span><span>})</span> <span>where</span> <span>{</span><span>D</span><span>,</span><span>T</span><span>,</span><span>n</span><span>}</span> <span>=</span> <span>u</span><span>[</span><span>I</span><span>+</span><span>δ</span><span>(</span><span>a</span><span>,</span><span>I</span><span>),</span><span>a</span><span>]</span><span>-</span><span>u</span><span>[</span><span>I</span><span>,</span><span>a</span><span>]</span>
<span>inside</span><span>(</span><span>a</span><span>)</span> <span>=</span> <span>CartesianIndices</span><span>(</span><span>ntuple</span><span>(</span><span>i</span><span>-&gt;</span> <span>2</span><span>:</span><span>size</span><span>(</span><span>a</span><span>)[</span><span>i</span><span>]</span><span>-</span><span>1</span><span>,</span><span>ndims</span><span>(</span><span>a</span><span>)))</span>

<span># serial loop macro</span>
<span>macro</span><span> loop</span><span>(</span><span>args</span><span>...</span><span>)</span>
    <span>ex</span><span>,</span><span>_</span><span>,</span><span>itr</span> <span>=</span> <span>args</span>
    <span>op</span><span>,</span><span>I</span><span>,</span><span>R</span> <span>=</span> <span>itr</span><span>.</span><span>args</span>
    <span>@assert</span> <span>op</span> <span>∈</span> <span>(</span><span>:</span><span>(</span><span>∈</span><span>),</span><span>:</span><span>(</span><span>in</span><span>))</span>
    <span>return</span> <span>quote</span>
        <span>for</span> <span>$</span><span>I</span> <span>∈</span> <span>$</span><span>R</span>
            <span>$</span><span>ex</span>
        <span>end</span>
    <span>end</span> <span>|&gt;</span> <span>esc</span>
<span>end</span>
<span># KA-adapted loop macro</span>
<span>macro</span><span> loopKA</span><span>(</span><span>args</span><span>...</span><span>)</span>
    <span>ex</span><span>,</span><span>_</span><span>,</span><span>itr</span> <span>=</span> <span>args</span>
    <span>_</span><span>,</span><span>I</span><span>,</span><span>R</span> <span>=</span> <span>itr</span><span>.</span><span>args</span><span>;</span> <span>sym</span> <span>=</span> <span>[]</span>
    <span>grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>)</span>     <span># get arguments and replace composites in `ex`</span>
    <span>setdiff!</span><span>(</span><span>sym</span><span>,[</span><span>I</span><span>])</span> <span># don&#39;t want to pass I as an argument</span>
    <span>@gensym</span> <span>kern</span>      <span># generate unique kernel function name</span>
    <span>return</span> <span>quote</span>
        <span>@kernel</span> <span>function</span><span> $kern</span><span>(</span><span>$</span><span>(</span><span>rep</span><span>.</span><span>(</span><span>sym</span><span>)</span><span>...</span><span>),</span><span>@Const</span><span>(</span><span>I0</span><span>))</span> <span># replace composite arguments</span>
            <span>$</span><span>I</span> <span>=</span> <span>@index</span><span>(</span><span>Global</span><span>,</span><span>Cartesian</span><span>)</span>
            <span>$</span><span>I</span> <span>+=</span> <span>I0</span>
            <span>$</span><span>ex</span>
        <span>end</span>
        <span>$</span><span>kern</span><span>(</span><span>get_backend</span><span>(</span><span>$</span><span>(</span><span>sym</span><span>[</span><span>1</span><span>])),</span><span>64</span><span>)(</span><span>$</span><span>(</span><span>sym</span><span>...</span><span>),</span><span>$</span><span>R</span><span>[</span><span>1</span><span>]</span><span>-</span><span>oneunit</span><span>(</span><span>$</span><span>R</span><span>[</span><span>1</span><span>]),</span><span>ndrange</span><span>=</span><span>size</span><span>(</span><span>$</span><span>R</span><span>))</span>
    <span>end</span> <span>|&gt;</span> <span>esc</span>
<span>end</span>
<span>function</span><span> grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>::</span><span>Expr</span><span>)</span>
    <span>ex</span><span>.</span><span>head</span> <span>==</span> <span>:.</span> <span>&amp;&amp;</span> <span>return</span> <span>union!</span><span>(</span><span>sym</span><span>,[</span><span>ex</span><span>])</span>      <span># grab composite name and return</span>
    <span>start</span> <span>=</span> <span>ex</span><span>.</span><span>head</span><span>==:</span><span>(</span><span>call</span><span>)</span> <span>?</span> <span>2</span> <span>:</span> <span>1</span>              <span># don&#39;t grab function names</span>
    <span>foreach</span><span>(</span><span>a</span><span>-&gt;</span><span>grab!</span><span>(</span><span>sym</span><span>,</span><span>a</span><span>),</span><span>ex</span><span>.</span><span>args</span><span>[</span><span>start</span><span>:</span><span>end</span><span>])</span>   <span># recurse into args</span>
    <span>ex</span><span>.</span><span>args</span><span>[</span><span>start</span><span>:</span><span>end</span><span>]</span> <span>=</span> <span>rep</span><span>.</span><span>(</span><span>ex</span><span>.</span><span>args</span><span>[</span><span>start</span><span>:</span><span>end</span><span>])</span> <span># replace composites in args</span>
<span>end</span>
<span>grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>::</span><span>Symbol</span><span>)</span> <span>=</span> <span>union!</span><span>(</span><span>sym</span><span>,[</span><span>ex</span><span>])</span>        <span># grab symbol name</span>
<span>grab!</span><span>(</span><span>sym</span><span>,</span><span>ex</span><span>)</span> <span>=</span> <span>nothing</span>
<span>rep</span><span>(</span><span>ex</span><span>)</span> <span>=</span> <span>ex</span>
<span>rep</span><span>(</span><span>ex</span><span>::</span><span>Expr</span><span>)</span> <span>=</span> <span>ex</span><span>.</span><span>head</span> <span>==</span> <span>:.</span> <span>?</span> <span>Symbol</span><span>(</span><span>ex</span><span>.</span><span>args</span><span>[</span><span>2</span><span>]</span><span>.</span><span>value</span><span>)</span> <span>:</span> <span>ex</span>

<span>function</span><span> divergence!</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>)</span>
    <span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>)</span>
        <span>@loop</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
    <span>end</span>
<span>end</span>
<span>function</span><span> divergenceKA!</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>)</span>
    <span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>)</span>
        <span>@loopKA</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
    <span>end</span>
<span>end</span>

<span>N</span> <span>=</span> <span>(</span><span>2</span><span>^</span><span>8</span><span>,</span> <span>2</span><span>^</span><span>8</span><span>,</span> <span>2</span><span>^</span><span>8</span><span>)</span>
<span># CPU serial arrays</span>
<span>σ_serial</span> <span>=</span> <span>zeros</span><span>(</span><span>N</span><span>)</span>
<span>u_serial</span> <span>=</span> <span>rand</span><span>(</span><span>N</span><span>...</span><span>,</span> <span>length</span><span>(</span><span>N</span><span>))</span>
<span># CPU multi-threading arrays</span>
<span>σ_CPU</span> <span>=</span> <span>zeros</span><span>(</span><span>N</span><span>)</span>
<span>u_CPU</span> <span>=</span> <span>copy</span><span>(</span><span>u_serial</span><span>)</span>
<span># GPU arrays</span>
<span>σ_GPU</span> <span>=</span> <span>zeros</span><span>(</span><span>N</span><span>)</span> <span>|&gt;</span> <span>CuArray</span>
<span>u_GPU</span> <span>=</span> <span>copy</span><span>(</span><span>u_serial</span><span>)</span> <span>|&gt;</span> <span>CuArray</span>

<span># Benchmark warmup (force compilation) and validation</span>
<span>divergence!</span><span>(</span><span>σ_serial</span><span>,</span> <span>u_serial</span><span>)</span>
<span>divergenceKA!</span><span>(</span><span>σ_CPU</span><span>,</span> <span>u_CPU</span><span>)</span>
<span>divergenceKA!</span><span>(</span><span>σ_GPU</span><span>,</span> <span>u_GPU</span><span>)</span>
<span>@assert</span> <span>σ_serial</span> <span>≈</span> <span>σ_CPU</span> <span>≈</span> <span>σ_GPU</span> <span>|&gt;</span> <span>Array</span>

<span># Create and run benchmarks</span>
<span>suite</span> <span>=</span> <span>BenchmarkGroup</span><span>()</span>
<span>suite</span><span>[</span><span>&#34;serial&#34;</span><span>]</span> <span>=</span> <span>@benchmarkable</span> <span>divergence!</span><span>(</span><span>$</span><span>σ_serial</span><span>,</span> <span>$</span><span>u_serial</span><span>)</span>
<span>suite</span><span>[</span><span>&#34;CPU&#34;</span><span>]</span> <span>=</span> <span>@benchmarkable</span> <span>begin</span>
    <span>divergenceKA!</span><span>(</span><span>$</span><span>σ_CPU</span><span>,</span> <span>$</span><span>u_CPU</span><span>)</span>
    <span>synchronize</span><span>(</span><span>get_backend</span><span>(</span><span>$</span><span>σ_CPU</span><span>))</span>
<span>end</span>
<span>suite</span><span>[</span><span>&#34;GPU&#34;</span><span>]</span> <span>=</span> <span>@benchmarkable</span> <span>begin</span>
    <span>divergenceKA!</span><span>(</span><span>$</span><span>σ_GPU</span><span>,</span> <span>$</span><span>u_GPU</span><span>)</span>
    <span>synchronize</span><span>(</span><span>get_backend</span><span>(</span><span>$</span><span>σ_GPU</span><span>))</span>
<span>end</span>
<span>results</span> <span>=</span> <span>run</span><span>(</span><span>suite</span><span>,</span> <span>verbose</span><span>=</span><span>true</span><span>)</span>
</code></pre></div></div>

<p>In this benchmark we have used a 3D array <code>σ</code> (scalar field) instead of the 2D array used before, hence demonstrating the n-dimensional capabilities of the current methodology.
For <code>N=(2^8,2^8,2^8)</code>, the following benchmark results are achieved on a 6-core laptop equipped with an NVIDIA GeForce GTX 1650 Ti GPU card</p>
<div><div><pre><code>&#34;CPU&#34; =&gt; Trial(52.651 ms)
&#34;GPU&#34; =&gt; Trial(7.589 ms)
&#34;serial&#34; =&gt; Trial(234.347 ms)
</code></pre></div></div>
<p>The GPU executions yields a <strong>30x</strong> speed-up compared to the serial execution and 7x compared to the multi-threaded CPU execution. The multi-threaded CPU execution yields 4.5x speed-up compared to the serial execution (ideally should be 6x in the 6-core machine).
As a final note on this section, see that <code>synchronize</code> is used when running the KA benchmarks. If not used, we would only be measuring the time that it takes to launch a kernel but not to actually run it.</p>

<h3 id="challenges">Challenges</h3>

<p>Porting the whole solver to GPU has been mostly a learning exercise.
With no previous experience on software development for GPUs, KA smoothens the learning curve, so it is a great way to get started.
Of course, a lot of stuff does not just work out of the box, and we have faced some challenges while doing the port. Here are some of them.</p>

<h4 id="offset-indices-in-ka-kernels">Offset indices in KA kernels</h4>
<p>Offset indices are important for boundary-value problems where arrays may contain both the solution and the boundary conditions of a problem.
In the stencil-based finite-volume and finite-difference methods, the boundary elements are only accessed to compute the stencil, but not directly modified when looping through the solution elements of an array.
It is in this scenario where offset indices are important, for example.
KA <code>@index</code> macro only provides natural indices in Julia (starting at 1), and this minor missing feature initially derailed us into using <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays.jl</a>.
Of course this added complexity to the code, and we even observed degraded performance in some kernels.
Some time after this (more than we would like to admit), the idea of manually passing the offset index into the KA kernel took shape and quickly yield a much cleaner solution.
Thankfully, this feature will be natively supported in KA in the future (see <a href="https://github.com/JuliaGPU/KernelAbstractions.jl/issues/384">KA issue #384</a>).</p>

<h4 id="to-inline-functions-can-be-important-in-gpu-kernels">To inline functions can be important in GPU kernels</h4>
<p>In KA, GPU kernels are of course more sensitive than CPU kernels when it comes to functions that may be called within.
We have observed this sensitivity both at compilation time and at runtime.
For example, the <code>δ</code> function was originally implemented with multiple dispatch as</p>
<div><div><pre><code><span>@inline</span> <span>δ</span><span>(</span><span>i</span><span>,</span><span>N</span><span>::</span><span>Int</span><span>)</span> <span>=</span> <span>CartesianIndex</span><span>(</span><span>ntuple</span><span>(</span><span>j</span> <span>-&gt;</span> <span>j</span><span>==</span><span>i</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>,</span> <span>N</span><span>))</span>
<span>δ</span><span>(</span><span>d</span><span>,</span><span>I</span><span>::</span><span>CartesianIndex</span><span>{</span><span>N</span><span>})</span> <span>where</span> <span>{</span><span>N</span><span>}</span> <span>=</span> <span>δ</span><span>(</span><span>d</span><span>,</span> <span>N</span><span>)</span>
</code></pre></div></div>
<p>The main problem here is that this implementation is type-unstable, and without <code>@inline</code> the GPU kernel was complaining about a dynamic function (see <a href="https://github.com/JuliaGPU/KernelAbstractions.jl/issues/392">KA issue #392</a>).
Another inline-related problem can be observed with the derivative function <code>∂</code>.
When removing the <code>@inline</code> macro from its definition, the GPU performance decays significantly, and the GPU benchmark gets even with the CPU one.
This demonstrates that the compiler can do performant tricks when the information on the required instructions is not nested on external functions to the kernel.</p>

<h4 id="popular-functions-may-not-work-within-kernels">Popular functions may not work within kernels</h4>
<p>Often we use functions such as the <code>norm2</code> from LinearAlgebra.jl to compute the norm of an array.
A surprise is that some of these do not work inside a kernel since the GPU compiler may not be equipped to do so. Hence, these need to be manually written in a suitable form.
In this case, we use <code>norm2(x) = √sum(abs2,x)</code>.
Another example is the <code>sum</code> function using generator syntax such as</p>
<div><div><pre><code><span>@kernel</span> <span>function</span><span> _divergence</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>)</span>
    <span>I</span> <span>=</span> <span>@index</span><span>(</span><span>Global</span><span>,</span> <span>Cartesian</span><span>)</span>
    <span>σ</span><span>[</span><span>I</span><span>]</span> <span>=</span> <span>sum</span><span>(</span><span>u</span><span>[</span><span>I</span><span>+</span><span>δ</span><span>(</span><span>d</span><span>),</span><span>d</span><span>]</span><span>-</span><span>u</span><span>[</span><span>I</span><span>,</span><span>d</span><span>]</span> <span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>))</span>
<span>end</span>
</code></pre></div></div>
<p>which errors during compilation for a GPU kernel.
Here a solution can be to use a different form of <code>sum</code></p>
<div><div><pre><code><span>@kernel</span> <span>function</span><span> _divergence</span><span>(</span><span>σ</span><span>,</span> <span>u</span><span>)</span>
    <span>I</span> <span>=</span> <span>@index</span><span>(</span><span>Global</span><span>,</span> <span>Cartesian</span><span>)</span>
    <span>σ</span><span>[</span><span>I</span><span>]</span> <span>=</span> <span>sum</span><span>(</span><span>j</span> <span>-&gt;</span> <span>u</span><span>[</span><span>I</span><span>+</span><span>δ</span><span>(</span><span>j</span><span>),</span><span>j</span><span>]</span><span>-</span><span>u</span><span>[</span><span>I</span><span>,</span><span>j</span><span>],</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>),</span> <span>init</span><span>=</span><span>zero</span><span>(</span><span>eltype</span><span>(</span><span>σ</span><span>)))</span>
<span>end</span>
</code></pre></div></div>
<p>even though we have observed reduced performance in the latter version (more information in <a href="https://discourse.julialang.org/t/gpu-sum-closure-throwing-an-error/96658">Discourse post #96658</a>).
There are efforts in KA directed towards providing a reduction interface for kernels (see <a href="https://github.com/JuliaGPU/KernelAbstractions.jl/issues/234">KA issue #234</a>).</p>

<h4 id="limitations-of-the-automatic-kernel-generation-on-loops">Limitations of the automatic kernel generation on loops</h4>
<p>While the <code>@loop</code> macro that generates KA kernels is fairly general, it also has some limitations.
For example, it may have been noticed that we have not nested the loop over the dimensions <code>d ∈ 1:ndims(σ)</code> in the kernel.
The reason behind this is that even if turning</p>
<div><div><pre><code><span>for</span> <span>d</span> <span>∈</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>)</span>
    <span>@loop</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>+=</span> <span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>)</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
<span>end</span>
</code></pre></div></div>
<p>into</p>
<div><div><pre><code><span>@loop</span> <span>σ</span><span>[</span><span>I</span><span>]</span> <span>=</span> <span>sum</span><span>(</span><span>d</span><span>-&gt;</span><span>∂</span><span>(</span><span>d</span><span>,</span> <span>I</span><span>,</span> <span>u</span><span>),</span> <span>1</span><span>:</span><span>ndims</span><span>(</span><span>σ</span><span>))</span> <span>over</span> <span>I</span> <span>∈</span> <span>inside</span><span>(</span><span>σ</span><span>)</span>
</code></pre></div></div>
<p>would reduce the number of kernel evaluations, the limitation of the <code>sum</code> function mentioned before makes this approach not as performant as writing a kernel for each dimension.
Also related to this issue is the fact that passing more than one expression per kernel would reduce the overall number of kernel evaluations, but gluing expressions together can be not straight-forward with the current implementation of <code>@loop</code>.</p>

<h4 id="care-for-race-conditions">Care for race conditions!</h4>
<p>When moving from serial to parallel computations, race conditions are a recurring issue.
For WaterLily, this issue popped up for the linear solver used in the pressure Poisson equation.
Prior to the port, WaterLily relied on Successive Over Relaxation (SOR) method (a Gauss-Seidel-type solver) which uses (ordered) backsubstitution, hence not suitable for parallel executions.
The solution here was just to switch to a better suited solver such as the Conjugate-Gradient method.</p>

<h3 id="acknowledgements">Acknowledgements</h3>

<p>Special thanks to <a href="https://vchuravy.dev/">Valentin Churavy</a> for creating <a href="https://github.com/JuliaGPU/KernelAbstractions.jl">KernelAbstractions.jl</a> and revising this article. And, of course, <a href="https://weymouth.github.io/">Gabriel D. Weymouth</a> for creating <a href="https://github.com/weymouth/WaterLily.jl">WaterLily.jl</a> and for helping in the revising of this article too! :)</p>
</div></div>
  </body>
</html>
