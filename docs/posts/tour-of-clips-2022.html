<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ryjo.codes/tour-of-clips.html">Original</a>
    <h1>Tour of CLIPS (2022)</h1>
    
    <div id="readability-page-1" class="page"><div id="article">
        <section id="0">
          <h3>0. Introduction</h3>
          <p>
          Over the last year and a half or so, I&#39;ve been learning about the
          <a href="https://www.clipsrules.net/" target="_blank">CLIPS</a>
          programming language.
          <a href="https://clipsrules.net/AboutCLIPS.html" target="_blank">
            A team of developers at NASA
          </a> created CLIPS in the mid-&#39;80s. It was released into the public domain in the mid-&#39;90s, and
          it has been actively developed by one of the original team members
          <a href="http://www.clipsrules.net/AboutTheDeveloper.html" target="_blank">
            Gary Riley</a> ever since.
          </p>
          <p>
          CLIPS
          has this air of mystery about it. There&#39;s no npm-like
          service that centralizes common CLIPS &#34;libraries.&#34; A lot of writing
          about the language appears, on the surface, academic or higher-level.
          To top it off, the
          <a href="https://en.wikipedia.org/wiki/Rete_algorithm" target="_blank">
            Rete algorithm</a> central to CLIPS can be rather intimidating
          to wrap one&#39;s head around.
          </p>
          <p>
          Don&#39;t let these things deter you; CLIPS is well worth learning. Its Rules-based approach
          is a good primer to learning neural networks and AI.
          With this tutorial, you&#39;ll take your first steps into Rules Engines and Expert Systems.
          </p>
          <p>
          First, we&#39;ll talk about why you should consider using CLIPS. At the heart
          of CLIPS is the
          <a href="https://en.wikipedia.org/wiki/Rete_algorithm" target="_blank">
            Rete algorithm</a>.
          This algorithm does a few very nice things for us. For one, it
          determines the order in which Rules should run. This allows us to focus on
          <b>what the domain business logic is</b> of our program rather than <b>how the software runs</b>.
          Second, the Rete network &#34;caches&#34; common calculations our software will make.
          Those who have written an in-app cache understand the benefits of this feature.
          </p>
          <p>
          Another huge win for CLIPS is the excellent documentation and support provided
          by the lead developer
          <a href="http://www.clipsrules.net/AboutTheDeveloper.html" target="_blank">
            Gary Riley</a>. Take a look at the various guides of all levels linked in the
          <a href="https://clipsrules.net/#documentation" target="_blank">
            documentation section</a>
          of the CLIPS homepage. Also, Mr. Riley is very active in various forums
          providing support for CLIPS. Once again, look at the main CLIPS website
          to find links to the
          <a href="https://clipsrules.net/#support" target="_blank">
            various avenues of support</a>.
          </p>
          <p>
          Finally, CLIPS is still actively developed; its latest release 6.40 was
          published in May of 2021. Pretty incredible!
          </p>
          <h4>0.a This Tutorial</h4>
          <p>
          This tutorial is greatly inspired by the fantastic
          <a href="https://go.dev/tour/welcome/1" target="_blank">
            A Tour of Go</a>.
          Run the examples presented in this tutorial 
          by clicking the <code>(batch*)</code> button under the code.
          The code in the box is editable, so tweak the code to test your curiosity.
          The output from the code will display in the box below the buttons.
          Navigate between the previous and next Chapters by clicking the links
          at the bottom of the screen. The left link (←) will navigate you to the previous chapter
          while the right link (→) will advance to the next chapter.
          Between these two links will show the name of the current Chapter. Click that link
          to reveal a list of all Chapters in this book. Clicking one of these Chapters
          should navigate you to the appropriate Chapter.
          </p>
          <pre id="input0">; Welcome to the tutorial! This is known as a &#34;comment.&#34;
; It is meant to help developers
; understand a particular line of code better.
;
; Click the (batch*) button to run this code sample.
; You will see CLIPS code written in this area of the webpage
; throughout this tour.
;
; This is a WASM compilation of CLIPS run completely in your browser;
; no server involved!
(println &#34;Hello, world&#34;)</pre>
          <ul>
            <li></li>
            <li>0. Introduction</li>
            <li><a href="#1">1. Saying Hello →</a></li>
          </ul>
        </section>

        <section id="1">
          <h3>1. Saying Hello</h3>
          <p>
          The classic &#34;first program&#34; is the &#34;Hello, World&#34; program. This will show you how
          to output some text from your program. Click the <code>(batch*)</code> button
          under the code on the right hand side. You should see text appear in the box
          beneath the buttons.
          </p>
          <p>
          With CLIPS, there are a few ways we can print text to the screen. Using
          <code>(print)</code> will print words out, while <code>(println)</code>
          will print words out <b>with a new line at the end</b>. In the code sample
          to the right, you can see us using <code>(print)</code> to print the word
          &#34;Hello&#34;. We then use <code>(println)</code> to print &#34;, World!&#34; and a new
          line character. Things printed after this text will appear on the next line.
          </p>
          <p>
          <code>(printout t)</code> is like <code>(print)</code> and
          <code>(println)</code>, but it allows you to send text to a given &#34;router.&#34; In
          this case, we send the text to the router <code>t</code> which is what
          <code>(print)</code> and <code>(println)</code> send text to by default.
          We also use the text <code>crlf</code> as the last
          argument to <code>(printout</code>. We do this so that our text &#34;breaks&#34; at the
          end of the line; the next thing we print will appear beneath this current line.
          <code>crlf</code> stands for &#34;carriage return line feed,&#34; which means
          &#34;move the cursor to the beginning of the next line.&#34;
          </p>
          <p>
          <code>(format t)</code> allows you to
          print a sentence structure that contains &#34;format flags.&#34; The <code>%s</code>
          and <code>%n</code> are format flags that specify a string and newline
          respectively. The next argument (in this case &#34;fun&#34;) will be substituted in place
          of the <code>%s</code>. <code>%n</code> will be replaced with a new line character.
          To see more of these &#34;format flags,&#34; check out the
          <a href="https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf" target="_blank">
            Basic Programming Guide
          </a> -- specifically the section entitled <b>12.4.6 Formatted Printing</b> --
          to learn more.
          </p>
          <pre id="input1">(print Hello)
(println &#34;, World!&#34;)
(printout t &#34;Welcome to this tour of CLIPS&#34; crlf)
(format t &#34;I hope that you have %s!%n&#34; fun)</pre>
          <ul>
            <li><a href="#0">← 0. Introduction</a></li>
            <li>1. Saying Hello</li>
            <li><a href="#2">2. Learning the Rules →</a></li>
          </ul>
        </section>

        <section id="2">
          <h3>2. Learning the Rules</h3>
          <p>
          Rules are an important part of understanding how CLIPS works. Rules consist of
          an &#34;antecedent&#34; and a &#34;consequent.&#34; The antecedent is also known as the &#34;if
          portion&#34; or the &#34;left-hand side.&#34; This part consists of the conditions that must
          be satisfied for the Rule to run.
          </p>
          <p>
          The consequent is also known as the &#34;then portion&#34; or the &#34;right-hand side.&#34; This
          part describes what will happen when the Rule is run.
          </p>
          <p>These two pieces are separated by a <code>=&gt;</code>. The antecedent is
          before this symbol while the consequent is after it.
          </p><p>
          In this example, we define a Rule called <code>will-run-no-matter-what</code>.
          This particular Rule has nothing on the left-hand side so it will always run.
          The right-hand side specifies that a <code>(println)</code> will run.
          </p>
          <p>
          Finally after the Rule is defined, there is a <code>(run)</code>. In order for
          this to work, click the <code>(batch*)</code> button.
          </p>

          <pre id="input2">(defrule will-run-no-matter-what
      =&gt;
      (println &#34;Hello from a rule, world!&#34;))
(run)</pre>
          <ul>
            <li><a href="#1">← 1. Saying Hello</a></li>
            <li>2. Learning the Rules</li>
            <li><a href="#3">3. Just the Facts →</a></li>
          </ul>
        </section>

        <section id="3">
          <h3>3. Just the Facts</h3>
          <p>
          In addition to Rules in CLIPS, we have &#34;Facts.&#34; A Fact represents &#34;data&#34; in CLIPS.
          In order to put data into CLIPS, we <code>(assert)</code>. Once we have
          <code>(assert)</code>ed Facts, they are said to be &#34;in working memory.&#34;
          </p>
          <p>
          In the code to the right, we <code>(assert)</code> one <code>(name</code> Fact with
          <code>ryjo</code> in its second field.
          </p>
          <p>
          We then print a single line of text with our old friend <code>(println)</code>.
          </p>
          <p>
          <code>(facts)</code> is a new one. We use this to print out the Facts stored in
          Working Memory. In this case, we see 1 fact printed with an index <code>1</code>
          as denoted by <code>f-1</code>.
          </p>
          <p>
          Finally, we&#39;ll <code>(retract</code> this Fact that we just asserted. We can reference
          this Fact with its index <code>1</code>.
          </p>
          <p>
          Note: If you click <code>(batch*)</code> multiple times in a row, an error will appear.
          This is because we must <code>(reset)</code> or <code>(clear)</code> the environment to
          reset the ids assigned to Facts in Working Memory. If we do not, the Fact that we assert will
          have an id of <code>2</code>, not <code>1</code>. If you click <code>(reset)</code> or
          <code>(clear)</code> and then click <code>(batch*)</code> again, the code will behave
          as expected.
          </p>
          <p>
          <b>Bonus</b>: if you are returning to this Chapter after completing
          <a href="#5">Chapter 5</a>, you may see a few more than 1 Fact returned. That&#39;s because
          we do not <code>(clear)</code> at the top of the code to first &#34;clean up&#34; the environment.
          You&#39;ll learn more about <code>(clear)</code> in <a href="#18">Chapter 18</a>.
          </p>
          <pre id="input3">(assert (name ryjo))
(println &#34;The current facts: &#34;)
(facts)
(retract 1)
(println &#34;After retracting: &#34;)
(facts)</pre>
          <ul>
            <li><a href="#2">← 2. Learning the Rules</a></li>
            <li>3. Just the Facts</li>
            <li><a href="#4">4. Running the Engine →</a></li>
          </ul>
        </section>

        <section id="4">
          <h3>4. Running the Engine</h3>
          <p>
          The &#34;Facts&#34; stored in &#34;Working Memory&#34; can be used to satisfy the
          LHS (left-hand side) of a rule. Remember: when the LHS of a Rule
          is satisfied, the Rule&#39;s RHS (right-hand side) will run.
          </p>
          <p>
          In the code to the right, we create a Rule using <code>(defrule)</code>
          called <code>greet</code>. This Rule will &#34;activate&#34; when a Fact that matches
          the form <code>(name ?)</code> is entered into Working Memory. Once we
          <code>(run)</code> the rules engine, the Right Hand side of this Rule will run
          if a <code>name</code> Fact exists in the system with a second field.
          </p>
          <p>
          Next, we <code>(assert)</code> a <code>name</code> Fact with the value
          <code>ryjo</code> in its second field. Once we do this, the <code>greet</code>
          rule is &#34;activated;&#34; when we <code>(run)</code> our Rules Engine next,
          this Rule&#39;s RHS will be executed.
          </p>
          <p>
          <b>Bonus</b>: if you are returning to this Chapter after completing
          <a href="#5">Chapter 5</a>, you may see a few more than 1 greeting. That&#39;s because
          we do not <code>(clear)</code> at the top of the code to first &#34;clean up&#34; the environment.
          You&#39;ll learn more about <code>(clear)</code> in <a href="#18">Chapter 18</a>.
          </p>
          <pre id="input4">(defrule greet
      (name ?name)
      =&gt;
      (println &#34;Hello &#34; ?name &#34;!&#34;))
(assert (name ryjo))
(run)</pre>
          <ul>
            <li><a href="#3">← 3. Just the Facts</a></li>
            <li>4. Running the Engine</li>
            <li><a href="#5">5. Negative, Ghostrider →</a></li>
          </ul>
        </section>

        <section id="5">
          <h3>5. Negative, Ghostrider</h3>
          <p>
          Sometimes you want to activate a Rule when there is a Fact in Working Memory
          that does not match a certain pattern. The tilde (<code>~</code>) character
          is used to negate a given pattern. It&#39;s like saying &#34;a Fact that does not have
          this here.&#34;
          </p>
          <p>
          Note that we are not able to use the non-matching names in the RHS of this Rule
          like we did in
          <a href="#4">Chapter 4</a>. We&#39;ll cover how to use these names in
          <a href="#6">Chapter 6</a>.
          </p>
          <p> 
          First, we <code>(clear)</code> our environment of all previously defined
          Rules and Facts from the CLIPS Environment. We then <code>(assert</code> two
          <code>(name</code>s: <code>Zach</code> and <code>Zethus</code>. Finally, our
          Rule <code>non-ryjos-only</code> will &#34;activate&#34; when a Fact matching the pattern
          <code>(name ~ryjo)</code> enters working memory. This pattern might be read in English
          as &#34;a Fact that starts with <code>name</code> and does not have <code>ryjo</code> in
          its second field.&#34; Finally, the RHS of this Rule prints the text &#34;Hello, not ryjo!&#34;
          </p>
          <p>
          <b>Bonus:</b> After you <code>(batch*)</code> this code, try navigating to
          <a href="#4">Chapter 4</a>; you&#39;ll see that the previously defined
          <code>greet</code> Rule runs for these two new names. That&#39;s because the examples
          in this tutorial use the same CLIPS Environment. In this example, we use
          <code>(clear)</code> at the top which removes everything defined in previous examples.
          You will see this convention more in following chapters.
          </p>
          <pre id="input5">(clear)

(assert (name Zach) (name Zethus))

(defrule non-ryjos-only
  (name ~ryjo)
  =&gt;
  (println &#34;Hello, not ryjo!&#34;))

(run)</pre>
          <ul>
            <li><a href="#4">← 4. Running the Engine</a></li>
            <li>5. Negative, Ghostrider</li>
            <li><a href="#6">6. Capturing the Name →</a></li>
          </ul>
        </section>

        <section id="6">
          <h3>6. Capturing the Name</h3>
          <p>
          Now we&#39;ll combine two previously presented concepts using a <code>&amp;</code>.
          First, we&#39;ll capture the value in the first field
          with <code>?n</code> (<a href="#4">Chapter 4</a>). Next, we&#39;ll specify &#34;not ryjo&#34; with
          <code>~</code> (<a href="#5">Chapter 5</a>).
          The <code>&amp;</code> symbol acts as an &#34;and.&#34; We can read the pattern
          <code>(name ?n&amp;~ryjo)</code> as &#34;a value and it is not ryjo.&#34;
          </p>
          <p>
          Additionally, we <code>(assert)</code> three facts. Only two of them will
          &#34;activate&#34; the <code>non-ryjos-only</code> rule we define right below it.
          Something neat to make note of: we only need to call <code>(assert)</code>
          once in order to put three new Facts into Working Memory.
          </p>
          <p>
          We define a second rule <code>ryjo</code> here to demonstrate the &#34;opposite&#34;
          of the <code>non-ryjos-only</code> rule. This will activate when a Fact
          enters Working Memory that looks exactly like <code>(name ryjo)</code>.
          </p>
          <p>
          Note how the Rules in this example don&#39;t execute in the order in which they were written.
          The reason for this is <b>the order in which Rules are run is determined algorithmically</b>.
          Read more about how CLIPS determines the order in which Rules are run in section
          <b>5.2 Basic Cycle Of Rule Execution</b> of the
          <a href="https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf" target="_blank">
            Basic Programming Guide
          </a>.
          We can use <code>(salience</code> to explicitly declare the order in which Rules run.
          We&#39;ll discuss this in <a href="#15">Chapter 15</a>.
          </p>
          <pre id="input6">(clear)

(assert
  (name Gabe)
  (name ryjo)
  (name John))

(defrule non-ryjos-only
  (name ?n&amp;~ryjo)
  =&gt;
  (println &#34;Hello, &#34; ?n &#34;!&#34;))

(defrule ryjo
  (name ryjo)
  =&gt;
  (println &#34;Oh hey there&#34;))

(run)</pre>
          <ul>
            <li><a href="#5">← 5. Negative, Ghostrider</a></li>
            <li>6. Capturing the Name</li>
            <li><a href="#7">7. And/Or →</a></li>
          </ul>
        </section>

        <section id="7">
          <h3>7. And/Or</h3>
          <p>
          We can make use of &#34;Connective Constraints&#34; to better refine the LHS of our Rules.
          For example, in the Rule <code>ors</code> in the code editor, we match on a Fact
          whose second field matches either <code>Gabe</code> or <code>Peter</code>. This can
          be read as &#34;A <code>name</code> Fact whose first field we store the variable
          <code>?name</code> and matches either <code>Gabe</code> or <code>Peter</code>.&#34;
          </p>
          <p>
          In the <code>and-nots</code> Rule, we store the second field of a <code>name</code>
          Fact in the variable <code>?name</code>. This time, we say
          &#34;the value in the first field cannot match <code>ryjo</code> and it cannot match
          <code>Zach</code> and it cannot match <code>Zethus</code>.&#34;
          </p>
          <pre id="input7">(clear)

(assert
  (name Gabe)
  (name ryjo)
  (name John)
  (name Zach)
  (name Zethus)
  (name Peter))

(defrule ors
  (name ?name&amp;Gabe|Peter)
  =&gt;
  (println &#34;Greetings, &#34; ?name))

(defrule and-nots
  (name ?name&amp;~ryjo&amp;~Zach&amp;~Zethus)
  =&gt;
  (println &#34;Hi there, &#34; ?name))

(run)</pre>
          <ul>
            <li><a href="#6">← 6. Capturing the Name</a></li>
            <li>7. And/Or</li>
            <li><a href="#8">8. Predicate Constraints →</a></li>
          </ul>
        </section>

        <section id="8">
          <h3>8. Predicate Constraints</h3>
          <p>
          Predicate Constraints sound fancy, but they&#39;re pretty straight forward. Basically
          they allow you to further specify what value a field holds.
          For example, with our current knowledge, we can specify <i>exact</i> matches for
          values such as <code>(name ?n&amp;ryjo)</code>. Predicate Conditions allow us to
          perform a function on the value to determine if it matches.
          </p>
          <p>
          In our code example for this chapter, we write a basic Rule that describes a rule
          that allows entry into a bar. In the United States of America, we require a person
          to be 21 years of age or older. If they are under 21 years of age, they are not
          allowed into a bar.
          </p>
          <p>
          Note the familiar form of <code>?variable&amp;</code>. We use the <code>and</code>
          symbol here (<code>&amp;</code>) to signify that <code>?variable</code> must match
          certain criteria. This allows us to read this as &#34;the age of a person and it is
          greater than or equal to 21&#34; in the <code>allow-entry-to-bar</code> Rule.
          </p>
          <p>
          Also note that we make use of 2 different Facts in Working Memory to
          activate our rules: the <code>name</code> and <code>age</code> Facts. Also note
          that in the LHS of our Rules, we specify that the first field of these Facts must
          match by using <code>?person</code> in both. Since <code>?person</code> is used
          in both of these conditions, we say that this Rule is &#34;activated&#34; when these Facts
          have the same value in their first field.
          </p>
          <p>
          For example, the <code>(name ryjo)</code> Fact and the <code>(age ryjo 32)</code>
          Fact will activate the <code>allow-entry-to-bar</code> Rule together. Both the
          value in the first field match for these Facts <i>and</i> the number 32 is
          greater than or equal to 21. The Facts <code>(name ryjo)</code> and
          <code>(age someone 20)</code> will not activate the <code>no-entry-to-bar</code>
          Rule. The number <code>20</code> is indeed less than 21, but these two Facts
          will not activate the Rule together. However, the 2 Facts
          <code>(name someone)</code> and <code>(age someone 20)</code> will. Not only is
          <code>20</code> less than <code>21</code> as noted in the Predicate Condition
          <code>(&gt;= ?a 21)</code>, but the Symbol <code>someone</code> matches in both Facts.
          </p>
          <pre id="input8">(clear)

(defrule allow-entry-to-bar
  (name ?person)
  (age ?person ?a&amp;:(&gt;= ?a 21))
  =&gt;
  (println ?person &#34; is over 21 years old and can enter the bar!&#34;))

(defrule no-entry-to-bar
  (name ?person)
  (age ?person ?a&amp;:(&lt; ?a 21))
  =&gt;
  (println ?person &#34; is not allowed in (under 21).&#34;))

(assert
  (name ryjo) (age ryjo 32)
  (name someone) (age someone 20))

(run)</pre>
          <ul>
            <li><a href="#7">← 7. And/Or</a></li>
            <li>8. Predicate Constraints</li>
            <li><a href="#9">9. Test Conditional →</a></li>
          </ul>
        </section>

        <section id="9">
          <h3>9. Test Conditional</h3>
          <p>
          This example looks like the previous section. Instead of using <code>&amp;:</code>,
          we define our constraints using the <code>(test</code> Conditional Element.
          </p>
          <p>
          The output for this example should look very similar to last example&#39;s.
          </p>
          <pre id="input9">(clear)

(defrule allow-entry-to-bar
  (name ?person)
  (age ?person ?a)
  (test (&gt;= ?a 21))
  =&gt;
  (println ?person &#34; is over 21 years old and can enter the bar!&#34;))

(defrule no-entry-to-bar
  (name ?person)
  (age ?person ?a)
  (test (&lt; ?a 21))
  =&gt;
  (println ?person &#34; is not allowed in (under 21).&#34;))

(assert
  (name ryjo) (age ryjo 32)
  (name someone) (age someone 20))

(run)</pre>
          <ul>
            <li><a href="#8">← 8. Predicate Constraints</a></li>
            <li>9. Test Conditional</li>
            <li><a href="#10">10. One forall →</a></li>
          </ul>
        </section>

        <section id="10">
          <h3>10. One forall</h3>
          <p>
          Sometimes you want to know if all Facts in Working Memory match a given pattern.
          <code>(forall</code> provides this check. In our example, <code>(forall</code> will
          match if every <code>(name</code>
          Fact in working memory can be matched with an <code>(age</code> Fact
          (and vice versa).
          </p>
          <p>
          In our example, the Fact <code>(name another)</code>
          does not have an <code>(age</code> Fact with a matching value <code>?n</code>.
          Therefore, our Engine tells us that the &#34;Roster has been declined.&#34;
          </p>
          <pre id="input10">(clear)

(assert
  (name ryjo) (age ryjo 32)
  (name someone) (age someone 20)
  (name another))

(defrule accept-roster
  (forall (name ?n) (age ?n ?))
  =&gt;
  (println &#34;Roster has been accepted&#34;))

(defrule decline-roster
  (not (forall (name ?n) (age ?n ?)))
  =&gt;
  (println &#34;Roster has been declined&#34;))

(run)</pre>
          <ul>
            <li><a href="#9">← 9. Test Conditional</a></li>
            <li>10. One forall</li>
            <li><a href="#11">11. Aliens exists →</a></li>
          </ul>
        </section>

        <section id="11">
          <h3>11. Aliens exists</h3>
          <p>
          This is a bit of a longer example, but it showcases a few things combined together.
          <code>(exists</code> will match once if a Fact in Working Memory matches
          the pattern within. It will not run again while the condition continues to match.
          In our example, we match for &#34;any fact that starts with <code>(age</code> and is
          followed with two values.&#34; When we use <code>?</code>, it doesn&#39;t matter what these
          values are; it only matters that they are there at all.
          </p>
          <p>
          Try modifying our <code>any-age-reported</code> Rule to capture the <code>?name</code>
          and <code>(println ?name)</code> it in the RHS of the Rule.
          </p><p>
          We also use <code>(forall</code> to determine when every user has reported their age.
          </p>
          <p>
          It may seem strange to give up control of our code&#39;s order of execution. Remember, this
          lets us focus on our Business Logic rather than Control Flow of our domain.
          Make sure to review the section <b>Performance Considerations</b> in the
          <a href="https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf" target="_blank">
            Basic Programming Guide
          </a> to learn how to write code in harmony with this approach.
          </p>
          <pre id="input11">(clear)

(defrule any-age-reported
  (exists (age ? ?))
  =&gt;
  (println &#34;Users have begun to report their age&#34;))

(defrule no-ages-reported
  (not (age ? ?))
  =&gt;
  (println &#34;No user has reported their age yet...&#34;))

(defrule reported-age
  (name ?n)
  (age ?n ?a)
  =&gt;
  (format t &#34;%s has reported their age: %d%n&#34; ?n ?a))

(defrule has-not-reported-age
  (name ?n)
  (not (age ?n ?))
  =&gt;
  (println ?n &#34; has not yet reported their age&#34;))

(defrule all-ages-reported
  (forall (name ?n) (age ?n ?))
  =&gt;
  (println &#34;Everyone in the system has reported their age&#34;))

(assert
  (name ryjo)
  (name someone)
  (name another))

(println &#34;First run results:&#34;)
(println &#34;------------------&#34;)
(run)
(println &#34; &#34;)

(assert (age ryjo 32))

(println &#34;Second run results:&#34;)
(println &#34;-------------------&#34;)
(run)
(println &#34; &#34;)

(assert (age someone 20)
        (age another 52))

(println &#34;Third run results:&#34;)
(println &#34;------------------&#34;)
(run)</pre>
          <ul>
            <li><a href="#10">← 10. One forall</a></li>
            <li>11. Aliens exists</li>
            <li><a href="#12">12. Do you read(line) me? →</a></li>
          </ul>
        </section>

        <section id="12">
          <h3>12. Do you read(line) me?</h3>
          <p>
          Sometime you want to take input from the user rather than
          &#34;hard-code&#34; their name, age, and other details. We can take input from the user
          using <code>(readline)</code>.
          </p>
          <p>
          In this example, we take input from the user, then we tell them what they entered.
          Note: when you run this example, a prompt will pop up on your screen. Enter your
          text into the field, then click the &#34;OK&#34; button.
          </p>
          <p>
          Similarly, <code>(read)</code> will take the input from a user, but it&#39;ll only take
          a single word. Change <code>(readline)</code> to <code>(read)</code> in the code editor.
          If you enter &#34;foo bar 123&#34; into the text box and then click the &#34;OK&#34; button,
          it&#39;ll only echo out &#34;foo.&#34;
          </p>
          <pre id="input12">(clear)

; replace (readline) with (read) and note the differences
(println &#34;You entered: &#34; (readline))

(run)</pre>
          <ul>
            <li><a href="#11">← 11. Aliens exists</a></li>
            <li>12. Do you read(line) me?</li>
            <li><a href="#13">13. Say the secret word →</a></li>
          </ul>
        </section>

        <section id="13">
          <h3>13. Say the secret word</h3>
          <p>
          <b>Be warned:</b> note that there is a line commented out in this example.
          If you uncomment this line, the pop-up prompt will continue to show until you enter
          the word <code>secret</code>.
          </p>
          <p>
          The reason that this loop occurs is because we <code>(retract</code> the <code>(word</code> Fact
          which we captured as <code>?f</code> in the LHS of the <code>user-did-not-say-secret</code>
          Rule. This triggers the pattern <code>(not (word ?))</code> in the <code>get-word-from-user</code>
          which is the absence of a <code>(word</code> Fact with one field in Working Memory.
          </p>
          <p>
          This example is a little more complex, but it provides a good example of a way
          in which you can &#34;validate&#34; user input. This is not the <i>only</i> way, mind you.
          It is, however, a good example of how the &#34;main loop&#34; of a program can be made
          using only Rules and Facts.
          </p>
          <pre id="input13">(clear)

(defrule get-word-from-user
  ;uncommenting this line will cause a prompt to popup
  ;until you enter &#34;secret&#34; in the textbox ;)
  ;(not (word ?))
  =&gt;
  (print &#34;Enter your word: &#34;)
  (bind ?word (read))
  (println ?word)
  (assert (word ?word)))

(defrule user-said-secret
  (word secret)
  =&gt;
  (println &#34;You said the secret word! Great job&#34;))

(defrule user-did-not-say-secret
  ?f &lt;- (word ~secret)
  =&gt;
  (retract ?f)
  (println &#34;Try again...&#34;))

(run)</pre>
          <ul>
            <li><a href="#12">← 12. Do you read(line) me?</a></li>
            <li>13. Say the secret word</li>
            <li><a href="#14">14. So many words →</a></li>
          </ul>
        </section>

        <section id="14">
          <h3>14. So many words</h3>
          <p>
          The <code>(readline)</code> function will capture user input and return a string.
          If the user&#39;s input has any spaces between words, we can use <code>(explode$</code>
          to break the input up into a &#34;multifield value.&#34; This lets us define patterns in our Rules
          that will match on individual words entered by the user.
          </p>
          <p>
          Take a look at the Rule <code>first-word-one</code>. This Rule will activate when
          the first word entered by the user is &#34;<b>one</b>.&#34; Similarly, the Rule
          <code>last-word-last</code> will activate when the last word entered is &#34;<b>last</b>.&#34;
          </p>
          <p>
          The <code>anywhere</code> Rule will trigger if &#34;<b>anywhere</b>&#34; is entered anywhere
          in the prompt. The <code>$?</code> will match for any number of words. For example,
          we see in the <code>counter</code> Rule the pattern <code>(exploded-words $?words)</code>.
          This means &#34;match any number of values and reference them as a &#34;multifield value&#34; <code>?words</code>.
          Just like <code>?</code>,
          <code>$?</code> allows us to say &#34;match on any number of fields&#34; without referencing it
          in the RHS.
          </p>
          <p>
          Speaking of the <code>counter</code> Rule: take a look at <code>(length$ ?words)</code>.
          As you may have guessed, <code>(length$</code> will return the number of values in the
          multifield value passed to it. In this case, it returns the number of words (as referenced
          by <code>?words</code>) entered by the user in the prompt.
          </p>
          <pre id="input14">(clear)

(defrule get-words-from-user
  =&gt;
  (assert (words (readline))))

(defrule catcher
  (words ?words)
  =&gt;
  (println &#34;You said: &#34; ?words)
  (assert (exploded-words (explode$ ?words))))

(defrule counter
  (exploded-words $?words)
  =&gt;
  (println &#34;That&#39;s &#34; (length$ ?words) &#34; words total.&#34;))

(defrule silence
  (exploded-words)
  =&gt;
  (println &#34;Ah, the strong silent type...&#34;))

(defrule first-word-one
  (exploded-words one $?words)
  =&gt;
  (println &#34;Your first word was &#39;one&#39;&#34;))

(defrule last-word-last
  (exploded-words $?words last)
  =&gt;
  (println &#34;Your last word was &#39;last&#39;&#34;))

(defrule anywhere
  (exploded-words $? anywhere $?)
  =&gt;
  (println &#34;At some point, you typed &#39;anywhere&#39;&#34;))

(run)</pre>
          <ul>
            <li><a href="#13">← 13. Say the secret word</a></li>
            <li>14. So many words</li>
            <li><a href="#15">15. Prominently salient →</a></li>
          </ul>
        </section>

        <section id="15">
          <h3>15. Prominently salient</h3>
          <p>
          By using <code>(declare (salience</code> in our Rule, we can specify the
          &#34;priority&#34; of a Rule. This allows us to declare that <b>some Rules must
          always run before others</b>. We &#34;hard-code&#34; the execution order for
          our rules, and the Rete algorithm builds around it.
          </p>
          <p>
          Rules have a salience of <code>0</code> by default. Rules with a salience
          greater than <code>0</code> will execute before them. Similarly, Rules with a
          lower salience will execute after them.
          According to the
          <a href="https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf" target="_blank">
            Basic Programming Guide</a>, this feature should be used sparingly:
          </p><blockquote cite="https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf">
            <p>
            Despite the large number of possible values, with good design there&#39;s rarely a need for more than
            five salience values in a simple program and ten salience values in a complex program.
            </p>
          </blockquote>
          <p>
          For the most part, a Rules Engine should be order independent. This allows CLIPS
          to do the &#34;heavy lifting&#34; of determining when Rules run.
          This is subtle, but rather powerful. With Rules, you do not &#34;pass&#34; values into
          a &#34;function&#34; that runs and returns a value. Instead, the algorithm &#34;activates&#34;
          Rules based on &#34;matched&#34; Facts in Working Memory. This decouples the data stored in your system
          (Facts) from the business logic (Rules).
          </p>
          <p>
          This decoupling can help express the domain you&#39;re modeling with less references
          to the &#34;control flow&#34; of the software. The more transparent the software, the closer your system
          brings the user to the &#34;truth&#34; of your domain.
          </p>
          <pre id="input15">(clear)

(defrule third
  (declare (salience 0))
  ?f &lt;- (my-fact)
  =&gt;
  (println &#34;Last!&#34;)
  (retract ?f))

(defrule never-runs
  (declare (salience -1))
  (my-fact)
  =&gt;
  (println &#34;:(&#34;))

(defrule first
  (declare (salience 2))
  (my-fact)
  =&gt;
  (println &#34;First!&#34;))

(defrule second
  (declare (salience 1))
  (my-fact)
  =&gt;
  (println &#34;Second!&#34;))

(assert (my-fact))

(run)</pre>
          <ul>
            <li><a href="#14">← 14. So many words</a></li>
            <li>15. Prominently salient</li>
            <li><a href="#16">16. What&#39;s your function? →</a></li>
          </ul>
        </section>

        <section id="16">
          <h3>16. What&#39;s your function?</h3>
          <p>
          Functions allow you to reference chunks of code
          that you write repeatedly throughout your program.
          If we were writing a book, we may find it easier to &#34;wrap&#34; text that has been
          spoken in quotes as well as a reference to the speaker.
          We do the same for shouting.
          </p>
          <p>
          We can also store difficult-to-remember formulas as Functions.
          Personally, I have trouble remembering the formula for converting
          fahrenheit to celsius. With the help of <code>deffunction</code>, I can
          store this calculation and reference it easily.
          </p>
          <p>
          Take note of the <code>(*</code>, <code>(-</code> and <code>(/</code>
          functions. These are basic math operations: multiplication, subtraction
          and division. In CLIPS, we write the math problem <code>1 + 2</code> as
          <code>(+ 1 2)</code>. That&#39;s because CLIPS uses a &#34;LISP-like&#34; syntax.
          </p>
          <pre id="input16">(clear)

(deffunction say (?words)
  (println &#34;You say, \&#34;&#34; ?words &#34;.\&#34;&#34;))

(say &#34;Hello, world&#34;)

(deffunction shout (?words)
  (println &#34;\&#34;&#34; ?words &#34;!\&#34; you shout.&#34;))

(shout &#34;Hello, world&#34;)&#39;

(deffunction fahrenheit-to-celsius (?f)
  (* (- ?f 32) (/ 5 9) ))

(println &#34;50°F is &#34; (fahrenheit-to-celsius 50) &#34;°C&#34;)</pre>
          <ul>
            <li><a href="#15">← 15. Prominently salient</a></li>
            <li>16. What&#39;s your function?</li>
            <li><a href="#17">17. Templatize me →</a></li>
          </ul>
        </section>

        <section id="17">
          <h3>17. Templatize me</h3>
          <p>
          Templates are used to define a formal structure for Facts. By using
          <code>(deftemplate person</code> in our example, we describe
          the structure of a <code>(person</code> Fact. We wrote Facts
          as lists of values in previous Chapters. We would describe these Facts as having ordered
          &#34;fields.&#34;
          <code>(person Sally &#34;Hi&#34;)</code> would describe a <code>(person</code>
          Fact with the values <code>Sally</code> in its second field
          and <code>&#34;Hi&#34;</code> in its third field.
          </p>
          <p>
          With Templates, we are no longer bound to storing people&#39;s information
          in a particular order. Instead, we store values in named &#34;Slots.&#34;
          For example, we can choose to define our Fact as
          <code>(person (greeting &#34;Hi&#34;) (name Sally))</code>, greeting first. We can also
          define &#34;default&#34; values for these named slots and omit them in
          asserted Facts.
          </p>
          <p>
          Using Templates gives us some flexibility in how we define our Facts as well as
          how we write the matching patterns in the LHS of our Rules.
          Take a look at the Rule <code>people-greet-each-other</code>. Our second
          pattern matches &#34;a person whos name is not <code>?name1</code>.&#34; We
          do not need to include a reference to this Fact&#39;s <code>(greeting</code>
          Slot in this Rule, so we can omit it.
          </p>
          <p>
          You&#39;ll also notice we define a default value for <code>(greeting</code>
          in the Template&#39;s definition. There are many other ways to describe a
          Slot besides <code>default</code>. Take a look at the
          <a href="https://clipsrules.sourceforge.io/documentation/v640/bpg.pdf" target="_blank">
            Basic Programming Guide</a> in the section
          titled &#34;Deftemplate Construct&#34; to learn what these are.
          </p>
          <pre id="input17">(clear)

(deftemplate person
  (slot name)
  (slot greeting (default Hello)))

(assert
  (person (name Greg))
  (person (name Sally) (greeting Hi))
  (person (name Sam) (greeting Howdy)))

(deffunction greet (?name1 ?name2 ?greeting)
  (println ?name1 &#34; says \&#34;&#34; ?greeting &#34;\&#34; to &#34; ?name2 &#34;.&#34;))

(defrule people-greet-each-other
  (person (name ?name1) (greeting ?greeting1))
  (person (name ?name2&amp;~?name1))
  =&gt;
  (greet ?name1 ?name2 ?greeting1))

(run)</pre>
          <ul>
            <li><a href="#16">← 16. What&#39;s your function?</a></li>
            <li>17. Templatize me</li>
            <li><a href="#18">18. Clearly resetting →</a></li>
          </ul>
        </section>

        <section id="18">
          <h3>18. Clearly resetting</h3>
          <p>
          Let&#39;s talk about <code>(clear)</code> and <code>(reset)</code>.
          We&#39;re familiar with <code>(clear)</code> which makes our
          environment like new again. No more Rules, no more Facts.
          </p>
          <p>
          <code>(reset)</code> does a little less.
          It retracts all Facts in your system and Rule
          activations while leaving the Rules themselves defined. In this way, you can
          use <code>(reset)</code> to return your Engine to a known default &#34;state&#34; before
          running it again with new input.
          </p>
          <p>
          What happens if we need some Facts asserted to return to the &#34;default&#34; state?
          Introducing <code>(deffacts</code>.
          When you use <code>(reset)</code>, the Facts defined in
          your <code>(deffacts</code> will be asserted. Consider the example in this chapter
          and its output. On the first run, we <code>(assert</code> 2 more fruit Facts
          than in the second. As a result, we see two more people eat their favorite
          fruit.
          </p>
          <pre id="input18">(clear)

(deffacts fruits
  (fruit apple 1)
  (fruit banana 1)
  (fruit orange 1))

(deftemplate person
  (slot name)
  (slot favorite-fruit))

(deffacts people
  (person (name Tom) (favorite-fruit apple))
  (person (name Jenna) (favorite-fruit orange))
  (person (name Rian) (favorite-fruit apple)))

(defrule people-eat-favorite-fruits
  (person (name ?name) (favorite-fruit ?fruit))
  ?f &lt;- (fruit ?fruit ?id)
  =&gt;
  (println ?name &#34; eats &#34; ?fruit)
  (retract ?f))

(defrule persons-favorite-fruit-missing
  (person (name ?name) (favorite-fruit ?fruit))
  (not (fruit ?fruit ?))
  =&gt;
  (format t &#34;There&#39;s no more of %s&#39;s favorite fruit %s!%n&#34; ?name ?fruit))

(reset)

(assert (fruit apple 2) (fruit orange 2))

(println &#34;Run 1:&#34;)
(println &#34;------&#34;)
(run)

(println &#34; &#34;)
(reset)

(println &#34;Run 2:&#34;)
(println &#34;------&#34;)
(run)</pre>
          <ul>
            <li><a href="#17">← 17. Templatize me</a></li>
            <li>18. Clearly resetting</li>
            <li><a href="#19">19. Who watches the statistics? →</a></li>
          </ul>
        </section>

        <section id="19">
          <h3>19. Who watches the statistics?</h3>
          
<pre id="input19">(clear)
(watch statistics)

(defrule fibonacci
  ?fact &lt;- (fib ?fib ?lastfib ?i&amp;:(&gt; ?i 1))
  =&gt;
  (print ?fib &#34; &#34;)
  (retract ?fact)
  (assert (fib (+ ?fib ?lastfib) ?fib (- ?i 1))))

(defrule last-fibonacci-number
  ?fact &lt;- (fib ?fib ? 1)
  =&gt;
  (println ?fib)
  (retract ?fact))

(assert (fib 1 0 10))

(run)
(unwatch statistics)</pre>
          <ul>
            <li><a href="#18">← 18. Clearly resetting</a></li>
            <li>19. Who watches the statistics?</li>
            <li><a href="#20">20. Rules: Activate! →</a></li>
          </ul>
        </section>

        <section id="20">
          <h3>20. Rules: Activate!</h3>
          
<pre id="input20">(clear)
(watch activations)

(defrule b-exists-and-a-less-than-1
   (b ?b)
   (a ?a&amp;:(&lt; ?a 1))
   =&gt;
   (println &#34;there is b = &#34; ?b &#34;, AND a &#34; ?a &#34; is less than 1&#34;))

(defrule a-less-than-1
   (a ?a&amp;:(&lt; ?a 1))
   =&gt;
   (println &#34;a &#34; ?a &#34; is less than 1&#34;))

(println &#34;  Step 1  &#34;)
(println &#34;==========&#34;)
(println &#34;--- assert&#34;)
(assert (a 2))
(println &#34;------ run&#34;)
(run)
(println &#34; &#34;)

(println &#34;  Step 2  &#34;)
(println &#34;==========&#34;)
(println &#34;--- assert&#34;)
(assert (a 0))
(println &#34;------ run&#34;)
(run)
(println &#34; &#34;)

(println &#34;  Step 3  &#34;)
(println &#34;==========&#34;)
(println &#34;--- assert&#34;)
(assert (b foo) (a -1) (a 3))
(println &#34;------ run&#34;)
(run)
(unwatch activations)</pre>
          <ul>
            <li><a href="#19">← 19. Who watches the statistics?</a></li>
            <li>20. Rules: Activate!</li>
            <li><a href="#21">21. Watching functions →</a></li>
          </ul>
        </section>

        <section id="21">
          <h3>21. Watching functions</h3>
          
<pre id="input21">(clear)
(watch deffunctions)

(deffunction less-than-1 (?a)
   (println &#34;calculating whether &#34; ?a &#34; is less than 1...&#34;)
   (&lt; ?a 1))

(defrule b-exists-and-a-less-than-1
   (b ?b)
   (a ?a&amp;:(less-than-1 ?a))
   =&gt;
   (println &#34;there is b = &#34; ?b &#34;, AND a &#34; ?a &#34; is less than 1&#34;))

(defrule a-less-than-1
   (a ?a&amp;:(less-than-1 ?a))
   =&gt;
   (println &#34;a &#34; ?a &#34; is less than 1&#34;))

(println &#34;  Step 1  &#34;)
(println &#34;==========&#34;)
(println &#34;--- assert&#34;)
(assert (a 2))
(println &#34;------ run&#34;)
(run)
(println &#34; &#34;)

(println &#34;  Step 2  &#34;)
(println &#34;==========&#34;)
(println &#34;--- assert&#34;)
(assert (a 0))
(println &#34;------ run&#34;)
(run)
(println &#34; &#34;)

(println &#34;  Step 3  &#34;)
(println &#34;==========&#34;)
(println &#34;--- assert&#34;)
(assert (b foo) (a -1) (a 3))
(println &#34;------ run&#34;)
(run)
(unwatch deffunctions)</pre>
          <ul>
            <li><a href="#20">← 20. Rules: Activate!</a></li>
            <li>21. Watching functions</li>
            <li><a href="#22">22. ??? →</a></li>
          </ul>
        </section>

        <section id="22">
          <h3>22. ???</h3>
          <p>
          That&#39;s it for now! Thanks for sticking with the tutorial up to this point.
          I&#39;ll be adding to this over time, so make sure to bookmark this page and check
          back :).
          </p>
          <p>
          This entire page is written from scratch when possible. No frameworks,
          just good ol&#39; fashioned procedural Javascript, CSS and HTML. I took a lot of
          inspiration from the
          <a href="https://go.dev/tour/welcome/1" target="_blank">Tour of Go</a>. I found it
          super helpful to not need to install anything when learning Go years back. I used
          <a href="https://emscripten.org/" target="_blank">emscripten</a> to compile
          <a href="https://www.clipsrules.net/" target="_blank">CLIPS</a> into a WASM binary.
          I wrote the code editor + syntax highlighter from scratch with
          code snippets pulled from <a href="https://stackoverflow.com/" target="_blank">Stackoverflow</a>.
          I&#39;ll admit I&#39;m a bit proud of that :).
          </p>
          <p>
          My goal with this tutorial is to spread the word about CLIPS. I&#39;d like to
          see it used in more everyday applications because it&#39;s a very powerful way
          of expressing complex business logic with less lines of code.
          </p>
<pre id="input22">(clear)
(run)</pre>
          <ul>
            <li><a href="#21">← 21. Watching functions</a></li>
            <li>22. ???</li>
            <li></li>
          </ul>
        </section>

      </div></div>
  </body>
</html>
