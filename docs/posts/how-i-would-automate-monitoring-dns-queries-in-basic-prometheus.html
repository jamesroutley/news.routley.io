<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/PrometheusAutomatingDNSChecks">Original</a>
    <h1>How I would automate monitoring DNS queries in basic Prometheus</h1>
    
    <div id="readability-page-1" class="page"><div><h2>How I would automate monitoring DNS queries in basic Prometheus</h2>

	<p><small>March 26, 2024</small></p>
</div><div><p>Recently I wrote about <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/PrometheusDNSMonitoringProblem">the problem of using basic Prometheus to
monitor DNS query results</a>, which
comes about primarily because the <a href="https://github.com/prometheus/blackbox_exporter">Blackbox exporter</a> requires a
configuration stanza (a <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/PrometheusBlackboxNotes"><em>module</em></a>) for
every DNS query you want to make and doesn&#39;t expose any labels for
what the query type and name are. In a comment, Mike Kohne asked
if I&#39;d considered using a script to generate the various configurations
needed for this, where you want to check N DNS queries across M
different DNS servers. I hadn&#39;t really thought about it and we&#39;re
unlikely to do it, but here is how I would if we did.</p>

<p>The input for the generation system is a list of DNS queries we
want to confirm work, which is at least a name and a DNS query type
(A, MX, SOA, etc), possibly along with an expected result, and a
list of the DNS servers that we want to make these queries against.
A full blown system would allow multiple groups of queries and DNS
servers, so that you can query your internal DNS servers for internal
names as well as external names you want to always be resolvable.</p>

<p>First, I&#39;d run a completely separate Blackbox instance for this
purpose, so that its configuration can be entirely script-generated.
For each DNS query to be made, the script will work out the Blackbox
module&#39;s name and then put together the formulaic stanza, for
example:</p>

<blockquote><pre>autodns_a_utoronto_something:
  prober: dns
  dns:
    query_name: &#34;utoronto.example.com&#34;
    query_type: &#34;A&#34;
    validate_answer_rrs:
      fail_if_none_matches_regexp:
        - &#34;.*\t[0-9]*\tIN\tA\t.*&#34;
</pre>
</blockquote>

<p>Then your generation program combines all of these stanzas together
with some stock front matter and you have this Blackbox instance&#39;s
configuration file.  It only needs to change if you add a new DNS
name to query.</p>

<p>The other thing the script generates is a list of scrape targets
and labels for them in the format that Prometheus <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/#file_sd_config">file discovery</a>
expects. Since we&#39;re automatically generating this file we might
as well put all of the smart stuff into labels, including specifying
the Blackbox module. This would give us one block for each module
that lists all of the DNS servers that will be queried for that
module, and the labels necessary. This could be JSON or YAML, and
in YAML form it would look like (for one module):</p>

<blockquote><pre>- labels:
    # Hopefully you can directly set __param_module in
    # a label like this.
    __param_module: autodns_a_utoronto_something
    query_name: utoronto.example.com
    query_type: A
    [... additional labels based on local needs ...]
  targets:
  - dns1.example.org:53
  - dns2.example.org:53
  - 8.8.8.8:53
  - 1.1.1.1:53
  [...]
</pre>
</blockquote>

<p>(If we&#39;re starting with data in a program it&#39;s probably better to
generate JSON. Pretty much every language can create JSON by now,
and it&#39;s a more forgiving format than trying to auto-generate
YAML even if the result is less readable. But if I was going to
put the result in a version control repository, I&#39;d generate YAML.)</p>

<p>More elaborate breakdowns are possible, for example to separate
external DNS servers from internal ones, and other people&#39;s DNS
names from your DNS names. You&#39;ll get an awful lot of stanzas with
various mixes of labels, but the whole thing is being generated
automatically and you don&#39;t have to look at it. In our local
configuration we&#39;d wind up with at least a few extra labels and a
more complicated set of combinations.</p>

<p>We need the query name and query type available as labels because we&#39;re
going to write one generic alert rule for all of these Blackbox modules,
something like:</p>

<blockquote><pre>- alert: DNSGeneric
  expr: probe_success{probe=~&#34;autodns_.*&#34;} == 0
  for: 5m
  annotations:
    summary: &#34;We cannot get the {{$labels.query_type}} record for {{$labels.query_name}} from the DNS server ...&#34;
</pre>
</blockquote>

<p>(If Blackbox put these labels in DNS probe metrics we could skip
adding them in the scrape target configuration. We&#39;d also be able
to fold a number of our existing DNS alerts into more generic ones.)</p>

<p>If you go the extra distance to have some DNS lookups require
specific results (instead of just &#39;some A record&#39; or &#39;some MX
record&#39;), then you might need additional labels to let you write a
more specific alert record.</p>

<p>For us, both generated files would be relatively static. As a practical
matter we don&#39;t add extra names to check or DNS servers to test against
very often.</p>

<p>We could certainly write such a configuration file generation system
and get more comprehensive coverage of our DNS zones and various
nameservers than we currently have. However, my current view is
that the extra complexity almost certainly wouldn&#39;t be worth it in
terms of detecting problems and maintaining the system. We&#39;d make
more queries against more DNS servers if it was easier, if it would
be with such a generation system, but those queries would almost
never detect anything we didn&#39;t already know.</p>
</div></div>
  </body>
</html>
