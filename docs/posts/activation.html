<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://macwright.com/2022/07/11/activation.html">Original</a>
    <h1>Activation</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the course of building <a href="https://placemark.io/">Placemark</a>, I’ve been learning about a corner of web standards that’s pretty underdiscussed and underdocumented. It’s odd enough that even <a href="https://developer.mozilla.org/en-US/">MDN</a>, the gospel for web standards documentation, doesn’t mention it very often.</p><p>The thing is called <strong>user activation</strong>. It’s existed in a de-facto form for years, but only recently earned itself <a href="https://html.spec.whatwg.org/multipage/interaction.html#tracking-user-activation">a web standard within the HTML spec</a>.</p><p>The essence of user activation is that there are certain APIs that do disruptive or annoying things like opening pop-up windows or saving a file that shouldn’t be callable arbitrarily. Classically, it’s annoying to open a browser window and get a pop-up ad.</p><p>To crack down on pop-up ads and other annoyances, browsers implemented restrictions to these APIs, mostly in the form of tying them to the “click” event. Calling <code>window.open</code> on a <code>setTimeout</code> is forbidden, but calling <code>window.open</code> within the event handler of a click on a button is totally fine. Unfortunately, every browser did something slightly different, which prompted the folks at Google to <a href="https://developer.chrome.com/blog/user-activation/">propose a new standard with consistent behavior</a>.</p><h3 id="how-this-gets-you">How this gets you</h3><p>Why has user activation been a bugbear for my daily development of Placemark?</p><p>Placemark uses many of these new APIs, like <a href="https://macwright.com/2022/03/04/browsers-and-files.html">native file access</a> and the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/write">new clipboard APIs</a>.</p><p>It also does a lot of computing in the browser. At the time of writing, 18 different file formats are supported, and some of them require large modules to convert. Plus, this is a modern web application, so I’m trying to offload more and more CPU-heavy work to <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">WebWorkers</a>, so the tab doesn’t grind to a halt when things are being converted.</p><p>So, to keep the initial JavaScript payload under control, some actions like saving a file might lazy-load a module. And to keep the tab interactive rather than blocking it with CPU-heavy tasks, some operations are offloaded into WebWorkers, which makes them asynchronous.</p><p>And so you get the perfect storm of advanced APIs and asynchrony around when they’re called. So I’ve run into a lot of bugs rooted in user activation. If lazy-loading and off-thread computation take too long, the file won’t be saved or opened, and the clipboard won’t be written.</p><h3 id="safari-different-and-worse">Safari, different and worse</h3><p>Chrome’s new “v2” behavior with activation mostly works. There are frustrating omissions in it, like the timeout in the specification called the <strong>transient activation duration</strong> that is “a constant number” of milliseconds, and then is referred to as “at most a few seconds” and the answer for how many seconds it is would probably require me cloning and grepping the Chromium source code, which I don’t have the patience to do right now.</p><p>The problem, though, is that Safari hasn’t followed Chrome’s lead. The smart stuff that Chrome is doing, <a href="https://bugs.webkit.org/show_bug.cgi?id=222262">Safari isn’t</a>.</p><p>Safari’s implementation of user activation is not sophisticated. If it’s documented precisely anywhere, I haven’t found that documentation, but the observed behavior is something like:</p><blockquote><p>you have user activation if you’re calling the function within the same stacktrace as a “click” event handler, and in the same tick or within a tiny time threshold.</p></blockquote><p>So unfortunately if you’re building a web application and you can’t throw out Safari support, you have to build to the lowest common denominator, which is Safari’s de-facto activation threshold.</p><h3 id="the-workaround">The workaround</h3><p>For the clipboard and file APIs, there’s a workaround that can sate both Chrome and Safari. Let’s say you have a button that’ll write an API response into a user’s clipboard:</p><div><div><pre><code><span>button</span><span>.</span><span>onclick</span> <span>=</span> <span>async</span> <span>()</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>response</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#39;</span><span>…</span><span>&#39;</span><span>);</span>
  <span>const</span> <span>type</span> <span>=</span> <span>&#34;</span><span>text/plain</span><span>&#34;</span><span>;</span>
  <span>const</span> <span>blob</span> <span>=</span> <span>new</span> <span>Blob</span><span>([</span><span>await</span> <span>response</span><span>.</span><span>text</span><span>()],</span> <span>{</span> <span>type</span> <span>});</span>
  <span>const</span> <span>data</span> <span>=</span> <span>[</span><span>new</span> <span>ClipboardItem</span><span>({</span> <span>[</span><span>type</span><span>]:</span> <span>blob</span> <span>})];</span>
  <span>await</span> <span>navigator</span><span>.</span><span>clipboard</span><span>.</span><span>write</span><span>(</span><span>data</span><span>)</span>
<span>}</span>
</code></pre></div></div><p>So, you’re doing a lot of asynchronous work in between getting the “click” event and writing to the clipboard. This should work, but this kind of code will cause chaos down the line in Safari.</p><p>Instead, you need to really dig into those MDN documentation pages and figure out that most of the methods that require user activation also <strong>accept Promises</strong> as inputs, specifically as a workaround to the more brutish kind of user activation rules. So this could would look more like:</p><div><div><pre><code><span>button</span><span>.</span><span>onclick</span> <span>=</span> <span>()</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>type</span> <span>=</span> <span>&#34;</span><span>text/plain</span><span>&#34;</span><span>;</span>
  <span>const</span> <span>data</span> <span>=</span> <span>[</span><span>new</span> <span>ClipboardItem</span><span>({</span>
    <span>[</span><span>type</span><span>]:</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=&gt;</span> <span>{</span>
      <span>const</span> <span>response</span> <span>=</span> <span>await</span> <span>fetch</span><span>(</span><span>&#39;</span><span>…</span><span>&#39;</span><span>);</span>
      <span>const</span> <span>blob</span> <span>=</span> <span>new</span> <span>Blob</span><span>([</span><span>await</span> <span>response</span><span>.</span><span>text</span><span>()],</span> <span>{</span> <span>type</span> <span>});</span>
      <span>return</span> <span>blob</span><span>;</span>
    <span>})</span>
  <span>})];</span>
  <span>navigator</span><span>.</span><span>clipboard</span><span>.</span><span>write</span><span>(</span><span>data</span><span>)</span>
<span>}</span>
</code></pre></div></div><p>Ta-da! You’re calling <code>navigator.clipboard.write</code> in a way that makes Safari happy, and putting the asynchronous work into a Promise that’s resolved later.</p><h3 id="its-not-great">It’s not great</h3><p>This workaround works, generally, but the state of affairs isn’t great. Sure, you can pass a Promise as an argument to <code>clipboard.write</code> and when you’re working with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">File System Access API</a>, but if you’re doing something like what I’m doing, this is unequivocally worse.</p><p>If you’re lazy-loading libraries, like your “KML converter” library from another part of your codebase, you might need one part of the library to get a list of valid extensions or something else that you need to provide to the <code>showOpenFilePicker</code> or <code>write</code> or whatever call, on the same tick, synchronously, but then you want to lazy-load the rest of the library to run the conversion asynchronously.</p><p>If you’re calling a method to save a file up-front and then awaiting an asynchronous value, then failure gets weird. If the file isn’t converted or the API request fails or anything else, you’ve still shown the user a file selection dialog <em>before</em> reporting the failure.</p><p>Finally, it’s just really easy to forget the rules here, add a little abstraction and a little asynchronous code, and break clipboard or file or some other API in Safari.</p><hr/><p>I hope that Safari adopts the proposed standard for user activation soon! Until then, it’s a mysterious, underdocumented quirk that’ll really sneak up you.</p></div></div>
  </body>
</html>
