<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://signoz.io/blog/query-builder-v5/">Original</a>
    <h1>Adding OR logic forced us to confront why users preferred raw SQL</h1>
    
    <div id="readability-page-1" class="page"><article><p>In 2022, we had three different query interfaces. Logs had a custom search syntax with no autocomplete. Traces only had predefined filters - no query builder at all. Metrics had a raw PromQL input box where you&#39;d paste queries from somewhere else and hope they worked.</p><p>Each system spoke a different language. An engineer debugging a production issue had to context-switch not just between data types, but between entirely different mental models of how to query data.</p><p>When we built v3 in 2022, we thought we were solving this. We created a unified query builder - essentially a UI abstraction over SQL. Count, group by, filter, limit. It worked well enough to carry us from 2022 to 2024.</p><p>But we were building with the wrong assumptions.</p><h2 id="the-v3v4-design-flaw-that-took-two-years-to-understand"><a href="#the-v3v4-design-flaw-that-took-two-years-to-understand" aria-hidden="true" tabindex="-1"></a>The v3/v4 Design Flaw That Took Two Years to Understand</h2><p>We designed v3 around traces and metrics. In these data types, you rarely need complex boolean logic. A simple AND between conditions is usually enough.</p><p>But logs are different. When you&#39;re searching logs during an incident, you need expressions like:</p><div><pre><code><span><span>(</span>node_name contains <span>&#39;management&#39;</span> <span>OR</span> pod_name contains <span>&#39;test&#39;</span><span>)</span>
</span><span><span>AND</span> <span>NOT</span> <span>(</span>status_code <span>&gt;=</span> <span>500</span><span>)</span>
</span></code></pre></div><p>v3 couldn&#39;t do this. No OR support. No complex boolean expressions. No parentheses for precedence.</p><p>This wasn&#39;t a minor limitation; it was a fundamental capability gap. Users were forced to learn ClickHouse SQL, write raw queries, and maintain them as our schemas evolved. We&#39;d built a query builder that couldn&#39;t handle real-world queries.</p><p>Over four years of support calls, a pattern emerged that challenged everything we thought we knew about UI design.</p><p>Senior engineers - people with 5-10 years of experience - couldn&#39;t find features that seemed obvious to us. The most telling example: chronological ordering in logs. The feature existed in v3 and v4, hidden three clicks deep in the UI. Users didn&#39;t just struggle to use it; they assumed we didn&#39;t support it at all.</p><p>During these calls, we&#39;d watch them search for features, see their frustration, and realize: if you built it and know exactly where it is, everything seems obvious. But if senior engineers can&#39;t discover your features, those features effectively don&#39;t exist.</p><p>This led to a fundamental principle for v5: <strong>Stop making decisions for users.</strong></p><p>In v3/v4, we tried to be clever. We&#39;d make assumptions about what users wanted, hide complexity to &#34;simplify&#34; the experience. These assumptions were often wrong and led to surprising behavior that broke trust.</p><p>For v5, we established a new rule: if we must make a decision, it should be the least surprising one possible. And wherever possible, don&#39;t make the decision at all - let users control their experience.</p><p>When we started building v5, we quickly discovered that the query builder isn&#39;t just one component. It&#39;s the foundation of how users interact with data across the entire product.</p><p>Think about the typical workflow: You write a query in the explorer to investigate an issue. Then you either:</p><ul><li>Save it as a dashboard panel to monitor the pattern</li><li>Create an alert to catch it next time</li><li>Switch between logs, traces, and metrics to correlate data</li></ul><p>This interconnection meant we couldn&#39;t ship v5 for just the explorer. A query written in the new format had to work everywhere. This forced us to simultaneously rebuild:</p><ul><li>All three explorers (logs, traces, metrics)</li><li>Dashboard panel creation (including value panels that only exist in dashboards)</li><li>Alert creation flows</li><li>The underlying query API that powers all of these</li></ul><p>What started as &#34;let&#39;s add OR support to the query builder&#34; became a complete architectural overhaul.</p><p><iframe src="https://www.youtube.com/embed/MwY7HEEfvCw" title="YouTube Video Player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe></p><p>The most common use case during an incident: a user sends you an error message. In v3, you&#39;d need to construct a query with the correct syntax. In v5, you just paste and search:</p><div><pre><code><span><span>&#34;connection timeout in payment service&#34;</span>
</span></code></pre></div><p>Behind the scenes, we parse this into the appropriate query structure. But the user doesn&#39;t need to know that. They&#39;re debugging a problem, not learning a query language.</p><p>The feature that was impossible in v3/v4 and forced users to write ClickHouse queries:</p><div><pre><code><span><span>(</span>service_name <span>=</span> <span>&#39;api&#39;</span> <span>AND</span> status_code <span>&gt;=</span> <span>500</span><span>)</span>
</span><span><span>OR</span>
</span><span><span>(</span>service_name <span>=</span> <span>&#39;worker&#39;</span> <span>AND</span> error_message contains <span>&#39;timeout&#39;</span><span>)</span>
</span></code></pre></div><p>This seems basic, but implementing it required rethinking our entire query structure. We needed to support arbitrary nesting, maintain precedence rules, and still provide autocomplete and suggestions at every level.</p><p>One of the most powerful features that users don&#39;t initially notice: queries are portable across data types.</p><p>Write a query filtering for <code>service_name = &#39;api&#39;</code> in logs. Copy it. Paste it in traces explorer. It works.</p><p>This seems simple, but the implementation is complex. Logs, traces, and metrics have:</p><ul><li>Different underlying table schemas</li><li>Different column names for similar concepts</li><li>Different valid operations</li></ul><p>We built an abstraction layer that translates queries between these contexts automatically. Users think in terms of their data, not our storage schema.</p><p>When you&#39;re typing a query, you need suggestions immediately. But we&#39;re dealing with:</p><ul><li>Millions of unique field values</li><li>Multiple data sources</li><li>Complex hierarchical data structures</li></ul><p>We implemented:</p><ul><li>Smart caching that predicts what fields you&#39;ll query next</li><li>Progressive loading that shows the most relevant suggestions first</li><li>Query optimization that happens before we send anything to ClickHouse</li></ul><p>The result: autocomplete that feels instant, even at scale.</p><p>Because we were touching every part of the query experience, we could finally address years of accumulated UX issues.</p><p><strong>Chronological ordering in logs:</strong> Moved from a hidden dropdown to a prominent toggle. Same capability, completely different discoverability.</p><p><strong>Time aggregation controls:</strong> Previously buried in advanced settings, now directly visible. Users can switch from 1-minute to 5-second granularity with one click.</p><p><strong>Interval selection:</strong> Direct control over data granularity from 5 seconds to 1 hour. Why does this matter? During an incident, 30-second aggregation might smooth out the spike that&#39;s causing your problem. 5-second aggregation shows you exactly when things went wrong.</p><p>These weren&#39;t query builder features, but fixing them was essential to delivering a coherent experience. When engineers are debugging production issues at 2 AM, they shouldn&#39;t hunt for basic controls.</p><p>We shipped v5 with a single changelog entry. No marketing campaign. No push to adopt it.</p><p>Within three weeks, the feedback started coming in. The one that stood out: a user telling us they&#39;d replaced all their ClickHouse queries with Query Builder queries.</p><p>This wasn&#39;t something we asked them to do. They discovered that the query builder could now handle their complex cases, and they preferred it over raw SQL.</p><p>Why? Because with Query Builder:</p><ul><li>They don&#39;t need to learn ClickHouse SQL syntax</li><li>They don&#39;t need to update queries when we change schemas</li><li>They get autocomplete and validation</li><li>They can copy queries between different data types</li><li>They can share queries with team members who don&#39;t know SQL</li></ul><p>When users actively choose your abstraction over direct database access, you know you&#39;ve built the right thing.</p><p>Imagine investigating an incident where you see 500 errors. Your hypothesis: high CPU usage caused the failures. Today, you check traces for errors, then separately check metrics for CPU usage, then try to mentally correlate the timings.</p><p>With subqueries (currently in development), you&#39;ll write:</p><div><pre><code><span><span>Show</span> traces where<span>:</span>
</span><span>  status_code <span>&gt;=</span> <span>500</span>
</span><span>  <span>AND</span> <span>subquery</span><span>(</span>metrics<span>:</span> <span>CPU_usage</span> <span>&gt;</span> <span>80</span><span>%</span> <span>for</span> same service<span>)</span>
</span></code></pre></div><p>This requires real-time joining of traces and metrics data. The architecture is designed, the UI patterns are established. Implementation is next.</p><p>Currently, logs and traces live in separate worlds. You can see that a trace has an error, and you can see related logs, but you can&#39;t query them together.</p><p>With joins (in design phase), you&#39;ll write:</p><div><pre><code><span><span>Show</span> logs where<span>:</span>
</span><span>  <span>JOIN</span> traces <span>ON</span> trace_id
</span><span>  <span>WHERE</span> traces<span>.</span><span>duration</span> <span>&gt;</span> 500ms
</span></code></pre></div><p>This unlocks debugging workflows that are impossible today. Find all logs related to slow traces. Show logs where the parent span had an error. Correlate log patterns with trace characteristics.</p><p>After four years working on this product, countless support calls, and watching experienced engineers struggle with features I thought were obvious, the lesson is clear:</p><p>Doesn&#39;t matter how elegant your technical solution is. Doesn&#39;t matter how powerful your features are. If users can&#39;t discover and use them, they don&#39;t exist.</p><p>We could have the most sophisticated query engine in the world. But if an engineer investigating a production incident can&#39;t immediately figure out how to use it, we&#39;ve failed.</p><p>Query Builder v5 isn&#39;t just about adding OR support or fixing bugs. It&#39;s about recognizing that during an incident, engineers shouldn&#39;t have to think about query syntax. They should think about their problem.</p><p>We closed 80 issues with v5. We have 50+ more in the backlog.</p><p>But we&#39;re not planning a v6 mega-release. We designed v5&#39;s architecture to be extensible. The abstractions are correct. The patterns are established. Now we can ship incremental improvements without breaking changes.</p><p>Subqueries, joins, and the remaining enhancements will roll out as they&#39;re ready. No more two-year gaps between major improvements.</p><p>The query builder is no longer just a UI component. It&#39;s the foundation of how engineers interact with their observability data. And for the first time, it&#39;s powerful enough that users are choosing it over writing raw SQL.</p><p>That&#39;s not just a technical achievement. That&#39;s validation that we finally understood the problem we were trying to solve.</p><hr/><p><em>Query Builder v5 is live in the latest release. <a target="_blank" rel="noopener noreferrer" href="https://signoz.io/docs/userguide/query-builder-v5/">Check the documentation</a> for detailed examples and capabilities.</em></p></article></div>
  </body>
</html>
