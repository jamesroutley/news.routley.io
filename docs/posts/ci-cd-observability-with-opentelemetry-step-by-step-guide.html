<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://signoz.io/blog/cicd-observability-with-opentelemetry/">Original</a>
    <h1>CI/CD Observability with OpenTelemetry Step by Step Guide</h1>
    
    <div id="readability-page-1" class="page"><article><p>In the fast-paced world of CI/CD, understanding the performance and behaviour of your pipelines is crucial. GitHub Actions has become a popular choice for automating builds and deployments, but anyone who&#39;s debugged a flaky workflow or long-running job knows how challenging it can be to get visibility into what&#39;s happening under the hood. We usually rely on build logs, timing data, or guesswork when something goes wrong. <em>Wouldn&#39;t it be nice to trace a pipeline run step-by-step, or have metrics on how your workflows are performing over time?</em> This is where OpenTelemetry comes into play.</p><p><strong>OpenTelemetry [OTel]</strong> is an open-source observability framework that enables collecting traces, metrics, and logs in a standard, vendor-agnostic way. With a bit of configuration, OTel can capture telemetry from even our CI/CD pipelines. In this guide, we&#39;ll walk through setting up OpenTelemetry for GitHub Actions [covering both tracing and metrics], with practical examples and configuration snippets.</p><p>Just as we use traces and metrics to understand microservices and applications, we can apply the same to CI/CD pipelines. Instrumenting GitHub Actions with OpenTelemetry yields several benefits:</p><ul><li><p><strong>End-to-end visibility:</strong> You can trace the entire lifecycle of a workflow run, from trigger to completion. Each job and step can be visualised, showing how they execute and interact.</p></li><li><p><strong>Performance optimisation:</strong> By measuring the duration of each job and step, you can identify bottlenecks or slow steps in your pipeline.</p><p>For example, a long testing phase or a slow dependency installation.</p></li><li><p><strong>Error detection and debugging:</strong> Traces can pinpoint exactly where a workflow failed or took an unexpected path, making it easier to debug broken pipelines. Instead of combing through logs, you&#39;ll see which step or action resulted in an error.</p></li><li><p><strong>Dependency analysis:</strong> In complex workflows with multiple jobs [possibly with dependencies or concurrent runs], tracing helps you understand how different jobs and steps relate to each other within the workflow.</p></li></ul><p>Traditionally, engineering teams have monitored CI pipelines using ad-hoc methods, maybe exporting build logs to an ELK stack, timing data to Prometheus, or using CI-specific analytics. Those approaches often cover only metrics [like durations, success/failure counts] or logs. OpenTelemetry provides a unified approach, it can capture <em>traces</em> [for structure and timing] and <em>metrics</em> [for quantitative monitoring] in one system.</p><p>Every pipeline run can become a trace, and important KPIs can be emitted as metrics using OTel. Next, we&#39;ll see how to set this up with GitHub Actions.</p><p>To make GitHub Actions observable with OTel, we leverage a component of the OTel Collector known as the <a target="_blank" rel="noopener noreferrer" href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/githubreceiver"><em>GitHub Receiver</em></a>. This receiver can do some very cool things like,</p><ol><li><strong>Ingest GitHub workflow events as traces:</strong> GitHub can send events [via webhooks] whenever workflows run or jobs execute. The GitHub Receiver accepts these events and converts them into trace data.</li><li><strong>Scrape GitHub metrics via the API:</strong> The same receiver can use GitHub&#39;s APIs [GraphQL and REST] to scrape repository and workflow-related metrics. This includes information like <em>repository size, star count, open pull requests, issue counts, contributor statistics</em>, and more.</li></ol><div><p><span>üìù<!-- --> <!-- -->Note</span></p><div><p>We can set intervals at which scraping should take place when configuring the receiver as shown below:</p><div><pre><code><span><span>github</span><span>:</span>
</span><span>	<span>initial_delay</span><span>:</span> 1s
</span><span>	<span>collection_interval</span><span>:</span> 60s
</span></code></pre></div></div></div><p>In the sections below, we&#39;ll go through the steps to configure the OpenTelemetry Collector with the GitHub receiver for both traces and metrics.</p><p>Okay. Let&#39;s dive into the setup.</p><p>On the GitHub side of things, you&#39;ll need to set up a webhook on your repository [or organization] that sends <em>workflow_run</em> and <em>workflow_job</em> events to your Collector endpoint. In GitHub&#39;s settings, add a new webhook and select at least these two event types, with the content type set to <em>application/json</em>.</p><p>We will configure the Collector to listen for these events on a specific URL. You&#39;ll also need a secret token for the webhook [a random string] to secure it; the Collector will use the same secret to validate incoming events.</p><p>For metrics, if you want to scrape data from the GitHub API, you&#39;ll need an access token with permissions to read repo and workflow data. You can read this <a target="_blank" rel="noopener noreferrer" href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens#creating-a-personal-access-token-classic">guide</a> to understand how to get your personal access token.</p><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"><figure><img src="https://signoz.io/img/blog/2025/06/github-settings.webp" alt="Configure your GitHub webhook"/><figcaption><i>Configure your GitHub webhook</i></figcaption></figure></div></div><p>With that in place, let&#39;s set up the Collector step by step.</p><p>If you haven&#39;t already, install the OpenTelemetry Collector [we&#39;ll use the <em>otelcol-contrib</em> distribution because the GitHub receiver is part of the contrib components]. <a target="_blank" rel="noopener noreferrer" href="https://signoz.io/docs/tutorial/opentelemetry-binary-usage-in-virtual-machine/">Check this guide</a> for more details on installation.</p><div><p><span>‚ö†Ô∏è<!-- --> <!-- -->Warning</span></p><p>Ensure you have a recent version of <em>otelcol-contrib</em>, the GitHub receiver and CI/CD features are relatively new, so using the latest release is important.</p></div><p>In our OpenTelemetry configuration yaml file, we need to add the GitHub receiver under the receivers section. Below is a snippet for enabling trace collection via GitHub webhooks:</p><div><pre><code><span><span>receivers</span><span>:</span>
</span><span>  <span>github</span><span>:</span>
</span><span>    <span>webhook</span><span>:</span>
</span><span>      <span>endpoint</span><span>:</span> 0.0.0.0<span>:</span><span>19418</span>   
</span><span>      <span>path</span><span>:</span> /events    
</span><span>      <span>health_path</span><span>:</span> /health  
</span><span>      <span>secret</span><span>:</span> $<span>{</span>GITHUB_WEBHOOK_SECRET<span>}</span>   
</span><span>      <span>service_name</span><span>:</span> &lt;service_name<span>&gt;</span> 
</span><span>    <span>scrapers</span><span>:</span>
</span><span>      <span>scraper</span><span>:</span> <span>{</span><span>}</span> 
</span></code></pre></div><div><p><span>üìù<!-- --> <!-- -->Note</span></p><p>Depending on where you have your collector running, your &#39;endpoint&#39; setting will change. If you are trying in your local, you can use ngrok to tunnel the public webhook url to the specified port in your local.</p></div><p>With this in place, the collector knows how to receive GitHub events and turn them into trace data. But we&#39;re not done yet, we have to tell the collector what to do with these traces once received.</p><p>In the same receivers section of the Collector config, we will expand the github receiver settings to enable metric scraping. The GitHub receiver uses GitHub&#39;s APIs to pull various metrics about your repositories. Here&#39;s a snippet to add [we&#39;ll merge it with the earlier receiver conf].</p><div><pre><code><span><span>receivers</span><span>:</span>
</span><span>  <span>github</span><span>:</span>
</span><span>    
</span><span>    <span>scrapers</span><span>:</span>
</span><span>      <span>scraper</span><span>:</span>
</span><span>        <span>github_org</span><span>:</span> your<span>-</span>github<span>-</span>org 
</span><span>        <span>metrics</span><span>:</span>
</span><span>          <span>vcs.contributor.count</span><span>:</span>
</span><span>            <span>enabled</span><span>:</span> <span>true</span>
</span><span>        <span>auth</span><span>:</span>
</span><span>          <span>authenticator</span><span>:</span> bearertokenauth/github
</span></code></pre></div><p>After adding the above, our github receiver config now has both the webhook section [for traces] and the scraper section [for metrics] configured. The receiver will handle both concurrently.</p><h3 id="step-3-add-metadata-and-authentication-for-collecting-metrics"><a href="#step-3-add-metadata-and-authentication-for-collecting-metrics" aria-hidden="true" tabindex="-1"></a>Step 3: Add Metadata and Authentication for Collecting Metrics</h3><p>Once your GitHub receiver is in place, you&#39;ll need two supporting components to make everything work smoothly,</p><p>1/ a <strong>processor</strong> to tag your data</p><p>2/ an <strong>extension</strong> to authenticate your API requests to GitHub.</p><p>Observability tools always group and query telemetry by the <em>service.name</em> attribute. Since the GitHub receiver doesn&#39;t add this by default, we should explicitly tag our metrics.</p><p>In your Collector config:</p><div><pre><code><span><span>processors</span><span>:</span>
</span><span>  <span>resource/github</span><span>:</span>
</span><span>    <span>attributes</span><span>:</span>
</span><span>      <span>-</span> <span>key</span><span>:</span> service.name
</span><span>        <span>value</span><span>:</span> `&lt;service<span>-</span>name<span>&gt;</span>`
</span><span>        <span>action</span><span>:</span> insert
</span></code></pre></div><p>This processor inserts &#39;service.name=<code>&lt;service-name&gt;</code>&#39; into all telemetry data flowing through the pipeline, making it easier to search and slice them later in our dashboards and queries.</p><p>The GitHub receiver scrapes metrics by calling GitHub&#39;s REST and GraphQL APIs. To do this reliably, it needs authentication via a Personal Access Token [we had discussed earlier on how to access this].</p><p>Let&#39;s add this to your config,</p><div><pre><code><span><span>extensions</span><span>:</span>
</span><span>  <span>bearertokenauth/github</span><span>:</span>
</span><span>    <span>token</span><span>:</span> $<span>{</span>GH_PAT<span>}</span>
</span></code></pre></div><p>Next, in the collector config, we need to include our github receiver in the traces and metrics pipeline and set up where to export the trace data to.</p><div><pre><code><span><span>service</span><span>:</span>
</span><span>	<span>extensions</span><span>:</span> <span>[</span>bearertokenauth/github<span>]</span>
</span><span>  <span>pipelines</span><span>:</span>
</span><span>    <span>traces</span><span>:</span>
</span><span>      <span>receivers</span><span>:</span> <span>[</span>github<span>]</span>
</span><span>      <span>processors</span><span>:</span> <span>[</span><span>]</span>
</span><span>      <span>exporters</span><span>:</span> <span>[</span>otlp<span>]</span>
</span><span> 
</span><span>    <span>metrics</span><span>:</span>
</span><span>      <span>receivers</span><span>:</span> <span>[</span>github<span>]</span>
</span><span>      <span>processors</span><span>:</span> <span>[</span>resource/github<span>]</span>
</span><span>      <span>exporters</span><span>:</span> <span>[</span>otlp<span>,</span> debug<span>]</span>
</span></code></pre></div><div><p><span>üí°<!-- --> <!-- -->Tip</span></p><p>Make sure to include <em>bearertokenauth/github</em> in the extensions under service itself! [as shown in the code above]</p></div><h3 id="step-6-provide-authentication-tokens-and-run-the-collector"><a href="#step-6-provide-authentication-tokens-and-run-the-collector" aria-hidden="true" tabindex="-1"></a>Step 6: Provide Authentication Tokens and Run the Collector</h3><p>Before running the Collector, we need to supply the two secret values we referenced in the config:</p><ul><li>GITHUB_WEBHOOK_SECRET ‚Äì the secret token for validating webhook events.</li><li>GH_PAT ‚Äì the GitHub token used by the bearer token authenticator for metrics [used by the.</li></ul><p>Make sure you have these values handy. The PAT should have permissions to read repository and Actions data. A classic Personal Access Token with repo scope or a fine-grained PAT with appropriate read permissions should suffice, or you can use a GitHub App token if you set one up.</p><p>Now we&#39;re ready to start the collector. Export the environment variables and run the collector binary [or pass the env vars to your container if running via Docker:</p><div><pre><code><span><span>export</span> <span>GITHUB_WEBHOOK_SECRET</span><span>=</span><span>&lt;</span>your-webhook-secret<span>&gt;</span>
</span><span><span>export</span> <span>GH_PAT</span><span>=</span><span>&lt;</span>your-github-access-token<span>&gt;</span>
</span><span>otelcol-contrib <span>--config</span> ./config.yaml
</span></code></pre></div><p>This launches the OpenTelemetry Collector with our configuration. It will start the HTTP server for webhooks and schedule the metric scrapers.</p><p>You can configure your collector to send data to any backend you choose by adding it to the exporters field. We are sending data to SigNoz for this example, <a target="_blank" rel="noopener noreferrer" href="https://www.reddit.com/r/opensource/comments/zlkb6y/we_are_framasoft_we_develop_peertube_and_promote/">you can find the instructions here</a>. <a target="_blank" rel="noopener noreferrer" href="https://signoz.io/teams/"><img alt="Get Started - Free CTA" src="https://signoz.io/img/launch_week/try-signoz-cloud-blog-cta.png"/></a></p><p>If everything is set up correctly, as soon as your collector is running and the GitHub webhook is configured, any new GitHub Actions workflow run should trigger events that hit the collector. You can test this by manually running a workflow or simply waiting for the next run [including failed runs]. You should see logs in the collector.</p><p>At this point, the collector will be pushing telemetry to SigNoz or any observability platform of your choice. Next, we&#39;ll head over to SigNoz to visualise and verify the traces and metrics.</p><p>In SigNoz, you can view traces from your GitHub repository after filtering with the service names we mentioned earlier.</p><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"><figure><img src="https://signoz.io/img/blog/2025/06/github-traces.webp" alt="Traces from github actions"/><figcaption><i>Traces from github actions</i></figcaption></figure></div></div><p>To view metrics in SigNoz, you can use this <a target="_blank" rel="noopener noreferrer" href="https://github.com/SigNoz/dashboards/blob/main/cicd/cicd.json">dashboard</a>.</p><div aria-owns="rmiz-modal-" data-rmiz=""><div data-rmiz-content="not-found"><figure><img src="https://signoz.io/img/blog/2025/06/github-metrics.gif" alt="CI/ CD metrics, including Repository health, DORA metics, Pipeline health etc"/><figcaption><i>CI/ CD metrics, including Repository health, DORA metics, Pipeline health etc</i></figcaption></figure></div></div><p>On that note, our CI/CD pipelines deserve just as much visibility as our production systems. They&#39;re the heartbeat of shipping software, and yet they&#39;re often left in the dark. With OpenTelemetry, bringing them into the light is easier than ever. So go ahead instrument your pipelines, trace your builds, and monitor what matters!</p></article></div>
  </body>
</html>
