<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ratfactor.com/assembly-nights">Original</a>
    <h1>Assembly Nights</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <p>Over the last three months, I’ve developed an unusual little nighttime routine: after
reading bedtime stories to the kids, I hop into bed and instead of reaching for
a fiction book, I’m turning on my 14-year old
<a href="https://en.wikipedia.org/wiki/Asus_Eee_PC">Asus eeePC 701</a> miniature laptop
and writing x86 assembly language. This is turning out to be an insanely good
use of my time…​</p>
<div>
<p><img src="http://harihareswara.net/images/misc/assembly-nights.jpg" alt="My faithful asus eeepc 701 waiting romantically on the bed"/>
</p>
</div>
<p>
My faithful eeePC 701 is a 32 bit Celeron &#34;netbook&#34; mini-laptop from 2007
currently running Alpine Linux and is seen here editing my very early
work-in-progress NASM port of &#34;JonesForth&#34;. This little computer has run more
versions of Linux and BSD than I can count! It is also warm on a cold night.
</p>
<p>My interest in the <a href="http://harihareswara.net/posts/2021/the-stories-i-chose/zig/">Zig programming language</a> has driven me into a deeper interest in &#34;systems-level&#34; programming and that, ultimately, seems to lead to computer architecture, instruction sets, and assembly languages.</p>
<div>
<h2 id="_learning_environment">Learning environment</h2>
<div>
<p>For reasons I can’t explain, it just feels right to use my tiny computer with
its tiny keyboard to type tiny instructions late at night. I suppose it stands
to reason that being in a completely different environment from my normal
desktop development machines put me in a receptive learning mood.</p>
<p>Also, though I did install
<a href="https://en.wikipedia.org/wiki/Lynx_(web_browser)">Lynx</a>,
this is not a great machine for modern Web
surfing (except for ratfactor.com, of course). So it’s a pretty
distraction-free device.</p>
<p>Since this little computer is used for nothing else, I’ve been slowly
customizing it for this one task: when I log in, my <code>.bash_profile</code> script
immediately does a <code>cd</code> to my assembly project directory.</p>
<p>I have a bunch of little cryptic one and two-letter scripts and aliases that
open my project and related documentation in Vim, or start up the GDB debugger
and run a GDB script with a breakpoint at the last thing I was working on.</p>
<p>These little things make it so much easier to get going when I’m tired and not
feeling like expending much effort.  Now I’m at the point where grabbing the eeePC,
logging in, and opening the assembly project is automatic, like brushing my
teeth.</p>
<p>So, what’s this project I’m working on?</p>
</div>
</div>
<div>
<h2 id="_porting_jonesforth">Porting JonesForth</h2>
<div>
<p>Immediately after completing the lessons on asmtutor.com (see NASM under
Resources below), I immediately began on one of the &#34;bucket list&#34; projects I’d
shelved many moons ago: reading and understanding Richard WM Jones’s
<a href="https://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/">JONESFORTH</a>.</p>

<p>But not content to merely read it, I’ve decided to port it to NASM.</p>
<p>The progress has been incredibly slow because I’m new to assembly in general
and NASM specifically.  JonesForth is written in GAS (the GNU Assembler) with a
completely different syntax.  Even the machine instruction mnemonics are
different because GAS often includes the size of the data being manipulated as
part of the mnemonic.</p>

<p>The biggest initial challenge was porting some vital macros from GAS to NASM.
Each one took weeks to understand and convert.</p>
<p>But it’s pretty awesome and satisfying to be working on something non-trivial,
even if it started <em>way</em> over my head. I’ve wanted to give up on this so many
times, but I just keep grinding away at it and the barriers are slowly giving
way.  Every time I figure out what a new instruction does or fix a bug, it’s a
little triumph.</p>
</div>
</div>
<div>

<div>
<p><strong>This section is an update:</strong></p>
<p>I &#34;accidentally&#34; put a deadline on the JonesForth port recently. I
want to finish off a bunch of the little projects I’ve accrued for myself this
year so I can more single-mindedly focus on a few bigger ones going into the
next year.  Well, as soon as I had that deadline, you know what happened? I
started trying to hurry through blocks of JonesForth assembly, converting them
to NASM as fast as I could. Stupid, right?</p>
<p>I knew I had to force myself slow down. But that’s easier said than done. A
sense of urgency is easily gained, but not so easily lost.</p>
<p>My &#34;shower epiphany&#34; last night (this is days after writing this original
article), was how to go about slowing down. And here it is: I’m going to stop
where I’m at in the translation, fix any syntax errors so the thing assembles,
and then <em>walk through every single instruction</em> I’ve got so far and make sure
it all works as expected. And to make that more enjoyable and actually have
something to show for my efforts when I’m done, I’m going to log the whole
session. I don’t even have X on this computer, so the obvious choice for
logging is GNU Screen, the terminal multiplexer.</p>
<p>My first thought was, oh great, now I have to learn another tool and get
completely sidetracked!</p>
<p>Then my second thought was, hold on, that <em>is</em> great. Now I can finally learn
another big ubiquitous GNU application properly and have another tool I’m
confident using. Plus, I think Screen will be useful for all kinds of
convenience improvements: I’m currently using Linux’s virtual terminals
(<code>Alt-F1</code>, <code>Alt-F2</code>, etc.) to have a Vim session and GDB session both open for
easy reference. I have to manage those manually. With Screen, I’m pretty sure I
can automate opening both things with a single command and then be able to
toggle between them with Screen’s <code>Ctrl-a, Ctrl-a</code>.</p>
<p>So I’m currently reading the entire
<a href="https://www.gnu.org/software/screen/manual/screen.html">GNU Screen User’s Manual</a>
and trying it all out so I know what my options are. <em>Then</em> I’m going
to log a big old GDB session and turn it into a transcript which can go into
the repo as another artifact on the journey. Now I’m imagining a series of
brief session transcripts in which I explore each new bit of functionality. I
think this will be really neat.</p>
<p>The point is, I sort of lost my way for a moment, thinking of the finished
Forth port as the &#34;point&#34; of this exercise. It’s not. The learning process and
the skills I acquire are the point. Plus, after the port is done, Assembly
Nights are going to turn into Forth Nights. I’ve got Leo Brodie’s <em>Starting
Forth</em> and <em>Thinking Forth</em> on my nightstand. So this journey will take however
long it takes and it will be glorious.</p>
</div>
</div>
<div>
<h2 id="_resources">Resources</h2>
<div>
<div>
<h3 id="_nasm">NASM</h3>
<p>The NASM assembler comes with documentation in the form of a single text file. I have this file open with my assembly source file so it’s always just a Vim buffer away.
It’s the same content as <a href="https://www.nasm.us/xdoc/2.15.05/html/nasmdoc0.html">this HTML version</a>.</p>
<p>But where to start?</p>
<p>My path (which I highly recommend, by the way) has been to first learn the
basics of assembly with the clean &#34;Intel-style&#34; syntax of NASM. For that, I
<em>very</em> highly recommend:</p>

<p>You’ll need a Linux computer (or I suppose something virtual like WSL on
Windows) since the tutorials rely on Linux system calls.</p>
<p>I did all of the exercises on the eeePC, under the covers, with asmtutor.com
open on my phone! It’s just as naughty as it sounds.</p>
<p>What I love about asmtutor.com (besides being exactly what I was looking for
and completely free) is that you end up covering a ton of functionality (from
Hello World to a multi-threaded Web server) in bite-sized lessons.  You also
end up building up a utility library of little functions which you can use as a
jump-start on other projects.</p>
<p>I gained a lot of understanding from these lessons in a very natural way -
through use.  Each lesson is a handful of explanatory paragraphs and then an
assembly program. I always tweak and modify examples to make sure I understand
them, so my utility functions started to diverge from the originals pretty
early on.</p>
<p>Anyway, using <code>push</code>, <code>pop</code>, <code>call</code>, and <code>ret</code> over and over in these exercises
did more for concretizing these fundamental concepts than years of theory and
programming in high-level languages. <em>Wow,</em> I kept thinking, <em>I should have taken
the assembly dive years ago!</em></p>
<p>(<em>Actually</em>, I read a DOS-based  x86 assembly book and enjoyed writing DOS assembly
programs using nothing but <code>debug</code> waaaay back in my youth, but that was before
I’d really done a whole lot of programming. So the experience hit and stuck
differently this time around.)</p>
</div>
<div>
<h3 id="_gdb">GDB</h3>
<p>GDB is a huge and intimidating piece of software (practically an operating
system), so I went ahead and purchased the physical paper book
<a href="https://shop.fsf.org/books-docs/debugging-gdb-gnu-source-level-debugger-v-731">Debugging with GDB: The GNU Source-Level Debugger</a>
direct from GNU Press/FSF.
I read the book on weekends from the comfort of a couch and bookmarked things
to try when I got on the eeePC that night.</p>

</div>
<div>
<h3 id="_x86_assembly_language">x86 Assembly Language</h3>
<p>There is a really nice overview with a list of common instructions written by
Adam Ferrari. I recently discovered that it exists in &#34;Intel-style&#34; at the
University of Virginia:</p>

<p>and in GAS/AT&amp;T syntax at Yale:</p>


<p>…​But I actually believe the book is going to stick so much better now that
I’ve already learned some of this the hard way. Which perfectly fits my
pet theory about learning:
<a href="http://harihareswara.net/posts/2021/the-stories-i-chose/manuals">The Phenomena of the Game Manual</a>.</p>
</div>
</div>
</div>
    </article></div>
  </body>
</html>
