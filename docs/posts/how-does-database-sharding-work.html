<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://planetscale.com/blog/how-does-database-sharding-work">Original</a>
    <h1>How does database sharding work?</h1>
    
    <div id="readability-page-1" class="page"><article><header></header><section><div><p>If you’ve used Google or YouTube, you’ve probably accessed sharded data. Sharding helps you <strong>scale out your database</strong> by storing partitions of your data across multiple servers instead of putting everything on a single giant one. This post will walk through how database sharding works, how to think about implementing your own sharded database, and some useful tools out there that can help, with a particular focus on MySQL and Postgres.</p>
<h2 id="sharding-is-how-you-scale-out-relational-databases"><a href="#sharding-is-how-you-scale-out-relational-databases">Sharding is how you scale out relational databases<span aria-label="Permalink to Sharding is how you scale out relational databases" role="complementary">#</span></a></h2>
<p>Scene: you’ve upsized your MySQL on RDS instance for the 3rd time this quarter and your CFO just put 30 minutes on your calendar to “chat budget.” It might be time to scale out instead of scaling up! <a href="#references"><sup>[1]</sup></a> Read replicas in RDS seem straightforward enough, but reading data is only half of the problem. What is an overwhelmed developer to do?</p>
<p>Sharding — a term that probably <a href="https://www.raphkoster.com/2009/01/08/database-sharding-came-from-uo/">originally came from a video game</a> — is how you scale out relational databases. You’ve probably seen this table before, about how scaling out helps you take this users table, all stored on a single server:</p>
<table><thead><tr><th>user_id</th><th>first_name</th><th>last_name</th><th>email</th><th>...</th></tr></thead><tbody><tr><td>ZpaDr20TTD4ZL7Wma</td><td>Peter</td><td>Gibbons</td><td><a href="mailto:peter@initech.net">peter@initech.net</a></td><td>...</td></tr><tr><td>bI32htQ1PsEQioC7G</td><td>Bill</td><td>Lumbergh</td><td><a href="mailto:bill@initech.net">bill@initech.net</a></td><td>...</td></tr><tr><td>99J3x257SGP7J4IkF</td><td>Milton</td><td>Waddams</td><td><a href="mailto:stapler@initech.net">stapler@initech.net</a></td><td>...</td></tr><tr><td>0SH0pyi9bO5RM4I03</td><td>Lawrence</td><td></td><td><a href="mailto:two@onetime.com">two@onetime.com</a></td><td></td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table>
<p>And turn it into this users table, stored across 2 (or 1,000) servers:</p>
<table><thead><tr><th>user_id</th><th>first_name</th><th>last_name</th><th>email</th><th>Server</th></tr></thead><tbody><tr><td>ZpaDr20TTD4ZL7Wma</td><td>Peter</td><td>Gibbons</td><td><a href="mailto:peter@initech.net">peter@initech.net</a></td><td><strong>Server A</strong></td></tr><tr><td>bI32htQ1PsEQioC7G</td><td>Bill</td><td>Lumbergh</td><td><a href="mailto:bill@initech.net">bill@initech.net</a></td><td><strong>Server B</strong></td></tr><tr><td>99J3x257SGP7J4IkF</td><td>Milton</td><td>Waddams</td><td><a href="mailto:stapler@initech.net">stapler@initech.net</a></td><td><strong>Server B</strong></td></tr><tr><td>0SH0pyi9bO5RM4I03</td><td>Lawrence</td><td></td><td><a href="mailto:two@onetime.com">two@onetime.com</a></td><td><strong>Server A</strong></td></tr><tr><td>...</td><td>...</td><td>...</td><td></td><td>...</td></tr></tbody></table>
<p>But that’s only one type of sharding (row level, or horizontal). There are tons of different ways to split up your data across servers to best match how your business and data model works. Vertical sharding, for example, is when you split things at the schema or table level. More on this later!</p>
<p>Partitioning has existed – especially in OLAP setups – for a long time, primarily as a mechanism for improving query speed. Nightmares of sifting through HDFS partitions to find the missing snapshot pervade my sleep schedule... Anyway, sharding takes that concept and applies it to distributed systems: in addition to splitting up data into logical groups, let’s put those groups across multiple servers that talk to each other. Even Oracle <a href="https://docs.oracle.com/en/database/oracle/oracle-database/21/shard/how-database-requests-are-routed-shards.html#GUID-0E965889-9C00-43EF-88BB-12DA1114E559">does it</a>!</p>
<p>For as long as relational databases have existed, they’ve been designed to run on a single server. Partially because of that, and partially because of fundamental laws of physics, sharding your data properly is, uh, not very easy.</p>
<h2 id="how-sharding-in-relational-databases-works-under-the-hood"><a href="#how-sharding-in-relational-databases-works-under-the-hood">How sharding in relational databases works under the hood<span aria-label="Permalink to How sharding in relational databases works under the hood" role="complementary">#</span></a></h2>
<p>To shard your database, you’ll need to do a few things:</p>
<ol>
<li><strong>Decide on a sharding scheme</strong> — What data gets split up, and how? How is it organized?</li>
<li><strong>Organize your target infrastructure</strong> — How many servers are you sharding to? How much data will be on each one?</li>
<li><strong>Create a routing layer</strong> — How does your application know where to store new data, and query existing data?</li>
<li><strong>Planning and executing the migration</strong> — How do you migrate from a single database to many with minimal downtime?</li>
</ol>
<p>There’s no hard and fast playbook for each; everyone’s data model and business constraints are different. Let’s dive in.</p>
<h3>Sharding schemes and algorithms</h3>
<p>How you decide to split up your data into shards – also referred to as your <strong>partition strategy</strong> – should be a <em>direct function</em> of how your business runs, and where your query load is concentrated. For a B2B SaaS company where every user belongs to an organization, sharding by splitting up organization-level data probably makes sense. If you’re a consumer company, you may want to shard based on a random hash. Notion <a href="https://www.notion.so/blog/sharding-postgres-at-notion">manually sharded their Postgres database</a> by simply splitting on team ID. All of this is to say that sharding can be as simple or as complicated as you make it.</p>
<p>With that in mind, there are a few popular “algorithms” to decide which rows are stored together and on which servers:</p>
<ul>
<li><strong>Hash based sharding (also known as key based)</strong> – Take a value from the row, hash it, and send buckets of hashes to the same server. Whichever column you choose to hash is your <em>shard key</em>.</li>
<li><strong>Range based sharding</strong> – Pick a column, create ranges, and allocate shards based on those ranges. Most useful for numerical columns that are (somewhat) randomly or evenly distributed.</li>
<li><strong>Directory based sharding</strong> – Pick a column, allocate shards manually, and maintain a lookup table so you know where each row is stored.</li>
</ul>
<p>If your sharding scheme isn’t random (e.g. hash based), you can begin to see why query profiling and understanding how your load is distributed can be useful.</p>
<p>Imagine you’re Amazon, and you want to shard your MySQL database that stores customer orders. On the surface, there seems to be no meaningful clustering: sure, you’ve got customers who order a lot of stuff, but that volume (and the associated reads during the shopping process) are basically random. It might make sense to use hash based sharding, and use the order ID as the shard key.</p>
<p>A big part of your sharding scheme is considering <strong>which tables are stored together</strong>. Joins across databases in a distributed system are difficult and costly, so ideally all of the data you need to answer a particular query exists on the same physical machine. For Amazon, that means the <code>orders</code> table and the <code>products</code> table containing the products in the <code>orders</code> table need to be physically colocated. This also requires incremental maintenance: if a customer makes a new order, the product data for that order needs to be included in the new shard so it can be read quickly later on.</p>
<p><strong>Sharding maintenance</strong> is an oft underappreciated piece of scaling out your relational database. Depending on what your partition strategy is, you’ll likely end up with <a href="https://architecturenotes.co/database-sharding-explained/">hotspots</a>, where a particular server in your cluster is either storing too much data or handling too much throughput. In our Amazon example, it could be because a large business started ordering a metric-ton of stuff, and all of their data is on one server. Managing those hotspots, redistributing data and load, and reorganizing your partition strategy to prevent future issues is part of what you’re signing up for when you shard.</p>
<h3>Deciding on what servers to use</h3>
<p>With your sharding scheme set, it’s time to decide on how many machines you want to store data on, and how big you need them to be. There’s no formula here; this decision depends on your budget, projections for future database load, cloud provider, etc.</p>
<p>A common approach is <strong>maximizing flexibility</strong>. Start with a small number of hosts, and add more as needed. To maintain an even distribution of shards across your servers, you’ll need to re-balance every time you add a host. This is why companies like to choose a number of shards that’s divisible by a lot of smaller numbers; it allows you to scale out the number of servers incrementally while maintaining that smooth, even distribution.</p>
<h3>Routing your queries to the right databases</h3>
<p>With your data distributed across multiple databases (imagine 20 of them), how does your application know which database to query? You need to build some sort of routing layer that decides. But how?</p>
<p>For those building sharding from scratch, the most common answer is <strong>in the application layer</strong>. You need to build logic into your application code that decides which database (and schema) to connect to for a particular query, conditional on the data inside that query and where it belongs in your sharding scheme. The logic looks something like:</p>
<div><pre><code>if data.sharding_key in database_1.sharding_keys:
  …connect to database_1
else if data.sharding_key in database_2.sharding_keys:
  …connect to database_2
</code></pre></div>
<p>Depending on how you’ve partitioned your data and the number of physical machines / databases you’re working with, this logic can be relatively simple and stored in a JSON blob, config file, etc. More commonly, teams will use some sort of key value store or a lookup table in a database. The important thing is to have the information that ties a piece of data to its destination encoded somewhere so your application knows where to issue the query.</p>
<p>Building this for the first time is actually not that difficult; it’s the <strong>operational maintenance</strong> that becomes the real problem over time. If you move shards from database to database, rebalance, add new machines, remove machines, change any database properties…you’ll need to update that application logic to account for it. <a href="https://proxysql.com/">ProxySQL</a> isn’t a full fledged solution for this, but it could be classified as a rough “shard routing” service.</p>
<h3>Planning and executing your migration</h3>
<p>Once you’ve taken care of all of the above and have your physical servers running with empty databases on them, plus a plan for routing in your application logic, you’re faced with the age-old problem of how to migrate without (too much) downtime. Unlike a (potentially) more straightforward migration to a single new database provider, moving to sharding introduces a lot more things that can go wrong and in more ways.</p>
<p>Notion’s engineering team suggested a useful framework for thinking about the migration in <a href="https://www.notion.so/blog/sharding-postgres-at-notion">their post about how they implemented sharding</a>:</p>
<ol>
<li>
<p><strong>Double-write</strong>: Incoming writes get applied to both the old and new databases.</p>
</li>
<li>
<p><strong>Backfill</strong>: Once double-writing has begun, migrate the old data to the new database.</p>
</li>
<li>
<p><strong>Verification</strong>: Ensure the integrity of data in the new database.</p>
</li>
<li>
<p><strong>Switch-over</strong>: Actually switch to the new database. This can be done incrementally, e.g. double-reads, then migrate all reads.</p>
</li>
</ol>
<p>Each of these steps still introduces the possibility of downtime; it’s just a risk you’re going to have to take for changes at this scale.</p>

<p>Though many teams do build sharding for their database of choice from scratch, there is an ecosystem of tools, albeit perhaps less mature than the database software they’re built on.</p>
<h3>Vitess</h3>
<p><a href="https://vitess.io/">Vitess</a> was built at YouTube when they needed to shard MySQL, and is now available to you and me. It’s basically a layer on top of MySQL that gives you sharding, and a lot of other neat stuff related to really big workloads: connection pooling, dynamic re-sharding and balancing, and monitoring tools, among other things. For a technical overview of how Vitess improves on vanilla MySQL, check out <a href="https://vitess.io/docs/overview/whatisvitess/">their comparison here</a>.</p>
<p>As far as I’m aware, Vitess is the most mature and the most popular OSS sharding layer for a relational database. It served all YouTube DB traffic for years, and is in production at <a href="https://slack.engineering/scaling-datastores-at-slack-with-vitess/">Slack</a>, GitHub, NewRelic, Pinterest, Square, etc.</p>
<div><p><strong>Note</strong></p><p>Every <a href="https://planetscale.com/docs/concepts/what-is-planetscale">PlanetScale database</a> is deployed with Vitess under the hood. If you&#39;re
looking for a pain-free sharding solution for your MySQL database, we can help. <a href="https://planetscale.com/contact">Reach out to us</a>, and we&#39;ll
be in touch shortly.</p></div>
<h3>Citus</h3>
<p><a href="https://www.citusdata.com/">Citus</a> does what Vitess does for MySQL, but for Postgres (minus some more flashy features). It’s open source, designed as a Postgres extension, and can be run as a single node or several. It’s in production at Algolia, Heap, Cisco, and a few more. <a href="https://docs.citusdata.com/en/v11.2/sharding/data_modeling.html">Their docs</a> have good general advice for picking your sharding scheme, Citus or otherwise.</p>
<h3>The serverless database wave</h3>
<p>I suppose the more fundamental question is: why are you not using a database that does sharding for you? Over the past few years the so-called “serverless” database has gotten a lot more traction. Starting with the infamous <a href="https://research.google/pubs/pub39966/">Spanner paper</a>, many have been thinking about how running a distributed system should be native to the database itself, the foremost of which has been <a href="https://www.cockroachlabs.com/">CockroachDB</a>. You can even run <a href="https://cloud.google.com/spanner">cloud Spanner on GCP</a>.</p>
<p>You’re reading this blog on the <a href="https://planetscale.com/">PlanetScale website</a>. They sell a shard-native (did I just coin this?) database built on MySQL and Vitess. I’m not a PlanetScale employee, but I am a big proponent of what they’re doing, specifically shifting the focus in databases to <a href="https://planetscale.com/blog/nonesql-all-the-devex">developer experience</a> instead of infrastructure maintenance.</p>
<p>The question is starting to become: if you’re paying someone like AWS to run your database for you, why are you busy figuring out how to scale out that database? And I think that’s a good question the major cloud providers should be asking themselves.</p>
<h2 id="references"><a href="#references">References<span aria-label="Permalink to References" role="complementary">#</span></a></h2>
<p><sup>[1]</sup> There is no shortage of opinion pieces on the web arguing against premature sharding. This post assumes an
educated reader who can judge when scaling out is the right decision and when it isn’t.</p>
</div></section></article></div>
  </body>
</html>
