<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://norasandler.com/2022/03/29/Write-a-C-Compiler-the-Book.html">Original</a>
    <h1>Writing a C Compiler is a book!</h1>
    
    <div id="readability-page-1" class="page"><div aria-label="Content">
      <div>
        <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    <p>I have some very exciting news to share: the “Writing a C Compiler” series is now a book!</p>

<p><a href="https://nostarch.com/writing-c-compiler"><em>Writing a C Compiler: Build a Real Programming Language from Scratch</em></a> is coming out from No Starch Press next January. You can preorder at the link to get early access to the first few chapters.</p>

<p>In the <a href="https://www.dropbox.com/2019/02/18/Write-a-Compiler-10.html">last post in the series</a>, I said that I was going to take a six-month break to figure out how to finish the compiler. Instead, I took a three-year break, reworked the backend, implemented the rest of the features I wanted to add (well, most of them), and wrote a book. If you were already following the series, you can jump to <a href="#what-if-ive-already-done-the-series">this section</a> to learn what’s changed. Otherwise, read on for an elevator pitch!</p>



<p><em>Writing a C Compiler</em> is a hands-on guide to, well, writing your own C compiler. It takes the same basic approach as the <a href="https://www.dropbox.com/2017/11/29/Write-a-Compiler.html">series</a> of blog posts I published here a few years ago. You start out by compiling the tiniest possible C program to x64 assembly, then add a new feature in each chapter. This book is all about compiling a real, widely used programming language into real assembly code, with all the low-level details and ugly edge cases that entails.</p>

<p>At the same time, I wanted to write this book for a broad audience, not just people who already know assembly code or have the C standard memorized. So I’ve tried to lay the whole process–ugly edge cases included–in a way that’s accessible, easy to follow, and maybe even fun. The implementation code in the book is all pseudocode, so you can implement your compiler in whatever language you want!</p>

<p>Here’s a non-exhaustive look at what you’ll learn:
<a id="outline"></a></p>
<ul>
  <li><strong>Part I</strong> introduces the basics, like expressions, variables, control flow statements, and function calls.</li>
  <li><strong>Part II</strong> adds more types, including floating-point numbers, arrays and pointers, and structs.</li>
  <li><strong>Part III</strong> covers a few classic optimizations, like constant folding, dead code elimination, and register allocation.</li>
</ul>

<p>I didn’t include every feature in the C standard, but I wanted the end result to <em>feel</em> complete. I’ve also tried to cover the fundamentals that you’ll need to know if you want to keep building out new features on your own.</p>



<p>When I started working on the book, I thought that I’d just be building on the existing series. But the implementation in the book quickly diverged from what I’d originally posted. The most obvious problem is that the original design produced 32-bit x86 assembly, which was quickly becoming obsolete even when I first started the project back in 2017.</p>

<p>The other problem was that I needed a new intermediate representation. Converting the AST directly to assembly worked well for the first few chapters, but got more and more unwieldy as the project went on. I knew that things would only get worse as I started to add new types, and optimizations were going to be really difficult. The new implementation converts the program to <a href="https://en.wikipedia.org/wiki/Three-address_code">three-address code</a> before it generates assembly.</p>

<p>The upshot is that I won’t be continuing the series on this blog. The good news, of course, is that you can finish your compiler by working through the book, which covers <a href="#outline">a lot more ground</a>! The bad news is that you won’t be able to skip straight to Part II; you’ll have to bring your backend in line with the implementation described in Part I first. Hopefully, the payoff of finishing your compiler will be well worth the extra work!</p>

  </div>
</article>

      </div>
    </div></div>
  </body>
</html>
