<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://corrode.dev/blog/pitfalls-of-safe-rust/">Original</a>
    <h1>Pitfalls of Safe Rust</h1>
    
    <div id="readability-page-1" class="page"><div>
    
    <div>
    

      <p>When people say Rust is a ‚Äúsafe language‚Äù, they often mean memory safety.
And while memory safety is a great start, it‚Äôs far from all it takes to build robust applications.</p>
<p><strong>Memory safety is important but not sufficient for overall reliability.</strong></p>
<p>In this article, I want to show you a few common gotchas in safe Rust that the compiler doesn‚Äôt detect and how to avoid them.</p>
<h2 id="why-rust-can-t-always-help"><a href="#why-rust-can-t-always-help" aria-label="Anchor link for: why-rust-can-t-always-help">Why Rust Can‚Äôt Always Help</a></h2>
<p>Even in safe Rust code, you still need to handle various risks and edge cases.
You need to address aspects like input validation and making sure that your business logic is correct.</p>
<p>Here are just a few categories of bugs that Rust <strong>doesn‚Äôt</strong> protect you from:</p>
<ul>
<li>Type casting mistakes (e.g. overflows)</li>
<li>Logic bugs</li>
<li>Panics because of using <code>unwrap</code> or <code>expect</code></li>
<li>Malicious or incorrect <code>build.rs</code> scripts in third-party crates</li>
<li>Incorrect unsafe code in third-party libraries</li>
<li>Race conditions</li>
</ul>
<p>Let‚Äôs look at ways to avoid some of the more common problems.
The tips are roughly ordered by how likely you are to encounter them.</p>
<h2 id="table-of-contents"><a href="#table-of-contents" aria-label="Anchor link for: table-of-contents">Table of Contents</a></h2>
<details>
<summary>
Click here to expand the table of contents.
</summary>
<ul>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#protect-against-integer-overflow">Protect Against Integer Overflow</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#avoid-as-for-numeric-conversions">Avoid <code>as</code> For Numeric Conversions</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#use-bounded-types-for-numeric-values">Use Bounded Types for Numeric Values</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#don-t-index-into-arrays-without-bounds-checking">Don‚Äôt Index Into Arrays Without Bounds Checking</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#use-split-at-checked-instead-of-split-at">Use <code>split_at_checked</code> Instead Of <code>split_at</code></a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#make-invalid-states-unrepresentable">Make Invalid States Unrepresentable</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#avoid-primitive-types-for-business-logic">Avoid Primitive Types For Business Logic</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#handle-default-values-carefully">Handle Default Values Carefully</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#implement-debug-safely">Implement <code>Debug</code> Safely</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#careful-with-serialization">Careful With Serialization</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#protect-against-time-of-check-to-time-of-use-toctou">Protect Against Time-of-Check to Time-of-Use (TOCTOU)</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#use-constant-time-comparison-for-sensitive-data">Use Constant-Time Comparison for Sensitive Data</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#don-t-accept-unbounded-input">Don‚Äôt Accept Unbounded Input</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#surprising-behavior-of-path-join-with-absolute-paths">Surprising Behavior of <code>Path::join</code> With Absolute Paths</a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#check-for-unsafe-code-in-your-dependencies-with-cargo-geiger">Check For Unsafe Code In Your Dependencies With <code>cargo-geiger</code></a></li>
<li><a href="https://corrode.dev/blog/pitfalls-of-safe-rust/#conclusion">Conclusion</a></li>
</ul>
</details>
<h2 id="protect-against-integer-overflow"><a href="#protect-against-integer-overflow" aria-label="Anchor link for: protect-against-integer-overflow">Protect Against Integer Overflow</a></h2>
<p>Overflow errors can happen pretty easily:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Use unchecked arithmetic
</span></span><span><span><span><span>fn</span> </span><span>calculate_total</span></span><span><span><span>(</span><span>price</span><span>:</span> <span>u32</span>, <span>quantity</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>u32</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    price <span>*</span> quantity  <span><span>//</span> Could overflow!
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>If <code>price</code> and <code>quantity</code> are large enough, the result will overflow.
Rust will panic in debug mode, but in release mode, it will silently wrap around.</p>
<p>To avoid this, use checked arithmetic operations:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DO: Use checked arithmetic operations
</span></span><span><span><span><span>fn</span> </span><span>calculate_total</span></span><span><span><span>(</span><span>price</span><span>:</span> <span>u32</span>, <span>quantity</span><span>:</span> <span>u32</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>u32</span>, ArithmeticError<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    price<span>.</span><span>checked_mul</span><span><span>(</span>quantity</span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>ok_or</span><span><span>(</span><span>ArithmeticError<span>::</span></span>Overflow</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Static checks are not removed since they don‚Äôt affect the performance of generated code.
So if the compiler is able to detect the problem at compile time, it will do so:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> x<span>:</span> <span>u8</span> <span>=</span> <span>2</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> y<span>:</span> <span>u8</span> <span>=</span> <span>128</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> z <span>=</span> x <span>*</span> y<span>;</span>  <span><span>//</span> Compile-time error!
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The error message will be:</p>
<pre data-lang="rust"><code data-lang="rust"><span>error<span>:</span> this arithmetic operation will overflow
</span><span> <span>-</span><span><span>-&gt;</span> src</span><span>/</span>main<span>.</span>rs<span>:</span><span>4</span><span>:</span><span>13</span>
</span><span>  <span>|</span>
</span><span><span>4</span> <span>|</span>     <span>let</span> z <span>=</span> x <span>*</span> y<span>;</span>  <span><span>//</span> Compile-time error!
</span></span><span>  <span>|</span>             <span>^</span><span>^</span><span>^</span><span>^</span><span>^</span> attempt to compute `<span>2_</span><span>u8</span> <span>*</span> <span>128_</span><span>u8</span>`<span>,</span> which would overflow
</span><span>  <span>|</span>
</span><span>  <span>=</span> note<span>:</span> `<span><span>#</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>arithmetic_overflow</span></span><span><span><span>)</span></span></span><span>]</span></span>` on by default
</span></code></pre>
<p>For all other cases, use <a href="https://docs.rs/num/latest/num/trait.CheckedAdd.html"><code>checked_add</code></a>, <a href="https://docs.rs/num/latest/num/trait.CheckedSub.html"><code>checked_sub</code></a>, <a href="https://docs.rs/num/latest/num/trait.CheckedMul.html"><code>checked_mul</code></a>, and <a href="https://docs.rs/num/latest/num/trait.CheckedDiv.html"><code>checked_div</code></a>, which return <code>None</code> instead of wrapping around on underflow or overflow. <sup id="fr-intrinsics_docs-1"><a href="#fn-intrinsics_docs">1</a></sup></p>
<div>
  
  <div>
    
      <h4><p>Quick Tip: Enable Overflow Checks In Release Mode</p>
</h4>
  </div>
  
  <p>Rust carefully balances performance and safety.
In scenarios where a performance hit is acceptable, memory safety takes precedence. <sup id="fr-memory_safety-1"><a href="#fn-memory_safety">1</a></sup></p>
<p>Integer overflows can lead to unexpected results, but they are not inherently unsafe.
On top of that, overflow checks can be expensive, which is why Rust disables them in release mode. <sup id="fr-overflow-1"><a href="#fn-overflow">2</a></sup></p>
<p>However, you can re-enable them in case your application can trade the last 1%
of performance for better overflow detection.</p>
<p>Put this into your <code>Cargo.toml</code>:</p>
<pre data-lang="toml"><code data-lang="toml"><span><span>[</span><span><span>profile</span><span>.</span><span>release</span></span><span>]</span>
</span><span><span><span>overflow-checks</span></span> <span>=</span> <span>true</span> <span><span>#</span> Enable integer overflow checks in release mode</span>
</span></code></pre>
<p>This will enable overflow checks in release mode. As a consequence,
the code will panic if an overflow occurs.</p>
<p>See <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#release">the docs</a>
for more details.</p>


</div>
<h2 id="avoid-as-for-numeric-conversions"><a href="#avoid-as-for-numeric-conversions" aria-label="Anchor link for: avoid-as-for-numeric-conversions">Avoid <code>as</code> For Numeric Conversions</a></h2>
<p>While we‚Äôre on the topic of integer arithmetic, let‚Äôs talk about type conversions.
Casting values with <code>as</code> is convenient but risky unless you know exactly what you are doing.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> x<span>:</span> <span>i32</span> <span>=</span> <span>42</span><span>;</span>
</span><span><span>let</span> y<span>:</span> <span>i8</span> <span>=</span> x <span>as</span> <span>i8</span><span>;</span>  <span><span>//</span> Can overflow!
</span></span></code></pre>
<p>There are three main ways to convert between numeric types in Rust:</p>
<ol>
<li>
<p>‚ö†Ô∏è Using the <code>as</code> keyword: This approach works for both lossless and lossy conversions. In cases where data loss might occur (like converting from <code>i64</code> to <code>i32</code>), <strong>it will simply truncate the value</strong>.</p>
</li>
<li>
<p>Using <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from()</code></a>: This method only allows <strong>lossless conversions</strong>. For example, you can convert from <code>i32</code> to <code>i64</code> since all 32-bit integers can fit within 64 bits. However, you cannot convert from <code>i64</code> to <code>i32</code> using this method since it could potentially lose data.</p>
</li>
<li>
<p>Using <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html"><code>TryFrom</code></a>: This method is similar to <code>From::from()</code> but returns a <code>Result</code> instead of panicking. This is useful when you want to handle potential data loss gracefully.</p>
</li>
</ol>
<div>
  
  <div>
    
      <h4><p>Quick Tip: Safe Numeric Conversions</p>
</h4>
  </div>
  
  <p><strong>If in doubt, prefer <code>From::from()</code> and <code>TryFrom</code> over <code>as</code>.</strong></p>
<ul>
<li>use <code>From::from()</code> when you can guarantee no data loss.</li>
<li>use <code>TryFrom</code> when you need to handle potential data loss gracefully.</li>
<li>only use <code>as</code> when you‚Äôre comfortable with potential truncation or know the values will fit within the target type‚Äôs range and when performance is absolutely critical.</li>
</ul>
<p>(<em>Adapted from <a href="https://stackoverflow.com/a/28280042/270334">StackOverflow answer by delnan</a> and <a href="https://stackoverflow.com/a/48795524/270334">additional context</a>.</em>)</p>

</div>
<p>The <code>as</code> operator is <strong>not safe for narrowing conversions</strong>.
It will silently truncate the value, leading to unexpected results.</p>
<p>What is a narrowing conversion?
It‚Äôs when you convert a larger type to a smaller type, e.g. <code>i32</code> to <code>i8</code>.</p>
<p>For example, see how <code>as</code> chops off the high bits from our value:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> a<span>:</span> <span>u16</span> <span>=</span> <span>0x1234</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> b<span>:</span> <span>u8</span> <span>=</span> a <span>as</span> <span>u8</span><span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>0x<span>{:04x}</span>, 0x<span>{:02x}</span><span>&#34;</span></span></span><span><span>,</span> a<span>,</span> b<span>)</span></span><span>;</span> <span><span>//</span> 0x1234, 0x34
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>So, coming back to our first example above, instead of writing</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> x<span>:</span> <span>i32</span> <span>=</span> <span>42</span><span>;</span>
</span><span><span>let</span> y<span>:</span> <span>i8</span> <span>=</span> x <span>as</span> <span>i8</span><span>;</span>  <span><span>//</span> Can overflow!
</span></span></code></pre>
<p>use <code>TryFrom</code> instead and handle the error gracefully:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> y <span>=</span> <span>i8</span><span><span>::</span></span>try_from<span><span>(</span>x</span><span><span>)</span></span><span>.</span><span>ok_or</span><span><span>(</span><span><span>&#34;</span>Number is too big to be used here<span>&#34;</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></code></pre>
<h2 id="use-bounded-types-for-numeric-values"><a href="#use-bounded-types-for-numeric-values" aria-label="Anchor link for: use-bounded-types-for-numeric-values">Use Bounded Types for Numeric Values</a></h2>
<p>Bounded types make it easier to express invariants and avoid invalid states.</p>
<p>E.g. if you have a numeric type and 0 is <em>never</em> a correct value, use <a href="https://doc.rust-lang.org/std/num/type.NonZeroUsize.html"><code>std::num::NonZeroUsize</code></a> instead.</p>
<p>You can also create your own bounded types:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Use raw numeric types for domain values
</span></span><span><span><span>struct</span> </span><span><span>Measurement</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>distance</span><span>:</span> <span>f64</span>,  <span><span>//</span> Could be negative!
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> DO: Create bounded types
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> Clone<span>,</span> Copy</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>Distance</span></span><span><span><span>(</span><span>f64</span></span><span>)</span></span><span>;</span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>Distance</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>value</span><span>:</span> <span>f64</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, DistanceError<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>if</span> value <span>&lt;</span> <span>0.</span><span>0</span> <span>||</span> <span>!</span>value<span>.</span><span>is_finite</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span>DistanceError<span>::</span></span>Invalid</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        <span>Ok</span><span><span>(</span>Distance<span><span>(</span>value</span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Measurement</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>distance</span><span>:</span> Distance,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a9157c58ada88e85b82d835a5eceac66">Rust Playground</a>)</p>
<h2 id="don-t-index-into-arrays-without-bounds-checking"><a href="#don-t-index-into-arrays-without-bounds-checking" aria-label="Anchor link for: don-t-index-into-arrays-without-bounds-checking">Don‚Äôt Index Into Arrays Without Bounds Checking</a></h2>
<p>Whenever I see the following, I get goosebumps üò®:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> arr <span>=</span> <span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span></span><span>;</span>
</span><span><span>let</span> elem <span>=</span> arr<span><span>[</span><span>3</span><span>]</span></span><span>;</span>  <span><span>//</span> Panic!
</span></span></code></pre>
<p>That‚Äôs a common source of bugs.
Unlike C, Rust <em>does</em> check array bounds and prevents a security vulnerability,
but <strong>it still panics at runtime</strong>.</p>
<p>Instead, use the <code>get</code> method:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> elem <span>=</span> arr<span>.</span><span>get</span><span><span>(</span><span>3</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>It returns an <code>Option</code> which you can now handle gracefully.</p>
<p>See <a href="https://shnatsel.medium.com/how-to-avoid-bounds-checks-in-rust-without-unsafe-f65e618b4c1e">this blog post</a> for more info on the topic.</p>
<h2 id="use-split-at-checked-instead-of-split-at"><a href="#use-split-at-checked-instead-of-split-at" aria-label="Anchor link for: use-split-at-checked-instead-of-split-at">Use <code>split_at_checked</code> Instead Of <code>split_at</code></a></h2>
<p>This issue is related to the previous one.
Say you have a slice and you want to split it at a certain index.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> mid <span>=</span> <span>4</span><span>;</span>
</span><span><span>let</span> arr <span>=</span> <span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span></span><span>;</span>
</span><span><span>let</span> <span><span>(</span>left<span>,</span> right</span><span><span>)</span></span> <span>=</span> arr<span>.</span><span>split_at</span><span><span>(</span>mid</span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>You might expect that this returns a tuple of slices where the first slice contains all elements
and the second slice is empty.</p>
<p><strong>Instead, the above code will panic because the mid index is out of bounds!</strong></p>
<p>To handle that more gracefully, use <code>split_at_checked</code> instead:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>let</span> arr <span>=</span> <span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span></span><span>;</span>
</span><span><span><span>//</span> This returns an Option
</span></span><span><span>match</span> arr<span>.</span><span>split_at_checked</span><span><span>(</span>mid</span><span><span>)</span></span> <span><span>{</span>
</span></span><span><span>    <span>Some</span><span><span>(</span><span><span>(</span>left<span>,</span> right</span><span><span>)</span></span></span><span><span>)</span></span> <span>=&gt;</span> <span><span>{</span>
</span></span></span><span><span><span>        <span><span>//</span> Do something with left and right
</span></span></span></span><span><span><span>    </span><span><span>}</span></span>
</span></span><span><span>    <span>None</span> <span>=&gt;</span> <span><span>{</span>
</span></span></span><span><span><span>        <span><span>//</span> Handle the error
</span></span></span></span><span><span><span>    </span><span><span>}</span></span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>This returns an <code>Option</code> which allows you to handle the error case.
(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8208b1a16e73e63d37799fed27cd1e49">Rust Playground</a>)</p>
<p>More info about <code>split_at_checked</code> <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_checked">here</a>.</p>
<h2 id="avoid-primitive-types-for-business-logic"><a href="#avoid-primitive-types-for-business-logic" aria-label="Anchor link for: avoid-primitive-types-for-business-logic">Avoid Primitive Types For Business Logic</a></h2>
<p>It‚Äôs very tempting to use primitive types for everything.
Especially Rust beginners fall into this trap.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Use primitive types for usernames
</span></span><span><span><span><span>fn</span> </span><span>authenticate_user</span></span><span><span><span>(</span><span>username</span><span>:</span> String</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Raw String could be anything - empty, too long, or contain invalid characters
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>However, do you really accept any string as a valid username?
What if it‚Äôs empty? What if it contains emojis or special characters?</p>
<p>You can create a custom type for your domain instead:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> Clone<span>,</span> PartialEq<span>,</span> Eq<span>,</span> Hash</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>Username</span></span><span><span><span>(</span>String</span><span>)</span></span><span>;</span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>Username</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>name</span><span>:</span> <span>&amp;</span><span>str</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, UsernameError<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> Check for empty username
</span></span></span></span></span></span><span><span><span><span><span>        <span>if</span> name<span>.</span><span>is_empty</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span>UsernameError<span>::</span></span>Empty</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> Check length (for example, max 30 characters)
</span></span></span></span></span></span><span><span><span><span><span>        <span>if</span> name<span>.</span><span>len</span><span><span>(</span></span><span><span>)</span></span> <span>&gt;</span> <span>30</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span>UsernameError<span>::</span></span>TooLong</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> Only allow alphanumeric characters and underscores
</span></span></span></span></span></span><span><span><span><span><span>        <span>if</span> <span>!</span>name<span>.</span><span>chars</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>all</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>c</span><span>|</span></span> </span><span>c<span>.</span><span>is_alphanumeric</span><span><span>(</span></span><span><span>)</span></span> <span>||</span> c <span>==</span> <span><span>&#39;</span>_<span>&#39;</span></span></span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span>UsernameError<span>::</span></span>InvalidCharacters</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>Ok</span><span><span>(</span>Username<span><span>(</span>name<span>.</span><span>to_string</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>///</span> Allow to get a reference to the inner string
</span></span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>as_str</span></span><span><span><span>(</span><span>&amp;</span><span>self</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>&amp;</span><span>str</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>&amp;</span><span>self</span><span>.</span><span>0</span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>authenticate_user</span></span><span><span><span>(</span><span>username</span><span>:</span> Username</span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> We know this is always a valid username!
</span></span></span></span><span><span><span>    <span><span>//</span> No empty strings, no emojis, no spaces, etc.
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=fe47108e246366718d7759eb7abf02f3">Rust playground</a>)</p>
<h2 id="make-invalid-states-unrepresentable"><a href="#make-invalid-states-unrepresentable" aria-label="Anchor link for: make-invalid-states-unrepresentable">Make Invalid States Unrepresentable</a></h2>
<p>The next point is closely related to the previous one.</p>
<p>Can you spot the bug in the following code?</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Allow invalid combinations
</span></span><span><span><span>struct</span> </span><span><span>Configuration</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>port</span><span>:</span> <span>u16</span>,
</span></span></span><span><span><span>    <span>host</span><span>:</span> String,
</span></span></span><span><span><span>    <span>ssl</span><span>:</span> <span>bool</span>,
</span></span></span><span><span><span>    <span>ssl_cert</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span></span>, 
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>The problem is that you can have <code>ssl</code> set to <code>true</code> but <code>ssl_cert</code> set to <code>None</code>.
That‚Äôs an invalid state! If you try to use the SSL connection, you can‚Äôt because there‚Äôs no certificate.
This issue can be detected at compile-time:</p>
<p>Use types to enforce valid states:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> First, let&#39;s define the possible states for the connection
</span></span><span><span><span>enum</span> <span>ConnectionSecurity</span> <span><span>{</span>
</span></span></span><span><span><span>    Insecure<span>,</span>
</span></span></span><span><span><span>    <span><span>//</span> We can&#39;t have an SSL connection
</span></span></span></span><span><span><span>    <span><span>//</span> without a certificate!
</span></span></span></span><span><span><span>    Ssl <span><span>{</span> cert_path<span>:</span> <span>String</span> </span><span><span>}</span></span><span>,</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Configuration</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>port</span><span>:</span> <span>u16</span>,
</span></span></span><span><span><span>    <span>host</span><span>:</span> String,
</span></span></span><span><span><span>    <span><span>//</span> Now we can&#39;t have an invalid state!
</span></span></span></span><span><span><span>    <span><span>//</span> Either we have an SSL connection with a certificate
</span></span></span></span><span><span><span>    <span><span>//</span> or we don&#39;t have SSL at all.
</span></span></span></span><span><span><span>    <span>security</span><span>:</span> ConnectionSecurity,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>In comparison to the previous section, the bug was caused by an <em>invalid combination of closely related fields</em>.
To prevent that, clearly map out all possible states and transitions between them.
A simple way is to define an enum with optional metadata for each state.</p>
<p>If you‚Äôre curious to learn more, here is a more in-depth <a href="https://vrklovespaper.substack.com/blog/illegal-state/">blog post on the topic</a>.</p>
<h2 id="handle-default-values-carefully"><a href="#handle-default-values-carefully" aria-label="Anchor link for: handle-default-values-carefully">Handle Default Values Carefully</a></h2>
<p>It‚Äôs quite common to add a blanket <code>Default</code> implementation to your types.
But that can lead to unforeseen issues.</p>
<p>For example, here‚Äôs a case where the port is set to 0 by default, which is not a valid port number.<sup id="fr-port-1"><a href="#fn-port">2</a></sup></p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Implement `Default` without consideration
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Default</span></span><span><span><span>)</span></span></span><span>]</span></span>  <span><span>//</span> Might create invalid states!
</span></span><span><span><span>struct</span> </span><span><span>ServerConfig</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>port</span><span>:</span> <span>u16</span>,      <span><span>//</span> Will be 0, which isn&#39;t a valid port!
</span></span></span></span><span><span><span>    <span>max_connections</span><span>:</span> <span>usize</span>,
</span></span></span><span><span><span>    <span>timeout_seconds</span><span>:</span> <span>u64</span>,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Instead, consider if a default value makes sense for your type.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DO: Make Default meaningful or don&#39;t implement it
</span></span><span><span><span>struct</span> </span><span><span>ServerConfig</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>port</span><span>:</span> Port,
</span></span></span><span><span><span>    <span>max_connections</span><span>:</span> NonZeroUsize,
</span></span></span><span><span><span>    <span>timeout_seconds</span><span>:</span> Duration,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>ServerConfig</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>pub</span> <span>fn</span> </span><span>new</span></span><span><span><span>(</span><span>port</span><span>:</span> Port</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>Self</span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>Self</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            port<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            max_connections<span>:</span> <span>NonZeroUsize<span>::</span></span>new<span><span>(</span><span>100</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            timeout_seconds<span>:</span> <span>Duration<span>::</span></span>from_secs<span><span>(</span><span>30</span></span><span><span>)</span></span><span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="implement-debug-safely"><a href="#implement-debug-safely" aria-label="Anchor link for: implement-debug-safely">Implement <code>Debug</code> Safely</a></h2>
<p>If you blindly derive <code>Debug</code> for your types, you might expose sensitive data.
Instead, implement <code>Debug</code> manually for types that contain sensitive information.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Expose sensitive data in debug output
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>User</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>username</span><span>:</span> String,
</span></span></span><span><span><span>    <span>password</span><span>:</span> String,  <span><span>//</span> Will be printed in debug output!
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Instead, you could write:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DO: Implement Debug manually
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>User</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>username</span><span>:</span> String,
</span></span></span><span><span><span>    <span>password</span><span>:</span> Password,
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>struct</span> </span><span><span>Password</span></span><span><span><span>(</span>String</span><span>)</span></span><span>;</span>
</span><span>
</span><span><span><span>impl</span> </span><span><span>std<span>::</span></span><span>fmt<span>::</span></span>Debug <span>for</span></span><span> <span>Password</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>fmt</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>f</span><span>:</span> <span>&amp;</span><span>mut</span> <span>std<span>::</span></span><span>fmt<span>::</span></span><span>Formatter<span>&lt;</span>&#39;<span>_</span><span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>std<span>::</span></span><span>fmt<span>::</span></span>Result</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        f<span>.</span><span>write_str</span><span><span>(</span><span><span>&#34;</span>[REDACTED]<span>&#34;</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> user <span>=</span> User <span><span>{</span>
</span></span></span></span><span><span><span><span>        username<span>:</span> <span>String</span><span><span>::</span></span>from<span><span>(</span><span><span>&#34;</span><span>&#34;</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span><span><span><span><span>        password<span>:</span> Password<span><span>(</span><span>String</span><span><span>::</span></span>from<span><span>(</span><span><span>&#34;</span><span>&#34;</span></span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span><span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{user:#?}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>This prints</p>
<pre data-lang="rust"><code data-lang="rust"><span>User <span><span>{</span>
</span></span><span><span>    username<span>:</span> <span><span>&#34;</span><span>&#34;</span></span><span>,</span>
</span></span><span><span>    password<span>:</span> <span><span>[</span><span>REDACTED</span><span>]</span></span><span>,</span>
</span></span><span><span></span><span><span>}</span></span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8fd18d9e13f60193bc14e97ea258707e">Rust playground</a>)</p>
<p>For production code, use a crate like <a href="https://crates.io/crates/secrecy"><code>secrecy</code></a>.</p>
<p>However, it‚Äôs not black and white either:
If you implement <code>Debug</code> manually, you might forget to update the implementation when your struct changes.
A common pattern is to destructure the struct in the <code>Debug</code> implementation to catch such errors.</p>
<p>Instead of this:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> don&#39;t
</span></span><span><span><span>impl</span> </span><span><span>std<span>::</span></span><span>fmt<span>::</span></span>Debug <span>for</span></span><span> <span>DatabaseURI</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>fmt</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>f</span><span>:</span> <span>&amp;</span><span>mut</span> <span>std<span>::</span></span><span>fmt<span>::</span></span><span>Formatter<span>&lt;</span>&#39;<span>_</span><span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>std<span>::</span></span><span>fmt<span>::</span></span>Result</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span>write!</span><span><span>(</span></span><span>f,</span><span> <span><span>&#34;</span><span>{}</span>://<span>{}</span>:[REDACTED]@<span>{}</span>/<span>{}</span><span>&#34;</span></span></span><span><span>,</span> <span>self</span><span>.</span>scheme<span>,</span> <span>self</span><span>.</span>user<span>,</span> <span>self</span><span>.</span>host<span>,</span> <span>self</span><span>.</span>database<span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>How about destructuring the struct to catch changes?</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> do
</span></span><span><span><span>impl</span> </span><span><span>std<span>::</span></span><span>fmt<span>::</span></span>Debug <span>for</span></span><span> <span>DatabaseURI</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>fmt</span></span><span><span><span>(</span><span>&amp;</span><span>self</span>, <span>f</span><span>:</span> <span>&amp;</span><span>mut</span> <span>std<span>::</span></span><span>fmt<span>::</span></span><span>Formatter<span>&lt;</span>&#39;<span>_</span><span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>std<span>::</span></span><span>fmt<span>::</span></span>Result</span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>       <span><span>//</span> Destructure the struct to catch changes
</span></span></span></span></span></span><span><span><span><span><span>       <span><span>//</span> This way, the compiler will warn you if you add a new field
</span></span></span></span></span></span><span><span><span><span><span>       <span><span>//</span> and forget to update the Debug implementation
</span></span></span></span></span></span><span><span><span><span><span>        <span>let</span> DatabaseURI <span><span>{</span> scheme<span>,</span> user<span>,</span> password<span>:</span> <span>_</span><span>,</span> host<span>,</span> database<span>,</span> </span><span><span>}</span></span> <span>=</span> <span>self</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span>write!</span><span><span>(</span></span><span>f,</span><span> <span><span>&#34;</span><span>{scheme}</span>://<span>{user}</span>:[REDACTED]@<span>{host}</span>/<span>{database}</span><span>&#34;</span></span></span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> -- or --
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> f.debug_struct(&#34;DatabaseURI&#34;)
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span>     .field(&#34;scheme&#34;, scheme)
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span>     .field(&#34;user&#34;, user)
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span>     .field(&#34;password&#34;, &amp;&#34;***&#34;)
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span>     .field(&#34;host&#34;, host)
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span>     .field(&#34;database&#34;, database)
</span></span></span></span></span></span><span><span><span><span><span>        <span><span>//</span>     .finish()
</span></span></span></span></span></span><span><span><span><span><span>
</span></span></span></span></span><span><span><span><span><span>        <span>Ok</span><span><span>(</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=a2facbaa5290f9518072ac214df370aa">Rust playground</a>)</p>
<p>Thanks to <a href="https://www.wezm.net">Wesley Moore (wezm)</a> for the hint and to <a href="https://github.com/M3t0r">Simon Br√ºggen (m3t0r)</a> for the example.</p>
<h2 id="careful-with-serialization"><a href="#careful-with-serialization" aria-label="Anchor link for: careful-with-serialization">Careful With Serialization</a></h2>
<p>Don‚Äôt blindly derive <code>Serialize</code> and <code>Deserialize</code> ‚Äì especially for sensitive data.
The values you read/write might not be what you expect!</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Blindly derive Serialize and Deserialize 
</span></span><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Serialize<span>,</span> Deserialize</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>struct</span> </span><span><span>UserCredentials</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>#</span><span>[</span><span>serde</span><span><span><span>(</span></span></span><span><span>default</span></span><span><span><span>)</span></span></span><span>]</span></span>  <span><span>//</span> ‚ö†Ô∏è Accepts empty strings when deserializing!
</span></span></span></span><span><span><span>    <span>username</span><span>:</span> String,
</span></span></span><span><span><span>    <span><span>#</span><span>[</span><span>serde</span><span><span><span>(</span></span></span><span><span>default</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span></span></span><span><span><span>    <span>password</span><span>:</span> String, <span><span>//</span> ‚ö†Ô∏è Leaks the password when serialized!
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>When deserializing, the fields might be empty.
Empty credentials could potentially pass validation checks if not properly handled</p>
<p>On top of that, the serialization behavior could also leak sensitive data.
By default, <code>Serialize</code> will include the password field in the serialized output, which could expose sensitive credentials in logs, API responses, or debug output.</p>
<p>A common fix is to implement your own custom serialization and deserialization methods by using <code>impl&lt;&#39;de&gt; Deserialize&lt;&#39;de&gt; for UserCredentials</code>.</p>
<p>The advantage is that you have full control over input validation.
However, the disadvantage is that you need to implement all the logic yourself.</p>
<p>An alternative strategy is to use the <code>#[serde(try_from = &#34;FromType&#34;)]</code> attribute.</p>
<p>Let‚Äôs take the <code>Password</code> field as an example.
Start by using the newtype pattern to wrap the standard types and add custom validation:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Deserialize</span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>//</span> Tell serde to call `Password::try_from` with a `String`
</span></span><span><span><span>#</span><span>[</span><span>serde</span><span><span><span>(</span></span></span><span><span>try_from <span>=</span> <span><span>&#34;</span>String<span>&#34;</span></span></span></span><span><span><span>)</span></span></span><span>]</span></span>
</span><span><span><span>pub</span> <span>struct</span> </span><span><span>Password</span></span><span><span><span>(</span>String</span><span>)</span></span><span>;</span>
</span></code></pre>
<p>Now implement <code>TryFrom</code> for <code>Password</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>impl</span> </span><span><span>TryFrom<span>&lt;</span><span>String</span><span>&gt;</span></span> <span>for</span></span><span> <span>Password</span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>type</span> <span>Error</span> <span>=</span> PasswordError<span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>///</span> Create a new password
</span></span></span></span><span><span><span>    <span><span>///</span>
</span></span></span></span><span><span><span>    <span><span>///</span> Throws an error if the password is too short.
</span></span></span></span><span><span><span>    <span><span>///</span> You can add more checks here.
</span></span></span></span><span><span><span>    <span><span><span>fn</span> </span><span>try_from</span></span><span><span><span>(</span><span>value</span><span>:</span> String</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>Self</span>, <span><span><span>Self</span><span>::</span></span></span>Error<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span></span></span><span><span><span><span><span>        <span><span>//</span> Validate the password
</span></span></span></span></span></span><span><span><span><span><span>        <span>if</span> value<span>.</span><span>len</span><span><span>(</span></span><span><span>)</span></span> <span>&lt;</span> <span>8</span> <span><span>{</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>return</span> <span>Err</span><span><span>(</span><span>PasswordError<span>::</span></span>TooShort</span><span><span>)</span></span><span>;</span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>}</span></span>
</span></span></span></span></span><span><span><span><span><span>        <span>Ok</span><span><span>(</span>Password<span><span>(</span>value</span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span></span></span><span><span><span><span><span>    </span><span><span>}</span></span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>With this trick, you can no longer deserialize invalid passwords:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> Panic: password too short!
</span></span><span><span>let</span> password<span>:</span> Password <span>=</span> <span>serde_json<span>::</span></span>from_str<span><span>(</span><span><span>r</span><span>#&#34;</span>&#34;pass&#34;<span>&#34;#</span></span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>(Try it on the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ba0f1a45d5ac982b00a5b5f68a1a0d9e">Rust Playground</a>)</p>
<p>Credits go to <a href="https://dev.to/equalma/validate-fields-and-types-in-serde-with-tryfrom-c2n">EqualMa‚Äôs article on dev.to</a> and to <a href="https://github.com/durka">Alex Burka (durka)</a> for the hint.</p>
<h2 id="protect-against-time-of-check-to-time-of-use-toctou"><a href="#protect-against-time-of-check-to-time-of-use-toctou" aria-label="Anchor link for: protect-against-time-of-check-to-time-of-use-toctou">Protect Against Time-of-Check to Time-of-Use (TOCTOU)</a></h2>
<p>This is a more advanced topic, but it‚Äôs important to be aware of it.
TOCTOU (time-of-check to time-of-use) is a class of software bugs caused by changes that happen between when you check a condition and when you use a resource.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Vulnerable approach with separate check and use
</span></span><span><span><span><span>fn</span> </span><span>remove_dir</span></span><span><span><span>(</span><span>path</span><span>:</span> <span>&amp;</span>Path</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>io<span>::</span></span><span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> First check if it&#39;s a directory
</span></span></span></span><span><span><span>    <span>if</span> <span>!</span>path<span>.</span><span>is_dir</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>return</span> <span>Err</span><span><span>(</span><span>io<span>::</span></span><span>Error<span>::</span></span>new<span><span>(</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span>io<span>::</span></span><span>ErrorKind<span>::</span></span>NotADirectory<span>,</span>
</span></span></span></span></span></span><span><span><span><span><span><span>            <span><span>&#34;</span>not a directory<span>&#34;</span></span>
</span></span></span></span></span></span><span><span><span><span><span><span>        </span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span><span>//</span> TOCTOU vulnerability: Between the check above and the use below,
</span></span></span></span><span><span><span>    <span><span>//</span> the path could be replaced with a symlink to a directory we shouldn&#39;t access!
</span></span></span></span><span><span><span>    <span>remove_dir_impl</span><span><span>(</span>path</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=fb208eb58e49ce70bde77a48b9b102d1">Rust playground</a>)</p>
<p>The safer approach opens the directory first, ensuring we operate on what we checked:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DO: Safer approach that opens first, then checks
</span></span><span><span><span><span>fn</span> </span><span>remove_dir</span></span><span><span><span>(</span><span>path</span><span>:</span> <span>&amp;</span>Path</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>io<span>::</span></span><span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> Open the directory WITHOUT following symlinks
</span></span></span></span><span><span><span>    <span>let</span> handle <span>=</span> <span>OpenOptions<span>::</span></span>new<span><span>(</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>read</span><span><span>(</span><span>true</span></span><span><span>)</span></span>
</span></span></span><span><span><span>        <span>.</span><span>custom_flags</span><span><span>(</span><span>O_NOFOLLOW</span> <span>|</span> <span>O_DIRECTORY</span></span><span><span>)</span></span> <span><span>//</span> Fails if not a directory or is a symlink
</span></span></span></span><span><span><span>        <span>.</span><span>open</span><span><span>(</span>path</span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span><span>//</span> Now we can safely remove the directory contents using the open handle
</span></span></span></span><span><span><span>    <span>remove_dir_impl</span><span><span>(</span><span>&amp;</span>handle</span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>(<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=08a3a0a030a1878171e7eb76adb6ffb8">Rust playground</a>)</p>
<p>Here‚Äôs why it‚Äôs safer:
while we hold the handle, the directory can‚Äôt be replaced with a symlink.
This way, the directory we‚Äôre working with is the same as the one we checked.
Any attempt to replace it won‚Äôt affect us because the handle is already open.</p>
<p>You‚Äôd be forgiven if you overlooked this issue before.
In fact, even the Rust core team missed it in the standard library.
What you saw is a simplified version of an actual bug in the <a href="https://doc.rust-lang.org/std/fs/fn.remove_dir_all.html"><code>std::fs::remove_dir_all</code></a> function.
Read more about it in <a href="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html">this blog post about CVE-2022-21658</a>.</p>
<h2 id="use-constant-time-comparison-for-sensitive-data"><a href="#use-constant-time-comparison-for-sensitive-data" aria-label="Anchor link for: use-constant-time-comparison-for-sensitive-data">Use Constant-Time Comparison for Sensitive Data</a></h2>
<p>Timing attacks are a nifty way to extract information from your application.
The idea is that the time it takes to compare two values can leak information about them.
For example, the time it takes to compare two strings can reveal how many characters are correct.
Therefore, for production code, be careful with regular equality checks when handling sensitive data like passwords.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Use regular equality for sensitive comparisons
</span></span><span><span><span><span>fn</span> </span><span>verify_password</span></span><span><span><span>(</span><span>stored</span><span>:</span> <span>&amp;</span>[<span>u8</span>], <span>provided</span><span>:</span> <span>&amp;</span>[<span>u8</span>]</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    stored <span>==</span> provided  <span><span>//</span> Vulnerable to timing attacks!
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span><span>
</span><span><span><span>//</span> DO: Use constant-time comparison
</span></span><span><span>use</span> <span>subtle<span>::</span></span><span><span>{</span>ConstantTimeEq<span>,</span> Choice</span><span><span>}</span></span><span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>verify_password</span></span><span><span><span>(</span><span>stored</span><span>:</span> <span>&amp;</span>[<span>u8</span>], <span>provided</span><span>:</span> <span>&amp;</span>[<span>u8</span>]</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>bool</span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    stored<span>.</span><span>ct_eq</span><span><span>(</span>provided</span><span><span>)</span></span><span>.</span><span>unwrap_u8</span><span><span>(</span></span><span><span>)</span></span> <span>==</span> <span>1</span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="don-t-accept-unbounded-input"><a href="#don-t-accept-unbounded-input" aria-label="Anchor link for: don-t-accept-unbounded-input">Don‚Äôt Accept Unbounded Input</a></h2>
<p>Protect Against Denial-of-Service Attacks with Resource Limits.
These happen when you accept unbounded input, e.g. a huge request body
which might not fit into memory.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> DON&#39;T: Accept unbounded input
</span></span><span><span><span><span>fn</span> </span><span>process_request</span></span><span><span><span>(</span><span>data</span><span>:</span> <span>&amp;</span>[<span>u8</span>]</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>(</span><span>)</span>, Error<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> decoded <span>=</span> <span>decode_data</span><span><span>(</span>data</span><span><span>)</span></span><span>?</span><span>;</span>  <span><span>//</span> Could be enormous!
</span></span></span></span><span><span><span>    <span><span>//</span> Process decoded data
</span></span></span></span><span><span><span>    <span>Ok</span><span><span>(</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>Instead, set explicit limits for your accepted payloads:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>const</span> <span>MAX_REQUEST_SIZE</span><span>:</span> <span>usize</span> <span>=</span> <span>1024</span> <span>*</span> <span>1024</span><span>;</span>  <span><span>//</span> 1MiB
</span></span><span>
</span><span><span><span><span>fn</span> </span><span>process_request</span></span><span><span><span>(</span><span>data</span><span>:</span> <span>&amp;</span>[<span>u8</span>]</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span><span>Result</span><span>&lt;</span><span>(</span><span>)</span>, Error<span>&gt;</span></span></span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>if</span> data<span>.</span><span>len</span><span><span>(</span></span><span><span>)</span></span> <span>&gt;</span> <span>MAX_REQUEST_SIZE</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>return</span> <span>Err</span><span><span>(</span><span>Error<span>::</span></span>RequestTooLarge</span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span>    
</span></span></span><span><span><span>    <span>let</span> decoded <span>=</span> <span>decode_data</span><span><span>(</span>data</span><span><span>)</span></span><span>?</span><span>;</span>
</span></span></span><span><span><span>    <span><span>//</span> Process decoded data
</span></span></span></span><span><span><span>    <span>Ok</span><span><span>(</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="surprising-behavior-of-path-join-with-absolute-paths"><a href="#surprising-behavior-of-path-join-with-absolute-paths" aria-label="Anchor link for: surprising-behavior-of-path-join-with-absolute-paths">Surprising Behavior of <code>Path::join</code> With Absolute Paths</a></h2>
<p>If you use <code>Path::join</code> to join a relative path with an absolute path, it will silently replace the relative path with the absolute path.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>std<span>::</span></span><span>path<span>::</span></span>Path<span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span>let</span> path <span>=</span> <span>Path<span>::</span></span>new<span><span>(</span><span><span>&#34;</span>/usr<span>&#34;</span></span></span><span><span>)</span></span><span>.</span><span>join</span><span><span>(</span><span><span>&#34;</span>/local/bin<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{path:?}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span> <span><span>//</span> Prints &#34;/local/bin&#34; 
</span></span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<p>This is because <code>Path::join</code> will return the second path if it is absolute.</p>
<p>I was not the only one who was confused by this behavior.
Here‚Äôs a <a href="https://users.rust-lang.org/t/rationale-behind-replacing-paths-while-joining/104288">thread on the topic</a>, which also includes an answer by <a href="https://users.rust-lang.org/u/jdahlstrom/summary">Johannes Dahlstr√∂m</a>:</p>
<blockquote>
<p>The behavior is useful because a caller [‚Ä¶] can choose whether it wants to
use a relative or absolute path, and the callee can then simply absolutize it by
adding its own prefix and the absolute path is unaffected which is probably what
the caller wanted. The callee doesn‚Äôt have to separately check whether the path
is absolute or not.</p>
</blockquote>
<p>And yet, I still think it‚Äôs a footgun.
It‚Äôs easy to overlook this behavior when you use user-provided paths.
Perhaps <code>join</code> should return a <code>Result</code> instead?
In any case, be aware of this behavior.</p>
<h2 id="check-for-unsafe-code-in-your-dependencies-with-cargo-geiger"><a href="#check-for-unsafe-code-in-your-dependencies-with-cargo-geiger" aria-label="Anchor link for: check-for-unsafe-code-in-your-dependencies-with-cargo-geiger">Check For Unsafe Code In Your Dependencies With <code>cargo-geiger</code></a></h2>
<p>So far, we‚Äôve only covered issues with your own code.
For production code, you also need to check your dependencies.
Especially unsafe code would be a concern.
This can be quite challenging, especially if you have a lot of dependencies.</p>
<p><a href="https://github.com/geiger-rs/cargo-geiger">cargo-geiger</a> is a neat tool that checks your dependencies for unsafe code.
It can help you identify potential security risks in your project.</p>
<pre data-lang="bash"><code data-lang="bash"><span><span><span>cargo</span></span><span> install cargo-geiger</span>
</span><span><span><span>cargo</span></span><span> geiger</span>
</span></code></pre>
<p>This will give you a report of how many unsafe functions are in your dependencies.
Based on this, you can decide if you want to keep a dependency or not.</p>
<h2 id="clippy-can-prevent-many-of-these-issues"><a href="#clippy-can-prevent-many-of-these-issues" aria-label="Anchor link for: clippy-can-prevent-many-of-these-issues">Clippy Can Prevent Many Of These Issues</a></h2>
<p>Here is a set of clippy lints that can help you catch these issues at compile time.
See for yourself in the <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=26fffd0b9c89822295c4225182238c8c">Rust playground</a>.</p>
<p>Here‚Äôs the gist:</p>
<ul>
<li><code>cargo check</code> will <strong>not</strong> report any issues.</li>
<li><code>cargo run</code> will <strong>panic</strong> or silently fail at runtime.</li>
<li><code>cargo clippy</code> will <strong>catch</strong> all issues at <em>compile time</em> (!) üòé</li>
</ul>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>//</span> Arithmetic
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>arithmetic_overflow</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent operations that would cause integer overflow
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::checked_conversions</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Suggest using checked conversions between numeric types
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::cast_possible_truncation</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Detect when casting might truncate a value
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::cast_sign_loss</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Detect when casting might lose sign information
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::cast_possible_wrap</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Detect when casting might cause value to wrap around
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::cast_precision_loss</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Detect when casting might lose precision
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::integer_division</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Highlight potential bugs from integer division truncation
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::arithmetic_side_effects</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Detect arithmetic operations with potential side effects
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::unchecked_duration_subtraction</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Ensure duration subtraction won&#39;t cause underflow
</span></span><span>
</span><span><span><span>//</span> Unwraps
</span></span><span><span><span>#!</span><span>[</span><span>warn</span><span><span><span>(</span></span></span><span><span>clippy::unwrap_used</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Discourage using .unwrap() which can cause panics
</span></span><span><span><span>#!</span><span>[</span><span>warn</span><span><span><span>(</span></span></span><span><span>clippy::expect_used</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Discourage using .expect() which can cause panics
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::panicking_unwrap</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent unwrap on values known to cause panics
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::option_env_unwrap</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent unwrapping environment variables which might be absent
</span></span><span>
</span><span><span><span>//</span> Array indexing
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::indexing_slicing</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Avoid direct array indexing and use safer methods like .get()
</span></span><span>
</span><span><span><span>//</span> Path handling
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::join_absolute_paths</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent issues when joining paths with absolute paths
</span></span><span>
</span><span><span><span>//</span> Serialization issues
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::serde_api_misuse</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent incorrect usage of Serde&#39;s serialization/deserialization API
</span></span><span>
</span><span><span><span>//</span> Unbounded input
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::uninit_vec</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent creating uninitialized vectors which is unsafe
</span></span><span>
</span><span><span><span>//</span> Unsafe code detection
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::transmute_int_to_char</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent unsafe transmutation from integers to characters
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::transmute_int_to_float</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent unsafe transmutation from integers to floats
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::transmute_ptr_to_ref</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Prevent unsafe transmutation from pointers to references
</span></span><span><span><span>#!</span><span>[</span><span>deny</span><span><span><span>(</span></span></span><span><span>clippy::transmute_undefined_repr</span></span><span><span><span>)</span></span></span><span>]</span></span> <span><span>//</span> Detect transmutes with potentially undefined representations
</span></span><span>
</span><span><span>use</span> <span>std<span>::</span></span><span>path<span>::</span></span>Path<span>;</span>
</span><span><span>use</span> <span>std<span>::</span></span><span>time<span>::</span></span>Duration<span>;</span>
</span><span>
</span><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
</span></span></span><span><span><span>    <span><span>//</span> ARITHMETIC ISSUES
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Integer overflow: This would panic in debug mode and silently wrap in release
</span></span></span></span><span><span><span>    <span>let</span> a<span>:</span> <span>u8</span> <span>=</span> <span>255</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _b <span>=</span> a <span>+</span> <span>1</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Unsafe casting: Could truncate the value
</span></span></span></span><span><span><span>    <span>let</span> large_number<span>:</span> <span>i64</span> <span>=</span> <span>1_000_000_000_000</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _small_number<span>:</span> <span>i32</span> <span>=</span> large_number <span>as</span> <span>i32</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Sign loss when casting
</span></span></span></span><span><span><span>    <span>let</span> negative<span>:</span> <span>i32</span> <span>=</span> <span>-</span><span>5</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _unsigned<span>:</span> <span>u32</span> <span>=</span> negative <span>as</span> <span>u32</span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Integer division can truncate results
</span></span></span></span><span><span><span>    <span>let</span> _result <span>=</span> <span>5</span> <span>/</span> <span>2</span><span>;</span> <span><span>//</span> Results in 2, not 2.5
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Duration subtraction can underflow
</span></span></span></span><span><span><span>    <span>let</span> short <span>=</span> <span>Duration<span>::</span></span>from_secs<span><span>(</span><span>1</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> long <span>=</span> <span>Duration<span>::</span></span>from_secs<span><span>(</span><span>2</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _negative <span>=</span> short <span>-</span> long<span>;</span> <span><span>//</span> This would underflow
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> UNWRAP ISSUES
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Using unwrap on Option that could be None
</span></span></span></span><span><span><span>    <span>let</span> data<span>:</span> <span><span>Option</span><span>&lt;</span><span>i32</span><span>&gt;</span></span> <span>=</span> <span>None</span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _value <span>=</span> data<span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Using expect on Result that could be Err
</span></span></span></span><span><span><span>    <span>let</span> result<span>:</span> <span><span>Result</span><span>&lt;</span><span>i32</span>, <span>&amp;</span><span>str</span><span>&gt;</span></span> <span>=</span> <span>Err</span><span><span>(</span><span><span>&#34;</span>error occurred<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _value <span>=</span> result<span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>This will panic<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Trying to get environment variable that might not exist
</span></span></span></span><span><span><span>    <span>let</span> _api_key <span>=</span> <span>std<span>::</span></span><span>env<span>::</span></span>var<span><span>(</span><span><span>&#34;</span>API_KEY<span>&#34;</span></span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> ARRAY INDEXING ISSUES
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Direct indexing without bounds checking
</span></span></span></span><span><span><span>    <span>let</span> numbers <span>=</span> <span>vec!</span><span><span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _fourth <span>=</span> numbers<span><span>[</span><span>3</span><span>]</span></span><span>;</span> <span><span>//</span> This would panic
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Safe alternative with .get()
</span></span></span></span><span><span><span>    <span>if</span> <span>let</span> <span>Some</span><span><span>(</span>fourth</span><span><span>)</span></span> <span>=</span> numbers<span>.</span><span>get</span><span><span>(</span><span>3</span></span><span><span>)</span></span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span><span>{fourth}</span><span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> PATH HANDLING ISSUES
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Joining with absolute path discards the base path
</span></span></span></span><span><span><span>    <span>let</span> base <span>=</span> <span>Path<span>::</span></span>new<span><span>(</span><span><span>&#34;</span>/home/user<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> _full_path <span>=</span> base<span>.</span><span>join</span><span><span>(</span><span><span>&#34;</span>/etc/config<span>&#34;</span></span></span><span><span>)</span></span><span>;</span> <span><span>//</span> Results in &#34;/etc/config&#34;, base is ignored
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Safe alternative
</span></span></span></span><span><span><span>    <span>let</span> base <span>=</span> <span>Path<span>::</span></span>new<span><span>(</span><span><span>&#34;</span>/home/user<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> relative <span>=</span> <span>Path<span>::</span></span>new<span><span>(</span><span><span>&#34;</span>config<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>let</span> full_path <span>=</span> base<span>.</span><span>join</span><span><span>(</span>relative</span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>println!</span><span><span>(</span></span><span><span><span>&#34;</span>Safe path joining: <span>{:?}</span><span>&#34;</span></span></span><span><span>,</span> full_path<span>)</span></span><span>;</span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> UNSAFE CODE ISSUES
</span></span></span></span><span><span><span>
</span></span></span><span><span><span>    <span><span>//</span> Creating uninitialized vectors (could cause undefined behavior)
</span></span></span></span><span><span><span>    <span>let</span> <span>mut</span> vec<span>:</span> <span><span>Vec</span><span>&lt;</span><span>String</span><span>&gt;</span></span> <span>=</span> <span>Vec</span><span><span>::</span></span>with_capacity<span><span>(</span><span>10</span></span><span><span>)</span></span><span>;</span>
</span></span></span><span><span><span>    <span>unsafe</span> <span><span>{</span>
</span></span></span></span><span><span><span><span>        vec<span>.</span><span>set_len</span><span><span>(</span><span>10</span></span><span><span>)</span></span><span>;</span> <span><span>//</span> This is UB as Strings aren&#39;t initialized
</span></span></span></span></span><span><span><span><span>    </span><span><span>}</span></span>
</span></span></span><span><span><span></span><span><span>}</span></span></span>
</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" aria-label="Anchor link for: conclusion">Conclusion</a></h2>
<p>Phew, that was a lot of pitfalls!
How many of them did you know about?</p>
<p>Even if Rust is a great language for writing safe, reliable code, developers still need to be disciplined to avoid bugs.</p>
<p>A lot of the common mistakes we saw have to do with Rust being a systems programming language:
In computing systems, a lot of operations are performance critical and inherently unsafe.
We are dealing with external systems outside of our control, such as the operating system, hardware, or the network.
The goal is to build safe abstractions on top of an unsafe world.</p>
<p>Rust shares an FFI interface with C, which means that it can do anything C can do.
So, while some operations that Rust allows are theoretically possible, they might lead to unexpected results.</p>
<p>But not all is lost!
If you are aware of these pitfalls, you can avoid them, and with the above clippy lints, you can catch most of them at compile time.</p>
<p>That‚Äôs why testing, linting, and fuzzing are still important in Rust.</p>
<p>For maximum robustness, combine Rust‚Äôs safety guarantees with strict checks and
strong verification methods.</p>
<div>
  
  <div>
    
      <h4><p>Let an Expert Review Your Rust Code</p>
</h4>
  </div>
  
  <p>I hope you found this article helpful!
If you want to take your Rust code to the next level, consider a code review by an expert.
I offer code reviews for Rust projects of all sizes. <a href="https://vrklovespaper.substack.com/about/">Get in touch</a> to learn more.</p>

</div>


    </div>
  </div></div>
  </body>
</html>
