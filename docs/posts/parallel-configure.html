<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://tavianator.com/2025/configure.html">Original</a>
    <h1>Parallel ./configure</h1>
    
    <div id="readability-page-1" class="page">
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        

        <!-- Set the theme before any content is loaded, prevents flash -->
        

        

        <!-- Hide / unhide sidebar before it is displayed -->
        

        <nav id="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox></mdbook-sidebar-scrollbox>
            
            
        </nav>

        <div id="page-wrapper">

            <div class="page">
                
                

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                

                <div id="content">
                    <main>
                        
<div>
<span><i aria-hidden="true"></i> <time datetime="2025-04-25">2025-04-25</time>
</span><span><i aria-hidden="true"></i> Tavian Barnes
</span><a href="https://github.com/tavianator/parconf"><i aria-hidden="true"></i> GitHub</a>
</div>
<p>I&#39;m sorry, but in the year 2025, this is ridiculous:</p>

<pre><code>$ time ./configure
./configure  13.80s user 12.72s system 69% cpu 38.018 total
$ time make -j48
make -j48  12.05s user 4.70s system 593% cpu 2.822 total
</code></pre>
<p>I paid <a href="https://en.wikipedia.org/wiki/Threadripper#Castle_Peak_(Threadripper_3000_series,_Zen_2_based)">good money</a> for my 24 CPU cores, but <code>./configure</code> can only manage to use 69% of one of them.
As a result, this random project takes about 13.5× longer to <em>configure</em> the build than it does to actually <em>do</em> the build.</p>
<p>The purpose of a <code>./configure</code> script is basically to run the compiler a bunch of times and check which runs succeeded.
In this way it can test whether particular headers, functions, struct fields, etc. exist, which lets people write portable software.
This is an <a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a> problem, but <a href="https://lists.gnu.org/archive/html/autoconf/2021-01/msg00112.html">Autoconf can&#39;t parallelize it</a>, and <a href="https://stackoverflow.com/a/75161236/502399">neither can CMake</a>, <a href="https://github.com/mesonbuild/meson/issues/3635">neither can Meson</a>, etc., etc.</p>
<p>The problem is that most build configurations scripts pretty much look like this:</p>
<pre><code>CFLAGS=&#34;-g&#34;
if $CC $CFLAGS -Wall empty.c; then
    CFLAGS=&#34;$CFLAGS -Wall&#34;
fi
...

: &gt;config.h
if $CC $CFLAGS have_statx.c; then
    echo &#34;#define HAVE_STATX 1&#34; &gt;&gt;config.h
else
    echo &#34;#define HAVE_STATX 0&#34; &gt;&gt;config.h
fi
...
</code></pre>
<p>This is written in an inherently sequential way, but in principle many of these tests could be run in parallel.
In fact, we already have an effective tool for parallelizing lots of commands (<code>make</code>), so let&#39;s use it.
We&#39;ll have a configuration makefile that generates our <code>Makefile</code> and <code>config.h</code>:</p>

<div>
<h4 id="configuremk"><a href="#configuremk"><code>configure.mk</code></a></h4>
<pre><code># The default goal generates both outputs, and merges the logs together
config: Makefile config.h
	cat Makefile.log config.h.log &gt;$@.log
	rm Makefile.log config.h.log
</code></pre>
</div>
<hr/>
<p>To start with, we&#39;ll save the initial values of variables like <code>CC</code> and <code>CFLAGS</code> into the <code>Makefile</code>:</p>
<div>
<h4 id="configuremk-1"><a href="#configuremk-1"><code>configure.mk</code></a></h4>
<pre><code># Default values, if unspecified
CC ?= cc
CPPFLAGS ?= -D_GNU_SOURCE
CFLAGS ?= -g
LDFLAGS ?=

# Export these through the environment to avoid stripping backslashes
export _CC=${CC}
export _CPPFLAGS=${CPPFLAGS}
export _CFLAGS=${CFLAGS}
export _LDFLAGS=${LDFLAGS}

Makefile:
	printf &#39;CC := %s\n&#39; &#34;$$_CC&#34; &gt;$@
	printf &#39;CPPFLAGS := %s\n&#39; &#34;$$_CPPFLAGS&#34; &gt;&gt;$@
	printf &#39;CFLAGS := %s\n&#39; &#34;$$_CFLAGS&#34; &gt;&gt;$@
	printf &#39;LDFLAGS := %s\n&#39; &#34;$$_LDFLAGS&#34; &gt;&gt;$@
</code></pre>
</div>
<p>Using <code>export</code> like this avoids stripping the necessary backslashes from invocations like</p>
<pre><code>$ ./configure CPPFLAGS=&#39;-DMACRO=\&#34;string\&#34;&#39;
</code></pre>
<hr/>
<p>Now let&#39;s check which flags our compiler supports.
We&#39;ll use this helper script:</p>
<div>
<h4 id="flagssh"><a href="#flagssh"><code>flags.sh</code></a></h4>
<pre><code>#!/bin/sh

set -eu

VAR=&#34;$1&#34;
FLAGS=&#34;$2&#34;
shift 2

if &#34;$@&#34; $FLAGS; then
    printf &#39;%s += %s\n&#39; &#34;$VAR&#34; &#34;$FLAGS&#34;
fi
</code></pre>
</div>
<p>When we run</p>
<pre><code>$ ./flags.sh CFLAGS -Wall cc empty.c
</code></pre>
<p>it will print</p>
<pre><code>CFLAGS += -Wall
</code></pre>
<p>if <code>cc empty.c -Wall</code> succeeds (and nothing otherwise).
We can use this to generate some makefile fragments that enable only the supported flags.</p>
<div>
<h4 id="configuremk-2"><a href="#configuremk-2"><code>configure.mk</code></a></h4>
<pre><code>ALL_FLAGS = ${CPPFLAGS} ${CFLAGS} ${LDFLAGS}

# Run the compiler with the given flags, sending
#
# - stdout to foo.mk (e.g. CFLAGS += -flag)
# - stderr to foo.mk.log (e.g. error: unrecognized command-line option ‘-flag’)
# - the compiled binary to foo.mk.out
#   - but then we delete it immediately
TRY_CC = ${CC} ${ALL_FLAGS} empty.c -o $@.out &gt;$@ 2&gt;$@.log &amp;&amp; rm -f $@.out $@.d

deps.mk:
	./flags.sh CPPFLAGS &#34;-MP -MD&#34; ${TRY_CC}
Wall.mk:
	./flags.sh CFLAGS -Wall ${TRY_CC}
pthread.mk:
	./flags.sh CFLAGS -pthread ${TRY_CC}
bind-now.mk:
	./flags.sh LDFLAGS -Wl,-z,now ${TRY_CC}
</code></pre>
</div>
<p>Each of these targets generates a tiny makefile fragment that&#39;s responsible for a single flag.
Importantly, each one can run independently, in parallel.
Once they&#39;re done, we can merge them all into the main <code>Makefile</code> and clean up the cruft:</p>
<div>
<h4 id="configuremk-3"><a href="#configuremk-3"><code>configure.mk</code></a></h4>
<pre><code>FLAGS := \
    deps.mk \
    Wall.mk \
    pthread.mk \
    bind-now.mk

Makefile: ${FLAGS}
	printf &#39;CC := %s\n&#39; &#34;$$_CC&#34; &gt;$@
	...
	cat ${FLAGS} &gt;&gt;$@
	cat ${FLAGS:%=%.log} &gt;$@.log
	rm ${FLAGS} ${FLAGS:%=%.log}
</code></pre>
</div>
<p>The last part to add to the <code>Makefile</code> is the part that actually builds our application.
We can write a simple makefile like this:</p>
<div>
<h4 id="mainmk"><a href="#mainmk"><code>main.mk</code></a></h4>
<pre><code>OBJS := main.o

app: ${OBJS}
	${CC} ${CFLAGS} ${LDFLAGS} ${OBJS} -o $@

${OBJS}:
	${CC} ${CPPFLAGS} ${CFLAGS} -c ${@:.o=.c} -o $@

-include ${OBJS:.o=.d}
</code></pre>
</div>
<p>And append it to the <code>Makefile</code> after all the flags:</p>

<hr/>
<p>We also want to generate a <code>config.h</code> file, which defines macros that tell us whether certain libraries/headers/functions/struct fields/etc. exist.
We can do this by test-compiling some simple C programs.
As an example, these programs check for the various ways to learn about a file&#39;s <em>creation timestamp</em>:</p>
<div>

<label for="tabs-have-statx"><code>have_statx.c</code></label>

<label for="tabs-have-st-birthtim"><code>have_st_birthtim.c</code></label>

<label for="tabs-have-st-birthtimespec"><code>have_st_birthtimespec.c</code></label>

<label for="tabs-have---st-birthtim"><code>have___st_birthtim.c</code></label>
<div>
<pre><code>#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;

int main(void) {
	struct statx stx;
	return statx(AT_FDCWD, &#34;.&#34;, 0, STATX_BTIME, &amp;stx);
}
</code></pre>
</div>
<div>
<pre><code>#include &lt;sys/stat.h&gt;

int main(void) {
	struct stat sb = {0};
	return sb.st_birthtim.tv_sec;
}
</code></pre>
</div>
<div>
<pre><code>#include &lt;sys/stat.h&gt;

int main(void) {
	struct stat sb = {0};
	return sb.st_birthtimespec.tv_sec;
}
</code></pre>
</div>
<div>
<pre><code>#include &lt;sys/stat.h&gt;

int main(void) {
	struct stat sb = {0};
	return sb.__st_birthtim.tv_sec;
}
</code></pre>
</div>
</div>
This helper script:
<div>
<h4 id="definesh"><a href="#definesh"><code>define.sh</code></a></h4>
<pre><code>#!/bin/sh

set -eu

MACRO=$1
shift

if &#34;$@&#34;; then
    printf &#39;#define %s 1\n&#39; &#34;$MACRO&#34;
else
    printf &#39;#define %s 0\n&#39; &#34;$MACRO&#34;
fi
</code></pre>
</div>
<p>will output things like</p>
<pre><code>#define HAVE_STATX 1
</code></pre>
<p>or</p>
<pre><code>#define HAVE_ST_BIRTHTIM 0
</code></pre>
<p>depending on whether the build succeeds.
We can use it in a makefile like this:</p>
<div>
<h4 id="configuremk-5"><a href="#configuremk-5"><code>configure.mk</code></a></h4>
<pre><code># Use a recursive make to pick up our auto-detected *FLAGS from above
config.h: Makefile
	+${MAKE} -f header.mk $@
</code></pre>
<h4 id="headermk"><a href="#headermk"><code>header.mk</code></a></h4>
<pre><code># Get the final *FLAGS values from the Makefile
include Makefile

# We first generate a lot of small headers, before merging them into one big one
HEADERS := \
    have_statx.h \
    have_st_birthtim.h \
    have_st_birthtimespec.h \
    have___st_birthtim.h

# Strip .h and capitalize the macro name
MACRO = $$(printf &#39;%s&#39; ${@:.h=} | tr &#39;a-z&#39; &#39;A-Z&#39;)

ALL_FLAGS = ${CPPFLAGS} ${CFLAGS} ${LDFLAGS}

${HEADERS}:
	./define.sh ${MACRO} ${CC} ${ALL_FLAGS} ${@:.h=.c} -o $@.out &gt;$@ 2&gt;$@.log
	rm -f $@.out $@.d
</code></pre>
</div>
<p>And to join them all together (along with a header guard):</p>
<div>
<h4 id="headermk-1"><a href="#headermk-1"><code>header.mk</code></a></h4>
<pre><code>config.h: ${HEADERS}
	printf &#39;#ifndef CONFIG_H\n&#39; &gt;$@
	printf &#39;#define CONFIG_H\n&#39; &gt;&gt;$@
	cat ${HEADERS} &gt;&gt;$@
	printf &#39;#endif\n&#39; &gt;&gt;$@
	cat ${HEADERS:%=%.log} &gt;$@.log
	rm ${HEADERS} ${HEADERS:%=%.log}
</code></pre>
</div>
<hr/>
<p>The last step is to wrap <code>configure.mk</code> in a shell script, so people can run <code>./configure</code> like they&#39;re used to:</p>
<div>
<h4 id="configure"><a href="#configure"><code>configure</code></a></h4>
<pre><code>#!/bin/sh

set -eu

# Guess a good number for make -j&lt;N&gt;
jobs() {
    {
        nproc \
            || sysctl -n hw.ncpu \
            || getconf _NPROCESSORS_ONLN \
            || echo 1
    } 2&gt;/dev/null
}

# Default to MAKE=make
MAKE=&#34;${MAKE-make}&#34;

# Set MAKEFLAGS to -j$(jobs) if it&#39;s unset
export MAKEFLAGS=&#34;${MAKEFLAGS--j$(jobs)}&#34;

$MAKE -r -f configure.mk &#34;$@&#34;
</code></pre>
</div>
<p>I put together a simple proof-of-concept <a href="https://github.com/tavianator/parconf"><i aria-hidden="true"></i> GitHub repository</a> that contains the full version of all these files if you want to copy-paste.
The demo app prints file creation times, if it can figure out how to on your platform.</p>
<p>I&#39;ve also been using a similar build system in <a href="https://kevingal.com/projects/bfs.html">bfs</a> for a while, if you want to see a larger example.
The performance benefit is substantial:</p>

<pre><code>$ time ./configure
./configure  1.44s user 1.78s system 802% cpu 0.401 total
tavianator@tachyon $ time make -j48
make -j48  1.89s user 0.64s system 817% cpu 0.310 total
</code></pre>
<p>Of course, a lot of the benefit comes from just doing less configuration steps, but the 802% CPU use is a tremendous improvement over everything else I&#39;ve tried.</p>

                    </main>

                    
                </div>
            </div>

            

        </div>






        
        
        

        
        
        

        <!-- Custom JS scripts -->


    </div>
    

</div>
  </body>
</html>
