<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://retrocoding.net/the-90s-developer-starter-pack">Original</a>
    <h1>The 90s Developer Starter Pack</h1>
    
    <div id="readability-page-1" class="page"><div id="post-content-parent"><div id="post-content-wrapper"><p>I recently found a 386 emulator called 86Box, a fork of the earlier version of PCEm. Because I&#39;m a real programmerâ„¢, I build the <code>master</code> branch from its Git source on a macOS Ventura. How I build it from sources will be the subject of a new article.</p>

<p>86Box supports a breadth of selection of combinations of PC hardware components in the 90s. A real gold mine for a person like me who lives in a developing country with restricted access to old hardware. I set a goal to replicate the experience of installing a fresh Windows 95 PC from hardware available around 1990-1995. I&#39;ll limit it to something typical for developers on 95s to run on their medium-powered PC, which may have a few esoteric components. I remember my late father having AMD Am486 with 8MB of RAM. So I&#39;ll use that as a frame of reference. Also, I&#39;ve found an article <a target="_blank" href="https://www.chicagotribune.com/news/ct-xpm-1995-11-03-9511030044-story.html">about buyers&#39; guides from the Chicago Tribune explaining the spec for the holiday season in 1995</a>.</p>
<p>After mucking around the settings, these are the components that I decided to have.</p>
<h2 id="heading-cpu">CPU</h2>
<p>I&#39;ll go with <strong>AMD Am486DX4 with 100 MHz</strong> Speed with PGA 168 socket. This is how it originally looked like</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667642338455/_lMQJWFx8.jpg?auto=compress,format&amp;format=webp" alt="AMD Am486DX4 100MHz"/></p>
<p>There&#39;s &#34;Designed for Windows 95&#34; imprinted on the chip itself. We&#39;re going to a good start.  This chip is Intel 486 compatible. I didn&#39;t go to Pentium or Pentium Pro because I wanted pure, unextended, intel 486 instruction sets with no Pentium Pro extensions like <code>CMOVNS</code>, which I&#39;ve written about in my previous posts. </p>
<h2 id="heading-motherboard">Motherboard</h2>
<p>ASUS PVI-486SP3C with SiS 496 as the Chipset. Without further ADO, please look at this beauty.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667642689155/xRlenge2K.jpg?auto=compress,format&amp;format=webp" alt="ASUS PVI-486SP3C"/></p>
<p>As depicted in the picture above, this motherboard featured a PGA168 socket. With both SIS 496 as the Northbridge chip and SIS 497 as the Southbridge chip. This features these I/O:</p>
<ul>
<li>Dual-channel IDE.</li>
<li>1 Floppy Disk Interface.</li>
<li>3 PIC slots.</li>
<li>4 ISA slots, with one of them being a VLB slot (that extension is not an AGP slot, it didn&#39;t exist back then)</li>
<li>One parallel, two serial ports, and 1 PS/2 port.</li>
</ul>
<h2 id="heading-ram-and-disks">RAM and Disks</h2>
<p>There are two EDO-RAM over there, which I&#39;ll fill with a whopping 16 MB of RAM, which is 4 times the minimum requirement for Windows 95. As for disk, we&#39;ll fill all floppy disk controllers with 2.88 MB Drives. On the IDE slot, we&#39;ll put a 2GB disk drive.</p>
<p>We&#39;ll utilise ZIP drives and CD-ROM. I&#39;ll not use IDE for these. Like a grown-up, let&#39;s use SCSI for both ZIP and CD ROM drives.</p>
<h2 id="heading-components-and-accessories">Components and Accessories</h2>
<p>I&#39;ll start with the graphics card. Because we were in 1994, and we have a VLB slot, let&#39;s use that. We&#39;re going to use the S3 Vision964 VLB Version.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667644946189/qrpXhIgT_.jpeg?auto=compress,format&amp;format=webp" alt="Elsa Winner S3 Vision 964 Card"/></p>
<p>This card is an accelerated card which allows us to decode MPEG-1 without any additional accelerator cards.</p>
<p>The next obvious accessory is the sound card. We&#39;re not going crazy this time. Let&#39;s use good ol&#39; Sound Blaster 16-bit and fill one more of our ISA slots.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667645205759/ijBrWahzA.jpg?auto=compress,format&amp;format=webp" alt="Sound Blaster 16 bit"/></p>
<p>As we&#39;re going to use SCSI, we&#39;re going to use BusLogic PCI BT-958D for our SCSI controller, which will drive both ZIP Drive and CD ROM drives.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667645641177/Xd4rsBVyH.jpeg?auto=compress,format&amp;format=webp" alt="BusLogic"/></p>

<h2 id="heading-prerequisite-microsoft-dos-622">Prerequisite: Microsoft DOS 6.22</h2>
<p>Most of the motherboard is not ready for booting from CDs, let alone SCSI. So, unlike Windows 98. To install Windows 95, you&#39;d need Microsoft DOS 6.22. We&#39;re going to install it, and for me, I&#39;ll also enable the Dvorak keyboard. I&#39;ll gloss over this process as you might already know how to install them from diskettes. After installing MSDOS, you&#39;ll be greeted with the typical C-prompt <code>C:\</code>. I usually install the supplemental disk to be able to use Dvorak as my keyboard and add this line to <code>AUTOEXEC.BAT</code> file.</p>
<pre><code>REM Use Dvorak Keyboard
KEYB DV,,C:\DOS\DVORAK.SYS
</code></pre><p>We&#39;d need to access our CDROM, which is attached to a SCSI card. For this we&#39;ll use the driver from BusLogic and Microsoft MSCDEX. You can find the file on the net. The name are <code>btdosm.sys</code> <code>btcdrom.sys</code> and <code>mscdex.exe</code>. To access the drive, we&#39;ll need to load them on our <code>CONFIG.SYS</code> file.</p>
<pre><code>DEVICE=BTDOSM.SYS
DEVICE=BTCDROM.SYS /D:RETROCD
</code></pre><p>And then add this line to <code>AUTOEXEC.BAT</code></p>
<pre><code>REM Mount CD ROM
MSCDEX.EXE /D:RETROCD
</code></pre><p>Reboot, and now you can access your <code>D</code> drive from DOS command prompt.</p>
<h2 id="heading-install-windows-95-osr-25">Install Windows 95 OSR 2.5</h2>
<p>Mount your Windows 95 on the CD Drive and then go to drive D.</p>
<pre><code>C:\&gt; D:
D:\&gt; SETUP
</code></pre><p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667655529827/b5Ok_zHi2.png?auto=compress,format&amp;format=webp" alt="Setup Wizard"/></p>
<p>Follow the setup instructions, and you&#39;ll end up with a desktop. Right-click on the <strong>My Computer</strong> section and select <strong>Properties</strong>. You&#39;ll end up with something like this.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667655920414/6CdD0c8JD.png?auto=compress,format&amp;format=webp" alt="Desktop Machine Properties"/></p>
<p>Look at that 16 MB RAM and a proud 80486 owner with all the bells and whistles. Now time to install our development tool of choice.</p>

<p>We&#39;re &#34;real programmers&#34;, so we&#39;re not gonna use peasants&#39; tools like Visual Basic. No, no siree... We are going to use a real programming language like C++. So prepare your <a target="_blank" href="https://winworldpc.com/product/microsoft-visual-stu/97-5x">Visual Studio Enterprise 97</a> disks and install Visual C++.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667656275181/2WacmCqyL.png?auto=compress,format&amp;format=webp" alt="Visual C++ Advertisement of COM"/>.</p>
<p>Look at that! What an amazing compiler supporting <a target="_blank" href="https://en.wikipedia.org/wiki/Component_Object_Model">COM</a>, and it supports creating COM clients and interfaces, exciting time to code in 1994.</p>
<p>If you are clueless enough, you can also install the MSDN for Visual Studio 97 if you can get the CD image from the internet. However, our next step is very simple. We won&#39;t need to use that.</p>

<p>So we have our money-making machine being set up. The next step is to write a program for the 90s. Let&#39;s give ourselves a treat of being beginners again and see what we can achieve using a 30-years-old platform with machine 1/1000 times less powerful than our typical phone in 2022.</p>
<p>Let&#39;s fire up the IDE and enjoy the developer tools created by Microsoft in the early 90s.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667661905493/wy8ZcwYb6.png?auto=compress,format&amp;format=webp" alt="Hello Win95"/></p>
<p>Proceed by selecting &#34;Win32 Application&#34; and then choose &#34;Empty Project&#34;. You&#39;ll be greeted with an empty project. Add new files named <code>main.cpp</code> to the files section and let&#39;s start by building a GUI program which will show you a &#34;Hello, Welcome to Windows95&#34; message box.</p>
<h2 id="heading-entry-point">Entry Point</h2>
<p>A win32 project entry point is not <code>main</code> but <code>WinMain</code>. A minimal program which will start and do absolutely nothing will be as follows.</p>
<pre><code><span>#<span>include</span> <span>&lt;Windows.h&gt;</span></span>

<span><span>int</span> APIENTRY <span>WinMain</span><span>(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, <span>int</span> nCmdShow)</span>
</span>{
  <span>return</span> <span>0</span>;
}
</code></pre>
<p>Although the program does absolutely nothing, it&#39;ll just start and immediately exit, the function signature is a mouthful and verbose. Not all of these parameters are important or even usable. This is the quirk of Windows programming as Microsoft needs to maintain the API signature for backward compatibility. </p>
<ol>
<li>Including the <code>Windows.h</code> header is mandatory for all Windows programs written this way.</li>
<li>The <code>WinMain</code> function needs to return an <code>int</code>. If there&#39;s no Windows Message Pump defined, return <code>0</code> on exist. We&#39;ll talk about Windows Message Pump in another post.</li>
<li><code>APIENTRY</code> is an alias to stdcall calling convention, which means the function itself will clean the stack.</li>
<li><code>HINSTANCE</code> is a &#34;handle&#34; to an application instance. A handle is an opaque value for an object within Windows operating system. Both first parameters are purely for backward compatibility. The first <code>HINSTANCE</code> is always pegged to <code>0x04</code>, and the second is always <code>0x00</code> on 32-bit protected mode Windows.</li>
<li><code>lpCmdLine</code> is the command line to invoke the program. We can use this parameter to parse the command line and its arguments when it&#39;s invoked from the command line.</li>
<li><code>nCmdShow</code> is the value which tell the window, if the Window will be shown minimised, maximised, or hidden.</li>
</ol>
<p>Try to build the application, and you&#39;ll see.. nothing. Building only validates that our syntax is correct. The message on the build window will show something like this.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667663069376/E8PVkXUuP.png?auto=compress,format&amp;format=webp" alt="Building Program Console"/></p>
<h2 id="heading-our-first-windows-api">Our first Windows API</h2>
<p>When we started with something new, we started with &#34;Hello, World!&#34; program. This can be accomplished in Win32 API by calling <code>MessageBox</code> function. The function prototype is very simple.</p>
<pre><code><span><span>int</span> <span>MessageBox</span><span>(HWND hWnd, LPSTR lpText, LPSTR lpCaption, UINT uType)</span></span>;
</code></pre>
<p>The meaning of each of the parameter are:</p>
<ul>
<li><code>hWnd</code> is the parent window of the message box window being displayed. Passing <code>0</code> means that the message box parent will be the Desktop.</li>
<li><code>lpText</code> is a zero-terminated string containing the message to be displayed.</li>
<li><code>lpCaption</code> is the caption of the message box.</li>
<li><code>uType</code> is the message box type. There are several values that you can use. The value is a bit flag. We&#39;ll use <code>MB_OK | MB_ICONINFORMATION</code> which means that we&#39;ll only show the OK button and an information icon.</li>
</ul>
<p>The full program to be run is as below:</p>
<pre><code><span>#<span>include</span> <span>&lt;Windows.h&gt;</span></span>

<span><span>int</span> APIENTRY <span>WinMain</span><span>(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine, <span>int</span> nCmdShow)</span>
</span>{
  MessageBox(<span>NULL</span>, <span>&#34;Hello, Welcome to Win32 Programming&#34;</span>, 
      <span>&#34;Hello, World&#34;</span>, MB_OK | MB_ICONINFORMATION);
  <span>return</span> <span>0</span>;
}
</code></pre>
<p>And the program will show a nice message box.</p>
<p><img loading="lazy" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1667664027301/s938PW0B6.png?auto=compress,format&amp;format=webp" alt="Hello World Win32"/></p>
<p>That&#39;s it! Our first GUI program using Win32 API running on typical early 90s workstation running on Windows 95. There will be more which we&#39;ll explore on next articles. Including on how to create a window and draw something there.</p>
<p>If you curious, you can build the executable to an .exe and then try to run it on modern Windows operating system like Windows 11. You&#39;ll surprise that the program still run perfectly fine.</p>

<p>Windows 95 is the first full 32-bit Windows that&#39;s built by Microsoft. It&#39;s a break from previous generations of Windows which brings 32-bit programming to consumer which previously was only available on Windows NT. Programming C/C++ in Windows differs with typical console-based C/C++ applications. For example, the entry point of Win32 program is <code>WinMain</code> and not <code>main</code>. In the future article we&#39;ll explore more about Window 95 and Win32 API.</p>
</div></div></div>
  </body>
</html>
