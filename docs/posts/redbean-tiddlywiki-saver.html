<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rpdillon.net/redbean-tiddlywiki-saver.html">Original</a>
    <h1>Redbean Tiddlywiki Saver</h1>
    
    <div id="readability-page-1" class="page"><div><p><a href="https://tiddlywiki.com" rel="noopener noreferrer" target="_blank">Tiddlywiki</a> is a great tool, but because it runs in the browser, it has only limited access to the filesystem to save changes. This has led to dozens of tools called &#34;savers&#34; that work with Tiddlywiki to save it. These span the gamut, including full fledged desktop apps (most notably <a href="https://tiddlywiki.com/static/TiddlyDesktop.html" rel="noopener noreferrer" target="_blank">TiddlyDesktop</a>), browser extensions, and server applications of varying complexity.</p><p>I ran across jart&#39;s phenomenal <a href="https://redbean.dev" rel="noopener noreferrer" target="_blank">Redbean</a> project, which is a webserver contained as an αcτµαlly pδrταblε εxεcµταblε. This approach appeals strongly to my love of small, self-contained tools (one of the reasons I love Tiddlywiki!) It&#39;s a web server application that is also a zip archive.  By adding Lua code and assets to the zip archive, and then executing it on most any x86_64 system, it provides a self-contained, offline web application.  After reading through the documentation for Redbean, it occurred to me that it should be not only possible, but quite easy to write a Redbean application that not only is a saver for Tiddlywiki, but can bundle the wiki into the application itself, creating a completely self-contained Tiddlywiki application.</p><p>But, I&#39;ve never worked with Redbean before, so these are my notes on implementing this idea.</p><h2>Redbean&#39;s Hello World</h2><p>Here&#39;s my hello world in <code>index.lua</code>:</p><pre><code>Write(<span>&#34;&lt;html&gt;&#34;</span>)
Write(<span>&#34;&lt;head&gt;&lt;title&gt;Redbean Lua Demo&lt;/title&gt;&lt;/head&gt;&#34;</span>)
Write(<span>&#34;&lt;body&gt;&#34;</span>)
Write(<span>&#34;This is just a demo page...hello, world!&#34;</span>)
Write(<span>&#34;&lt;/body&gt;&#34;</span>)
Write(<span>&#34;&lt;/html&gt;&#34;</span>)</code></pre><p>I then build the executable using a small script:</p><pre><code><span>if</span> [! -f redbean.com ]; <span>then</span>
    curl https://redbean.dev/redbean-latest.com &gt; redbean.com
    <span>chmod</span> +x redbean.com
<span>fi</span>
<span>cp</span> redbean.com wiki.com
zip wiki.com index.lua
./wiki.com</code></pre><h2>Serving a Tiddlywiki</h2><p>Instead of generating HTML in the Lua code, we already have a bundle of HTML to serve: a Tiddlywiki!  This means all the Lua code has to do is serve that asset:</p><pre><code>ServeAsset(<span>&#34;wiki.html&#34;</span>)</code></pre><p>Of course, we need to provide that <code>wiki.html</code> file to serve. Let&#39;s grab one:</p><pre><code>curl https://tiddlywiki.com/empty.html &gt; wiki.html
zip wiki.com index.lua wiki.html
./wiki.com</code></pre><p>Opening <code>localhost:8080</code> in the browser, we can see that the wiki loads, and can be edited, but there&#39;s no saving yet. </p><h2>Adding Saving</h2><p>Redbean has a surprisingly comprehensive set of methods available to tackle the saving piece.  In order to enable saving for Tiddlywiki with the built-in DAV tooling, the server needs to understand four major HTTP methods: <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, and <code>PUT</code>.</p><p>To implement <code>HEAD</code>, we want to provide two relevant headers: the <code>Content-Type</code> and the <code>Content-Length</code>.  Right now, the goal is to have Redbean store exactly one wiki, so the path to the resource doesn&#39;t matter.  But since we&#39;ll have to dispatch on method type, we need to extract that first.  At the same time, we&#39;ll hardcode the path to the wiki inside the zip:</p><pre><code>method = GetMethod()
WIKI_PATH=<span>&#34;wiki.html&#34;</span></code></pre><p>To implement <code>GET</code> we simply use the logic from above:</p><pre><code><span>if</span> method == <span>&#34;GET&#34;</span> <span>then</span>
   ServeAsset(WIKI_PATH)
<span>end</span></code></pre><p>For <code>HEAD</code>, two headers are required, and they can be set with <code>SetHeader</code>. One is <code>Content-Length</code>, which is dynamic, so it first needs to load the wiki and get its length before setting the headers:</p><pre><code>
<span>elseif</span> method == <span>&#34;HEAD&#34;</span> <span>then</span>
   wiki = LoadAsset(WIKI_PATH)
   SetStatus(<span>200</span>)
   SetHeader(<span>&#34;Content-Type&#34;</span>, <span>&#34;text/html&#34;</span>)
   SetHeader(<span>&#34;Content-Length&#34;</span>, <span>tostring</span>(#wiki))
<span>end</span></code></pre><p>Implementing <code>OPTIONS</code> has to emulate WebDAV just enough to trick Tiddlywiki into saving using that mechanism. I based these headers from the very sleek <a href="https://gist.github.com/jimfoltz/ee791c1bdd30ce137bc23cce826096da" rel="noopener noreferrer" target="_blank">Ruby saver</a> written by Jim Foltz.</p><pre><code>
<span>elseif</span> method == <span>&#34;OPTIONS&#34;</span> <span>then</span>
   SetStatus(<span>200</span>)
   SetHeader(<span>&#34;allow&#34;</span>, <span>&#34;GET,HEAD,POST,OPTIONS,CONNECT,PUT,DAV,dav&#34;</span>)
   SetHeader(<span>&#34;x-api-access-type&#34;</span>, <span>&#34;file&#34;</span>)
   SetHeader(<span>&#34;dav&#34;</span>, <span>&#34;tw5/put&#34;</span>)
<span>end</span></code></pre><p>The last method is <code>PUT</code>, which needs to write the payload back to the Redbean archive.  Luckily, Redbean provides a <code>StoreAsset</code> function for exactly this case:</p><pre><code>
<span>elseif</span> method == <span>&#34;PUT&#34;</span> <span>then</span>
   length = <span>tonumber</span>(GetHeader(<span>&#34;Content-Length&#34;</span>))
   body = GetBody()
   StoreAsset(WIKI_PATH, body)
   SetStatus(<span>200</span>)
<span>end</span></code></pre><h2>Putting It All Together</h2><p>So, the full script is a compact 21 lines of Lua:</p><pre><code>method = GetMethod()
WIKI_PATH=<span>&#34;wiki.html&#34;</span>

<span>if</span> method == <span>&#34;GET&#34;</span> <span>then</span>
   ServeAsset(WIKI_PATH)
<span>elseif</span> method == <span>&#34;HEAD&#34;</span> <span>then</span>
   wiki = LoadAsset(WIKI_PATH)
   SetStatus(<span>200</span>)
   SetHeader(<span>&#34;Content-Type&#34;</span>, <span>&#34;text/html&#34;</span>)
   SetHeader(<span>&#34;Content-Length&#34;</span>, <span>tostring</span>(#wiki))
<span>elseif</span> method == <span>&#34;OPTIONS&#34;</span> <span>then</span>
   SetStatus(<span>200</span>)
   SetHeader(<span>&#34;allow&#34;</span>, <span>&#34;GET,HEAD,POST,OPTIONS,CONNECT,PUT,DAV,dav&#34;</span>)
   SetHeader(<span>&#34;x-api-access-type&#34;</span>, <span>&#34;file&#34;</span>)
   SetHeader(<span>&#34;dav&#34;</span>, <span>&#34;tw5/put&#34;</span>)   
<span>elseif</span> method == <span>&#34;PUT&#34;</span> <span>then</span>
   length = <span>tonumber</span>(GetHeader(<span>&#34;Content-Length&#34;</span>))
   body = GetBody()
   StoreAsset(WIKI_PATH, body)
   SetStatus(<span>200</span>)
<span>end</span></code></pre><p>Then all that&#39;s needed is to inject <code>index.lua</code>, along with a wiki, into the archive and run it:</p><pre><code>zip wiki.com wiki.html index.lua
./wiki.com</code></pre><p>While this loads and allows editing as before, upon saving, Tiddlywiki throws an error, and the Redbean logs reveal a <code>413</code> error: the payload during the <code>PUT</code> is too large.  This is because a Tiddlywiki is over 1MB, but the maximum payload size of Redbean is 65k.  This can be adjusted during launch...here we&#39;ll use 5MB:</p><pre><code>./wiki.com -M 5000000</code></pre><p>This approach allows Tiddlywiki to load and save exactly as expected, and packs everything into a single 2.5M file.</p></div></div>
  </body>
</html>
