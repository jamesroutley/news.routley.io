<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spidermonkey.dev/blog/2025/10/28/iongraph-web.html">Original</a>
    <h1>Who needs Graphviz when you can build it yourself?</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
    <section>
    <div>
      <div>
      <article itemscope="" itemtype="http://schema.org/BlogPosting">

  

  <div itemprop="articleBody">
    



<p>We recently overhauled our internal tools for visualizing the compilation of JavaScript and WebAssembly. When SpiderMonkey’s optimizing compiler, Ion, is active, we can now produce interactive graphs showing exactly how functions are processed and optimized.</p>

<div id="livegraph-available">
  <p>You can play with these graphs right here on this page. Simply write some JavaScript code in the <code>test</code> function and see what graph is produced. You can click and drag to navigate, ctrl-scroll to zoom, and drag the slider at the bottom to scrub through the optimization process.</p>
  <p>As you experiment, take note of how stable the graph layout is, even as the sizes of blocks change or new structures are added. Try clicking a block&#39;s title to select it, then drag the slider and watch the graph change while the block remains in place. Or, click an instruction&#39;s number to highlight it so you can keep an eye on it across passes.</p>
</div>



<p><img id="livegraph-preview" alt="Example iongraph output" src="https://spidermonkey.dev/assets/img/iongraph-preview.png"/></p>



<p>We are not the first to visualize our compiler’s internal graphs, of course, nor the first to make them interactive. But I was not satisfied with the output of common tools like <a href="https://graphviz.org/">Graphviz</a> or <a href="https://mermaid.js.org/">Mermaid</a>, so I decided to create a layout algorithm specifically tailored to our needs. The resulting algorithm is simple, fast, produces surprisingly high-quality output, and can be implemented in less than a thousand lines of code. The purpose of this article is to walk you through this algorithm and the design concepts behind it.</p>

<p><i>Read this post on desktop to see an interactive demo of iongraph.</i></p>

<h2 id="background">Background</h2>

<p>As readers of this blog already know, SpiderMonkey has several tiers of execution for JavaScript and WebAssembly code. The highest tier is known as Ion, an optimizing SSA compiler that takes the most time to compile but produces the highest-quality output.</p>

<p>Working with Ion frequently requires us to visualize and debug the SSA graph. Since 2011 we have used a tool for this purpose called <a href="https://github.com/sstangl/iongraph">iongraph</a>, built by Sean Stangl. It is a simple Python script that takes a JSON dump of our compiler graphs and uses Graphviz to produce a PDF. It is perfectly adequate, and very much the status quo for compiler authors, but unfortunately the Graphviz output has many problems that make our work tedious and frustrating.</p>

<p>The first problem is that the Graphviz output rarely bears any resemblance to the source code that produced it. Graphviz will place nodes wherever it feels will minimize error, resulting in a graph that snakes left and right seemingly at random. There is no visual intuition for how deeply nested a block of code is, nor is it easy to determine which blocks are inside or outside of loops. Consider the following function, and its Graphviz graph:</p>

<div><div><pre><code><span>function</span> <span>foo</span><span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>let</span> <span>result</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>n</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!!</span><span>(</span><span>i</span> <span>%</span> <span>2</span><span>))</span> <span>{</span>
      <span>result</span> <span>=</span> <span>0x600DBEEF</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>result</span> <span>=</span> <span>0xBADBEEF</span><span>;</span>
    <span>}</span>
  <span>}</span>

  <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p><img src="https://spidermonkey.dev/assets/img/iongraph-example1-orig.svg"/>
</p>

<p>Counterintuitively, the <code>return</code> appears <em>before</em> the two assignments in the body of the loop. Since this graph mirrors JavaScript control flow, we’d expect to see the return at the bottom. This problem only gets worse as graphs grow larger and more complex.</p>

<p>The second, related problem is that Graphviz’s output is unstable. Small changes to the input can result in large changes to the output. As you page through the graphs of each pass within Ion, nodes will jump left and right, true and false branches will swap, loops will run up the right side instead of the left, and so on. This makes it very hard to understand the actual effect of any given pass. Consider the following before and after, and notice how the second graph is almost—but not quite—a mirror image of the first, despite very minimal changes to the graph’s structure:</p>

<div>
  <p><img src="https://spidermonkey.dev/assets/img/iongraph-example2-before.svg"/>
    <img src="https://spidermonkey.dev/assets/img/iongraph-example2-after.svg"/>
  </p>
</div>

<p>None of this felt right to me. Control flow graphs should be able to follow the structure of the program that produced them. After all, a control flow graph has many restrictions that a general-purpose tool would not be aware of: they have very few cycles, all of which are well-defined because they come from loops; furthermore, both JavaScript and WebAssembly have reducible control flow, meaning all loops have only one entry, and it is not possible to jump directly into the middle of a loop. This information could be used to our advantage.</p>

<p>Beyond that, a static PDF is far from ideal when exploring complicated graphs. Finding the inputs or uses of a given instruction is a tedious and frustrating exercise, as is following arrows from block to block. Even just zooming in and out is difficult. I eventually concluded that we ought to just build an interactive tool to overcome these limitations.</p>

<h2 id="how-hard-could-layout-be">How hard could layout be?</h2>

<p>I had one false start with graph layout, with an algorithm that attempted to sort blocks into vertical “tracks”. This broke down quickly on a variety of programs and I was forced to go back to the drawing board—in fact, back to the source of the very tool I was trying to replace.</p>

<p>The algorithm used by <code>dot</code>, the typical hierarchical layout mode for Graphviz, is known as the Sugiyama layout algorithm, from a 1981 paper by Sugiyama et al. As introduction, I found a short series of <a href="https://www.youtube.com/watch?v=3_FbSCWLC3A&amp;list=PLubYOWSl9mIvoXDwf_Wqcrvlg15N_AWQE&amp;index=38">lectures</a> that broke down the Sugiyama algorithm into 5 steps:</p>

<ol>
  <li><strong>Cycle breaking</strong>, where the direction of some edges are flipped in order to produce a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>.</li>
  <li><strong>Leveling</strong>, where vertices are assigned into horizontal layers according to their depth in the graph, and dummy vertices are added to any edge that crosses multiple layers.</li>
  <li><strong>Crossing minimization</strong>, where vertices on a layer are reordered in order to minimize the number of edge crossings.</li>
  <li><strong>Vertex positioning</strong>, where vertices are horizontally positioned in order to make the edges as straight as possible.</li>
  <li><strong>Drawing</strong>, where the final graph is rendered to the screen.</li>
</ol>

<p><img src="https://spidermonkey.dev/assets/img/kindermann.png" alt="A screenshot from the lectures, showing the five steps above"/></p>

<p>These steps struck me as surprisingly straightforward, and provided useful opportunities to insert our own knowledge of the problem:</p>

<ul>
  <li>Cycle breaking would be trivial for us, since the only cycles in our data are loops, and loop backedges are explicitly labeled. We could simply ignore backedges when laying out the graph.</li>
  <li>Leveling would be straightforward, and could easily be modified to better mimic the source code. Specifically, any blocks coming after a loop in the source code could be artificially pushed down in the layout, solving the confusing early-exit problem.</li>
  <li>Permuting vertices to reduce edge crossings was actually just a bad idea, since our goal was stability from graph to graph. The true and false branches of a condition should always appear in the same order, for example, and a few edge crossings is a small price to pay for this stability.</li>
  <li>Since reducible control flow ensures that a program’s loops form a tree, vertex positioning could ensure that loops are always well-nested in the final graph.</li>
</ul>

<p>Taken all together, these simplifications resulted in a remarkably straightforward algorithm, with the <a href="https://github.com/mozilla-spidermonkey/iongraph/blob/fc27ee3e8f3bd3c020aaf2498de9a260da089bc1/src/Graph.ts">initial implementation</a> being just 1000 lines of JavaScript. (See this <a href="https://x.com/its_bvisness/status/1957565307809329465?s=46">demo</a> for what it looked like at the time.) It also proved to be very efficient, since it avoided the most computationally complex parts of the Sugiyama algorithm.</p>

<h2 id="iongraph-from-start-to-finish">iongraph from start to finish</h2>

<p>We will now go through the entire iongraph layout algorithm. Each section contains explanatory diagrams, in which rectangles are basic blocks and circles are dummy nodes. Loop header blocks (the single entry point to each loop) are additionally colored green.</p>

<p>Be aware that the block positions in these diagrams are not representative of the actual computed layout position at each point in the process. For example, vertical positions are not calculated until the very end, but it would be hard to communicate what the algorithm was doing if all blocks were drawn on a single line!</p>

<h3 id="step-1-layering">Step 1: Layering</h3>

<p>We first sort the basic blocks into horizontal tracks called “layers”. This is very simple; we just start at layer 0 and recursively walk the graph, incrementing the layer number as we go. As we go, we track the “height” of each loop, not in pixels, but in layers.</p>

<p>We also take this opportunity to vertically position nodes “inside” and “outside” of loops. Whenever we see an edge that exits a loop, we defer the layering of the destination block until we are done layering the loop contents, at which point we know the loop’s height.</p>

<p>A note on implementation: nodes are visited multiple times throughout the process, not just once. This can produce a quadratic explosion for large graphs, but I find that an early-out is sufficient to avoid this problem in practice.</p>

<p>The animation below shows the layering algorithm in action. Notice how the final block in the graph is visited twice, once after each loop that branches to it, and in each case, the block is deferred until the entire loop has been layered, rather than processed immediately after its predecessor block. The final position of the block is below the entirety of both loops, rather than directly below one of its predecessors as Graphviz would do. (Remember, horizontal and vertical positions have not yet been computed; the positions of the blocks in this diagram are hardcoded for demonstration purposes.)</p>

<details>
<summary>Implementation pseudocode</summary>

</details>

<div><div><pre><code><span>/*CODEBLOCK=layering*/</span><span>function</span> <span>layerBlock</span><span>(</span><span>block</span><span>,</span> <span>layer</span> <span>=</span> <span>0</span><span>)</span> <span>{</span>
  <span>// Omitted for clarity: special handling of our &#34;backedge blocks&#34;</span>

  <span>// Early out if the block would not be updated</span>
  <span>if</span> <span>(</span><span>layer</span> <span>&lt;=</span> <span>block</span><span>.</span><span>layer</span><span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>

  <span>// Update the layer of the current block</span>
  <span>block</span><span>.</span><span>layer</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>block</span><span>.</span><span>layer</span><span>,</span> <span>layer</span><span>);</span>

  <span>// Update the heights of all loops containing the current block</span>
  <span>let</span> <span>header</span> <span>=</span> <span>block</span><span>.</span><span>loopHeader</span><span>;</span>
  <span>while</span> <span>(</span><span>header</span><span>)</span> <span>{</span>
    <span>header</span><span>.</span><span>loopHeight</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>header</span><span>.</span><span>loopHeight</span><span>,</span> <span>block</span><span>.</span><span>layer</span> <span>-</span> <span>header</span><span>.</span><span>layer</span> <span>+</span> <span>1</span><span>);</span>
    <span>header</span> <span>=</span> <span>header</span><span>.</span><span>parentLoopHeader</span><span>;</span>
  <span>}</span>

  <span>// Recursively layer successors</span>
  <span>for</span> <span>(</span><span>const</span> <span>succ</span> <span>of</span> <span>block</span><span>.</span><span>successors</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>succ</span><span>.</span><span>loopDepth</span> <span>&lt;</span> <span>block</span><span>.</span><span>loopDepth</span><span>)</span> <span>{</span>
      <span>// Outgoing edges from the current loop will be layered later</span>
      <span>block</span><span>.</span><span>loopHeader</span><span>.</span><span>outgoingEdges</span><span>.</span><span>push</span><span>(</span><span>succ</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>layerBlock</span><span>(</span><span>succ</span><span>,</span> <span>layer</span> <span>+</span> <span>1</span><span>);</span>
    <span>}</span>
  <span>}</span>

  <span>// Layer any outgoing edges only after the contents of the loop have</span>
  <span>// been processed</span>
  <span>if</span> <span>(</span><span>block</span><span>.</span><span>isLoopHeader</span><span>())</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>succ</span> <span>of</span> <span>block</span><span>.</span><span>outgoingEdges</span><span>)</span> <span>{</span>
      <span>layerBlock</span><span>(</span><span>succ</span><span>,</span> <span>layer</span> <span>+</span> <span>block</span><span>.</span><span>loopHeight</span><span>);</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>







<h3 id="step-2-create-dummy-nodes">Step 2: Create dummy nodes</h3>

<p>Any time an edge crosses a layer, we create a dummy node. This allows edges to be routed across layers without overlapping any blocks. Unlike in traditional Sugiyama, we always put downward dummies on the left and upward dummies on the right, producing a consistent “counter-clockwise” flow. This also makes it easy to read long vertical edges, whose direction would otherwise be ambiguous. (Recall how the loop backedge flipped from the right to the left in the “unstable layout” Graphviz example from before.)</p>

<p>In addition, we coalesce any edges that are going to the same destination by merging their dummy nodes. This heavily reduces visual noise.</p>

<!--
Interesting program:

function test(n) {
  let result = 0;
  early:
  for (let i = n; i >= -10; i--) {
    if (i > 0) {
      switch (i % 3) {
        case 0:
          result += 1;
          break;
        case 1:
          result -= 1;
          break;
        case 2:
          result *= 3;
          break;
      }
    } else {
      result -= 2;
      break;
    }
    // result += 10;
  }
  return result;
}
-->




<h3 id="step-3-straighten-edges">Step 3: Straighten edges</h3>

<p>This is the fuzziest and most ad-hoc part of the process. Basically, we run lots of small passes that walk up and down the graph, aligning layout nodes with each other. Our edge-straightening passes include:</p>

<ul>
  <li>Pushing nodes to the right of their loop header to “indent” them.</li>
  <li>Walking a layer left to right, moving children to the right to line up with their parents. If any nodes overlap as a result, they are pushed further to the right.</li>
  <li>Walking a layer right to left, moving parents to the right to line up with their children. This version is more conservative and will not move a node if it would overlap with another. This cleans up most issues from the first pass.</li>
  <li>Straightening runs of dummy nodes so we have clean vertical lines.</li>
  <li>“Sucking in” dummy runs on the left side of the graph if there is room for them to move to the right.</li>
  <li>Straighten out any edges that are “nearly straight”, according to a chosen threshold. This makes the graph appear less wobbly. We do this by repeatedly “combing” the graph upward and downward, aligning parents with children, then children with parents, and so on.</li>
</ul>

<p>It is important to note that dummy nodes participate fully in this system. If for example you have two side-by-side loops, straightening the left loop’s backedge will push the right loop to the side, avoiding overlaps and preserving the graph’s visual structure.</p>

<p>We do not reach a fixed point with this strategy, nor do we attempt to. I find that if you continue to repeatedly apply these particular layout passes, nodes will wander to the right forever. Instead, the layout passes are hand-tuned to produce decent-looking results for most of the graphs we look at on a regular basis. That said, this could certainly be improved, especially for larger graphs which do benefit from more iterations.</p>

<p>At the end of this step, all nodes have a fixed X-coordinate and will not be modified further.</p>







<h3 id="step-4-track-horizontal-edges">Step 4: Track horizontal edges</h3>

<p>Edges may overlap visually as they run horizontally between layers. To resolve this, we sort edges into parallel “tracks”, giving each a vertical offset. After tracking all the edges, we record the total height of the tracks and store it on the preceding layer as its “track height”. This allows us to leave room for the edges in the final layout step.</p>

<p>We first sort edges by their starting position, left to right. This produces a consistent arrangement of edges that has few vertical crossings in practice. Edges are then placed into tracks from the “outside in”, stacking rightward edges on top and leftward edges on the bottom, creating a new track if the edge would overlap with or cross any other edge.</p>

<p>The diagram below is interactive. Click and drag the blocks to see how the horizontal edges get assigned to tracks.</p>

<details>
<summary>Implementation pseudocode</summary>

</details>

<div><div><pre><code><span>/*CODEBLOCK=tracks*/</span><span>function</span> <span>trackHorizontalEdges</span><span>(</span><span>layer</span><span>)</span> <span>{</span>
  <span>const</span> <span>TRACK_SPACING</span> <span>=</span> <span>20</span><span>;</span>

  <span>// Gather all edges on the layer, and sort left to right by starting coordinate</span>
  <span>const</span> <span>layerEdges</span> <span>=</span> <span>[];</span>
  <span>for</span> <span>(</span><span>const</span> <span>node</span> <span>of</span> <span>layer</span><span>.</span><span>nodes</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>edge</span> <span>of</span> <span>node</span><span>.</span><span>edges</span><span>)</span> <span>{</span>
      <span>layerEdges</span><span>.</span><span>push</span><span>(</span><span>edge</span><span>);</span>
    <span>}</span>
  <span>}</span>
  <span>layerEdges</span><span>.</span><span>sort</span><span>((</span><span>a</span><span>,</span> <span>b</span><span>)</span> <span>=&gt;</span> <span>a</span><span>.</span><span>startX</span> <span>-</span> <span>b</span><span>.</span><span>startX</span><span>);</span>

  <span>// Assign edges to &#34;tracks&#34; based on whether they overlap horizontally with</span>
  <span>// each other. We walk the tracks from the outside in and stop if we ever</span>
  <span>// overlap with any other edge.</span>
  <span>const</span> <span>rightwardTracks</span> <span>=</span> <span>[];</span> <span>// [][]Edge</span>
  <span>const</span> <span>leftwardTracks</span> <span>=</span> <span>[];</span>  <span>// [][]Edge</span>
  <span>nextEdge</span><span>:</span>
  <span>for</span> <span>(</span><span>const</span> <span>edge</span> <span>of</span> <span>layerEdges</span><span>)</span> <span>{</span>
    <span>const</span> <span>trackSet</span> <span>=</span> <span>edge</span><span>.</span><span>endX</span> <span>-</span> <span>edge</span><span>.</span><span>startX</span> <span>&gt;=</span> <span>0</span> <span>?</span> <span>rightwardTracks</span> <span>:</span> <span>leftwardTracks</span><span>;</span>
    <span>let</span> <span>lastValidTrack</span> <span>=</span> <span>null</span><span>;</span> <span>// []Edge | null</span>

    <span>// Iterate through the tracks in reverse order (outside in)</span>
    <span>for</span> <span>(</span><span>let</span> <span>i</span> <span>=</span> <span>trackSet</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>;</span> <span>i</span> <span>&gt;=</span> <span>0</span><span>;</span> <span>i</span><span>--</span><span>)</span> <span>{</span>
      <span>const</span> <span>track</span> <span>=</span> <span>trackSet</span><span>[</span><span>i</span><span>];</span>
      <span>let</span> <span>overlapsWithAnyInThisTrack</span> <span>=</span> <span>false</span><span>;</span>
      <span>for</span> <span>(</span><span>const</span> <span>otherEdge</span> <span>of</span> <span>track</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>edge</span><span>.</span><span>dst</span> <span>===</span> <span>otherEdge</span><span>.</span><span>dst</span><span>)</span> <span>{</span>
          <span>// Assign the edge to this track to merge arrows</span>
          <span>track</span><span>.</span><span>push</span><span>(</span><span>edge</span><span>);</span>
          <span>continue</span> <span>nextEdge</span><span>;</span>
        <span>}</span>

        <span>const</span> <span>al</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span><span>edge</span><span>.</span><span>startX</span><span>,</span> <span>edge</span><span>.</span><span>endX</span><span>);</span>
        <span>const</span> <span>ar</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>edge</span><span>.</span><span>startX</span><span>,</span> <span>edge</span><span>.</span><span>endX</span><span>);</span>
        <span>const</span> <span>bl</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span><span>otherEdge</span><span>.</span><span>startX</span><span>,</span> <span>otherEdge</span><span>.</span><span>endX</span><span>);</span>
        <span>const</span> <span>br</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>otherEdge</span><span>.</span><span>startX</span><span>,</span> <span>otherEdge</span><span>.</span><span>endX</span><span>);</span>
        <span>const</span> <span>overlaps</span> <span>=</span> <span>ar</span> <span>&gt;=</span> <span>bl</span> <span>&amp;&amp;</span> <span>al</span> <span>&lt;=</span> <span>br</span><span>;</span>
        <span>if</span> <span>(</span><span>overlaps</span><span>)</span> <span>{</span>
          <span>overlapsWithAnyInThisTrack</span> <span>=</span> <span>true</span><span>;</span>
          <span>break</span><span>;</span>
        <span>}</span>
      <span>}</span>

      <span>if</span> <span>(</span><span>overlapsWithAnyInThisTrack</span><span>)</span> <span>{</span>
        <span>break</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>lastValidTrack</span> <span>=</span> <span>track</span><span>;</span>
      <span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span><span>lastValidTrack</span><span>)</span> <span>{</span>
      <span>lastValidTrack</span><span>.</span><span>push</span><span>(</span><span>edge</span><span>);</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>trackSet</span><span>.</span><span>push</span><span>([</span><span>edge</span><span>]);</span>
    <span>}</span>
  <span>}</span>

  <span>// Use track info to apply offsets to each edge for rendering.</span>
  <span>const</span> <span>tracksHeight</span> <span>=</span> <span>TRACK_SPACING</span> <span>*</span> <span>Math</span><span>.</span><span>max</span><span>(</span>
    <span>0</span><span>,</span>
    <span>rightwardTracks</span><span>.</span><span>length</span> <span>+</span> <span>leftwardTracks</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>,</span>
  <span>);</span>
  <span>let</span> <span>trackOffset</span> <span>=</span> <span>-</span><span>tracksHeight</span> <span>/</span> <span>2</span><span>;</span>
  <span>for</span> <span>(</span><span>const</span> <span>track</span> <span>of</span> <span>[...</span><span>rightwardTracks</span><span>.</span><span>toReversed</span><span>(),</span> <span>...</span><span>leftwardTracks</span><span>])</span> <span>{</span>
    <span>for</span> <span>(</span><span>const</span> <span>edge</span> <span>of</span> <span>track</span><span>)</span> <span>{</span>
      <span>edge</span><span>.</span><span>offset</span> <span>=</span> <span>trackOffset</span><span>;</span>
    <span>}</span>
    <span>trackOffset</span> <span>+=</span> <span>TRACK_SPACING</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>







<h3 id="step-5-verticalize">Step 5: Verticalize</h3>

<p>Finally, we assign each node a Y-coordinate. Starting at a Y-coordinate of zero, we iterate through the layers, repeatedly adding the layer’s height and its track height, where the layer height is the maximum height of any node in the layer. All nodes within a layer receive the same Y-coordinate; this is simple and easier to read than Graphviz’s default of vertically centering nodes within a layer.</p>

<p>Now that every node has both an X and Y coordinate, the layout process is complete.</p>

<details>
<summary>Implementation pseudocode</summary>

</details>

<div><div><pre><code><span>/*CODEBLOCK=verticalize*/</span><span>function</span> <span>verticalize</span><span>(</span><span>layers</span><span>)</span> <span>{</span>
  <span>let</span> <span>layerY</span> <span>=</span> <span>0</span><span>;</span>
  <span>for</span> <span>(</span><span>const</span> <span>layer</span> <span>of</span> <span>layers</span><span>)</span> <span>{</span>
    <span>let</span> <span>layerHeight</span> <span>=</span> <span>0</span><span>;</span>
    <span>for</span> <span>(</span><span>const</span> <span>node</span> <span>of</span> <span>layer</span><span>.</span><span>nodes</span><span>)</span> <span>{</span>
      <span>node</span><span>.</span><span>y</span> <span>=</span> <span>layerY</span><span>;</span>
      <span>layerHeight</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span><span>layerHeight</span><span>,</span> <span>node</span><span>.</span><span>height</span><span>);</span>
    <span>}</span>
    <span>layerY</span> <span>+=</span> <span>layerHeight</span><span>;</span>
    <span>layerY</span> <span>+=</span> <span>layer</span><span>.</span><span>trackHeight</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>







<h3 id="step-6-render">Step 6: Render</h3>

<p>The details of rendering are out of scope for this article, and depend on the specific application. However, I wish to highlight a stylistic decision that I feel makes our graphs more readable.</p>

<p>When rendering edges, we use a style inspired by <a href="https://en.wikipedia.org/wiki/Syntax_diagram">railroad diagrams</a>. These have many advantages over the Bézier curves employed by Graphviz. First, straight lines feel more organized and are easier to follow when scrolling up and down. Second, they are easy to route (vertical when crossing layers, horizontal between layers). Third, they are easy to coalesce when they share a destination, and the junctions provide a clear indication of the edge’s direction. Fourth, they always cross at right angles, improving clarity and reducing the need to avoid edge crossings in the first place.</p>

<p>Consider the following example. There are several edge crossings that may traditionally be considered undesirable—yet the edges and their directions remain clear. Of particular note is the vertical junction highlighted in red on the left: not only is it immediately clear that these edges share a destination, but the junction itself signals that the edges are flowing downward. I find this much more pleasant than the “rat’s nest” that Graphviz tends to produce.</p>

<p><img alt="Examples of railroad-diagram edges" src="https://spidermonkey.dev/assets/img/iongraph-edge-examples-highlighted.png" width="716"/></p>

<h2 id="why-does-this-work">Why does this work?</h2>

<p>It may seem surprising that such a simple (and stupid) layout algorithm could produce such readable graphs, when more sophisticated layout algorithms struggle. However, I feel that the algorithm succeeds <em>because</em> of its simplicity.</p>

<p>Most graph layout algorithms are optimization problems, where error is minimized on some chosen metrics. However, these metrics seem to correlate poorly to readability in practice. For example, it seems good in theory to rearrange nodes to minimize edge crossings. But a predictable order of nodes seems to produce more sensible results overall, and simple rules for edge routing are sufficient to keep things tidy. (As a bonus, this also gives us layout stability from pass to pass.) Similarly, layout rules like “align parents with their children” produce more readable results than “minimize the lengths of edges”.</p>

<p>Furthermore, by rejecting the optimization problem, a human author gains more control over the layout. We are able to position nodes “inside” of loops, and push post-loop content down in the graph, <em>because</em> we reject this global constraint-solver approach. Minimizing “error” is meaningless compared to a human <em>maximizing</em> meaning through thoughtful design.</p>

<p>And finally, the resulting algorithm is simply more efficient. All the layout passes in iongraph are easy to program and scale gracefully to large graphs because they run in roughly linear time. It is better, in my view, to run a fixed number of layout iterations according to your graph complexity and time budget, rather than to run a complex constraint solver until it is “done”.</p>

<p>By following this philosophy, even the worst graphs become tractable. Below is a screenshot of a zlib function, compiled to WebAssembly, and rendered using the old tool.</p>

<p><img alt="spaghetti nightmare!!" src="https://spidermonkey.dev/assets/img/iongraph-spaghetti-nightmare.png"/></p>

<p>It took about <strong>ten minutes</strong> for Graphviz to produce this spaghetti nightmare. By comparison, iongraph can now lay out this function in <strong>20 milliseconds</strong>. The result is still not particularly beautiful, but it renders thousands of times faster <em>and</em> is much easier to navigate.</p>

<p><img alt="better spaghetti" src="https://spidermonkey.dev/assets/img/iongraph-zlib.png"/></p>

<p>Perhaps programmers ought to put less trust into magic optimizing systems, especially when a human-friendly result is the goal. Simple (and stupid) algorithms can be very effective when applied with discretion and taste.</p>

<h2 id="future-work">Future work</h2>

<p>We have already integrated iongraph into the Firefox profiler, making it easy for us to view the graphs of the most expensive or impactful functions we find in our performance work. Unfortunately, this is only available in specific builds of the SpiderMonkey shell, and is not available in full browser builds. This is due to architectural differences in how profiling data is captured and the flags with which the browser and shell are built. I would love for Firefox users to someday be able to view these graphs themselves, but at the moment we have no plans to expose this to the browser. However, one bug tracking some related work can be found <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1987005">here</a>.</p>

<p>We will continue to sporadically update iongraph with more features to aid us in our work. We have several ideas for new features, including <a href="https://github.com/mozilla-spidermonkey/iongraph/issues/9">richer navigation</a>, search, and visualization of <a href="https://github.com/mozilla-spidermonkey/iongraph/issues/4">register allocation info</a>. However, we have no explicit roadmap for when these features may be released.</p>

<p>To experiment with iongraph locally, you can run a debug build of the SpiderMonkey shell with <code>IONFLAGS=logs</code>; this will dump information to <code>/tmp/ion.json</code>. This file can then be loaded into the <a href="https://mozilla-spidermonkey.github.io/iongraph/">standalone deployment of iongraph</a>. Please be aware that the user experience is rough and unpolished in its current state.</p>

<p>The source code for iongraph can be found on <a href="https://github.com/mozilla-spidermonkey/iongraph">GitHub</a>. If this subject interests you, we would welcome contributions to iongraph and its integration into the browser. The best place to reach us is our <a href="https://chat.mozilla.org/#/room/#spidermonkey:mozilla.org">Matrix chat</a>.</p>

<hr/>

<p><em>Thanks to Matthew Gaudet, Asaf Gartner, and Colin Davidson for their feedback on this article.</em></p>




  </div>

  
</article>

      </div>
    </div>
    </section>
    </div></div>
  </body>
</html>
