<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://elijer.github.io/garden/devnotes/LeetCode-Journal/15%29-Maximum-Depth-of-Binary-Tree">Original</a>
    <h1>15) Maximum Depth of Binary Tree</h1>
    
    <div id="readability-page-1" class="page"><div id="quartz-body"><div><article><p>I tried this problem with Paul winkler. My approach was to define a recursion function inside of the main function and mutate a global <code>depth</code> variable, but as I worked through it realized I faced a challenge which was that I didnâ€™t really have a way to make sure that the left and right nodes didnâ€™t BOTH increment the global depth. I had sort of found a fake solution to this, which was incredibly stupid:</p>
<pre><code>if (root){
	let localDepth = globalDepth += 1
	if (localDepth &gt; globalDepth){
		glovalDepth = localDepth
	}
}
</code></pre>
<p>Iâ€™mâ€¦still not exactly sure what I was thinking here. This is a really verbose way of just saying <code>globalDepth++</code> ðŸ˜‚</p>
<p>But clearly when I wrote it I thought that somehow I could trick logic into only incrementing under some special condition, which never seemed to show up.</p>
<p>Ultimately, I found that a pure functional recursive approach worked great! Here it is along with my psuedocode:</p>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>/**</span></span>
<span data-line=""><span> * Definition for a binary tree node.</span></span>
<span data-line=""><span> * class TreeNode {</span></span>
<span data-line=""><span> *     val: number</span></span>
<span data-line=""><span> *     left: TreeNode | null</span></span>
<span data-line=""><span> *     right: TreeNode | null</span></span>
<span data-line=""><span> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {</span></span>
<span data-line=""><span> *         this.val = (val===undefined ? 0 : val)</span></span>
<span data-line=""><span> *         this.left = (left===undefined ? null : left)</span></span>
<span data-line=""><span> *         this.right = (right===undefined ? null : right)</span></span>
<span data-line=""><span> *     }</span></span>
<span data-line=""><span> * }</span></span>
<span data-line=""><span> */</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Return maximum depth - the number of nodes along the longest path from the root node to the farthest leaf node</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> maxDepth</span><span>(</span><span>root</span><span>:</span><span> TreeNode</span><span> |</span><span> null</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>    function</span><span> recursiveMaxDepth</span><span>(</span><span>root</span><span>:</span><span> TreeNode</span><span> |</span><span> null</span><span>, </span><span>depth</span><span>:</span><span>number</span><span> =</span><span> 0</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>root) </span><span>return</span><span> depth</span><span>// end of computation base case</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // I cannot be doing this for both branches</span></span>
<span data-line=""> </span>
<span data-line=""><span>        // let localDepth = globalDepth</span></span>
<span data-line=""><span>        // localDepth += 1</span></span>
<span data-line=""><span>        //if (localDepth &gt; globalDepth){</span></span>
<span data-line=""><span>        //    globalDepth = localDepth // mutation</span></span>
<span data-line=""><span>        //}</span></span>
<span data-line=""><span>        // I am trying to increment the global depth by 1</span></span>
<span data-line=""><span>        // for every generation</span></span>
<span data-line=""><span>        // checking if it&#39;s already been done for that generation</span></span>
<span data-line=""><span>        const</span><span> leftDepth</span><span> =</span><span> recursiveMaxDepth</span><span>(root.right, depth </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>        const</span><span> rightDepth</span><span> =</span><span> recursiveMaxDepth</span><span>(root.left, depth </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>        return</span><span> Math.</span><span>max</span><span>(leftDepth, rightDepth)</span></span>
<span data-line=""> </span>
<span data-line=""><span>    }</span></span>
<span data-line=""><span>    return</span><span> recursiveMaxDepth</span><span>(root)</span></span>
<span data-line=""><span>    // return globalDepth</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // edge case - initial root is null (make sure depth has been given initial value 0)</span></span>
<span data-line=""><span>    // some leafs are null, </span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Can&#39;t return </span></span>
<span data-line=""> </span>
<span data-line=""><span>    // local depth will start as 0 - done</span></span>
<span data-line=""><span>    // recursively start with the root node - done</span></span>
<span data-line=""><span>    // If it exists (recursive case) </span></span>
<span data-line=""><span>    // increment depth by 1,</span></span>
<span data-line=""><span>    // If it&#39;s null (base case)</span></span>
<span data-line=""><span>    // return </span></span>
<span data-line=""><span>    // do two recursive cases, one for each leaf</span></span>
<span data-line=""><span>    // We have to have a base case that returns the depth</span></span>
<span data-line=""><span>    // I think I will make a global variable, set it to 0</span></span>
<span data-line=""><span>    // and during base case, if the value of the current node is 0</span></span>
<span data-line=""><span>    // Check and see if the depth that we have at that point is greater than global depth</span></span>
<span data-line=""><span>    // If it is, set global depth</span></span>
<span data-line=""> </span>
<span data-line=""><span>    // Once done with recursion, return the global depth</span></span>
<span data-line=""><span>    </span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p><strong>Time it took me to get to this code^: 26 minutes</strong></p>
<blockquote data-callout="note" data-callout-metadata=" on followup challenge">

<p>Can I do this without recursion? No I cannot. It would be useful to learn how to do that.</p>
</blockquote>
<h2 id="despite-the-carnage-i-got-when-i-ran-this-and-generally-got-an-extra-increment-for-every-generation-of-depth-initially-i-am-proud-of-the-eloquence-of-my-final-solution-if-i-just-remove-it-from-its-parent-function-in-which-its-needlessly-encased-i-get-this">Despite the carnage I got when I ran this and generally got an extra increment for every generation of depth initially, I am proud of the eloquence of my final solution. If I just remove it from itâ€™s parent function in which itâ€™s needlessly encased, I get this:<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#despite-the-carnage-i-got-when-i-ran-this-and-generally-got-an-extra-increment-for-every-generation-of-depth-initially-i-am-proud-of-the-eloquence-of-my-final-solution-if-i-just-remove-it-from-its-parent-function-in-which-its-needlessly-encased-i-get-this"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<figure data-rehype-pretty-code-figure=""><pre tabindex="0" data-language="ts" data-theme="github-light github-dark"><code data-language="ts" data-theme="github-light github-dark"><span data-line=""><span>/**</span></span>
<span data-line=""><span> * Definition for a binary tree node.</span></span>
<span data-line=""><span> * class TreeNode {</span></span>
<span data-line=""><span> *     val: number</span></span>
<span data-line=""><span> *     left: TreeNode | null</span></span>
<span data-line=""><span> *     right: TreeNode | null</span></span>
<span data-line=""><span> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {</span></span>
<span data-line=""><span> *         this.val = (val===undefined ? 0 : val)</span></span>
<span data-line=""><span> *         this.left = (left===undefined ? null : left)</span></span>
<span data-line=""><span> *         this.right = (right===undefined ? null : right)</span></span>
<span data-line=""><span> *     }</span></span>
<span data-line=""><span> * }</span></span>
<span data-line=""><span> */</span></span>
<span data-line=""> </span>
<span data-line=""><span>// Return maximum depth - the number of nodes along the longest path from the root node to the farthest leaf node</span></span>
<span data-line=""> </span>
<span data-line=""><span>function</span><span> maxDepth</span><span>(</span><span>root</span><span>:</span><span> TreeNode</span><span> |</span><span> null</span><span>, </span><span>depth</span><span>:</span><span>number</span><span> =</span><span> 0</span><span>)</span><span>:</span><span> number</span><span> {</span></span>
<span data-line=""><span>        if</span><span> (</span><span>!</span><span>root) </span><span>return</span><span> depth</span></span>
<span data-line=""><span>        const</span><span> leftDepth</span><span> =</span><span> maxDepth</span><span>(root.right, depth </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>        const</span><span> rightDepth</span><span> =</span><span> maxDepth</span><span>(root.left, depth </span><span>+</span><span> 1</span><span>)</span></span>
<span data-line=""><span>        return</span><span> Math.</span><span>max</span><span>(leftDepth, rightDepth)</span></span>
<span data-line=""><span>};</span></span></code></pre></figure>
<p>Not bad! Thatâ€™s probably the first time Iâ€™ve gotten to a five-line function on my own in less than half an hour.</p>
<p>It never ceases to amaze me the way code works - how much more available a 40 line function is than a four or five line solution, even though the latter looks so simple when I look at it.</p></article><hr/></div></div></div>
  </body>
</html>
