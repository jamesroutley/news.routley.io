<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.timescale.com/blog/how-to-collapse-your-stack-using-postgresql-for-everything/">Original</a>
    <h1>Using Postgres for Everything</h1>
    
    <div id="readability-page-1" class="page"><div>
        <p>The idea of using <a href="https://www.timescale.com/blog/postgres-for-everything/"><u>PostgreSQL for Everything</u></a> isn&#39;t <a href="https://www.amazingcto.com/postgres-for-everything/?ref=timescale.com"><u>new</u></a>, but it&#39;s <a href="https://leaddev.com/tech/postgresql-database-quietly-ate-world?ref=timescale.com"><u>steadily</u></a> <a href="https://www.reddit.com/r/PostgreSQL/comments/1cfpyv7/what_does_postgresql_for_everything_mean_to_you/?ref=timescale.com"><u>gaining</u></a> <a href="https://www.youtube.com/watch?v=VEWXmdjzIpQ&amp;ref=timescale.com"><u>attention</u></a>, especially as Postgres keeps <a href="https://survey.stackoverflow.co/2023/?ref=timescale.com#section-most-popular-technologies-databases"><u>increasing in popularity</u></a>. As someone who’s spent most of their career deploying all sorts of databases, here’s what it means to me and how you can apply it to get some simplicity back into your world.</p><h2 id="how-technical-sprawl-creeps-in">How Technical Sprawl Creeps In</h2><p>Imagine you&#39;re starting on a new product or feature. Early on, your team lists out technical problems you need to tackle. Some solutions you&#39;ll develop in-house (your secret sauce), and others you&#39;ll address with existing technologies, probably including at least one database.</p><p>Unless you&#39;re in the business of building databases, it’s usually unwise to develop your own; it&#39;s complex, risky, and requires a very specialized skill set. So, you might end up adopting various existing databases: Postgres for transactional data, Elastic for full-text search, Influx for time series, Pinecone for vector operations, and maybe ClickHouse for analytics. Suddenly, your tech stack is sprawling.</p>
<!--kg-card-begin: html-->
<p><a href="https://imgflip.com/i/8pw1uv?ref=timescale.com"><img src="https://i.imgflip.com/8pw1uv.jpg" title="made at imgflip.com"/></a><a></a></p><!--kg-card-end: html-->
<h2 id="why-stack-sprawl-is-a-problem">Why Stack Sprawl Is a Problem</h2><p>Each new database you add brings its own set of challenges: different languages to learn, consistency models to understand, and operational nuances that can’t be ignored. Not only does this add complexity, but it also introduces what I call “dotted line” complexity, the additional overhead that comes from each pair of systems which data flows between. The more databases and the more dotted lines you have, the harder it is to reason about the state of your system as a whole.</p><p>You’ve got more databases, and because of that, you’ve got more problems.</p><figure><img src="https://www.timescale.com/blog/content/images/2024/05/Postgres-for-Everything_Biggie.gif" alt="A Biggie gif: mo&#39; databases, mo&#39; problems" loading="lazy" width="512" height="512"/></figure><h2 id="the-case-for-collapsing-your-stack">The Case for Collapsing Your Stack</h2><p>So what’s the alternative? In my mind, it’s collapsing your stack. If you solve more problems with one database, you’re removing multiple complex pieces of software and the dotted line complexity between them. It’s much easier to keep a mental model of your data flow in your head, as well as reason about the consistency of data at different times. You get time back, which would have been spent on operating these new databases, and you can spend that time building features.</p><figure><img src="https://www.timescale.com/blog/content/images/2024/05/Collapse-your-stack-postgres-for-eveything-3.png" alt="Several problems leading to a single Postgres solution" loading="lazy" width="1200" height="701" srcset="https://www.timescale.com/blog/content/images/size/w600/2024/05/Collapse-your-stack-postgres-for-eveything-3.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2024/05/Collapse-your-stack-postgres-for-eveything-3.png 1000w, https://www.timescale.com/blog/content/images/2024/05/Collapse-your-stack-postgres-for-eveything-3.png 1200w" sizes="(min-width: 720px) 720px"/></figure><p>PostgreSQL excels at stack collapsing because it’s simultaneously general-purpose and specialized. As well as being an amazing relational database, it supports a wide range of extra use cases through its advanced extension framework. PostgreSQL can easily handle workloads like <a href="https://www.postgresql.org/docs/current/textsearch-intro.html?ref=timescale.com"><u>full-text search</u></a>, <a href="https://www.timescale.com/?ref=timescale.com"><u>time-series data,</u></a> <a href="https://github.com/pgvector/pgvector?ref=timescale.com"><u>vectors for AI</u></a>, and analytics. </p><p>PostgreSQL isn’t just versatile, it&#39;s also robust and mature. People have been running PostgreSQL in production for over 20 years, and with adoption speeding up, PostgreSQL shows no sign of slowing down. Edge cases are well known, deployment patterns, recovery strategies, and high availability are well defined, and there are many, many companies and champions who can help you along the way.</p><p>Because of this, I encourage you to use PostgreSQL to solve as many problems as you can, collapsing your stack, reducing your complexity, and giving you time back to focus on building.</p><p>There’s a well-known argument that you should pick the &#34;best tool for the job,&#34; which sometimes gets turned on its head as, “If you’ve only got a hammer, everything looks like a nail.” I don’t see the principle of &#34;PostgreSQL for Everything&#34; contradicting these, as long as you make sure you look at the big picture.</p><p>How do you define &#34;The Best Database for the Job&#34;? Is it the fastest? The easiest to use? The most fault-tolerant? Or is it the one that integrates most seamlessly into your existing infrastructure and you know how to use—perhaps one that’s already in place? The best choice usually falls somewhere in between these criteria.</p><figure><img src="https://www.timescale.com/blog/content/images/2024/05/collapse-your-stack-postgres-for-everything-4.png" alt="The phrase: &#34;Let&#39;s just attach x to y and send the data to z.&#34; by someone who has no experience supporting x, y, or z. White text over a black background" loading="lazy" width="1200" height="701" srcset="https://www.timescale.com/blog/content/images/size/w600/2024/05/collapse-your-stack-postgres-for-everything-4.png 600w, https://www.timescale.com/blog/content/images/size/w1000/2024/05/collapse-your-stack-postgres-for-everything-4.png 1000w, https://www.timescale.com/blog/content/images/2024/05/collapse-your-stack-postgres-for-everything-4.png 1200w" sizes="(min-width: 720px) 720px"/></figure><p>Should you choose database X for its speed, database Y for efficiency, or database Z for its cloud optimization? If good old PostgreSQL does what you need now—with battle-tested effectiveness—and can scale further (perhaps up to 10x your current needs), then I think you should start with the known quantity. Only consider adding other databases when PostgreSQL lacks critical features, weighing the benefits against the added complexity of managing multiple systems. Or, to put it in a slightly different way, <a href="https://mcfunley.com/choose-boring-technology?ref=timescale.com"><u>Choose Boring Technology</u></a> (sorry Postgres, I promise I still think you’re exciting).</p><p>Let’s consider two possible scenarios:</p><ol><li><strong>PostgreSQL for Everything works</strong>: After years, your workload outgrows the original system capabilities. PostgreSQL struggles in some areas, but this is a “good problem”—a sign of success and a cue to evolve your architecture.</li><li><strong>Overengineered with multiple databases</strong>: You&#39;re set up to handle immense scale, but the system is fragile, full of edge cases, and difficult to maintain. This isn&#39;t just challenging; it&#39;s a threat to your operation&#39;s stability.</li></ol><p>Given these scenarios, I’d argue that the theoretical future challenges of a PostgreSQL-centric system are preferable to today’s complexities of opting into a multi-database architecture too early. </p><h2 id="a-final-word">A Final Word</h2><p>&#34;PostgreSQL for Everything&#34; isn&#39;t about never using other databases. Honestly, it’s not even about using PostgreSQL for everything. It&#39;s a maxim against overengineering your solutions prematurely and an advocate for the benefits of simplicity. Just remember, there are a lot of companies and applications in the world, and with the help of companies like Timescale, PostgreSQL will scale to meet most of their demands. </p><p>If you want to expand your PostgreSQL database, try Timescale. <a href="https://console.cloud.timescale.com/signup?ref=timescale.com" rel="noreferrer">Create a free account today</a> and start simplifying your data stack.</p>
        <div>
          <p>Ingest and query in milliseconds, even at terabyte scale.</p>
          </div>
      </div></div>
  </body>
</html>
