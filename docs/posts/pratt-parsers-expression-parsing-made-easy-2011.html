<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">Original</a>
    <h1>Pratt Parsers: Expression Parsing Made Easy (2011)</h1>
    
    <div id="readability-page-1" class="page"><article>
<header>


  <a href="https://journal.stuffwithstuff.com/2011/02/21/multiple-inheritance-in-javascript/" title="Older Post “Multiple Inheritance in JavaScript”">↩</a>


  <a href="https://journal.stuffwithstuff.com/2011/04/21/multimethods-multiple-inheritance-multiawesome/" title="Newer Post “Multimethods, Multiple Inheritance, Multiawesome!”">↪</a>

</header>
<h4><a href="https://journal.stuffwithstuff.com/archive">March 19, 2011</a>
    <span><a href="https://journal.stuffwithstuff.com/category/code">code</a> <a href="https://journal.stuffwithstuff.com/category/java">java</a> <a href="https://journal.stuffwithstuff.com/category/js">js</a> <a href="https://journal.stuffwithstuff.com/category/language">language</a> <a href="https://journal.stuffwithstuff.com/category/magpie">magpie</a> <a href="https://journal.stuffwithstuff.com/category/parsing">parsing</a></span>
</h4>

<p>Every now and then, I stumble onto some algorithm or idea that’s so clever and
such a perfect solution to a problem that I feel like I got smarter or gained <a href="http://xkcd.com/208/">a
new superpower</a> just by learning it. <a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">Heaps</a> were one, just about the
only thing I got out of my truncated CS education. I recently stumbled onto
another: <a href="http://en.wikipedia.org/wiki/Vaughan_Pratt">Pratt</a> or “top-down operator precedence” parsers.</p>

<p>When you’re writing a parser, <a href="http://en.wikipedia.org/wiki/Recursive_descent">recursive descent</a> is as easy as spreading
peanut butter. It excels when you can figure out what to parse based on the next
bit of code you’re looking at. That’s usually true at the declaration and
statement levels of a language’s grammar since most syntax there starts with
keywords—<code>class</code>, <code>if</code>, <code>for</code>, <code>while</code>, etc.</p>

<p>Parsing gets trickier when you get to expressions. When it comes to infix
operators like <code>+</code>, postfix ones like <code>++</code>, and even mixfix expressions like
<code>?:</code>, it can be hard to tell what kind of expression you’re parsing until you’re
halfway through it. You <em>can</em> do this with recursive descent, but it’s a chore.
You have to write separate functions for each level of precedence (JavaScript
has 17 of them, for example), manually handle associativity, and smear your
grammar across a bunch of parsing code until it’s hard to see.</p>

<h2>Peanut butter and jelly, the secret weapon</h2>

<p>Pratt parsing solves that. If recursive descent is peanut butter, Pratt parsing
is the jelly. When you mix the two together, you get a simple, terse, readable
parser that can handle any grammar you throw at it.</p>

<p>Pratt’s technique for handling operator precedence and infix expressions is so
simple and effective it’s a mystery why almost no one knows about it. After the
seventies, top down operator precedence parsers seem to have fallen off the
Earth. Douglas Crockford’s <a href="http://www.jslint.com/">JSLint</a> uses one to <a href="http://crockford.com/javascript/tdop/tdop.html">parse JavaScript</a>, but
his treatment is one of the <a href="http://effbot.org/zone/simple-top-down-parsing.htm">very few</a> remotely modern articles about
it.</p>

<p>Part of the problem, I think, is that Pratt’s terminology is opaque, and
Crockford’s article is itself rather murky. Pratt uses terms like “null
denominator” and Crockford mixes in extra stuff like tracking lexical scope that
obscures the core idea.</p>

<p>This is where I come in. I won’t do anything revolutionary. I’ll just try to get
the core concepts behind top down operator precedence parsers and present them
as clearly as I can. I’ll switch out some terms to (I hope) clarify things.
Hopefully I won’t offend anyone’s purist sensibilities. I’ll be coding in Java,
the vulgar Latin of programming languages. I figure if you can write it in Java,
you can write it in anything.</p>

<h2>What we’ll be making</h2>

<p>I’m a learn-by-doing person, which means I’m also a teach-by-doing one. So to
show how Pratt parsers work, we’ll build a parser for a <a href="https://github.com/munificent/bantam">tiny little toy
language called <em>Bantam</em></a>. The language only has expressions since
that’s where Pratt parsing is really helpful, but that should be enough to
convince you of its usefulness.</p>

<p>Even though Bantam is simple, it has a full gamut of operators: prefix (<code>+</code>,
<code>-</code>, <code>~</code>, <code>!</code>), postfix (<code>!</code>), infix (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>), and even a
mixfix conditional operator (<code>?:</code>). It has multiple precedence levels and both
right and left associative operators. It also has assignment, function calls and
parentheses for grouping. If we can parse this, we can parse anything.</p>

<h2>What we’ll start with</h2>

<p>All we care about is parsing, so we’ll ignore the tokenizing phase. I slapped
together <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Lexer.java">a crude lexer</a> that works and we’ll just pretend that tokens
are raining down from heaven or something.</p>

<p>A token is the smallest chunk of meaningful code. It has a type and a string
associated with it. Given <code>from + offset(time)</code>, the tokens would be:</p>
<div><pre><code data-lang="text"><span></span>NAME &#34;from&#34;
PLUS &#34;+&#34;
NAME &#34;offset&#34;
LEFT_PAREN &#34;(&#34;
NAME &#34;time&#34;
RIGHT_PAREN &#34;)&#34;
</code></pre></div>
<p>For this exercise, we won’t be <em>interpreting</em> or <em>compiling</em> this code. We just
want to parse it to a nice data structure. For our purposes, that means our
parser should chew up a bunch of <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Token.java">Token</a> objects and spit out an instance
of some class that implements <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/Expression.java">Expression</a>. To give you an idea,
here’s a simplified version of the class for a <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/expressions/ConditionalExpression.java">conditional expression</a>:</p>
<div><pre><code data-lang="java"><span>class</span> <span>ConditionalExpression</span> <span>implements</span> <span>Expression</span> <span>{</span>
  <span>public</span> <span>ConditionalExpression</span><span>(</span>
      <span>Expression</span> <span>condition</span><span>,</span>
      <span>Expression</span> <span>thenArm</span><span>,</span>
      <span>Expression</span> <span>elseArm</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>condition</span> <span>=</span> <span>condition</span><span>;</span>
    <span>this</span><span>.</span><span>thenArm</span>   <span>=</span> <span>thenArm</span><span>;</span>
    <span>this</span><span>.</span><span>elseArm</span>   <span>=</span> <span>elseArm</span><span>;</span>
  <span>}</span>

  <span>public</span> <span>final</span> <span>Expression</span> <span>condition</span><span>;</span>
  <span>public</span> <span>final</span> <span>Expression</span> <span>thenArm</span><span>;</span>
  <span>public</span> <span>final</span> <span>Expression</span> <span>elseArm</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>(You gotta love Java’s “please sign it in quadruplicate” level of bureaucracy
here. Like I said, if you can tolerate this in Java, it can work in <em>any</em>
language.)</p>

<p>We’ll start from a simple <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/Parser.java">Parser</a> class. The parser owns the token
stream, handles lookahead and provides the basic methods you need to write a
top-down recursive descent parser with a single token of lookahead (it’s
<a href="https://en.wikipedia.org/wiki/LL_parser">LL(1)</a>). This is enough to get us going. If we need more later, it’s easy to
extend it.</p>

<p>OK, let’s build ourselves a parser!</p>

<h2>First things first</h2>

<p>Even though a “full” Pratt parser is pretty tiny, I found it to be hard to
decipher. Sort of like <a href="http://en.wikipedia.org/wiki/Quicksort">quicksort</a>, the implementation is a deceptively simple
handful of deeply intertwined code. To untangle it, we’ll build it up one tiny
step at a time.</p>

<p>The simplest expressions to parse are prefix operators and single-token
expressions. For those, the current token tells us everything we need to do.
Bantam has one single-token expression: named variables. It has four prefix
operators: <code>+</code>, <code>-</code>, <code>~</code>, and <code>!</code>. The simplest possible code to parse those is:</p>
<div><pre><code data-lang="java"><span>Expression</span> <span>parseExpression</span><span>()</span> <span>{</span>
  <span>if</span> <span>(</span><span>match</span><span>(</span><span>TokenType</span><span>.</span><span>NAME</span><span>))</span>       <span>// Return NameExpression...</span>
  <span>else</span> <span>if</span> <span>(</span><span>match</span><span>(</span><span>TokenType</span><span>.</span><span>PLUS</span><span>))</span>  <span>// Return prefix + operator...</span>
  <span>else</span> <span>if</span> <span>(</span><span>match</span><span>(</span><span>TokenType</span><span>.</span><span>MINUS</span><span>))</span> <span>// Return prefix - operator...</span>
  <span>else</span> <span>if</span> <span>(</span><span>match</span><span>(</span><span>TokenType</span><span>.</span><span>TILDE</span><span>))</span> <span>// Return prefix ~ operator...</span>
  <span>else</span> <span>if</span> <span>(</span><span>match</span><span>(</span><span>TokenType</span><span>.</span><span>BANG</span><span>))</span>  <span>// Return prefix ! operator...</span>
  <span>else</span> <span>throw</span> <span>new</span> <span>ParseException</span><span>();</span>
<span>}</span>
</code></pre></div>
<p>But that’s a bit monolithic. As you can see, we’re switching off of a TokenType
to branch to different parsing behavior. Let’s encode that directly by making a
Map from TokenTypes to chunks of parsing code. We’ll call these chunks
“parselets”, and they will implement this:</p>
<div><pre><code data-lang="java"><span>interface</span> <span>PrefixParselet</span> <span>{</span>
  <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Token</span> <span>token</span><span>);</span>
<span>}</span>
</code></pre></div>
<p>An parselet implementation to parse variable names is simply:</p>
<div><pre><code data-lang="java"><span>class</span> <span>NameParselet</span> <span>implements</span> <span>PrefixParselet</span> <span>{</span>
  <span>public</span> <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Token</span> <span>token</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>NameExpression</span><span>(</span><span>token</span><span>.</span><span>getText</span><span>());</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>We can use a single class for all of the prefix operators since they only differ
in the actual operator token itself:</p>
<div><pre><code data-lang="java"><span>class</span> <span>PrefixOperatorParselet</span> <span>implements</span> <span>PrefixParselet</span> <span>{</span>
  <span>public</span> <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Token</span> <span>token</span><span>)</span> <span>{</span>
    <span>Expression</span> <span>operand</span> <span>=</span> <span>parser</span><span>.</span><span>parseExpression</span><span>();</span>
    <span>return</span> <span>new</span> <span>PrefixExpression</span><span>(</span><span>token</span><span>.</span><span>getType</span><span>(),</span> <span>operand</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>You’ll note that it calls back into <code>parseExpression()</code> to parse the operand
that appears after the operator (for example, to parse the <code>a</code> in <code>-a</code>). This
recursion takes care of nested operators like <code>-+~!a</code>.</p>

<p>Back in Parser, the chained <code>if</code> statements are replaced with a map:</p>
<div><pre><code data-lang="java"><span>class</span> <span>Parser</span> <span>{</span>
  <span>public</span> <span>Expression</span> <span>parseExpression</span><span>()</span> <span>{</span>
    <span>Token</span> <span>token</span> <span>=</span> <span>consume</span><span>();</span>
    <span>PrefixParselet</span> <span>prefix</span> <span>=</span> <span>mPrefixParselets</span><span>.</span><span>get</span><span>(</span><span>token</span><span>.</span><span>getType</span><span>());</span>

    <span>if</span> <span>(</span><span>prefix</span> <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>ParseException</span><span>(</span>
        <span>&#34;Could not parse </span><span>\&#34;</span><span>&#34;</span> <span>+</span> <span>token</span><span>.</span><span>getText</span><span>()</span> <span>+</span> <span>&#34;</span><span>\&#34;</span><span>.&#34;</span><span>);</span>

    <span>return</span> <span>prefix</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>,</span> <span>token</span><span>);</span>
  <span>}</span>

  <span>// Other stuff...</span>

  <span>private</span> <span>final</span> <span>Map</span><span>&lt;</span><span>TokenType</span><span>,</span> <span>PrefixParselet</span><span>&gt;</span> <span>mPrefixParselets</span> <span>=</span>
      <span>new</span> <span>HashMap</span><span>&lt;</span><span>TokenType</span><span>,</span> <span>PrefixParselet</span><span>&gt;</span><span>();</span>
<span>}</span>
</code></pre></div>
<p>To define the grammar we have so far—variables and the four prefix
operators—we’ll add these helper methods:</p>
<div><pre><code data-lang="java"><span>public</span> <span>void</span> <span>register</span><span>(</span><span>TokenType</span> <span>token</span><span>,</span> <span>PrefixParselet</span> <span>parselet</span><span>)</span> <span>{</span>
  <span>mPrefixParselets</span><span>.</span><span>put</span><span>(</span><span>token</span><span>,</span> <span>parselet</span><span>);</span>
<span>}</span>

<span>public</span> <span>void</span> <span>prefix</span><span>(</span><span>TokenType</span> <span>token</span><span>)</span> <span>{</span>
  <span>register</span><span>(</span><span>token</span><span>,</span> <span>new</span> <span>PrefixOperatorParselet</span><span>());</span>
<span>}</span>
</code></pre></div>
<p>And now we can define the grammar like:</p>
<div><pre><code data-lang="java"><span>register</span><span>(</span><span>TokenType</span><span>.</span><span>NAME</span><span>,</span> <span>new</span> <span>NameParselet</span><span>());</span>
<span>prefix</span><span>(</span><span>TokenType</span><span>.</span><span>PLUS</span><span>);</span>
<span>prefix</span><span>(</span><span>TokenType</span><span>.</span><span>MINUS</span><span>);</span>
<span>prefix</span><span>(</span><span>TokenType</span><span>.</span><span>TILDE</span><span>);</span>
<span>prefix</span><span>(</span><span>TokenType</span><span>.</span><span>BANG</span><span>);</span>
</code></pre></div>
<p>This is already an improvement over a recursive descent parser because our
grammar is now more declarative instead of being spread out over a few
imperative functions, and we can see the actual grammar all in one place. Even
better, we can extend the grammar just by registering new parselets. We don’t
have to change the Parser class itself.</p>

<p>If we <em>only</em> had prefix expressions, we’d be done now. Alas, we don’t.</p>

<h2>Stuck in the middle</h2>

<p>What we have so far only works if the <em>first</em> token tells us what kind of
expression we’re parsing, but that isn’t always the case. With an expression
like <code>a + b</code>, we don’t know we have an add expression until after we parse the
<code>a</code> and get to <code>+</code>. We have to extend the parser to support that.</p>

<p>Fortunately, we’re in a good place to do so. Our current <code>parseExpression()</code>
method parses a complete prefix expression including any nested prefix
expressions and then stops. So, if we throw this at it:</p>

<p>It will parse <code>-a</code> and leave us sitting on <code>+</code>. That’s exactly the token we need
to tell what infix expression we need to parse. Compared to prefix parsing, the
only change for infix parsing is that there’s another expression <em>before</em> the
infix operator that the infix parser receives as an argument. Let’s define a
parselet that supports that:</p>
<div><pre><code data-lang="java"><span>interface</span> <span>InfixParselet</span> <span>{</span>
  <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Expression</span> <span>left</span><span>,</span> <span>Token</span> <span>token</span><span>);</span>
<span>}</span>
</code></pre></div>
<p>The only difference is that <code>left</code> argument, which is the expression we parsed
before we got to the infix token. We wire this up to our parser by having
another table of infix parselets.</p>

<p>Having separate tables for prefix and infix expressions is important because we
sometimes have both a prefix and infix parselet for the same TokenType. For
example, the prefix parselet for <code>(</code> handles grouping in an expression like <code>a * (b + c)</code>. Meanwhile, the <em>infix</em> parselet for <code>(</code> handles function calls like
<code>a(b)</code>.</p>

<p>Now, after we parse the leading prefix expression, we look for an infix parser
that matches the next token and wraps the prefix expression as an operand:</p>
<div><pre><code data-lang="java"><span>class</span> <span>Parser</span> <span>{</span>
  <span>public</span> <span>void</span> <span>register</span><span>(</span><span>TokenType</span> <span>token</span><span>,</span> <span>InfixParselet</span> <span>parselet</span><span>)</span> <span>{</span>
    <span>mInfixParselets</span><span>.</span><span>put</span><span>(</span><span>token</span><span>,</span> <span>parselet</span><span>);</span>
  <span>}</span>

  <span>public</span> <span>Expression</span> <span>parseExpression</span><span>()</span> <span>{</span>
    <span>Token</span> <span>token</span> <span>=</span> <span>consume</span><span>();</span>
    <span>PrefixParselet</span> <span>prefix</span> <span>=</span> <span>mPrefixParselets</span><span>.</span><span>get</span><span>(</span><span>token</span><span>.</span><span>getType</span><span>());</span>

    <span>if</span> <span>(</span><span>prefix</span> <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>ParseException</span><span>(</span>
        <span>&#34;Could not parse </span><span>\&#34;</span><span>&#34;</span> <span>+</span> <span>token</span><span>.</span><span>getText</span><span>()</span> <span>+</span> <span>&#34;</span><span>\&#34;</span><span>.&#34;</span><span>);</span>

    <span>Expression</span> <span>left</span> <span>=</span> <span>prefix</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>,</span> <span>token</span><span>);</span>

    <span>token</span> <span>=</span> <span>lookAhead</span><span>(</span><span>0</span><span>);</span>
    <span>InfixParselet</span> <span>infix</span> <span>=</span> <span>mInfixParselets</span><span>.</span><span>get</span><span>(</span><span>token</span><span>.</span><span>getType</span><span>());</span>

    <span>// No infix expression at this point, so we&#39;re done.</span>
    <span>if</span> <span>(</span><span>infix</span> <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>left</span><span>;</span>

    <span>consume</span><span>();</span>
    <span>return</span> <span>infix</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>,</span> <span>left</span><span>,</span> <span>token</span><span>);</span>
  <span>}</span>

  <span>// Other stuff...</span>

  <span>private</span> <span>final</span> <span>Map</span><span>&lt;</span><span>TokenType</span><span>,</span> <span>InfixParselet</span><span>&gt;</span> <span>mInfixParselets</span> <span>=</span>
      <span>new</span> <span>HashMap</span><span>&lt;</span><span>TokenType</span><span>,</span> <span>InfixParselet</span><span>&gt;</span><span>();</span>
<span>}</span>
</code></pre></div>
<p>Pretty straightforward. We can implement an infix parselet for binary arithmetic
operators like <code>+</code> like so:</p>
<div><pre><code data-lang="java"><span>class</span> <span>BinaryOperatorParselet</span> <span>implements</span> <span>InfixParselet</span> <span>{</span>
  <span>public</span> <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span>
      <span>Expression</span> <span>left</span><span>,</span> <span>Token</span> <span>token</span><span>)</span> <span>{</span>
    <span>Expression</span> <span>right</span> <span>=</span> <span>parser</span><span>.</span><span>parseExpression</span><span>();</span>
    <span>return</span> <span>new</span> <span>OperatorExpression</span><span>(</span><span>left</span><span>,</span> <span>token</span><span>.</span><span>getType</span><span>(),</span> <span>right</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>Infix parselets also works for postfix operators. I’m calling them “infix”, but
they’re really “anything but prefix”. If there’s some leading subexpression that
comes before the token, the token will be handled by an infix parselet. That
includes postfix expressions and mixfix ones like <code>?:</code>.</p>

<p>Postfix expressions are as simple as single-token prefix parselets: they just
take the <code>left</code> operand and wraps it in another expression:</p>
<div><pre><code data-lang="java"><span>class</span> <span>PostfixOperatorParselet</span> <span>implements</span> <span>InfixParselet</span> <span>{</span>
  <span>public</span> <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Expression</span> <span>left</span><span>,</span>
      <span>Token</span> <span>token</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>PostfixExpression</span><span>(</span><span>left</span><span>,</span> <span>token</span><span>.</span><span>getType</span><span>());</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>Mixfix is easy too. It’s similar to recursive descent:</p>
<div><pre><code data-lang="java"><span>class</span> <span>ConditionalParselet</span> <span>implements</span> <span>InfixParselet</span> <span>{</span>
  <span>public</span> <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Expression</span> <span>left</span><span>,</span>
      <span>Token</span> <span>token</span><span>)</span> <span>{</span>
    <span>Expression</span> <span>thenArm</span> <span>=</span> <span>parser</span><span>.</span><span>parseExpression</span><span>();</span>
    <span>parser</span><span>.</span><span>consume</span><span>(</span><span>TokenType</span><span>.</span><span>COLON</span><span>);</span>
    <span>Expression</span> <span>elseArm</span> <span>=</span> <span>parser</span><span>.</span><span>parseExpression</span><span>();</span>

    <span>return</span> <span>new</span> <span>ConditionalExpression</span><span>(</span><span>left</span><span>,</span> <span>thenArm</span><span>,</span> <span>elseArm</span><span>);</span>
  <span>}</span>
<span>}</span>
</code></pre></div>
<p>Now we can parse prefix, postfix, infix, and even mixfix expressions. With a
pretty small amount of code, we can parse complex nested expressions like <code>a + (b ? c! : -d)</code>. We’re done, right? Well… almost.</p>

<h2>Excuse you, aunt Sally</h2>

<p>Our parser <em>can</em> parse all of this stuff, but it doesn’t parse it with the right
precedence or associativity. If you throw <code>a - b - c</code> at the parser, it will
parse the nested expressions like <code>a - (b - c)</code>, which isn’t right. (Well,
actually it is <em>right</em>—associative that is. We need it to be <em>left</em>.)</p>

<p>And this <em>last</em> step where we fix that is where Pratt parsers go from pretty
nice to totally radical. We’ll make two simple changes. We extend
<code>parseExpression()</code> to take a <em>precedence</em>—a number that tells which
expressions can be parsed by that call. If <code>parseExpression()</code> encounters an
expression whose precedence is lower than we allow, it stops parsing and returns
what it has so far.</p>

<p>To make that check we need to know the precedence of any given infix
expression. We’ll let the parselet specify it:</p>
<div><pre><code data-lang="java"><span>public</span> <span>interface</span> <span>InfixParselet</span> <span>{</span>
  <span>Expression</span> <span>parse</span><span>(</span><span>Parser</span> <span>parser</span><span>,</span> <span>Expression</span> <span>left</span><span>,</span> <span>Token</span> <span>token</span><span>);</span>
  <span>int</span> <span>getPrecedence</span><span>();</span>
<span>}</span>
</code></pre></div>
<p>Using that, our core expression parser looks like this:</p>
<div><pre><code data-lang="java"><span>public</span> <span>Expression</span> <span>parseExpression</span><span>(</span><span>int</span> <span>precedence</span><span>)</span> <span>{</span>
  <span>Token</span> <span>token</span> <span>=</span> <span>consume</span><span>();</span>
  <span>PrefixParselet</span> <span>prefix</span> <span>=</span> <span>mPrefixParselets</span><span>.</span><span>get</span><span>(</span><span>token</span><span>.</span><span>getType</span><span>());</span>

  <span>if</span> <span>(</span><span>prefix</span> <span>==</span> <span>null</span><span>)</span> <span>throw</span> <span>new</span> <span>ParseException</span><span>(</span>
      <span>&#34;Could not parse </span><span>\&#34;</span><span>&#34;</span> <span>+</span> <span>token</span><span>.</span><span>getText</span><span>()</span> <span>+</span> <span>&#34;</span><span>\&#34;</span><span>.&#34;</span><span>);</span>

  <span>Expression</span> <span>left</span> <span>=</span> <span>prefix</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>,</span> <span>token</span><span>);</span>

  <span>while</span> <span>(</span><span>precedence</span> <span>&lt;</span> <span>getPrecedence</span><span>())</span> <span>{</span>
    <span>token</span> <span>=</span> <span>consume</span><span>();</span>

    <span>InfixParselet</span> <span>infix</span> <span>=</span> <span>mInfixParselets</span><span>.</span><span>get</span><span>(</span><span>token</span><span>.</span><span>getType</span><span>());</span>
    <span>left</span> <span>=</span> <span>infix</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>,</span> <span>left</span><span>,</span> <span>token</span><span>);</span>
  <span>}</span>

  <span>return</span> <span>left</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>That relies on a tiny helper function to get the precedence of the current
token or a default value if there’s no infix parselet for the token:</p>
<div><pre><code data-lang="java"><span>private</span> <span>int</span> <span>getPrecedence</span><span>()</span> <span>{</span>
  <span>InfixParselet</span> <span>parser</span> <span>=</span> <span>mInfixParselets</span><span>.</span><span>get</span><span>(</span>
      <span>lookAhead</span><span>(</span><span>0</span><span>).</span><span>getType</span><span>());</span>
  <span>if</span> <span>(</span><span>parser</span> <span>!=</span> <span>null</span><span>)</span> <span>return</span> <span>parser</span><span>.</span><span>getPrecedence</span><span>();</span>

  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>And that’s it. To wire precedence into Bantam’s grammar, we set up a little
precedence table:</p>
<div><pre><code data-lang="java"><span>public</span> <span>class</span> <span>Precedence</span> <span>{</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>ASSIGNMENT</span>  <span>=</span> <span>1</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>CONDITIONAL</span> <span>=</span> <span>2</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>SUM</span>         <span>=</span> <span>3</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>PRODUCT</span>     <span>=</span> <span>4</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>EXPONENT</span>    <span>=</span> <span>5</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>PREFIX</span>      <span>=</span> <span>6</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>POSTFIX</span>     <span>=</span> <span>7</span><span>;</span>
  <span>public</span> <span>static</span> <span>final</span> <span>int</span> <span>CALL</span>        <span>=</span> <span>8</span><span>;</span>
<span>}</span>
</code></pre></div>
<p>To make our operators parse their operands with the correct precedence, they
pass an appropriate value back into <code>parseExpression()</code> when they call it
recursively. For example, the <a href="https://github.com/munificent/bantam/blob/master/src/com/stuffwithstuff/bantam/parselets/BinaryOperatorParselet.java">BinaryOperatorParselet</a> instance that handles
the <code>+</code> operator passes in <code>Precedence.SUM</code> when it parses its right-hand
operand.</p>

<p>Associativity is easy too. If an infix parselet calls <code>parseExpression()</code> with
the <em>same</em> precedence that it returns for its own <code>getPrecedence()</code> call, you
get left associativity. To be right-associative, it just needs to pass in <em>one
less</em> than that instead.</p>

<h2>Go forth and multiply</h2>

<p>I’ve rewritten the <a href="https://github.com/munificent/magpie/blob/master/src/com/stuffwithstuff/magpie/parser/MagpieParser.java">parser for Magpie</a> using this and it worked
like a charm. I’m also working on a JavaScript parser using this technique and
again it’s been a great fit.</p>

<p>I Pratt parsers to be simple, terse, extensible (Magpie, for example, uses this
to <a href="https://journal.stuffwithstuff.com/2011/02/13/extending-syntax-from-within-a-language/">let you extend its own syntax</a> at runtime), and easy to read. I’m at
the point where I can’t imagine writing a parser any other way. I never thought
I’d say this, but parsers feel easy now.</p>

<p>To see for yourself, just take a look at <a href="https://github.com/munificent/bantam">the complete program</a>.</p>



  

  
  
  
</article></div>
  </body>
</html>
