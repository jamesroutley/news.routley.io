<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://checkoway.net/musings/nix/">Original</a>
    <h1>Using Nix on macOS</h1>
    
    <div id="readability-page-1" class="page"><div><article vocab="http://schema.org" typeof="BlogPosting"><div property="articleBody"><p>I recently started using the <a href="https://nixos.org/">Nix Package Manager</a> on macOS and the process has been <a href="https://twitter.com/stevecheckoway/status/1535675350033784836">painful</a>. In this post, I’m going to write down how I’m currently using Nix on macOS with the Zsh shell.</p><p>Let me start by acknowledging Ian Henry’s wonderful series of <a href="https://ianthehenry.com/posts/how-to-learn-nix/">blog posts on Nix</a>. Nix is an extremely complex system that is poorly documented. There are many blog posts by a variety of authors about using Nix, Ian’s series is the most comprehensive (and funny) that I’ve read.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup></p><p>In this post, I will not discuss NixOS at all. I have no experience with NixOS (although the idea is neat). Every use of Nix below should be understood to mean using Nix to interact with the <code>nixpkgs</code> set of packages running on macOS.</p><p>If you’re familiar with Nix, you may be wondering, why not use <a href="https://github.com/nix-community/home-manager">Home Manager</a>? The short answer is Nix is already too complex. Adding additional tools just makes it harder to understand how Nix works and how to use it directly.</p><p>In this post, I’m going to stick with running standard Nix binaries and not use any additional tools (although there are two shell scripts that run Nix tools that I find useful at the end of the post). Nix has a bunch of experimental features (including the <code>nix</code> binary itself and flakes<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>). The experimental features change so I won’t discuss them at all either.</p><h2 id="nix-overview">Nix overview</h2><p>Nix <a href="https://nixos.org/">bills itself</a> as “a tool that takes a unique approach to package management and system configuration” that can be used “to make reproducible, declarative and reliable systems.”</p><p>In my mind, there are four main use cases for Nix.</p><ol><li>User package management;</li><li>Consistent developer environments;</li><li>One-off shells with packages installed; and</li><li>Building software.</li></ol><p>For the first use case, I mean package management in the style of Apt, MacPorts, or HomeBrew. The tool for this is called <code>nix-env</code> and it’s responsible for installing packages. It’s usually used on the command line to install packages incrementally. For example, if you want to install the excellent <a href="https://github.com/BurntSushi/ripgrep">ripgrep</a> tool, you’d use the following command.</p><div><div><pre><code>$ nix-env -iA nixpkgs.ripgrep
</code></pre></div></div><p>Like any good package manager, this will install <code>rg</code> along with any dependencies.</p><p>Nix also supports a declarative package management system where you put the list of packages you want in a file and then you can (for example) check that file into version control.</p><p>Nix’s second use case lets developers declaratively specify a (more or less) complete environment for a project in a <code>shell.nix</code> file. (E.g., a Python project may require other Python packages to be installed. These dependencies can be specified in the <code>shell.nix</code> file. All developers can use the <code>nix-shell</code> command to launch a Bash shell with the appropriate dependencies installed and available.) This use case seems more aspirational than practical since it requires all developers use Nix to get this benefit.</p><p>The third use case is Nix’s killer feature in my mind. Rather than install and remove packages as necessary, Nix lets you create a one-off shell that contains a set of packages. For example, if you need a shell with <code>socat</code> installed and don’t want to install it in your normal environment using <code>nix-env</code>, you would run</p><p>which would fire up a new Bash shell with <code>socat</code> installed and ready to run. Neat!</p><p>The last use case is similar to the second except that rather than just have the dependencies be installed and managed by Nix, the whole project is built by Nix.</p><p>Of these, I’m interested in declarative package management, one-off shells, and developer environments, in that order. I’m not interested in building software using Nix.</p><h2 id="consistent-reproducable-declarative-package-management">Consistent, reproducable, declarative package management</h2><p>My requirements for using Nix as a package management system are simple.</p><ul><li>It must be <em>declarative</em> in that I can write a simple file (I call mine <code>env.nix</code>) which specifies the list of packages to install;</li><li>It must be <em>reproducable</em> meaning that I should be able to check my <code>env.nix</code> into version control, check it out later—on another machine—and get the same set of packages installed; and</li><li>It must be <em>consistent</em> in the sense that if I install a package via <code>nix-env</code> (as I did above with Ripgrep), then that should be exactly the same as if I had specified it in my <code>env.nix</code> file.</li></ul><p>One could be forgiven for thinking consistency is a natural consequence of reproducability. In Nix, consistency requires additional work.</p><p>Let’s start by making a declarative list of packages. There are at least three ways of using Nix as a declarative package manager: <a href="https://ianthehenry.com/posts/how-to-learn-nix/overlays/">overlays</a>, <a href="https://ianthehenry.com/posts/how-to-learn-nix/overriding/">overrides</a>, and for lack of a better term, a package file.</p><p>Overlays and overrides are confusing and don’t match my mental model for how declaring a set of packages to be installed should work. And I think using them is more complex than necessary. But first, we need to talk about how Nix works.</p><h3 id="how-nix-works">How Nix works</h3><p>At a high level, you tell Nix to install a package (<code>$ nix-env -iA nixpkgs.fd</code> installs the excellent <code>fd</code> utility) and it figures out everything it needs to install, and then installs it.</p><p>In more detail, Nix reads and evaluates the “Nix expression” that says how to build software. Each expression is (usually) contained in a file somewhere that says how to build the software. <a href="https://github.com/NixOS/nixpkgs/blob/becea4604c71b6508346102bf9e3a50d449cde85/pkgs/tools/misc/fd/default.nix">This is the Nix expression</a> for building version 8.4.0 of <code>fd</code>.</p><p>Nix expressions are written in the Nix language which is pure, lazy, and functional (like Haskell) and the main datatype is the “attribute set” which is just a key-value map or dictionary. The Nix expression for building software evaluates to a <em>derivation</em> which is an attribute set containing a key <code>type</code> with the value <code>derivation</code>. <strong>A side effect of <code>nix-env</code> evaluating a derivation is to download and install the package described by the derivation!</strong> This is kind of shocking in a pure language.</p><p>Once a derivation is evaluated, the package is installed under <code>/nix</code> somewhere and symlinks are created in the user’s <em>profile</em>. A profile is just a directory containing <code>bin</code> and <code>share</code> and similar directories. There’s a symlink <code>~/.nix-profile</code> which points to the active profile.</p><p>Nix exposes software to a shell by creating symlinks in the profile’s <code>bin</code> directory. One of the shell’s start up files will contain code to put <code>~/.nix-profile/bin</code> in the <code>PATH</code> environment variable. (See [below][#fixing-shell-integration] for more details.) <code>nix-shell</code>, the command for getting shells with packages installed works similarly except it also adjusts the <code>PATH</code> before invoking Bash.</p><p>(Nix supports multiple profiles and rolling back profiles to earlier versions. This happens by updating the <code>~/.nix-profile</code> symbolic link. I have found no use for using multiple profiles because my environment is specified declaratively by a file in Git, so I can use standard Git commands to roll back as needed.)</p><p>Before getting to my approach, there’s one last thing we need to discuss and that’s where does Nix get the Nix expressions that are used to build packages? The answer is complicated and is different for each Nix tool.</p><p>First, <code>nix-env</code> uses a “default” expression when installing, updating, and querying for available packages. (Never, ever update packages with <code>nix-env -u</code>. I have no idea what the use case is, but it does the wrong thing. Just don’t do it. Similarly, never use <code>nix-env -i</code> without also passing <code>-A</code>. It doesn’t do what you want otherwise.) The default expression is either a file or a directory named <code>~/.nix-defexpr</code>.</p><p>If it’s a file, then the contents of a file is the default expression which must evaluate to an attribute set (dictionary). If it’s a directory, then the name of each directory inside <code>~/.nix-defexpr</code> becomes a key in the default expression’s attribute set whose value is the result of evaluating the <code>default.nix</code> inside the directory. It’s complicated and the full details are immaterial. But as an example</p><div><div><pre><code>~/.nix-defexpr
├── bar
│   └── default.nix
└── foo
    └── default.nix
</code></pre></div></div><p>would create an attribute set <code>{ foo = ...; bar = ...; }</code> as the default expression where the values corresponding to <code>foo</code> and <code>bar</code> come from evaluating their <code>default.nix</code> files.</p><p>The traditional method of using Nix as a package manager uses <a href="https://nixos.wiki/wiki/Nix_channels">Nix channels</a> which are similar to Git branches. Each channel refers to a <a href="https://github.com/NixOS/nixpkgs/"><code>nixpkgs</code></a> commit. Nix has a tool, <code>nix-channel</code>, which maintains a list of channels. It downloads a snapshot of the <code>nixpkgs</code> repository at the commit specified by the channel. This contains all of the Nix expressions used to build packages (as well as a bunch of helper Nix code). <code>$ nix-env -iA</code> can then be used to install (or update) a package.</p><p>Returning to my original example</p><div><div><pre><code>$ nix-env -iA nixpkgs.ripgrep
</code></pre></div></div><p>this instructs <code>nix-env</code> to start with the “default” expression (<code>~/.nix-defexpr</code>) which evaluates to an attribute set as described above. Next, <code>nix-env</code> will look up the key <code>nixpkgs</code> in the default expression which returns another attribute set. Then, <code>nix-env</code> will look up the key <code>ripgrep</code> in that attribute set. Since this causes the <code>ripgrep</code> derivation to be evaluated, it will install the package (and dependencies).</p><p>Nix channels have a problem: they’re not reproducible. You get whatever revision of <code>nixpkgs</code> happens to be current when you run <code>$ nix-channel --update</code>. As a result, Nix channels are not useful and I won’t discuss them further, but the <code>~/.nix-defexpr</code> is essential for <code>nix-env</code>. I’ll return to this below.</p><p>So if <code>nix-env</code> uses this default Nix expression, it stands to reason that other Nix tools like <code>nix-shell</code> do as well. Alas, no.</p><p>The second method Nix tools like <code>nix-shell</code> and <code>nix-build</code> use to look up Nix expressions is via the <code>NIX_PATH</code> environment variable. There are a bunch of valid formats for <code>NIX_PATH</code>, but the simplest is a colon-separated list of directories. <code>NIX_PATH</code> is used in two key places (for my purposes).</p><p>The first is when <code>nix-shell</code> is run on a file (<code>shell.nix</code> by default), the contents of the file is the entire Nix expression. Since these files need a way to refer to Nix packages, it’s common to see Nix files that contain a line like this.</p><p>Without delving too deeply into the Nix language, the <code>import &lt;nixpkgs&gt;</code> instructs <code>nix-shell</code> to look for a directory named <code>nixpkgs</code> in the <code>NIX_PATH</code> and load <code>nixpkgs/default.nix</code> as a Nix expression. The <code>{}</code> is an empty attribute set that is passed to the function returned by <code>import &lt;nixpkgs&gt;</code>. Why does <code>import &lt;nixpkgs&gt;</code> return a function? It does simply because the expression that was loaded from the <code>nixpkgs/default.nix</code> file is a function. This function will return an attribute set whose keys are the names of packages, more or less.</p><p>So we have two separate mechanisms to specify where to find a Nix expression that describes how to build a package.</p><p>The last thing we need is a way to specify a particular revision of the <code>nixpkgs</code> repository we want to use. There are multiple ways to do this. For <code>NIX_PATH</code>, we can use a URL like <code>NIX_PATH=nixpkgs=https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz</code> which will map <code>&lt;nixpkgs&gt;</code> to <code>nixpkgs</code> revision <code>87d9c84817d7be81850c07e8f6a362b1dfc30feb</code>.</p><p>For <code>nix-env</code>, there are several ways to do this, including having a single <code>~/.nix-defexpr</code> file, a <code>~/.nix-defexpr/nixpkgs.nix</code> file, or a <code>~/.nix-defexpr/nixpkgs/default.nix</code> file. I’d prefer the first option, but as we’ll see the last option works best. The contents of <code>~/.nix-defexpr/nixpkgs/default.nix</code> is a single expression that evaluates to a function which, when called, evaluates to the attribute set containing the list of packages.</p><div><div><pre><code><span>import</span> <span>(</span><span>fetchTarball</span> <span>&#34;https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz&#34;</span><span>)</span>
</code></pre></div></div><p>(Note the lack of <code>{}</code> at the end of the line. This is because the contents of the file needs to evaluate to a function which is precisely what we get from the <code>import</code>. If we added the <code>{}</code>, it’d call the function and return an attribute set.)</p><p>At the end of the day, I want the exact same packages to be installed regardless of whether I use <code>$ nix-env -iA foo</code> or <code>nix-shell -p foo</code>, or update the list of packages in my <code>env.nix</code>. That means we’ll need <code>NIX_PATH</code> and the default Nix expression to agree on the list of packages.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup></p><h3 id="declarative-package-manager-implementation">Declarative package manager implementation</h3><p>With all of the preliminaries out of the way, let’s see how to set up a declarative package manager that meets my three requirements.</p><p>Let’s make a list of packages that works first and pin it to a specific <code>nixpkgs</code> revision afterward.</p><p>As discussed above, <code>nix-env</code> has a default expression it uses for installing packages. This default can be overridden using the <code>-f</code> (or <code>--file</code>) argument. We can also instruct <code>nix-env</code> to also install <em>every</em> package. I have no idea why we’d want to do that in general. However, if we specify a different default expression—one that contains just a list of the packages we want—then it’ll install all of those. So without further ado, here’s my <code>env.nix</code>.</p><div><div><pre><code><span>with</span> <span>import</span> <span>&lt;</span><span>nixpkgs</span><span>&gt;</span> <span>{};</span> <span>[</span>
  <span>calc</span>
  <span>coreutils-full</span>
  <span>fd</span>
  <span>gdb</span>
  <span>jq</span>
  <span>nasm</span>
  <span>neovim</span>
  <span>nodejs</span>
  <span>pwgen</span>
  <span>python3</span>
  <span>ripgrep</span>
  <span>ruby_3_1</span>
  <span>shellcheck</span>
  <span>socat</span>
  <span>tmux</span>
  <span>tree</span>
  <span>universal-ctags</span>
  <span>zsh-syntax-highlighting</span>
<span>]</span>
</code></pre></div></div><p>The <code>with expr1; expr2</code> construct evaluates <code>expr1</code> to an attribute set <em>S</em> and then it evaluates <code>expr2</code> with the keys of <em>S</em> bound to their values. We can write an equivalent <code>env.nix</code> file as something like</p><div><div><pre><code><span>let</span>
  <span>pkgs</span> <span>=</span> <span>import</span> <span>&lt;</span><span>nixpkgs</span><span>&gt;</span> <span>{};</span>
<span>in</span> <span>[</span>
  <span>pkgs</span><span>.</span><span>calc</span>
  <span>pkgs</span><span>.</span><span>coreutils-full</span>
  <span>...</span>
  <span>pkgs</span><span>.</span><span>zsh-syntax-highlighting</span>
<span>]</span>
</code></pre></div></div><p>To install all of the packages in <code>env.nix</code>, it’s sufficient to run <code>$ nix-env -irf env.nix</code>. The <code>--remove-all</code> (<code>-r</code>) flag will remove anything that was installed (e.g., by <code>nix-env -iA</code>) but isn’t in <code>env.nix</code>.</p><p>This satisfies my first requirement: a <em>declarative</em> package manager.</p><p>Note that this is essentially the solution Ian Henry <a href="https://ianthehenry.com/posts/how-to-learn-nix/declarative-user-environment/">arrived at</a>. All credit to him for this.</p><p>Notice how <code>$ nix-env -irf env.nix</code> is not using the default Nix expression, <code>~/.nix-defexpr</code>, but is instead using <code>NIX_PATH</code> by way of <code>import &lt;nixpkgs&gt;</code>. To satisfy the second requirement, <em>reproducability</em>, we need to pin <code>nixpkgs</code> to a particular revision. We can do that by setting <code>NIX_PATH=nixpkgs=https://...</code> as described above; however, there’s a better way.</p><p>To make this reproducable, it’s enough to check the <code>env.nix</code> and the shell dotfiles which set <code>NIX_PATH</code> into version control.</p><p>The final requirement is <em>consistency</em>: installing a package using any of the standard methods (<code>nix-env -iA</code>, <code>nix-env -irf env.nix</code>, <code>nix-shell -p</code>, etc.) should always give me the same package. If <code>~/.nix-defexpr</code> and <code>NIX_SHELL</code> are kept in sync, pointing to the same revision of <code>nixpkgs</code>, this will work out.</p><p>Unfortunately, updating the Nix expressions for a package by changing the value of the <code>NIX_PATH</code> environment variable has a few downsides. First, changing it in a dotfile like <code>~/.bash_profile</code> or <code>~/.zprofile</code> has no effect on the currently running shells meaning it’d be easy to install package in a shell that still has the old <code>NIX_PATH</code> value.</p><p>So that suggests that <code>NIX_PATH</code> should remain constant and only <code>~/.nix-defexpr</code> should be updated. My <code>~/.zprofile</code> contains the following line (but see <a href="#fixing-shell-integration">fixing shell integration</a> below).</p><div><div><pre><code><span>export </span><span>NIX_PATH</span><span>=</span><span>&#34;</span><span>$HOME</span><span>/.nix-defexpr&#34;</span>
</code></pre></div></div><p>Recall that if <code>NIX_PATH</code> is a colon-separated list of directories, then the Nix code <code>import &lt;foo&gt;</code> is going to look for a directory named <code>foo</code> in each of those directories. Since I’m always using <code>import &lt;nixpkgs&gt;</code> (as is everyone else), we need a <code>~/.nix-defexpr/nixpkgs</code> directory containing a <code>default.nix</code> file.<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup></p><div><div><pre><code><span>import</span> <span>(</span><span>fetchTarball</span> <span>&#34;https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz&#34;</span><span>)</span>
</code></pre></div></div><p>This is the only file that specifies which revision of <code>nixpkgs</code> to use and it will be used by all of the Nix tools.</p><p>Checking this file into version control (along with <code>nix.env</code> and the <code>~/.zprofile</code> which specifies <code>NIX_PATH</code>) satisfies all of my requirements. Yay!</p><h2 id="fixing-shell-integration">Fixing shell integration</h2><p>Installing Nix on macOS is a bit unpleasant. Single-user installs are no longer supported. Multi-user installs have to be used instead.<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup> This goes through a complicated dance to create <code>/nix</code> and some accounts for building software not as your user.</p><p>One of the steps of the installer is to modify the system-wide <code>/etc/bashrc</code> and <code>/etc/zshrc</code> files to insert the lines</p><div><div><pre><code><span># Nix</span>
<span>if</span> <span>[</span> <span>-e</span> <span>&#39;/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&#39;</span> <span>]</span><span>;</span> <span>then</span>
  <span>.</span> <span>&#39;/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&#39;</span>
<span>fi</span>
<span># End Nix</span>
</code></pre></div></div><p>The sourced <code>nix-daemon.sh</code> starts the Nix daemon running and sets some environment variables, including <code>PATH</code>.</p><p>This code doesn’t belong in either of these files for two reasons: 1. They’re system-owned files. macOS <em>will</em> overwrite them when updating so you need equivalent code in your local shell start up files. 2. Setting environment variables doesn’t belong in the shell’s rc files; neither in the global ones in <code>/etc</code> nor in the dotfile ones in <code>$HOME</code>. It belongs in the local “profile” files: <code>~/.bash_profile</code> and <code>~/.zprofile</code>.</p><p>To elaborate on the second point, we have to look at which files are sourced when shells start and that means we have to talk about types of shells (unfortunately).</p><p>Every shell is either a login shell or not. Independently, every shell is either interactive or not. All four combinations are possible, although a noninteractive, login shell is uncommon.</p><p>A login shell is created by running <code>$ bash -l</code> or <code>$ zsh --login</code>. Otherwise, it’s not a login shell.</p><p>An interactive shell is one that gives you a prompt and you, well, interact with. A noninteractive shell is what you get when you run a shell script.</p><p>Usually, your terminal emulator will create a login shell by default when you open a new terminal window. (Apple Terminal and iTerm2 both do.) And that’s generally the only time you create a login shell.</p><p>When a login shell is created, it’s usually going to create its environment from scratch rather than using the environment it inherited from its parent. In contrast, since a nonlogin shell is usually created by running <code>bash</code> or <code>zsh</code> from inside another shell, it’s going to inherit its environment. This suggests that environment variables (like <code>PATH</code>) should only ever be set when login shells start. Since they’re going to be the same from shell to shell, it doesn’t make sense to set them again when starting a nonlogin shell.</p><p>Interactive shells, in contrast, need to be configured every time they are started. This includes setting up shell completions and command line prompts (e.g., <code>PS1</code>). We have to do this every time because these settings are not inherited by child processes.</p><p>To support this, shells support a dizzying array of files that get read on start up. In the interest of length, I’m going to focus on Zsh since that’s the new default macOS shell.</p><p>Zsh has 8 different startup files it sources, depending on whether the shell is a login shell or not and whether the shell is interactive or not. Here they are, in the order they are sourced.</p><ol><li><code>/etc/zshenv</code></li><li><code>~/.zshenv</code></li><li><code>/etc/zprofile</code> for a login shell</li><li><code>~/.zprofile</code> for a login shell</li><li><code>/etc/zshrc</code> for an interactive shell</li><li><code>~/.zshrc</code> for an interactive shell</li><li><code>/etc/zlogin</code> for a login shell</li><li><code>~/.zlogin</code> for a login shell</li></ol><p>If a file doesn’t exist, it is skipped. On macOS, <code>/etc/zshenv</code> and <code>/etc/zlogin</code> don’t exist so we can ignore those. I don’t use <code>~/.zlogin</code>, so we can ignore that one too.</p><p>This leaves <code>~/.zshenv</code>, <code>/etc/zprofile</code>, <code>~/.zprofile</code>, <code>/etc/zshrc</code>, and <code>~/.zshrc</code> to deal with.</p><p>“But Steve,” I hear you object, “I don’t care about any of that. I just want to put all my shell configuration in a single file and be done with it.” That’d be nice, but macOS doesn’t care what you want.</p><p>Here’s the problem. On macOS, <code>/etc/zprofile</code> runs <code>/usr/libexec/path_helper</code> and sets <code>PATH</code> from its output. <code>path_helper</code> constructs a <code>PATH</code> starting with the paths from <code>/etc/paths</code> and <code>/etc/paths.d</code> and appending the other directories already on <code>PATH</code>. Let’s look at an example.</p><p>With an empty <code>PATH</code>, <code>path_helper</code> outputs a string (which the shell will <code>eval</code>) to set a default <code>PATH</code>.</p><div><div><pre><code>$ PATH= /usr/libexec/path_helper
PATH=&#34;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin&#34;; export PATH;
</code></pre></div></div><p>If <code>PATH</code> contains any other directories, such as <code>~/.nix-profile/bin</code>, these will be moved to the end.</p><div><div><pre><code>$ PATH=$HOME/.nix-profile/bin:/usr/bin /usr/libexec/path_helper
PATH=&#34;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Library/Apple/usr/bin:/Users/steve/.nix-profile/bin&#34;; export PATH;
</code></pre></div></div><p>Therefore, if a new login shell is launched, your <code>PATH</code> will be rearranged!</p><p>To deal with this, we’ll need to treat login shell specially and reset <code>PATH</code> prior to <code>/etc/zprofile</code> being sourced.</p><p>This is a relatively minor issue since you don’t often run a new login shell. A bigger problem comes from interactive shells.</p><p>Nix’s modifications to <code>/etc/zshrc</code> will source <code>nix-daemon.sh</code> which unconditionally prepends Nix profile directories to <code>PATH</code>. So invoking <code>zsh</code> (i.e., an interactive, nonlogin shell) causes the directories to be added to the <code>PATH</code> again.</p><p>To summarize, if we launch a new login shell, our <code>PATH</code> is rearranged. If we launch a new interactive shell, duplicate entries are added to the path. If we launch a new interactive, login shell, we get a rearranged <code>PATH</code> with duplicate entries. Not great.</p><p>So here’s the solution. First, after installing Nix, undo the modifications Nix made to the files in <code>/etc</code>. The install script creates a copy of the file before modification (e.g., <code>/etc/zprofile.backup-before-nix</code>). Just rename that to <code>/etc/zprofile</code> to restore the original.</p><p>Second, create a <code>~/.zshenv</code> file with the following contents.</p><div><div><pre><code><span>[[</span> <span>-o</span> login <span>]]</span> <span>&amp;&amp;</span> <span>export </span><span>PATH</span><span>=</span><span>&#39;/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin&#39;</span>
</code></pre></div></div><p>If Zsh is launched as a login shell, then it’ll source <code>~/.zshenv</code> which will reset <code>PATH</code> to a sensible default. Next, it’ll source <code>/etc/zprofile</code> which will run <code>path_helper</code> and set up the default <code>PATH</code> according to the usual macOS rules.</p><p>Third, create a <code>~/.zprofile</code> file containing all of the exported environment variables you want. You should also prepend directories to <code>PATH</code> in this file. Since this is sourced after <code>path_helper</code> is run, the directories added will not be rearranged.</p><p>This is the (partial) contents of my <code>~/.zprofile</code>.</p><div><div><pre><code><span># Environment variables.</span>
<span>export </span><span>EDITOR</span><span>=</span><span>&#39;nvim&#39;</span>
<span>export </span><span>LANG</span><span>=</span>en_US.UTF-8
<span>export </span><span>LC_CTYPE</span><span>=</span>en_US.UTF-8
<span>export </span><span>PAGER</span><span>=</span><span>&#39;less -R&#39;</span>
<span># Other exported environment variables here.</span>

<span># Add paths to PATH.</span>
<span>if</span> <span>[[</span> <span>-f</span> <span>&#39;/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&#39;</span> <span>]]</span><span>;</span> <span>then
  </span><span>source</span> <span>&#39;/nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh&#39;</span>
  <span>export </span><span>NIX_PATH</span><span>=</span><span>&#34;</span><span>$HOME</span><span>/.nix-defexpr&#34;</span>
<span>fi</span>
<span>[[</span> <span>-f</span> <span>&#34;</span><span>$HOME</span><span>/.ghcup/env&#34;</span> <span>]]</span> <span>&amp;&amp;</span> <span>source</span> <span>&#34;</span><span>$HOME</span><span>/.ghcup/env&#34;</span>
<span>[[</span> <span>-f</span> <span>&#34;</span><span>$HOME</span><span>/.cargo/env&#34;</span> <span>]]</span> <span>&amp;&amp;</span> <span>source</span> <span>&#34;</span><span>$HOME</span><span>/.cargo/env&#34;</span>
</code></pre></div></div><p>Notice that it sets <code>NIX_PATH</code> as described above.</p><p>It’s important that the <code>PATH</code> clearing happen in <code>~/.zshenv</code> and not <code>~/.zprofile</code> because otherwise system directories from <code>/etc/paths</code> won’t make it into the <code>PATH</code> (or work will have to be duplicated).</p><p>Finally, put the per-shell configuration in <code>~/.zshrc</code>. This includes things like your prompt, shell aliases, shell completions, and so on.</p><p>In general, if it’s an exported environment variable, put it in <code>~/.zprofile</code>. If it’s any other configuration, put it in <code>~/.zshrc</code>.</p><p>With this setup, every new login shell will clear <code>PATH</code> and reset it. Nonlogin shells (interactive or not) will inherit the <code>PATH</code>.</p><h2 id="wrapping-up">Wrapping up</h2><p>To summarize, to use Nix on macOS in a reliable and reproducable manner,</p><ol><li>Undo the modifications the Nix installer made to the files in <code>/etc</code>;</li><li>Separate your shell configuration into <code>~/.zshenv</code>, <code>~/.zprofile</code>, and <code>~/.zshrc</code> such that exported environment variables go in <code>~/.zprofile</code>, configuration for interactive shells goes in <code>~/.zshrc</code>, and <code>~/.zshenv</code> resets <code>PATH</code> for login shells;</li><li>Create a <code>~/.nix-defexpr/nixpkgs/default.nix</code> file with the single line <div><div><pre><code><span>import</span> <span>(</span><span>fetchTarball</span> <span>&#34;https://github.com/NixOS/nixpkgs/archive/87d9c84817d7be81850c07e8f6a362b1dfc30feb.tar.gz&#34;</span><span>)</span>
</code></pre></div></div></li><li>Modify <code>~/.zprofile</code> to run <code>nix-daemon.sh</code> and set <code>NIX_PATH</code>; and</li><li>Create an <code>env.nix</code> somewhere containing your list of packages and install them with <code>$ nix-env -irf env.nix</code>.</li></ol><p>The only thing I haven’t touched on is how you get the revision of <code>nixpkgs</code> to use. How I do it is I run a script (which I called <code>nix-update-nixpkgs</code>) which grabs the revision for the stable Darwin (i.e., macOS) channel and uses that.</p><div><div><pre><code><span>#!/usr/bin/env nix-shell</span>
<span>#!nix-shell -i bash -p bash curl jq</span>
<span># shellcheck shell=bash</span>

<span># Just go with the revision that works for stable darwin. Might as well for now</span>
<span># unless there&#39;s an issue.</span>

<span>set</span> <span>-euo</span> pipefail

<span>dryrun</span><span>=</span>0

usage<span>()</span> <span>{</span>
  <span>cat</span> <span>&lt;&lt;</span><span>USAGEEOF</span><span>
Usage: </span><span>$0</span><span> [OPTIONS]

Options:
  -h  --help      show this help
  -n  --dry-run   do not make any changes
</span><span>USAGEEOF
</span><span>}</span>

<span>for </span>arg <span>in</span> <span>&#34;</span><span>$@</span><span>&#34;</span><span>;</span> <span>do
  case</span> <span>${</span><span>arg</span><span>}</span> <span>in</span>
    <span>&#39;-n&#39;</span> <span>|</span> <span>&#39;--dry-run&#39;</span><span>)</span>
      <span>dryrun</span><span>=</span>1
      <span>;;</span>
    <span>&#39;-h&#39;</span> <span>|</span> <span>&#39;--help&#39;</span><span>)</span>
      usage
      <span>exit </span>0
      <span>;;</span>
    <span>*</span><span>)</span>
      <span>echo</span> <span>&#34;</span><span>$0</span><span>: Unexpected argument: </span><span>${</span><span>arg</span><span>}</span><span>&#34;</span> <span>&gt;</span>&amp;2
      usage <span>&gt;</span>&amp;2
      <span>exit </span>1
      <span>;;</span>
  <span>esac</span>
<span>done


</span><span>revision</span><span>=</span><span>$(</span>curl <span>--silent</span> <span>--show-error</span> <span>&#39;https://monitoring.nixos.org/prometheus/api/v1/query?query=channel_revision&#39;</span> <span>\</span>
  | jq <span>-r</span> <span>&#39;.data.result[]|select(.metric.status == &#34;stable&#34; and .metric.variant == &#34;darwin&#34;).metric.revision&#39;</span><span>)</span>
<span>nixexpr</span><span>=</span><span>&#34;import (fetchTarball </span><span>\&#34;</span><span>https://github.com/NixOS/nixpkgs/archive/</span><span>${</span><span>revision</span><span>}</span><span>.tar.gz</span><span>\&#34;</span><span>)&#34;</span>
<span>nixpkgsfile</span><span>=</span>~/.nix-defexpr/nixpkgs/default.nix

<span>mkdir</span> <span>-p</span> <span>&#34;</span><span>$(</span><span>dirname</span> <span>&#34;</span><span>${</span><span>nixpkgsfile</span><span>}</span><span>&#34;</span><span>)</span><span>&#34;</span>
<span>if</span> <span>[[</span> <span>-f</span> <span>&#34;</span><span>${</span><span>nixpkgsfile</span><span>}</span><span>&#34;</span> <span>]]</span> <span>&amp;&amp;</span> diff <span>-q</span> <span>&#34;</span><span>${</span><span>nixpkgsfile</span><span>}</span><span>&#34;</span> - <span>&lt;&lt;&lt;</span> <span>&#34;</span><span>${</span><span>nixexpr</span><span>}</span><span>&#34;</span> <span>&gt;</span>/dev/null<span>;</span> <span>then
  </span><span>echo</span> <span>&#39;nixpkgs already up to date&#39;</span>
  <span>exit </span>0
<span>fi

if</span> <span>[[</span> <span>${</span><span>dryrun</span><span>}</span> <span>-ne</span> 0 <span>]]</span><span>;</span> <span>then
  </span><span>echo</span> <span>&#34;This would set nixpkgs to revision </span><span>${</span><span>revision</span><span>}</span><span>&#34;</span>
<span>else
  </span><span>echo</span> <span>&#34;Setting nixpkgs to revision </span><span>${</span><span>revision</span><span>}</span><span>&#34;</span>
  <span>echo</span> <span>&#34;</span><span>${</span><span>nixexpr</span><span>}</span><span>&#34;</span> <span>&gt;</span><span>${</span><span>nixpkgsfile</span><span>}</span>
<span>fi</span>

<span>&#34;</span><span>$(</span><span>dirname</span> <span>&#34;</span><span>$0</span><span>&#34;</span><span>)</span><span>/nix-diff&#34;</span> <span>&#34;</span><span>${</span><span>revision</span><span>}</span><span>&#34;</span>
<span># vim: set sw=2 sts=2 ts=8 et ft=bash:</span>
</code></pre></div></div><p>The penultimate line runs my <code>nix-diff</code> script which shows the changes that would be made if <code>$ nix-env -irf env.nix</code> were run. This is based on Ian Henry’s <a href="https://github.com/ianthehenry/sd-nix/blob/master/diff">similar script</a>. Here it is.</p><div><div><pre><code><span>#!/usr/bin/env nix-shell</span>
<span>#!nix-shell -i bash -p bash jq</span>
<span># shellcheck shell=bash</span>

<span># Usage: nix-diff [revision]</span>
<span># where revision is the full nixpkgs revision.</span>

<span>set</span> <span>-euo</span> pipefail

<span>declare</span> <span>-A</span> cur

query<span>()</span> <span>{</span>
  nix-env <span>--query</span> <span>--json</span> <span>&#34;</span><span>$@</span><span>&#34;</span> | jq <span>-r</span> <span>&#39;.[] | .pname + &#34; &#34; + .version&#39;</span>
<span>}</span>

<span>query_args</span><span>=()</span>

<span>if</span> <span>[[</span> <span>$# </span><span>-eq</span> 1 <span>]]</span><span>;</span> <span>then
  </span><span>query_args</span><span>=(</span><span>&#39;--file&#39;</span> <span>&#34;https://github.com/NixOS/nixpkgs/archive/</span><span>$1</span><span>.tar.gz&#34;</span><span>)</span>
<span>fi

while </span><span>read</span> <span>-r</span> name version<span>;</span> <span>do
  </span>cur[<span>${</span><span>name</span><span>}</span><span>]=</span><span>${</span><span>version</span><span>}</span>
<span>done</span> &lt; &lt;<span>(</span>query <span>&#34;</span><span>${</span><span>query_args</span><span>[@]</span><span>}</span><span>&#34;</span><span>)</span>

<span>ret</span><span>=</span>0
<span>while </span><span>read</span> <span>-r</span> name version<span>;</span> <span>do
  if</span> <span>[[</span> <span>-n</span> <span>${</span><span>cur</span><span>[</span><span>${</span><span>name</span><span>}</span><span>]</span><span>:-}</span> <span>]]</span><span>;</span> <span>then
    if</span> <span>[[</span> <span>&#34;</span><span>${</span><span>version</span><span>}</span><span>&#34;</span> <span>!=</span> <span>&#34;</span><span>${</span><span>cur</span><span>[</span><span>${</span><span>name</span><span>}</span><span>]</span><span>}</span><span>&#34;</span> <span>]]</span><span>;</span> <span>then
      </span><span>echo</span> <span>-e</span> <span>&#34;</span><span>\0</span><span>33[33mM </span><span>${</span><span>name</span><span>}</span><span> </span><span>${</span><span>cur</span><span>[</span><span>${</span><span>name</span><span>}</span><span>]</span><span>}</span><span> ➤ </span><span>${</span><span>version</span><span>}</span><span>\0</span><span>33[0m&#34;</span>
      <span>ret</span><span>=</span>1
    <span>fi
    </span><span>unset</span> <span>&#34;cur[</span><span>${</span><span>name</span><span>}</span><span>]&#34;</span>
  <span>else
    </span><span>echo</span> <span>-e</span> <span>&#34;</span><span>\0</span><span>33[32mA </span><span>${</span><span>name</span><span>}</span><span> </span><span>${</span><span>version</span><span>}</span><span>\0</span><span>33[0m&#34;</span>
    <span>ret</span><span>=</span>1
  <span>fi
done</span> &lt; &lt;<span>(</span>query <span>-af</span> <span>&#34;</span><span>${</span><span>HOME</span><span>}</span><span>/.dotfiles/env.nix&#34;</span><span>)</span>

<span>for </span>name <span>in</span> <span>&#34;</span><span>${</span><span>!cur[@]</span><span>}</span><span>&#34;</span><span>;</span> <span>do
  </span><span>echo</span> <span>-e</span> <span>&#34;</span><span>\0</span><span>33[31mD </span><span>${</span><span>name</span><span>}</span><span> </span><span>${</span><span>cur</span><span>[</span><span>${</span><span>name</span><span>}</span><span>]</span><span>}</span><span>\0</span><span>33[0m&#34;</span>
  <span>ret</span><span>=</span>1
<span>done

if</span> <span>[[</span> <span>${</span><span>ret</span><span>}</span> <span>-ne</span> 0 <span>]]</span><span>;</span> <span>then</span>
  <span># Disable SC2016 (info): Expressions don&#39;t expand in single quotes, use double quotes for that.</span>
  <span># shellcheck disable=SC2016</span>
  <span>echo</span> <span>&#39;Run `nix-env -irf ~/.dotfiles/env.nix` to make these changes&#39;</span>
<span>fi

</span><span>exit</span> <span>&#34;</span><span>${</span><span>ret</span><span>}</span><span>&#34;</span>

<span># vim: set sw=2 sts=2 ts=8 et ft=bash:</span>
</code></pre></div></div><p>Happy Nixing.</p><hr/></div></article></div></div>
  </body>
</html>
