<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.sawyerhood.com/blog/llm-extension">Original</a>
    <h1>The Bitter Lesson of LLM Extensions</h1>
    
    <div id="readability-page-1" class="page"><div><p>Three years ago, “using an LLM” meant pasting a wall of text into a chat box and hoping for something useful back. Today, we point agents at our codebases, our browsers, and let them go off and act on our behalf. A key question that has been brewing under the surface during this time has been: <strong>how do we let end users actually customize these systems</strong>?</p>
<p>As models have become more capable, the ways and mechanisms that end users have access to customize them have expanded as well. We&#39;ve gone from simple system prompts to complex client-server protocols and back again.</p>
<p>I wanted to take a moment to reflect on the history of LLM extension over the last three years and where I see it going in the future.</p>
<h2>ChatGPT Plugins (<a href="https://openai.com/index/chatgpt-plugins/">March 2023</a>)</h2>
<p>Just four months after launch, OpenAI announced <strong>ChatGPT Plugins</strong>. Looking back, these were wildly ahead of their time.</p>
<p>The idea was ambitious: give the LLM a link to an OpenAPI spec and let it &#34;run wild&#34; calling REST endpoints. It was a direct line to AGI-style thinking: universal tool use via standard APIs.</p>
<pre><code><span><span>{</span>
</span><span>  <span>&#34;schema_version&#34;</span><span>:</span> <span>&#34;v1&#34;</span><span>,</span>
</span><span>  <span>&#34;name_for_human&#34;</span><span>:</span> <span>&#34;TODO Manager&#34;</span><span>,</span>
</span><span>  <span>&#34;name_for_model&#34;</span><span>:</span> <span>&#34;todo_manager&#34;</span><span>,</span>
</span><span>  <span>&#34;description_for_human&#34;</span><span>:</span> <span>&#34;Manages your TODOs!&#34;</span><span>,</span>
</span><span>  <span>&#34;description_for_model&#34;</span><span>:</span> <span>&#34;An app for managing a user&#39;s TODOs&#34;</span><span>,</span>
</span><span>  <span>&#34;api&#34;</span><span>:</span> <span>{</span> <span>&#34;url&#34;</span><span>:</span> <span>&#34;/openapi.json&#34;</span> <span>}</span><span>,</span>
</span><span>  <span>&#34;auth&#34;</span><span>:</span> <span>{</span> <span>&#34;type&#34;</span><span>:</span> <span>&#34;none&#34;</span> <span>}</span><span>,</span>
</span><span>  <span>&#34;logo_url&#34;</span><span>:</span> <span>&#34;https://example.com/logo.png&#34;</span><span>,</span>
</span><span>  <span>&#34;legal_info_url&#34;</span><span>:</span> <span>&#34;http://example.com&#34;</span><span>,</span>
</span><span>  <span>&#34;contact_email&#34;</span><span>:</span> <span>&#34;hello@example.com&#34;</span>
</span><span><span>}</span>
</span></code></pre>
<p>The problem? <strong>The models weren&#39;t ready.</strong> GPT-3.5 (and even early GPT-4) struggled to navigate massive API specs without hallucinating or getting lost in context. Plus, the UX was clunky. You had to manually toggle plugins for every chat!</p>
<p>Here&#39;s what that looked like:</p>
<p><iframe src="https://player.vimeo.com/video/810715468?h=ee0f32a8f5&amp;badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen="" title="ChatGPT Plugins Demo"></iframe></p>
<p>But it gave us a glimpse of the future: <strong>The Code Interpreter</strong> plugin (later Advanced Data Analysis) became indispensable, foreshadowing the powerful sandboxed execution environments we use today.</p>
<h2>Custom Instructions (<a href="https://openai.com/index/custom-instructions-for-chatgpt/?utm_source=chatgpt.com">July 2023</a>)</h2>
<p>Custom instructions were the &#34;smooth brain&#34; counter-reaction to the complexity of plugins. I did a double take when writing this because I thought for sure this feature was released before plugins.</p>
<p>It was just a user-defined prompt appended to every chat. Simple. Obvious. Yet it solved a huge problem: repetitive context setting.</p>
<p>This was the spiritual ancestor to every <code>.cursorrules</code> and <code>CLAUDE.md</code> file that followed.</p>
<h2>Custom GPTs (<a href="https://openai.com/index/introducing-gpts/">Nov 2023</a>)</h2>
<p>OpenAI repackaged instructions and tools into <strong>Custom GPTs</strong>. This was an attempt to &#34;productize&#34; prompt engineering. You could bundle a persona, some files, and a few actions into a shareable link.</p>
<p>It was a retreat from the open-ended promise of plugins toward curated, single-purpose &#34;apps.&#34;</p>
<h2>Memory in ChatGPT (<a href="https://openai.com/index/memory-and-new-controls-for-chatgpt/">February 2024</a>)</h2>
<p>So far, we&#39;ve discussed manual ways to extend LLMs. <strong>Memory</strong> represented a shift toward automatic personalization.</p>
<p>ChatGPT Memory records details from your conversations and quietly inserts them into future context. It&#39;s like a system prompt that writes itself. If you mention you&#39;re a vegetarian, it remembers that weeks later. It’s a small feature, but it marked the beginning of agents that maintain long-term state without user intervention.</p>
<h2>Cursor Rules (<a href="https://cursor.com/changelog/0-32-x">April 2024</a>)</h2>
<p><strong>Cursor</strong> changed the game by putting custom instructions where they belonged: <strong>in the repo</strong>.</p>
<p>The <code>.cursorrules</code> file was a revelation. Instead of pasting context into a chat window, you committed it to git.</p>
<ul>
<li>&#34;We use tabs, not spaces.&#34;</li>
<li>&#34;No semicolons.&#34;</li>
<li>&#34;Always use TypeScript.&#34;</li>
</ul>
<p>It started as a single file, then evolved into a <code>.cursor/rules</code> folder with sophisticated scoping. You could organize multiple rule files, and even define when they applied, for example, only for certain file types or subdirectories. It was the first time extension felt &#34;native&#34; to the code.</p>
<p>Later Cursor introduced the ability to let the LLM decide when to apply a rule, which is a pattern we will see again.</p>
<h2>Model Context Protocol (<a href="https://en.wikipedia.org/wiki/Model_Context_Protocol">Nov 2024</a>)</h2>
<p>By late 2024, models were finally smart enough to handle real tools reliably. Anthropic&#39;s <strong>Model Context Protocol (MCP)</strong> was the answer.</p>
<p>MCP is a heavyweight solution. An MCP client needs to keep a persistent connection to an MCP server. The server serves up tool definitions, resources, and prompts to the client (in most cases is an agent) and it can send a message to the server saying a tool has been called and the server can respond with the result.</p>
<p>Unlike Custom Instructions (which just add context), <strong>MCP gives the model actual capabilities</strong>. It can read your repo, query your Postgres DB, or deploy to Vercel. Besides just providing tools, it also allows servers to provide <strong>resources</strong> (documents, logs) and <strong>prompts</strong> directly to the agent.</p>
<p>It&#39;s powerful, and perhaps a bit of overkill. While the complexity might be worth it for agent developers asking a user to set up and connect an MCP is a lot of friction and there is an entire ecosystem of startups like <a href="https://smithery.ai/">Smithery</a> built around making it easier to use MCP.</p>
<p>It is worth noting that ChatGPT apps which were announced in <a href="https://openai.com/index/introducing-apps-in-chatgpt/">October 2025</a> are built on top of MCP as a base layer. This is an attempt to make it easier for end users to use MCP without having to actually think about it.</p>
<h2>Claude Code: New Agent, New Extensions (Feb 2025)</h2>
<p>Early 2025 brought us <strong>Claude Code</strong>, which essentially added every extension mechanism under the sun to an agent.</p>
<ul>
<li><strong><code>CLAUDE.md</code>:</strong> The standard for repo-level instructions.</li>
<li><strong>MCP:</strong> For heavy-duty tool integration.</li>
<li><strong>Slash Commands:</strong> Like Cursor&#39;s notebooks, for reusable prompts.</li>
<li><strong>Hooks:</strong> The ability to intercept and modify the agent&#39;s loop (e.g., &#34;Stop if the tests fail&#34;).</li>
<li><strong>Sub-agents:</strong> Spawning specialized workers to handle sub-tasks.</li>
<li><strong>Output Styles:</strong> (Deprecated) Configuring tone and format.</li>
</ul>
<p>Time will tell how many of these features will stick around in the long term. Anthropic has already tried to <a href="https://github.com/anthropics/claude-code/blob/main/CHANGELOG.md#2030">deprecate output styles</a>.</p>
<h2>Agent Skills (<a href="https://www.claude.com/blog/skills">Oct 2025</a>)</h2>
<p>The next extension mechanism added to Claude Code is significant enough to warrant a deeper dive. <strong>Agent Skills</strong> are the rebirth of ChatGPT Plugins.</p>
<p>While MCP has a whole client-server protocol, Agent Skills are just folders of markdown files and scripts (in whatever language you choose).</p>
<p>The agent simply scans a <code>skills/</code> directory, reads the frontmatter of every <code>SKILL.md</code>, and builds a lightweight index. It then chooses to read the full contents of a skill only if it&#39;s appropriate for the current task. This solves one of the major problems with MCP: the context bloat that comes from having to load all of the tool definitions into the context window at once.</p>
<p>Here is a snippet of the structure of a skill for doing e2e testing with Playwright taken from Anthropic&#39;s <a href="https://github.com/anthropics/skills/blob/main/webapp-testing/SKILL.md">Skills examples</a> repository:</p>
<pre><code><span>webapp-testing/
</span><span>├── examples/
</span><span>│   ├── console_logging.py
</span><span>│   ├── element_discovery.py
</span><span>│   └── static_html_automation.py
</span><span>├── scripts/
</span><span>│   └── with_server.py
</span><span>└── SKILL.md
</span></code></pre>
<p>There is a mix of scripts, examples, and plain text instructions. The only required file is the SKILL.md file. Let&#39;s take a look at that file:</p>
<pre><code><span><span><span>---</span>
</span></span><span><span><span><span>name</span><span>:</span> webapp<span>-</span>testing
</span></span></span><span><span><span><span>description</span><span>:</span> Toolkit for interacting with and testing local web applications using Playwright. Supports verifying frontend functionality<span>,</span> debugging UI behavior<span>,</span> capturing browser screenshots<span>,</span> and viewing browser logs.
</span></span></span><span><span><span><span>license</span><span>:</span> Complete terms in LICENSE.txt</span>
</span></span><span><span><span>---</span></span>
</span><span>
</span><span><span><span>#</span> Web Application Testing</span>
</span><span>
</span><span>To test local web applications, write native Python Playwright scripts.
</span><span>
</span><span><span><span>**</span><span>Helper Scripts Available</span><span>**</span></span>:
</span><span>
</span><span><span>-</span> <span>`scripts/with_server.py`</span> - Manages server lifecycle (supports multiple servers)
</span><span>
</span><span><span><span>**</span><span>Always run scripts with <span>`--help`</span> first</span><span>**</span></span> to see usage. DO NOT read the source until you try running the script first and find that a customized solution is absolutely necessary. These scripts can be very large and thus pollute your context window. They exist to be called directly as black-box scripts rather than ingested into your context window.
</span><span>
</span><span>... skill continues ...
</span></code></pre>
<p>This is just a plain markdown file with some metadata and a description of the skill. The agent reads the file which freely references other files that the agent can read. In contrast a playwright MCP server has dozens of tool definitions to control a browser, this skill just says &#34;you have bash, this is how you write a playwright script&#34;.</p>
<p>Granted to use a skill the agent needs to have general purpose access to a computer, but this is the <a href="https://en.wikipedia.org/wiki/Bitter_lesson">bitter lesson</a> in action. Giving an agent general purpose tools and trusting it to have the ability to use them to accomplish a task might very well be the winning strategy over making specialized tools for every task.</p>
<h2>What the future holds</h2>
<p>Skills are the actualization of the dream that was set out by ChatGPT Plugins: just give the model instructions and some generic tools and trust it to do the glue work in-between. But I have a hypothesis that it might actually work now because the <strong>models are actually smart enough for it to work.</strong></p>
<p>Agent skills work because it assumes the agent has the ability to write its own tools (via bash commands). You can just give it code snippets and ask the agent to figure out how to run them generically for the task at hand.</p>
<p>Importantly, I think that skills signal towards a new definition of what an agent really is. An agent isn&#39;t just a LLM in a while loop. It&#39;s an LLM in a while loop that has a computer strapped to it.</p>
<p>Claude Code is the piece of software that first made this click for me, but it is way too developer focused to be the final form. Other applications like <a href="https://www.zo.computer/">Zo Computer</a> try to package the llm and computer together into a single application, but I still think it still doesn&#39;t abstract the computer away enough from the end user. If I ask a coworker to do something, I don&#39;t need to see their entire file system, I just need to know that they have a computer.</p>
<p>Looking forward into 2026 I expect more and more llm applications that we use will have a computer strapped to them in new and interesting ways, whether we know it or not.</p>
<p>If I could short MCP, I would, and I expect us to go back to extending our agents with the most accessible programming language: natural language.</p></div></div>
  </body>
</html>
