<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/">Original</a>
    <h1>Extreme Pi Boot Optimization</h1>
    
    <div id="readability-page-1" class="page"><div><p>üöÄ 3.5 sec to Linux userspace code</p><h3 id="motivation">Motivation<a href="#motivation" aria-label="Heading self-link"></a></h3><p>A while ago, the <a href="https://kittenlabs.de/solarcampi/">SolarCamPi</a> project, a off-grid solar-powered WiFi camera, was built.</p><p>In this project, a Raspberry Pi Zero 2 W is being booted into Linux, a picture is taken, WiFi connectivity is established and the Pi is shut down again (to save power).
This repeats every couple of minutes to always deliver a fresh image to a cloud service.</p><p><img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/IMG_4607.jpg" width="49%" alt="Weatherproof enclosure, with 7.2Ah lead-gel battery and SolarCamPi inside"/> <img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/IMG_4629.jpg" width="49%" alt="Mast, with solar panel, WiFi antenna and SolarCamPi enclosure mounted to it, in nature"/></p><p>Each second the Pi Zero is powered up uses valuable electricity, which is a scarce resource in a solar-powered device (at least in West European winters‚Ä¶).</p><p>There a 2 possible ways to reduce total energy consumption further:</p><ul><li>decrease power consumption / current</li><li>decrease time spent running</li></ul><p>However, in some situations a balance needs to be found between the two.
For example: Disabling CPU turbo just to save some current consumption is a bad choice, because the resulting extra time will use more energy than just getting the job done quickly and shutting off.
We want the least area under the graph (of current vs. time) possible.</p><h3 id="hardware-setup">Hardware setup<a href="#hardware-setup" aria-label="Heading self-link"></a></h3><p>Having a short cycle time between making a change and actually seeing it run is critical when optimizing embedded boot processes.
Swapping SD cards, messing with card readers and power supplies while working is distracting and annoying.</p><p>In order to avoid this, a number of useful tools exist:</p><ul><li><a href="https://www.nordicsemi.com/Products/Development-hardware/Power-Profiler-Kit-2" target="_blank">Nordic Power Profiler Kit II</a></li><li><a href="https://github.com/linux-automation/usbsdmux" target="_blank">USB-SD-Mux Fast</a></li><li>USB-UART converter</li></ul><p><img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/featured-DSC01414.jpg" width="80%" alt="Hardware setup, Raspberry Pi Zero 2 W, USB-SD-Mux and PPK2"/></p><h5 id="power-profiler-kit">Power Profiler Kit<a href="#power-profiler-kit" aria-label="Heading self-link"></a></h5><p>The Power Profiler Kit II (now called PPK) can supply power to a device-under-test (DUT) and will measure it accurately over time.
You can enable/disable the DUT, see the power consumption at any point and also see the status of 8 digital inputs!
We‚Äôll connect one of the digital inputs to a GPIO pin on the Raspberry Pi.</p><p>This way, the first action of ‚Äúour application‚Äù (aka the finish line) will be to toggle the GPIO pin.
We then just have to measure the time between power-up and GPIO toggle.</p><h5 id="usb-sd-mux">USB-SD-Mux<a href="#usb-sd-mux" aria-label="Heading self-link"></a></h5><p>The USB-SD-Mux is a very useful tool for hardware hackers - it‚Äôs an interposer between a microSD card and a DUT with a USB-C interface.
A computer can ‚Äústeal‚Äù the microSD card from the DUT, rewrite its contents and then plug the microSD card back into the DUT, without ever having to touch the device.</p><p>This makes the workflow of testing changes <em>much</em> easier and faster by avoiding unplugging the card, plugging it into a microSD reader, flashing it, plugging the card back into the DUT, etc. It can even be used to automate the reset or power of the DUT with on-board GPIOs.</p><h5 id="usb-uart-converter">USB-UART converter<a href="#usb-uart-converter" aria-label="Heading self-link"></a></h5><p>Some form of UART interface is pretty much required. These changes will break system boot, WiFi connectivity, etc. at some point and without a UART console we would be flying blind. A standard CP2102, FTDI, etc. will work well.</p><h3 id="measurement--test-setup">Measurement / Test setup<a href="#measurement--test-setup" aria-label="Heading self-link"></a></h3><p>On a clean Debian 12 (bookworm) arm64 Lite image, the <code>/boot/firmware/cmdline.txt</code> file was modified to include <code>init=/init.sh</code>.
This means that the kernel will execute the script at <code>/init.sh</code> as the very first thing in userspace (before running systemd or anything else).</p><p>Such an <code>init.sh</code> script might look like this:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span>gpioset <span>0</span> <span>4</span><span>=</span><span>0</span>
</span></span><span><span>sleep <span>1</span>
</span></span><span><span>gpioset <span>0</span> <span>4</span><span>=</span><span>1</span>
</span></span><span><span>sleep <span>1</span>
</span></span><span><span>gpioset <span>0</span> <span>4</span><span>=</span><span>0</span>
</span></span><span><span>
</span></span><span><span><span>exec</span> /sbin/init
</span></span></code></pre></div><p>which will toggle the GPIO4 and then resume normal boot by replacing itself with <code>/sbin/init</code> (aka systemd).</p><p><img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/debian12-lite-arm64-initsh.png" alt="Power Profiler screenshot, showing GPIO4 going low after about 12s"/></p><p>In this screenshot from Nordic‚Äôs Power Profiler software, you can see the current consumption of the Raspberry Pi (at 5V) while booting.
After about 12 seconds, digital input 0 is going low, showing that our <code>init.sh</code> was executed.</p><p>In doing so, a total charge of 1.90 coulomb (coulomb and ampere-seconds are equivalent) was used.</p><p>For reference: A single AA-alkaline battery can deliver about 13500 Ws of energy.</p><h3 id="reducing-current">Reducing current<a href="#reducing-current" aria-label="Heading self-link"></a></h3><p>Let‚Äôs get the easy part out of the way first and reduce the operating current as much as possible.</p><h5 id="disabling-hdmi">Disabling HDMI<a href="#disabling-hdmi" aria-label="Heading self-link"></a></h5><p>We can disable the HDMI encoder entirely. Disabling the GPU is not possible, because we need it to encode our camera data.
If your application doesn‚Äôt require camera/GPU support, try disabling the GPU entirely.</p><p>This reduces the current consumption from 136.7mA down to 122.6mA (over 10%!).</p><p>Relevant config.txt parameters:</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span># disable HDMI (saves power)</span>
</span></span><span><span><span>dtoverlay</span><span>=</span><span>vc4-kms-v3d,nohdmi</span>
</span></span><span><span><span>max_framebuffers</span><span>=</span><span>1</span>
</span></span><span><span><span>disable_fw_kms_setup</span><span>=</span><span>1</span>
</span></span><span><span><span>disable_overscan</span><span>=</span><span>1</span>
</span></span><span><span>
</span></span><span><span><span># disable composite video output</span>
</span></span><span><span><span>enable_tvout</span><span>=</span><span>0</span>
</span></span></code></pre></div><h5 id="disabling-activity-led">Disabling Activity LED<a href="#disabling-activity-led" aria-label="Heading self-link"></a></h5><p>Just by disabling the activity LED, we can save 2mA (122.6mA down to 120.6mA).</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span>dtparam</span><span>=</span><span>act_led_trigger=none</span>
</span></span><span><span><span>dtparam</span><span>=</span><span>act_led_activelow=on</span>
</span></span></code></pre></div><h5 id="disabling-camera-led">Disabling Camera LED<a href="#disabling-camera-led" aria-label="Heading self-link"></a></h5><p>Repeat the same for the camera LED (if present). It will also reduce the chance of the LED reflecting back into the image.</p><h4 id="turbo-tweaking">Turbo tweaking<a href="#turbo-tweaking" aria-label="Heading self-link"></a></h4><p>As mentioned before, saving current while wasting time might not be ideal.</p><p>With our current changes, the Pi can boot while using 1.62As.
<img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/turbo-defaults.png" alt="Power Profiler screenshot, showing a total current usage of 1.62C/As"/></p><div><pre tabindex="0"><code data-lang="ini"><span><span><span>force_turbo</span><span>=</span><span>0</span>
</span></span><span><span><span>initial_turbo</span><span>=</span><span>10</span>
</span></span><span><span><span>arm_boost</span><span>=</span><span>0</span>
</span></span></code></pre></div><p>Without forced turbo mode, 1.58As were used:
<img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/turbo-disabled.png" alt="Power Profiler screenshot, showing a total current usage of 1.58C/As"/></p><p>For some, unknown reason, disabling the turbo/boost mode also inverts the default state of GPIO4 (thus I‚Äôve switched the polarity in init.sh).</p><h3 id="reducing-time">Reducing time<a href="#reducing-time" aria-label="Heading self-link"></a></h3><p>The ~13% reduction in current is helpful, but there‚Äôs still a long way to go.</p><p>The Pi takes 8s (while consuming ~1As) before the first line of Linux output appears on the console.</p><h4 id="debug-boot">Debug boot<a href="#debug-boot" aria-label="Heading self-link"></a></h4><p>In the boot process of the Raspberry Pi family, the GPU initializes first.</p><p>We can modify this bootcode.bin to <a href="https://www.raspberrypi.com/documentation/computers/raspberry-pi.html#bootcode-bin-uart-enable" target="_blank">enable detailed UART logging</a>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>sed -i -e <span>&#34;s/BOOT_UART=0/BOOT_UART=1/&#34;</span> /boot/firmware/bootcode.bin
</span></span></code></pre></div><p><strong>Backup the original bootcode.bin first, this process is potentially destructive.</strong></p><p>Rebooting with <code>BOOT_UART</code> enabled gives us loads of nice information:</p><pre tabindex="0"><code>Raspberry Pi Bootcode

Found SD card, config.txt = 1, start.elf = 1, recovery.elf = 0, timeout = 0
Read File: config.txt, 1322 (bytes)

Raspberry Pi Bootcode
Read File: config.txt, 1322
Read File: start.elf, 2981376 (bytes)
Read File: fixup.dat, 7303 (bytes)
MESS:00:00:01.295242:0: brfs: File read: /mfs/sd/config.txt
MESS:00:00:01.300131:0: brfs: File read: 1322 bytes
MESS:00:00:01.335680:0: HDMI0:EDID error reading EDID block 0 attempt 0
[..]
MESS:00:00:01.392537:0: HDMI0:EDID error reading EDID block 0 attempt 9
MESS:00:00:01.398632:0: HDMI0:EDID giving up on reading EDID block 0
MESS:00:00:01.406335:0: brfs: File read: /mfs/sd/config.txt
MESS:00:00:01.411272:0: gpioman: gpioman_get_pin_num: pin LEDS_PWR_OK not defined
MESS:00:00:01.918176:0: gpioman: gpioman_get_pin_num: pin LEDS_PWR_OK not defined
MESS:00:00:01.923999:0: *** Restart logging
MESS:00:00:01.927872:0: brfs: File read: 1322 bytes
MESS:00:00:01.933328:0: hdmi: HDMI0:EDID error reading EDID block 0 attempt 0
[..]
MESS:00:00:01.995436:0: hdmi: HDMI0:EDID error reading EDID block 0 attempt 9
MESS:00:00:02.002052:0: hdmi: HDMI0:EDID giving up on reading EDID block 0
MESS:00:00:02.007955:0: hdmi: HDMI0:EDID error reading EDID block 0 attempt 0
[..]
MESS:00:00:02.070610:0: hdmi: HDMI0:EDID error reading EDID block 0 attempt 9
MESS:00:00:02.077225:0: hdmi: HDMI0:EDID giving up on reading EDID block 0
MESS:00:00:02.082840:0: hdmi: HDMI:hdmi_get_state is deprecated, use hdmi_get_display_state instead
MESS:00:00:02.091586:0: HDMI0: hdmi_pixel_encoding: 162000000
MESS:00:00:02.799203:0: brfs: File read: /mfs/sd/initramfs8
MESS:00:00:02.803082:0: Loaded &#39;initramfs8&#39; to 0x0 size 0xb0898e
MESS:00:00:02.821799:0: initramfs loaded to 0x1b4e7000 (size 0xb0898e)
MESS:00:00:02.836318:0: dtb_file &#39;bcm2710-rpi-zero-2-w.dtb&#39;
MESS:00:00:02.840194:0: brfs: File read: 11569550 bytes
MESS:00:00:02.849171:0: brfs: File read: /mfs/sd/bcm2710-rpi-zero-2-w.dtb
MESS:00:00:02.854262:0: Loaded &#39;bcm2710-rpi-zero-2-w.dtb&#39; to 0x100 size 0x8258
MESS:00:00:02.876038:0: brfs: File read: 33368 bytes
MESS:00:00:02.892755:0: brfs: File read: /mfs/sd/overlays/overlay_map.dtb
MESS:00:00:02.927145:0: brfs: File read: 5255 bytes
MESS:00:00:02.933541:0: brfs: File read: /mfs/sd/config.txt
MESS:00:00:02.937568:0: dtparam: audio=on
MESS:00:00:02.948005:0: brfs: File read: 1322 bytes
MESS:00:00:02.971952:0: brfs: File read: /mfs/sd/overlays/vc4-kms-v3d.dtbo
MESS:00:00:03.023016:0: Loaded overlay &#39;vc4-kms-v3d&#39;
MESS:00:00:03.026278:0: dtparam: nohdmi=true
MESS:00:00:03.031105:0: dtparam: act_led_trigger=none
MESS:00:00:03.048180:0: dtparam: act_led_activelow=on
MESS:00:00:03.149316:0: brfs: File read: 2760 bytes
MESS:00:00:03.154502:0: brfs: File read: /mfs/sd/cmdline.txt
MESS:00:00:03.158504:0: Read command line from file &#39;cmdline.txt&#39;:
MESS:00:00:03.164369:0: &#39;console=serial0,115200 console=tty1 root=PARTUUID=26bbce6b-02 rootfstype=ext4 fsck.repair=yes rootwait cfg80211.ieee80211_regdom=DE init=/init.sh&#39;
MESS:00:00:03.195926:0: gpioman: gpioman_get_pin_num: pin EMMC_ENABLE not defined
MESS:00:00:03.269361:0: brfs: File read: 146 bytes
MESS:00:00:03.812401:0: brfs: File read: /mfs/sd/kernel8.img
MESS:00:00:03.816343:0: Loaded &#39;kernel8.img&#39; to 0x200000 size 0x8d8bd7
MESS:00:00:05.364579:0: Device tree loaded to 0x1b4de900 (size 0x8605)
MESS:00:00:05.370571:0: uart: Set PL011 baud rate to 103448.300000 Hz
MESS:00:00:05.377080:0: uart: Baud rate change done...
MESS:00:00:05.380495:0: uart: Baud rate[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd034]
</code></pre><h3 id="disabling-hdmi-probing">Disabling HDMI probing<a href="#disabling-hdmi-probing" aria-label="Heading self-link"></a></h3><p>The bootloader spends a lot of time trying to auto-detect video parameters for a possibly attached HDMI monitor.</p><p>By simply hardcoding an EDID string, we can disable any probing:</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span># don&#39;t try to read HDMI eeprom</span>
</span></span><span><span><span>hdmi_blanking</span><span>=</span><span>2</span>
</span></span><span><span><span>hdmi_ignore_edid</span><span>=</span><span>0xa5000080</span>
</span></span><span><span><span>hdmi_ignore_cec_init</span><span>=</span><span>1</span>
</span></span><span><span><span>hdmi_ignore_cec</span><span>=</span><span>1</span>
</span></span></code></pre></div><h3 id="disable-hat-poe-and-lcd-probing">Disable HAT, PoE and LCD probing<a href="#disable-hat-poe-and-lcd-probing" aria-label="Heading self-link"></a></h3><p>The boot process will additionally try to detect I2C EEPROMs on HATs, will try to detect a PoE hat (which needs a fan) and some other things.
We can safely disable those:</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span># all these options cause a wait for an I2C bus response, we don&#39;t need any of them, so let&#39;s disable them.</span>
</span></span><span><span><span>force_eeprom_read</span><span>=</span><span>0</span>
</span></span><span><span><span>disable_poe_fan</span><span>=</span><span>1</span>
</span></span><span><span><span>ignore_lcd</span><span>=</span><span>1</span>
</span></span><span><span><span>disable_touchscreen</span><span>=</span><span>1</span>
</span></span><span><span><span>disable_fw_kms_setup</span><span>=</span><span>1</span>
</span></span></code></pre></div><h3 id="disable-camera--display-probing">Disable camera &amp; display probing<a href="#disable-camera--display-probing" aria-label="Heading self-link"></a></h3><p>Probing for an attached MIPI camera or display will also take some time.
We know which camera is attached (HQ Camera, IMX477 in this case), so let‚Äôs hardcode this:</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span># no autodetection for anything (will wait for I2C answers)</span>
</span></span><span><span><span>camera_auto_detect</span><span>=</span><span>0</span>
</span></span><span><span><span>display_auto_detect</span><span>=</span><span>0</span>
</span></span><span><span>
</span></span><span><span><span># load HQ camera IMX477 sensor manually</span>
</span></span><span><span><span>dtoverlay</span><span>=</span><span>imx477</span>
</span></span></code></pre></div><h3 id="disabling-initramfs">Disabling initramfs<a href="#disabling-initramfs" aria-label="Heading self-link"></a></h3><p>The above changes brought the (self reported) boot time from 5.38s down to 4.75s.</p><p>Savings depend on the size of the initramfs of course, but this brings us down to 4.47s.</p><h3 id="tested-with-no-significant-difference">Tested, with no significant difference<a href="#tested-with-no-significant-difference" aria-label="Heading self-link"></a></h3><p>Overclocking the SD peripheral to 100 MHz is often recommended online but did not create a measurable difference in boot performance.</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span># not recommended! data corruption risk!</span>
</span></span><span><span><span>dtoverlay</span><span>=</span><span>sdtweak,overclock_50=100</span>
</span></span></code></pre></div><p>Operating the SD peripheral at such high speeds also risks data corruption (on write accesses), which is very undesirable in remote IoT devices.</p><h3 id="kernel-load">Kernel load<a href="#kernel-load" aria-label="Heading self-link"></a></h3><p>At this point, loading the kernel is one of the slowest operations:</p><pre tabindex="0"><code>MESS:00:00:03.816343:0: Loaded &#39;kernel8.img&#39; to 0x200000 size 0x8d8bd7
MESS:00:00:05.364579:0: Device tree loaded to 0x1b4de900 (size 0x8605)
</code></pre><p>Loading 9276375 Bytes takes about 1.54s -&gt; about 6 MiB/s transfer speed.</p><p>This load is being done by the GPU (!) with the internal, proprietary VideoCoreIV processor.</p><p>I haven‚Äôt found a good way to optimize this yet, so a smaller kernel is needed.</p><p>Overclocking the GPU processor core is theoretically possible with</p><div><pre tabindex="0"><code data-lang="ini"><span><span><span># Overclock GPU VideoCore IV processor (not recommended!)</span>
</span></span><span><span><span>core_freq_min</span><span>=</span><span>500</span>
</span></span><span><span><span>core_freq</span><span>=</span><span>550</span>
</span></span></code></pre></div><p>which does lead to a 20% reduction in kernel load time. The side effects (reliability, etc.) of this are unknown.</p><h3 id="buildroot--custom-kernel">Buildroot / Custom kernel<a href="#buildroot--custom-kernel" aria-label="Heading self-link"></a></h3><p>It‚Äôs time to migrate the system from Raspbian/Debian to a custom built Buildroot distro (especially to get the custom kernel).</p><p>Using buildroot 2024.02.1, a very stripped down system was configured.</p><p><img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/buildroot-menuconfig.png" alt="Buildroot ncurses menuconfig screenshot"/></p><p>The kernel was configured:</p><ul><li>without sound support</li><li>without most of the block device &amp; filesystem drivers (except SD/MMC and ext4)</li><li>without RAID support</li><li>without USB support</li><li>without HID support</li><li>without DVB support</li><li>without video &amp; framebuffer support (HDMI is disabled anyway)</li><li>without advanced networking features (tunnels, bridging, firewalling, etc.)</li><li>uncompressed (not Gzip)</li><li>modules uncompressed (not Gzip)</li></ul><p>In testing, having both the kernel and the modules uncompressed results in a net-positive energy result (even if more time is spent in the GPU loading the kernel).
Decompressing Gzip takes a lot of energy (and effectively involves another relocation step).</p><p>A security feature called KASLR was also disabled.</p><p>In our usecase, the network attack surface is very limited, so KASLR can be disabled (all application software runs as root anyway).
Mitigations for speculative execution vulnurabilies like Spectre were also disabled.</p><p><img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/buildroot-linux-menuconfig.png" alt="Linux 6.6.26 menuconfig screenshot"/></p><p>The resulting kernel is 8.5MiB (uncompressed) in size, 4.1MiB compressed as Gzip (which isn‚Äôt used here, just for comparison).</p><h3 id="final-result">Final result<a href="#final-result" aria-label="Heading self-link"></a></h3><p><img src="https://kittenlabs.de/blog/2024/09/01/extreme-pi-boot-optimization/buildroot-kernel.png" alt="Power Profiler screenshot, showing GPIO4 going low after 3.4s"/></p><p><strong>We can now boot into a Linux user space program in less than 3.5s!</strong></p><p>Total energy consumption: <strong>0.364 As * 5.0 V = 1.82 Ws</strong></p><h3 id="links">Links<a href="#links" aria-label="Heading self-link"></a></h3><ul><li><a href="https://github.com/Manawyrm/SolarCamPi-Buildroot/blob/v2/buildroot/board/raspberrypi0w/config.txt" target="_blank">SolarCamPi config.txt</a>: Complete config.txt</li><li><a href="https://github.com/Manawyrm/SolarCamPi-Buildroot/blob/v2/buildroot/configs/linux_solarcampi_defconfig" target="_blank">SolarCamPi Linux kernel defconfig</a>: Stripped down kernel config</li><li><a href="https://github.com/Manawyrm/SolarCamPi-Buildroot/tree/v2" target="_blank">SolarCamPi-Buildroot (v2 branch)</a>: Full Buildroot tree (work-in-progress!)</li></ul></div></div>
  </body>
</html>
