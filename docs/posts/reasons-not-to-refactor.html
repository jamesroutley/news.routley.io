<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://thoughtbot.com/blog/reasons-not-to-refactor">Original</a>
    <h1>Reasons Not to Refactor</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Refactoring is a wonderful practice for making code and change easier to manage. That said, here are some reasons why we should not proceed with a refactor.</p>
<h2 id="1-the-change-is-not-really-a-refactor">
  <a href="#1-the-change-is-not-really-a-refactor">
    1. The change is not really a refactor
  </a>
</h2>

<p>Many people use the word “refactoring” incorrectly. If we’re embarking on <a href="https://thoughtbot.com/blog/what-happens-when-we-misuse-refactoring-in-conversation">a change that is not really refactoring</a> (for example looking at a bug or an adjustment after a third party change), we can’t fix it with refactoring.</p>

<p><strong>What to do instead:</strong> we need to think and talk about it differently from refactoring. We can stop and consider how the system will change (from what to what) and raise it with teammates to discuss why it matters, what action to take, and when.</p>
<h2 id="2-there-are-examples-that-don39t-fit-our-planned-refactor">
  <a href="#2-there-are-examples-that-don39t-fit-our-planned-refactor">
    2. There are examples that don’t fit our planned refactor
  </a>
</h2>

<p>We often reach a point during refactoring where it seems like there is an easy improvement that applies to almost all cases. It’s usually better not to impose additional abstraction if it only matches “almost” all cases.</p>

<p>Here’s an example inspired by the <a href="https://github.com/thoughtbot/noisy-animals-kata">Noisy Animals kata</a>. Consider this code:</p>
<div><pre><code>   <span>def</span> <span>make_noise</span><span>(</span><span>loud: </span><span>true</span><span>)</span>
    <span>noise</span> <span>=</span> <span>{</span>
      <span>&#39;leopard&#39;</span> <span>=&gt;</span> <span>{</span> <span>quiet: </span><span>&#39;growl&#39;</span><span>,</span> <span>loud: </span><span>[</span><span>&#39;growl&#39;</span><span>,</span> <span>&#39;growl&#39;</span><span>]</span> <span>},</span>
      <span>&#39;owl&#39;</span> <span>=&gt;</span> <span>{</span> <span>quiet: </span><span>&#39;hoot&#39;</span><span>,</span> <span>loud: </span><span>[</span><span>&#39;hoot&#39;</span><span>,</span> <span>&#39;hoot&#39;</span><span>]</span> <span>},</span>
      <span>&#39;eagle&#39;</span> <span>=&gt;</span> <span>{</span> <span>quiet: </span><span>&#39;caw&#39;</span><span>,</span> <span>loud: </span><span>[</span><span>&#39;caw&#39;</span><span>,</span> <span>&#39;caw&#39;</span><span>]</span> <span>},</span>
      <span>&#39;mouse&#39;</span> <span>=&gt;</span> <span>{</span> <span>quiet: </span><span>&#34;</span><span>\n</span><span>&#34;</span><span>,</span> <span>loud: </span><span>[</span><span>&#34;</span><span>\n</span><span>&#34;</span><span>]</span> <span>},</span>
      <span>&#39;snake&#39;</span> <span>=&gt;</span> <span>{</span> <span>quiet: </span><span>&#39;slither&#39;</span><span>,</span> <span>loud: </span><span>[</span><span>&#39;hiss&#39;</span><span>]</span> <span>},</span>
    <span>}.</span><span>fetch</span><span>(</span><span>species</span><span>)</span>
    <span>puts</span> <span>noise</span><span>.</span><span>fetch</span><span>(</span><span>loud</span> <span>?</span> <span>:loud</span> <span>:</span> <span>:quiet</span><span>)</span>
  <span>end</span>

</code></pre></div>
<p>Those repeated strings on some lines might be irritating, but two lines don’t share the repetition. We’re better off leaving the code as is than trying something like this:</p>
<div><pre><code>  <span>def</span> <span>make_noise</span><span>(</span><span>loud: </span><span>true</span><span>)</span>
    <span>noise</span> <span>=</span> <span>{</span>
      <span>&#39;leopard&#39;</span> <span>=&gt;</span> <span>&#39;growl&#39;</span>
      <span>&#39;owl&#39;</span> <span>=&gt;</span> <span>&#39;hoot&#39;</span><span>,</span>
      <span>&#39;eagle&#39;</span> <span>=&gt;</span> <span>&#39;caw&#39;</span><span>,</span>
      <span>&#39;mouse&#39;</span> <span>=&gt;</span> <span>&#34;</span><span>\n</span><span>&#34;</span><span>,</span>
      <span>&#39;snake&#39;</span> <span>=&gt;</span> <span>&#39;slither&#39;</span>
    <span>}[</span><span>species</span><span>]</span>

    <span>if</span> <span>loud</span> <span>&amp;&amp;</span> <span>species</span> <span>==</span> <span>&#39;snake&#39;</span>
      <span>puts</span> <span>&#39;hiss&#39;</span>
    <span>elsif</span> <span>loud</span> <span>&amp;&amp;</span> <span>species</span> <span>==</span> <span>&#39;mouse&#39;</span>
      <span>puts</span> <span>&#34;</span><span>\n</span><span>&#34;</span>
    <span>elsif</span> <span>loud</span>
      <span>puts</span> <span>noise</span><span>,</span> <span>noise</span>
    <span>else</span>
      <span>puts</span> <span>noise</span>
    <span>end</span>
  <span>end</span>
</code></pre></div>
<p>Here we’ve moved from a single ternary conditional to an if statement with four branches. Knowledge of how each species behaves was contained in a single line but is now split up over the entire method. The method is also almost double its original length.</p>

<p><strong>What to do instead:</strong> perhaps there is a different code smell we can investigate, or maybe we need to stop where we are until a new requirement demonstrates the need to change.</p>
<h2 id="3-another-refactor-is-already-in-progress">
  <a href="#3-another-refactor-is-already-in-progress">
    3. Another refactor is already in progress
  </a>
</h2>

<p>We’re often confronted with more than one code smell at a time. Perhaps a piece of code seems like it should be extracted to a method, and inside that code is an unnecessary local variable. Create the method and replace all occurrences of the original code with the method call before you remove the local variable. Alternatively, remove the variable before you extract the code into a method. After you finish one, save, run the tests, and commit, all before you move on to the next.</p>

<p>Whatever you do, don’t try to do both at the same time. Doing them separately may seem like a hassle, but the risk of a typo and the benefit of knowing that you started each change from the safety of green tests are worth much more than the hassle (and there are techniques you can learn to reduce the hassle).</p>

<p><strong>What to do instead:</strong> live with the code that isn’t ideal long enough to see the results of your current refactor. The current refactor may help you realise something new about the code that you would have missed if you tried to do both at the same time.</p>
<h2 id="4-the-code-is-unlikely-to-change">
  <a href="#4-the-code-is-unlikely-to-change">
    4. The code is unlikely to change
  </a>
</h2>

<p>There’s no benefit to improving code that never changes, even if it is highly complex. This is the basis of Michael Feather’s <a href="https://www.stickyminds.com/article/getting-empirical-about-refactoring">process for identifying good refactoring targets</a> (spoiler: code that is complex and changes often is the best place to look).</p>

<p>We should be aware in this case that it is really easy to apply wishful thinking: we imagine that the code that everyone is scared of will never change, simply because we cannot think of how to improve it.</p>

<p><strong>What to do instead:</strong> find something else that is more likely to change to refactor, or pause refactoring and move on to the next requirement.</p>
<h2 id="5-there-are-no-tests">
  <a href="#5-there-are-no-tests">
    5. There are no tests
  </a>
</h2>

<p>If we’re changing tests (or we have none), we have no guarantee that behaviour is unchanged. If we are possibly changing behaviour, we are not refactoring.</p>

<p>Here’s a delightful extract from <a href="https://app.thestorygraph.com/books/4795b19b-f913-44c2-a44b-73af56931c3d">Refactoring Javascript</a>:</p>

<blockquote>
<p>HOW CONVERSATIONS ABOUT REFACTORING SHOULD GO UNTIL TESTS ARE WRITTEN</p>

<p>“I refactored login to take email address and username.”</p>

<p>“No, you didn’t.”</p>

<p>“I’m refactoring the code to ____”</p>

<p>“No, you aren’t.”</p>

<p>“Before we can add tests, we need to refactor.”</p>

<p>“No.”</p>

<p>“Refactoring th–”</p>

<p>“No.”</p>

<p>“Refa–”</p>

<p>“No.”</p>
</blockquote>

<p><strong>What to do instead:</strong> Instead of “refactoring” without tests, we can start by writing some tests! <a href="https://thoughtbot.com/blog/unlock-the-value-of-tests-in-understanding-your-codebase">Writing new tests will help us learn about the code</a>. After that, we can come back to refactoring.</p>
<h2 id="6-refactoring-reveals-more-risk-than-imagined">
  <a href="#6-refactoring-reveals-more-risk-than-imagined">
    6. Refactoring reveals more risk than imagined
  </a>
</h2>

<p>Sometimes we tidy the code to a certain point and realise that there is something we don’t understand. That’s ok, we can stop where we are now. If we’ve been working in small low-risk steps the way that the refactoring community encourages, the tidying we did already was either valuable and should be kept, or is really safe and easy to revert.</p>

<p>From <a href="https://martinfowler.com/books/refactoring.html">Martin Fowler’s description of the Refactoring book</a>: “its essence is a series of small behavior-preserving transformations… You also avoid having the system broken while you are carrying out the restructuring - which allows you to gradually refactor a system over an extended period of time.”</p>

<p><strong>What to do instead:</strong> Simply pause where we are and continue another time when we know more. That “more” may be something about our product that reveals that some code is overly complex or unnecessary. It might also be a new requirement that shows us a new way that the code is likely to change in future.</p>


<p>We’ve discussed several reasons not to refactor. Ironically, we might end up doing more refactoring as a result, because we won’t be trying to use refactoring to solve unsuitable problems. The refactoring we do will be faster, have a bigger impact, and be more rewarding.</p>

    </div></div>
  </body>
</html>
