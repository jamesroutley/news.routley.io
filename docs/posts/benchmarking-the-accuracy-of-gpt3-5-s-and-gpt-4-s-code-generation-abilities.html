<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/E-xyza/Exonerate/blob/master/bench/reports/gpt-bench.md">Original</a>
    <h1>Benchmarking the accuracy of GPT3.5&#39;s and GPT-4&#39;s code generation abilities</h1>
    
    <div id="readability-page-1" class="page"><div>

    <div data-target="readme-toc.content">
      
  


        <div id="readme">
    <article itemprop="text">

<p dir="auto">by <a href="https://twitter.com/dnautics" rel="nofollow">@dnautics</a></p>
<blockquote>
<p dir="auto">This md file can be run as a livebook found at the following location:
The full chart has interactive tooltips not available in the &#34;non-live&#34;
markdown form.</p>
<p dir="auto"><a href="https://github.com/E-xyza/Exonerate/blob/master/bench/gpt-bench.livemd">https://github.com/E-xyza/Exonerate/blob/master/bench/gpt-bench.livemd</a></p>
<p dir="auto">For more information on livebook see: <a href="https://livebook.dev/" rel="nofollow">https://livebook.dev/</a></p>
</blockquote>
<div dir="auto" data-snippet-clipboard-copy-content="Mix.install([
  {:jason, &#34;&gt; 0.0.0&#34;},
  {:vega_lite, &#34;~&gt; 0.1.7&#34;},
  {:kino_vega_lite, &#34;~&gt; 0.1.8&#34;},
  {:benchee, &#34;~&gt; 1.1.0&#34;},
  {:exonerate, &#34;~&gt; 0.3.0&#34;}
])

~w(test.ex schema.ex)
|&gt; Enum.each(fn file -&gt;
  __DIR__
  |&gt; Path.join(&#34;benchmark/#{file}&#34;)
  |&gt; Code.compile_file()
end)

alias Benchmark.Schema
alias Benchmark.Test"><pre><span>Mix</span><span>.</span><span>install</span><span>(</span><span>[</span>
  <span>{</span><span>:jason</span><span>,</span> <span>&#34;&gt; 0.0.0&#34;</span><span>}</span><span>,</span>
  <span>{</span><span>:vega_lite</span><span>,</span> <span>&#34;~&gt; 0.1.7&#34;</span><span>}</span><span>,</span>
  <span>{</span><span>:kino_vega_lite</span><span>,</span> <span>&#34;~&gt; 0.1.8&#34;</span><span>}</span><span>,</span>
  <span>{</span><span>:benchee</span><span>,</span> <span>&#34;~&gt; 1.1.0&#34;</span><span>}</span><span>,</span>
  <span>{</span><span>:exonerate</span><span>,</span> <span>&#34;~&gt; 0.3.0&#34;</span><span>}</span>
<span>]</span><span>)</span>

<span>~w<span>(</span>test.ex schema.ex<span>)</span></span>
<span>|&gt;</span> <span>Enum</span><span>.</span><span>each</span><span>(</span><span>fn</span> <span>file</span> <span>-&gt;</span>
  <span>__DIR__</span>
  <span>|&gt;</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>&#34;benchmark/<span><span>#{</span><span>file</span><span>}</span></span>&#34;</span><span>)</span>
  <span>|&gt;</span> <span>Code</span><span>.</span><span>compile_file</span><span>(</span><span>)</span>
<span>end</span><span>)</span>

<span>alias</span> <span>Benchmark.Schema</span>
<span>alias</span> <span>Benchmark.Test</span></pre></div>
<h2 dir="auto"><a id="user-content-motivation" aria-hidden="true" href="#motivation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Motivation</h2>
<p dir="auto">This entire month (March, 2023), I had been spending a ton of effort completing a major
refactor of my json-schema library for Elixir.  As I was toiling away handcrafting macros to
generate optimized, bespoke, yet generalizable code, GPT-4 rolled onto the scene and awed all of
us in the industry with its almost magical ability to craft code out of whole cloth.  I felt a
little bit like John Henry battling against the steam drill<sup><a href="#user-content-fn-1-fb6bad95db2b19e01310f58281d7e2d7" id="user-content-fnref-1-fb6bad95db2b19e01310f58281d7e2d7" data-footnote-ref="" aria-describedby="footnote-label">1</a></sup>, only to win but expire from his exertion.</p>
<p dir="auto"><a target="_blank" rel="noopener noreferrer nofollow" href="https://camo.githubusercontent.com/f334d53d8934c9851346ec7619360566c6a54002ab6b290471dace1f58a1c662/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f302f30302f4a6f686e5f48656e72792d32373532372e6a7067"><img src="https://camo.githubusercontent.com/f334d53d8934c9851346ec7619360566c6a54002ab6b290471dace1f58a1c662/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f302f30302f4a6f686e5f48656e72792d32373532372e6a7067" width="50%" data-canonical-src="https://upload.wikimedia.org/wikipedia/commons/0/00/John_Henry-27527.jpg"/></a></p>
<p dir="auto">With the advent of LLM-based code generation, we are seeing programmers leveraging the power of
LLMs, such as GPT, to generate difficult or fussy code and rapidly create code.  Is this a good
idea?</p>
<p dir="auto">Note that compared to a schema compiler, LLM-generated code may be able to see some nice
optimizations for simple schemas.  This is roughly equivalent to a human claiming to be able to
write better assembly language than a low-level language compiler.  In some cases, the human
may access extra knowledge about the structure of the data being handled, and thus the claim
may be justified.</p>
<p dir="auto">On the other hand, JSONSchema validations are typically used at the edge of a system,
especially when interfacing with a 3rd party system (or human) with QC that is not under the
control of the publisher of the JSONSchema.  In these situations, strict adherence to JSONSchema
is desirable.  An early 422 rejection with a reason explaining where the data are misshapen is
generally more desirable than a typically more opaque 500 rejection because the data do not
match the expectations of the internal system.</p>
<p dir="auto">With these considerations, I decided to test just how good GPT is at writing JSONSchemas, and
answer the question <strong>&#34;Should I use GPT to autogenerate schema validations?&#34;</strong></p>
<h2 dir="auto"><a id="user-content-methodology" aria-hidden="true" href="#methodology"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Methodology</h2>
<p dir="auto">To test this question, the following prompt was generated against ~&gt; 250 JSONSchemas provided
as a part of the JSONSchema engine validation suite (<a href="https://github.com/json-schema-org/JSON-Schema-Test-Suite">https://github.com/json-schema-org/JSON-Schema-Test-Suite</a>).</p>
<div data-snippet-clipboard-copy-content="Hi, ChatGPT! I would love your help writing an Elixir public function `validate/1`, which takes
one parameter, which is a decoded JSON value.  The function should return :ok if the following
jsonschema validates, and an error if it does not:

```
#{schema}
```

The function should NOT store or parse the schema, it should translate the instructions in the schema directly as
elixir code.  For example:

```
{&#34;type&#34;: &#34;object&#34;}
```

should emit the following code:

```
def validate(object) when is_map(object), do: :ok
def validate(_), do: :error
```

DO NOT STORE THE SCHEMA or EXAMINE THE SCHEMA anywhere in the code.  There should not be any
`schema` variables anywhere in the code.  please name the module with the atom `:&#34;#{group}-#{title}&#34;

Thank you!"><pre><code>Hi, ChatGPT! I would love your help writing an Elixir public function `validate/1`, which takes
one parameter, which is a decoded JSON value.  The function should return :ok if the following
jsonschema validates, and an error if it does not:

```
#{schema}
```

The function should NOT store or parse the schema, it should translate the instructions in the schema directly as
elixir code.  For example:

```
{&#34;type&#34;: &#34;object&#34;}
```

should emit the following code:

```
def validate(object) when is_map(object), do: :ok
def validate(_), do: :error
```

DO NOT STORE THE SCHEMA or EXAMINE THE SCHEMA anywhere in the code.  There should not be any
`schema` variables anywhere in the code.  please name the module with the atom `:&#34;#{group}-#{title}&#34;

Thank you!
</code></pre></div>
<p dir="auto">From the response, the code inside of the elixir fenced block was extracted and saved into a .exs
file for processing as below in this live notebook.  GPT-3.5 was not capable of correctly wrapping
the elixir module, so it required an automated result curation step; GPT-4 code was able to be used
as-is.  Some further manual curation was performed (see Systematic Issues.).  The code generated by
GPT is available in this repository.</p>
<h2 dir="auto"><a id="user-content-limitations" aria-hidden="true" href="#limitations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Limitations</h2>
<p dir="auto">The biggest limitation of this approach is the nature of the examples provided in the JSONSchema
validation suite.  These validations exist to help JSONSchema implementers understand &#34;gotchas&#34; in
the JSONSchema standard.  As such, they don&#39;t feature &#34;real-world&#34; payloads and their complexity is
mostly limited to testing a single JSONSchema filter, in some cases, a handful of JSONSchema filters,
where the filters have a long-distance interaction as part of the specification.</p>
<p dir="auto">As a result, the optimizations that GPT performs may not really be scalable to real-world cases,
and it&#39;s not clear if GPT will have sufficient attention to handle the more complex cases.</p>
<p dir="auto">Future studies, possibly involving schema generation and a property testing approach, can yield a
more comprehensive understanding of GPT code generation</p>
<p dir="auto">Note that the source data for GPT is more heavily biased towards imperative programming languages,
so deficiencies in the code may also be a result of a deficiency in the LLM&#39;s understanding of Elixir.</p>
<h2 dir="auto"><a id="user-content-benchmarking-accuracy" aria-hidden="true" href="#benchmarking-accuracy"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Benchmarking Accuracy</h2>
<p dir="auto">We&#39;re going to marshal our results into the following struct, which carries information for
visualization:</p>
<div dir="auto" data-snippet-clipboard-copy-content="defmodule Benchmark.Result do
  @enforce_keys [:schema, :type]
  defstruct @enforce_keys ++ [fail: [], pass: [], pct: 0.0, exception: nil]
end"><pre><span>defmodule</span> <span>Benchmark.Result</span> <span>do</span>
  <span>@</span><span>enforce_keys</span> <span>[</span><span>:schema</span><span>,</span> <span>:type</span><span>]</span>
  <span>defstruct</span> <span>@</span><span>enforce_keys</span> <span>++</span> <span>[</span><span>fail: </span><span>[</span><span>]</span><span>,</span> <span>pass: </span><span>[</span><span>]</span><span>,</span> <span>pct: </span><span>0.0</span><span>,</span> <span>exception: </span><span>nil</span><span>]</span>
<span>end</span></pre></div>

<p dir="auto">The following code is used to profile our GPT-generated code.  The directory structure is
expected to be that of the <a href="https://github.com/E-xyza/exonerate">https://github.com/E-xyza/exonerate</a> repository, and this notebook is
expected to be in the ./bench/, otherwise the relative directory paths won&#39;t work.</p>
<p dir="auto">Note that the Schema and Test modules should be in <code>./bench/benchmark/schema.ex</code> and
<code>./bench/benchmark/test.ex</code>, respectively, these are loaded in the dependencies section.</p>
<div dir="auto" data-snippet-clipboard-copy-content="defmodule Benchmark do
  alias Benchmark.Result

  @omit ~w(anchor.json refRemote.json dynamicRef.json)

  @test_directory Path.join(__DIR__, &#34;../test/_draft2020-12&#34;)
  def get_test_content do
    Schema.stream_from_directory(@test_directory, omit: @omit)
  end

  def run(gpt, test_content) do
    code_directory = Path.join(__DIR__, gpt)

    test_content
    |&gt; Stream.map(&amp;compile_schema(&amp;1, code_directory))
    |&gt; Stream.map(&amp;evaluate_test/1)
    |&gt; Enum.to_list()
  end

  defp escape(string), do: String.replace(string, &#34;/&#34;, &#34;-&#34;)

  defp compile_schema(schema, code_directory) do
    filename = &#34;#{schema.group}-#{escape(schema.description)}.exs&#34;
    code_path = Path.join(code_directory, filename)

    module =
      try do
        {{:module, module, _, _}, _} = Code.eval_file(code_path)
        module
      rescue
        error -&gt; error
      end

    {schema, module}
  end

  defp evaluate_test({schema, exception}) when is_exception(exception) do
    %Result{schema: schema, type: :compile, exception: exception}
  end

  defp evaluate_test({schema, module}) do
    # check to make sure module exports the validate function.
    if function_exported?(module, :validate, 1) do
      increment = 100.0 / length(schema.tests)

      schema.tests
      |&gt; Enum.reduce(%Result{schema: schema, type: :ok}, fn test, result -&gt;
        expected = if test.valid, do: :ok, else: :error

        try do
          if module.validate(test.data) === expected do
            %{result | pct: result.pct + increment, pass: [test.description | result.pass]}
          else
            %{result | type: :partial, fail: [{test.description, :incorrect} | result.fail]}
          end
        rescue
          e -&gt;
            %{result | type: :partial, fail: [{test.description, e} | result.fail]}
        end
      end)
      |&gt; set_total_failure
    else
      %Result{schema: schema, type: :compile, exception: :not_generated}
    end
  end

  # if absolutely none of the answers is correct, then set the type to :failure
  defp set_total_failure(result = %Result{pct: 0.0}), do: %{result | type: :failure}
  defp set_total_failure(result), do: result
end

tests = Benchmark.get_test_content()

gpt_3_results = Benchmark.run(&#34;gpt-3.5&#34;, tests)
gpt_4_results = Benchmark.run(&#34;gpt-4&#34;, tests)

:ok"><pre><span>defmodule</span> <span>Benchmark</span> <span>do</span>
  <span>alias</span> <span>Benchmark.Result</span>

  <span>@</span><span>omit</span> <span>~w<span>(</span>anchor.json refRemote.json dynamicRef.json<span>)</span></span>

  <span>@</span><span>test_directory</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>__DIR__</span><span>,</span> <span>&#34;../test/_draft2020-12&#34;</span><span>)</span>
  <span>def</span> <span>get_test_content</span> <span>do</span>
    <span>Schema</span><span>.</span><span>stream_from_directory</span><span>(</span><span>@</span><span>test_directory</span><span>,</span> <span>omit: </span><span>@</span><span>omit</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>run</span><span>(</span><span>gpt</span><span>,</span> <span>test_content</span><span>)</span> <span>do</span>
    <span>code_directory</span> <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>__DIR__</span><span>,</span> <span>gpt</span><span>)</span>

    <span>test_content</span>
    <span>|&gt;</span> <span>Stream</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>compile_schema</span><span>(</span><span>&amp;</span><span>1</span><span>,</span> <span>code_directory</span><span>)</span><span>)</span>
    <span>|&gt;</span> <span>Stream</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>evaluate_test</span><span>/</span><span>1</span><span>)</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>to_list</span><span>(</span><span>)</span>
  <span>end</span>

  <span>defp</span> <span>escape</span><span>(</span><span>string</span><span>)</span><span>,</span> <span>do: </span><span>String</span><span>.</span><span>replace</span><span>(</span><span>string</span><span>,</span> <span>&#34;/&#34;</span><span>,</span> <span>&#34;-&#34;</span><span>)</span>

  <span>defp</span> <span>compile_schema</span><span>(</span><span>schema</span><span>,</span> <span>code_directory</span><span>)</span> <span>do</span>
    <span>filename</span> <span>=</span> <span>&#34;<span><span>#{</span><span>schema</span><span>.</span><span>group</span><span>}</span></span>-<span><span>#{</span><span>escape</span><span>(</span><span>schema</span><span>.</span><span>description</span><span>)</span><span>}</span></span>.exs&#34;</span>
    <span>code_path</span> <span>=</span> <span>Path</span><span>.</span><span>join</span><span>(</span><span>code_directory</span><span>,</span> <span>filename</span><span>)</span>

    <span>module</span> <span>=</span>
      <span>try</span> <span>do</span>
        <span>{</span><span>{</span><span>:module</span><span>,</span> <span>module</span><span>,</span> <span>_</span><span>,</span> <span>_</span><span>}</span><span>,</span> <span>_</span><span>}</span> <span>=</span> <span>Code</span><span>.</span><span>eval_file</span><span>(</span><span>code_path</span><span>)</span>
        <span>module</span>
      <span>rescue</span>
        <span>error</span> <span>-&gt;</span> <span>error</span>
      <span>end</span>

    <span>{</span><span>schema</span><span>,</span> <span>module</span><span>}</span>
  <span>end</span>

  <span>defp</span> <span>evaluate_test</span><span>(</span><span>{</span><span>schema</span><span>,</span> <span>exception</span><span>}</span><span>)</span> <span>when</span> <span>is_exception</span><span>(</span><span>exception</span><span>)</span> <span>do</span>
    <span>%</span><span>Result</span><span>{</span><span>schema: </span><span>schema</span><span>,</span> <span>type: </span><span>:compile</span><span>,</span> <span>exception: </span><span>exception</span><span>}</span>
  <span>end</span>

  <span>defp</span> <span>evaluate_test</span><span>(</span><span>{</span><span>schema</span><span>,</span> <span>module</span><span>}</span><span>)</span> <span>do</span>
    <span># check to make sure module exports the validate function.</span>
    <span>if</span> <span>function_exported?</span><span>(</span><span>module</span><span>,</span> <span>:validate</span><span>,</span> <span>1</span><span>)</span> <span>do</span>
      <span>increment</span> <span>=</span> <span>100.0</span> <span>/</span> <span>length</span><span>(</span><span>schema</span><span>.</span><span>tests</span><span>)</span>

      <span>schema</span><span>.</span><span>tests</span>
      <span>|&gt;</span> <span>Enum</span><span>.</span><span>reduce</span><span>(</span><span>%</span><span>Result</span><span>{</span><span>schema: </span><span>schema</span><span>,</span> <span>type: </span><span>:ok</span><span>}</span><span>,</span> <span>fn</span> <span>test</span><span>,</span> <span>result</span> <span>-&gt;</span>
        <span>expected</span> <span>=</span> <span>if</span> <span>test</span><span>.</span><span>valid</span><span>,</span> <span>do: </span><span>:ok</span><span>,</span> <span>else: </span><span>:error</span>

        <span>try</span> <span>do</span>
          <span>if</span> <span>module</span><span>.</span><span>validate</span><span>(</span><span>test</span><span>.</span><span>data</span><span>)</span> <span>===</span> <span>expected</span> <span>do</span>
            <span>%</span><span>{</span><span>result</span> <span>|</span> <span>pct: </span><span>result</span><span>.</span><span>pct</span> <span>+</span> <span>increment</span><span>,</span> <span>pass: </span><span>[</span><span>test</span><span>.</span><span>description</span> <span>|</span> <span>result</span><span>.</span><span>pass</span><span>]</span><span>}</span>
          <span>else</span>
            <span>%</span><span>{</span><span>result</span> <span>|</span> <span>type: </span><span>:partial</span><span>,</span> <span>fail: </span><span>[</span><span>{</span><span>test</span><span>.</span><span>description</span><span>,</span> <span>:incorrect</span><span>}</span> <span>|</span> <span>result</span><span>.</span><span>fail</span><span>]</span><span>}</span>
          <span>end</span>
        <span>rescue</span>
          <span>e</span> <span>-&gt;</span>
            <span>%</span><span>{</span><span>result</span> <span>|</span> <span>type: </span><span>:partial</span><span>,</span> <span>fail: </span><span>[</span><span>{</span><span>test</span><span>.</span><span>description</span><span>,</span> <span>e</span><span>}</span> <span>|</span> <span>result</span><span>.</span><span>fail</span><span>]</span><span>}</span>
        <span>end</span>
      <span>end</span><span>)</span>
      <span>|&gt;</span> <span>set_total_failure</span>
    <span>else</span>
      <span>%</span><span>Result</span><span>{</span><span>schema: </span><span>schema</span><span>,</span> <span>type: </span><span>:compile</span><span>,</span> <span>exception: </span><span>:not_generated</span><span>}</span>
    <span>end</span>
  <span>end</span>

  <span># if absolutely none of the answers is correct, then set the type to :failure</span>
  <span>defp</span> <span>set_total_failure</span><span>(</span><span>result</span> <span>=</span> <span>%</span><span>Result</span><span>{</span><span>pct: </span><span>0.0</span><span>}</span><span>)</span><span>,</span> <span>do: </span><span>%</span><span>{</span><span>result</span> <span>|</span> <span>type: </span><span>:failure</span><span>}</span>
  <span>defp</span> <span>set_total_failure</span><span>(</span><span>result</span><span>)</span><span>,</span> <span>do: </span><span>result</span>
<span>end</span>

<span>tests</span> <span>=</span> <span>Benchmark</span><span>.</span><span>get_test_content</span><span>(</span><span>)</span>

<span>gpt_3_results</span> <span>=</span> <span>Benchmark</span><span>.</span><span>run</span><span>(</span><span>&#34;gpt-3.5&#34;</span><span>,</span> <span>tests</span><span>)</span>
<span>gpt_4_results</span> <span>=</span> <span>Benchmark</span><span>.</span><span>run</span><span>(</span><span>&#34;gpt-4&#34;</span><span>,</span> <span>tests</span><span>)</span>

<span>:ok</span></pre></div>
<h2 dir="auto"><a id="user-content-systematic-issues" aria-hidden="true" href="#systematic-issues"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Systematic Issues</h2>
<p dir="auto">Before we take a look at the results, after generating and compiling the code, I noticed a few
systematic issues that needed to be addressed before performing the profiling.  I&#39;ll talk about
individual interesting cases after the full profile.</p>
<h3 dir="auto"><a id="user-content-atoms-vs-strings" aria-hidden="true" href="#atoms-vs-strings"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Atoms vs. Strings</h3>
<p dir="auto">Both GPT-3.5 and GPT-4 sometimes use atoms in their code instead of strings.  This is
understandable, since various Elixir JSON implementations may use atoms instead of strings
in the internal representation of JSON, especially for object keys.  However, validation of
JSON is most likely going to operate on string keys, since atom keys for input is discouraged
due to security concerns.  Here is some example code that GPT-4 generated:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;oneOf-oneOf complex types&#34; do
  def validate(object) when is_map(object) do
    case Enum.filter([:bar, :foo], &amp;Map.has_key?(object, &amp;1)) do
      [:bar] -&gt;
        case Map.fetch(object, :bar) do
          {:ok, value} when is_integer(value) -&gt; :ok
          _ -&gt; :error
        end
      [:foo] -&gt;
        case Map.fetch(object, :foo) do
          {:ok, value} when is_binary(value) -&gt; :ok
          _ -&gt; :error
        end
      _ -&gt; :error
    end
  end

  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;oneOf-oneOf complex types&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>object</span><span>)</span> <span>when</span> <span>is_map</span><span>(</span><span>object</span><span>)</span> <span>do</span>
    <span>case</span> <span>Enum</span><span>.</span><span>filter</span><span>(</span><span>[</span><span>:bar</span><span>,</span> <span>:foo</span><span>]</span><span>,</span> <span>&amp;</span><span>Map</span><span>.</span><span>has_key?</span><span>(</span><span>object</span><span>,</span> <span>&amp;</span><span>1</span><span>)</span><span>)</span> <span>do</span>
      <span>[</span><span>:bar</span><span>]</span> <span>-&gt;</span>
        <span>case</span> <span>Map</span><span>.</span><span>fetch</span><span>(</span><span>object</span><span>,</span> <span>:bar</span><span>)</span> <span>do</span>
          <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>when</span> <span>is_integer</span><span>(</span><span>value</span><span>)</span> <span>-&gt;</span> <span>:ok</span>
          <span>_</span> <span>-&gt;</span> <span>:error</span>
        <span>end</span>
      <span>[</span><span>:foo</span><span>]</span> <span>-&gt;</span>
        <span>case</span> <span>Map</span><span>.</span><span>fetch</span><span>(</span><span>object</span><span>,</span> <span>:foo</span><span>)</span> <span>do</span>
          <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>when</span> <span>is_binary</span><span>(</span><span>value</span><span>)</span> <span>-&gt;</span> <span>:ok</span>
          <span>_</span> <span>-&gt;</span> <span>:error</span>
        <span>end</span>
      <span>_</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">Code featuring atom keys in maps was manually converted prior to benchmarking accuracy, for
example, the above code is converted to:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;oneOf-oneOf complex types&#34; do
  def validate(object) when is_map(object) do
    case Enum.filter([&#34;bar&#34;, &#34;foo&#34;], &amp;Map.has_key?(object, &amp;1)) do
      [&#34;bar&#34;] -&gt;
        case Map.fetch(object, &#34;bar&#34;) do
          {:ok, value} when is_integer(value) -&gt; :ok
          _ -&gt; :error
        end
      [&#34;foo&#34;] -&gt;
        case Map.fetch(object, &#34;foo&#34;) do
          {:ok, value} when is_binary(value) -&gt; :ok
          _ -&gt; :error
        end
      _ -&gt; :error
    end
  end

  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;oneOf-oneOf complex types&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>object</span><span>)</span> <span>when</span> <span>is_map</span><span>(</span><span>object</span><span>)</span> <span>do</span>
    <span>case</span> <span>Enum</span><span>.</span><span>filter</span><span>(</span><span>[</span><span>&#34;bar&#34;</span><span>,</span> <span>&#34;foo&#34;</span><span>]</span><span>,</span> <span>&amp;</span><span>Map</span><span>.</span><span>has_key?</span><span>(</span><span>object</span><span>,</span> <span>&amp;</span><span>1</span><span>)</span><span>)</span> <span>do</span>
      <span>[</span><span>&#34;bar&#34;</span><span>]</span> <span>-&gt;</span>
        <span>case</span> <span>Map</span><span>.</span><span>fetch</span><span>(</span><span>object</span><span>,</span> <span>&#34;bar&#34;</span><span>)</span> <span>do</span>
          <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>when</span> <span>is_integer</span><span>(</span><span>value</span><span>)</span> <span>-&gt;</span> <span>:ok</span>
          <span>_</span> <span>-&gt;</span> <span>:error</span>
        <span>end</span>
      <span>[</span><span>&#34;foo&#34;</span><span>]</span> <span>-&gt;</span>
        <span>case</span> <span>Map</span><span>.</span><span>fetch</span><span>(</span><span>object</span><span>,</span> <span>&#34;foo&#34;</span><span>)</span> <span>do</span>
          <span>{</span><span>:ok</span><span>,</span> <span>value</span><span>}</span> <span>when</span> <span>is_binary</span><span>(</span><span>value</span><span>)</span> <span>-&gt;</span> <span>:ok</span>
          <span>_</span> <span>-&gt;</span> <span>:error</span>
        <span>end</span>
      <span>_</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<h3 dir="auto"><a id="user-content-string-length-is-utf-8-grapheme-count" aria-hidden="true" href="#string-length-is-utf-8-grapheme-count"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>String length is UTF-8 grapheme count</h3>
<p dir="auto">Neither GPT understood that the JSONSchema string length count counts UTF-8 graphemes.  As an
example, GPT-4 produced the following code:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;maxLength-maxLength validation&#34; do
  def validate(string) when is_binary(string) do
    if byte_size(string) &lt;= 2, do: :ok, else: :error
  end

  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;maxLength-maxLength validation&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>string</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>if</span> <span>byte_size</span><span>(</span><span>string</span><span>)</span> <span>&lt;=</span> <span>2</span><span>,</span> <span>do: </span><span>:ok</span><span>,</span> <span>else: </span><span>:error</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">Instead, the if statement should have been:</p>

<div dir="auto" data-snippet-clipboard-copy-content="if String.length(string) &lt;= 2, do: :ok, else: :error"><pre><span>if</span> <span>String</span><span>.</span><span>length</span><span>(</span><span>string</span><span>)</span> <span>&lt;=</span> <span>2</span><span>,</span> <span>do: </span><span>:ok</span><span>,</span> <span>else: </span><span>:error</span></pre></div>
<h3 dir="auto"><a id="user-content-integers-need-to-match-floats" aria-hidden="true" href="#integers-need-to-match-floats"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Integers need to match Floats</h3>
<p dir="auto">The JSONSchema standard requires that constant integers, enumerated integers, and floating
point numbers must match as integers.  In elixir, while the <code>==</code> operator will resolve as true
when comparing an integral floating point, other operations, such as matching, will not.  Both
GPT-3.5 and GPT-4 struggled with this.  GPT-4 missed several validations due to this.</p>
<h4 dir="auto"><a id="user-content-example" aria-hidden="true" href="#example"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Example:</h4>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;enum-enum with 0 does not match false&#34; do
  def validate(0), do: :ok
  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;enum-enum with 0 does not match false&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>0</span><span>)</span><span>,</span> <span>do: </span><span>:ok</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<h3 dir="auto"><a id="user-content-filters-only-apply-to-their-own-types" aria-hidden="true" href="#filters-only-apply-to-their-own-types"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Filters only apply to their own types</h3>
<p dir="auto">This error, which is common to both GPT-3.5 and GPT-4, occurs because GPT does not
understand that a filter will not reject a type it is not designed to operate on.  A good
example of such code is the following (derived from the schema <code>{&#34;maxItems&#34;: 2}</code>):</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;maxItems-maxItems validation&#34; do
  def validate(list) when is_list(list) and length(list) &lt;= 2, do: :ok
  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;maxItems-maxItems validation&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>list</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>list</span><span>)</span> <span>and</span> <span>length</span><span>(</span><span>list</span><span>)</span> <span>&lt;=</span> <span>2</span><span>,</span> <span>do: </span><span>:ok</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">Note that <code>validate/1</code> will return <code>:error</code> when confronted with a string, even
though the JSONSchema spec says that the <code>maxItems</code> filter should not apply, defaulting to
successful validation.</p>
<p dir="auto">When given the schema <code>{&#34;maxItems&#34;: 2, &#34;maxLength&#34;: 4}</code> (not in the test suite), GPT-4 does
something even stranger, applying the <code>maxLength</code> criterion to the inner elements of the list,
even while accepting the that the outer element can be either a list or a string.</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;maxItems-maxLength&#34; do
  def validate(value) when is_list(value) and length(value) &lt;= 2 do
    Enum.reduce(value, :ok, fn item, acc -&gt;
      if is_binary(item) and byte_size(item) &lt;= 4, do: acc, else: :error
    end)
  end

  def validate(value) when is_binary(value) and byte_size(value) &lt;= 4 do
    :ok
  end

  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;maxItems-maxLength&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>value</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>value</span><span>)</span> <span>and</span> <span>length</span><span>(</span><span>value</span><span>)</span> <span>&lt;=</span> <span>2</span> <span>do</span>
    <span>Enum</span><span>.</span><span>reduce</span><span>(</span><span>value</span><span>,</span> <span>:ok</span><span>,</span> <span>fn</span> <span>item</span><span>,</span> <span>acc</span> <span>-&gt;</span>
      <span>if</span> <span>is_binary</span><span>(</span><span>item</span><span>)</span> <span>and</span> <span>byte_size</span><span>(</span><span>item</span><span>)</span> <span>&lt;=</span> <span>4</span><span>,</span> <span>do: </span><span>acc</span><span>,</span> <span>else: </span><span>:error</span>
    <span>end</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>value</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>value</span><span>)</span> <span>and</span> <span>byte_size</span><span>(</span><span>value</span><span>)</span> <span>&lt;=</span> <span>4</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">When given <code>{&#34;maxLength&#34;: 4, &#34;maximum&#34;: 3}</code>, GPT-4 gets the code correct.</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;maxLength-maximum&#34; do
  def validate(value) when is_binary(value) and byte_size(value) &lt;= 4, do: :ok
  def validate(value) when is_number(value) and value &lt;= 3, do: :ok
  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;maxLength-maximum&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>value</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>value</span><span>)</span> <span>and</span> <span>byte_size</span><span>(</span><span>value</span><span>)</span> <span>&lt;=</span> <span>4</span><span>,</span> <span>do: </span><span>:ok</span>
  <span>def</span> <span>validate</span><span>(</span><span>value</span><span>)</span> <span>when</span> <span>is_number</span><span>(</span><span>value</span><span>)</span> <span>and</span> <span>value</span> <span>&lt;=</span> <span>3</span><span>,</span> <span>do: </span><span>:ok</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">In the GPT-4 accuracy benchmark, ~15 of the test schemas were prevented from passing all of
their tests solely because of missing this criterion.</p>
<h3 dir="auto"><a id="user-content-formatcontent" aria-hidden="true" href="#formatcontent"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Format/Content</h3>
<p dir="auto">Neither GPT knew that <code>format</code> and <code>content-*</code> filters are default off and the test suite does
not test against this validation.  However, both GPTs reached for Elixir standard library
tools, even though these do not necessarily fit the explicit requirements set forth by the
JSONSchema standard, or 3rd party tools (despite being told explictly not to) to perform
validations.</p>
<h4 dir="auto"><a id="user-content-examples-all-gpt-4" aria-hidden="true" href="#examples-all-gpt-4"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Examples (all GPT-4):</h4>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;format-validation of date-time strings&#34; do
  def validate(datetime_string) when is_binary(datetime_string) do
    if valid_datetime?(datetime_string) do
      :ok
    else
      :error
    end
  end

  def validate(_), do: :error

  defp valid_datetime?(datetime_string) do
    case DateTime.from_iso8601(datetime_string) do
      {:ok, _} -&gt; true
      :error -&gt; false
    end
  end
end"><pre><span>defmodule</span> <span>:&#34;format-validation of date-time strings&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>datetime_string</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>datetime_string</span><span>)</span> <span>do</span>
    <span>if</span> <span>valid_datetime?</span><span>(</span><span>datetime_string</span><span>)</span> <span>do</span>
      <span>:ok</span>
    <span>else</span>
      <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>

  <span>defp</span> <span>valid_datetime?</span><span>(</span><span>datetime_string</span><span>)</span> <span>do</span>
    <span>case</span> <span>DateTime</span><span>.</span><span>from_iso8601</span><span>(</span><span>datetime_string</span><span>)</span> <span>do</span>
      <span>{</span><span>:ok</span><span>,</span> <span>_</span><span>}</span> <span>-&gt;</span> <span>true</span>
      <span>:error</span> <span>-&gt;</span> <span>false</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">For <code>date-time</code> validation, the correct Elixir Standard Library to use is <code>NaiveDateTime</code>, not
<code>DateTime</code>.  <code>DateTime</code> will fail without being given time-zone information.</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;format-validation of IDN hostnames&#34; do
  alias :idna, as: Idna

  def validate(hostname) when is_binary(hostname) do
    if valid_idn_hostname?(hostname) do
      :ok
    else
      :error
    end
  end

  def validate(_), do: :error

  defp valid_idn_hostname?(hostname) do
    case Idna.to_ascii(hostname) do
      {:ok, ascii_hostname} -&gt; valid_ascii_hostname?(ascii_hostname)
      _ -&gt; false
    end
  end

  defp valid_ascii_hostname?(hostname) do
    :inet.parse_strict_address(hostname) == :error and
      Enum.all?(String.split(hostname, &#34;.&#34;, trim: true), &amp;valid_label?/1)
  end

  defp valid_label?(label) do
    byte_size(label) in 1..63 and
      String.match?(label, ~r/^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$/)
  end
end"><pre><span>defmodule</span> <span>:&#34;format-validation of IDN hostnames&#34;</span> <span>do</span>
  <span>alias</span> <span>:idna</span><span>,</span> <span>as: </span><span>Idna</span>

  <span>def</span> <span>validate</span><span>(</span><span>hostname</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>hostname</span><span>)</span> <span>do</span>
    <span>if</span> <span>valid_idn_hostname?</span><span>(</span><span>hostname</span><span>)</span> <span>do</span>
      <span>:ok</span>
    <span>else</span>
      <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>

  <span>defp</span> <span>valid_idn_hostname?</span><span>(</span><span>hostname</span><span>)</span> <span>do</span>
    <span>case</span> <span>Idna</span><span>.</span><span>to_ascii</span><span>(</span><span>hostname</span><span>)</span> <span>do</span>
      <span>{</span><span>:ok</span><span>,</span> <span>ascii_hostname</span><span>}</span> <span>-&gt;</span> <span>valid_ascii_hostname?</span><span>(</span><span>ascii_hostname</span><span>)</span>
      <span>_</span> <span>-&gt;</span> <span>false</span>
    <span>end</span>
  <span>end</span>

  <span>defp</span> <span>valid_ascii_hostname?</span><span>(</span><span>hostname</span><span>)</span> <span>do</span>
    <span>:inet</span><span>.</span><span>parse_strict_address</span><span>(</span><span>hostname</span><span>)</span> <span>==</span> <span>:error</span> <span>and</span>
      <span>Enum</span><span>.</span><span>all?</span><span>(</span><span>String</span><span>.</span><span>split</span><span>(</span><span>hostname</span><span>,</span> <span>&#34;.&#34;</span><span>,</span> <span>trim: </span><span>true</span><span>)</span><span>,</span> <span>&amp;</span><span>valid_label?</span><span>/</span><span>1</span><span>)</span>
  <span>end</span>

  <span>defp</span> <span>valid_label?</span><span>(</span><span>label</span><span>)</span> <span>do</span>
    <span>byte_size</span><span>(</span><span>label</span><span>)</span> <span>in</span> <span>1</span><span>..</span><span>63</span> <span>and</span>
      <span>String</span><span>.</span><span>match?</span><span>(</span><span>label</span><span>,</span> <span>~r<span>/</span>^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?$<span>/</span></span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">GPT-4 (impressively) reaches for the :idna erlang library, but, oddly decides to alias it with
an Elixir-style module name.</p>
<h2 dir="auto"><a id="user-content-accuracy-evaluation" aria-hidden="true" href="#accuracy-evaluation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Accuracy Evaluation</h2>
<p dir="auto">Next, let&#39;s look at how accurately GPT-3.5 and GPT-4 perform across all of the JSONSchema tests:</p>
<div dir="auto" data-snippet-clipboard-copy-content="defmodule Benchmark.Plotter do
  def format_passes(result) do
    result.pass
    |&gt; Enum.map(&amp;&#34;✅ #{&amp;1}&#34;)
    |&gt; Enum.join(&#34;\n&#34;)
  end

  def format_fails(result) do
    result.fail
    |&gt; Enum.map(&amp;&#34;❌ #{elem(&amp;1, 0)}&#34;)
    |&gt; Enum.join(&#34;\n&#34;)
  end

  @granularity 2

  def tabularize(result) do
    color =
      case result.type do
        :ok -&gt; :green
        :partial -&gt; :yellow
        :failure -&gt; :orange
        :compile -&gt; :red
      end

    %{
      group: result.schema.group,
      test: result.schema.description,
      schema: Jason.encode!(result.schema.schema),
      pct: round(result.pct / @granularity) * @granularity,
      color: color,
      pass: format_passes(result),
      fail: format_fails(result)
    }
  end

  def nudge_data(results) do
    # data points might overlap, so to make the visualization more effective,
    # we should nudge the points apart from each other.
    results
    |&gt; Enum.sort_by(&amp;{&amp;1.group, &amp;1.pct})
    |&gt; Enum.map_reduce(MapSet.new(), &amp;nudge/2)
    |&gt; elem(0)
  end

  @nudge 2

  # points might overlap, so move them up or down accordingly for better 
  # visualization.  Colors help us understand the qualitative results.
  defp nudge(result = %{pct: pct}, seen) when pct == 100, do: nudge(result, seen, -@nudge)
  defp nudge(result, seen), do: nudge(result, seen, @nudge)

  defp nudge(result, seen, amount) do
    if {result.group, result.pct} in seen do
      nudge(%{result | pct: result.pct + amount}, seen, amount)
    else
      {result, MapSet.put(seen, {result.group, result.pct})}
    end
  end

  def plot_one({title, results}) do
    tabularized =
      results
      |&gt; Enum.map(&amp;tabularize/1)
      |&gt; nudge_data

    VegaLite.new(title: title)
    |&gt; VegaLite.data_from_values(tabularized)
    |&gt; VegaLite.mark(:circle)
    |&gt; VegaLite.encode_field(:x, &#34;group&#34;, type: :nominal, title: false)
    |&gt; VegaLite.encode_field(:y, &#34;pct&#34;, type: :quantitative, title: &#34;percent correct&#34;)
    |&gt; VegaLite.encode_field(:color, &#34;color&#34;, legend: false)
    |&gt; VegaLite.encode(:tooltip, [
      [field: &#34;group&#34;],
      [field: &#34;test&#34;],
      [field: &#34;schema&#34;],
      [field: &#34;pass&#34;],
      [field: &#34;fail&#34;]
    ])
  end

  def plot(list_of_results) do
    VegaLite.new()
    |&gt; VegaLite.concat(Enum.map(list_of_results, &amp;plot_one/1), :vertical)
  end
end

Benchmark.Plotter.plot(&#34;gpt-3.5&#34;: gpt_3_results, &#34;gpt-4&#34;: gpt_4_results)"><pre><span>defmodule</span> <span>Benchmark.Plotter</span> <span>do</span>
  <span>def</span> <span>format_passes</span><span>(</span><span>result</span><span>)</span> <span>do</span>
    <span>result</span><span>.</span><span>pass</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>&#34;✅ <span><span>#{</span><span>&amp;</span><span>1</span><span>}</span></span>&#34;</span><span>)</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>join</span><span>(</span><span>&#34;<span>\n</span>&#34;</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>format_fails</span><span>(</span><span>result</span><span>)</span> <span>do</span>
    <span>result</span><span>.</span><span>fail</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>&#34;❌ <span><span>#{</span><span>elem</span><span>(</span><span>&amp;</span><span>1</span><span>,</span> <span>0</span><span>)</span><span>}</span></span>&#34;</span><span>)</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>join</span><span>(</span><span>&#34;<span>\n</span>&#34;</span><span>)</span>
  <span>end</span>

  <span>@</span><span>granularity</span> <span>2</span>

  <span>def</span> <span>tabularize</span><span>(</span><span>result</span><span>)</span> <span>do</span>
    <span>color</span> <span>=</span>
      <span>case</span> <span>result</span><span>.</span><span>type</span> <span>do</span>
        <span>:ok</span> <span>-&gt;</span> <span>:green</span>
        <span>:partial</span> <span>-&gt;</span> <span>:yellow</span>
        <span>:failure</span> <span>-&gt;</span> <span>:orange</span>
        <span>:compile</span> <span>-&gt;</span> <span>:red</span>
      <span>end</span>

    <span>%</span><span>{</span>
      <span>group: </span><span>result</span><span>.</span><span>schema</span><span>.</span><span>group</span><span>,</span>
      <span>test: </span><span>result</span><span>.</span><span>schema</span><span>.</span><span>description</span><span>,</span>
      <span>schema: </span><span>Jason</span><span>.</span><span>encode!</span><span>(</span><span>result</span><span>.</span><span>schema</span><span>.</span><span>schema</span><span>)</span><span>,</span>
      <span>pct: </span><span>round</span><span>(</span><span>result</span><span>.</span><span>pct</span> <span>/</span> <span>@</span><span>granularity</span><span>)</span> <span>*</span> <span>@</span><span>granularity</span><span>,</span>
      <span>color: </span><span>color</span><span>,</span>
      <span>pass: </span><span>format_passes</span><span>(</span><span>result</span><span>)</span><span>,</span>
      <span>fail: </span><span>format_fails</span><span>(</span><span>result</span><span>)</span>
    <span>}</span>
  <span>end</span>

  <span>def</span> <span>nudge_data</span><span>(</span><span>results</span><span>)</span> <span>do</span>
    <span># data points might overlap, so to make the visualization more effective,</span>
    <span># we should nudge the points apart from each other.</span>
    <span>results</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>sort_by</span><span>(</span><span>&amp;</span><span>{</span><span>&amp;</span><span>1</span><span>.</span><span>group</span><span>,</span> <span>&amp;</span><span>1</span><span>.</span><span>pct</span><span>}</span><span>)</span>
    <span>|&gt;</span> <span>Enum</span><span>.</span><span>map_reduce</span><span>(</span><span>MapSet</span><span>.</span><span>new</span><span>(</span><span>)</span><span>,</span> <span>&amp;</span><span>nudge</span><span>/</span><span>2</span><span>)</span>
    <span>|&gt;</span> <span>elem</span><span>(</span><span>0</span><span>)</span>
  <span>end</span>

  <span>@</span><span>nudge</span> <span>2</span>

  <span># points might overlap, so move them up or down accordingly for better </span>
  <span># visualization.  Colors help us understand the qualitative results.</span>
  <span>defp</span> <span>nudge</span><span>(</span><span>result</span> <span>=</span> <span>%</span><span>{</span><span>pct: </span><span>pct</span><span>}</span><span>,</span> <span>seen</span><span>)</span> <span>when</span> <span>pct</span> <span>==</span> <span>100</span><span>,</span> <span>do: </span><span>nudge</span><span>(</span><span>result</span><span>,</span> <span>seen</span><span>,</span> <span>-</span><span>@</span><span>nudge</span><span>)</span>
  <span>defp</span> <span>nudge</span><span>(</span><span>result</span><span>,</span> <span>seen</span><span>)</span><span>,</span> <span>do: </span><span>nudge</span><span>(</span><span>result</span><span>,</span> <span>seen</span><span>,</span> <span>@</span><span>nudge</span><span>)</span>

  <span>defp</span> <span>nudge</span><span>(</span><span>result</span><span>,</span> <span>seen</span><span>,</span> <span>amount</span><span>)</span> <span>do</span>
    <span>if</span> <span>{</span><span>result</span><span>.</span><span>group</span><span>,</span> <span>result</span><span>.</span><span>pct</span><span>}</span> <span>in</span> <span>seen</span> <span>do</span>
      <span>nudge</span><span>(</span><span>%</span><span>{</span><span>result</span> <span>|</span> <span>pct: </span><span>result</span><span>.</span><span>pct</span> <span>+</span> <span>amount</span><span>}</span><span>,</span> <span>seen</span><span>,</span> <span>amount</span><span>)</span>
    <span>else</span>
      <span>{</span><span>result</span><span>,</span> <span>MapSet</span><span>.</span><span>put</span><span>(</span><span>seen</span><span>,</span> <span>{</span><span>result</span><span>.</span><span>group</span><span>,</span> <span>result</span><span>.</span><span>pct</span><span>}</span><span>)</span><span>}</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>plot_one</span><span>(</span><span>{</span><span>title</span><span>,</span> <span>results</span><span>}</span><span>)</span> <span>do</span>
    <span>tabularized</span> <span>=</span>
      <span>results</span>
      <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span><span>tabularize</span><span>/</span><span>1</span><span>)</span>
      <span>|&gt;</span> <span>nudge_data</span>

    <span>VegaLite</span><span>.</span><span>new</span><span>(</span><span>title: </span><span>title</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>data_from_values</span><span>(</span><span>tabularized</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>mark</span><span>(</span><span>:circle</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:x</span><span>,</span> <span>&#34;group&#34;</span><span>,</span> <span>type: </span><span>:nominal</span><span>,</span> <span>title: </span><span>false</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:y</span><span>,</span> <span>&#34;pct&#34;</span><span>,</span> <span>type: </span><span>:quantitative</span><span>,</span> <span>title: </span><span>&#34;percent correct&#34;</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:color</span><span>,</span> <span>&#34;color&#34;</span><span>,</span> <span>legend: </span><span>false</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode</span><span>(</span><span>:tooltip</span><span>,</span> <span>[</span>
      <span>[</span><span>field: </span><span>&#34;group&#34;</span><span>]</span><span>,</span>
      <span>[</span><span>field: </span><span>&#34;test&#34;</span><span>]</span><span>,</span>
      <span>[</span><span>field: </span><span>&#34;schema&#34;</span><span>]</span><span>,</span>
      <span>[</span><span>field: </span><span>&#34;pass&#34;</span><span>]</span><span>,</span>
      <span>[</span><span>field: </span><span>&#34;fail&#34;</span><span>]</span>
    <span>]</span><span>)</span>
  <span>end</span>

  <span>def</span> <span>plot</span><span>(</span><span>list_of_results</span><span>)</span> <span>do</span>
    <span>VegaLite</span><span>.</span><span>new</span><span>(</span><span>)</span>
    <span>|&gt;</span> <span>VegaLite</span><span>.</span><span>concat</span><span>(</span><span>Enum</span><span>.</span><span>map</span><span>(</span><span>list_of_results</span><span>,</span> <span>&amp;</span><span>plot_one</span><span>/</span><span>1</span><span>)</span><span>,</span> <span>:vertical</span><span>)</span>
  <span>end</span>
<span>end</span>

<span>Benchmark.Plotter</span><span>.</span><span>plot</span><span>(</span><span>&#34;gpt-3.5&#34;: </span><span>gpt_3_results</span><span>,</span> <span>&#34;gpt-4&#34;: </span><span>gpt_4_results</span><span>)</span></pre></div>

<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://reserialised.routley.io/E-xyza/Exonerate/blob/master/bench/reports/full-chart.svg"><img src="https://reserialised.routley.io/E-xyza/Exonerate/raw/master/bench/reports/full-chart.svg" alt=""/></a></p>
<p dir="auto">In the above chart, blue dots are 100% correct, green dots are partially correct, orange dots
are completely incorrect, and red dots are compilation errors.  Note that dot positions may
not be at the exact percentage, so that the count of overlapping tests can be easily seen.</p>
<h2 dir="auto"><a id="user-content-selected-observations-of-interest" aria-hidden="true" href="#selected-observations-of-interest"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Selected Observations of interest</h2>
<h3 dir="auto"><a id="user-content-incorrect-elixir" aria-hidden="true" href="#incorrect-elixir"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Incorrect Elixir</h3>
<p dir="auto">GPT-3.5 and GPT-4 are not aware that only certain functions can be called in function guards,
so this example from GPT-4 causes a compilation error:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;anyOf-anyOf with base schema&#34; do
  def validate(value) when is_binary(value) and (String.length(value) &lt;= 2 or String.length(value) &gt;= 4), do: :ok
  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;anyOf-anyOf with base schema&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>value</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>value</span><span>)</span> <span>and</span> <span>(</span><span>String</span><span>.</span><span>length</span><span>(</span><span>value</span><span>)</span> <span>&lt;=</span> <span>2</span> <span>or</span> <span>String</span><span>.</span><span>length</span><span>(</span><span>value</span><span>)</span> <span>&gt;=</span> <span>4</span><span>)</span><span>,</span> <span>do: </span><span>:ok</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<h3 dir="auto"><a id="user-content-misunderstanding-elixir" aria-hidden="true" href="#misunderstanding-elixir"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Misunderstanding Elixir</h3>
<p dir="auto">GPT-4 attempts to directly match the result of <code>Map.keys/1</code>.  (see second function header)  This likely works
in this case, but in general there is no guarantee that the list result of this function will return the
keys in any given order see: <a href="https://www.erlang.org/doc/man/maps.html#keys-1" rel="nofollow">https://www.erlang.org/doc/man/maps.html#keys-1</a>.</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;oneOf-oneOf with missing optional property&#34; do
  def validate(%{&#34;foo&#34; =&gt; _} = object) do
    case Map.keys(object) do
      [&#34;foo&#34;] -&gt; :ok
      _ -&gt; :error
    end
  end
  def validate(%{&#34;bar&#34; =&gt; _} = object) do
    case Map.keys(object) do
      [&#34;bar&#34;, &#34;baz&#34;] -&gt; :ok
      _ -&gt; :error
    end
  end
  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;oneOf-oneOf with missing optional property&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>%</span><span>{</span><span>&#34;foo&#34;</span> <span>=&gt;</span> <span>_</span><span>}</span> <span>=</span> <span>object</span><span>)</span> <span>do</span>
    <span>case</span> <span>Map</span><span>.</span><span>keys</span><span>(</span><span>object</span><span>)</span> <span>do</span>
      <span>[</span><span>&#34;foo&#34;</span><span>]</span> <span>-&gt;</span> <span>:ok</span>
      <span>_</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>
  <span>def</span> <span>validate</span><span>(</span><span>%</span><span>{</span><span>&#34;bar&#34;</span> <span>=&gt;</span> <span>_</span><span>}</span> <span>=</span> <span>object</span><span>)</span> <span>do</span>
    <span>case</span> <span>Map</span><span>.</span><span>keys</span><span>(</span><span>object</span><span>)</span> <span>do</span>
      <span>[</span><span>&#34;bar&#34;</span><span>,</span> <span>&#34;baz&#34;</span><span>]</span> <span>-&gt;</span> <span>:ok</span>
      <span>_</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">GPT-3 also often attempts to match from <code>Map.keys/1</code>:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;unevaluatedProperties-nested unevaluatedProperties, outer false, inner true, properties inside-gpt-3.5&#34; do
  def validate(object) when is_map(object) do
    case Map.keys(object) do
      [&#34;foo&#34; | _] -&gt; :ok
      _ -&gt; :error
    end
  end

  def validate(_) do
    :error
  end
end"><pre><span>defmodule</span> <span>:&#34;unevaluatedProperties-nested unevaluatedProperties, outer false, inner true, properties inside-gpt-3.5&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>object</span><span>)</span> <span>when</span> <span>is_map</span><span>(</span><span>object</span><span>)</span> <span>do</span>
    <span>case</span> <span>Map</span><span>.</span><span>keys</span><span>(</span><span>object</span><span>)</span> <span>do</span>
      <span>[</span><span>&#34;foo&#34;</span> <span>|</span> <span>_</span><span>]</span> <span>-&gt;</span> <span>:ok</span>
      <span>_</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span> <span>do</span>
    <span>:error</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">in this case simply</p>

<div dir="auto" data-snippet-clipboard-copy-content="if Map.has_key?(object, &#34;foo&#34;), do: :ok, else: :error"><pre><span>if</span> <span>Map</span><span>.</span><span>has_key?</span><span>(</span><span>object</span><span>,</span> <span>&#34;foo&#34;</span><span>)</span><span>,</span> <span>do: </span><span>:ok</span><span>,</span> <span>else: </span><span>:error</span></pre></div>
<p dir="auto">would have done the trick, and is O(1) in the size of the map; <code>Map.keys/1</code> is
O(N) by virtue of synthesizing the entire array.</p>
<h3 dir="auto"><a id="user-content-hallucinations" aria-hidden="true" href="#hallucinations"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hallucinations</h3>
<p dir="auto">GPT-3.5 was particularly prone to hallucinations.  In one case, it hallucinated a <code>json_schema</code>
library (and also flubbed the parameter it passed):</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;items-prefixItems with no additional items allowed-gpt-3.5&#34; do
  def validate(object) when is_map(object), do: validate_object(object)
  def validate(_), do: :error

  defp validate_object(object) do
    case Map.has_key?(object, :items) and Map.has_key?(object, :prefixItems) and not Map.has_key?(object, :additionalItems) do
      true -&gt; Map.get(object, :prefixItems)
              |&gt; Enum.all?(fn _ -&gt; %{} end)
              |&gt; :json_schema.validate(:#{false})
              |&gt; handle_validation_result()
      false -&gt; :error
    end
  end

  defp handle_validation_result(result) do
    case result do
      {:ok, _} -&gt; :ok
      {:error, _, _} -&gt; :error
    end
  end
end"><pre><span>defmodule</span> <span>:&#34;items-prefixItems with no additional items allowed-gpt-3.5&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>object</span><span>)</span> <span>when</span> <span>is_map</span><span>(</span><span>object</span><span>)</span><span>,</span> <span>do: </span><span>validate_object</span><span>(</span><span>object</span><span>)</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>

  <span>defp</span> <span>validate_object</span><span>(</span><span>object</span><span>)</span> <span>do</span>
    <span>case</span> <span>Map</span><span>.</span><span>has_key?</span><span>(</span><span>object</span><span>,</span> <span>:items</span><span>)</span> <span>and</span> <span>Map</span><span>.</span><span>has_key?</span><span>(</span><span>object</span><span>,</span> <span>:prefixItems</span><span>)</span> <span>and</span> <span>not</span> <span>Map</span><span>.</span><span>has_key?</span><span>(</span><span>object</span><span>,</span> <span>:additionalItems</span><span>)</span> <span>do</span>
      <span>true</span> <span>-&gt;</span> <span>Map</span><span>.</span><span>get</span><span>(</span><span>object</span><span>,</span> <span>:prefixItems</span><span>)</span>
              <span>|&gt;</span> <span>Enum</span><span>.</span><span>all?</span><span>(</span><span>fn</span> <span>_</span> <span>-&gt;</span> <span>%</span><span>{</span><span>}</span> <span>end</span><span>)</span>
              <span>|&gt;</span> <span>:json_schema</span><span>.</span><span>validate</span><span>(</span>:#{<span>false</span><span>}</span><span>)</span>
              <span>|&gt;</span> <span>handle_validation_result</span><span>(</span><span>)</span>
      <span>false</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>defp</span> <span>handle_validation_result</span><span>(</span><span>result</span><span>)</span> <span>do</span>
    <span>case</span> <span>result</span> <span>do</span>
      <span>{</span><span>:ok</span><span>,</span> <span>_</span><span>}</span> <span>-&gt;</span> <span>:ok</span>
      <span>{</span><span>:error</span><span>,</span> <span>_</span><span>,</span> <span>_</span><span>}</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<h3 dir="auto"><a id="user-content-semantic-misunderstanding" aria-hidden="true" href="#semantic-misunderstanding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Semantic misunderstanding</h3>
<div dir="auto" data-snippet-clipboard-copy-content="{&#34;contains&#34;:{&#34;maximum&#34;: 5}}"><pre>{<span>&#34;contains&#34;</span>:{<span>&#34;maximum&#34;</span>: <span>5</span>}}</pre></div>
<p dir="auto">GPT-4 misinterprets OpenAPI and generates the following code:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;contains-contains keyword validation&#34; do
  def validate(object) when is_list(object) do
    if Enum.count(object) &gt;= 5 do
      :ok
    else
      :error
    end
  end
  def validate(_), do: :error
end"><pre><span>defmodule</span> <span>:&#34;contains-contains keyword validation&#34;</span> <span>do</span>
  <span>def</span> <span>validate</span><span>(</span><span>object</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>object</span><span>)</span> <span>do</span>
    <span>if</span> <span>Enum</span><span>.</span><span>count</span><span>(</span><span>object</span><span>)</span> <span>&gt;=</span> <span>5</span> <span>do</span>
      <span>:ok</span>
    <span>else</span>
      <span>:error</span>
    <span>end</span>
  <span>end</span>
  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span>
<span>end</span></pre></div>
<p dir="auto">This would be the correct code for:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{&#34;contains&#34;: {}, &#34;maxContains&#34;: 5}"><pre>{<span>&#34;contains&#34;</span>: {}, <span>&#34;maxContains&#34;</span>: <span>5</span>}</pre></div>
<p dir="auto">But the semantic error that GPT-4 makes is that it thinks that &#34;maximum&#34; is a qualifier on
&#34;contains&#34;, when in fact the schema calls for a new &#34;context&#34;; each object in the list should
validate as <code>{&#34;maximum&#34;: 5}</code> but this doesn&#39;t apply to the list itself.</p>
<h3 dir="auto"><a id="user-content-completely-misunderstanding" aria-hidden="true" href="#completely-misunderstanding"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Completely misunderstanding</h3>
<p dir="auto">Several times, GPT-3.5 gave up on doing the task properly and instead wandered off into
matching the schema, despite being told explictly not to.  Here is the simplest example:</p>

<div dir="auto" data-snippet-clipboard-copy-content="defmodule :&#34;uniqueItems-uniqueItems=false validation-gpt-3.5&#34; do
  @moduledoc &#34;Validates a JSON object against the &#39;uniqueItems=false&#39; schema.\n&#34;
  @doc &#34;Validates the given JSON object against the schema.\n&#34;
  @spec validate(Map.t()) :: :ok | :error
  def validate(%{uniqueItems: false} = object) when is_list(object) do
    if Enum.uniq(object) == object do
      :ok
    else
      :error
    end
  end

  def validate(_) do
    :error
  end
end"><pre><span>defmodule</span> <span>:&#34;uniqueItems-uniqueItems=false validation-gpt-3.5&#34;</span> <span>do</span>
  <span>@</span><span>moduledoc</span> <span>&#34;Validates a JSON object against the &#39;uniqueItems=false&#39; schema.<span>\n</span>&#34;</span>
  <span>@</span><span>doc</span> <span>&#34;Validates the given JSON object against the schema.<span>\n</span>&#34;</span>
  <span>@</span><span>spec</span> <span>validate</span><span>(</span><span>Map</span><span>.</span><span>t</span><span>(</span><span>)</span><span>)</span> <span>::</span> <span>:ok</span> <span>|</span> <span>:error</span>
  <span>def</span> <span>validate</span><span>(</span><span>%</span><span>{</span><span>uniqueItems: </span><span>false</span><span>}</span> <span>=</span> <span>object</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>object</span><span>)</span> <span>do</span>
    <span>if</span> <span>Enum</span><span>.</span><span>uniq</span><span>(</span><span>object</span><span>)</span> <span>==</span> <span>object</span> <span>do</span>
      <span>:ok</span>
    <span>else</span>
      <span>:error</span>
    <span>end</span>
  <span>end</span>

  <span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span> <span>do</span>
    <span>:error</span>
  <span>end</span>
<span>end</span></pre></div>
<h2 dir="auto"><a id="user-content-selected-performance-comparisons" aria-hidden="true" href="#selected-performance-comparisons"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Selected Performance Comparisons</h2>
<p dir="auto">Using the Benchee library, here I set up a framework by which we can test the speed of a few
representative samples of generated code.  The &#34;John Henry&#34; contender will be Exonerate, the
Elixir library that this notebook lives in.  Here we set up a <code>compare/2</code> function that runs
Benchee and reports the winner (ips = invocations per second, <strong>bigger is better</strong>).  The
module will also host the code generated by Exonerate.</p>
<div dir="auto" data-snippet-clipboard-copy-content="defmodule ExonerateBenchmarks do
  require Exonerate

  def compare(scenario, value, raw \\ false) do
    [exonerate_ips, gpt_ips] =
      %{
        gpt4: fn -&gt; apply(scenario, :validate, [value]) end,
        exonerate: fn -&gt; apply(__MODULE__, scenario, [value]) end
      }
      |&gt; Benchee.run()
      |&gt; Map.get(:scenarios)
      |&gt; Enum.sort_by(&amp; &amp;1.name)
      |&gt; Enum.map(&amp; &amp;1.run_time_data.statistics.ips)

    cond do
      raw -&gt;
        exonerate_ips / gpt_ips

      gpt_ips &gt; exonerate_ips -&gt;
        &#34;gpt-4 faster than exonerate by #{gpt_ips / exonerate_ips}x&#34;

      true -&gt;
        &#34;exonerate faster than gpt-4 by #{exonerate_ips / gpt_ips}x&#34;
    end
  end

  Exonerate.function_from_string(
    :def,
    :&#34;allOf-allOf simple types&#34;,
    ~S({&#34;allOf&#34;: [{&#34;maximum&#34;: 30}, {&#34;minimum&#34;: 20}]})
  )

  Exonerate.function_from_string(
    :def,
    :&#34;uniqueItems-uniqueItems validation&#34;,
    ~S({&#34;uniqueItems&#34;: true})
  )

  Exonerate.function_from_string(
    :def,
    :&#34;oneOf-oneOf with required&#34;,
    ~S({
            &#34;type&#34;: &#34;object&#34;,
            &#34;oneOf&#34;: [
                { &#34;required&#34;: [&#34;foo&#34;, &#34;bar&#34;] },
                { &#34;required&#34;: [&#34;foo&#34;, &#34;baz&#34;] }
            ]
        })
  )
end"><pre><span>defmodule</span> <span>ExonerateBenchmarks</span> <span>do</span>
  <span>require</span> <span>Exonerate</span>

  <span>def</span> <span>compare</span><span>(</span><span>scenario</span><span>,</span> <span>value</span><span>,</span> <span>raw</span> <span>\\</span> <span>false</span><span>)</span> <span>do</span>
    <span>[</span><span>exonerate_ips</span><span>,</span> <span>gpt_ips</span><span>]</span> <span>=</span>
      <span>%</span><span>{</span>
        <span>gpt4: </span><span>fn</span> <span>-&gt;</span> <span>apply</span><span>(</span><span>scenario</span><span>,</span> <span>:validate</span><span>,</span> <span>[</span><span>value</span><span>]</span><span>)</span> <span>end</span><span>,</span>
        <span>exonerate: </span><span>fn</span> <span>-&gt;</span> <span>apply</span><span>(</span><span>__MODULE__</span><span>,</span> <span>scenario</span><span>,</span> <span>[</span><span>value</span><span>]</span><span>)</span> <span>end</span>
      <span>}</span>
      <span>|&gt;</span> <span>Benchee</span><span>.</span><span>run</span><span>(</span><span>)</span>
      <span>|&gt;</span> <span>Map</span><span>.</span><span>get</span><span>(</span><span>:scenarios</span><span>)</span>
      <span>|&gt;</span> <span>Enum</span><span>.</span><span>sort_by</span><span>(</span><span>&amp;</span> <span>&amp;</span><span>1</span><span>.</span><span>name</span><span>)</span>
      <span>|&gt;</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>&amp;</span> <span>&amp;</span><span>1</span><span>.</span><span>run_time_data</span><span>.</span><span>statistics</span><span>.</span><span>ips</span><span>)</span>

    <span>cond</span> <span>do</span>
      <span>raw</span> <span>-&gt;</span>
        <span>exonerate_ips</span> <span>/</span> <span>gpt_ips</span>

      <span>gpt_ips</span> <span>&gt;</span> <span>exonerate_ips</span> <span>-&gt;</span>
        <span>&#34;gpt-4 faster than exonerate by <span><span>#{</span><span>gpt_ips</span> <span>/</span> <span>exonerate_ips</span><span>}</span></span>x&#34;</span>

      <span>true</span> <span>-&gt;</span>
        <span>&#34;exonerate faster than gpt-4 by <span><span>#{</span><span>exonerate_ips</span> <span>/</span> <span>gpt_ips</span><span>}</span></span>x&#34;</span>
    <span>end</span>
  <span>end</span>

  <span>Exonerate</span><span>.</span><span>function_from_string</span><span>(</span>
    <span>:def</span><span>,</span>
    <span>:&#34;allOf-allOf simple types&#34;</span><span>,</span>
    <span>~S<span>(</span>{&#34;allOf&#34;: [{&#34;maximum&#34;: 30}, {&#34;minimum&#34;: 20}]}<span>)</span></span>
  <span>)</span>

  <span>Exonerate</span><span>.</span><span>function_from_string</span><span>(</span>
    <span>:def</span><span>,</span>
    <span>:&#34;uniqueItems-uniqueItems validation&#34;</span><span>,</span>
    <span>~S<span>(</span>{&#34;uniqueItems&#34;: true}<span>)</span></span>
  <span>)</span>

  <span>Exonerate</span><span>.</span><span>function_from_string</span><span>(</span>
    <span>:def</span><span>,</span>
    <span>:&#34;oneOf-oneOf with required&#34;</span><span>,</span>
    <span>~S<span>(</span>{</span>
<span>            &#34;type&#34;: &#34;object&#34;,</span>
<span>            &#34;oneOf&#34;: [</span>
<span>                { &#34;required&#34;: [&#34;foo&#34;, &#34;bar&#34;] },</span>
<span>                { &#34;required&#34;: [&#34;foo&#34;, &#34;baz&#34;] }</span>
<span>            ]</span>
<span>        }<span>)</span></span>
  <span>)</span>
<span>end</span></pre></div>
<h3 dir="auto"><a id="user-content-gpt-4-wins" aria-hidden="true" href="#gpt-4-wins"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>GPT-4 wins!</h3>
<div dir="auto" data-snippet-clipboard-copy-content="{&#34;allOf&#34;: [{&#34;maximum&#34;: 30}, {&#34;minimum&#34;: 20}]}"><pre>{<span>&#34;allOf&#34;</span>: [{<span>&#34;maximum&#34;</span>: <span>30</span>}, {<span>&#34;minimum&#34;</span>: <span>20</span>}]}</pre></div>
<p dir="auto">Let&#39;s take a look at a clear case where GPT-4 is the winning contender.  In this code, we apply
two filters to a number using the allOf construct so that the number is subjected to both
schemata.  This would not be the best way to do this (probably doing this without allOf is
better) but it will be very illustrative of how GPT-4 can do better.</p>
<p dir="auto">This is GPT-4&#39;s code:</p>

<div dir="auto" data-snippet-clipboard-copy-content="def validate(number) when is_number(number) do
  if number &gt;= 20 and number &lt;= 30 do
    :ok
  else
    :error
  end
end

def validate(_), do: :error"><pre><span>def</span> <span>validate</span><span>(</span><span>number</span><span>)</span> <span>when</span> <span>is_number</span><span>(</span><span>number</span><span>)</span> <span>do</span>
  <span>if</span> <span>number</span> <span>&gt;=</span> <span>20</span> <span>and</span> <span>number</span> <span>&lt;=</span> <span>30</span> <span>do</span>
    <span>:ok</span>
  <span>else</span>
    <span>:error</span>
  <span>end</span>
<span>end</span>

<span>def</span> <span>validate</span><span>(</span><span>_</span><span>)</span><span>,</span> <span>do: </span><span>:error</span></pre></div>
<p dir="auto">Holy moly.  GPT-4 was able to deduce the intent of the allOf and see clearly that the filters
collapse into a single set of conditions that can be checked without indirection.</p>
<p dir="auto">By contrast, this is what Exonerate creates:</p>

<div dir="auto" data-snippet-clipboard-copy-content="def validate(data) do
  unquote(:&#34;function://validate/#/&#34;)(data, &#34;/&#34;)
end

defp unquote(:&#34;function://validate/#/&#34;)(array, path) when is_list(array) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(array, path) do
    :ok
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(boolean, path) when is_boolean(boolean) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(boolean, path) do
    :ok
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(integer, path) when is_integer(integer) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(integer, path) do
    :ok
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(null, path) when is_nil(null) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(null, path) do
    :ok
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(float, path) when is_float(float) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(float, path) do
    :ok
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(object, path) when is_map(object) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(object, path) do
    :ok
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(string, path) when is_binary(string) do
  if String.valid?(string) do
    with :ok &lt;- unquote(:&#34;function://validate/#/allOf&#34;)(string, path) do
      :ok
    end
  else
    require Exonerate.Tools
    Exonerate.Tools.mismatch(string, &#34;function://validate/&#34;, [&#34;type&#34;], path)
  end
end
defp unquote(:&#34;function://validate/#/&#34;)(content, path) do
  require Exonerate.Tools
  Exonerate.Tools.mismatch(content, &#34;function://validate/&#34;, [&#34;type&#34;], path)
end

defp unquote(:&#34;function://validate/#/allOf&#34;)(data, path) do
  require Exonerate.Tools

  Enum.reduce_while([
    &amp;unquote(:&#34;function://validate/#/allOf/0&#34;)/2, 
    &amp;unquote(:&#34;function://validate/#/allOf/1&#34;)/2
    ], 
    :ok, 
    fn fun, :ok -&gt;
      case fun.(data, path) do
        :ok -&gt; {:cont, :ok}
        Exonerate.Tools.error_match(error) -&gt; {:halt, error}
      end
  end)
end

defp unquote(:&#34;function://validate/#/allOf/0&#34;)(integer, path) when is_integer(integer) do
  with :ok &lt;- unquote(:&#34;function://validate/#/allOf/0/maximum&#34;)(integer, path) do
    :ok
  end
end

# ... SNIP ...

defp unquote(:&#34;function://validate/#/allOf/1/minimum&#34;)(number, path) do
  case number do
    number when number &gt;= 20 -&gt;
      :ok

    _ -&gt;
      require Exonerate.Tools
      Exonerate.Tools.mismatch(number, &#34;function://validate/&#34;, [&#34;allOf&#34;, &#34;1&#34;, &#34;minimum&#34;], path)
  end
end"><pre><span>def</span> <span>validate</span><span>(</span><span>data</span><span>)</span> <span>do</span>
  <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>data</span><span>,</span> <span>&#34;/&#34;</span><span>)</span>
<span>end</span>

<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>array</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>array</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>array</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>boolean</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_boolean</span><span>(</span><span>boolean</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>boolean</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>integer</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_integer</span><span>(</span><span>integer</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>integer</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>null</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_nil</span><span>(</span><span>null</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>null</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>float</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_float</span><span>(</span><span>float</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>float</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>object</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_map</span><span>(</span><span>object</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>object</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>string</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_binary</span><span>(</span><span>string</span><span>)</span> <span>do</span>
  <span>if</span> <span>String</span><span>.</span><span>valid?</span><span>(</span><span>string</span><span>)</span> <span>do</span>
    <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>string</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
      <span>:ok</span>
    <span>end</span>
  <span>else</span>
    <span>require</span> <span>Exonerate.Tools</span>
    <span>Exonerate.Tools</span><span>.</span><span>mismatch</span><span>(</span><span>string</span><span>,</span> <span>&#34;function://validate/&#34;</span><span>,</span> <span>[</span><span>&#34;type&#34;</span><span>]</span><span>,</span> <span>path</span><span>)</span>
  <span>end</span>
<span>end</span>
<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/&#34;</span><span>)</span><span>(</span><span>content</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
  <span>require</span> <span>Exonerate.Tools</span>
  <span>Exonerate.Tools</span><span>.</span><span>mismatch</span><span>(</span><span>content</span><span>,</span> <span>&#34;function://validate/&#34;</span><span>,</span> <span>[</span><span>&#34;type&#34;</span><span>]</span><span>,</span> <span>path</span><span>)</span>
<span>end</span>

<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf&#34;</span><span>)</span><span>(</span><span>data</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
  <span>require</span> <span>Exonerate.Tools</span>

  <span>Enum</span><span>.</span><span>reduce_while</span><span>(</span><span>[</span>
    <span>&amp;</span><span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf/0&#34;</span><span>)</span><span>/</span><span>2</span><span>,</span> 
    <span>&amp;</span><span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf/1&#34;</span><span>)</span><span>/</span><span>2</span>
    <span>]</span><span>,</span> 
    <span>:ok</span><span>,</span> 
    <span>fn</span> <span>fun</span><span>,</span> <span>:ok</span> <span>-&gt;</span>
      <span>case</span> <span>fun</span><span>.</span><span>(</span><span>data</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
        <span>:ok</span> <span>-&gt;</span> <span>{</span><span>:cont</span><span>,</span> <span>:ok</span><span>}</span>
        <span>Exonerate.Tools</span><span>.</span><span>error_match</span><span>(</span><span>error</span><span>)</span> <span>-&gt;</span> <span>{</span><span>:halt</span><span>,</span> <span>error</span><span>}</span>
      <span>end</span>
  <span>end</span><span>)</span>
<span>end</span>

<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf/0&#34;</span><span>)</span><span>(</span><span>integer</span><span>,</span> <span>path</span><span>)</span> <span>when</span> <span>is_integer</span><span>(</span><span>integer</span><span>)</span> <span>do</span>
  <span>with</span> <span>:ok</span> <span>&lt;-</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf/0/maximum&#34;</span><span>)</span><span>(</span><span>integer</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>end</span>
<span>end</span>

<span># ... SNIP ...</span>

<span>defp</span> <span>unquote</span><span>(</span><span>:&#34;function://validate/#/allOf/1/minimum&#34;</span><span>)</span><span>(</span><span>number</span><span>,</span> <span>path</span><span>)</span> <span>do</span>
  <span>case</span> <span>number</span> <span>do</span>
    <span>number</span> <span>when</span> <span>number</span> <span>&gt;=</span> <span>20</span> <span>-&gt;</span>
      <span>:ok</span>

    <span>_</span> <span>-&gt;</span>
      <span>require</span> <span>Exonerate.Tools</span>
      <span>Exonerate.Tools</span><span>.</span><span>mismatch</span><span>(</span><span>number</span><span>,</span> <span>&#34;function://validate/&#34;</span><span>,</span> <span>[</span><span>&#34;allOf&#34;</span><span>,</span> <span>&#34;1&#34;</span><span>,</span> <span>&#34;minimum&#34;</span><span>]</span><span>,</span> <span>path</span><span>)</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">It was so long I had to trim it down to keep from boring you.  But you should be able to get
the point.  The exonerate code painstakingly goes through every single branch of the schema
giving it its own, legible function and when there&#39;s an error it also goes ahead and
annotates the location in the schema where the error occurred, and what filter the input
violated.  So it&#39;s legitimately doing <em>more</em> than what the GPT-4 code does, which gleefully
destroyed this information that could be useful to whoever is trying to send data.</p>
<p dir="auto">Then again, I didn&#39;t <em>ask</em> it to do that.  Let&#39;s see how much of a difference in performance
all this makes</p>
<div dir="auto" data-snippet-clipboard-copy-content="ExonerateBenchmarks.compare(:&#34;allOf-allOf simple types&#34;, 25)"><pre><span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span><span>:&#34;allOf-allOf simple types&#34;</span><span>,</span> <span>25</span><span>)</span></pre></div>

<div data-snippet-clipboard-copy-content="&#34;gpt-4 faster than exonerate by 2.2903531909721173x&#34;"><pre><code>&#34;gpt-4 faster than exonerate by 2.2903531909721173x&#34;
</code></pre></div>
<p dir="auto">So above, we see that gpt-4 is ~&gt;2x faster than exonerate.  John Henry is defeated, in this round.</p>
<h3 dir="auto"><a id="user-content-hidden-regressions" aria-hidden="true" href="#hidden-regressions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Hidden Regressions</h3>
<p dir="auto"><code>{&#34;uniqueItems&#34;: true}</code></p>
<p dir="auto">Next, let&#39;s take a look at a place where a quick glance at the GPT-4 code creates a
tough-to-spot regression, in a very simple filter.  Here, GPT-4 does an obvious thing:</p>

<div dir="auto" data-snippet-clipboard-copy-content="def validate(list) when is_list(list) do
  unique_list = Enum.uniq(list)

  if length(list) == length(unique_list) do
    :ok
  else
    :error
  end
end"><pre><span>def</span> <span>validate</span><span>(</span><span>list</span><span>)</span> <span>when</span> <span>is_list</span><span>(</span><span>list</span><span>)</span> <span>do</span>
  <span>unique_list</span> <span>=</span> <span>Enum</span><span>.</span><span>uniq</span><span>(</span><span>list</span><span>)</span>

  <span>if</span> <span>length</span><span>(</span><span>list</span><span>)</span> <span>==</span> <span>length</span><span>(</span><span>unique_list</span><span>)</span> <span>do</span>
    <span>:ok</span>
  <span>else</span>
    <span>:error</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">If you&#39;re not familiar with how the BEAM works, the regression occurs because <code>Enum.uniq()</code> is
O(N) in the length of the list; <code>length(...)</code> is O(N) as well, so in the worst case this
algorithm runs through the length of the list <em>three</em> times.</p>
<p dir="auto">I won&#39;t show you the code Exonerate generated, but suffice it to say, the validator only loops
through the list once.  And it even quits early if it encounters a uniqueness violation.</p>
<p dir="auto">When we give it a short list, GPT-4 wins still.</p>
<div dir="auto" data-snippet-clipboard-copy-content="ExonerateBenchmarks.compare(:&#34;uniqueItems-uniqueItems validation&#34;, [1, 2, 3])"><pre><span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span><span>:&#34;uniqueItems-uniqueItems validation&#34;</span><span>,</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>)</span></pre></div>

<div data-snippet-clipboard-copy-content="&#34;gpt-4 faster than exonerate by 5.284881178051852x&#34;"><pre><code>&#34;gpt-4 faster than exonerate by 5.284881178051852x&#34;
</code></pre></div>
<p dir="auto">but, given a longer list, we see that exonerate will win out.</p>
<div dir="auto" data-snippet-clipboard-copy-content="input = List.duplicate(1, 1000)
ExonerateBenchmarks.compare(:&#34;uniqueItems-uniqueItems validation&#34;, input)"><pre><span>input</span> <span>=</span> <span>List</span><span>.</span><span>duplicate</span><span>(</span><span>1</span><span>,</span> <span>1000</span><span>)</span>
<span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span><span>:&#34;uniqueItems-uniqueItems validation&#34;</span><span>,</span> <span>input</span><span>)</span></pre></div>
<div data-snippet-clipboard-copy-content="&#34;exonerate faster than gpt-4 by 8.93731926728509x&#34;"><pre><code>&#34;exonerate faster than gpt-4 by 8.93731926728509x&#34;
</code></pre></div>
<p dir="auto">we can run different length sizes in both the best-case and worst-case scenarios and see where
the performance crosses over.</p>
<div dir="auto" data-snippet-clipboard-copy-content="list_lengths = [1, 3, 10, 30, 100, 300, 1000]

worst_case =
  Enum.map(
    list_lengths,
    &amp;ExonerateBenchmarks.compare(:&#34;uniqueItems-uniqueItems validation&#34;, Enum.to_list(1..&amp;1), true)
  )

best_case =
  Enum.map(
    list_lengths,
    &amp;ExonerateBenchmarks.compare(
      :&#34;uniqueItems-uniqueItems validation&#34;,
      List.duplicate(1, &amp;1),
      true
    )
  )

tabularized =
  worst_case
  |&gt; Enum.zip(best_case)
  |&gt; Enum.zip(list_lengths)
  |&gt; Enum.flat_map(fn {{worst, best}, list_length} -&gt;
    [
      %{
        relative: :math.log10(worst),
        length: :math.log10(list_length),
        label: list_length,
        group: :worst
      },
      %{
        relative: :math.log10(best),
        length: :math.log10(list_length),
        label: list_length,
        group: :best
      }
    ]
  end)

VegaLite.new(width: 500)
|&gt; VegaLite.data_from_values(tabularized)
|&gt; VegaLite.mark(:circle)
|&gt; VegaLite.encode_field(:x, &#34;length&#34;, type: :quantitative, title: &#34;log_10(list_length)&#34;)
|&gt; VegaLite.encode_field(:y, &#34;relative&#34;,
  type: :quantitative,
  title: &#34;log_10(exonerate_ips/gpt_ips)&#34;
)
|&gt; VegaLite.encode_field(:color, &#34;group&#34;)"><pre><span>list_lengths</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>3</span><span>,</span> <span>10</span><span>,</span> <span>30</span><span>,</span> <span>100</span><span>,</span> <span>300</span><span>,</span> <span>1000</span><span>]</span>

<span>worst_case</span> <span>=</span>
  <span>Enum</span><span>.</span><span>map</span><span>(</span>
    <span>list_lengths</span><span>,</span>
    <span>&amp;</span><span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span><span>:&#34;uniqueItems-uniqueItems validation&#34;</span><span>,</span> <span>Enum</span><span>.</span><span>to_list</span><span>(</span><span>1</span><span>..</span><span>&amp;</span><span>1</span><span>)</span><span>,</span> <span>true</span><span>)</span>
  <span>)</span>

<span>best_case</span> <span>=</span>
  <span>Enum</span><span>.</span><span>map</span><span>(</span>
    <span>list_lengths</span><span>,</span>
    <span>&amp;</span><span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span>
      <span>:&#34;uniqueItems-uniqueItems validation&#34;</span><span>,</span>
      <span>List</span><span>.</span><span>duplicate</span><span>(</span><span>1</span><span>,</span> <span>&amp;</span><span>1</span><span>)</span><span>,</span>
      <span>true</span>
    <span>)</span>
  <span>)</span>

<span>tabularized</span> <span>=</span>
  <span>worst_case</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>zip</span><span>(</span><span>best_case</span><span>)</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>zip</span><span>(</span><span>list_lengths</span><span>)</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>flat_map</span><span>(</span><span>fn</span> <span>{</span><span>{</span><span>worst</span><span>,</span> <span>best</span><span>}</span><span>,</span> <span>list_length</span><span>}</span> <span>-&gt;</span>
    <span>[</span>
      <span>%</span><span>{</span>
        <span>relative: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>worst</span><span>)</span><span>,</span>
        <span>length: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>list_length</span><span>)</span><span>,</span>
        <span>label: </span><span>list_length</span><span>,</span>
        <span>group: </span><span>:worst</span>
      <span>}</span><span>,</span>
      <span>%</span><span>{</span>
        <span>relative: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>best</span><span>)</span><span>,</span>
        <span>length: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>list_length</span><span>)</span><span>,</span>
        <span>label: </span><span>list_length</span><span>,</span>
        <span>group: </span><span>:best</span>
      <span>}</span>
    <span>]</span>
  <span>end</span><span>)</span>

<span>VegaLite</span><span>.</span><span>new</span><span>(</span><span>width: </span><span>500</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>data_from_values</span><span>(</span><span>tabularized</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>mark</span><span>(</span><span>:circle</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:x</span><span>,</span> <span>&#34;length&#34;</span><span>,</span> <span>type: </span><span>:quantitative</span><span>,</span> <span>title: </span><span>&#34;log_10(list_length)&#34;</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:y</span><span>,</span> <span>&#34;relative&#34;</span><span>,</span>
  <span>type: </span><span>:quantitative</span><span>,</span>
  <span>title: </span><span>&#34;log_10(exonerate_ips/gpt_ips)&#34;</span>
<span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:color</span><span>,</span> <span>&#34;group&#34;</span><span>)</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://reserialised.routley.io/E-xyza/Exonerate/blob/master/bench/reports/uniqueItems-perf.svg"><img src="https://reserialised.routley.io/E-xyza/Exonerate/raw/master/bench/reports/uniqueItems-perf.svg" alt=""/></a></p>
<p dir="auto">In the worst case scenario for Exonerate, we see that the relative speeds stay about the same:
This makes sense, as both processes are O(N) in the size of the list, and the Exonerate overhead
is the same per function instance, even if GPT-4 actually traverses the list more times.</p>
<p dir="auto">In the best case scenario, the crossover occurs at around 80 items in the list.  This isn&#39;t
terribly good, but a 3x slower for a 100ns function call isn&#39;t the end of the world.
Let&#39;s take a look at another example.</p>
<div dir="auto" data-snippet-clipboard-copy-content="{
    &#34;type&#34;: &#34;object&#34;,
    &#34;oneOf&#34;: [
        { &#34;required&#34;: [&#34;foo&#34;, &#34;bar&#34;] },
        { &#34;required&#34;: [&#34;foo&#34;, &#34;baz&#34;] }
    ]
}"><pre>{
    <span>&#34;type&#34;</span>: <span><span>&#34;</span>object<span>&#34;</span></span>,
    <span>&#34;oneOf&#34;</span>: [
        { <span>&#34;required&#34;</span>: [<span><span>&#34;</span>foo<span>&#34;</span></span>, <span><span>&#34;</span>bar<span>&#34;</span></span>] },
        { <span>&#34;required&#34;</span>: [<span><span>&#34;</span>foo<span>&#34;</span></span>, <span><span>&#34;</span>baz<span>&#34;</span></span>] }
    ]
}</pre></div>
<p dir="auto">Here is the function that GPT-4 generates:</p>

<div dir="auto" data-snippet-clipboard-copy-content="def validate(object) when is_map(object) do
  case Enum.count([&#34;foo&#34;, &#34;bar&#34;] -- Map.keys(object)) do
    0 -&gt; :ok
    _ -&gt; case Enum.count([&#34;foo&#34;, &#34;baz&#34;] -- Map.keys(object)) do
      0 -&gt; :ok
      _ -&gt; :error
    end
  end
end"><pre><span>def</span> <span>validate</span><span>(</span><span>object</span><span>)</span> <span>when</span> <span>is_map</span><span>(</span><span>object</span><span>)</span> <span>do</span>
  <span>case</span> <span>Enum</span><span>.</span><span>count</span><span>(</span><span>[</span><span>&#34;foo&#34;</span><span>,</span> <span>&#34;bar&#34;</span><span>]</span> <span>--</span> <span>Map</span><span>.</span><span>keys</span><span>(</span><span>object</span><span>)</span><span>)</span> <span>do</span>
    <span>0</span> <span>-&gt;</span> <span>:ok</span>
    <span>_</span> <span>-&gt;</span> <span>case</span> <span>Enum</span><span>.</span><span>count</span><span>(</span><span>[</span><span>&#34;foo&#34;</span><span>,</span> <span>&#34;baz&#34;</span><span>]</span> <span>--</span> <span>Map</span><span>.</span><span>keys</span><span>(</span><span>object</span><span>)</span><span>)</span> <span>do</span>
      <span>0</span> <span>-&gt;</span> <span>:ok</span>
      <span>_</span> <span>-&gt;</span> <span>:error</span>
    <span>end</span>
  <span>end</span>
<span>end</span></pre></div>
<p dir="auto">This too is O(N) in the size of the object, whereas the code generated by exonerate is O(1).
Checking to see if a constant set of items are keys in the object should be a fixed-time
process.</p>
<p dir="auto">In the next cell, we&#39;ll test several different inputs, maps with &#34;foo&#34; and &#34;bar&#34; keys, as well
as maps with &#34;bar&#34; and &#34;baz&#34; keys, and maps that only have &#34;foo&#34; keys.  To expand the size of
the map, we&#39;ll add string number keys.  All keys will have to the string &#34;foo&#34; as values. Note
that the GPT-4 code doesn&#39;t address a map with &#34;foo&#34;, &#34;bar&#34;, and &#34;baz&#34; keys, which should be
rejected.  We expect to see performance regressions that are worse for the case without &#34;baz&#34;
because these cases will run through the size of the map twice.</p>
<div dir="auto" data-snippet-clipboard-copy-content="with_bar =
  Enum.map(
    list_lengths,
    fn list_length -&gt;
      input = Map.new([&#34;foo&#34;, &#34;bar&#34;] ++ Enum.map(1..list_length, &amp;&#34;#{&amp;1}&#34;), &amp;{&amp;1, &#34;foo&#34;})

      ExonerateBenchmarks.compare(
        :&#34;oneOf-oneOf with required&#34;,
        input,
        true
      )
    end
  )

with_baz =
  Enum.map(
    list_lengths,
    fn list_length -&gt;
      input = Map.new([&#34;foo&#34;, &#34;baz&#34;] ++ Enum.map(1..list_length, &amp;&#34;#{&amp;1}&#34;), &amp;{&amp;1, &#34;foo&#34;})

      ExonerateBenchmarks.compare(
        :&#34;oneOf-oneOf with required&#34;,
        input,
        true
      )
    end
  )

with_none =
  Enum.map(
    list_lengths,
    fn list_length -&gt;
      input = Map.new([&#34;foo&#34;, &#34;baz&#34;] ++ Enum.map(1..list_length, &amp;&#34;#{&amp;1}&#34;), &amp;{&amp;1, &#34;foo&#34;})

      ExonerateBenchmarks.compare(
        :&#34;oneOf-oneOf with required&#34;,
        input,
        true
      )
    end
  )

tabularized =
  with_bar
  |&gt; Enum.zip(with_baz)
  |&gt; Enum.zip(with_none)
  |&gt; Enum.zip(list_lengths)
  |&gt; Enum.flat_map(fn {{{bar, baz}, none}, list_length} -&gt;
    [
      %{
        relative: :math.log10(bar),
        length: :math.log10(list_length),
        label: list_length,
        group: :bar
      },
      %{
        relative: :math.log10(baz),
        length: :math.log10(list_length),
        label: list_length,
        group: :baz
      },
      %{
        relative: :math.log10(none),
        length: :math.log10(list_length),
        label: list_length,
        group: :none
      }
    ]
  end)

VegaLite.new(width: 500)
|&gt; VegaLite.data_from_values(tabularized)
|&gt; VegaLite.mark(:circle)
|&gt; VegaLite.encode_field(:x, &#34;length&#34;, type: :quantitative, title: &#34;log_10(list_length)&#34;)
|&gt; VegaLite.encode_field(:y, &#34;relative&#34;,
  type: :quantitative,
  title: &#34;log_10(exonerate_ips/gpt_ips)&#34;
)
|&gt; VegaLite.encode_field(:color, &#34;group&#34;)"><pre><span>with_bar</span> <span>=</span>
  <span>Enum</span><span>.</span><span>map</span><span>(</span>
    <span>list_lengths</span><span>,</span>
    <span>fn</span> <span>list_length</span> <span>-&gt;</span>
      <span>input</span> <span>=</span> <span>Map</span><span>.</span><span>new</span><span>(</span><span>[</span><span>&#34;foo&#34;</span><span>,</span> <span>&#34;bar&#34;</span><span>]</span> <span>++</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>1</span><span>..</span><span>list_length</span><span>,</span> <span>&amp;</span><span>&#34;<span><span>#{</span><span>&amp;</span><span>1</span><span>}</span></span>&#34;</span><span>)</span><span>,</span> <span>&amp;</span><span>{</span><span>&amp;</span><span>1</span><span>,</span> <span>&#34;foo&#34;</span><span>}</span><span>)</span>

      <span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span>
        <span>:&#34;oneOf-oneOf with required&#34;</span><span>,</span>
        <span>input</span><span>,</span>
        <span>true</span>
      <span>)</span>
    <span>end</span>
  <span>)</span>

<span>with_baz</span> <span>=</span>
  <span>Enum</span><span>.</span><span>map</span><span>(</span>
    <span>list_lengths</span><span>,</span>
    <span>fn</span> <span>list_length</span> <span>-&gt;</span>
      <span>input</span> <span>=</span> <span>Map</span><span>.</span><span>new</span><span>(</span><span>[</span><span>&#34;foo&#34;</span><span>,</span> <span>&#34;baz&#34;</span><span>]</span> <span>++</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>1</span><span>..</span><span>list_length</span><span>,</span> <span>&amp;</span><span>&#34;<span><span>#{</span><span>&amp;</span><span>1</span><span>}</span></span>&#34;</span><span>)</span><span>,</span> <span>&amp;</span><span>{</span><span>&amp;</span><span>1</span><span>,</span> <span>&#34;foo&#34;</span><span>}</span><span>)</span>

      <span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span>
        <span>:&#34;oneOf-oneOf with required&#34;</span><span>,</span>
        <span>input</span><span>,</span>
        <span>true</span>
      <span>)</span>
    <span>end</span>
  <span>)</span>

<span>with_none</span> <span>=</span>
  <span>Enum</span><span>.</span><span>map</span><span>(</span>
    <span>list_lengths</span><span>,</span>
    <span>fn</span> <span>list_length</span> <span>-&gt;</span>
      <span>input</span> <span>=</span> <span>Map</span><span>.</span><span>new</span><span>(</span><span>[</span><span>&#34;foo&#34;</span><span>,</span> <span>&#34;baz&#34;</span><span>]</span> <span>++</span> <span>Enum</span><span>.</span><span>map</span><span>(</span><span>1</span><span>..</span><span>list_length</span><span>,</span> <span>&amp;</span><span>&#34;<span><span>#{</span><span>&amp;</span><span>1</span><span>}</span></span>&#34;</span><span>)</span><span>,</span> <span>&amp;</span><span>{</span><span>&amp;</span><span>1</span><span>,</span> <span>&#34;foo&#34;</span><span>}</span><span>)</span>

      <span>ExonerateBenchmarks</span><span>.</span><span>compare</span><span>(</span>
        <span>:&#34;oneOf-oneOf with required&#34;</span><span>,</span>
        <span>input</span><span>,</span>
        <span>true</span>
      <span>)</span>
    <span>end</span>
  <span>)</span>

<span>tabularized</span> <span>=</span>
  <span>with_bar</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>zip</span><span>(</span><span>with_baz</span><span>)</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>zip</span><span>(</span><span>with_none</span><span>)</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>zip</span><span>(</span><span>list_lengths</span><span>)</span>
  <span>|&gt;</span> <span>Enum</span><span>.</span><span>flat_map</span><span>(</span><span>fn</span> <span>{</span><span>{</span><span>{</span><span>bar</span><span>,</span> <span>baz</span><span>}</span><span>,</span> <span>none</span><span>}</span><span>,</span> <span>list_length</span><span>}</span> <span>-&gt;</span>
    <span>[</span>
      <span>%</span><span>{</span>
        <span>relative: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>bar</span><span>)</span><span>,</span>
        <span>length: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>list_length</span><span>)</span><span>,</span>
        <span>label: </span><span>list_length</span><span>,</span>
        <span>group: </span><span>:bar</span>
      <span>}</span><span>,</span>
      <span>%</span><span>{</span>
        <span>relative: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>baz</span><span>)</span><span>,</span>
        <span>length: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>list_length</span><span>)</span><span>,</span>
        <span>label: </span><span>list_length</span><span>,</span>
        <span>group: </span><span>:baz</span>
      <span>}</span><span>,</span>
      <span>%</span><span>{</span>
        <span>relative: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>none</span><span>)</span><span>,</span>
        <span>length: </span><span>:math</span><span>.</span><span>log10</span><span>(</span><span>list_length</span><span>)</span><span>,</span>
        <span>label: </span><span>list_length</span><span>,</span>
        <span>group: </span><span>:none</span>
      <span>}</span>
    <span>]</span>
  <span>end</span><span>)</span>

<span>VegaLite</span><span>.</span><span>new</span><span>(</span><span>width: </span><span>500</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>data_from_values</span><span>(</span><span>tabularized</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>mark</span><span>(</span><span>:circle</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:x</span><span>,</span> <span>&#34;length&#34;</span><span>,</span> <span>type: </span><span>:quantitative</span><span>,</span> <span>title: </span><span>&#34;log_10(list_length)&#34;</span><span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:y</span><span>,</span> <span>&#34;relative&#34;</span><span>,</span>
  <span>type: </span><span>:quantitative</span><span>,</span>
  <span>title: </span><span>&#34;log_10(exonerate_ips/gpt_ips)&#34;</span>
<span>)</span>
<span>|&gt;</span> <span>VegaLite</span><span>.</span><span>encode_field</span><span>(</span><span>:color</span><span>,</span> <span>&#34;group&#34;</span><span>)</span></pre></div>
<p dir="auto"><a target="_blank" rel="noopener noreferrer" href="https://reserialised.routley.io/E-xyza/Exonerate/blob/master/bench/reports/oneOf-perf.svg"><img src="https://reserialised.routley.io/E-xyza/Exonerate/raw/master/bench/reports/oneOf-perf.svg" alt=""/></a></p>
<p dir="auto">Indeed, we see exactly the relationship we expect:  maps with &#34;foo/baz&#34; and &#34;foo/none&#34; have a
more dramatic performance improvement over maps with &#34;foo/bar&#34;.  Moreover, we see a &#34;kink&#34; in
the performance regression around N=30.  This is likely because in the BEAM virtual machine,
under the hood maps switch from a linked list implementation (with O(N) worst case search) to a
hashmap implementation at N=32.</p>
<h2 dir="auto"><a id="user-content-conclusions" aria-hidden="true" href="#conclusions"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Conclusions</h2>
<p dir="auto">So, should you use GPT to generate your OpenAPI validations?  Probably not... yet</p>
<p dir="auto">GPT-3.5 (and even better, GPT-4) are very impressive at generating correct validations for
OpenAPI schemas in Elixir.  The most common systematic errors (e.g. not being sure whether to
use atoms or strings) are easily addressable using prompt engineering.  However, the
GPT-generated is <em>not quite right</em> in many cases and sometimes it dangerously misunderstands
(see Semantic Misunderstanding).</p>
<p dir="auto">Although indeed GPT appears to be able to perform compiler optimizations that generate highly
efficient code, this code is not composable, and the attention of the current state of the art
LLM models may not scale to more complex schemas.  In the small, GPT makes performance errors
that are likely due to its lack of understanding of the VM architecture; without repeating this
experiment in other languages, though, I can&#39;t be certain.  In some sense it&#39;s a pity that LLMs
are overwhelmingly trained on languages like javascript, python, ruby, C#, etc. because due to
the limitations of LLM attention, the safety of LLMs as coding copilots is better for languages
where higher order structures (arrays, dicts) are not mutable across function calls.</p>
<p dir="auto">The use case for autogenerating JSONSchema code in GPT is likely to be a developer with low
experience in JSONSchema and/or low experience in Elixir.  Accordingly, a one-shot usecase
model (like what is tested here) is representative of how some may want
to use GPT.  Because using GPT to generate validation should probably involve the review by
someone who is experienced in Elixir AND JSONSchema, for these practicioners, using GPT in
lieu of the compiler is still generally not a good idea.  Interestingly, since GPT-4&#39;s API
plugin architecture understands OpenAPI (and thus JSONSchema) one wonders if some data
marshalling/unmarshalling errors exist its interfaces.  I&#39;m looking forward to repeating this
experiment with GPT-6, and maybe GPT-7 will be able to generate an JSONSchema compiler and
replace this library altogether.</p>

</article>
  </div>

    </div>

  </div></div>
  </body>
</html>
