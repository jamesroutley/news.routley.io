<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://halb.it/posts/ebpf-fingerprinting-1/">Original</a>
    <h1>Implementing fast TCP fingerprinting with eBPF</h1>
    
    <div id="readability-page-1" class="page"><div data-astro-cid-27g4gyeh="">  <article data-astro-cid-xj2uyz6m=""> <div data-astro-cid-xj2uyz6m=""> <header data-astro-cid-xj2uyz6m="">  <p>
Written

on <time data-astro-cid-xj2uyz6m="">Jun 1, 2025</time> </p>    </header> <section data-astro-cid-xj2uyz6m="">  <p>In this article I want to document my journey implementing fast TCP fingerprinting
in a golang webserver, using eBPF.</p>
<p>Just to provide some background, TCP fingerprinting is one of the many techniques that can be used to detect
unusual or identifying informations about a web request when implementing an anti-bot solution.</p>
<p>I split this article in two parts.</p>
<ul>
<li>In this first part I provide a background on TCP fingerprinting, and discuss some implementation strategies.</li>
<li>In the <a href="https://halb.it/posts/ebpf-fingerprinting-2/">second part</a> I describe the actual development
of a proof-of-concept Golang webserver that echoes back the TCP fingerprint of the client.
The project is <a href="https://github.com/robalb/ebpf-web-fingerprint/tree/main">open source on Github</a></li>
</ul>
<h3 id="http-requests-from-first-principles">HTTP requests, from first principles</h3>
<p>It can be useful to approach this problem from first principles, looking at the way web servers work under the hood.</p>
<p>This is not as scary as it might seem: although browsers and the underlying protocols evolved and got <a href="https://en.wikipedia.org/wiki/HTTP/3">more complex</a> over time, for
compatibility reasons they
still support the HTTP/1.0 protocol, which was <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Evolution_of_HTTP">designed to be simple</a>.
An HTTP/1.0 web server is just a light layer on top of a TCP connection, and can be implemented in just a few lines of C code.</p>
<p>As an example, I implemented a simple hello world webserver in C that we’ll use as
a starting point for the experiments in this article.
You don’t really have to read the code for now, but keep in mind that it’s here:</p>
<pre><code is:raw=""><span><span>#</span><span>include</span> <span>&lt;netinet/in.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;stdio.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;stdlib.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;string.h&gt;</span></span>
<span><span>#</span><span>include</span> <span>&lt;unistd.h&gt;</span></span>

<span><span>#</span><span>define</span> <span>PORT</span> <span><span>8080</span></span></span>

<span>int</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  
  <span>int</span> server_fd <span>=</span> <span>socket</span><span>(</span>AF_INET<span>,</span> SOCK_STREAM<span>,</span> <span>0</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span>server_fd <span>==</span> <span>0</span><span>)</span> <span>{</span>
    <span>perror</span><span>(</span><span>&#34;socket failed&#34;</span><span>)</span><span>;</span>
    <span>exit</span><span>(</span>EXIT_FAILURE<span>)</span><span>;</span>
  <span>}</span>

  
  <span>struct</span> <span>sockaddr_in</span> address <span>=</span> <span>{</span>
        <span>.</span>sin_family <span>=</span> AF_INET<span>,</span>
        <span>.</span>sin_addr<span>.</span>s_addr <span>=</span> INADDR_ANY<span>,</span>
        <span>.</span>sin_port <span>=</span> <span>htons</span><span>(</span>PORT<span>)</span>
    <span>}</span><span>;</span>
  <span>socklen_t</span> address_length <span>=</span> <span>sizeof</span><span>(</span>address<span>)</span><span>;</span>
  <span>struct</span> <span>sockaddr</span> <span>*</span>address_pointer <span>=</span> <span>(</span><span>struct</span> <span>sockaddr</span> <span>*</span><span>)</span><span>&amp;</span>address<span>;</span>

  
  <span>if</span> <span>(</span><span>bind</span><span>(</span>server_fd<span>,</span> address_pointer<span>,</span> address_length<span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>perror</span><span>(</span><span>&#34;bind failed&#34;</span><span>)</span><span>;</span>
    <span>exit</span><span>(</span>EXIT_FAILURE<span>)</span><span>;</span>
  <span>}</span>

  
  <span>if</span> <span>(</span><span>listen</span><span>(</span>server_fd<span>,</span> <span>1</span><span>)</span> <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
    <span>perror</span><span>(</span><span>&#34;listen failed&#34;</span><span>)</span><span>;</span>
    <span>exit</span><span>(</span>EXIT_FAILURE<span>)</span><span>;</span>
  <span>}</span>

  <span>printf</span><span>(</span><span>&#34;Server listening on port %d...\n&#34;</span><span>,</span> PORT<span>)</span><span>;</span>

  <span>while</span> <span>(</span><span>1</span><span>)</span> <span>{</span>
    
    <span>int</span> new_socket <span>=</span> <span>accept</span><span>(</span>server_fd<span>,</span> address_pointer<span>,</span> <span>&amp;</span>address_length<span>)</span><span>;</span>
    <span>if</span> <span>(</span>new_socket <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
      <span>perror</span><span>(</span><span>&#34;accept failed&#34;</span><span>)</span><span>;</span>
      <span>exit</span><span>(</span>EXIT_FAILURE<span>)</span><span>;</span>
    <span>}</span>

    
    <span>const</span> <span>char</span> <span>*</span>response <span>=</span> <span>&#34;HTTP/1.0 200 OK\r\n&#34;</span>
                           <span>&#34;Content-Type: text/plain\r\n&#34;</span>
                           <span>&#34;Content-Length: 12\r\n&#34;</span>
                           <span>&#34;\r\n&#34;</span>
                           <span>&#34;Hello world &#34;</span><span>;</span>

    <span>send</span><span>(</span>new_socket<span>,</span> response<span>,</span> <span>strlen</span><span>(</span>response<span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span>

    
    <span>close</span><span>(</span>new_socket<span>)</span><span>;</span>
  <span>}</span>

  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre>
<p>This is certainly not a production ready webserver, but it does its job.
If we compile the code, run it, and visit <code>http://127.0.0.1:8080</code>
from any modern browser, we’ll be greeted by a hello world:</p>
<picture><img src="https://halb.it/_astro/ebpf-fingerprint-browser1.CGjHcDk9.png" height="490" width="627" alt=""/></picture>
</section> </div> </article>   </div></div>
  </body>
</html>
