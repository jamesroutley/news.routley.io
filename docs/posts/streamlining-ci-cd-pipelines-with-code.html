<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.matiaspan.dev/posts/exploring-dagger-streamlining-ci-cd-pipelines-with-code/">Original</a>
    <h1>Streamlining CI/CD Pipelines with Code</h1>
    
    <div id="readability-page-1" class="page"><div><p>This is the second post in a <a href="https://blog.matiaspan.dev/tags/exploring-dagger/">series of blog posts</a> that look at Dagger from different perspectives. In this post we do a deep dive on how to leverage Dagger as a developer that is tasked with implementing the CI process of a Java-Gradle service. In this CI process we need to: build, run integration tests with external dependencies and package the service. We will leave the CD part for a future blog post that looks at Dagger from the perspective of a Platform Engineer/SRE. We are going to build this with traditional tools like docker-compose and with Dagger modules and then compare the two approaches.</p><p><strong>NOTE</strong>: Dagger is in very active development so by the time you read this blog post some things might have changed.</p><h2 id="background">Background</h2><p>We suddenly land on a team that is the owner of a Spring-Boot service that uses gradle as its build tool and we are tasked to build the CI process for this service. The first we think about when we look at this codebase is that we should rewrite it in Go. But we are going to decide to push that thought aside for a bit and be productive 🤵. This service is part of an E-Commerce system and is used primarily for filtering orders that are stored inside a MySQL database. It exposes one important endpoint that accepts a list of filters and returns the orders that match those filters. For example:</p><div><pre tabindex="0"><code data-lang="json"><span><span><span>GET</span> <span>/orders?page=</span><span>1</span><span>&amp;status=open&amp;shipping_method=</span><span>43123</span>
</span></span><span><span><span>{</span>
</span></span><span><span>    <span>&#34;orders&#34;</span><span>:</span> <span>[</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>&#34;id&#34;</span><span>:</span> <span>1234</span><span>,</span>
</span></span><span><span>            <span>&#34;status&#34;</span><span>:</span> <span>&#34;open&#34;</span><span>,</span>
</span></span><span><span>            <span>&#34;shipping_method&#34;</span><span>:</span> <span>43123</span><span>,</span>
</span></span><span><span>            <span>&#34;payment_status&#34;</span><span>:</span> <span>&#34;pending&#34;</span><span>,</span>
</span></span><span><span>            <span>&#34;fulfillment_status&#34;</span><span>:</span> <span>&#34;unfulfilled&#34;</span>
</span></span><span><span>        <span>},</span>
</span></span><span><span>        <span>{</span>
</span></span><span><span>            <span>&#34;id&#34;</span><span>:</span> <span>1235</span><span>,</span>
</span></span><span><span>            <span>&#34;status&#34;</span><span>:</span> <span>&#34;open&#34;</span><span>,</span>
</span></span><span><span>            <span>&#34;shipping_method&#34;</span><span>:</span> <span>43123</span><span>,</span>
</span></span><span><span>            <span>&#34;payment_status&#34;</span><span>:</span> <span>&#34;paid&#34;</span><span>,</span>
</span></span><span><span>            <span>&#34;fulfillment_status&#34;</span><span>:</span> <span>&#34;fulfilled&#34;</span>
</span></span><span><span>        <span>}</span>
</span></span><span><span>    <span>]</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>The service has not yet reached production but we know this endpoint will be very critical. It has to be consistent, meaning that if I specify <code>status=open</code> as a filter, it should only return orders that match that status. If we break this constraint we are going to be in big trouble. To guarantee that we never merge or deploy code that breaks this constraint we decide is best to build a few black-box integration tests that validate the behavior of the entire system. We are going to start our service and its dependencies and execute a program that makes HTTP requests with different filters and validates that the responses match what we expect. We want developers to be able to run this tests locally but we also want to make them a hard constraint on our CI, so we need to run them there as well. For the sake of keeping this blog post focused on the CI part, I’ll share just a snippet of what this integration tests look like. In our repository we created a <code>tests</code> folder and wrote a <code>main.go</code> file that does what we just mentioned. Here is a snippet of what this program looks like:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>var</span> <span>endpoint</span> <span>=</span> <span>flag</span><span>.</span><span>String</span><span>(</span><span>&#34;endpoint&#34;</span><span>,</span> <span>&#34;localhost:8080&#34;</span><span>,</span> <span>&#34;service endpoint&#34;</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>main</span><span>()</span> <span>{</span>
</span></span><span><span>	<span>flag</span><span>.</span><span>Parse</span><span>()</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>:=</span> <span>OrdersList</span><span>(</span><span>*</span><span>endpoint</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>log</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;tests failed: %s&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>OrdersList</span><span>(</span><span>endpoint</span> <span>string</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>tests</span> <span>:=</span> <span>[]</span><span>struct</span> <span>{</span>
</span></span><span><span>		<span>name</span>    <span>string</span>
</span></span><span><span>		<span>filters</span> <span>Filters</span>
</span></span><span><span>	<span>}{</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>name</span><span>:</span> <span>&#34;open&#34;</span><span>,</span>
</span></span><span><span>			<span>filters</span><span>:</span> <span>Filters</span><span>{</span>
</span></span><span><span>				<span>Status</span><span>:</span> <span>OrderStatusOpen</span><span>,</span>
</span></span><span><span>			<span>},</span>
</span></span><span><span>		<span>},</span>
</span></span><span><span>		<span>{</span>
</span></span><span><span>			<span>name</span><span>:</span> <span>&#34;open paid&#34;</span><span>,</span>
</span></span><span><span>			<span>filters</span><span>:</span> <span>Filters</span><span>{</span>
</span></span><span><span>				<span>Status</span><span>:</span>        <span>OrderStatusOpen</span><span>,</span>
</span></span><span><span>				<span>PaymentStatus</span><span>:</span> <span>PaymentStatusPaid</span><span>,</span>
</span></span><span><span>			<span>},</span>
</span></span><span><span>		<span>},</span>
</span></span><span><span>		<span>// more test cases
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>errs</span> <span>:=</span> <span>[]</span><span>error</span><span>{}</span>
</span></span><span><span>	<span>for</span> <span>_</span><span>,</span> <span>test</span> <span>:=</span> <span>range</span> <span>tests</span> <span>{</span>
</span></span><span><span>		<span>name</span> <span>:=</span> <span>test</span><span>.</span><span>name</span>
</span></span><span><span>		<span>filters</span> <span>:=</span> <span>test</span><span>.</span><span>filters</span>
</span></span><span><span>
</span></span><span><span>		<span>// create HTTP request and send it using Go&#39;s standard library
</span></span></span><span><span><span></span>
</span></span><span><span>		<span>// validate the response
</span></span></span><span><span><span></span>		<span>if</span> <span>err</span> <span>=</span> <span>validateResponse</span><span>(</span><span>filters</span><span>,</span> <span>response</span><span>.</span><span>Orders</span><span>);</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>			<span>errs</span> <span>=</span> <span>append</span><span>(</span><span>errs</span><span>,</span> <span>testErr</span><span>(</span><span>name</span><span>,</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;response for filters is invalid: %v.\n\tResponse: %+v\n\tFilters: %+v&#34;</span><span>,</span> <span>err</span><span>,</span> <span>response</span><span>.</span><span>Orders</span><span>,</span> <span>filters</span><span>)))</span>
</span></span><span><span>			<span>continue</span>
</span></span><span><span>		<span>}</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>if</span> <span>len</span><span>(</span><span>errs</span><span>)</span> <span>==</span> <span>0</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>nil</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>rerr</span> <span>:=</span> <span>errors</span><span>.</span><span>New</span><span>(</span><span>&#34;tests have failed&#34;</span><span>)</span>
</span></span><span><span>	<span>for</span> <span>_</span><span>,</span> <span>err</span> <span>:=</span> <span>range</span> <span>errs</span> <span>{</span>
</span></span><span><span>		<span>rerr</span> <span>=</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;%s\n\t%s&#34;</span><span>,</span> <span>rerr</span><span>,</span> <span>err</span><span>.</span><span>Error</span><span>())</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>return</span> <span>rerr</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>testErr</span><span>(</span><span>name</span> <span>string</span><span>,</span> <span>err</span> <span>error</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>fmt</span><span>.</span><span>Errorf</span><span>(</span><span>&#34;❌ test %s failed. Error: %w&#34;</span><span>,</span> <span>name</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>validateResponse</span><span>(</span><span>filters</span> <span>Filters</span><span>,</span> <span>orders</span> <span>[]</span><span>*</span><span>Order</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>for</span> <span>_</span><span>,</span> <span>order</span> <span>:=</span> <span>range</span> <span>orders</span> <span>{</span>
</span></span><span><span>		<span>// validate that the orders respect the filters that were specified
</span></span></span><span><span><span></span>        <span>// if it is not the case then we return an error
</span></span></span><span><span><span></span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>nil</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>With this program developers can start their local environment and run <code>go run ./tests/main.go -endpoint=localhost:&lt;PORT&gt;</code>.</p><p>In summary, we want to build a reproducible way to:</p><ul><li>build and package our service</li><li>run unit tests</li><li>run integration tests that require the service and its dependencies to be running</li></ul><p>So that we can then build a CI process that integrates all of it.</p><h2 id="using-docker-and-docker-compose">Using docker and docker-compose</h2><p>Let’s start building this using the tools you are probably already familiar with: docker and docker-compose. To build and package our service we first write a Dockerfile that:</p><ul><li>Starts from an image with the Java version we require already installed.</li><li>Copies all of our required files and folders.</li><li>Performs a gradle build using the gradle wrapper.</li><li>Starts a new stage from an image with Java installed.</li><li>Installs critical dependencies that are often used to troubleshoot.</li><li>Copies over the .jar generated in the previous stage.</li><li>Defines a command for running the service.</li></ul><div><pre tabindex="0"><code data-lang="dockerfile"><span><span><span>FROM</span><span> amazoncorretto:21.0.1-alpine3.18 AS base</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>WORKDIR</span><span> /app</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>COPY</span> src src<span>
</span></span></span><span><span><span></span><span>COPY</span> gradlew gradlew<span>
</span></span></span><span><span><span></span><span>COPY</span> gradle gradle<span>
</span></span></span><span><span><span></span><span>COPY</span> build.gradle.kts build.gradle.kts<span>
</span></span></span><span><span><span></span><span>COPY</span> settings.gradle.kts settings.gradle.kts<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> base AS build</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>RUN</span> <span>[</span><span>&#34;./gradlew&#34;</span>, <span>&#34;clean&#34;</span>, <span>&#34;build&#34;</span>, <span>&#34;--no-daemon&#34;</span><span>]</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>FROM</span><span> amazoncorretto:21.0.1-alpine3.18 AS runtime</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>RUN</span> apk update <span>&amp;&amp;</span> apk --no-cache add ca-certificates curl tcpdump procps bind-tools<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>RUN</span> mkdir -p /var/log/spring<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>WORKDIR</span><span> /app</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>COPY</span> --from<span>=</span>build /app/build/libs/gradle-service-0.0.1-SNAPSHOT.jar app.jar<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>ENV</span> <span>APP_PROFILE</span><span>=</span><span>&#34;default&#34;</span><span>
</span></span></span><span><span><span></span><span>ENV</span> <span>JAVA_OPTS</span><span>=</span><span>&#34;&#34;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>CMD</span> java <span>$JAVA_OPTS</span> -jar app.jar --server.port<span>=</span><span>80</span> --spring.profiles.active<span>=</span><span>$APP_PROFILE</span><span>
</span></span></span></code></pre></div><p>In this Dockerfile we are leveraging Docker’s multi stage capabilities to reduce the final size of our image and only ship the things that we need.</p><p>With this defined developers can now build and run the service locally without having to install java, gradle and such:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>docker build -t gradle-service .
</span></span><span><span>docker run -p 8080:8080 -e <span>APP_PROFILE</span><span>=</span><span>local</span> gradle-service
</span></span></code></pre></div><p>How about running unit tests? Well, in our Dockerfile you probably saw that we first defined a stage called <code>base</code> were we mounted the code of our application. This was done to re-use the <code>Dockerfile</code> for running our unit tests. We can do this by leveraging BuildKit’s ability to target specific stages like so:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>docker build -t gradle-service-base --target base .
</span></span><span><span>docker run -e <span>APP_PROFILE</span><span>=</span><span>test</span> gradle-service-base ./gradlew clean <span>test</span>
</span></span></code></pre></div><p>With this approach we were able to containerize our build and test so that these processes run in the exact same way on all machines. Something I’ve seen quite frequently, specially in the Java ecosystem, is that developers usually run build and test commands in their CI workflows by re-using whatever abstraction the CI runtime provides. For example, in the case of Github workflows I’ve seen people often use the <a href="https://github.com/gradle/gradle-build-action">gradle action</a> to run gradle commands directly in their CI. What usually ends up happening is that the action sets things up in a different way and then tests end up failing in the CI but not in the local environment of the developer. Leaving people confused and forced to ignore the tests in that PR because who has time to debug the CI?</p><p>Now for the interesting part: integration tests. We mentioned previously that our service uses MySQL to store and retrieve the orders it is requested. To be able to run this integration tests we need to have MySQL running and the service connected to it. Since we want this to be reproducible and run in our CI as well we will leverage docker-compose:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span>version</span><span>:</span><span> </span><span>&#39;3.9&#39;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>services</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>mysql</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>image</span><span>:</span><span> </span><span>mysql:8.2.0</span><span>
</span></span></span><span><span><span>    </span><span>container_name</span><span>:</span><span> </span><span>mysql</span><span>
</span></span></span><span><span><span>    </span><span>environment</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>MYSQL_ROOT_PASSWORD=password</span><span>
</span></span></span><span><span><span>      </span>- <span>MYSQL_DATABASE=database</span><span>
</span></span></span><span><span><span>    </span><span>volumes</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>./db/db.sql:/docker-entrypoint-initdb.d/db.sql</span><span>
</span></span></span><span><span><span>    </span><span>ports</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>3306</span><span>:</span><span>3306</span><span>
</span></span></span><span><span><span>    </span><span>healthcheck</span><span>:</span><span>
</span></span></span><span><span><span>        </span><span>test</span><span>:</span><span> </span><span>[</span><span>&#34;CMD&#34;</span><span>,</span><span> </span><span>&#34;mysqladmin&#34;</span><span> </span><span>,</span><span>&#34;ping&#34;</span><span>,</span><span> </span><span>&#34;-h&#34;</span><span>,</span><span> </span><span>&#34;localhost&#34;</span><span>]</span><span>
</span></span></span><span><span><span>        </span><span>timeout</span><span>:</span><span> </span><span>5s</span><span>
</span></span></span><span><span><span>        </span><span>retries</span><span>:</span><span> </span><span>10</span><span>
</span></span></span><span><span><span>    </span><span>networks</span><span>:</span><span> </span><span>[</span><span>&#34;service&#34;</span><span>]</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span>  </span><span>service</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>build</span><span>:</span><span> </span><span>.</span><span>
</span></span></span><span><span><span>    </span><span>container_name</span><span>:</span><span> </span><span>service</span><span>
</span></span></span><span><span><span>    </span><span>environment</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>&#34;DB_HOST=mysql&#34;</span><span>
</span></span></span><span><span><span>      </span>- <span>&#34;DB_PORT=3306&#34;</span><span>
</span></span></span><span><span><span>      </span>- <span>&#34;APP_PROFILE=default&#34;</span><span>
</span></span></span><span><span><span>    </span><span>ports</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>8080</span><span>:</span><span>80</span><span>
</span></span></span><span><span><span>    </span><span>depends_on</span><span>:</span><span>
</span></span></span><span><span><span>      </span><span>mysql</span><span>:</span><span>
</span></span></span><span><span><span>        </span><span>condition</span><span>:</span><span> </span><span>service_healthy</span><span>
</span></span></span><span><span><span>    </span><span>links</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>&#34;mysql:mysql&#34;</span><span>
</span></span></span><span><span><span>    </span><span>networks</span><span>:</span><span> </span><span>[</span><span>&#34;service&#34;</span><span>]</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>networks</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>service</span><span>:</span><span>
</span></span></span></code></pre></div><p>Let’s quickly go over what this docker-compose file has:</p><ul><li>service: the definition of our service that will trigger a <code>build</code> when we run it (this is because we specified the <code>build: .</code> to docker-compose). We added a <code>depends_on</code> to MySQL with a <code>service_healthy</code> condition so that the service is only started once MySQL is up and accepting connections.</li><li>mysql: a service that runs a MySQL 8 server with an SQL file mounted to seed some data for our tests. We specified a <code>healthcheck</code> that uses <code>mysqladmin</code> so that the service connects to it only once MySQL is ready for connections.</li></ul><p>We can now start our services locally and in any other environment by running <code>docker-compose up</code>.</p><p>Time to add our integration tests. We also want these tests to be able to run in any host without requiring that host to have dependencies installed (other than the ability to run containers of course). For this reason we start writing a <code>Dockerfile</code> inside our tests folder:</p><div><pre tabindex="0"><code data-lang="dockerfile"><span><span><span>FROM</span><span> golang:1.21-alpine</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>WORKDIR</span><span> /app</span><span>
</span></span></span><span><span><span></span><span>COPY</span> main.go main.go<span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>CMD</span> go run main.go -endpoint <span>$ENDPOINT</span><span>
</span></span></span></code></pre></div><p>Quite simple: we want Go and we want to execute our tests. We don’t care about publishing this image so no need to optimize it with multi-stage builds.</p><p>With this new dockerfile and our docker-compose we can now execute our tests. However, since everything is dockerized we need to run the container for our tests in the same network as the service is running so that it can access its endpoint. We also need to wait a bit until the service is running before triggering our tests:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>$ docker-compose up -d
</span></span><span><span><span># You should wait for the service to be up and running</span>
</span></span><span><span>$ <span>cd</span> tests <span>&amp;&amp;</span> docker build -t tests .
</span></span><span><span>$ docker run --network dagger-developer-perspective_service -e <span>&#34;ENDPOINT=service:80&#34;</span> --rm --name tests tests
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open paid
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open pending
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open paid unpacked
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open paid unpacked shippingMethod:table
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open paid unpacked completedAtFrom completedAtTo
</span></span><span><span>2023/11/19 14:22:37 running validation <span>for</span>: open paid and pending
</span></span></code></pre></div><p>We are now ready to build our Github workflow that re-uses what we built here.</p><h3 id="building-our-ci-workflow">Building our CI workflow</h3><p>I won’t go over too much detail here on the syntax for Github workflows. We want our workflow to run only on pull requests that are made against our main branch and we want it to:</p><ul><li>Run unit tests</li><li>Build the service</li><li>Run integration tests</li></ul><p>As we saw previously, building the sevice already happens when we do a <code>docker-compose up</code> so we only need to take care of the other two:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span>name</span><span>:</span><span> </span><span>&#39;pull request&#39;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>on</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>pull_request</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>branches</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>main</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>jobs</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>build-and-test</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>runs-on</span><span>:</span><span> </span><span>ubuntu-latest</span><span>
</span></span></span><span><span><span>    </span><span>steps</span><span>:</span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Checkout</span><span>
</span></span></span><span><span><span>      </span><span>uses</span><span>:</span><span> </span><span>actions/checkout@v3</span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Build the base image</span><span>
</span></span></span><span><span><span>      </span><span>run</span><span>:</span><span> </span><span>docker build -t gradle-service-base --target base . </span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Run unit tests</span><span>
</span></span></span><span><span><span>      </span><span>run</span><span>:</span><span> </span><span>docker run gradle-service-base ./gradlew clean test</span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Start services</span><span>
</span></span></span><span><span><span>      </span><span>run</span><span>:</span><span> </span><span>docker-compose up -d</span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Check service health</span><span>
</span></span></span><span><span><span>      </span><span>run</span><span>:</span><span> </span><span>./tests/check_health.sh</span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Run integration tests</span><span>
</span></span></span><span><span><span>      </span><span>working-directory</span><span>:</span><span> </span><span>tests</span><span>
</span></span></span><span><span><span>      </span><span>run</span><span>:</span><span> </span><span>docker build -t tests . &amp;&amp; docker run --network dagger-developer-perspective_service -e &#34;ENDPOINT=service:80&#34; --rm --name tests tests</span><span>
</span></span></span><span><span><span>    </span>- <span>name</span><span>:</span><span> </span><span>Tear down</span><span>
</span></span></span><span><span><span>      </span><span>run</span><span>:</span><span> </span><span>docker-compose down</span><span>
</span></span></span></code></pre></div><p>In this CI workflow we are:</p><ol><li>Building the <code>base</code> image that we can then use to run our tests</li><li>Using the <code>base</code> image to run our tests</li><li>Starting the service and database with docker-compose</li><li>Running a script that checks the health of the service so that we run our integration tests once the service is up</li><li>Building the container image for our tests and running them in the same network as the service</li><li>Tearing down our service and database</li></ol><p>You can see that we added a new step that previously was done manually: service healthcheck. This is so that the integration tests only run once the service is ready:</p><div><pre tabindex="0"><code data-lang="bash"><span><span><span>#!/bin/bash
</span></span></span><span><span><span></span>
</span></span><span><span><span>max_attempts</span><span>=</span><span>5</span>
</span></span><span><span><span>for</span> <span>((</span> <span>i</span><span>=</span>1<span>;</span> i&lt;<span>=</span>max_attempts<span>;</span> i++ <span>))</span>
</span></span><span><span><span>do</span>
</span></span><span><span>    <span>response</span><span>=</span><span>$(</span>curl -o /dev/null -s -w <span>&#34;%{http_code}\n&#34;</span> http://localhost:8080/health<span>)</span>
</span></span><span><span>    <span>if</span> <span>[</span> <span>&#34;</span><span>$response</span><span>&#34;</span> -eq <span>200</span> <span>]</span><span>;</span> <span>then</span>
</span></span><span><span>        <span>echo</span> <span>&#34;Server is up and running.&#34;</span>
</span></span><span><span>        <span>exit</span> <span>0</span>
</span></span><span><span>    <span>else</span>
</span></span><span><span>        <span>echo</span> <span>&#34;Attempt </span><span>$i</span><span>: Server not responding, retrying in 5 seconds...&#34;</span>
</span></span><span><span>        sleep <span>5</span>
</span></span><span><span>    <span>fi</span>
</span></span><span><span><span>done</span>
</span></span><span><span><span>echo</span> <span>&#34;All attempts failed, exiting with code 1.&#34;</span>
</span></span><span><span><span>exit</span> <span>1</span>
</span></span></code></pre></div><p>Now we can push our branch, create a pull request and see that our CI workflow is running successfully:
<img loading="lazy" src="https://blog.matiaspan.dev/images/gradle-github-workflow.png" alt="a screenshot of the Github website showing that the workflow run successfully in a total of 5m10s"/></p><h3 id="thoughts">Thoughts</h3><p>There were quite a few things we had to build in order to make this happen, and they were all a bit scattered:</p><ul><li>A <code>Dockerfile</code> for the service</li><li>A <code>Dockerfile</code> for the integration tests</li><li>A <code>docker-compose.yaml</code> to run the services in a reproducible way</li><li>A <code>check_health.sh</code> to check the health of the service before running our integration tests</li><li>The <code>.github/workflows/pr.yaml</code> that glues everything together.</li></ul><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/docker-compose-overview.png" alt="image showing the contents of the files that were written in this blog post"/></p><p>Developing this wasn’t as “smooth” as I wrote it here. There were many mistakes I made in the middle that forced me to iterate a bit on how things would run locally and how they would run in the CI, for example the <code>check_health.sh</code> was only necessary in the CI. Having to define 3 stages in order to be able to run the tests in a dockerized way is also something that I haven’t seen people often do, they just rely on their CI runtime to also install dependencies and pray it does not break. I also had to play around with how to connect containers together so that our integraion tests can actually access the service. My developer experience here, in my opinion, wasn’t great. Probably no developer in the team will do a <code>docker build &amp;&amp; docker run</code> locally to run their tests, it requires more effort and steps than simply using their tool of choice (in this case gradle). If the CI ever breaks, it will probably go ignored until someone decides to be unhappy for a bit and fix it.</p><h2 id="using-dagger-modules">Using Dagger modules</h2><p>Can Dagger provide a better experience for building this? Let’s give it a try!</p><p>Quick intro: Dagger allows you to define the entire lifecycle of your application (building, testing, packaging, etc) using code with one of the supported languages. Instead of having to write Dockerfiles and docker-compose files, you write everything in a Dagger module with your programming language of choice. Internally, Dagger leverages BuildKit and containers to make sure that the code you are writing runs anywhere in the exact the same way.</p><p>So, what do we do first? We initialize a Dagger module in our repository that will hold all the code required to build what we built before. Lets start by creating a <code>ci</code> folder and create a new Dagger module that will use Go:</p><div><pre tabindex="0"><code data-lang="sh"><span><span>mkdir ci <span>&amp;&amp;</span> <span>cd</span> ci
</span></span><span><span>dagger module init --name gradle-service --sdk go
</span></span></code></pre></div><p>Quickly inspecting the contents of the program that dagger generated we can see that it is using an object called <code>dag</code> to create containers and perform actions on them:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>	<span>&#34;context&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>GradleService</span> <span>struct</span> <span>{}</span>
</span></span><span><span>
</span></span><span><span><span>// example usage: &#34;dagger call container-echo --string-arg yo&#34;
</span></span></span><span><span><span></span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>ContainerEcho</span><span>(</span><span>stringArg</span> <span>string</span><span>)</span> <span>*</span><span>Container</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>dag</span><span>.</span><span>Container</span><span>().</span><span>From</span><span>(</span><span>&#34;alpine:latest&#34;</span><span>).</span><span>WithExec</span><span>([]</span><span>string</span><span>{</span><span>&#34;echo&#34;</span><span>,</span> <span>stringArg</span><span>})</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>// example usage: &#34;dagger call grep-dir --directory-arg . --pattern GrepDir&#34;
</span></span></span><span><span><span></span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>GrepDir</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>directoryArg</span> <span>*</span><span>Directory</span><span>,</span> <span>pattern</span> <span>string</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>dag</span><span>.</span><span>Container</span><span>().</span>
</span></span><span><span>		<span>From</span><span>(</span><span>&#34;alpine:latest&#34;</span><span>).</span>
</span></span><span><span>		<span>WithMountedDirectory</span><span>(</span><span>&#34;/mnt&#34;</span><span>,</span> <span>directoryArg</span><span>).</span>
</span></span><span><span>		<span>WithWorkdir</span><span>(</span><span>&#34;/mnt&#34;</span><span>).</span>
</span></span><span><span>		<span>WithExec</span><span>([]</span><span>string</span><span>{</span><span>&#34;grep&#34;</span><span>,</span> <span>&#34;-R&#34;</span><span>,</span> <span>pattern</span><span>,</span> <span>&#34;.&#34;</span><span>}).</span>
</span></span><span><span>		<span>Stdout</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We can leverage dagger’s CLI to explore what the <code>module</code> can actually do, from the root of the repository we can run <code>dagger -m ./ci functions</code> and then try some of the already provided examples:</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/dagger-basic-usage-screenshot.png" alt="screenshot of a terminal showing the usage of dagger "/></p><p>Let’s start re-writing our module to build and test our service.Now, the interesting thing about Dagger is that modules can be published and re-used by others no matter what programming language was used to write the module, this means you can use a Go module from within a Python one. At the time of this writing modules are published at the <a href="https://daggerverse.dev">daggerverse</a>. If we look in the Daggerverse we can see that someone already developed a module to running <code>gradle</code> commands:
<img loading="lazy" src="https://www.wildlondon.org.uk/images/gradle-module.png" alt="screenshot of the daggerverse showing a module for running gradle commands"/></p><p>We can leverage this module to execute the build and test commands. To use it we simply have to import it by running <code>dagger mod use github.com/matipan/daggerverse/gradle</code>. If you inspect the module with <code>dagger -m github.com/matipan/daggerverse/gradle functions</code> you’ll see, among other things, that we can define what version of the gradle image to start from. In our case we are using the JDK 21. Let’s write our <code>Build</code> and <code>Test</code> functions with this in mind:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>package</span> <span>main</span>
</span></span><span><span>
</span></span><span><span><span>import</span> <span>(</span>
</span></span><span><span>	<span>&#34;context&#34;</span>
</span></span><span><span>	<span>&#34;fmt&#34;</span>
</span></span><span><span>	<span>&#34;log&#34;</span>
</span></span><span><span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>var</span> <span>GradleVersion</span> <span>=</span> <span>&#34;jdk21-alpine&#34;</span>
</span></span><span><span>
</span></span><span><span><span>type</span> <span>GradleService</span> <span>struct</span> <span>{</span>
</span></span><span><span>	<span>Source</span> <span>*</span><span>Directory</span>
</span></span><span><span>
</span></span><span><span>	<span>gradle</span> <span>*</span><span>Gradle</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>WithSource</span><span>(</span><span>src</span> <span>*</span><span>Directory</span><span>)</span> <span>*</span><span>GradleService</span> <span>{</span>
</span></span><span><span>	<span>m</span><span>.</span><span>Source</span> <span>=</span> <span>src</span>
</span></span><span><span>	<span>return</span> <span>m</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>Build</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>)</span> <span>*</span><span>Container</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>m</span><span>.</span><span>getGradle</span><span>(</span><span>m</span><span>.</span><span>Source</span><span>).</span><span>Build</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>Test</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>)</span> <span>*</span><span>Container</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>m</span><span>.</span><span>getGradle</span><span>(</span><span>m</span><span>.</span><span>Source</span><span>).</span><span>Test</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>getGradle</span><span>(</span><span>src</span> <span>*</span><span>Directory</span><span>)</span> <span>*</span><span>Gradle</span> <span>{</span>
</span></span><span><span>	<span>if</span> <span>m</span><span>.</span><span>gradle</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>m</span><span>.</span><span>gradle</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>m</span><span>.</span><span>gradle</span> <span>=</span> <span>dag</span><span>.</span><span>Gradle</span><span>().</span>
</span></span><span><span>		<span>FromVersion</span><span>(</span><span>GradleVersion</span><span>).</span>
</span></span><span><span>		<span>WithDirectory</span><span>(</span><span>src</span><span>).</span>
</span></span><span><span>		<span>WithWrapper</span><span>()</span>
</span></span><span><span>	<span>return</span> <span>m</span><span>.</span><span>gradle</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Let’s go over what we did here:</p><ul><li><code>WithSource</code>: all Dagger calls run inside a sandboxed environment, so we need to explicitly provide things such as folders and env variables to the commands.</li><li><code>getGradle</code>: this function creates a reference to the <code>Gradle</code> module, specifying the version and configuring it to use the gradle wrapper.</li><li><code>Build</code> and <code>Test</code>: in this functions we simply obtain a reference to the Gradle module with our src directory mounted and run the specific operation there.</li></ul><p>We can now try our build function by running <code>dagger -m ./ci call with-source --src &#34;.&#34; build</code>:</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/gradle-call-build.png" alt="screenshot of the terminal showing the output of the command"/></p><p>In the <code>Build</code> function we are only executing a <code>./gradlew clean build</code>, we can’t really build a final image from the output of this command. With <code>Dockerfile</code>s we created a multi-stage build to separate our runtime from our build. With Dagger we can do the same thing:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>BuildRuntime</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>)</span> <span>*</span><span>Container</span> <span>{</span>
</span></span><span><span>	<span>ctr</span><span>,</span> <span>err</span> <span>:=</span> <span>m</span><span>.</span><span>Build</span><span>(</span><span>ctx</span><span>).</span><span>Sync</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>log</span><span>.</span><span>Fatalf</span><span>(</span><span>&#34;build failed: %s&#34;</span><span>,</span> <span>err</span><span>)</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>dag</span><span>.</span><span>Container</span><span>().</span>
</span></span><span><span>		<span>From</span><span>(</span><span>&#34;amazoncorretto:21.0.1-alpine3.18&#34;</span><span>).</span>
</span></span><span><span>		<span>WithExec</span><span>([]</span><span>string</span><span>{</span><span>&#34;apk&#34;</span><span>,</span> <span>&#34;update&#34;</span><span>,</span> <span>&#34;&amp;&amp;&#34;</span><span>,</span> <span>&#34;apk&#34;</span><span>,</span> <span>&#34;--no-cache&#34;</span><span>,</span> <span>&#34;add&#34;</span><span>,</span> <span>&#34;ca-certificates&#34;</span><span>,</span> <span>&#34;curl&#34;</span><span>,</span> <span>&#34;tcpdump&#34;</span><span>,</span> <span>&#34;procps&#34;</span><span>,</span> <span>&#34;bind-tools&#34;</span><span>}).</span>
</span></span><span><span>		<span>WithWorkdir</span><span>(</span><span>&#34;/app&#34;</span><span>).</span>
</span></span><span><span>		<span>WithFile</span><span>(</span><span>&#34;app.jar&#34;</span><span>,</span> <span>ctr</span><span>.</span><span>File</span><span>(</span><span>&#34;build/libs/gradle-service-0.0.1-SNAPSHOT.jar&#34;</span><span>)).</span>
</span></span><span><span>		<span>WithEntrypoint</span><span>([]</span><span>string</span><span>{</span><span>&#34;sh&#34;</span><span>,</span> <span>&#34;-c&#34;</span><span>,</span> <span>&#34;java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=default&#34;</span><span>})</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>You can see that from <code>BuildRuntime</code> we are calling the <code>Build</code> function defined previously. We then generate a new container that starts from <code>amazoncorretto:21.0.1-alpine3.18</code> and mounts the application <code>jar</code> found in the container returned by build.</p><p>So far we’ve only done <code>Build</code>, <code>BuildRuntime</code> and <code>Test</code>. But we also want to run integration tests and have everything integrated into Dagger. To do this we need a way to run the service and a MySQL server. Well, we are in luck. Dagger has native support for <code>Services</code>. With Dagger, we can define a container as a service and then use the <code>dagger up</code> command to start the service and its dependencies. All we have to do is write functions that return the <code>*Service</code> type:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>Service</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>sqlInitDB</span> <span>*</span><span>File</span><span>)</span> <span>*</span><span>Service</span> <span>{</span>
</span></span><span><span>	<span>runtime</span> <span>:=</span> <span>m</span><span>.</span><span>BuildRuntime</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>runtime</span><span>.</span>
</span></span><span><span>		<span>WithEnvVariable</span><span>(</span><span>&#34;DB_HOST&#34;</span><span>,</span> <span>&#34;mysql&#34;</span><span>).</span>
</span></span><span><span>		<span>WithEnvVariable</span><span>(</span><span>&#34;DB_PORT&#34;</span><span>,</span> <span>&#34;3306&#34;</span><span>).</span>
</span></span><span><span>		<span>WithServiceBinding</span><span>(</span><span>&#34;mysql&#34;</span><span>,</span> <span>m</span><span>.</span><span>Mysql</span><span>(</span><span>ctx</span><span>,</span> <span>sqlInitDB</span><span>)).</span>
</span></span><span><span>		<span>WithExposedPort</span><span>(</span><span>80</span><span>).</span>
</span></span><span><span>		<span>WithExec</span><span>([]</span><span>string</span><span>{</span><span>&#34;sh&#34;</span><span>,</span> <span>&#34;-c&#34;</span><span>,</span> <span>&#34;java $JAVA_OPTS -jar app.jar --server.port=80 --spring.profiles.active=default&#34;</span><span>}).</span>
</span></span><span><span>		<span>AsService</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>Mysql</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>sqlInitDB</span> <span>*</span><span>File</span><span>)</span> <span>*</span><span>Service</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>dag</span><span>.</span><span>Container</span><span>().</span>
</span></span><span><span>		<span>From</span><span>(</span><span>&#34;mysql:8.2.0&#34;</span><span>).</span>
</span></span><span><span>		<span>WithEnvVariable</span><span>(</span><span>&#34;MYSQL_ROOT_PASSWORD&#34;</span><span>,</span> <span>&#34;password&#34;</span><span>).</span>
</span></span><span><span>		<span>WithEnvVariable</span><span>(</span><span>&#34;MYSQL_DATABASE&#34;</span><span>,</span> <span>&#34;database&#34;</span><span>).</span>
</span></span><span><span>		<span>WithFile</span><span>(</span><span>&#34;/docker-entrypoint-initdb.d/db.sql&#34;</span><span>,</span> <span>sqlInitDB</span><span>).</span>
</span></span><span><span>		<span>WithExposedPort</span><span>(</span><span>3306</span><span>).</span>
</span></span><span><span>		<span>AsService</span><span>()</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Lets break this code down:</p><ul><li>In the <code>Service</code> function we first call the <code>BuildRuntime</code> to generate a container that has our <code>jar</code> ready to be executed.</li><li>We then create a new container that defines a mysql <code>ServiceBinding</code> to whatever <code>Service</code> the <code>Mysql</code> function returns.</li><li>The <code>Mysql</code> function returns MySQL 8 container with our seed file ready to populate the DB when it starts.</li></ul><p>Now we can use the <code>up</code> command to start the service and its dependencies locally <code>dagger -m ./ci up with-source --src &#34;.&#34; service --sql-init-db &#34;db/db.sql&#34;</code>:</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/dagger-up-service.png" alt="output of running the dagger up command"/></p><p>Dagger makes sure that the services are healthy before they connect to each other. All this runs in containers isolated in their own environments. This means that we can run this same command in other machines and expect it will work correctly.</p><p>To run the integration tests using Dagger we can choose one of two approaches: i) containerize the execution of integration tests and define it as a service connected to the others; ii) take advantage that tests are written in Go and simply call out to them as a library. Implementing the first one is quite straightfoward, we simply define a new function that uses the <code>Go</code> module from the Daggerverse and creates a container that is connected to the service:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>IntegrationTests</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>tests</span> <span>*</span><span>Directory</span><span>,</span> <span>sqlInitDB</span> <span>*</span><span>File</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
</span></span><span><span>	<span>return</span> <span>dag</span><span>.</span><span>Go</span><span>().</span>
</span></span><span><span>		<span>FromVersion</span><span>(</span><span>&#34;1.21-alpine&#34;</span><span>).</span>
</span></span><span><span>		<span>WithSource</span><span>(</span><span>tests</span><span>).</span>
</span></span><span><span>		<span>Container</span><span>().</span>
</span></span><span><span>		<span>WithServiceBinding</span><span>(</span><span>&#34;service&#34;</span><span>,</span> <span>m</span><span>.</span><span>Service</span><span>(</span><span>ctx</span><span>,</span> <span>sqlInitDB</span><span>)).</span>
</span></span><span><span>		<span>WithExec</span><span>([]</span><span>string</span><span>{</span><span>&#34;go&#34;</span><span>,</span> <span>&#34;run&#34;</span><span>,</span> <span>&#34;main.go&#34;</span><span>,</span> <span>&#34;--endpoint&#34;</span><span>,</span> <span>&#34;service:80&#34;</span><span>}).</span>
</span></span><span><span>		<span>Stdout</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In this function we expect to receive the directory that holds the tests, the database file used to seed the db and we return the output that the command generates. We can now use dagger’s CLI to call this function and run the integration tests, all containerized and defined within a single codebase:</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/integration-tests-cmd.png" alt="output of dagger showing the tests succeeded"/></p><p>The second approach is interesting to explore. Since our tests are written in Go, we could technically just import them as a library and execute that Go code from within the execution context of our module. Since that is also containerized, it is still re-usable. To be able to do this we would have to move the code of our tests inside the <code>ci</code> folder, since it is a go module, import it from our module and call the function that runs the tests:</p><div><pre tabindex="0"><code data-lang="go"><span><span><span>import</span> <span>&#34;main/test/orderlist&#34;</span>
</span></span><span><span>
</span></span><span><span><span>...</span>
</span></span><span><span>
</span></span><span><span><span>func</span> <span>(</span><span>m</span> <span>*</span><span>GradleService</span><span>)</span> <span>IntegrationTests</span><span>(</span><span>ctx</span> <span>context</span><span>.</span><span>Context</span><span>,</span> <span>sqlInitDB</span> <span>*</span><span>File</span><span>)</span> <span>error</span> <span>{</span>
</span></span><span><span>	<span>svc</span><span>,</span> <span>err</span> <span>:=</span> <span>dag</span><span>.</span><span>Host</span><span>().</span><span>Tunnel</span><span>(</span><span>m</span><span>.</span><span>Service</span><span>(</span><span>ctx</span><span>,</span> <span>sqlInitDB</span><span>)).</span><span>Start</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>err</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>	<span>defer</span> <span>svc</span><span>.</span><span>Stop</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span>
</span></span><span><span>	<span>endpoint</span><span>,</span> <span>err</span> <span>:=</span> <span>svc</span><span>.</span><span>Endpoint</span><span>(</span><span>ctx</span><span>)</span>
</span></span><span><span>	<span>if</span> <span>err</span> <span>!=</span> <span>nil</span> <span>{</span>
</span></span><span><span>		<span>return</span> <span>err</span>
</span></span><span><span>	<span>}</span>
</span></span><span><span>
</span></span><span><span>	<span>return</span> <span>orderlist</span><span>.</span><span>Test</span><span>(</span><span>endpoint</span><span>)</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>In this code we are importing the tests as a library, starting the service and the MySQL database, opening up a tunnel from the container of the service to the container our module is running on and then use the created endpoint to run the tests (the warning messages are from the <code>Stop</code> function, we can ignore them):</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/integration-tests-integrated.png" alt="screenshot showing the tests running successfully"/></p><p>I wanted to show both approaches since you might prefer to write your integration tests using a different language to the one used by your Dagger module. If this is the case, you can use the first approach of containerizing and executing a command there.</p><h3 id="building-our-ci-workflow-1">Building our CI workflow</h3><p>Let’s put all of this together in our CI workflow. This is where Dagger shines in my opinion. We don’t have to do anything special to make sure this works in our CI environment. We just need to install the dagger CLI and run the exact same command developers run locally:</p><div><pre tabindex="0"><code data-lang="yaml"><span><span><span>name</span><span>:</span><span> </span><span>&#39;pull request&#39;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>on</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>pull_request</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>branches</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>master</span><span>
</span></span></span><span><span><span>      </span>- <span>main</span><span>
</span></span></span><span><span><span>      </span>- <span>develop</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span></span><span>jobs</span><span>:</span><span>
</span></span></span><span><span><span>  </span><span>build-and-test</span><span>:</span><span>
</span></span></span><span><span><span>    </span><span>runs-on</span><span>:</span><span> </span><span>ubuntu-latest</span><span>
</span></span></span><span><span><span>    </span><span>steps</span><span>:</span><span>
</span></span></span><span><span><span>      </span>- <span>name</span><span>:</span><span> </span><span>Checkout</span><span>
</span></span></span><span><span><span>        </span><span>uses</span><span>:</span><span> </span><span>actions/checkout@v3</span><span>
</span></span></span><span><span><span>      </span>- <span>name</span><span>:</span><span> </span><span>Install Dagger CLI</span><span>
</span></span></span><span><span><span>        </span><span>run</span><span>:</span><span> </span><span>cd /usr/local &amp;&amp; { curl -L https://dl.dagger.io/dagger/install.sh | sh; cd -; }</span><span>
</span></span></span><span><span><span>      </span>- <span>name</span><span>:</span><span> </span><span>Test</span><span>
</span></span></span><span><span><span>        </span><span>run</span><span>:</span><span> </span><span>dagger -m ./ci call with-source --src &#34;.&#34; test</span><span>
</span></span></span><span><span><span>      </span>- <span>name</span><span>:</span><span> </span><span>Integration test</span><span>
</span></span></span><span><span><span>        </span><span>run</span><span>:</span><span> </span><span>dagger -m ./ci call with-source --src &#34;.&#34; integration-tests --tests &#34;./tests&#34; --sql-init-db &#34;./db/db.sql&#34;</span><span>
</span></span></span></code></pre></div><p>And we are done! Less YAML and no surprises. Here is the pipeline working as we expected:</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/dagger-gradle-github-workflow.png" alt="a screenshot of the Github website showing that the workflow run successfully in a total of 4m18s"/></p><h3 id="thoughts-1">Thoughts</h3><p>Through the use of code and Dagger’s capabilities for running containerized services and commands we were able to build our entire CI workflow in a programmatic way inside a single Go file. Here is an overview of what we needed to write in order to make this work:</p><p><img loading="lazy" src="https://www.wildlondon.org.uk/images/gradle-dagger-module-overview.png" alt="screenshot showing the entire dagger module and github workflow"/></p><p>Notice how we wrote all the important bits directly in code, no need for YAML and config files like <code>Dockerfile</code>s. Even though there are a few rough edges in Dagger (mainly due to how new it is) I personally believe this is a much better experience than what we had before. We wrote the entire definition of our CI using code and we were able to validate every single part of it locally. If we compare to how we could run the tests before, we now have an DX that developers can definitely use: <code>dagger -m ./ci call with-source --src &#34;.&#34; test</code>.</p><h2 id="conclusion">Conclusion</h2><p>In this blog post we compared the experience of using traditional tools like docker-compose with Dagger for building a CI workflow that builds and tests a Java-Gradle service. We saw how with docker and docker-compose we had to write a lot of configuration files and YAML to glue things together in a way that was not easily reproducible. Meaning that developers would run things locally in a way that would be different to how the CI would work. However, with Dagger we saw that it was no longer necessary to write this config and YAMl files. Instead, we built everything using Go code, we leveraged Dagger’s native support for running services and we glued everything together in a programmatic but still declarative way. We were then able to run this code in the CI in the exact same way that we run it locally.</p><p>I personally believe there is still a bit of a learning curve to Dagger. It requires a mindset shift in order to stop thinking that this processes should be written and defined with configuration “languages” such as YAML and dockerfile. However, I think Dagger provides a lot of power with it’s code-first approach and its ecosystem that will only get bigger and better. It’s interesting how easily it integrates with existing CI systems and gives a developer experience that allows us to treat pipelines as software and write them using our editors and IDEs.</p></div></div>
  </body>
</html>
