<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bradfrost.com/blog/post/the-design-system-ecosystem/">Original</a>
    <h1>The Design System Ecosystem</h1>
    
    <div id="readability-page-1" class="page"><div>

				
<p>What does a mature, end-to-end design system look like in a big, complex organization? What are all the moving pieces, and how do they hang together as a well-considered architecture? What’s required and what’s optional? <a href="https://www.youtube.com/watch?v=UjvGAYuWSUA">Hold onto your butts</a>, because we’re going to go deep on this one.</p>



<p>Let’s start here: a design system’s relationship to digital products can be boiled down like so:</p>



<figure><img decoding="async" fetchpriority="high" width="1024" height="576" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-14-at-11.59.12-1024x576.png" alt="An illustration that shows a blue circle labeled &#34;Design system&#34; with an orange circle next to it labeled &#34;product&#34;. An arrow points from the design system to the product, and another arrow points from the product back to the design system" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-14-at-11.59.12-1024x576.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-14-at-11.59.12-700x393.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-14-at-11.59.12-768x432.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-14-at-11.59.12.png 1386w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>There’s a design system. Products use the design system. The design system informs and influences the products, and in turn the products inform and influence what’s in the design system. </p>



<p>While this depiction is true, it ignores the complexities many organizations wrestle with day in and day out. Over the years, <strong>the digital product landscape has become vastly more complex, the responsibilities of design systems have grown substantially, tooling has evolved and matured, and processes &amp; organizational structures for managing digital products have grown up.</strong></p>



<p>In order to account for this complex reality, it’s important to paint a more nuanced picture of a design system ecosystem that can power an enterprise’s portfolio of digital products. The design system ecosystem of a complex organization takes the form of a delicious-yet-dense layer cake. Call it a devil cake: the devil’s in the details, and the devil can end up looking something more like this:</p>



<figure><img decoding="async" width="1024" height="577" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.57.22-1024x577.png" alt="An illustration that shows a 5 layers of a design system stacked on top of one another. Core design system is the bottom layer, technology-specific implementation on top of that, recipes on top of that, smart components on top of that, and product as the top layer. Arrows connect each layer to each other to demonstrate the interconnectedness of the ecosystem." srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.57.22-1024x577.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.57.22-700x394.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.57.22-768x433.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.57.22-1536x866.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.57.22-2048x1154.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>And to <em>really</em> show it in all of its terrifying detail:</p>



<figure><a href="https://www.figma.com/file/TfztDS5nOYVLGChUTbR78B/Design-System-Ecosystem?type=whiteboard&amp;node-id=0-1&amp;t=IZ7RRCW3MfZYbTEg-0"><img decoding="async" width="1171" height="2560" src="https://bradfrost.com/wp-content/uploads/2023/09/Design-System-Ecosystem-2-scaled.gif" alt="A terrifying and detailed flow chart of a 5-tier design system ecosystem. The diagram maps out the relationships between all of the design, code, and documentation assets in a design system ecosystem."/></a></figure>







<p>Wow, that looks overwhelming huh!? Before you freak out, it’s important to stress a few things. </p>



<p>First of all, <strong>nearly all of these layers are optional and don’t necessarily apply to every organization.</strong> Instead, this is a visualization of a complete, mature enterprise design system. It’s informed by our work helping some of the world’s largest companies successfully establish and evolve their design systems. We know companies start seeing value after implementing only a fraction of what’s shown here.</p>



<p>Second, Gall’s Law is extremely relevant here:</p>



<blockquote>
<p>A complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.</p>
<cite><a href="https://en.wikipedia.org/wiki/John_Gall_(author)#Galls_law">Gall’s Law</a></cite></blockquote>



<p>All to say, <strong>it’s critical for a design system architecture to be only as complex as it needs to be</strong>, and add additional layers or complexity only when real needs arise. Growing a design system is a gradual process. (And if it seems overwhelming, well, we’re happy to help. <a href="https://bigmedium.com/hire/">Get in touch</a> to hire us to help plan, build, or evolve your design system.)</p>



<p>In this article we’ll get down to the gory details of what makes up a successful, sophisticated, and mature design system ecosystem. We’ll break down what the capital-E Enterprise folks call the “end-to-end experience” for deploying user interfaces at scale.  This is tricky, nuanced work, but that’s the nature of the beast for digital organizations managing several/dozens/hundreds/thousands of products and people. </p>



<p>Alright, let’s dive in!</p>



<h2>Anatomy of a design system ecosystem</h2>



<p>We’re going to detail <a href="https://www.figma.com/file/TfztDS5nOYVLGChUTbR78B/Design-System-Ecosystem?type=whiteboard&amp;node-id=0%3A1&amp;t=IZ7RRCW3MfZYbTEg-1">this diagram</a>, which describes the various UI assets and the relationships between them. While the diagram looks intimidating, the crux of the ecosystem can be broken down like so:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="575" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.53.31-1024x575.png" alt="An illustration that shows a 5 layers of a design system stacked on top of one another. Core design system is the bottom layer, technology-specific implementation on top of that, recipes on top of that, smart components on top of that, and product as the top layer." srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.53.31-1024x575.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.53.31-700x393.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.53.31-768x432.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.53.31-1536x863.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.53.31.png 1831w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<ul>
<li><strong>Core design system layer</strong> – which contains the common, organization-wide UI building blocks for both design and development.</li>



<li><strong>Optional technology-specific layer</strong> – which contains framework-specific and native implementations of those common UI components.</li>



<li><strong>Optional recipe layer</strong> – which contains composed UI components to be used consistently across specific contexts (like a product or product family), but aren’t reusable across the entire organization.</li>



<li><strong>Optional smart components layer</strong> – which contains UI components wrapped in logic, functionality, or other smarts to make the integration of common components and services easier for product developers.</li>



<li><strong>Product layer</strong> – the actual websites and apps that we ship to customers (aka the whole reason we’re doing all of this!)</li>
</ul>



<p>If those are the broad layers of a UI ecosystem, here’s a breakdown of the types of assets that go into those layers:</p>



<figure><img decoding="async" loading="lazy" width="1024" height="701" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.21.41-1024x701.png" alt="An illustration showing the various assets in a design system ecosystem: purple dot for design library or file, orange dot for a code repository, yellow dot for a code package, blue dot for a reference website, pink dot for a front-end workshop, and a green dot for an application codebase" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.21.41-1024x701.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.21.41-700x479.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.21.41-768x526.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.21.41.png 1039w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<ul>
<li><strong>Design library</strong> – <a href="https://help.figma.com/hc/en-us/articles/360041051154-Guide-to-libraries-in-Figma">Figma team library</a> or similar</li>



<li><strong>Design file</strong> – Figma project file or similar</li>



<li><strong>Code repository</strong> – the source code home – GitHub or similar</li>



<li><strong><a href="https://bradfrost.com/blog/post/a-frontend-workshop-environment/">Front-end workshop</a></strong> – a tool like <a href="https://storybook.js.org/">Storybook</a> to build, view, test, review and document coded UI components</li>



<li><strong>Code package</strong> – a code library packaged up and published (on <a href="https://www.npmjs.com/">npm</a> or similar) in order to be consumed as a dependency by other applications. </li>



<li><strong>Reference website</strong> – <a href="https://zeroheight.com/">Zeroheight</a> or <a href="https://bradfrost.com/blog/post/self-hosted-vs-third-party-design-system-reference-website/">similar</a></li>
</ul>



<p>With all of that table setting out of the way, let’s dig into the anatomy of the core design system!</p>



<hr/>



<h2>Core design system </h2>



<p>The core design system contains common components, patterns, principles, and conventions that help an organization: </p>



<ol>
<li><a href="https://bradfrost.com/blog/post/design-systems-are-for-user-interfaces/">tell the official story of how it designs and builds user interfaces, </a>and </li>



<li>provide the building materials to do it. </li>
</ol>



<p>It’s a library of solved problems, the settled solutions that don’t need re-hashed for the 15th time It’s <a href="https://bigmedium.com/ideas/boring-design-systems.html">the boring stuff</a> like form controls, buttons, accordions, and the standard-fare components you see <a href="https://open-ui.org/research/component-matrix/">across many popular design systems</a>. </p>



<p>So what ingredients are included in the core design system? The key assets the design system includes are <strong>design tokens, icons</strong>, <strong>UI components</strong>, and a <strong>reference website</strong>.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="575" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.54.52-1024x575.png" alt="An illustration showing the core design system layer of a design system ecosystem. It shows a design token layer containing a design library, repo, and code package, an icon layer containing a design library, repo, and code package, and a UI component layer containing a design library, repo,  code package, Storybook, and reference website" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.54.52-1024x575.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.54.52-700x393.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.54.52-768x431.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.54.52-1536x862.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.54.52.png 1832w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h3>Design tokens layer</h3>



<p><strong><a href="https://css-tricks.com/what-are-design-tokens/">Design tokens</a> are low-level design definitions</strong> (the <a href="https://bradfrost.com/blog/post/extending-atomic-design/">sub-atomic particles</a> if you will) — color, typography, border radius, spacing, elevation, and other values — that make up a design language. Design tokens are ultimately applied to UI components in order to achieve a specific look and feel. Think of them as brand variables.</p>



<p>Nearly all of our design-system client work over the last 5 years has included creating/evolving some form of themeable design system. Architecting a <a href="https://bradfrost.com/blog/post/creating-themeable-design-systems/">thoughtful 3-tier token architecture</a> is the secret sauce for making a design system <a href="https://bradfrost.com/blog/post/the-many-faces-of-themeable-design-systems/">support multiple brands, white-labeling, different product families, redesigns, dark mode, and more</a>.</p>



<p>We recommend splitting design tokens into their own layer (separate from the UI component layer) to unlock theming, create a separation of concerns between brand language and UI components, and version brand languages independent of UI components.</p>



<figure><img decoding="async" loading="lazy" width="814" height="236" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.05.png" alt="Illustration featuring a foundations library circle, tokens repo, and tokens package" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.05.png 814w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.05-700x203.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.05-768x223.png 768w" sizes="(max-width: 814px) 100vw, 814px"/></figure>



<h4>Foundations design library</h4>



<p>Design tokens and associated styles are often referred to as “foundations” in the design discipline. In Figma, these design token foundations are defined as <a href="https://help.figma.com/hc/en-us/articles/15339657135383-Guide-to-variables-in-Figma">variables</a> for most values, while typography-specific tokens need to be defined as styles <small>(Note: for now! <a href="https://help.figma.com/hc/en-us/articles/4406787442711#01H8DQBXK0JPJYZQ4EEF42H71T">Figma said</a> they’re working on making typography-specific variables available)</small>. The foundations should be managed in their own <a href="https://help.figma.com/hc/en-us/articles/360041051154-Guide-to-libraries-in-Figma">design library</a> that other files and libraries — including the UI component library — can subscribe to. This library can contain the definitions for each supported theme, though organizations supporting dozens or hundreds of themes might want to consider chunking things out into different foundations libraries.</p>



<h4>Design tokens repo</h4>



<p>In code, the design token source of truth is a repository of JSON files that define all theme values. Tooling (<a href="https://amzn.github.io/style-dictionary/#/">Style Dictionary</a> has become the standard) then converts design token JSON files into the appropriate technology-specific format (CSS custom properties, Sass, iOS, Android, etc), which can then be applied to UI components. </p>



<h4>Design tokens package</h4>



<p>The technology-specific formatted tokens are packaged up and published on a software registry in order for consuming developers to pull them into web products, native apps, and other environments. </p>



<h3>Icons</h3>



<p>Icons are a weird one! Like design tokens, they can exist as their own product that gets packaged up and consumed by many different environments. More commonly, we tend to see icons bundled up alongside the design tokens. Teams powering web, native, and other non-web software that need to manage/version icons independently might want to consider splitting icons out as its own independent layer supported by the following assets:</p>



<figure><img decoding="async" loading="lazy" width="811" height="236" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.55.png" alt="Icons library, icons repo, and icons package illustration" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.55.png 811w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.55-700x204.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-09.43.55-768x223.png 768w" sizes="(max-width: 811px) 100vw, 811px"/></figure>



<ul>
<li>Icon Figma library</li>



<li>Icon SVG repository</li>



<li>Icon package</li>
</ul>



<h3>UI Components</h3>



<p>This is the star of the design system show! When people think of a design system, they think of a set of common UI components that can be used and reused in other products.  There are a few different assets that constitute a design system’s UI component library, so let’s break it down.</p>



<figure><img decoding="async" loading="lazy" width="961" height="181" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.33.42.png" alt="Illustration showing a UI component library design library, web component repo, web component package, storybook, and reference website" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.33.42.png 961w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.33.42-700x132.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.33.42-768x145.png 768w" sizes="(max-width: 961px) 100vw, 961px"/></figure>



<h4>Core UI components Figma library</h4>



<p>For designers, a design system’s <a href="https://help.figma.com/hc/en-us/articles/360041051154-Guide-to-libraries-in-Figma">design library</a> is a dedicated project where designers capture the design specifications for common UI components. Here’s where the design system designers sweat the small stuff (Alert layout! Accordion affordances! Badge variants! Required form field treatment! Etc etc) so other product designers don’t have to. The published design library becomes the thing product designers subscribe to in order to drag-and-drop the system’s components into their product design files.</p>



<h4>Web Components library repository</h4>



<p>While a Figma library is super helpful for designer efficiency, the true source of truth for a design system is a library of coded components that build real digital products. After all, despite all of this ecosystem mumbo jumbo, the <a href="https://bigmedium.com/ideas/only-one-deliverable-matters.html">only thing that really matters</a> at the end of the day is the actual user experience human beings interact with. And that reality snags many design system teams; it’s really easy to lose the forest for the trees. Don’t get it twisted: a design system is a means to an end.</p>



<p>We’ve helped organizations build design systems in a multitude of technologies over the years, but as time goes by <strong>we now heartily recommend one specific technology to build a core design system for the web: <a href="https://bradfrost.com/blog/post/lets-talk-about-web-components/">Web Components</a></strong>. Web Components are a standard, part of the web platform itself. That means they’re interoperable with any web framework or technology, they’re lightweight, they’re themeable, and they’re self-contained. <small>Note: It’s totally possible to build the coded design system in a specific technology like React, but just be eyes-wide-open to the fact that the system can’t power products that aren’t compatible with that technology. Everything has pros and cons! </small></p>



<p>The Web Component repository contains the source code for your design system’s common components. We’ve been using <a href="https://lit.dev/">Lit</a> for the last few years with great success (and have used <a href="https://stenciljs.com/">Stencil</a> successfully in the past) to help us author Web Components in a thoughtful, efficient manner. </p>



<h4>Web Components Storybook</h4>



<p><a href="https://bradfrost.com/blog/post/atomic-design-and-storybook/">We use Storybook</a> in order to build, visualize, test, review, and document our coded design system library. Storybook is included in the web component repository as a dev dependency; it’s not a separate repository or anything like that. We publish our Storybook to a URL for testing/review/documentation, and like to use <a href="https://www.netlify.com/">Netlify</a> or similar to publish each work-in-progress branch of the Web Components so that our client teams can test, review, and discuss changes before they get merged into the main library.</p>



<h4> Web component library package</h4>



<p>A build step converts the web component source code into a <code>dist</code> directory containing the built library of Web Components, which then gets packaged up and published on a software registry. This allows for any web product — a static website, React/Angular/Vue/Etc app, a CMS-powered website, whatever — to pull the web component library into their project and use the design system’s components in their products’ user interfaces. </p>



<h3>Reference website</h3>



<p>A reference website <a href="https://bradfrost.com/blog/post/the-workshop-and-the-storefront/">serves as the storefront</a> that is part marketing website, part documentation, part support channel, and all things design system. The reference website gather all of the assets described above under one roof to help the organization successfully wield the design system to build great interfaces for digital products.</p>



<p><a href="https://bradfrost.com/blog/post/self-hosted-vs-third-party-design-system-reference-website/">You can build the reference website from scratch, or power it using a third-party tool like Zeroheight</a>. As time goes on, we’ve found great success with Zeroheight as it elegantly pulls design assets from Figma and code assets from Storybook. This maintains Figma and code (visualized through Storybook) as the workshops for design and dev respectively, but brings them together in a single location to provide cross-disciplinary guidance for teams using the system.</p>



<hr/>



<h2>Technology-specific implementation (optional) </h2>



<p>This optional layer translates the core design system into specific technical implementations. This can help application developers working in specific tech stacks easily wield the design system’s ingredients.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="576" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.35.28-1024x576.png" alt="An illustration showing the technology-specific implementation layer of a design system ecosystem. It shows a framework, native, and other layer each containing their own repo, code package, and storybook" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.35.28-1024x576.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.35.28-700x394.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.35.28-768x432.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.35.28-1536x864.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.35.28-2048x1153.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h3>Framework wrapper layer</h3>



<p>As we’ve discussed, Web Components are a fantastic choice for <a href="https://bradfrost.com/blog/post/front-of-the-front-end-and-back-of-the-front-end-web-development/">front-of-the-front-end</a> code that serves as the backbone of a design system. But! It can be helpful or necessary to maintain a framework-specific flavor of the design system. This entails wrapping the design system’s Web Components in framework-specific syntax (for example, the button Web Component <code>&lt;ds-button variant=&#34;primary&#34;&gt;</code> could be wrapped in React and exposed to developers as <code>&lt;DsButton variant=&#34;primary&#34;&gt;</code>).</p>



<p>Our team thinks framework-specific implementations will diminish over time; most frameworks can consume Web Components as is. But in our experience, we’ve encountered a few good reasons to create and maintain these framework-wrapped versions:</p>



<ul>
<li>Some frameworks — especially earlier versions of React — need some massaging to get Web Components to work properly. <a href="https://github.com/lit/lit/tree/main/packages/labs/react">Lit’s React wrapper</a> is an example of a bit of glue code that’s necessary to get Web Components to work smoothly with the way React handles events.</li>



<li>Teams with existing React/Angular/Vue/etc libraries that power real products should preserve all that hard-earned adoption! Those-framework-specific libraries can continue to exist, but we often help teams replace the component guts with new web component-powered internals instead.</li>



<li>Maintaining existing framework-specific libraries can be a good way of incrementally adopting a sturdier API naming standard while still supporting legacy API language.</li>



<li>Teams used to wielding framework-shaped components (e.g. <code>&lt;DsButton text=&#34;Click me&#34;&gt;</code>) don’t have to adopt an unfamiliar web component convention (<code>&lt;ds-button text=&#34;Click me&#34;&gt;</code>). This layer can also serve as a safeguard in case teams want to swap out different technologies under the hood over time.</li>
</ul>



<h4>Framework code repo</h4>



<p>Where does the framework-wrapper repository live? We’ve seen it live under the formal design system umbrella (often as a sibling of the web component package in a monorepo), but we’ve also seen framework-wrapper layers live outside of the formal system maintained by downstream teams working in a specific technology. </p>



<p>Regardless of where the framework layer lives, it’s crucial for the core and framework-specific layers to stay in sync with one another. This can be helped along by the technical architecture of the system, but it ultimately requires coordination between the humans managing the different layers.</p>



<h4>Framework Storybook</h4>



<p>If a React flavor of the design system exists, spinning up a React-specific Storybook is necessary to provide React developers the appropriate code syntax to reference and copy-and-paste. </p>



<h4>Framework code package</h4>



<p>Each framework-specific flavor of the design system library gets built and published on a software registry, which allows product teams working in a specific framework to pull in the appropriate flavor of the design system as a dependency. </p>



<h3>Native layer</h3>



<p>Native apps are often an important part of an organizations’ digital landscape. They’re challenging from a design system perspective for a number of reasons: </p>



<ul>
<li>Native app UIs can be coded in an array of technologies. Some use (often heavily-modified) web tech like React Native or Ionic. There’s Jetpack Compose, Flutter, Swift UI, UIKit, and others for bespoke native application development. At the end of the day, there’s not exactly a standard for developing UI components for native platforms, so implementation can be uneven.</li>



<li>iOS and Android bring OS-level UI conventions and OS-provided UI components along for the ride, which means an organization’s bespoke UI needs to work with the grain of the operating systems. </li>



<li>Design system tooling for native codebases are absent or immature (If I had a nickel for every time I’ve been asked “is there a Storybook for iOS and Android?”, I’d have a handful of nickels).</li>



<li>Native teams tend to be more siloed (or outsourced) compared to their web counterparts. </li>
</ul>



<p>Whatever the challenges may be, organizations creating native design systems will need the following assets:</p>



<h4>iOS and/or Android component library repositories</h4>



<p>These repositories contain the source code for a design system’s native app implementations, similar to <a href="https://github.com/material-components/material-components-android">Material Design’s Android codebase</a>.</p>



<h4>iOS and/or Android code packages</h4>



<p>The native landscape operates a bit differently than the web landscape, but package managers exist (e.g. <a href="https://www.swift.org/package-manager/">Swift Package Manager</a>) to help deploy a native design system’s library to other native application codebases.</p>



<h3>Other non-web implementations</h3>



<p>iOS and Android mobile apps are certainly some of the more common non-web digital products, but there can be a vast array of other software interfaces floating around an organization. We’ve dealt with airplane seat-back UIs, banking ATM UIs, kiosk UIs, medical equipment UIs, scientific equipment UIs, and more. All of these UIs come to life <em>somehow</em>, and the technologies that power these experiences vary widely (and often frighteningly!). Regardless of the specific tech employed for these experiences, the same guidance applies: create a dedicated repository for common UI-specific code, and deploy that code using some form of software registry.</p>



<hr/>



<h2>Recipe layer (optional)</h2>



<p>We often encounter design system teams who are frantically trying to keep up with every UI-related product decision happening across their organization. The (often small-and-scrappy) team runs from meeting to meeting, captures other product teams’ UI needs in their already-crowded backlog, and then gets to work implementing those requests. This road leads to bottlenecks and burnout.</p>



<p>There’s a better way. The design system doesn’t have to own, include, or oversee every bit of UI across a company’s product landscape. It just needs to provide a core set of ingredients—and support/encourage teams to build recipes with those ingredients.</p>



<p>When we introduce the concept of a <a href="https://bradfrost.com/blog/post/design-system-components-recipes-and-snowflakes/">recipe component layer</a> to these frazzled teams, you can almost see the weight lift from their shoulders. The recipe layer serves as an important pressure release valve for the UI ecosystem. With recipes, product designers are able to own their product-specific UI components and work at a relatively fast pace, while design system designers carry on working on the core component ingredients at a slower, more considered pace.</p>



<p>The recipe layer proves to be a really crucial layer in the ecosystem for many teams, and an essential layer for massive organizations managing many business units or sub-brands. <a href="https://shinytoyrobots.substack.com/p/the-hub-and-spoke-design-system-model">This article</a> by Robin Cannon explains why IBM’s Carbon Design System team leaned into this concept of recipes:</p>



<blockquote>
<p>Business units needed extra capability to tailor how the design system was going to be consumed in their domain.</p>
<cite><a href="https://shinytoyrobots.substack.com/p/the-hub-and-spoke-design-system-model">Robin Cannon</a></cite></blockquote>



<p>This layer provides individual business units, sub-brands, product families, or products with important agency and autonomy over their domain while still adhering to the standards defined by the core design system.</p>



<p>What are recipes, exactly? As the name suggests, recipes combine ingredients to create UI experiences that are complex, delicious, nutritious. The design system’s core components are the ingredients stocked in the pantry. Other product designers then take those ingredients to create product-specific compositions that meet their product needs. </p>



<p>A design system’s core component library might contain a card, button, button group, heading, text passage, badge, and key-value table. </p>



<figure><img decoding="async" loading="lazy" width="1024" height="435" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.32.33-1024x435.png" alt="A smattering of design system components: a card, heading, text passage, badge, button group, and key-value pair table" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.32.33-1024x435.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.32.33-700x297.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.32.33-768x326.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.32.33-1536x652.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-13.32.33.png 1818w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<p>Out of those ingredients, different product teams can create their own compositions to be used consistently across their digital products. The e-commerce team can compose a product card recipe, the marketing team can compose a promo card recipe, and the analytics team can compose a customer data card recipe. </p>



<figure><img decoding="async" loading="lazy" width="1024" height="445" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-14.12.20-1024x445.png" alt="A demonstration of product-level recipes: a product card recipe to be used on an e-commerce site&#39;s product listing page, a promo card recipe to used on a homepage or marketing experience, and a customer data card detailing customer info. All use the same underlying design system components but compose them to meet their needs." srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-14.12.20-1024x445.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-14.12.20-700x304.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-14.12.20-768x334.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-14.12.20-1536x667.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-14.12.20.png 1918w" sizes="(max-width: 1024px) 100vw, 1024px"/><figcaption>A demonstration of product-level recipes: a product card recipe to be used on an e-commerce site’s product listing page, a promo card recipe to used on a homepage or marketing experience, and a customer data card detailing customer info for use in an admin experience. All use the same underlying design system components but compose them to meet their needs.</figcaption></figure>



<p>The cool thing is that the design system team can monitor these recipes and decide to “graduate” a recipe component into the core design system if it proves to be super successful. While not every recipe is a core design system candidate, it’s cool that the recipe layer provides a little design system component incubator.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="577" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.05-1024x577.png" alt="An illustration showing the recipe  layer of a design system ecosystem. It shows a recipe design library, repo, code package, storybook, and reference website." srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.05-1024x577.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.05-700x394.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.05-768x433.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.05-1536x866.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.05-2048x1154.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h4>Recipe design libraries</h4>



<p>Think of recipe design libraries as cookbooks. They are Figma libraries that contain product- or discipline-specific components and compositions. Recipe libraries subscribe to both the design system foundations and core UI component libraries. Designers working in these libraries create composite components out of core design system components that are meant to be used consistently across their product or product family, but may not be abstract enough or broadly used enough (yet?) to include in the core design system. </p>



<p>Product design teams maintain and publish their own recipe libraries, and downstream product designers subscribe to them in order to use recipe components in individual product files.</p>



<h4>Recipe repositories</h4>



<p>Recipe code repositories contain the coded corollaries to the recipe Figma libraries. These repositories contain the source code for component compositions meant to be used consistently across a product or product family. A product’s website header is a great example of a recipe: the specific header composition is reusable across one product family, but likely distinct from other headers in other product families:</p>



<pre><code>&lt;site-header&gt;&lt;/site-header&gt;</code></pre>



<p>Specific card recipes can be created so downstream developers don’t have to assemble raw design system ingredients for every product card instance:</p>



<pre><code><code>&lt;product-card
  heading=&#34;Kids Sloth T-Shirt&#34;
  price=&#34;$18&#34; 
  imgSrc=&#34;path/to/image.jpg&#34;
  imgAlt=&#34;Purple t-shirt with smiling sloth illustration graphic&#34; 
  href=&#34;path/to-product&#34;&gt;
&lt;/product-card&gt;    
</code></code></pre>



<p>Developers can create reusable recipes as Web Components, React/Angular/Vue/etc components, or native components. Because recipes are product-specific, they can be written in whatever language is practical for the team and technical architecture.</p>



<h4>Recipe Storybooks</h4>



<p>We’ve discussed how important it is for design system teams to be able to view, review, test, and document core UI components, and the same holds true for coded recipe components. Each recipe repository ought to maintain and publish a Storybook for the recipes used in a product or product family. Any recipe Storybook should mirror the corresponding recipe Figma library.</p>



<h4>Recipe code packages</h4>



<p>In order for recipes to be consumable to downstream products developers, they need to be published on a software registry. </p>



<h4>Recipe reference websites</h4>



<p>Think of this as a product-specific style guide. If YouTube uses Google’s Material Design System, the YouTube reference site would detail the YouTube-specific components and recipes built on top of Material. It’s important to provide guidelines, rationale, and examples for recipes. How should designers and developers use that product card recipe? What are the configurations? The gotchas? </p>



<hr/>



<h2>Smart component layer (optional)</h2>



<p>Design system UI components are intentionally dumb. This is by design! In order to be as portable and interoperable as possible, design system components (and many recipes) don’t contain business logic and aren’t wired up to any backend services; they strictly handle a component’s presentation and basic functionality (e.g. an accordion opens and closes on click). </p>



<p>However, these components actually need to work eventually! Enter the smart component layer. If core design system components are strictly <a href="https://bradfrost.com/blog/post/front-of-the-front-end-and-back-of-the-front-end-web-development/">front-of-front-end</a>, then smart components introduce the back-of the-front-end. This is is a place where the dumb design system components and recipes get wrapped in logic in order to provide downstream development teams with drop-in, ready-to-use functional components and services.</p>



<p>Some smart component layer use cases include:</p>



<ul>
<li>Form submission and validation (e.g. <a href="https://react-hook-form.com/">React Hook Form</a> and <a href="https://bradfrost.com/">React Redux Form</a>)</li>



<li>Payment component for processing credit card payments</li>



<li>Typeahead querying specific services or databases (e.g. search a company directory or product database and the typeahead dropdown returns the appropriate results)</li>



<li>Data tables with sorting/filtering/searching logic (e.g <a href="https://www.ag-grid.com/">AG Grid</a>)</li>



<li>Product grids with sorting/filtering</li>



<li>Wiring up analytics to UI components</li>



<li>CMS-ready components that make design system and recipe components available to CMS editors.</li>
</ul>



<p>In the same way design systems keep teams from reinventing the wheel, these common smart components and services take care of common business logic and functionality so downstream teams can focus their energy on more worthwhile tasks.</p>



<p>We’ve seen this concept extend beyond smart components and into the realm of full-blown software starter kits. We’ve had a few clients develop their own custom boilerplates akin to Create React App: “here’s a NextJS environment with the design system tokens, components, and other recipes linked as dependencies, all the form fields wired up, and routes ready to go.” Product developer teams can quickly spin up a new project and immediately get to work building their application logic rather than futzing with plumbing and infrastructure. Pretty cool!</p>



<p>This layer is often maintained by the team that also supports the underlying service, using the design system components to deliver ready-to-roll solutions for application teams.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="577" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.38-1024x577.png" alt="An illustration showing the smart component layer of a design system ecosystem repo, code package for each smart component or service" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.38-1024x577.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.38-700x394.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.38-768x433.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.38-1536x865.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.58.38-2048x1154.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h4>Smart component repositories and packages</h4>



<p>The structure and location of smart component repositories and packages can vary wildly since they’re directly adjacent to specific product architecture built using specific technologies. But ultimately, smart components and drop-in services should be managed as discrete products to make usage, versioning, and maintenance as easy as possible. </p>



<hr/>



<h2>Product layer</h2>



<p>Friends, we have finally arrived! The product layer is where the rubber meets the road. This is where  all of this infrastructure comes together to help power real websites and apps used by real human beings. </p>



<p>It’s at this product level where a design system’s success can truly be measured. In order for a design system to be successful, it needs to become the critical front-end infrastructure that powers real digital products. So let’s discuss how all of this design system ecosystem makes its way into real product environments.</p>



<figure><img decoding="async" loading="lazy" width="1024" height="576" src="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.59.03-1024x576.png" alt="An illustration showing the product layer of a design system ecosystem showing a product design file and code repo for each product" srcset="https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.59.03-1024x576.png 1024w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.59.03-700x394.png 700w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.59.03-768x432.png 768w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.59.03-1536x864.png 1536w, https://bradfrost.com/wp-content/uploads/2023/09/CleanShot-2023-09-21-at-10.59.03-2048x1152.png 2048w" sizes="(max-width: 1024px) 100vw, 1024px"/></figure>



<h4>Product design files</h4>



<p>Product designers working at this layer would spin up Figma files that subscribe to:</p>



<ul>
<li>The design systems Foundations library with the appropriate theme applied</li>



<li>The design system’s UI component library</li>



<li>Any relevant recipe library </li>
</ul>



<p>With all of those tools at their disposal, designers can go about their business designing product-specific screens and flows. </p>



<h4>Product codebase powered by [framework]</h4>



<p>For organizations building React apps, here’s where you’d find apps powered by Next.js/Express/Remix/Gatsby/whatever. It’s at this layer that <a href="https://bradfrost.com/blog/post/front-of-the-front-end-and-back-of-the-front-end-web-development/">back-of-the-front-end things</a> like business logic, routing, state management, and cache invalidation come into play. </p>



<p>Product codebases consume as dependencies the appropriate framework flavor of the design system’s component library, any applicable recipe packages, and any smart components. A <code>package.json</code> file could look something like this: </p>



<pre><code>&#34;dependencies&#34;: {
  &#34;@your-org/design-system-name&#34;: &#34;^0.1.0&#34;,
  &#34;@your-org/marketing-site-recipes&#34;: &#34;^0.1.0&#34;,
  &#34;@your-org/smart-form-components&#34;: &#34;^0.1.0&#34;
}</code></pre>



<p>With these packages installed, product engineers can pull in design system components and recipes into their projects like so:</p>



<pre><code>import DsButton from &#34;@your-org/design-system-name/Button&#34;;
import SiteHeader from &#34;@your-org/marketing-site-recipes/SiteHeader&#34;;
import TextField from &#34;@your-org/smart-form-components/TextField&#34;;

&lt;SiteHeader /&gt;
&lt;form onSubmit={handleSubmit(onSubmit)}&gt;
  &lt;TextField label=&#34;Email&#34; /&gt;
  &lt;TextField label=&#34;Password&#34; /&gt;
  &lt;DsButton variant=&#34;primary&#34; text=&#34;Sign in&#34; /&gt;
&lt;/form&gt;</code></pre>



<p>The <code>SiteHeader</code> is provided by the recipe package. The <code>TextField</code> is coming from the smart component package that handles the form logic. And the <code>DsButton</code> is coming from the design system. The ecosystem provides all of the look and feel and even some common functionality, which frees up product developers’ time to focus on bringing the application to life. </p>



<h4>Product codebase not powered by [framework]</h4>



<p>Products that aren’t based on React/Angular/Vue/whatever can consume the design system’s Web Components directly, either via npm/yarn or even by pulling them into a regular ol’ webpage.</p>



<pre><code>&lt;head&gt;
  &lt;link rel=&#34;stylesheet&#34; href=&#34;ds.css&#34; /&gt;
  &lt;script type=&#34;module&#34; src=&#34;ds-web-components.js&#34;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;ds-button variant=&#34;primary&#34; text=&#34;Hello&#34;&gt;&lt;/ds-button&gt;
&lt;/body&gt;</code></pre>



<p>It’s worth stepping back for a second to marvel that the design system’s web component source of truth can power any web-based digital product — irrespective of tech stack. It’s incredible! And because these are directly consumable components, improvements and additions can be deployed simply by pulling down the latest version of the library. </p>



<h4>iOS/Android/Non-web product codebases</h4>



<p>As we’ve already covered, native apps are likely written in non-web languages, which means they can’t share in the web component goodness. Native app environments would pull in their own flavors of the component library as dependencies.</p>



<h2>It’s that easy, folks!</h2>



<p>Whew, what a ride, huh!? We’ve gone deep into the weeds, so let’s zoom out a bit. A mature design system ecosystem for a complex organization may not be simple, but this layer-cake approach provides a robust way to orchestrate UI for designers and developers across the company. The word “ecosystem” is apt here; these are interconnected systems that all play an important role in powering the UI of a company’s digital products.</p>



<p><strong>It bears repeating that every piece articulated here doesn’t apply to every organization.</strong> We’ve explained that most of these layers are optional and can be added iteratively. Start simple and iterate your way to a more complex ecosystem as real needs arise.</p>



<h2>It’s People!</h2>



<p>Here’s the fun part: you can craft all of these layers and assets and the whole thing can still fall to pieces. <strong>Design systems are less about assets and their relationships to one another, but more about people and their relationships to one another.</strong></p>



<p>What we’ve covered here simply defines the ingredients and relationships between the different assets of a design system ecosystem. Of course, it’s human beings that hold it all together. We’ll be following this article up with others that detail the <em>human</em> relationships and processes that make this whole Rube Goldberg machine work. Also, I’ll update this post with demos we’re putting together to show examples of nearly every piece of this vast ecosystem. </p>



<p>Do you see yourself in this post? We’d love to hear about how you’re defining and managing your organization’s design system ecosystem. And hey! Do you need help figuring out how to make all of this work? At <a href="https://bigmedium.com/">Big Medium</a>, we help complex organizations plan, architect, build, evolve, and manage design systems and other aspects of big design at scale. Feel free to <a href="https://bigmedium.com/hire/">get in touch</a>!</p>

		    </div></div>
  </body>
</html>
