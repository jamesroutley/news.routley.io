<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://rachelbythebay.com/w/2023/11/30/armv6/">Original</a>
    <h1>clang now makes binaries an original Pi B&#43; can&#39;t run</h1>
    
    
<p>
I have a bunch of Raspberry Pi systems all over the place, goofy things 
that they are.  They do dumb and annoying jobs in strange locations.  I 
even have one of the older models, which is called just the B+.  You can 
think of it as the &#34;1B+&#34; but apparently it was never officially branded 
the 1.
</p>
<p>
If you have one of these, or perhaps an original Pi Zero hanging around, 
you might find that C++ programs built with clang don&#39;t work any more.
I ran into this as soon as I started trying to take binaries from my 
&#34;build host&#34; (a much faster Pi 4B) to run them on this original beast.  
It throws an illegal instruction.
</p>
<p>
This used to work in the old version (bullseye).  It now breaks in the 
current one (bookworm).  I figured, okay, maybe it&#39;s doing some 
optimization because it was built on the 4B.  So, I went and did a build 
on the B+ natively.  It also broke.
</p>
<p>
So I backed off another level to a much simpler reproduction case: just 
declare main() and return.  That still broke.
</p>
<p>
Looking this up, there are a bunch of screwy dead-end forum posts where 
people go back and forth asserting this package is installed and that&#39;s 
making the compiler go stupid, or it&#39;s because they did the &#34;lite&#34; 
install vs. the &#34;recommended&#34; install, or who knows what.
</p>
<p>
I wanted to do better than that, so this afternoon I picked up a brand 
new SD card, blew the whole &#34;desktop + recommended&#34; OS image onto it, 
booted *that*, then installed clang, and...
</p>
<pre class="terminal">raspberrypi:~/prog$ cat t.cc
#include &lt;stdio.h&gt;

int main() {
  return 0;
}
raspberrypi:~/prog$ clang++ -Wall -o t t.cc
raspberrypi:~/prog$ ./t
Illegal instruction
</pre>
<p>
Awesome.  It can compile something it can&#39;t even run.  What&#39;s the bad 
instruction?  gdb will answer that in a jiffy.
</p>
<pre class="terminal">(gdb) disassemble
Dump of assembler code for function main:
   0x004005a4 &lt;+0&gt;:	sub	sp, sp, #4
=&gt; 0x004005a8 &lt;+4&gt;:	movw	r0, #0
</pre>
<p>
movw.  That&#39;s not in armv6l, apparently.  So yeah, this compiler is 
effectively cross-compiling for armv7 (or something) by default.  That&#39;s 
not very useful.
</p>
<p>
You can work around this by grabbing the compiler by the lapels and 
saying &#34;build for armv6, punk&#34;, and it will give you a working binary:
</p>
<pre class="terminal">raspberrypi:~/prog$ clang++ --target=armv6-unknown-linux-gnueabihf -Wall -o t t.cc
raspberrypi:~/prog$ ./t
raspberrypi:~/prog$ 
</pre>
<p>
How and why did it get to that point?  I can only imagine it&#39;s some 
default that got bumped from version 11 to version 12, and somehow 
nobody noticed?  I guess nobody still runs these old things anywhere?
</p>
<p>
So weird.
</p>

  </body>
</html>
