<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://ktkaufman03.github.io/blog/2022/09/04/pakon-reverse-engineering/">Original</a>
    <h1>Reviving the coolest scanner you&#39;ve never heard of</h1>
    
    <div id="readability-page-1" class="page"><div>
        <article>
  
  <time datetime="2022-09-04T01:18:00+00:00">04 Sep 2022</time>
  <em>


7433
 words; 50 minute read
</em>

  <h2 id="introduction">Introduction</h2>

<p>Today’s digital cameras are nothing short of incredible when it comes to ease-of-use and image quality, and many take them for granted, myself included. For those of us in “generation Z”, though, it’s all too easy to be ignorant of what came <em>before</em> this now ubiquitous technology.</p>

<h3 id="a-semi-brief-history">A semi-brief<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" rel="footnote">1</a></sup> history</h3>

<h4 id="the-rise-of-photo-cd">The rise of Photo CD</h4>
<p>In the ’90s and early 2000s, getting film developed wasn’t exactly something for the average person to do at home. Instead, “minilabs” were a popular destination - you could take your film negatives to the local pharmacy, and in a reasonable amount of time, you’d have prints of your pictures!</p>

<p>Now, prints are wonderful, but in 1990 Kodak came up with a better idea - digitizing photos and putting them on CDs. Thus began the era of the aptly named “Photo CD.” Photo CD was an entire line of products dedicated to the digitization of photos, including film scanners and special Photo CD players. Photo CD enjoyed some popularity for a number of years, but ultimately faded away due to its various issues (much like Kodak’s other attempts at breaking into the digital photography industry.)</p>

<h4 id="a-new-player-enters-the-field">A new player enters the field</h4>

<p>While Kodak’s Photo CD system languished, a relatively obscure company named Pakon was busy working on its own film scanner. It’s surprisingly difficult to find useful, confirmed information about Pakon, but public records and <a href="https://patents.google.com/patent/US5872591A/en">their first film scanner patent</a> indicate that their scanner work likely began in the early ’90s.</p>

<p>Sometime around 2001, Pakon was acquired by Kodak. In the following years, Kodak would go on to release several models of Pakon film scanners - the F-135, F-235, F-335 and all their variants, collectively referred to as “F-X35.” These scanners came with a comprehensive software package for use in minilabs, and an SDK even existed to facilitate the development of specialized clients.</p>

<p>The F-X35 scanners boasted high performance, great image quality and post-processing techniques<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" rel="footnote">2</a></sup>, and relative ease of use. To say that they were popular would be an understatement - they found their way into minilabs all over the United States, including those in such major pharmacy chains as CVS and Walmart.</p>

<h4 id="the-fall-and-rise-of-pakon">The fall (and rise) of Pakon</h4>

<p>Sadly, Pakon’s business met an untimely doom as the digital photography industry became dominant, and the company filed for bankruptcy in 2012. While there was still <em>some</em> demand for film scanning, there wasn’t <em>enough</em> demand, and pharmacy minilabs were scaled down. Amazingly, the scanners didn’t go to waste - hobbyists picked them up for pennies on the dollar, and a new community was formed. Today, a <a href="https://www.facebook.com/groups/657750677577306">Facebook group</a> dedicated to the Pakon scanner line boasts over 6,000 members, with a fair amount of weekly activity.</p>

<h3 id="pakon-today">Pakon, today</h3>

<p>With the software readily available, and the hardware being available as well (albeit for a pretty penny - some scanners go for as much as $2500), one would assume that the story ends here. Surprisingly, it <strong>doesn’t</strong> - for reasons we’ll explore together, the final version of the software is only usable on <strong>32-bit Windows XP</strong>! To make matters worse, setting it up tends to be extraordinarily difficult for anyone who doesn’t have a sacrificial computer - in that case, a virtual machine is necessary, which makes everything more complicated and extremely error-prone.</p>

<h3 id="why-does-this-even-matter">Why does this even matter?</h3>

<p>I’ll be honest - I’m not a photographer, and I personally have no reason to use a Pakon scanner. I happen to have <em>access</em> to one, though, and when I learned about its status as a user’s nightmare, I felt like taking a look. As a college student who is particularly interested in software preservation and reverse engineering, these scanners appealed to me - it turns out that <strong>people still want to use them</strong> despite their difficult nature, and I was interested in making that easier.</p>

<p>“But why would anyone still want to use this?”, you might ask. Sure, there are other film scanners that come to mind - Epson makes their own, Nikon used to make their Coolscan scanners, and there are countless others available. Any of these options are perfectly fine, and in fact, some are even <em>better</em> than the Pakon in terms of technical specifications. Where Pakon scanners truly shine is in their seamlessness - unlike other scanners that require film rolls to be pre-cut into strips, the Pakon will accept entire rolls, and does everything for you: detecting frame edges and cropping images appropriately, performing color correction that <em>actually works</em>, reading DX codes if they’re available, and finally, giving you a set of high-quality, effectively noise-free scans. It does all of this at breakneck pace, too. While there are other <em>film scanners</em>, none of them that I’m aware of can even come close to the Pakon’s convenience.</p>

<p>The ideal outcome for most of these users would be one where the Pakon scanner software is usable on modern versions of Windows, running on modern workstations - no more sacrificial laptops running 32-bit XP, and no more VMs that are slower than a tortoise.</p>

<p>Now, finally, let’s see how we can make that happen. Extremely technical content ahead!</p>

<h2 id="glossary">Glossary</h2>

<p><strong>TLA, B and C:</strong> Client libraries for the F-235, F-135 and F-335 scanners respectively.</p>

<p><strong>TLX:</strong> A wrapper around TLA, B and C. It is <em>the</em> Pakon scanner SDK. (TLA originally held this title, and then TLB and TLC came along.)</p>

<p><strong>PSI:</strong> Pakon Scanning Interface. All-in-one desktop app for minilabs to run scans, make CDs, and do all sorts of other things.</p>

<p><strong>TLXClientDemo:</strong> A much simpler interface that was meant to serve as a demo for the TLX SDK. It allows the user to control every setting and pretty much do whatever they want within the confines of the SDK. This app is also sometimes referred to as just “TLX”, which isn’t confusing at all!</p>

<p><strong>User-mode:</strong> Refers to code running in “userland” - for simplicity’s sake, think of this as the desktop environment that you interact with and run applications in. Anything in userland is subject to various safety checks and interventions to ensure that the entire system can’t be brought down by a single program crashing.</p>

<p><strong>Kernel-mode:</strong> Refers to code running at the kernel, or operating system level. User-mode safeguards don’t exist here, and many errors can cause the entire system to crash. On Windows, crashes of this nature trigger the notorious Blue Screen of Death, or <strong>BSOD</strong>.</p>

<p><strong>Anything not explicitly defined here or anywhere else in this article is assumed to be known by those who choose to read further. If you <em>don’t</em> know, your search engine of choice should come in handy - but in general, I won’t throw anything too obscure at you without explaining it myself.</strong></p>

<h2 id="getting-to-work---a-compatibility-investigation">Getting to work - a compatibility investigation</h2>

<h3 id="what-are-we-targeting">What are we targeting?</h3>

<p>Any external hardware that you want the operating system to be able to interact with requires a <strong>driver.</strong> At a high level, the driver is responsible for accepting commands from the operating system (often on behalf of the user) and processing them in some well-defined way. On Windows, devices exist as fake files (similar to Unix’s rule of “everything is a file”) that user-mode applications can interact with. These fake files are set up by device drivers.</p>

<p>Since Windows has an astonishing compatibility track record for “normal” software, and we’re dealing with some rather obscure and unique hardware that requires a special driver, we can <em>guess</em> that the driver is going to be the source of any issues that come up. To verify this guess, we just have to try running a scan on a 32-bit version of Windows that’s <strong>not</strong> XP. In my own tests, I went with Windows 10, and as soon as the scanning software was starting to actually do something…</p>

<p><em>(pause for dramatic effect)</em></p>

<p>The system crashed, shocking absolutely nobody, but greatly disappointing me. Just getting Windows to recognize the scanner’s very existence was a minor production, the details of which I’ve chosen to omit because of how boring they are in comparison to everything else. In the end, if it were as simple as manually installing some drivers, it’s very likely that someone would’ve figured it out years ago. Onward!</p>

<h3 id="isolating-the-problem">Isolating the problem</h3>

<p>In order to determine <em>why</em> the entire system crashes, we’ll have to use a <strong>kernel debugger.</strong> I went with <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">WinDbg</a>, mainly because it actually works (which is more than can be said of certain other debuggers), but also because I’m already somewhat familiar with it from past kernel adventures.</p>

<p>After a bit of setup, my testing virtual machine was all set for debugging. A few minutes later, and round 2 of testing began…</p>

<div><div><pre><code>REFERENCE_BY_POINTER (18)
Arguments:
Arg1: 00000000, Object type of the object whose reference count is being lowered
Arg2: 8d704d2c, Object whose reference count is being lowered
Arg3: 00000001, Reserved
Arg4: ee751000, Reserved
</code></pre></div></div>

<p>We got our first <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/bug-check-code-reference2">bug check</a>! Bug checks normally lead to BSODs, but now that we’re using a kernel debugger, we can take a look around before restarting the system. A bit more analysis (powered by WinDbg’s <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-analyze"><code>!analyze</code></a> command) reveals that a call to <code>ObfDereferenceObject</code> at <code>F135usb2.sys+0x1db4</code> is to blame.</p>

<p>If you have no idea what that meant, I’m happy for you. You’ve spared yourself the immense mental pain that comes with trying to figure out how any of this actually works. Now it’s time to go down the first of many rabbit holes - what <em>is</em> <code>ObfDereferenceObject</code>, what is it meant to do, and why is it catastrophically failing?</p>

<h3 id="kernel-lore---what-are-we-looking-at-here">Kernel lore - what are we looking at here?</h3>

<p>First and foremost, for reasons that are unclear to me, <code>ObfDereferenceObject</code> is exposed to driver developers through a <strong>macro</strong><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" rel="footnote">3</a></sup> called <code>ObDereferenceObject</code>. I don’t understand what the point of this even is, but in any case, we can find the documentation for the macro <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obdereferenceobject">here.</a></p>

<blockquote>
  <p>The <strong><code>ObDereferenceObject</code></strong> routine decrements the given object’s reference count and performs retention checks.</p>
  <div><div><pre><code><span>void</span> <span>ObDereferenceObject</span><span>(</span>
  <span>[</span><span>in</span><span>]</span>  <span>a</span>
<span>);</span>
</code></pre></div>  </div>
  <p><code>[in] a</code>: Pointer to the object’s body.</p>
</blockquote>

<p>This doesn’t seem all that complicated. Before moving on, though, we should make sure we know what an “object” is in this context. According to <a href="https://docs.microsoft.com/en-us/windows/win32/sysinfo/handles-and-objects">Microsoft documentation</a>:</p>

<blockquote>
  <p>An object is a data structure that represents a system resource, such as a file, thread, or graphic image. Your application can’t directly access object data, nor the system resource that an object represents. Instead, your application must obtain an object <em>handle</em>, which it can use to examine or modify the system resource. Each handle has an entry in an internally maintained table. Those entries contain the addresses of the resources, and the means to identify the resource type.</p>
</blockquote>

<p>So, essentially, an “object” in the Windows kernel is just a resource of some sort that can have data associated with it. Furthermore, the “reference count” mentioned earlier is the number of times some bit of code has said “I care about this thing, don’t let it go away!” by using one of the functions in the <code>ObReferenceObject</code> family, which we’ll learn more about later.</p>

<p>Let’s move on - we’re taking the scenic route with figuring out this crash. The ending will shock you.</p>

<h3 id="reverse-engineering-the-drivers">Reverse engineering the driver(s)</h3>

<p>When trying to fix something, it’s often necessary to actually <em>understand</em> it. This is where reverse engineering, or “reversing” skills come in handy, and I was up to the task. Since I was doing my tests with an F-135 scanner, I focused on the F-135 drivers, consisting of 3 files:</p>
<ul>
  <li><code>F135usb2.sys</code>: The device-specific driver.</li>
  <li><code>F235Ldr.sys</code>: A firmware loader driver that is shared by all scanner models.</li>
  <li><code>F235Lib.sys</code>: A “framework” driver that is also shared by all scanner models.</li>
</ul>

<h4 id="recon">Recon</h4>

<p>Whenever I reverse engineer software, my first goal is to identify code that came from <em>somewhere else</em> - whether that’s OpenSSL or the sample CD included in an obscure book, I want to know what I can <em>avoid</em> painstakingly reversing. This time was no different, and I got to work trying to figure out exactly what I was looking at.</p>

<p>First, I took a look at <code>F235Ldr.sys</code>. Interestingly, it came with a little bit of useful information:</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/f235ldr_metadata.png" alt="Image of F235Ldr.sys metadata. F235Ldr.sys is described as &#34;ezloader&#34; by &#34;Anchor Chips&#34;"/></p>

<p>This gave me a real lead to follow. A bit of additional research revealed that the “ezloader” component was part of the “EZ-USB” kit sold by a company called Anchor Chips<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" rel="footnote">4</a></sup>. Surprisingly, I was able to <em>find</em> one of these kits on eBay, and a few days later, it arrived:</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/anchorchips_box.jpg" width="480" height="640" alt="Image of a box labeled &#39;The EZ-USB(TM) Integrated Circuit&#39;"/></p>

<p>Amusingly, the package had never actually been opened, and contained the original packing slip… with a date several years before I was born, addressed to a company that I don’t think exists anymore.</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/anchorchips_packing_slip.jpg" width="480" height="640" alt="Image of a packing slip dated August 10, 1999"/></p>

<p>The package contained lots of hardware, some books, and best of all, two CDs with software and documentation! After a quick search, I found what I was looking for: the source code to <code>ezloader</code>.</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/anchorchips_ezloader_srcdir.png" alt="Image of a list of ezloader source files in File Explorer"/></p>

<p>The story of <code>F235Ldr.sys</code> doesn’t quite end here, though. I wanted to make sure that the code I got from the CD was the same as the code in the compiled driver. To do this, I would have to look at <code>F235Ldr.sys</code> under a microscope. My binary microscope of choice is <a href="https://hex-rays.com/ida-pro/">IDA Pro</a> with the <a href="https://hex-rays.com/decompiler/">Hex-Rays Decompiler</a>.</p>

<p>After browsing around <code>F235Ldr.sys</code> in IDA, and comparing the code to the <code>ezloader</code> source code, pretty much everything seemed identical. There was one difference, however: the version provided by Anchor Chips requires the device firmware to be embedded into the compiled driver, while the Pakon version reads firmware from <a href="https://en.wikipedia.org/wiki/Intel_HEX">Intel HEX</a> files. This was almost certainly done to facilitate the sharing of the driver among all of the different scanner models. No other significant code changes were made.</p>

<p>While reversing this driver from scratch would not have been difficult, I was happy to have saved some time.</p>

<p>My next target was <code>F235Lib.sys</code>, which proved to be somewhat more challenging to identify. It, too, had publisher information:</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/f235lib_metadata.png" alt="Image of F235Lib.sys metadata."/></p>

<p>I have to say, I never would have thought that a driver called <code>F235Lib</code> would be the “F235 Usb 2.0 Library Driver.” Since this information is practically useless, we’ll once again have to examine the file under the microscope.</p>

<p>Upon loading <code>F235Lib.sys</code> into IDA, I noticed it exported several functions, as would be expected of a library:</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/f235lib_exports.png" alt="Image of F235Lib.sys export list displayed in IDA Pro"/></p>

<p>I didn’t notice anything that <em>obviously</em> came from somewhere else, and looking at the list of strings in IDA (much like running the <code>strings</code> command on the file) didn’t reveal anything either. So I got to work reverse engineering all the different functions, aided somewhat by the presence of these exported function names - about half of the functions in the driver were named, and the other half were unknown.</p>

<p>I made a good amount of progress before I decided to make one last attempt at figuring out if there was more to the story. I searched for the name of one of the functions - <code>GenericHandlePowerIoctl</code> - and found <a href="https://github.com/artemsv/usbjk/blob/master/DOC/LkWork/src/LKsolutions/Driver/BTV/generic/Power.cpp">a match on GitHub</a>. I noticed the name “Walter Oney” at the top of the file:</p>
<div><div><pre><code><span>// Power request handler for Generic driver</span>
<span>// Copyright (C) 1999 by Walter Oney</span>
<span>// All rights reserved</span>
<span>// @doc</span>

<span>#include &#34;stddcls.h&#34;
</span><span>// ...</span>
</code></pre></div></div>

<p>My next search was for “Walter Oney USB”, as I figured this individual had <em>probably</em> (read: definitely) worked on device drivers. That led me to a book called “Programming the Microsoft Windows Driver Model”, <em>written by Oney</em> and published by Microsoft as the official how-to guide for Windows driver programming.</p>

<p>A further search for “Programming the Microsoft Windows Driver Model” led me to the <a href="https://resources.oreilly.com/examples/9780735618039">published sample code</a> from the second edition of the book. And sure enough, there was an entire “generic” driver included, with <strong>all of the functions</strong> that I had found within <code>F235Lib.sys</code>. Although I was somewhat disappointed to find some differences between the published sample code and the compiled code I was looking at, I realized that they could all be explained by the passing of time - the sample code I had obtained was from the <em>second</em>, not first edition of the book, and for that reason was likely younger than the Pakon driver.</p>

<p>Despite this surprise, I was able to match almost all functions and <em>all</em> data structures in the compiled <code>F235Lib.sys</code> driver to the sample source code. The Hex-Rays decompiler really came in handy here. As an aside, just look at this sample decompilation:</p>

<div><div><pre><code><span>NTSTATUS</span> <span>__stdcall</span> <span>SequenceCompletionRoutine</span><span>(</span><span>PDEVICE_OBJECT</span> <span>junk</span><span>,</span> <span>PIRP</span> <span>Irp</span><span>,</span> <span>PPOWCONTEXT</span> <span>Context</span><span>)</span>
<span>{</span>
  <span>Context</span><span>-&gt;</span><span>status</span> <span>=</span> <span>Irp</span><span>-&gt;</span><span>IoStatus</span><span>.</span><span>Status</span><span>;</span>
  <span>HandlePowerEvent</span><span>(</span><span>Context</span><span>,</span> <span>AsyncNotify</span><span>);</span>
  <span>IoFreeIrp</span><span>(</span><span>Irp</span><span>);</span>
  <span>return</span> <span>STATUS_MORE_PROCESSING_REQUIRED</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>and compare it to the original code:</p>
<div><div><pre><code><span>NTSTATUS</span> <span>SequenceCompletionRoutine</span><span>(</span><span>PDEVICE_OBJECT</span> <span>junk</span><span>,</span> <span>PIRP</span> <span>Irp</span><span>,</span> <span>PPOWCONTEXT</span> <span>ctx</span><span>)</span>
	<span>{</span>							<span>// SequenceCompletionRoutine</span>
	<span>(</span><span>void</span><span>)</span><span>junk</span><span>;</span>
	<span>ctx</span><span>-&gt;</span><span>status</span> <span>=</span> <span>Irp</span><span>-&gt;</span><span>IoStatus</span><span>.</span><span>Status</span><span>;</span>
	<span>HandlePowerEvent</span><span>(</span><span>ctx</span><span>,</span> <span>AsyncNotify</span><span>);</span>
	<span>IoFreeIrp</span><span>(</span><span>Irp</span><span>);</span>
	<span>return</span> <span>STATUS_MORE_PROCESSING_REQUIRED</span><span>;</span>
	<span>}</span>							<span>// SequenceCompletionRoutine</span>
</code></pre></div></div>

<p>The differences are so minor that they might as well not exist. There are plenty of excellent examples of the decompiler’s abilities, but this tangent has run its course already.</p>

<p>There really isn’t much else to cover for these 2 supplementary drivers - ultimately, they’re just repackaged and modified versions of code written by third parties.</p>

<h4 id="back-to-f135usb2">Back to F135usb2</h4>

<p>Now that we’ve dealt with the firmware loader and generic driver, it’s time to get back down to business and figure out why we were getting those pesky system crashes.</p>

<p>Here’s a reminder of what we were faced with earlier:</p>
<blockquote>
  <p>After a bit of setup, my testing virtual machine was all set for debugging. A few minutes later, and round 2 of testing began…</p>
  <div><div><pre><code>REFERENCE_BY_POINTER (18)
Arguments:
Arg1: 00000000, Object type of the object whose reference count is being lowered
Arg2: 8d704d2c, Object whose reference count is being lowered
Arg3: 00000001, Reserved
Arg4: ee751000, Reserved
</code></pre></div>  </div>
  <p>…</p>

  <p>A bit more analysis reveals that a call to <code>ObfDereferenceObject</code> at <code>F135usb2.sys+0x1db4</code> is to blame.</p>
</blockquote>

<p>What’s also worth noting about this bug check report is the value of “Arg4” - <code>0xee751000</code>. According to WinDbg, this bug check can occur</p>
<blockquote>
  <p>when the object’s reference count <strong>drops below zero</strong> whether or not there are open handles to the object; in that case, [Arg4] contains the actual value of the pointer references count.</p>
</blockquote>

<p><code>0xee751000</code>, when interpreted as a signed 32-bit integer, is a negative number. My first thought was that a kernel structure was being corrupted, but I couldn’t find anything in the driver that could possibly cause such a thing to happen.</p>

<p>With <code>F135usb2.sys</code> under the binary microscope, let’s try to figure out what’s going on.</p>

<p><strong>WARNING: <em>Extremely</em> technical content ahead!</strong> (But if you’ve made it this far, odds are you won’t be scared away now.)</p>

<p>According to IDA, the driver’s base address is <code>0x10000</code>. This means that <code>F135usb2.sys+0x1db4</code> refers to <code>0x10000+0x1db4</code>, or <code>0x11DB4</code>. Going to that address in IDA reveals the following relevant x86 assembly instructions:</p>

<div><div><pre><code>.text:00011DB1 004 8D 4E 34         	lea     ecx, [esi+34h]  ; Object
.text:00011DB4 004 FF 15 7C 27 01 00	call    ds:ObfDereferenceObject
</code></pre></div></div>

<p>The first instruction - <code>lea ecx, [esi+34h]</code> - is taking the value of the <code>esi</code> register, adding hexadecimal <code>34</code> (or decimal 52) to it, and storing it into the <code>ecx</code> register. The second instruction is calling the <code>ObfDereferenceObject</code> function.</p>

<p>Some very rough pseudo-C for these 2 instructions is <code>ObfDereferenceObject(&amp;esi_struct-&gt;field_0x34)</code>.</p>

<p>Now, figuring out what the problem was took me longer than I would have liked. After staring at this code for a fairly long time, though, I finally realized what was going on. The key was to understand what lies at <code>esi+34h</code>, as opposed to <strong>what <code>ObfDereferenceObject</code> expects to be given.</strong></p>

<p>IDA has a useful feature called “immediate search”, where one can search for constants and offsets used in instructions. Searching for <code>0x34</code> revealed a block of code at <code>F135usb2.sys+0x1cef</code> that seemed to be accessing the same field.</p>

<p>If you’re wondering where all of the symbol (variable/field/function) names came from, they’re based on my multi-day reverse engineering effort. This particular driver is pretty much a bunch of prewritten code glued together - some from Walter Oney’s book, some from Anchor Chips - with some Pakon-specific code on top, which made it pretty easy to figure out what the original names likely were.</p>

<div><div><pre><code><span>if</span> <span>(</span> <span>ObReferenceObjectByHandle</span><span>(</span>
	<span>pRingTail</span><span>-&gt;</span><span>EventScanPacketReady</span><span>,</span>
	<span>2u</span><span>,</span>
	<span>ExEventObjectType</span><span>,</span>
	<span>ctx</span><span>-&gt;</span><span>RequestorMode</span><span>,</span>
	<span>// `EventScanPacketReady` is the field at offset 0x34 in `ctx`. </span>
	<span>// Corresponding instructions: </span>
	<span>// 		lea     ecx, [esi+34h]</span>
	<span>//		push	ecx</span>
	<span>&amp;</span><span>ctx</span><span>-&gt;</span><span>EventScanPacketReady</span><span>,</span>
	<span>0u</span><span>)</span> <span>&gt;=</span> <span>0</span> <span>)</span>
<span>{</span>
	<span>// do some stuff</span>
<span>}</span>
</code></pre></div></div>

<p>This seems like pretty clear evidence that we found the right code. Earlier I mentioned the “<code>ObReferenceObject</code> family of functions”, and here we see one of them being used: <code>ObReferenceObjectByHandle</code>. Let’s read the friendly manual!</p>

<blockquote>
  <div><div><pre><code><span>NTSTATUS</span> <span>ObReferenceObjectByHandle</span><span>(</span>
  <span>[</span><span>in</span><span>]</span>            <span>HANDLE</span>                     <span>Handle</span><span>,</span>
  <span>[</span><span>in</span><span>]</span>            <span>ACCESS_MASK</span>                <span>DesiredAccess</span><span>,</span>
  <span>[</span><span>in</span><span>,</span> <span>optional</span><span>]</span>  <span>POBJECT_TYPE</span>               <span>ObjectType</span><span>,</span>
  <span>[</span><span>in</span><span>]</span>            <span>KPROCESSOR_MODE</span>            <span>AccessMode</span><span>,</span>
  <span>[</span><span>out</span><span>]</span>           <span>PVOID</span>                      <span>*</span><span>Object</span><span>,</span>
  <span>[</span><span>out</span><span>,</span> <span>optional</span><span>]</span> <span>POBJECT_HANDLE_INFORMATION</span> <span>HandleInformation</span>
<span>);</span>
</code></pre></div>  </div>
  <p><code>[in] Handle</code>: Specifies an open handle for an object.</p>

  <p>…</p>

  <p><code>[out] Object</code>: Pointer to a variable that receives a pointer to the object’s body. The following table contains the pointer types.</p>

  <p>…</p>
</blockquote>

<p>So, let’s get this straight:</p>
<ul>
  <li>The <code>Object</code> parameter is a “pointer to a variable that receives a pointer to the object’s body.” In other words, it is a <strong>pointer to a pointer</strong>, which allows the kernel to “fill in the blank”, so to speak.</li>
  <li>The driver is passing <code>&amp;ctx-&gt;EventScanPacketReady</code> as the <code>Object</code> parameter. <strong>This is totally fine and correct!</strong> <code>ctx-&gt;EventScanPacketReady</code> will be set by the kernel since we provided a <strong>pointer</strong> (or reference) to it.</li>
  <li>When this is done, <code>ctx-&gt;EventScanPacketReady</code> (note the lack of <code>&amp;</code>) will be a <strong>pointer to the event object’s body.</strong></li>
</ul>

<p>Now, let’s look at the code that’s calling <code>ObDereferenceObject</code>:</p>

<div><div><pre><code><span>void</span> <span>__stdcall</span> <span>ReleaseContextResources</span><span>(</span><span>PRWCONTEXT</span> <span>ctx</span><span>)</span>
<span>{</span>
  <span>if</span> <span>(</span> <span>...</span> <span>)</span>
  <span>{</span>
    <span>ObDereferenceObject</span><span>(</span><span>&amp;</span><span>ctx</span><span>-&gt;</span><span>EventScanPacketReady</span><span>);</span>
    <span>// ...</span>
  <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>and at the documentation for <code>ObDereferenceObject</code>…</p>

<blockquote>
  <p>The <strong><code>ObDereferenceObject</code></strong> routine decrements the given object’s reference count and performs retention checks.</p>
  <div><div><pre><code><span>void</span> <span>ObDereferenceObject</span><span>(</span>
  <span>[</span><span>in</span><span>]</span>  <span>a</span>
<span>);</span>
</code></pre></div>  </div>
  <p><code>[in] a</code>: Pointer to the object’s body.</p>
</blockquote>

<p>Hold on a second. <code>ObDereferenceObject</code> wants a “pointer to the object’s body”, but we’re giving it <code>&amp;ctx-&gt;EventScanPacketReady</code>… which is <em>a pointer to the pointer to the object’s body.</em> The reason the system crashes is because <em>we’re misdirecting it.</em> Remember this from earlier:</p>

<blockquote>
  <p>What’s also worth noting about this bug check report is the value of “Arg4” - <code>0xee751000</code>. According to WinDbg, this bug check can occur</p>
  <blockquote>
    <p>when the object’s reference count <strong>drops below zero</strong> whether or not there are open handles to the object; in that case, [Arg4] contains the actual value of the pointer references count.</p>
  </blockquote>

  <p><code>0xee751000</code>, when interpreted as a signed 32-bit integer, is a negative number.</p>
</blockquote>

<p>Recall that we’re supposed to provide <code>ObDereferenceObject</code> with a “pointer to the object’s <em>body.</em>” Every kernel object has a <em>header</em> that comes immediately before the body, and the header stores the reference count! Because we were providing a pointer to the body pointer, rather than the body pointer itself, the kernel was reading the object header from the wrong place. This explains the weird reference count.</p>

<p>Additionally, using WinDbg’s <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-object">!object</a> command on the supposed object body pointer (<code>8d704d2c</code>, from the bug check report) gives us a pretty damning error:</p>
<div><div><pre><code>1: kd&gt; !object 8d704d2c
8d704d2c: Not a valid object (ObjectType invalid)
</code></pre></div></div>

<p>It’s pretty obvious now that we’ve found the issue. For some reason, Windows XP’s implementation of <code>ObfDereferenceObject</code> doesn’t validate the object’s reference count, but that seems to have changed in Windows Vista. (This may be one of the only good parts of Vista.) Essentially, the only reason this code worked at all was an implementation detail.</p>

<p>The solution is almost infuriating in its simplicity: at <code>F135usb2.sys+0x1db1</code>, replace <code>lea ecx, [esi+34h]</code> with <code>mov ecx, [esi+34h]</code>. Thankfully, this can be done by changing a single byte: <code>8d 4e 34</code> changes to <code>8b 4e 34</code>. (A more precise search-replace is: <code>83 7e 24 00 74 2a 8d 4e 34</code> -&gt; <code>83 7e 24 00 74 2a 8b 4e 34</code>)</p>

<p>In source-code, this would amount to changing <code>ObDereferenceObject(&amp;ctx-&gt;EventScanPacketReady);</code> to <code>ObDereferenceObject(ctx-&gt;EventScanPacketReady);</code>. That’s right - <strong>a single rogue ampersand is to blame for the catastrophic failure.</strong></p>

<p>Re-install the patched driver, try a scan, and… it just works! Luckily, the exact same patch can be applied to the drivers for the other scanner models.</p>

<p>At this point, I was ready to release what I had and then call it quits. I realized that a 32-bit device driver had no chance at running on 64-bit Windows, and I figured this was likely the end of the road. I had a change of heart, though, and decided to give it a shot anyway.</p>

<h2 id="the-64-bit-journey">The 64-bit journey</h2>

<p>Much to the chagrin of many people who wish to use very old external devices that require special drivers, Windows doesn’t provide a compatibility layer for kernel drivers like it does for normal user-facing applications with <a href="https://docs.microsoft.com/en-us/windows/win32/winprog64/running-32-bit-applications">WoW64</a>. This means that all drivers <strong>must</strong> be compiled to run on a 64-bit system. One of the major obstacles to 64-bit support is dealing with the use of “pointer-precision” data - 32-bit systems use 32-bit pointers, but 64-bit systems use 64-bit pointers, and this difference in size has a whole bunch of cascading effects.</p>

<p>The “obvious” solution to this problem is to <em>just decompile the driver and recompile it</em>, but that’s much easier said than done. It requires a complete reverse-engineering of the original code, especially anything that will end up using pointer-precision data somehow (for example, structures that store pointers.) Not one to shy away from a seemingly impossible challenge, I decided to give it a shot.</p>

<h3 id="rebuilding-the-firmware-loader-driver">Rebuilding the firmware loader driver</h3>

<p>My first target was the firmware loader driver - <code>F235Ldr.sys</code>. My goal with each driver was to get as much code to cleanly decompile as possible, and clean up the rest manually. The loader was relatively easy to deal with, as it only had 24 relatively simple functions.</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/f235ldr_re_functions.png" alt="A screenshot of reverse engineered function names shown in IDA Pro."/></p>

<p>Interestingly, some of the “Ezusb” functions differed slightly from the sample code that came in my kit - I guess the Pakon developers were working with a later revision. Regardless, within a couple of days I had a 64-bit version of the firmware loader that <em>compiled</em> successfully. After fixing a minor mistake that came about while I was trying to get rid of some deprecation warnings<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" rel="footnote">5</a></sup>, the driver sprang into action and successfully downloaded firmware to the scanner!</p>

<h3 id="rebuilding-the-device-driver">Rebuilding the device driver</h3>

<p>As we discussed earlier, the Pakon <em>device</em> drivers consist of 2 components: Walter Oney’s “generic” driver (<code>F235Lib.sys</code>) and the actual device-specific driver (<code>F*35usb2.sys</code>.) I felt like doing things a bit differently - instead of having 2 separate drivers, I chose to merge them. I also took the liberty of using the newer version of Oney’s code, since it was readily available and presumably<sup id="fnref:6" role="doc-noteref"><a href="#fn:6" rel="footnote">6</a></sup> a bit more refined than the Pakon version. After a <em>lot</em> more decompilation and cleanup, I ran a test…</p>

<div><div><pre><code>F135USB - Configuring device from Pakon
F135USB - Product is F135-USB Film Scanner
F135USB - Serial number is xxx-yyy-zz
F135USB - Device reports 3 endpoints
F135usb2 - To WORKING from STOPPED
F135usb2 - PNP Request (IRP_MN_QUERY_CAPABILITIES)
F135usb2 - PNP Request (IRP_MN_QUERY_PNP_DEVICE_STATE)
F135usb2 - PNP Request (IRP_MN_QUERY_DEVICE_RELATIONS)
</code></pre></div></div>

<p>Excellent! It seemed to be working - at least until I <em>unplugged</em> the scanner, at which point things started to go wrong. Turns out the Generic driver had a pretty subtle bug…</p>

<h4 id="unplug-and-pray">Unplug-and-pray</h4>

<p>One of the many things the Generic driver takes care of is supporting <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/introduction-to-plug-and-play">Plug and Play</a>. For the most part, this just works and I don’t need to worry about it. However, there was one thing that clearly <em>didn’t</em> work - whatever code ran as soon as the device was no longer available.</p>

<p>WinDbg helpfully informed me that something was going wrong with these two functions:</p>

<div><div><pre><code><span>// Code is slightly modified from the original to remove some unimportant details</span>
<span>VOID</span> <span>DeregisterAllInterfaces</span><span>(</span><span>PGENERIC_EXTENSION</span> <span>pdx</span><span>)</span>
<span>{</span>
	<span>// ...</span>
	<span>while</span> <span>(</span><span>!</span><span>IsListEmpty</span><span>(</span><span>&amp;</span><span>pdx</span><span>-&gt;</span><span>iflist</span><span>))</span>
	<span>{</span>
		<span>PLIST_ENTRY</span> <span>list</span> <span>=</span> <span>RemoveHeadList</span><span>(</span><span>&amp;</span><span>pdx</span><span>-&gt;</span><span>iflist</span><span>);</span>
		<span>PINTERFACE_RECORD</span> <span>ifp</span> <span>=</span> <span>CONTAINING_RECORD</span><span>(</span><span>list</span><span>,</span> <span>INTERFACE_RECORD</span><span>,</span> <span>list</span><span>);</span>
		<span>DeregisterInterface</span><span>(</span><span>pdx</span><span>,</span> <span>ifp</span><span>);</span>
	<span>}</span>
	<span>// ...</span>
<span>}</span>

<span>VOID</span> <span>DeregisterInterface</span><span>(</span><span>PGENERIC_EXTENSION</span> <span>pdx</span><span>,</span> <span>PINTERFACE_RECORD</span> <span>ifp</span><span>)</span>
<span>{</span>
	<span>// ...</span>
	<span>RemoveEntryList</span><span>(</span><span>&amp;</span><span>ifp</span><span>-&gt;</span><span>list</span><span>);</span>
	<span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>The calls to <code>DeregisterInterface</code> from <code>DeregisterAllInterfaces</code> were failing, and bringing the entire system down with them! <code>RemoveEntryList</code> in particular was causing this, and figuring out why didn’t take too long: <code>DeregisterAllInterfaces</code> was removing an item from a list (using <code>RemoveHeadList</code>), and passing that item to <code>DeregisterInterface</code>… which then tried to remove it <em>again.</em> Pretty subtle, and it didn’t cause any issues in older versions of Windows, so I can understand how it went unnoticed.</p>

<p>Fixing this was trivial - I simply added a flag parameter to <code>DeregisterInterface</code> to dictate whether <code>RemoveEntryList</code> should be called.<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" rel="footnote">7</a></sup> From then on, I was free to power cycle the scanner with impunity. My next test: trying to run a scan.</p>

<h4 id="i-can-not-has-pictures">I can (not) has pictures?</h4>

<p>Considering how well things had gone so far, I was sure that scanning would <em>just work.</em> I launched TLX (remember that?) and was perplexed by what happened. TLX has 2 status indicators, one for “Scan” and one for “Save.” <em>Usually</em>, the “Scan” status would start off as “Initializing Scanner” and then quickly change to “Idle”, indicating it was all ready to go. In this test, however, it got stuck on “Initializing Scanner.” Thus began a journey down yet another rabbit hole.</p>

<p>In the background, I had also been reversing <code>TLB.dll</code> in hopes of learning about the communication protocol. Thanks to the abundance of detailed error codes, I was able to assign names to a lot of functions, <em>including</em> some relevant to communication! I suspected that the initialization issue was likely related to communications, so I started looking for ways to see what communications were happening.</p>

<p>My first attempt at this was on the kernel driver side, as I already knew which function in the device driver was responsible for facilitating this type of communication. I added some code to print <a href="https://en.wikipedia.org/wiki/Hex_dump">hex dumps</a> of the packets, and this is what I saw:</p>

<div><div><pre><code>Input buffer (client message): 04 03 10 00 85 
Output buffer (scanner response): 07 02 10 00 
Input buffer: 03 01 00
Output buffer: 07 02 00 09
</code></pre></div></div>

<p>Without context this is meaningless, but let’s compare it to the opening of a session recorded on a <em>32-bit</em> system with the original drivers, using WinDbg for the logging this time:</p>
<div><div><pre><code>Input buffer: 04 03 10 00 85
Output buffer: 07 02 10 00
Input buffer: 02 04 10 01 8f 00
Output buffer: 07 02 10 00
</code></pre></div></div>

<p>Clearly, something strange happened after the first message/response exchange of my 64-bit test. By reversing TLB’s communication code, I was able to determine the structure of the packets:</p>

<table>
  <thead>
    <tr>
      <th>offset</th>
      <th>type</th>
      <th>name</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>byte (enum)</td>
      <td>type</td>
      <td>Packet type</td>
    </tr>
    <tr>
      <td>1</td>
      <td>byte</td>
      <td>count</td>
      <td>Packet data length</td>
    </tr>
    <tr>
      <td>2</td>
      <td>bytes</td>
      <td>data</td>
      <td>Packet data (<code>count</code> bytes, up to 34)</td>
    </tr>
  </tbody>
</table>

<p>The basic structure of the packet data is as follows:</p>

<table>
  <thead>
    <tr>
      <th>offset</th>
      <th>type</th>
      <th>name</th>
      <th>description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>byte (enum)</td>
      <td>address</td>
      <td>Unknown purpose, but known possible values</td>
    </tr>
    <tr>
      <td>1</td>
      <td>bytes</td>
      <td>data</td>
      <td>Context-dependent.  For scanner, the first byte of this section is a  status code.</td>
    </tr>
  </tbody>
</table>

<p>Addresses are:</p>

<table>
  <thead>
    <tr>
      <th>Address</th>
      <th>Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0x10</td>
      <td>AD_HOST</td>
    </tr>
    <tr>
      <td>0x20</td>
      <td>AD_PICL</td>
    </tr>
    <tr>
      <td>0x22</td>
      <td>AD_BOOT_PICL</td>
    </tr>
    <tr>
      <td>0x24</td>
      <td>AD_PICM</td>
    </tr>
    <tr>
      <td>0x26</td>
      <td>AD_BOOT_PICM</td>
    </tr>
    <tr>
      <td>0x28</td>
      <td>unknown</td>
    </tr>
    <tr>
      <td>0x40</td>
      <td>AD_PICL_PLUS</td>
    </tr>
    <tr>
      <td>0x42</td>
      <td>AD_BOOT_PICL_PLUS</td>
    </tr>
    <tr>
      <td>0x44</td>
      <td>AD_PICM_PLUS</td>
    </tr>
    <tr>
      <td>0x46</td>
      <td>AD_BOOT_PICM_PLUS</td>
    </tr>
  </tbody>
</table>

<p>Scanner status codes are:</p>

<table>
  <thead>
    <tr>
      <th>Code</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td>Success</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Packet not acknowledged</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Invalid packet</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Invalid checksum</td>
    </tr>
    <tr>
      <td>4-6</td>
      <td>Something to do with USB?</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Unknown: “EC_DRV_PacketHostErrorAlgo”</td>
    </tr>
    <tr>
      <td>8</td>
      <td>Success</td>
    </tr>
    <tr>
      <td>9</td>
      <td>Bus error</td>
    </tr>
  </tbody>
</table>

<p>This tells us that the <strong>4th byte</strong> of a packet from the scanner is a <strong>status code.</strong> If it’s 0 or 8, everything is fine, but if it’s <em>not</em>, something’s gone wrong. Let’s look at the 64-bit test again:</p>

<div><div><pre><code>Input buffer (client message): 04 03 10 00 85 
Output buffer (scanner response): 07 02 10 00 
Input buffer: 03 01 00
Output buffer: 07 02 00 09
</code></pre></div></div>

<p>The first exchange in this log is fine - the scanner replies with a status code of 0 - but in the <em>second</em> exchange, the scanner replies with a status code of 9. This indicates a “bus error.” Not only that, but <code>03 01 00</code> looks <em>nothing at all</em> like <code>02 04 10 01 8f 00</code>! What happened here?</p>

<h4 id="the-perils-of-lying-to-the-os">The perils of lying to the OS</h4>

<p>I was so perplexed by this issue that I went right back into my debugger and started tracing the events that unfolded upon launching TLX. After collecting some data, I was able to identify the source of this weird packet: a function named <code>CiCmdComm::bDrvGetPpbDeviceReadyNL</code><sup id="fnref:8" role="doc-noteref"><a href="#fn:8" rel="footnote">8</a></sup>.</p>

<div><div><pre><code>  <span>// ...</span>
  <span>if</span> <span>(</span> <span>CiCmdComm</span><span>::</span><span>bDrvOpen</span><span>(</span><span>this</span><span>,</span> <span>errorHandler</span><span>)</span> <span>)</span>
  <span>{</span>
    <span>if</span> <span>(</span> <span>address</span> <span>==</span> <span>AD_HOST</span> <span>)</span>
    <span>{</span>
      <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>else</span>
    <span>{</span>
      <span>InBuffer</span><span>.</span><span>type</span> <span>=</span> <span>PH_READ_STATUS</span><span>;</span>
      <span>InBuffer</span><span>.</span><span>count</span> <span>=</span> <span>1</span><span>;</span>

      <span>// address is junk!!!</span>
      <span>InBuffer</span><span>.</span><span>address</span> <span>=</span> <span>address</span><span>;</span>

      <span>// start a busy loop, sending this packet repeatedly!</span>
    <span>}</span>
    <span>// ...</span>
  <span>}</span>
</code></pre></div></div>

<p>Note the comment about <code>address</code> being “junk” - recall that the <em>third</em> byte of every packet is an “address”, and <code>00</code> does <em>not</em> correspond to a valid address! The question is… where did <code>00</code> come from?</p>

<p>Working my way down the stack, I found that <code>CiCmdComm::bDrvGetPpbDeviceReadyNL</code> was being called from a function named <code>CiCmdComm::bDrvWritePacketNL</code>:</p>

<div><div><pre><code><span>int</span> <span>__thiscall</span> <span>CiCmdComm</span><span>::</span><span>bDrvWritePacketNL</span><span>(</span><span>CiCmdComm</span> <span>*</span><span>this</span><span>,</span> <span>CiErrorHandler</span> <span>*</span><span>errorHandler</span><span>,</span> <span>PPB_REQUEST</span> <span>*</span><span>requestPacket</span><span>)</span>
<span>{</span>
  <span>// ...</span>
  <span>while</span> <span>(</span> <span>CiCmdComm</span><span>::</span><span>bDrvPacketExecuteNL</span><span>(</span><span>this</span><span>,</span> <span>errorHandler</span><span>,</span> <span>requestPacket</span><span>,</span> <span>&amp;</span><span>responsePacket</span><span>)</span> <span>)</span>
  <span>{</span>
    <span>// ...</span>
    <span>{</span>
      <span>// ...</span>
      <span>if</span> <span>(</span> <span>!</span><span>CiCmdComm</span><span>::</span><span>bDrvGetPpbDeviceReadyNL</span><span>(</span><span>this</span><span>,</span> <span>errorHandler</span><span>,</span> <span>requestPacket</span><span>-&gt;</span><span>address</span><span>,</span> <span>&amp;</span><span>responsePacket</span><span>.</span><span>status</span><span>)</span>
        <span>||</span> <span>!</span><span>CiCmdComm</span><span>::</span><span>bDrvPacketHandleErrorNL</span><span>(</span>
              <span>this</span><span>,</span>
              <span>errorHandler</span><span>,</span>
              <span>requestPacket</span><span>-&gt;</span><span>address</span><span>,</span>
              <span>requestPacket</span><span>,</span>
              <span>&amp;</span><span>responsePacket</span><span>,</span>
              <span>&amp;</span><span>v13</span><span>,</span>
              <span>&amp;</span><span>v10</span><span>)</span> <span>)</span>
      <span>{</span>
        <span>break</span><span>;</span>
      <span>}</span>
	  <span>// ...</span>
    <span>}</span>
	<span>// ...</span>
  <span>}</span>
  <span>CiErrorHandler</span><span>::</span><span>LogError</span><span>(</span><span>errorHandler</span><span>,</span> <span>this</span><span>-&gt;</span><span>classId</span><span>,</span> <span>FN_bDrvWritePacketNL</span><span>,</span> <span>EC_PreviousError</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>,</span> <span>0</span><span>);</span>
  <span>return</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>At this point, I realized I was going to have to get more precise with my debugging if I wanted to figure out exactly where things were going wrong. My first revelation was that the call to <code>CiCmdComm::bDrvPacketExecuteNL</code> was <strong>corrupting the <code>requestPacket</code>!</strong></p>

<p>In <code>CiCmdComm::bDrvWritePacketNL</code>, the <code>requestPacket</code> started out totally valid:</p>
<div><div><pre><code>Stack[00001CDC]:04F8FD58 db 4       ; packet type: PH_CMD
Stack[00001CDC]:04F8FD59 db 3       ; data length: 3 bytes
Stack[00001CDC]:04F8FD5A db 10h     ; address: AD_HOST
Stack[00001CDC]:04F8FD5B db 0       ; unknown
Stack[00001CDC]:04F8FD5C db 85h     ; unknown
</code></pre></div></div>

<p>but oddly, after <code>CiCmdComm::bDrvPacketExecuteNL</code> was called, the first 4 bytes vanished!</p>
<div><div><pre><code>Stack[00001CDC]:04F8FD58 db 0		; packet type: PH_INVALID (0)
Stack[00001CDC]:04F8FD59 db 0		; data length: 0 bytes
Stack[00001CDC]:04F8FD5A db 0		; address: undefined (0)
Stack[00001CDC]:04F8FD5B db 0		; unknown
Stack[00001CDC]:04F8FD5C db 85h		; unknown
</code></pre></div></div>

<p>Next, I stepped through <code>CiCmdComm::bDrvPacketExecuteNL</code>, and discovered that the data corruption was happening <em>after the driver had finished processing the request.</em> <code>CiCmdComm::bDrvPacketExecuteNL</code> uses a function named <a href="https://docs.microsoft.com/en-us/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol"><code>DeviceIoControl</code></a> to send packets to the driver, and <em>immediately after</em> the call to <code>DeviceIoControl</code>, I observed the data corruption!</p>

<div><div><pre><code><span>int</span> <span>__thiscall</span> <span>CiCmdComm</span><span>::</span><span>bDrvPacketExecuteNL</span><span>(</span>
        <span>CiCmdComm</span> <span>*</span><span>this</span><span>,</span>
        <span>CiErrorHandler</span> <span>*</span><span>errorHandler</span><span>,</span>
        <span>PPB_PACKET</span> <span>*</span><span>requestPacket</span><span>,</span>
        <span>PPB_PACKET</span> <span>*</span><span>responsePacket</span><span>)</span>
<span>{</span>
  <span>// ...</span>
  <span>if</span> <span>(</span> <span>!</span><span>DeviceIoControl</span><span>(</span>
          <span>*</span><span>this</span><span>-&gt;</span><span>pDeviceFileHandle</span><span>,</span>
          <span>0x222090u</span><span>,</span>                <span>// IO control code for packet exchange</span>
          <span>requestPacket</span><span>,</span>            <span>// Input buffer</span>
          <span>requestPacket</span><span>-&gt;</span><span>count</span> <span>+</span> <span>2</span><span>,</span> <span>// Size of input buffer</span>
          <span>responsePacket</span><span>,</span>           <span>// Output buffer</span>
          <span>0x40u</span><span>,</span>                    <span>// Size of output buffer</span>
          <span>&amp;</span><span>numBytesReturned</span><span>,</span>
          <span>&amp;</span><span>this</span><span>-&gt;</span><span>m_DriverOverlappedPPB</span><span>)</span> <span>)</span>
  <span>{</span>
	<span>// error handling</span>
  <span>}</span>
  <span>// ... a bunch of other stuff</span>
<span>}</span>
</code></pre></div></div>

<p>Notice the “size of output buffer” supplied to <code>DeviceIoControl</code> - <code>0x40</code>, or 64. Therein lies the problem - <strong>the structure used for <code>responsePacket</code> is only 36 bytes in length.</strong> As a result of this inconsistency, <em>something</em> (possibly the USB stack) was zeroing out memory that it really shouldn’t have, which ultimately led to the strange packet we saw!</p>

<p>I have no clue how this code <em>ever</em> worked (thanks, implementation details…), but that’s beside the point. After making another one-byte patch to fix this, I was delighted to see TLX progress from “Initializing Scanner” all the way to “Idle” as I had hoped for!</p>

<h4 id="the-final-frontier---scanning">The final frontier - scanning</h4>

<p>It turned out that I wasn’t quite out of the woods yet - attempting to run a scan resulted in a mysterious error.</p>
<div><div><pre><code>CN_CiScanner FN_bCalibrateEndDataFlow EC_WIN_GetOverlappedResult (177) The parameter is incorrect.
CN_CiScanner FN_bCalibrateFindCorrections EC_PreviousError (25) 0
CN_CiScanner FN_bBeforeScan EC_PreviousError (25) 0
CN_Global FN_FuncScanPictures EC_PreviousError (25) 0
CN_Global FN_FuncScanPictures EC_PreviousError (25) 0
</code></pre></div></div>

<p>My driver reported a similar issue:</p>
<div><div><pre><code>F135USB - RingPacketComplete:103 [ERROR]: Ring packet info has failing status: 80000300 (USBD_STATUS_INVALID_PARAMETER)
</code></pre></div></div>

<p>I couldn’t figure out where this status code was even <em>coming</em> from at first, but the name gave me a hint: it had something to do with the USB stack. I eventually realized that I had failed to recognize a certain data structure for what it really was, and that some of my driver code was almost certainly incorrect as a result. Ironically, this idea came to me just as I was going to sleep. When I got up the following morning I updated the driver to account for my discovery, crossed my fingers, and clicked the “scan” button for the millionth time…</p>

<p>…and it worked! After the equivalent of a full work week dedicated to these custom drivers, they finally worked - not just on Windows 10, but Windows 11 too. Some extra tweaks were necessary to prevent various crashes, like one that only occurred when a USB 3.0 controller was being used, as well as to fix some issues detected by the <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/driver-verifier">Driver Verifier</a>.</p>

<p><img src="https://ktkaufman03.github.io/assets/2022-08-28-pakon-reverse-engineering/example_test_scan2.jpg" alt="Image of a successful scan on Windows 11"/></p>

<h2 id="the-end">The end</h2>

<p>In the course of this article, the Pakon film scanners went from being a user’s nightmare to being totally usable with modern versions of Windows. While not all of the Pakon client software has stood the test of time - the PSI application, for example, isn’t 100% functional - this opens the door for so much more development, potentially including a new scanning client.</p>

<p>There’s a lot that I <em>didn’t</em> discuss in this article, including a lot of the details of my reverse engineering process. In the future I might write an article specifically about that, as I learned a lot of valuable information about how the scanner really works that I think is well worth sharing.</p>

<p>If you made it this far, I applaud you. Thanks for reading!</p>

<hr/>



</article>



      </div></div>
  </body>
</html>
