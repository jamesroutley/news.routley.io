<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ShellImportanceOfASpace">Original</a>
    <h1>The importance of an ordinary space in a Unix shell command line</h1>
    
    <div id="readability-page-1" class="page"><div><h2>The importance of an ordinary space in a Unix shell command line</h2>

	<p><small>April 25, 2024</small></p>
</div><div><p>In the sidebar to <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/FindPruningThingsOut">yesterday&#39;s entry</a>
I (originally) made a Unix command line mistake by unthinkingly
leaving out an ordinary, innocent looking space (it&#39;s corrected in
the current version of the entry after it was noted by Emilio in a
comment). This innocent looking mistake and its consequences are
an illustration of something in Unix shell command lines, although
I&#39;m not sure of just what, so I&#39;m going to write it up.</p>

<p>The story starts with the general arguments of <a href="https://www.gnu.org/software/bash/manual/bash.html#index-read">Bash&#39;s &#39;<code>read</code>&#39;
builtin</a>:</p>

<blockquote><p><code>read [-ers] [-a <em>aname</em>] [-d <em>delim</em>] [-i <em>text</em>] [-n <em>nchars</em>]
[-N <em>nchars</em>] [-p <em>prompt</em>] [-t <em>timeout</em>] [-u <em>fd</em>] [<em>name</em> â€¦]</code></p>
</blockquote>

<p>The &#39;<code>read</code>&#39; builtin follows the general standard behavior of Unix
commands where &#39;-d <em>delim</em>&#39; and other options that take an argument
can be shortened to omit the space, so &#39;-d<em>delim</em>&#39;. So you can
write, for example:</p>

<blockquote><pre>echo &#34;a:b:c&#34; | while IFS= read -r -d&#39;:&#39; l; do echo &#34;$l&#34;; done
</pre>
</blockquote>

<p>Bash also has a special feature for -d. Normally the first character
of <em>delim</em> is taken as the &#39;line&#39; terminator, but if <em>delim</em> is
blank, <code>read</code> will terminate the line when it reads a NUL character
(0 byte), which is just what you want to handle the output of, for
example, &#39;find ... -print0&#39;.</p>

<p>The way you create an empty string argument in a Bash command line
is to use an empty pair of quotes:</p>

<blockquote><pre>read -r -d &#39;&#39; line
</pre>
</blockquote>

<p>So when I was writing the original command line in <a href="https://utcc.utoronto.ca/~cks/space/blog/sysadmin/FindPruningThingsOut">yesterday&#39;s
entry</a>, I absently mashed these two things together in my mind
and wrote:</p>

<blockquote><pre>read -r -d&#39;&#39; line
</pre>
</blockquote>

<p>I&#39;ve used &#39;&#39; to create an empty argument and then I&#39;ve done the
standard thing of removing the space between -d and its argument.
So clearly I&#39;ve given &#39;-d&#39; an empty argument, right? Nope.</p>

<p>In Bash and other conventional shells, &#39;&#39; is nothingness. It only
means an argument that is an empty string if it occurs on its own;
this is a special interpretation added by the shell, and programs
don&#39;t actually see the &#39;&#39;s. If you put a &#39;&#39; next to other non-whitespace
characters, it disappears in the command line that the program will
see. So writing <code>-d&#39;&#39;</code> was the same as writing <code>-d</code> with no argument,
and the command line as &#39;<code>read</code>&#39; would see it was actually:</p>

<blockquote><pre>read -r -d line
</pre>
</blockquote>

<p>Which would have caused &#39;<code>read</code>&#39; to use &#39;l&#39; as the line terminator.</p>

<p>In the process of writing this entry, I realized that there&#39;s a more
interesting way to make what is fundamentally the same mistake, although
it goes deeper into Unix arcana and doesn&#39;t look half as obvious.
In many modern shells, the Bourne shell included, you can write a
NUL character (0 byte) as <code>$&#39;\0&#39;</code>. So you will see people write
a &#39;read with NUL terminated lines&#39; command line as:</p>

<blockquote><pre>IFS= read -r -d $&#39;\0&#39; line
</pre>
</blockquote>

<p>This works fine, and unlike the &#39;&#39; case we obviously have a real
argument here, not just an empty argument, so clearly we can shorten
this to:</p>

<blockquote><pre>IFS= read -r -d$&#39;\0&#39; line
</pre>
</blockquote>

<p>If you try this you will discover it doesn&#39;t work. The fundamental
problem is that <strong>Unix command line arguments can&#39;t include NUL
characters</strong>, because the Unix command line API passes the arguments
as an array of NUL-terminate (C) strings. No matter how you invoke a
program, the first NUL character in an argument is the end of that
argument from the program&#39;s perspective. So although it looked very
different as typed, from <code>read</code>&#39;s perspective what we did was the
same as:</p>

<blockquote><pre>IFS= read -r -d line
</pre>
</blockquote>

<p>(And then it would have the same effect as my mistake.)</p>

<p>PS: This is a little tangled because &#39;<code>read</code>&#39; is a Bash builtin so
in theory Bash doesn&#39;t have to stick to the limits of the kernel
API, but in practice I think Bash does do so.</p>
</div></div>
  </body>
</html>
