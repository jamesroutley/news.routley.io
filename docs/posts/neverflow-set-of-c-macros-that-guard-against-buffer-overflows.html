<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/skullchap/neverflow">Original</a>
    <h1>Neverflow: Set of C macros that guard against buffer overflows</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text"><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/11740883/242778042-b7fe10e0-3c05-4716-8a27-94b343f17bf0.jpg"><img src="https://user-images.githubusercontent.com/11740883/242778042-b7fe10e0-3c05-4716-8a27-94b343f17bf0.jpg" width="350"/></a>

<h4 tabindex="-1" dir="auto"><a id="user-content-small-set-of-macros-that-guard-against-buffer-overflows-based-on-c99-vla-feature" aria-hidden="true" href="#small-set-of-macros-that-guard-against-buffer-overflows-based-on-c99-vla-feature"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Small set of macros that guard against buffer overflows. Based on C99 VLA feature.</h4>
<p dir="auto"><em>a little prologue...</em></p>
<p dir="auto">Such feature of C as a variable length array (VLA) has been discussed more than once, and most of the time in a bad light. Continuous discussions on how it&#39;s dangerous and not safe, complete ban from Linux source code, ignore by Microsoft compiler and etc., led VLA as a feature to become optional since C11.</p>
<p dir="auto">And many still miss a very important detail of this feature how it&#39;s not just being able to declare runtime arrays on stack that can blow it at any time, no. It&#39;s declaration of variably modified types.</p>
<p dir="auto">Long story short, heres <a href="https://www.bell-labs.com/usr/dmr/www/vararray.pdf" rel="nofollow">Dennnis Ritchie&#39;s paper on VLA&#39;s</a> and this pretty informative <a href="https://stackoverflow.com/a/54163435" rel="nofollow">StackOverflow answer</a> to clarify real usage of VLAs more.</p>
<h2 tabindex="-1" dir="auto"><a id="user-content-note-keep-in-mind-that-neverflow-is-not-quite-battle-tested-and-its-more-like-a-pilot-study-of-a-feature-at-this-moment" aria-hidden="true" href="#note-keep-in-mind-that-neverflow-is-not-quite-battle-tested-and-its-more-like-a-pilot-study-of-a-feature-at-this-moment"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a>Note: keep in mind that Neverflow is not quite &#34;battle&#34; tested, and it&#39;s more like a pilot study of a feature at this moment.</h2>
<p dir="auto">Roughly speaking, there are two main macros to keep in mind: <strong><code>NEW</code></strong> to declare array, and <strong><code>AT</code></strong> to runtime check if index is in bounds and return address to element behind it.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// NEW(TYPE, NAME, COUNT)
// AT(NAME, IDX)

#include &#34;neverflow.h&#34;

int 
main(void)
{
      NEW(int, myarr, 10);      // 10 element array declaration
      int *p = AT(myarr, 4);    // pointer to 5th element
      int  v = *AT(myarr, 4);   // getting value by dereferencing
      *AT(myarr, 4) = 56;       // changing value directly by dereferencing
  
      *AT(myarr, 30) = 56;      // here comes the oopsie doopsie
      // main.c:14: Buffer Overflow. Index [30] is out of range [0-9]
      // main.c:14: Function: main
}"><pre><span><span>//</span> NEW(TYPE, NAME, COUNT)</span>
<span><span>//</span> AT(NAME, IDX)</span>

#<span>include</span> <span><span>&#34;</span>neverflow.h<span>&#34;</span></span>

<span>int</span> 
<span>main</span>(<span>void</span>)
{
      <span>NEW</span>(<span>int</span>, myarr, <span>10</span>);      <span><span>//</span> 10 element array declaration</span>
      <span>int</span> *p = <span>AT</span>(myarr, <span>4</span>);    <span><span>//</span> pointer to 5th element</span>
      <span>int</span>  v = *<span>AT</span>(myarr, <span>4</span>);   <span><span>//</span> getting value by dereferencing</span>
      *<span>AT</span>(myarr, <span>4</span>) = <span>56</span>;       <span><span>//</span> changing value directly by dereferencing</span>
  
      *<span>AT</span>(myarr, <span>30</span>) = <span>56</span>;      <span><span>//</span> here comes the oopsie doopsie</span>
      <span><span>//</span> main.c:14: Buffer Overflow. Index [30] is out of range [0-9]</span>
      <span><span>//</span> main.c:14: Function: main</span>
}</pre></div>
<p dir="auto">To semantically better distinguish getting address of element in array or element itself, <strong><code>GET</code></strong> macro was made and is a shorthand to <strong><code>*AT</code></strong>. It literally defined as</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define GET(NAME, IDX) *AT(NAME, IDX)"><pre>#<span>define</span> <span>GET</span>(<span>NAME, IDX</span>) *<span>AT</span>(NAME, IDX)</pre></div>
<p dir="auto"><em>little things...</em></p>
<p dir="auto"><strong><code>LET</code></strong> is a shorthand for <code>__auto_type</code> and easier type inference while mainly using <strong><code>AT</code></strong>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="LET e1 = AT(myarr, 4);  // e1 is pointer to an int
LET e2 = *AT(myarr, 4); // e2 is int"><pre>LET <span>e1</span> = AT(myarr, <span>4</span>);  <span><span>//</span> e1 is pointer to an int</span>
LET <span>e2</span> = *<span>AT</span>(myarr, <span>4</span>); <span><span>//</span> e2 is int</span></pre></div>
<p dir="auto"><strong><code>SIZE(myarr)</code></strong> returns size of allocated memory. <strong>DON&#39;T USE sizeof directly on VLA without dereferencing! It will return sizeof pointer pointing to array</strong></p>
<p dir="auto"><strong><code>LEN(myarr)</code></strong> returns number of elements in array.</p>
<p dir="auto">By default, Neverflow uses stdlib&#39;s calloc as an alloc function and gcc/clang feature for auto free/cleanup when array will be out of scope/block.
To disable auto cleanup define <strong><code>NO_AUTOFREE</code></strong> before including <code>neverflow.h</code>. To use own alloc function define <strong><code>ALLOCF</code></strong>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="#define NO_AUTOFREE     // you will need to free yourself
#define ALLOCF malloc
#include &#34;neverflow.h&#34;

..."><pre>#<span>define</span> <span>NO_AUTOFREE</span>     <span><span>//</span> you will need to free yourself</span>
#<span>define</span> <span>ALLOCF</span> malloc
#<span>include</span> <span><span>&#34;</span>neverflow.h<span>&#34;</span></span>

...</pre></div>
<p dir="auto">Passing array to function while preserving neverflow features done with <strong><code>ARR</code></strong> macro using this way:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void 
func(int count, ARR(int, arr, count))
{
      int c = LEN(arr);
      printf(&#34;ELEM COUNT: %d\n&#34;, c); // 10

      *AT(arr, 12) = 42; // fails
      // main.c:13: Buffer Overflow. Index [12] is out of range [0-9]
      // main.c:13: Function: func
}

int 
main(void)
{
      NEW(int, myarr, 10); 

      int count = LEN(myarr);
      func(count, myarr);
}"><pre><span>void</span> 
<span>func</span>(<span>int</span> count, ARR(<span>int</span>, arr, count))
{
      <span>int</span> c = <span>LEN</span>(arr);
      <span>printf</span>(<span><span>&#34;</span>ELEM COUNT: <span>%d</span><span>\n</span><span>&#34;</span></span>, c); <span><span>//</span> 10</span>

      *<span>AT</span>(arr, <span>12</span>) = <span>42</span>; <span><span>//</span> fails</span>
      <span><span>//</span> main.c:13: Buffer Overflow. Index [12] is out of range [0-9]</span>
      <span><span>//</span> main.c:13: Function: func</span>
}

<span>int</span> 
<span>main</span>(<span>void</span>)
{
      <span>NEW</span>(<span>int</span>, myarr, <span>10</span>); 

      <span>int</span> count = <span>LEN</span>(myarr);
      <span>func</span>(count, myarr);
}</pre></div>
<p dir="auto">As a nice sideeffect of <strong><code>ARR</code></strong>, it&#39;s also possible to &#34;wrap&#34; raw pointers/arrays this way:</p>
<div dir="auto" data-snippet-clipboard-copy-content="void 
func(int count, ARR(int, arr, count))
{
      int c = LEN(arr);
      printf(&#34;ELEM COUNT: %d\n&#34;, c);
      printf(&#34;6th elem: %d\n&#34;, GET(arr, 5)); // 42
}

int 
main(void)
{
      void *p = malloc(10 * sizeof(int));
      ARR(int, myarr, 10) = p;
      *AT(myarr, 5) = 42;
      func(LEN(myarr), myarr);
}"><pre><span>void</span> 
<span>func</span>(<span>int</span> count, ARR(<span>int</span>, arr, count))
{
      <span>int</span> c = <span>LEN</span>(arr);
      <span>printf</span>(<span><span>&#34;</span>ELEM COUNT: <span>%d</span><span>\n</span><span>&#34;</span></span>, c);
      <span>printf</span>(<span><span>&#34;</span>6th elem: <span>%d</span><span>\n</span><span>&#34;</span></span>, <span>GET</span>(arr, <span>5</span>)); <span><span>//</span> 42</span>
}

<span>int</span> 
<span>main</span>(<span>void</span>)
{
      <span>void</span> *p = <span>malloc</span>(<span>10</span> * <span>sizeof</span>(<span>int</span>));
      <span>ARR</span>(<span>int</span>, myarr, <span>10</span>) = p;
      *<span>AT</span>(myarr, <span>5</span>) = <span>42</span>;
      <span>func</span>(<span>LEN</span>(myarr), myarr);
}</pre></div>

<p dir="auto">[0.0.2]  -  name mangling removed,
added ARR() macro to ease passing arrays to functions.
Another neat sideeffect of it, is possibility of wrapping raw pointer
and providing runtime bound checking.</p>
<p dir="auto">[0.0.1]  -  initial release</p>

<p dir="auto">MIT</p>
</article>
          </div></div>
  </body>
</html>
