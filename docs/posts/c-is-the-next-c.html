<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2657r0.html">Original</a>
    <h1>C&#43;&#43; is the next C&#43;&#43;</h1>
    
    <div id="readability-page-1" class="page"><div id="doc" data-hard-breaks="true"><table>
<tbody><tr>
<td>Document number</td>
<td>P2657R0</td>
</tr>
<tr>
<td>Date</td>
<td>2022-10-11</td>
</tr>
<tr>
<td>Reply-to</td>
<td>
<p><span>Jarrad J. Waterloo &lt;descender76 at gmail dot com&gt;</span></p>
</td>
</tr>
<tr>
<td>Audience</td>
<td>Evolution Working Group (EWG)</td>
</tr>
</tbody></table><h2 id="Table-of-contents" data-id="Table-of-contents"><a href="#Table-of-contents" title="Table-of-contents"><span></span></a><span>Table of contents</span></h2><ul>
<li><a href="#c-is-the-next-c"><span>C++ is the next C++</span></a>
<ul>
<li><a href="#abstract"><span>Abstract</span></a></li>
<li><a href="#motivating-examples"><span>Motivating examples</span></a></li>
<li><a href="#summary"><span>Summary</span></a></li>
<li><a href="#frequently-asked-questions"><span>Frequently Asked Questions</span></a></li>
<li><a href="#references"><span>References</span></a></li>
</ul>
</li>
</ul><h2 id="Abstract" data-id="Abstract"><a href="#Abstract" title="Abstract"><span></span></a><span>Abstract</span></h2><p><span>Programmer’s, Businesses and Government(s) want C++ to be safer and simpler. This has led some </span><code>C++</code><span> programmers to create new programming languages or preprocessors, which again is a new language. This paper discusses using static analysis to make the </span><code>C++</code><span> language itself safer and simpler.</span></p><h2 id="Motivating-Examples" data-id="Motivating-Examples"><a href="#Motivating-Examples" title="Motivating-Examples"><span></span></a><span>Motivating Examples</span></h2><p><span>Following is a wishlist. Most are optional. While, they all would be of benefit. It all starts with a new repeatable module level attribute that would preferably be applied once in the </span><code>primary module interface unit</code><span> and would automatically apply to it and all </span><code>module implementation unit</code><span>(s). It could also be applied to a </span><code>module implementation unit</code><span> but that would generally be less useful. However, it might aid in </span><em><span>gradual migration</span></em><span>.</span></p><pre><code><span>export</span> <span>module</span> <span>some_module_name</span> <span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>]</span><span>]</span><span>;</span>

<span>module</span> <span>some_module_name</span> <span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;&#34;</span><span>)</span><span>]</span><span>]</span><span>;</span>
</code></pre><ul>
<li><span>It would be ideal if the name member of the </span><code>static_analysis</code><span> attribute could be passed as either an environment variable and/or command line argument to compilers so it could be used by pipelines to assert the degree of conformance to the defined static analyzer without actually changing the source.</span></li>
<li><span>It would be ideal if compilers could standardize the environment variable name or command line argument name in order to ease tooling.</span></li>
<li><span>It would be ideal if compilers could produce a machine readable report in JSON, YAML or something else so that pipelines could more easily consume the results.</span></li>
<li><span>It would be ideal if compilers could standardize the machine readable report.</span></li>
</ul><p><span>The name of the static analyzer are dotted. Unscoped or names that start with </span><code>std.</code><span>, </span><code>c++.</code><span>, </span><code>cpp.</code><span>, </span><code>cxx.</code><span> or </span><code>c.</code><span> are reserved for standardization.</span></p><p><span>This proposal wants to stardardize two overarching static analyzer names; </span><code>safer</code><span> and </span><code>modern</code><span>.</span></p><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;safer&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><span>The </span><code>safer</code><span> analyzer is for safety, primarily memory related. It is for those businesses and programmers who must conform to safety standards.</span></p>
</td>
</tr>
<tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;modern&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><span>The </span><code>safer</code><span> analyzer is a subset of </span><code>modern</code><span> analyzer. The </span><code>modern</code><span> analyzer goes beyond just memory and safety concerns. It can be thought of as bleeding edge. It is for those businesses and programmers who commit to safety and higher quality modern code.</span></p>
</td>
</tr>
</tbody></table><p><span>Neither is concerned about formatting or nitpicking. Both static analyzers only produce errors. These are meant for programmers, businesses and governments in which safety takes precedence. They both represent +∞. When a new version of the standard is released and adds new sub static analyzers than everyone’s code is broken, until their code is fixed. These sub static analyzers usually consist of features that have been mostly replaced with some other feature. It would be ideal if the errors produced not only say that the code is wrong but also provide a link to html page(s) maintained by the </span><code>C++</code><span> teaching group, the authors of the </span><code>C++ Core Guidelines</code><span> </span><span> and compiler specific errors. These pages should provide example(s) of what is being replaced and by what was it replaced. Mentioning the version of the </span><code>C++</code><span> standard would also be helpful.</span></p><p><span>All modules can be used even if they don’t use the </span><code>static_analysis</code><span> attribute as this allows </span><em><span>gradual adoption</span></em><span>.</span></p><h3 id="What-are-the-safer-and-modern-analyzers-composed-of" data-id="What-are-the-safer-and-modern-analyzers-composed-of"><a href="#What-are-the-safer-and-modern-analyzers-composed-of" title="What-are-the-safer-and-modern-analyzers-composed-of"><span></span></a><span>What are the </span><code>safer</code><span> and </span><code>modern</code><span> analyzers composed of?</span></h3><p><span>These overarching static analyzers are composed of multiple static analyzers which can be used individually to allow a degree of </span><em><span>gradual adoption</span></em><span>.</span></p><h4 id="Use-lvalue-references" data-id="Use-lvalue-references"><a href="#Use-lvalue-references" title="Use-lvalue-references"><span></span></a><span>Use lvalue references</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;use_lvalue_references&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>use_lvalue_references</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Any declaration of a pointer is an error.</span></li>
<li><span>Calling any function that has parameters that take a pointer is an error unless the pointer type are “pointer to </span><code>const</code><span> character type” or “</span><code>const</code><span> pointer to </span><code>const</code><span> character type” and their arguments were string literals.</span>
<ul>
<li><span>string literals are always safe having static storage duration</span></li>
<li><code>std::string</code><span> and </span><code>std::string_view</code><span> must be creatable at compile time</span></li>
</ul>
</li>
<li><span>Function pointers and member function pointers can still be used.</span>
<ul>
<li><span>Function pointers and member function pointers that declare pointers to non [member] function pointers produces an error.</span></li>
</ul>
</li>
<li><span>Lvalue references, &amp;, can still be used.</span></li>
</ul><p><strong><span>WHY?</span></strong></p><ul>
<li><span>A large portion of the C++ community have been programming without pointers for years. Some can go their whole career this way. This proposal just standardise existing practice.</span></li>
<li><span>Modern </span><code>C++</code><span> has been advocated to programmers in other programming languages who complain about memory issues. This allows us to show them what we have been saying for decades.</span></li>
<li><span>Over half of our memory related issues gets hashed away.</span></li>
<li><span>Pointers have largely been replaced with the following:</span></li>
</ul><table>
<tbody><tr>
<td>
<p><span>lvalue references</span></p>
</td>
<td>
<p><span>1985: Cfront 1.0 </span></p>
</td>
</tr>
<tr>
<td>
<p><span>STL</span></p>
</td>
<td>
<p><span>1992 </span></p>
</td>
</tr>
<tr>
<td>
<p><code>std::unique_ptr</code><span>, </span><code>std::shared_ptr</code><span>, </span><code>std::weak_ptr</code><span>, </span><code>std::reference_wrapper</code><span>, </span><code>std::make_shared</code></p>
</td>
<td>
<p><span>C++11</span></p>
</td>
</tr>
<tr>
<td>
<p><code>std::make_unique</code></p>
</td>
<td>
<p><span>C++14</span></p>
</td>
</tr>
<tr>
<td>
<p><code>std::string_view</code><span>, </span><code>std::optional</code><span>, </span><code>std::any</code><span>, </span><code>std::variant</code></p>
</td>
<td>
<p><span>C++17</span></p>
</td>
</tr>
<tr>
<td>
<p><code>std::make_shared</code><span> support arrays, </span><code>std::span</code></p>
</td>
<td>
<p><span>C++20</span></p>
</td>
</tr>
</tbody></table><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>P.4: Ideally, a program should be statically type safe</code><span> </span></li>
<li><code>P.6: What cannot be checked at compile time should be checkable at run time</code><span> </span></li>
<li><code>P.7: Catch run-time errors early</code><span> </span></li>
<li><code>P.8: Don’t leak any resources</code><span> </span></li>
<li><code>P.11: Encapsulate messy constructs, rather than spreading through the code</code><span> </span></li>
<li><code>P.12: Use supporting tools as appropriate</code><span> </span></li>
<li><code>P.13: Use support libraries as appropriate</code><span> </span></li>
<li><code>I.4: Make interfaces precisely and strongly typed</code><span> </span></li>
<li><code>I.11: Never transfer ownership by a raw pointer (T*) or reference (T&amp;)</code><span> </span></li>
<li><code>I.12: Declare a pointer that must not be null as not_null</code><span> </span></li>
<li><code>I.13: Do not pass an array as a single pointer</code><span> </span></li>
<li><code>I.23: Keep the number of function arguments low</code><span> </span></li>
<li><code>F.7: For general use, take T* or T&amp; arguments rather than smart pointers</code><span> </span></li>
<li><code>F.15: Prefer simple and conventional ways of passing information</code><span> </span></li>
<li><code>F.22: Use T* or owner&lt;T*&gt; to designate a single object</code><span> </span></li>
<li><code>F.23: Use a not_null&lt;T&gt; to indicate that “null” is not a valid value</code><span> </span></li>
<li><code>F.25: Use a zstring or a not_null&lt;zstring&gt; to designate a C-style string</code><span> </span></li>
<li><code>F.26: Use a unique_ptr&lt;T&gt; to transfer ownership where a pointer is needed</code><span> </span></li>
<li><code>F.27: Use a shared_ptr&lt;T&gt; to share ownership</code><span> </span></li>
<li><code>F.42: Return a T* to indicate a position (only)</code><span> </span></li>
<li><code>F.43: Never (directly or indirectly) return a pointer or a reference to a local object</code><span> </span></li>
<li><code>C.31: All resources acquired by a class must be released by the class’s destructor</code><span> </span></li>
<li><code>C.32: If a class has a raw pointer (T*) or reference (T&amp;), consider whether it might be owning</code><span> </span></li>
<li><code>C.33: If a class has an owning pointer member, define a destructor</code><span> </span></li>
<li><code>C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new</code><span> </span></li>
<li><code>C.150: Use make_unique() to construct objects owned by unique_ptrs</code><span> </span></li>
<li><code>C.151: Use make_shared() to construct objects owned by shared_ptrs</code><span> </span></li>
<li><code>R.1: Manage resources automatically using resource handles and RAII (Resource Acquisition Is Initialization)</code><span> </span></li>
<li><code>R.2: In interfaces, use raw pointers to denote individual objects (only)</code><span> </span></li>
<li><code>R.3: A raw pointer (a T*) is non-owning</code><span> </span></li>
<li><code>R.5: Prefer scoped objects, don’t heap-allocate unnecessarily</code><span> </span></li>
<li><code>R.10: Avoid malloc() and free()</code><span> </span></li>
<li><code>R.11: Avoid calling new and delete explicitly</code><span> </span></li>
<li><code>R.12: Immediately give the result of an explicit resource allocation to a manager object</code><span> </span></li>
<li><code>R.13: Perform at most one explicit resource allocation in a single expression statement</code><span> </span></li>
<li><code>R.14: Avoid [] parameters, prefer span</code><span> </span></li>
<li><code>R.15: Always overload matched allocation/deallocation pairs</code><span> </span></li>
<li><code>R.20: Use unique_ptr or shared_ptr to represent ownership</code><span> </span></li>
<li><code>R.22: Use make_shared() to make shared_ptrs</code><span> </span></li>
<li><code>R.23: Use make_unique() to make unique_ptrs</code><span> </span></li>
<li><code>ES.20: Always initialize an object</code><span> </span></li>
<li><code>ES.24: Use a unique_ptr&lt;T&gt; to hold pointers</code><span> </span></li>
<li><code>ES.42: Keep use of pointers simple and straightforward</code><span> </span></li>
<li><code>ES.47: Use nullptr rather than 0 or NULL</code><span> </span></li>
<li><code>ES.60: Avoid new and delete outside resource management functions</code><span> </span></li>
<li><code>ES.61: Delete arrays using delete[] and non-arrays using delete</code><span> </span></li>
<li><code>ES.65: Don’t dereference an invalid pointer</code><span> </span></li>
<li><code>E.13: Never throw while being the direct owner of an object</code><span> </span></li>
<li><code>CPL.1: Prefer C++ to C</code><span> </span></li>
</ul><p><strong><span>Gotchas</span></strong></p><p><strong><span>Usage of smart pointers</span></strong></p><p><span>This static analyzer causes programmers to use 2 extra characters when using smart pointers, </span><code>-&gt;</code><span> vs </span><code>(*).</code><span>, since the overloaded </span><code>-&gt;</code><span> operator returns a pointer.</span></p><table>
<tbody><tr>
<td>
<pre><code>smart_pointer<span>-&gt;</span><span>some_function</span><span>(</span><span>)</span><span>;</span>
</code></pre>
</td>
<td>
<pre><code><span>(</span><span>*</span>smart_pointer<span>)</span><span>.</span><span>some_function</span><span>(</span><span>)</span><span>;</span>
</code></pre>
</td>
</tr>
</tbody></table><p><strong><span>the main function and environment variables</span></strong></p><p><span>A shim module is needed in order to transform main and env functions into a more C++ friendly functions. These have been asked for years.</span></p><ol>
<li><code>A Modern C++ Signature for main</code><span> </span></li>
<li><code>Desert Sessions: Improving hostile environment interactions</code><span> </span></li>
</ol><hr/><h4 id="No-unsafe-casts" data-id="No-unsafe-casts"><a href="#No-unsafe-casts" title="No-unsafe-casts"><span></span></a><span>No unsafe casts</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_unsafe_casts&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_unsafe_casts</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using </span><code>C</code><span>/core cast produces an error.</span></li>
<li><span>Using </span><code>reinterpret_cast</code><span> produces an error.</span></li>
<li><span>Using </span><code>const_cast</code><span> produces an error.</span></li>
</ul><p><span>Why?</span></p><ul>
<li><code>C</code><span>/core cast was replaced by </span><code>static_cast</code><span> and </span><code>dynamic_cast</code><span>.</span></li>
<li><span>The </span><code>reinterpret_cast</code><span> is needed more for library authors than their users. For library users it usually just causes problems and questions. It is rarely used in daily </span><code>C++</code><span> when coding at a higher level.</span></li>
<li><span>The </span><code>const_cast</code><span> is needed more for library authors than their users. It is a means for the programmer to lie to oneself. For library users it usually just causes problems and questions. It is rarely used in daily </span><code>C++</code><span> when coding at a higher level.</span></li>
</ul><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>C.146: Use dynamic_cast where class hierarchy navigation is unavoidable</code><span> </span></li>
<li><code>ES.48: Avoid casts</code><span> </span></li>
<li><code>ES.49: If you must use a cast, use a named cast</code><span> </span></li>
<li><code>ES.50: Don’t cast away const</code><span> </span></li>
</ul><hr/><h4 id="No-unions" data-id="No-unions"><a href="#No-unions" title="No-unions"><span></span></a><span>No unions</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_union&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_union</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using the </span><code>union</code><span> keyword produces an error.</span></li>
</ul><p><span>It was replaced by </span><code>std::variant</code><span>, which is safer.</span></p><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>C.181: Avoid “naked” unions</code><span> </span></li>
</ul><hr/><h4 id="No-mutable" data-id="No-mutable"><a href="#No-mutable" title="No-mutable"><span></span></a><span>No mutable</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_mutable&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_mutable</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using the </span><code>mutable</code><span> keyword produces an error.</span></li>
</ul><p><span>The programmer shall not lie to oneself. The </span><code>mutable</code><span> keyword violates the safety of </span><code>const</code><span> and is rarely used at a high level.</span></p><hr/><h4 id="No-new-or-delete" data-id="No-new-or-delete"><a href="#No-new-or-delete" title="No-new-or-delete"><span></span></a><span>No new or delete</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_new_delete&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_new_delete</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using the </span><code>new</code><span> and </span><code>delete</code><span> keywords to allocate and deallocate memory produces an error.</span></li>
</ul><p><span>It was replaced by </span><code>std::make_unique</code><span> and </span><code>std::make_shared</code><span>, which are safer.</span></p><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>F.26: Use a unique_ptr&lt;T&gt; to transfer ownership where a pointer is needed</code><span> </span></li>
<li><code>F.27: Use a shared_ptr&lt;T&gt; to share ownership</code><span> </span></li>
<li><code>C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new</code><span> </span></li>
<li><code>C.150: Use make_unique() to construct objects owned by unique_ptrs</code><span> </span></li>
<li><code>C.151: Use make_shared() to construct objects owned by shared_ptrs</code><span> </span></li>
<li><code>R.11: Avoid calling new and delete explicitly</code><span> </span></li>
<li><code>R.20: Use unique_ptr or shared_ptr to represent ownership</code><span> </span></li>
<li><code>R.22: Use make_shared() to make shared_ptrs</code><span> </span></li>
<li><code>R.23: Use make_unique() to make unique_ptrs</code><span> </span></li>
<li><code>ES.60: Avoid new and delete outside resource management functions</code><span> </span></li>
<li><code>ES.61: Delete arrays using delete[] and non-arrays using delete</code><span> </span></li>
</ul><hr/><h4 id="No-volatile" data-id="No-volatile"><a href="#No-volatile" title="No-volatile"><span></span></a><span>No volatile</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_volatile&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_volatile</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using the </span><code>volatile</code><span> keyword produces an error.</span></li>
</ul><p><span>The </span><code>volatile</code><span> keyword has nothing to do with concurrency. Use </span><code>std::atomic</code><span> or </span><code>std::mutex</code><span> instead.</span></p><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>CP.8: Don’t try to use volatile for synchronization</code><span> </span></li>
</ul><hr/><h4 id="No-C-style-variadic-functions" data-id="No-C-style-variadic-functions"><a href="#No-C-style-variadic-functions" title="No-C-style-variadic-functions"><span></span></a><span>No </span><code>C</code><span> style variadic functions</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_c_style_variadic_functions&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_c_style_variadic_functions</code><span> is a subset of </span><code>safer</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Declaring a </span><code>C</code><span> style variadic function produces an error.</span></li>
<li><span>Calling a </span><code>C</code><span> style variadic function produces an error.</span></li>
<li><span>Using the </span><code>va_start</code><span>, </span><code>va_arg</code><span>, </span><code>va_copy</code><span>, </span><code>va_end</code><span> or </span><code>va_list</code><span> functions produces errors.</span></li>
</ul><p><code>C</code><span> style variadic functions has been replaced by overloading, templates and variadic template functions.</span></p><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>F.55: Don’t use va_arg arguments</code><span> </span></li>
<li><code>ES.34: Don’t define a (C-style) variadic function</code><span> </span></li>
</ul><hr/><h4 id="No-deprecated" data-id="No-deprecated"><a href="#No-deprecated" title="No-deprecated"><span></span></a><span>No deprecated</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_deprecated&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_deprecated</code><span> is a subset of </span><code>modern</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using anything that has the deprecated attribute on it produces an error.</span></li>
</ul><p><span>Deprecated functionality is not modern.</span></p><hr/><h4 id="Use-stdarray" data-id="Use-stdarray"><a href="#Use-stdarray" title="Use-stdarray"><span></span></a><span>Use </span><code>std::array</code></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;use_std_array&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>use_std_array</code><span> is a subset of </span><code>modern</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Declaring a </span><code>C</code><span> style/core </span><code>C++</code><span> array variable, whether locally or in a class, produces an error.</span></li>
<li><span>It is okay to use array literals when initializing </span><code>std::array</code><span> and other collections.</span></li>
</ul><p><span>Use </span><code>std::array</code><span> instead of </span><code>C</code><span> style/core </span><code>C++</code><span> array.</span></p><hr/><h3 id="What-may-safer-and-modern-analyzers-be-composed-of-in-the-future" data-id="What-may-safer-and-modern-analyzers-be-composed-of-in-the-future"><a href="#What-may-safer-and-modern-analyzers-be-composed-of-in-the-future" title="What-may-safer-and-modern-analyzers-be-composed-of-in-the-future"><span></span></a><span>What may </span><code>safer</code><span> and </span><code>modern</code><span> analyzers be composed of in the future?</span></h3><h4 id="No-include" data-id="No-include"><a href="#No-include" title="No-include"><span></span></a><span>No include</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_include&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_include</code><span> is a subset of </span><code>modern</code><span>.</span></p>
</td>
</tr>
</tbody></table><p><span>The preprocessor directive </span><code>#include</code><span> has been replaced with </span><code>import</code><span>.</span></p><p><span><strong><span>NOTE</span></strong><span>: This may be impossible to implement as preprocessing occurs before compilation.</span></span></p><hr/><h4 id="No-goto" data-id="No-goto"><a href="#No-goto" title="No-goto"><span></span></a><span>No goto</span></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;no_goto&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>no_goto</code><span> is a subset of </span><code>modern</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Using the </span><code>goto</code><span> keyword produces an error.</span></li>
</ul><p><span>Don’t add until </span><code>break</code><span> and </span><code>continue</code><span> to a label is added. Also a really easy to use finite state machine library may be needed.</span></p><p><span>The </span><code>C++ Core Guidelines</code><span> </span><span> identifies issues that this feature helps to mitigate.</span></p><ul>
<li><code>ES.76: Avoid goto</code><span> </span></li>
</ul><hr/><h4 id="Use-stdfunction_ref" data-id="Use-stdfunction_ref"><a href="#Use-stdfunction_ref" title="Use-stdfunction_ref"><span></span></a><span>Use </span><code>std::function_ref</code></h4><table>
<tbody><tr>
<td>
<pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;use_function_ref&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre>
</td>
<td>
<p><code>use_function_ref</code><span> is a subset of </span><code>modern</code><span>.</span></p>
</td>
</tr>
</tbody></table><ul>
<li><span>Declaring a </span><code>C</code><span> style/core </span><code>C++</code><span> function pointer, whether locally or in a class, produces an error.</span></li>
<li><span>Declaring a </span><code>C</code><span> style/core </span><code>C++</code><span> member function pointer, whether locally or in a class, produces an error.</span></li>
<li><span>It is okay to use [member] function pointer literals when initializing </span><code>std::function_ref</code><span> and others.</span></li>
</ul><p><span>Use </span><code>std::function_ref</code><span> instead of </span><code>C</code><span> style/core </span><code>C++</code><span> [member] function pointers. </span><code>std::function_ref</code><span> can bind to stateful and stateless, free and member functions. It saves programmers from having to include a </span><code>void*</code><span> state parameter in their function pointer types and it also saves from having to include </span><code>void*</code><span> state parameter along side the function pointer type in each function where the function pointer type is used in function declarations. Neither of which could be performed with the </span><code>&#34;use_lvalue_references&#34;</code><span> static analyzer.</span></p><p><strong><span>NOTE:</span></strong></p><ul>
<li><span>This can’t be performed until </span><code>nontype_t</code><span> </span><span> </span><code>std::function_ref</code><span> </span><span> gets standardized.</span></li>
</ul><hr/><h2 id="Summary" data-id="Summary"><a href="#Summary" title="Summary"><span></span></a><span>Summary</span></h2><p><span>By adding static analysis to the </span><code>C++</code><span> language we can make the language safer and easier to teach because we can restrict how much of the language we use. Human readable errors and references turns the compiler into a teacher freeing human teachers to focus on what the compiler doesn’t handle.</span></p><h2 id="Frequently-Asked-Questions" data-id="Frequently-Asked-Questions"><a href="#Frequently-Asked-Questions" title="Frequently-Asked-Questions"><span></span></a><span>Frequently Asked Questions</span></h2><h3 id="Shouldn’t-these-be-warnings-instead-of-errors" data-id="Shouldn’t-these-be-warnings-instead-of-errors"><a href="#Shouldn’t-these-be-warnings-instead-of-errors" title="Shouldn’t-these-be-warnings-instead-of-errors"><span></span></a><span>Shouldn’t these be warnings instead of errors?</span></h3><p><span>NO, otherwise we’ll be stuck with what we just have. </span><code>C++</code><span> compilers produces plenty of warnings. </span><code>C++</code><span> static analyzers produces plenty of warnings. However, when some one talks about creating a new language, then old language syntax becomes invalid i.e. errors. This is for programmers. Programmers and businesses rarely upgrade their code unless they are forced to. Businesses and Government(s) want errors, as well, in order to ensure code quality and the assurance that bad code doesn’t exist anywhere in the module. This is also important from a language standpoint because we are essentially pruning; somewhat. Keep in mind that all of these pruned features still have use now. In the future, as more constructs are built upon these pruned features, which is why they need to be part of the language, just not a part of everyday usage of the language.</span></p><h3 id="Why-at-the-module-level-Why-not-safe-and-unsafe-blocks" data-id="Why-at-the-module-level-Why-not-safe-and-unsafe-blocks"><a href="#Why-at-the-module-level-Why-not-safe-and-unsafe-blocks" title="Why-at-the-module-level-Why-not-safe-and-unsafe-blocks"><span></span></a><span>Why at the module level? Why not safe and unsafe blocks?</span></h3><p><span>Programmers and businesses rarely upgrade their code unless they are forced to. New programmers need training wheels and some of us older programmers like them too. Due to the proliferation of government regulations and oversight, businesses have acquired </span><code>software composition analysis</code><span> services and tools. These services map security errors to specific versions of modules; specifically programming artifacts such as executables and libraries. As such, businesses want to know if a module is reasonably safe.</span></p><h3 id="How-do-we-configure-future-analyzers" data-id="How-do-we-configure-future-analyzers"><a href="#How-do-we-configure-future-analyzers" title="How-do-we-configure-future-analyzers"><span></span></a><span>How do we configure future analyzers?</span></h3><p><span>Any arguments provided after the name of the analyzer can be forwarded onto the analyzer.</span></p><pre><code><span>[</span><span>[</span><span>static_analysis</span><span>(</span><span>&#34;some_future_analyzer&#34;</span><span>,</span> <span>1</span><span>,</span> <span>true</span><span>,</span> <span>0.5</span><span>,</span> <span>&#34;Hello World&#34;</span><span>)</span><span>]</span><span>]</span>
</code></pre><p><span>In this case, </span><code>1, true, 0.5, &#34;Hello World&#34;</code><span> would all be forwarded to the static analyzer “some_future_analyzer”. None of the current analyzers use this functionality so this just illustrates distant future work where we can define these analyzers in a standard fashion but that can’t happen until we have a code DOM. As such, how these arguments are forwarded are currently compiler specific.</span></p><h3 id="You-must-really-hate-pointers" data-id="You-must-really-hate-pointers"><a href="#You-must-really-hate-pointers" title="You-must-really-hate-pointers"><span></span></a><span>You must really hate pointers?</span></h3><p><span>Actually, I love </span><code>C</code><span>, </span><code>C++</code><span> and pointers.</span></p><ul>
<li><span>I recognize that most of the time, when I code, that I don’t need them.</span></li>
<li><span>I recognize that </span><strong><span>past</span></strong><span> fundamental </span><code>C++</code><span> libraries use pointers but the users of those libraries don’t need them.</span></li>
<li><span>I recognize that </span><strong><span>present</span></strong><span> fundamental libraries such </span><code>function_ref</code><span> uses </span><code>void*</code><span> for type erasure but the users of </span><code>function_ref</code><span>, most of the time, won’t need it.</span></li>
<li><span>I recognize that </span><strong><span>future</span></strong><span> fundamental libraries such as dynamic polymorphic traits also need pointers for type erasure but they don’t expect their users to fidget with raw pointers.</span></li>
<li><span>I also recognize that 1 programmer writes a library but hundreds use the library without needing the same parts of C++ used in its creation.</span></li>
<li><span>Pointers are simple and easy for memory mapped hardware but many C++ programmers don’t operate at this level.</span></li>
<li><span>A few will create an OS [driver] but thousands will use it.</span></li>
</ul><p><span>The fact is pointers, unsafe casts, </span><code>union</code><span>, </span><code>mutable</code><span> and </span><code>goto</code><span> are the engine of C++ change. As such it would be foolish to remove them but it is also unrealistic for users/drivers of a vehicle to have to drive with nothing between them and the engine, without listening to them clamor for interior finishing.</span></p><h3 id="C-can’t-standardize-specific-static-analyzers" data-id="C-can’t-standardize-specific-static-analyzers"><a href="#C-can’t-standardize-specific-static-analyzers" title="C-can’t-standardize-specific-static-analyzers"><span></span></a><span>C++ can’t standardize specific static analyzers</span></h3><ul>
<li><span>Can’t </span><code>C++</code><span> provide the </span><code>static_analysis</code><span> attribute so that static analyzers can be called?</span></li>
<li><span>Can’t </span><code>C++</code><span> reserve unscoped or names that start with </span><code>std.</code><span>, </span><code>c++.</code><span>, </span><code>cpp.</code><span>, </span><code>cxx.</code><span> or </span><code>c.</code><span> are for future standardization?</span></li>
<li><span>Can’t </span><code>C++</code><span> reserve the names of static analyzers in the reserved </span><code>C++</code><span> static analyzer namespace?</span></li>
<li><span>Can’t </span><code>C++</code><span> </span><strong><span>recommend</span></strong><span> these reserved static analyzers and leave it to the compiler writers to appease their users that clamor for them?</span></li>
</ul><h3 id="Do-you-fear-that-this-could-create-a-“subset-of-C”-that-“could-split-the-user-community-and-cause-acrimony”-65" data-id="Do-you-fear-that-this-could-create-a-“subset-of-C”-that-“could-split-the-user-community-and-cause-acrimony”-65"><a href="#Do-you-fear-that-this-could-create-a-“subset-of-C”-that-“could-split-the-user-community-and-cause-acrimony”-65" title="Do-you-fear-that-this-could-create-a-“subset-of-C”-that-“could-split-the-user-community-and-cause-acrimony”-65"><span></span></a><span>Do you fear that this could create a “subset of C++” that “could split the user community and cause acrimony”? </span></h3><p><span>First of all, let’s consider the quotes of Bjarne Stroustrup that this question are based upon.</span></p><div>
<p><em><span>“being defined by an ‘industry consortium.’ I am not in favor of language subsets or dialects. I am especially not fond of subsets that cannot support the standard library so that the users of that subset must invent their own incompatible foundation libraries. I fear that a defined subset of C++ could split the user community and cause acrimony”</span></em><span> </span></p>
</div><p><span>Does this paper create a subset? YES. Like it or not </span><code>C++</code><span> already have a couple of subsets; some positive, some quasi. </span><code>Freestanding</code><span> is a subset for low level programming. This proposal primarily focus on high level programming but there is nothing preventing the creation of </span><code>[[static_analysis(&#34;freestanding&#34;)]]</code><span> which enforces </span><code>freestanding</code><span>. The </span><code>C++</code><span> value categories has to some degree fractured the community into a clergy class that thoroughly understand its intracacies and a leity class that gleefully uses it.</span></p><p><span>Does this paper split the user community? YES and NO. It splits code into safer vs. less safe, high level vs. low level. However, this is performed at the module level, allowing the same programmer to decide what falls on either side of the fence. This would not be performed by an industry consortium but rather the standard. Safer modules can be used by less safe modules. Less safe modules can partly be used by safer modules, such as with the standard module. This latter impact is already minimalized because the standard frequently write their library code in </span><code>C++</code><span> fashion instead of a </span><code>C</code><span> fashion.</span></p><hr/><div>
<p><em><strong><span>“Are there any features you’d like to remove from C++?”</span></strong></em><span> </span></p>
<p><em><span>Not really. People who ask this kind of question usually think of one of the major features such as multiple inheritance, exceptions, templates, or run-time type identification. C++ would be incomplete without those. I have reviewed their design over the years, and together with the standards committee I have improved some of their details, but none could be removed without doing damage.</span></em><span> </span></p>
<p><em><span>Most of the features I dislike from a language-design perspective (e.g., the declarator syntax and array decay) are part of the C subset of C++ and couldn’t be removed without doing harm to programmers working under real-world conditions. C++&#39;s C compatibility was a key language design decision rather than a marketing gimmick. Compatibility has been difficult to achieve and maintain, but real benefits to real programmers resulted, and still result today. By now, C++ has features that allow a programmer to refrain from using the most troublesome C features. For example, standard library containers such as vector, list, map, and string can be used to avoid most tricky low-level pointer manipulation.</span></em><span> </span></p>
</div><p><span>The beauty of this proposal is it does not and it does remove features from C++. Like the standard library, it allows programmers to refrain from using the most troublesome </span><code>C</code><span> and </span><code>C++</code><span> features.</span></p><hr/><div>
<p><span>“Within C++, there is a much smaller and cleaner language struggling to get out” </span></p>
</div><p><span>Both making things smaller and cleaner requires removing something. When creating a new language, removing things happens extensively at the beginning but, frequently, features have to be added back in, when programmers clamor for them. This paper cleans up a programmers use of the </span><code>C++</code><span> language, meaning less </span><code>C++</code><span> has to be taught immediately, thus making things simpler. As a programmer matures, features can be gradually added to their repertoire, just as it was added to ours. After all, isn’t </span><code>C++</code><span> larger now, than when we started programming in </span><code>C++</code><span>.</span></p><h2 id="References" data-id="References"><a href="#References" title="References"><span></span></a><span>References</span></h2></div></div>
  </body>
</html>
