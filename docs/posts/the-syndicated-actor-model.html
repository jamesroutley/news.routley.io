<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://syndicate-lang.org/about/">Original</a>
    <h1>The Syndicated Actor Model</h1>
    
    <div id="readability-page-1" class="page"><div>
    <blockquote>
  

  <h2 id="could-there-be-a-better-way-to-program-communicating-systems">Could there be a better way to program communicating systems?</h2>

  <p>Functional programs are easy to write, but programs that interact with
each other and the outside world are much harder.</p>

  

  <p>Programming models like the Actor model and the Tuplespace model make
great strides toward simplifying programs that communicate. However, a
few key difficulties remain.</p>

  <p>The Syndicated Actor model addresses these difficulties. It is closely
related to both Actors and Tuplespaces, but builds on a different
underlying primitive: <em>eventually-consistent replication of state</em>
among actors. Its design also draws on widely deployed but informal
ideas like publish/subscribe messaging.</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#syndicated-actors" id="markdown-toc-syndicated-actors">Syndicated Actors</a>    <ul>
      <li><a href="#securing-syndicated-interaction" id="markdown-toc-securing-syndicated-interaction">Securing syndicated interaction</a></li>
      <li><a href="#the-syndicated-actor-model-in-context" id="markdown-toc-the-syndicated-actor-model-in-context">The Syndicated Actor model in context</a></li>
      <li><a href="#actors" id="markdown-toc-actors">Actors</a></li>
      <li><a href="#tuplespaces" id="markdown-toc-tuplespaces">Tuplespaces</a></li>
      <li><a href="#publishsubscribe" id="markdown-toc-publishsubscribe">Publish/Subscribe</a></li>
    </ul>
  </li>
  <li><a href="#conversational-concurrency-1" id="markdown-toc-conversational-concurrency-1">Conversational Concurrency</a>    <ul>
      <li></li>
      <li><a href="#conversational-concurrency-in-brief" id="markdown-toc-conversational-concurrency-in-brief">Conversational Concurrency in brief</a></li>
      <li><a href="#conversational-frames-conversational-knowledge" id="markdown-toc-conversational-frames-conversational-knowledge">Conversational frames, conversational knowledge</a></li>
    </ul>
  </li>
  <li><a href="#language-support-syndicate-dsl" id="markdown-toc-language-support-syndicate-dsl">Language support: Syndicate DSL</a>    <ul>
      <li><a href="#facets-represent-sub-conversations" id="markdown-toc-facets-represent-sub-conversations">Facets represent (sub-)conversations</a></li>
      <li><a href="#a-taste-of-the-syndicatejs-dsl" id="markdown-toc-a-taste-of-the-syndicatejs-dsl">A taste of the Syndicate/js DSL</a></li>
    </ul>
  </li>
  <li><a href="#polyglot-and-networked-programming-preserves" id="markdown-toc-polyglot-and-networked-programming-preserves">Polyglot and networked programming: Preserves</a>    <ul>
      <li><a href="#preserves-a-data-model-with-associated-syntax" id="markdown-toc-preserves-a-data-model-with-associated-syntax">Preserves: a data model with associated syntax</a></li>
      <li><a href="#syndicated-actor-network-protocol" id="markdown-toc-syndicated-actor-network-protocol">Syndicated Actor network protocol</a></li>
    </ul>
  </li>
  <li><a href="#who-i-am" id="markdown-toc-who-i-am">Who I am</a></li>
</ul>

<p>Three big ideas fit together to yield the complete vision:</p>

<ul>
  <li>
    

    <p>Integrates Actors with Tuplespace-like shared state, Ambients-like
treatment of system boundaries, and Erlang-like techniques for
signalling and recovering from partial failure. A special kind of
syndicated actor, a <em>dataspace</em>, routes and replicates published
data according to actors’ interests.</p>
  </li>
  <li>
    

    <p>A way of thinking about IPC and networking, going beyond
message-passing to include ideas of conversational frame and
conversational state.</p>
  </li>
  <li>
    

    <p>Extends programming languages with domain-specific language (DSL)
constructs for directly expressing syndicated actor and
conversational concepts.</p>
  </li>
</ul>

<p>A few smaller pieces of the puzzle exist alongside the main ideas:</p>

<ul>
  <li>
    <p><em>Object capabilities.</em>
The only properly compositional way to secure a distributed system.</p>
  </li>
  <li>
    <p><em>A meaningful data language.</em>
For robust communication between programming languages and across
network links, we need a data language with a sensible equational
theory.</p>
  </li>
  <li>
    <p><em>Interaction protocols.</em>
“Procedure call” is baked-in to our programming languages. What
other interaction patterns deserve similar treatment?</p>
  </li>
  <li>
    <p><em>Integrated networking.</em>
After all, <a href="https://cceckman.com/writing/yak-and-duck/history">IPC is networking and networking is IPC</a>!
Anything more remote than “objects in the same sequential thread
(actor)” is considered “remote”, and works the same way.</p>
  </li>
</ul>

<blockquote>
  

  <p>The <a href="https://cceckman.com/about/">Syndicated Actor model</a> is a new model
of concurrency, closely related to the actor, tuplespace, and
publish/subscribe models.</p>
</blockquote>

<p>The Syndicated Actor model is, at heart, a mechanism for sharing state
among neighboring concurrent components. The design focuses on
mechanisms for sharing state because effective mechanisms for
communication and coordination follow as special cases.</p>

<p>You can think of it as concurrent object-oriented programming with
intrinsic publish/subscribe support.</p>

<p>It is based around actors which not only exchange messages, but
publish (“assert”) selected portions of their internal state
(“assertions”) to their peers in a publish/subscribe, reactive manner.</p>

<p>A <em>dataspace</em> is a special kind of actor which <em>relays</em> messages and
<em>replicates</em> published state from peer to peer. State replication
subsumes Erlang-style links and monitors, publish/subscribe,
tuplespaces, presence notifications, directory/naming services, and
more.</p>

<h2 id="securing-syndicated-interaction">Securing syndicated interaction</h2>

<p>Access control is expressed using a generalization of <em>object
capabilities</em> to express control over state replication and
observation of replicated state as well as ordinary message-passing
and RPC. Long-lived capabilities based on
<a href="https://research.google/pubs/pub41892/">Macaroons</a> allow secure
delegation and attenuation of authority.</p>

<p>Object capabilities are a natural fit for Actor-style systems (as
demonstrated by
<a href="http://www.erights.org/">E and subsequent research and systems based on it</a>),
so it makes sense that they would work well for the Syndicated Actor
model. The main difference to capabilities for plain Actors is that
syndicated capabilities express pattern-matching-based restrictions on
the <em>assertions</em> that may be directed toward a given peer, as well as
the <em>messages</em> that may be sent its way.</p>

<h2 id="the-syndicated-actor-model-in-context">The Syndicated Actor model in context</h2>

<blockquote>
  <p>See <a href="https://cceckman.com/about/syndicate-in-context/">here</a> for more
on comparisons of syndicated actors with other programming models.</p>
</blockquote>

<p>The closest relatives to the Syndicated Actor model are Actors, Tuplespaces,
and Pub/Sub:<sup id="fnref:diss-chap3" role="doc-noteref"><a href="#fn:diss-chap3" rel="footnote">1</a></sup></p>

<ul>
  <li>
    <h2 id="actors">Actors</h2>

    <p>In the Actor model<sup id="fnref:actor-model-hopl" role="doc-noteref"><a href="#fn:actor-model-hopl" rel="footnote">2</a></sup>, message passing is fundamental. But what we
really want, often, is <em>state synchronization</em>: I want some object
<em>over there</em> to know about my state <em>over here</em>; and I want this
object <em>here</em> to track the state of that object <em>there</em>.</p>

    <p>→ Actors don’t handle shared state well: programmers are left to
encode it via message-passing.</p>
  </li>
  <li>
    <h2 id="tuplespaces">Tuplespaces</h2>

    <p>With Tuplespaces, state-passing is fundamental. But the way state
moves around a tuplespace system causes problems for both
fault-tolerance and eventual consistency. Lots of research on
Tuplespaces has explored ways to repair these deficits.</p>

    <p>→ Tuplespaces don’t do messaging at all, and handle shared state in
a way that causes problems for fault-tolerance and eventual
consistency.</p>
  </li>
  <li>
    <h2 id="publishsubscribe">Publish/Subscribe</h2>

    <p>Pub/sub systems offer multicast of messages to groups of
subscribers. They work well when topic matching rules are simple
and with self-contained, ephemeral messages. They work less well
for stateful <em>conversations</em>, where joining subscribers must be
“brought up to speed” before their real-time stream of messages
starts.</p>

    <p>→ Pub/sub systems can struggle with flexibility and with management
of state.</p>
  </li>
</ul>

<p>In short, despite the fact that the same patterns of interconnection,
naming, routing and layering keep reappearing in all sorts of
software, our programming models and languages don’t do well at
letting us express these patterns. Likewise, firewalls, membranes and
system boundaries are ubiquitous, but remain unrepresented and
implicit in most approaches to concurrency.</p>

<p>Bringing these concepts into our programming models and programming
languages helps eliminate language patterns, simplifying our
programs.<sup id="fnref:diss-chap9" role="doc-noteref"><a href="#fn:diss-chap9" rel="footnote">3</a></sup></p>

<blockquote>
  

  

  <p>When programs are written with concurrency in mind, the programmer
reasons about the interactions between concurrent components or
agents in the program. This includes exchange of information, as
well as management of resources, handling of partial failure,
collective decision-making and so on.<sup id="fnref:diss-chap2" role="doc-noteref"><a href="#fn:diss-chap2" rel="footnote">4</a></sup></p>
</blockquote>

<p>These components might be objects, or threads, or processes, or
actors; or larger units still, such as whole machines or clusters; or
even some more nebulous and loosely-defined concept—a group of
callbacks, perhaps. The programmer has the notion of an agent in their
mind, which translates into some representation of that agent in the
program.</p>

<p>We think about the contexts (because there can be more than one) in
which agents exist in two different ways. From each agent’s
perspective, the important thing to think about is the boundary
between the agent and everything else in the system.</p>

<p>But from the system perspective, we often think about <em>conversations</em>
between agents, whether it’s just two having an exchange, or a whole
group collaborating on some task. Agents in a conversation play
different roles, join and leave the group, and build shared
conversational state.</p>

<p>Each act of communication contributes to a shared understanding of the
relevant knowledge required to undertake some task common to the
involved parties.</p>

<p>That is, <em>the purpose of communication is to share state</em>: to
replicate information from peer to peer.</p>

<h2 id="conversational-concurrency-in-brief">Conversational Concurrency in brief</h2>

<p>The idea of Conversational Concurrency can be summarised as
follows:<sup id="fnref:diss-chap2-redux" role="doc-noteref"><a href="#fn:diss-chap2-redux" rel="footnote">5</a></sup></p>

<ol>
  <li>Agents collaborate to achieve some shared task.</li>
  <li>Each task is delimited by a conversational frame.</li>
  <li>Within that frame, components share
    <ol>
      <li>knowledge related to the domain of the task at hand, and</li>
      <li>knowledge related to the knowledge, beliefs, needs, and
interests of the various participants in the collaborative
group.</li>
    </ol>
  </li>
  <li>Conversations are recursively structured by shared knowledge of
(sub-)conversational frames, defined in terms of any or all of the
types of knowledge we have discussed.</li>
  <li>Some conversations take place at different levels within a larger
frame, bridging between tasks and their subtasks.</li>
  <li>Components are frequently engaged in multiple tasks, and thus
often participate in multiple conversations at once.</li>
  <li>The knowledge a component needs to do its job is provided to it
when it is created, or later supplied to it in response to its
interests.</li>
</ol>

<p>Existing programming languages lack linguistic support for
conversational concurrency, leaving the programmer to fend for
themselves. The Syndicated Actor model, the idea of dataspaces, and
their supporting DSL are a response to this lack.</p>

<h2 id="conversational-frames-conversational-knowledge">Conversational frames, conversational knowledge</h2>

<p><a href="https://cceckman.com/tonyg-dissertation/html/index.html#x_2_2_0_0_2"><img src="https://cceckman.com/tonyg-dissertation/html/Figures/conversation.svg" alt="Components, tasks, and conversational structure"/></a></p>

<p>The conversational state that accumulates as part of a collaboration
among components can be thought of as a collection of facts. First,
there are those facts that define the <em>frame</em> of a conversation. These
are exactly the facts that identify the task at hand; we label them
“framing knowledge”, and taken together, they are the “conversational
frame” for the conversation whose purpose is completion of a
particular shared task.</p>

<p>Just as tasks can be broken down into more finely-focused subtasks, so
conversations can be broken down into sub-conversations. Part of the
conversational state of an overarching interaction describes a frame
for each sub-conversation, within which sub-conversational state
exists. The knowledge framing a conversation acts as a bridge between
it and its wider context.</p>

<p>If domain knowledge is “what is true in the world” for the purposes of
a given conversation, and epistemic knowledge is “who knows what”, the
third piece of the puzzle is “who <em>needs</em> to know what” in order to
effectively make a contribution to the shared task at hand.</p>

<p>Knowledge of the various <em>interests</em> in a group allows collaborators
to plan their communication acts according to the needs of individual
components and the group as a whole. In conversations among people,
interests are expressed as <em>questions</em>; in a computational setting,
they are conveyed by <em>requests</em>, <em>queries</em>, or <em>subscriptions</em>.</p>

<p>The interests of components in a concurrent system thus direct the
flow of knowledge within the system.</p>

<blockquote id="dsl">
  

  <p>The Syndicated Actor model, taken alone, explains communication and
coordination among components but does not offer the programmer any
assistance in structuring the internals of components.</p>

  <p>A handful of Domain-Specific Language (DSL) constructs, together
dubbed <em>Syndicate</em>, expose the primitives of the Syndicated Actor
model, the features of dataspaces, and the concepts of
conversational concurrency to the programmer in an ergonomic way.</p>
</blockquote>

<blockquote>
  <p>See the <a href="https://cceckman.com/doc/syndicate/">Syndicate DSL documentation</a>
for details of the syntax and meaning of the constructs that
Syndicate adds to each underlying programming language.</p>
</blockquote>

<p>The language constructs offered by the Syndicate DSL extend the
underlying programming language that is used to write a component.
They bridge between the language’s own computational model and the
style of interaction offered by the Syndicated Actor model.</p>

<p>Each interactive component needs some way of</p>

<ol>
  <li>representing the <em>conversations</em> it is engaged in</li>
  <li><em>mapping incoming events</em> to these conversations</li>
  <li>managing the <em>shared understanding</em> that it builds as it works towards the overall program’s goal</li>
  <li>cleaning up shared state after <em>partial failure</em> of a component</li>
  <li><em>scoping</em> interactions and shared state inside the program</li>
</ol>

<h2 id="facets-represent-sub-conversations">Facets represent (sub-)conversations</h2>

<p>To address these requirements, Syndicate represents conversations with
a language construct called a <em>facet</em>. Facets are similar to the
“nested threads” of Martin Sústrik’s idea of
<a href="https://250bpm.com/blog:71/">Structured Concurrency</a> (see also
<a href="https://en.wikipedia.org/wiki/Structured_concurrency">Wikipedia</a>).</p>

<p>Every actor has at least one (root) facet, and all its facets form a
tree. Generally speaking, one facet corresponds to one conversation,
<em>framing</em> (in the sense of Conversational Concurrency) its children,
which each correspond to some <em>sub-</em>conversation within the frame of
their parent.</p>

<p>When a parent facet is shut down, all its children are shut down in an
orderly fashion, making management of conversational state
straightforward.</p>

<p>Each facet publishes (“asserts”) relevant pieces of state
(“assertions”) to relevant peers. As its internal state changes, its
published assertions are re-evaluated, and any changes are
automatically propagated to peers.</p>

<p>Facets also subscribe to assertions emanating from their peers. They
do this in a unique way: by <em>asserting their interest</em> in particular
fact(s) to the publishing peer. That is, an expression of interest is
<em>itself</em> an assertion that can be seen and reacted to by peers.</p>

<p>When a facet terminates, whether normally or as the result of an
exception, all the assertions it has published are guaranteed to be
withdrawn. Assertions thus subsume Erlang-style monitors/links,
“presence” notifications (as seen in, for example,
<a href="https://xmpp.org/rfcs/rfc6121.html">XMPP</a>), and pub/sub mechanisms
for optimizing message delivery based on subscriber presence or
absence.</p>

<h2 id="a-taste-of-the-syndicatejs-dsl">A taste of the Syndicate/js DSL</h2>

<p>To give some of the flavour of working with Syndicate DSL constructs,
here’s a program written in
<a href="https://cceckman.com/code/js/">JavaScript extended with Syndicate constructs</a>:</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td><pre><span>function</span> <span>chat</span><span>(</span><span>initialNickname</span><span>,</span> <span>sharedDataspace</span><span>,</span> <span>stdin</span><span>)</span> <span>{</span>
  <span>spawn</span> <span>&#39;</span><span>chat-client</span><span>&#39;</span> <span>{</span>
    <span>field</span> <span>nickName</span> <span>=</span> <span>initialNickname</span><span>;</span>

    <span>at</span> <span>sharedDataspace</span> <span>assert</span> <span>Present</span><span>(</span><span>this</span><span>.</span><span>nickname</span><span>);</span>
    <span>during</span> <span>sharedDataspace</span> <span>asserted</span> <span>Present</span><span>(</span><span>$who</span><span>)</span> <span>{</span>
      <span>on</span> <span>start</span> <span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>who</span><span>}</span><span> arrived`</span><span>);</span>
      <span>on</span> <span>stop</span>  <span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>who</span><span>}</span><span> left`</span><span>);</span>
      <span>on</span> <span>sharedDataspace</span> <span>message</span> <span>Says</span><span>(</span><span>who</span><span>,</span> <span>$what</span><span>)</span> <span>{</span>
        <span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>who</span><span>}</span><span>: </span><span>${</span><span>what</span><span>}</span><span>`</span><span>);</span>
      <span>}</span>
    <span>}</span>

    <span>on</span> <span>stdin</span> <span>message</span> <span>Line</span><span>(</span><span>$text</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>text</span><span>.</span><span>startsWith</span><span>(</span><span>&#39;</span><span>/nick </span><span>&#39;</span><span>))</span> <span>{</span>
        <span>this</span><span>.</span><span>nickname</span> <span>=</span> <span>text</span><span>.</span><span>slice</span><span>(</span><span>6</span><span>);</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>send</span> <span>sharedDataspace</span> <span>message</span> <span>Says</span><span>(</span><span>this</span><span>.</span><span>nickname</span><span>,</span> <span>text</span><span>);</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote id="preserves">
  

  <p>Interoperation among programming languages and across network links
demands a shared data language and a common network protocol.</p>
</blockquote>

<p>For components to communicate, they need a common vocabulary.</p>

<p>When Syndicate is used to organise concurrency within a single
program, in a single programming language, that language’s own data
structures suffice.</p>

<p>But when Syndicate is used to organise larger systems, perhaps written
as separate, interoperating programs in many different languages,
perhaps communicating via network links (e.g. Bluetooth, Ethernet, or
TCP/IP), a common data language is needed.</p>

<p>A new data language called <a href="https://preserves.dev/">Preserves</a>
plays the role of common data language in this project, and a network
protocol built using Preserves allows expression of syndicated-actor
actions and events across network links.</p>

<h2 id="preserves-a-data-model-with-associated-syntax">Preserves: a data model with associated syntax</h2>

<blockquote>
  <p>See the <a href="https://preserves.dev/">Preserves website</a> for more
about Preserves.</p>
</blockquote>

<p>From the introduction to the <a href="https://preserves.dev/preserves.html">Preserves specification document</a>:</p>

<blockquote>
  <p>Preserves supports <em>records</em> with user-defined <em>labels</em>, embedded
<em>references</em>, and the usual suite of atomic and compound data types,
including <em>binary</em> data as a distinct type from text strings. Its
<em>annotations</em> allow separation of data from metadata such as
comments, trace information, and provenance information.</p>

  <p>Preserves departs from many other data languages in defining how to
<em>compare</em> two values. Comparison is based on the data model, not on
syntax or on data structures of any particular implementation
language.</p>
</blockquote>

<p>Preserves supports <em>schemas</em> for describing the structure and
interesting content of Preserves documents. It has multiple <em>syntaxes</em>
for different purposes: one is human-readable, and looks a lot like
JSON; another is a compact binary format, suitable for
<a href="https://preserves.dev/canonical-binary.html">canonicalization</a>
and hashing.</p>

<p>Here are some example Preserves documents, written in
<a href="https://preserves.dev/preserves.html#textual-syntax">Preserves text syntax</a>:</p>

<ul>
  <li>
    <pre><code>&lt;Present &#34;Alice&#34;&gt;
</code></pre>

    <p>A simple record, used in the example chat program above to assert
presence of a user within a chat room.</p>
  </li>
  <li>
    <pre><code>&lt;Says &#34;Alice&#34; &#34;Hello everybody!&#34;&gt;
</code></pre>

    <p>Again, a simple record, used as a message indicating that a user
said something to be forwarded on to peers in a chat room.</p>
  </li>
  <li>
    <pre><code>&lt;Observe &lt;Present *&gt; #:&lt;MyRef 7&gt;&gt;
</code></pre>

    <p>A more complex record, representing an asserted <em>interest</em> in other
assertions. The first field in the <code>Observe</code> record is a pattern
over asserted records. The second is an <em>embedded capability</em>
denoting the endpoint within a facet within an actor that should
receive notifications as matching records come and go.</p>
  </li>
  <li>
    <pre><code>version 1 .
embeddedType Actor.Ref .
Present = &lt;Present @username string&gt;.
Says = &lt;Says @who string @what string&gt;.
</code></pre>

    <p>A Preserves schema describing the allowable formats of assertions
and messages in the example “chat” protocol, usable within
<em>patterns</em> as well as for <em>attenuating authority</em> in syndicated
capabilities.</p>
  </li>
</ul>

<ul>
  <li>
    <pre><code>&lt;bundle {
  [simple-chat-protocol]: &lt;schema {
    version: 1,
    embeddedType: &lt;ref [Actor] Ref&gt;,
    definitions: {
      Says: &lt;rec &lt;lit Says&gt; &lt;tuple [
        &lt;named who &lt;atom String&gt;&gt;,
        &lt;named what &lt;atom String&gt;&gt;
      ]&gt;&gt;,
      Present: &lt;rec &lt;lit Present&gt; &lt;tuple [
        &lt;named username &lt;atom String&gt;&gt;
      ]&gt;&gt;
    }
  }&gt;
}&gt;
</code></pre>

    <p>This is the compiled form of the schema given above. Schema
compilers accept documents in this format,<sup id="fnref:meta-schema" role="doc-noteref"><a href="#fn:meta-schema" rel="footnote">6</a></sup> and
generate types representing the definitions in the schema bundle
along with code for parsing and reconstructing the Preserves
documents corresponding to instances of those types.</p>
  </li>
</ul>

<h2 id="syndicated-actor-network-protocol">Syndicated Actor network protocol</h2>

<blockquote>
  <p>See the <a href="https://cceckman.com/doc/protocol/">protocol specification</a>
for more on syndicated communication across network links.</p>
</blockquote>

<p>The following Preserves schema describes <em>turns</em>, which are messages
to be sent across a network link expressing <em>assertions</em>,
<em>retractions</em> of previous assertions, the sending of <em>messages</em>, and
<em>synchronization</em> with some remote party.</p>

<div><div><pre><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td><pre>version 1 .
embeddedType WireRef .

Assertion = any .
Handle    = int .
Event     = Assert / Retract / Message / Sync .
Oid       = int .
Turn      = [TurnEvent ...].
TurnEvent = [@oid Oid @event Event].

Assert = &lt;assert @assertion Assertion @handle Handle&gt;.
Retract = &lt;retract @handle Handle&gt;.
Message = &lt;message @body Assertion&gt;.
Sync = &lt;sync @peer ref&gt;.

# Definition of Caveat omitted here

WireRef = @mine &lt;MyRef @oid Oid]&gt;
        / @yours &lt;YourRef @oid Oid @attenuation Caveat ...&gt;.
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  
</blockquote>

<p>I’m <a href="https://leastfixedpoint.com/">Tony Garnock-Jones</a>;
<a href="mailto:tonyg@leastfixedpoint.com">tonyg@leastfixedpoint.com</a>;
<a href="https://twitter.com/leastfixedpoint">@leastfixedpoint</a>; <code>tonyg</code> on
Libera.Chat and HN. I’m a computer science researcher and software
developer. I’ve used Linux since the mid-1990s, contributed to
open-source software since the late 1990s, and I have a
<a href="https://cceckman.com/tonyg-dissertation/">PhD in, well, Syndicate</a>!</p>

<p>See also <a href="https://leastfixedpoint.com/">my personal website</a>.</p>

<hr/>



    
  </div></div>
  </body>
</html>
