<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://shopify.engineering/introducing-ruvy">Original</a>
    <h1>Ruvy: creating Wasm modules from Ruby code</h1>
    
    <div id="readability-page-1" class="page"><div itemprop="articleBody">
  <p>We’ve recently open sourced a project called Ruvy! <a href="https://github.com/Shopify/ruvy" title="Shopify/Ruvy" data-mce-href="https://github.com/Shopify/ruvy" target="_blank" rel="nofollow noopener noreferrer">Ruvy</a> is a toolchain that takes Ruby code as input and creates a WebAssembly module that will execute that Ruby code. There are other options for creating Wasm modules from Ruby code. The most common one is <a href="https://github.com/ruby/ruby.wasm" title="ruby/ruby.wasm" data-mce-href="https://github.com/ruby/ruby.wasm" target="_blank" rel="nofollow noopener noreferrer">ruby.wasm</a>. Ruvy is built on top of ruby.wasm to provide some specific benefits. We created Ruvy to take advantage of performance improvements from pre-initializing the Ruby virtual machine and Ruby files included by the Ruby script as well as not requiring WASI arguments to be provided at runtime to simplify executing the Wasm module.</p>
<p><a href="https://wasi.dev/" title="WASI" data-mce-href="https://wasi.dev/" target="_blank" rel="nofollow noopener noreferrer">WASI</a> is a standardized collection of imported Wasm functions that are intended to provide a standard interface for Wasm modules to implement many system calls that are present in typical language standard libraries. These include reading files, retrieving the current time, and reading environment variables. To provide context for readers not familiar with WASI arguments, WASI arguments are conceptually similar to command line arguments. Code compiled to WASI to read these arguments is the same code that would be written to read command line arguments for code compiled to target machine code. WASI arguments are distinct from function arguments and standard library code uses the WASI API to retrieve these arguments.</p>

<p>At the present time, Ruvy does not ship with precompiled binaries so its build dependencies need to be installed and then Ruvy needs to be compiled before it can be used. The details for how to install these dependencies is available in the <a href="https://github.com/Shopify/ruvy" title="Shopify/Ruvy" data-mce-href="https://github.com/Shopify/ruvy" target="_blank" rel="nofollow noopener noreferrer">README</a>.</p>
<p>After building Ruvy, you can run:</p>



<p>The content of <code>ruby_examples/hello_world.rb</code>  is:</p>

<p>When running <code>Ruvy</code>, the first line builds and executes the CLI to take the content of <code>ruby_examples/hello_world.rb</code> and creates a Wasm module named <code>index.wasm</code> that will execute <code>puts “Hello world”</code> when <code>index.wasm</code>’s exported <code>_start</code> function is invoked.</p>
<p>To use additional Ruby files, you can run:</p>

<p>Where the content of <code>ruby_examples/use_preludes_and_stdin.rb</code> is:</p>

<p>And the <code>prelude</code> directory contains two files. One with the content:</p>

<p>And another file with the content:</p>

<p>The preload flag tells the CLI to include each file in the directory specified, in this case <code>prelude</code>, into the Ruby virtual machine, which will make definitions for those files available to the input Ruby file.</p>

<h2><strong>Ruby.wasm</strong></h2>
<p>Ruby.wasm is a collection of ports of CRuby to WebAssembly targeting different environments such as web browsers through <a href="https://emscripten.org/" title="Emscription" target="_blank" rel="nofollow noopener noreferrer">Emscripten</a> and non-web environments through WASI. Ruby.wasm’s WASI ports include a Ruby interpreter that is compiled to a Wasm module and that module can use WASI APIs. For the Ruby interpreter to be useful in most use cases, it needs access to a filesystem to load Ruby files to execute. While it’s possible to ship Ruby files along with the Ruby interpreter Wasm module and specify in a WASI-compatible WebAssembly runtime to allow access to the directory containing those Ruby files from the interpreter’s Wasm instance, there’s a somewhat easier approach. You can use a tool called <a href="https://github.com/kateinoigakukun/wasi-vfs" title="kateinoigakukun/wasi-vsf" target="_blank" rel="nofollow noopener noreferrer"><code>wasi-vfs</code></a> (short for WASI virtual file system) to pack the contents of specified directories into a WebAssembly module at build time. This allows the Ruby interpreter to access the contents of the Ruby files without also having to ship the Ruby files separately with your Wasm module.</p>
<p>Using <code>wasi-vfs</code> with ruby.wasm looks like:</p>

<p>Running one of these modules requires providing the path to a Ruby script for the Ruby virtual machine to execute as a WASI argument. You can see that with the <code>-- /src/my_app.rb</code> argument to Wasmtime.</p>
<h2>Pre-initializing</h2>
<p>When using a ruby.wasm Wasm module built with <code>wasi-vfs </code>(WASI virtual file system), a tool which takes a specified directory and creates a Wasm module containing a collection of specified files in a specified set of paths, the Ruby virtual machine is started during the execution of the Wasm module. Whereas Ruvy pre-initializes the Ruby virtual machine when the Wasm module is built, which improves runtime performance by around 20%.</p>
<p>Here are some <a title="Shopify/Ruvy/Add benchmarks" href="https://github.com/Shopify/ruvy/pull/31" target="_blank" rel="nofollow noopener noreferrer">benchmark results</a> from timing how long it takes to instantiate and execute a <code>_start</code> function using Wasmtime:</p>

<table>
<thead>
<tr>
<td>
<p><b>Description</b></p>
</td>
<td>
<p><b>Toolchain</b></p>
</td>
<td>
<p><b>Low</b></p>
</td>
<td>
<p><b>Mid</b></p>
</td>
<td>
<p><b>High</b></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="2">
<p><span data-mce-style="font-weight: 400;">Hello world</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">Ruby.wasm + wasi-vfs</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">55.833 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">56.262 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">56.730 ms</span></p>
</td>
</tr>
<tr>
<td>
<p><span data-mce-style="font-weight: 400;">Ruvy</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">44.367 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">44.543 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">44.739 ms</span></p>
</td>
</tr>
<tr>
<td rowspan="2">
<p><span data-mce-style="font-weight: 400;">Includes + logic</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">Ruby.wasm + wasi-vfs</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">56.081 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">56.487 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">56.932 ms</span></p>
</td>
</tr>
<tr>
<td>
<p><span data-mce-style="font-weight: 400;">Ruvy</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">44.449 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">44.763 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">45.216 ms</span></p>
</td>
</tr>
</tbody>
</table>
<p><em>Execution benchmark results</em></p>



<p>The “Hello world” example is just running <code>puts “Hello world”</code> and the “Includes + logic” example uses a file that is <code>required</code> containing a class that changes some input in a trivial way.</p>
<p>Here are some benchmark results from comparing how long it takes Wasmtime to compile a ruby.wasm module and a Ruvy module from Wasm to native code using the Cranelift compiler:</p>

<table>
<thead>
<tr>
<td>
<p><b>Description</b></p>
</td>
<td>
<p><b>Toolchain</b></p>
</td>
<td>
<p><b>Low</b></p>
</td>
<td>
<p><b>Mid</b></p>
</td>
<td>
<p><b>High</b></p>
</td>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="2">
<p><span data-mce-style="font-weight: 400;">Hello world</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">Ruby.wasm + wasi-vfs</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">1.6351 s</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">1.6590 s</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">1.6844 s</span></p>
</td>
</tr>
<tr>
<td>
<p><span data-mce-style="font-weight: 400;">Ruvy</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">439.93 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">446.31 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">452.81 ms</span></p>
</td>
</tr>
<tr>
<td rowspan="2">
<p><span data-mce-style="font-weight: 400;">Includes + logic</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">Ruby.wasm + wasi-vfs</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">1.6227 s</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">1.6460 s</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">1.6706 s</span></p>
</td>
</tr>
<tr>
<td>
<p><span data-mce-style="font-weight: 400;">Ruvy</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">442.83 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">449.40 ms</span></p>
</td>
<td>
<p><span data-mce-style="font-weight: 400;">456.39 ms</span></p>
</td>
</tr>
</tbody>
</table>
<p><em>Compilation benchmark results</em></p>
<p>We can see that Ruvy Wasm modules take ~70% less time to compile from Wasm to native code.</p>
<h2>No need to specify arguments when executing</h2>
<p>Wasm modules created by Ruvy do not require providing a file path as a WASI argument. This makes it compatible with computing environments that cannot be configured to provide additional WASI arguments to start functions, for example various edge computing services.</p>

<p>We think Ruvy might be useful to the wider developer community by providing a straightforward way to build and execute simple Ruby programs in WebAssembly runtimes. There are a number of improvements that would also be very welcome from external contributors that we’ve documented in our <a title="Shopify/Ruvy" href="https://github.com/Shopify/ruvy" target="_blank" rel="nofollow noopener noreferrer">README</a>. Shopify Partners who would prefer to reuse some of their Shopify Scripts Ruby logic in Shopify Functions may be particularly interested in addressing the compatibility with Shopify Functions items that are listed.</p>
<p><strong>Jeff Charles</strong> is a Senior Developer on Shopify&#39;s Wasm Foundations team. You can find him on GitHub as <a title="Jeff Charles GitHub Profile" href="https://github.com/jeffcharles" target="_blank" rel="nofollow noopener noreferrer">@jeffcharles</a> or on LinkedIn at <a title="Jeff Charles LinkedIn Profile" href="https://www.linkedin.com/in/jeffrey-charles-779aa621/" target="_blank" rel="nofollow noopener noreferrer">Jeff Charles</a>.</p>
</div><div><div><div><svg aria-hidden="true" focusable="false"> <use xlink:href="#spot-blog-post"></use> </svg><h3>Get stories like this in your inbox!</h3><p>Stories from the teams who build and scale Shopify. The commerce platform powering millions of businesses worldwide.</p><p>Share your email with us and receive monthly updates.</p></div><div aria-hidden="true">
    <h3>Thanks for subscribing.</h3>
    <p>You’ll start receiving free tips and resources soon.</p>
</div></div></div></div>
  </body>
</html>
