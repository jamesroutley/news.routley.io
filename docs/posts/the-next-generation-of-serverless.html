<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.fermyon.com/blog/next-generation-of-serverless-is-happening">Original</a>
    <h1>The next generation of serverless</h1>
    
    <div id="readability-page-1" class="page"><div>
            <article>
                
                
                <p>The term “serverless” is used ambiguously, so let’s start off with a specific definition. Serverless apps are applications that are not written as software servers. “Server-less” code is code that responds to events (such as HTTP requests), but does not run as a daemon process listening on a socket. The networking part of serverless architectures is relegated to the infrastructure. One key feature of most serverless offerings is that they run in multi-tenant environments. That is, I can deploy my code to someone else’s infrastructure, where they may (safely) run that code in the same service in which they run other people’s code.</p>
<p>The most prominent example of first-wave serverless was AWS’s Lambda. And now, a new wave of serverless is emerging with some key differentiators against the first wave. And a few companies have now broken away from the pack, showing off these new features (spoiler: It’s Fermyon, Vercel, and Deno).</p>
<p>Let’s start from the beginning (a very good place to start). Because back before AWS, there were a couple of technologies that set the course for serverless.</p>
<!-- break -->
<h2>Before Serverless: CGI and PHP</h2>
<p>In the early days of the web, web servers could deliver only static assets: HTML, images, and files.  But developers wanted a way to write bits of code that could run on-demand and produce HTML (or other web file types) as output.</p>
<p>The Common Gateway Interface (CGI) protocol defined a simple standard for how a web server could run such programs. It also defined how an HTTP request could be passed to a program, and how the program could then return a response. The key innovation was that a single program could be run in many different web servers (Apache, IIS, and Jigsaw were a few examples back then).</p>
<p>CGI programs were not servers. They didn’t start a socket listener. Instead, the web server listened for requests, and then invoked the CGI program directly. There was no security sandbox, and CGI was definitely not safe for multi-tenancy. But the programming model was simple: programs received a request and returned a response.</p>
<p>Perl was arguably the most popular language for writing CGI programs initially. What made it great was its combination of expressive syntax, great web libraries, and neat language features (by which I mean built-in regular expressions — a novelty at the time).</p>
<p>But a challenger emerged. PHP started as a template language: One wrote HTML files and embedded executable snippets. The language grew and matured. More libraries were added. And soon, major applications were being written in the language. While PHP has gotten a bad reputation, shunned by “purists,” it has been in the top 10 most popular languages for decades.</p>
<p>While PHP’s runtime implementation changed from a CGI shim to an Apache module and on from there, its core programming model is a reified version of CGI’s programming model: A program is invoked on request, and returns a response. Only this time, the code <em>is</em> the response (and the request is presented as a nicely structured object).</p>
<p>Like CGI, PHP was never multi-tenant safe. But the model is a remarkable precursor to serverless functions.</p>
<h2>Historical Interlude: The Rise of Cloud</h2>
<p>I used to pay for a web hosting provider to run a chroot’ed virtual environment with an instance of Apache where I could dump my PHP files. The very thought of this setup now makes me cringe. It was not a particularly safe way to run a site. And, yes, like many others, I woke up to find my site hacked via another user’s account, or my files deleted by a glitch in a backup script, and so on.</p>
<p>Then along came two technologies that changed things: AWS’ Elastic Compute (EC2) and Heroku’s PaaS.</p>
<p>EC2 let me run an entire server on Amazon’s hardware. That was neat, provided I wanted to spend as much time administering my system as I did writing my code.</p>
<p>Heroku made it possible for me to run just a server on someone else’s hardware, and in a true multitenant way.</p>
<p>Both were cool technologies. But both introduced complexity into the developer’s world (at varying degrees). Heroku made developer self-service a thing, and that was excellent. But the code I had to write to run there was definitely more complex than the code I wrote back in the CGI and PHP days. And, yes, I ran PHP on both of these platforms, though in both cases I had to manage the web server as well as the code.</p>
<p>In a large part, the cloud took a turn toward devops and platform engineering. Infrastructure as a service, database as a service, EVERYTHING as a service… and everything needing wiring up and monitoring and administration and… work. Kubernetes promised to make all of this easier… and then ended up making it harder. But a little tiny experiment in making use of spare compute capacity turned into a revolution for AWS.</p>
<h2>Serverless v1</h2>
<p>As the story goes, Amazon had spare compute capacity that they wanted to put to productive use. So they created a product that ran small bits of code for a short period of time. Users could upload these tiny code bits. Events, such as an inbound HTTP request, could then trigger the small bit of code, which would be started, run to completion, and then shut down. This was AWS Lambda, described more generically as serverless functions.</p>
<p>This spawned a wave of copycat technologies: Azure Functions, IBM Cloud Functions, Google Cloud Functions, and so on. Even edge companies like Cloudflare got on board (though in a more limited fashion).</p>
<p>This first generation of serverless functions were built on one of two existing technologies:</p>
<ul>
<li>Virtual machines, where each virtual machine ran exactly one serverless function</li>
<li>Containers, where each container ran exactly one serverless function</li>
</ul>
<p>The cloud runtime, be it a VM or a container, provide a secure single-use wrapper for a function. But because neither compute type is designed to start quickly, an elaborate dance of pre-warming compute capacity and loading a workload just-in-time made this first generation of serverless slow and inefficient. At the time of this writing, Lambda functions require a cold start time of 200 milliseconds or more.</p>
<p>Furthermore, the developer experience of this first generation of serverless functions was less than ideal. With no common packaging format, no standard set of APIs, and no strong day 2 operational story, developers had to write platform-specific code packaged in bespoke ways. And often the debugging and troubleshooting story was convoluted and frustrating.</p>
<p>The attributes of each of these systems meant that developers were locked into one particular platform as they wrote their serverless functions. </p>
<p>Finally, because the infrastructure was costly to operate (with pre-warmed compute power sitting around), the more the serverless functions were executed, the pricier to platform became.</p>
<p>As we at Fermyon looked into the situation, we were convinced that a new technology, WebAssembly, could vastly improve these aspects of serverless applications.</p>
<h2>Defining Features of Next Wave Serverless</h2>
<p>To summarize the four issues with serverless v1 listed in the previous section:</p>
<ol>
<li>Serverless functions are slow</li>
<li>The developer experience for serverless functions is sub-par</li>
<li>Serverless functions come with vendor lock in</li>
<li>Cost eventually gets in the way</li>
</ol>
<p>As we looked at this list back when Fermyon started, we wondered if there was a single technology that could make progress in all of these areas. And WebAssembly seemed like the right tool.</p>
<p>WebAssembly binaries can start up far faster than containers and VMs. Orders upon orders of magnitude faster. And with some optimizations, it is possible to cold start serverless functions in one or two milliseconds.</p>
<p>Cold start performance is only one reason WebAssembly is a better fit for the next generation of serverless. Its isolation model and security sandbox mean we can safely run multiple tenants (each in its own sandbox) in the same WebAssembly supervisor. And that, in turn, means we can have thousands of serverless functions on a single virtual machine (and cluster VMs to run tens of thousands without breaking a sweat). This translates to reduced cost since we don’t need queues of warmed VMs or containers sitting idly by waiting for requests.</p>
<p>That takes care of both the performance and cost stories above. What about developer experience?</p>
<p>Since WebAssembly is just a compile target, many languages already have support for building this brand of serverless app. And the list of supporting languages continues to grow rapidly. This means that the developer is already in their comfort zone when using their regular development tools. There was still plenty of room for improvement, though. Spin uses the OCI packaging format (used by the container ecosystem), and applications deployed to Fermyon Cloud can access the dashboard for visibility into each execution of each serverless function.</p>
<p>Spin also allows multiple functions to be grouped together into a serverless app. And this is a critical feature of a new wave of serverless functions: A group of functions is easily deployed in concert, ameliorating the difficult procedural roll-outs one must use with Lambda.</p>
<p>The future of debugging and analyzing is even more exciting. Since all apps, regardless of source language, are represented as WebAssembly bytecode, a new generation of analysis tools is emerging. With these, developers do not need to instrument their code manually (at development time) in order to investigate the application when it is running. We imagine a feature in which a user can log into their dashboard and say, “This function is misbehaving. I would like to enable function tracing right now.” The serverless function runtime can then immediately begin tracing without any sort of recompile on the user’s side.</p>
<p>Finally, there is the matter of vendor lock-in. The first-generation serverless function environments were each designed to run in a specific cloud, use specific APIs, and have access to specific services. Effectively, a Lambda function cannot <em>just be run</em> in Azure. And neither can be easily run on-prem or in an IoT device or even in a Kubernetes cluster. The developer must pick (or at least know) their production requirement from day 1, and must write code specific to that environment.</p>
<p>Our view is that this is contrary to the spirit of serverless, in which a developer should be required to know as little as possible about the deployment environment. Deployment is an operations issue. And an operations team should be free to choose a deployment environment that suits their needs without requiring the developer to rewrite an app.</p>
<p>Spin is designed to run in a wide variety of environments. Whether Kubernetes or Fermyon Cloud or on-prem, it should be possible to run the same app. WebAssembly is, of course, a big part of this puzzle. The format itself is OS-neutral and architecture-neutral. The same binary can run on Windows with an Intel processor or macOS with an Arm processor… and various other permutations. But another piece of the puzzle is providing standard interfaces to frequently required services.</p>
<p>That brings us to the next point.</p>
<h2>Data Services are Part of Next Generation Serverless</h2>
<p>Heroku was the paradigmatic case of a developer self-service platform. Bring your own language and deploy it to Heroku’s platform in just a few commands. But if you need a database, things get more complicated.</p>
<p>The story is the same for first-generation serverless. When it comes to adding a database or a pubsub or key/value storage or object storage… it was up to the developer to do all the heavy lifting. Local development required setting up local data services. One’s laptop was suddenly home to a Postgres server, a Redis instance, and so on. And the developer had to inject connection info, manage local accounts, and do all of this without leaking credentials into Git.</p>
<p>As it came time to deploy into staging, and then production, the same operational dance must be done on the cloud side. Account management. Connection management. Configuration management. And with one more addition: feature parity between the development environment (of every developer) and staging and production.</p>
<p>That’s a lot of ops.</p>
<p>What if the next generation of serverless eliminates all of that?</p>
<p>When we introduced key/value storage earlier this year, our goal was to provide such an experience. All the developer needs to do to get key/value storage is say so in <code>spin.toml</code>. Spin itself automatically creates a local key/value storage for local use, and the developer doesn’t need to do anything at all to manage it. No process. No connection string. No accounts or usernames or passwords or permissions… it’s just there.</p>
<p>And when the developer deploys to Fermyon Cloud? Same thing. Fermyon Cloud creates an in-cloud highly available key/value store for the app. And once more, the developer needs to do nothing at all to manage it.</p>
<p>When the operations team sets up a Spin runtime in another environment, the team can choose to bring their own backend, be it Redis or CosmosDB or a custom one. And it doesn’t require a single change to the code. It’s all backend configuration that the developer needs never touch.</p>
<p>This makes things much simpler for the developer. Using key/value storage is suddenly reduced to just a <a href="https://developer.fermyon.com/spin/kv-store-api-guide">handful of API calls</a> like <code>open</code>, <code>get</code>, <code>set</code>, and <code>delete</code>.</p>
<p>A few weeks after Fermyon released key/value storage, Deno and then Vercel announced their own offerings. This is a trend marking those who break away from serverless v1.</p>
<p>In addition to being faster, easier, cheaper, and more portable, the next generation of serverless functions includes ops-less cloud services that free the developer.</p>
<h2>Conclusion</h2>
<p>Serverless applications have a surprisingly long lineage from CGI and PHP on through the evolution of cloud. But this new generation of serverless is not only more powerful, but also easier to use. Freeing the developer from operational concerns, and the platform engineer from developer concerns, this approach to serverless reduces friction on both sides of the deployment divide.</p>

            </article>
        </div></div>
  </body>
</html>
