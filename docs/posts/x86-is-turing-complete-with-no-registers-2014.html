<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://mainisusuallyafunction.blogspot.com/2014/02/x86-is-turing-complete-with-no-registers.html">Original</a>
    <h1>x86 is Turing-complete with no registers (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
<p><em>In which x86 has too many registers after all.</em></p>

<p>The fiendish complexity of the x86 instruction set means that even bizarrely restricted subsets are capable of arbitrary computation. As others have shown, we can compute using <a href="http://www.phrack.org/issues.html?issue=57&amp;id=15#article">alphanumeric machine code</a> or <a href="http://www.cs.jhu.edu/~sam/ccs243-mason.pdf">English sentences</a>, using <a href="http://www.cl.cam.ac.uk/~sd601/papers/mov.pdf">only the <code>mov</code> instruction</a>, or <a href="https://github.com/jbangert/trapcc">using the MMU</a> as it handles a never-ending double-fault. Here is my contribution to this genre of <a href="http://esolangs.org/wiki/Turing_tarpit">Turing tarpit</a>: x86 is <a href="http://esolangs.org/wiki/Turing-complete">Turing-complete</a> with no registers.</p>

<p>What do I mean by &#34;no registers&#34;? Well, really just whatever makes the puzzle interesting, but the basic guideline is:</p>
<blockquote>
<p>No instruction&#39;s observable behavior can depend on the contents of any ordinary user-space register.</p>
</blockquote>
<p>So we can&#39;t read from <code>R[ABCD]X</code>, <code>R[SD]I</code>, <code>R[SB]P</code> (that&#39;s right, no stack), <code>R8</code>-<code>R15</code>, any of their smaller sub-registers, or any of the x87 / MMX / SSE registers. This forbids implicit register access like <code>push</code> or <code>movsb</code> as well as explicit operands. I think I would allow <code>RIP</code>-relative addressing, but it&#39;s probably not useful when you&#39;re building a single executable which loads at a fixed address.</p>
<p>We also can&#39;t use the condition flags in <code>EFLAGS</code>, so conditional jumps and moves are right out. Many instructions will set these flags, but those dead stores are okay by me.</p>
<p>All memory access depends on segment selectors, the page table base in <code>CR3</code>, and so on. We trust that the OS (Linux in my example) has set up a reasonable flat memory model, and we shouldn&#39;t try to modify that. Likewise there are debug registers, parts of <code>EFLAGS</code> (such as the trap bit), and numerous <a href="http://wiki.osdev.org/Model_Specific_Registers">MSRs</a> which can influence the execution of nearly any instruction. We ignore all that too. Basically, the parts of CPU state which normal user-space code doesn&#39;t touch are treated as constants.</p>
<p>So what&#39;s left that we can work with? Just</p>
<ul>
<li>the instruction pointer,</li>
<li>memory operands, and</li>
<li>self-modifying code.</li>
</ul>
<p>But it would be too easy to self-modify an instruction into having a register operand. The above restrictions must hold for every instruction we execute, not just those appearing in our binary. Later on I&#39;ll demonstrate experimentally that we aren&#39;t cheating.</p>

<p>In a RISC architecture, every memory access is a register load or store, and our task would be completely impossible. But x86 does not have this property. For example we can store a constant directly into memory. Here&#39;s machine code along with NASM (Intel syntax) assembly:</p>
<pre><code>c6042500004000ba          mov byte  [0x400000], 0xba
66c7042500004000dbba      mov word  [0x400000], 0xbadb
c7042500004000efbead0b    mov dword [0x400000], 0xbadbeef
48c7042500004000efbead0b  mov qword [0x400000], 0xbadbeef</code></pre>
<p>In the latter case the 4-byte constant is <a href="http://en.wikipedia.org/wiki/Sign_extension">sign-extended</a> to 8 bytes.</p>
<p>We can also perform arithmetic on a memory location in place:</p>
<pre><code>8304250000400010          add dword [0x400000], 0x10</code></pre>
<p>But moving data around is going to be hard. As far as I know, every instruction which loads from one address and stores to another, for example <code>movsb</code>, depends on registers in some way.</p>
<p>Conditional control flow is possible thanks to this gem of an instruction:</p>
<pre><code>ff242500004000            jmp qword [0x400000]</code></pre>
<p>This jumps to whatever address is stored as a 64-bit quantity at address 0x400000. This seems weird but it&#39;s really just a load where the destination register is the instruction pointer. Many RISC architectures also allow this.</p>

<p>Let&#39;s get more concrete and talk about compiling <a href="http://esolangs.org/wiki/Brainfuck">Brainfuck</a> code to this subset of x86. Brainfuck isn&#39;t the simplest language out there (try <a href="http://esolangs.org/wiki/Subleq">Subleq</a>) but it&#39;s pretty familiar as an imperative, structured-control language. So I think compiling from Brainfuck makes this feel &#34;more real&#34; than compiling from something super weird.</p>
<p>A Brainfuck program executes on a linear tape of (<a href="http://esolangs.org/wiki/Brainfuck#Memory_and_wrapping">typically</a>) byte-size cells.</p>
<pre><code>TAPE_SIZE equ 30000

tape_start:
    times TAPE_SIZE dq cell0

head equ tape_start + (TAPE_SIZE / 2)</code></pre>
<p>Like many Brainfuck implementations, the tape has a fixed size (more on this later) and we start in the middle. <code>head</code> is not a variable with a memory location; it&#39;s just an assembler constant for the address of the middle of the tape.</p>
<p>Since our only way to read memory is <code>jmp [addr]</code>, the tape must store pointers to code. We create 256 short routines, each representing one of the values a cell can hold.</p>
<pre><code>cont_zero:     dq 0
cont_nonzero:  dq 0
out_byte:      db 0

align 16
cell_underflow:
    jmp inc_cell

align 16
cell0:
    mov byte [out_byte], 0
    jmp [cont_zero]

%assign cellval 1
%rep 255
    align 16
    mov byte [out_byte], cellval
    jmp [cont_nonzero]
    %assign cellval cellval+1
%endrep

align 16
cell_overflow:
    jmp dec_cell</code></pre>
<p>There are two things we need to do with a cell: get its byte value for output, and test whether it&#39;s zero. So each routine moves a byte into <code>out_byte</code> and jumps to the address stored at either <code>cont_zero</code> or <code>cont_nonzero</code>.</p>
<p>We produce most of the routines using a <a href="http://www.nasm.us/doc/nasmdoc4.html">NASM macro</a>. We also have functions to handle underflow and overflow, so a cell which would reach -1 or 256 is bumped back to 0 or 255. (We could implement the more typical wrap-around behavior with somewhat more code.)</p>
<p>The routines are aligned on 16-byte boundaries so that we can implement Brainfuck&#39;s <code>+</code> and <code>-</code> by adding or subtracting 16. But how do we know where the head is? We can&#39;t store it in a simple memory variable because we&#39;d need a double-indirect jump instruction. This is where the self-modifying code comes in.</p>
<pre><code>test_cell:
    jmp [head]

inc_cell:
    add qword [head], 16
    jmp test_cell

dec_cell:
    sub qword [head], 16
    jmp test_cell

move_right:
    add dword [inc_cell+4],  8
    add dword [dec_cell+4],  8
    add dword [test_cell+3], 8
    jmp [cont_zero]

move_left:
    sub dword [inc_cell+4],  8
    sub dword [dec_cell+4],  8
    sub dword [test_cell+3], 8
    jmp [cont_zero]</code></pre>
<p>Recall that <code>head</code> is an assembler constant for the middle of the tape. So <code>inc_cell</code> etc. will only touch the exact middle of the tape — except that we modify the instructions when we move left or right. The address operand starts at byte 3 or 4 of the instruction (check the disassembly!) and we change it by 8, the size of a function pointer.</p>
<p>Also note that <code>inc_cell</code> and <code>dec_cell</code> jump to <code>test_cell</code> in order to handle overflow / underflow. By contrast the move instructions don&#39;t test the current cell and just jump to <code>[cont_zero]</code> unconditionally.</p>
<p>To output a byte we <a href="https://github.com/kmcallister/rip/blob/4595341f8635c184f620a01a944a84c700e3641d/rip.asm#L7-L14">perform</a> the system call <a href="http://man7.org/linux/man-pages/man2/write.2.html"><code>write</code></a><code>(1, &amp;out_byte, 1)</code>. There&#39;s no escaping the fact that the <a href="http://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64">Linux system call ABI</a> uses registers, so I allow them here. We can do arbitrary computation without output; it&#39;s just nice if we can see the results. Input is <a href="https://github.com/kmcallister/rip/blob/4595341f8635c184f620a01a944a84c700e3641d/rip.asm#L73-L88">messier still</a> but it&#39;s not fundamentally different from what we&#39;ve seen here. Code that self-modifies by calling <a href="http://man7.org/linux/man-pages/man2/read.2.html"><code>read</code></a><code>()</code> is clearly the future of computing.</p>
<p>Putting it all together, I wrote a small <a href="https://github.com/kmcallister/rip/blob/4595341f8635c184f620a01a944a84c700e3641d/compiler">Brainfuck compiler</a> which does little more than match brackets. For each Brainfuck instruction it outputs one line of assembly, a call to a <a href="https://github.com/kmcallister/rip/blob/4595341f8635c184f620a01a944a84c700e3641d/rip.asm#L91-L135">NASM macro</a> which will load <code>cont_[non]zero</code> and jump to one of <code>test_cell</code>, <code>inc_cell</code>, etc. For the program <code>[+]</code> the compiler&#39;s output looks like</p>
<pre><code>k00000000: do_branch k00000003, k00000001
k00000001: do_inc    k00000002
k00000002: do_branch k00000003, k00000001
k00000003: jmp exit</code></pre>
<p>which blows up into something like</p>
<pre><code>401205:  48c70425611240005c124000  mov qword ptr [0x401261], 0x40125c
401211:  48c704256912400022124000  mov qword ptr [0x401269], 0x401222
40121d:  e90cefffff                jmp 40012e &lt;test_cell&gt;

401222:  48c70425611240003f124000  mov qword ptr [0x401261], 0x40123f
40122e:  48c70425691240003f124000  mov qword ptr [0x401269], 0x40123f
40123a:  e9f6eeffff                jmp 400135 &lt;inc_cell&gt;

40123f:  48c70425611240005c124000  mov qword ptr [0x401261], 0x40125c
40124b:  48c704256912400022124000  mov qword ptr [0x401269], 0x401222
401257:  e9d2eeffffe9d2eeffff      jmp 40012e &lt;test_cell&gt;

40125c:  e9c1eeffff                jmp 400122 &lt;exit&gt;</code></pre>
<p>Even within our constraints, this code could be a lot more compact. For example, a <code>test</code> could be merged with a preceding <code>inc</code> or <code>dec</code>.</p>

<p>Let&#39;s try it out on some of Daniel B Cristofani&#39;s <a href="http://www.hevanet.com/cristofd/brainfuck/">Brainfuck examples</a>.</p>
<pre><code>$ curl -s http://www.hevanet.com/cristofd/brainfuck/rot13.b | ./compiler
$ echo &#39;Uryyb, jbeyq!&#39; | ./rip
Hello, world!

$ curl -s http://www.hevanet.com/cristofd/brainfuck/fib.b | ./compiler
$ ./rip
0
1
1
2
3
5
8
13
…</code></pre>
<p>And now let&#39;s try a Brainfuck interpreter written in Brainfuck. There are <a href="http://esolangs.org/wiki/Brainfuck#Self-interpreters">several</a>, but we will choose the <a href="http://homepages.xnet.co.nz/~clive/eigenratios/cgbfi2.b">fastest one</a> (by Clive Gifford), which is also compatible with our handling of end-of-file and cell overflow.</p>
<pre><code>$ curl -s http://homepages.xnet.co.nz/~clive/eigenratios/cgbfi2.b | ./compiler
$ (curl -s http://www.hevanet.com/cristofd/brainfuck/rot13.b;
   echo &#39;!Uryyb, jbeyq!&#39;) | ./rip
Hello, world!</code></pre>
<p>This takes about 4.5 seconds on my machine.</p>

<p>How can we verify that a program doesn&#39;t use registers? There&#39;s no CPU flag to disable registers, but setting them to zero after each instruction is close enough. Linux&#39;s <a href="http://man7.org/linux/man-pages/man2/ptrace.2.html"><code>ptrace</code></a> system call allows us to manipulate the state of a target process.</p>
<pre><code><span>uint64_t</span> regs_boundary;

<span>void</span> clobber_regs(pid_t child) {
    <span>struct</span> user_regs_struct   regs_int;
    <span>struct</span> user_fpregs_struct regs_fp;

    CHECK(ptrace(PTRACE_GETREGS, child, <span>0</span>, &amp;regs_int));
    <span>if</span> (regs_int.rip &lt; regs_boundary)
        <span>return</span>;

    CHECK(ptrace(PTRACE_GETFPREGS, child, <span>0</span>, &amp;regs_fp));

    <span>// Clear everything before the instruction pointer,</span>
    <span>// plus the stack pointer and some bits of EFLAGS.</span>
    memset(&amp;regs_int, <span>0</span>, offsetof(<span>struct</span> user_regs_struct, rip));
    regs_int.rsp = <span>0</span>;
    regs_int.eflags &amp;= EFLAGS_MASK;

    <span>// Clear x87 and SSE registers.</span>
    memset(regs_fp.st_space,  <span>0</span>, <span>sizeof</span>(regs_fp.st_space));
    memset(regs_fp.xmm_space, <span>0</span>, <span>sizeof</span>(regs_fp.xmm_space));

    CHECK(ptrace(PTRACE_SETREGS,   child, <span>0</span>, &amp;regs_int));
    CHECK(ptrace(PTRACE_SETFPREGS, child, <span>0</span>, &amp;regs_fp));

    clobber_count++;
}</code></pre>
<p>For the layout of <code>struct user_regs_struct</code>, see <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysv/linux/x86/sys/user.h;h=02d3db78891a409c79571343cd732a9cdcdc868a;hb=eefa3be8e4c2c721a9f277d8ea2e11180231829f#l42"><code>/usr/include/sys/user.h</code></a>.</p>
<p>We allow registers in the first part of the program, which is responsible for system calls. <code>regs_boundary</code> is set by <a href="https://github.com/kmcallister/rip/blob/4595341f8635c184f620a01a944a84c700e3641d/regclobber.c#L42-L58">looking</a> for the symbol <code>FORBID_REGS</code> in the binary.</p>
<p>We run the target using <code>PTRACE_SINGLESTEP</code>, which sets the <a href="http://en.wikipedia.org/wiki/Trap_flag">trap flag</a> so that the CPU will raise a <a href="http://wiki.osdev.org/Exceptions#Debug">debug exception</a> after one instruction. Linux handles this exception, suspends the traced process, and wakes up the tracer, which was blocked on <a href="http://man7.org/linux/man-pages/man2/waitpid.2.html"><code>waitpid</code></a>.</p>
<pre><code><span>while</span> (<span>1</span>) {
    <span>// For this demo it&#39;s simpler if we don&#39;t deliver signals to</span>
    <span>// the child, so the last argument to ptrace() is zero.</span>
    CHECK(ptrace(PTRACE_SINGLESTEP, child, <span>0</span>, <span>0</span>));
    CHECK(waitpid(child, &amp;status, <span>0</span>));

    <span>if</span> (WIFEXITED(status))
      finish(WEXITSTATUS(status));

    inst_count++;
    clobber_regs(child);
}</code></pre>
<p>And the demo:</p>
<pre><code>$ gcc -O2 -Wall -o regclobber regclobber.c
$ curl -s http://www.hevanet.com/cristofd/brainfuck/rot13.b | ./compiler
$ echo &#39;Uryyb, jbeyq!&#39; | time ./regclobber ./rip
Hello, world!

Executed 81366 instructions; clobbered registers 81189 times.
0.36user 1.81system 0:01.96elapsed 110%CPU (0avgtext+0avgdata 1392maxresident)k</code></pre>
<p>At almost two seconds elapsed, this is hundreds of times slower than running <code>./rip</code> directly. Most of the time is spent in the kernel, handling all those system calls and debug exceptions.</p>
<p>I <a href="http://mainisusuallyafunction.blogspot.com/2011/01/implementing-breakpoints-on-x86-linux.html">wrote about <code>ptrace</code> before</a> if you&#39;d like to see more of the things it can do.</p>

<p>Our tape has a fixed size of 30,000 cells, the same as Urban Müller&#39;s original Brainfuck compiler. A system with a finite amount of state can&#39;t really be Turing-complete. But x86 itself also has a limit on addressable memory. So does C, because <span><code>sizeof(void *)</code></span> is finite. These systems <em>are</em> Turing-complete when you add an external tape using I/O, but so is a <a href="http://en.wikipedia.org/wiki/Finite-state_machine">finite-state machine</a>!</p>
<p>So while x86 isn&#39;t really Turing-complete, with or without registers, I think the above construction &#34;feels like&#34; arbitrary computation enough to meet the informal definition of &#34;Turing-complete&#34; commonly used by programmers, for example in the <a href="http://www.cl.cam.ac.uk/~sd601/papers/mov.pdf"><em><code>mov</code> is Turing-complete</em></a> paper. If you know of a way to formalize this idea, do let me know (I&#39;m more likely to notice tweets <a href="https://twitter.com/miuaf"><code>@miuaf</code></a> than comments here).</p>

</div></div>
  </body>
</html>
