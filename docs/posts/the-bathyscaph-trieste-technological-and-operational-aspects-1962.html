<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://archive.org/details/bathyscaphtriest00wals">Original</a>
    <h1>The Bathyscaph Trieste: Technological and Operational Aspects (1962)</h1>
    
    <div id="readability-page-1" class="page"><div role="main"><article><header><section><span><a href="https://thevaluable.dev/tags/tools/">#Tools</a></span>
<span><a href="https://thevaluable.dev/tags/mouseless/">#Mouseless</a></span></section></header><section><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/find_ring.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/find_ring.jpg" alt="Bilbo searching for its ring"/></picture><p>Another boring day at MegaCorpMoneyMaker, the company you’re working with. You have the most exciting task anybody would ask for: modifying the README of an obscure microservice due to recent changes from your team. Looking at the project, you realise that it has way too many files, and worth, that the readme file is nowhere to be found!</p><p>Anxious, you ask Davina, your colleague developer, how to find this file. She tries to help:</p><p>“Let’s see. It’s a markdown file, so it should have the extension “md”. It’s also a plain text file, so we can exclude directory of our search. Maybe using a regular expression would work well, trying to search anything which have the substring “read”, or even “me” if we have no luck”.</p><p>You stop Davina. You have no clue how to perform these searches, except using the crappy search and find functionality of your desktop manager.</p><p>Davina looks at the room full of disheartened developers. She begins to shout out:</p><p>“If anybody is interested to explore the CLI find alltogether, let’s begin in 10 minute on my computer!”</p><p>Half of the room joins, some interested, some trying to fight their boredom. This article is the transcription of this magical day, written in stone like the 10 commandments. More specifically, we’ll cover the following in this article:</p><ul><li>The general syntax of find, and what are test and action expressions.</li><li>How to search files by name, type, permissions, and users.</li><li>How to delete automatically the files found.</li><li>How to run any command on the result.</li><li>How to manipulate the output.</li><li>How to write and format the output in files.</li><li>What are find’s operators you can use.</li><li>The differences between find and the CLI fd.</li></ul><p>As indicated in the title, we’ll focus on GNU find in this article. If you don’t have it, I’d recommend you to install and use it, instead of crappiest versions (looking at you, BSD find).</p><p>Why learning this old tool, you might wonder? You can find this tool (pun intended) almost everywhere: remote servers, docker containers, you name it. It might be the only available way to find files. For your local machine, there are more modern options (we’ll cover one of them in this article).</p><p>The CLI find has more than one trick in its sleeve; but it doesn’t mean we should use it for everything. As always with CLIs, it’s important to be careful not to do some irreversible changes in our filesystem.</p><p>If you prefer learning by watching videos, I recorded two of them; you’ll find them at the end of this article.</p><p>Last thing: you can download the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-find" target="_blank" rel="noopener">companion project</a> if you want to follow along and try by yourself the different commands. I’d recommend you to do so, to remember what we’ll see here, and be able to use find in different contexts.</p><p>It’s about time: let’s find these files!</p><h2 id="the-basics-of-find">The Basics of find</h2><p>Let’s look first at find’s general syntax:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find <span>[</span>options<span>]</span> <span>[</span>starting_directory<span>]</span> <span>[</span>expressions<span>]</span>
</span></span></code></pre></div><p>What are these different elements?</p><table><tbody><tr><th>Element</th><th>Description</th><th>Default</th></tr><tr><td><code>[options]</code></td><td>Options are arguments about symlinks and search optimization.</td><td>None</td></tr><tr><td><code>[starting_point]</code></td><td>List of directories to search through. The subdirectories are recursively included.</td><td>Current directory</td></tr><tr><td><code>[expressions]</code></td><td>List of expressions with their (often required) values.</td><td>None</td></tr></tbody></table><p>Nothing is mandatory here: running <code>find</code> alone will give you some output.</p><p>The <code>[options]</code> are not the most useful elements you’ll use over and over with find; we won’t focus on them in this article. Instead, we’ll look mostly at the <code>[expressions]</code>. They are queries describing how to match files, or what action to perform on these files. They’re always prefixed with a single dash <code>-</code> (like <code>-name</code> for example).</p><p>Here are the different categories of expressions:</p><table><tbody><tr><th>Category</th><th>Description</th></tr><tr><td>Test expressions</td><td>Most common expressions. They’re used to filtering your files.</td></tr><tr><td>Action expressions</td><td>Expressions used to perform an action on each file found.</td></tr><tr><td>Operators</td><td>Boolean operators to manage the relationships between the different expressions.</td></tr><tr><td>Global options</td><td>Options changing the behavior of the test and action expressions.</td></tr><tr><td>Positional options</td><td>Options changing the behavior of the test and action expressions directly following them.</td></tr></tbody></table><p>When using multiple expressions without specifying any operator, the AND operator is implicitly used. We’ll look at that in a section below.</p><p>For you to understand my obscure rambling, nothing beats an example. You can try to run the following in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-find" target="_blank" rel="noopener">companion project</a> to see what it does:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find mouseless -name <span>&#39;*.jpg&#39;</span> -perm <span>&#39;664&#39;</span>
</span></span></code></pre></div><p>Let’s look at each element of the command more closely:</p><table><tbody><tr><th>Part</th><th>Description</th></tr><tr><td><code>mouseless</code></td><td>Starting directory of the search. All subdirectories will be parsed to find the files.</td></tr><tr><td><code>-name</code></td><td>The test expression <code>-name</code> search files by… name. Flabbergasting.</td></tr><tr><td><code>*.jpg</code></td><td>The value given to the expression <code>-name</code>. Here, we only want to match JPG files.</td></tr><tr><td><code>-perm</code></td><td>Another test expression to search files according to their permissions.</td></tr><tr><td><code>664</code></td><td>Value given to the expression <code>-perm</code>. Here, we only want files with permissions <code>664</code>.</td></tr></tbody></table><p>To drive the point home: we’re searching in the directory <code>mouseless</code> (and all its subdirectories) files with extensions <code>jpg</code> which have the permissions <code>664</code>.</p><p>Let’s look at the value <code>*.jpg</code> of the test expression <code>-name</code>: we use single quotes around it here. This is important: it forbids your shell to expand the wildcard <code>*</code>, letting find doing it. I’d recommend to always use single quotes when giving values to expressions: it will save you some headaches down the line, or you might wonder why the results are not the ones you expect.</p><p>There are only two JPG files in the entire project, and only one with the permissions <code>664</code>. As a result, you should get this output:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/01_find_general.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/01_find_general.jpg" alt="Output of the CLI find using test expression -name and -perm"/></picture><p>As you can see, by default, find displays the relative path of each result.</p><p>You don’t have to specify a starting directory; by default, find will begin the search in the current directory. As a result, the two following commands are equivalent:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find -name <span>&#39;*.jpg&#39;</span> -perm <span>&#39;664&#39;</span>
</span></span><span><span>find . -name <span>&#39;*.jpg&#39;</span> -perm <span>&#39;664&#39;</span>
</span></span></code></pre></div><p>That said, it’s always clearer to specify the starting directory, to avoid any confusion.</p><h2 id="test-expressions">Test Expressions</h2><p>Test expressions specify what files you want to match (including directories). Here are the most useful ones:</p><h3 id="find-empty-file-and-directories">Find Empty File and Directories</h3><p>Our first test expression is easy: <code>-empty</code> will only find empty files and directories. It doesn’t need a value.</p><p>Let’s try to run the following in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-find" target="_blank" rel="noopener">companion project</a>:</p><p>Here’s the output of the command:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/04_find_empty.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/04_find_empty.jpg" alt="Output of the CLI find using test expression -empty"/></picture><p>We don’t have empty directories in there (Git won’t let me push some), but if it was the case it would appear in the results. You can try to create it yourself and see what happens.</p><h3 id="find-files-by-names">Find Files by Names</h3><p>More often than not, you’ll want to find files depending on their filenames (or their entire filepaths). That’s great, because we’ve a set of test expressions dedicated to this task.</p><h4 id="find-by-filename">Find by Filename</h4><p>The expression <code>-name</code> finds files and directories by filename. If you want to use regular expressions, too bad: only shell patterns (also called <em>glob operators</em>) are allowed here. More specifically, you can use the following globs: <code>*</code>, <code>?</code>, or <code>[]</code>.</p><p>As an example, let’s try to run the following in our <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-find" target="_blank" rel="noopener">companion project</a>:</p><p>This command will try to find every file with extension <code>.tex</code>. The output:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/02_find_name.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/02_find_name.jpg" alt="Output of the CLI find using test expression -name"/></picture><h4 id="find-by-filepath">Find by Filepath</h4><p>The expression <code>-path</code> filter files and directories depending on their filepaths. Like <code>-name</code>, it doesn’t accept regexes as value but glob operators.</p><p>For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -path <span>&#39;*/headers/*&#39;</span>
</span></span></code></pre></div><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/02_find_name.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/02_find_path.jpg" alt="Output of the CLI find using test expression -name"/></picture><p>We’ve now every file which have <code>/headers/</code> in their filepaths.</p><h4 id="find-filepaths-using-regular-expressions">Find Filepaths Using Regular Expressions</h4><p>If you want to use a regex to specify the filepaths you want, the expression <code>-regex</code> is here for you.</p><p>You can also use the <em>positional option</em> <code>-regextype</code> before <code>-regex</code>, to specify the regex engine you want to use. To output a list of regex engines supported, you can run <code>find . -regextype dummy</code>:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/05_find_regex_engine.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/05_find_regex_engine.jpg" alt="Output of the CLI find using test expression -name"/></picture><p>For example, If I want to find every TEX and JPG files, I can try to run the following:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -regex <span>&#39;.*(tex|jpg)$&#39;</span>
</span></span></code></pre></div><p>But it won’t work: by default, find uses the <code>emacs</code> regex engine, which doesn’t include all the metacharacters used above. The [extended regular expressions (using the <a href="https://linux.die.net/man/1/egrep" target="_blank" rel="noopener">egrep</a> engine) is more powerful:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -regextype <span>&#39;egrep&#39;</span> -regex <span>&#39;.*(tex|jpg)$&#39;</span>
</span></span></code></pre></div><p>This time, we get the output we want:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/06_find_extended_regex_engine.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/06_find_extended_regex_engine.jpg" alt="Output of the CLI find using test expression -regex and -regextype"/></picture><h4 id="case-sensitivity">Case Sensitivity</h4><p>If you want your expression’s value to be case-insensitive, you can add the prefix <code>i</code> to the expression’s names seen above. For example: <code>-iname</code>, <code>-ipath</code>, or even <code>-iregex</code>.</p><p>Let’s try to run the following in the <a href="https://github.com/Phantas0s/the_valuable_dev_companion/tree/main/guide-find" target="_blank" rel="noopener">companion project</a>:</p><p>Nothing will be output, even if we have a file named <code>Makefile</code> in our project. But the following will work:</p><p>Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/07_find_case_sensitivity.jpg" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/07_find_case_sensitivity.jpg" alt="Output of the CLI find using test expression -iname (case-sensitive)"/></picture><h3 id="find-by-type-of-file">Find by Type of File</h3><p>If you want to search your files by type, you can use the expression <code>-type</code> followed by one of these values:</p><table><tbody><tr><th>Value</th><th>Description</th></tr><tr><td><code>f</code></td><td>Regular file</td></tr><tr><td><code>d</code></td><td>Directory</td></tr><tr><td><code>l</code></td><td>Symlink</td></tr></tbody></table><p>For example, if you run the following:</p><pre tabindex="0"><code>find . -name &#39;*ge*&#39; -type d
</code></pre><p>We get only one output because we only want directories.</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/07_find_case_sensitivity.jpg" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/08_find_type_file.jpg" alt="Output of the CLI find using test expression -iname (case-sensitive)"/></picture><h3 id="find-by-permissions">Find by Permissions</h3><p>You can also find files depending on their permissions: whether they’re <code>-writable</code>, <code>-executable</code>, or <code>-readable</code> for the current user; all three can be used as test expressions.</p><p>If you want to find files with a specific set of permissions for all kind of users, you can use <code>-perm</code>. Its value can be:</p><ul><li>A string beginning with <code>/</code> (using the boolean “OR”) and followed by a series of rules. For example: <code>-perm &#39;/u=w,g=x&#39;</code> (writable by the owner, <em>or</em> executable by the group).</li><li>A string beginning with <code>-</code> (using the boolean “AND”) and followed by a series of rules. For example: <code>-perm &#39;-u=w,g=x&#39;</code> (writable by owner, <em>and</em> executable by the group).</li><li>An octal number, for example: <code>644</code> (see <a href="https://wiki.archlinux.org/title/File_permissions_and_attributes" target="_blank" rel="noopener">file permissions</a>).</li></ul><p>We’ve already seen an example of this expression in the first section of this article.</p><h3 id="filtering-by-owner-or-group">Filtering by Owner or Group</h3><p>To find files depending on their owners, we can use the expression <code>-user</code>, where the value is a username. For example, <code>find . -user myuser</code>.</p><p>You might have guessed it: to filter by group, we can naturally use the <code>-group</code> expression. For example, <code>find . -group mygroup</code>.</p><h3 id="a-brief-summary-of-test-expressions">A Brief Summary of Test Expressions</h3><p>We already covered a lot of ground here! Let’s summarize the different test expressions we’ve seen in this section:</p><table><tbody><tr><th>Expression</th><th>Description</th><th>Example(s)</th></tr><tr><td><code>-empty</code></td><td>Only return empty files or directories.</td><td><code>find . -empty</code></td></tr><tr><td><code>-name</code></td><td>Search by filename.</td><td><code>find . -name &#39;*.jpg&#39;</code></td></tr><tr><td><code>-iname</code></td><td>Search by filename (case-insensitive).</td><td><code>find . -iname &#39;*make*&#39;</code></td></tr><tr><td><code>-path</code></td><td>Search by filepath.</td><td><code>find . -path &#39;*/headers/*&#39;</code></td></tr><tr><td><code>-ipath</code></td><td>Search by filepath (case-insensitive)</td><td><code>find . -ipath &#39;*readme*&#39;</code></td></tr><tr><td><code>-regex</code></td><td>Search by filepath using a regex.</td><td><code>find . -regex &#39;.*tex&#39;</code></td></tr><tr><td><code>-iregex</code></td><td>Search by filepath using a regex (case-insensitive).</td><td><code>find . -iregex &#39;.*readme.*&#39;</code></td></tr><tr><td><code>-regextype</code></td><td>Placed before <code>-regex</code>, specify the regex engine to use.</td><td><code>find . -regextype &#39;egrep&#39; -regex &#39;.*(tex|jpg)$&#39;</code></td></tr><tr><td><code>-type</code></td><td>Search files by their types (use <code>d</code>, <code>f</code> or <code>l</code> as value).</td><td><code>find . -type d</code></td></tr><tr><td><code>-writable</code></td><td>Output files which are writable for the current user.</td><td><code>find . -writable</code></td></tr><tr><td><code>-executable</code></td><td>Output files which are executable for the current user.</td><td><code>find . -executable</code></td></tr><tr><td><code>-readable</code></td><td>Output files which are readable for the current user.</td><td><code>find . -readable</code></td></tr><tr><td><code>-perm</code></td><td>Output files depending on specific permissions.</td><td><code>find . -perm -u=w,g=e</code>, <code>find . -perm 664</code></td></tr><tr><td><code>-user</code></td><td>Search files by user.</td><td><code>find . -user myuser</code></td></tr><tr><td><code>-group</code></td><td>Search files by group.</td><td><code>find . -group sudo</code></td></tr></tbody></table><h2 id="action-expressions">Action Expressions</h2><p>Expressions are not only there for filtering your search. We can also perform some actions on each file found.</p><h3 id="deleting-files">Deleting Files</h3><p>You can easily delete the files and directories found using the <code>-delete</code> option. For example, the command <code>find . -name &#34;*.jpg&#34; -delete</code> will delete all JPG files.</p><p>This is a dangerous expression: there is no prompt to confirm if you want to delete your files, they’re just gone. I never use it personally, it’s too frightening for my little heart.</p><h3 id="running-a-command-on-each-result">Running a Command on Each Result</h3><p>You can also run any command you want on each file found. The following expressions enable us to reach this glorious goal.</p><h4 id="running-a-command-in-the-working-directory">Running a Command in the Working Directory</h4><p>The expression <code>-exec</code> allows us to run a command on each file found, from the current working directory.</p><p>The characters <code>{}</code> are used as placeholder for each result; they will be expanded with the filename of each file found. You also need to use <code>;</code> to end the command (it allows us to add other commands afterward, which doesn’t happen often).</p><p>Here are a couple of examples:</p><table><tbody><tr><th>Example</th><th>Description</th></tr><tr><td><code>find . -exec &#39;basename&#39; &#39;{}&#39; &#39;;&#39;</code></td><td>Run the command <code>basename</code> for every result of the search.</td></tr><tr><td><code>find . -type f -exec &#39;rm -i&#39; &#39;{}&#39; &#39;;&#39;</code></td><td>Prompt you for each file to delete it. Safer than using the expression <code>-delete</code>.</td></tr><tr><td><code>find mouseless -exec bash -c &#39;basename &#34;${0%.*}&#34;&#39; &#39;{}&#39; &#39;;&#39;</code></td><td>Using <code>bash -c</code> allows us to expand parameters. We use here <code>${0%.*}</code> to delete the file extension of each result.</td></tr></tbody></table><p>Again, the single quotes are important here: we don’t want our shell to expand our placeholder (or even <code>&#39;;&#39;</code>) before find has the chance to process the input.</p><p>You can also use the expression <code>-ok</code>. It’s the same as <code>-exec</code>, except that find will prompt you to make sure that you want to run the command for each file. For example:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type f -ok rm <span>&#39;{}&#39;</span> <span>&#39;;&#39;</span>
</span></span></code></pre></div><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/10_find_ok_safe_delete.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/10_find_ok_safe_delete.jpg" alt="Using the test expression -ok to delete your files safely"/></picture><h4 id="running-a-command-in-the-starting-directory">Running a Command in the Starting Directory</h4><p>We saw that <code>-exec</code> and <code>-ok</code> can run commands on each result in the working directory. If you want to run these commands in the directory where the file found is, you can use respectively the expressions <code>-execdir</code> and <code>-okdir</code>.</p><p>For example:</p><pre tabindex="0"><code>find mouseless/headers -execdir echo &#39;{}&#39; &#39;;&#39;
</code></pre><p>Here’s a little preview to show the difference between <code>-exec</code> and <code>-execdir</code>:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/11_find_difference_exec_execdir.jpg" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/11_find_difference_exec_execdir.jpg" alt="The difference between the test expression -exec and -execdir"/></picture><p>Another example, from The Real Life™ this time: in a past long gone, I wanted to convert a bunch of images to black and white. Using <a href="https://imagemagick.org/" target="_blank" rel="noopener">imagemagick</a>, I came up with the following command:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find -name <span>&#39;*.jpg&#39;</span> <span>\
</span></span></span><span><span><span></span>-execdir bash -c <span>\
</span></span></span><span><span><span></span><span>&#39;convert $0 -colorspace Gray ${0%.*}_bw.jpg {}&#39;</span> <span>\
</span></span></span><span><span><span></span><span>&#39;;&#39;</span>
</span></span></code></pre></div><p>It copies the files, convert them to black and white, and add the suffix <code>_bw.jpg</code> to the original filenames. Neat! You can see it here in action:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/12_find_exec_imagemagick.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/12_find_exec_imagemagick.jpg" alt="Converting images to black and white using find and imagemagick"/></picture><h3 id="formatting-finds-output">Formatting Find’s Output</h3><p>You urgently need to format find’s output? The following expressions will become your best friends:</p><table><tbody><tr><th>Expression</th><th>Description</th></tr><tr><td><code>-print</code></td><td>This is the default action used when you don’t specify any. It simply prints each filepath found.</td></tr><tr><td><code>-printf</code></td><td>Print each result following a format given as value.</td></tr><tr><td><code>-print0</code></td><td>Replace the separator between each output from newlines to null characters.</td></tr><tr><td><code>-ls</code></td><td>Print each result like the command <code>ls -dils</code> would do.</td></tr></tbody></table><p>The expression <code>-print0</code> can be quite useful if you want to pipe your results to <code>xargs -0</code> for example. Many CLIs give you the ability to work with null characters as separators, which can be easier than dealing with newlines.</p><p>Let’s look a bit more closely at the expression <code>-printf</code>:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -type f -printf <span>&#39;Level: %d | File: %p\n&#39;</span>
</span></span></code></pre></div><p>The placeholder <code>%d</code> prints the depth of the file in the filetree, and <code>%p</code> prints the filepath of the file found. Here’s the result:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/13_find_using_printf.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/13_find_using_printf.jpg" alt="Using the test expression -printf with find"/></picture><h3 id="writing-finds-output-to-a-file">Writing Find’s Output to a File</h3><p>You can also use a bunch of action expressions to write find’s output to a file instead of displaying it in your shell. You just need to prefix the expressions we saw above with a <code>f</code>.</p><p>For example: <code>-fls</code>, <code>-fprint</code>, <code>-fprint0</code> or <code>-fprintf</code>.</p><p>You can pass the filepath you want to write to as value of these expressions:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -fprintf myfile <span>&#39;Level: %d | File: %p\n&#39;</span>
</span></span></code></pre></div><p>The result:</p><picture><source srcset="https://thevaluable.dev/images/2023/find-guide/14_find_fprintf.webp" type="image/webp"/><img width="780" height="520" src="https://thevaluable.dev/images/2023/find-guide/14_find_fprintf.jpg" alt="Using the test expression -fprintf with find to write the output to a file"/></picture><h3 id="a-brief-summary-of-action-expressions">A Brief Summary of Action Expressions</h3><p>Again, let’s summarize what action expressions we saw in this section:</p><table><tbody><tr><th>Expression</th><th>Description</th><th>Example(s)</th></tr><tr><td><code>-delete</code></td><td>Delete each file without prompt. Be careful: it’s not possible to go back.</td><td><code>find . -delete</code></td></tr><tr><td><code>-exec</code></td><td>Run a command on each file found.</td><td><code>find . -exec basename &#39;{}&#39; &#39;;&#39;</code></td></tr><tr><td><code>-ok</code></td><td>Prompt you to run a command on each file found.</td><td><code>find . -exec rm -ri &#39;{}&#39; &#39;;&#39;</code></td></tr><tr><td><code>-execdir</code></td><td>Like <code>-exec</code>, but the filepaths are relative to the starting directory.</td><td><code>find mouseless -execdir echo &#39;{}&#39; &#39;;&#39;</code></td></tr><tr><td><code>-okdir</code></td><td>Like <code>-ok</code>, but the filepaths are relative to the starting directory.</td><td><code>find mouseless -okdir echo &#39;{}&#39; &#39;;&#39;</code></td></tr><tr><td><code>-print</code></td><td>Print each result. Default action expression used to output the results.</td><td><code>find . -print</code> or <code>find .</code></td></tr><tr><td><code>-printf</code></td><td>Print each result using a given format.</td><td><code>find . -printf &#39;Level: %d\n&#39;</code></td></tr><tr><td><code>-ls</code></td><td>Print each result like the command <code>ls -dils</code> would do.</td><td><code>find . -ls</code></td></tr><tr><td><code>-print0</code></td><td>Like <code>-print</code>, but replace newline separators with null characters.</td><td><code>find . -print0 | xargs -0 file</code></td></tr><tr><td><code>-fprint</code></td><td>Print the results in a file instead of stdout.</td><td><code>find . -fprint myfile</code></td></tr><tr><td><code>-fprintf</code></td><td>Like <code>-printf</code>, but print the result to a file instead of stdout.</td><td><code>find . -fprintf myfile &#39;Level:%d&#39;\n</code></td></tr><tr><td><code>-fprint0</code></td><td>Like <code>-print0</code>, but print the result to a file instead of stdout.</td><td><code>find . -fprint0 myfile</code></td></tr><tr><td><code>-fls</code></td><td>Like <code>-ls</code>, but print the result to a file instead of stdout.</td><td><code>find . -fls myfile</code></td></tr></tbody></table><p>Using null characters can be useful when using xargs and your filenames have spaces for example. Without the null characters, <code>xargs</code> would consider any space as a separator, effectively trying to run the command on the results, but using only part of the filenames.</p><h2 id="operators">Operators</h2><p>Test and action expressions are really useful, but you’ll see quickly their limitations when you put them together. What if you want to filter everything which <em>doesn’t</em> have a specific filename or filepath for example?</p><p>We can add operators to our expressions to make find even more powerful. Here are the most useful ones:</p><table><tbody><tr><th>Operator</th><th>Description</th></tr><tr><td><code>!</code></td><td>Reverse the test expression following it.</td></tr><tr><td><code>-or</code> or <code>-o</code></td><td>Logical “OR”.</td></tr><tr><td><code>-and</code> or <code>-a</code></td><td>Logical “AND”. It’s the default if no operator is given.</td></tr><tr><td><code>,</code></td><td>Separate multiple expressions, only traversing the whole filetree once.</td></tr></tbody></table><p>The usual examples:</p><table><tbody><tr><th>Command</th><th>Description</th></tr><tr><td><code>find . &#39;!&#39; -path &#39;*headers*&#39;</code></td><td>Output every file except the ones having <code>headers</code> in their filepaths.</td></tr><tr><td><code>find . -name &#39;*.css&#39; -or -name &#39;*.md&#39;</code></td><td>Output every file with extensions <code>css</code> or <code>md</code>.</td></tr><tr><td><code>find . -name &#39;*s*&#39; -and -type d</code></td><td>Find directories with names finishing with <code>s</code>.</td></tr><tr><td><code>find . -name &#39;*s*&#39; -type d</code></td><td>Equivalent to the previous example.</td></tr></tbody></table><p>And a last example: a command writing every markdown filenames in the file <code>md_files</code>, and every CSS filenames in the file <code>css_files</code>, while traversing the filetree once:</p><div><pre tabindex="0"><code data-lang="bash"><span><span>find . -name <span>&#39;*.css&#39;</span> -fprint css_files <span>&#39;,&#39;</span> -name <span>&#39;*.md&#39;</span> -fprint md_files
</span></span></code></pre></div><h2 id="the-cli-fd-an-alternative-to-find">The CLI fd, an Alternative to find</h2><p>The CLI find is a great tool, but it’s also old; it doesn’t take into consideration all the other tools we use nowadays. For example, it’s not easy to automatically skip the files ignored by Git.</p><p>If you want a more modern experience, you can use an alternative, something like the excellent <a href="https://github.com/sharkdp/fd" target="_blank" rel="noopener">fd</a>.</p><p>I think it’s always good to know the OG tools (like grep or find) because, as I was writting it in the introduction, they’re often available everywhere, or they can be installed easily, even on docker containers. If you know how to use find, it should be easy to use more modern alternatives.</p><p>By default, fd will ignore hidden files and files in your <code>.gitignore</code>. It also supports regexes out of the box, without the need to use any option. The cherries on top: it’s faster, and it has colored output, similar to the CLI ls.</p><p>To give you an idea, here are some equivalent commands using find and fd. They’re not always exactly equivalent, but it’s close enough:</p><table><tbody><tr><th>find</th><th>fd</th></tr><tr><td><code>find . -iname &#39;*headers*&#39;</code></td><td><code>fd headers</code></td></tr><tr><td><code>find . -iregex &#39;.*readme.*&#39;</code></td><td><code>fd &#39;.*readme.*&#39;</code></td></tr><tr><td><code>find . -iname &#39;*headers*&#39;</code></td><td><code>fd --glob &#39;*headers*&#39;</code></td></tr><tr><td><code>find mouseless -name &#39;*.theme&#39;</code></td><td><code>fd &#39;.*.theme&#39; mouseless</code></td></tr><tr><td><code>find mouseless/headers</code></td><td><code>fd . mouseless/headers</code></td></tr><tr><td><code>find . -name &#39;*.tex&#39;</code></td><td><code>fd --extension tex</code></td></tr><tr><td><code>find .. -name &#39;.git&#39;</code></td><td><code>fd --hidden &#39;.git&#39; ..</code></td></tr><tr><td><code>find -path &#39;*/headers/*&#39;</code></td><td><code>fd --full-path &#39;/headers/&#39;</code></td></tr><tr><td><code>find . -exec stat &#39;{}&#39; &#39;;&#39;</code></td><td><code>fd --exec stat</code></td></tr><tr><td><code>find . -exec grep &#39;itemData&#39; &#39;{}&#39; &#39;;&#39;</code></td><td><code>fd --exec grep &#39;itemData&#39;</code></td></tr><tr><td><code>vim $(find . -name &#39;*.tex&#39;)</code></td><td><code>fd --extension tex --exec-batch vim</code></td></tr></tbody></table><p>The commands using fd were mainly pulled from its excellent <a href="https://github.com/sharkdp/fd/blob/master/README.md" target="_blank" rel="noopener">README</a> - it’s a great resource to learn how to use fd in more details. It has more quality of life improvements: different placeholders possible when using <code>--exec</code> to get only some part of the filepaths, parallel executions… You name it!</p><p>As I was writing in <a href="https://thevaluable.dev/fzf-shell-integration/">another article</a>, fd is also great to use in concert with other tools, like fzf for examples.</p><h2 id="are-your-ready-to-find">Are Your Ready to Find?</h2><p>If you prefer watching videos instead of reading this article, most (but not all) of the good tips provided here are also available on YouTube:</p><p><iframe src="https://www.youtube.com/embed/nJ7NvcPnVE4" allowfullscreen="" title="YouTube Video"></iframe></p><p><iframe src="https://www.youtube.com/embed/mSEVOZWtlJc" allowfullscreen="" title="YouTube Video"></iframe></p><p>What did we learn in this article?</p><ul><li>There are multiple types of expressions we can use with find: test expressions (filters) and action expressions (running commands on each result).</li><li>The test expressions <code>-name</code> <code>-path</code>, and <code>-regex</code> will likely be your favorite ones to cover most needs.</li><li>To filter by type of files, we can use the expression <code>-type</code> with <code>f</code>, <code>d</code>, or <code>l</code> (<code>f</code>iles, <code>d</code>irectories, and sym<code>l</code>inks).</li><li>We can also filter by permission with <code>-writable</code>, <code>-executable</code>, and <code>-writable</code>. For more control: <code>-perm</code> is here for you.</li><li>Regarding action expressions, <code>-exec</code> is the most versatile of all. Don’t forget to use the placeholder <code>{}</code>, and to add <code>&#39;;&#39;</code> at the end!</li><li>If you need to be prompted for sensible operations (deleting files for example), you can use <code>-ok</code> instead of <code>-exec</code>.</li></ul><p>Davina finishes her demo. The participants, amazed by so many skills, ask their managers to raise Davina’s salary by 200%. This is what will happen to you too if you use find! Success, glory, and fame guaranteed. How do you think Joe Rogan went that far (arguably) in life?</p></section></article></div></div>
  </body>
</html>
