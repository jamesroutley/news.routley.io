<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://lwn.net/Articles/605607/">Original</a>
    <h1>The glibc s390 ABI break (2014)</h1>
    
    <div id="readability-page-1" class="page"><div>
<center>
           <div><b>Please consider subscribing to LWN</b><p>Subscriptions are the lifeblood of LWN.net.  If you appreciate this
       content and would like to see more of it, your subscription will
       help to ensure that LWN continues to thrive.  Please visit
       <a href="https://lwn.net/subscribe/">this page</a> to join up and keep LWN on
       the net.</p></div>
           </center>
           <p>
The GNU C library (glibc) project has long lived up to a reputation for
conservatism; glibc developers know that an ill-chosen change can create a
great deal of pain downstream, so they proceed with caution.  Even so,
mistakes can happen.  A recent slip-up involving the s390 architecture
makes it clear how one of those mistakes can cascade into a significant
mess that is hard to clean up afterward.
</p><p>
The <a href="http://man7.org/linux/man-pages/man3/setjmp.3.html"><tt>setjmp()</tt></a>
and <a href="http://man7.org/linux/man-pages/man3/longjmp.3.html"><tt>longjmp()</tt></a>
functions have been part of the standard C library since something close to
the beginning.  They can be used to perform stack unwinding — a sort of
&#34;long return&#34; from a function that skips over any number of intervening
function calls.  Both of these functions take an opaque <tt>jmp_buf</tt>
data structure as an argument.  The caller provides the buffer to
<tt>setjmp()</tt>, which fills it with the information needed to make
another return to the location of that call.  A later call to
<tt>longjmp()</tt> with that buffer will then cause <tt>setjmp()</tt> to
appear to have returned a second time.
</p><p>
Back in April, developers from IBM committed 
<a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=93a45ff1">a
patch</a> 
that <a href="https://sourceware.org/git/?p=glibc.git;a=blobdiff;f=sysdeps/s390/bits/setjmp.h;h=25eaf10fdf1dae0d27efd743a954990c5a410498;hp=0071a9dce548644027a510d8a7e1dcb8800487a2;hb=93a45ff1;hpb=d5780febe69c2fe42d857e2feed54e9f4ba9ab87">changed the size</a> of the <tt>jmp_buf</tt> structure on the
s390 architecture; this change, which subsequently became part of the 2.19
release, was apparently needed to enable better hardware support for
<tt>setjmp()</tt> and <tt>longjmp()</tt>.  Since <tt>jmp_buf</tt> is a type
that is visible to applications, this was a clear ABI change, with all of
the possible problems that can go with it.  For example, newer glibc
releases expect the larger <tt>jmp_buf</tt> size, but they may be linked
(at run time) against applications that have not been rebuilt
and, thus, are still working with the older version of
<tt>jmp_buf</tt>.
</p><p>
This possibility was taken into account, though.  Symbol versioning was
used to provide compatible versions of <tt>setjmp()</tt> and
<tt>longjmp()</tt> for these older applications.  So, in theory, things
should Just Work without additional problems.  This particular theory did
not last long after its encounter with the real world, though.
</p><p>
The problem is that <tt>jmp_buf</tt> structures are often embedded into
other structures, so a change in the size of that structure will change the
containing structures too.  To find victims, one need not even look outside
of glibc; it turns out that glibc&#39;s POSIX threads (pthreads) implementation
<a href="https://lwn.net/Articles/605608/">embeds a <tt>jmp_buf</tt> structure</a> into
its own <tt>__pthread_unwind_buf_t</tt> structure which, in turn, is visible to
applications.  So, as a result, a number of pthreads functions need to
become versioned as well.
</p><p>
Versioning does not work, though, for problems that pop up outside of
glibc.  Consider, for example, the Perl interpreter, which embeds a
<tt>jmp_buf</tt> in its main &#34;this is a running Perl instance&#34; structure.
That has caused various Perl modules to fail (<a href="https://bugzilla.redhat.com/show_bug.cgi?id=1064271">example</a>) and
can only really be fixed by rebuilding the entire Perl environment.  The
PNG image format library (libpng) also has an embedded <tt>jmp_buf</tt> — in a
structure that is used by all PNG-using applications.
</p><p>
Debian&#39;s developers, who were trying to clean up this mess, considered
rebuilding all of Perl and then, perhaps, all (500 or so) packages
depending on the PNG library.  But, by this point, it became clear that
the ripples from this change spread widely indeed and that playing
whack-a-mole may never get all of them fixed.  So the Debian developers
have <a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=754125#32">figured</a>
that the course they may have to consider is to &#34;<span>do like Red Hat, ie
just rebuild everything and warn the users their system might break during
upgrade.</span>&#34;  Needless to say, this approach lacks appeal, especially
in the Debian world, where mass rebuilds are a rare event.
</p><p>
Even then, of course, there is the problem of end-user applications.
Distributors cannot rebuild those; even worse, the user may not
be able to either.  So some things might just be broken.
</p><p>
One might be thinking that there is a mechanism in place for this kind of
incompatible ABI change.  Shared libraries have a shared-object name
(&#34;soname&#34;) built into them; applications linked against those libraries
also contain that name.  For glibc on your editor&#39;s system, for example,
the soname is &#34;<tt>libc.so.6</tt>&#34;.  The runtime linker will not link an
application against a shared object if the sonames do not match.  In this
way, the system can disallow running against a library that will not work.
It also enables, in theory, the parallel installation of multiple versions
of the library; older applications would continue to use the older library,
while newly built binaries would use the current version.
</p><p>
So the glibc project could consider making a point release with a different
soname (<tt>libc.so.6.1</tt>, say); distributors could then install the
result alongside an older version of the library and, in theory, things
should work.  Except that glibc developer Carlos O&#39;Donell <a href="https://lwn.net/Articles/605632/">tried it</a> and concluded that:
</p><div><p>
	It&#39;s unsupportable as a solution for glibc.
</p><p>
	The SO name bump in a mixed-ABI environment like debian results in
	two libc&#39;s being loaded and competing for effectively the same
	namespace of symbols with resolution (and therefore selection of
	the ABI) being determined by ELF interposition and scope
	rules. It&#39;s a nightmare.  It&#39;s possible a worse solution than just
	telling everyone to rebuild and get on with their lives.
</p></div>
<p>
It also turns out to be painful to bootstrap a system with a
new, ABI-incompatible version of the C library.  So it seems that the
soname change will not happen and that, on s390, a lot of rebuilding is
going to have to go on.  It will also become impossible to move affected
applications between systems with pre- and post-change libraries.  Not fun,
but, as David Miller <a href="https://lwn.net/Articles/605633/">put it</a>:
</p><p>
	Therefore, on the negative side, we might be stuck with this.  But,
	on the positive side, we can refer to this incident next time a
	similar incident arises.  We now know exactly what the
	ramifications are for not handling this properly.
</p>
<p>
That leads to the obvious question: what can be done to avoid this kind of
problem in the future?  Carlos <a href="https://lwn.net/Articles/605634/">plans</a> to put
together a policy on how to manage ABI changes, with &#34;<span>don&#39;t break
ABI ever</span>&#34; as
the first item.  There has been talk of improving the testing tools in an
attempt to catch this kind of ABI break in the future.
</p><p>
In the end, though, nothing can replace a high level of care on the part of
the developers involved.  Glibc developers have always shown that care,
which is why stories like this one are rare.  In the aftermath of this
mistake, one can assume that they will be doubly careful in the future.
That, along with some testing support, should help to ensure that upcoming
glibc releases are free of this kind of issue.<br clear="all"/></p><hr/><p>
           (<a href="https://lwn.net/Login/?target=/Articles/605607/">Log in</a> to post comments)
           </p></div></div>
  </body>
</html>
