<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.d46.us/advanced-emacs-startup/">Original</a>
    <h1>Advanced Techniques for Reducing Emacs Startup Time</h1>
    
    <div id="readability-page-1" class="page"><div><article itemscope="" itemtype="http://schema.org/Article">
<header>

</header>


<p>
tl;dr: Do these steps:
</p>

<ol>
<li>Profile with Esup.</li>
<li>Adjust the garbage collection threshold.</li>
<li>Autoload <b>everything</b> with use-package.</li>
<li>Avoid helper functions which cause eager loads.</li>
<li>See my Emacs <a href="https://github.com/jschaf/dotfiles/blob/master/emacs/start.el">config</a> for an example.</li>
</ol>


<h2 id="org427ea2a">From .emacs.d Bankruptcy to Now</h2>
<p>
I recently declared my third .emacs.d bankruptcy and finished the
fourth iteration of my Emacs configuration.  The evolution was:
</p>

<ol>
<li>Copy and paste elisp snippets into <code>~/.emacs</code> and hope it works.</li>
<li>Adopt a more structured approach with <code>el-get</code> to manage
dependencies.</li>
<li>Give up and outsource to Spacemacs.</li>
<li>Get tired of Spacemacs intricacies and rewrite with <code>use-package</code>.</li>
</ol>

<p>
This article is a collection of tips collected during the 3 rewrites
and from creating the Emacs Start Up Profiler.  Many thanks to the
teams behind Spacemacs, use-package and general.  Without these
dedicated voluteers, this task would be vastly more difficult.
</p>


<h2 id="org59da114">But What About Daemon Mode</h2>
<p>
Before we get started, let me acknowledge the common retort when
optimizing Emacs: “Emacs is meant to run as a daemon so you’ll only
start it once.”  That’s all well and good except:
</p>

<ul>
<li>Fast things feel nicer.</li>

<li>When customizing Emacs, you sometimes get into weird states that can
be hard to recover from without restarting.  For example, if you add
a slow <code>lambda</code> function to your <code>post-command-hook</code>, it’s tough to
remove it.</li>

<li>Restarting Emacs helps verify that customization will persist
between sessions.</li>
</ul>


<h2 id="org771752b">1. Establish the Current and Best Possible Start Up Time</h2>
<p>
The first step is to measure the current start up time.  The easy way
is to display the information at startup which will show progress
through the next steps.
</p>


<pre>

(add-hook &#39;emacs-startup-hook
          (<span>lambda</span> ()
            (message <span>&#34;Emacs ready in %s with %d garbage collections.&#34;</span>
                     (format <span>&#34;%.2f seconds&#34;</span>
                             (float-time
                              (time-subtract after-init-time before-init-time)))
                     gcs-done)))
</pre>

<p>
Second, measure the best possible startup speed so you know what’s
possible.  Mine is 0.3 seconds.
</p>


<pre>

emacs -q --eval=<span>&#39;(message &#34;%s&#34; (emacs-init-time))&#39;</span> 

;; For macOS users:
open -n /Applications/Emacs.app --args -q --eval=<span>&#39;(message &#34;%s&#34; (emacs-init-time))&#39;</span>  
</pre>


<h2 id="orga2036b6">2. Profile Emacs Startup for Easy Wins</h2>
<p>
The <a href="https://github.com/jschaf/esup">Emacs StartUp Profiler</a> (ESUP) will give you detailed metrics for
top-level expressions.
</p>


<figure id="fig:esup">
<p><img src="https://blog.d46.us/images/esup.png" alt="esup.png"/>
</p>
<figcaption><span>Figure 1:</span> Emacs Start Up Profiler Screenshot</figcaption>
</figure>

<p>
WARNING: Spacemacs users, ESUP currently chokes on the Spacemacs
init.el file.  Follow <a href="https://github.com/jschaf/esup/issues/48">https://github.com/jschaf/esup/issues/48</a> for
updates.
</p>


<h2 id="org37ca53c">3. Set the Garbage Collection Threshold Higher during Startup</h2>
<p>
This saves about <b><b>0.3 seconds</b></b> on my configuration.
</p>

<p>
The default value for Emacs is 760kB which is extremely conservative on
a modern machine. The real trick is to lower it back to something
reasonable after initialization.  This saves about 0.3 seconds on my
init files.
</p>


<pre id="/.emacs.d/init.el">


(<span>setq</span> gc-cons-threshold (* 50 1000 1000))




(<span>setq</span> gc-cons-threshold (* 2 1000 1000))
</pre>


<h2 id="orgdf956cf">4. Never require anything; autoload with use-package instead</h2>
<p>
The best way to make Emacs faster is to do less.  Running <code>require</code>
eagerly loads the underlying source file.  It’s rare the you’ll need
functionality immediately at startup time.  
</p>

<p>
With <a href="https://github.com/jwiegley/use-package"><code>use-package</code></a>, you declare which features you need from a package
and <code>use-package</code> does the right thing.  Here’s what it looks like:
</p>


<pre>(use-package evil-lisp-state 

  <span>:defer</span> t 

  <span>:init</span> 
  (<span>setq</span> evil-lisp-state-global nil)

  <span>:config</span> 
  (abn/define-leader-keys <span>&#34;k&#34;</span> evil-lisp-state-map))
</pre>

<p>
To see what packages Emacs currently has loaded, examine the
<code>features</code> variable.  For nice output see <a href="https://gist.github.com/RockyRoad29/bd4ca6fdb41196a71662986f809e2b1c">lpkg explorer</a> or my variant
in <a href="https://github.com/jschaf/dotfiles/blob/master/emacs/funcs/abn-funcs-benchmark.el">abn-funcs-benchmark.el</a>.  The output looks like:
</p>


<pre>479 features currently loaded
  - abn-funcs-benchmark: /Users/jschaf/.dotfiles/emacs/funcs/abn-funcs-benchmark.el
  - evil-surround: /Users/jschaf/.emacs.d/elpa/evil-surround-20170910.1952/evil-surround.elc
  - misearch: /Applications/Emacs.app/Contents/Resources/lisp/misearch.elc
  - multi-isearch: nil
  - &lt;many more&gt;
</pre>


<h2 id="org142995b">5. Avoid Helper Functions to Set Up Modes</h2>
<p>
Often, Emacs packages will suggest running a helper function to set up
keybindings.  Here’s a few examples: 
</p>

<ul>
<li><code>(evil-escape-mode)</code></li>
<li><code>(windmove-default-keybindings) ; Sets up keybindings.</code></li>
<li><code>(yas-global-mode 1) ; Complex snippet setup.</code></li>
</ul>

<p>
Rewrite these with use-package to improve startup speed.  These helper
functions are really just sneaky ways to trick you into eagerly
loading packages before you need them.
</p>

<p>
As an example, here’s how to autoload <code>evil-escape-mode</code>.
</p>


<pre>

(<span>define-minor-mode</span> <span>evil-escape-mode</span>
  (<span>if</span> evil-escape-mode
      (add-hook &#39;pre-command-hook &#39;evil-escape-pre-command-hook)
    (remove-hook &#39;pre-command-hook &#39;evil-escape-pre-command-hook)))


(evil-escape-mode)


(use-package evil-escape
  <span>:defer</span> t
  
  <span>:commands</span> (evil-escape-pre-command-hook) 

  
  
  
  <span>:init</span> (add-hook &#39;pre-command-hook &#39;evil-escape-pre-command-hook))
</pre>

<p>
For a much trickier example, consider <code>org-babel</code>.  The common recipe is:
</p>


<pre>(org-babel-do-load-languages
 &#39;org-babel-load-languages
 &#39;((shell . t)
   (emacs-lisp . nil)))
</pre>

<p>
This is bad because <code>org-babel-do-load-languages</code> is defined in
<code>org.el</code>, which is over 24k lines of code and takes about 0.2 seconds
to load.  After examining the source code,
<code>org-babel-do-load-languages</code> is simply requiring the <code>ob-&lt;lang&gt;</code>
package like so:
</p>


<pre>

(<span>require</span> (intern (concat <span>&#34;ob-&#34;</span> lang)))
</pre>

<p>
In the <code>ob-&lt;lang&gt;.el</code>, there’s only two methods we care about,
<code>org-babel-execute:&lt;lang&gt;</code> and <code>org-babel-expand-body:&lt;lang&gt;</code>.  We can
autoload the org-babel functionality instead of
<code>org-babel-do-load-languages</code> like so:
</p>


<pre>

(use-package ob-python
  <span>:defer</span> t
  <span>:ensure</span> org-plus-contrib
  <span>:commands</span> (org-babel-execute:python))

(use-package ob-shell
  <span>:defer</span> t
  <span>:ensure</span> org-plus-contrib
  <span>:commands</span>
  (org-babel-execute:sh
   org-babel-expand-body:sh

   org-babel-execute:bash
   org-babel-expand-body:bash))
</pre>


<h2 id="org3d73f8c">6. Defer Packages you don’t need Immediately with Idle Timers</h2>
<p>
This saves about <b><b>0.4 seconds</b></b> for the 9 packages I defer.
</p>

<p>
Some packages are useful and you want them available soon, but are not
essential for immediate editing.  These modes include:
</p>

<ul>
<li><code>recentf</code>: Saves recent files.</li>
<li><code>saveplace</code>: Saves point of visited files.</li>
<li><code>server</code>: Starts Emacs daemon.</li>
<li><code>autorevert</code>: Automatically reloads files that changed on disk.</li>
<li><code>paren</code>: Highlight matching parenthesis.</li>
<li><code>projectile</code>: Project management tools.</li>
<li><code>whitespace</code>: Highlight trailing whitespace.</li>
</ul>

<p>
Instead of requiring these modes, <b><b>load them after N seconds of idle
time</b></b>.  I use 1 second for the more important packages and 2 seconds
for everything else.
</p>


<pre>(use-package recentf
  
  <span>:defer</span> 1)

(use-package uniquify
  
  <span>:defer</span> 2)
</pre>



<h2 id="orgc7c3ed4">Optimizations that aren’t Worth It</h2>
<p>
Don’t bother byte-compiling your personal Emacs files.  It saved
about 0.05 seconds.  Byte compiling causes difficult to debug errors when the
source file gets out of sync with compiled file.
</p>

</article>
</div></div>
  </body>
</html>
