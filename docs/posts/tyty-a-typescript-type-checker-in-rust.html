<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://zackoverflow.dev/writing/tyty">Original</a>
    <h1>Tyty: A TypeScript type checker in Rust</h1>
    
    <div id="readability-page-1" class="page"><div><p>In the past I&#39;ve <a href="https://zackoverflow.dev/writing/the-problem-with-typescript">written</a> about Typescript&#39;s biggest underlying problem: it&#39;s slow compilation speeds. Amazing projects like <a href="https://github.com/evanw/esbuild">esbuild</a>, <a href="https://github.com/swc-project/swc">SWC</a>, and <a href="https://bun.sh/">bun</a> solve the first half of the problem, emitting JS from TS, but they skip the critical type-checking phase completely due to complexity.</p>
<p>In that post I briefly mentioned that most of the major players (also including Deno, Rome, etc.) in the JS compilation ecosystem don&#39;t have any plans to type-check TS code. SWC is the only project actively solving this problem, but it&#39;s unclear if it will be <a href="https://github.com/swc-project/swc/issues/571#issuecomment-803553183">open-source or commercially licensed</a>.</p>
<p>This basically means that the majority of us will be at the mercy of <code>tsc</code>&#39;s abysmally slow speed, and that prompted me to consider building an open-source type-checker of my own. It certainly would be a fun and challenging undertaking, and would provide utility to a vast number of people.</p>
<p>And thus, I started working on a TS type-checker arbitrarily named <code>tyty</code> about a week ago in my spare time. It currently supports a small subset of Typescript, I plan to open-source it soon.</p>
<p>The obvious starting point was to build upon an existing JS/TS parser/bundler by type-checking its output AST. The <a href="https://github.com/evanw/esbuild/issues/101#issuecomment-626239597">difficult problem</a> of parsing JS/TS has been solved many times over now, why reinvent the wheel? Of the existing projects out there, SWC is the only one which makes its AST nodes accessible to its public facing API, so it became the clear choice.</p>
<h2>Challenges</h2>
<p>Typescript&#39;s type-system is simple in some ways and complex in others. In the traditional type systems view, it is quite simple. Typescript uses bidirectional type-checking which has a very simple local type inference algorithm. There are type systems with more sophicasted inference, for example the <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">Hindley-Milner</a> type system. As a result, the majority of type-checking in Typescript is more straightforward than you&#39;d think.</p>
<p>The remaining difficulty comes from some of Typescript&#39;s unique features. One of the coolest features is its conditional and recursive types. When paired with generic parameters, they allow you to add complex logic to your type definitions, effectively giving you a simple functional programming language (that operates on types instead of data), all embedded within Typescript&#39;s type-system. For example, see this <a href="https://github.com/jamiebuilds/json-parser-in-typescript-very-bad-idea-please-dont-use">JSON parser</a> created entirely from Typescript types.</p>
<p>The consequence of this is the problem of type checking complex types becomes more of a problem of building an interpreter for this meta-language embedded within the type-system. Having created a <a href="https://github.com/zackradisic/aussieplusplus">programming language</a> before, I am really excited to tackle this aspect of Typescript as it&#39;s more familiar ground for me.</p>
<h2>Goals</h2>
<p>The end goal is to reach feature parity with Typescript and provide a way to compile TS code either through SWC&#39;s upcoming plugin system or a wrapper around it.</p>
<p>I also want to leverage the speed of a Rust-based type-checker to create a very fast LSP server implementation that works well in all editors (not just VSCode!).</p>
<p>Additionally, I want to <code>tyty</code> to have better and more descriptive error messages than <code>tsc</code>&#39;s. Isn&#39;t this nice?:
<img src="https://zackoverflow.dev/tyty-errors.jpeg" alt="tyty&#39;s errors"/></p>
<p>Ideally I would also like to expose some of the type-checking functionality in a library, because Typescript&#39;s compiler API is quite horrendous. This would give developers more robust tooling to manipulate Typescript types. When I was working on <a href="https://zackoverflow.dev/writing/tsgql">tsgql</a> I had such a terrible time working with the TS compiler API.</p>
<p>This is more of a moonshot idea, but it would be amazing if <code>tyty</code> could interoperate with other JS/TS compilers. It could be compiled into a dynamic library and called through FFI.</p></div></div>
  </body>
</html>
