<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://buttondown.com/hillelwayne/archive/my-gripes-with-prolog/">Original</a>
    <h1>My Gripes with Prolog</h1>
    
    <div id="readability-page-1" class="page"><div>
    
        
            <p>For the next release of <a href="https://leanpub.com/logic/" target="_blank">Logic for Programmers</a>, I&#39;m finally adding the sections on Answer Set Programming and Constraint Logic Programming that I TODOd back in version 0.9. And this is making me re-experience some of my pain points with Prolog, which I will gripe about now.  If you want to know more about why Prolog is cool instead, go <a href="https://buttondown.com/hillelwayne/archive/a48fce5b-8a05-4302-b620-9b26f057f145/" target="_blank">here</a> or <a href="https://www.metalevel.at/prolog" target="_blank">here</a> or <a href="https://ianthehenry.com/posts/drinking-with-datalog/" target="_blank">here</a> or <a href="https://logicprogramming.org/" target="_blank">here</a>. </p>
<h3>No standardized strings</h3>
<p>ISO &#34;strings&#34; are just atoms or lists of single-character atoms (or lists of integer character codes). The various implementations of Prolog add custom string operators but they are not cross compatible, so code written with strings in SWI-Prolog will not work in Scryer Prolog. </p>
<h3>No functions</h3>
<p>Code logic is expressed entirely in <em>rules</em>, predicates which return true or false for certain values. For example if you wanted to get the length of a Prolog list, you write this:</p>
<div><pre><span></span><code><span>?-</span> <span>length</span><span>([</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>],</span> <span>Len</span><span>).</span>

   <span>Len</span> <span>=</span> <span>3.</span>
</code></pre></div>

<p>Now this is pretty cool in that it allows bidirectionality, or running predicates &#34;in reverse&#34;. To generate lists of length 3, you can write <code>length(L, 3)</code>. But it also means that if you want to get the length a list <em>plus one</em>, you can&#39;t do that in one expression, you have to write <code>length(List, Out), X is Out+1</code>.</p>
<p>For a while I thought no functions was necessary evil for bidirectionality, but then I discovered <a href="https://picat-lang.org/" target="_blank">Picat</a> has functions and works just fine. That by itself is a reason for me to prefer Picat for my LP needs.</p>
<p>(Bidirectionality is a killer feature of Prolog, so it&#39;s a shame I so rarely run into situations that use it.)</p>
<h3>No standardized collection types besides lists</h3>
<p>Aside from atoms (<code>abc</code>) and numbers, there are two data types:</p>
<ul>
<li>Linked lists like <code>[a,b,c,d]</code>.</li>
<li>Compound terms like <code>dog(rex, poodle)</code>, which <em>seem</em> like record types but are actually tuples. You can even convert compound terms to linked lists with <code>=..</code>:</li>
</ul>
<div><pre><span></span><code><span>?-</span> <span>L</span> <span>=..</span> <span>[</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>].</span>
   <span>L</span> <span>=</span> <span>a</span><span>(</span><span>b</span><span>,</span> <span>c</span><span>).</span>
<span>?-</span> <span>a</span><span>(</span><span>b</span><span>,</span> <span>c</span><span>(</span><span>c</span><span>))</span> <span>=..</span> <span>L</span><span>.</span>
   <span>L</span> <span>=</span> <span>[</span><span>a</span><span>,</span> <span>b</span><span>,</span> <span>c</span><span>(</span><span>c</span><span>)].</span>
</code></pre></div>
<p>There&#39;s no proper key-value maps or even struct types. Again, this is something that individual distributions can fix (without cross compatibility), but these never feel integrated with the rest of the language. </p>
<h3>No boolean values</h3>
<p><code>true</code> and <code>false</code> aren&#39;t values, they&#39;re control flow statements. <code>true</code> is a noop and <code>false</code> says that the current search path is a dead end, so backtrack and start again. You can&#39;t explicitly store true and false as values, you have to implicitly have them in facts (<code>passed(test)</code> instead of <code>test.passed? == true</code>).</p>
<p>This hasn&#39;t made any tasks impossible, and I can usually find a workaround to whatever I want to do. But I do think it makes things more inconvenient! Sometimes I want to do something dumb like &#34;get all atoms that don&#39;t pass at least three of these rules&#34;, and that&#39;d be a lot easier if I could shove intermediate results into a sack of booleans. </p>
<p>(This is called &#34;<a href="https://en.wikipedia.org/wiki/Negation_as_failure" target="_blank">Negation as Failure</a>&#34;. I think this might be necessary to make Prolog a Turing complete general programming language. Picat fixes a lot of Prolog&#39;s gripes and still has negation as failure. ASP has regular negation but it&#39;s not Turing complete.) </p>
<h3>Cuts are confusing</h3>

<p>Prolog finds solutions through depth first search, and a &#34;cut&#34; (<code>!</code>) symbol prevents backtracking past a certain point. This is necessary for optimization but can lead to invalid programs. </p>
<p>You&#39;re not supposed to use cuts if you can avoid it, so I pretended cuts didn&#39;t exist. Which is why I was surprised to find that <a href="https://eu.swi-prolog.org/pldoc/doc_for?object=(-%3E)/2" target="_blank">conditionals</a> are implemented with cuts. Because cuts are spooky dark magic conditionals <em>sometimes</em> conditionals work as I expect them to and sometimes leave out valid solutions and I have no idea how to tell which it&#39;ll be. Usually I find it safer to just avoid conditionals entirely, which means my code gets a lot longer and messier. </p>
<h3>Non-cuts are confusing</h3>
<p>The original example in the last section was this: </p>
<div><pre><span></span><code><span>foo</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>)</span> <span>:-</span>
    <span>\+</span> <span>(</span><span>A</span> <span>=</span> <span>B</span><span>),</span>
    <span>A</span> <span>=</span> <span>1</span><span>,</span>
    <span>B</span> <span>=</span> <span>2.</span>
</code></pre></div>
<p><code>foo(1, 2)</code> returns true, so you&#39;d expect <code>f(A, B)</code> to return <code>A=1, B=2</code>. But it returns <code>false</code>.  Whereas this works as expected.</p>
<div><pre><span></span><code><span>bar</span><span>(</span><span>A</span><span>,</span> <span>B</span><span>)</span> <span>:-</span>
    <span>A</span> <span>=</span> <span>1</span><span>,</span>
    <span>B</span> <span>=</span> <span>2</span><span>,</span>
    <span>\+</span> <span>(</span><span>A</span> <span>=</span> <span>B</span><span>).</span>
</code></pre></div>
<p>I <em>thought</em> this was because <code>\+</code> was implemented with cuts, and the <a href="https://www.amazon.com/Programming-Prolog-Using-ISO-Standard/dp/3540006788" target="_blank">Clocksin book</a> suggests it&#39;s <code>call(P), !, fail</code>, so this was my prime example about how cuts are confusing. But then I tried this:</p>
<div><pre><span></span><code><span>?-</span> <span>member</span><span>(</span><span>A</span><span>,</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]),</span> <span>\+</span> <span>(</span><span>A</span> <span>=</span> <span>2</span><span>),</span> <span>A</span> <span>=</span> <span>3.</span>
<span>A</span> <span>=</span> <span>3.</span> <span>% wtf?</span>
</code></pre></div>
<p>There&#39;s no way to get that behavior with cuts! I don&#39;t think <code>\+</code> uses cuts at all! And now I have to figure out why 
<code>foo(A, B)</code> doesn&#39;t returns results. Is it <a href="https://github.com/dtonhofer/prolog_notes/blob/master/other_notes/about_negation/floundering.md" target="_blank">floundering</a>? Is it because <code>\+ P</code> only succeeds if <code>P</code> fails, and <code>A = B</code> always succeeds? A closed-world assumption? Something else?<sup id="fnref:dif"><a href="#fn:dif">1</a></sup></p>
<h3>Straying outside of default queries is confusing</h3>
<p>Say I have a program like this:</p>
<div><pre><span></span><code><span>tree</span><span>(</span><span>n</span><span>,</span> <span>n1</span><span>).</span>
<span>tree</span><span>(</span><span>n</span><span>,</span> <span>n2</span><span>).</span>
<span>tree</span><span>(</span><span>n1</span><span>,</span> <span>n11</span><span>).</span>
<span>tree</span><span>(</span><span>n2</span><span>,</span> <span>n21</span><span>).</span>
<span>tree</span><span>(</span><span>n2</span><span>,</span> <span>n22</span><span>).</span>
<span>tree</span><span>(</span><span>n11</span><span>,</span> <span>n111</span><span>).</span>
<span>tree</span><span>(</span><span>n11</span><span>,</span> <span>n112</span><span>).</span>

<span>branch</span><span>(</span><span>N</span><span>)</span> <span>:-</span> <span>% two children</span>
    <span>tree</span><span>(</span><span>N</span><span>,</span> <span>C1</span><span>),</span>
    <span>tree</span><span>(</span><span>N</span><span>,</span> <span>C2</span><span>),</span>
    <span>C1</span> <span>@&lt;</span> <span>C2</span><span>.</span> <span>% ordering</span>
</code></pre></div>
<p>And I want to know all of the nodes that are parents of branches. The normal way to do this is with a query:</p>
<div><pre><span></span><code><span>?-</span> <span>tree</span><span>(</span><span>A</span><span>,</span> <span>N</span><span>),</span> <span>branch</span><span>(</span><span>N</span><span>).</span>
<span>A</span> <span>=</span> <span>n</span><span>,</span> <span>N</span> <span>=</span> <span>n2</span><span>;</span> <span>% show more...</span>
<span>A</span> <span>=</span> <span>n1</span><span>,</span> <span>N</span> <span>=</span> <span>n11</span><span>.</span>
</code></pre></div>
<p>This is interactively making me query for every result. That&#39;s usually not what I want, I know the result of my query is finite and I want all of the results at once, so I can count or farble or whatever them. It took a while to figure out that the proper solution is <a href="https://www.swi-prolog.org/pldoc/man?predicate=bagof/3" target="_blank"><code>bagof(Template, Goal, Bag)</code></a>, which will &#34;Unify Bag with the alternatives of Template&#34;:</p>
<div><pre><span></span><code><span>?-</span> <span>bagof</span><span>(</span><span>A</span><span>,</span> <span>(</span><span>tree</span><span>(</span><span>A</span><span>,</span> <span>N</span><span>),</span> <span>branch</span><span>(</span><span>N</span><span>)),</span> <span>As</span><span>).</span>

<span>As</span> <span>=</span> <span>[</span><span>n1</span><span>],</span> <span>N</span> <span>=</span> <span>n11</span><span>;</span>
<span>As</span> <span>=</span> <span>[</span><span>n</span><span>],</span> <span>N</span> <span>=</span> <span>n2</span><span>.</span>
</code></pre></div>
<p>Wait crap that&#39;s still giving one result at a time, because <code>N</code> is a free variable in <code>bagof</code> so it backtracks over that. It surprises me but I guess it&#39;s good to have as an option. So how do I get all of the results at once?</p>
<div><pre><span></span><code><span>?-</span> <span>bagof</span><span>(</span><span>A</span><span>,</span> <span>N</span><span>^</span><span>(</span><span>tree</span><span>(</span><span>A</span><span>,</span> <span>N</span><span>),</span> <span>branch</span><span>(</span><span>N</span><span>)),</span> <span>As</span><span>).</span>

<span>As</span> <span>=</span> <span>[</span><span>n</span><span>,</span> <span>n1</span><span>]</span>
</code></pre></div>
<p>The only difference is the <code>N^Goal</code>, which tells <code>bagof</code> to ignore and group the results of <code>N</code>. As far as I can tell, this is the <em>only</em> place the ISO standard uses <code>^</code> to mean anything besides exponentiation. Supposedly it&#39;s the <a href="https://sicstus.sics.se/sicstus/docs/latest4/html/sicstus.html/ref_002dall_002dsum.html" target="_blank">existential quantifier</a>? In general whenever I try to stray outside simpler use-cases, especially if I try to do things non-interactively, I run into trouble.</p>
<h3>I have mixed feelings about symbol terms</h3>
<p>It took me a long time to realize the reason <code>bagof</code>  &#34;works&#34; is because infix symbols are mapped to prefix compound terms, so that  <code>a^b</code> is <code>^(a, b)</code>, and then different predicates can decide to do different things with <code>^(a, b)</code>.</p>
<p>This is also why you can&#39;t just write <code>A = B+1</code>: that unifies <code>A</code> with the <em>compound term</em> <code>+(B, 1)</code>. <code>A+1 = B+2</code> is <em>false</em>, as <code>1 \= 2</code>. You have to write <code>A+1 is B+2</code>, as <code>is</code> is the operator that converts <code>+(B, 1)</code> to a mathematical term.</p>
<p>(And <em>that</em> fails because <code>is</code> isn&#39;t fully bidirectional. The lhs <em>must</em> be a single variable. You have to import <code>clpfd</code> and write <code>A + 1 #= B + 2</code>.)</p>
<p>I don&#39;t like this, but I&#39;m a hypocrite for saying that because I appreciate the idea and don&#39;t mind custom symbols in other languages. I guess what annoys me is there&#39;s no official definition of what <code>^(a, b)</code> is, it&#39;s purely a convention. ISO Prolog uses <code>-(a, b)</code> (aka <code>a-b</code>) as a convention to mean &#34;pairs&#34;, and the only way to realize that is to see that an awful lot of standard modules use that convention. But you can use <code>-(a, b)</code> to mean something else in your own code and nothing will warn you of the inconsistency.</p>
<p>Anyway I griped about pairs so I can gripe about <code>sort</code>.</p>
<h3>go home sort, ur drunk</h3>
<p>This one&#39;s just a blunder:</p>
<div><pre><span></span><code><span>?-</span> <span>sort</span><span>([</span><span>3</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>1</span><span>,</span><span>3</span><span>],</span> <span>Out</span><span>).</span>
   <span>Out</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>].</span> <span>% wat</span>
</code></pre></div>
<p>According to an expert online this is because sort is supposed to return a sorted <em>set</em>, not a sorted list. If you want to preserve duplicates you&#39;re supposed to lift all of the values into <code>-($key, $value)</code> compound terms, then use <a href="https://eu.swi-prolog.org/pldoc/doc_for?object=keysort/2" target="_blank">keysort</a>, then extract the values. And, since there&#39;s no functions, this process takes at least three lines. This is also how you&#39;re supposed to sort by a custom predicate, like &#34;the second value of a compound term&#34;. </p>
<p>(Most (but not all) distributions have a duplicate merge like <a href="https://eu.swi-prolog.org/pldoc/doc_for?object=msort/2" target="_blank">msort</a>. SWI-Prolog also has a <a href="https://eu.swi-prolog.org/pldoc/doc_for?object=predsort/3" target="_blank">sort by key</a> but it removes duplicates.)</p>
<h3>Please just let me end rules with a trailing comma instead of a period, I&#39;m begging you</h3>
<p>I don&#39;t care if it makes fact parsing ambiguous, I just don&#39;t want &#34;reorder two lines&#34; to be a syntax error anymore</p>
<hr/>
<p>I expect by this time tomorrow I&#39;ll have been Cunningham&#39;d and there will be a 2000 word essay about how all of my gripes are either easily fixable by doing XYZ or how they are the best possible choice that Prolog could have made. I mean, even in writing this I found out some fixes to problems I had. Like I was going to gripe about how I can&#39;t run SWI-Prolog queries from the command line but, in doing do diligence finally <em>finally</em> figured it out:</p>
<div><pre><span></span><code>swipl<span> </span>-t<span> </span>halt<span> </span>-g<span> </span><span>&#34;bagof(X, Goal, Xs), print(Xs)&#34;</span><span> </span>./file.pl
</code></pre></div>
<p>It&#39;s pretty clunky but still better than the old process of having to enter an interactive session every time I wanted to validate a script change.</p>
<p>(Also, answer set programming is pretty darn cool. Excited to write about it in the book!)</p>

        
    
</div></div>
  </body>
</html>
