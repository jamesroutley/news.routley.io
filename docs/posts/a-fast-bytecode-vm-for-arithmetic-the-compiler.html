<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-compiler/">Original</a>
    <h1>A Fast Bytecode VM for Arithmetic: The Compiler</h1>
    
    <div id="readability-page-1" class="page"><article itemscope="" itemtype="http://schema.org/Article" id="arithmetic-bytecode-vm-compiler">
  
  <header>
    

    
  </header>

  <section><p>In this series of posts, we write a fast bytecode compiler and a virtual machine for arithmetic in Haskell. We explore the following topics:</p>
<ul>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#parsing-expressions">Parsing arithmetic expressions to Abstract Syntax Trees (ASTs).</a></label></li>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#testing-the-parser">Unit testing for our parser.</a></label></li>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#the-ast-interpreter">Interpreting ASTs.</a></label></li>
<li><label><span>Compiling ASTs to bytecode.</span></label></li>
<li><label><span>Disassembling and decompiling bytecode.</span></label></li>
<li><label><span>Unit testing for our compiler.</span></label></li>
<li><label>Property-based testing for our compiler.</label></li>
<li><label>Efficiently executing bytecode in a virtual machine (VM).</label></li>
<li><label>Unit testing and property-based testing for our <abbr title="Virtual Machine">VM</abbr>.</label></li>
<li><label>Benchmarking our code to see how the different passes perform.</label></li>
<li><label>All the while keeping an eye on performance.</label></li>
</ul>
<p>In this post, we write the compiler for our <abbr title="Abstract Syntax Tree">AST</abbr> to bytecode, and a decompiler for the bytecode.</p>
</section>

  <section itemprop="articleBody">
    <p>In this series of posts, we write a fast bytecode compiler and a virtual machine for arithmetic in Haskell. We explore the following topics:</p>
<ul>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#parsing-expressions">Parsing arithmetic expressions to Abstract Syntax Trees (ASTs).</a></label></li>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#testing-the-parser">Unit testing for our parser.</a></label></li>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#the-ast-interpreter">Interpreting ASTs.</a></label></li>
<li><label><span>Compiling ASTs to bytecode.</span></label></li>
<li><label><span>Disassembling and decompiling bytecode.</span></label></li>
<li><label><span>Unit testing for our compiler.</span></label></li>
<li><label>Property-based testing for our compiler.</label></li>
<li><label>Efficiently executing bytecode in a virtual machine (VM).</label></li>
<li><label>Unit testing and property-based testing for our <abbr title="Virtual Machine">VM</abbr>.</label></li>
<li><label>Benchmarking our code to see how the different passes perform.</label></li>
<li><label>All the while keeping an eye on performance.</label></li>
</ul>
<p>In this post, we write the compiler for our <abbr title="Abstract Syntax Tree">AST</abbr> to bytecode, and a decompiler for the bytecode.</p>
<!--more-->
<p>This is the second post in a series of posts:</p>
<ol type="1">
<li><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/">A Fast Bytecode VM for Arithmetic: The Parser</a></li>
<li>A Fast Bytecode VM for Arithmetic: The Compiler</li>
<li>A Fast Bytecode VM for Arithmetic: The Virtual Machine</li>
</ol>
<nav id="toc"><h3>Contents</h3><ol><li><a href="#introduction">Introduction</a></li><li><a href="#the-bytecode">The Bytecode</a><ol><li><a href="#num"><code><span>Num</span></code></a></li><li><a href="#binop"><code><span>BinOp</span></code></a></li><li><a href="#var-and-let"><code><span>Var</span></code> and
<code><span>Let</span></code></a></li></ol></li><li><a href="#the-compiler">The Compiler</a><ol><li><a href="#compiling-fast-and-slow">Compiling, Fast and Slow</a></li></ol></li><li><a href="#the-decompiler">The Decompiler</a></li><li><a href="#testing-the-compiler">Testing the Compiler</a></li></ol></nav>
<h2 data-track-content="" data-content-name="introduction" data-content-piece="arithmetic-bytecode-vm-compiler" id="introduction">Introduction</h2>
<p><abbr title="Abstract Syntax Tree">AST</abbr> interpreters are well known to be slow because of how <abbr title="Abstract Syntax Tree">AST</abbr> nodes are represented in the computer’s memory. The <abbr title="Abstract Syntax Tree">AST</abbr> nodes contain pointers to other nodes, which may be anywhere in the memory. So while interpreting an <abbr title="Abstract Syntax Tree">AST</abbr>, the interpreter jumps all over the memory, causing a slowdown. One solution to this is to convert the <abbr title="Abstract Syntax Tree">AST</abbr> into a more compact and optimized representation known as <em><a href="https://en.wikipedia.org/wiki/Bytecode" target="_blank" rel="noopener">Bytecode</a></em>.</p>
<p>Bytecode is a flattened and compact representation of a program, usually manifested as a byte array. Bytecode is essentially an <em><a href="https://en.wikipedia.org/wiki/Instruction_Set" target="_blank" rel="noopener">Instruction Set</a></em> (IS), but custom-made to be executed by a <em><a href="https://en.wikipedia.org/wiki/Virtual_Machine" target="_blank" rel="noopener">Virtual Machine</a></em> (VM), instead of a physical machine. Each bytecode instruction is one byte in size (that’s where it gets its name from). A bytecode and its <abbr title="Virtual Machine">VM</abbr> are created in synergy so that the execution is as efficient as possible<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Compiling source code to bytecode and executing it in a <abbr title="Virtual Machine">VM</abbr> also allows the program to be run on all platforms that the <abbr title="Virtual Machine">VM</abbr> supports without the developer caring much about portability concerns. The most popular combo of bytecode and <abbr title="Virtual Machine">VM</abbr> is probably the <a href="https://en.wikipedia.org/wiki/Java_bytecode" target="_blank" rel="noopener">Java bytecode</a> and the <a href="https://en.wikipedia.org/wiki/Java_virtual_machine" target="_blank" rel="noopener">Java virtual machine</a>.</p>
<p>The <abbr title="Virtual Machine">VM</abbr>s can be <a href="https://en.wikipedia.org/wiki/Stack_machine" target="_blank" rel="noopener">stack-based</a> or <a href="https://en.wikipedia.org/wiki/Register_machine" target="_blank" rel="noopener">register-based</a>. In a stack-based <abbr title="Virtual Machine">VM</abbr>, all values created during the execution of a program are stored only in a <em><a href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" target="_blank" rel="noopener">Stack</a></em> data-structure residing in the memory. Whereas, in a register-based <abbr title="Virtual Machine">VM</abbr>, there is also an additional set of fixed number of <a href="https://en.wikipedia.org/wiki/Processor_register" target="_blank" rel="noopener">registers</a> that are used to store values in preference to the stack<a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Register-based <abbr title="Virtual Machine">VM</abbr>s are usually faster, but stack-based <abbr title="Virtual Machine">VM</abbr>s are usually simpler to implement. For our purpose, we choose to implement a stack-based <abbr title="Virtual Machine">VM</abbr>.</p>
<p>We are going to write a compiler that compiles our expression <abbr title="Abstract Syntax Tree">AST</abbr> to bytecode. But first, let’s design the bytecode for our stack-based <abbr title="Virtual Machine">VM</abbr>.</p>
<h2 data-track-content="" data-content-name="the-bytecode" data-content-piece="arithmetic-bytecode-vm-compiler" id="the-bytecode">The Bytecode</h2>
<p>Here is our expression AST as a reminder:</p>
<figure>
<div id="cb1" data-lang="haskell"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Expr</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>Num</span> <span>!</span><span>Int16</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Var</span> <span>!</span><span>Ident</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>BinOp</span> <span>!</span><span>Op</span> <span>Expr</span> <span>Expr</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>Let</span> <span>!</span><span>Ident</span> <span>Expr</span> <span>Expr</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Generic</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Ident</span> <span>=</span> <span>Ident</span> <span>BS.ByteString</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Eq</span>, <span>Ord</span>, <span>Generic</span>, <span>Hashable</span>)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Op</span> <span>=</span> <span>Add</span> <span>|</span> <span>Sub</span> <span>|</span> <span>Mul</span> <span>|</span> <span>Div</span> <span>deriving</span> (<span>Eq</span>, <span>Enum</span>, <span>Generic</span>)</span></code></pre></div>
<figcaption>
ArithVMLib.hs
</figcaption>
</figure>
<p>Let’s figure out the right bytecode for each case. First, we create <em><a href="https://en.wikipedia.org/wiki/Opcodes" target="_blank" rel="noopener">Opcodes</a></em> for each bytecode, which are sort of mnemonics for actual bytecode. Think of them as <em><a href="https://en.wikipedia.org/wiki/Assembly_language" target="_blank" rel="noopener">Assembly</a></em> is to <em><a href="https://en.wikipedia.org/wiki/Machine_Code" target="_blank" rel="noopener">Machine Code</a></em>.</p>
<h3 id="num"><code><span>Num</span></code></h3>
<p>For a number literal, we need to put it directly in the bytecode so that we can use it later during the execution. We also need an opcode to push it on the stack. Let’s call it <code><span>OPush</span></code> with an <code><span>Int16</span></code> parameter.</p>
<h3 id="binop"><code><span>BinOp</span></code></h3>
<p>Binary operations recursively use <code><span>Expr</span></code> for their operands. To evaluate a binary operation, we need its operands to be evaluated before, so we compile them first to bytecode. After that, all we need is an opcode per operator. Let’s call them <code><span>OAdd</span></code>, <code><span>OSub</span></code>, <code><span>OMul</span></code>, and <code><span>ODiv</span></code> for <code><span>Add</span></code>, <code><span>Sub</span></code>, <code><span>Mul</span></code>, and <code><span>Div</span></code> operators respectively.</p>
<h3 id="var-and-let"><code><span>Var</span></code> and <code><span>Let</span></code></h3>
<p>Variables and <code><span>Let</span></code> expressions are more complex<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a>. In the <abbr title="Abstract Syntax Tree">AST</abbr> interpreter we chucked the variables in a map, but we cannot do that in a <abbr title="Virtual Machine">VM</abbr>. There is no environment map in a <abbr title="Virtual Machine">VM</abbr>, and all values must reside in the stack. How do we have variables at all then? Let’s think for a bit.</p>
<p>Each expression, after being evaluated in the <abbr title="Virtual Machine">VM</abbr>, must push exactly one value on the stack: its result. <code><span>Num</span></code> expressions are a trivial case. When a binary operation is evaluated, first its left operand is evaluated. That pushes one value on the stack. Then its right operand is evaluated, and that pushes another value on the stack. Finally, the operation pops the two values from the top of the stack, does its thing, and pushes the resultant value back on the stack—again one value for the entire <code><span>BinOp</span></code> expression.</p>
<p>A <code><span>Let</span></code> expression binds a variable’s value to its name, and then the variable can be referred from the body of the expression. But how can we refer to a variable when the stack contains only values, not names? Let’s imagine that we are in middle of evaluating a large expression, wherein we encounter a <code><span>Let</span></code> expression. First we evaluate its assignment expression, and that leaves a value on the top of the stack. Let’s say that the stack has <code>n</code> values at this point. After this we get to evaluate the body expression. At all times when we are doing that, the value from assignment stays at the same point in the stack because evaluating sub-expressions, no matter how complicated, only adds new values to the stack, without popping an existing value from before. Therefore, we can use the stack index of the assignment value (<code>n−1</code>) to refer to it within the body expression. So, we encode <code><span>Var</span></code> as an opcode and an integer index into the stack.</p>
<p>We choose to use a <code><span>Word8</span></code> to index the stack, limiting us to a stack depth of 256. We encode the variable references with an opcode <code><span>OGet</span></code>, which when executed gets the value from the stack at the given index and pushes it on the stack.</p>
<p>For a <code><span>Let</span></code> expression, after we compile its assignment and body expressions, we need to make sure that the exactly-one-value invariant holds. Evaluating the assignment and body pushes two values on the stack, but we can have only one! So we overwrite the assignment value with the body value, and pop the stack to remove the body value. We invent a new opcode <code><span>OSwapPop</span></code> to do this, called so because its effect is equivalent to swapping the topmost two values on the stack, and then popping the new top value<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a>.</p>
<p>Putting all the opcodes together, we have the <code><span>Opcode</span></code> ADT:</p>
<figure>
<div id="cb2" data-lang="haskell"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>Opcode</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span>=</span> <span>OPush</span> <span>!</span><span>Int16</span>        <span>-- 0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>OSwapPop</span>            <span>-- 1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>OGet</span> <span>!</span><span>Word8</span>         <span>-- 2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>OAdd</span>                <span>-- 3</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>OSub</span>                <span>-- 4</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>OMul</span>                <span>-- 5</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span>|</span> <span>ODiv</span>                <span>-- 6</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  <span>deriving</span> (<span>Show</span>, <span>Read</span>, <span>Eq</span>, <span>Generic</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>NFData</span> <span>Opcode</span></span></code></pre></div>
<figcaption>
ArithVMLib.hs
</figcaption>
</figure>
<p>Notice that we also assigned bytecodes—that is, a unique byte value—to each <code><span>Opcode</span></code> above, which are just their ordinals. Now we are ready to write the compiler.</p>
<h2 data-track-content="" data-content-name="the-compiler" data-content-piece="arithmetic-bytecode-vm-compiler" id="the-compiler">The Compiler</h2>
<p>The compiler takes an expression with the bytecode size, and compiles it to a strict <a href="https://hackage.haskell.org/package/bytestring/docs/Data-ByteString.html#t:ByteString" target="_blank" rel="noopener"><code><span>ByteString</span></code></a> of that size. Recall that in <a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#parsing-expressions">the previous post</a>, we wrote our parser such that the bytecode size for each <abbr title="Abstract Syntax Tree">AST</abbr> node was calculated while parsing it. This allows us to pre-allocate a bytestring of required size before compiling the <abbr title="Abstract Syntax Tree">AST</abbr>. We compile to actual bytes here, and don’t use the opcodes.</p>
<figure>
<div id="cb3" data-lang="haskell"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Bytecode</span> <span>=</span> <span>BS.ByteString</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span>compile ::</span> <span>SizedExpr</span> <span>-&gt;</span> <span>Result</span> <span>Bytecode</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>compile <span>=</span> compile&#39; defaultStackSize</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span>compile&#39; ::</span> <span>Int</span> <span>-&gt;</span> <span>SizedExpr</span> <span>-&gt;</span> <span>Result</span> <span>Bytecode</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>compile&#39; stackSize (expr, bytecodeSize) <span>=</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span>uncurry</span> (<span>fmap</span> <span>.</span> <span>const</span>) <span>.</span> BSI.unsafeCreateUptoN&#39; bytecodeSize <span>$</span> \fp <span>-&gt;</span> <span>do</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    (bytecodeSize,)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      <span>&lt;$&gt;</span> <span>fmap</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span>Right</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        (compileIO bytecodeSize stackSize fp fp expr <span>&gt;&gt;=</span> checkSize fp <span>.</span> TS.fst)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span>`catch`</span> (<span>pure</span> <span>.</span> <span>Left</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    checkSize fp ip <span>=</span> <span>do</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      <span>let</span> actualBytecodeSize <span>=</span> ip <span>`minusPtr`</span> fp</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>      unless (actualBytecodeSize <span>==</span> bytecodeSize) <span>$</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        throwIO <span>.</span> <span>Error</span> <span>Compile</span> <span>$</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>          <span>&#34;Compiled bytecode size &#34;</span> <span>&lt;&gt;</span> <span>show</span> actualBytecodeSize</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            <span>&lt;&gt;</span> <span>&#34; is not same as expected size: &#34;</span> <span>&lt;&gt;</span> <span>show</span> bytecodeSize</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span>compileIO ::</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>  <span>Int</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Ptr</span> <span>Word8</span> <span>-&gt;</span> <span>Ptr</span> <span>Word8</span> <span>-&gt;</span> <span>Expr</span> <span>-&gt;</span> <span>IO</span> (<span>Pair</span> (<span>Ptr</span> <span>Word8</span>) <span>Int</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>compileIO bytecodeSize stackSize fp ip <span>=</span> go Map.empty <span>0</span> ip</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    ep <span>=</span> fp <span>`plusPtr`</span> bytecodeSize</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    go env <span>!</span>sp <span>!</span>ip <span>=</span> \<span>case</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>      <span>Num</span> n <span>|</span> sp <span>+</span> <span>1</span> <span>&lt;=</span> stackSize <span>-&gt;</span> <span>do</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span>let</span> <span>!</span>lb <span>=</span> <span>fromIntegral</span> <span>$</span> n <span>.&amp;.</span> <span>0xff</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            <span>!</span>mb <span>=</span> <span>fromIntegral</span> <span>$</span> ((<span>fromIntegral</span><span> n ::</span> <span>Word16</span>) <span>.&amp;.</span> <span>0xff00</span>) <span>`shiftR`</span> <span>8</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        writeByte ip <span>0</span> <span>-- OPush</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        writeByte (ip <span>`plusPtr`</span> <span>1</span>) lb</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>        writeByte (ip <span>`plusPtr`</span> <span>2</span>) mb</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        <span>pure</span> (ip <span>`plusPtr`</span> <span>3</span> <span>:!:</span> sp <span>+</span> <span>1</span>)</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>      <span>Num</span> _ <span>-&gt;</span> throwCompileError <span>&#34;Stack overflow&#34;</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>      <span>BinOp</span> op a b <span>-&gt;</span> <span>do</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        (ip&#39; <span>:!:</span> sp&#39;) <span>&lt;-</span> go env sp ip a</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        (ip&#39;&#39; <span>:!:</span> sp&#39;&#39;) <span>&lt;-</span> go env sp&#39; ip&#39; b</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        writeByte ip&#39;&#39; <span>$</span> translateOp op</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        <span>pure</span> (ip&#39;&#39; <span>`plusPtr`</span> <span>1</span> <span>:!:</span> sp&#39;&#39; <span>-</span> <span>1</span>)</span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>      <span>Let</span> x assign body <span>-&gt;</span> <span>do</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>        (ip&#39; <span>:!:</span> sp&#39;) <span>&lt;-</span> go env sp ip assign</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>        (ip&#39;&#39; <span>:!:</span> sp&#39;&#39;) <span>&lt;-</span> go (Map.insert x sp env) sp&#39; ip&#39; body</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        writeByte ip&#39;&#39; <span>1</span> <span>-- OSwapPop</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span>pure</span> (ip&#39;&#39; <span>`plusPtr`</span> <span>1</span> <span>:!:</span> sp&#39;&#39; <span>-</span> <span>1</span>)</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>      <span>Var</span> x <span>|</span> sp <span>+</span> <span>1</span> <span>&lt;=</span> stackSize <span>-&gt;</span> <span>case</span> Map.lookup x env <span>of</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>        <span>Nothing</span> <span>-&gt;</span> throwCompileError <span>$</span> <span>&#34;Unknown variable: &#34;</span> <span>&lt;&gt;</span> <span>show</span> x</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>        <span>Just</span> varScope</span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>          <span>|</span> varScope <span>&lt;</span> stackSize <span>&amp;&amp;</span> varScope <span>&lt;</span> <span>fromIntegral</span> (<span>maxBound</span> <span>@</span><span>Word8</span>) <span>-&gt;</span> <span>do</span></span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>              writeByte ip <span>2</span> <span>-- OGet</span></span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>              writeByte (ip <span>`plusPtr`</span> <span>1</span>) <span>$</span> <span>fromIntegral</span> varScope</span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>              <span>pure</span> (ip <span>`plusPtr`</span> <span>2</span> <span>:!:</span> sp <span>+</span> <span>1</span>)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>        <span>Just</span> _ <span>-&gt;</span> throwCompileError <span>&#34;Stack overflow&#34;</span></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>      <span>Var</span> _ <span>-&gt;</span> throwCompileError <span>&#34;Stack overflow&#34;</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a><span>    writeByte ::</span> <span>Ptr</span> <span>Word8</span> <span>-&gt;</span> <span>Word8</span> <span>-&gt;</span> <span>IO</span> ()</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>    writeByte <span>!</span>ip <span>!</span>val</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>      <span>|</span> ip <span>&lt;</span> ep <span>=</span> poke ip val</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>      <span>|</span> <span>otherwise</span> <span>=</span> throwCompileError <span>$</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>          <span>&#34;Instruction index &#34;</span> <span>&lt;&gt;</span> <span>show</span> (ip <span>`minusPtr`</span> fp)</span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>            <span>&lt;&gt;</span> <span>&#34; out of bound &#34;</span> <span>&lt;&gt;</span> <span>show</span> (bytecodeSize <span>-</span> <span>1</span>)</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    translateOp <span>=</span> \<span>case</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>      <span>Add</span> <span>-&gt;</span> <span>3</span> <span>-- OAdd</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>      <span>Sub</span> <span>-&gt;</span> <span>4</span> <span>-- OSub</span></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>      <span>Mul</span> <span>-&gt;</span> <span>5</span> <span>-- OMul</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>      <span>Div</span> <span>-&gt;</span> <span>6</span> <span>-- ODiv</span></span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>    throwCompileError <span>=</span> throwIO <span>.</span> <span>Error</span> <span>Compile</span></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a><span>defaultStackSize ::</span> <span>Int</span></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>defaultStackSize <span>=</span> <span>256</span></span></code></pre></div>
<figcaption>
ArithVMLib.hs
</figcaption>
</figure>
<p>We use the <code>unsafeCreateUptoN&#39;</code> function from the <a href="https://hackage-content.haskell.org/package/bytestring/docs/Data-ByteString-Internal.html" target="_blank" rel="noopener"><code><span>Data.ByteString.Internal</span></code></a> module that allocates enough memory for the provided bytecode size, and gives us a pointer to the allocated memory. We call this pointer <code>fp</code> for <a href="https://en.wikipedia.org/wiki/frame_pointer" target="_blank" rel="noopener">frame pointer</a>. Then we traverse the <abbr title="Abstract Syntax Tree">AST</abbr> recursively, writing bytes for opcodes and arguments for each case. We use pointer arithmetic and the <a href="https://hackage.haskell.org/package/base/docs/Foreign-Storable.html#v:poke" target="_blank" rel="noopener"><code>poke</code></a> function to write the bytes. <code><span>Int16</span></code> numbers are encoded as two bytes in <a href="https://en.wikipedia.org/wiki/little_endian" target="_blank" rel="noopener">little endian</a> fashion.</p>
<p>In the recursive traversal function <code>go</code>, we pass and return the current stack pointer <code>sp</code> and instruction pointer <code>ip</code>. We update these correctly for each case<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>. We also take care of checking that the pointers stay in the right bounds, failing which we throw appropriate errors.</p>
<p>We also pass an <code>env</code> parameter that is similar to the variable names to values environment we use in the <abbr title="Abstract Syntax Tree">AST</abbr> interpreter, but this one tracks variable names to stack indices at which they reside. We update this information before compiling the body of a <code><span>Let</span></code> expression to capture the stack index of its assignment value. When compiling a <code><span>Var</span></code> expression, we use the <code>env</code> map to lookup the variable’s stack index, and encode it in the bytecode.</p>
<p>At the end of compilation, we check that the entire bytestring is filled with bytes till the very end, failing which we throw an error. This check is required because otherwise the bytestring may have garbage bytes, and may fail inexplicably during execution.</p>
<p>All the errors are thrown in the <code>IO</code> monad using the <a href="https://hackage.haskell.org/package/base/docs/Control-Exception.html#v:throwIO" target="_blank" rel="noopener"><code>throwIO</code></a> function, and are caught after compilation using the <a href="https://hackage.haskell.org/package/base/docs/Control-Exception.html#v:catch" target="_blank" rel="noopener"><code>catch</code></a> function. The final result or error is returned wrapped into <a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#error-handling"><code><span>Result</span></code></a>.</p>
<p>Let’s see it in action:</p>
<pre><code>$ echo -n &#34;1 + 2 - 3 * 4&#34; | arith-vm compile | hexdump -C
00000000  00 01 00 00 02 00 03 00  03 00 00 04 00 05 04     |...............|
0000000f</code></pre>
<pre><code>$ echo -n &#34;let x = 4 in let y = 5 in x + y&#34; | arith-vm compile | hexdump -C
00000000  00 04 00 00 05 00 02 00  02 01 03 01 01           |.............|
0000000d</code></pre>
<p>You can verify that the resultant bytes are indeed correct. I assume that it is difficult for you to read raw bytes. We’ll fix this in a minute. Meanwhile, let’s ponder upon some performance characteristics of our compiler.</p>
<h3 id="compiling-fast-and-slow">Compiling, Fast and Slow</h3>
<p>You may be wondering why I chose to write the compiler in this somewhat convoluted way of pre-allocating a bytestring and using pointers. The answer is: performance. I didn’t actually start with pointers. I iterated through many different data and control structures to find the fastest one.</p>
<p>The table below shows the compilation times for a benchmark expression file when using different data structures to implement the <code>compileIO</code> function:</p>

<p>I started with the bread-and-butter data structure of Haskellers, the humble and known to be slow <a href="https://hackage.haskell.org/package/base/docs/Data-List.html" target="_blank" rel="noopener"><code><span>List</span></code></a>, which was indeed quite slow. Next, I moved on to <a href="https://hackage.haskell.org/package/containers/docs/Data-Sequence.html#t:Seq" target="_blank" rel="noopener"><code><span>Seq</span></code></a> and thereafter <a href="https://hackage.haskell.org/package/dlist/docs/Data-DList.html#t:DList" target="_blank" rel="noopener"><code><span>DList</span></code></a>, which are known to be faster at concatenation/consing. Then I abandoned the use of intermediate data structures completely, choosing to use a bytestring <a href="https://hackage-content.haskell.org/package/bytestring/docs/Data-ByteString-Builder.html#t:Builder" target="_blank" rel="noopener"><code><span>Builder</span></code></a> to create the bytestring. Finally, I had the epiphany that the bytestring size was known at compile time, and rewrote the function to pre-allocate the bytestring, thereby reaching the fastest solution.</p>
<p>I also tried using <a href="https://hackage.haskell.org/package/primitive/docs/Data-Primitive-ByteArray.html#t:ByteArra" target="_blank" rel="noopener"><code><span>Bytearray</span></code></a>, which has more-or-less same performance of bytestring, but it is inconvenient to use because there are no functions to do IO with bytearrays. So I’d anyway need to use bytestrings for reading from STDIN or writing to STDOUT, and converting to-and-fro between bytearray and bytestring is a performance killer. Thus, I decided to stick to bytestrings.</p>
<p>The pre-allocated bytestring approach is 80 times faster than using lists, and almost 10 times faster than using <code><span>Seq</span></code>. For such gain, I’m okay with the complications it brings to the code. Here are the numbers in a chart (smaller is better):</p>
<figure>
<a href="https://abhinavsarkar.net/images/plots/pandocplot17352576262852070621.svg"><img src="https://abhinavsarkar.net/images/plots/pandocplot17352576262852070621.svg" alt="Compilation time using different data-structures"/></a>
<figcaption>Compilation time using different data-structures</figcaption>
</figure>
<p>The other important data structure used here is the map (or dictionary) in which we add the mappings from identifiers to their stack indices. This data structure needs to be performant because we do a lookup for each variable we encounter while compiling. I benchmarked compilation for some data structures:</p>

<p>Strict hashmap turns out to be the fasted one, but interestingly, linked list is a close second. Mutable hashtable is the slowest even though I expected it to be the fastest. Here are the times in a chart (smaller is better):</p>
<figure>
<a href="https://abhinavsarkar.net/images/plots/pandocplot4391142994549610502.svg"><img src="https://abhinavsarkar.net/images/plots/pandocplot4391142994549610502.svg" alt="Compilation time using different map data-structures"/></a>
<figcaption>Compilation time using different map data-structures</figcaption>
</figure>
<p>Another choice I had to make was how to write the <code>go</code> function. I ended up passing and returning pointers and environment map, and throwing errors in <code><span>IO</span></code>, but a number of solutions are possible. I tried out some of them, and noted the compilation times for the benchmark expression file:</p>

<p>I tried putting the pointer in <a href="https://hackage.haskell.org/package/base/docs/Data-IORef.html#t:IORef" target="_blank" rel="noopener"><code><span>IORef</span></code></a>s and <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-State-Strict.html#v:StateT" target="_blank" rel="noopener"><code><span>StateT</span></code></a> state instead of passing them back-and-forth. I tried putting the environment in a <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-Reader.html#t:ReaderT" target="_blank" rel="noopener"><code><span>ReaderT</span></code></a> config. I tried using <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-Except.html#t:ExceptT" target="_blank" rel="noopener"><code><span>ExceptT</span></code></a> for throwing errors instead of using IO errors. Then I tried various combinations of these monad transformers.</p>
<p>Finally, I also tried converting the <code>go</code> function to be tail-recursive by using <em><a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank" rel="noopener">Continuation-passing style</a></em> (CPS), and then <a href="https://en.wikipedia.org/wiki/Defunctionalization" target="_blank" rel="noopener">defunctionalizing</a> the continuations, as well as, using the <a href="https://hackage.haskell.org/package/mtl/docs/Control-Monad-Cont.html#t:ContT" target="_blank" rel="noopener"><code><span>ContT</span></code></a> monad transformer. All of these approaches resulted in slower code. The times are interesting to compare (smaller is better):</p>
<figure>
<a href="https://abhinavsarkar.net/images/plots/pandocplot3581979369734495442.svg"><img src="https://abhinavsarkar.net/images/plots/pandocplot3581979369734495442.svg" alt="Compilation time using different control-structures"/></a>
<figcaption>Compilation time using different control-structures</figcaption>
</figure>
<p>There is no reason to use <code><span>IORef</span></code>s here because they result in slower and uglier code. Using one monad transformer at a time results in slight slowdowns, which may be worth the improvement in the code. But using more than one of them degrades performance by a lot. Also, there is no improvement caused by <abbr title="Continuation-passing style">CPS</abbr> conversion, because <abbr title="Glasgow Haskell Compiler">GHC</abbr> is smart enough to optimize the non tail-recursive code to be faster then handwritten tail-recursive one that allocates a lot of closures (or objects in case of defunctionalization).</p>
<p>Moving on …</p>
<h2 data-track-content="" data-content-name="the-decompiler" data-content-piece="arithmetic-bytecode-vm-compiler" id="the-decompiler">The Decompiler</h2>
<p>It is a hassle to read raw bytes in the compiler output. Let’s write a decompiler to aid us in debugging and testing the compiler. First, a disassembler that converts bytes to opcodes:</p>
<figure>
<div id="cb6" data-lang="haskell"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>type</span> <span>Program</span> <span>=</span> <span>Seq</span> <span>Opcode</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span>disassemble ::</span> <span>Bytecode</span> <span>-&gt;</span> <span>Result</span> <span>Program</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>disassemble bytecode <span>=</span> go <span>0</span> Seq.empty</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span>!</span>size <span>=</span> BS.length bytecode</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    go <span>!</span>ip <span>!</span>program</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>      <span>|</span> ip <span>==</span> size <span>=</span> <span>pure</span> program</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>      <span>|</span> <span>otherwise</span> <span>=</span> <span>case</span> readInstr bytecode ip <span>of</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>          <span>0</span> <span>|</span> ip <span>+</span> <span>2</span> <span>&lt;</span> size <span>-&gt;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            go (ip <span>+</span> <span>3</span>) <span>$</span> program <span>|&gt;</span> <span>OPush</span> (readInstrArgInt16 bytecode ip)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>          <span>0</span> <span>-&gt;</span> throwIPOOBError <span>$</span> ip <span>+</span> <span>2</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>          <span>1</span> <span>-&gt;</span> go (ip <span>+</span> <span>1</span>) <span>$</span> program <span>|&gt;</span> <span>OSwapPop</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>          <span>2</span> <span>|</span> ip <span>+</span> <span>1</span> <span>&lt;</span> size <span>-&gt;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            go (ip <span>+</span> <span>2</span>) <span>$</span> program <span>|&gt;</span> <span>OGet</span> (readInstrArgWord8 bytecode ip)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>          <span>2</span> <span>-&gt;</span> throwIPOOBError <span>$</span> ip <span>+</span> <span>1</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>          <span>3</span> <span>-&gt;</span> go (ip <span>+</span> <span>1</span>) <span>$</span> program <span>|&gt;</span> <span>OAdd</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>          <span>4</span> <span>-&gt;</span> go (ip <span>+</span> <span>1</span>) <span>$</span> program <span>|&gt;</span> <span>OSub</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>          <span>5</span> <span>-&gt;</span> go (ip <span>+</span> <span>1</span>) <span>$</span> program <span>|&gt;</span> <span>OMul</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>          <span>6</span> <span>-&gt;</span> go (ip <span>+</span> <span>1</span>) <span>$</span> program <span>|&gt;</span> <span>ODiv</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>          n <span>-&gt;</span> throwDisassembleError <span>$</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            <span>&#34;Invalid bytecode: &#34;</span> <span>&lt;&gt;</span> <span>show</span> n <span>&lt;&gt;</span> <span>&#34; at: &#34;</span> <span>&lt;&gt;</span> <span>show</span> ip</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    throwIPOOBError ip <span>=</span> throwDisassembleError <span>$</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>      <span>&#34;Instruction index &#34;</span> <span>&lt;&gt;</span> <span>show</span> ip <span>&lt;&gt;</span> <span>&#34; out of bound &#34;</span> <span>&lt;&gt;</span> <span>show</span> (size <span>-</span> <span>1</span>)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    throwDisassembleError <span>=</span> throwError <span>.</span> <span>Error</span> <span>Disassemble</span></span></code></pre></div>
<figcaption>
ArithVMLib.hs
</figcaption>
</figure>
<p>A disassembled program is a sequence of opcodes. We simply go over each byte of the bytecode, and append the right opcode for it to the program, along with any parameters it may have. Note that we do not verify that the disassembled program is correct.</p>
<p>Here are the helpers that read instruction bytes and their arguments from a bytestring:</p>
<figure>
<div id="cb7" data-lang="haskell"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>readInstr ::</span> <span>BS.ByteString</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Word8</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>readInstr <span>=</span> BS.unsafeIndex</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>{-# INLINE readInstr #-}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span>readInstrArgWord8 ::</span> <span>BS.ByteString</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Word8</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>readInstrArgWord8 bytecode ip <span>=</span> readInstr bytecode (ip <span>+</span> <span>1</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span>{-# INLINE readInstrArgWord8 #-}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span>readInstrArgInt16 ::</span> <span>BS.ByteString</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Int16</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>readInstrArgInt16 bytecode ip <span>=</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span>let</span> lb <span>=</span> readInstr bytecode (ip <span>+</span> <span>1</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>      mb <span>=</span> readInstr bytecode (ip <span>+</span> <span>2</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span>      b1 ::</span> <span>Word16</span> <span>=</span> <span>fromIntegral</span> lb</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>      b2 <span>=</span> <span>fromIntegral</span> mb <span>`shiftL`</span> <span>8</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>   <span>in</span> <span>fromIntegral</span> (b1 <span>.|.</span> b2)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span>{-# INLINE readInstrArgInt16 #-}</span></span></code></pre></div>
<figcaption>
ArithVMLib.hs
</figcaption>
</figure>
<p>Next, we decompile the opcodes to an expression:</p>
<figure>
<div id="cb8" data-lang="haskell"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>decompile ::</span> <span>Program</span> <span>-&gt;</span> <span>Result</span> <span>Expr</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>decompile program <span>=</span> <span>do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  stack <span>&lt;-</span> go Seq.empty program</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  checkStack <span>Decompile</span> <span>maxBound</span> <span>$</span> <span>length</span> stack</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span>let</span> ast <span>:&lt;|</span> _ <span>=</span> stack</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span>pure</span> ast</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    go stack <span>=</span> \<span>case</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>      <span>Seq.Empty</span> <span>-&gt;</span> <span>pure</span> stack</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      opcode <span>:&lt;|</span> rest <span>-&gt;</span> <span>case</span> opcode <span>of</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span>OPush</span> n <span>-&gt;</span> go (stack <span>|&gt;</span> <span>Num</span> n) rest</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span>OAdd</span> <span>-&gt;</span> decompileBinOp <span>Add</span> <span>&gt;&gt;=</span> <span>flip</span> go rest</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span>OSub</span> <span>-&gt;</span> decompileBinOp <span>Sub</span> <span>&gt;&gt;=</span> <span>flip</span> go rest</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span>OMul</span> <span>-&gt;</span> decompileBinOp <span>Mul</span> <span>&gt;&gt;=</span> <span>flip</span> go rest</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span>ODiv</span> <span>-&gt;</span> decompileBinOp <span>Div</span> <span>&gt;&gt;=</span> <span>flip</span> go rest</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span>OGet</span> i <span>-&gt;</span> go (stack <span>|&gt;</span> <span>Var</span> (mkIdent <span>$</span> mkName <span>$</span> <span>fromIntegral</span> i)) rest</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span>OSwapPop</span> <span>-&gt;</span> decompileLet <span>&gt;&gt;=</span> <span>flip</span> go rest</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>      <span>where</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        decompileBinOp op <span>=</span> <span>case</span> stack <span>of</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>          stack&#39; <span>:|&gt;</span> a <span>:|&gt;</span> b <span>-&gt;</span> <span>pure</span> <span>$</span> stack&#39; <span>|&gt;</span> <span>BinOp</span> op a b</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>          _ <span>-&gt;</span> throwDecompileError <span>$</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            <span>&#34;Not enough elements to decompile binary operation: &#34;</span> <span>&lt;&gt;</span> <span>show</span> op</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        decompileLet <span>=</span> <span>case</span> stack <span>of</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>          stack&#39; <span>:|&gt;</span> a <span>:|&gt;</span> b <span>-&gt;</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            <span>pure</span> <span>$</span> stack&#39; <span>|&gt;</span> <span>Let</span> (mkIdent <span>$</span> mkName <span>$</span> <span>length</span> stack <span>-</span> <span>2</span>) a b</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>          _ <span>-&gt;</span> throwDecompileError <span>&#34;Not enough elements to decompile let&#34;</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    mkName i <span>=</span> names <span>`Seq.index`</span> i</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    names <span>=</span> Seq.fromList <span>$</span> <span>tail</span> <span>$</span> combinations <span>2</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    combinations <span>=</span> \<span>case</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>      <span>0</span> <span>-&gt;</span> [<span>&#34;&#34;</span>]</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>      n <span>-&gt;</span> <span>let</span> prev <span>=</span> combinations (n <span>-</span> <span>1</span>)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>        <span>in</span> prev <span>&lt;&gt;</span> [x <span>:</span> xs <span>|</span> x <span>&lt;-</span> [<span>&#39;a&#39;</span> <span>..</span> <span>&#39;z&#39;</span>], xs <span>&lt;-</span> prev]</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>    throwDecompileError <span>=</span> throwError <span>.</span> <span>Error</span> <span>Decompile</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span>checkStack ::</span> (<span>MonadError</span> <span>Error</span> m) <span>=&gt;</span> <span>Pass</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> <span>Int</span> <span>-&gt;</span> m ()</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>checkStack pass stackSize <span>=</span> \<span>case</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>  <span>1</span> <span>-&gt;</span> <span>pure</span> ()</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>  <span>0</span> <span>-&gt;</span> throwError <span>$</span> <span>Error</span> pass <span>&#34;Final stack has no elements&#34;</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>  n <span>|</span> n <span>&gt;</span> stackSize <span>-&gt;</span> throwError <span>.</span> <span>Error</span> pass <span>$</span> <span>&#34;Stack overflow&#34;</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>  n <span>|</span> n <span>&gt;</span> <span>1</span> <span>-&gt;</span> throwError <span>.</span> <span>Error</span> pass <span>$</span> <span>&#34;Final stack has more than one element&#34;</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>  _ <span>-&gt;</span> throwError <span>.</span> <span>Error</span> pass <span>$</span> <span>&#34;Stack underflow&#34;</span></span></code></pre></div>
<figcaption>
ArithVMLib.hs
</figcaption>
</figure>
<p>Decompilation is the opposite of compilation. While compiling there is an implicit stack of expressions that are yet to be compiled. We make that stack explicit here, capturing expressions as they are decompiled from opcodes. For compound expressions, we inspect the stack and use the already decompiled expressions as the operands of the expression being decompiled. This way we build up larger expressions from smaller ones, culminating in the single top-level expression at the end. Finally, we check the stack to make sure that there is only one expression left in it. Note that like the disassembler, we do not verify that the decompiled expression is correct.</p>
<p>There is one tricky thing in decompilation: we lose the names of the variables when compiling, and are left with only stack indices. So while decompiling, we generate variable names from their stack indices by indexing a list of unique names. Let’s see it in action:</p>
<pre><code>$ echo -n &#34;1 + 2 - 3 * 4&#34; | arith-vm compile | arith-vm disassemble
OPush 1
OPush 2
OAdd
OPush 3
OPush 4
OMul
OSub

$ echo -n &#34;1 + 2 - 3 * 4&#34; | arith-vm compile | arith-vm decompile
( ( 1 + 2 ) - ( 3 * 4 ) )

$ echo -n &#34;let x = 4 in let y = 5 in x + y&#34; | arith-vm compile | arith-vm disassemble
OPush 4
OPush 5
OGet 0
OGet 1
OAdd
OSwapPop
OSwapPop

$ echo -n &#34;let x = 4 in let y = 5 in x + y&#34; | arith-vm compile | arith-vm decompile
( let a = 4 in ( let b = 5 in ( a + b ) ) )</code></pre>
<p>That’s all for compilation and decompilation. Now, we use them together to make sure that everything works.</p>
<h2 data-track-content="" data-content-name="testing-the-compiler" data-content-piece="arithmetic-bytecode-vm-compiler" id="testing-the-compiler">Testing the Compiler</h2>
<p>We write some unit tests for the compiler, targeting both success and failure cases:</p>
<figure>
<div id="cb10" data-lang="haskell"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>compilerSpec ::</span> <span>Spec</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>compilerSpec <span>=</span> describe <span>&#34;Compiler&#34;</span> <span>$</span> <span>do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  forM_ compilerSuccessTests <span>$</span> \(input, result) <span>-&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    it (<span>&#34;compiles: \&#34;&#34;</span> <span>&lt;&gt;</span> BSC.unpack input <span>&lt;&gt;</span> <span>&#34;\&#34;&#34;</span>) <span>$</span> <span>do</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>      parseCompile input <span>`shouldBe`</span> <span>Right</span> (Seq.fromList result)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  forM_ compilerErrorTests <span>$</span> \(input, err) <span>-&gt;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    it (<span>&#34;fails for: \&#34;&#34;</span> <span>&lt;&gt;</span> BSC.unpack input <span>&lt;&gt;</span> <span>&#34;\&#34;&#34;</span>) <span>$</span> <span>do</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>      parseCompile input <span>`shouldSatisfy`</span> \<span>case</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span>Left</span> (<span>Error</span> <span>Compile</span> msg) <span>|</span> err <span>==</span> msg <span>-&gt;</span> <span>True</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        _ <span>-&gt;</span> <span>False</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>  it <span>&#34;fails for greater sized expr&#34;</span> <span>$</span> <span>do</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    compile (<span>Num</span> <span>1</span>, <span>4</span>) <span>`shouldSatisfy`</span> \<span>case</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>      <span>Left</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        ( <span>Error</span> <span>Compile</span> <span>&#34;Compiled bytecode size 3 is not same as expected size: 4&#34;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        ) <span>-&gt;</span> <span>True</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>      _ <span>-&gt;</span> <span>False</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>  it <span>&#34;fails for lesser sized expr&#34;</span> <span>$</span> <span>do</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    compile (<span>Num</span> <span>1</span>, <span>2</span>) <span>`shouldSatisfy`</span> \<span>case</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>      <span>Left</span> (<span>Error</span> <span>Compile</span> <span>&#34;Instruction index 2 out of bound 1&#34;</span>) <span>-&gt;</span> <span>True</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>      _ <span>-&gt;</span> <span>False</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>  <span>where</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    parseCompile <span>=</span> parseSized <span>&gt;=&gt;</span> compile&#39; <span>4</span> <span>&gt;=&gt;</span> disassemble</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span>compilerSuccessTests ::</span> [(<span>BSC.ByteString</span>, [<span>Opcode</span>])]</span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>compilerSuccessTests <span>=</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>  [ ( <span>&#34;1&#34;</span>,</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>      [<span>OPush</span> <span>1</span>]</span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;1 + 2 - 3 * 4 + 5 / 6 / 1 + 1&#34;</span>,</span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>      [ <span>OPush</span> <span>1</span>, <span>OPush</span> <span>2</span>, <span>OAdd</span>, <span>OPush</span> <span>3</span>, <span>OPush</span> <span>4</span>, <span>OMul</span>, <span>OSub</span>, <span>OPush</span> <span>5</span>, <span>OPush</span> <span>6</span>,</span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>        <span>ODiv</span>, <span>OPush</span> <span>1</span>, <span>ODiv</span>, <span>OAdd</span>, <span>OPush</span> <span>1</span>, <span>OAdd</span> ]</span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;1 + (2 - 3) * 4 + 5 / 6 / (1 + 1)&#34;</span>,</span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>      [ <span>OPush</span> <span>1</span>, <span>OPush</span> <span>2</span>, <span>OPush</span> <span>3</span>, <span>OSub</span>, <span>OPush</span> <span>4</span>, <span>OMul</span>, <span>OAdd</span>, <span>OPush</span> <span>5</span>, <span>OPush</span> <span>6</span>,</span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>        <span>ODiv</span>, <span>OPush</span> <span>1</span>, <span>OPush</span> <span>1</span>, <span>OAdd</span>, <span>ODiv</span>, <span>OAdd</span> ]</span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;let x = 4 in x + 1&#34;</span>,</span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>      [<span>OPush</span> <span>4</span>, <span>OGet</span> <span>0</span>, <span>OPush</span> <span>1</span>, <span>OAdd</span>, <span>OSwapPop</span>]</span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;let x = 4 in let y = 5 in x + y&#34;</span>,</span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>      [<span>OPush</span> <span>4</span>, <span>OPush</span> <span>5</span>, <span>OGet</span> <span>0</span>, <span>OGet</span> <span>1</span>, <span>OAdd</span>, <span>OSwapPop</span>, <span>OSwapPop</span>]</span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;let x = 4 in let x = x + 1 in x + 2&#34;</span>,</span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>      [<span>OPush</span> <span>4</span>, <span>OGet</span> <span>0</span>, <span>OPush</span> <span>1</span>, <span>OAdd</span>, <span>OGet</span> <span>1</span>, <span>OPush</span> <span>2</span>, <span>OAdd</span>, <span>OSwapPop</span>, <span>OSwapPop</span>]</span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;let x = let y = 3 in y + y in x * 3&#34;</span>,</span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>      [ <span>OPush</span> <span>3</span>, <span>OGet</span> <span>0</span>, <span>OGet</span> <span>0</span>, <span>OAdd</span>, <span>OSwapPop</span>, <span>OGet</span> <span>0</span>, <span>OPush</span> <span>3</span>, <span>OMul</span>, <span>OSwapPop</span> ]</span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>    ( <span>&#34;let x = let y = 1 + let z = 2 in z * z in y + 1 in x * 3&#34;</span>,</span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a>      [ <span>OPush</span> <span>1</span>, <span>OPush</span> <span>2</span>, <span>OGet</span> <span>1</span>, <span>OGet</span> <span>1</span>, <span>OMul</span>, <span>OSwapPop</span>, <span>OAdd</span>, <span>OGet</span> <span>0</span>, <span>OPush</span> <span>1</span>,</span>
<span id="cb10-54"><a href="#cb10-54" aria-hidden="true" tabindex="-1"></a>        <span>OAdd</span>, <span>OSwapPop</span>, <span>OGet</span> <span>0</span>, <span>OPush</span> <span>3</span>, <span>OMul</span>, <span>OSwapPop</span> ]</span>
<span id="cb10-55"><a href="#cb10-55" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb10-56"><a href="#cb10-56" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;1/0&#34;</span>, [<span>OPush</span> <span>1</span>, <span>OPush</span> <span>0</span>, <span>ODiv</span>]),</span>
<span id="cb10-57"><a href="#cb10-57" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;-32768 / -1&#34;</span>, [<span>OPush</span> (<span>-</span><span>32768</span>), <span>OPush</span> (<span>-</span><span>1</span>), <span>ODiv</span>])</span>
<span id="cb10-58"><a href="#cb10-58" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb10-59"><a href="#cb10-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-60"><a href="#cb10-60" aria-hidden="true" tabindex="-1"></a><span>compilerErrorTests ::</span> [(<span>BSC.ByteString</span>, <span>String</span>)]</span>
<span id="cb10-61"><a href="#cb10-61" aria-hidden="true" tabindex="-1"></a>compilerErrorTests <span>=</span></span>
<span id="cb10-62"><a href="#cb10-62" aria-hidden="true" tabindex="-1"></a>  [ (<span>&#34;x&#34;</span>, <span>&#34;Unknown variable: x&#34;</span>),</span>
<span id="cb10-63"><a href="#cb10-63" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;let x = 4 in y + 1&#34;</span>, <span>&#34;Unknown variable: y&#34;</span>),</span>
<span id="cb10-64"><a href="#cb10-64" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;let x = y + 1 in x&#34;</span>, <span>&#34;Unknown variable: y&#34;</span>),</span>
<span id="cb10-65"><a href="#cb10-65" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;let x = x + 1 in x&#34;</span>, <span>&#34;Unknown variable: x&#34;</span>),</span>
<span id="cb10-66"><a href="#cb10-66" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;let x = 4 in let y = 1 in let z = 2 in y + x&#34;</span>, <span>&#34;Stack overflow&#34;</span>),</span>
<span id="cb10-67"><a href="#cb10-67" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;let x = 4 in let y = 5 in x + let z = y in z * z&#34;</span>, <span>&#34;Stack overflow&#34;</span>),</span>
<span id="cb10-68"><a href="#cb10-68" aria-hidden="true" tabindex="-1"></a>    (<span>&#34;let a = 0 in let b = 0 in let c = 0 in let d = 0 in d&#34;</span>, <span>&#34;Stack overflow&#34;</span>)</span>
<span id="cb10-69"><a href="#cb10-69" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<figcaption>
ArithVMSpec.hs
</figcaption>
</figure>
<p>In each test, we parse and compile an expression, and then disassemble the compiled bytes, which we match with expected list of opcodes, or an error message.</p>
<p>Let’s put these tests with the parser tests, and run them:</p>
<figure>
<div id="cb11" data-lang="haskell"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>main ::</span> <span>IO</span> ()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>main <span>=</span> hspec <span>$</span> <span>do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  parserSpec</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  astInterpreterSpec</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  compilerSpec</span></code></pre></div>
<figcaption>
ArithVMSpec.hs
</figcaption>
</figure>
<details>
<summary>
Output of the test run
</summary>
<pre><code>$ cabal test -O2
Running 1 test suites...
Test suite specs: RUNNING...

Parser
  parses: &#34;1 + 2 - 3 * 4 + 5 / 6 / 0 + 1&#34; [✔]
  parses: &#34;1+2-3*4+5/6/0+1&#34; [✔]
  parses: &#34;1 + -1&#34; [✔]
  parses: &#34;let x = 4 in x + 1&#34; [✔]
  parses: &#34;let x=4in x+1&#34; [✔]
  parses: &#34;let x = 4 in let y = 5 in x + y&#34; [✔]
  parses: &#34;let x = 4 in let y = 5 in x + let z = y in z * z&#34; [✔]
  parses: &#34;let x = 4 in (let y = 5 in x + 1) + let z = 2 in z * z&#34; [✔]
  parses: &#34;let x=4in 2+let y=x-5in x+let z=y+1in z/2&#34; [✔]
  parses: &#34;let x = (let y = 3 in y + y) in x * 3&#34; [✔]
  parses: &#34;let x = let y = 3 in y + y in x * 3&#34; [✔]
  parses: &#34;let x = let y = 1 + let z = 2 in z * z in y + 1 in x * 3&#34; [✔]
  fails for: &#34;&#34; [✔]
  fails for: &#34;1 +&#34; [✔]
  fails for: &#34;1 &amp; 1&#34; [✔]
  fails for: &#34;1 + 1 &amp; 1&#34; [✔]
  fails for: &#34;1 &amp; 1 + 1&#34; [✔]
  fails for: &#34;(&#34; [✔]
  fails for: &#34;(1&#34; [✔]
  fails for: &#34;(1 + &#34; [✔]
  fails for: &#34;(1 + 2&#34; [✔]
  fails for: &#34;(1 + 2}&#34; [✔]
  fails for: &#34;66666&#34; [✔]
  fails for: &#34;-x&#34; [✔]
  fails for: &#34;let 1&#34; [✔]
  fails for: &#34;let x = 1 in &#34; [✔]
  fails for: &#34;let let = 1 in 1&#34; [✔]
  fails for: &#34;let x = 1 in in&#34; [✔]
  fails for: &#34;let x=1 inx&#34; [✔]
  fails for: &#34;letx = 1 in x&#34; [✔]
  fails for: &#34;let x ~ 1 in x&#34; [✔]
  fails for: &#34;let x = 1 &amp; 2 in x&#34; [✔]
  fails for: &#34;let x = 1 inx&#34; [✔]
  fails for: &#34;let x = 1 in x +&#34; [✔]
  fails for: &#34;let x = 1 in x in&#34; [✔]
  fails for: &#34;let x = let x = 1 in x&#34; [✔]
AST interpreter
  interprets: &#34;1&#34; [✔]
  interprets: &#34;1 + 2 - 3 * 4 + 5 / 6 / 1 + 1&#34; [✔]
  interprets: &#34;1 + (2 - 3) * 4 + 5 / 6 / (1 + 1)&#34; [✔]
  interprets: &#34;1 + -1&#34; [✔]
  interprets: &#34;1 * -1&#34; [✔]
  interprets: &#34;let x = 4 in x + 1&#34; [✔]
  interprets: &#34;let x = 4 in let x = x + 1 in x + 2&#34; [✔]
  interprets: &#34;let x = 4 in let y = 5 in x + y&#34; [✔]
  interprets: &#34;let x = 4 in let y = 5 in x + let z = y in z * z&#34; [✔]
  interprets: &#34;let x = 4 in (let y = 5 in x + y) + let z = 2 in z * z&#34; [✔]
  interprets: &#34;let x = let y = 3 in y + y in x * 3&#34; [✔]
  interprets: &#34;let x = let y = 1 + let z = 2 in z * z in y + 1 in x * 3&#34; [✔]
  fails for: &#34;x&#34; [✔]
  fails for: &#34;let x = 4 in y + 1&#34; [✔]
  fails for: &#34;let x = y + 1 in x&#34; [✔]
  fails for: &#34;let x = x + 1 in x&#34; [✔]
  fails for: &#34;1/0&#34; [✔]
  fails for: &#34;-32768 / -1&#34; [✔]
Compiler
  compiles: &#34;1&#34; [✔]
  compiles: &#34;1 + 2 - 3 * 4 + 5 / 6 / 1 + 1&#34; [✔]
  compiles: &#34;1 + (2 - 3) * 4 + 5 / 6 / (1 + 1)&#34; [✔]
  compiles: &#34;let x = 4 in x + 1&#34; [✔]
  compiles: &#34;let x = 4 in let y = 5 in x + y&#34; [✔]
  compiles: &#34;let x = 4 in let x = x + 1 in x + 2&#34; [✔]
  compiles: &#34;let x = let y = 3 in y + y in x * 3&#34; [✔]
  compiles: &#34;let x = let y = 1 + let z = 2 in z * z in y + 1 in x * 3&#34; [✔]
  compiles: &#34;1/0&#34; [✔]
  compiles: &#34;-32768 / -1&#34; [✔]
  fails for: &#34;x&#34; [✔]
  fails for: &#34;let x = 4 in y + 1&#34; [✔]
  fails for: &#34;let x = y + 1 in x&#34; [✔]
  fails for: &#34;let x = x + 1 in x&#34; [✔]
  fails for: &#34;let x = 4 in let y = 1 in let z = 2 in y + x&#34; [✔]
  fails for: &#34;let x = 4 in let y = 5 in x + let z = y in z * z&#34; [✔]
  fails for: &#34;let a = 0 in let b = 0 in let c = 0 in let d = 0 in d&#34; [✔]
  fails for greater sized expr [✔]
  fails for lesser sized expr [✔]

Finished in 0.0147 seconds
73 examples, 0 failures
Test suite specs: PASS</code></pre>
</details>
<p>Awesome, it works! That’s it for this post. Let’s update our checklist:</p>
<ul>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#parsing-expressions">Parsing arithmetic expressions to Abstract Syntax Trees (ASTs).</a></label></li>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#testing-the-parser">Unit testing for our parser.</a></label></li>
<li><label><a href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-parser/#the-ast-interpreter">Interpreting ASTs.</a></label></li>
<li><label><a href="#the-compiler">Compiling ASTs to bytecode.</a></label></li>
<li><label><a href="#the-decompiler">Disassembling and decompiling bytecode.</a></label></li>
<li><label><a href="#testing-the-compiler">Unit testing for our compiler.</a></label></li>
<li><label>Property-based testing for our compiler.</label></li>
<li><label>Efficiently executing bytecode in a virtual machine (VM).</label></li>
<li><label>Unit testing and property-based testing for our <abbr title="Virtual Machine">VM</abbr>.</label></li>
<li><label>Benchmarking our code to see how the different passes perform.</label></li>
<li><label>All the while keeping an eye on performance.</label></li>
</ul>
<p>In the next part, we write a virtual machine that runs our compiled bytecode, and do some benchmarking.</p>
<p>
If you have any questions or comments, please leave a comment below. If you liked this post, please share it. Thanks for reading!
</p>

  </section>
  <section id="syndications">
    
<h3>Like, repost, or comment</h3>
    <ul>
    <li><a href="https://fantastic.earth/@abnv/115083735766872552" rel="syndication" target="_blank">Fediverse</a></li>
    <li><a href="https://lobste.rs/s/q7fels" rel="syndication" target="_blank">Lobsters</a></li>
    <li><a href="https://www.reddit.com/r/haskell/comments/1myu96l/" rel="syndication" target="_blank">Reddit</a></li>
    <li><a href="https://discourse.haskell.org/t//12816" rel="syndication" target="_blank">Discourse</a></li>
    <li><a href="#comment-container">Comments below</a></li>
    </ul>
    
    <p id="webmention-form">
      <h3>Send a Webmention for this post</h3>
      
    </p>
  </section>
  <section>
    Posted by 
    at <a itemprop="url" content="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-compiler/" href="https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-compiler/">https://abhinavsarkar.net/posts/arithmetic-bytecode-vm-compiler/</a>
  </section>
</article><p>
  <h3>Like this post? Subscribe to get future posts by email.</h3>

</p></div>
  </body>
</html>
