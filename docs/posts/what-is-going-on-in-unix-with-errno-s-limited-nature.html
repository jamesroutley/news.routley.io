<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ErrnoWhySoLimited">Original</a>
    <h1>What is going on in Unix with errno&#39;s limited nature</h1>
    
    <div id="readability-page-1" class="page"><div><h2>What is going on in Unix with errno&#39;s limited nature</h2>

	<p><small>July  3, 2025</small></p>
</div><div><p>If you read manual pages, such as Linux&#39;s <a href="https://www.man7.org/linux/man-pages/man3/errno.3.html">errno(3)</a>, you&#39;ll
soon discover an important and peculiar seeming limitation of
looking at errno. To quote the Linux version:</p>

<blockquote><p><strong>The value in errno is significant only when the return value of the
call indicated an error</strong> (i.e., -1 from most system calls; -1 or NULL
from most library functions); a function that succeeds is allowed to
change errno. The value of errno is never set to zero by any system
call or library function.</p>
</blockquote>

<p>This is also more or less what POSIX says in <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/errno.html">errno</a>,
although in standards language that&#39;s less clear. All of this is a sign
of what has traditionally been going on behind the scenes in Unix.</p>

<p>The classical Unix approach to kernel system calls doesn&#39;t return
multiple values, for example the regular return value and errno.
Instead, Unix kernels have traditionally returned either a success
value or the errno value along with an indication of failure, telling
them apart in various ways (such as <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ErrnoGoodBad">the PDP-11 return method</a>). At the C library level, the simple approach taken
in early Unix was that system call wrappers only bothered to set
the C level <code>errno</code> if the kernel signaled an error. See, for
example, the V7 <a href="https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/libc/crt/cerror.s">libc/crt/cerror.s</a>
combined with <a href="https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/libc/sys/dup.s">libc/sys/dup.s</a>,
where the dup() wrapper only jumps to <code>cerror</code> and sets <code>errno</code> if
the kernel signals an error. The system call wrappers could all
have explicitly set <code>errno</code> to 0 on success, but they didn&#39;t.</p>

<p>The next issue is that various C library calls may make a number
of system calls themselves, some of which may fail without the
library call itself failing. The classical case is stdio checking
to see whether stdout is connected to a terminal and so should be
line buffered, which was traditionally implemented by trying to do
a terminal-only ioctl() to the file descriptors, which would fail
with ENOTTY on non-terminal file descriptors. Even if stdio did a
successful write() rather than only buffering your output, the
write() system call wrapper wouldn&#39;t change the existing ENOTTY
<code>errno</code> value from the failed ioctl(). So you can have a fwrite()
(or printf() or puts() or other stdio call) that succeeds while
&#39;setting&#39; <code>errno</code> to some value such as ENOTTY.</p>

<p>When ANSI C and POSIX came along, they inherited this existing
situation and there wasn&#39;t much they could do about it (<a href="https://utcc.utoronto.ca/~cks/space/blog/unix/CloseEINTR">POSIX
was mostly documenting existing practice</a>). I believe
that they also wanted to allow a situation where POSIX functions
were implemented on top of whatever oddball system calls you wanted
to have your library code do, even if they set <code>errno</code>. So the only
thing POSIX could really require was the traditional Unix behavior
that if something failed and it was documented to set errno on
failure, you could then look at <code>errno</code> and have it be meaningful.</p>

<p>(This was what existing Unixes were already mostly doing and
specifying it put minimal constraints on any new POSIX environments,
including POSIX environments on top of other operating systems.)</p>

<p>(This elaborates on <a href="https://mastodon.social/@cks/114739240491982347">a Fediverse post of mine</a>, and <a href="https://utcc.utoronto.ca/~cks/space/blog/programming/GoCgoErrorReturns">you can
run into this in non-C languages that have true multi-value returns
under the right circumstances</a>.)</p>
</div></div>
  </body>
</html>
