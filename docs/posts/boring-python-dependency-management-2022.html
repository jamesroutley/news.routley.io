<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.b-list.org/weblog/2022/may/13/boring-python-dependencies/">Original</a>
    <h1>Boring Python: dependency management (2022)</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
    <!-- These classes are used by the Bootstrap CSS framework to control layout. -->
    <div>
      




<!--
 If this entry is assigned to one or more categories, they'll appear
 in links in the paragraph below. Each of those links uses
 rel="category" to indicate it's a link to a category.

 See http://microformats.org/wiki/rel-category for details.
-->
<p>Published: <a href="https://www.b-list.org/weblog/2022/may/13/">May 13, 2022</a>. Filed under:
<a rel="category" href="https://www.b-list.org/weblog/categories/django/">Django</a>, <a rel="category" href="https://www.b-list.org/weblog/categories/python/">Python</a>.
  
</p><p>This is the first in hopefully a series of posts I intend to write about how to build/manage/deploy/etc. Python applications in as boring a way as possible. So before I go any further, I want to be absolutely clear on what I mean by “boring”: I don’t mean “reliable” or “bug-free” or “no incidents”. While there is some overlap, and some of the things I’ll be recommending can help to reduce bugs, I also want to be clear: there will be bugs. There will be incidents where a feature or maybe an entire service is down. “Boring”, to me, is about the <em>sources</em> of those incidents. It’s difficult enough to manage your own code and the bugs and other problems that will inevitably pop up in it from time to time; you don’t want to compound that by having bugs or other surprises coming from the tools and processes you use to build, manage, and deploy it. So when I call something “boring”, I mean it’s unlikely to add another source of bugs and nasty surprises that cause a pager to go off at <span>2AM</span>; the pager <em>will</em>, of course, eventually go off at <span>2AM</span>, but when it does you’ll be able to feel reasonably confident (if that’s the right word for such a situation) that the source of it was something in your own code that you can diagnose and fix.</p>
<p>And so I’m planning several posts exploring different aspects of making Python development boring (in this sense). But for this first installment, I’ll be talking about one of the internet’s favorite topics: managing dependencies.</p>
<p>If you’re just interested in the end result, the process I recommend is pretty simple and can be found in the section titled “putting it all together”. The rest of this post exists to explain, in as much detail as I can manage, all the things going on behind those simple-looking recommendations, and why I make those specific recommendations.</p>
<h2>A quick introduction to Python packaging</h2>
<p><a href="https://www.b-list.org/weblog/2020/jan/05/packaging/">I’ve written about this before</a>, but to make sure this is clear I want to do a quick refresher.</p>
<p>As I see it, there are three basic aspects to “packaging”, and one of the difficult things about “packaging” discussions is lack of clarity around which are being discussed. They are:</p>
<ol>
<li>Given some working code, define and produce from it a distributable artifact.</li>
<li>Given that someone has produced a distributable artifact, use it to cause the corresponding code to appear, in working form, somewhere else.</li>
<li>Given the existence of potentially many separate projects or versions of projects with their own independent and potentially-conflicting sets of dependencies, make it possible to work on and run more than one at a time.</li>
</ol>
<p>Python’s packaging ecosystem has default tools for each of these. In order, they are: (1) setuptools, (2) pip, (3) virtual environments. These three tools are your foundation, and for truly “boring” Python development work, I would argue that you should stick to them almost exclusively.</p>
<p>I know there are other tools out there, and more being developed. Most of the perceived change and churn in “Python packaging” is around tools that try to provide a single interface for all three of the aspects I’ve listed above. I don’t personally use or recommend any such tool because, again, my goal is <em>boring</em> — I want to worry as little as possible about this stuff once I’ve initially set it up, and that mostly means not being an early adopter. The three core default tools I’ve mentioned have all been around and stable for a long time, in software terms, at least — they’re all over a decade old, and their end-user interfaces evolve <em>incredibly</em> slowly, when they evolve at all. They’re reliable. They’re well-understood. That’s exactly what I want and exactly what I recommend.</p>
<p>Now, maybe you’ll read this and decide to use something else. Or maybe you’ll take my advice and start out with the default tooling, and then later on decide to change. But even if you do end up thinking something else is the best choice for your team/project, I think you will benefit greatly from at least trying out the default tools and understanding how to use them for their respective aspects of packaging.</p>
<p>Also, I should note here that my use case for Python is deploying networked (primarily web) services, on servers. If you primarily use Python for, say, machine learning or data science, you are likely to already be a happy user of a completely different world of tools (such as Anaconda and notebooks). Please continue using them! They suit your use case really well, and replacing them with my preferred workflow would be a regression for you.</p>
<p>Now, let’s get started.</p>
<h2>Requirements</h2>
<p>The eventual goal is to invoke <code>pip install</code> to, well, do what it says: install a bunch of Python packages. But how to tell <code>pip</code> <em>which</em> packages to install? There are a couple of options:</p>
<ul>
<li>Passing a list of package names on the command line: <code>pip install package1 package2 …</code></li>
<li>Passing a file containing a list of package names: <code>pip install -r filename</code></li>
</ul>
<p>The second option is generally referred to as a “requirements file”, and by convention when you’re using only one such file, it’s named <code>requirements.txt</code>. I’m going to recommend a multi-file setup, though, so we’ll hold off on naming for now.</p>
<p>It’s also worth being clear on the purpose of a requirements file: it’s to take a particular environment you already have, and reproduce it somewhere else. Which means that a requirements file typically should list <em>all</em> packages to install and <em>exact versions</em> to install. This is different from the dependency declarations of individual distributable packages (the <code>dependencies</code> section of a <code>pyproject.toml</code> packaging config file), which generally specify broad ranges that the package is tested against and compatible with, and only direct dependencies.</p>
<p>If you’re deploying services written in Python, you <em>can</em> build them as distributable packages. I just don’t recommend it, for a few reasons:</p>
<ul>
<li>The convenience of distributable packages is that you can re-use them across multiple projects/services/etc. For example, you might have an auth setup you want to use in all your services, and build it as a package that can be installed by those services. When the thing you’re deploying <em>is</em> the service, this is much less important.</li>
<li>It’s overwhelmingly likely, here in 2022, that your deployment will consist of building some type of container and then pushing it to some type of container runtime/orchestration system, and that the manifest which defines that container will be version-controlled along with the service’s code. In which case it doesn’t make much sense to build a package from the code and then pull it into the container to be installed; just copy the source tree into the container, rather than adding extra steps for no benefit.</li>
<li>Copying the source tree as-is into your container avoids some potential issues, primarily around imports: a common error made by people building packages for the first time is relying — often without realizing it! — on the fact that in Python the current working directory is always on the import path. As a result, they end up building packages that only “work” in the original local development environment with a specific working directory, and even then only by accident (<a href="https://hynek.me/articles/testing-packaging/">the solution to this, if you’re curious, is to force your local development workflow to depend on the installability of your package</a>).</li>
<li>Ultimately, what you <em>want</em> is to take a known-good, working environment from a developer’s machine, and reproduce exactly that environment on your servers. That’s just what requirements files are for.</li>
</ul>
<h2>More requirements</h2>
<p>As I mentioned above, I’m advocating a setup which will use multiple requirements files. This involves a bit of organization, so I recommend creating a top-level <code>requirements/</code> directory in your source-code repository and placing requirements files in it, rather than putting the files themselves top-level, or putting them somewhere else.</p>
<p>Now, why multiple files? Well, because there are often multiple types of dependencies and you often want to select only a particular subset to install. The most common such split is between general always-needed packages, and packages which are only needed in order to run your test suite; there’s no need for a production container to have all the test-only dependencies installed, and in general the less code you put in the production container the fewer things you have that can go wrong, so I generally like to install those only when the test suite is actually going to be run.</p>
<p>You can split this up further if you want — I’ve done finer-grained splits of dependencies before — but at the very least I think you should be keeping test-only dependencies separate from the rest.</p>
<h2>Seeing the trees in the forest</h2>
<p>Now we run into our first clear problem: what’s in a requirements file is not necessarily what will be installed. Or, to be specific: is not necessarily <em>all</em> of what will be installed. Suppose, for example, that you put <code>Django==4.0.4</code> (the latest version as I write this) in your requirements file, and then <code>pip install -r</code> from it. You’ll get Django 4.0.4… and also <code>asgiref</code> and <code>sqlparse</code>, and depending on your platform and Python version possibly also <code>backports.zoneinfo</code> and <code>tzdata</code>, because those are dependencies declared by Django.</p>
<p>So how do you see, and control, your entire dependency tree? Well, one option is to list out your direct dependencies, <code>pip install</code> them locally in a virtual environment, then run <code>pip freeze</code> to see the full list of what was installed, and then add any indirect dependencies to your requirements file. You could even script this if you wanted to, and in fact someone already <em>has</em> scripted it: <a href="https://pypi.org/project/pip-tools/">the pip-tools project</a>, which provides a <code>pip-compile</code> command that takes a list of the packages you directly care about, and outputs a requirements file containing the entire tree, with all direct and indirect dependencies, pinned to exact versions.</p>
<p>If you really want to write your own script to do this, I won’t stop you, but I’ve used <code>pip-compile</code> at multiple jobs now and on my own personal projects and been happy enough with it that it’s the only non-standard Python packaging tool I’m willing to recommend people use.</p>
<h2>Hashing it out</h2>
<p>Tracking the full dependency tree, and having the ability (thanks to <code>pip-tools</code>) to see both the full tree and just the direct dependencies, gets most of the way to a reproducible environment. But not <em>all</em> of the way, because this process implicitly relies on the integrity of the Python Package Index to serve you the same package every time and not silently swap out something different or even malicious.</p>
<p>Now, I should be clear here: every single breathless <span>OMG</span> <span>SUPPLY</span> <span>CHAIN</span> <span>ATTACK</span> <span>ON</span> <span>PYPI</span> article I’ve ever seen has just been sensationalized typosquatting. Things like registering a package named “Dajngo” and hoping to catch people who mistyped “Django”, or similar. I’ve <em>never</em> seen one making a tenable claim of compromise of package maintainers’ accounts, or of PyPI itself. PyPI has been reliable and trustworthy to an incredibly high degree.</p>
<p>But even the folks who run PyPI have put thought — see <a href="https://peps.python.org/pep-0458/"><span>PEP</span> 458</a> and <a href="https://peps.python.org/pep-0480/"><span>PEP</span> 480</a> for two examples — into some of the scarier scenarios and how PyPI can be made more resilient to them. And you should be thinking about those scenarios, too: PyPI has been highly trustworthy, but there’s a reason why the saying is “trust, but verify”.</p>
<p>It’s worth noting here that signed packages, as many operating-system vendors use, are not really a solution for PyPI. <span>OS</span> vendors tend to have a small set of specially-trusted package maintainers, so there’s a small set of signing keys to keep track of. A repository like PyPI is open to arbitrary members of the public for package publishing, which is fundamentally incompatible with having only a small set of trusted keys. You <em>can</em>, and some package authors <em>do</em>, <span>PGP</span>-sign PyPI uploads anyway, but standard Python package tooling doesn’t do anything with the signatures.</p>
<p>But in the absence of a small set of trusted package signers, the next best thing is just reproducibility: ensuring that what you get the next time you <code>pip install</code> will be the same as what you got <em>this</em> time (when, presumably, you verified that it was what you expected it to be), or if not that the installation will fail.</p>
<p>For this you can use pip’s <a href="https://pip.pypa.io/en/stable/cli/pip_install/#hash-checking-mode">hash-checking mode</a>, where in addition to the package name and version, you also list the expected hash or hashes of the package. When this is provided, pip’s behavior changes as follows:</p>
<ul>
<li><em>All</em> packages to be installed must specify hashes, including all indirect dependencies. If any package does not have a hash specified, the installation will fail.</li>
<li>If any package’s actual hash does not match its expected hash, the entire installation attempt fails.</li>
</ul>
<p>This is as close as you can get to fully-reproducible environments using the standard Python packaging tool chain. The only room for variation here is if your dependencies include packages with compiled extensions, and you install onto multiple different platforms; the compiled packages for different platforms will, naturally, have different hashes. This can be worked around by specifying <em>multiple</em> hashes for such packages, listing one hash for each platform-specific variant you expect to install.</p>
<p>To manually obtain the hashes for your dependency tree you can run <code>pip download</code> to download all the packages locally, and then <code>pip hash</code> on each one to obtain the hash. For platform-specific packages you can manually download each platform variant and <code>pip hash</code> them.</p>
<p>Or, once again, you can script this, and once again the pip-tools project <em>has</em> scripted it; the <code>--generate-hashes</code> argument to <code>pip-compile</code> will automatically calculate and insert all necessary package hashes (including all platform variants) into the compiled requirements file.</p>
<h2>Invocations</h2>
<p>Before putting all this together, it’s worth covering one more detail: how to invoke the tools. This may seem a bit silly, since they all provide command-line entry points: just run <code>pip install</code>, right?</p>
<p>But there’s a potential issue here: in a moment I’m going to recommend creating a Python virtual environment, which opens up the possibility of multiple Python environments coexisting on the same machine. This is certainly a useful feature, but it does come with a new concern, which is how to ensure you’re using and running things in the environment you expect to be using.</p>
<p>One common way to run into trouble here is having one Python environment’s package directory be first on your <code>$PYTHONPATH</code> while, unbeknownst to you, a different one’s <code>bin/</code> directory is first on your general <code>$PATH</code>. If you just run <code>pip install</code> you’ll get the second one’s instance of <code>pip</code>, which may not be at all what you want.</p>
<p>This is why the official Python packaging guides, and official documentation for tools like <code>pip</code>, always use a different approach: they run <code>python -m pip</code> instead of <code>pip</code>, and <code>python -m venv</code> instead of a standalone script like <code>virtualenv</code>. The <code>-m</code> flag allows a Python module to be run as a script (providing it’s been written to expose an entry point for this, which <code>pip</code> and <code>venv</code> both have), and while it doesn’t guarantee that you’ll invoke the Python interpreter you were expecting, it does prevent a lot of potential hard-to-debug issues that can accidentally result from things like manually hacking around with paths.</p>
<h2>Putting it all together</h2>
<p>That was a lot of explanation for what ends up being, ultimately, a fairly simple process to actually use. So now let’s finally take a look at it.</p>
<p>First things first: always work in, and deploy in, a virtual environment. Even if you think you don’t need one. In fact, <em>especially</em> if you don’t think you need one. Virtual environments (originally the third-party <code>virtualenv</code> module, now with the core functionality in the standard library as the <code>venv</code> module) provide isolation of a particular Python environment and set of installed packages, which is incredibly handy when you want or need to have multiple such environments. And even if you’re deploying in a container which you <em>know</em> has only one Python interpreter in it, I still urge you to create a virtual environment inside it anyway; they don’t cost you anything to create, and if you ever <em>do</em> end up with multiple Python interpreters in the container — which is easy to accidentally do, if you use a base image with a purpose-built Python and then install a system package that turns out to depend on the distro’s own Python, for example — using one from the start will save you from potentially having a pager go off one night when suddenly the wrong Python is being invoked.</p>
<p>If you’re developing locally and not using a local container build, just invoke <code>python -m venv</code> however you like, and activate it before running any packaging-related commands. There are several popular conventions for this, and I won’t push any specific one on you, but I do recommend that you adopt some sort of standard way of placing your virtual environments, whether it’s to put them all in a single directory, or always in a hidden directory at the root of a project’s source tree, or something else.</p>
<p>In a container, you have a choice of whether to put it the virtual environment in some system-wide location like <code>/opt</code> (which is, as far as I can tell, the choice least offensive to filesystem hierarchy standards), or if you’re running the container as a non-root user — which you should be — in that user’s home directory. Personally I lean toward putting it in the systemwide location and then dropping to non-root after packages have been installed, because it ensures the virtual environment’s package-install location is not writeable by the user the container runs as.</p>
<p>But no matter where you put it, “activation” is a simple matter: set the environment variable <code>VIRTUAL_ENV</code> to the path to the virtual environment and then put <code>$VIRTUAL_ENV/bin</code> onto <code>$PATH</code> to be sure any accidental direct invocations of scripts will work. Which means that so far it’s going to be:</p>
<div><pre><span></span><code><span>RUN</span><span> </span>mkdir -p /opt/venvs <span>&amp;&amp;</span> python -m venv /opt/venvs/my-app
<span>ENV</span><span> </span><span>VIRTUAL_ENV</span><span>=</span>/opt/venvs/my-app
<span>ENV</span><span> </span><span>PATH</span><span>=</span>“<span>$VIRTUAL_ENV</span>/bin:<span>$PATH</span>”
</code></pre></div>

<p>You should have at least a couple of requirements files containing your dependencies; I tend to name them <code>app.txt</code> and <code>tests.txt</code> to distinguish the general app dependencies from the test-only ones, but you can name them however you like. If you take my advice about letting pip-tools provide the implementation of “compiling” a list of direct dependencies to a full pinned and hashed tree of all your dependencies, you’ll need to have a step for that. Most of the projects I work on use a <code>Makefile</code> to drive common dev tasks, so a <code>make requirements</code> target that invokes pip-tools is pretty standard for me, and usually I have it run something like this inside the container:</p>
<div><pre><span></span><code>python -m pip install --upgrade pip-tools
python -m pip-tools compile --generate-hashes requirements/app.in --output-file requirements/app.txt
python -m pip-tools compile --generate-hashes requirements/tests.in --output-file requirements/tests.txt
</code></pre></div>

<p>And the container can simply pull in the compiled requirements files and install them:</p>
<div><pre><span></span><code><span>COPY</span><span> </span>requirements/ .
python -m pip install -r requirements/app.txt
<span># Somewhere else, possibly in a separate build stage or script:</span>
python -m pip install -r requirements/tests.txt
</code></pre></div>

<p>This gets you:</p>
<ul>
<li>As reproducible and consistent an environment as possible, all the way from local development through to production, especially if you do local dev in containers and build from the same <code>Dockerfile</code> or other manifest both locally and for production.</li>
<li>Instant warning if any of your dependencies suddenly changes: if a package somehow gets surreptitiously replaced, the install step will fail on a hash mismatch.</li>
<li>Minimal worries about conflicts with a “system Python” or its packages.</li>
</ul>
<div>
<p><strong>Packages can run code during installation</strong></p>
<p>Python packages come in two forms: “source” or “sdist” packages, which typically have the file extension <code>.tar.gz</code>, and “wheel” packages, which have the file extension <code>.whl</code>. A source package historically includes a <code>setup.py</code> script which specifies how to build and install it (though this is being gradually replaced by the static <code>pyproject.toml</code> config file), and that script will be run during installation. If you were to accidentally install a malicious package, it could run arbitrary code in its <code>setup.py</code> script during installation, which would be very bad. Wheel packages, on the other hand, are simple archives whose installation process consists of extracting the files and putting them in the correct locations; there are no install-time hooks for running code.</p>
<p>You can tell <code>pip</code> to use <em>only</em> wheel packages, by passing <a href="https://pip.pypa.io/en/stable/cli/pip_install/#cmdoption-only-binary">the <code>--only-binary</code> flag</a> and either a list of packages or the special value <code>:all:</code>. For example: <code>python -m pip install --only-binary :all: -r requirements/app.txt</code>.</p>
<p>I strongly recommend trying this option first, and sticking with it if it works. Unfortunately, not all packages provide <code>.whl</code> format, so you may not be able to force it for your entire install. If you run into a package that doesn’t provide a wheel, you can still require all other packages to use wheels.</p>
</div>
<h2>Staying up-to-date</h2>
<p>The only thing still missing is updates as new versions of your dependencies are released. For security updates this is pretty crucial, but it’s also useful to have even for non-security updates; if you’re not regularly looking for and applying updated versions of dependencies, you’re likely to end up with painful upgrade-the-whole-world-at-once moments when you hit a milestone like a major library/framework version reaching the end of its upstream support cycle.</p>
<p>This is where things get a little bit tricky, because the usual way you’d automatically pick up updates is by specifying a range of versions you’re willing to accept for direct dependencies, and periodically rebuilding your full tree to pick up any updates. For example, if you want to use the Django 3.2 <span>LTS</span> release, you might specify <code>Django&gt;=3.2.0,&lt;4.0</code>. And then you’d always get the latest 3.2-series Django release.</p>
<p>And you can do this if you want; you’ll likely want to combine it with pip-tools or your own scripting to perform the equivalent “compilation” of the full pinned and hashed dependency tree, and then you’ll automatically pull updated versions every time you recompile the dependencies.</p>
<p>The only potential downside is the same as the upside: you get updated every time you recompile the dependencies. Which is great when it works, and not so great when it doesn’t. Personally, I lean toward the super-boring approach, which is to apply updates explicitly and one at a time, rather than implicitly in batches. For this I tend to configure and use <a href="https://docs.github.com/en/code-security/dependabot/dependabot-version-updates/configuring-dependabot-version-updates">dependabot</a> or its equivalent for other code-hosting platforms. My experience with dependabot is that it just works — it even understands the pip-tools style of requirements and will do the right thing. So I generally like to set it up, let it file pull requests on a weekly cadence, and then manually review and apply those pull requests. But again, that’s me and my preference for being as boring as possible; I don’t mind spending a little time each week dealing with the dependabot PRs if it prevents a pager from going off at <span>2AM</span>.</p>
<p>And of course, if you just want got get security updates and not every single version bump of every dependency, several code-hosting platforms have that built-in as a feature now, and there are also third-party services like <a href="https://pyup.io">pyup</a> that will do it for you.</p>
<h2>And that’s a wrap</h2>
<p>As promised, that was a lot of words for what’s really a pretty simple process, but there’s a lot of complexity — necessary complexity, of a sort that pops up in any software packaging ecosystem — lurking underneath, and explaining <em>that</em> is what drives up the word count. </p>
<p>But hopefully you now understand how to do “boring” Python dependency management, using only the standard Python packaging tools and <em>optionally</em> pip-tools for the “already scripted this bit so you don’t have to” factor. And hopefully you understand <em>why</em> I’m recommending the particular workflow I’ve given above. Even if you don’t want to adopt my recommendations, I’d like to think that learning what they are and why I make them is helpful to you. For me, these recommendations are the result of nearly a decade of trying, across four different employers, to settle on a dependency management workflow that kept things up to date with minimal risk of causing pagers to go off.</p>
<p>Meanwhile I’ve got some ideas for further “boring Python” articles, including why to keep using Python at all when its trendiness, at least for my own domain of web apps, seems to be on the decline — but those will have to wait for another day.</p>


    </div>
  </div></div>
  </body>
</html>
