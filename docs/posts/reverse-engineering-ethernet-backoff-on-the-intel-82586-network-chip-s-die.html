<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="http://www.righto.com/2023/10/reverse-engineering-ethernet-backoff-on.html">Original</a>
    <h1>Reverse-engineering Ethernet backoff on the Intel 82586 network chip&#39;s die</h1>
    
    <div id="readability-page-1" class="page"><div id="post-body-6841874513404372481" itemprop="description articleBody"><p>
Introduced in 1973, Ethernet is the predominant way of wiring computers together.
Chips were soon introduced to handle the low-level aspects of Ethernet: converting data packets into bits,
implementing checksums, and handling network collisions.
In 1982, Intel announced the i82586 Ethernet LAN coprocessor chip, which went much further by offloading most of the
data movement from the main processor to an on-chip coprocessor.
Modern Ethernet networks handle a gigabit of data per second or more, but at the time, the Intel chip&#39;s support for 10 Mb/s
Ethernet put it on the cutting edge.
(Ethernet was surprisingly expensive, about $2000 at the time, but <a href="https://books.google.com/books?id=3kpkQKds0lAC&amp;lpg=PA4&amp;pg=PA4#v=onepage&amp;q&amp;f=false">expected to drop</a> under $1000 with the Intel chip.)
In this blog post, I focus on a specific part of the coprocessor chip: how it handles network collisions and implements
exponential backoff.</p>
<p>The die photo below shows the i82586 chip. This photo shows the metal layer on top of the chip, which hides the underlying
polysilicon wiring and silicon transistors.
Around the edge of the chip, square bond pads provide the link to the chip&#39;s 48 external pins.
I have labeled the function blocks based on my reverse engineering and published descriptions. The left side of the chip is called the &#34;receive unit&#34; and
handles the low-level networking,
with circuitry for the network transmitter and receiver.
The left side also contains low-level control and status registers.
The right side is called the &#34;command unit&#34; and interfaces to memory and the main processor.
The right side contains a simple processor controlled by a microinstruction ROM.<span id="fnref:microcode"><a href="#fn:microcode">1</a></span>
Data is transmitted between the two halves of the chip by 16-byte FIFOs (first in, first out queues).</p>
<p><a href="https://static.righto.com/images/i82586s/die-labeled.jpg"><img alt="The die of the Intel 82586 with the main functional blocks labeled. Click this image (or any other) for a larger version." height="528" src="https://static.righto.com/images/i82586s/die-labeled-w600.jpg" title="The die of the Intel 82586 with the main functional blocks labeled. Click this image (or any other) for a larger version." width="600"/></a></p><p>The die of the Intel 82586 with the main functional blocks labeled. Click this image (or any other) for a larger version.</p>
<p>The 82586 chip is more complex than the typical Ethernet chip at the time.
It was designed to improve system performance by moving most of the Ethernet processing from the main processor to
the coprocessor, allowing the main processor and the coprocessor to operate in parallel.
The coprocessor provides four DMA channels to move data between memory and the network without the main processor&#39;s involvement.
The main processor and the coprocessor communicate through complex data structures<span id="fnref:structures"><a href="#fn:structures">2</a></span> in shared memory: the main processor puts control blocks in memory
to tell the I/O coprocessor what to do, specifying the locations of transmit and receive buffers in memory.
In response, the I/O coprocessor puts status blocks in memory.
The processor onboard the 82586 chip allows the chip to handle these complex data structures in software.
Meanwhile, the transmission/receive circuitry on the left side of the chip uses dedicated circuitry to handle the low-level,
high-speed aspects of Ethernet. </p>
<h2>Ethernet and collisions</h2>
<p>A key problem with a shared network is how to prevent multiple computers from trying to send data on the network at the same
time.
Instead of a centralized control mechanism, Ethernet allows computers to transmit whenever they want.<span id="fnref:token-ring"><a href="#fn:token-ring">3</a></span>
If two computers transmit at the same time, the &#34;collision&#34; is detected and the computers try again, hoping to
avoid a collision the next time.
Although this may sound inefficient, it turns out to work out remarkably well.<span id="fnref:csma"><a href="#fn:csma">4</a></span>
To avoid a second collision, each computer waits a random amount of time before retransmitting the packet.
If a collision happens again (which is likely on a busy network), an exponential backoff algorithm is used, with each
computer waiting longer and longer after each collision.
This automatically balances the retransmission delay to minimize collisions and maximize throughput.</p>
<p>I traced out a bunch of circuitry to determine how the exponential backoff logic is implemented.
To summarize, exponential backoff is implemented with a 10-bit counter to provide a pseudorandom number, a 10-bit mask register to get an exponentially sized
delay, and a delay counter to count down the delay.
I&#39;ll discuss how these are implemented, starting with the 10-bit counter.</p>
<h2>The 10-bit counter</h2>
<p>A 10-bit counter may seem trivial, but it still takes up a substantial area of the chip.
The straightforward way of implementing a counter is to hook up 10 latches as a &#34;ripple counter&#34;.
The counter is controlled by a clock signal that indicates that the counter should increment.
The clock toggles the lowest bit of the counter.
If this bit flips from 1 to 0, the next higher bit is toggled.
The process is repeated from bit to bit, toggling a bit if there is a carry.
The problem with this approach is that the carry &#34;ripples&#34; through the counter.
Each bit is delayed by the lower bit, so the bits don&#39;t all flip at the same time.
This limits the speed of the counter as the top bit isn&#39;t settled until the carry has propagated through the nine lower bits.</p>
<p>The counter in the chip uses a different approach with additional circuitry to improve performance.
Each bit has logic to check if all the lower bits are ones. If so, the clock signal toggles the bit.
All the bits toggle at the same time, rapidly incrementing the counter in response to the clock signals.
The drawback of this approach is that it requires much more logic.</p>
<p>The diagram below shows how the carry logic is implemented. 
The circuitry is optimized to balance speed and complexity.
In particular, bits are examined in groups of three, allowing some of the logic to be shared across multiple bits.
For instance, instead of using a 9-input gate to examine the nine lower bits, separate gates test bits 0-2 and 3-5.</p>
<p><a href="https://static.righto.com/images/i82586s/toggle-logic.jpg"><img alt="The circuitry to generate the toggle signals for each bit of the counter." height="555" src="https://static.righto.com/images/i82586s/toggle-logic-w350.jpg" title="The circuitry to generate the toggle signals for each bit of the counter." width="350"/></a></p><p>The circuitry to generate the toggle signals for each bit of the counter.</p>
<p>The implementation of the latches is also interesting. 
Each latch is implemented with dynamic logic, using the circuit&#39;s capacitance to store each bit.
The input is connected to the output with two inverters.
When the clock is high, the transistor turns on, connecting the inverters in a loop that holds the value.
When the clock is low, the transistor turns off. However, the 0 or 1 value will still remain on the input to
the first inverter, held by the charge on the transistor&#39;s gate. 
At this time, an input can be fed into the latch, overriding the old value.</p>
<p><a href="https://static.righto.com/images/i82586s/bit.jpg"><img alt="The basic dynamic latch circuit." height="148" src="https://static.righto.com/images/i82586s/bit-w300.jpg" title="The basic dynamic latch circuit." width="300"/></a></p><p>The basic dynamic latch circuit.</p>
<p>The latch has some additional circuitry to make it useful.
To toggle the latch, the output is inverted before feeding it back to the input. The toggle control signal selects
the inverted output through another pass transistor.
The toggle signal is only activated when the clock is low, ensuring that the
circuit doesn&#39;t repeatedly toggle, oscillating out of control.</p>
<p><a href="https://static.righto.com/images/i82586s/counter-bit.jpg"><img alt="One bit of the counter." height="196" src="https://static.righto.com/images/i82586s/counter-bit-w400.jpg" title="One bit of the counter." width="400"/></a></p><p>One bit of the counter.</p>
<p>The image below shows how the counter circuit is implemented on the die. I have removed the metal layer to show the underlying transistors; the circles are contacts where the metal was connected to the underlying silicon.
The pinkish regions are doped silicon. The pink-gray lines are polysilicon wiring. When polysilicon crosses doped silicon, it
creates a transistor.
The blue color swirls are not significant; they are bits of oxide remaining on the die.</p>
<p><a href="https://static.righto.com/images/i82586s/die-counter.jpg"><img alt="The counter circuitry on the die." height="764" src="https://static.righto.com/images/i82586s/die-counter-w400.jpg" title="The counter circuitry on the die." width="400"/></a></p><p>The counter circuitry on the die.</p>
<h2>The 10-bit mask register</h2>
<p>The mask register has a particular number of low bits set, providing a mask of length 0 to 10.
For instance, with 4 bits set, the mask register is 0000001111.
The mask register can be updated in two ways. First, it can be set to length 1-8 with a three-bit length input.<span id="fnref:length"><a href="#fn:length">5</a></span>
Second, the mask can be lengthened by one bit, for example going from 0000001111 to 0000011111 (length 4 to 5).</p>
<p>The mask register is implemented with dynamic latches similar to the counter, but the inputs to the latches are different.
To load the mask to a particular length, each bit has logic to determine if the bit should be set based on the three-bit input.
For example, bit 3 is cleared if the specified length is 0 to 3, and set otherwise.
The lengthening feature is implemented by shifting the mask value to the left by one bit and inserting a 1 into the lowest bit.</p>
<p>The schematic below shows one bit of the mask register. At the center is a two-inverter latch as seen before.
When the clock is high, it holds its value. When the clock is low, the latch can be loaded with a new value.
The &#34;shift&#34; line causes the bit from the previous stage to be shifted in. The &#34;load&#34; line loads the mask bit generated from
the input length. The &#34;reset&#34; line clears the mask.
At the right is the NAND gate that applies the mask to the count and inverts the result.
As will be seen below, these NAND gates are unusually large.</p>
<p><a href="https://static.righto.com/images/i82586s/mask-stage.png"><img alt="One stage of the mask register." height="259" src="https://static.righto.com/images/i82586s/mask-stage-w500.png" title="One stage of the mask register." width="500"/></a></p><p>One stage of the mask register.</p>
<p>The logic to set a mask bit based on the length input is shown below.<span id="fnref:demorgan"><a href="#fn:demorgan">6</a></span>
The three-bit &#34;sel&#34; input selects the mask length from 1 to 8 bits; note that the mask0 bit is always set while bits
8 and 9 are cleared.<span id="fnref:control"><a href="#fn:control">7</a></span>
Each set of gates energizes the corresponding mask line for the appropriate inputs.</p>
<p><a href="https://static.righto.com/images/i82586s/mask-ctrl.png"><img alt="The control logic to enable mask bits based on length." height="602" src="https://static.righto.com/images/i82586s/mask-ctrl-w350.png" title="The control logic to enable mask bits based on length." width="350"/></a></p><p>The control logic to enable mask bits based on length.</p>
<p>The diagram below shows the mask register on the die. I removed the metal layer to show the underlying
silicon and polysilicon, so the transistors are visible.
On the left are the NAND gates that combine each bit of the counter with the mask. Note that large snake-like
transistors; these larger transistors provide enough current to drive the signal over the long bus to
the delay counter register at the bottom of the chip.
Bit 0 of the mask is always set, so it doesn&#39;t have a latch. Bits 8 and 9 of the mask are only set by
shifting, not by selecting a mask length, so they don&#39;t have mask logic.<span id="fnref:state"><a href="#fn:state">8</a></span></p>
<p><a href="https://static.righto.com/images/i82586s/mask-register.jpg"><img alt="The mask register on the die." height="764" src="https://static.righto.com/images/i82586s/mask-register-w400.jpg" title="The mask register on the die." width="400"/></a></p><p>The mask register on the die.</p>
<h2>The delay counter register</h2>
<p>To generate the pseudorandom exponential backoff, the counter register and the mask register are NANDed together.
This generates a number of the desired binary length, which is stored in the delay counter.
Note that the NAND operation inverts the result, making it negative.
Thus, as the delay counter counts up, it counts toward zero, reaching zero after the desired number of clock ticks.</p>
<p>The implementation of the delay counter is similar to the first counter, so I won&#39;t include a schematic.
However, the delay counter is attached to the register bus, allowing its value to be read by the chip&#39;s CPU.
Control lines allow the delay counter&#39;s value to pass onto the register bus.</p>
<p>The diagram below shows the locations of the counter, mask, and delay register on the die.
In this era, something as simple as a 10-bit register occupied a significant part of the die.
Also note the distance between the counter and mask and the delay register at the bottom of the chip.
The NAND gates for the counter and mask required large transistors to drive the signal across this large distance.</p>
<p><a href="https://static.righto.com/images/i82586s/die-labeled-backoff.jpg"><img alt="The die, with counter, mask, and delay register." height="446" src="https://static.righto.com/images/i82586s/die-labeled-backoff-w600.jpg" title="The die, with counter, mask, and delay register." width="600"/></a></p><p>The die, with counter, mask, and delay register.</p>
<h2>Conclusions</h2>
<p>The Intel Ethernet chip provides an interesting example of how a real-world circuit is implemented on a chip.
Exponential backoff is a key part of the Ethernet standard.
This chip implements backoff with a simple but optimized circuit.<span id="fnref:drawback"><a href="#fn:drawback">9</a></span></p>
<p><a href="https://static.righto.com/images/i82586s/die-stripped-r.jpg"><img alt="A high-resolution image of the die with the metal removed. (Click for a larger version.) Some of the oxide layer remains, causing colored regions due to thin-film interference." height="511" src="https://static.righto.com/images/i82586s/die-stripped-r-w600.jpg" title="A high-resolution image of the die with the metal removed. (Click for a larger version.) Some of the oxide layer remains, causing colored regions due to thin-film interference." width="600"/></a></p><p>A high-resolution image of the die with the metal removed. (Click for a larger version.) Some of the oxide layer remains, causing colored regions due to thin-film interference.</p>
<p>For more chip reverse engineering,
follow me on Twitter <a href="https://twitter.com/kenshirriff">@kenshirriff</a> or <a href="http://www.righto.com/feeds/posts/default">RSS</a> for updates.
I&#39;m also on Mastodon occasionally as <a href="https://oldbytes.space/@kenshirriff">@<span data-cfemail="412a242f3229283333282727012e2d2523383524326f3231202224">[email protected]</span></a>.
Acknowledgments: Thanks to Robert Garner for providing the chip and questions.</p>
<h2>Notes and references</h2>


</div></div>
  </body>
</html>
