<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blintzbase.com/posts/pir-and-fhe-from-scratch/">Original</a>
    <h1>Explained from scratch: private information retrieval and homomorphic encryption</h1>
    
    <div id="readability-page-1" class="page"><div id="content">
<article>
    <p><em>This is a from-scratch explanation of private information retrieval built using homomorphic encryption. I try to assume only a general math / computer science background. To simplify things, my explanations may not always match academic definitions. You can check out this <a href="https://spiralwiki.com/">Wikipedia demo</a>, <a href="https://btc.usespiral.com/">Bitcoin balance checker</a>, <a href="https://ia.cr/2022/368">paper</a>, or <a href="https://github.com/menonsamir/spiral-rs">code</a> for more. Follow us <a href="https://twitter.com/SpiralPrivacy">@SpiralPrivacy</a>.</em></p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Say we want to fetch an article from Wikipedia, but somehow <em>not</em> reveal to the server which one we fetched.</p>
<p>A naive solution is to download and store the entirety of Wikipedia; then, all your queries can be local and the server never learns anything. Unfortunately, this takes a lot of bandwidth and storage (~10 GB), so it isn’t very practical.</p>
<p>Another strawman solution might be to put the articles in buckets, and just send some ‘dummy’ articles along with the true response. This still leaks significant information - over time, or with any additional prior about your behavior, it’s easy to narrow down the set of articles you were really looking at.</p>
<p>It turns out that we can do much better - it is possible to <em>cryptographically guarantee</em> that the server cannot learn <em>anything</em> about your query. In cryptography, this problem is called “Private Information Retrieval”, or “PIR”. In PIR, a client wishes to retrieve the $i$-th item of an $n$-item database hosted on a server, without revealing $i$ to the server or downloading the entire database. Crucially, this “query privacy” guarantee should hold even if the server is actively malicious.</p>
<p><img src="https://blintzbase.com/images/pir.png#small" alt="Private information retrieval"/></p>
<p>The power of PIR is that it cuts off the flow of data from clients to servers <em>at the source</em> - the server never gets the data in the first place! This is a big deal: we can stop <em>promising</em> not to collect and store data (promises that inevitably get watered down by acquisitions, external pressures, etc), and start <em>cryptographically guaranteeing</em> that there is no data to collect. You can use PIR to build websites that can’t learn the pages you load (<a href="https://spiralwiki.com">private Wikipedia</a>), cryptocurrency block explorers that can’t learn your address (<a href="https://btc.usespiral.com">private Bitcoin explorer</a>), and someday, maybe even private search engines or messaging services that can’t learn who you talk to.</p>
<!-- raw HTML omitted -->
<p>In this post, I’ll explain how we can build PIR from scratch. By the end of this article, we’ll have <a href="https://replit.com/@blintzbase/Toy-PIR">200 lines of zero-dependency Python</a> that implement a working (though inefficient) PIR scheme.</p>


<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="constructing-pir-using-homomorphic-encryption">Constructing PIR using homomorphic encryption</h2>
<p>The standard toolkit of normal encryption and hash functions does not yield a workable solution to PIR.
However, using a special kind of encryption called “homomorphic encryption”, it is possible to answer a query privately without downloading the entire database. Here is a high-level overview of how a client can privately retrieve the $i$-th item from an $n$-item database; in our example, $i=3$ and $n=4$:</p>
<p><img src="https://blintzbase.com/images/pir-from-fhe.png#wide" alt="PIR from homomorphic encryption"/></p>
<ol>
<li>The client encodes its desired index $i=3$ in a one-hot encoding. That is, it builds a vector of $n=4$ bits, where the $i$-th bit is $1$ and the rest are $0$.</li>
<li>The client generates a homomorphic encryption secret key, and uses it to encrypt each bit, producing $n$ ciphertexts, where the $i$-th ciphertext is an encrypted $1$, and the rest are encrypted $0$&#39;s.</li>
<li>The client sends this vector of encrypted bits to the server. To the server, this vector of encrypted bits is completely random noise; it cannot learn anything about the encrypted bits.</li>
<li>The server takes the $n$ ciphertexts (each encrypting a bit), and <strong>homomorphically multiplies</strong> them by the corresponding <em>plaintext</em> database item. This produces a total of $n$ ciphertexts, each encrypting either 0 or the desired database item.</li>
<li>The server <strong>homomorphically adds</strong> all of these ciphertexts, resulting in a single ciphertext encrypting the desired database item.</li>
<li>The server sends this single ciphertext to the client.</li>
<li>The client decrypts this ciphertext and obtains its desired plaintext item.</li>
</ol>
<p>The special feature of homomorphic encryption is that it is possible to perform the above two bolded operations; specifically:</p>
<ul>
<li><strong>Homomorphic addition</strong>: If the ciphertext $c_1$ encrypts $m_1$, and the ciphertext $c_2$ encrypts $m_2$, then $c’ = c_1 + c_2$ encrypts the value $m_1 + m_2$.</li>
<li><strong>Homomorphic plaintext multiplication</strong>: If the ciphertext $c_1$ encrypts $m_1$ and we have some other plaintext $m_2$, then $c’ = c_1 * m_2$ encrypts the value $m_1 * m_2$.</li>
</ul>
<p>Basically, these properties let the server “add” ciphertexts or “multiply them by plaintexts”, without learning what they encrypt. These properties are not a part of normal encryption schemes - if you try to add ciphetexts in a standard encryption scheme like AES, you will get garbage.</p>
<!-- raw HTML omitted -->
<p>Importantly, aside from the homomorphic properties, homomorphic encryption schemes still satisfy the key property of normal encryption:</p>
<ul>
<li><strong>Confidentiality:</strong> A ciphertext reveals <em>nothing</em> about the plaintext it encrypts without access to the secret key; this remains true even if an attacker is allowed to repeatedly observe encryptions of known plaintexts. For example, an attacker can observe 10 encryptions of the value “0”, but they will all look different, and the attacker will gain no information about what an 11th ciphertext encrypts.</li>
</ul>
<p>It’s this property that prevents the ciphertexts sent by the client from leaking information about the query; since the scheme they are encrypted under provides confidentiality, an attacker cannot learn anything about the encrypted bits, and therefore cannot learn anything about the query.</p>
<p>So, to build PIR, we will need a homomorphic encryption scheme which achieves <strong>confidentiality</strong>, <strong>homomorphic addition</strong>, and <strong>homomorphic plaintext multiplication</strong>. Let’s see how to construct one.</p>
<div>
<p>I’ve abridged the exact definition of <strong>confidentiality</strong> for an encryption scheme. There are actually a wide variety of ways to define what makes encryption “secure” in an intuitive sense, and some of them are broken in surprising ways (ex: <a href="https://github.com/robertdavidgraham/ecb-penguin">the AES ECB Penguin</a>). If you’re interested in the formal defitions, check out <a href="https://www.coursera.org/lecture/crypto/active-attacks-on-cpa-secure-encryption-SiCKv">this lecture</a> or <a href="https://toc.cryptobook.us/">chapter 9 of this free online textbook</a>.</p></div>

<!-- raw HTML omitted -->
<h2 id="lattice-based-cryptography">Lattice-based cryptography</h2>
<p>To build homomorphic encryption, we will need a new cryptographic scheme. You might already be familiar with symmetric cryptography, like AES or ChaCha, where we want to encrypt data and send it to someone else who has our secret key, and public-key cryptography, like RSA and elliptic curve cryptography (ECC), where we want to allow others to encrypt things to us using only our public key. Ultimately, all these schemes provide variations on <em>confidentiality</em>, but they cannot be used to construct efficient homomorphic encryption. Instead, we will need to learn about a new family of schemes, <em>lattice-based</em> schemes, that can provide both confidentiality <em>and</em> the homomorphic properties we want.</p>
<p>Encryption schemes like RSA or ECC are based on hard problems that cryptographers hypothesize are very difficult to solve. I’m oversimplifying, but the RSA problem boils down to something like:</p>
<blockquote>
<p>“Given $n = p*q$, where $p$ and $q$ are large primes, find $p$”</p>
</blockquote>
<p>Cryptographers’ hypothesis for RSA is that given $n$, finding $p$ (without knowing $q$) will take an amount of computation that is exponential in the size of the number n (in bits). The hard problem that ECC is based on is more complicated (see <a href="https://jeremykun.com/2014/02/08/introducing-elliptic-curves/">this detailed explanation</a> for more).</p>
<p>When we say that a problem is “hard” here, we mean something more than the colloquial meaning of “it’s not easy to solve”. The technical meaning of “hard” in this context is more like “taking time exponential in the size of the problem”<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>. To avoid getting into complexity theory that I barely understand, we’ll focus on the most concrete requirement: for a specific instance of a problem to be considered “hard”, it should take at least $2^{128}$ basic operations (addition, multiplication, etc) to solve it using the best known algorithms. You might ask, “Why $2^{128}$?&#34;; it is a somewhat arbitrary value, but it’s widely used across academia and industry, and current estimates indicate that it would take all of the computing power on Earth working for millions of years to perform $2^{128}$ operations. So, we say that any problem which takes $2^{128}$ operations to solve is “hard”, and in practice impossible to solve.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Lattice-based cryptography is based on a different class of hard problem than RSA and ECC, (unsurprisingly) called lattice problems. We will focus on a single hard problem, called the “learning with errors” problem, or LWE. I think that this problem is actually in some ways <em>simpler</em> to understand than the hard problems that underly RSA and ECC, and we can use it to build efficient homomorphic encryption.</p>
<div>
<p><strong>Post-quantum cryptography</strong></p>
<p>In what is basically an unfortunate coincidence, both the RSA and ECC problems can be solved quite easily by a large-enough quantum computer. Lattices, as far as we know today, cannot, so another motivation for lattice-based cryptography is that it will still be secure if someone builds a large quantum computer (there’s even <a href="https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization">a global competition to choose a secure post-quantum encryption scheme</a>).</p></div>

<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="learning-with-errors-lwe">Learning with errors (LWE)</h2>
<p>The “Learning with errors” (“LWE”) problem was introduced by Oded Regev in 2005, and has since been used to build many advanced cryptographic schemes, of both theoretical and practical interest.</p>
<p>Some preliminaries: assume that $q$ is some prime number. We write $\Z_q$ to represent the set of integers modulo $q$; when we say some value $x \in \Z_q$, we mean that $x$ is an integer in the range $[0, q-1]$. We assume that all operations between elements of $\Z_q$ are modulo $q$; so, if we have $x = 4 \in \Z_7$ and $y = 5 \in \Z_7$, then $x + y = 2 \in \Z_7$ and $x\cdot y = 6 \in \Z_7$. We write $\Z_q^{n}$ to represent an $n$-element vector, and $\Z_q^{n \times n}$ to represent an $n \times n$ matrix. When we say that we “sample” vectors or matrices “at random”, we mean that we choose a random number in the range $[0, q-1]$ for each element of the vector or matrix. We use $m=2$, $n=3$ and $q=7$ for our toy examples, but “hard” instances of the problem have larger values.</p>
<p>Now, imagine someone samples a vector $s \in \Z_q^{n}$ and a matrix $A \in \Z_q^{m \times n}$ uniformly at random.</p>
<p>Say they give us $A$ and the matrix-vector product $b = As$. Can we determine $s$?</p>
<p><img src="https://blintzbase.com/images/lwe-pre-noise.png" alt="LWE without noise"/></p>
<p>The answer is, with overwhelming probability, yes, it will be easy to dermine $s$. How? We can compute the matrix inverse of $A$, and then multiply this by $b$. This will give us $s$ since $A^{-1}b = A^{-1}As = s$. The matrix inverse will exist as long as the determinant of $A$ is not zero, which is almost certainly true, since $A$ was chosen uniformly at random. Computing the matrix inverse is also not difficult, so this is not a ‘hard’ problem, and so it’s not one we can base cryptography on.</p>
<p>Things get more interesting when we make a small change to the problem. Instead of sending us $b = As$, what if instead they make things harder by injecting some <em>error</em> into $b$? Specifically, if they send us $b = As + e$, for some error vector $e$, the problem becomes suprisingly hard. This is because multiplying by the matrix inverse doesn’t work well in the presence of even a small amount of error. The error can be sampled a number of ways, but for now imagine that it is chosen uniformly over a small range (much less than $q$).</p>
<p><img src="https://blintzbase.com/images/lwe-post-noise.png" alt="LWE with noise"/></p>
<p>This problem is called “learning with errors”, or LWE, since we are trying to learn $s$ given some data that contains errors. Each row of the output can be called an “LWE sample”, since it is a <em>noisy</em> ‘observation’ of the dot product of a row of $A$ and $s$. For this reason, the error is also often referred to as “noise”, and the distribution it is sampled from is called the “noise distribution”. The challenge is to determine $s$ from at most $m$ LWE samples.</p>
<p>This is thought to be very hard, even for surprisingly small choices of the parameters. For example, cryptographers think that solving this problem for $n=512$, $q=3329$, and error sampled uniformly from $[-3,3]$ is difficult (in fact, NIST is <a href="https://csrc.nist.gov/News/2022/pqc-candidates-to-be-standardized-and-round-4">standardizing a scheme with similar parameters</a> for its resistance to even a large quantum computer). We think that this instance of the problem is hard no matter how many LWE samples an attacker gets access to, so we would say that $m=\infty$ for these parameters. Concretely, calling these parameters “hard” means that the following problem is hard (practically impossible) to solve:</p>
<ol>
<li>Generate a vector of $512$ random numbers, each in the range $[0,3328]$, and call this $s$.</li>
<li>Generate a vector of $512$ random numbers, each in the range $[0,3328]$, and call this $a$.</li>
<li>Generate a random number, from the set $\{3326, 3327, 3328, 0, 1, 2, 3\}$, and call this $e$.</li>
<li>Compute $b = a\cdot s + e$, where $\cdot$ is the dot product.</li>
<li>Output $(a,b)$.</li>
<li>You may repeat steps 2-5, getting a new $(a, b)$ each time, as many times as you want.</li>
<li>Figure out $s$.</li>
</ol>
<!-- raw HTML omitted -->
<p>So far, we’ve looked at a “search” version of the LWE problem - we are trying to ‘find’ $s$ given noisy samples. To build encryption using LWE, it will be useful to work with a related version of LWE which we’ll call the “distinguishing” problem, which is also considered hard. In this version of the problem, we have to ‘tell the difference’ between an $(A, b)$ where $b=As+e$, as above, and an $(A, b)$ where $b$ was picked totally randomly. That is, we are given $(A, b)$, and we need to output a guess as to whether $b$ was sampled the ‘LWE way’, or whether $b$ was sampled randomly. What cryptographers hypothesize is that, for the the same choices of $n$ and $q$ as before, there is no algorithm that can output a correct guess with better than extremely low ($&gt;2^{-128}$) probability. The assumption that this problem is hard, which we can use to build cryptography, is called the decision LWE assumption, or ‘DLWE’ (the decision variant was actually proven to be equivalent to the search variant in most cases, so it is often also referred to as ‘LWE’).</p>
<p>To be concrete, let’s try to formalize our definition of the DLWE assumption. If we have the following functions in pseudocode:</p>
<div><pre><code data-lang="py"><span>def</span> <span>sample_true</span>():
    A <span>=</span> random_matrix(n, n)
    s <span>=</span> random_vector(n)
    e <span>=</span> random_noise_vector(n)
    b <span>=</span> A <span>*</span> s <span>+</span> e
    <span>return</span> (A, b)

<span>def</span> <span>sample_random</span>():
    A <span>=</span> random_matrix(n, n)
    b <span>=</span> random_vector(n)
    <span>return</span> (A, b)
</code></pre></div><p>Then we can first informally state the assumption as:</p>
<blockquote>
<p>It is “hard” to tell the difference between the outputs of <code>sample_true()</code> and <code>sample_random()</code>.</p>
</blockquote>
<p>Let’s try formalize this statement. Say we are given an algorithm <code>algorithm</code> that takes in the result of calling either <code>sample_true()</code> or <code>sample_random()</code>, and outputs a bit indicating a guess for which function produced it (say <code>0</code> means <code>sample_true()</code>, and <code>1</code> means <code>sample_random()</code>). Now, we’d like to quantitatively measure how well <code>algorithm</code> can “tell the difference” between the functions. We can run the following experiment on it many times:</p>
<a id="experiment"></a>
<div><pre><code data-lang="py"><span>def</span> <span>experiment</span>(algorithm):
    bit <span>=</span> random_bit()
    <span>if</span> bit <span>==</span> <span>0</span>:
        guess <span>=</span> algorithm(sample_true())
    <span>else</span>:
        guess <span>=</span> algorithm(sample_random())

    <span>return</span> guess <span>==</span> bit
</code></pre></div><p>The probability that <code>experiment</code> returns true will be something between 1/2 and 1 (we know it is at least 1/2, since even an <code>algorithm</code> that just always outputted <code>1</code> would be correct half of the time). The higher this probability, the better <code>algorithm</code> is at “telling the difference”. Now, we can state the DLWE assumption formally:</p>
<blockquote>
<p>The DLWE assumption for a security parameter $\lambda$ is: for <em>any</em> <code>algorithm</code> that performs less than $2^\lambda$ operations, <code>experiment(algorithm)</code> will succeed with a probability less than $1/2 + 2^{-\lambda}$.</p>
</blockquote>
<p>The <em>security parameter</em> $\lambda$ captures formally the idea of it being “very hard” to distinguish the outputs of these functions - for example, if the DLWE assumption holds for $\lambda=128$, then any attacker that can perform less than $2^{128}$ operations cannot effectively distinguish <code>sample_true()</code> from <code>sample_random()</code>. This concept of LWE samples being “computationally indistinguishable from random” is the key property that makes them useful for encryption. The word “operation” in our definition is a bit quishy - let’s just think of this as some kind of basic addition or multiplication, or if you prefer, a logicial gate in a circuit representing the computation.</p>
<p>I will omit a deeper explanation of <em>why</em> the DLWE assumption holds, and under which parameters. This is a still-active area of research, and the mathematics is complicated. We will just assume that for some choices of $n$, $q$, and the noise distributuion, DLWE is completely infeasible to solve.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="regevs-scheme-homomorphic-encryption-from-lwe">Regev’s Scheme: Homomorphic Encryption from LWE</h2>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>Now that we understand LWE, let’s see how we can use it to build homomorphic encryption. To start, we will just use LWE to build normal encryption, and then afterwards, we’ll try to make it homomorphic.</p>
<p>Say we have a secret key $s$, sampled uniformly at random from $\Z_q$. Then the DLWE assumption states that, for a random matrix $A$ and noise vector $e$, the vector $b=As+e$ is indistinguishable from random. How can we use this to build encryption?</p>
<p>Let’s start simply and assume we’d like to encrypt a single bit $x\in \{0,1\}$. How can we use the fact that $b$ is indistinguishable from random to encrypt $x$? Well, if I sampled a truly uniform random element $r$ from $\Z_q$, and then gave you $r + x$, you would have no hope of learning anything about $x$ (remember that $\Z_q$ is the integers mod q, so it “wraps around”). This is because $r$ is chosen randomly, so no matter what $x$ is, $r+x$ still “looks” random; cryptographers call this “blinding”.</p>
<p>Now, we know that $(A,b)$ is not actually random; but, by the DLWE assumption, to an attacker that does not no the secret key, it might as well be - it is indistinguishable (in a feasible amount of operations) from random. Let’s try to blind $x$ using $(A,b)$. Since $x$ is just a bit, we’ll want to set our $m=1$ for encryption - this makes $b$ a single value in $\Z_q$, so that we can encrypt $x$ as the ciphertext $(A, c = b + x)$.</p>
<p>Then what if we encrypt the message $x$ with the ciphertext $(A, c = b + x)$? We can make a very convoluted argument (a proof by contradiction) that, by the DLWE assumption, $(A, c)$ does not reveal anything about $x$. If proofs make you fall asleep, feel free to skip it; it’s not important for the rest of our explanation.</p>
<details open=""><summary>Proof</summary>
  <div>
    <blockquote>
<p>Say there was an algorithm <strong><code>algA</code></strong> that could figure out $x$ from $(A, c = b + x)$, where $(A,b)$ is an LWE sample, and $x$ is a single bit. Then we can construct an algorithm <strong><code>algB</code></strong> that can “break” DLWE. Specifically:</p>
<div><pre><code data-lang="py"><span>def</span> <span>algB</span>((A, b)):
  x <span>=</span> random_bit()
  guess <span>=</span> algA(A, b <span>+</span> x)
  <span>if</span> guess <span>==</span> x:
      <span>return</span> <span>0</span>
  <span>else</span>:
      <span>return</span> <span>1</span>
</code></pre></div><p>Recall that to “break” DLWE, we need to run the <code>experiment</code> function (<a href="#experiment">see above</a>) on <strong><code>algB</code></strong>, many times, and have it succeed more than with a probability significantly larger than $1/2$ (specifically, larger than $1/2 + 1/2^{128}$). Now, let’s walk through what happens when we run <code>experiment(</code><strong><code>algB</code></strong><code>)</code>, depending on the <code>bit</code> chosen in the first line of <code>experiment</code>:</p>
<ul>
<li>If <code>bit</code> in <code>experiment</code> is <code>0</code>, then we will pass <strong><code>algB</code></strong> a “true” LWE sample, and (by assumption) <strong><code>algA</code></strong> will work correctly, so <code>guess == x</code>, and we will return <code>0</code>.</li>
<li>If <code>bit</code> in <code>experiment</code> is <code>1</code>, so we pass <strong><code>algB</code></strong> a completely random <code>(A, b)</code>. Then we also end up passing in two random values to <strong><code>algA</code></strong>; since the input is completely random, <strong><code>algA</code></strong> must guess correctly exactly half the time, so we will output a random bit.</li>
</ul>
<p>To summarize, if <code>bit</code> is <code>0</code>, then <strong><code>algB</code></strong> will always correctly output <code>0</code>, and <code>experiment</code> will return <code>True</code>. If the <code>bit</code> is <code>1</code>, then <strong><code>algB</code></strong> will output a random bit, and so <code>experiment</code> will return <code>True</code> with probability 1/2. Then the total probability that the <code>experiment</code> returns <code>True</code> is $(1/2)\cdot 1 + (1/2)\cdot(1/2)=3/4$.</p>
<p>Since $3/4$ is (much) bigger than $1/2 + 1/2^{128}$, <strong><code>algB</code></strong> breaks the DLWE assumption.</p>
<p>We have shown that any efficient algorithm that could figure out $x$ from $(A, c = b + x)$ would violate the DLWE assumption. Then, since we assume DLWE is true, no efficient (running in less than $2^{128}$ operations) algorithm can figure out $x$ from $(A, c = b + x)$.</p>
</blockquote>

  </div>
</details>
<p>If the above proof is interesting to you, then you might really like academic cryptography - this <a href="https://crypto.stanford.edu/~dabo/courses/OnlineCrypto/">online cryptography class from Stanford</a> is a great introduction. The above kind of proof is called a “security reduction”, since it ‘reduces’ the security of the encryption scheme to the DLWE problem. The basic outline of the argument is:</p>
<ol>
<li>We first show: “If you break our scheme, then you can break DLWE”</li>
<li>Then we have really also proved the contrapositive: “If it’s difficult to break DLWE, then it must be difficult to break our scheme”</li>
</ol>
<p>If the above proof seems like a very complicated way to express something simple, you might still like cryptography, but maybe not the proofs…</p>
<p>So, you should now be convinced that just adding our message $x$ to $b$ in the LWE sample gives us a ciphertext $(A, c = b + x)$ that reveals nothing about $x$ to an attacker. We are missing the other piece, though - how do we actually decrypt this ciphertext using the secret key?</p>
<p>To decrypt the ciphertext $(A, c)$ using secret key $s$, we can compute $c - As$, and get:
$$
\begin{aligned}
c - As &amp;= (b + x) - As \cr
&amp;= ((As + e) + x) - As \cr
&amp;= x + e
\end{aligned}
$$</p>
<p>This gives us something very close to what we want. Our goal is recover $x$, but we have gotten $x + e$. Recall that $e$ is some noise, sampled from the noise distribution, so it is not uniformly random. Still, since $x\in\{0, 1\}$, we’re not going to be able to extract the message $x$ out of the value $x+e$, since our noise distribution is a centered distribution with small range. Recall our example parameters of $n=512$, $q=3329$, and a noise distribution of $[-3, 3]$; it is not possible to recover $x$ given $x+e$, since $x$ is 0 or 1, and $e$ is a random integer between -3 and 3.</p>
<p>So, we have to make a small change to how we encode the message $x$ in the ciphertext. Instead of just directly adding our message value of 0 or 1 ($c=b+x$), let’s add a “scaled up” version of our message: we will encrypt the message in the ciphertext as
$$c = b + \lfloor q/2 \rfloor \cdot x$$</p>
<p>Here, the value $\lfloor q/2 \rfloor$ is $q$ divided by 2, rounded down to the nearest integer. The point of doing this is that now, when we decrypt with $c-As$, we will now get $\lfloor q/2 \rfloor \cdot x + e$. If $e$ is sampled from a small range, much smaller than $\lfloor q/2 \rfloor$, then it’s now possible to recover $x$ from $x+e$ - we just need to “discard the low bits” of noise. Basically, we should see if $x+e$ is closer to $q/2$, in which case $x=1$, or $0$, in which case $x=0$. Concretely, we can calculate $x = \lfloor (x+e)\cdot 2 / q \rceil$, where $\lfloor \cdot \rceil$ just denotes rounding. As long as $e$ is within the range $[-q/4, q/4]$, the decryption will be correct.</p>
<p><img src="https://blintzbase.com/images/decryption2.png" alt="Decryption ranges"/></p>
<p>So, our full scheme (a version of Regev’s original one) looks like:</p>
<div><pre><code data-lang="py">n <span>=</span> <span>512</span>
q <span>=</span> <span>3329</span>
noise_distribution <span>=</span> [<span>-</span><span>3</span>, <span>3</span>]

<span>def</span> <span>get_LWE_sample</span>(s):
    A <span>=</span> random_matrix(n, n)
    e <span>=</span> random_noise_vector(n)
    b <span>=</span> A <span>*</span> s <span>+</span> e
    <span>return</span> (A, b)

<span>def</span> <span>keygen</span>():
    s <span>=</span> random_vector(n)
    <span>return</span> s

<span>def</span> <span>encrypt</span>(s, x):
    <span>assert</span> x <span>==</span> <span>0</span> <span>or</span> x <span>==</span> <span>1</span>
    (A, b) <span>=</span> get_LWE_sample(s)
    c <span>=</span> b <span>+</span> floor(q <span>/</span> <span>2</span>) <span>*</span> x
    <span>return</span> (A, c)

<span>def</span> <span>decrypt</span>(s, (A, c)):
    raw <span>=</span> c <span>-</span> A <span>*</span> s
    <span>return</span> round(raw <span>*</span> <span>2</span> <span>/</span> q)
</code></pre></div><div>
<p>Notice that the ciphertexts in this scheme are very large compared to what they encrypt. To encrypt <em>a single bit</em>, our scheme takes $(n+1) \log_2 q = 6003$ bits! This is much worse than AES, for example, where ciphertexts are basically the same size as plaintexts. There are effective techniques to make the ciphertext sizes in LWE-base encryption smaller, but we won’t cover them in this post.</p></div>

<h3 id="homomorphic-addition">Homomorphic addition</h3>
<p>So, we’ve constructed a “confidential” scheme, and now we’d like to make it homomorphic - this was the entire point of learning about LWE and Regev’s scheme!</p>
<p>The good news is we don’t have to do much. Let’s say we have two ciphertexts $(A_1, c_1)$ and $(A_2, c_2)$ which encrypt messages $m_1$ and $m_2$, all under the secret key $s$. Then we know that the following will be true, for some noises $e_1$ and $e_2$:</p>
<p>$$
\begin{aligned}
c_1 - A_1 s &amp;= \lfloor q/2 \rfloor \cdot m_1 + e_1 \cr
c_2 - A_2 s &amp;= \lfloor q/2 \rfloor \cdot m_2 + e_2
\end{aligned}
$$</p>
<p>Basically, we are rewriting the fact that if you decrypt $(c_1, A_1)$, you will get $m_1$, and similiarly for $(c_2, A_2)$.</p>
<p>Then what happens if we just naively add the ciphertexts? We can construct a new ciphertext by just adding the $A$ and $c$ components separately: $(A_3=A_1 + A_2,~c_3=c_1+c_2)$. If we try to decrypt it:</p>
<p>$$
\begin{aligned}
c_3 - A_3 s &amp;= (c_1 + c_2) - (A_1 + A_2) s \cr
&amp;= c_1 - A_1 s + c_2 - A_2 s \cr
&amp;= \lfloor q/2 \rfloor \cdot m_1 + e_1 + \lfloor q/2 \rfloor \cdot m_2 + e_2 \cr
&amp;= \lfloor q/2 \rfloor \cdot (m_1 + m_2) + e_1 + e_2
\end{aligned}
$$</p>
<p>We get the sum of the messages, $m_1 + m_2$, with noise $e_1 + e_2$. This is exactly what we want! This means if we add a ciphertext for $1$ and a ciphertext for $0$, we will get a new ciphertext for $1$. When we add two ciphertexts, both encoding $1$&#39;s, we will get a ciphertext encoding $0$ (the messages are bits, and the addition of bits gets performed like a XOR operation) <sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>.</p>
<p>Now, we could send the server a bunch of encrypted bits, and it could respond with the XOR of all of these bits, without ever learning the input bits or the output bit. Essentially, we could “outsource” the computation (just XOR’ing all the bits)</p>
<p>A really interesting thing is happening to the noise when we do homomorphic addition. Remember that for our example parameters, the noise distribution is $[-3,3]$. This means that both $e_1$ and $e_2$ fall in the range $[-3, 3]$. But what about their sum, $e_1 + e_2$? Well, their sum can fall in a wider range, $[-6, 6]$. Luckily, even this is not a wide enough range to make our message bit unrecoverable - we chose $q=3329$, and as long as the noise is less than $\lfloor q/4 \rfloor=832$, we should decrypt properly. But, notice that this is not an unlimited budget; if we kept adding up ciphertexts, we would eventually have a noise range that exceeded $q/4$. At that point, if we tried to decrypt, there’s a chance we would get an <em>incorrect</em> message.</p>
<p>If we add more than $278$ ciphertexts ($278 \cdot 3 &gt; q/4$), there is a (very small) chance that decryption could fail. If you enjoy statistics, you could try using the <a href="https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution">Irwin-Hall Distribution</a> to figure out the exact probability of decryption becoming incorrect given some number of ciphertext additions.</p>
<p>This idea that the noise “grows” as you perform homomorphic operations on the ciphertexts is fundamental - one main challenge of homomorphic encryption is controlling “noise growth” to be able to perform computation without letting the noise grow so large that you end up with incorrect results.</p>
<!-- raw HTML omitted -->
<p>So, we have achieved <strong>homomorphic addition</strong>! As we outlined at the beginning, this is one crucial property needed to build PIR.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="homomorphic-plaintext-multiplication">Homomorphic plaintext multiplication</h3>
<!-- raw HTML omitted -->
<p>Recall the two key properties that we wanted from a homomorphic encryption scheme:</p>
<ul>
<li><strong>Homomorphic addition</strong>: If the ciphertext $c_1$ encrypts $m_1$, and the ciphertext $c_2$ encrypts $m_2$, then $c’ = c_1 + c_2$ encrypts the value $m_1 + m_2$.</li>
<li><strong>Homomorphic plaintext multiplication</strong>: If the ciphertext $c_1$ encrypts $m_1$ and we have some other plaintext $m_2$, then $c’ = c_1 * m_2$ encrypts the value $m_1 * m_2$.</li>
</ul>
<p>We’ve already shown how to achieve <strong>homomorphic addition</strong>. Now, we can turn our attention to <strong>homomorphic plaintext multiplication</strong>.</p>
<p>Thinking more deeply about these two properties, you might notice that they are related. If you add a ciphertext to itself, this is equivalent to multiplying the ciphertext by the plaintext value ‘2’.</p>
<p>In our scheme that encrypts only bits, the relationship is actually even simpler. Remember that in our scheme so far, every plaintext value is just a bit. So, homomorphic plaintext multiplication really just entails being able to multiply a ciphertext by a <em>plaintext</em> $0$ or $1$. As it turns out, these are straightforward already: to multiply a ciphertext by the plaintext $0$, just zero out the entire ciphertext, and to multiply a ciphertext by the plaintext $1$, just don’t do anything to the ciphertext. So, we already have <strong>homomorphic plaintext multiplication</strong>! Now, we have all the components needed to finally build PIR.</p>
<!-- raw HTML omitted -->
<h2 id="back-to-pir-finally">Back to PIR, finally</h2>
<p>We now have a complete and secure PIR scheme, though it is quite inefficient. Here is the complete scheme in action:</p>
<div><pre><code data-lang="py">n <span>=</span> <span>512</span>
q <span>=</span> <span>3329</span>
noise_distribution <span>=</span> [<span>-</span><span>3</span>, <span>3</span>]

num_items_in_db <span>=</span> <span>50</span>
desired_idx <span>=</span> <span>24</span>
db <span>=</span> [random_bit() <span>for</span> i <span>in</span> range(num_items_in_db)]

<span>def</span> <span>generate_query</span>(desired_idx):
    v <span>=</span> []
    <span>for</span> i <span>in</span> range(num_items_in_db):
        bit <span>=</span> <span>1</span> <span>if</span> i <span>==</span> desired_idx <span>else</span> <span>0</span>
        ct <span>=</span> encrypt(s, bit)
        v<span>.</span>append(ct)
    <span>return</span> v

<span>def</span> <span>answer_query</span>(query, db):
    summed_A <span>=</span> zero_matrix(n, n)
    summed_c <span>=</span> zero_vector(n)
    <span>for</span> i <span>in</span> range(num_items_in_db):
        <span>if</span> db[i] <span>==</span> <span>1</span>:
            (A, c) <span>=</span> query[i]
            summed_A <span>+=</span> A
            summed_c <span>+=</span> c
    <span>return</span> (summed_A, summed_c)

s <span>=</span> keygen()
query <span>=</span> generate_query(desired_idx)

<span>print</span>(<span>&#34;Sending the query to the server...&#34;</span>)

answer <span>=</span> answer_query(query, db)

<span>print</span>(<span>&#34;Got the answer back from the server...&#34;</span>)

result <span>=</span> decrypt(s, answer)

<span>print</span>(<span>&#34;The item at index </span><span>%d</span><span> of the database is </span><span>%d</span><span>&#34;</span>, desired_idx, result)

<span>assert</span> result <span>==</span> db[desired_idx]
<span>print</span>(<span>&#34;PIR was correct!&#34;</span>)
</code></pre></div><p>You can also <a href="https://replit.com/@blintzbase/Toy-PIR">run this code in your browser</a> and try it out yourself! It’s 200 lines of Python with zero dependencies.</p>
<p>To privately retrieve a single bit (again, it’s not very efficient…) from the database, we upload a vector of ciphertexts encrypting bits (where only one encrypts a $1$, and the rest encrypt $0$&#39;s), multiply each one by a plaintext database bit, and then add it all up. The final ciphertext can get sent back to the client, and when they decrypt they will get the desired database bit.</p>
<p>We should take a moment to savor how we have actually solved a problem using cryptography that intuition would imply might be <em>totally impossible</em>. It really is not intuitive that there is <em>any</em> way to <em>privately</em> get a subset of the data on a server without just downloading everything. We also learned from the ground up <em>why</em> this scheme is secure, and how we could prove this formally.</p>
<p>Of course, before we congratulate ourselves too much, we might realize our scheme is quite impractical. There are several glaring problems:</p>
<ul>
<li>You have to upload more data (in the query) than the size of the entire database (!)</li>
<li>You can only retrieve one bit at a time</li>
</ul>
<p>The barriers to practicality for PIR are formidable; so formidable, in fact, that as recently as 2007, <a href="https://zxr.io/research/sion2007pir.pdf">researchers hypothesized that PIR might <em>never</em> be practical</a> for any real-world scenario.</p>
<p>The wonderful news is that the research has come a long way, and there are now many practical and efficient PIR schemes!
See <a href="https://github.com/menonsamir/spiral-rs">Spiral</a>, <a href="https://github.com/ahenzinger/simplepir">SimplePIR/DoublePIR</a>, <a href="https://github.com/mhmughees/Onion-PIR">OnionPIR</a>, <a href="https://github.com/ishtiyaque/FastPIR">FastPIR</a>, <a href="https://github.com/microsoft/SealPIR">SealPIR</a>, <a href="https://github.com/XPIR-team/XPIR">XPIR</a>, and more.</p>
<p>Making the toy scheme we’ve outlined here practical and efficient is no small task, so I will save that for another post. I will show how we can use homomorphic multiplication to make the queries smaller, and how we can extend the scheme to encrypt more than just a single bit per ciphertext. In the meantime, try <a href="https://spiralwiki.com/">reading Wikipedia</a> or <a href="https://btc.usespiral.com/">checking a Bitcoin address balance</a> using PIR. If you have questions or comments, email me at <a href="mailto:founders@usespiral.com">founders@usespiral.com</a> or tweet <a href="https://twitter.com/SpiralPrivacy">@SpiralPrivacy</a>.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->

</article>

        </div></div>
  </body>
</html>
