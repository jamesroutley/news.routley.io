<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://welltypedwit.ch/posts/value-restriction">Original</a>
    <h1>Violating memory safety with Haskell&#39;s value restriction</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <span>17 May 2025</span>
        
<p>A common issue in impure ML-style languages with polymorphism and
mutable references is the possibility of <em>polymorphic
references</em>.</p>
<p>In a hypothetical impure language that had both these features, but
no mitigations against polymorphic references, the following code would
be extremely unsafe.</p>
<div id="cb1"><pre><code><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span>unsafeCoerce ::</span> a <span>-&gt;</span> b</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>unsafeCoerce x <span>=</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span>let</span> dangerous <span>=</span> ref <span>Nothing</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    dangerous <span>:=</span> <span>Just</span> x</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span>case</span> dangerous <span>of</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span>Nothing</span> <span>-&gt;</span> <span>error</span> <span>&#34;unreachable&#34;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span>Just</span> y <span>-&gt;</span> y</span></code></pre></div>
<p>This code creates a reference <code>dangerous</code> with an initial
value of <code>Nothing</code>, writes <code>x</code> to it, and then
reads from it again. But because this language doesn’t prevent
polymorphic references and <code>Nothing</code> has type
<code>forall a. Maybe a</code>, <code>dangerous</code> is actually
<em>generalized</em> to <code>forall a. Ref (Maybe a)</code>. This means
that in the line that writes to it, <code>dangerous</code> is
instantiated to <code>Maybe a</code>, whereas in the line that
<em>reads</em> from it, it is instantiated to <code>Maybe b</code>,
although the value stored in it still has type <code>a</code>, breaking
type safety and consequently memory safety!</p>
<p>Scary, right?</p>
<p>You might think that you could prevent this by just preventing
generalization of reference types, but references can be hidden behind
closures, so languages need a slightly blunter hammer: the <em>value
restriction</em>.</p>
<p>The value restriction says that a let binding can only ever be given
a polymorphic type if its bound expression is syntactically a “value”,
i.e. an expression that obviously will not perform any computation.
<code>5</code> is a value. So is <code>Nothing</code>. But
<code>sqrt 42</code> and (crucially) <code>ref Nothing</code> are
<em>not</em> values and will not be generalized.<a href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<h2 id="haskells-let-bindings-do-not-have-a-value-restriction.">Haskell’s
let bindings do not have a value restriction.</h2>
<p>So, does this mean that Haskell’s type system is deeply unsound and
we just never noticed?</p>
<p>No! If we translate the original example to Haskell, we will hit a
type error, telling us that <code>dangerous</code> was <em>not</em>
generalized.</p>
<div id="cb2"><pre><code><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span>unsafeCoerce ::</span> a <span>-&gt;</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>unsafeCoerce x <span>=</span> <span>do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dangerous <span>&lt;-</span> newIORef <span>Nothing</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    writeIORef dangerous (<span>Just</span> x)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    result <span>&lt;-</span> readIORef dangerous</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span>case</span> result <span>of</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span>Nothing</span> <span>-&gt;</span> <span>error</span> <span>&#34;unreachable&#34;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span>Just</span> y <span>-&gt;</span> y</span></code></pre></div>
<!-- ghc output -->
<pre><div><p><span>MonadGen.hs:82:19: </span><span>error</span><span>: [</span><span>GHC-25897</span><span>]</span><span>
</span></p><p><span></span><span>    • Couldn&#39;t match type ‘a’ with ‘b’</span></p><p><span></span><span>      Expected: IO b</span></p><p><span>        Actual: IO a</span></p></div></pre>
<!-- /ghc output -->
<p>But the interesting question here is: <em>Why</em> was it not
generalized? To answer that, we will have to take a small step back.</p>
<h2 id="what-even-is-an-io">What even is an IO</h2>
<p>The important detail in this Haskell code is that
<code>dangerous</code> was <em>not</em> bound in a <code>let</code>
binding. It was bound in a monadic <code>do</code>-binding.</p>
<p><code>IO</code> is famously a monad, so a <code>do</code>-binding
like this is just syntactic sugar for an application of
<code>(&gt;&gt;=)</code>, which (specialized to <code>IO</code>) has the
following type.</p>
<div id="cb3"><pre><code><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span>(&gt;&gt;=) ::</span> <span>forall</span> a b<span>.</span> <span>IO</span> a <span>-&gt;</span> (a <span>-&gt;</span> <span>IO</span> b) <span>-&gt;</span> <span>IO</span> b</span></code></pre></div>
<p>So the value passed to the continuation (corresponding to the
variable in the let binding) has whatever type is wrapped
<em>inside</em> the <code>IO</code> type constructor of its first
argument.</p>
<p>Now, <code>newIORef Nothing</code> can itself have a polymorphic
type.</p>
<div id="cb4"><pre><code><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>newIORef <span>Nothing</span><span> ::</span> <span>forall</span> a<span>.</span> <span>IO</span> (<span>IORef</span> (<span>Maybe</span> a))</span></code></pre></div>
<p>However, notice that the polymorphic forall quantifier occurs
<em>outside</em> the <code>IO</code>! This means that the value passed
to the continuation of <code>(newIORef Nothing &gt;&gt;=)</code> will
always have type <code>IORef _</code> and therefore be
<em>monomorphic</em>. We can instantiate the <code>a</code> with
<code>forall a. Maybe a</code>, but that only gives us a perfectly safe
<code>IORef (forall a. Maybe a)</code><a href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a>,
<em>not</em> a <code>forall a. IORef (Maybe a)</code>.</p>
<p>That’s the magic! The placement of the <code>IO</code> in the types
prevents giving <code>dangerous</code> a polymorphic type.</p>
<p>What I really want you to appreciate here is just how similar this is
to the traditional value restriction. If we’re allowed to do arbitrary
effects, we might create a polymorphic reference, so ML bans all let
bindings that look like they might perform effects, whereas Haskell
already has a distinction between pure and effectful let bindings
(<code>&gt;&gt;=</code>) and just needs to prevent the second group from
being generalized.</p>
<h2 id="generalizable-monads">Generalizable Monads</h2>
<p>This hopefully all seems reasonable so far. <code>IO</code> can
create mutable references so we need to prevent it from generalizing
them and that’s why the monadic interface imposes something resembling
the value restriction.</p>
<p>But… <code>IO</code> is not the only monad. If we look at <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor-Identity.html#t:Identity"><code>Identity</code></a>,
it’s a monad that quite literally does nothing, so a
<code>do</code>-binding in <code>Identity</code> is just a pure
<code>let</code>-binding. Shouldn’t we at least be able to generalize
<code>do</code>-bindings in a trivial monad like this?</p>
<p>Let’s think through what that would mean. Above, we couldn’t
generalize <code>newIORef Nothing</code> because it had type
<code>forall a. IO (IORef (Maybe a))</code> with the <code>forall</code>
on the <em>outside</em>. If it had type
<code>IO (forall a. IORef (Maybe a))</code>, we could instantiate the
<code>a</code> parameter to <code>(&gt;&gt;=)</code> with
<code>forall a. IORef (Maybe a)</code> and therefore generalize it.</p>
<p>Coming back to <code>Identity</code>, we can generalize Identity
bindings, if for any context <code>f</code>
(e.g. <code>f ~ IORef</code>), we can turn something of type
<code>forall a. Identity (f a)</code> into something of type
<code>Identity (forall a. f a)</code>. More generally, we can define a
type class for monads where we can generalize bindings this way.</p>
<div id="cb5"><pre><code><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span>class</span> (<span>Monad</span> m) <span>=&gt;</span> <span>MonadGen</span> m <span>where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span>    generalize ::</span> <span>forall</span> f<span>.</span> (<span>forall</span> a<span>.</span> m (f a)) <span>-&gt;</span> m (<span>forall</span> a<span>.</span> f a)</span></code></pre></div>
<p>So, can we define this for Identity? Yes!<a href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div id="cb6"><pre><code><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>MonadGen</span> <span>Identity</span> <span>where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    generalize m <span>=</span> <span>do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span>let</span> (<span>Identity</span> x) <span>=</span> m</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span>Identity</span> x</span></code></pre></div>
<p>If we use this new fancy function, our monadic bindings in
<code>Identity</code> can be just as powerful as regular let bindings!
(though a little less convenient since we need newtypes)</p>
<div id="cb7"><pre><code><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>Endo</span> a <span>=</span> <span>Endo</span> (a <span>-&gt;</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span>applyEndo ::</span> <span>Endo</span> a <span>-&gt;</span> a <span>-&gt;</span> a</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>applyEndo (<span>Endo</span> f) x <span>=</span> f x</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span>blah ::</span> <span>Identity</span> (<span>Bool</span>, <span>Char</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>blah <span>=</span> <span>do</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span>-- f :: forall a. Endo a &lt;- pure (Endo (\x -&gt; x))  -- fails</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span>    f ::</span> <span>forall</span> a<span>.</span> <span>Endo</span> a <span>&lt;-</span> generalize (<span>pure</span> (<span>Endo</span> (\x <span>-&gt;</span> x))) <span>-- succeeds</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span>pure</span> (applyEndo f <span>True</span>, applyEndo f <span>&#39;a&#39;</span>)</span></code></pre></div>
<p>Nice! Since we made this a type class, you’re probably already
wondering which other monads we can implement it for. Turns out, there
are actually quite a few! For reasons that will become apparent in a
moment, let’s look at…</p>
<h2 id="statestate">State<a href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></h2>
<p>The <code>State</code> monad in Haskell is defined as<a href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div id="cb8"><pre><code><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>State</span> s a <span>=</span> <span>State</span> (s <span>-&gt;</span> (s, a))</span></code></pre></div>
<p>In order to simulate mutable state, this definition represents
computations as functions that take the current state as a parameter and
return a new state value. As it turns out, if we just keep plumbing
those state values around, nothing stops us from binding the result of
this function in a let binding and thereby generalizing the result of
the computation!</p>
<div id="cb9"><pre><code><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>MonadGen</span> (<span>State</span> s) <span>where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    generalize m <span>=</span> <span>do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span>let</span> (<span>State</span> f) <span>=</span> m</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span>State</span> \s <span>-&gt;</span> <span>do</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span>let</span> (s&#39;, result) <span>=</span> f s</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            (s&#39;, result)</span></code></pre></div>
<p>Great! So it seems like many pure monads do support binding
generalization. Then there must be something about the internal
structure of <code>IO</code> that is somehow special and prevents us
from implementing <code>MonadGen IO</code>, right?</p>
<p>Right?</p>
<h2 id="what-is-an-io-really">What is an IO, <em>really</em>?</h2>
<p>A popular metaphor for impure functions in pure languages is that
instead of modifying the world around it, a function like
<code>putStrLn</code> essentially takes the real world as a parameter
and returns a modified version of it where a string has been written to
<code>stdout</code>. Interestingly enough, this is very close to how
<code>IO</code> works internally!</p>
<div id="cb10"><pre><code><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>IO</span> a <span>=</span> <span>IO</span> (<span>State</span><span>#</span> <span>RealWorld</span> <span>-&gt;</span> (<span>#</span> <span>State</span><span>#</span> <span>RealWorld</span>, a <span>#</span>))</span></code></pre></div>
<p>Of course, we cannot literally modify the real world as a pure value,
so internally, <code>putStrLn</code> is an actual, impure function.</p>
<p>But the <code>State#</code> values still act both as capabilities
(ensuring that impure functions can only be called from impure
functions) and data dependencies (to ensure that impure functions are
evaluated in the correct order despite laziness).</p>
<p>Using this constructor directly can be unsafe, since the illusion of
purely modifying the real world (and <code>IO</code>’s sequencing
guarantees) only apply if the <code>State# RealWorld</code> tokens are
passed around <em>linearly</em>, i.e. are never duplicated or dropped.
However, if we manually make sure to uphold this invariant and we don’t
use any further GHC internals, common knowledge suggests that we should
be safe.</p>
<h2 id="that-type-definition-looks-familiar">That type definition looks
familiar</h2>
<p>It uses an unboxed tuple instead of a boxed one and is specialized to
(zero-sized) unboxed <code>State# RealWorld</code> tokens, but otherwise
<code>IO</code> is really just a state monad! So, if we were able to
implement <code>MonadGen</code> for <code>State</code>, shouldn’t we be
able to implement it for <code>IO</code> as well?</p>
<p>If we tried to copy the <code>State</code> definition directly, we
would hit a quite awkwardly phrased error message<a href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div id="cb11"><pre><code><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>MonadGen</span> <span>IO</span> <span>where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    generalize m <span>=</span> <span>do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span>let</span> (<span>IO</span> f) <span>=</span> m</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span>IO</span> \s <span>-&gt;</span> <span>do</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            <span>let</span> (<span>#</span> s&#39;, result <span>#</span>) <span>=</span> f s</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            (<span>#</span> s&#39;, result <span>#</span>)</span></code></pre></div>
<pre><div><p><span></span><span>MonadGen.hs:51:17: </span><span>error</span><span>: [</span><span>GHC-20036</span><span>]</span></p><p><span></span><span>    You can&#39;t mix polymorphic and unlifted bindings:</span></p><p><span></span><span>      (# s&#39;, result #) = f s</span></p><p><span>    Suggested fix: Add a type signature.</span></p></div></pre>
<p>Unfortunately, the suggested fix doesn’t help us. Giving
<code>result</code> a polymorphic type is the whole point here!</p>
<p>Fortunately, we can just box the <code>State# RealWorld</code> token
first and avoid the issue.</p>
<div id="cb12"><pre><code><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span>data</span> <span>BoxedState</span> s <span>=</span> <span>BoxedState</span> {<span>state ::</span> <span>State</span><span>#</span> s}</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span>liftState ::</span> (<span>#</span> <span>State</span><span>#</span> s, b <span>#</span>) <span>-&gt;</span> (<span>BoxedState</span> s, b)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>liftState (<span>#</span> s, b <span>#</span>) <span>=</span> (<span>BoxedState</span> s, b)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span>instance</span> <span>MonadGen</span> <span>IO</span> <span>where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    generalize m <span>=</span> <span>do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span>let</span> (<span>IO</span> f) <span>=</span> m</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span>IO</span> \s <span>-&gt;</span> <span>do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span>let</span> (boxedState, result) <span>=</span> liftState (f s)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span>let</span> (<span>BoxedState</span>{state}) <span>=</span> boxedState</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            (<span>#</span> state, result <span>#</span>)</span></code></pre></div>
<p>And this compiles! So, does that mean…</p>
<h2 id="yes">Yes!</h2>
<div id="cb13"><pre><code><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span>newtype</span> <span>MaybeRef</span> a <span>=</span> <span>MaybeRef</span> (<span>IORef</span> (<span>Maybe</span> a))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span>unsafeCoerceIO ::</span> <span>forall</span> a b<span>.</span> a <span>-&gt;</span> <span>IO</span> b</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>unsafeCoerceIO x <span>=</span> <span>do</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    maybeRef <span>&lt;-</span> generalize (<span>MaybeRef</span> <span>&lt;$&gt;</span> newIORef <span>Nothing</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span>let</span> <span>MaybeRef</span> ref <span>=</span> maybeRef</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    writeIORef ref (<span>Just</span> x)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    readIORef ref <span>&gt;&gt;=</span> \<span>case</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span>Just</span> y <span>-&gt;</span> <span>pure</span> y</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span>Nothing</span> <span>-&gt;</span> <span>error</span> <span>&#34;unreachable&#34;</span></span></code></pre></div>

<div id="cb14"><pre><code><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>λ<span>&gt;</span> unsafeCoerceIO <span>@</span>_ <span>@</span><span>String</span> <span>id</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span>&#34;fish: Job 1, &#39;ghci MonadGen.hs&#39; terminated by signal SIGSEGV (Address boundary error)</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>What I want you to take away from this is that</p>
<ul>
<li>Despite its purity, Haskell <em>does</em> need something resembling
the value restriction, just like every other ML with references.</li>
<li>However, this value restriction is only given by the monadic
interface of <code>IO</code> and <em>not</em> inherent to its
definition.</li>
<li>Contrary to popular belief, unwrapping the <code>IO</code>
constructor is deeply unsafe and can violate memory safety, even if
<code>State#</code> tokens are never duplicated or dropped.</li>
</ul>

    </article></div>
  </body>
</html>
