<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/irony/aspipes">Original</a>
    <h1>Working pipe operator today in pure JavaScript</h1>
    
    <div id="readability-page-1" class="page"><div data-hpc="true"><article itemprop="text">

<p dir="auto">asPipes is an experimental runtime abstraction that models the semantics of the proposed |&gt; pipeline operator, implemented entirely in standard JavaScript (ES2020+).
It demonstrates that pipeline-style composition can be expressed using the existing coercion semantics of the bitwise OR operator (|) and Symbol.toPrimitive.</p>
<p dir="auto">The implementation is small (&lt;50 lines) and supports both synchronous and asynchronous evaluation with a familiar syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const greeting = pipe(&#39;hello&#39;);

greeting 
  | upper 
  | ex(&#39;!!!&#39;);

await greeting.run(); // → &#34;HELLO!!!&#34;"><pre><span>const</span> <span>greeting</span> <span>=</span> <span>pipe</span><span>(</span><span>&#39;hello&#39;</span><span>)</span><span>;</span>

<span>greeting</span> 
  <span>|</span> <span>upper</span> 
  <span>|</span> <span>ex</span><span>(</span><span>&#39;!!!&#39;</span><span>)</span><span>;</span>

<span>await</span> <span>greeting</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span> <span>// → &#34;HELLO!!!&#34;</span></pre></div>


<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span></pre></div>
<p dir="auto">⸻</p>

<p dir="auto">The pipeline operator proposal (tc39/proposal-pipeline-operator) has been under discussion for several years, exploring multiple variants (F#, Smart, Hack, etc.).
The asPipes experiment aims to:</p>
<ul dir="auto">
<li>prototype F#-style semantics directly in today’s JavaScript;</li>
<li>study ergonomics and readability in real-world code;</li>
<li>show that deferred, referentially transparent composition can be achieved without syntax extensions; and</li>
<li>inform the design conversation with practical, user-level feedback.</li>
</ul>
<p dir="auto">⸻</p>

<ul dir="auto">
<li>✅ Composable — each transformation behaves like a unary function of the previous result.</li>
<li>✅ Deferred — no execution until .run() is called.</li>
<li>✅ Async-safe — promises and async functions are first-class citizens.</li>
<li>✅ Stateless — no global mutation; every pipeline owns its own context.</li>
<li>✅ Ergonomic — visually aligns with the future |&gt; operator.</li>
</ul>
<p dir="auto">⸻</p>



<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span></pre></div>

<p dir="auto">Creates an isolated pipeline environment and returns:</p>
<div dir="auto" data-snippet-clipboard-copy-content="{
  pipe, // begin a pipeline
  asPipe // lift a function into a pipeable form
}"><pre><span>{</span>
  <span>pipe</span><span>,</span> <span>// begin a pipeline</span>
  <span>asPipe</span> <span>// lift a function into a pipeable form</span>
<span>}</span></pre></div>
<p dir="auto">pipe(initialValue)</p>
<p dir="auto">Begins a new pipeline with initialValue.
The returned object intercepts | operations via Symbol.toPrimitive.
Call .run() to evaluate and retrieve the final result (async).</p>
<p dir="auto">asPipe(fn)</p>
<p dir="auto">Wraps a function fn so that it can be used in a pipeline:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const upper = asPipe((s) =&gt; s.toUpperCase());
const ex = asPipe((s, mark = &#39;!&#39;) =&gt; s + mark);"><pre><span>const</span> <span>upper</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>s</span><span>)</span> <span>=&gt;</span> <span>s</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>ex</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>s</span><span>,</span> <span>mark</span> <span>=</span> <span>&#39;!&#39;</span><span>)</span> <span>=&gt;</span> <span>s</span> <span>+</span> <span>mark</span><span>)</span><span>;</span></pre></div>
<p dir="auto">Pipeable functions can also be called with arguments:</p>
<div dir="auto" data-snippet-clipboard-copy-content="pipe(&#39;hello&#39;) 
  | upper 
  | ex(&#39;!!!&#39;);"><pre><span>pipe</span><span>(</span><span>&#39;hello&#39;</span><span>)</span> 
  <span>|</span> <span>upper</span> 
  <span>|</span> <span>ex</span><span>(</span><span>&#39;!!!&#39;</span><span>)</span><span>;</span></pre></div>
<p dir="auto">.run()</p>
<p dir="auto">Evaluates the accumulated transformations sequentially, returning a Promise of the final value.</p>

<p dir="auto"><strong>A. String pipeline</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;

const { pipe, asPipe } = createAsPipes();

const upper = asPipe((s) =&gt; s.toUpperCase());
const ex = asPipe((s, mark = &#39;!&#39;) =&gt; s + mark);

const greeting = pipe(&#39;hello&#39;);
greeting 
  | upper 
  | ex(&#39;!!!&#39;);
  
console.log(await greeting.run()); // &#34;HELLO!!!&#34;"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span>

<span>const</span> <span>{</span> pipe<span>,</span> asPipe <span>}</span> <span>=</span> <span>createAsPipes</span><span>(</span><span>)</span><span>;</span>

<span>const</span> <span>upper</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>s</span><span>)</span> <span>=&gt;</span> <span>s</span><span>.</span><span>toUpperCase</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>ex</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>s</span><span>,</span> <span>mark</span> <span>=</span> <span>&#39;!&#39;</span><span>)</span> <span>=&gt;</span> <span>s</span> <span>+</span> <span>mark</span><span>)</span><span>;</span>

<span>const</span> <span>greeting</span> <span>=</span> <span>pipe</span><span>(</span><span>&#39;hello&#39;</span><span>)</span><span>;</span>
<span>greeting</span> 
  <span>|</span> <span>upper</span> 
  <span>|</span> <span>ex</span><span>(</span><span>&#39;!!!&#39;</span><span>)</span><span>;</span>
  
<span>console</span><span>.</span><span>log</span><span>(</span><span>await</span> <span>greeting</span><span>.</span><span>run</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// &#34;HELLO!!!&#34;</span></pre></div>
<p dir="auto"><strong>B. Numeric pipeline</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;

const { pipe, asPipe } = createAsPipes();

const inc = asPipe((x) =&gt; x + 1);
const mul = asPipe((x, k) =&gt; x * k);

const calc = pipe(3);
calc 
  | inc 
  | mul(10);

console.log(await calc.run()); // 40"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span>

<span>const</span> <span>{</span> pipe<span>,</span> asPipe <span>}</span> <span>=</span> <span>createAsPipes</span><span>(</span><span>)</span><span>;</span>

<span>const</span> <span>inc</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>const</span> <span>mul</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>x</span><span>,</span> <span>k</span><span>)</span> <span>=&gt;</span> <span>x</span> <span>*</span> <span>k</span><span>)</span><span>;</span>

<span>const</span> <span>calc</span> <span>=</span> <span>pipe</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>calc</span> 
  <span>|</span> <span>inc</span> 
  <span>|</span> <span>mul</span><span>(</span><span>10</span><span>)</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>await</span> <span>calc</span><span>.</span><span>run</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 40</span></pre></div>
<p dir="auto"><strong>C. Async composition (LLM API call)</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;

const { pipe, asPipe } = createAsPipes();

const postJson = asPipe((url, body, headers = {}) =&gt;
  fetch(url, {
    method: &#39;POST&#39;,
    headers: { &#39;content-type&#39;: &#39;application/json&#39;, ...headers },
    body: JSON.stringify(body),
  }),
);
const toJson = asPipe((r) =&gt; r.json());
const pick = asPipe((o, ...keys) =&gt; keys.reduce((a, k) =&gt; a?.[k], o));
const trim = asPipe((s) =&gt; (typeof s === &#39;string&#39; ? s.trim() : s));

const ENDPOINT = &#39;https://api.berget.ai/v1/chat/completions&#39;;
const BODY = {
  model: &#39;gpt-oss&#39;,
  messages: [
    { role: &#39;system&#39;, content: &#39;Reply briefly.&#39; },
    { role: &#39;user&#39;, content: &#39;Write a haiku about mountains.&#39; },
  ],
};

const haiku = pipe(ENDPOINT);
haiku 
| postJson(BODY) 
| toJson 
| pick(&#39;choices&#39;, 0, &#39;message&#39;, &#39;content&#39;) 
| trim;
console.log(await haiku.run());"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span>

<span>const</span> <span>{</span> pipe<span>,</span> asPipe <span>}</span> <span>=</span> <span>createAsPipes</span><span>(</span><span>)</span><span>;</span>

<span>const</span> <span>postJson</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>url</span><span>,</span> <span>body</span><span>,</span> <span>headers</span> <span>=</span> <span>{</span><span>}</span><span>)</span> <span>=&gt;</span>
  <span>fetch</span><span>(</span><span>url</span><span>,</span> <span>{</span>
    <span>method</span>: <span>&#39;POST&#39;</span><span>,</span>
    <span>headers</span>: <span>{</span> <span>&#39;content-type&#39;</span>: <span>&#39;application/json&#39;</span><span>,</span> ...<span>headers</span> <span>}</span><span>,</span>
    <span>body</span>: <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>body</span><span>)</span><span>,</span>
  <span>}</span><span>)</span><span>,</span>
<span>)</span><span>;</span>
<span>const</span> <span>toJson</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>r</span><span>)</span> <span>=&gt;</span> <span>r</span><span>.</span><span>json</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>pick</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>o</span><span>,</span> ...<span>keys</span><span>)</span> <span>=&gt;</span> <span>keys</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>a</span><span>,</span> <span>k</span><span>)</span> <span>=&gt;</span> <span>a</span><span>?.</span><span>[</span><span>k</span><span>]</span><span>,</span> <span>o</span><span>)</span><span>)</span><span>;</span>
<span>const</span> <span>trim</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>s</span><span>)</span> <span>=&gt;</span> <span>(</span><span>typeof</span> <span>s</span> <span>===</span> <span>&#39;string&#39;</span> ? <span>s</span><span>.</span><span>trim</span><span>(</span><span>)</span> : <span>s</span><span>)</span><span>)</span><span>;</span>

<span>const</span> <span>ENDPOINT</span> <span>=</span> <span>&#39;https://api.berget.ai/v1/chat/completions&#39;</span><span>;</span>
<span>const</span> <span>BODY</span> <span>=</span> <span>{</span>
  <span>model</span>: <span>&#39;gpt-oss&#39;</span><span>,</span>
  <span>messages</span>: <span>[</span>
    <span>{</span> <span>role</span>: <span>&#39;system&#39;</span><span>,</span> <span>content</span>: <span>&#39;Reply briefly.&#39;</span> <span>}</span><span>,</span>
    <span>{</span> <span>role</span>: <span>&#39;user&#39;</span><span>,</span> <span>content</span>: <span>&#39;Write a haiku about mountains.&#39;</span> <span>}</span><span>,</span>
  <span>]</span><span>,</span>
<span>}</span><span>;</span>

<span>const</span> <span>haiku</span> <span>=</span> <span>pipe</span><span>(</span><span>ENDPOINT</span><span>)</span><span>;</span>
<span>haiku</span> 
<span>|</span> <span>postJson</span><span>(</span><span>BODY</span><span>)</span> 
<span>|</span> <span>toJson</span> 
<span>|</span> <span>pick</span><span>(</span><span>&#39;choices&#39;</span><span>,</span> <span>0</span><span>,</span> <span>&#39;message&#39;</span><span>,</span> <span>&#39;content&#39;</span><span>)</span> 
<span>|</span> <span>trim</span><span>;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>await</span> <span>haiku</span><span>.</span><span>run</span><span>(</span><span>)</span><span>)</span><span>;</span></pre></div>
<p dir="auto"><strong>D. Composable pipes (Higher-Order Pipes)</strong></p>
<p dir="auto">Pipes can be composed into reusable, named higher-order pipes by wrapping them with <code>asPipe</code>. The implementation automatically detects and executes pipeline expressions, enabling clean, direct syntax:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;

const { pipe, asPipe } = createAsPipes();

// Assume postJson, toJson, pick, trim are defined (see example C)

// Create reusable bot operations
const askBot = asPipe((question) =&gt; {
  const p = pipe(&#39;https://api.berget.ai/v1/chat/completions&#39;);
  p 
  | postJson({
      model: &#39;gpt-oss&#39;,
      messages: [{ role: &#39;user&#39;, content: question }],
    }) 
  | toJson 
  | pick(&#39;choices&#39;, 0, &#39;message&#39;, &#39;content&#39;) 
  | trim;
  return p;
});

const summarize = asPipe((text) =&gt; {
  const p = pipe(&#39;https://api.berget.ai/v1/chat/completions&#39;);
  p 
  | postJson({
      model: &#39;gpt-oss&#39;,
      messages: [
        { role: &#39;system&#39;, content: &#39;Summarize in one sentence.&#39; },
        { role: &#39;user&#39;, content: text },
      ],
    }) 
  | toJson 
  | pick(&#39;choices&#39;, 0, &#39;message&#39;, &#39;content&#39;) 
  | trim;
  return p;
});

// Compose an agent that chains multiple bot operations
const researchAgent = asPipe((topic) =&gt; {
  const p = pipe(`Research topic: ${topic}`);
  p 
    | askBot 
    | summarize;
  return p;
});

// Use the composed agent in a pipeline
const result = pipe(&#39;quantum computing&#39;);
result 
  | researchAgent;

console.log(await result.run());
// First asks bot about quantum computing, then summarizes the response"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span>

<span>const</span> <span>{</span> pipe<span>,</span> asPipe <span>}</span> <span>=</span> <span>createAsPipes</span><span>(</span><span>)</span><span>;</span>

<span>// Assume postJson, toJson, pick, trim are defined (see example C)</span>

<span>// Create reusable bot operations</span>
<span>const</span> <span>askBot</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>question</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>p</span> <span>=</span> <span>pipe</span><span>(</span><span>&#39;https://api.berget.ai/v1/chat/completions&#39;</span><span>)</span><span>;</span>
  <span>p</span> 
  <span>|</span> <span>postJson</span><span>(</span><span>{</span>
      <span>model</span>: <span>&#39;gpt-oss&#39;</span><span>,</span>
      <span>messages</span>: <span>[</span><span>{</span> <span>role</span>: <span>&#39;user&#39;</span><span>,</span> <span>content</span>: <span>question</span> <span>}</span><span>]</span><span>,</span>
    <span>}</span><span>)</span> 
  <span>|</span> <span>toJson</span> 
  <span>|</span> <span>pick</span><span>(</span><span>&#39;choices&#39;</span><span>,</span> <span>0</span><span>,</span> <span>&#39;message&#39;</span><span>,</span> <span>&#39;content&#39;</span><span>)</span> 
  <span>|</span> <span>trim</span><span>;</span>
  <span>return</span> <span>p</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> <span>summarize</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>text</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>p</span> <span>=</span> <span>pipe</span><span>(</span><span>&#39;https://api.berget.ai/v1/chat/completions&#39;</span><span>)</span><span>;</span>
  <span>p</span> 
  <span>|</span> <span>postJson</span><span>(</span><span>{</span>
      <span>model</span>: <span>&#39;gpt-oss&#39;</span><span>,</span>
      <span>messages</span>: <span>[</span>
        <span>{</span> <span>role</span>: <span>&#39;system&#39;</span><span>,</span> <span>content</span>: <span>&#39;Summarize in one sentence.&#39;</span> <span>}</span><span>,</span>
        <span>{</span> <span>role</span>: <span>&#39;user&#39;</span><span>,</span> <span>content</span>: <span>text</span> <span>}</span><span>,</span>
      <span>]</span><span>,</span>
    <span>}</span><span>)</span> 
  <span>|</span> <span>toJson</span> 
  <span>|</span> <span>pick</span><span>(</span><span>&#39;choices&#39;</span><span>,</span> <span>0</span><span>,</span> <span>&#39;message&#39;</span><span>,</span> <span>&#39;content&#39;</span><span>)</span> 
  <span>|</span> <span>trim</span><span>;</span>
  <span>return</span> <span>p</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// Compose an agent that chains multiple bot operations</span>
<span>const</span> <span>researchAgent</span> <span>=</span> <span>asPipe</span><span>(</span><span>(</span><span>topic</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>p</span> <span>=</span> <span>pipe</span><span>(</span><span>`Research topic: <span><span>${</span><span>topic</span><span>}</span></span>`</span><span>)</span><span>;</span>
  <span>p</span> 
    <span>|</span> <span>askBot</span> 
    <span>|</span> <span>summarize</span><span>;</span>
  <span>return</span> <span>p</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// Use the composed agent in a pipeline</span>
<span>const</span> <span>result</span> <span>=</span> <span>pipe</span><span>(</span><span>&#39;quantum computing&#39;</span><span>)</span><span>;</span>
<span>result</span> 
  <span>|</span> <span>researchAgent</span><span>;</span>

<span>console</span><span>.</span><span>log</span><span>(</span><span>await</span> <span>result</span><span>.</span><span>run</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// First asks bot about quantum computing, then summarizes the response</span></pre></div>
<p dir="auto">This pattern demonstrates:</p>
<ul dir="auto">
<li><strong>Composability</strong>: Small pipes (<code>askBot</code>, <code>summarize</code>) combine into larger ones (<code>researchAgent</code>)</li>
<li><strong>Abstraction</strong>: Complex multi-step operations hidden behind simple interfaces</li>
<li><strong>Reusability</strong>: Each composed pipe can be used independently or as part of larger workflows</li>
</ul>
<p dir="auto"><strong>E. Stream processing with async generators (Functional Reactive Programming)</strong></p>
<p dir="auto">The asPipes library includes stream support for working with async generators, enabling functional reactive programming patterns:</p>
<div dir="auto" data-snippet-clipboard-copy-content="import { createAsPipes } from &#39;aspipes&#39;;
import { createStreamPipes, eventStream } from &#39;aspipes/stream.js&#39;;

const { pipe, asPipe } = createAsPipes();
const { map, filter, take, scan } = createStreamPipes(asPipe);

// Process an endless stream of events
async function* eventGenerator() {
  let id = 0;
  while (true) {
    yield { id: id++, type: id % 3 === 0 ? &#39;special&#39; : &#39;normal&#39; };
  }
}

// Take first 3 &#34;special&#34; events
const result = pipe(eventGenerator());
result 
  | filter((e) =&gt; e.type === &#39;special&#39;) 
  | map((e) =&gt; e.id) 
  | take(3);

const stream = await result.run();
for await (const id of stream) {
  console.log(id); // 0, 3, 6
}"><pre><span>import</span> <span>{</span> <span>createAsPipes</span> <span>}</span> <span>from</span> <span>&#39;aspipes&#39;</span><span>;</span>
<span>import</span> <span>{</span> <span>createStreamPipes</span><span>,</span> <span>eventStream</span> <span>}</span> <span>from</span> <span>&#39;aspipes/stream.js&#39;</span><span>;</span>

<span>const</span> <span>{</span> pipe<span>,</span> asPipe <span>}</span> <span>=</span> <span>createAsPipes</span><span>(</span><span>)</span><span>;</span>
<span>const</span> <span>{</span> map<span>,</span> filter<span>,</span> take<span>,</span> scan <span>}</span> <span>=</span> <span>createStreamPipes</span><span>(</span><span>asPipe</span><span>)</span><span>;</span>

<span>// Process an endless stream of events</span>
<span>async</span> <span>function</span><span>*</span> <span>eventGenerator</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> <span>id</span> <span>=</span> <span>0</span><span>;</span>
  <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>yield</span> <span>{</span> <span>id</span>: <span>id</span><span>++</span><span>,</span> <span>type</span>: <span>id</span> <span>%</span> <span>3</span> <span>===</span> <span>0</span> ? <span>&#39;special&#39;</span> : <span>&#39;normal&#39;</span> <span>}</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// Take first 3 &#34;special&#34; events</span>
<span>const</span> <span>result</span> <span>=</span> <span>pipe</span><span>(</span><span>eventGenerator</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>result</span> 
  <span>|</span> <span>filter</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>e</span><span>.</span><span>type</span> <span>===</span> <span>&#39;special&#39;</span><span>)</span> 
  <span>|</span> <span>map</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>e</span><span>.</span><span>id</span><span>)</span> 
  <span>|</span> <span>take</span><span>(</span><span>3</span><span>)</span><span>;</span>

<span>const</span> <span>stream</span> <span>=</span> <span>await</span> <span>result</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
<span>for</span> <span>await</span> <span>(</span><span>const</span> <span>id</span> <span>of</span> <span>stream</span><span>)</span> <span>{</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>id</span><span>)</span><span>;</span> <span>// 0, 3, 6</span>
<span>}</span></pre></div>
<p dir="auto"><strong>F. Mouse event stream processing</strong></p>
<div dir="auto" data-snippet-clipboard-copy-content="// Simulate mouse drag tracking
const events = [
  { type: &#39;mousedown&#39;, x: 10, y: 10 },
  { type: &#39;mousemove&#39;, x: 15, y: 15 },
  { type: &#39;mousemove&#39;, x: 20, y: 20 },
  { type: &#39;mouseup&#39;, x: 20, y: 20 },
];

let isDragging = false;
const trackDrag = (e) =&gt; {
  if (e.type === &#39;mousedown&#39;) isDragging = true;
  if (e.type === &#39;mouseup&#39;) isDragging = false;
  return isDragging &amp;&amp; e.type === &#39;mousemove&#39;;
};

const result = pipe(eventStream(events));
result 
  | filter(trackDrag) 
  | map((e) =&gt; ({ x: e.x, y: e.y }));

const stream = await result.run();
const positions = [];
for await (const pos of stream) {
  positions.push(pos); // [{ x: 15, y: 15 }, { x: 20, y: 20 }]
}"><pre><span>// Simulate mouse drag tracking</span>
<span>const</span> <span>events</span> <span>=</span> <span>[</span>
  <span>{</span> <span>type</span>: <span>&#39;mousedown&#39;</span><span>,</span> <span>x</span>: <span>10</span><span>,</span> <span>y</span>: <span>10</span> <span>}</span><span>,</span>
  <span>{</span> <span>type</span>: <span>&#39;mousemove&#39;</span><span>,</span> <span>x</span>: <span>15</span><span>,</span> <span>y</span>: <span>15</span> <span>}</span><span>,</span>
  <span>{</span> <span>type</span>: <span>&#39;mousemove&#39;</span><span>,</span> <span>x</span>: <span>20</span><span>,</span> <span>y</span>: <span>20</span> <span>}</span><span>,</span>
  <span>{</span> <span>type</span>: <span>&#39;mouseup&#39;</span><span>,</span> <span>x</span>: <span>20</span><span>,</span> <span>y</span>: <span>20</span> <span>}</span><span>,</span>
<span>]</span><span>;</span>

<span>let</span> <span>isDragging</span> <span>=</span> <span>false</span><span>;</span>
<span>const</span> <span>trackDrag</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>if</span> <span>(</span><span>e</span><span>.</span><span>type</span> <span>===</span> <span>&#39;mousedown&#39;</span><span>)</span> <span>isDragging</span> <span>=</span> <span>true</span><span>;</span>
  <span>if</span> <span>(</span><span>e</span><span>.</span><span>type</span> <span>===</span> <span>&#39;mouseup&#39;</span><span>)</span> <span>isDragging</span> <span>=</span> <span>false</span><span>;</span>
  <span>return</span> <span>isDragging</span> <span>&amp;&amp;</span> <span>e</span><span>.</span><span>type</span> <span>===</span> <span>&#39;mousemove&#39;</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> <span>result</span> <span>=</span> <span>pipe</span><span>(</span><span>eventStream</span><span>(</span><span>events</span><span>)</span><span>)</span><span>;</span>
<span>result</span> 
  <span>|</span> <span>filter</span><span>(</span><span>trackDrag</span><span>)</span> 
  <span>|</span> <span>map</span><span>(</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span> <span>x</span>: <span>e</span><span>.</span><span>x</span><span>,</span> <span>y</span>: <span>e</span><span>.</span><span>y</span> <span>}</span><span>)</span><span>)</span><span>;</span>

<span>const</span> <span>stream</span> <span>=</span> <span>await</span> <span>result</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
<span>const</span> <span>positions</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>for</span> <span>await</span> <span>(</span><span>const</span> <span>pos</span> <span>of</span> <span>stream</span><span>)</span> <span>{</span>
  <span>positions</span><span>.</span><span>push</span><span>(</span><span>pos</span><span>)</span><span>;</span> <span>// [{ x: 15, y: 15 }, { x: 20, y: 20 }]</span>
<span>}</span></pre></div>
<p dir="auto"><strong>Stream Functions</strong></p>
<p dir="auto">The <code>stream.js</code> module provides these generator-based aspipe functions:</p>
<ul dir="auto">
<li><strong>map(iterable, fn)</strong> - Transform each item in the stream</li>
<li><strong>filter(iterable, predicate)</strong> - Filter items based on a condition</li>
<li><strong>take(iterable, n)</strong> - Take the first n items from a stream</li>
<li><strong>scan(iterable, reducer, initial)</strong> - Accumulate values, yielding intermediate results</li>
<li><strong>reduce(iterable, reducer, initial)</strong> - Reduce stream to a single value</li>
</ul>
<p dir="auto">These functions work seamlessly with async generators, enabling reactive patterns like waiting for specific events in an endless stream.</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">6 Reference Implementation</h2><a id="user-content-6-reference-implementation" aria-label="Permalink: 6 Reference Implementation" href="#6-reference-implementation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<div dir="auto" data-snippet-clipboard-copy-content="export function createAsPipes() {
  const stack = [];

  const asPipe = (fn) =&gt;
    new Proxy(function () {}, {
      get(_, prop) {
        if (prop === Symbol.toPrimitive)
          return () =&gt; (
            stack.at(-1).steps.push(async (v) =&gt; {
              const stackLengthBefore = stack.length;
              const result = await Promise.resolve(fn(v));

              // If a new pipeline was created during fn execution and result is 0
              if (result === 0 &amp;&amp; stack.length &gt; stackLengthBefore) {
                // Get the pipeline that was created and execute it
                const pipelineCtx = stack[stack.length - 1];
                stack.pop(); // Remove from stack as we&#39;re executing it
                return await pipelineCtx.steps.reduce(
                  (p, f) =&gt; p.then(f),
                  Promise.resolve(pipelineCtx.v),
                );
              }

              // If the function returns a pipeline token, execute it automatically
              if (result &amp;&amp; typeof result.run === &#39;function&#39;) {
                return await result.run();
              }
              return result;
            }),
            0
          );
      },
      apply(_, __, args) {
        const t = function () {};
        t[Symbol.toPrimitive] = () =&gt; (
          stack.at(-1).steps.push(async (v) =&gt; {
            const stackLengthBefore = stack.length;
            const result = await Promise.resolve(fn(v, ...args));

            // If a new pipeline was created during fn execution and result is 0
            if (result === 0 &amp;&amp; stack.length &gt; stackLengthBefore) {
              // Get the pipeline that was created and execute it
              const pipelineCtx = stack[stack.length - 1];
              stack.pop(); // Remove from stack as we&#39;re executing it
              return await pipelineCtx.steps.reduce(
                (p, f) =&gt; p.then(f),
                Promise.resolve(pipelineCtx.v),
              );
            }

            // If the function returns a pipeline token, execute it automatically
            if (result &amp;&amp; typeof result.run === &#39;function&#39;) {
              return await result.run();
            }
            return result;
          }),
          0
        );
        return t;
      },
    });

  const pipe = (x) =&gt; {
    const ctx = { v: x, steps: [] };
    const token = {
      [Symbol.toPrimitive]: () =&gt; (stack.push(ctx), 0),
      async run() {
        return ctx.steps.reduce((p, f) =&gt; p.then(f), Promise.resolve(ctx.v));
      },
    };
    return token;
  };

  return { pipe, asPipe };
}"><pre><span>export</span> <span>function</span> <span>createAsPipes</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>stack</span> <span>=</span> <span>[</span><span>]</span><span>;</span>

  <span>const</span> <span>asPipe</span> <span>=</span> <span>(</span><span>fn</span><span>)</span> <span>=&gt;</span>
    <span>new</span> <span>Proxy</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span> <span>{</span>
      <span>get</span><span>(</span><span>_</span><span>,</span> <span>prop</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>prop</span> <span>===</span> <span>Symbol</span><span>.</span><span>toPrimitive</span><span>)</span>
          <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>(</span>
            <span>stack</span><span>.</span><span>at</span><span>(</span><span>-</span><span>1</span><span>)</span><span>.</span><span>steps</span><span>.</span><span>push</span><span>(</span><span>async</span> <span>(</span><span>v</span><span>)</span> <span>=&gt;</span> <span>{</span>
              <span>const</span> <span>stackLengthBefore</span> <span>=</span> <span>stack</span><span>.</span><span>length</span><span>;</span>
              <span>const</span> <span>result</span> <span>=</span> <span>await</span> <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>fn</span><span>(</span><span>v</span><span>)</span><span>)</span><span>;</span>

              <span>// If a new pipeline was created during fn execution and result is 0</span>
              <span>if</span> <span>(</span><span>result</span> <span>===</span> <span>0</span> <span>&amp;&amp;</span> <span>stack</span><span>.</span><span>length</span> <span>&gt;</span> <span>stackLengthBefore</span><span>)</span> <span>{</span>
                <span>// Get the pipeline that was created and execute it</span>
                <span>const</span> <span>pipelineCtx</span> <span>=</span> <span>stack</span><span>[</span><span>stack</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>]</span><span>;</span>
                <span>stack</span><span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span> <span>// Remove from stack as we&#39;re executing it</span>
                <span>return</span> <span>await</span> <span>pipelineCtx</span><span>.</span><span>steps</span><span>.</span><span>reduce</span><span>(</span>
                  <span>(</span><span>p</span><span>,</span> <span>f</span><span>)</span> <span>=&gt;</span> <span>p</span><span>.</span><span>then</span><span>(</span><span>f</span><span>)</span><span>,</span>
                  <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>pipelineCtx</span><span>.</span><span>v</span><span>)</span><span>,</span>
                <span>)</span><span>;</span>
              <span>}</span>

              <span>// If the function returns a pipeline token, execute it automatically</span>
              <span>if</span> <span>(</span><span>result</span> <span>&amp;&amp;</span> <span>typeof</span> <span>result</span><span>.</span><span>run</span> <span>===</span> <span>&#39;function&#39;</span><span>)</span> <span>{</span>
                <span>return</span> <span>await</span> <span>result</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
              <span>}</span>
              <span>return</span> <span>result</span><span>;</span>
            <span>}</span><span>)</span><span>,</span>
            <span>0</span>
          <span>)</span><span>;</span>
      <span>}</span><span>,</span>
      <span>apply</span><span>(</span><span>_</span><span>,</span> <span>__</span><span>,</span> <span>args</span><span>)</span> <span>{</span>
        <span>const</span> <span>t</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
        <span>t</span><span>[</span><span>Symbol</span><span>.</span><span>toPrimitive</span><span>]</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>(</span>
          <span>stack</span><span>.</span><span>at</span><span>(</span><span>-</span><span>1</span><span>)</span><span>.</span><span>steps</span><span>.</span><span>push</span><span>(</span><span>async</span> <span>(</span><span>v</span><span>)</span> <span>=&gt;</span> <span>{</span>
            <span>const</span> <span>stackLengthBefore</span> <span>=</span> <span>stack</span><span>.</span><span>length</span><span>;</span>
            <span>const</span> <span>result</span> <span>=</span> <span>await</span> <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>fn</span><span>(</span><span>v</span><span>,</span> ...<span>args</span><span>)</span><span>)</span><span>;</span>

            <span>// If a new pipeline was created during fn execution and result is 0</span>
            <span>if</span> <span>(</span><span>result</span> <span>===</span> <span>0</span> <span>&amp;&amp;</span> <span>stack</span><span>.</span><span>length</span> <span>&gt;</span> <span>stackLengthBefore</span><span>)</span> <span>{</span>
              <span>// Get the pipeline that was created and execute it</span>
              <span>const</span> <span>pipelineCtx</span> <span>=</span> <span>stack</span><span>[</span><span>stack</span><span>.</span><span>length</span> <span>-</span> <span>1</span><span>]</span><span>;</span>
              <span>stack</span><span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span> <span>// Remove from stack as we&#39;re executing it</span>
              <span>return</span> <span>await</span> <span>pipelineCtx</span><span>.</span><span>steps</span><span>.</span><span>reduce</span><span>(</span>
                <span>(</span><span>p</span><span>,</span> <span>f</span><span>)</span> <span>=&gt;</span> <span>p</span><span>.</span><span>then</span><span>(</span><span>f</span><span>)</span><span>,</span>
                <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>pipelineCtx</span><span>.</span><span>v</span><span>)</span><span>,</span>
              <span>)</span><span>;</span>
            <span>}</span>

            <span>// If the function returns a pipeline token, execute it automatically</span>
            <span>if</span> <span>(</span><span>result</span> <span>&amp;&amp;</span> <span>typeof</span> <span>result</span><span>.</span><span>run</span> <span>===</span> <span>&#39;function&#39;</span><span>)</span> <span>{</span>
              <span>return</span> <span>await</span> <span>result</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>return</span> <span>result</span><span>;</span>
          <span>}</span><span>)</span><span>,</span>
          <span>0</span>
        <span>)</span><span>;</span>
        <span>return</span> <span>t</span><span>;</span>
      <span>}</span><span>,</span>
    <span>}</span><span>)</span><span>;</span>

  <span>const</span> <span>pipe</span> <span>=</span> <span>(</span><span>x</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>ctx</span> <span>=</span> <span>{</span> <span>v</span>: <span>x</span><span>,</span> <span>steps</span>: <span>[</span><span>]</span> <span>}</span><span>;</span>
    <span>const</span> <span>token</span> <span>=</span> <span>{</span>
      <span>[</span><span>Symbol</span><span>.</span><span>toPrimitive</span><span>]</span>: <span>(</span><span>)</span> <span>=&gt;</span> <span>(</span><span>stack</span><span>.</span><span>push</span><span>(</span><span>ctx</span><span>)</span><span>,</span> <span>0</span><span>)</span><span>,</span>
      <span>async</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>ctx</span><span>.</span><span>steps</span><span>.</span><span>reduce</span><span>(</span><span>(</span><span>p</span><span>,</span> <span>f</span><span>)</span> <span>=&gt;</span> <span>p</span><span>.</span><span>then</span><span>(</span><span>f</span><span>)</span><span>,</span> <span>Promise</span><span>.</span><span>resolve</span><span>(</span><span>ctx</span><span>.</span><span>v</span><span>)</span><span>)</span><span>;</span>
      <span>}</span><span>,</span>
    <span>}</span><span>;</span>
    <span>return</span> <span>token</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> <span>{</span> pipe<span>,</span> asPipe <span>}</span><span>;</span>
<span>}</span></pre></div>

<p dir="auto">Each pipe() call creates a private evaluation context { v, steps[] }.
Every pipeable function registers a transformation when coerced by |.
.run() folds the step list into a promise chain:</p>
<div data-snippet-clipboard-copy-content="value₀ → step₁(value₀) → step₂(value₁) → … → result"><pre><code>value₀ → step₁(value₀) → step₂(value₁) → … → result
</code></pre></div>
<p dir="auto">Each step may return either a value or a promise.
Evaluation order is strict left-to-right, with promise resolution between steps.</p>
<p dir="auto">⸻</p>
<div dir="auto"><h2 tabindex="-1" dir="auto">8 Motivation and Design Notes</h2><a id="user-content-8-motivation-and-design-notes" aria-label="Permalink: 8 Motivation and Design Notes" href="#8-motivation-and-design-notes"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg></a></div>
<p dir="auto">Why use Symbol.toPrimitive?
Because bitwise operators force primitive coercion and can be intercepted per-object, giving a hook for sequencing without syntax modification.</p>
<p dir="auto">Why | and not || or &amp;?
| is the simplest binary operator that (a) performs coercion on both operands, and (b) yields a valid runtime expression chain.</p>
<p dir="auto">Why explicit .run()?
It makes side effects explicit, keeps the evaluation lazy, and aligns with functional semantics (like Observable.subscribe() or Task.run()).</p>
<p dir="auto">Limitations:</p>
<ul dir="auto">
<li>Doesn’t support arbitrary expressions on the right-hand side (only pipeable tokens).</li>
<li>Overuse may confuse tooling or linters.</li>
<li>Purely demonstrative — not intended for production.</li>
</ul>
<p dir="auto">⸻</p>

<ol dir="auto">
<li>Could a future ECMAScript grammar support a similar deferred evaluation model natively?</li>
<li>What would static analyzers and TypeScript need to infer such pipeline types?</li>
<li>Can the |&gt; proposal benefit from runtime experiments like this to clarify ergonomics?</li>
<li>Should .run() be implicit (auto-executed) or always explicit?</li>
</ol>
<p dir="auto">⸻</p>

<p dir="auto">asPipes is not a syntax proposal but a runtime prototype — a living example of how far JavaScript can stretch to approximate future language constructs using only what’s already standardized.</p>
<p dir="auto">It demonstrates that:</p>
<ul dir="auto">
<li>The semantics of pipelines are composable and ergonomic in practice.</li>
<li>Async behavior integrates naturally.</li>
<li>The readability and cognitive flow of |&gt; syntax can be validated today.</li>
</ul>
<p dir="auto">⸻</p>

<p dir="auto">MIT © 2025
This document is non-normative and intended for exploration and discussion within the JavaScript community.</p>
</article></div></div>
  </body>
</html>
