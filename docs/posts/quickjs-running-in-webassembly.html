<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.com/justjake/quickjs-emscripten">Original</a>
    <h1>QuickJS Running in WebAssembly</h1>
    
    <div id="readability-page-1" class="page"><div data-target="readme-toc.content">
            <article itemprop="text">
<p dir="auto">Javascript/Typescript bindings for QuickJS, a modern Javascript interpreter,
compiled to WebAssembly.</p>
<ul dir="auto">
<li>Safely evaluate untrusted Javascript (up to ES2020).</li>
<li>Create and manipulate values inside the QuickJS runtime (<a href="#interfacing-with-the-interpreter">more</a>).</li>
<li>Expose host functions to the QuickJS runtime (<a href="#exposing-apis">more</a>).</li>
<li>Execute synchronous code that uses asynchronous functions, with <a href="#asyncify">asyncify</a>.</li>
</ul>
<p dir="auto"><a href="https://github.com/justjake/quickjs-emscripten">Github</a> | <a href="https://www.npmjs.com/package/quickjs-emscripten" rel="nofollow">NPM</a> | <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/modules.md">API Documentation</a> | <a href="https://github.com/justjake/quickjs-emscripten/blob/main/ts/quickjs.test.ts">Examples</a></p>
<div dir="auto" data-snippet-clipboard-copy-content="import { getQuickJS } from &#34;quickjs-emscripten&#34;

async function main() {
  const QuickJS = await getQuickJS()
  const vm = QuickJS.newContext()

  const world = vm.newString(&#34;world&#34;)
  vm.setProp(vm.global, &#34;NAME&#34;, world)
  world.dispose()

  const result = vm.evalCode(`&#34;Hello &#34; + NAME + &#34;!&#34;`)
  if (result.error) {
    console.log(&#34;Execution failed:&#34;, vm.dump(result.error))
    result.error.dispose()
  } else {
    console.log(&#34;Success:&#34;, vm.dump(result.value))
    result.value.dispose()
  }

  vm.dispose()
}

main()"><pre><span>import</span> <span>{</span> <span>getQuickJS</span> <span>}</span> <span>from</span> <span>&#34;quickjs-emscripten&#34;</span>

<span>async</span> <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>QuickJS</span> <span>=</span> <span>await</span> <span>getQuickJS</span><span>(</span><span>)</span>
  <span>const</span> <span>vm</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>

  <span>const</span> <span>world</span> <span>=</span> <span>vm</span><span>.</span><span>newString</span><span>(</span><span>&#34;world&#34;</span><span>)</span>
  <span>vm</span><span>.</span><span>setProp</span><span>(</span><span>vm</span><span>.</span><span>global</span><span>,</span> <span>&#34;NAME&#34;</span><span>,</span> <span>world</span><span>)</span>
  <span>world</span><span>.</span><span>dispose</span><span>(</span><span>)</span>

  <span>const</span> <span>result</span> <span>=</span> <span>vm</span><span>.</span><span>evalCode</span><span>(</span><span>`&#34;Hello &#34; + NAME + &#34;!&#34;`</span><span>)</span>
  <span>if</span> <span>(</span><span>result</span><span>.</span><span>error</span><span>)</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;Execution failed:&#34;</span><span>,</span> <span>vm</span><span>.</span><span>dump</span><span>(</span><span>result</span><span>.</span><span>error</span><span>)</span><span>)</span>
    <span>result</span><span>.</span><span>error</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;Success:&#34;</span><span>,</span> <span>vm</span><span>.</span><span>dump</span><span>(</span><span>result</span><span>.</span><span>value</span><span>)</span><span>)</span>
    <span>result</span><span>.</span><span>value</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
  <span>}</span>

  <span>vm</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>}</span>

<span>main</span><span>(</span><span>)</span></pre></div>
<h2 dir="auto"><a id="user-content-usage" aria-hidden="true" href="#usage"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Usage</h2>
<p dir="auto">Install from <code>npm</code>: <code>npm install --save quickjs-emscripten</code> or <code>yarn add quickjs-emscripten</code>.</p>
<p dir="auto">The root entrypoint of this library is the <code>getQuickJS</code> function, which returns
a promise that resolves to a <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/quickjs.md">QuickJS singleton</a> when
the QuickJS WASM module is ready.</p>
<p dir="auto">Once <code>getQuickJS</code> has been awaited at least once, you also can use the <code>getQuickJSSync</code>
function to directly access the singleton engine in your synchronous code.</p>
<h3 dir="auto"><a id="user-content-safely-evaluate-javascript-code" aria-hidden="true" href="#safely-evaluate-javascript-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Safely evaluate Javascript code</h3>
<p dir="auto">See <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/quickjs.md#evalcode">QuickJS.evalCode</a></p>
<div dir="auto" data-snippet-clipboard-copy-content="import { getQuickJS, shouldInterruptAfterDeadline } from &#34;quickjs-emscripten&#34;

getQuickJS().then((QuickJS) =&gt; {
  const result = QuickJS.evalCode(&#34;1 + 1&#34;, {
    shouldInterrupt: shouldInterruptAfterDeadline(Date.now() + 1000),
    memoryLimitBytes: 1024 * 1024,
  })
  console.log(result)
})"><pre><span>import</span> <span>{</span> <span>getQuickJS</span><span>,</span> <span>shouldInterruptAfterDeadline</span> <span>}</span> <span>from</span> <span>&#34;quickjs-emscripten&#34;</span>

<span>getQuickJS</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>QuickJS</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>result</span> <span>=</span> <span>QuickJS</span><span>.</span><span>evalCode</span><span>(</span><span>&#34;1 + 1&#34;</span><span>,</span> <span>{</span>
    <span>shouldInterrupt</span>: <span>shouldInterruptAfterDeadline</span><span>(</span><span>Date</span><span>.</span><span>now</span><span>(</span><span>)</span> <span>+</span> <span>1000</span><span>)</span><span>,</span>
    <span>memoryLimitBytes</span>: <span>1024</span> <span>*</span> <span>1024</span><span>,</span>
  <span>}</span><span>)</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>result</span><span>)</span>
<span>}</span><span>)</span></pre></div>
<h3 dir="auto"><a id="user-content-interfacing-with-the-interpreter" aria-hidden="true" href="#interfacing-with-the-interpreter"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Interfacing with the interpreter</h3>
<p dir="auto">You can use <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/QuickJSContext.md">QuickJSContext</a>
to build a scripting environment by modifying globals and exposing functions
into the QuickJS interpreter.</p>
<p dir="auto">Each <code>QuickJSContext</code> instance has its own environment -- globals, built-in
classes -- and actions from one context won&#39;t leak into other contexts or
runtimes (with one exception, see <a href="#asyncify">Asyncify</a>).</p>
<p dir="auto">Every context is created inside a
<a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/QuickJSRuntime.md">QuickJSRuntime</a>.
A runtime represents a Javascript heap, and you can even share values between
contexts in the same runtime.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const vm = QuickJS.newContext()
let state = 0

const fnHandle = vm.newFunction(&#34;nextId&#34;, () =&gt; {
  return vm.newNumber(++state)
})

vm.setProp(vm.global, &#34;nextId&#34;, fnHandle)
fnHandle.dispose()

const nextId = vm.unwrapResult(vm.evalCode(`nextId(); nextId(); nextId()`))
console.log(&#34;vm result:&#34;, vm.getNumber(nextId), &#34;native state:&#34;, state)

nextId.dispose()
vm.dispose()"><pre><span>const</span> <span>vm</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>let</span> <span>state</span> <span>=</span> <span>0</span>

<span>const</span> <span>fnHandle</span> <span>=</span> <span>vm</span><span>.</span><span>newFunction</span><span>(</span><span>&#34;nextId&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>vm</span><span>.</span><span>newNumber</span><span>(</span><span>++</span><span>state</span><span>)</span>
<span>}</span><span>)</span>

<span>vm</span><span>.</span><span>setProp</span><span>(</span><span>vm</span><span>.</span><span>global</span><span>,</span> <span>&#34;nextId&#34;</span><span>,</span> <span>fnHandle</span><span>)</span>
<span>fnHandle</span><span>.</span><span>dispose</span><span>(</span><span>)</span>

<span>const</span> <span>nextId</span> <span>=</span> <span>vm</span><span>.</span><span>unwrapResult</span><span>(</span><span>vm</span><span>.</span><span>evalCode</span><span>(</span><span>`nextId(); nextId(); nextId()`</span><span>)</span><span>)</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;vm result:&#34;</span><span>,</span> <span>vm</span><span>.</span><span>getNumber</span><span>(</span><span>nextId</span><span>)</span><span>,</span> <span>&#34;native state:&#34;</span><span>,</span> <span>state</span><span>)</span>

<span>nextId</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>vm</span><span>.</span><span>dispose</span><span>(</span><span>)</span></pre></div>
<p dir="auto">When you create a context from a top-level API like in the example above,
instead of by calling <code>runtime.newContext()</code>, a runtime is automatically created
for the lifetime of the context, and disposed of when you dispose the context.</p>
<h4 dir="auto"><a id="user-content-runtime" aria-hidden="true" href="#runtime"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Runtime</h4>
<p dir="auto">The runtime has APIs for CPU and memory limits that apply to all contexts within
the runtime in aggregate. You can also use the runtime to configure EcmaScript
module loading.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const runtime = QuickJS.newRuntime()
// &#34;Should be enough for everyone&#34; -- attributed to B. Gates
runtime.setMemoryLimit(1024 * 640)
// Limit stack size
runtime.setMaxStackSize(1024 * 320)
// Interrupt computation after 1024 calls to the interrupt handler
let interruptCycles = 0
runtime.setInterruptHandler(() =&gt; ++interruptCycles &gt; 1024)
// Toy module system that always returns the module name
// as the default export
runtime.setModuleLoader((moduleName) =&gt; `export default &#39;${moduleName}&#39;`)
const context = runtime.newContext()
const ok = context.evalCode(`
import fooName from &#39;./foo.js&#39;
globalThis.result = fooName
`)
context.unwrapResult(ok).dispose()
// logs &#34;foo.js&#34;
console.log(context.getProp(context.global, &#34;result&#34;).consume(context.dump))
context.dispose()
runtime.dispose()"><pre><span>const</span> <span>runtime</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newRuntime</span><span>(</span><span>)</span>
<span>// &#34;Should be enough for everyone&#34; -- attributed to B. Gates</span>
<span>runtime</span><span>.</span><span>setMemoryLimit</span><span>(</span><span>1024</span> <span>*</span> <span>640</span><span>)</span>
<span>// Limit stack size</span>
<span>runtime</span><span>.</span><span>setMaxStackSize</span><span>(</span><span>1024</span> <span>*</span> <span>320</span><span>)</span>
<span>// Interrupt computation after 1024 calls to the interrupt handler</span>
<span>let</span> <span>interruptCycles</span> <span>=</span> <span>0</span>
<span>runtime</span><span>.</span><span>setInterruptHandler</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>++</span><span>interruptCycles</span> <span>&gt;</span> <span>1024</span><span>)</span>
<span>// Toy module system that always returns the module name</span>
<span>// as the default export</span>
<span>runtime</span><span>.</span><span>setModuleLoader</span><span>(</span><span>(</span><span>moduleName</span><span>)</span> <span>=&gt;</span> <span>`export default &#39;<span><span>${</span><span>moduleName</span><span>}</span></span>&#39;`</span><span>)</span>
<span>const</span> <span>context</span> <span>=</span> <span>runtime</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>const</span> <span>ok</span> <span>=</span> <span>context</span><span>.</span><span>evalCode</span><span>(</span><span>`</span>
<span>import fooName from &#39;./foo.js&#39;</span>
<span>globalThis.result = fooName</span>
<span>`</span><span>)</span>
<span>context</span><span>.</span><span>unwrapResult</span><span>(</span><span>ok</span><span>)</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>// logs &#34;foo.js&#34;</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>context</span><span>.</span><span>getProp</span><span>(</span><span>context</span><span>.</span><span>global</span><span>,</span> <span>&#34;result&#34;</span><span>)</span><span>.</span><span>consume</span><span>(</span><span>context</span><span>.</span><span>dump</span><span>)</span><span>)</span>
<span>context</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>runtime</span><span>.</span><span>dispose</span><span>(</span><span>)</span></pre></div>
<h3 dir="auto"><a id="user-content-memory-management" aria-hidden="true" href="#memory-management"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Memory Management</h3>
<p dir="auto">Many methods in this library return handles to memory allocated inside the
WebAssembly heap. These types cannot be garbage-collected as usual in
Javascript. Instead, you must manually manage their memory by calling a
<code>.dispose()</code> method to free the underlying resources. Once a handle has been
disposed, it cannot be used anymore. Note that in the example above, we call
<code>.dispose()</code> on each handle once it is no longer needed.</p>
<p dir="auto">Calling <code>QuickJSContext.dispose()</code> will throw a RuntimeError if you&#39;ve forgotten to
dispose any handles associated with that VM, so it&#39;s good practice to create a
new VM instance for each of your tests, and to call <code>vm.dispose()</code> at the end
of every test.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const vm = QuickJS.newContext()
const numberHandle = vm.newNumber(42)
// Note: numberHandle not disposed, so it leaks memory.
vm.dispose()
// throws RuntimeError: abort(Assertion failed: list_empty(&amp;rt-&gt;gc_obj_list), at: quickjs/quickjs.c,1963,JS_FreeRuntime)"><pre><span>const</span> <span>vm</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>const</span> <span>numberHandle</span> <span>=</span> <span>vm</span><span>.</span><span>newNumber</span><span>(</span><span>42</span><span>)</span>
<span>// Note: numberHandle not disposed, so it leaks memory.</span>
<span>vm</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>// throws RuntimeError: abort(Assertion failed: list_empty(&amp;rt-&gt;gc_obj_list), at: quickjs/quickjs.c,1963,JS_FreeRuntime)</span></pre></div>
<p dir="auto">Here are some strategies to reduce the toil of calling <code>.dispose()</code> on each
handle you create:</p>
<h4 dir="auto"><a id="user-content-scope" aria-hidden="true" href="#scope"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Scope</h4>
<p dir="auto">A
<a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/scope.md#class-scope"><code>Scope</code></a>
instance manages a set of disposables and calls their <code>.dispose()</code>
method in the reverse order in which they&#39;re added to the scope. Here&#39;s the
&#34;Interfacing with the interpreter&#34; example re-written using <code>Scope</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="Scope.withScope((scope) =&gt; {
  const vm = scope.manage(QuickJS.newContext())
  let state = 0

  const fnHandle = scope.manage(
    vm.newFunction(&#34;nextId&#34;, () =&gt; {
      return vm.newNumber(++state)
    })
  )

  vm.setProp(vm.global, &#34;nextId&#34;, fnHandle)

  const nextId = scope.manage(vm.unwrapResult(vm.evalCode(`nextId(); nextId(); nextId()`)))
  console.log(&#34;vm result:&#34;, vm.getNumber(nextId), &#34;native state:&#34;, state)

  // When the withScope block exits, it calls scope.dispose(), which in turn calls
  // the .dispose() methods of all the disposables managed by the scope.
})"><pre><span>Scope</span><span>.</span><span>withScope</span><span>(</span><span>(</span><span>scope</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>vm</span> <span>=</span> <span>scope</span><span>.</span><span>manage</span><span>(</span><span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span><span>)</span>
  <span>let</span> <span>state</span> <span>=</span> <span>0</span>

  <span>const</span> <span>fnHandle</span> <span>=</span> <span>scope</span><span>.</span><span>manage</span><span>(</span>
    <span>vm</span><span>.</span><span>newFunction</span><span>(</span><span>&#34;nextId&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>return</span> <span>vm</span><span>.</span><span>newNumber</span><span>(</span><span>++</span><span>state</span><span>)</span>
    <span>}</span><span>)</span>
  <span>)</span>

  <span>vm</span><span>.</span><span>setProp</span><span>(</span><span>vm</span><span>.</span><span>global</span><span>,</span> <span>&#34;nextId&#34;</span><span>,</span> <span>fnHandle</span><span>)</span>

  <span>const</span> <span>nextId</span> <span>=</span> <span>scope</span><span>.</span><span>manage</span><span>(</span><span>vm</span><span>.</span><span>unwrapResult</span><span>(</span><span>vm</span><span>.</span><span>evalCode</span><span>(</span><span>`nextId(); nextId(); nextId()`</span><span>)</span><span>)</span><span>)</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;vm result:&#34;</span><span>,</span> <span>vm</span><span>.</span><span>getNumber</span><span>(</span><span>nextId</span><span>)</span><span>,</span> <span>&#34;native state:&#34;</span><span>,</span> <span>state</span><span>)</span>

  <span>// When the withScope block exits, it calls scope.dispose(), which in turn calls</span>
  <span>// the .dispose() methods of all the disposables managed by the scope.</span>
<span>}</span><span>)</span></pre></div>
<p dir="auto">You can also create <code>Scope</code> instances with <code>new Scope()</code> if you want to manage
calling <code>scope.dispose()</code> yourself.</p>
<h4 dir="auto"><a id="user-content-lifetimeconsumefn" aria-hidden="true" href="#lifetimeconsumefn"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><code>Lifetime.consume(fn)</code></h4>
<p dir="auto"><a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/lifetime.md#consume"><code>Lifetime.consume</code></a>
is sugar for the common pattern of using a handle and then
immediately disposing of it. <code>Lifetime.consume</code> takes a <code>map</code> function that
produces a result of any type. The <code>map</code> fuction is called with the handle,
then the handle is disposed, then the result is returned.</p>
<p dir="auto">Here&#39;s the &#34;Interfacing with interpreter&#34; example re-written using <code>.consume()</code>:</p>
<div dir="auto" data-snippet-clipboard-copy-content="const vm = QuickJS.newContext()
let state = 0

vm.newFunction(&#34;nextId&#34;, () =&gt; {
  return vm.newNumber(++state)
}).consume((fnHandle) =&gt; vm.setProp(vm.global, &#34;nextId&#34;, fnHandle))

vm.unwrapResult(vm.evalCode(`nextId(); nextId(); nextId()`)).consume((nextId) =&gt;
  console.log(&#34;vm result:&#34;, vm.getNumber(nextId), &#34;native state:&#34;, state)
)

vm.dispose()"><pre><span>const</span> <span>vm</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>let</span> <span>state</span> <span>=</span> <span>0</span>

<span>vm</span><span>.</span><span>newFunction</span><span>(</span><span>&#34;nextId&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>return</span> <span>vm</span><span>.</span><span>newNumber</span><span>(</span><span>++</span><span>state</span><span>)</span>
<span>}</span><span>)</span><span>.</span><span>consume</span><span>(</span><span>(</span><span>fnHandle</span><span>)</span> <span>=&gt;</span> <span>vm</span><span>.</span><span>setProp</span><span>(</span><span>vm</span><span>.</span><span>global</span><span>,</span> <span>&#34;nextId&#34;</span><span>,</span> <span>fnHandle</span><span>)</span><span>)</span>

<span>vm</span><span>.</span><span>unwrapResult</span><span>(</span><span>vm</span><span>.</span><span>evalCode</span><span>(</span><span>`nextId(); nextId(); nextId()`</span><span>)</span><span>)</span><span>.</span><span>consume</span><span>(</span><span>(</span><span>nextId</span><span>)</span> <span>=&gt;</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;vm result:&#34;</span><span>,</span> <span>vm</span><span>.</span><span>getNumber</span><span>(</span><span>nextId</span><span>)</span><span>,</span> <span>&#34;native state:&#34;</span><span>,</span> <span>state</span><span>)</span>
<span>)</span>

<span>vm</span><span>.</span><span>dispose</span><span>(</span><span>)</span></pre></div>
<p dir="auto">Generally working with <code>Scope</code> leads to more straight-forward code, but
<code>Lifetime.consume</code> can be handy sugar as part of a method call chain.</p>
<h3 dir="auto"><a id="user-content-exposing-apis" aria-hidden="true" href="#exposing-apis"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Exposing APIs</h3>
<p dir="auto">To add APIs inside the QuickJS environment, you&#39;ll need to create objects to
define the shape of your API, and add properties and functions to those objects
to allow code inside QuickJS to call code on the host.</p>
<p dir="auto">By default, no host functionality is exposed to code running inside QuickJS.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const vm = QuickJS.newContext()
// `console.log`
const logHandle = vm.newFunction(&#34;log&#34;, (...args) =&gt; {
  const nativeArgs = args.map(vm.dump)
  console.log(&#34;QuickJS:&#34;, ...nativeArgs)
})
// Partially implement `console` object
const consoleHandle = vm.newObject()
vm.setProp(consoleHandle, &#34;log&#34;, logHandle)
vm.setProp(vm.global, &#34;console&#34;, consoleHandle)
consoleHandle.dispose()
logHandle.dispose()

vm.unwrapResult(vm.evalCode(`console.log(&#34;Hello from QuickJS!&#34;)`)).dispose()"><pre><span>const</span> <span>vm</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>// `console.log`</span>
<span>const</span> <span>logHandle</span> <span>=</span> <span>vm</span><span>.</span><span>newFunction</span><span>(</span><span>&#34;log&#34;</span><span>,</span> <span>(</span>...<span>args</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>nativeArgs</span> <span>=</span> <span>args</span><span>.</span><span>map</span><span>(</span><span>vm</span><span>.</span><span>dump</span><span>)</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;QuickJS:&#34;</span><span>,</span> ...<span>nativeArgs</span><span>)</span>
<span>}</span><span>)</span>
<span>// Partially implement `console` object</span>
<span>const</span> <span>consoleHandle</span> <span>=</span> <span>vm</span><span>.</span><span>newObject</span><span>(</span><span>)</span>
<span>vm</span><span>.</span><span>setProp</span><span>(</span><span>consoleHandle</span><span>,</span> <span>&#34;log&#34;</span><span>,</span> <span>logHandle</span><span>)</span>
<span>vm</span><span>.</span><span>setProp</span><span>(</span><span>vm</span><span>.</span><span>global</span><span>,</span> <span>&#34;console&#34;</span><span>,</span> <span>consoleHandle</span><span>)</span>
<span>consoleHandle</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>logHandle</span><span>.</span><span>dispose</span><span>(</span><span>)</span>

<span>vm</span><span>.</span><span>unwrapResult</span><span>(</span><span>vm</span><span>.</span><span>evalCode</span><span>(</span><span>`console.log(&#34;Hello from QuickJS!&#34;)`</span><span>)</span><span>)</span><span>.</span><span>dispose</span><span>(</span><span>)</span></pre></div>
<h4 dir="auto"><a id="user-content-promises" aria-hidden="true" href="#promises"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Promises</h4>
<p dir="auto">To expose an asynchronous function that <em>returns a promise</em> to callers within
QuickJS, your function can return the handle of a <code>QuickJSDeferredPromise</code>
created via <code>context.newPromise()</code>.</p>
<p dir="auto">When you resolve a <code>QuickJSDeferredPromise</code> -- and generally whenever async
behavior completes for the VM -- pending listeners inside QuickJS may not
execute immediately. Your code needs to explicitly call
<code>runtime.executePendingJobs()</code> to resume execution inside QuickJS. This API
gives your code maximum control to <em>schedule</em> when QuickJS will block the host&#39;s
event loop by resuming execution.</p>
<p dir="auto">To work with QuickJS handles that contain a promise inside the environment, you
can convert the QuickJSHandle into a native promise using
<code>context.resolvePromise()</code>. Take care with this API to avoid &#39;deadlocks&#39; where
the host awaits a guest promise, but the guest cannot make progress until the
host calls <code>runtime.executePendingJobs()</code>. The simplest way to avoid this kind
of deadlock is to always schedule <code>executePendingJobs</code> after any promise is
settled.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const vm = QuickJS.newContext()
const fakeFileSystem = new Map([[&#34;example.txt&#34;, &#34;Example file content&#34;]])

// Function that simulates reading data asynchronously
const readFileHandle = vm.newFunction(&#34;readFile&#34;, (pathHandle) =&gt; {
  const path = vm.getString(pathHandle)
  const promise = vm.newPromise()
  setTimeout(() =&gt; {
    const content = fakeFileSystem.get(path)
    promise.resolve(vm.newString(content || &#34;&#34;))
  }, 100)
  // IMPORTANT: Once you resolve an async action inside QuickJS,
  // call runtime.executePendingJobs() to run any code that was
  // waiting on the promise or callback.
  promise.settled.then(vm.runtime.executePendingJobs)
  return promise.handle
})
readFileHandle.consume((handle) =&gt; vm.setProp(vm.global, &#34;readFile&#34;, handle))

// Evaluate code that uses `readFile`, which returns a promise
const result = vm.evalCode(`(async () =&gt; {
  const content = await readFile(&#39;example.txt&#39;)
  return content.toUpperCase()
})()`)
const promiseHandle = vm.unwrapResult(result)

// Convert the promise handle into a native promise and await it.
// If code like this deadlocks, make sure you are calling
// runtime.executePendingJobs appropriately.
const resolvedResult = await vm.resolvePromise(promiseHandle)
promiseHandle.dispose()
const resolvedHandle = vm.unwrapResult(resolvedResult)
console.log(&#34;Result:&#34;, vm.getString(resolvedHandle))
resolvedHandle.dispose()"><pre><span>const</span> <span>vm</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>const</span> <span>fakeFileSystem</span> <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span><span>[</span><span>&#34;example.txt&#34;</span><span>,</span> <span>&#34;Example file content&#34;</span><span>]</span><span>]</span><span>)</span>

<span>// Function that simulates reading data asynchronously</span>
<span>const</span> <span>readFileHandle</span> <span>=</span> <span>vm</span><span>.</span><span>newFunction</span><span>(</span><span>&#34;readFile&#34;</span><span>,</span> <span>(</span><span>pathHandle</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>path</span> <span>=</span> <span>vm</span><span>.</span><span>getString</span><span>(</span><span>pathHandle</span><span>)</span>
  <span>const</span> <span>promise</span> <span>=</span> <span>vm</span><span>.</span><span>newPromise</span><span>(</span><span>)</span>
  <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>content</span> <span>=</span> <span>fakeFileSystem</span><span>.</span><span>get</span><span>(</span><span>path</span><span>)</span>
    <span>promise</span><span>.</span><span>resolve</span><span>(</span><span>vm</span><span>.</span><span>newString</span><span>(</span><span>content</span> <span>||</span> <span>&#34;&#34;</span><span>)</span><span>)</span>
  <span>}</span><span>,</span> <span>100</span><span>)</span>
  <span>// IMPORTANT: Once you resolve an async action inside QuickJS,</span>
  <span>// call runtime.executePendingJobs() to run any code that was</span>
  <span>// waiting on the promise or callback.</span>
  <span>promise</span><span>.</span><span>settled</span><span>.</span><span>then</span><span>(</span><span>vm</span><span>.</span><span>runtime</span><span>.</span><span>executePendingJobs</span><span>)</span>
  <span>return</span> <span>promise</span><span>.</span><span>handle</span>
<span>}</span><span>)</span>
<span>readFileHandle</span><span>.</span><span>consume</span><span>(</span><span>(</span><span>handle</span><span>)</span> <span>=&gt;</span> <span>vm</span><span>.</span><span>setProp</span><span>(</span><span>vm</span><span>.</span><span>global</span><span>,</span> <span>&#34;readFile&#34;</span><span>,</span> <span>handle</span><span>)</span><span>)</span>

<span>// Evaluate code that uses `readFile`, which returns a promise</span>
<span>const</span> <span>result</span> <span>=</span> <span>vm</span><span>.</span><span>evalCode</span><span>(</span><span>`(async () =&gt; {</span>
<span>  const content = await readFile(&#39;example.txt&#39;)</span>
<span>  return content.toUpperCase()</span>
<span>})()`</span><span>)</span>
<span>const</span> <span>promiseHandle</span> <span>=</span> <span>vm</span><span>.</span><span>unwrapResult</span><span>(</span><span>result</span><span>)</span>

<span>// Convert the promise handle into a native promise and await it.</span>
<span>// If code like this deadlocks, make sure you are calling</span>
<span>// runtime.executePendingJobs appropriately.</span>
<span>const</span> <span>resolvedResult</span> <span>=</span> <span>await</span> <span>vm</span><span>.</span><span>resolvePromise</span><span>(</span><span>promiseHandle</span><span>)</span>
<span>promiseHandle</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>const</span> <span>resolvedHandle</span> <span>=</span> <span>vm</span><span>.</span><span>unwrapResult</span><span>(</span><span>resolvedResult</span><span>)</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;Result:&#34;</span><span>,</span> <span>vm</span><span>.</span><span>getString</span><span>(</span><span>resolvedHandle</span><span>)</span><span>)</span>
<span>resolvedHandle</span><span>.</span><span>dispose</span><span>(</span><span>)</span></pre></div>
<h4 dir="auto"><a id="user-content-asyncify" aria-hidden="true" href="#asyncify"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Asyncify</h4>
<p dir="auto">Sometimes, we want to create a function that&#39;s synchronous from the perspective
of QuickJS, but prefer to implement that function <em>asynchronously</em> in your host
code. The most obvious use-case is for EcmaScript module loading. The underlying
QuickJS C library expects the module loader function to return synchronously,
but loading data synchronously in the browser or server is somewhere between &#34;a
bad idea&#34; and &#34;impossible&#34;. QuickJS also doesn&#39;t expose an API to &#34;pause&#34; the
execution of a runtime, and adding such an API is tricky due to the VM&#39;s
implementation.</p>
<p dir="auto">As a work-around, we provide an alternate build of QuickJS processed by
Emscripten/Binaryen&#39;s <a href="https://emscripten.org/docs/porting/asyncify.html" rel="nofollow">ASYNCIFY</a>
compiler transform. Here&#39;s how Emscripten&#39;s documentation describes Asyncify:</p>
<blockquote>
<p dir="auto">Asyncify lets synchronous C or C++ code interact with asynchronous [host] JavaScript. This allows things like:</p>
<ul dir="auto">
<li>
<p dir="auto">A synchronous call in C that yields to the event loop, which allows browser events to be handled.</p>
</li>
<li>
<p dir="auto">A synchronous call in C that waits for an asynchronous operation in [host] JS to complete.</p>
</li>
</ul>
<p dir="auto">Asyncify automatically transforms ... code into a form that can be paused and
resumed ..., so that it is asynchronous (hence the name “Asyncify”) even though
[it is written] in a normal synchronous way.</p>
</blockquote>
<p dir="auto">This means we can suspend an <em>entire WebAssembly module</em> (which could contain
multiple runtimes and contexts) while our host Javascript loads data
asynchronously, and then resume execution once the data load completes. This is
a very handy superpower, but it comes with a couple of major limitations:</p>
<ol dir="auto">
<li>
<p dir="auto"><em>An asyncified WebAssembly module can only suspend to wait for a single
asynchronous call at a time</em>. You may call back into a suspended WebAssembly
module eg. to create a QuickJS value to return a result, but the system will
crash if this call tries to suspend again. Take a look at Emscripten&#39;s documentation
on <a href="https://emscripten.org/docs/porting/asyncify.html#reentrancy" rel="nofollow">reentrancy</a>.</p>
</li>
<li>
<p dir="auto"><em>Asyncified code is bigger and runs slower</em>. The asyncified build of
Quickjs-emscripten library is 1M, 2x larger than the 500K of the default
version. There may be room for further
<a href="https://emscripten.org/docs/porting/asyncify.html#optimizing" rel="nofollow">optimization</a>
Of our build in the future.</p>
</li>
</ol>
<p dir="auto">To use asyncify features, use the following functions:</p>
<ul dir="auto">
<li><a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/modules.md#newasyncruntime">newAsyncRuntime</a>: create a runtime inside a new WebAssembly module.</li>
<li><a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/modules.md#newasynccontext">newAsyncContext</a>: create runtime and context together inside a new
WebAssembly module.</li>
<li><a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/modules.md#newquickjsasyncwasmmodule">newQuickJSAsyncWASMModule</a>: create an empty WebAssembly module.</li>
</ul>
<p dir="auto">These functions are asynchronous because they always create a new underlying
WebAssembly module so that each instance can suspend and resume independently,
and instantiating a WebAssembly module is an async operation. This also adds
substantial overhead compared to creating a runtime or context inside an
existing module; if you only need to wait for a single async action at a time,
you can create a single top-level module and create runtimes or contexts inside
of it.</p>
<h5 dir="auto"><a id="user-content-async-module-loader" aria-hidden="true" href="#async-module-loader"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Async module loader</h5>
<p dir="auto">Here&#39;s an example of valuating a script that loads React asynchronously as an ES
module. In our example, we&#39;re loading from the filesystem for reproducibility,
but you can use this technique to load using <code>fetch</code>.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const module = await newQuickJSAsyncWASMModule()
const runtime = module.newRuntime()
const path = await import(&#34;path&#34;)
const { promises: fs } = await import(&#34;fs&#34;)

const importsPath = path.join(__dirname, &#34;../examples/imports&#34;) + &#34;/&#34;
// Module loaders can return promises.
// Execution will suspend until the promise resolves.
runtime.setModuleLoader((moduleName) =&gt; {
  const modulePath = path.join(importsPath, moduleName)
  if (!modulePath.startsWith(importsPath)) {
    throw new Error(&#34;out of bounds&#34;)
  }
  console.log(&#34;loading&#34;, moduleName, &#34;from&#34;, modulePath)
  return fs.readFile(modulePath, &#34;utf-8&#34;)
})

// evalCodeAsync is required when execution may suspend.
const context = runtime.newContext()
const result = await context.evalCodeAsync(`
import * as React from &#39;esm.sh/react@17&#39;
import * as ReactDOMServer from &#39;esm.sh/react-dom@17/server&#39;
const e = React.createElement
globalThis.html = ReactDOMServer.renderToStaticMarkup(
  e(&#39;div&#39;, null, e(&#39;strong&#39;, null, &#39;Hello world!&#39;))
)
`)
context.unwrapResult(result).dispose()
const html = context.getProp(context.global, &#34;html&#34;).consume(context.getString)
console.log(html) // &lt;div&gt;&lt;strong&gt;Hello world!&lt;/strong&gt;&lt;/div&gt;"><pre><span>const</span> <span>module</span> <span>=</span> <span>await</span> <span>newQuickJSAsyncWASMModule</span><span>(</span><span>)</span>
<span>const</span> <span>runtime</span> <span>=</span> <span>module</span><span>.</span><span>newRuntime</span><span>(</span><span>)</span>
<span>const</span> <span>path</span> <span>=</span> <span>await</span> <span>import</span><span>(</span><span>&#34;path&#34;</span><span>)</span>
<span>const</span> <span>{</span> <span>promises</span>: <span>fs</span> <span>}</span> <span>=</span> <span>await</span> <span>import</span><span>(</span><span>&#34;fs&#34;</span><span>)</span>

<span>const</span> <span>importsPath</span> <span>=</span> <span>path</span><span>.</span><span>join</span><span>(</span><span>__dirname</span><span>,</span> <span>&#34;../examples/imports&#34;</span><span>)</span> <span>+</span> <span>&#34;/&#34;</span>
<span>// Module loaders can return promises.</span>
<span>// Execution will suspend until the promise resolves.</span>
<span>runtime</span><span>.</span><span>setModuleLoader</span><span>(</span><span>(</span><span>moduleName</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>modulePath</span> <span>=</span> <span>path</span><span>.</span><span>join</span><span>(</span><span>importsPath</span><span>,</span> <span>moduleName</span><span>)</span>
  <span>if</span> <span>(</span><span>!</span><span>modulePath</span><span>.</span><span>startsWith</span><span>(</span><span>importsPath</span><span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;out of bounds&#34;</span><span>)</span>
  <span>}</span>
  <span>console</span><span>.</span><span>log</span><span>(</span><span>&#34;loading&#34;</span><span>,</span> <span>moduleName</span><span>,</span> <span>&#34;from&#34;</span><span>,</span> <span>modulePath</span><span>)</span>
  <span>return</span> <span>fs</span><span>.</span><span>readFile</span><span>(</span><span>modulePath</span><span>,</span> <span>&#34;utf-8&#34;</span><span>)</span>
<span>}</span><span>)</span>

<span>// evalCodeAsync is required when execution may suspend.</span>
<span>const</span> <span>context</span> <span>=</span> <span>runtime</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
<span>const</span> <span>result</span> <span>=</span> <span>await</span> <span>context</span><span>.</span><span>evalCodeAsync</span><span>(</span><span>`</span>
<span>import * as React from &#39;esm.sh/react@17&#39;</span>
<span>import * as ReactDOMServer from &#39;esm.sh/react-dom@17/server&#39;</span>
<span>const e = React.createElement</span>
<span>globalThis.html = ReactDOMServer.renderToStaticMarkup(</span>
<span>  e(&#39;div&#39;, null, e(&#39;strong&#39;, null, &#39;Hello world!&#39;))</span>
<span>)</span>
<span>`</span><span>)</span>
<span>context</span><span>.</span><span>unwrapResult</span><span>(</span><span>result</span><span>)</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
<span>const</span> <span>html</span> <span>=</span> <span>context</span><span>.</span><span>getProp</span><span>(</span><span>context</span><span>.</span><span>global</span><span>,</span> <span>&#34;html&#34;</span><span>)</span><span>.</span><span>consume</span><span>(</span><span>context</span><span>.</span><span>getString</span><span>)</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>html</span><span>)</span> <span>// &lt;div&gt;&lt;strong&gt;Hello world!&lt;/strong&gt;&lt;/div&gt;</span></pre></div>
<h5 dir="auto"><a id="user-content-async-on-host-sync-in-quickjs" aria-hidden="true" href="#async-on-host-sync-in-quickjs"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Async on host, sync in QuickJS</h5>
<p dir="auto">Here&#39;s an example of turning an async function into a sync function inside the
VM.</p>
<div dir="auto" data-snippet-clipboard-copy-content="const context = await newAsyncContext()
const path = await import(&#34;path&#34;)
const { promises: fs } = await import(&#34;fs&#34;)

const importsPath = path.join(__dirname, &#34;../examples/imports&#34;) + &#34;/&#34;
const readFileHandle = context.newAsyncifiedFunction(&#34;readFile&#34;, async (pathHandle) =&gt; {
  const pathString = path.join(importsPath, context.getString(pathHandle))
  if (!pathString.startsWith(importsPath)) {
    throw new Error(&#34;out of bounds&#34;)
  }
  const data = await fs.readFile(pathString, &#34;utf-8&#34;)
  return context.newString(data)
})
readFileHandle.consume((fn) =&gt; context.setProp(context.global, &#34;readFile&#34;, fn))

// evalCodeAsync is required when execution may suspend.
const result = await context.evalCodeAsync(`
// Not a promise! Sync! vvvvvvvvvvvvvvvvvvvv 
const data = JSON.parse(readFile(&#39;data.json&#39;))
data.map(x =&gt; x.toUpperCase()).join(&#39; &#39;)
`)
const upperCaseData = context.unwrapResult(result).consume(context.getString)
console.log(upperCaseData) // &#39;VERY USEFUL DATA&#39;"><pre><span>const</span> <span>context</span> <span>=</span> <span>await</span> <span>newAsyncContext</span><span>(</span><span>)</span>
<span>const</span> <span>path</span> <span>=</span> <span>await</span> <span>import</span><span>(</span><span>&#34;path&#34;</span><span>)</span>
<span>const</span> <span>{</span> <span>promises</span>: <span>fs</span> <span>}</span> <span>=</span> <span>await</span> <span>import</span><span>(</span><span>&#34;fs&#34;</span><span>)</span>

<span>const</span> <span>importsPath</span> <span>=</span> <span>path</span><span>.</span><span>join</span><span>(</span><span>__dirname</span><span>,</span> <span>&#34;../examples/imports&#34;</span><span>)</span> <span>+</span> <span>&#34;/&#34;</span>
<span>const</span> <span>readFileHandle</span> <span>=</span> <span>context</span><span>.</span><span>newAsyncifiedFunction</span><span>(</span><span>&#34;readFile&#34;</span><span>,</span> <span>async</span> <span>(</span><span>pathHandle</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>pathString</span> <span>=</span> <span>path</span><span>.</span><span>join</span><span>(</span><span>importsPath</span><span>,</span> <span>context</span><span>.</span><span>getString</span><span>(</span><span>pathHandle</span><span>)</span><span>)</span>
  <span>if</span> <span>(</span><span>!</span><span>pathString</span><span>.</span><span>startsWith</span><span>(</span><span>importsPath</span><span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>&#34;out of bounds&#34;</span><span>)</span>
  <span>}</span>
  <span>const</span> <span>data</span> <span>=</span> <span>await</span> <span>fs</span><span>.</span><span>readFile</span><span>(</span><span>pathString</span><span>,</span> <span>&#34;utf-8&#34;</span><span>)</span>
  <span>return</span> <span>context</span><span>.</span><span>newString</span><span>(</span><span>data</span><span>)</span>
<span>}</span><span>)</span>
<span>readFileHandle</span><span>.</span><span>consume</span><span>(</span><span>(</span><span>fn</span><span>)</span> <span>=&gt;</span> <span>context</span><span>.</span><span>setProp</span><span>(</span><span>context</span><span>.</span><span>global</span><span>,</span> <span>&#34;readFile&#34;</span><span>,</span> <span>fn</span><span>)</span><span>)</span>

<span>// evalCodeAsync is required when execution may suspend.</span>
<span>const</span> <span>result</span> <span>=</span> <span>await</span> <span>context</span><span>.</span><span>evalCodeAsync</span><span>(</span><span>`</span>
<span>// Not a promise! Sync! vvvvvvvvvvvvvvvvvvvv </span>
<span>const data = JSON.parse(readFile(&#39;data.json&#39;))</span>
<span>data.map(x =&gt; x.toUpperCase()).join(&#39; &#39;)</span>
<span>`</span><span>)</span>
<span>const</span> <span>upperCaseData</span> <span>=</span> <span>context</span><span>.</span><span>unwrapResult</span><span>(</span><span>result</span><span>)</span><span>.</span><span>consume</span><span>(</span><span>context</span><span>.</span><span>getString</span><span>)</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>upperCaseData</span><span>)</span> <span>// &#39;VERY USEFUL DATA&#39;</span></pre></div>
<h3 dir="auto"><a id="user-content-testing-your-code" aria-hidden="true" href="#testing-your-code"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Testing your code</h3>
<p dir="auto">This library is complicated to use, so please consider automated testing your
implementation. We highly writing your test suite to run with both the &#34;release&#34;
build variant of quickjs-emscripten, and also the <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/modules.md#debug_sync">DEBUG_SYNC</a> build variant.
The debug sync build variant has extra instrumentation code for detecting memory
leaks.</p>
<p dir="auto">The class <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/classes/TestQuickJSWASMModule.md">TestQuickJSWASMModule</a> exposes the memory leak detection API, although
this API is only accurate when using <code>DEBUG_SYNC</code> variant.</p>
<div dir="auto" data-snippet-clipboard-copy-content="// Define your test suite in a function, so that you can test against
// different module loaders.
function myTests(moduleLoader: () =&gt; Promise&lt;QuickJSWASMModule&gt;) {
  let QuickJS: TestQuickJSWASMModule
  beforeEach(async () =&gt; {
    // Get a unique TestQuickJSWASMModule instance for each test.
    const wasmModule = await moduleLoader()
    QuickJS = new TestQuickJSWASMModule(wasmModule)
  })
  afterEach(() =&gt; {
    // Assert that the test disposed all handles. The DEBUG_SYNC build
    // variant will show detailed traces for each leak.
    QuickJS.assertNoMemoryAllocated()
  })

  it(&#34;works well&#34;, () =&gt; {
    // TODO: write a test using QuickJS
    const context = QuickJS.newContext()
    context.unwrapResult(context.evalCode(&#34;1 + 1&#34;)).dispose()
    context.dispose()
  })
}

// Run the test suite against a matrix of module loaders.
describe(&#34;Check for memory leaks with QuickJS DEBUG build&#34;, () =&gt; {
  const moduleLoader = memoizePromiseFactory(() =&gt; newQuickJSWASMModule(DEBUG_SYNC))
  myTests(moduleLoader)
})

describe(&#34;Realistic test with QuickJS RELEASE build&#34;, () =&gt; {
  myTests(getQuickJS)
})"><pre><span>// Define your test suite in a function, so that you can test against</span>
<span>// different module loaders.</span>
<span>function</span> <span>myTests</span><span>(</span><span>moduleLoader</span>: <span>(</span><span>)</span> <span>=&gt;</span> <span>Promise</span><span>&lt;</span><span>QuickJSWASMModule</span><span>&gt;</span><span>)</span> <span>{</span>
  <span>let</span> <span>QuickJS</span>: <span>TestQuickJSWASMModule</span>
  <span>beforeEach</span><span>(</span><span>async</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Get a unique TestQuickJSWASMModule instance for each test.</span>
    <span>const</span> <span>wasmModule</span> <span>=</span> <span>await</span> <span>moduleLoader</span><span>(</span><span>)</span>
    <span>QuickJS</span> <span>=</span> <span>new</span> <span>TestQuickJSWASMModule</span><span>(</span><span>wasmModule</span><span>)</span>
  <span>}</span><span>)</span>
  <span>afterEach</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Assert that the test disposed all handles. The DEBUG_SYNC build</span>
    <span>// variant will show detailed traces for each leak.</span>
    <span>QuickJS</span><span>.</span><span>assertNoMemoryAllocated</span><span>(</span><span>)</span>
  <span>}</span><span>)</span>

  <span>it</span><span>(</span><span>&#34;works well&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// TODO: write a test using QuickJS</span>
    <span>const</span> <span>context</span> <span>=</span> <span>QuickJS</span><span>.</span><span>newContext</span><span>(</span><span>)</span>
    <span>context</span><span>.</span><span>unwrapResult</span><span>(</span><span>context</span><span>.</span><span>evalCode</span><span>(</span><span>&#34;1 + 1&#34;</span><span>)</span><span>)</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
    <span>context</span><span>.</span><span>dispose</span><span>(</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>// Run the test suite against a matrix of module loaders.</span>
<span>describe</span><span>(</span><span>&#34;Check for memory leaks with QuickJS DEBUG build&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>const</span> <span>moduleLoader</span> <span>=</span> <span>memoizePromiseFactory</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>newQuickJSWASMModule</span><span>(</span><span>DEBUG_SYNC</span><span>)</span><span>)</span>
  <span>myTests</span><span>(</span><span>moduleLoader</span><span>)</span>
<span>}</span><span>)</span>

<span>describe</span><span>(</span><span>&#34;Realistic test with QuickJS RELEASE build&#34;</span><span>,</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>myTests</span><span>(</span><span>getQuickJS</span><span>)</span>
<span>}</span><span>)</span></pre></div>
<p dir="auto">For more testing examples, please explore the typescript source of <a href="https://github.com/justjake/quickjs-emscripten/blob/main/ts">quickjs-emscripten</a> repository.</p>
<h3 dir="auto"><a id="user-content-debugging" aria-hidden="true" href="#debugging"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Debugging</h3>
<ul dir="auto">
<li>Switch to a DEBUG build variant of the WebAssembly module to see debug log messages from the C part of this library.</li>
<li>Set <code>process.env.QTS_DEBUG</code> to see debug log messages from the Javascript part of this library.</li>
</ul>
<h3 dir="auto"><a id="user-content-more-documentation" aria-hidden="true" href="#more-documentation"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>More Documentation</h3>
<p dir="auto"><a href="https://github.com/justjake/quickjs-emscripten">Github</a> | <a href="https://www.npmjs.com/package/quickjs-emscripten" rel="nofollow">NPM</a> | <a href="https://github.com/justjake/quickjs-emscripten/blob/main/doc/modules.md">API Documentation</a> | <a href="https://github.com/justjake/quickjs-emscripten/blob/main/ts/quickjs.test.ts">Examples</a></p>
<h2 dir="auto"><a id="user-content-background" aria-hidden="true" href="#background"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Background</h2>
<p dir="auto">This was inspired by seeing <a href="https://github.com/maple3142/duktape-eval">https://github.com/maple3142/duktape-eval</a>
<a href="https://news.ycombinator.com/item?id=21946565" rel="nofollow">on Hacker News</a> and Figma&#39;s
blogposts about using building a Javascript plugin runtime:</p>
<ul dir="auto">
<li><a href="https://www.figma.com/blog/how-we-built-the-figma-plugin-system/" rel="nofollow">How Figma built the Figma plugin system</a>: Describes the LowLevelJavascriptVm interface.</li>
<li><a href="https://www.figma.com/blog/an-update-on-plugin-security/" rel="nofollow">An update on plugin security</a>: Figma switches to QuickJS.</li>
</ul>
<h2 dir="auto"><a id="user-content-status--roadmap" aria-hidden="true" href="#status--roadmap"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Status &amp; Roadmap</h2>
<p dir="auto"><strong>Stability</strong>: Because the version number of this project is below <code>1.0.0</code>,
*expect occasional breaking API changes.</p>
<p dir="auto"><strong>Security</strong>: This project makes every effort to be secure, but has not been
audited. Please use with care in production settings.</p>
<p dir="auto"><strong>Roadmap</strong>: I work on this project in my free time, for fun. Here&#39;s I&#39;m
thinking comes next. Last updated 2022-03-18.</p>
<ol dir="auto">
<li>
<p dir="auto">Further work on module loading APIs:</p>
<ul dir="auto">
<li>Create modules via Javascript, instead of source text.</li>
<li>Scan source text for imports, for ahead of time or concurrent loading.
(This is possible with third-party tools, so lower priority.)</li>
</ul>
</li>
<li>
<p dir="auto">Higher-level tools for reading QuickJS values:</p>
<ul dir="auto">
<li>Type guard functions: <code>context.isArray(handle)</code>, <code>context.isPromise(handle)</code>, etc.</li>
<li>Iteration utilities: <code>context.getIterable(handle)</code>, <code>context.iterateObjectEntries(handle)</code>.
This better supports user-level code to deserialize complex handle objects.</li>
</ul>
</li>
<li>
<p dir="auto">Higher-level tools for creating QuickJS values:</p>
<ul dir="auto">
<li>Devise a way to avoid needing to mess around with handles when setting up
the environment.</li>
<li>Consider integrating
<a href="https://github.com/reearth/quickjs-emscripten-sync">quickjs-emscripten-sync</a>
for automatic translation.</li>
<li>Consider class-based or interface-type-based marshalling.</li>
</ul>
</li>
<li>
<p dir="auto">EcmaScript Modules / WebAssembly files / Deno support. This requires me to
learn a lot of new things, but should be interesting for modern browser usage.</p>
</li>
<li>
<p dir="auto">SQLite integration.</p>
</li>
</ol>
<h2 dir="auto"><a id="user-content-related" aria-hidden="true" href="#related"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Related</h2>
<ul dir="auto">
<li>Duktape wrapped in Wasm: <a href="https://github.com/maple3142/duktape-eval/blob/main/src/Makefile">https://github.com/maple3142/duktape-eval/blob/main/src/Makefile</a></li>
<li>QuickJS wrapped in C++: <a href="https://github.com/ftk/quickjspp">https://github.com/ftk/quickjspp</a></li>
</ul>
<h2 dir="auto"><a id="user-content-developing" aria-hidden="true" href="#developing"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Developing</h2>
<p dir="auto">This library is implemented in two languages: C (compiled to WASM with
Emscripten), and Typescript.</p>
<h3 dir="auto"><a id="user-content-the-c-parts" aria-hidden="true" href="#the-c-parts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The C parts</h3>
<p dir="auto">The ./c directory contains C code that wraps the QuickJS C library (in ./quickjs).
Public functions (those starting with <code>QTS_</code>) in ./c/interface.c are
automatically exported to native code (via a generated header) and to
Typescript (via a generated FFI class). See ./generate.ts for how this works.</p>
<p dir="auto">The C code builds as both with <code>emscripten</code> (using <code>emcc</code>), to produce WASM (or
ASM.js) and with <code>clang</code>. Build outputs are checked in, so you can iterate on
the Javascript parts of the library without setting up the Emscripten toolchain.</p>
<p dir="auto">Intermediate object files from QuickJS end up in ./build/quickjs/.</p>
<p dir="auto">This project uses <code>emscripten 3.1.7</code> via Docker. You will need a working <code>docker</code>
install to build the Emscripten artifacts.</p>
<p dir="auto">Related NPM scripts:</p>
<ul dir="auto">
<li><code>yarn update-quickjs</code> will sync the ./quickjs folder with a
github repo tracking the upstream QuickJS.</li>
<li><code>yarn make-debug</code> will rebuild C outputs into ./build/wrapper</li>
<li><code>yarn make-release</code> will rebuild C outputs in release mode, which is the mode
that should be checked into the repo.</li>
</ul>
<h3 dir="auto"><a id="user-content-the-typescript-parts" aria-hidden="true" href="#the-typescript-parts"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>The Typescript parts</h3>
<p dir="auto">The ./ts directory contains Typescript types and wraps the generated Emscripten
FFI in a more usable interface.</p>
<p dir="auto">You&#39;ll need <code>node</code> and <code>npm</code> or <code>yarn</code>. Install dependencies with <code>npm install</code>
or <code>yarn install</code>.</p>
<ul dir="auto">
<li><code>yarn build</code> produces ./dist.</li>
<li><code>yarn test</code> runs the tests.</li>
<li><code>yarn test --watch</code> watches for changes and re-runs the tests.</li>
</ul>
<h3 dir="auto"><a id="user-content-yarn-updates" aria-hidden="true" href="#yarn-updates"><svg viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a>Yarn updates</h3>
<p dir="auto">Just run <code>yarn set version from sources</code> to upgrade the Yarn release.</p>
</article>
          </div></div>
  </body>
</html>
