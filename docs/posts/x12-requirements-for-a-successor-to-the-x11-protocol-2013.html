<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.x.org/wiki/Development/X12/">Original</a>
    <h1>X12: Requirements for a successor to the X11 protocol (2013)</h1>
    
    <div id="readability-page-1" class="page"><div class="page">




<div id="pagebody">

<div id="content">




<p>X11 was defined in the middle of the 1980&#39;s. Since then, computers have changed <em>almost</em> beyond recognition; the simple framebuffer model used by computers at the time has been replaced programmable graphics hardware that is both complex and powerful. Not only has graphics hardware changed, but the basic processing model has and continues to change; parallelism in core system design is becoming the norm, rather than a special case for &#39;large&#39; systems.</p>

<p>And that&#39;s just talking about desktop systems; now there are smart phones, netbooks, tablets, and probably will shortly be other device types that this author can&#39;t imagine (else I&#39;d be working on them...).</p>

<p>In short, X11 was designed for a different era of computing.</p>

<p>This is not to say that there&#39;s an X12 project.  There isn&#39;t.  But if one day there is...</p>

<h2 id="requirementsforthesuccessortothex11protocol-x12"><a name="index1h2"></a>Requirements for the Successor to the X11 Protocol - “X12”</h2>

<p>This section is a discussion of the broad requirements for X12; discussion of the specific failings of X11 are addressed in later sections.</p>

<p>To call this subject controversial would be an understatement; there have been and continue to be many attempts to either freeze &#39;X11&#39; in time or discard it completely. Clearly, this author believes this to be wrong.</p>

<h3 id="whatisgoodaboutx11"><a name="index1h3"></a>What is Good about X11</h3>

<p>Network transparency. Network transparency rocks! Run a program on a remote system and interact with it on your local terminal; write a program and not <strong>need</strong> to care whether it&#39;s going to be run on a full workstation or a dumb terminal. Some may say this is unimportant, but when one looks at the development of Windows and the evolution of RDP, it starts to look a lot more like X in terms of its features.</p>

<h3 id="aroughlistofrequirements"><a name="index2h3"></a>A Rough List of Requirements</h3>

<h4 id="securitydesigned-infromthestart"><a name="index1h4"></a>Security designed-in from the start</h4>

<p>Systems need to be secure. X12 needs to be designed with security in mind.</p>

<h4 id="multipleplatformsupport"><a name="index2h4"></a>Multiple Platform Support</h4>

<p>X12 should be designed with mobile phones, tablets, dumb terminals, netbooks and desktop workstations in mind; if it is to succeed, it must work well on all these systems.</p>

<h4 id="maintainnetworktransparency"><a name="index3h4"></a>Maintain Network Transparency</h4>

<p>The future will be more interconnected and network-oriented, not less. Network transparency makes things easier for users and can&#39;t be considered an &#39;optional extra&#39;.</p>

<h4 id="supportmoderngraphicshardwareandrendering"><a name="index4h4"></a>Support Modern Graphics Hardware and Rendering</h4>

<p>Programmable hardware, composition; all that good stuff. X12 needs to naturally support modern hardware in a way that allows developers to gain access to the hardware without having to completely bypass X (as happens currently).</p>

<h4 id="theframebufferisdeadlonglivetheframebuffer"><a name="index5h4"></a>The Framebuffer is dead, Long Live the Framebuffer</h4>

<p>For all the talk of modern hardware, let&#39;s not forget that the framebuffer concept is still extremely useful in certain situations; killing it off completely is likely to be serious mistake.</p>

<h4 id="beasefficientaspossible"><a name="index6h4"></a>Be as Efficient as Possible</h4>

<p>X has always been a low-level protocol; inefficiencies here will hurt applications.</p>

<h4 id="thinkparallel"><a name="index7h4"></a>Think Parallel</h4>

<p>This is perhaps the hardest part of the design of X12; the approach to computation and rendering is changing with a greater emphasis parallelism. X12 should be sympathetic to being implemented on massively-parallel systems, if not actively support such systems.</p>

<p>On the other-hand, trying <em>too</em> hard in this regard is likely to be serious cause of difficulties in finalising the design of the protocol; if in doubt, the designers should work to the standards of the day, rather than attempting to predict the future.</p>

<h2 id="errorsoversightsandomissions"><a name="index2h2"></a>Errors, Oversights and Omissions</h2>

<p>This section attempts to document the failings of the X protocol and rendering model.  Learn from history, or be doomed to repeat it.</p>

<h3 id="objectmodel"><a name="index3h3"></a>Object model</h3>

<h4 id="windowscannotbezero-sized"><a name="index8h4"></a>Windows can not be zero-sized</h4>

<h4 id="colormapsarenon-obvious"><a name="index9h4"></a>Color maps are non-obvious</h4>

<h4 id="grabscanblocktoomuch"><a name="index10h4"></a>Grabs can block too much</h4>

<p>Popping up a menu and walking away can leave your screenlock unable to lock the screen since it won&#39;t be able to grab the pointer.</p>

<p>Server grabs are even worse when they lock out all other clients including those necessary for user interaction like compositing managers and accessibility helpers.</p>

<p>Current theory: Multiple clients can grab; when any grabs are active, only clients with grabs receive events.</p>

<h4 id="windowsandpixmapsarentsplitcorrectly"><a name="index11h4"></a>Windows and Pixmaps aren&#39;t split correctly</h4>

<p>You can&#39;t resize a pixmap in the X11 protocol, because you can&#39;t get events on things that aren&#39;t windows.  Lame.  Really a Window should only be an IPC name, with one or more associated pixmaps and etc.</p>

<h4 id="finegrainedevents"><a name="index12h4"></a>Fine grained events</h4>

<p><em>PropertyNotify</em> is a disaster.  And we probably want to be able to get events on things other than Windows.</p>

<h4 id="infeasibletochangecolordepthwithclientsrunning"><a name="index13h4"></a>Infeasible to change color depth with clients running</h4>

<p>Possibly not worth fixing.  However, composited by default might make it reasonable.</p>

<h3 id="renderingmodel"><a name="index4h3"></a>Rendering model</h3>

<h4 id="compositedbydefault"><a name="index14h4"></a>Composited by default</h4>

<p>Probably.  Note that we can more or less accomplish this within X11, but there are probably simplifications to be had by making this explicit in the protocol.</p>

<h4 id="nooverride-redirect"><a name="index15h4"></a>No override-redirect</h4>

<h4 id="corerenderingislargelyuseless"><a name="index16h4"></a>Core rendering is largely useless</h4>

<h4 id="widelinesbite"><a name="index17h4"></a>Wide lines bite</h4>

<h4 id="backgroundnonemakessecuritygeekscry"><a name="index18h4"></a>BackgroundNone makes security geeks cry</h4>

<p>See <span><a href="https://secure.freedesktop.org/write/xorg/ikiwiki.cgi?do=create&amp;from=Development%2FX12&amp;page=EamonWalsh" rel="nofollow">?</a>EamonWalsh</span>&#39;s talk from <a href="http://wiki.x.org/wiki/Events/XDC2008/Notes">XDevConf 2008</a>.</p>

<h4 id="bordersarestupid"><a name="index19h4"></a>Borders are stupid</h4>

<p>Which is really a special case of...</p>

<h4 id="implicitrenderingisstupid"><a name="index20h4"></a>Implicit rendering is stupid</h4>

<p>Borders and window backgrounds and the bg=None trick and backing store and saveunders and all that.</p>

<p>There&#39;s a speed/complexity tradeoff here, of course.  Any time that implicit server rendering works, it saves you exposures and round trips.  But the implicit mechanisms we have are poor fits for a composited model.  Think very carefully about adding implicit rendering to the server process; it&#39;s probably a mistake.</p>

<h3 id="encodingbugs"><a name="index5h3"></a>Encoding bugs</h3>

<h4 id="extensionspaceistoosmall"><a name="index21h4"></a>Extension space is too small</h4>

<p>The first 128 requests are core protocol; the remaining 128 are single-entry multiplex functions for extensions.  It&#39;s sort of ridiculous to have XPolyFillArc on the same footing as GLX.</p>

<p>The minor opcode &#34;convention&#34; should be formalized and made part of the standard.  The core protocol should be assigned major number zero and use minor numbers.</p>

<h4 id="xidsaretoosmall"><a name="index22h4"></a>XIDs are too small</h4>

<p>XIDs are 29 bits for some inexplicable lisp-related reason.  Client-side allocation seems like a reasonable idea for avoiding round-trips, but the need to slice the 29-bit space into client and resource parts means we have an unpleasant tradeoff.  Right now most X servers have a 256 client limit, which is uncomfortably close.</p>

<p>Should probably just bump this to uint32 for client ID and uint32 for resource ID.</p>

<h4 id="sequencenumbersaretoosmall"><a name="index23h4"></a>Sequence numbers are too small</h4>

<p>It&#39;s pretty easy to hit 16-bit sequence number wrap without getting any responses from the server, which can make interpreting later events or errors impossible. Although perhaps it would be better to introduce a <em>SequenceWrap</em> event sent every 64k requests than to grow the sequence numbers.</p>

<h4 id="bitcoordinatelimit"><a name="index24h4"></a>15 bit coordinate limit</h4>

<p>Ouch.  32768 pixels at 100dpi is 8.3 meters.</p>

<h4 id="bitnanosecond-precisiontimestamps"><a name="index25h4"></a>64 bit, nanosecond-precision timestamps</h4>

<p>585 years ftw.  The server time should be included in every event, reply, and error.  It should also be present in every request (but with the &#34;CurrentTime&#34; option available).</p>

<h4 id="cursorimageencoding"><a name="index26h4"></a>Cursor image encoding</h4>

<p>Cursors are encoded as rectangular bitmaps, so a full-screen crosshairs would be a bitmap 4 times the size of the screen. Allowing a more flexible format, such as SVG, would be good, as well as allowing smoother scaling for screen magnifiers.</p>



<p>Kill them or standardize them, preferably the former.  Note that XCB-style asynchronous requests with replies make some uses of these less important.</p>

<h4 id="thekeymapnotifyeventspecial-caseshouldgoaway"><a name="index28h4"></a>The KeymapNotify event special-case should go away</h4>

<p>All events provide a sequence number, except for the <em>KeymapNotify</em> event which wants the space for more data.</p>

<h4 id="xgebydefault"><a name="index29h4"></a>XGE by default</h4>

<p>Events and errors are a fixed packet size to make parsing easy, but they aren&#39;t big enough to convey all the information you want.  Some extensions like Xinput literally use every byte, and then some.  The X Generic Events (XGE) extension adds a mechanism for larger events.</p>

<p>XGE should become the default, rather than fixed-size events.</p>

<h4 id="char2b"><a name="index30h4"></a>CHAR2B</h4>

<p>Kill this off.  It&#39;s only used for core text, which should die.</p>

<h4 id="responsesshouldassumelessclientstate"><a name="index31h4"></a>Responses should assume less client state</h4>

<p>Replies, and probably errors, should include the major and minor opcode of the request that triggered them, to ease debugging.</p>

<h4 id="latin-1iso8859-1"><a name="index32h4"></a>Latin-1 (ISO 8859-1)</h4>

<p>Strings for Atom names and the like are required to be in Latin-1 encoding - should be replaced with UTF-8.</p>

<h4 id="lengthfieldsrequireconstantconversion"><a name="index33h4"></a>Length fields require constant conversion</h4>

<p>All requests and replies in X11 have a length field.   This is cleverly encoded as number of 32-bit words, since all packets are padded to 32-bit alignment.   This annoyingly results in tons of &lt;&lt; 2 and &gt;&gt; 2 conversions everywhere to get into useful byte counts for reading &amp; writing across the sockets.</p>

<h3 id="input"><a name="index6h3"></a>Input</h3>

<h4 id="coreinputisuseless"><a name="index34h4"></a>Core input is useless</h4>

<p>Xi and (at least some elements of) XKB need to be folded in to the core protocol and made mandatory.</p>

<h4 id="resourcelimits"><a name="index35h4"></a>Resource limits</h4>

<p>We need more than 255 keycodes, and more than 4 groups.  We also need a better mechanism for expressing state than the current field, which limits us to 5 buttons and 4 modifiers, or so.</p>

<h4 id="redirectionshouldbeintegrated"><a name="index36h4"></a>Redirection should be integrated</h4>

<p>The current deep binding of input delivery to window coordinates is garbage.  The redirection mesh idea is nice but it should be the only way.</p>

<h4 id="keysymnamesareamess"><a name="index37h4"></a>Keysym names are a mess</h4>

<p>Come up with a vastly more coherent set of keysym names than the current scattergun approach.</p>

<h3 id="designissues"><a name="index7h3"></a>Design issues</h3>

<h4 id="circulationapisincoreprotocolareemacsdisease"><a name="index38h4"></a>Circulation APIs in core protocol are emacs disease</h4>

<p>These are wildly unhelpful.  <em>CirculateWindow</em> and <em>RotateProperties</em> can taste the curb.</p>

<h4 id="screensarenothelpful"><a name="index39h4"></a>Screens are not helpful</h4>

<p>(Screens is used in the protocol sense, with displays used in the physical output device sense.)</p>

<p>This is part intractably large implementation problem (of not allowing resource sharing among screens, nor screen hotplugging), and part protocol problem (screens as defined are static, and there&#39;s no expressed relationships).  Pushing most of RandR down will help this, as well as rewriting core code.</p>

<h4 id="eventsshouldalwaysgotoawindow"><a name="index40h4"></a>Events should always go to a window</h4>

<p>Events should have a fixed destination window field, to support the idea of events delivered to windows, not to clients directly.</p>

<h4 id="movestufffromtherandomfixesextensionsintocore"><a name="index41h4"></a>Move stuff from the &#34;random fixes&#34; extensions into core</h4>

<p>Decide what from XC-Misc, MIT-SUNDRY, XFree86-Misc, and XFixes needs to go in core.</p>

<h4 id="dontsplitorduplicateaclassofrequestsacrosscoreandextensions"><a name="index42h4"></a>Don&#39;t split or duplicate a class of requests across core and extensions</h4>

<p>For instance, the core <em>ForceScreenSaver</em> and the MIT-SCREEN-SAVER extension.</p>

<h4 id="predefinedatoms"><a name="index43h4"></a>Predefined atoms</h4>

<p>ICCCM gets special pre-defined atoms, but newer standards like EWMH don&#39;t. One approach would be to identify a set of predefined atoms by the hash of the names of the atoms, allowing extensibility in which atoms to predefine in the future. The connection setup response could include a list of the atom-sets this server provides, eliminating a round-trip at startup in the common case that all the atoms a client wants are already known.</p>

<h4 id="extensioninitialization"><a name="index44h4"></a>Extension initialization</h4>

<p>With XCB we can, in principle, initialize all the extensions a client needs in two round-trips. But there aren&#39;t so many extensions in a server that we couldn&#39;t just provide the list in the connection setup reply. If that list included all the data that <em>QueryExtension</em> returns, that would eliminate one round-trip. If we standardize that every extension has a major and minor version number, and include those in the setup data as well, we can eliminate the other round-trip.</p>

<h3 id="raceconditions"><a name="index8h3"></a>Race Conditions</h3>

<h4 id="needabasicsyncrequest"><a name="index45h4"></a>Need a basic sync request</h4>

<p>Need a dedicated request that just sends back an empty reply.</p>

<h4 id="implementtheicccmsuggestions"><a name="index46h4"></a>Implement the ICCCM suggestions</h4>

<p>An <a href="http://www.x.org/releases/X11R7.7/doc/xorg-docs/icccm/icccm.html#suggested_protocol_revisions">appendix to the ICCCM</a> lists mostly trivial improvements that would simplify the procedures set forth in that document.</p>

<h2 id="referencematerial"><a name="index3h2"></a>Reference material</h2>

<ul>
<li><a href="http://www.std.org/~msm/common/protocol.pdf">Why X Is Not Our Ideal Window System</a></li>
<li><a href="http://hack.org/mc/texts/gosling-wsd.pdf">Window System Design: If I had it to do over again in 2002</a></li>
</ul>

<p>etc.</p>

</div>





</div>



</div></div>
  </body>
</html>
