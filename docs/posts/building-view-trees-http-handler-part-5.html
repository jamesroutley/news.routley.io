<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/">Original</a>
    <h1>Building view-trees: http.Handler [Part 5]</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        

        

        
        <section>
            <ul>
                
                <li>
                    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#an-aside-small-improvements">An Aside: Small Improvements</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#parsing-templates-from-separate-files">Parsing templates from separate files</a>
                        </li>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#others">Others</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#the-http-server">The HTTP Server</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#views-are-a-function-of-requests-and-routes">Views are a function of requests and routes</a>
                        </li>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#testing">Testing</a>
                        </li>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#more-funcs">More Funcs</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#composing-requestrenderable">Composing RequestRenderable</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#why-do-we-even-care">Why do we even care?</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#fixing-the-abstraction">Fixing the abstraction</a>
                    
                    <ul>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#http-handler">http.Handler</a>
                        </li>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#error-handling">Error Handling</a>
                        </li>
                        
                        <li>
                            <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#adding-the-error-delegate-option">Adding the error delegate option</a>
                        </li>
                        
                    </ul>
                    
                </li>
                
                <li>
                    <a href="https://www.stanistan.com/writes/building-view-trees-in-go-part-5/#putting-it-together">Putting it together</a>
                    
                </li>
                
            </ul>
        </section>
        

        <section>
            <p>Previously: <a href="https://tacf.org/writes/building-view-trees-in-go-part-1">intro</a>, <a href="https://tacf.org/writes/building-view-trees-in-go-part-2">the basics</a>, <a href="https://tacf.org/writes/building-view-trees-in-go-part-3">error handling</a>,
and <a href="https://tacf.org/writes/building-view-trees-in-go-part-4">async data fetching</a>.</p>
<hr/>
<h2 id="an-aside-small-improvements">An Aside: Small Improvements</h2>
<p>Before we go forward, let&#39;s make some small quality of life improvements.</p>
<h3 id="parsing-templates-from-separate-files">Parsing templates from separate files</h3>
<p>We&#39;ve had all of our templates be inlined in strings before. This is
fine for testing, but when we&#39;re building an app, we&#39;ll want to have
something in place for loading/embedding our templates diffently.</p>










<div>
  <details>
    <summary>
      tempalte FS parsing
      <a href="https://github.com/stanistan/veun/commit/cde937033d46b06c8fb959e745df8d73436c4267">(source: cde93703)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/view.go b/view.go
</span><span>index 97f02f5..f092749 100644
</span><span>---</span><span> a/view.go
</span><span>+++</span><span> b/view.go
</span><span>@@ -3,6 +3,7 @@ package veun
</span><span> import (
</span><span> 	&#34;context&#34;
</span><span> 	&#34;html/template&#34;
</span><span>+</span><span>	&#34;io/fs&#34;
</span><span> )
</span><span> 
</span><span> type View struct {
</span><span>@@ -27,10 +28,16 @@ func slotFuncStub(name string) (template.HTML, error) {
</span><span> 	return template.HTML(&#34;&#34;), nil
</span><span> }
</span><span> 
</span><span>+</span><span>func newTemplate(name string) *template.Template {
</span><span>+</span><span>	return template.New(name).Funcs(template.FuncMap{
</span><span>+</span><span>		&#34;slot&#34;: slotFuncStub,
</span><span>+</span><span>	})
</span><span>+</span><span>}
</span><span>+
</span><span> func MustParseTemplate(name, contents string) *template.Template {
</span><span>-	return template.Must(
</span><span>-		template.New(name).
</span><span>-			Funcs(template.FuncMap{&#34;slot&#34;: slotFuncStub}).
</span><span>-			Parse(contents),
</span><span>-	)
</span><span>+</span><span>	return template.Must(newTemplate(name).Parse(contents))
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func MustParseTemplateFS(f fs.FS, ps ...string) *template.Template {
</span><span>+</span><span>	return template.Must(newTemplate(&#34;ROOT&#34;).ParseFS(f, ps...))
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<pre data-lang="go"><code data-lang="go"><span>import </span><span>&#34;embed&#34;
</span><span>
</span><span>var </span><span>(
</span><span>    </span><span>//go:embed templates
</span><span>    templatesFS embed.</span><span>FS
</span><span>    templates   </span><span>= </span><span>MustParseTemplateFS(templatesFS, </span><span>&#34;templates/*.tpl&#34;</span><span>)
</span><span>)
</span></code></pre>
<p>If our templates are malformed, this will panic during startup or test
time.</p>
<pre data-lang="go"><code data-lang="go"><span>View{
</span><span>    </span><span>// ...
</span><span>    Tpl: templates.Lookup(</span><span>&#34;my_view.tpl&#34;</span><span>),
</span><span>}
</span></code></pre>
<h3 id="others">Others</h3>
<h4 id="slots-can-be-nil-views">Slots can be nil views</h4>










<div>
  <details>
    <summary>
      slot can be nil, we return empty
      <a href="https://github.com/stanistan/veun/commit/35883748e5b08774c57ae582bc5e700eb053161c">(source: 35883748)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/slots.go b/slots.go
</span><span>index 61f7fb4..8a04e81 100644
</span><span>---</span><span> a/slots.go
</span><span>+++</span><span> b/slots.go
</span><span>@@ -10,7 +10,7 @@ type Slots map[string]AsRenderable
</span><span> func (s Slots) renderSlot(ctx context.Context) func(string) (template.HTML, error) {
</span><span> 	return func(name string) (template.HTML, error) {
</span><span> 		slot, ok := s[name]
</span><span>-		if ok {
</span><span>+</span><span>		if ok &amp;&amp; slot != nil {
</span><span> 			return Render(ctx, slot)
</span><span> 		}
</span><span> 
</span><span>
</span></code></pre>


  </details>
</div>
<p>This is a design decision, but we allow a view to be empty/nil and then
we don&#39;t render it. We might want to move this into <code>Render</code>, but
this can be here as well.</p>
<h4 id="documentation">Documentation</h4>
<p>Adding some documentation to our public functions and types.</p>










<div>
  <details>
    <summary>
      doc comments
      <a href="https://github.com/stanistan/veun/commit/2b70959caf5740686880054be3ef90289d73cce9">(source: 2b70959c)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/renderable.go b/renderable.go
</span><span>index 57f3791..27759f6 100644
</span><span>---</span><span> a/renderable.go
</span><span>+++</span><span> b/renderable.go
</span><span>@@ -5,17 +5,25 @@ import (
</span><span> 	&#34;html/template&#34;
</span><span> )
</span><span> 
</span><span>+</span><span>// Renderable represents any struct that can be rendered
</span><span>+</span><span>// in the Render function.
</span><span> type Renderable interface {
</span><span>+</span><span>	// Template provides the template object / parsed and compiled,
</span><span>+</span><span>	// that Render will execute given a context.
</span><span> 	Template(ctx context.Context) (*template.Template, error)
</span><span>+</span><span>	// TemplateData provides the data to the template given a context.
</span><span> 	TemplateData(ctx context.Context) (any, error)
</span><span> }
</span><span> 
</span><span> type AsRenderable interface {
</span><span>+</span><span>	// Renderable produces a Renderable struct given a context.
</span><span> 	Renderable(ctx context.Context) (Renderable, error)
</span><span> }
</span><span> 
</span><span>+</span><span>// RenderableFunc is a function that conforms to the Renderable interface.
</span><span> type RenderableFunc func(context.Context) (Renderable, error)
</span><span> 
</span><span>+</span><span>// Renderable implements Renderable for RenderableFunc.
</span><span> func (f RenderableFunc) Renderable(ctx context.Context) (Renderable, error) {
</span><span> 	return f(ctx)
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<h4 id="more-meaningful-library-errors">More meaningful library errors</h4>
<p>These should be custom error types but for now this is ok.</p>










<div>
  <details>
    <summary>
      error wrapping
      <a href="https://github.com/stanistan/veun/commit/7008a944d4b4997f862326e7eff9c5b7afced7ce">(source: 7008a944)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/renderer.go b/renderer.go
</span><span>index ebbddef..fe37ba0 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -26,7 +26,7 @@ func render(ctx context.Context, r Renderable) (template.HTML, error) {
</span><span> 
</span><span> 	tpl, err := r.Template(ctx)
</span><span> 	if err != nil {
</span><span>-		return empty, err
</span><span>+</span><span>		return empty, fmt.Errorf(&#34;Template: %w&#34;, err)
</span><span> 	}
</span><span> 
</span><span> 	if tpl == nil {
</span><span>@@ -35,12 +35,12 @@ func render(ctx context.Context, r Renderable) (template.HTML, error) {
</span><span> 
</span><span> 	data, err := r.TemplateData(ctx)
</span><span> 	if err != nil {
</span><span>-		return empty, err
</span><span>+</span><span>		return empty, fmt.Errorf(&#34;TemplateData: %w&#34;, err)
</span><span> 	}
</span><span> 
</span><span> 	var bs bytes.Buffer
</span><span> 	if err := tpl.Execute(&amp;bs, data); err != nil {
</span><span>-		return empty, err
</span><span>+</span><span>		return empty, fmt.Errorf(&#34;tpl.Execute: %w&#34;, err)
</span><span> 	}
</span><span> 
</span><span> 	return template.HTML(bs.String()), nil
</span><span>
</span></code></pre>


  </details>
</div>
<h2 id="the-http-server">The HTTP Server</h2>
<p>In Go, there is one fundamental interface for serving an HTTP endpoint,
<a rel="nofollow noreferrer" href="https://pkg.go.dev/net/http#Handler"><code>http.Handler</code></a>. In practice, you can either make a type
that implements <code>ServeHTTP(...)</code> or use <code>http.HandlerFunc</code> to make a
function into a handler. For us, with views and renderables, this is
a bit too low level. We want:</p>
<ul>
<li>Something that can produce views based on a request.</li>
<li>Something that will allow us to do redirects and 404s.</li>
<li>To integrate well with standard http handlers and middleware.</li>
<li>To have short meaningful routes.</li>
<li>To maintain flexibility and composability.</li>
<li>TO NOT build our own router.</li>
</ul>
<h3 id="views-are-a-function-of-requests-and-routes">Views are a function of requests and routes</h3>
<p>In the simplest case, a view/renderable can be produced by a request.
We keep our the views simple and they don&#39;t know anything about
where their inputs come from.</p>
<p>I can imagine having different kind of constructing functions
for the view type as well.</p>
<pre data-lang="go"><code data-lang="go"><span>package </span><span>some_view
</span><span>
</span><span>import </span><span>(
</span><span>    </span><span>&#34;net/http&#34;
</span><span>
</span><span>    </span><span>&#34;github.com/stanistan/veun&#34;
</span><span>)
</span><span>
</span><span>type </span><span>FromRequest(</span><span>r *</span><span>http.</span><span>Request</span><span>) (veun.AsRenderable, error) {
</span><span>    </span><span>return </span><span>myView{</span><span>/* */</span><span>}, </span><span>nil
</span><span>}
</span></code></pre>
<p>This is a good start and we can write a handler that works with
this type of function.</p>
<p>We&#39;re going to <code>panic</code> everywhere for error handling for the moment
because what that&#39;s a problem for future us to solve.</p>
<pre data-lang="go"><code data-lang="go"><span>http.HandlerFunc(</span><span>func</span><span>(w http.</span><span>ResponseWriter</span><span>, r </span><span>*</span><span>http.</span><span>Request</span><span>) {
</span><span>    view, err </span><span>:= </span><span>some_view.FromRequest(r)
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>panic</span><span>(err)
</span><span>    }
</span><span>
</span><span>    html, err </span><span>:= </span><span>Render(r.Context(), view)
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>panic</span><span>(err)
</span><span>    }
</span><span>
</span><span>    _, err </span><span>= </span><span>w.Write([]</span><span>byte</span><span>(html))
</span><span>    </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>        </span><span>panic</span><span>(err)
</span><span>    }
</span><span>})
</span></code></pre>
<p>The only thing that is specific to that route (that isn&#39;t part of
the rendering behavior) is <code>FromRequest</code>.</p>
<p>And we can extract it into an interface (and function type) that can
produce either a view or error out.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>RequestRenderable </span><span>interface </span><span>{
</span><span>    </span><span>RequestRenderable</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>)
</span><span>}
</span><span>
</span><span>type </span><span>RequestRenderableFunc </span><span>func</span><span>(</span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>)
</span><span>
</span><span>func </span><span>(f </span><span>RequestRenderableFunc</span><span>) </span><span>RequestRenderable</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>f(r)
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      Adding RequestRenderable &amp; Func
      <a href="https://github.com/stanistan/veun/commit/bda46e00f7b324f3f9e456d0de9a2531adfe0518">(source: bda46e00)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>new file mode 100644
</span><span>index 0000000..66700c8
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -0,0 +1,21 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;net/http&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>// RequestRenderable represents a method that
</span><span>+</span><span>// can create a view out of an http.Request.
</span><span>+</span><span>type RequestRenderable interface {
</span><span>+</span><span>	RequestRenderable(r *http.Request) (AsRenderable, error)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// RequestRenderableFunc is the function representation of a
</span><span>+</span><span>// RequestRenderable.
</span><span>+</span><span>type RequestRenderableFunc func(*http.Request) (AsRenderable, error)
</span><span>+
</span><span>+</span><span>// RequestRenderable conforms RequestRenderableFunc to
</span><span>+</span><span>// RequestRenderable interface.
</span><span>+</span><span>func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable, error) {
</span><span>+</span><span>	return f(r)
</span><span>+</span><span>}
</span><span>
</span></code></pre>


  </details>
</div>
<p>And to make a handler:</p>
<pre data-lang="go"><code data-lang="go"><span>func</span><span>(renderable </span><span>RequestRenderable</span><span>) http.</span><span>Handler </span><span>{
</span><span>    </span><span>return </span><span>http.HandlerFunc(</span><span>func</span><span>(w http.</span><span>ResponseWriter</span><span>, r </span><span>*</span><span>http.</span><span>Request</span><span>) {
</span><span>        </span><span>// snip...
</span><span>        view, err </span><span>:= </span><span>renderable.RequestRenderable(r)
</span><span>        </span><span>// snip ...
</span><span>    })
</span><span>}
</span></code></pre>
<p>We can extract this into a type:</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>HTTPHandler </span><span>struct </span><span>{
</span><span>    r </span><span>RequestRenderable
</span><span>}
</span><span>
</span><span>func </span><span>(h </span><span>HTTPHandler</span><span>) </span><span>ServeHTTP</span><span>(w http.</span><span>ResponseWriter</span><span>, r </span><span>*</span><span>http.</span><span>Request</span><span>) {
</span><span>    view, err </span><span>:= </span><span>h.r.RequestRenderable(r)
</span><span>    </span><span>// ...
</span><span>}
</span></code></pre>










<div>
  <details>
    <summary>
      Initial HTTPHandler (with panics)
      <a href="https://github.com/stanistan/veun/commit/4f37b29cf27abf2e516c922a4353f784e6c996cf">(source: 4f37b29c)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index 66700c8..8d5f5c0 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -19,3 +19,26 @@ type RequestRenderableFunc func(*http.Request) (AsRenderable, error)
</span><span> func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable, error) {
</span><span> 	return f(r)
</span><span> }
</span><span>+
</span><span>+</span><span>// HTTPHandler implements http.Handler for a RequestRenderable.
</span><span>+</span><span>type HTTPHandler struct {
</span><span>+</span><span>	Renderable RequestRenderable
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// ServeHTTP implements http.Handler.
</span><span>+</span><span>func (h HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span>+</span><span>	renderable, err := h.Renderable.RequestRenderable(r)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		panic(err)
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	html, err := Render(r.Context(), renderable)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		panic(err)
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	_, err = w.Write([]byte(html))
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		panic(err)
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>
</span></code></pre>


  </details>
</div>
<p>And our route definition can look more like this:</p>
<pre data-lang="go"><code data-lang="go"><span>mux </span><span>:= </span><span>http.NewServeMux()
</span><span>
</span><span>mux.Handle(</span><span>&#34;/empty&#34;</span><span>, HTTPHandler{
</span><span>    RequestRenderableFunc(</span><span>func</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>        </span><span>return </span><span>nil</span><span>, </span><span>nil
</span><span>    }),
</span><span>})
</span></code></pre>
<h3 id="testing">Testing</h3>
<p>Of course we can write an HTTP server using the standard library, <em>but</em> Go also
provides <code>net/http/httptest</code>, where we can start a server and make requests
to it as if it were remote from our tests.</p>
<pre data-lang="go"><code data-lang="go"><span>srv </span><span>:= </span><span>httptest.NewServer(mux)
</span><span>// and we can make requests to srv.URL
</span></code></pre>










<div>
  <details>
    <summary>
      First test for the http handler
      <a href="https://github.com/stanistan/veun/commit/cf9d6bbd91707b0bf8eeca426d9d2f2f876038ef">(source: cf9d6bbd)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>new file mode 100644
</span><span>index 0000000..04f6f6b
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -0,0 +1,57 @@
</span><span>+</span><span>package veun_test
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;io/ioutil&#34;
</span><span>+</span><span>	&#34;net/http&#34;
</span><span>+</span><span>	&#34;net/http/httptest&#34;
</span><span>+</span><span>	&#34;testing&#34;
</span><span>+
</span><span>+</span><span>	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>+</span><span>	&#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>func TestRequestBasicHandler(t *testing.T) {
</span><span>+</span><span>	var handler = veun.HTTPHandler{
</span><span>+</span><span>		veun.RequestRenderableFunc(func(r *http.Request) (veun.AsRenderable, error) {
</span><span>+</span><span>			return nil, nil
</span><span>+</span><span>		}),
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	mux := http.NewServeMux()
</span><span>+
</span><span>+</span><span>	mux.Handle(&#34;/empty&#34;, handler)
</span><span>+
</span><span>+</span><span>	server := httptest.NewServer(mux)
</span><span>+</span><span>	defer server.Close()
</span><span>+
</span><span>+</span><span>	var sendRequest = func(t *testing.T, to string) (string, int, error) {
</span><span>+</span><span>		t.Helper()
</span><span>+
</span><span>+</span><span>		req, err := http.NewRequestWithContext(context.TODO(), &#34;GET&#34;, server.URL+to, nil)
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+
</span><span>+</span><span>		res, err := http.DefaultClient.Do(req)
</span><span>+</span><span>		if err != nil {
</span><span>+</span><span>			return &#34;&#34;, 0, err
</span><span>+</span><span>		}
</span><span>+
</span><span>+</span><span>		defer res.Body.Close()
</span><span>+
</span><span>+</span><span>		data, err := ioutil.ReadAll(res.Body)
</span><span>+</span><span>		assert.NoError(t, err)
</span><span>+
</span><span>+</span><span>		return string(data), res.StatusCode, nil
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	t.Run(&#34;the root path is a real server that 404s&#34;, func(t *testing.T) {
</span><span>+</span><span>		_, code, _ := sendRequest(t, &#34;/&#34;)
</span><span>+</span><span>		assert.Equal(t, 404, code)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;empty handler is indeed empty&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/empty&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 200, code)
</span><span>+</span><span>	})
</span><span>+</span><span>}
</span><span>
</span></code></pre>


  </details>
</div>
<p>Our example above ended up unearthing a bug where that was not safe to do,
but it should be-- in our error handlers and the slot we allow for a view
to be <code>nil</code>.</p>










<div>
  <details>
    <summary>
      fix: safe to pass nil to renderer
      <a href="https://github.com/stanistan/veun/commit/eedee59249cc4308a7262d0fd0a4112e1d707248">(source: eedee592)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/renderer.go b/renderer.go
</span><span>index fe37ba0..8546abc 100644
</span><span>---</span><span> a/renderer.go
</span><span>+++</span><span> b/renderer.go
</span><span>@@ -8,6 +8,10 @@ import (
</span><span> )
</span><span> 
</span><span> func Render(ctx context.Context, r AsRenderable) (template.HTML, error) {
</span><span>+</span><span>	if r == nil {
</span><span>+</span><span>		return template.HTML(&#34;&#34;), nil
</span><span>+</span><span>	}
</span><span>+
</span><span> 	renderable, err := r.Renderable(ctx)
</span><span> 	if err != nil {
</span><span> 		return handleRenderError(ctx, err, r)
</span><span>
</span></code></pre>


  </details>
</div>
<h3 id="more-funcs">More Funcs</h3>
<p>We can add convenience constructors to the <code>HTTPHandler{RequestRenderable...}</code>
pattern, and this becomes a bit nicer to deal with.</p>
<pre data-lang="go"><code data-lang="go"><span>var </span><span>empty </span><span>= </span><span>RequestRenderableFunc(
</span><span>    </span><span>func</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>        </span><span>return </span><span>nil</span><span>, </span><span>nil
</span><span>    },
</span><span>)
</span><span>
</span><span>mux.Handle(</span><span>&#34;/empty&#34;</span><span>, HTTPHandler{empty})
</span></code></pre>
<p>Every change we make to how we represent requets/renderables and handlers
will be captured in these tests going forward.</p>










<div>
  <details>
    <summary>
      convenience function RequestHandlerFunc
      <a href="https://github.com/stanistan/veun/commit/791b18a1bad686f575176c63dd504284d61d6a81">(source: 791b18a1)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index 8d5f5c0..9a0c7c5 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -20,6 +20,14 @@ func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable,
</span><span> 	return f(r)
</span><span> }
</span><span> 
</span><span>+</span><span>func RequestHandlerFunc(r RequestRenderableFunc) http.Handler {
</span><span>+</span><span>	return HTTPHandler{Renderable: r}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func RequestHandler(r RequestRenderable) http.Handler {
</span><span>+</span><span>	return HTTPHandler{Renderable: r}
</span><span>+</span><span>}
</span><span>+
</span><span> // HTTPHandler implements http.Handler for a RequestRenderable.
</span><span> type HTTPHandler struct {
</span><span> 	Renderable RequestRenderable
</span><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>index 04f6f6b..8298521 100644
</span><span>---</span><span> a/http_request_test.go
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -12,11 +12,9 @@ import (
</span><span> )
</span><span> 
</span><span> func TestRequestBasicHandler(t *testing.T) {
</span><span>-	var handler = veun.HTTPHandler{
</span><span>-		veun.RequestRenderableFunc(func(r *http.Request) (veun.AsRenderable, error) {
</span><span>-			return nil, nil
</span><span>-		}),
</span><span>-	}
</span><span>+</span><span>	var handler = veun.RequestHandlerFunc(func(r *http.Request) (veun.AsRenderable, error) {
</span><span>+</span><span>		return nil, nil
</span><span>+</span><span>	})
</span><span> 
</span><span> 	mux := http.NewServeMux()
</span><span> 
</span><span>
</span></code></pre>


  </details>
</div>
<h2 id="composing-requestrenderable">Composing RequestRenderable</h2>
<p>I&#39;m a big fan of interfaces that work well together and are self-consistent.
Views and renderables compose well together (using slots and delegation), we
are making trees of views after all. And the tree itself is renderable, just
like a node in the tree is-- at some point we don&#39;t really have to care too
much.</p>
<p>Turns out we have a very similar pattern available to us with <code>RequestRenderable</code>
types.</p>
<h3 id="why-do-we-even-care">Why do we even care?</h3>
<p>In a real world web application, you are going to end up up with standard a container
view at the top level signifying the <code>&lt;html&gt;...</code> and whatever application and page chrome
you need.</p>
<pre data-lang="go"><code data-lang="go"><span>var </span><span>htmlTpl </span><span>= </span><span>MustParseTemplate(</span><span>&#34;html&#34;</span><span>, </span><span>`&lt;html&gt;&lt;body&gt;</span><span>{{ slot </span><span>&#34;body&#34; </span><span>}}</span><span>&lt;/body&gt;&lt;/html&gt;`</span><span>)
</span><span>
</span><span>type </span><span>html </span><span>struct </span><span>{
</span><span>    Body  </span><span>AsRenderable
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>html</span><span>) </span><span>Renderable</span><span>(_ context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>View{Tpl: htmlTpl, Slots: Slots{</span><span>&#34;body&#34;</span><span>: v.Body}}, </span><span>nil
</span><span>}
</span></code></pre>
<p>Having each <code>RequestRenderable</code> be aware of which wrapper view is needed might be
annoying, and ends up making our functions less re-usable across different contexts.</p>
<p><em>But,</em> we can re-use the interface (similar to the middleware pattern).</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>HTML</span><span>(renderable </span><span>RequestRenderable</span><span>) </span><span>RequestRenderable </span><span>{
</span><span>    </span><span>return </span><span>RequestRenderableFunc(</span><span>func</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>        v, err </span><span>:= </span><span>renderable.RequestRenderable(r)
</span><span>        </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>            </span><span>return </span><span>nil</span><span>, err
</span><span>        }
</span><span>
</span><span>        </span><span>return </span><span>html{Body: v}, </span><span>nil
</span><span>    })
</span><span>}
</span></code></pre>
<p>Or more clearly:</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>HTML</span><span>(renderable </span><span>RequestRenderable</span><span>) http.</span><span>Handler </span><span>{
</span><span>    </span><span>return </span><span>RequestHandlerFunc( </span><span>/* ... */ </span><span>)
</span><span>}
</span></code></pre>
<p>So we can:</p>
<pre data-lang="go"><code data-lang="go"><span>mux.handle(</span><span>&#34;/html/empty&#34;</span><span>, HTML(empty))
</span></code></pre>










<div>
  <details>
    <summary>
      Adding tests for HTML()
      <a href="https://github.com/stanistan/veun/commit/74eeff3c00dda3cb5e92278cb3e1b0a76af560a7">(source: 74eeff3c)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>index 8298521..7df31ba 100644
</span><span>---</span><span> a/http_request_test.go
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -2,23 +2,55 @@ package veun_test
</span><span> 
</span><span> import (
</span><span> 	&#34;context&#34;
</span><span>+</span><span>	&#34;fmt&#34;
</span><span> 	&#34;io/ioutil&#34;
</span><span> 	&#34;net/http&#34;
</span><span> 	&#34;net/http/httptest&#34;
</span><span> 	&#34;testing&#34;
</span><span> 
</span><span> 	&#34;github.com/alecthomas/assert/v2&#34;
</span><span>-	&#34;github.com/stanistan/veun&#34;
</span><span>+</span><span>	. &#34;github.com/stanistan/veun&#34;
</span><span> )
</span><span> 
</span><span>-func TestRequestBasicHandler(t *testing.T) {
</span><span>-	var handler = veun.RequestHandlerFunc(func(r *http.Request) (veun.AsRenderable, error) {
</span><span>+</span><span>var htmlTpl = MustParseTemplate(&#34;html&#34;, `&lt;html&gt;&lt;body&gt;{{ slot &#34;body&#34; }}&lt;/body&gt;&lt;/html&gt;`)
</span><span>+
</span><span>+</span><span>type html struct {
</span><span>+</span><span>	Body AsRenderable
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v html) Renderable(_ context.Context) (Renderable, error) {
</span><span>+</span><span>	return View{Tpl: htmlTpl, Slots: Slots{&#34;body&#34;: v.Body}}, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func HTML(renderable RequestRenderable) http.Handler {
</span><span>+</span><span>	return RequestHandlerFunc(func(r *http.Request) (AsRenderable, error) {
</span><span>+</span><span>		v, err := renderable.RequestRenderable(r)
</span><span>+</span><span>		if err != nil {
</span><span>+</span><span>			return nil, err
</span><span>+</span><span>		}
</span><span>+
</span><span>+</span><span>		return html{Body: v}, nil
</span><span>+</span><span>	})
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func TestRequestRequestHandler(t *testing.T) {
</span><span>+</span><span>	var empty = RequestRenderableFunc(func(r *http.Request) (AsRenderable, error) {
</span><span> 		return nil, nil
</span><span> 	})
</span><span> 
</span><span> 	mux := http.NewServeMux()
</span><span> 
</span><span>-	mux.Handle(&#34;/empty&#34;, handler)
</span><span>+</span><span>	mux.Handle(&#34;/empty&#34;, RequestHandlerFunc(empty))
</span><span>+</span><span>	mux.Handle(&#34;/html/empty&#34;, HTML(empty))
</span><span>+
</span><span>+</span><span>	mux.Handle(&#34;/person&#34;, RequestHandlerFunc(func(r *http.Request) (AsRenderable, error) {
</span><span>+</span><span>		name := r.URL.Query().Get(&#34;name&#34;)
</span><span>+</span><span>		if name == &#34;&#34; {
</span><span>+</span><span>			return nil, fmt.Errorf(&#34;missing name&#34;)
</span><span>+</span><span>		}
</span><span>+
</span><span>+</span><span>		return PersonView(Person{Name: name}), nil
</span><span>+</span><span>	}))
</span><span> 
</span><span> 	server := httptest.NewServer(mux)
</span><span> 	defer server.Close()
</span><span>@@ -52,4 +84,22 @@ func TestRequestBasicHandler(t *testing.T) {
</span><span> 		assert.Equal(t, &#34;&#34;, body)
</span><span> 		assert.Equal(t, 200, code)
</span><span> 	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;person renders (name=Stan)&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/person?name=Stan&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;&lt;div&gt;Hi, Stan.&lt;/div&gt;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 200, code)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;person renders (name=someone)&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/person?name=someone&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;&lt;div&gt;Hi, someone.&lt;/div&gt;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 200, code)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;/html/empty&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/html/empty&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 200, code)
</span><span>+</span><span>	})
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<h2 id="fixing-the-abstraction">Fixing the abstraction</h2>
<p>While this is <em>nice</em>, we&#39;ve lost some functionality, and no longer have answers
to the questions:</p>
<ul>
<li>How will we redirect?</li>
<li>What if we want to 404?</li>
<li>What if we want to send back http response headers?</li>
<li>What is our error handling strategy?</li>
</ul>
<p>And real applications <em>need answers</em> to these questions.</p>
<p>The current implementation will either fail (with panics, for now), or render a <code>200</code>.</p>
<p>I&#39;ve played around with having this return an <code>Response</code> struct or something
like that, which would create different levels of composition with usage that
is something like this:</p>
<p><strong>Standard response, <code>200</code> with rendered view:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>Response(view), </span><span>nil
</span></code></pre>
<p><strong>Rendered view with custom status code:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>Response(view, StatusCode(</span><span>404</span><span>)), </span><span>nil
</span></code></pre>
<p><strong>An empty 404</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>NotFoundResponse()
</span></code></pre>
<p><strong>Redirects</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>RedirectResponse(</span><span>301</span><span>, toLocation)
</span></code></pre>
<p>Looking at this, and remembering we want to be compatible with
the standard library, what we&#39;re really doing here is building
things that implememnt <code>http.Handler</code>. This is really powerful.</p>
<p>The problem with the above approach is we lose library composability,
as soon as we are dealing with <code>http.Handler</code> we can longer extract
view information.</p>
<h3 id="http-handler">http.Handler</h3>
<p>But we can do both! Go obviously has multiple return values, so
let&#39;s add <em>one more</em> to our <code>RequestRenderable</code>.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>RequestRenderable </span><span>interface </span><span>{
</span><span>    </span><span>RequestRenderable</span><span>(</span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, http.</span><span>Handler</span><span>, </span><span>error</span><span>)
</span><span>}
</span></code></pre>
<p>To go back through our examples above usage would be:</p>
<p><strong>Standard response, <code>200</code> with rendered view:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>view, </span><span>nil</span><span>, </span><span>nil
</span></code></pre>
<p><strong>Rendered view with custom status code:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>view, StatusCode(</span><span>404</span><span>), </span><span>nil
</span></code></pre>
<p><strong>An empty 404:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>nil</span><span>, http.NotFoundHandler(), </span><span>nil
</span></code></pre>
<p><strong>Redirects:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>nil</span><span>, http.RedirectHandler(toLocation, </span><span>301</span><span>), </span><span>nil
</span></code></pre>
<p><strong>Custom Response Headers:</strong></p>
<pre data-lang="go"><code data-lang="go"><span>return </span><span>view, ResponseHeader(</span><span>...</span><span>), </span><span>nil
</span></code></pre>
<p>This means we have the optionality of adding http handlers to our response
but <em>also</em> have the types and flexibility to do view composition
in our request handers.</p>










<div>
  <details>
    <summary>
      Adding http.Handler as a return parameter to RequestRenderable
      <a href="https://github.com/stanistan/veun/commit/db0d1a58bc9e0aa7c68c258bc11c587f830a6901">(source: db0d1a58)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index 9a0c7c5..1ff20bc 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -7,16 +7,16 @@ import (
</span><span> // RequestRenderable represents a method that
</span><span> // can create a view out of an http.Request.
</span><span> type RequestRenderable interface {
</span><span>-	RequestRenderable(r *http.Request) (AsRenderable, error)
</span><span>+</span><span>	RequestRenderable(r *http.Request) (AsRenderable, http.Handler, error)
</span><span> }
</span><span> 
</span><span> // RequestRenderableFunc is the function representation of a
</span><span> // RequestRenderable.
</span><span>-type RequestRenderableFunc func(*http.Request) (AsRenderable, error)
</span><span>+</span><span>type RequestRenderableFunc func(*http.Request) (AsRenderable, http.Handler, error)
</span><span> 
</span><span> // RequestRenderable conforms RequestRenderableFunc to
</span><span> // RequestRenderable interface.
</span><span>-func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable, error) {
</span><span>+</span><span>func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 	return f(r)
</span><span> }
</span><span> 
</span><span>@@ -35,7 +35,7 @@ type HTTPHandler struct {
</span><span> 
</span><span> // ServeHTTP implements http.Handler.
</span><span> func (h HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span>-	renderable, err := h.Renderable.RequestRenderable(r)
</span><span>+</span><span>	renderable, _, err := h.Renderable.RequestRenderable(r)
</span><span> 	if err != nil {
</span><span> 		panic(err)
</span><span> 	}
</span><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>index 7df31ba..23051c5 100644
</span><span>---</span><span> a/http_request_test.go
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -23,33 +23,33 @@ func (v html) Renderable(_ context.Context) (Renderable, error) {
</span><span> }
</span><span> 
</span><span> func HTML(renderable RequestRenderable) http.Handler {
</span><span>-	return RequestHandlerFunc(func(r *http.Request) (AsRenderable, error) {
</span><span>-		v, err := renderable.RequestRenderable(r)
</span><span>+</span><span>	return RequestHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span>+</span><span>		v, next, err := renderable.RequestRenderable(r)
</span><span> 		if err != nil {
</span><span>-			return nil, err
</span><span>+</span><span>			return nil, next, err
</span><span> 		}
</span><span> 
</span><span>-		return html{Body: v}, nil
</span><span>+</span><span>		return html{Body: v}, next, nil
</span><span> 	})
</span><span> }
</span><span> 
</span><span> func TestRequestRequestHandler(t *testing.T) {
</span><span>-	var empty = RequestRenderableFunc(func(r *http.Request) (AsRenderable, error) {
</span><span>-		return nil, nil
</span><span>+</span><span>	var empty = RequestRenderableFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span>+</span><span>		return nil, nil, nil
</span><span> 	})
</span><span> 
</span><span> 	mux := http.NewServeMux()
</span><span> 
</span><span>-	mux.Handle(&#34;/empty&#34;, RequestHandlerFunc(empty))
</span><span>+</span><span>	mux.Handle(&#34;/empty&#34;, RequestHandler(empty))
</span><span> 	mux.Handle(&#34;/html/empty&#34;, HTML(empty))
</span><span> 
</span><span>-	mux.Handle(&#34;/person&#34;, RequestHandlerFunc(func(r *http.Request) (AsRenderable, error) {
</span><span>+</span><span>	mux.Handle(&#34;/person&#34;, RequestHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 		name := r.URL.Query().Get(&#34;name&#34;)
</span><span> 		if name == &#34;&#34; {
</span><span>-			return nil, fmt.Errorf(&#34;missing name&#34;)
</span><span>+</span><span>			return nil, nil, fmt.Errorf(&#34;missing name&#34;)
</span><span> 		}
</span><span> 
</span><span>-		return PersonView(Person{Name: name}), nil
</span><span>+</span><span>		return PersonView(Person{Name: name}), nil, nil
</span><span> 	}))
</span><span> 
</span><span> 	server := httptest.NewServer(mux)
</span><span>
</span></code></pre>


  </details>
</div>










<div>
  <details>
    <summary>
      one-liner implementation for our HTTPHandler
      <a href="https://github.com/stanistan/veun/commit/2b9f6914a5b601be10aa63954e68a50229ee7cc6">(source: 2b9f6914)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index 1ff20bc..5d6bf82 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -35,7 +35,7 @@ type HTTPHandler struct {
</span><span> 
</span><span> // ServeHTTP implements http.Handler.
</span><span> func (h HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span>-	renderable, _, err := h.Renderable.RequestRenderable(r)
</span><span>+</span><span>	renderable, next, err := h.Renderable.RequestRenderable(r)
</span><span> 	if err != nil {
</span><span> 		panic(err)
</span><span> 	}
</span><span>@@ -45,8 +45,13 @@ func (h HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span> 		panic(err)
</span><span> 	}
</span><span> 
</span><span>+</span><span>	if next != nil {
</span><span>+</span><span>		next.ServeHTTP(w, r)
</span><span>+</span><span>	}
</span><span>+
</span><span> 	_, err = w.Write([]byte(html))
</span><span> 	if err != nil {
</span><span> 		panic(err)
</span><span> 	}
</span><span>+
</span><span> }
</span><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>index 23051c5..237f111 100644
</span><span>---</span><span> a/http_request_test.go
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -34,8 +34,21 @@ func HTML(renderable RequestRenderable) http.Handler {
</span><span> }
</span><span> 
</span><span> func TestRequestRequestHandler(t *testing.T) {
</span><span>+</span><span>	var statusCode = func(code int) http.Handler {
</span><span>+</span><span>		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
</span><span>+</span><span>			w.WriteHeader(code)
</span><span>+</span><span>		})
</span><span>+</span><span>	}
</span><span>+
</span><span> 	var empty = RequestRenderableFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span>-		return nil, nil, nil
</span><span>+</span><span>		switch r.URL.Query().Get(&#34;not_found&#34;) {
</span><span>+</span><span>		case &#34;default&#34;:
</span><span>+</span><span>			return nil, http.NotFoundHandler(), nil
</span><span>+</span><span>		case &#34;nil_404&#34;:
</span><span>+</span><span>			return nil, statusCode(http.StatusNotFound), nil
</span><span>+</span><span>		default:
</span><span>+</span><span>			return nil, nil, nil
</span><span>+</span><span>		}
</span><span> 	})
</span><span> 
</span><span> 	mux := http.NewServeMux()
</span><span>@@ -85,6 +98,18 @@ func TestRequestRequestHandler(t *testing.T) {
</span><span> 		assert.Equal(t, 200, code)
</span><span> 	})
</span><span> 
</span><span>+</span><span>	t.Run(&#34;empty handler can 404&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/empty?not_found=default&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;404 page not found\n&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 404, code)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;empty handler can 404 and nil&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/empty?not_found=nil_404&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 404, code)
</span><span>+</span><span>	})
</span><span>+
</span><span> 	t.Run(&#34;person renders (name=Stan)&#34;, func(t *testing.T) {
</span><span> 		body, code, _ := sendRequest(t, &#34;/person?name=Stan&#34;)
</span><span> 		assert.Equal(t, &#34;&lt;div&gt;Hi, Stan.&lt;/div&gt;&#34;, body)
</span><span>
</span></code></pre>


  </details>
</div>
<p>This is pretty neat, and allows the person writing their application
to only use what they need and when they need it.</p>
<h3 id="error-handling">Error Handling</h3>
<p>Going back to error handling, we always come back to error handling,
our implementation currently has three places where we <code>panic</code>.</p>
<ol>
<li><code>RequestRenderable()</code> returns an error</li>
<li><code>Render()</code> returns an error</li>
<li><code>Write</code> fails</li>
</ol>
<p>Our library already has hooks two of these to fail...</p>
<ul>
<li>RequestRenderable composition can fully handle (1) and (2).</li>
<li>For (3), we can&#39;t really do anything else here-- maybe the connection went away,
and we let it fail.</li>
</ul>
<p>Let&#39;s make a really silly error view...</p>
<pre data-lang="go"><code data-lang="go"><span>var </span><span>errorViewTpl </span><span>= </span><span>MustParseTemplate(</span><span>&#34;errorView&#34;</span><span>, </span><span>`Error: </span><span>{{ . }}</span><span>`</span><span>)
</span><span>
</span><span>type </span><span>errorView </span><span>struct </span><span>{
</span><span>    Error </span><span>error
</span><span>}
</span><span>
</span><span>func </span><span>(v </span><span>errorView</span><span>) </span><span>Renderable</span><span>(_ context.</span><span>Context</span><span>) (</span><span>Renderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>View{Tpl: errorViewTpl, Data: v.Error}, </span><span>nil
</span><span>}
</span><span>
</span><span>func </span><span>newErrorView</span><span>(_ context.</span><span>Context</span><span>, err </span><span>error</span><span>) (</span><span>AsRenderable</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>return </span><span>errorView{Error: err}, </span><span>nil
</span><span>}
</span></code></pre>
<p>And leverage our <code>ErrorRenderable</code> interface to do some composition.</p>
<pre data-lang="go"><code data-lang="go"><span>func </span><span>WithErrorHandler</span><span>(eh </span><span>ErrorRenderable</span><span>) </span><span>func</span><span>(</span><span>RequestRenderable</span><span>) </span><span>RequestRenderable </span><span>{
</span><span>    </span><span>return func</span><span>(renderable </span><span>RequestRenderable</span><span>) </span><span>RequestRenderable </span><span>{
</span><span>        </span><span>return </span><span>RequestRenderableFunc(</span><span>func</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, http.</span><span>Handler</span><span>, </span><span>error</span><span>) {
</span><span>            v, next, err </span><span>:= </span><span>renderable.RequestRenderable(r)
</span><span>            </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>                v, err </span><span>= </span><span>eh.ErrorRenderable(r.Context(), err)
</span><span>                </span><span>return </span><span>v, </span><span>nil</span><span>, err
</span><span>            }
</span><span>
</span><span>            html, err </span><span>:= </span><span>Render(r.Context(), v)
</span><span>            </span><span>if </span><span>err </span><span>!= </span><span>nil </span><span>{
</span><span>                v, err </span><span>= </span><span>eh.ErrorRenderable(r.Context(), err)
</span><span>                </span><span>return </span><span>v, </span><span>nil</span><span>, err
</span><span>            }
</span><span>
</span><span>            </span><span>if </span><span>len</span><span>(html) </span><span>== </span><span>0 </span><span>{
</span><span>                </span><span>return </span><span>nil</span><span>, next, </span><span>nil
</span><span>            }
</span><span>
</span><span>            </span><span>return </span><span>nil</span><span>, http.HandlerFunc(</span><span>func</span><span>(w http.</span><span>ResponseWriter</span><span>, r </span><span>*</span><span>http.</span><span>Request</span><span>) {
</span><span>                </span><span>if </span><span>next </span><span>!= </span><span>nil </span><span>{
</span><span>                    next.ServeHTTP(w, r)
</span><span>                }
</span><span>
</span><span>                _, _ </span><span>= </span><span>w.Write([]</span><span>byte</span><span>(html))
</span><span>            }), </span><span>nil
</span><span>        })
</span><span>    }
</span><span>}
</span></code></pre>
<p>I don&#39;t like it...</p>
<ol>
<li>
<p>It illustrates how given the public types and functions in
our library, we can pretty quickly build out a solution without breaking our
abstraction.</p>
</li>
<li>
<p>It&#39;s <em>basically</em> the same thing as our <code>HTTPHandler</code>, but with an
ErrorRenderable provided (which maybe isn&#39;t the right abstraction).</p>
</li>
</ol>
<p>We can  put this responsibility in our handler implementation and add some sane defaults,
mainly <code>500 Internal Server Error</code>.</p>
<p>First, let&#39;s make <code>HTTPHandler</code> a function instead of a struct, this eliminates the
need for <code>RequestHandlerFunc</code>.</p>










<div>
  <details>
    <summary>
      HTTPHandler is a function, and renaming RequestHandler
      <a href="https://github.com/stanistan/veun/commit/8020b8ca9584eba0e6b6369428a98fe8248f1c15">(source: 8020b8ca)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index 5d6bf82..d62379d 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -20,21 +20,21 @@ func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable,
</span><span> 	return f(r)
</span><span> }
</span><span> 
</span><span>-func RequestHandlerFunc(r RequestRenderableFunc) http.Handler {
</span><span>-	return HTTPHandler{Renderable: r}
</span><span>+</span><span>func HTTPHandlerFunc(r RequestRenderableFunc) http.Handler {
</span><span>+</span><span>	return handler{Renderable: r}
</span><span> }
</span><span> 
</span><span>-func RequestHandler(r RequestRenderable) http.Handler {
</span><span>-	return HTTPHandler{Renderable: r}
</span><span>+</span><span>func HTTPHandler(r RequestRenderable) http.Handler {
</span><span>+</span><span>	return handler{Renderable: r}
</span><span> }
</span><span> 
</span><span>-// HTTPHandler implements http.Handler for a RequestRenderable.
</span><span>-type HTTPHandler struct {
</span><span>+</span><span>// handler implements http.Handler for a RequestRenderable.
</span><span>+</span><span>type handler struct {
</span><span> 	Renderable RequestRenderable
</span><span> }
</span><span> 
</span><span> // ServeHTTP implements http.Handler.
</span><span>-func (h HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span>+</span><span>func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span> 	renderable, next, err := h.Renderable.RequestRenderable(r)
</span><span> 	if err != nil {
</span><span> 		panic(err)
</span><span>@@ -53,5 +53,4 @@ func (h HTTPHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span> 	if err != nil {
</span><span> 		panic(err)
</span><span> 	}
</span><span>-
</span><span> }
</span><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>index 237f111..2940f4d 100644
</span><span>---</span><span> a/http_request_test.go
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -23,7 +23,7 @@ func (v html) Renderable(_ context.Context) (Renderable, error) {
</span><span> }
</span><span> 
</span><span> func HTML(renderable RequestRenderable) http.Handler {
</span><span>-	return RequestHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span>+</span><span>	return HTTPHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 		v, next, err := renderable.RequestRenderable(r)
</span><span> 		if err != nil {
</span><span> 			return nil, next, err
</span><span>@@ -53,10 +53,10 @@ func TestRequestRequestHandler(t *testing.T) {
</span><span> 
</span><span> 	mux := http.NewServeMux()
</span><span> 
</span><span>-	mux.Handle(&#34;/empty&#34;, RequestHandler(empty))
</span><span>+</span><span>	mux.Handle(&#34;/empty&#34;, HTTPHandler(empty))
</span><span> 	mux.Handle(&#34;/html/empty&#34;, HTML(empty))
</span><span> 
</span><span>-	mux.Handle(&#34;/person&#34;, RequestHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span>+</span><span>	mux.Handle(&#34;/person&#34;, HTTPHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 		name := r.URL.Query().Get(&#34;name&#34;)
</span><span> 		if name == &#34;&#34; {
</span><span> 			return nil, nil, fmt.Errorf(&#34;missing name&#34;)
</span><span>
</span></code></pre>


  </details>
</div>
<h3 id="adding-the-error-delegate-option">Adding the error delegate option</h3>
<p>Now that our handler is private, we can add options! And our options should be
optional. If we end up adding more things to our handler, we can do so with
these optional arguments.</p>
<pre data-lang="go"><code data-lang="go"><span>type </span><span>HandlerOption </span><span>func</span><span>(h </span><span>*handler</span><span>)
</span><span>
</span><span>func </span><span>HTTPHandler</span><span>(r </span><span>RequestRenderable</span><span>, opts </span><span>...HandlerOption</span><span>) http.</span><span>Handler </span><span>{ </span><span>/* ... */ </span><span>}
</span><span>
</span><span>type </span><span>handler </span><span>struct </span><span>{
</span><span>    Renderable   </span><span>RequestRenderable
</span><span>    ErrorHandler </span><span>ErrorRenderable    </span><span>// &lt;- this is new
</span><span>}
</span></code></pre>
<p>Replace the <code>panic</code> calls with <code>handleError(ctx, err, ResponseWriter)</code>
which will either do error degation-- using our <code>handleRenderError</code>, or
write out at <code>500 Internal Server Error</code>, and we&#39;re basically done!</p>










<div>
  <details>
    <summary>
      handler with error handler
      <a href="https://github.com/stanistan/veun/commit/5ae41f095fbc0cbe8392010ff6f0c5a11a4bf9f8">(source: 5ae41f09)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/error_renderable.go b/error_renderable.go
</span><span>index 0dcab6c..87f539b 100644
</span><span>---</span><span> a/error_renderable.go
</span><span>+++</span><span> b/error_renderable.go
</span><span>@@ -17,6 +17,12 @@ type ErrorRenderable interface {
</span><span> 	ErrorRenderable(ctx context.Context, err error) (AsRenderable, error)
</span><span> }
</span><span> 
</span><span>+</span><span>type ErrorRenderableFunc func(context.Context, error) (AsRenderable, error)
</span><span>+
</span><span>+</span><span>func (f ErrorRenderableFunc) ErrorRenderable(ctx context.Context, err error) (AsRenderable, error) {
</span><span>+</span><span>	return f(ctx, err)
</span><span>+</span><span>}
</span><span>+
</span><span> func handleRenderError(ctx context.Context, err error, with any) (template.HTML, error) {
</span><span> 	var empty template.HTML
</span><span> 
</span><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index d62379d..8ef40b5 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -1,6 +1,8 @@
</span><span> package veun
</span><span> 
</span><span> import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;log/slog&#34;
</span><span> 	&#34;net/http&#34;
</span><span> )
</span><span> 
</span><span>@@ -20,29 +22,54 @@ func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable,
</span><span> 	return f(r)
</span><span> }
</span><span> 
</span><span>-func HTTPHandlerFunc(r RequestRenderableFunc) http.Handler {
</span><span>-	return handler{Renderable: r}
</span><span>+</span><span>func HTTPHandlerFunc(r RequestRenderableFunc, opts ...HandlerOption) http.Handler {
</span><span>+</span><span>	h := handler{Renderable: r}
</span><span>+</span><span>	for _, opt := range opts {
</span><span>+</span><span>		opt(&amp;h)
</span><span>+</span><span>	}
</span><span>+</span><span>	return h
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func HTTPHandler(r RequestRenderable, opts ...HandlerOption) http.Handler {
</span><span>+</span><span>	h := handler{Renderable: r}
</span><span>+</span><span>	for _, opt := range opts {
</span><span>+</span><span>		opt(&amp;h)
</span><span>+</span><span>	}
</span><span>+</span><span>	return h
</span><span> }
</span><span> 
</span><span>-func HTTPHandler(r RequestRenderable) http.Handler {
</span><span>-	return handler{Renderable: r}
</span><span>+</span><span>type HandlerOption func(h *handler)
</span><span>+
</span><span>+</span><span>func WithErrorHandler(eh ErrorRenderable) HandlerOption {
</span><span>+</span><span>	return func(h *handler) {
</span><span>+</span><span>		h.ErrorHandler = eh
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func WithErrorHandlerFunc(eh ErrorRenderableFunc) HandlerOption {
</span><span>+</span><span>	return func(h *handler) {
</span><span>+</span><span>		h.ErrorHandler = eh
</span><span>+</span><span>	}
</span><span> }
</span><span> 
</span><span> // handler implements http.Handler for a RequestRenderable.
</span><span> type handler struct {
</span><span>-	Renderable RequestRenderable
</span><span>+</span><span>	Renderable   RequestRenderable
</span><span>+</span><span>	ErrorHandler ErrorRenderable
</span><span> }
</span><span> 
</span><span> // ServeHTTP implements http.Handler.
</span><span> func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span> 	renderable, next, err := h.Renderable.RequestRenderable(r)
</span><span> 	if err != nil {
</span><span>-		panic(err)
</span><span>+</span><span>		h.handleError(r.Context(), w, err)
</span><span>+</span><span>		return
</span><span> 	}
</span><span> 
</span><span> 	html, err := Render(r.Context(), renderable)
</span><span> 	if err != nil {
</span><span>-		panic(err)
</span><span>+</span><span>		h.handleError(r.Context(), w, err)
</span><span>+</span><span>		return
</span><span> 	}
</span><span> 
</span><span> 	if next != nil {
</span><span>@@ -54,3 +81,17 @@ func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span> 		panic(err)
</span><span> 	}
</span><span> }
</span><span>+
</span><span>+</span><span>func (h handler) handleError(ctx context.Context, w http.ResponseWriter, err error) {
</span><span>+</span><span>	html, rErr := handleRenderError(ctx, err, h.ErrorHandler)
</span><span>+</span><span>	if rErr == nil &amp;&amp; len(html) &gt; 0 {
</span><span>+</span><span>		w.WriteHeader(http.StatusInternalServerError)
</span><span>+</span><span>		_, _ = w.Write([]byte(html))
</span><span>+</span><span>		return
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	// TODO: grab the logger from the context
</span><span>+</span><span>	slog.Error(&#34;handler failed&#34;, &#34;err&#34;, err)
</span><span>+</span><span>	code := http.StatusInternalServerError
</span><span>+</span><span>	http.Error(w, http.StatusText(code), code)
</span><span>+</span><span>}
</span><span>diff --git a/http_request_test.go b/http_request_test.go
</span><span>index 2940f4d..fa0f800 100644
</span><span>---</span><span> a/http_request_test.go
</span><span>+++</span><span> b/http_request_test.go
</span><span>@@ -26,14 +26,31 @@ func HTML(renderable RequestRenderable) http.Handler {
</span><span> 	return HTTPHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 		v, next, err := renderable.RequestRenderable(r)
</span><span> 		if err != nil {
</span><span>-			return nil, next, err
</span><span>+</span><span>			return nil, nil, err
</span><span>+</span><span>		} else if v == nil {
</span><span>+</span><span>			return nil, next, nil
</span><span> 		}
</span><span> 
</span><span> 		return html{Body: v}, next, nil
</span><span> 	})
</span><span> }
</span><span> 
</span><span>+</span><span>var errorViewTpl = MustParseTemplate(&#34;errorView&#34;, `Error: {{ . }}`)
</span><span>+
</span><span>+</span><span>type errorView struct {
</span><span>+</span><span>	Error error
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (v errorView) Renderable(_ context.Context) (Renderable, error) {
</span><span>+</span><span>	return View{Tpl: errorViewTpl, Data: v.Error}, nil
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func newErrorView(_ context.Context, err error) (AsRenderable, error) {
</span><span>+</span><span>	return errorView{Error: err}, nil
</span><span>+</span><span>}
</span><span>+
</span><span> func TestRequestRequestHandler(t *testing.T) {
</span><span>+
</span><span> 	var statusCode = func(code int) http.Handler {
</span><span> 		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
</span><span> 			w.WriteHeader(code)
</span><span>@@ -51,19 +68,22 @@ func TestRequestRequestHandler(t *testing.T) {
</span><span> 		}
</span><span> 	})
</span><span> 
</span><span>-	mux := http.NewServeMux()
</span><span>-
</span><span>-	mux.Handle(&#34;/empty&#34;, HTTPHandler(empty))
</span><span>-	mux.Handle(&#34;/html/empty&#34;, HTML(empty))
</span><span>-
</span><span>-	mux.Handle(&#34;/person&#34;, HTTPHandlerFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span>+</span><span>	var person = RequestRenderableFunc(func(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 		name := r.URL.Query().Get(&#34;name&#34;)
</span><span> 		if name == &#34;&#34; {
</span><span> 			return nil, nil, fmt.Errorf(&#34;missing name&#34;)
</span><span> 		}
</span><span> 
</span><span> 		return PersonView(Person{Name: name}), nil, nil
</span><span>-	}))
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	mux := http.NewServeMux()
</span><span>+
</span><span>+</span><span>	mux.Handle(&#34;/empty&#34;, HTTPHandler(empty))
</span><span>+</span><span>	mux.Handle(&#34;/html/empty&#34;, HTML(empty))
</span><span>+
</span><span>+</span><span>	mux.Handle(&#34;/person&#34;, HTTPHandler(person, WithErrorHandlerFunc(newErrorView)))
</span><span>+</span><span>	mux.Handle(&#34;/html/person&#34;, HTML(person))
</span><span> 
</span><span> 	server := httptest.NewServer(mux)
</span><span> 	defer server.Close()
</span><span>@@ -116,6 +136,12 @@ func TestRequestRequestHandler(t *testing.T) {
</span><span> 		assert.Equal(t, 200, code)
</span><span> 	})
</span><span> 
</span><span>+</span><span>	t.Run(&#34;person (name=)&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/person?name=&#34;)
</span><span>+</span><span>		assert.Equal(t, 500, code)
</span><span>+</span><span>		assert.Equal(t, &#34;Error: missing name&#34;, body)
</span><span>+</span><span>	})
</span><span>+
</span><span> 	t.Run(&#34;person renders (name=someone)&#34;, func(t *testing.T) {
</span><span> 		body, code, _ := sendRequest(t, &#34;/person?name=someone&#34;)
</span><span> 		assert.Equal(t, &#34;&lt;div&gt;Hi, someone.&lt;/div&gt;&#34;, body)
</span><span>@@ -124,7 +150,19 @@ func TestRequestRequestHandler(t *testing.T) {
</span><span> 
</span><span> 	t.Run(&#34;/html/empty&#34;, func(t *testing.T) {
</span><span> 		body, code, _ := sendRequest(t, &#34;/html/empty&#34;)
</span><span>-		assert.Equal(t, &#34;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, &#34;&#34;, body)
</span><span> 		assert.Equal(t, 200, code)
</span><span> 	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;/html/person (name=Stan)&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/html/person?name=Stan&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;&lt;html&gt;&lt;body&gt;&lt;div&gt;Hi, Stan.&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 200, code)
</span><span>+</span><span>	})
</span><span>+
</span><span>+</span><span>	t.Run(&#34;/html/person (name=)&#34;, func(t *testing.T) {
</span><span>+</span><span>		body, code, _ := sendRequest(t, &#34;/html/person?name=&#34;)
</span><span>+</span><span>		assert.Equal(t, &#34;Internal Server Error\n&#34;, body)
</span><span>+</span><span>		assert.Equal(t, 500, code)
</span><span>+</span><span>	})
</span><span> }
</span><span>
</span></code></pre>


  </details>
</div>
<h2 id="putting-it-together">Putting it together</h2>
<p>From the tests in the patches, we can see that making a handler is now pretty
simple, by building up the few pieces we&#39;ve put together, we have a pretty
robust little library.</p>
<pre data-lang="go"><code data-lang="go"><span>import </span><span>(
</span><span>    </span><span>&#34;net/http&#34;
</span><span>
</span><span>    . </span><span>&#34;github.com/stanistan/veun&#34;
</span><span>)
</span><span>
</span><span>type </span><span>myServer </span><span>struct </span><span>{
</span><span>    </span><span>// some db contections and contexts
</span><span>}
</span><span>
</span><span>func </span><span>(s </span><span>*myServer</span><span>) </span><span>SomePageHandler</span><span>(r </span><span>*</span><span>http.</span><span>Request</span><span>) (</span><span>AsRenderable</span><span>, http.</span><span>Handler</span><span>, </span><span>error</span><span>) {
</span><span>    </span><span>// Stuff...
</span><span>}
</span><span>
</span><span>func </span><span>main</span><span>() {
</span><span>    http.Handle(</span><span>&#34;/some-page&#34;</span><span>, HTML(s.SomePageHandler))
</span><span>}
</span></code></pre>
<p>This is compatible with middleware, any router that works with <code>http.Handler</code>
functions, and can do response headers, redirects, custom error pages,
and cancellation/deadlines, and really any kind of way that someone would
want to structure their HTTP server.</p>










<div>
  <details>
    <summary>
      moving HTTPHandler to http_handler
      <a href="https://github.com/stanistan/veun/commit/9e99612419b441ee13cae48174fa504306127e39">(source: 9e996124)</a>
    </summary>

<pre data-lang="patch"><code data-lang="patch"><span>diff --git a/http_handler.go b/http_handler.go
</span><span>new file mode 100644
</span><span>index 0000000..dd725ff
</span><span>---</span><span> /dev/null
</span><span>+++</span><span> b/http_handler.go
</span><span>@@ -0,0 +1,87 @@
</span><span>+</span><span>package veun
</span><span>+
</span><span>+</span><span>import (
</span><span>+</span><span>	&#34;context&#34;
</span><span>+</span><span>	&#34;log/slog&#34;
</span><span>+</span><span>	&#34;net/http&#34;
</span><span>+</span><span>)
</span><span>+
</span><span>+</span><span>// HTTPHandler constructs an http.HTTPHandler given the RequestRenderable.
</span><span>+</span><span>func HTTPHandler(r RequestRenderable, opts ...HandlerOption) http.Handler {
</span><span>+</span><span>	h := handler{Renderable: r}
</span><span>+</span><span>	for _, opt := range opts {
</span><span>+</span><span>		opt(&amp;h)
</span><span>+</span><span>	}
</span><span>+</span><span>	return h
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// HTTPHandler constructs an http.HTTPHandler given the RequestRenderableFunc.
</span><span>+</span><span>func HTTPHandlerFunc(r RequestRenderableFunc, opts ...HandlerOption) http.Handler {
</span><span>+</span><span>	h := handler{Renderable: r}
</span><span>+</span><span>	for _, opt := range opts {
</span><span>+</span><span>		opt(&amp;h)
</span><span>+</span><span>	}
</span><span>+</span><span>	return h
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// HandlerOption is an option that can be provided to the handler.
</span><span>+</span><span>type HandlerOption func(h *handler)
</span><span>+
</span><span>+</span><span>// WithErrorHandler creates a HandlerOption that can be provided to HTTPHandler
</span><span>+</span><span>// or HTTPHandlerFunc.
</span><span>+</span><span>//
</span><span>+</span><span>// This can change the default error handling behavior of the handler.
</span><span>+</span><span>func WithErrorHandler(eh ErrorRenderable) HandlerOption {
</span><span>+</span><span>	return func(h *handler) {
</span><span>+</span><span>		h.ErrorHandler = eh
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// WithErrorHandlerFunc is the same as WithErrorHandler.
</span><span>+</span><span>func WithErrorHandlerFunc(eh ErrorRenderableFunc) HandlerOption {
</span><span>+</span><span>	return WithErrorHandler(eh)
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// handler implements http.Handler for a RequestRenderable.
</span><span>+</span><span>type handler struct {
</span><span>+</span><span>	Renderable   RequestRenderable
</span><span>+</span><span>	ErrorHandler ErrorRenderable
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>// ServeHTTP implements http.Handler.
</span><span>+</span><span>func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span>+</span><span>	renderable, next, err := h.Renderable.RequestRenderable(r)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		h.handleError(r.Context(), w, err)
</span><span>+</span><span>		return
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	html, err := Render(r.Context(), renderable)
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		h.handleError(r.Context(), w, err)
</span><span>+</span><span>		return
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	if next != nil {
</span><span>+</span><span>		next.ServeHTTP(w, r)
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	_, err = w.Write([]byte(html))
</span><span>+</span><span>	if err != nil {
</span><span>+</span><span>		panic(err)
</span><span>+</span><span>	}
</span><span>+</span><span>}
</span><span>+
</span><span>+</span><span>func (h handler) handleError(ctx context.Context, w http.ResponseWriter, err error) {
</span><span>+</span><span>	html, rErr := handleRenderError(ctx, err, h.ErrorHandler)
</span><span>+</span><span>	if rErr == nil &amp;&amp; len(html) &gt; 0 {
</span><span>+</span><span>		w.WriteHeader(http.StatusInternalServerError)
</span><span>+</span><span>		_, _ = w.Write([]byte(html))
</span><span>+</span><span>		return
</span><span>+</span><span>	}
</span><span>+
</span><span>+</span><span>	// TODO: grab the logger from the context
</span><span>+</span><span>	slog.Error(&#34;handler failed&#34;, &#34;err&#34;, err)
</span><span>+</span><span>	code := http.StatusInternalServerError
</span><span>+</span><span>	http.Error(w, http.StatusText(code), code)
</span><span>+</span><span>}
</span><span>diff --git a/http_request_renderable.go b/http_request_renderable.go
</span><span>index 8ef40b5..267a293 100644
</span><span>---</span><span> a/http_request_renderable.go
</span><span>+++</span><span> b/http_request_renderable.go
</span><span>@@ -1,8 +1,6 @@
</span><span> package veun
</span><span> 
</span><span> import (
</span><span>-	&#34;context&#34;
</span><span>-	&#34;log/slog&#34;
</span><span> 	&#34;net/http&#34;
</span><span> )
</span><span> 
</span><span>@@ -21,77 +19,3 @@ type RequestRenderableFunc func(*http.Request) (AsRenderable, http.Handler, erro
</span><span> func (f RequestRenderableFunc) RequestRenderable(r *http.Request) (AsRenderable, http.Handler, error) {
</span><span> 	return f(r)
</span><span> }
</span><span>-
</span><span>-func HTTPHandlerFunc(r RequestRenderableFunc, opts ...HandlerOption) http.Handler {
</span><span>-	h := handler{Renderable: r}
</span><span>-	for _, opt := range opts {
</span><span>-		opt(&amp;h)
</span><span>-	}
</span><span>-	return h
</span><span>-}
</span><span>-
</span><span>-func HTTPHandler(r RequestRenderable, opts ...HandlerOption) http.Handler {
</span><span>-	h := handler{Renderable: r}
</span><span>-	for _, opt := range opts {
</span><span>-		opt(&amp;h)
</span><span>-	}
</span><span>-	return h
</span><span>-}
</span><span>-
</span><span>-type HandlerOption func(h *handler)
</span><span>-
</span><span>-func WithErrorHandler(eh ErrorRenderable) HandlerOption {
</span><span>-	return func(h *handler) {
</span><span>-		h.ErrorHandler = eh
</span><span>-	}
</span><span>-}
</span><span>-
</span><span>-func WithErrorHandlerFunc(eh ErrorRenderableFunc) HandlerOption {
</span><span>-	return func(h *handler) {
</span><span>-		h.ErrorHandler = eh
</span><span>-	}
</span><span>-}
</span><span>-
</span><span>-// handler implements http.Handler for a RequestRenderable.
</span><span>-type handler struct {
</span><span>-	Renderable   RequestRenderable
</span><span>-	ErrorHandler ErrorRenderable
</span><span>-}
</span><span>-
</span><span>-// ServeHTTP implements http.Handler.
</span><span>-func (h handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
</span><span>-	renderable, next, err := h.Renderable.RequestRenderable(r)
</span><span>-	if err != nil {
</span><span>-		h.handleError(r.Context(), w, err)
</span><span>-		return
</span><span>-	}
</span><span>-
</span><span>-	html, err := Render(r.Context(), renderable)
</span><span>-	if err != nil {
</span><span>-		h.handleError(r.Context(), w, err)
</span><span>-		return
</span><span>-	}
</span><span>-
</span><span>-	if next != nil {
</span><span>-		next.ServeHTTP(w, r)
</span><span>-	}
</span><span>-
</span><span>-	_, err = w.Write([]byte(html))
</span><span>-	if err != nil {
</span><span>-		panic(err)
</span><span>-	}
</span><span>-}
</span><span>-
</span><span>-func (h handler) handleError(ctx context.Context, w http.ResponseWriter, err error) {
</span><span>-	html, rErr := handleRenderError(ctx, err, h.ErrorHandler)
</span><span>-	if rErr == nil &amp;&amp; len(html) &gt; 0 {
</span><span>-		w.WriteHeader(http.StatusInternalServerError)
</span><span>-		_, _ = w.Write([]byte(html))
</span><span>-		return
</span><span>-	}
</span><span>-
</span><span>-	// TODO: grab the logger from the context
</span><span>-	slog.Error(&#34;handler failed&#34;, &#34;err&#34;, err)
</span><span>-	code := http.StatusInternalServerError
</span><span>-	http.Error(w, http.StatusText(code), code)
</span><span>-}
</span><span>
</span></code></pre>


  </details>
</div>

        </section>

        

    </article></div>
  </body>
</html>
