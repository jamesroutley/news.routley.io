<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.johndcook.com/blog/2023/05/12/circulant-matrices/">Original</a>
    <h1>Circulant Matrices, Eigenvectors, and the FFT</h1>
    
    <div id="readability-page-1" class="page"><div>
		<p>A circulant matrix is a square matrix in which each row is a rotation of the previous row. This post will illustrate a connection between circulant matrices and the FFT (Fast Fourier Transform).</p>
<h2>Circulant matrices<!--?h2 ></p> <p>Here's a visualization of a 5 by 5 circulant matrix.</p> <p><img class="aligncenter size-medium" src="https://www.johndcook.com/circulant.png" width="277" height="288" ?--></h2>
<p>Color in the first row however you want. Then move the last element to the front to make the next row. Repeat this process until the matrix is full.</p>
<p><img decoding="async" fetchpriority="high" src="https://www.johndcook.com/foobazqux.png" alt="" width="277" height="288"/></p>
<p>The NumPy function <code>roll</code> will do this rotation for us. Its first argument is the row to rotate, and the second argument is the number of rotations to do. So the following Python code generates a random circulant matrix of size N.</p>
<pre>    import numpy as np

    np.random.seed(20230512)
    N = 5
    row = np.random.random(N)
    M = np.array([np.roll(row, i) for i in range(N)])
</pre>
<p>Here’s the matrix M with entries truncated to 3 decimal places to make it easier to read.</p>
<pre>    [[0.556 0.440 0.083 0.460 0.909]
     [0.909 0.556 0.440 0.083 0.460]
     [0.460 0.909 0.556 0.440 0.083]
     [0.083 0.460 0.909 0.556 0.440]
     [0.440 0.083 0.460 0.909 0.556]]    
</pre>
<h2>Fast Fourier Transform</h2>
<p>The Fast Fourier Transform is a linear transformation and so it can be represented by a matrix [1]. This the <em>N</em> by <em>N</em> matrix whose (<em>j</em>, <em>k</em>) entry is ω<sup><em>jk</em></sup> where ω = exp(-2π<em>i</em>/<em>N</em>), with <em>j</em> and <em>k</em> running from 0 to <em>N</em> – 1. [2]</p>
<p>Each element of the FFT matrix corresponds to a rotation, so you could visualize the matrix using clocks in each entry or by a cycle of colors. A few years ago I created a <a href="https://www.johndcook.com/blog/2016/01/10/visualizing-the-dft-matrix/">visualization</a> using both clock faces and colors:</p>
<p><img decoding="async" src="https://www.johndcook.com/clock_fft.png" alt="" width="450" height="477"/></p>
<h2>Eigenvectors and Python code</h2>
<p>Here’s a <strong>surprising property</strong> of circulant matrices: the eigenvectors of a circulant matrix depend only on the size of the matrix, not on the elements of the matrix. Furthermore, these eigenvectors are the columns of the FFT matrix. The eigenvalues depend on the matrix entries, but the eigenvectors do not.</p>
<p>Said another way, when you multiply a circulant matrix by a column of the FFT matrix of the same size, this column will be stretched but not rotated. The amount of stretching depends on the particular circulant matrix.</p>
<p>Here is Python code to illustrate this.</p>
<pre>    for i in range(N):
        ω = np.exp(-2j*np.pi/N)
        col1 = np.array([ω**(i*j) for j in range(N)])
        col2 = np.matmul(M, col1)
        print(col1/col2)
</pre>
<p>In this code <code>col1</code> is a column of the FFT matrix, and <code>col2</code> is the image of the column when multiplied by the circulant matrix <code>M</code>. The print statement shows that the ratios of each elements are the same in each position. This ratio is the eigenvalue associated with each eigenvector. If you were to generate a new random circulant matrix, the ratios would change, but the input and output vectors would still be proportional.</p>
<h2>Notes</h2>
<p>[1] Technically this is the discrete Fourier transform (DFT). The FFT is an <em>algorithm</em> for computing the DFT. Because the DFT is always computed using the FFT, the transformation itself is usually referred to as the FFT.</p>
<p>[2] Conventions vary, so you may see the FFT matrix written differently.</p>
			</div></div>
  </body>
</html>
