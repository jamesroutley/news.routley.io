<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.ryanliptak.com/blog/every-rc-exe-bug-quirk-probably/">Original</a>
    <h1>Every bug/quirk of the Windows resource compiler (rc.exe), probably</h1>
    
    <div id="readability-page-1" class="page"><div id="container">
<div>

<p><time>2024-10-11</time>
 - <a href="https://gianluca.ai/blog/categories/programming">Programming</a>
 - <a href="https://gianluca.ai/blog/categories/fuzzing">Fuzzing</a></p><ul>
<li><code>7 NOT NOT 4 NOT 2 NOT NOT 1</code> is a valid expression</li>
<li><code>०००</code> is a number that gets parsed into the decimal value 65130</li>
<li>A &lt; 1 MiB icon file can get compiled into 127 TiB of data</li>
</ul>
<p>The above is just a small sampling of a few of the strange behaviors of the Windows RC compiler (<code>rc.exe</code>). All of the above bugs/quirks, and many, many more, will be detailed and explained (to the best of my ability) in this post.</p>

<h2>Context<a id="context" href="#context">🔗</a></h2>
<p>Inspired by an <a href="https://github.com/ziglang/zig/issues/3702">accepted proposal</a> for <a href="https://ziglang.org/">Zig</a> to include support for compiling Windows resource script (<code>.rc</code>) files, I set out on what I thought at the time would be a somewhat straightforward side-project of writing a Windows resource compiler in Zig. Microsoft&#39;s RC compiler (<code>rc.exe</code>) is closed source, but alternative implementations are nothing new—there are multiple existing projects that tackle the same goal of an open source and cross-platform Windows resource compiler (in particular, <code>windres</code> and <code>llvm-rc</code>). I figured that I could use them as a reference, and that the syntax of <code>.rc</code> files didn&#39;t look too complicated.</p>
<p><strong>I was wrong on both counts.</strong></p>
<p>While the <code>.rc</code> syntax <em>in theory</em> is not complicated, there are edge cases hiding around every corner, and each of the existing alternative Windows resource compilers handle each edge case very differently from the canonical Microsoft implementation.</p>
<p>With a goal of byte-for-byte-identical-outputs (and possible bug-for-bug compatibility) for my implementation, I had to effectively start from scratch, as even <a href="https://github.com/MicrosoftDocs/win32/pulls?q=is%3Apr+author%3Asqueek502">the Windows documentation couldn&#39;t be fully trusted to be accurate</a>. Ultimately, I went with fuzz testing (with <code>rc.exe</code> as the source of truth/oracle) as my method of choice for deciphering the behavior of the Windows resource compiler (this approach is similar to something I did <a href="https://www.ryanliptak.com/blog/fuzzing-as-test-case-generator/">with Lua</a> a while back).</p>
<p>This process led to a few things:</p>
<ul>
<li>A completely clean-room implementation of a Windows resource compiler (not even any decompilation of <code>rc.exe</code> involved in the process)</li>
<li>A high degree of compatibility with the <code>rc.exe</code> implementation, including <a href="https://github.com/squeek502/win32-samples-rc-tests/">byte-for-byte identical outputs</a> for a sizable corpus of Microsoft-provided sample <code>.rc</code> files (~500 files)</li>
<li>A large list of strange/interesting/baffling behaviors of the Windows resource compiler</li>
</ul>
<p>My resource compiler implementation, <a href="https://github.com/squeek502/resinator"><code>resinator</code></a>, has now reached relative maturity and has <a href="https://www.ryanliptak.com/blog/zig-is-a-windows-resource-compiler/">been merged into the Zig compiler</a> (but is also maintained as a standalone project), so I thought it might be interesting to write about all the weird stuff I found along the way.</p>

<h2>Who is this article for?<a id="who-is-this-article-for" href="#who-is-this-article-for">🔗</a></h2>
<ul>
<li>If you work at Microsoft, consider this a large list of bug reports (of particular note, see everything labeled &#39;miscompilation&#39;)
<ul>
<li>If you&#39;re <a href="https://devblogs.microsoft.com/oldnewthing/author/oldnewthing">Raymond Chen</a>, then consider this an extension of/homage to all the (fantastic, very helpful) blog posts about Windows resources in <a href="https://devblogs.microsoft.com/oldnewthing/">The Old New Thing</a></li>
</ul>
</li>
<li>If you are a contributor to <code>llvm-rc</code>, <code>windres</code>, or <code>wrc</code>, consider this a long list of behaviors to test for (if strict compatibility is a goal)</li>
<li>If you are someone that managed to <a href="https://www.youtube.com/watch?v=RZczLb_uI9E">endure the bad audio of this talk I gave about my resource compiler</a> and wanted more, consider this an extension of that talk</li>
<li>If you are none of the above, consider this an entertaining list of bizarre bugs/edge cases
<ul>
<li>If you&#39;d like to skip around and check out the strangest bugs/quirks, <code>Ctrl+F</code> for &#39;utterly baffling&#39;</li>
</ul>
</li>
</ul>
<h2>A brief intro to resource compilers<a id="a-brief-intro-to-resource-compilers" href="#a-brief-intro-to-resource-compilers">🔗</a></h2>
<p><code>.rc</code> files (resource definition-script files) are scripts that contain both C/C++ preprocessor commands and resource definitions. We&#39;ll ignore the preprocessor for now and focus on resource definitions. One possible resource definition might look like this:</p>
<pre><code><span><span>id<i></i></span><span><span>1</span></span></span> <span><span>type<i></i></span><span><span>FOO</span></span></span> <span>{</span> <span><span>data<i></i></span><span><span>&#34;bar&#34;</span></span></span> <span>}</span></code></pre>
<p>The <code>1</code> is the ID of the resource, which can be a number (ordinal) or literal (name). The <code>FOO</code> is the type of the resource, and in this case it&#39;s a user-defined type with the name <code>FOO</code>. The <code>{ &#34;bar&#34; }</code> is a block that contains the data of the resource, which in this case is the string literal <code>&#34;bar&#34;</code>. Not all resource definitions look exactly like this, but the <code>&lt;id&gt; &lt;type&gt;</code> part is fairly common.</p>
<p>Resource compilers take <code>.rc</code> files and compile them into binary <code>.res</code> files:</p>
<div>

<div>
  <pre>    <code>00 00 00 00 20 00 00 00  .... ...
FF FF 00 00 FF FF 00 00  ........
00 00 00 00 00 00 00 00  ........
00 00 00 00 00 00 00 00  ........
03 00 00 00 20 00 00 00  .... ...
FF FF <span>0A 00<span>The predefined RCDATA</span></span> FF FF <span>01 00</span>  ..<span>..</span>..<span>..</span>
00 00 00 00 30 00 09 04  ....0...
00 00 00 00 00 00 00 00  ........
<span>61 62 63</span> 00              <span>abc</span>.</code>
  </pre>
</div>
</div>
<p><i>A simple <code>.rc</code> file and a hexdump of the relevant part of the resulting <code>.res</code> file</i></p>
<p>The <code>.res</code> file can then be handed off to the linker in order to include the resources in the resource table of a PE/COFF binary (<code>.exe</code>/<code>.dll</code>). The resources in the PE/COFF binary can be used for various things, like:</p>
<ul>
<li>Executable icons that show up in Explorer</li>
<li>Version information that integrates with the Properties window</li>
<li>Defining dialogs/menus that can be loaded at runtime</li>
<li>Localization strings</li>
<li>Embedding arbitrary data</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/menurc/resource-definition-statements">etc.</a></li>
</ul>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/zig-ico.png"/>
<i>Both the executable&#39;s icon and the version information in the Properties window come from a compiled <code>.rc</code> file</i>
</p>
<p>So, in general, a resource is a blob of data that can be referenced by an ID, plus a type that determines how that data should be interpreted. The resource(s) are embedded into compiled binaries (<code>.exe</code>/<code>.dll</code>) and can then be loaded at runtime, and/or can be loaded by the operating system for certain Windows-specific integrations.</p>

<p>An additional bit of context worth knowing is that <code>.rc</code> files were/are very often generated by Visual Studio rather than manually written-by-hand, which could explain why many of the bugs/quirks detailed here have gone undetected/unfixed for so long (i.e. the Visual Studio generator just so happened not to trigger these edge cases).</p>
<p>With that out of the way, we&#39;re ready to get into it.</p>
<h2>The list of bugs/quirks<a id="the-list-of-bugs-quirks" href="#the-list-of-bugs-quirks">🔗</a></h2>
<div>
<p><span>tokenizer quirk</span></p><h3>Special tokenization rules for names/IDs<a id="special-tokenization-rules-for-names-ids" href="#special-tokenization-rules-for-names-ids">🔗</a></h3>
<p>Here&#39;s a resource definition with a user-defined type of <code>FOO</code> (&#34;user-defined&#34; means that it&#39;s not one of the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/resource-definition-statements#resources">predefined resource types</a>):</p>
<pre><code><span>1</span><span> </span><span>FOO</span><span> </span><span>{</span><span> </span><span>&#34;bar&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>For user-defined types, the (uppercased) resource type name is written as UTF-16 into the resulting <code>.res</code> file, so in this case <code>FOO</code> is written as the type of the resource, and the bytes of the string <code>bar</code> are written as the resource&#39;s data.</p>
<p>So, following from this, let&#39;s try wrapping the resource type name in double quotes:</p>
<pre><code><span>1</span><span> </span><span>&#34;FOO&#34;</span><span> </span><span>{</span><span> </span><span>&#34;bar&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>Intuitively, you might expect that this doesn&#39;t change anything (i.e. it&#39;ll still get parsed into <code>FOO</code>), but in fact the Windows RC compiler will now include the quotes in the user-defined type name. That is, <code>&#34;FOO&#34;</code> will be written as the resource type name in the <code>.res</code> file, not <code>FOO</code>.</p>
<p>This is because both resource IDs and resource types use special tokenization rules—they are basically only terminated by whitespace and nothing else (well, not exactly whitespace, it&#39;s actually any ASCII character from <code>0x05</code> to <code>0x20</code> [inclusive]). As an example:</p>
<pre><code><span>L&#34;\r\n&#34;123abc</span><span> </span><span>error{OutOfMemory}!?u8</span><span> </span><span>{</span><span> </span><span>&#34;bar&#34;</span><span> </span><span>}</span><span>
</span></code></pre>

<p>In this case, the ID would be <code>L&#34;\R\N&#34;123ABC</code> (uppercased) and the resource type would be <code>ERROR{OUTOFMEMORY}!?U8</code> (again, uppercased).</p>
<hr/>
<p>I&#39;ve started with this particular quirk because it is actually demonstrative of the level of <code>rc.exe</code>-compatibility of the existing cross-platform resource compiler projects:</p>
<ul>
<li><a href="https://ftp.gnu.org/old-gnu/Manuals/binutils-2.12/html_node/binutils_14.html"><code>windres</code></a> parses the <code>&#34;FOO&#34;</code> resource type as a regular string literal and the resource type name ends up as <code>FOO</code> (without the quotes)</li>
<li><a href="https://github.com/llvm/llvm-project/tree/56b3222b79632a4bbb36271735556a03b2504791/llvm/tools/llvm-rc"><code>llvm-rc</code></a> errors with <code>expected int or identifier, got &#34;FOO&#34;</code></li>
<li><a href="https://www.winehq.org/docs/wrc"><code>wrc</code></a> also errors with <code>syntax error</code></li>
</ul>

<h4><a href="https://github.com/squeek502/resinator"><code>resinator</code></a>&#39;s behavior<a id="resinator-s-behavior" href="#resinator-s-behavior">🔗</a></h4>
<p><code>resinator</code> matches the resource ID/type tokenization behavior of <code>rc.exe</code> in all known cases.</p>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>Non-ASCII digits in number literals<a id="non-ascii-digits-in-number-literals" href="#non-ascii-digits-in-number-literals">🔗</a></h3>
<p>The Windows RC compiler allows non-ASCII digit codepoints within number literals, but the resulting numeric value is arbitrary.</p>
<p>For ASCII digit characters, the standard procedure for calculating the numeric value of an integer literal is the following:</p>
<ul>
<li>For each digit, subtract the ASCII value of the zero character (<code>&#39;0&#39;</code>) from the ASCII value of the digit to get the numeric value of the digit</li>
<li>Multiply the numeric value of the digit by the relevant multiple of 10, depending on the place value of the digit</li>
<li>Sum the result of all the digits</li>
</ul>
<p>For example, for the integer literal <code>123</code>:</p>
<div>

<div>
<pre><code><span>&#39;1&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>1</span><span>
</span><span>&#39;2&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>2</span><span>
</span><span>&#39;3&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>3</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span> </span><span>1</span><span> </span><span>*</span><span> </span><span>100</span><span> </span><span>=</span><span> </span><span>100</span><span>
  </span><span>2</span><span> </span><span>*</span><span> </span><span>10</span><span> </span><span>=</span><span>  </span><span>20</span><span>
   </span><span>3</span><span> </span><span>*</span><span> </span><span>1</span><span> </span><span>=</span><span>   </span><span>3</span><span>
</span><span>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span><span>
           </span><span>123</span><span>
</span></code></pre>
</div>
<p><i>integer literal</i></p>
<p><i>numeric value of each digit</i></p>
<p><i>numeric value of the integer literal</i></p>
</div>
<p>So, how about the integer literal <code>1²3</code>? The Windows RC compiler accepts it, but the resulting numeric value ends up being 1403.</p>
<p>The problem is that the exact same procedure outlined above is erroneously followed for <em>all</em> allowed digits, so things go haywire for non-ASCII digits since the relationship between the non-ASCII digit&#39;s codepoint value and the ASCII value of <code>&#39;0&#39;</code> is arbitrary:</p>
<div>


<div>
<pre><code><span> </span><span>1</span><span> </span><span>*</span><span> </span><span>100</span><span> </span><span>=</span><span>  </span><span>100</span><span>
</span><span>130</span><span> </span><span>*</span><span> </span><span>10</span><span> </span><span>=</span><span> </span><span>1300</span><span>
   </span><span>3</span><span> </span><span>*</span><span> </span><span>1</span><span> </span><span>=</span><span>    </span><span>3</span><span>
</span><span>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span><span>
           </span><span>1403</span><span>
</span></code></pre>
</div>
<p><i>integer literal</i></p>
<p><i>numeric value of the ² &#34;digit&#34;</i></p>
<p><i>numeric value of the integer literal</i></p>
</div>
<p>In other words, the <code>²</code> is treated as a base-10 &#34;digit&#34; with the value 130 (and <code>³</code> would be a base-10 &#34;digit&#34; with the value 131, <code>၅</code> (<a href="https://www.compart.com/en/unicode/U+1045"><code>U+1045</code></a>) would be a base-10 &#34;digit&#34; with the value 4117, etc).</p>
<p>This particular bug/quirk is (presumably) due to the use of the <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/isdigit-iswdigit-isdigit-l-iswdigit-l"><code>iswdigit</code></a> function, and the <a href="https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html">same sort of bug/quirk exists with special <code>COM[1-9]</code> device names</a>.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-2" href="#resinator-s-behavior-2">🔗</a></h4>
<pre><code><span>test.rc:2:3:</span><span> error:</span><span> non-ASCII digit characters are not allowed in number literals
</span><span> 1²3
</span><span> ^~
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3><code>BEGIN</code> or <code>{</code> as filename<a id="begin-or-as-filename" href="#begin-or-as-filename">🔗</a></h3>
<p>Many resource types can get their data from a file, in which case their resource definition will look something like:</p>
<pre><code><span>1</span><span> </span><span>ICON</span><span> </span><span>&#34;file.ico&#34;</span><span>
</span></code></pre>
<p>Additionally, some resource types (like <code>ICON</code>) <em>must</em> get their data from a file. When attempting to define an <code>ICON</code> resource with a raw data block like so:</p>
<pre><code><span>1</span><span> </span><span>ICON</span><span> </span><span>BEGIN</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>END</span><span>
</span></code></pre>

<p>and then trying to compile that <code>ICON</code>, <code>rc.exe</code> has a confusing error:</p>
<pre><code>test.rc(1) : error RC2135 : file not found: BEGIN

test.rc(2) : error RC2135 : file not found: END
</code></pre>
<p>That is, the Windows RC compiler will try to interpret <code>BEGIN</code> as a filename, which is extremely likely to fail and (if it succeeds) is almost certainly not what the user intended. It will then move on and continue trying to parse the file as if the first resource definition is <code>1 ICON BEGIN</code> and almost certainly hit more errors, since everything afterwards will be misinterpreted just as badly.</p>
<p>This is even worse when using <code>{</code> and <code>}</code> to open/close the block, as it triggers a separate bug:</p>
<pre><code><span>1</span><span> </span><span>ICON</span><span> </span><span>{</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<pre><code>test.rc(1) : error RC2135 : file not found: ICON

test.rc(2) : error RC2135 : file not found: }
</code></pre>
<p>Somehow, the filename <code>{</code> causes <code>rc.exe</code> to think the filename token is actually the preceding token, so it&#39;s trying to interpret <code>ICON</code> as both the resource type <em>and</em> the file path of the resource. Who knows what&#39;s going on there.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-3" href="#resinator-s-behavior-3">🔗</a></h4>
<p>In <code>resinator</code>, trying to use a raw data block with resource types that don&#39;t support raw data is an error, noting that if <code>{</code> or <code>BEGIN</code> is intended as a filename, it should use a quoted string literal.</p>
<pre><code><span>test.rc:1:8:</span><span> error:</span><span> expected &#39;&lt;filename&gt;&#39;, found &#39;BEGIN&#39; (resource type &#39;icon&#39; can&#39;t use raw data)
</span><span>1 ICON BEGIN
</span><span>       ^~~~~
</span><span></span><span>test.rc:1:8:</span><span> note:</span><span> if &#39;BEGIN&#39; is intended to be a filename, it must be specified as a quoted string literal
</span><span></span></code></pre>

</div>
<div>
<p><span>parser bug/quirk</span></p><h3>Number expressions as filenames<a id="number-expressions-as-filenames" href="#number-expressions-as-filenames">🔗</a></h3>
<p>There are multiple valid ways to specify the filename of a resource:</p>
<pre><code><span>
</span><span>1</span><span> </span><span>FOO</span><span> </span><span>&#34;bar.txt&#34;</span><span>

</span><span>
</span><span>2</span><span> </span><span>FOO</span><span> </span><span>bar</span><span>.</span><span>txt</span><span>

</span><span>
</span><span>3</span><span> </span><span>FOO</span><span> </span><span>123</span><span>
</span></code></pre>
<p>But that&#39;s not all, as you can also specify the filename as an arbitrarily complex number expression, like so:</p>
<pre><code><span>1</span><span> </span><span>FOO</span><span> </span><span>(</span><span>1</span><span> </span><span>|</span><span> </span><span>2</span><span>)</span><span>+</span><span>(</span><span>2</span><span>-</span><span>1</span><span> </span><span>&amp;</span><span> </span><span>0xFF</span><span>)</span><span>
</span></code></pre>
<p>The entire <code>(1 | 2)+(2-1 &amp; 0xFF)</code> expression, spaces and all, is interpreted as the filename of the resource. Want to take a guess as to which file path it tries to read the data from?</p>
<p>Yes, that&#39;s right, <code>0xFF</code>!</p>
<p>For whatever reason, <code>rc.exe</code> will just take the last number literal in the expression and try to read from a file with that name, e.g. <code>(1+2)</code> will try to read from the path <code>2</code>, and <code>1+-1</code> will try to read from the path <code>-1</code> (the <code>-</code> sign is part of the number literal token, this will be detailed later in <a href="#unary-operators-are-an-illusion">&#34;<em>Unary operators are an illusion</em>&#34;</a>).</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-4" href="#resinator-s-behavior-4">🔗</a></h4>
<p>In <code>resinator</code>, trying to use a number expression as a filename is an error, noting that a quoted string literal should be used instead. Singular number literals are allowed, though (e.g. <code>-1</code>).</p>
<pre><code><span>test.rc:1:7:</span><span> error:</span><span> filename cannot be specified using a number expression, consider using a quoted string instead
</span><span>1 FOO (1 | 2)+(2-1 &amp; 0xFF)
</span><span>      ^~~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:1:7:</span><span> note:</span><span> the Win32 RC compiler would evaluate this number expression as the filename &#39;0xFF&#39;
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>Incomplete resource at EOF<a id="incomplete-resource-at-eof" href="#incomplete-resource-at-eof">🔗</a></h3>
<p>The incomplete resource definition in the following example is an error:</p>
<pre><code><span>
</span><span>1</span><span> </span><span>FOO</span><span> </span><span>{</span><span> </span><span>&#34;bar&#34;</span><span> </span><span>}</span><span>

</span><span>
</span><span>2</span><span> </span><span>FOO</span><span>
</span></code></pre>
<p>But it&#39;s not the error you might be expecting:</p>
<pre><code>test.rc(6) : error RC2135 : file not found: FOO
</code></pre>
<p>Strangely, <code>rc.exe</code> will treat <code>FOO</code> as both the type of the resource <em>and</em> as a filename (similar to what we saw earlier in <a href="#begin-or-as-filename">&#34;<em><code>BEGIN</code> or <code>{</code> as filename</em>&#34;</a>). If you create a file with the name <code>FOO</code> it will then <em>successfully compile</em>, and the <code>.res</code> will have a resource with type <code>FOO</code> and its data will be that of the file <code>FOO</code>.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-5" href="#resinator-s-behavior-5">🔗</a></h4>
<p><code>resinator</code> does not match the <code>rc.exe</code> behavior and instead always errors on this type of incomplete resource definition at the end of a file:</p>
<pre><code><span>test.rc:5:6:</span><span> error:</span><span> expected quoted string literal or unquoted literal; got &#39;&lt;eof&gt;&#39;
</span><span>2 FOO
</span><span>     ^
</span><span></span></code></pre>
<p>However...</p>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>Dangling literal at EOF<a id="dangling-literal-at-eof" href="#dangling-literal-at-eof">🔗</a></h3>
<p>If we change the previous example to only have one dangling literal for its incomplete resource definition like so:</p>
<pre><code><span>
</span><span>1</span><span> </span><span>FOO</span><span> </span><span>{</span><span> </span><span>&#34;bar&#34;</span><span> </span><span>}</span><span>

</span><span>
</span><span>FOO</span><span>
</span></code></pre>
<p>Then <code>rc.exe</code> <em>will always successfully compile it</em>, and it won&#39;t try to read from the file <code>FOO</code>. That is, a single dangling literal at the end of a file is fully allowed, and it is just treated as if it doesn&#39;t exist (there&#39;s no corresponding resource in the resulting <code>.res</code> file).</p>

<p>It also turns out that there are three <code>.rc</code> files in <a href="https://github.com/microsoft/Windows-classic-samples">Windows-classic-samples</a> that (accidentally, presumably) rely on this behavior (<a href="https://github.com/microsoft/Windows-classic-samples/blob/a47da3d4551b74bb8cc1f4c7447445ac594afb44/Samples/CredentialProvider/cpp/resources.rc">1</a>, <a href="https://github.com/microsoft/Windows-classic-samples/blob/a47da3d4551b74bb8cc1f4c7447445ac594afb44/Samples/Win7Samples/security/credentialproviders/sampleallcontrolscredentialprovider/resources.rc">2</a>, <a href="https://github.com/microsoft/Windows-classic-samples/blob/a47da3d4551b74bb8cc1f4c7447445ac594afb44/Samples/Win7Samples/security/credentialproviders/samplewrapexistingcredentialprovider/resources.rc">3</a>), so in order to fully pass <a href="https://github.com/squeek502/win32-samples-rc-tests/">win32-samples-rc-tests</a>, it is necessary to allow a dangling literal at the end of a file.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-6" href="#resinator-s-behavior-6">🔗</a></h4>
<p><code>resinator</code> allows a single dangling literal at the end of a file, but emits a warning:</p>
<pre><code><span>test.rc:5:1:</span><span> warning:</span><span> dangling literal at end-of-file; this is not a problem, but it is likely a mistake
</span><span>FOO
</span><span>^~~
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk, miscompilation</span></p><h3>Yes, that <code>MENU</code> over there (vague gesturing)<a id="yes-that-menu-over-there-vague-gesturing" href="#yes-that-menu-over-there-vague-gesturing">🔗</a></h3>
<p>As established in the intro, resource definitions typically have an <code>id</code>, like so:</p>
<pre><code><span><span>id<i></i></span><span>1</span></span> <span>FOO</span> <span>{</span> <span>&#34;bar&#34;</span> <span>}</span></code></pre>
<p>The <code>id</code> can be either a number (&#34;ordinal&#34;) or a string (&#34;name&#34;), and the type of the <code>id</code> is inferred by its contents. This mostly works as you&#39;d expect:</p>
<ul>
<li>If the <code>id</code> is all digits, then it&#39;s a number/ordinal</li>
<li>If the <code>id</code> is all letters, then it&#39;s a string/name</li>
<li>If the <code>id</code> is a mix of digits and letters, then it&#39;s a string/name</li>
</ul>
<p>Here&#39;s a few examples:</p>
<pre><code> 123    ───►  Ordinal: <span>123</span>
 ABC    ───►  Name: <span>ABC</span>
123ABC  ───►  Name: <span>123ABC</span></code></pre>
<p>This is relevant, because when defining <code>DIALOG</code>/<code>DIALOGEX</code> resources, there is an optional <code>MENU</code> statement that can specify the <code>id</code> of a separately defined <code>MENU</code>/<code>MENUEX</code> resource to use. From <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/dialogex-resource">the <code>DIALOGEX</code> docs</a>:</p>
<blockquote>
<table>
  <thead>
    <tr>
      <th>Statement</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>MENU</b> <i>menuname</i></td>
      <td>Menu to be used. This value is either the name of the menu or its integer identifier.</td>
    </tr>
  </tbody>
</table>
</blockquote>
<p>Here&#39;s an example of that in action, where the <code>DIALOGEX</code> is attempting to specify that the <code>MENUEX</code> with the <code>id</code> of <code>1ABC</code> should be used:</p>
<pre><code><span>1ABC</span> <span>MENUEX</span>  <span>◄╍╍╍╍╍╍╍╍╍╍╍╍╍╍┓</span>
<span>{</span>                           <span>┇</span>
<span>  // ...</span>                    <span>┇</span>
<span>}</span>                           <span>┇</span>
                            <span>┇</span>
<span>1 DIALOGEX 0, 0, 640, 480</span>   <span>┇</span>
  <span>MENU</span> <span>1ABC</span>  <span>╍╍╍╍╍╍╍╍╍╍╍╍╍╍╍┛</span>
<span>{
  // ...
}</span></code></pre>
<p>However, this is not what actually occurs, as for some reason, the <code>MENU</code> statement has different rules around inferring the type of the <code>id</code>. For the <code>MENU</code> statement, whenever the first character is a number, then the whole <code>id</code> is interpreted as a number no matter what.</p>
<p>The value of this &#34;number&#34; is determined using the same bogus methodology detailed in <a href="#non-ascii-digits-in-number-literals">&#34;<em>Non-ASCII digits in number literals</em>&#34;</a>, so in the case of <code>1ABC</code>, the value works out to 2899:</p>
<div>

<div>
<pre><code><span>&#39;1&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>1</span><span>
</span><span>&#39;A&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>17</span><span>
</span><span>&#39;B&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>18</span><span>
</span><span>&#39;C&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>19</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span> </span><span>1</span><span> </span><span>*</span><span> </span><span>1000</span><span> </span><span>=</span><span> </span><span>1000</span><span>
 </span><span>17</span><span> </span><span>*</span><span> </span><span>100</span><span> </span><span>=</span><span> </span><span>1700</span><span>
  </span><span>18</span><span> </span><span>*</span><span> </span><span>10</span><span> </span><span>=</span><span>  </span><span>180</span><span>
   </span><span>19</span><span> </span><span>*</span><span> </span><span>1</span><span> </span><span>=</span><span>   </span><span>19</span><span>
</span><span>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span><span>
            </span><span>2899</span><span>
</span></code></pre>
</div>
<p><i>&#34;numeric&#34; id</i></p>
<p><i>numeric value of each &#34;digit&#34;</i></p>
<p><i>numeric value of the id</i></p>
</div>
<p>Unlike <a href="#non-ascii-digits-in-number-literals">&#34;<em>Non-ASCII digits in number literals</em>&#34;</a>, though, it&#39;s now also possible to include characters in a &#34;number&#34; literal that have a <em>lower</em> ASCII value than the <code>&#39;0&#39;</code> character, meaning that attempting to get the numeric value for such a &#39;digit&#39; will induce wrapping <code>u16</code> overflow:</p>
<div>

<div>
<pre><code><span>&#39;1&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>1</span><span>
</span><span>&#39;!&#39;</span><span> </span><span>-</span><span> </span><span>&#39;0&#39;</span><span> </span><span>=</span><span> </span><span>-15</span><span>
      </span><span>-15</span><span> </span><span>=</span><span> </span><span>65521</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>    </span><span>1</span><span> </span><span>*</span><span> </span><span>10</span><span> </span><span>=</span><span>    </span><span>10</span><span>
 </span><span>65521</span><span> </span><span>*</span><span> </span><span>1</span><span> </span><span>=</span><span> </span><span>65521</span><span>
</span><span>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</span><span>
             </span><span>65531</span><span>
</span></code></pre>
</div>
<p><i>&#34;numeric&#34; id</i></p>
<p><i>numeric value of each &#34;digit&#34;</i></p>
<p><i>numeric value of the id</i></p>
</div>
<h4>This is always a miscompilation<a id="this-is-always-a-miscompilation" href="#this-is-always-a-miscompilation">🔗</a></h4>
<p>In the following example using the same <code>1ABC</code> ID as above:</p>
<pre><code><span>
</span><span>1ABC</span><span> </span><span>MENU</span><span>
</span><span>BEGIN</span><span>
  </span><span>POPUP</span><span> </span><span>&#34;Menu from .rc&#34;</span><span>
  </span><span>BEGIN</span><span>
    </span><span>MENUITEM</span><span> </span><span>&#34;Open File&#34;</span><span>,</span><span> </span><span>1</span><span>
  </span><span>END</span><span>
</span><span>END</span><span>

</span><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>275</span><span>,</span><span> </span><span>280</span><span>
  </span><span>CAPTION</span><span> </span><span>&#34;Dialog from .rc&#34;</span><span>
  </span><span>MENU</span><span> </span><span>1ABC</span><span>
</span><span>BEGIN</span><span>
</span><span>END</span><span>
</span></code></pre>
<pre><code><span>
</span><span>
    </span><span>HWND</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>CreateDialogParamW</span><span>(</span><span>g_hInst</span><span>,</span><span> </span><span>MAKEINTRESOURCE</span><span>(</span><span>1</span><span>),</span><span> </span><span>hwnd</span><span>,</span><span> </span><span>DialogProc</span><span>,</span><span> </span><span>(</span><span>LPARAM</span><span>)</span><span>NULL</span><span>);</span><span>
</span><span>
</span></code></pre>
<p>This <code>CreateDialogParamW</code> call will fail with <code>The specified resource name cannot be found in the image file</code> because, when loading the dialog, it will attempt to look for a menu resource with an integer ID of <code>2899</code>.</p>
<p>If we add such a <code>MENU</code> to the <code>.rc</code> file:</p>
<pre><code><span>2899</span><span> </span><span>MENU</span><span>
</span><span>BEGIN</span><span>
  </span><span>POPUP</span><span> </span><span>&#34;Wrong menu from .rc&#34;</span><span>
  </span><span>BEGIN</span><span>
    </span><span>MENUITEM</span><span> </span><span>&#34;Destroy File&#34;</span><span>,</span><span> </span><span>1</span><span>
  </span><span>END</span><span>
</span><span>END</span><span>
</span></code></pre>
<p>then the dialog will successfully load with this new menu, but it&#39;s pretty obvious this is <em>not</em> what was intended:</p>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/rc-wrong-menu.png"/>
<i>The misinterpretation of the ID can (at best) lead to an unexpected menu being loaded</i>
</p>
<h4>A related, but inconsequential, inconsistency<a id="a-related-but-inconsequential-inconsistency" href="#a-related-but-inconsequential-inconsistency">🔗</a></h4>
<p>As mentioned in <a href="#special-tokenization-rules-for-names-ids">&#34;<em>Special tokenization rules for names/IDs</em>&#34;</a>, when the <code>id</code> of a resource is a string/name, it is uppercased before being written to the <code>.res</code> file. This uppercasing is <em>not</em> done for the <code>MENU</code> statement of a <code>DIALOG</code>/<code>DIALOGEX</code> resource, so in this example:</p>
<pre><code><span>abc</span> <span>MENUEX</span>
<span>{</span>
<span>  // ...</span>
<span>}</span>

<span>1 DIALOGEX 0, 0, 640, 480</span>
  <span>MENU</span> <span>abc</span>
<span>{
  // ...
}</span></code></pre>
<p>The <code>id</code> of the <code>MENUEX</code> resource would be compiled as <code>ABC</code>, but the <code>DIALOGEX</code> would write the <code>id</code> of its menu as <code>abc</code>. This ends up not mattering, though, because it appears that <code>LoadMenu</code> uses a case-insensitive lookup.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-7" href="#resinator-s-behavior-7">🔗</a></h4>
<p><code>resinator</code> avoids the miscompilation and treats the <code>id</code> parameter of <code>MENU</code> statements in <code>DIALOG</code>/<code>DIALOGEX</code> resources exactly the same as the <code>id</code> of <code>MENU</code> resources.</p>
<pre><code><span>test.rc:3:8:</span><span> warning:</span><span> the id of this menu would be miscompiled by the Win32 RC compiler
</span><span>  MENU 1ABC
</span><span>       ^~~~
</span><span></span><span>test.rc:3:8:</span><span> note:</span><span> the Win32 RC compiler would evaluate the id as the ordinal/number value 2899
</span><span>
</span><span>test.rc:3:8:</span><span> note:</span><span> to avoid the potential miscompilation, the first character of the id should not be a digit
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>If you&#39;re not last, you&#39;re irrelevant<a id="if-you-re-not-last-you-re-irrelevant" href="#if-you-re-not-last-you-re-irrelevant">🔗</a></h3>
<p>Many resource types have optional statements that can be specified between the resource type and the beginning of its body, e.g.</p>
<pre><code><span>1</span><span> </span><span>ACCELERATORS</span><span>
  </span><span>LANGUAGE</span><span> </span><span>0x09</span><span>,</span><span> </span><span>0x01</span><span>
  </span><span>CHARACTERISTICS</span><span> </span><span>0x1234</span><span>
  </span><span>VERSION</span><span> </span><span>1</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Specifying multiple statements of the same type within a single resource definition is allowed, and the last occurrence of each statement type is the one that takes precedence, so the following would compile to the exact same <code>.res</code> as the example above:</p>
<pre><code><span>1</span><span> </span><span>ACCELERATORS</span><span>
  </span><span>CHARACTERISTICS</span><span> </span><span>1</span><span>
  </span><span>LANGUAGE</span><span> </span><span>0xFF</span><span>,</span><span> </span><span>0xFF</span><span>
  </span><span>LANGUAGE</span><span> </span><span>0x09</span><span>,</span><span> </span><span>0x01</span><span>
  </span><span>CHARACTERISTICS</span><span> </span><span>999</span><span>
  </span><span>CHARACTERISTICS</span><span> </span><span>0x1234</span><span>
  </span><span>VERSION</span><span> </span><span>999</span><span>
  </span><span>VERSION</span><span> </span><span>1</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This is not necessarily a problem on its own (although I think it should at least be a warning), but it can inadvertently lead to some bizarre behavior, as we&#39;ll see in the next bug/quirk.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-8" href="#resinator-s-behavior-8">🔗</a></h4>
<p><code>resinator</code> matches the Windows RC compiler behavior, but emits a warning for each ignored statement:</p>
<pre><code><span>test.rc:2:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  CHARACTERISTICS 1
</span><span>  ^~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:3:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  LANGUAGE 0xFF, 0xFF
</span><span>  ^~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:5:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  CHARACTERISTICS 999
</span><span>  ^~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:7:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  VERSION 999
</span><span>  ^~~~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk, miscompilation</span></p><h3>Once a number, always a number<a id="once-a-number-always-a-number" href="#once-a-number-always-a-number">🔗</a></h3>
<p>The behavior described in <a href="#yes-that-menu-over-there-vague-gesturing">&#34;<em>Yes, that <code>MENU</code> over there (vague gesturing)</em>&#34;</a> can also be induced in both <code>CLASS</code> and <code>MENU</code> statements of <code>DIALOG</code>/<code>DIALOGEX</code> resources via redundant statements. As seen in <a href="#if-you-re-not-last-you-re-irrelevant">&#34;<em>If you&#39;re not last, you&#39;re irrelevant</em>&#34;</a>, multiple statements of the same type are allowed to be specified without much issue, but in the case of <code>CLASS</code> and <code>MENU</code>, if any of the duplicate statements are interpreted as a number, then the value of last statement of its type (the only one that matters) <em>is always interpreted as a number no matter what it contains</em>.</p>
<pre><code><span>1 DIALOGEX 0, 0, 640, 480</span>
  <span>MENU</span> <span>123</span> 
  <span>MENU</span> <span>IM_A_STRING_I_SWEAR</span>  <span>────►</span>  <span>8360</span>
  <span>CLASS</span> <span>123</span> 
  <span>CLASS</span> <span>&#34;Seriously, I&#39;m a string&#34;</span>  <span>────►</span>  <span>55127</span>
<span>{
  // ...
}</span></code></pre>
<p>The algorithm for coercing the strings to a number is the same as the one outlined in <a href="#yes-that-menu-over-there-vague-gesturing">&#34;<em>Yes, that <code>MENU</code> over there (vague gesturing)</em>&#34;</a>, and, for the same reasons discussed there, this too is always a miscompilation.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-9" href="#resinator-s-behavior-9">🔗</a></h4>
<p><code>resinator</code> avoids the miscompilation and emits warnings:</p>
<pre><code><span>test.rc:2:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  MENU 123
</span><span>  ^~~~~~~~
</span><span></span><span>test.rc:4:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  CLASS 123
</span><span>  ^~~~~~~~~
</span><span></span><span>test.rc:5:9:</span><span> warning:</span><span> this class would be miscompiled by the Win32 RC compiler
</span><span>  CLASS &#34;Seriously, I&#39;m a string&#34;
</span><span>        ^~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:5:9:</span><span> note:</span><span> the Win32 RC compiler would evaluate it as the ordinal/number value 55127
</span><span>
</span><span>test.rc:5:9:</span><span> note:</span><span> to avoid the potential miscompilation, only specify one class per dialog resource
</span><span>
</span><span>test.rc:3:8:</span><span> warning:</span><span> the id of this menu would be miscompiled by the Win32 RC compiler
</span><span>  MENU IM_A_STRING_I_SWEAR
</span><span>       ^~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:3:8:</span><span> note:</span><span> the Win32 RC compiler would evaluate the id as the ordinal/number value 8360
</span><span>
</span><span>test.rc:3:8:</span><span> note:</span><span> to avoid the potential miscompilation, only specify one menu per dialog resource
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>L is not allowed there<a id="l-is-not-allowed-there" href="#l-is-not-allowed-there">🔗</a></h3>
<p>Like in C, an integer literal can be suffixed with <code>L</code> to signify that it is a &#39;long&#39; integer literal. In the case of the Windows RC compiler, integer literals are typically 16 bits wide, and suffixing an integer literal with <code>L</code> will instead make it 32 bits wide.</p>

<p><i>An <code>RCDATA</code> resource definition and a hexdump of the resulting data in the <code>.res</code> file</i></p>
<p>However, outside of raw data blocks like the <code>RCDATA</code> example above, the <code>L</code> suffix is typically meaningless, as it has no bearing on the size of the integer used. For example, <code>DIALOG</code> resources have <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> parameters, and they are each encoded in the data as a <code>u16</code> regardless of the integer literal used. If the value would overflow a <code>u16</code>, then the value is truncated back down to a <code>u16</code>, meaning in the following example all 4 parameters after <code>DIALOG</code> get compiled down to <code>1</code> as a <code>u16</code>:</p>
<pre><code><span>1</span><span> </span><span>DIALOG</span><span> </span><span>1</span><span>,</span><span> </span><span>1L</span><span>,</span><span> </span><span>65537</span><span>,</span><span> </span><span>65537L</span><span> </span><span>{}</span><span>
</span></code></pre>
<p><i>The maximum value of a <code>u16</code> is 65535</i></p>
<p>A few particular parameters, though, fully disallow integer literals with the <code>L</code> suffix from being used:</p>
<ul>
<li>Any of the four parameters of the <code>FILEVERSION</code> statement of a <code>VERSIONINFO</code> resource</li>
<li>Any of the four parameters of the <code>PRODUCTVERSION</code> statement of a <code>VERSIONINFO</code> resource</li>
<li>Any of the two parameters of a <code>LANGUAGE</code> statement</li>
</ul>
<div>

<div>
<pre><code><span>test.rc(1) : error RC2145 : PRIMARY LANGUAGE ID too large
</span></code></pre>
</div>
</div>
<div>
<div>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span>
  </span><span>FILEVERSION</span><span> </span><span>1L</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
</span><span>BEGIN</span><span>
  </span><span>
</span><span>END</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2127 : version WORDs separated by commas expected
</span></code></pre>
</div>
</div>
<p>It is true that these parameters are limited to <code>u16</code>, so using an <code>L</code> suffix is likely a mistake, but that is also true of many other parameters for which the Windows RC compiler happily allows <code>L</code> suffixed numbers for. It&#39;s unclear why these particular parameters are singled out, and even more unclear given the fact that specifying these parameters using an integer literal that would overflow a <code>u16</code> does not actually trigger an error (and instead it truncates the values to a <code>u16</code>):</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span>
  </span><span>FILEVERSION</span><span> </span><span>65537</span><span>,</span><span> </span><span>65538</span><span>,</span><span> </span><span>65539</span><span>,</span><span> </span><span>65540</span><span>
</span><span>BEGIN</span><span>
</span><span>END</span><span>
</span></code></pre>
<p>The compiled <code>FILEVERSION</code> in this case will be <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>:</p>
<pre><code>65537 = 0x10001; truncated to u16 = 0x0001
65538 = 0x10002; truncated to u16 = 0x0002
65539 = 0x10003; truncated to u16 = 0x0003
65540 = 0x10004; truncated to u16 = 0x0004
</code></pre>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-10" href="#resinator-s-behavior-10">🔗</a></h4>
<p><code>resinator</code> allows <code>L</code> suffixed integer literals everywhere and truncates the value down to the appropriate number of bits when necessary.</p>
<pre><code><span>test.rc:1:10:</span><span> warning:</span><span> this language parameter would be an error in the Win32 RC compiler
</span><span>LANGUAGE 1L, 2
</span><span>         ^~
</span><span></span><span>test.rc:1:10:</span><span> note:</span><span> to avoid the error, remove any L suffixes from numbers within the parameter
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>Unary operators are an illusion<a id="unary-operators-are-an-illusion" href="#unary-operators-are-an-illusion">🔗</a></h3>
<p>Typically, unary <code>+</code>, <code>-</code>, etc. operators are just that—operators; they are separate tokens that act on other tokens (number literals, variables, etc). However, in the Windows RC compiler, they are not real operators.</p>
<h4>Unary <code>-</code><a id="unary" href="#unary">🔗</a></h4>
<p>The unary <code>-</code> is included as part of a number literal, not as a distinct operator. This behavior can be confirmed in a rather strange way, taking advantage of a separate quirk described in <a href="#number-expressions-as-filenames">&#34;<em>Number expressions as filenames</em>&#34;</a>. When a resource&#39;s filename is specified as a number expression, the file path it ultimately looks for is the last number literal in the expression, so for example:</p>
<div>

<div>
<pre><code><span>test.rc(1) : error RC2135 : file not found: 123
</span></code></pre>
</div>
</div>
<p>And if we throw in a unary <code>-</code> like so, then it gets included as part of the filename:</p>
<div>

<div>
<pre><code><span>test.rc(1) : error RC2135 : file not found: -123
</span></code></pre>
</div>
</div>
<p>This quirk leads to a few unexpected valid patterns, since <code>-</code> on its own is also considered a valid number literal (and it resolves to <code>0</code>), so:</p>
<pre><code><span>1</span><span> </span><span>FOO</span><span> </span><span>{</span><span> </span><span>1</span><span>--</span><span> </span><span>}</span><span>
</span></code></pre>
<p>evaluates to <code>1-0</code> and results in <code>1</code> being written to the resource&#39;s data, while:</p>
<pre><code><span>1</span><span> </span><span>FOO</span><span> </span><span>{</span><span> </span><span>&#34;str&#34;</span><span> </span><span>-</span><span> </span><span>1</span><span> </span><span>}</span><span>
</span></code></pre>
<p>looks like a string literal minus 1, but it&#39;s actually interpreted as 3 separate raw data values (<code>str</code>, <code>-</code> [which evaluates to 0], and <code>1</code>), since commas between data values in a raw data block are optional.</p>
<p>Additionally, it means that otherwise valid looking expressions may not actually be considered valid:</p>
<div>

<div>
<pre><code><span>test.rc(1) : error RC1013 : mismatched parentheses
</span></code></pre>
</div>
</div>
<h4>Unary <code>~</code><a id="unary-2" href="#unary-2">🔗</a></h4>
<p>The unary NOT (<code>~</code>) works exactly the same as the unary <code>-</code> and has all the same quirks. For example, a <code>~</code> on its own is also a valid number literal:</p>
<div>

<div>
<div><p>Data is a <code>u16</code> with the value <code>0xFFFF</code></p></div>
</div>
</div>
<p>And <code>~L</code> (to turn the integer into a <code>u32</code>) is valid in the same way that <code>-L</code> would be valid:</p>
<div>

<div>
<div><p>Data is a <code>u32</code> with the value <code>0xFFFFFFFF</code></p></div>
</div>
</div>
<h4>Unary <code>+</code><a id="unary-3" href="#unary-3">🔗</a></h4>
<p>The unary <code>+</code> is almost entirely a hallucination; it can be used in some places, but not others, without any discernible rhyme or reason.</p>
<p>This is valid (and the parameters evaluate to <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> as expected):</p>
<pre><code><span>1</span><span> </span><span>DIALOG</span><span> </span><span>+</span><span>1</span><span>,</span><span> </span><span>+</span><span>2</span><span>,</span><span> </span><span>+</span><span>3</span><span>,</span><span> </span><span>+</span><span>4</span><span> </span><span>{}</span><span>
</span></code></pre>
<p>but this is an error:</p>
<div>

<div>
<pre><code><span>test.rc(1) : error RC2164 : unexpected value in RCDATA
</span></code></pre>
</div>
</div>
<p>and so is this:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>DIALOG</span><span> </span><span>(</span><span>+</span><span>1</span><span>),</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span> </span><span>{}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(1) : error RC2237 : numeric value expected at DIALOG
</span></code></pre>
</div>
</div>
<p>Because the rules around the unary <code>+</code> are so opaque, I am unsure if it shares many of the same properties as the unary <code>-</code>. I do know, though, that <code>+</code> on its own does not seem to be an accepted number literal in any case I&#39;ve seen so far.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-11" href="#resinator-s-behavior-11">🔗</a></h4>
<p><code>resinator</code> matches the Windows RC compiler&#39;s behavior around unary <code>-</code>/<code>~</code>, but disallows unary <code>+</code> entirely:</p>
<pre><code><span>test.rc:1:10:</span><span> error:</span><span> expected number or number expression; got &#39;+&#39;
</span><span>1 DIALOG +1, +2, +3, +4 {}
</span><span>         ^
</span><span></span><span>test.rc:1:10:</span><span> note:</span><span> the Win32 RC compiler may accept &#39;+&#39; as a unary operator here, but it is not supported in this implementation; consider omitting the unary +
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation</span></p><h3>Your fate will be determined by a comma<a id="your-fate-will-be-determined-by-a-comma" href="#your-fate-will-be-determined-by-a-comma">🔗</a></h3>
<p>Version information is specified using key/value pairs within <code>VERSIONINFO</code> resources. In the compiled <code>.res</code> file, the value data should always start at a 4-byte boundary, so after the key data is written, a variable number of padding bytes are written to get back to 4-byte alignment:</p>
<div>
<div>
  <pre>    <code><span>1 VERSIONINFO {</span>
  <span>VALUE</span> <span>&#34;key&#34;</span>, <span>&#34;value&#34;</span>
<span>}</span></code>
  </pre>
</div>
<div>
  <pre>    <code><span>......</span><span>k.e.y...</span><span>..</span>
<span>v.a.l.u.e...</span><span>....</span></code>
  </pre>
</div>
</div>
<p><i>Two padding bytes are inserted after the <code>key</code> to get back to 4-byte alignment</i></p>
<p>However, if the comma between the key and value is omitted, then for whatever reason the padding bytes are also omitted:</p>
<div>
<div>
  <pre>    <code><span>1 VERSIONINFO {</span>
  <span>VALUE</span> <span>&#34;key&#34;</span> <span>&#34;value&#34;</span>
<span>}</span></code>
  </pre>
</div>
<div>
  <pre>    <code><span>......</span><span>k.e.y...</span><span>v.
a.l.u.e...</span><span>......</span></code>
  </pre>
</div>
</div>
<p><i>Without the comma between <code>&#34;key&#34;</code> and <code>&#34;value&#34;</code>, the padding bytes are not written</i></p>
<p>The problem here is that consumers of the <code>VERSIONINFO</code> resource (e.g. <a href="https://learn.microsoft.com/en-us/windows/win32/api/winver/nf-winver-verqueryvaluew"><code>VerQueryValue</code></a>) will expect the padding bytes, so it will try to read the value as if the padding bytes were there. For example, with the simple <code>&#34;key&#34; &#34;value&#34;</code> example:</p>
<pre><code><span>VerQueryValueW</span><span>(</span><span>verbuf</span><span>,</span><span> </span><span>L</span><span>&#34;\\key&#34;</span><span>,</span><span> </span><span>&amp;</span><span>querybuf</span><span>,</span><span> </span><span>&amp;</span><span>querysize</span><span>);</span><span>
</span><span>wprintf</span><span>(</span><span>L</span><span>&#34;%s\n&#34;</span><span>,</span><span> </span><span>querybuf</span><span>);</span><span>
</span></code></pre>
<p>Which will print:</p>
<pre><code><span>alue
</span></code></pre>
<p>Plus, depending on the length of the key string, it can end up being even worse, since the value could end up being written over the top of the null terminator of the key. Here&#39;s an example:</p>
<div>
<div>
  <pre>    <code><span>1 VERSIONINFO {</span>
  <span>VALUE</span> <span>&#34;ke&#34;</span> <span>&#34;value&#34;</span>
<span>}</span></code>
  </pre>
</div>
<div>
  <pre>    <code><span>......</span><span>k.e.</span><span>v.a.l.
u.e...</span><span>..........</span></code>
  </pre>
</div>
</div>
<p>And the problems don&#39;t end there—<code>VERSIONINFO</code> is compiled into a tree structure, meaning the misreading of one node affects the reading of future nodes. Here&#39;s a (simplified) real-world <code>VERSIONINFO</code> resource definition from a random <code>.rc</code> file in <a href="https://github.com/microsoft/Windows-classic-samples">Windows-classic-samples</a>:</p>
<pre><code><span>VS_VERSION_INFO</span><span> </span><span>VERSIONINFO</span><span>
</span><span>BEGIN</span><span>
    </span><span>BLOCK</span><span> </span><span>&#34;StringFileInfo&#34;</span><span>
    </span><span>BEGIN</span><span>
        </span><span>BLOCK</span><span> </span><span>&#34;040904e4&#34;</span><span>
        </span><span>BEGIN</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;CompanyName&#34;</span><span>,</span><span> </span><span>&#34;Microsoft&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;FileDescription&#34;</span><span>,</span><span> </span><span>&#34;AmbientLightAware&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;FileVersion&#34;</span><span>,</span><span> </span><span>&#34;1.0.0.1&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;InternalName&#34;</span><span>,</span><span> </span><span>&#34;AmbientLightAware.exe&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;LegalCopyright&#34;</span><span>,</span><span> </span><span>&#34;(c) Microsoft.  All rights reserved.&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;OriginalFilename&#34;</span><span>,</span><span> </span><span>&#34;AmbientLightAware.exe&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;ProductName&#34;</span><span>,</span><span> </span><span>&#34;AmbientLightAware&#34;</span><span>
            </span><span>VALUE</span><span> </span><span>&#34;ProductVersion&#34;</span><span>,</span><span> </span><span>&#34;1.0.0.1&#34;</span><span>
        </span><span>END</span><span>
    </span><span>END</span><span>
    </span><span>BLOCK</span><span> </span><span>&#34;VarFileInfo&#34;</span><span>
    </span><span>BEGIN</span><span>
        </span><span>VALUE</span><span> </span><span>&#34;Translation&#34;</span><span>,</span><span> </span><span>0x409</span><span>,</span><span> </span><span>1252</span><span>
    </span><span>END</span><span>
</span><span>END</span><span>
</span></code></pre>
<p>and here&#39;s the Properties window of an <code>.exe</code> compiled with and without commas between all the key/value pairs:</p>
<div>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/versioninfo-correct.png"/>
<i>Correct version information with commas included...</i>
</p>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/versioninfo-broken.png"/>
<i>...but completely broken if the commas are omitted</i>
</p>
</div>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-12" href="#resinator-s-behavior-12">🔗</a></h4>
<p><code>resinator</code> avoids the miscompilation (always inserts the necessary padding bytes) and emits a warning.</p>
<pre><code><span>test.rc:2:15:</span><span> warning:</span><span> the padding before this quoted string value would be miscompiled by the Win32 RC compiler
</span><span>  VALUE &#34;key&#34; &#34;value&#34;
</span><span>              ^~~~~~~
</span><span></span><span>test.rc:2:15:</span><span> note:</span><span> to avoid the potential miscompilation, consider adding a comma between the key and the quoted string
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation</span></p><h3>Mismatch in length units in <code>VERSIONINFO</code> nodes<a id="mismatch-in-length-units-in-versioninfo-nodes" href="#mismatch-in-length-units-in-versioninfo-nodes">🔗</a></h3>
<p>A <code>VALUE</code> within a <code>VERSIONINFO</code> resource is specified using this syntax:</p>
<pre><code><span>VALUE</span><span> </span><span>&lt;</span><span>name</span><span>&gt;</span><span>,</span><span> </span><span>&lt;</span><span>value</span><span>(</span><span>s</span><span>)</span><span>&gt;</span><span>
</span></code></pre>
<p>The <code>value(s)</code> can be specified as either number literals or quoted string literals, like so:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;numbers&#34;</span><span>,</span><span> </span><span>123</span><span>,</span><span> </span><span>456</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;strings&#34;</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;bar&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Each <code>VALUE</code> is compiled into a structure that contains the length of its value data, but the unit used for the length varies:</p>
<ul>
<li>For strings, the string data is written as UTF-16, and the length is given in UTF-16 code units (2 bytes per code unit)</li>
<li>For numbers, the numbers are written either as <code>u16</code> or <code>u32</code> (depending on the presence of an <code>L</code> suffix), and the length is given in bytes</li>
</ul>
<p>So, for the above example, the <code>&#34;numbers&#34;</code> value would be compiled into a node with:</p>
<ul>
<li>&#34;Binary&#34; data, meaning the length is given in bytes</li>
<li>A length of <code>4</code>, since each number literal is compiled as a <code>u16</code></li>
<li>Data bytes of <code><span>7B 00</span></code> <code><span>C8 01</span></code>, where <code><span>7B 00</span></code> is <code>123</code> and <code><span>C8 01</span></code> is <code>456</code> (as little-endian <code>u16</code>)</li>
</ul>
<p>and the <code>&#34;strings&#34;</code> value would be compiled into a node with:</p>
<ul>
<li>&#34;String&#34; data, meaning the length is given in UTF-16 code units</li>
<li>A length of <code>8</code>, since each string is 3 UTF-16 code units plus a <code>NUL</code>-terminator</li>
<li>Data bytes of <code><span>66 00 6F 00 6F 00 00 00</span> <span>62 00 61 00 72 00 00 00</span></code>, where <code><span>66 00 6F 00 6F 00 00 00</span></code> is <code>&#34;foo&#34;</code> and <code><span>62 00 61 00 72 00 00 00</span></code> is <code>&#34;bar&#34;</code> (both as <code>NUL</code>-terminated little-endian UTF-16)</li>
</ul>
<p>This is a bit bizarre, but when separated out like this it works fine. The problem is that there is nothing stopping you from mixing strings and numbers in one value, in which case the Windows RC compiler freaks out and writes the type as &#34;binary&#34; (meaning the length should be interpreted as a byte count), but the length as a mixture of byte count and UTF-16 code unit count. For example, with this resource:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;something&#34;</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>123</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Its value&#39;s data will get compiled into these bytes: <code><span>66 00 6F 00 6F 00 00 00</span> <span>7B 00</span></code>, where <code><span>66 00 6F 00 6F 00 00 00</span></code> is <code>&#34;foo&#34;</code> (as <code>NUL</code>-terminated little-endian UTF-16) and <code><span>7B 00</span></code> is <code>123</code> (as a little-endian <code>u16</code>). This makes for a total of 10 bytes (8 for <code>&#34;foo&#34;</code>, 2 for <code>123</code>), but the Windows RC compiler erroneously reports the value&#39;s data length as 6 (4 for <code>&#34;foo&#34;</code> [counted as UTF-16 code units], and 2 for <code>123</code> [counted as bytes]).</p>
<p>This miscompilation has similar results as those detailed in <a href="#your-fate-will-be-determined-by-a-comma">&#34;<em>Your fate will be determined by a comma</em>&#34;</a>:</p>
<ul>
<li>The full data of the value will not be read by a parser</li>
<li>Due to the tree structure of <code>VERSIONINFO</code> resource data, this has knock-on effects on all following nodes, meaning the entire resource will be mangled</li>
</ul>

<h4>The return of the meaningful comma<a id="the-return-of-the-meaningful-comma" href="#the-return-of-the-meaningful-comma">🔗</a></h4>
<p>Before, I said that string values were compiled as <code>NUL</code>-terminated UTF-16 strings, but this is only the case when either:</p>
<ul>
<li>It is the last data element of a <code>VALUE</code>, or</li>
<li>There is a comma separating it from the element after it</li>
</ul>
<p>So, this:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;strings&#34;</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;bar&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>will be compiled with a <code>NUL</code> terminator after both <code>foo</code> and <code>bar</code>, but this:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;strings&#34;</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>&#34;bar&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>will be compiled only with a <code>NUL</code> terminator after <code>bar</code>. This is also similar to <a href="#your-fate-will-be-determined-by-a-comma">&#34;<em>Your fate will be determined by a comma</em>&#34;</a>, but unlike that comma quirk, I don&#39;t consider this one a miscompilation because the result is not invalid/mangled, and there is a possible use-case for this behavior (concatenating two or more string literals together). However, this behavior is not mentioned in the documentation, so it&#39;s unclear if it&#39;s actually intended.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-13" href="#resinator-s-behavior-13">🔗</a></h4>
<p><code>resinator</code> avoids the length-related miscompilation and emits a warning:</p>
<pre><code><span>test.rc:2:22:</span><span> warning:</span><span> the byte count of this value would be miscompiled by the Win32 RC compiler
</span><span>  VALUE &#34;something&#34;, &#34;foo&#34;, 123
</span><span>                     ^~~~~~~~~~
</span><span></span><span>test.rc:2:22:</span><span> note:</span><span> to avoid the potential miscompilation, do not mix numbers and strings within a value
</span><span></span></code></pre>
<p>but matches the &#34;meaningful comma&#34; behavior of the Windows RC compiler.</p>
</div>
<div>
<p><span>fundamental concept</span></p><h3>Turning off flags with <code>NOT</code> expressions<a id="turning-off-flags-with-not-expressions" href="#turning-off-flags-with-not-expressions">🔗</a></h3>
<p>Let&#39;s say you wanted to define a dialog resource with a button, but you wanted the button to start invisible. You&#39;d do this with a <code>NOT</code> expression in the &#34;style&#34; parameter of the button like so:</p>
<pre><code><span>1 DIALOGEX 0, 0, 282, 239
{</span>
  PUSHBUTTON <span>&#34;Cancel&#34;,1,129,212,50,14,</span> <span>NOT</span> WS_VISIBLE
<span>}</span></code>
</pre>
<p>Since <code>WS_VISIBLE</code> is set by default, this will unset it and make the button invisible. If there are any other flags that should be applied, they can be bitwise OR&#39;d like so:</p>
<pre><code><span>1 DIALOGEX 0, 0, 282, 239
{</span>
  PUSHBUTTON <span>&#34;Cancel&#34;,1,129,212,50,14,</span> <span>NOT</span> WS_VISIBLE <span>|</span> BS_VCENTER
<span>}</span></code>
</pre>
<p><code>WS_VISIBLE</code> and <code>BS_VCENTER</code> are just numbers under-the-hood. For simplicity&#39;s sake, let&#39;s pretend their values are <code>0x1</code> for <code>WS_VISIBLE</code> and <code>0x2</code> for <code>BS_VCENTER</code> and then focus on this simplified <code>NOT</code> expression:</p>
<pre><code><span>NOT</span> 0x1 <span>|</span> 0x2</code>
</pre>
<p>Since <code>WS_VISIBLE</code> is on by default, the default value of these flags is <code>0x1</code>, and so the resulting value is evaluated like this:</p>
<div>
<p><i>operation</i></p>
<p><i>binary representation of the result</i></p>
<p><i>hex representation of the result</i></p>
<p><span><small>Default value:</small> <code>0x1</code></span></p>

<p><span><code>0x1</code></span></p>
<p><code><span>NOT</span> 0x1</code></p>

<p><span><code>0x0</code></span></p>
<p><code><span>|</span> 0x2</code></p>

<p><span><code>0x2</code></span></p>
</div>
<p>Ordering matters as well. If we switch the expression to:</p>
<pre><code><span>NOT</span><span> </span><span>0x1</span><span> </span><span>|</span><span> </span><span>0x1</span><span>
</span></code></pre>
<p>then we end up with <code>0x1</code> as the result:</p>
<div>
<p><i>operation</i></p>
<p><i>binary representation of the result</i></p>
<p><i>hex representation of the result</i></p>
<p><span><small>Default value:</small> <code>0x1</code></span></p>

<p><span><code>0x1</code></span></p>
<p><code><span>NOT</span> 0x1</code></p>

<p><span><code>0x0</code></span></p>
<p><code><span>|</span> 0x1</code></p>

<p><span><code>0x1</code></span></p>
</div>
<p>If, instead, the ordering was reversed like so:</p>
<pre><code><span>0x1</span><span> </span><span>|</span><span> </span><span>NOT</span><span> </span><span>0x1</span><span>
</span></code></pre>
<p>then the value at the end would be <code>0x0</code>:</p>
<div>
<p><i>operation</i></p>
<p><i>binary representation of the result</i></p>
<p><i>hex representation of the result</i></p>
<p><span><small>Default value:</small> <code>0x1</code></span></p>

<p><span><code>0x1</code></span></p>
<p><code>0x1</code></p>

<p><span><code>0x1</code></span></p>
<p><code><span>|</span> <span>NOT</span> 0x1</code></p>

<p><span><code>0x0</code></span></p>
</div>
<p>With these basic examples, <code>NOT</code> seems pretty straightforward, however...</p>
</div>
<div>
<p><span>utterly baffling</span></p><h3><code>NOT</code> is incomprehensible<a id="not-is-incomprehensible" href="#not-is-incomprehensible">🔗</a></h3>
<p>Practically any deviation outside the simple examples outlined in <a href="#turning-off-flags-with-not-expressions"><em>Turning off flags with <code>NOT</code> expressions</em></a> leads to bizarre and inexplicable results. For example, these expressions are all accepted by the Windows RC compiler:</p>
<ul>
<li><code>NOT (1 | 2)</code></li>
<li><code>NOT () 2</code></li>
<li><code>7 NOT NOT 4 NOT 2 NOT NOT 1</code></li>
</ul>
<p>The first one looks like it makes sense, as intuitively the <code>(1 | 2)</code> would be evaluated first so in theory it should be equivalent to <code>NOT 3</code>. However, if the default value of the flags is <code>0</code>, then the expression <code>NOT (1 | 2)</code> (somehow) evaluates to <code>2</code>, whereas <code>NOT 3</code> would evaluate to <code>0</code>.</p>
<p><code>NOT () 2</code> seems like it should obviously be a syntax error, but for whatever reason it&#39;s accepted by the Windows RC compiler and also evaluates to <code>2</code>.</p>
<p><code>7 NOT NOT 4 NOT 2 NOT NOT 1</code> is entirely incomprehensible, and just as incomprehensibly, it <em>also</em> results in <code>2</code> (if the default value is <code>0</code>).</p>
<p>This behavior is so bizarre and obviously incorrect that I didn&#39;t even try to understand what&#39;s going on here, so your guess is as good as mine on this one.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-14" href="#resinator-s-behavior-14">🔗</a></h4>
<p><code>resinator</code> only accepts <code>NOT &lt;number&gt;</code>, anything else is an error:</p>
<pre><code><span>test.rc:2:13:</span><span> error:</span><span> expected &#39;&lt;number&gt;&#39;, got &#39;(&#39;
</span><span>  STYLE NOT () 2
</span><span>            ^
</span><span></span></code></pre>
<p>All 3 of the above examples lead to compile errors in <code>resinator</code>.</p>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3><code>NOT</code> can be used in places it makes no sense<a id="not-can-be-used-in-places-it-makes-no-sense" href="#not-can-be-used-in-places-it-makes-no-sense">🔗</a></h3>
<p>The strangeness of <code>NOT</code> doesn&#39;t end there, as the Windows RC compiler also allows it to be used in many (but not all) places that a number expression can be used.</p>
<p>As an example, here are <code>NOT</code> expressions used in the <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> arguments of a <code>DIALOGEX</code> resource:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>NOT</span><span> </span><span>1</span><span>,</span><span> </span><span>NOT</span><span> </span><span>2</span><span>,</span><span> </span><span>NOT</span><span> </span><span>3</span><span>,</span><span> </span><span>NOT</span><span> </span><span>4</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This doesn&#39;t necessarily cause problems, but since <code>NOT</code> is only useful in the context of turning off enabled-by-default flags of a bit flag parameter, there&#39;s no reason to allow <code>NOT</code> expressions outside of that context.</p>
<p>However, there <em>is</em> an extra bit of weirdness involved here, since certain <code>NOT</code> expressions cause errors in some places but not others. For example, the expression <code>1 | NOT 2</code> is an error if it&#39;s used in the <code>type</code> parameter of a <code>MENUEX</code>&#39;s <code>MENUITEM</code>, but <code>NOT 2 | 1</code> is totally accepted.</p>
<pre><code><span>1</span><span> </span><span>MENUEX</span><span> </span><span>{</span><span>
  </span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;bar&#34;</span><span>,</span><span> </span><span>101</span><span>,</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>NOT</span><span> </span><span>2</span><span>
  </span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>100</span><span>,</span><span> </span><span>NOT</span><span> </span><span>2</span><span> </span><span>|</span><span> </span><span>1</span><span>
</span><span>}</span><span>
</span></code></pre>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-15" href="#resinator-s-behavior-15">🔗</a></h4>
<p><code>resinator</code> errors if <code>NOT</code> expressions are attempted to be used outside of bit flag parameters:</p>
<pre><code><span>test.rc:1:12:</span><span> error:</span><span> expected number or number expression; got &#39;NOT&#39;
</span><span>1 DIALOGEX NOT 1, NOT 2, NOT 3, NOT 4
</span><span>           ^~~
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation, crash</span></p><h3>No one has thought about <code>FONT</code> resources for decades<a id="no-one-has-thought-about-font-resources-for-decades" href="#no-one-has-thought-about-font-resources-for-decades">🔗</a></h3>
<p>As far as I can tell, the <code>FONT</code> resource has exactly one purpose: creating <code>.fon</code> files, which are resource-only <code>.dll</code>s (i.e. a <code>.dll</code> with resources, but no entry point) renamed to have a <code>.fon</code> extension. Such <code>.fon</code> files contain a collection of fonts in the obsolete <code>.fnt</code> font format.</p>
<p>The <code>.fon</code> format is mostly obsolete, but is still supported in modern Windows, and Windows <em>still</em> ships with some <code>.fon</code> files included:</p>
<div>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/windows-10-fon.png"/></p><p><i>The <code>Terminal</code> font included in Windows 10 is a <code>.fon</code> file</i></p>
</div>
<p>This <code>.fon</code>-related purpose for the <code>FONT</code> resource, however, has been irrelevant for decades, and, as far as I can tell, has not worked fully correctly since the 16-bit version of the Windows RC compiler. To understand why, though, we have to understand a little bit about the <code>.fnt</code> format.</p>
<p>In version 1 of the <code>.fnt</code> format, specified by the <a href="https://www.os2museum.com/files/docs/win10sdk/windows-1.03-sdk-prgref-1986.pdf">Windows 1.03 SDK from 1986</a>, the total size of all the static fields in the header was 117 bytes, with a few fields containing offsets to variable-length data elsewhere in the file. Here&#39;s a (truncated) visualization, with some relevant &#39;offset&#39; fields expanded:</p>
<pre><code><span>....version....</span>
<span>......size.....</span>
<span>...copyright...</span>
<span>......type.....</span>
<span>. . . etc . . .</span>
<span>. . . etc . . .</span>
<span>.device_offset.</span> ───► <span>NUL-terminated device name.</span>
<span>..face_offset..</span> ───► <span>NUL-terminated font face name.</span>
<span>....bits_ptr...</span>
<span>..bits_offset..</span></code></pre>
<p>In <a href="https://web.archive.org/web/20080115184921/http://support.microsoft.com/kb/65123">version 3 of the <code>.fnt</code> format</a> (and presumably version 2, but I can&#39;t find much info about version 2), all of the fields up to and including <code>bits_offset</code> are the same, but there are an additional 31 bytes of new fields, making for a total size of 148 bytes:</p>
<pre><code><span><span>....version....</span>
<span>. . . etc . . .</span>
<span>. . . etc . . .</span>
<span>.device_offset.</span>
<span>..face_offset..</span>
<span>....bits_ptr...</span>
<span>..bits_offset..</span></span>
<span>....reserved...</span> ◄─┐
<span>.....flags.....</span> ◄─┤
<span>.....aspace....</span> ◄─┤
<span>.....bspace....</span> ◄─┼── new fields
<span>.....cspace....</span> ◄─┤
<span>...color_ptr...</span> ◄─┤
<span>...reserved1...</span>   │
<span>...............</span> ◄─┘
<span>...............</span></code></pre>
<p>Getting back to resource compilation, <code>FONT</code> resources within <code>.rc</code> files are collected and compiled into the following resources:</p>
<ul>
<li>A <code>RT_FONT</code> resource for each <code>FONT</code>, where the data is the verbatim file contents of the <code>.fnt</code> file</li>
<li>A <code>FONTDIR</code> resource that contains data about each font, in the format specified by <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/fontgrouphdr"><code>FONTGROUPHDR</code></a>
<ul>
<li>side note: the string <code>FONTDIR</code> is the type of this resource, it doesn&#39;t have an associated integer ID like most other Windows-defined resources do</li>
</ul>
</li>
</ul>
<p>Within the <code>FONTDIR</code> resource, there is a <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/fontdirentry"><code>FONTDIRENTRY</code></a> for each font, containing much of the information in the <code>.fnt</code> header. In fact, the data actually matches the version 1 <code>.fnt</code> header almost exactly, with only a few differences at the end:</p>
<pre><code>.fnt version 1      FONTDIRENTRY
<span></span>
<span>....version....</span> == <span>...dfVersion...</span>
<span>......size.....</span> == <span>.....dfSize....</span>
<span>...copyright...</span> == <span>..dfCopyright..</span>
<span>......type.....</span> == <span>.....dfType....</span>
<span>. . . etc . . .</span> == <span>. . . etc . . .</span>
<span>. . . etc . . .</span> == <span>. . . etc . . .</span>
<span>.device_offset.</span> == <span>....dfDevice...</span>
<span>..face_offset..</span> == <span>.....dfFace....</span>
<span>....bits_ptr...</span> =? <span>...dfReserved..</span>
<span>..bits_offset..</span>    <span>NUL-terminated device name.</span>
                   <span>NUL-terminated font face name.</span></code></pre>
<p><i>The formats match, except <code>FONTDIRENTRY</code> does not include <code>bits_offset</code> and instead it has trailing variable-length strings</i></p>
<p>This documented <code>FONTDIRENTRY</code> <em>is</em> what the obsolete 16-bit version of <code>rc.exe</code> outputs: 113 bytes plus two variable-length <code>NUL</code>-terminated strings at the end. However, starting with the 32-bit resource compiler, contrary to the documentation, <code>rc.exe</code> now outputs <code>FONTDIRENTRY</code> as 148 bytes plus the two variable-length <code>NUL</code>-terminated strings.</p>
<p>You might notice that this 148 number has come up before; it&#39;s the size of the <code>.fnt</code> version 3 header. So, starting with the 32-bit <code>rc.exe</code>, <code>FONTDIRENTRY</code> as-written-by-the-resource-compiler is effectively the first 148 bytes of the <code>.fnt</code> file, plus the two strings located at the positions given by the <code>device_offset</code> and <code>face_offset</code> fields. Or, at least, that&#39;s clearly the intention, but this is labeled &#39;miscompilation&#39; for a reason.</p>
<p>Let&#39;s take this example <code>.fnt</code> file for instance:</p>
<pre><code><span>....version....</span>
<span>. . . etc . . .</span>
<span>. . . etc . . .</span>
<span>.device_offset.</span> ───► <span>some device.</span>
<span>..face_offset..</span> ───► <span>some font face.</span>
<span>. . . etc . . .</span>
<span>. . . etc . . .</span>
<span>...reserved1...</span>
<span>...............</span>
<span>...............</span></code></pre>
<p>When compiled with the old 16-bit Windows RC compiler, <code>some device</code> and <code>some font face</code> are written as trailing strings in the <code>FONTDIRENTRY</code> (as expected), but when compiled with the modern <code>rc.exe</code>, both strings get written as 0-length (only a <code>NUL</code> terminator). The reason why is rather silly, so let&#39;s go through it. Here&#39;s the documented <code>FONTDIRENTRY</code> format again, this time with some annotations:</p>
<pre><code>      FONTDIRENTRY
<span></span>
-113 <span>...dfVersion...</span> (2 bytes)
-111 <span>.....dfSize....</span> (4 bytes)
-107 <span>..dfCopyright..</span> (60 bytes)
 -47 <span>.....dfType....</span> (2 bytes)
     <span>. . . etc . . .</span>
     <span>. . . etc . . .</span>
 -12 <span>....dfDevice...</span> (4 bytes)
  -8 <span>.....dfFace....</span> (4 bytes)
  -4 <span>...dfReserved..</span> (4 bytes)</code></pre>
<p><i>The numbers on the left represent the offset from the end of the <code>FONTDIRENTRY</code> data to the start of the field</i></p>
<p>It turns out that the Windows RC compiler uses the offset <em>from the end of <code>FONTDIRENTRY</code></em> to get the values of the <code>dfDevice</code> and <code>dfFace</code> fields. This works fine when those offsets are unchanging, but, as we&#39;ve seen, the Windows RC compiler now uses an undocumented <code>FONTDIRENTRY</code> definition that is is 35 bytes longer, but these hardcoded offsets were never updated accordingly. This means that the Windows RC compiler is actually attempting to read the <code>dfDevice</code> and <code>dfFace</code> fields from this part of the <code>.fnt</code> version 3 header:</p>
<pre><code>    <span>....version....</span>
    <span>. . . etc . . .</span>
    <span>. . . etc . . .</span>
    <span>.device_offset.</span>
    <span>..face_offset..</span>
    <span>. . . etc . . .</span>
    <span>. . . etc . . .</span>
-12 <span>...reserved1...</span> ───► <span>???</span>
 -8 <span>...............</span> ───► <span>???</span>
 -4 <span>...............</span></code></pre>
<p><i>The Windows RC compiler reads data from the <code>reserved1</code> field and interprets it as <code>dfDevice</code> and <code>dfFace</code></i></p>
<p>Because this bug happens to end up reading data from a reserved field, it&#39;s very likely for that data to just contain zeroes, which means it will try to read the <code>NUL</code>-terminated strings starting at offset <code>0</code> from the start of the file. As a second coincidence, the first field of a <code>.fnt</code> file is a <code>u16</code> containing the version, and the only versions I&#39;m aware of are:</p>
<ul>
<li>Version 1, <code>0x0100</code> encoded as little-endian, so the bytes at offset 0 are <code>00 01</code></li>
<li>Version 2, <code>0x0200</code> encoded as little-endian, so the bytes at offset 0 are <code>00 02</code></li>
<li>Version 3, <code>0x0300</code> encoded as little-endian, so the bytes at offset 0 are <code>00 03</code></li>
</ul>
<p>In all three cases, the first byte is <code>0x00</code>, meaning attempting to read a <code>NUL</code> terminated string from offset <code>0</code> always ends up with a 0-length string for all known/valid <code>.fnt</code> versions. So, in practice, the Windows RC compiler almost always writes the trailing <code>szDeviceName</code> and <code>szFaceName</code> strings as 0-length strings.</p>

<p>This behavior can be confirmed by crafting a <code>.fnt</code> file with actual offsets to <code>NUL</code>-terminated strings within the reserved data field that the Windows RC compiler erroneously reads from:</p>
<pre><code><span>....version....</span>
<span>. . . etc . . .</span>
<span>. . . etc . . .</span>
<span>.device_offset.</span> ───► <span>some device.</span>
<span>..face_offset..</span> ───► <span>some font face.</span>
<span>. . . etc . . .</span>
<span>. . . etc . . .</span>
<span>...reserved1...</span> ───► <span>i dare you to read me.</span>
<span>...............</span> ───► <span>you wouldn&#39;t.</span>
<span>...............</span></code></pre>
<p>Compiling such a <code>FONT</code> resource, we do indeed see that the strings <code>i dare you to read me</code> and <code>you wouldn&#39;t</code> are written to the <code>FONTDIRENTRY</code> for this <code>FONT</code> rather than <code>some device</code> and <code>some font face</code>.</p>
<h4>Does any of this even matter?<a id="does-any-of-this-even-matter" href="#does-any-of-this-even-matter">🔗</a></h4>
<p>Well, no, not really. The whole concept of the <code>FONTDIR</code> containing information about all the <code>RT_FONT</code> resources is something of a historical relic, likely only relevant when resources were constrained enough that having an overview of the font data all in once place allowed for optimization opportunities that made a difference.</p>
<p>From what I can tell, though, on modern Windows, the <code>FONTDIR</code> resource is ignored entirely:</p>
<ul>
<li>Linker implementations will happily link <code>.res</code> files that contain <code>RT_FONT</code> resources with no <code>FONTDIR</code> resource</li>
<li>Windows will happily load/install <code>.fon</code> files that contain <code>RT_FONT</code> resources with no <code>FONTDIR</code> resource</li>
</ul>
<p>However, there are a few caveats...</p>
<h4>Misuse of the <code>FONT</code> resource for non-<code>.fnt</code> fonts<a id="misuse-of-the-font-resource-for-non-fnt-fonts" href="#misuse-of-the-font-resource-for-non-fnt-fonts">🔗</a></h4>
<p>I&#39;m not sure how prevalent this is, but it can be forgiven that someone might not realize that <code>FONT</code> is only intended to be used with a font format that has been obsolete for multiple decades, and try to use the <code>FONT</code> resource with a modern font format.</p>
<p>In fact, there is one Microsoft-provided <a href="https://github.com/microsoft/Windows-classic-samples"><code>Windows-classic-samples</code></a> example program that uses <code>FONT</code> resources with <code>.ttf</code> files to include custom fonts in a program: <a href="https://github.com/microsoft/Windows-classic-samples/tree/main/Samples/Win7Samples/multimedia/DirectWrite/CustomFont"><code>Win7Samples/multimedia/DirectWrite/CustomFont</code></a>. This is meant to be an example of using <a href="https://learn.microsoft.com/en-us/windows/win32/directwrite/custom-font-collections">the DirectWrite APIs described here</a>, but this is almost certainly a misuse of the <code>FONT</code> resource. <a href="https://github.com/microsoft/Windows-classic-samples/tree/main/Samples/DirectWriteCustomFontSets">Other examples</a>, however, use user-defined resource types for including <code>.ttf</code> font files, which seems like the correct choice.</p>
<p>When using non-<code>.fnt</code> files with the <code>FONT</code> resource, the resulting <code>FONTDIRENTRY</code> will be made up of garbage, since it effectively just takes the first 148 bytes of the file and stuffs it into the <code>FONTDIRENTRY</code> format. An additional complication with this is that the Windows RC compiler will still try to read <code>NUL</code>-terminated strings using the offsets from the <code>dfDevice</code> and <code>dfFace</code> fields (or at least, where it thinks they are). These offset values, in turn, will have much more variance since the format of <code>.fnt</code> and <code>.ttf</code> are so different.</p>
<p>This means that using <code>FONT</code> with <code>.ttf</code> files may lead to errors, since...</p>
<h4>&#34;Negative&#34; offsets lead to errors<a id="negative-offsets-lead-to-errors" href="#negative-offsets-lead-to-errors">🔗</a></h4>
<p>For who knows what reason, the <code>dfDevice</code> and <code>dfFace</code> values are seemingly treated as signed integers, even though they ostensibly contain an offset from the beginning of the <code>.fnt</code> file, so a negative value makes no sense. When the sign bit is set in either of these fields, the Windows RC compiler will error with:</p>
<pre><code>fatal error RW1023: I/O error seeking in file
</code></pre>
<p>This means that, for some subset of valid <code>.ttf</code> files (or other non-<code>.fnt</code> font formats), the Windows RC compiler will fail with this error.</p>
<h4>Other oddities and crashes<a id="other-oddities-and-crashes" href="#other-oddities-and-crashes">🔗</a></h4>
<ul>
<li>If the font file is 140 bytes or fewer, the Windows RC compiler seems to default to a <code>dfFace</code> of <code>0</code> (as the [incorrect] location of the <code>dfFace</code> field is past the end of the file).</li>
<li>If the file is 75 bytes or smaller with no <code>0x00</code> bytes, the <code>FONTDIR</code> data for it will be 149 bytes (the first <code>n</code> being the bytes from the file, then the rest are <code>0x00</code> padding bytes). After that, there will be <code>n</code> bytes from the file again, and then a final <code>0x00</code>.</li>
<li>If the file is between 76 and 140 bytes long with no <code>0x00</code> bytes, the Windows RC compiler will crash.</li>
</ul>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-16" href="#resinator-s-behavior-16">🔗</a></h4>
<p>I&#39;m still not quite sure what the best course of action is here. I&#39;ve <a href="https://squeek502.github.io/resinator/windows/resources/font.html#so-really-what-should-go-in-the-fontdir">written up what I see as the possibilities here</a>, and for now I&#39;ve gone with what I&#39;m calling the &#34;semi-compatibility while avoiding the sharp edges&#34; approach:</p>
<blockquote>
<p>Do something similar enough to the Win32 compiler in the common case, but avoid emulating the buggy behavior where it makes sense. That would look like a <code>FONTDIRENTRY</code> with the following format:</p>
<ul>
<li>The first 148 bytes from the file verbatim, with no interpretation whatsoever, followed by two <code>NUL</code> bytes (corresponding to &#39;device name&#39; and &#39;face name&#39; both being zero length strings)</li>
</ul>
<p>This would allow the <code>FONTDIR</code> to match byte-for-byte with the Win32 RC compiler in the common case (since very often the misinterpreted <code>dfDevice</code>/<code>dfFace</code> will be <code>0</code> or point somewhere outside the bounds of the file and therefore will be written as a zero-length string anyway), and only differ in the case where the Win32 RC compiler writes some bogus string(s) to the <code>szDeviceName</code>/<code>szFaceName</code>.</p>
<p>This also enables the use-case of non-<code>.FNT</code> files without any loose ends.</p>
</blockquote>
<p>In short: write the new/undocumented <code>FONTDIRENTRY</code> format, but avoid the crashes, avoid the negative integer-related errors, and always write <code>szDeviceName</code> and <code>szFaceName</code> as 0-length.</p>
</div>
<div>
<p><span>fundamental concept</span></p><h3>The involvement of a C/C++ preprocessor<a id="the-involvement-of-a-c-c-preprocessor" href="#the-involvement-of-a-c-c-preprocessor">🔗</a></h3>
<p>In the intro, I said:</p>
<blockquote>
<p><code>.rc</code> files are scripts that contain both <strong>C/C++ preprocessor commands</strong> and resource definitions.</p>
</blockquote>
<p>So far, I&#39;ve only focused on resource definitions, but the involvement of the C/C++ preprocessor cannot be ignored. From the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/about-resource-files">About Resource Files</a> documentation:</p>
<blockquote>
<p>The syntax and semantics for the RC preprocessor are similar to those of the Microsoft C/C++ compiler. However, RC supports a subset of the preprocessor directives, defines, and pragmas in a script.</p>
</blockquote>
<p>The primary use-case for this is two-fold:</p>
<ul>
<li>Inclusion of C/C++ headers within a <code>.rc</code> file to pull in constants, e.g. <code>#include &lt;windows.h&gt;</code> to allow usage of <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles">window style constants</a> like <code>WS_VISIBLE</code>, <code>WS_BORDER</code>, etc.</li>
<li>Being able to share a <code>.h</code> file between your <code>.rc</code> file and your C/C++ source files, where the <code>.h</code> file contains things like the IDs of various resources.</li>
</ul>
<p>Here&#39;s some snippets that demonstrate both use-cases:</p>
<pre><code><span>
</span><span>#define</span><span> </span><span>DIALOG_ID</span><span> </span><span>123</span><span>
</span><span>#define</span><span> </span><span>BUTTON_ID</span><span> </span><span>234</span><span>
</span></code></pre>
<pre><code><span>
</span><span>#include</span><span> </span><span>&lt;windows.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&#34;resource.h&#34;</span><span>

</span><span>
</span><span>DIALOG_ID</span><span> </span><span>DIALOGEX</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>282</span><span>,</span><span> </span><span>239</span><span>
  </span><span>
  </span><span>STYLE</span><span> </span><span>DS_SETFONT</span><span> </span><span>|</span><span> </span><span>DS_MODALFRAME</span><span> </span><span>|</span><span> </span><span>DS_CENTER</span><span> </span><span>|</span><span> </span><span>WS_POPUP</span><span> </span><span>|</span><span> </span><span>WS_CAPTION</span><span> </span><span>|</span><span> </span><span>WS_SYSMENU</span><span>
  </span><span>CAPTION</span><span> </span><span>&#34;Dialog&#34;</span><span>
</span><span>{</span><span>
  </span><span>
  </span><span>PUSHBUTTON</span><span> </span><span>&#34;Button&#34;</span><span>,</span><span> </span><span>BUTTON_ID</span><span>,</span><span> </span><span>129</span><span>,</span><span> </span><span>182</span><span>,</span><span> </span><span>50</span><span>,</span><span> </span><span>14</span><span>
</span><span>}</span><span>
</span></code></pre>
<pre><code><span>
</span><span>#include</span><span> </span><span>&lt;windows.h&gt;</span><span>
</span><span>#include</span><span> </span><span>&#34;resource.h&#34;</span><span>

</span><span>
  </span><span>
  </span><span>HWND</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>CreateDialogParamW</span><span>(</span><span>hInst</span><span>,</span><span> </span><span>MAKEINTRESOURCEW</span><span>(</span><span>DIALOG_ID</span><span>),</span><span> </span><span>hwnd</span><span>,</span><span> </span><span>DialogProc</span><span>,</span><span> </span><span>(</span><span>LPARAM</span><span>)</span><span>NULL</span><span>);</span><span>
</span><span>

</span><span>
  </span><span>
  </span><span>HWND</span><span> </span><span>button</span><span> </span><span>=</span><span> </span><span>GetDlgItem</span><span>(</span><span>hwnd</span><span>,</span><span> </span><span>BUTTON_ID</span><span>);</span><span>
</span><span>
</span></code></pre>
<p>With this setup, changing <code>DIALOG_ID</code>/<code>BUTTON_ID</code> in <code>resource.h</code> affects both <code>resource.rc</code> and <code>main.c</code>, so they are always kept in sync.</p>

</div>
<div>
<p><span>preprocessor bug/quirk, parser bug/quirk</span></p><h3>Multiline strings don&#39;t behave as expected/documented<a id="multiline-strings-don-t-behave-as-expected-documented" href="#multiline-strings-don-t-behave-as-expected-documented">🔗</a></h3>
<p>Within the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/stringtable-resource"><code>STRINGTABLE</code> resource documentation</a> we see this statement:</p>
<blockquote>
<p>The string [...] must occupy a single line in the source file (unless a &#39;\&#39; is used as a line continuation).</p>
</blockquote>

<p>This is similar to the rules around C strings:</p>
<div>
<div>
<pre><code><span>char</span><span> </span><span>*</span><span>my_string</span><span> </span><span>=</span><span> </span><span>&#34;Line 1</span><span>
</span><span>Line</span><span> </span><span>2</span><span>&#34;;</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>multilinestring.c:1:19:</span><span> error:</span><span> missing terminating &#39;&#34;&#39; character
</span><span>char *my_string = &#34;Line 1
</span><span>                  ^
</span><span></span></code></pre>
</div>
</div>
<p><i>Splitting a string across multiple lines without using <code>\</code> is an error in C</i></p>
<div>
<div>
<pre><code><span>char</span><span> </span><span>*</span><span>my_string</span><span> </span><span>=</span><span> </span><span>&#34;Line 1 \
Line 2&#34;</span><span>;</span><span>
</span></code></pre>
</div>
<div>
<p><code>printf(&#34;%s\n&#34;, my_string);</code> results in:</p>
<pre><code><span>Line 1 Line 2
</span></code></pre>
</div>
</div>
<p>And yet, contrary to the documentation, splitting a string across multiple lines without <code>\</code> continuations <em>is not an error</em> in the Windows RC compiler. Here&#39;s an example:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>

</span><span>&#34;foo
bar&#34;</span><span>

</span><span>}</span><span>
</span></code></pre>
<p>This will successfully compile, and the data of the <code>RCDATA</code> resource will end up as</p>
<pre><code><span>66 6F 6F</span> <span>20</span> <span>0A</span> <span>62 61 72</span>   <span>foo</span><span> <span>space<i></i></span></span><span>.<span>\n<i></i></span></span><span>bar</span></code></pre>
<p>I&#39;m not sure why this is allowed, and I also don&#39;t have an explanation for why a space character sneaks into the resulting data out of nowhere. It&#39;s also worth noting that whitespace is collapsed in these should-be-invalid multiline strings. For example, this:</p>
<pre><code><span>&#34;foo

    bar&#34;</span><span>
</span></code></pre>
<p>will get compiled into exactly the same data as above (with only a space and a newline between <code>foo</code> and <code>bar</code>).</p>

<p>But, this on its own is only a minor nuisance from the perspective of implementing a resource compiler—it is undocumented behavior, but it&#39;s pretty easy to account for. The real problems start when someone actually uses <code>\</code> as intended.</p>
<h4>The collapse of whitespace is imminent<a id="the-collapse-of-whitespace-is-imminent" href="#the-collapse-of-whitespace-is-imminent">🔗</a></h4>
<p>C pop quiz: what will get printed in this example (i.e. what will <code>my_string</code> evaluate to)?</p>
<pre><code><span>char</span><span> </span><span>*</span><span>my_string</span><span> </span><span>=</span><span> </span><span>&#34;Line 1 \
                   Line 2&#34;</span><span>;</span><span>

</span><span>#include</span><span> </span><span>&lt;stdio.h&gt;</span><span>

</span><span>int</span><span> </span><span>main</span><span>()</span><span> </span><span>{</span><span>
  </span><span>printf</span><span>(</span><span>&#34;%s\n&#34;</span><span>,</span><span> </span><span>my_string</span><span>);</span><span>
  </span><span>return</span><span> </span><span>0</span><span>;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Let&#39;s compile it with a few different compilers to find out:</p>
<pre><code><span>&gt;</span><span> zig run multilinestring.c -lc
</span><span>Line 1                    Line 2

</span><span>&gt;</span><span> clang multilinestring.c
</span><span></span><span>&gt;</span><span> a.exe
</span><span>Line 1                    Line 2

</span><span>&gt;</span><span> cl.exe multilinestring.c
</span><span></span><span>&gt;</span><span> multilinestring.exe
</span><span>Line 1                    Line 2
</span></code></pre>
<p>That is, the whitespace preceding &#34;Line 2&#34; is included in the string literal.</p>

<p>However, the Windows RC compiler behaves differently here. If we pass the same example through <em>its</em> preprocessor, we end up with:</p>
<pre><code><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;multilinestring.c&#34;</span><span>
</span><span>char</span><span> </span><span>*</span><span>my_string</span><span> </span><span>=</span><span> </span><span>&#34;Line 1 \
Line 2&#34;</span><span>;</span><span>
</span></code></pre>
<ol>
<li>The <code>\</code> remains (similar to the MSVC compiler, see the note above)</li>
<li>The whitespace before &#34;Line 2&#34; is removed</li>
</ol>
<p>So the value of <code>my_string</code> would be <code>Line 1 Line 2</code> (well, not really, since <code>char *my_string = </code> doesn&#39;t have a meaning in <code>.rc</code> files, but you get the idea). This divergence in behavior from C has practical consequences: in <a href="https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/winui/shell/appshellintegration/NonDefaultDropMenuVerb/NonDefaultDropMenuVerb.rc">this <code>.rc</code> file</a> from one of the <a href="https://github.com/microsoft/Windows-classic-samples">Windows-classic-samples</a> example programs, we see the following, which takes advantage of the <code>rc.exe</code>-preprocessor-specific-whitespace-collapsing behavior:</p>
<pre><code><span>STRINGTABLE</span><span> 
</span><span>BEGIN</span><span>
    </span><span>
    </span><span>IDS_MESSAGETEMPLATEFS</span><span>   </span><span>&#34;The drop target is %s.\n\
                            %d files/directories in HDROP\n\
                            The path to the first object is\n\
                            \t%s.&#34;</span><span>
    </span><span>
</span><span>END</span><span>
</span></code></pre>
<p>Plus, in certain circumstances, this difference between <code>rc.exe</code> and C (like <a href="#all-operators-have-equal-precedence">other differences to C</a>) can lead to bugs. This is a rather contrived example, but here&#39;s one way things could go wrong:</p>
<pre><code><span>
</span><span>#define</span><span> </span><span>FOO_TEXT</span><span> </span><span>&#34;foo \
                  bar&#34;</span><span>
</span><span>#define</span><span> </span><span>IDC_BUTTON_FOO</span><span> </span><span>1001</span><span>
</span></code></pre>
<pre><code><span>
</span><span>#include</span><span> </span><span>&#34;foo.h&#34;</span><span>

</span><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>275</span><span>,</span><span> </span><span>280</span><span>
</span><span>BEGIN</span><span>
    </span><span>PUSHBUTTON</span><span> </span><span>FOO_TEXT</span><span>,</span><span> </span><span>IDC_BUTTON_FOO</span><span>,</span><span> </span><span>7</span><span>,</span><span> </span><span>73</span><span>,</span><span> </span><span>93</span><span>,</span><span> </span><span>14</span><span>
</span><span>END</span><span>
</span></code></pre>
<pre><code><span>
</span><span>#include</span><span> </span><span>&#34;foo.h&#34;</span><span>

</span><span>
    </span><span>HWND</span><span> </span><span>hFooBtn</span><span> </span><span>=</span><span> </span><span>GetDlgItem</span><span>(</span><span>hDlg</span><span>,</span><span> </span><span>IDC_BUTTON_FOO</span><span>);</span><span>
    </span><span>
    </span><span>
    </span><span>SendMessage</span><span>(</span><span>hFooBtn</span><span>,</span><span> </span><span>WM_SETTEXT</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>(</span><span>LPARAM</span><span>)</span><span> </span><span>_T</span><span>(</span><span>FOO_TEXT</span><span>));</span><span>
</span><span>
</span></code></pre>
<p>In this example, the button defined in the <code>DIALOGEX</code> would start with the text <code>foo bar</code>, since that is the value that the Windows RC compiler resolves <code>FOO_TEXT</code> to be, but the <code>SendMessage</code> call would then set the text to <code>foo                   bar</code>, since that&#39;s what the C compiler resolves <code>FOO_TEXT</code> to be.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-17" href="#resinator-s-behavior-17">🔗</a></h4>
<p><code>resinator</code> uses the <a href="https://github.com/Vexu/arocc">Aro preprocessor</a>, which means it acts like a C compiler. In the future, <code>resinator</code> will likely fork Aro (<a href="https://github.com/squeek502/resinator/issues/5">mostly to support UTF-16 encoded files</a>), which could allow matching the behavior of <code>rc.exe</code> in this case as well.</p>
</div>
<div>
<p><span>parser bug/quirk, utterly baffling</span></p><h3>Escaping quotes is fraught<a id="escaping-quotes-is-fraught" href="#escaping-quotes-is-fraught">🔗</a></h3>
<p>Again from the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/stringtable-resource"><code>STRINGTABLE</code> resource docs</a>:</p>
<blockquote>
<p>To embed quotes in the string, use the following sequence: <code>&#34;&#34;</code>. For example, <code>&#34;&#34;&#34;Line three&#34;&#34;&#34;</code> defines a string that is displayed as follows:</p>
<pre><code>&#34;Line three&#34;
</code></pre>
</blockquote>
<p>This is different from C, where <code>\&#34;</code> is used to escape quotes within a string literal, so in C to get <code>&#34;Line three&#34;</code> you&#39;d do <code>&#34;\&#34;Line three\&#34;&#34;</code>.</p>

<p>This difference, though, can lead to some really bizarre results, since the preprocessor <em>still uses the C escaping rules</em>. Take this simple example:</p>
<pre><code><span>&#34;\&#34;&#34;BLAH&#34;
</span></code></pre>
<p>Here&#39;s how that is seen from the perspective of the preprocessor:</p>
<pre><code><span><span>string<i></i></span><span><span>&#34;\&#34;&#34;</span></span></span><span><span>identifier<i></i></span><span><span>BLAH</span></span></span><span><span>string (unfinished)<i></i></span><span><span>&#34;</span></span></span></code></pre>
<p>And from the perspective of the compiler:</p>
<pre><code><span><span>string<i></i></span><span><span>&#34;\&#34;&#34;BLAH&#34;</span></span></span></code></pre>
<p>So, following from this, say you had this <code>.rc</code> file:</p>
<pre><code><span>#define</span><span> </span><span>BLAH</span><span> </span><span>&#34;hello&#34;</span><span>

</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;\&#34;&#34;BLAH&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>Since we know the preprocessor sees <code>BLAH</code> as an identifier and we&#39;ve done <code>#define BLAH &#34;hello&#34;</code>, it will replace <code>BLAH</code> with <code>&#34;hello&#34;</code>, leading to this result:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;\&#34;&#34;&#34;</span><span>hello</span><span>&#34;&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>which would now be parsed by the compiler as:</p>
<pre><code><span><span>string<i></i></span><span><span>&#34;\&#34;&#34;&#34;</span></span></span><span><span>identifier<i></i></span><span><span>hello</span></span></span><span><span>string<i></i></span><span><span>&#34;&#34;</span></span></span></code></pre>
<p>and lead to a compile error:</p>
<pre><code>test.rc(3) : error RC2104 : undefined keyword or key name: hello
</code></pre>
<p>This is just one example, but the general disagreement around escaped quotes between the preprocessor and the compiler can lead to some really unexpected error messages.</p>
<h4>Wait, but what actually happens to the backslash?<a id="wait-but-what-actually-happens-to-the-backslash" href="#wait-but-what-actually-happens-to-the-backslash">🔗</a></h4>
<p>Backing up a bit, I said that the compiler sees <code>&#34;\&#34;&#34;BLAH&#34;</code> as one string literal token, so:</p>
<pre><code>1 <span>RCDATA</span> <span>{</span> <span><span>string<i></i></span><span><span>&#34;\&#34;&#34;BLAH&#34;</span></span></span> <span>}</span></code></pre>
<p>If we compile this, then the data of this <code>RCDATA</code> resource ends up as:</p>
<pre><code>&#34;BLAH
</code></pre>
<p>That is, the <code>\</code> fully drops out and the <code>&#34;&#34;</code> is treated as an escaped quote. This seems to some sort of special case, as this behavior is not present for other unrecognized escape sequences, e.g. <code>&#34;\k&#34;</code> will end up as <code>\k</code> when compiled, and <code>&#34;\&#34;</code> will end up as <code>\</code>.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-18" href="#resinator-s-behavior-18">🔗</a></h4>
<p>Using <code>\&#34;</code> within string literals is always an error, since (as mentioned) it can lead to things like unexpected macro expansions and hard-to-understand errors when the preprocessor and the compiler disagree.</p>
<pre><code><span>test.rc:1:13:</span><span> error:</span><span> escaping quotes with \&#34; is not allowed (use &#34;&#34; instead)
</span><span>1 RCDATA { &#34;\&#34;&#34;BLAH&#34; }
</span><span>            ^~
</span><span></span></code></pre>
<p>This may change if it turns out <code>\&#34;</code> is commonly used in the wild, but that seems unlikely to be the case.</p>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>The column of a tab character matters<a id="the-column-of-a-tab-character-matters" href="#the-column-of-a-tab-character-matters">🔗</a></h3>
<p>Literal tab characters (<code>U+009</code>) within an <code>.rc</code> file get transformed by the preprocessor into a variable number of spaces (1-8), depending on the column of the tab character in the source file. This means that whitespace can affect the output of the compiler. Here&#39;s a few examples, where <code><span title="Horizontal Tab (\t)">────</span></code> denotes a tab character:</p>
<div>
<div>
<div>
  <pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span>
<span>&#34;</span><span title="Horizontal Tab (\t)">────</span><span>&#34;</span>
<span>}</span></code></pre>
</div>
</div>
<div>
<p>the tab gets compiled to 7 spaces:</p>
</div>

</div>
<div>
<div>
<div>
  <pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span>
   <span>&#34;</span><span title="Horizontal Tab (\t)">────</span><span>&#34;</span>
<span>}</span></code></pre>
</div>
</div>
<div>
<p>the tab gets compiled to 4 spaces:</p>
</div>

</div>
<div>
<div>
<div>
  <pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span>
      <span>&#34;</span><span title="Horizontal Tab (\t)">────</span><span>&#34;</span>
<span>}</span></code></pre>
</div>
</div>
<div>
<p>the tab gets compiled to 1 space:</p>
</div>

</div>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-19" href="#resinator-s-behavior-19">🔗</a></h4>
<p><code>resinator</code> matches the Win32 RC compiler behavior, but emits a warning</p>
<pre><code><span>test.rc:2:4:</span><span> warning:</span><span> the tab character(s) in this string will be converted into a variable number of spaces (determined by the column of the tab character in the .rc file)
</span><span>   &#34; &#34;
</span><span>   ^~~
</span><span></span><span>test.rc:2:4:</span><span> note:</span><span> to include the tab character itself in a string, the escape sequence \t should be used
</span><span></span></code></pre>
</div>
<div>
<p><span>fundamental concept</span></p><h3>The Windows RC compiler &#39;speaks&#39; UTF-16<a id="the-windows-rc-compiler-speaks-utf-16" href="#the-windows-rc-compiler-speaks-utf-16">🔗</a></h3>
<p>As mentioned before, <code>.rc</code> files are compiled in two distinct steps:</p>
<ol>
<li>First, they are run through a C/C++ preprocessor (<code>rc.exe</code> has a preprocessor implementation built-in)</li>
<li>The result of the preprocessing step is then compiled into a <code>.res</code> file</li>
</ol>
<p>In addition to <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/preprocessor-directives">a subset of the normal C/C++ preprocessor directives</a>, there is one resource-compiler-specific <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/pragma-directives"><code>#pragma code_page</code> directive</a> that allows changing which code page is active mid-file. This means that <code>.rc</code> files can <em>have a mixture of encodings</em> within a single file:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>1252</span><span>)</span><span> </span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;This is interpreted as Windows-1252: €&#34;</span><span> </span><span>}</span><span>

</span><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span><span> </span><span>
</span><span>2</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;This is interpreted as UTF-8: €&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>If the above example file is saved as <a href="https://en.wikipedia.org/wiki/Windows-1252">Windows-1252</a>, each <code>€</code> is encoded as the byte <code>0x80</code>, meaning:</p>
<ul>
<li>The <code>€</code> (<code>0x80</code>) in the <code>RCDATA</code> with ID <code>1</code> will be interpreted as a <code>€</code></li>
<li>The <code>€</code> (<code>0x80</code>) in the <code>RCDATA</code> with ID <code>2</code> will attempt to be interpreted as UTF-8, but <code>0x80</code> is an invalid start byte for a UTF-8 sequence, so it will be replaced during preprocessing with the Unicode replacement character (� or <code>U+FFFD</code>)</li>
</ul>
<p>So, if we run the Windows-1252-encoded file through only the <code>rc.exe</code> preprocessor (using the <a href="#p-okay-i-ll-only-preprocess-but-you-re-not-going-to-like-it">undocumented <code>rc.exe /p</code> option</a>), the result is a file with the following contents:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span> </span><span>1252</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;This is interpreted as Windows-1252: €&#34;</span><span> </span><span>}</span><span>

</span><span>#pragma</span><span> </span><span>code_page</span><span> </span><span>65001</span><span>
</span><span>2</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;This is interpreted as UTF-8: �&#34;</span><span> </span><span>}</span><span>
</span></code></pre>

<p>If, instead, the example file is saved as <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, each <code>€</code> is encoded as the byte sequence <code>0xE2 0x82 0xAC</code>, meaning:</p>
<ul>
<li>The <code>€</code> (<code>0xE2 0x82 0xAC</code>) in the <code>RCDATA</code> with ID <code>1</code> will be interpreted as <code>â‚¬</code></li>
<li>The <code>€</code> (<code>0xE2 0x82 0xAC</code>) in the <code>RCDATA</code> with ID <code>2</code> will be interpreted as <code>€</code></li>
</ul>
<p>So, if we run the UTF-8-encoded version through the <code>rc.exe</code> preprocessor, the result looks like this:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span> </span><span>1252</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;This is interpreted as Windows-1252: â‚¬&#34;</span><span> </span><span>}</span><span>

</span><span>#pragma</span><span> </span><span>code_page</span><span> </span><span>65001</span><span>
</span><span>2</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;This is interpreted as UTF-8: €&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>In both of these examples, the result of the <code>rc.exe</code> preprocessor is encoded as UTF-16. This is because, in the Windows RC compiler, the relevant code page interpretation is done during preprocessing, and the output of the preprocessor is <em>always</em> UTF-16. This, in turn, means that the parser/compiler of the Windows RC compiler <em>always</em> ingests UTF-16, as there&#39;s no option to skip the preprocessing step.</p>
<p>This will be relevant for future bugs/quirks, so just file this knowledge away for now.</p>
</div>
<div>
<p><span>preprocessor bug/quirk</span></p><h3>Extreme <code>#pragma code_page</code> values<a id="extreme-pragma-code-page-values" href="#extreme-pragma-code-page-values">🔗</a></h3>
<p>As seen above, the resource-compiler-specific preprocessor directive <code>#pragma code_page</code> can be used to alter the current <a href="https://en.wikipedia.org/wiki/Code_page">code page</a> mid-file. It&#39;s used like so:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>1252</span><span>)</span><span> </span><span>
</span><span>

</span><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span><span> </span><span>
</span><span>
</span></code></pre>
<p>The list of possible code pages <a href="https://learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers">can be found here</a>. If you try to use one that is not valid, <code>rc.exe</code> will error with:</p>
<pre><code>fatal error RC4214: Codepage not valid:  ignored
</code></pre>
<p>But what happens if you try to use an extremely large code page value (greater or equal to the max of a <code>u32</code>)? Most of the time it errors in the same way as above, but occasionally there&#39;s a strange / inexplicable error. Here&#39;s a selection of a few:</p>
<div>
<div>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>4294967296</span><span>)</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>error RC4212: Codepage not integer:  )
fatal error RC1116: RC terminating after preprocessor errors
</span></code></pre>
</div>
<div>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>4295032296</span><span>)</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>fatal error RC22105: MultiByteToWideChar failed.
</span></code></pre>
</div>
<div>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>4295032297</span><span>)</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2177: constant too big
test.rc(2) : error RC4212: Codepage not integer:  4
fatal error RC1116: RC terminating after preprocessor errors
</span></code></pre>
</div>
</div>
<p>I don&#39;t have an explanation for this behavior, especially with regards to why only certian extreme values induce an error at all.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-20" href="#resinator-s-behavior-20">🔗</a></h4>
<p><code>resinator</code> treats code pages exceeding the max of a <code>u32</code> as a fatal error.</p>
<pre><code><span>test.rc:1:1:</span><span> error:</span><span> code page too large in #pragma code_page
</span><span>#pragma code_page ( 4294967296 )
</span><span>^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
<p>This is a separate error from the one caused by invalid/unsupported code pages:</p>
<pre><code><span>test.rc:1:1:</span><span> error:</span><span> invalid or unknown code page in #pragma code_page
</span><span>#pragma code_page ( 64999 )
</span><span>^~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
<pre><code><span>test.rc:1:1:</span><span> error:</span><span> unsupported code page &#39;utf7 (id=65000)&#39; in #pragma code_page
</span><span>#pragma code_page ( 65000 )
</span><span>^~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>preprocessor/parser bug/quirk</span></p><h3>Escaping in wide string literals<a id="escaping-in-wide-string-literals" href="#escaping-in-wide-string-literals">🔗</a></h3>
<p>In regular string literals, invalid escape sequences get compiled into their literal characters. For example:</p>
<pre><code><span>1</span> <span>RCDATA</span> <span>{</span>
   <span>&#34;abc\k&#34;</span>  <span>────►</span>  <span title="Compiled data">abc\k</span>
<span>}</span></code></pre>
<p>However, for reasons unknown, invalid escape characters within wide string literals disappear from the compiled result entirely:</p>
<pre><code><span>1</span> <span>RCDATA</span> <span>{</span>
  L<span>&#34;abc\k&#34;</span>  <span>────►</span>  <span title="Compiled data (UTF-16)">a.b.c.</span>
<span>}</span></code></pre>
<p>On its own, this is just an inexplicable quirk, but when combined with other quirks, it gets elevated to the level of a (potential) bug.</p>
<h4>In combination with tab characters<a id="in-combination-with-tab-characters" href="#in-combination-with-tab-characters">🔗</a></h4>
<p>As detailed in <a href="#the-column-of-a-tab-character-matters">&#34;<em>The column of a tab character matters</em>&#34;</a>, an embedded tab character gets converted to a variable number of spaces depending on which column it&#39;s at in the file. This happens during preprocesing, which means that by the time a string literal is parsed, the tab character will have been replaced with space character(s). This, in turn, means that &#34;escaping&#34; an embedded tab character will actually end up escaping a space character.</p>
<p>Here&#39;s an example where the tab character (denoted by <code><span title="Horizontal Tab (\t)">────</span></code>) will get converted to 6 space characters:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span>
L<span>&#34;\</span><span title="Horizontal Tab (\t)">────</span><span>&#34;</span>
<span>}</span></code></pre>
<p>And here&#39;s what that example looks like after preprocessing (note that the escape sequence now applies to a single space character).</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span>
L<span>&#34;</span><span><span>\</span><span title="Space">·</span></span><span title="Space">·</span><span title="Space">·</span><span title="Space">·</span><span title="Space">·</span><span title="Space">·</span><span>&#34;</span>
<span>}</span></code></pre>
<p>With the quirk around invalid escape sequences in wide string literals, this means that the &#34;escaped space&#34; gets skipped over/ignored when parsing the string, meaning that the compiled data in this case will have 5 space characters instead of 6.</p>
<h4>In combination with codepoints represented by a surrogate pair<a id="in-combination-with-codepoints-represented-by-a-surrogate-pair" href="#in-combination-with-codepoints-represented-by-a-surrogate-pair">🔗</a></h4>
<p>As detailed in <a href="#the-windows-rc-compiler-speaks-utf-16">&#34;<em>The Windows RC compiler &#39;speaks&#39; UTF-16</em>&#34;</a>, the output of the Windows RC preprocessor is always encoded as UTF-16. In UTF-16, codepoints &gt;= <code>U+10000</code> are encoded as a surrogate pair (two <code>u16</code> code units). For example, the codepoint for 𐐷 (<code>U+10437</code>) is encoded in UTF-16 as <code><span title="UTF-16 encoding of 𐐷 (U+10437)">&lt;0xD801&gt;&lt;0xDC37&gt;</span></code>.</p>
<p>So, let&#39;s say we have this <code>.rc</code> file:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
  </span><span>L</span><span>&#34;\𐐷&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>The file is encoded as UTF-8, meaning the 𐐷 is encoded as 4 bytes like so:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
  </span><span>L</span><span>&#34;\<span title="UTF-8 encoding of 𐐷 (U+10437)">&lt;0xF0&gt;&lt;0x90&gt;&lt;0x90&gt;&lt;0xB7&gt;</span>&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>When run through the Windows RC preprocessor, it parses the file successfully and outputs the correct UTF-16 encoding of the 𐐷 codepoint (remember that the Windows RC preprocessor always outputs UTF-16):</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
</span><span>L</span><span>&#34;\𐐷&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>However, the Windows RC <em>parser</em> does not seem to be aware of surrogate pairs, and therefore treats the escape sequence as only pertaining to the first <code>u16</code> surrogate code unit (the &#34;high surrogate&#34;):</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
</span><span>L</span><span>&#34;</span><span><span>\</span><span title="UTF-16 high surrogate encoding of 𐐷 (U+10437)">&lt;0xD801&gt;</span></span><span title="UTF-16 low surrogate encoding of 𐐷 (U+10437)">&lt;0xDC37&gt;</span><span>&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This means that the <code><span>\</span><span title="UTF-16 high surrogate encoding of 𐐷 (U+10437)">&lt;0xD801&gt;</span></code> is treated as an invalid escape sequence and skipped, and only <code><span title="UTF-16 low surrogate encoding of 𐐷 (U+10437)">&lt;0xDC37&gt;</span></code> makes it into the compiled resource data. This will essentially always end up being invalid UTF-16, since an unpaired surrogate code unit is ill-formed (the only way it wouldn&#39;t end up as ill-formed is if an intentionally unpaired high surrogate code unit was included before the escape sequence, e.g. <code>L&#34;\xD801\𐐷&#34;</code>).</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-21" href="#resinator-s-behavior-21">🔗</a></h4>
<p><code>resinator</code> currently attempts to match the Windows RC compiler&#39;s behavior exactly, and <a href="https://github.com/squeek502/resinator/blob/9a6e50b0c0859e0dee5fd1871d93329e0e1194ef/src/literals.zig#L298-L356">emulates the interaction between the preprocessor and wide string escape sequences in its string parser</a>.</p>
<p>The reasoning for emulating the Windows RC compiler for escaped tabs/escaped surrogate pairs seems rather dubious, though, so this may change in the future.</p>
</div>
<div>
<p><span>miscompilation</span></p><h3><code>STRINGTABLE</code> semantics bypass<a id="stringtable-semantics-bypass" href="#stringtable-semantics-bypass">🔗</a></h3>
<p>The <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/stringtable-resource"><code>STRINGTABLE</code> resource</a> is intended for embedding string data, which can then be loaded at runtime with <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadstringw"><code>LoadString</code></a>. A <code>STRINGTABLE</code> resource definition looks something like this:</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span><span>
  </span><span>0</span><span>,</span><span> </span><span>&#34;Hello&#34;</span><span>
  </span><span>1</span><span>,</span><span> </span><span>&#34;Goodbye&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Notice that there is no <code>id</code> before the <code>STRINGTABLE</code> resource type. This is because all strings within <code>STRINGTABLE</code> resources are bundled together in groups of 16 based on their ID and language (we can ignore the language part for now, though). So, if we have this example <code>.rc</code> file:</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span><span>
  </span><span>1</span><span>,</span><span> </span><span>&#34;Goodbye&#34;</span><span>
</span><span>}</span><span>

</span><span>STRINGTABLE</span><span> </span><span>{</span><span>
  </span><span>0</span><span>,</span><span> </span><span>&#34;Hello&#34;</span><span>
  </span><span>23</span><span>,</span><span> </span><span>&#34;Hm&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>The <code>&#34;Hello&#34;</code> and <code>&#34;Goodbye&#34;</code> strings will be grouped together into one resource, and the <code>&#34;Hm&#34;</code> will be put into another. Each group is written as a series of 16 length integers (one for each string within the group), and each length is immediately followed by a UTF-16 encoded string of that length (if the length is non-zero). So, for example, the first group contains the strings with IDs 0-15, meaning, for the <code>.rc</code> file above, the first group would be compiled as:</p>
<pre><code><span title="Length of string ID 0">05 00</span> <span>48 00 65 00 6C 00</span>  <span>..</span><span>H.e.l.</span>
<span>6C 00 6F 00</span> <span title="Length of string ID 1">07 00</span> <span>47 00</span>  <span>l.o.</span><span>..</span><span>G.</span>
<span>6F 00 6F 00 64 00 62 00</span>  <span>o.o.d.b.</span>
<span>79 00 65 00</span> <span><span title="Length of string ID 2">00 00</span> <span title="Length of string ID 3">00 00</span></span>  <span>y.e.</span><span><span>..</span><span>..</span>
<span title="Length of string ID 4">00 00</span> <span title="Length of string ID 5">00 00</span> <span title="Length of string ID 6">00 00</span> <span title="Length of string ID 7">00 00</span>  <span>..</span><span>..</span><span>..</span><span>..</span>
<span title="Length of string ID 8">00 00</span> <span title="Length of string ID 9">00 00</span> <span title="Length of string ID 10">00 00</span> <span title="Length of string ID 11">00 00</span>  <span>..</span><span>..</span><span>..</span><span>..</span>
<span title="Length of string ID 12">00 00</span> <span title="Length of string ID 13">00 00</span> <span title="Length of string ID 14">00 00</span> <span title="Length of string ID 15">00 00</span>  <span>..</span><span>..</span><span>..</span><span>..</span></span>
</code></pre>
<p>Internally, <code>STRINGTABLE</code> resources get compiled as the integer resource type <code>RT_STRING</code>, which is 6. The ID of the resource is based on the grouping, so strings with IDs 0-15 go into a <code>RT_STRING</code> resource with ID 1, 16-31 go into a resource with ID 2, etc.</p>
<p>The above is all well and good, but what happens if you <em>manually</em> define a resource with the <code>RT_STRING</code> type of 6? The Windows RC compiler has no qualms with that at all, and compiles it similarly to a user-defined resource, so the data of the resource below will be 3 bytes long, containing <code>foo</code>:</p>
<pre><code><span>1</span><span> </span><span>6</span><span> </span><span>{</span><span>
  </span><span>&#34;foo&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>In the compiled resource, though, the resource type and ID are indistinguishable from a properly defined <code>STRINGTABLE</code>. This means that compiling the above resource and then trying to use <code>LoadString</code> will <em>succeed</em>, even though the resource&#39;s data does not conform at all to the intended structure of a <code>RT_STRING</code> resource:</p>
<pre><code><span>UINT</span><span> </span><span>string_id</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span>
</span><span>WCHAR</span><span> </span><span>buf</span><span>[</span><span>1024</span><span>];</span><span>
</span><span>int</span><span> </span><span>len</span><span> </span><span>=</span><span> </span><span>LoadStringW</span><span>(</span><span>NULL</span><span>,</span><span> </span><span>string_id</span><span>,</span><span> </span><span>buf</span><span>,</span><span> </span><span>1024</span><span>);</span><span>
</span><span>if</span><span> </span><span>(</span><span>len</span><span> </span><span>!=</span><span> </span><span>0</span><span>)</span><span> </span><span>{</span><span>
    </span><span>printf</span><span>(</span><span>&#34;len: %d\n&#34;</span><span>,</span><span> </span><span>len</span><span>);</span><span>
    </span><span>wprintf</span><span>(</span><span>L</span><span>&#34;%s\n&#34;</span><span>,</span><span> </span><span>buf</span><span>);</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>That code will output:</p>
<pre><code>len: 1023
o
</code></pre>
<p>Let&#39;s think about what&#39;s going on here. We compiled a resource with three bytes of data: <code>foo</code>. We have no real control over what follows that data in the compiled binary, so we can think about how this resource is interpreted by <code>LoadString</code> like this:</p>
<pre><code><span title="Length of string ID 0">66 6F</span> <span>6F ?? ?? ?? ?? ??</span>  <span>fo</span><span>o?????</span>
<span>?? ?? ?? ?? ?? ?? ?? ??</span>  <span>????????</span>
<span><span>          ...          </span>  <span>   ...  </span></span></code></pre>
<p>The first two bytes, <code>66 6F</code>, are treated as a little-endian <code>u16</code> containing the length of the string that follows it. <code>66 6F</code> as a little-endian <code>u16</code> is 28518, so <code>LoadString</code> thinks that the string with ID <code>0</code> is 28 thousand UTF-16 code units long. All of the <code>??</code> bytes are those that happen to follow the resource data—they could in theory be anything. So, <code>LoadString</code> will erroneously attempt to read this gargantuan string into <code>buf</code>, but since we only provided a buffer of 1024, it only fills up to that size and stops.</p>
<p>In the actual compiled binary of my test program, the bytes following <code>foo</code> happen to look like this:</p>
<pre><code><span title="Length of string ID 0">66 6F</span> <span>6F 00 00 00 00 00</span>  <span>fo</span><span>o.....</span>
<span>3C 3F 78 6D 6C 20 76 65</span>  <span>&lt;?xml ve</span>
<span><span>          ...          </span>  <span>   ...  </span></span></code></pre>
<p>This means that the last <code>o</code> in <code>foo</code> happens to be followed by <code>00</code>, and <code>6F 00</code> is interpreted as a UTF-16 <code>o</code> character, and that happens to be followed by <code>00 00</code> which is treated as a <code>NUL</code> terminator by <code>wprintf</code>. This explains the <code>o</code> we got earlier from <code>wprintf(L&#34;%s\n&#34;, buf);</code>. However, if we print the full 1023 <code>wchar</code>&#39;s of the buf like so:</p>
<pre><code><span>for</span><span> </span><span>(</span><span>int</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>len</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span><span>
    </span><span>const</span><span> </span><span>char</span><span>*</span><span> </span><span>bytes</span><span> </span><span>=</span><span> </span><span>&amp;</span><span>buf</span><span>[</span><span>i</span><span>];</span><span>
    </span><span>printf</span><span>(</span><span>&#34;%d: %02X %02X\n&#34;</span><span>,</span><span> </span><span>i</span><span>,</span><span> </span><span>bytes</span><span>[</span><span>0</span><span>],</span><span> </span><span>bytes</span><span>[</span><span>1</span><span>]);</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Then it shows more clearly that <code>LoadString</code> did indeed read past our resource data and started loading bytes from totally unrelated areas of the compiled binary (note that these bytes match the hexdump above):</p>
<pre><code>0: 6F 00
1: 00 00
2: 00 00
3: 3C 3F
4: 78 6D
5: 6C 20
6: 76 65
...
</code></pre>
<p>If we then modify our program to try to load a string with an ID of 1, then the <code>LoadStringW</code> call will crash within <code>RtlLoadString</code> (and it would do the same for any ID from 1-15):</p>
<pre><code>Exception thrown at 0x00007FFA63623C88 (ntdll.dll) in stringtabletest.exe: 0xC0000005: Access violation reading location 0x00007FF7A80A2F6E.

  ntdll.dll!RtlLoadString()
  KernelBase.dll!LoadStringBaseExW()
  user32.dll!LoadStringW()
&gt; stringtabletest.exe!main(...)
</code></pre>
<p>This is because, in order to load a string with ID 1, the bytes of the string with ID 0 need to be skipped past. That is, <code>LoadString</code> will determine that the string with ID 0 has a length of 28 thousand, and then try to skip ahead in the file <em>56 thousand bytes</em> (since the length is in UTF-16 code units), which in our case is well past the end of the file.</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-22" href="#resinator-s-behavior-22">🔗</a></h4>
<pre><code><span>test.rc:1:3:</span><span> error:</span><span> the number 6 (RT_STRING) cannot be used as a resource type
</span><span>1 6 {
</span><span>  ^
</span><span></span><span>test.rc:1:3:</span><span> note:</span><span> using RT_STRING directly likely results in an invalid .res file, use a STRINGTABLE instead
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk, utterly baffling</span></p><h3><code>CONTROL</code>: &#34;I&#39;m just going to pretend I didn&#39;t see that&#34;<a id="control-i-m-just-going-to-pretend-i-didn-t-see-that" href="#control-i-m-just-going-to-pretend-i-didn-t-see-that">🔗</a></h3>
<p>Within <code>DIALOG</code>/<code>DIALOGEX</code> resources, there are predefined controls like <code>PUSHBUTTON</code>, <code>CHECKBOX</code>, etc, which are actually just syntactic sugar for generic <code>CONTROL</code> statements with particular default values for the &#34;class name&#34; and &#34;style&#34; parameters.</p>
<p>For example, these two statements are equivalent:</p>
<pre><code><span><span>class<i></i></span><span><span>CHECKBOX</span></span></span><span>,</span> <span><span>text<i></i></span><span><span>&#34;foo&#34;</span></span></span><span>,</span> <span><span>id<i></i></span><span>1</span></span><span>,</span> <span><span>x<i></i></span><span>2</span></span><span>,</span> <span><span>y<i></i></span><span>3</span></span><span>,</span> <span><span>w<i></i></span><span>4</span></span><span>,</span> <span><span>h<i></i></span><span>5</span></span></code></pre>
<pre><code><span><span>class<i></i></span><span><span>CONTROL</span></span></span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> 1<span>,</span> <span><span>class name<i></i></span><span><span>BUTTON</span></span></span><span>,</span> <span><span>style<i></i></span><span><span>BS_CHECKBOX</span> <span>|</span> <span>WS_TABSTOP</span></span></span><span>,</span> 2<span>,</span> 3<span>,</span> 4<span>,</span> 5</code></pre>
<p>There is something bizarre about the &#34;style&#34; parameter of a generic control statement, though. For whatever reason, it allows an extra token within it and will act as if it doesn&#39;t exist.</p>
<pre><code><span>CONTROL, &#34;text&#34;, 1, BUTTON,</span> <span><span>BS_CHECKBOX</span> <span>|</span> <span>WS_TABSTOP</span> <span>&#34;why is this allowed&#34;</span><span>style<i></i></span></span><span>, 2, 3, 4, 5</span></code></pre>
<p>The <code>&#34;why is this allowed&#34;</code> string is completely ignored, and this <code>CONTROL</code> will be compiled exactly the same as the previous <code>CONTROL</code> statement shown above.</p>

<p>The extra token can be many things (string, number, <code>=</code>, etc), but not <em>anything</em>. For example, if the extra token is <code>;</code>, then it will error with <code>expected numerical dialog constant</code>.</p>
<h4><code>CONTROL</code>: &#34;Okay, I see that expression, but I don&#39;t understand it&#34;<a id="control-okay-i-see-that-expression-but-i-don-t-understand-it" href="#control-okay-i-see-that-expression-but-i-don-t-understand-it">🔗</a></h4>
<p>Instead of a single extra token in the <code>style</code> parameter of a <code>CONTROL</code>, it&#39;s also possible to sneak an extra number expression in there like so:</p>
<pre><code><span>CONTROL, &#34;text&#34;, 1, BUTTON,</span> <span><span>BS_CHECKBOX</span> <span>|</span> <span>WS_TABSTOP</span> <span>(</span>7<span>+</span>8<span>)</span><span>style<i></i></span></span><span>, 2, 3, 4, 5</span></code></pre>
<p>In this case, the Windows RC compiler no longer ignores the expression, but still behaves strangely. Instead of the entire <code>(7+8)</code> expression being treated as the <code>x</code> parameter like one might expect, in this case <em>only the</em> <code>8</code> in the expression is treated as the <code>x</code> parameter, so it ends up interpreted like this:</p>
<pre><code><span>CONTROL, &#34;text&#34;, 1, BUTTON,</span> <span><span>style<i></i></span><span><span>BS_CHECKBOX</span> <span>|</span> <span>WS_TABSTOP</span></span></span> <span>(7+</span><span><span>x<i></i></span><span>8</span></span><span>)</span><span>,</span> <span><span>y<i></i></span><span>2</span></span><span>,</span> <span><span>w<i></i></span><span>3</span></span><span>,</span> <span><span>h<i></i></span><span>4</span></span><span>,</span> <span><span>exstyle<i></i></span><span>5</span></span></code></pre>
<p>My guess is that the similarity between this number-expression-related-behavior and <a href="#number-expressions-as-filenames">&#34;<em>Number expressions as filenames</em>&#34;</a> is not a coincidence, but beyond that I couldn&#39;t tell you what&#39;s going on here.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-23" href="#resinator-s-behavior-23">🔗</a></h4>
<p>Such extra tokens/expressions are never ignored by <code>resinator</code>; they are always treated as the <code>x</code> parameter, and a warning is emitted if there is no comma between the <code>style</code> and <code>x</code> parameters.</p>
<pre><code><span>test.rc:4:57:</span><span> warning:</span><span> this token could be erroneously skipped over by the Win32 RC compiler
</span><span>  CONTROL, &#34;text&#34;, 1, BUTTON, 0x00000002L | 0x00010000L &#34;why is this allowed&#34;, 2, 3, 4, 5
</span><span>                                                        ^~~~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:4:57:</span><span> note:</span><span> this line originated from line 4 of file &#39;test.rc&#39;
</span><span>  CONTROL, &#34;text&#34;, 1, BUTTON, BS_CHECKBOX | WS_TABSTOP &#34;why is this allowed&#34;, 2, 3, 4, 5

</span><span>test.rc:4:31:</span><span> note:</span><span> to avoid the potential miscompilation, consider adding a comma after the style parameter
</span><span>  CONTROL, &#34;text&#34;, 1, BUTTON, 0x00000002L | 0x00010000L &#34;why is this allowed&#34;, 2, 3, 4, 5
</span><span>                              ^~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:4:57:</span><span> error:</span><span> expected number or number expression; got &#39;&#34;why is this allowed&#34;&#39;
</span><span>  CONTROL, &#34;text&#34;, 1, BUTTON, 0x00000002L | 0x00010000L &#34;why is this allowed&#34;, 2, 3, 4, 5
</span><span>                                                        ^~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation</span></p><h3>That&#39;s odd, I thought you needed more padding<a id="that-s-odd-i-thought-you-needed-more-padding" href="#that-s-odd-i-thought-you-needed-more-padding">🔗</a></h3>
<p>In <code>DIALOGEX</code> resources, a control statement is documented to have the following syntax:</p>
<blockquote>
<pre><code>control [[text,]] id, x, y, width, height[[, style[[, extended-style]]]][, helpId]
[{ data-element-1 [, data-element-2 [,  . . . ]]}]
</code></pre>
</blockquote>
<p>For now, we can ignore everything except the <code>[{ data-element-1 [, data-element-2 [,  . . . ]]}]</code> part, which is documented like so:</p>
<blockquote>
<p><em>controlData</em></p>
<p>Control-specific data for the control. When a dialog is created, and a control in that dialog which has control-specific data is created, a pointer to that data is passed into the control&#39;s window procedure through the lParam of the WM_CREATE message for that control.</p>
</blockquote>
<p>Here&#39;s an example, where the string <code>&#34;foo&#34;</code> is the control data:</p>
<pre><code><span>1 DIALOGEX 0, 0, 282, 239 {</span>
  PUSHBUTTON <span>&#34;Cancel&#34;,1,129,212,50,14</span> <span>{</span> <span>&#34;foo&#34;</span> <span>}</span>
<span>}</span></code>
</pre>
<p>After a very long time of having no idea how to retrieve this data from a Win32 program, I finally figured it out while writing this article. As far as I know, the <code>WM_CREATE</code> event can only be received for custom controls or by <a href="https://learn.microsoft.com/en-us/windows/win32/winmsg/about-window-procedures#winproc_superclassing">superclassing</a> a predefined control.</p>

<p>So, let&#39;s say in our program we register a class named <code>CustomControl</code>. We can then use it in a <code>DIALOGEX</code> resource like this:</p>
<pre><code><span>1 DIALOGEX 0, 0, 282, 239 {</span>
  <span>CONTROL</span> <span>&#34;text&#34;, 901,</span> <span>&#34;CustomControl&#34;</span><span>, 0, 129,212,50,14</span> <span>{</span> <span>&#34;foo&#34;</span> <span>}</span>
<span>}</span></code>
</pre>
<p>The control data (<code>&#34;foo&#34;</code>) will get compiled as <code><span>03 00</span></code> <code><span>66 6F 6F</span></code>, where <code><span>03 00</span></code> is the length of the control data in bytes (3 as a little-endian <code>u16</code>) and <code><span>66 6F 6F</span></code> are the bytes of <code>foo</code>.</p>
<p>If we load this dialog, then our custom control&#39;s <code>WNDPROC</code> callback will receive a <code>WM_CREATE</code> event where the <code>LPARAM</code> parameter is a pointer to a <code>CREATESTRUCT</code> and <code>((CREATESTRUCT*)lParam)-&gt;lpCreateParams</code> will be a pointer to the control data (if any exists). So, in our case, the <code>lpCreateParams</code> pointer points to memory that looks the same as the bytes shown above: a <code>u16</code> length first, and the specified number of bytes following it. If we handle the event like this:</p>
<pre><code><span>
    </span><span>case</span><span> </span><span>WM_CREATE</span><span>:</span><span>
      </span><span>if</span><span> </span><span>(</span><span>lParam</span><span>)</span><span> </span><span>{</span><span>
        </span><span>CREATESTRUCT</span><span>*</span><span> </span><span>create_params</span><span> </span><span>=</span><span> </span><span>(</span><span>CREATESTRUCT</span><span>*</span><span>)</span><span>lParam</span><span>;</span><span>
        </span><span>const</span><span> </span><span>BYTE</span><span>*</span><span> </span><span>data</span><span> </span><span>=</span><span> </span><span>create_params</span><span>-&gt;</span><span>lpCreateParams</span><span>;</span><span>
        </span><span>if</span><span> </span><span>(</span><span>data</span><span>)</span><span> </span><span>{</span><span>
          </span><span>WORD</span><span> </span><span>len</span><span> </span><span>=</span><span> </span><span>*</span><span>((</span><span>WORD</span><span>*</span><span>)</span><span>data</span><span>);</span><span>
          </span><span>printf</span><span>(</span><span>&#34;control data len: %d\n&#34;</span><span>,</span><span> </span><span>len</span><span>);</span><span>
          </span><span>for</span><span> </span><span>(</span><span>WORD</span><span> </span><span>i</span><span> </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>i</span><span> </span><span>&lt;</span><span> </span><span>len</span><span>;</span><span> </span><span>i</span><span>++</span><span>)</span><span> </span><span>{</span><span>
              </span><span>printf</span><span>(</span><span>&#34;%02X &#34;</span><span>,</span><span> </span><span>data</span><span>[</span><span>2</span><span> </span><span>+</span><span> </span><span>i</span><span>]);</span><span>
          </span><span>}</span><span>
          </span><span>printf</span><span>(</span><span>&#34;\n&#34;</span><span>);</span><span>
        </span><span>}</span><span>
      </span><span>}</span><span>
      </span><span>break</span><span>;</span><span>
</span><span>
</span></code></pre>
<p>then we get this output (with some additional printing of the callback parameters):</p>
<pre><code>CustomProc hwnd: 00000000022C0A8A msg: WM_CREATE wParam: 0000000000000000 lParam: 000000D7624FE730
control data len: 3
66 6F 6F
</code></pre>
<p>Nice! Now let&#39;s try to add a second <code>CONTROL</code>:</p>
<pre><code><span>1 DIALOGEX 0, 0, 282, 239 {</span>
  <span>CONTROL</span> <span>&#34;text&#34;, 901,</span> <span>&#34;CustomControl&#34;</span><span>, 0, 129,212,50,14</span> <span>{</span> <span>&#34;foo&#34;</span> <span>}</span>
  <span>CONTROL</span> <span>&#34;text&#34;, 902,</span> <span>&#34;CustomControl&#34;</span><span>, 0, 189,212,50,14</span> <span>{</span> <span>&#34;bar&#34;</span> <span>}</span>
<span>}</span></code>
</pre>
<p>With this, the <code>CreateDialogParamW</code> call starts failing with:</p>
<pre><code>Cannot find window class.
</code></pre>
<p>Why would that be? Well, it turns out that the Windows RC compiler miscompiles the padding bytes following a control if its control data has an odd number of bytes. This is similar to what&#39;s described in <a href="#your-fate-will-be-determined-by-a-comma">&#34;<em>Your fate will be determined by a comma</em>&#34;</a>, but in the opposite direction: instead of adding too few padding bytes, the Windows RC compiler in this case will add <em>too many</em>.</p>
<p>Each control within a dialog resource is expected to be 4-byte aligned (meaning its memory starts at an offset that is a multiple of 4). So, if the bytes at the end of one control looks like this, where the dotted boxes represent 4-byte boundaries:</p>
<pre>  <code><span><span>....</span></span><span><span>....</span></span><span><span>foo</span> </span><span>    </span><span>    </span></code>
</pre>
<p>then we only need one byte of padding after <code>foo</code> to ensure the next control is 4-byte aligned:</p>
<pre>  <code><span><span>....</span></span><span><span>....</span></span><span><span>foo</span><span>.</span></span><span><span>....</span></span><span><span>....</span></span></code>
</pre>
<p>However, the Windows RC compiler erroneously inserts two additional padding bytes in this case, meaning the control afterwards is misaligned by two bytes:</p>
<pre>  <code><span><span>....</span></span><span><span>....</span></span><span><span>foo</span><span>.</span></span><span><span>..</span><span>..</span></span><span><span>....</span></span></code>
</pre>
<p>This causes every field of the misaligned control to be misread, leading to a malformed dialog that can&#39;t be loaded. As mentioned, this is only the case with odd control data byte counts; if we add or remove a byte from the control data, then this miscompilation does not happen and the correct amount of padding is written. Here&#39;s what it looks like if <code>&#34;foo&#34;</code> is changed to <code>&#34;fo&#34;</code>:</p>
<pre>  <code><span><span>....</span></span><span><span>....</span></span><span><span>fo</span><span>..</span></span><span><span>....</span></span><span><span>....</span></span></code>
</pre>

<p>This is a miscompilation that seems very easy to accidentally hit, but it has gone undetected/unfixed for so long presumably because this &#39;control data&#39; syntax is <em>very</em> seldom used. For example, there&#39;s not a single usage of this feature anywhere within <a href="https://github.com/microsoft/Windows-classic-samples">Windows-classic-samples</a>.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-24" href="#resinator-s-behavior-24">🔗</a></h4>
<p><code>resinator</code> will avoid the miscompilation and will emit a warning when it detects that the Windows RC compiler would miscompile:</p>
<pre><code><span>test.rc:3:3:</span><span> warning:</span><span> the padding before this control would be miscompiled by the Win32 RC compiler (it would insert 2 extra bytes of padding)
</span><span>  CONTROL &#34;text&#34;, 902, &#34;CustomControl&#34;, 1, 189,212,50,14,2,3 { &#34;bar&#34; }
</span><span>  ^~~~~~~
</span><span></span><span>test.rc:3:3:</span><span> note:</span><span> to avoid the potential miscompilation, consider adding one more byte to the control data of the control preceding this one
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation, utterly baffling</span></p><h3><code>CONTROL</code> class specified as a number<a id="control-class-specified-as-a-number" href="#control-class-specified-as-a-number">🔗</a></h3>
<p>A generic <code>CONTROL</code> within a <code>DIALOG</code>/<code>DIALOGEX</code> resource is specified like this:</p>
<pre><code><span><span>class<i></i></span><span><span>CONTROL</span></span></span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> 1<span>,</span> <span><span>class name<i></i></span><span><span>BUTTON</span></span></span><span>,</span> <span>1</span><span>,</span> 2<span>,</span> 3<span>,</span> 4<span>,</span> 5</code></pre>
<p>The <code>class name</code> can be a string literal (<code>&#34;CustomControlClass&#34;</code>) or one of <code>BUTTON</code>, <code>EDIT</code>, <code>STATIC</code>, <code>LISTBOX</code>, <code>SCROLLBAR</code>, or <code>COMBOBOX</code>. Internally, those unquoted literals are just predefined values that compile down to numeric integers:</p>
<pre><code>BUTTON    ──► 0x80
EDIT      ──► 0x81
STATIC    ──► 0x82
LISTBOX   ──► 0x83
SCROLLBAR ──► 0x84
COMBOBOX  ──► 0x85
</code></pre>
<p>There&#39;s plenty of precedence within the Windows RC compiler that you can swap out a predefined type for its underlying integer and get the same result, and indeed the Windows RC compiler does not complain if you try to do so in this case:</p>
<pre><code><span>CONTROL</span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> 1<span>,</span> <span><span>class name<i></i></span><span><span>0x80</span></span></span><span>,</span> <span>1</span><span>,</span> 2<span>,</span> 3<span>,</span> 4<span>,</span> 5</code></pre>
<p>Before we look at what happens, though, we need to understand how values that can be either a string or a number get compiled. For such values, if it is a string, it is always compiled as <code>NUL</code>-terminated UTF-16:</p>
<pre><code>66 00 6F 00 6F 00 00 00  f.o.o...
</code></pre>
<p>If such a value is a number, then it&#39;s compiled as a pair of <code>u16</code> values: <code>0xFFFF</code> and then the actual number value following that, where the <code>0xFFFF</code> acts as a indicator that the ambiguous string/number value is a number. So, if the number is <code>0x80</code>, it would get compiled into:</p>
<pre><code>FF FF 80 00  ....
</code></pre>
<p>The above (<code>FF FF 80 00</code>) is what <code>BUTTON</code> gets compiled into, since <code>BUTTON</code> gets translated to the integer <code>0x80</code> under-the-hood. However, getting back to this example:</p>
<pre><code><span>CONTROL</span><span>,</span> <span>&#34;foo&#34;</span><span>,</span> 1<span>,</span> <span><span>class name<i></i></span><span><span>0x80</span></span></span><span>,</span> <span>1</span><span>,</span> 2<span>,</span> 3<span>,</span> 4<span>,</span> 5</code></pre>
<p>We should expect the <code>0x80</code> also gets compiled into <code>FF FF 80 00</code>, but instead the Windows RC compiler compiles it into:</p>
<pre><code>80 FF 00 00
</code></pre>
<p>As far as I can tell, the behavior here is to:</p>
<ul>
<li>Truncate the value to a <code>u8</code></li>
<li>If the truncated value is &gt;= <code>0x80</code>, add <code>0xFF00</code> and write the result as a little-endian <code>u32</code></li>
<li>If the truncated value is &lt; <code>0x80</code> but not zero, write the value as a little-endian <code>u32</code></li>
<li>If the truncated value is zero, write zero as a <code>u16</code></li>
</ul>
<p>Some examples:</p>
<pre><code> 0x00 ──► 00 00
 0x01 ──► 01 00 00 00
 0x7F ──► 7F 00 00 00
 0x80 ──► 80 FF 00 00
 0xFF ──► FF FF 00 00
0x100 ──► 00 00
0x101 ──► 01 00 00 00
0x17F ──► 7F 00 00 00
0x180 ──► 80 FF 00 00
0x1FF ──► FF FF 00 00
      etc
</code></pre>
<p>I only have the faintest idea of what could be going on here. My guess is that this is some sort of half-baked leftover behavior from the 16-bit resource compiler that never got properly updated in the move to the 32-bit compiler, since in the 16-bit version of <code>rc.exe</code>, numbers were compiled as <code>FF &lt;number as u8&gt;</code> instead of <code>FF FF &lt;number as u16&gt;</code>. However, the results we see don&#39;t fully match what we&#39;d expect if that were the case—instead of <code>FF 80</code>, we get <code>80 FF</code>, so I don&#39;t think this explanation holds up.</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-25" href="#resinator-s-behavior-25">🔗</a></h4>
<p><code>resinator</code> will avoid the miscompilation and will emit a warning:</p>
<pre><code><span>test.rc:2:22:</span><span> warning:</span><span> the control class of this CONTROL would be miscompiled by the Win32 RC compiler
</span><span>  CONTROL, &#34;foo&#34;, 1, 0x80, 1, 2, 3, 4, 5
</span><span>                     ^~~~
</span><span></span><span>test.rc:2:22:</span><span> note:</span><span> to avoid the potential miscompilation, consider specifying the control class using a string (BUTTON, EDIT, etc) instead of a number
</span><span></span></code></pre>
</div>
<div>
<p><span>compiler bug/quirk</span></p><h3><code>CONTROL</code> class specified as a string literal<a id="control-class-specified-as-a-string-literal" href="#control-class-specified-as-a-string-literal">🔗</a></h3>
<p>I said in <a href="#control-class-specified-as-a-number">&#34;<em><code>CONTROL</code> class specified as a number</em>&#34;</a> that <code>class name</code> can be specified as a particular set of unquoted identifiers (<code>BUTTON</code>, <code>EDIT</code>, <code>STATIC</code>, etc). I left out that it&#39;s also possible to specify them as quoted string literals—these are equivalent to the unquoted <code>BUTTON</code> class name:</p>
<pre><code><span>CONTROL, &#34;foo&#34;, 1, </span><span>&#34;BUTTON&#34;</span><span>, 1, 2, 3, 4, 5</span>
<span>CONTROL, &#34;foo&#34;, 1, </span>L<span>&#34;BUTTON&#34;</span><span>, 1, 2, 3, 4, 5</span></code></pre>
<p>Additionally, this equivalence is determined <em>after</em> parsing, so <em>these</em> are also equivalent, since <code>\x42</code> parses to the ASCII character <code>B</code>:</p>
<pre><code><span>CONTROL, &#34;foo&#34;, 1, </span><span>&#34;\x42UTTON&#34;</span><span>, 1, 2, 3, 4, 5</span>
<span>CONTROL, &#34;foo&#34;, 1, </span>L<span>&#34;\x42UTTON&#34;</span><span>, 1, 2, 3, 4, 5</span></code></pre>
<p>All of the above examples get treated the same as the unquoted literal <code>BUTTON</code>, which gets compiled to <code>FF FF 80 00</code> as mentioned in the previous section.</p>
<h4>A string masquerading as a number<a id="a-string-masquerading-as-a-number" href="#a-string-masquerading-as-a-number">🔗</a></h4>
<p>For class name strings that do not parse into one of the predefined classes (<code>BUTTON</code>, <code>EDIT</code>, <code>STATIC</code>, etc), the class name typically gets written as <code>NUL</code>-terminated UTF-16. For example:</p>
<div>


<div>
<div>
<pre><code>61 00 62 00 63 00 00 00   a.b.c...
</code></pre>
</div>
</div>
</div>
<p>However, if you use an <code>L</code> prefixed string that starts with a <code>\xFFFF</code> escape, then the value is written as if it were a number (i.e. the value is always 32-bits long and has the format <code>FF FF &lt;number as u16&gt;</code>). Here&#39;s an example:</p>

<p>All but the first <code>z</code> drop out, as seemingly the first character value after the <code>\xFFFF</code> escape is written as a <code>u16</code>. Here&#39;s another example using a 4-digit hex escape after the <code>\xFFFF</code>:</p>


<p>So, with this bug/quirk, this:</p>

<p>which is <em>indistinguisable</em> from the compiled form of the class name specified as either an unquoted literal (<code>BUTTON</code>) or quoted string (<code>&#34;BUTTON&#34;</code>). I want to say that this edge case is so specific that it has to have been intentional, but I&#39;m not sure I can rule out the idea that some very strange confluence of quirks is coming together to produce this behavior unintentionally.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-26" href="#resinator-s-behavior-26">🔗</a></h4>
<p><code>resinator</code> matches the behavior of the Windows RC compiler for the <code>&#34;BUTTON&#34;</code>/<code>&#34;\x42UTTON&#34;</code> examples, but the <code>L&#34;\xFFFF...&#34;</code> edge case <a href="https://github.com/squeek502/resinator/issues/13">has not yet been decided on</a> as of now.</p>
</div>
<div>
<p><span>missing error, miscompilation</span></p><h3>Cursor posing as an icon and vice versa<a id="cursor-posing-as-an-icon-and-vice-versa" href="#cursor-posing-as-an-icon-and-vice-versa">🔗</a></h3>
<p>The <code>ICON</code> and <code>CURSOR</code> resource types expect a <code>.ico</code> file and a <code>.cur</code> file, respectively. The format of <code>.ico</code> and <code>.cur</code> is identical, but there is an &#39;image type&#39; field that denotes the type of the file (<code>1</code> for icon, <code>2</code> for cursor).</p>
<p>The Windows RC compiler does not discriminate on what type is used for which resource. If we have <code>foo.ico</code> with the &#39;icon&#39; type, and <code>foo.cur</code> with the &#39;cursor&#39; type, then the Windows RC compiler will happily accept all of the following resources:</p>
<pre><code><span>1</span><span> </span><span>ICON</span><span> </span><span>&#34;foo.ico&#34;</span><span>
</span><span>2</span><span> </span><span>ICON</span><span> </span><span>&#34;foo.cur&#34;</span><span>
</span><span>3</span><span> </span><span>CURSOR</span><span> </span><span>&#34;foo.ico&#34;</span><span>
</span><span>4</span><span> </span><span>CURSOR</span><span> </span><span>&#34;foo.cur&#34;</span><span>
</span></code></pre>
<p>However, the resources with the mismatched types becomes a problem in the resulting <code>.res</code> file because <code>ICON</code> and <code>CURSOR</code> have different formats for their resource data. When the type is &#39;cursor&#39;, a <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/localheader">LOCALHEADER</a> consisting of two cursor-specific <code>u16</code> fields is written at the start of the resource data. This means that:</p>
<ul>
<li>An <code>ICON</code> resource with a <code>.cur</code> file will write those extra cursor-specific fields, but still &#39;advertise&#39; itself as an <code>ICON</code> resource</li>
<li>A <code>CURSOR</code> resource with an <code>.ico</code> file will <em>not</em> write those cursor-specific fields, but still &#39;advertise&#39; itself as a <code>CURSOR</code> resource</li>
<li>In both of these cases, attempting to load the resource will always end up with an incorrect/invalid result because the parser will be assuming that those fields exist/don&#39;t exist based on the resource type</li>
</ul>
<p>So, such a mismatch <em>always</em> leads to incorrect/invalid resources in the <code>.res</code> file.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-27" href="#resinator-s-behavior-27">🔗</a></h4>
<p><code>resinator</code> errors if the resource type (<code>ICON</code>/<code>CURSOR</code>) doesn&#39;t match the type specified in the <code>.ico</code>/<code>.cur</code> file:</p>
<pre><code><span>test.rc:1:10:</span><span> error:</span><span> resource type &#39;cursor&#39; does not match type &#39;icon&#39; specified in the file
</span><span>1 CURSOR &#34;foo.ico&#34;
</span><span>         ^~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>unnecessary limitation</span></p><h3>PNG encoded cursors are erroneously rejected<a id="png-encoded-cursors-are-erroneously-rejected" href="#png-encoded-cursors-are-erroneously-rejected">🔗</a></h3>
<p><code>.ico</code>/<code>.cur</code> files are a &#39;directory&#39; of multiple icons/cursors, used for different resolutions. Historically, each image was a <a href="https://learn.microsoft.com/en-us/windows/win32/gdi/device-independent-bitmaps">device-independent bitmap (DIB)</a>, but nowadays they can also be encoded as PNG.</p>
<p>The Windows RC compiler is fine with <code>.ico</code> files that have PNG encoded images, but for whatever reason rejects <code>.cur</code> files with PNG encoded images.</p>
<pre><code><span>
</span><span>1</span><span> </span><span>ICON</span><span> </span><span>&#34;png.ico&#34;</span><span>
</span><span>
</span><span>2</span><span> </span><span>CURSOR</span><span> </span><span>&#34;png.cur&#34;</span><span>
</span></code></pre>
<p>This limitation is provably artificial, though. If a <code>.res</code> file contains a <code>CURSOR</code> resource with PNG encoded image(s), then <a href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursorw"><code>LoadCursor</code></a> works correctly and the cursor displays correctly.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-28" href="#resinator-s-behavior-28">🔗</a></h4>
<p><code>resinator</code> allows PNG encoded cursor images, and warns about the Windows RC compiler behavior:</p>
<pre><code><span>test.rc:2:10:</span><span> warning:</span><span> the resource at index 0 of this cursor has the format &#39;png&#39;; this would be an error in the Win32 RC compiler
</span><span>2 CURSOR png.cur
</span><span>         ^~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation, utterly baffling</span></p><h3>Adversarial icons/cursors can lead to arbitrarily large <code>.res</code> files<a id="adversarial-icons-cursors-can-lead-to-arbitrarily-large-res-files" href="#adversarial-icons-cursors-can-lead-to-arbitrarily-large-res-files">🔗</a></h3>
<p>Each image in a <code>.ico</code>/<code>.cur</code> file has a corresponding header entry which contains (a)
the size of the image in bytes, and (b) the offset of the image&#39;s data within the file. The Windows RC file fully trusts that this information is accurate; it will never error regardless of how malformed these two pieces of information are.</p>
<p>If the reported size of an image is larger than the size of the <code>.ico</code>/<code>.cur</code> file itself, the Windows RC compiler will:</p>
<ul>
<li>Write however many bytes there are before the end of the file</li>
<li>Write zeroes for any bytes that are past the end of the file, except</li>
<li>Once it has written 0x4000 bytes total, it will repeat these steps again and again until it reaches the full reported size</li>
</ul>
<p>Because a <code>.ico</code>/<code>.cur</code> can contain up to 65535 images, and each image within can report its size as up to 2 GiB (more on this in the next bug/quirk), this means that a small (&lt; 1 MiB) maliciously constructed <code>.ico</code>/<code>.cur</code> could cause the Windows RC compiler to attempt to write up to 127 TiB of data to the <code>.res</code> file.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-29" href="#resinator-s-behavior-29">🔗</a></h4>
<p><code>resinator</code> errors if the reported file size of an image is larger than the size of the <code>.ico</code>/<code>.cur</code> file:</p>
<pre><code><span>test.rc:1:8:</span><span> error:</span><span> unable to read icon file &#39;test.ico&#39;: ImpossibleDataSize
</span><span>1 ICON test.ico
</span><span>       ^~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation, utterly baffling</span></p><h3>Adversarial icons/cursors can lead to <em><strong>infinitely large</strong></em> <code>.res</code> files<a id="adversarial-icons-cursors-can-lead-to-infinitely-large-res-files" href="#adversarial-icons-cursors-can-lead-to-infinitely-large-res-files">🔗</a></h3>
<p>As mentioned in <a href="#adversarial-icons-cursors-can-lead-to-arbitrarily-large-res-files"><em>Adversarial icons/cursors can lead to arbitrarily large <code>.res</code> files</em></a>, each image within an icon/cursor can report its size as up to 2 GiB. However, the field for the image size is actually 4 bytes wide, meaning the maximum should technically be 4 GiB.</p>
<p>The 2 GiB limit comes from the fact that the Windows RC compiler actually interprets this field as a <em>signed</em> integer, so if you try to define an image with a size larger than 2 GiB, it&#39;ll get interpreted as negative. We can somewhat confirm this by compiling with the verbose flag (<code>/v</code>):</p>
<pre><code>Writing ICON:1, lang:0x409, size -6000000
</code></pre>
<p>When this happens, the Windows RC compiler seemingly enters into an infinite loop when writing the icon data to the <code>.res</code> file, meaning it will continue trying to write garbage until (presumably) all the space of the hard drive has been used up.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-30" href="#resinator-s-behavior-30">🔗</a></h4>
<p><code>resinator</code> avoids misinterpreting the image size as signed, and allows images of up to 4 GiB to be specified if the <code>.ico</code>/<code>.cur</code> file actually is large enough to contain them.</p>
</div>
<div>
<div>
<p><span>miscompilation</span></p><h3>Icon/cursor images with impossibly small sizes lead to bogus <code>.res</code> files<a id="icon-cursor-images-with-impossibly-small-sizes-lead-to-bogus-res-files" href="#icon-cursor-images-with-impossibly-small-sizes-lead-to-bogus-res-files">🔗</a></h3>
<p>Similar to <a href="#adversarial-icons-cursors-can-lead-to-arbitrarily-large-res-files"><em>Adversarial icons/cursors can lead to arbitrarily large <code>.res</code> files</em></a>, it&#39;s also possible for images to specify their size as impossibly small:</p>
<ul>
<li>If the size of an image is reported as zero, then the Windows RC compiler will:
<ul>
<li>Write an arbitrary size for the resource&#39;s data</li>
<li>Not actually write any bytes to the data section of the resource</li>
</ul>
</li>
<li>If the size of an image is smaller than the header of the image format, then the Windows RC compiler will:
<ul>
<li>Read the full header for the image, even if it goes past the reported end of the image data</li>
<li>Write the reported number of bytes to the <code>.res</code> file, which can never be a valid image since it is smaller than the header size of the image format</li>
</ul>
</li>
</ul>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-31" href="#resinator-s-behavior-31">🔗</a></h4>
<p><code>resinator</code> errors if the reported size of an image within a <code>.ico</code>/<code>.cur</code> is too small to contain a valid image header:</p>
<pre><code><span>test.rc:1:8:</span><span> error:</span><span> unable to read icon file &#39;test.ico&#39;: ImpossibleDataSize
</span><span>1 ICON test.ico
</span><span>       ^~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation</span></p><h3>Bitmaps with missing bytes in their color table<a id="bitmaps-with-missing-bytes-in-their-color-table" href="#bitmaps-with-missing-bytes-in-their-color-table">🔗</a></h3>
<p><code>BITMAP</code> resources expect <code>.bmp</code> files, which are roughly structured something like this:</p>
<div>
  <pre>    <code><span>..BITMAPFILEHEADER..</span>
<span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<span>....color table.....</span>
<span>....................</span>
<span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
<p>The color table has a variable number of entries, dictated by either the <code>biClrUsed</code> field of the <code>BITMAPINFOHEADER</code>, or, if <code>biClrUsed</code> is zero, 2<sup>n</sup> where <code>n</code> is the number of bits per pixel (<code>biBitCount</code>). When the number of bits per pixel is 8 or fewer, this color table is used as a color palette for the pixels in the image:</p>
<div>
  
  <div>
    <p>color index</p>
    <p>color rgb</p>
    <p>color</p>
  </div>
</div>
<p><i>Example color table (above) and some pixel data that references the color table (below)</i></p>

<p>This is relevant because the Windows resource compiler does not just write the bitmap data to the <code>.res</code> verbatim. Instead, it strips the <code>BITMAPFILEHEADER</code> and will always write the expected number of color table bytes, even if the number of color table bytes in the file doesn&#39;t match expectations.</p>
<div>
<div>
  <pre>    <code><span>..BITMAPFILEHEADER..</span>
<span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
<div>
  <pre>    <code><span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<span>....color table.....</span>
<span>....................</span>
<span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
</div>
<p><i>A bitmap file that omits the color table even though a color table is expected, and the data written to the <code>.res</code> for that bitmap</i></p>
<p>Typically, a bitmap with a shorter-than-expected color table is considered invalid (or, at least, Windows and Firefox fail to render them), but the Windows RC compiler does not error on such files. Instead, it will completely ignore the bounds of the color table and just read into the following pixel data if necessary, treating it as color data.</p>
<div>
<div>
  <pre>    <code><span>..BITMAPFILEHEADER..</span>
<span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<p><span>....pixel data......</span>
<span>....................</span></p><span>....................</span></code>
  </pre>
</div>
<div>
  <pre>    <code><span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<p><span>...&#34;color table&#34;....</span>
<span>....................</span></p><span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
</div>
<p><i>When compiled with the Windows RC compiler, the bytes of the color table in the <code>.res</code> will consist of the bytes in the outlined region of the pixel data in the original bitmap file.</i></p>
<p>Further, if it runs out of pixel data to read (i.e. the inferred size of the color table extends beyond the end of the file), it will start filling in the remaining missing color table bytes with zeroes.</p>

<h4>From invalid to valid<a id="from-invalid-to-valid" href="#from-invalid-to-valid">🔗</a></h4>
<p>Interestingly, the behavior with regards to smaller-than-expected color tables means that an invalid bitmap compiled as a resource can end up becoming a valid bitmap. For example, if you have a bitmap with 12 actual entries in the color table, but <code>BITMAPFILEHEADER.biClrUsed</code> says there are 13, Windows considers that an invalid bitmap and won&#39;t render it. If you take that bitmap and compile it as a resource, though:</p>
<pre><code><span>1</span><span> </span><span>BITMAP</span><span> </span><span>&#34;invalid.bmp&#34;</span><span>
</span></code></pre>
<p>The resulting <code>.res</code> will pad the color table of the bitmap to get up to the expected number of entries (13 in this case), and therefore the resulting resource will render fine when using <code>LoadBitmap</code> to load it.</p>
<h4>Maliciously constructed bitmaps<a id="maliciously-constructed-bitmaps" href="#maliciously-constructed-bitmaps">🔗</a></h4>
<p>The dark side of this bug/quirk is that the Windows RC compiler does not have any limit as to how many missing color palette bytes it allows, and this is even the case when there are possible hard limits available (e.g. a bitmap with 4-bits-per-pixel can only have 2<sup>4</sup> (16) colors, but the Windows RC compiler doesn&#39;t mind if a bitmap says it has more than that).</p>
<p>The <code>biClrUsed</code> field (which contains the number of color table entries) is a <code>u32</code>, meaning a bitmap can specify it contains up to 4.29 billion entries in its color table, where each color entry is 4 bytes long (or 3 bytes for old Windows 2.0 bitmaps). This means that a maliciously constructed bitmap can induce the Windows RC compiler to write up to 16 GiB of color table data when writing its resource, even if the file itself doesn&#39;t contain <em>any</em> color table at all.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-32" href="#resinator-s-behavior-32">🔗</a></h4>
<p><code>resinator</code> errors if there are any missing palette bytes:</p>
<pre><code><span>test.rc:1:10:</span><span> error:</span><span> bitmap has 16 missing color palette bytes
</span><span>1 BITMAP missing_palette_bytes.bmp
</span><span>         ^~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:1:10:</span><span> note:</span><span> the Win32 RC compiler would erroneously pad out the missing bytes (and the added padding bytes would include 6 bytes of the pixel data)
</span><span></span></code></pre>
<p>For a maliciously constructed bitmap, that error might look like:</p>
<pre><code><span>test.rc:1:10:</span><span> error:</span><span> bitmap has 17179869180 missing color palette bytes
</span><span>1 BITMAP trust_me.bmp
</span><span>         ^~~~~~~~~~~~
</span><span></span><span>test.rc:1:10:</span><span> note:</span><span> the Win32 RC compiler would erroneously pad out the missing bytes
</span><span></span></code></pre>
<p>There&#39;s also a warning for extra bytes between the color table and the pixel data:</p>
<pre><code><span>test.rc:2:10:</span><span> warning:</span><span> bitmap has 4 extra bytes preceding the pixel data which will be ignored
</span><span>2 BITMAP extra_palette_bytes.bmp
</span><span>         ^~~~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>miscompilation</span></p><h3>Bitmaps with BITFIELDS and a color palette<a id="bitmaps-with-bitfields-and-a-color-palette" href="#bitmaps-with-bitfields-and-a-color-palette">🔗</a></h3>
<p>When testing things using the bitmaps from <a href="https://entropymine.com/jason/bmpsuite/">bmpsuite</a>, there is one well-formed <code>.bmp</code> file that <code>rc.exe</code> and <code>resinator</code> handle differently:</p>
<blockquote>
<p><code>g/rgb16-565pal.bmp</code>: A 16-bit image with both a BITFIELDS segment and a palette.</p>
</blockquote>
<p>The details aren&#39;t too important here, so just know that the file is structured like this:</p>
<div>
  <pre>    <code><span>..BITMAPFILEHEADER..</span>
<span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<span>.....bitfields......</span>
<span>....color table.....</span>
<span>....................</span>
<span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
<p>As mentioned earlier, the <code>BITMAPFILEHEADER</code> is dropped when compiling a <code>BITMAP</code> resource, but for whatever reason, <code>rc.exe</code> also drops the color table when compiling this <code>.bmp</code>, so it ends up like this in the compiled <code>.res</code>:</p>
<div>
  <pre>    <code><span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<span>.....bitfields......</span>
<span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
<p>Note, though, that within the <code>BITMAPINFOHEADER</code>, it still says that there is a color table present (specifically, that there are 256 entries in the color table), so this is likely a miscompilation. One possibility here is that it&#39;s not intended to be valid for a <code>.bmp</code> to contain <em>both</em> color masks <em>and</em> a color table, but that seems dubious because Windows renders the original <code>.bmp</code> file just fine in Explorer/Photos.</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-33" href="#resinator-s-behavior-33">🔗</a></h4>
<p><code>resinator</code> does not drop the color table, so in the compiled <code>.res</code> the bitmap resource data looks like this:</p>
<div>
  <pre>    <code><span>..BITMAPINFOHEADER..</span>
<span>....................</span>
<span>.....bitfields......</span>
<span>....color table.....</span>
<span>....................</span>
<span>....pixel data......</span>
<span>....................</span>
<span>....................</span></code>
  </pre>
</div>
<p>and while I think this is correct, it turns out that...</p>
<h4><code>LoadBitmap</code> mangles both versions anyway<a id="loadbitmap-mangles-both-versions-anyway" href="#loadbitmap-mangles-both-versions-anyway">🔗</a></h4>
<p>When the compiled resources are loaded with <code>LoadBitmap</code> and drawn <a href="http://parallel.vub.ac.be/education/modula2/technology/Win32_tutorial/bitmaps.html">using <code>BitBlt</code></a>, neither the <code>rc.exe</code>-compiled version, nor the <code>resinator</code>-compiled version are drawn correctly:</p>
<div>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/bmp-intended.png"/></p>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/bmp-rc.png"/></p>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/bmp-resinator.png"/></p>
<p><i>intended image</i></p>
<p><i>bitmap resource from <code>rc.exe</code></i></p>
<p><i>bitmap resource from <code>resinator</code></i></p>
</div>
<p>My guess/hope is that this a bug in <code>LoadBitmap</code>, as I believe the <code>resinator</code>-compiled resource should be correct/valid.</p>
</div>
<div>
<p><span>parser bug/quirk, utterly baffling</span></p><h3>The strange power of the lonely close parenthesis<a id="the-strange-power-of-the-lonely-close-parenthesis" href="#the-strange-power-of-the-lonely-close-parenthesis">🔗</a></h3>
<p>Likely due to some number expression parsing code gone haywire, a single close parenthesis <code>)</code> is occasionally treated as a &#39;valid&#39; expression, with bizarre consequences.</p>
<p>Similar to what was detailed in <a href="#begin-or-as-filename">&#34;<em><code>BEGIN</code> or <code>{</code> as filename</em>&#34;</a>, using <code>)</code> as a filename has the same interaction as <code>{</code> where the preceding token is treated as both the resource type and the filename.</p>
<div>

<div>
<pre><code><span>test.rc(2) : error RC2135 : file not found: RCDATA
</span></code></pre>
</div>
</div>
<p>But that&#39;s not all; take this, for example, where we define an <code>RCDATA</code> resource using a raw data block:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>1</span><span>,</span><span> </span><span>),</span><span> </span><span>),</span><span> </span><span>),</span><span> </span><span>2</span><span> </span><span>}</span><span>
</span></code></pre>
<p>This should very clearly be a syntax error, but it&#39;s actually accepted by the Windows RC compiler. What does the RC compiler do, you ask? Well, it just skips right over all the <code>)</code>, of course, and the data of this resource ends up as:</p>
<pre>  <code><span>the 1 (u16 little endian) →</span> <span>01 00</span> <span>02 00</span> <span>← the 2 (u16 little endian)</span></code>
</pre>
<p>I said &#39;skip&#39; because that&#39;s truly what seems to happen. For example, for resource definitions that take positional parameters like so:</p>
<pre><code><span>1 DIALOGEX 1, 2, 3, 4 {</span>
  
  <span>CHECKBOX</span>  <span>&#34;test&#34;</span>,  1,  2,  3,  4,  5,  6
<span>}</span></code>
</pre>
<p>If you replace the <code>&lt;id&gt;</code> parameter of <code>1</code> with <code>)</code>, then all the parameters shift over and they get interpreted like this instead:</p>
<pre><code><span>1 DIALOGEX 1, 2, 3, 4 {</span>
  
  <span>CHECKBOX</span>  <span>&#34;test&#34;</span>,  <span>)</span>,  2,  3,  4,  5,  6
<span>}</span></code>
</pre>
<p>Note also that all of this is only true of the <em>close parenthesis</em>. The open parenthesis was not deemed worthy of the same power:</p>
<div>

<div>
<pre><code><span>test.rc(1) : error RC2237 : numeric value expected at 1
test.rc(1) : error RC1013 : mismatched parentheses
</span></code></pre>
</div>
</div>
<p>Instead, <code>(</code> was bestowed a different power, which we&#39;ll see next.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-34" href="#resinator-s-behavior-34">🔗</a></h4>
<p>A single close parenthesis is never a valid expression in <code>resinator</code>:</p>
<pre><code><span>test.rc:2:20:</span><span> error:</span><span> expected number or number expression; got &#39;)&#39;
</span><span>  CHECKBOX &#34;test&#34;, ), 2, 3, 4, 5, 6
</span><span>                   ^
</span><span></span><span>test.rc:2:20:</span><span> note:</span><span> the Win32 RC compiler would accept &#39;)&#39; as a valid expression, but it would be skipped over and potentially lead to unexpected outcomes
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk, utterly baffling</span></p><h3>The strange power of the sociable open parenthesis<a id="the-strange-power-of-the-sociable-open-parenthesis" href="#the-strange-power-of-the-sociable-open-parenthesis">🔗</a></h3>
<p>While the <a href="#the-strange-power-of-the-lonely-close-parenthesis">close parenthesis</a> has a bug/quirk involving being isolated, the open parenthesis has a bug/quirk regarding being snug up against another token.</p>
<p>This is (somehow) allowed:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>(,</span><span> </span><span>(</span><span>2</span><span>,</span><span> </span><span>(</span><span>3</span><span>(,</span><span> </span><span>((((</span><span>4</span><span>((((</span><span> </span><span>{}</span><span>
</span></code></pre>
<p>In the above case, the parameters are interpreted as if the <code>(</code> characters don&#39;t exist, e.g. they compile to the values <code>1</code>, <code>2</code>, <code>3</code>, and <code>4</code>.</p>
<p>This power of <code>(</code> does not have infinite reach, though—in other places a <code>(</code> leads to an mismatched parentheses error as you might expect:</p>
<div>

<div>
<pre><code><span>test.rc(1) : error RC1013 : mismatched parentheses
</span></code></pre>
</div>
</div>
<p>There&#39;s no chance I&#39;m interested in bug-for-bug compatibility with this behavior, so I haven&#39;t investigated it beyond the shallow examples above. I&#39;m sure there are more strange implications of this bug lurking for those willing to dive deeper.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-35" href="#resinator-s-behavior-35">🔗</a></h4>
<p>An unclosed open parenthesis is always an error <code>resinator</code>:</p>
<pre><code><span>test.rc:1:14:</span><span> error:</span><span> expected number or number expression; got &#39;,&#39;
</span><span>1 DIALOGEX 1(, (2, (3(, ((((4(((( {}
</span><span>             ^
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>General comma-related inconsistencies<a id="general-comma-related-inconsistencies" href="#general-comma-related-inconsistencies">🔗</a></h3>
<p>The rules around commas within statements can be one of the following depending on the context:</p>
<ul>
<li>Exactly one comma</li>
<li>Zero or one comma</li>
<li>Zero or any number of commas</li>
</ul>
<p>And these rules can be mixed and matched within statements. I&#39;ve tried to codify my understanding of the rules around commas in a <a href="https://github.com/squeek502/resinator/blob/9a6e50b0c0859e0dee5fd1871d93329e0e1194ef/test/data/reference.rc">test <code>.rc</code> file I wrote</a>. Here&#39;s an example statement that contains all 3 rules:</p>
<pre><code><span>AUTO3STATE</span><span>,,</span><span> </span><span>&#34;mytext&#34;</span><span>,,</span><span> </span><span>900</span><span>,,</span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span>4</span><span>,</span><span> </span><span>3</span><span> </span><span>|</span><span> </span><span>NOT</span><span> </span><span>1L</span><span>,</span><span> </span><span>NOT</span><span> </span><span>1</span><span> </span><span>|</span><span> </span><span>3L</span><span>
</span></code></pre>
<p><i><code>,,</code> indicates &#34;zero or any number of commas&#34;, <code></code> indicates &#34;zero or one comma&#34;, and <code>,</code> indicates &#34;exactly 1 comma&#34;</i></p>
<h4>Empty parameters<a id="empty-parameters" href="#empty-parameters">🔗</a></h4>
<p>In most places where parameters cannot have any number of commas separating them, <code>,,</code> will lead to a compile error. For example:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>ACCELERATORS</span><span> </span><span>{</span><span>
  </span><span>&#34;^b&#34;</span><span>,,</span><span> </span><span>1</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2107 : expected numeric command value
</span></code></pre>
</div>
</div>
<p>However, there are a few places where empty parameters are accepted, and therefore <code>,,</code> is not a compile error, e.g. in the <code>MENUITEM</code> of a <code>MENUEX</code> resource:</p>
<pre><code><span>1</span><span> </span><span>MENUEX</span><span> </span><span>{</span><span>
  </span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>,</span><span> </span><span>,</span><span> </span><span>,</span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>,,,,</span><span>
  </span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Adding one more comma will cause a compile error:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>MENUEX</span><span> </span><span>{</span><span>
  </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>,,,,,</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2235 : too many arguments supplied
</span></code></pre>
</div>
</div>
<h4>Italic is singled out<a id="italic-is-singled-out" href="#italic-is-singled-out">🔗</a></h4>
<p><code>DIALOGEX</code> resources can specify a font to use using a <code>FONT</code> optional statement like so:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
  </span><span>FONT</span><span> </span><span>16</span><span>,</span><span> </span><span>&#34;Foo&#34;</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>The full syntax of the <code>FONT</code> statement in this context is:</p>
<pre><code><span>FONT</span> <span><span>pointsize<i></i></span><span><span>16</span></span></span><span>,</span> <span><span>typeface<i></i></span><span><span>&#34;Foo&#34;</span></span></span><span>,</span> <span><span>weight<i></i></span><span><span>1</span></span></span><span>,</span> <span><span>italic<i></i></span><span><span>2</span></span></span><span>,</span> <span><span>charset<i></i></span><span><span>3</span></span></span></code></pre>
<p><i><code>weight</code>, <code>italic</code>, and <code>charset</code> are optional</i></p>
<p>For whatever reason, while <code>weight</code> and <code>charset</code> can be empty parameters, <code>italic</code> seemingly cannot, since this fails:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
  </span><span>FONT</span><span> </span><span>16</span><span>,</span><span> </span><span>&#34;Foo&#34;</span><span>,</span><span> </span><span>,</span><span> </span><span>,</span><span> </span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2112 : BEGIN expected in dialog

test.rc(6) : error RC2135 : file not found: }
</span></code></pre>
</div>
</div>
<p>but this succeeds:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
  </span><span>FONT</span><span> </span><span>16</span><span>,</span><span> </span><span>&#34;Foo&#34;</span><span>,</span><span> </span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Due to the strangeness of the error, I&#39;m assuming that this <code>italic</code>-parameter-specific-behavior is unintended.</p>
<h4>Further weirdness<a id="further-weirdness" href="#further-weirdness">🔗</a></h4>

<p>Continuing on with the <code>FONT</code> statement of <code>DIALOGEX</code> resources: as we saw in <a href="#if-you-re-not-last-you-re-irrelevant">&#34;<em>If you&#39;re not last, you&#39;re irrelevant</em>&#34;</a>, if there are duplicate statements of the same type, all but the last one is ignored:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
  </span><span>FONT</span><span> </span><span>16</span><span>,</span><span> </span><span>&#34;Foo&#34;</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span> </span><span>
  </span><span>FONT</span><span> </span><span>32</span><span>,</span><span> </span><span>&#34;Bar&#34;</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>6</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>In the above example, the values-as-compiled will all come from this <code>FONT</code> statement:</p>
<pre><code><span>  </span><span>FONT</span><span> </span><span>32</span><span>,</span><span> </span><span>&#34;Bar&#34;</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>6</span><span>
</span></code></pre>
<p>However, given that the <code>weight</code>, <code>italic</code>, and <code>charset</code> parameters are optional, if you don&#39;t specify them, then their values from the previous <code>FONT</code> statement(s) <em>do</em> actually carry over, with the exception of the <code>charset</code> parameter:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
  </span><span>FONT</span><span> </span><span>16</span><span>,</span><span> </span><span>&#34;Foo&#34;</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>
  </span><span>FONT</span><span> </span><span>32</span><span>,</span><span> </span><span>&#34;Bar&#34;</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>With the above, the <code>FONT</code> statement that ends up being compiled will effectively be:</p>
<pre><code><span>  </span><span>FONT</span><span> </span><span>32</span><span>,</span><span> </span><span>&#34;Bar&#34;</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>1</span><span>
</span></code></pre>
<p>where the last <code>1</code> is the <code>charset</code> parameter&#39;s default value (<code>DEFAULT_CHARSET</code>) rather than the <code>3</code> we might expect from the duplicate <code>FONT</code> statement.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-36" href="#resinator-s-behavior-36">🔗</a></h4>
<p><code>resinator</code> matches the Windows RC compiler behavior, but has better error messages/additonal warnings where appropriate:</p>
<pre><code><span>test.rc:2:21:</span><span> error:</span><span> expected number or number expression; got &#39;,&#39;
</span><span>  FONT 16, &#34;Foo&#34;, , ,
</span><span>                    ^
</span><span></span><span>test.rc:2:21:</span><span> note:</span><span> this line originated from line 2 of file &#39;test.rc&#39;
</span><span>  FONT 16, &#34;Foo&#34;, /*weight*/, /*italic*/, /*charset*/
</span></code></pre>
<pre><code><span>test.rc:2:3:</span><span> warning:</span><span> this statement was ignored; when multiple statements of the same type are specified, only the last takes precedence
</span><span>  FONT 16, &#34;Foo&#34;, 1, 2, 3
</span><span>  ^~~~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3><code>NUL</code> in filenames<a id="nul-in-filenames" href="#nul-in-filenames">🔗</a></h3>
<p>If a filename evaluates to a string that contains a <code>NUL</code> (<code>0x00</code>) character, the Windows RC compiler treats it as a terminator. For example,</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>&#34;hello\x00world&#34;</span><span>
</span></code></pre>
<p>will try to read from the file <code>hello</code>. This is understandable considering how C handles strings, but doesn&#39;t exactly seem like desirable behavior since it happens silently.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-37" href="#resinator-s-behavior-37">🔗</a></h4>
<p>Any evaluated filename string containing a <code>NUL</code> is an error:</p>
<pre><code><span>test.rc:1:10:</span><span> error:</span><span> evaluated filename contains a disallowed codepoint: &lt;U+0000&gt;
</span><span>1 RCDATA &#34;hello\x00world&#34;
</span><span>         ^~~~~~~~~~~~~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>parser bug/quirk, utterly baffling</span></p><h3>Subtracting zero can lead to bizarre results<a id="subtracting-zero-can-lead-to-bizarre-results" href="#subtracting-zero-can-lead-to-bizarre-results">🔗</a></h3>
<p>This compiles:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span> </span><span>-</span><span> </span><span>0</span><span> </span><span>{}</span><span>
</span></code></pre>
<p>This doesn&#39;t:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>-</span><span>0</span><span> </span><span>{}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(1) : error RC2112 : BEGIN expected in dialog
</span></code></pre>
</div>
</div>
<p>I don&#39;t have a complete understanding as to why, but it seems to be related to subtracting the value zero within certain contexts.</p>
<p>Resource definitions that compile:</p>
<ul>
<li><code>1 RCDATA { 4-0 }</code></li>
<li><code>1 DIALOGEX 1, 2, 3, 4--0 {}</code></li>
<li><code>1 DIALOGEX 1, 2, 3, 4-(0) {}</code></li>
</ul>
<p>Resource definitions that error:</p>
<ul>
<li><code>1 DIALOGEX 1, 2, 3, 4-0x0 {}</code></li>
<li><code>1 DIALOGEX 1, 2, 3, (4-0) {}</code></li>
</ul>
<p>The only additional information I have is that the following:</p>
<pre><code><span>1</span><span> </span><span>DIALOGEX</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>10</span><span>-</span><span>0x0</span><span>+</span><span>5</span><span> </span><span>{}</span><span> </span><span>hello</span><span>
</span></code></pre>
<p>will error, and with the <code>/verbose</code> flag set, <code>rc.exe</code> will output:</p>
<pre><code>test.rc.
test.rc(1) : error RC2112 : BEGIN expected in dialog

Writing DIALOG:1,       lang:0x409,     size 0.
test.rc(1) : error RC2135 : file not found: hello

Writing {}:+5,  lang:0x409,     size 0
</code></pre>
<p>The verbose output gives us a hint that the Windows RC compiler is interpreting the <code>+5 {} hello</code> as a new resource definition like so:</p>
<pre><code><span><span>id<i></i></span><span>+5</span></span> <span><span>type<i></i></span><span><span>{}</span></span></span> <span><span>filename<i></i></span><span><span>hello</span></span></span></code></pre>
<p>So, somehow, the subtraction of the zero caused the <code>BEGIN expected in dialog</code> error, and then the Windows RC compiler immediately restarted its parser state and began parsing a new resource definition from scratch. This doesn&#39;t give much insight into why subtracting zero causes an error in the first place, but I thought it was a slightly interesting additional wrinkle.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-38" href="#resinator-s-behavior-38">🔗</a></h4>
<p><code>resinator</code> does not treat subtracting zero as special, and therefore never errors on any expressions that subtract zero.</p>
<p>Ideally, a warning would be emitted in cases where the Windows RC compiler would error, but detecting when that would be the case is not something I&#39;m capable of doing currently due to my lack of understanding of this bug/quirk.</p>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>All operators have equal precedence<a id="all-operators-have-equal-precedence" href="#all-operators-have-equal-precedence">🔗</a></h3>
<p>In the Windows RC compiler, all operators have equal precedence, which is not the case in C. This means that there is a mismatch between the precedence used by the preprocessor (C/C++ operator precedence) and the precedence used by the compiler.</p>
<p>Instead of detailing this bug/quirk, though, I&#39;m just going to link to Raymond Chen&#39;s excellent description (complete with the potential consequences):</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-39" href="#resinator-s-behavior-39">🔗</a></h4>
<p><code>resinator</code> matches the behavior of the Windows RC compiler with regards to operator precedence (i.e. it also contains an operator-precedence-mismatch between the preprocessor and the compiler)</p>
</div>
<div>
<p><span>parser bug/quirk</span></p><h3>That&#39;s not <em>my</em> <code>\a</code><a id="that-s-not-my-a" href="#that-s-not-my-a">🔗</a></h3>
<p>The Windows RC compiler supports some (but not all) <a href="https://en.wikipedia.org/wiki/Escape_sequences_in_C">C escape sequences</a> within string literals.</p>
<div>
<div>
<div>
<p>Supported</p>
<ul>
<li><code>\a</code></li>
<li><code>\n</code></li>
<li><code>\r</code></li>
<li><code>\t</code></li>
<li><code>\nnn</code> (or <code>\nnnnnnn</code> in wide literals)</li>
<li><code>\xhh</code> (or <code>\xhhhh</code> in wide literals)</li>
</ul>

</div>
</div>

</div>
<p>All of the supported escape sequences behave similarly to how they do in C, with the exception of <code>\a</code>. In C, <code>\a</code> is translated to the hex value <code>0x07</code> (aka the &#34;Alert (Beep, Bell)&#34; control character), while the Windows RC compiler translates <code>\a</code> to <code>0x08</code> (aka the &#34;Backspace&#34; control character).</p>
<p>On first glance, this seems like a bug, but there may be some historical reason for this that I&#39;m missing the context for.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-40" href="#resinator-s-behavior-40">🔗</a></h4>
<p><code>resinator</code> matches the behavior of the Windows RC compiler, translating <code>\a</code> to <code>0x08</code>.</p>
</div>
<div>
<p><span>undocumented, cli bug/quirk</span></p><h3>Undocumented/strange command-line options<a id="undocumented-strange-command-line-options" href="#undocumented-strange-command-line-options">🔗</a></h3>
<h4><code>/sl</code>: Maximum string length, with a twist<a id="sl-maximum-string-length-with-a-twist" href="#sl-maximum-string-length-with-a-twist">🔗</a></h4>
<p>From the help text of the Windows RC compiler (<code>rc.exe /?</code>):</p>
<pre><code>/sl      Specify the resource string length limit in percentage
</code></pre>
<p>No further information is given, and the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/using-rc-the-rc-command-line-">CLI documentation</a> doesn&#39;t even mention the option. It turns out that the <code>/sl</code> option expects a number between 1 and 100:</p>
<div>

<div>
<pre><code><span>fatal error RC1235: invalid option - string length limit percentage should be between 1 and 100 inclusive
</span></code></pre>
</div>
</div>
<p>What this option controls is the maximum number of characters within a string literal. For example, 4098 <code>a</code> characters within a string literal will fail with <code>string literal too long</code>:</p>
<pre><code>1 <span>RCDATA</span> <span>{</span> <span>&#34;aaaa</span><span title="4090 &#39;a&#39; characters omitted">&lt;...&gt;</span><span>aaaa&#34;</span> <span>}</span></code></pre>
<p>So, what are the actual limits here? What does 100% of the maximum string literal length limit get you?</p>
<ul>
<li>The default maximum string literal length (if <code>/sl</code> is not specified) is 4097; it will error if there are 4098 characters in a string literal.</li>
<li>If <code>/sl 50</code> is specified, the maximum string literal length becomes 4096 rather than 4097. There is no <code>/sl</code> setting that&#39;s equivalent to the default string literal length limit, since the option is limited to whole numbers.</li>
<li>If <code>/sl 100</code> is specified, the maximum length of a string literal becomes 8192.</li>
<li>If <code>/sl 33</code> is set, the maximum string literal length becomes 2703 (<code>8192 * 0.33 = 2,703.36</code>). 2704 characters will error with <code>string literal too long</code>.</li>
<li>If <code>/sl 15</code> is set, the maximum string literal length becomes 1228 (<code>8192 * 0.15 = 1,228.8</code>). 1229 characters will error with <code>string literal too long</code>.</li>
</ul>
<p>And to top it all off, <code>rc.exe</code> will crash if <code>/sl 100</code> is set and there is a string literal with exactly 8193 characters in it. If one more character is added to the string literal, it errors with &#39;string literal too long&#39;.</p>

<h5><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-41" href="#resinator-s-behavior-41">🔗</a></h5>
<p><code>resinator</code> uses codepoint count as the limiting factor and avoids the crash when <code>/sl 100</code> is set.</p>
<pre><code><span>string-literal-8193.rc:2:2:</span><span> error:</span><span> string literal too long (max is currently 8192 characters)
</span><span> &#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&lt;...truncated...&gt;
</span><span> ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span></code></pre>
<h4><code>/a</code>: The unknown<a id="a-the-unknown" href="#a-the-unknown">🔗</a></h4>
<p><code>/a</code> seems to be a recognized option but it&#39;s unclear what it does and the option is totally undocumented (and also was not an option in the 16-bit version of the compiler from what I can tell). I was unable to find anything that it affects about the output of <code>rc.exe</code>.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-42" href="#resinator-s-behavior-42">🔗</a></h4>
<pre><code><span>&lt;cli&gt;:</span><span> warning:</span><span> option /a has no effect (it is undocumented and its function is unknown in the Win32 RC compiler)
</span><span> ... /a ...
</span><span>     ~^
</span><span></span></code></pre>
<h4><code>/?c</code> and friends: LCX/LCE hidden options<a id="c-and-friends-lcx-lce-hidden-options" href="#c-and-friends-lcx-lce-hidden-options">🔗</a></h4>
<p>Either one of <code>/?c</code> or <code>/hc</code> will add a normally hidden &#39;Comments extracting switches:&#39; section to the help menu, with <code>/t</code> and <code>/t</code>-prefixed options dealing with <code>.LCX</code> and <code>.LCE</code> files.</p>
<pre><code><span>Comments extracting switches:
   /t           Generate .LCX output file
   /tp:&lt;prefix&gt; Extract only comments starting with &lt;prefix&gt;
   /tm          Do not save mnemonics into the output file
   /tc          Do not save comments into the output file
   /tw          Display warning if custom resources does not have LCX file
   /te          Treat all warnings as errors
   /ti          Save source file information for each resource
   /ta          Extract data for all resources
   /tn          Rename .LCE file
</span></code></pre>
<p>I can find zero info about any of this online. A generated <code>.LCE</code> file seems to be an XML file with some info about the comments and resources in the <code>.rc</code> file(s).</p>
<h5><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-43" href="#resinator-s-behavior-43">🔗</a></h5>
<pre><code><span>&lt;cli&gt;:</span><span> error:</span><span> the /t option is unsupported
</span><span> ... /t ...
</span><span>     ~^
</span><span></span></code></pre>
<p>(and similar errors for all of the other related options)</p>
<h4><code>/p</code>: Okay, I&#39;ll only preprocess, but you&#39;re not going to like it<a id="p-okay-i-ll-only-preprocess-but-you-re-not-going-to-like-it" href="#p-okay-i-ll-only-preprocess-but-you-re-not-going-to-like-it">🔗</a></h4>
<p>The undocumented <code>/p</code> option will output the preprocessed version of the <code>.rc</code> file to <code>&lt;filename&gt;.rcpp</code> instead of outputting a <code>.res</code> file (i.e. it will only run the preprocessor). However, there are two slightly strange things about this option:</p>
<ul>
<li>There doesn&#39;t appear to be any way to control the name of the <code>.rcpp</code> file (<code>/fo</code> does not affect it)</li>
<li><code>rc.exe</code> will always exit with exit code 1 when the <code>/p</code> option is used, even on success</li>
</ul>
<h5><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-44" href="#resinator-s-behavior-44">🔗</a></h5>
<p><code>resinator</code> recognizes the <code>/p</code> option, but (1) it allows <code>/fo</code> to control the file name of the preprocessed output file, and (2) it exits with 0 on success.</p>
<h4><code>/s</code>: What&#39;s HWB?<a id="s-what-s-hwb" href="#s-what-s-hwb">🔗</a></h4>
<p>The option <code>/s &lt;unknown&gt;</code> will insert a bunch of resources with name <code>HWB</code> into the <code>.res</code>. I can&#39;t find any info on this except a note <a href="https://learn.microsoft.com/en-us/cpp/windows/how-to-create-a-resource-script-file?view=msvc-170">on this page</a> saying that <code>HWB</code> is a resource name that is reserved by Visual Studio. The option seems to need a value but the value doesn&#39;t seem to have any affect on the <code>.res</code> contents and it seems to accept any value without complaint.</p>
<h5><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-45" href="#resinator-s-behavior-45">🔗</a></h5>
<pre><code><span>&lt;cli&gt;:</span><span> error:</span><span> the /s option is unsupported
</span><span> ... /s ...
</span><span>     ~^
</span><span></span></code></pre>
<h4><code>/z</code>: Mysterious font substitution<a id="z-mysterious-font-substitution" href="#z-mysterious-font-substitution">🔗</a></h4>
<p>The undocumented <code>/z</code> option almost always errors with</p>
<pre><code>fatal error RC1212: invalid option - /z argument missing substitute font name
</code></pre>
<p>To avoid this error, a value with <code>/</code> in it seems to do the trick (e.g. <code>rc.exe /z foo/bar test.rc</code>), but it&#39;s still unclear to me what purpose (if any) this option has. The title of <a href="#no-one-has-thought-about-font-resources-for-decades">&#34;<em>No one has thought about <code>FONT</code> resources for decades</em>&#34;</a> is probably relevant here, too.</p>
<h5><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-46" href="#resinator-s-behavior-46">🔗</a></h5>
<pre><code><span>&lt;cli&gt;:</span><span> error:</span><span> the /z option is unsupported
</span><span> ... /z ...
</span><span>     ~^
</span><span></span></code></pre>
</div>
<div>
<p><span>undocumented</span></p><h3>Undocumented resource types<a id="undocumented-resource-types" href="#undocumented-resource-types">🔗</a></h3>
<p>Most predefined resource types have some level of documentation <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/resource-definition-statements">here</a> (or are at least listed), but there are a few that are recognized but not documented.</p>
<h4><code>DLGINCLUDE</code><a id="dlginclude" href="#dlginclude">🔗</a></h4>
<p>The tiny bit of available documentation I could find for <code>DLGINCLUDE</code> comes from <a href="https://www.betaarchive.com/wiki/index.php/Microsoft_KB_Archive/91697">Microsoft KB Archive/91697</a>:</p>
<blockquote>
<p>The dialog editor needs a way to know what include file is associated with a resource file that it opens. Rather than prompt the user for the name of the include file, the name of the include file is embedded in the resource file in most cases.</p>
</blockquote>
<p>Here&#39;s an example from <a href="https://github.com/microsoft/Windows-classic-samples/blob/be3df303c13bcf5526250a2e1659e8add8d2e35d/Samples/Win7Samples/begin/sdkdiff/sdkdiff.rc#L281"><code>sdkdiff.rc</code> in Windows-classic-samples</a>:</p>
<pre><code>1 DLGINCLUDE &#34;wdiffrc.h&#34;
</code></pre>
<p>Further details from <a href="https://www.betaarchive.com/wiki/index.php/Microsoft_KB_Archive/91697">Microsoft KB Archive/91697</a>:</p>
<blockquote>
<p>In the Win32 SDK, changes were made so that this resource has its own resource type; it was changed from an RCDATA-type resource with the special name, DLGINCLUDE, to a DLGINCLUDE resource type whose name can be specified.</p>
</blockquote>
<p>So, in the 16-bit Windows RC compiler, a DLGINCLUDE would have looked something like this:</p>
<pre><code><span>DLGINCLUDE</span><span> </span><span>RCDATA</span><span> </span><span>DISCARDABLE</span><span>
</span><span>BEGIN</span><span>
    </span><span>&#34;GUTILSRC.H\0&#34;</span><span>
</span><span>END</span><span>
</span></code></pre>

<p><code>DLGINCLUDE</code> resources get compiled into the <code>.res</code>, but subsequently get ignored by <code>cvtres.exe</code> (the tool that turns the <code>.res</code> into a COFF object file) and therefore do not make it into the final linked binary. So, in practical terms, <code>DLGINCLUDE</code> is entirely meaningless outside of the Visual Studio dialog editor GUI as far as I know.</p>
<h4><code>DLGINIT</code><a id="dlginit" href="#dlginit">🔗</a></h4>
<p>The purpose of this resource seems like it could be similar to <code>controlData</code> in <code>DIALOGEX</code> resources (as detailed in <a href="#that-s-odd-i-thought-you-needed-more-padding">&#34;<em>That&#39;s odd, I thought you needed more padding</em>&#34;</a>)—that is, it is used to specify control-specific data that is loaded/utilized when initializing a particular control within a dialog.</p>
<p>Here&#39;s an example from <a href="https://github.com/microsoft/Windows-classic-samples/blob/main/Samples/Win7Samples/web/bits/bits_ie/bits_ie.rc"><code>bits_ie.rc</code> of Windows-classic-samples</a>:</p>
<pre><code><span>IDD_DIALOG</span><span> </span><span>DLGINIT</span><span>
</span><span>BEGIN</span><span>
    </span><span>IDC_PRIORITY</span><span>,</span><span> </span><span>0x403</span><span>,</span><span> </span><span>11</span><span>,</span><span> </span><span>0</span><span>
</span><span>0x6f46</span><span>,</span><span> </span><span>0x6572</span><span>,</span><span> </span><span>0x7267</span><span>,</span><span> </span><span>0x756f</span><span>,</span><span> </span><span>0x646e</span><span>,</span><span> </span><span>&#34;\000&#34;</span><span> 
    </span><span>IDC_PRIORITY</span><span>,</span><span> </span><span>0x403</span><span>,</span><span> </span><span>5</span><span>,</span><span> </span><span>0</span><span>
</span><span>0x6948</span><span>,</span><span> </span><span>0x6867</span><span>,</span><span> </span><span>&#34;\000&#34;</span><span> 
    </span><span>IDC_PRIORITY</span><span>,</span><span> </span><span>0x403</span><span>,</span><span> </span><span>7</span><span>,</span><span> </span><span>0</span><span>
</span><span>0x6f4e</span><span>,</span><span> </span><span>0x6d72</span><span>,</span><span> </span><span>0x6c61</span><span>,</span><span> </span><span>&#34;\000&#34;</span><span> 
    </span><span>IDC_PRIORITY</span><span>,</span><span> </span><span>0x403</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>0</span><span>
</span><span>0x6f4c</span><span>,</span><span> </span><span>0x0077</span><span>,</span><span> 
    </span><span>0</span><span>
</span><span>END</span><span>
</span></code></pre>
<p>The resource itself is compiled the same way an <code>RCDATA</code> or User-defined resource would be when using a raw data block, so each number is compiled as a 16-bit little-endian integer. The expected structure of the data seems to be dependent on the type of control it&#39;s for (in this case, <code>IDC_PRIORITY</code> is the ID for a <code>COMBOBOX</code> control). In the above example, the format seems to be something like:</p>
<pre><code><span>    </span><span>&lt;</span><span>control</span><span> </span><span>id</span><span>&gt;</span><span>,</span><span> </span><span>&lt;</span><span>language</span><span> </span><span>id</span><span>&gt;</span><span>,</span><span> </span><span>&lt;</span><span>data</span><span> </span><span>length</span><span> </span><span>in</span><span> </span><span>bytes</span><span>&gt;</span><span>,</span><span> </span><span>&lt;</span><span>unknown</span><span>&gt;</span><span>
</span><span>&lt;</span><span>data</span><span> </span><span>...</span><span>&gt;</span><span>
</span></code></pre>
<p>The particular format is not very relevant, though, as it is (1) also entirely undocumented, and (2) generated by the Visual Studio dialog editor.</p>
<p>It is worth noting, though, that the <code>&lt;data ...&gt;</code> parts of the above example, when written as little-endian <code>u16</code> integers, correspond to the bytes for the ASCII string <code>Foreground</code>, <code>High</code>, <code>Normal</code>, and <code>Low</code>. These strings can also be seen in the Properties window of the dialog editor in Visual Studio (and the dialog editor is almost certainly how the <code>DLGINIT</code> was generated in the first place):</p>
<div>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/dlginit-properties-window.png"/></p><p><i>The <code>Data</code> section of Combo-box Controls in Visual Studio corresponds to the <code>DLGINIT</code> data</i></p>
</div>
<p>While it would make sense for these strings to be used to populate the initial options in the combo box, I couldn&#39;t actually get modifications to the <code>DLGINIT</code> to affect anything in the compiled program in my testing. I&#39;m guessing that&#39;s due to a mistake on my part, though; my knowledge of the Visual Studio GUI side of <code>.rc</code> files is essentially zero.</p>
<h4><code>TOOLBAR</code><a id="toolbar" href="#toolbar">🔗</a></h4>
<p>The undocumented <code>TOOLBAR</code> resource seems to be used in combination with <a href="https://learn.microsoft.com/en-us/windows/win32/api/commctrl/nf-commctrl-createtoolbarex"><code>CreateToolbarEx</code></a> to create a toolbar of buttons from a bitmap. Here&#39;s the syntax:</p>
<pre><code><span>&lt;</span><span>id</span><span>&gt;</span><span> </span><span>TOOLBAR</span><span> </span><span>&lt;</span><span>button</span><span> </span><span>width</span><span>&gt;</span><span> </span><span>&lt;</span><span>button</span><span> </span><span>height</span><span>&gt;</span><span> </span><span>{</span><span>
  </span><span>
  </span><span>BUTTON</span><span> </span><span>&lt;</span><span>id</span><span>&gt;</span><span>
  </span><span>
  </span><span>SEPARATOR</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This resource is used in a few different <code>.rc</code> files within <a href="https://github.com/Microsoft/Windows-classic-samples">Windows-classic-samples</a>. Here&#39;s one example from <a href="https://github.com/microsoft/Windows-classic-samples/blob/7af17c73750469ed2b5732a49e5cb26cbb716094/Samples/Win7Samples/com/administration/explore.vc/VCExplore.Rc#L410-L431"><code>VCExplore.Rc</code></a>:</p>
<pre><code><span>IDR_TOOLBAR_MAIN</span><span> </span><span>TOOLBAR</span><span> </span><span>DISCARDABLE</span><span>  </span><span>16</span><span>,</span><span> </span><span>15</span><span>
</span><span>BEGIN</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_CONNECT</span><span>
    </span><span>SEPARATOR</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_REFRESH</span><span>
    </span><span>SEPARATOR</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_NEW</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_SAVE</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_DELETE</span><span>
    </span><span>SEPARATOR</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_START_APP</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_STOP_APP</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_INSTALL_APP</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_EXPORT_APP</span><span>
    </span><span>SEPARATOR</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_INSTALL_COMPONENT</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_IMPORT_COMPONENT</span><span>
    </span><span>SEPARATOR</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_UTILITY</span><span>
    </span><span>SEPARATOR</span><span>
    </span><span>BUTTON</span><span>      </span><span>ID_TBTN_ABOUT</span><span>
</span><span>END</span><span>
</span></code></pre>
<p>Additionally, a <code>BITMAP</code> resource is defined with the same ID as the toolbar:</p>
<pre><code><span>IDR_TOOLBAR_MAIN</span><span>        </span><span>BITMAP</span><span>  </span><span>DISCARDABLE</span><span>     </span><span>&#34;res\\toolbar1.bmp&#34;</span><span>
</span></code></pre>
<div>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/toolbar1.png"/></p><p><i>The example toolbar bitmap, each icon is 16x15</i></p>
</div>
<p>With the <code>TOOLBAR</code> and <code>BITMAP</code> resources together, and with a <code>CreateToolbarEx</code> call as mentioned above, we get a functional toolbar that looks like this:</p>
<div>
<p><img src="https://gianluca.ai/images/every-rc-exe-bug-quirk-probably/toolbar-gui.png"/></p><p><i>The toolbar as displayed in the GUI; note the gaps between some of the buttons (the gaps were specified in the <code>.rc</code> file)</i></p>
</div>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-47" href="#resinator-s-behavior-47">🔗</a></h4>
<p><code>resinator</code> supports these undocumented resource types, and attempts to match the behavior of the Windows RC compiler exactly.</p>
</div>
<div>
<p><span>utterly baffling</span></p><h3>Certain <code>DLGINCLUDE</code> filenames break the preprocessor<a id="certain-dlginclude-filenames-break-the-preprocessor" href="#certain-dlginclude-filenames-break-the-preprocessor">🔗</a></h3>

<p>The following script, when encoded as Windows-1252, will cause the <code>rc.exe</code> preprocessor to freak out and output what seems to be garbage:</p>
<pre><code><span>1</span><span> </span><span>DLGINCLUDE</span><span> </span><span>&#34;\001ýA\001\001\x1aý\xFF&#34;</span><span>
</span></code></pre>

<p>If we run this through the preprocessor like so:</p>
<pre><code><span>&gt;</span><span> rc.exe /p test.rc
</span><span>
Preprocessed file created in: test.rcpp
</span></code></pre>
<p>Then, in this particular case, it outputs mostly CJK characters and <code>test.rcpp</code> ends up looking like this:</p>
<pre><code><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;C:\\Users\\Ryan\\Programming\\Zig\\resinator\\tmp\\RCa18588&#34;</span><span>
</span><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;test.rc&#34;</span><span>
</span><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;test.rc&#34;</span><span>
</span><span>‱䱄䥇䍎啌䕄∠ぜ㄰䇽ぜ㄰ぜ㄰硜愱峽䙸≆</span><span>
</span></code></pre>
<p>The most minimal reproduction I&#39;ve found is:</p>
<pre><code><span>1</span><span> </span><span>DLGINCLUDE</span><span> </span><span>&#34;â&#34;&#34;&#34;</span><span>
</span></code></pre>
<p>which outputs:</p>
<pre><code><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;C:\\Users\\Ryan\\Programming\\Zig\\resinator\\tmp\\RCa21256&#34;</span><span>
</span><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;test.rc&#34;</span><span>
</span><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;test.rc&#34;</span><span>
</span><span>‱䱄䥇䍎啌䕄∠⋢∢</span><span>
</span></code></pre>

<p>As mentioned in <a href="#the-windows-rc-compiler-speaks-utf-16">&#34;<em>The Windows RC compiler &#39;speaks&#39; UTF-16</em>&#34;</a>, the result of the preprocessor is always encoded as UTF-16, and the above is the result of interpreting the preprocessed file as UTF-16. If, instead, we interpret the preprocessed file as UTF-8 (or ASCII), we would see something like this instead:</p>
<pre><code><span>#<span title="NUL">&lt;0x00&gt;</span></span><span>l</span><span title="NUL">&lt;0x00&gt;</span><span>i</span><span title="NUL">&lt;0x00&gt;</span><span>n</span><span title="NUL">&lt;0x00&gt;</span><span>e</span><span title="NUL">&lt;0x00&gt;</span><span> </span><span title="NUL">&lt;0x00&gt;</span><span>1</span><span title="NUL">&lt;0x00&gt;</span><span> </span><span title="NUL">&lt;0x00&gt;</span><span>&#34;<span title="NUL">&lt;0x00&gt;</span>C<span title="NUL">&lt;0x00&gt;</span>:<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>U<span title="NUL">&lt;0x00&gt;</span>s<span title="NUL">&lt;0x00&gt;</span>e<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>s<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>R<span title="NUL">&lt;0x00&gt;</span>y<span title="NUL">&lt;0x00&gt;</span>a<span title="NUL">&lt;0x00&gt;</span>n<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>P<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>o<span title="NUL">&lt;0x00&gt;</span>g<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>a<span title="NUL">&lt;0x00&gt;</span>m<span title="NUL">&lt;0x00&gt;</span>m<span title="NUL">&lt;0x00&gt;</span>i<span title="NUL">&lt;0x00&gt;</span>n<span title="NUL">&lt;0x00&gt;</span>g<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>Z<span title="NUL">&lt;0x00&gt;</span>i<span title="NUL">&lt;0x00&gt;</span>g<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>e<span title="NUL">&lt;0x00&gt;</span>s<span title="NUL">&lt;0x00&gt;</span>i<span title="NUL">&lt;0x00&gt;</span>n<span title="NUL">&lt;0x00&gt;</span>a<span title="NUL">&lt;0x00&gt;</span>t<span title="NUL">&lt;0x00&gt;</span>o<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>t<span title="NUL">&lt;0x00&gt;</span>m<span title="NUL">&lt;0x00&gt;</span>p<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>\<span title="NUL">&lt;0x00&gt;</span>R<span title="NUL">&lt;0x00&gt;</span>C<span title="NUL">&lt;0x00&gt;</span>a<span title="NUL">&lt;0x00&gt;</span>2<span title="NUL">&lt;0x00&gt;</span>2<span title="NUL">&lt;0x00&gt;</span>9<span title="NUL">&lt;0x00&gt;</span>4<span title="NUL">&lt;0x00&gt;</span>0<span title="NUL">&lt;0x00&gt;</span>&#34;</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span><span title="NUL">&lt;0x00&gt;</span>#<span title="NUL">&lt;0x00&gt;</span></span><span>l</span><span title="NUL">&lt;0x00&gt;</span><span>i</span><span title="NUL">&lt;0x00&gt;</span><span>n</span><span title="NUL">&lt;0x00&gt;</span><span>e</span><span title="NUL">&lt;0x00&gt;</span><span> </span><span title="NUL">&lt;0x00&gt;</span><span>1</span><span title="NUL">&lt;0x00&gt;</span><span> </span><span title="NUL">&lt;0x00&gt;</span><span>&#34;<span title="NUL">&lt;0x00&gt;</span>t<span title="NUL">&lt;0x00&gt;</span>e<span title="NUL">&lt;0x00&gt;</span>s<span title="NUL">&lt;0x00&gt;</span>t<span title="NUL">&lt;0x00&gt;</span>.<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>c<span title="NUL">&lt;0x00&gt;</span>&#34;</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span><span title="NUL">&lt;0x00&gt;</span>#<span title="NUL">&lt;0x00&gt;</span></span><span>l</span><span title="NUL">&lt;0x00&gt;</span><span>i</span><span title="NUL">&lt;0x00&gt;</span><span>n</span><span title="NUL">&lt;0x00&gt;</span><span>e</span><span title="NUL">&lt;0x00&gt;</span><span> </span><span title="NUL">&lt;0x00&gt;</span><span>1</span><span title="NUL">&lt;0x00&gt;</span><span> </span><span title="NUL">&lt;0x00&gt;</span><span>&#34;<span title="NUL">&lt;0x00&gt;</span>t<span title="NUL">&lt;0x00&gt;</span>e<span title="NUL">&lt;0x00&gt;</span>s<span title="NUL">&lt;0x00&gt;</span>t<span title="NUL">&lt;0x00&gt;</span>.<span title="NUL">&lt;0x00&gt;</span>r<span title="NUL">&lt;0x00&gt;</span>c<span title="NUL">&lt;0x00&gt;</span>&#34;</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span title="NUL">&lt;0x00&gt;</span><span>1</span><span> </span><span>DLGINCLUDE</span><span> </span><span>&#34;?&#34;&#34;&#34;</span><span>
</span><span title="NUL">&lt;0x00&gt;</span><span>
</span><span title="NUL">&lt;0x00&gt;</span><span>
</span></code></pre>
<p>With this interpretation, we can see that <code>1 DLGINCLUDE &#34;â&#34;&#34;&#34;</code> actually <em>did</em> get emitted by the preprocessor (albeit with <code>â</code> replaced by <code>?</code>), but it was emitted as a single-byte-encoding (e.g. ASCII) while the rest of the file was emitted as UTF-16 (hence all the <code><span title="NUL">&lt;0x00&gt;</span></code> bytes). The file mixing encodings like this means that it is completely unusable, but at least we know a little bit about what&#39;s going on. As to <em>why</em> or <em>how</em> this bug could manifest, that is <em>completely</em> unknowable. I can&#39;t even hazard a guess as to why certain <code>DLGINCLUDE</code> string literals would cause the preprocessor to output parts of the file with a single-byte-encoding.</p>
<p>Some commonalities between all the reproductions of this bug I&#39;ve found so far:</p>
<ul>
<li>The byte count of the <code>.rc</code> file is even, no reproduction has had a filesize with an odd byte count.</li>
<li>The number of distinct sequences (a byte, an escaped integer, or an escaped quote) in the filename string has to be small (min: 2, max: 18)</li>
</ul>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-48" href="#resinator-s-behavior-48">🔗</a></h4>
<p><code>resinator</code> avoids this bug and handles the affected strings the same way that other <code>DLGINCLUDE</code> strings are handled by the Windows RC compiler</p>
</div>
<div>
<p><span>utterly baffling</span></p><h3>Certain <code>DLGINCLUDE</code> filenames trigger <code>missing &#39;=&#39; in EXSTYLE=&lt;flags&gt;</code> errors<a id="certain-dlginclude-filenames-trigger-missing-in-exstyle-flags-errors" href="#certain-dlginclude-filenames-trigger-missing-in-exstyle-flags-errors">🔗</a></h3>

<p>Certain strings, when used with the <code>DLGINCLUDE</code> resource, will cause a seemingly entirely disconnected error. Here&#39;s one example (truncated, the full reproduction is just a longer sequence of random characters/escapes):</p>
<pre><code><span>1</span><span> </span><span>DLGINCLUDE</span><span> </span><span>&#34;\06f\x2\x2b\445q\105[ð\134\x90<span title="about 230 more characters/escape sequences not shown">&lt;...truncated...&gt;</span>&#34;</span><span>
</span></code></pre>
<p>If we try to compile this, we get this error:</p>
<pre><code>test.rc(2) : error RC2136 : missing &#39;=&#39; in EXSTYLE=&lt;flags&gt;
</code></pre>
<p>Not only do I not know why this error would ever be triggered for <code>DLGINCLUDE</code> (<code>EXSTYLE</code> is specific to <code>DIALOG</code>/<code>DIALOGEX</code>), I&#39;m not even sure what this error means or how it could be triggered <em>normally</em>, since <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/exstyle-statement"><code>EXSTYLE</code> doesn&#39;t use the syntax <code>EXSTYLE=&lt;flags&gt;</code> at all</a>. If we actually try to use the <code>EXSTYLE=&lt;flags&gt;</code> syntax, it gives us an error, so this is not a case of an error message for an undocumented feature:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>DIALOG</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>
  </span><span>EXSTYLE</span><span>=</span><span>1</span><span>
</span><span>{</span><span>
  </span><span>
</span><span>}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2112 : BEGIN expected in dialog

test.rc(4) : error RC2135 : file not found: END
</span></code></pre>
</div>
</div>
<p>I have two possible theories of what might be going on here:</p>
<ol>
<li>The error is intended but the error message is wrong, i.e. it&#39;s using some internal code for an error message that never got its message updated accordingly</li>
<li>There&#39;s a lot of undefined behavior being invoked here, and it just so happens that some random (normally impossible?) error is the result</li>
</ol>
<p>I&#39;m leaning more towards option 2, since there&#39;s no obvious reason why the strings that reproduce the error would cause any error at all. One point against it, though, is that I&#39;ve found quite a few different reproductions that all trigger the same error—the only real commonality in the reproductions is that they all have around 240 to 250 distinct characters/escape sequences within the <code>DLGINCLUDE</code> string literal.</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-49" href="#resinator-s-behavior-49">🔗</a></h4>
<p><code>resinator</code> avoids the error and handles the affected strings the same way that other <code>DLGINCLUDE</code> strings are handled by the Windows RC compiler</p>
</div>
<div>
<p><span>undocumented</span></p><h3>Various other undocumented/misdocumented things<a id="various-other-undocumented-misdocumented-things" href="#various-other-undocumented-misdocumented-things">🔗</a></h3>
<h4>Predefined macros<a id="predefined-macros" href="#predefined-macros">🔗</a></h4>
<p>The <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/predefined-macros">documentation</a> only mentions <code>RC_INVOKED</code>, but <code>_WIN32</code> is also defined by default by the Windows RC compiler. For example, this successfully compiles and the <code>.res</code> contains the <code>RCDATA</code> resource.</p>
<pre><code><span>#ifdef</span><span> </span><span>_WIN32</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;hello&#34;</span><span> </span><span>}</span><span>
</span><span>#endif</span><span>
</span></code></pre>
<h4>Dialog controls<a id="dialog-controls" href="#dialog-controls">🔗</a></h4>
<p>In the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/dialogex-resource#edit-control-statements">&#34;Edit Control Statements&#34;</a> documentation:</p>
<ul>
<li><code>BEDIT</code> is listed, but is unrecognized by the Windows RC compiler and will error with <code>undefined keyword or key name: BEDIT</code> if you attempt to use it</li>
<li><code>HEDIT</code> and <code>IEDIT</code> are listed and are recognized, but have no further documentation</li>
</ul>
<p>In the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/groupbox-control">&#34;GROUPBOX control&#34;</a> documentation, it says:</p>
<blockquote>
<p>The GROUPBOX statement, which you can use only in a DIALOGEX statement, defines the text, identifier, dimensions, and attributes of a control window.</p>
</blockquote>
<p>However, the &#34;can use only in a <code>DIALOGEX</code> statement&#34; (meaning it&#39;s not allowed in a <code>DIALOG</code> resource) is not actually true, since this compiles successfully:</p>
<pre><code><span>1</span><span> </span><span>DIALOG</span><span> </span><span>0</span><span>,</span><span> </span><span>0</span><span>,</span><span> </span><span>640</span><span>,</span><span> </span><span>480</span><span> </span><span>{</span><span>
  </span><span>GROUPBOX</span><span> </span><span>&#34;text&#34;</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>4</span><span>,</span><span> </span><span>5</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>In the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/dialogex-resource#button-control-statements">&#34;Button Control Statements&#34;</a> documentation, <code>USERBUTTON</code> is listed (and is recognized by the Windows RC compiler), but contains no further documentation.</p>
<h4><code>HTML</code> can use a raw data block, too<a id="html-can-use-a-raw-data-block-too" href="#html-can-use-a-raw-data-block-too">🔗</a></h4>
<p>In the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/rcdata-resource"><code>RCDATA</code></a> and <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/user-defined-resource">User-defined resource documentation</a>, it mentions that they can use raw data blocks:</p>
<blockquote>
<p>The data can have any format and can be defined [...] as a series of numbers and strings (if the raw-data block is specified).</p>
</blockquote>
<p>The <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/html-resource"><code>HTML</code> resource documentation</a> does not mention raw data blocks, even though it, too, can use them:</p>
<pre><code><span>1</span><span> </span><span>HTML</span><span> </span><span>{</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<h4><code>GRAYED</code> and <code>INACTIVE</code><a id="grayed-and-inactive" href="#grayed-and-inactive">🔗</a></h4>
<p>In both the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/menuitem-statement#optionlist"><code>MENUITEM</code></a> and <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/popup-resource#optionlist"><code>POPUP</code></a> documentation:</p>
<blockquote>
<table>
  <thead>
    <tr>
      <th>Option</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>GRAYED</b></td>
      <td>[...]. This option cannot be used with the <b>INACTIVE</b> option.</td>
    </tr>
    <tr>
      <td><b>INACTIVE</b></td>
      <td>[...]. This option cannot be used with the <b>GRAYED</b> option.</td>
    </tr>
  </tbody>
</table>
</blockquote>
<p>However, there is no warning or error if they <em>are</em> used together:</p>
<pre><code><span>1</span><span> </span><span>MENU</span><span> </span><span>{</span><span>
  </span><span>POPUP</span><span> </span><span>&#34;bar&#34;</span><span>,</span><span> </span><span>GRAYED</span><span>,</span><span> </span><span>INACTIVE</span><span> </span><span>{</span><span>
    </span><span>MENUITEM</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>1</span><span>,</span><span> </span><span>GRAYED</span><span>,</span><span> </span><span>INACTIVE</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>It&#39;s not clear to me why the documentation says that they cannot be used together, and I haven&#39;t (yet) put in the effort to investigate if there are any practical consequences of doing so.</p>
<h4>Semicolon comments<a id="semicolon-comments" href="#semicolon-comments">🔗</a></h4>
<p>From the <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/comments">Comments documentation</a>:</p>
<blockquote>
<p>RC supports C-style syntax for both single-line comments and block comments. Single-line comments begin with two forward slashes (//) and run to the end of the line.</p>
</blockquote>
<p>What&#39;s not mentioned is that a semicolon (<code>;</code>) is treated roughly the same as <code>//</code>:</p>
<pre><code><span>;</span><span> </span><span>this</span><span> </span><span>is</span><span> </span><span>treated</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>comment</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>}</span><span> </span><span>;</span><span> </span><span>this</span><span> </span><span>is</span><span> </span><span>also</span><span> </span><span>treated</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>comment</span><span>
</span></code></pre>
<p>There is one difference, though, and that&#39;s how each is treated within a resource ID/type. As mentioned in <a href="#special-tokenization-rules-for-names-ids">&#34;<em>Special tokenization rules for names/IDs</em>&#34;</a>, resource ID/type tokens are basically only terminated by whitespace. However, <code>//</code> within an ID/type is treated as the start of a comment, so this, for example, errors:</p>
<div>

<div>
<pre><code><span>test.rc(2) : error RC2135 : file not found: RC
</span></code></pre>
</div>
</div>
<p><i>See <a href="#incomplete-resource-at-eof">&#34;Incomplete resource at EOF&#34;</a> for an explanation of the error</i></p>
<p>This is not the case for semicolons, though, where the following example compiles into a resource with the type <code>RC;DATA</code>:</p>
<pre><code><span>1</span><span> </span><span>RC</span><span>;</span><span>DATA</span><span> </span><span>{</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>We can be reasonably sure that the semicolon comment is an intentional feature due to its presence in <a href="https://github.com/microsoft/Windows-classic-samples/blob/7af17c73750469ed2b5732a49e5cb26cbb716094/Samples/Win7Samples/netds/winsock/ipxchat/IpxChat.Rc">a file within Windows-classic-samples</a>:</p>
<pre><code><span>;</span><span> </span><span>Version</span><span> </span><span>stamping</span><span> </span><span>information</span><span>:</span><span>

</span><span>VS_VERSION_INFO</span><span> </span><span>VERSIONINFO</span><span>
</span><span>...</span><span>

</span><span>;</span><span> </span><span>String</span><span> </span><span>table</span><span>

</span><span>STRINGTABLE</span><span>
</span><span>...</span><span>
</span></code></pre>
<p>but it is wholly undocumented.</p>
<h4><code>BLOCK</code> statements support values, too<a id="block-statements-support-values-too" href="#block-statements-support-values-too">🔗</a></h4>
<p>As detailed in <a href="#mismatch-in-length-units-in-versioninfo-nodes">&#34;<em>Mismatch in length units in <code>VERSIONINFO</code> nodes</em>&#34;</a>, <code>VALUE</code> statements within <code>VERSIONINFO</code> resources are specified like so:</p>
<pre><code><span>VALUE</span><span> </span><span>&lt;</span><span>name</span><span>&gt;</span><span>,</span><span> </span><span>&lt;</span><span>value</span><span>(</span><span>s</span><span>)</span><span>&gt;</span><span>
</span></code></pre>
<p>Some examples:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;numbers&#34;</span><span>,</span><span> </span><span>123</span><span>,</span><span> </span><span>456</span><span>
  </span><span>VALUE</span><span> </span><span>&#34;strings&#34;</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;bar&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>There are also <code>BLOCK</code> statements, which themselves can contain <code>BLOCK</code>/<code>VALUE</code> statements:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>BLOCK</span><span> </span><span>&#34;foo&#34;</span><span> </span><span>{</span><span>
    </span><span>VALUE</span><span> </span><span>&#34;child&#34;</span><span>,</span><span> </span><span>&#34;of&#34;</span><span>,</span><span> </span><span>&#34;foo&#34;</span><span>
    </span><span>BLOCK</span><span> </span><span>&#34;bar&#34;</span><span> </span><span>{</span><span>
      </span><span>VALUE</span><span> </span><span>&#34;nested&#34;</span><span>,</span><span> </span><span>&#34;value&#34;</span><span>
    </span><span>}</span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>What is not mentioned anywhere that I&#39;ve seen, though, is that <code>BLOCK</code> statements can also have <code>&lt;value(s)&gt;</code> after their name parameter like so:</p>
<pre><code><span>1</span><span> </span><span>VERSIONINFO</span><span> </span><span>{</span><span>
  </span><span>BLOCK</span><span> </span><span>&#34;foo&#34;</span><span>,</span><span> </span><span>&#34;bar&#34;</span><span>,</span><span> </span><span>&#34;baz&#34;</span><span> </span><span>{</span><span>
    </span><span>
  </span><span>}</span><span>
</span><span>}</span><span>
</span></code></pre>

<p>In practice, this capability is almost entirely irrelevant. Even though <code>VERSIONINFO</code> allows you to specify any arbitrary tree structure that you&#39;d like, consumers of the <code>VERSIONINFO</code> resource expect a <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/versioninfo-resource#examples">very particular structure</a> with certain <code>BLOCK</code> names. In fact, it&#39;s understandable that this is left out of the documentation, since the <code>VERSIONINFO</code> documentation doesn&#39;t document <code>BLOCK</code>/<code>VALUE</code> statements in general, but rather only <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/stringfileinfo-block">StringFileInfo BLOCK</a> and <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/varfileinfo-block">VarFileInfo BLOCK</a>, specifically.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-50" href="#resinator-s-behavior-50">🔗</a></h4>
<p>For all of the undocumented things detailed in this section, <code>resinator</code> attempts to match the behavior of the Windows RC compiler 1:1 (or, as closely as my current understanding of the Windows RC compiler&#39;s behavior allows).</p>
</div>
<div>
<p><span>parser bug/quirk, miscompilation</span></p><h3>Non-ASCII accelerator characters<a id="non-ascii-accelerator-characters" href="#non-ascii-accelerator-characters">🔗</a></h3>
<p>The <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/accelerators-resource"><code>ACCELERATORS</code></a> resource can be used to essentially define hotkeys for a program. In the message loop of a Win32 program, the <code>TranslateAccelerator</code> function can be used to automatically turn the relevant keystrokes into <code>WM_COMMAND</code> messages with the associated <code>idvalue</code> as the parameter (meaning it can be handled like any other message coming from a menu, button, etc).</p>
<p>Simplified example from <a href="https://learn.microsoft.com/en-us/windows/win32/menurc/using-keyboard-accelerators">Using Keyboard Accelerators</a>:</p>
<pre><code><span>1</span><span> </span><span>ACCELERATORS</span><span> </span><span>{</span><span>
  </span><span>&#34;B&#34;</span><span>,</span><span> </span><span>300</span><span>,</span><span> </span><span>CONTROL</span><span>,</span><span> </span><span>VIRTKEY</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>This associates the key combination <code>Ctrl + B</code> with the ID <code>300</code> which can then be handled in Win32 message loop processing code like this:</p>
<pre><code><span>
        </span><span>case</span><span> </span><span>WM_COMMAND</span><span>:</span><span> 
            </span><span>switch</span><span> </span><span>(</span><span>LOWORD</span><span>(</span><span>wParam</span><span>))</span><span> 
            </span><span>{</span><span>
                </span><span>case</span><span> </span><span>300</span><span>:</span><span>
</span><span>
</span></code></pre>
<p>There are also a number of ways to specify the keys for an accelerator, but the relevant form here is specifying &#34;control characters&#34; using a string literal with a <code>^</code> character, e.g. <code>&#34;^B&#34;</code>.</p>

<p>When specifying a control character using <code>^</code> with an ASCII character that is outside of the range of <code>A-Z</code> (case insensitive), the Windows RC compiler will give the following error:</p>
<div>
<div>
<pre><code><span>1</span><span> </span><span>ACCELERATORS</span><span> </span><span>{</span><span>
  </span><span>&#34;^!&#34;</span><span>,</span><span> </span><span>300</span><span>
</span><span>}</span><span>
</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : error RC2154 : control character out of range [^A - ^Z]
</span></code></pre>
</div>
</div>
<p>However, contrary to what the error implies, many (but not all) non-ASCII characters outside the <code>A-Z</code> range are actually accepted. For example, this is <em>not</em> an error (when the file is encoded as UTF-8):</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span><span>
</span><span>1</span><span> </span><span>ACCELERATORS</span><span> </span><span>{</span><span>
  </span><span>&#34;^Ξ&#34;</span><span>,</span><span> </span><span>300</span><span>
</span><span>}</span><span>
</span></code></pre>

<p>When evaluating these <code>^</code> strings, the final &#39;control character&#39; value is determined by subtracting <code>0x40</code> from the ASCII uppercased value of the character following the <code>^</code>, so in the case of <code>^b</code> that would look like:</p>
<div>



<p><i>character (hex value)</i></p>
<p><i>uppercased (hex value)</i></p>
<p><i>control character value</i></p>
</div>
<p>The same process is used for any allowed codepoints outside the <code>A-Z</code> range, but the uppercasing is only done for ASCII values, so in the example above with <code>Ξ</code> (the codepoint <code>U+039E</code>; Greek Capital Letter Xi), the value is calculated like this:</p>
<div>


<p><i>codepoint (hex value)</i></p>
<p><i>control character value</i></p>
</div>
<p>I believe this is a bogus value, since the final value of a control character is meant to be in the range of <code>0x01</code> (<code>^A</code>) through <code>0x1A</code> (<code>^Z</code>), which are treated specially. My assumption is that a value of <code>0x035E</code> would just be treated as the Unicode codepoint <code>U+035E</code> (Combining Double Macron), but I&#39;m unsure exactly how I would go about testing this assumption since all aspects of the interaction between accelerators and non-ASCII key values are still fully opaque to me.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-51" href="#resinator-s-behavior-51">🔗</a></h4>
<p>In <code>resinator</code>, control characters specified as a quoted string with a <code>^</code> in an <code>ACCELERATORS</code> resource (e.g. <code>&#34;^C&#34;</code>) must be in the range of <code>A-Z</code> (case insensitive).</p>
<pre><code><span>test.rc:3:3:</span><span> error:</span><span> invalid accelerator key &#39;&#34;^Ξ&#34;&#39;: ControlCharacterOutOfRange
</span><span>  &#34;^Ξ&#34;, 1
</span><span>  ^~~~~
</span><span></span></code></pre>
</div>
<div>
<p><span>fundamental concept</span></p><h3>The entirely undocumented concept of the &#39;output&#39; code page<a id="the-entirely-undocumented-concept-of-the-output-code-page" href="#the-entirely-undocumented-concept-of-the-output-code-page">🔗</a></h3>
<p>As mentioned in <a href="#the-windows-rc-compiler-speaks-utf-16">&#34;<em>The Windows RC compiler &#39;speaks&#39; UTF-16</em>&#34;</a>, there are <code>#pragma code_page</code> preprocessor directives that can modify how each line of the input <code>.rc</code> file is interpreted. Additionally, the default code page for a file can also be set via the CLI <code>/c</code> option, e.g. <code>/c65001</code> to set the default code page to UTF-8.</p>
<p>What was not mentioned, however, is that the code page affects both how the input is interpreted <em>and</em> how the output is encoded. Take the following example:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;Ó&#34;</span><span> </span><span>}</span><span>
</span></code></pre>

<p>When saved as Windows-1252 (the default code page for the Windows RC compiler), the <code>0xD3</code> byte in the string will be interpreted as <code>Ó</code> and written to the <code>.res</code> as its Windows-1252 representation (<code>0xD3</code>).</p>
<p>If the same Windows-1252-encoded file is compiled with the default code page set to UTF-8 (<code>rc.exe /c65001</code>), then the <code>0xD3</code> byte in the <code>.rc</code> file will be an invalid UTF-8 byte sequence and get replaced with � during preprocessing, and because the code page is UTF-8, the <em>output</em> in the <code>.res</code> file will also be encoded as UTF-8, so the bytes <code>0xEF 0xBF 0xBD</code> (the UTF-8 sequence for �) will be written.</p>
<p>This is all pretty reasonable, but things start to get truly bizarre when you add <code>#pragma code_page</code> into the mix:</p>
<pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>1252</span><span>)</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;Ó&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>When saved as Windows-1252 and compiled with Windows-1252 as the default code page, this will work the same as described above. However, if we compile the same Windows-1252-encoded <code>.rc</code> file with the default code page set to UTF-8 (<code>rc.exe /c65001</code>), we see something rather strange:</p>
<ul>
<li>The input <code>0xD3</code> byte is interpreted as <code>Ó</code>, as expected since the <code>#pragma code_page</code> changed the code page to 1252</li>
<li>The output in the <code>.res</code> is <code>0xC3 0x93</code>, the UTF-8 sequence for <code>Ó</code> (instead of the expected <code>0xD3</code> which is the Windows-1252 encoding of <code>Ó</code>)</li>
</ul>
<p>That is, the <code>#pragma code_page</code> changed the <em>input</em> code page, but there is a distinct <em>output</em> code page that can be out-of-sync with the input code page. In this instance, the input code page for the <code>1 RCDATA ...</code> line is Windows-1252, but the output code page is still the default set from the CLI option (in this case, UTF-8).</p>
<p>Even more bizarrely, this disjointedness can <em>only</em> occur when a <code>#pragma code_page</code> is the first &#39;thing&#39; in the file:</p>
<pre><code><span>
</span><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>1252</span><span>)</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;Ó&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>With this, still saved as Windows-1252, the code page from the CLI option no longer matters—even when compiled with <code>/c65001</code>, the <code>0xD3</code> in the file is both interpreted as Windows-1252 (<code>Ó</code>) <em>and</em> outputted as Windows-1252 (<code>0xD3</code>).</p>
<p>I used the nebulous term &#39;thing&#39; because the rules for what stops the disjoint code page phenomenon is equally nebulous. Here&#39;s what I currently know can come before the first <code>#pragma code_page</code> while still causing the input/output code page desync:</p>
<ul>
<li>Any whitespace</li>
<li>A non-<code>code_page</code> pragma directive (e.g. <code>#pragma foo</code>)</li>
<li>An <code>#include</code> that includes a file with a <code>.h</code> or <code>.c</code> extension (<a href="https://learn.microsoft.com/en-us/windows/win32/menurc/preprocessor-directives">the contents of those files are ignored after preprocessing</a>)</li>
<li>A <code>code_page</code> pragma with an invalid code page, but only if the <code>/w</code> CLI option is set which turns invalid code page pragmas into warnings instead of errors</li>
</ul>
<p>I have a feeling this list is incomplete, though, as I only recently figured out that it&#39;s not an inherent bug/quirk of the first <code>#pragma code_page</code> in the file. Here&#39;s a file containing all of the above elements:</p>
<pre><code><span>#include</span><span> </span><span>&#34;empty.h&#34;</span><span>
    </span><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>123456789</span><span>)</span><span>
</span><span>#pragma</span><span> </span><span>foo</span><span>

</span><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>1252</span><span>)</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;Ó&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>When compiled with <code>rc.exe /c65001 /w</code>, the above still exhibits the input/output code page desync (i.e. the <code>Ó</code> is interpreted as Windows-1252 but compiled into UTF-8).</p>
<p>So, to summarize, this is how things seem to work:</p>
<ul>
<li>The CLI <code>/c</code> option sets both the input and output code pages</li>
<li>If the first <code>#pragma code_page</code> in the file is also the first &#39;thing&#39; in the file, then it <em>only</em> sets the input code page, and does not modify the output code page</li>
<li>Any other <code>#pragma code_page</code> directives set <em>both</em> the input and output code pages</li>
</ul>
<p>This behavior is baffling and I&#39;ve not seen it mentioned anywhere on the internet at any point in time. Even the concept of the code page affecting the encoding of the output is fully undocumented as far as I can tell.</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-52" href="#resinator-s-behavior-52">🔗</a></h4>
<p><code>resinator</code> emulates the behavior of the Windows RC compiler, but emits a warning:</p>
<pre><code><span>test.rc:1:1:</span><span> warning:</span><span> #pragma code_page as the first thing in the .rc script can cause the input and output code pages to become out-of-sync
</span><span>#pragma code_page ( 1252 )
</span><span>^~~~~~~~~~~~~~~~~~~~~~~~~~
</span><span></span><span>test.rc:1:1:</span><span> note:</span><span> this line originated from line 1 of file &#39;test.rc&#39;
</span><span>#pragma code_page(1252)

</span><span>test.rc:1:1:</span><span> note:</span><span> to avoid unexpected behavior, add a comment (or anything else) above the #pragma code_page line
</span><span></span></code></pre>
<p>It&#39;s possible that <code>resinator</code> will not emulate the input/output code page desync in the future, but still emit a warning about the Windows RC compiler behavior when the situation is detected.</p>
</div>
<div>
<p><span>preprocessor bug/quirk</span></p><h3>That&#39;s not whitespace, <em>this</em> is whitespace<a id="that-s-not-whitespace-this-is-whitespace" href="#that-s-not-whitespace-this-is-whitespace">🔗</a></h3>
<p>As touched on in <a href="#the-collapse-of-whitespace-is-imminent">&#34;<em>The collapse of whitespace is imminent</em>&#34;</a>, the preprocessor trims whitespace. What wasn&#39;t mentioned explicitly, though, is that this whitespace trimming happens for every line in the file (and it only trims leading whitespace). So, for example, if you run this simple example through the preprocessor:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
    </span><span>&#34;this was indented&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>it becomes this after preprocessing:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
</span><span>&#34;this was indented&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>
<p>Additionally, as briefly mentioned in <a href="#special-tokenization-rules-for-names-ids">&#34;<em>Special tokenization rules for names/IDs</em>&#34;</a>, the Windows RC compiler treats any ASCII character from <code>0x05</code> to <code>0x20</code> (inclusive) as whitespace for the purpose of tokenization. However, it turns out that this is <em>not</em> the set of characters that the <em>preprocessor</em> treats as whitespace.</p>
<p>To determine what the preprocessor considers to be whitespace, we can take advantage of its whitespace collapsing behavior. For example, if we run the following script through the preprocessor, we will see that it does not get collapsed, so therefore we know the preprocessor does not consider <code><span title="U+0005 Enquiry">&lt;0x05&gt;</span></code> to be whitespace:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span>
<span title="U+0005 Enquiry">&lt;0x05&gt;</span>   <span>&#34;this was indented&#34;</span><span>
</span><span>}</span><span>
</span></code></pre>

<p>If we iterate over every codepoint and check if they get collapsed, we can figure out exactly what the preprocessor sees as whitespace. These are the results:</p>
<ul>
<li>U+0009 Horizontal Tab (<code>\t</code>)</li>
<li>U+000A Line Feed (<code>\n</code>)</li>
<li>U+000B Vertical Tab</li>
<li>U+000C Form Feed</li>
<li>U+000D Carriage Return (<code>\r</code>)</li>
<li>U+0020 Space</li>
<li>U+00A0 No-Break Space</li>
<li>U+1680 Ogham Space Mark</li>
<li>U+180E Mongolian Vowel Separator</li>
<li>U+2000 En Quad</li>
<li>U+2001 Em Quad</li>
<li>U+2002 En Space</li>
<li>U+2003 Em Space</li>
<li>U+2004 Three-Per-Em Space</li>
<li>U+2005 Four-Per-Em Space</li>
<li>U+2006 Six-Per-Em Space</li>
<li>U+2007 Figure Space</li>
<li>U+2008 Punctuation Space</li>
<li>U+2009 Thin Space</li>
<li>U+200A Hair Space</li>
<li>U+2028 Line Separator</li>
<li>U+2029 Paragraph Separator</li>
<li>U+202F Narrow No-Break Space</li>
<li>U+205F Medium Mathematical Space</li>
<li>U+3000 Ideographic Space</li>
</ul>
<p>This list <em>almost</em> matches exactly with the Windows implementation of <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/isspace-iswspace-isspace-l-iswspace-l"><code>iswspace</code></a>, but <code>iswspace</code> returns <code>true</code> for <a href="https://codepoints.net/U+0085">U+0085 Next Line</a> while the <code>rc.exe</code> preprocessor does not consider U+0085 to be whitespace. So, while I consider the <code>rc.exe</code> preprocessor using <code>iswspace</code> to be the most likely explanation for its whitespace handling, I don&#39;t have a reason for why U+0085 in particular is excluded.</p>
<p>In terms of practical consequences of this mismatch in whitespace characters between the preprocessor and the parser, I don&#39;t have much. This is mostly just another entry in the general &#34;things you would expect some consistency on&#34; category. The only thing I was able to come up with is related to the previous <a href="#the-entirely-undocumented-concept-of-the-output-code-page">&#34;<em>The entirely undocumented concept of the &#39;output&#39; code page</em>&#34;</a> section, since the trimming of whitespace-that-only-the-preprocessor-considers-to-be-whitespace means that this example will exhibit the input/output code page desync:</p>
<pre><code><span title="U+00A0 No-Break Space">&lt;U+00A0&gt;</span><span title="U+1680 Ogham Space Mark">&lt;U+1680&gt;</span><span title="U+180E Mongolian Vowel Separator">&lt;U+180E&gt;</span>
<span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>1252</span><span>)</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;Ó&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-53" href="#resinator-s-behavior-53">🔗</a></h4>
<p><code>resinator</code> does not currently handle this very well. There&#39;s some support for <a href="https://github.com/squeek502/resinator/blob/a2a8f61fbdabdc2339a3a36ab1ce44b73e682177/src/lex.zig#L286-L291">handling <code>U+00A0</code> (No-Break Space)</a> at the start of a line in the tokenizer due to a previously incomplete understanding of this bug/quirk, but I&#39;m currently in the process of considering how this should best be handled.</p>
</div>
<div>
<p><span>parser bug/quirk, utterly baffling</span></p><h3>String literals that are forced to be &#39;wide&#39;<a id="string-literals-that-are-forced-to-be-wide" href="#string-literals-that-are-forced-to-be-wide">🔗</a></h3>
<p>There are two types of string literals in <code>.rc</code> files. For lack of better terminology, I&#39;m going to call them normal (<code>&#34;foo&#34;</code>) and wide (<code>L&#34;foo&#34;</code>, note the <code>L</code> prefix). In the context of raw data blocks, this difference is meaningful with regards to the compiled result, since normal string literals are encoded using the current output code page (see <a href="#the-entirely-undocumented-concept-of-the-output-code-page">&#34;<em>The entirely undocumented concept of the &#39;output&#39; code page</em>&#34;</a>), while wide string literals are encoded as UTF-16:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
  </span><span>&#34;foo&#34;</span><span>,</span>  <span>────►</span>  <span title="Hexdump of the compiled result of &#34;foo&#34;">66 6F 6F  foo</span>
  <span>L</span><span>&#34;foo&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;foo&#34;">66 00 6F 00 6F 00  f.o.o.</span>
<span>}</span><span>
</span></code></pre>
<p>However, in other contexts, the result is <em>always</em> encoded as UTF-16, and, in that case, there are some special (and strange) rules for how strings are parsed/handled. The full list of contexts in which this occurs is not super relevant (see the <a href="https://github.com/search?q=repo%3Asqueek502%2Fresinator%20parseQuotedStringAsWideString&amp;type=code">usages of <code>parseQuotedStringAsWideString</code></a> in <code>resinator</code> if you&#39;re curious), so we&#39;ll focus on just one: <code>STRINGTABLE</code> strings. Within a <code>STRINGTABLE</code>, both <code>&#34;foo&#34;</code> and <code>L&#34;foo&#34;</code> will get compiled to the same result (encoded as UTF-16):</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span>
  1 <span>&#34;foo&#34;</span>   <span>────►</span>  <span title="Hexdump of the compiled result of &#34;foo&#34;">66 00 6F 00 6F 00  f.o.o.</span>
  2 <span>L</span><span>&#34;foo&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;foo&#34;">66 00 6F 00 6F 00  f.o.o.</span>
<span>}</span><span>
</span></code></pre>
<p>We can also ignore <code>L</code> prefixed strings (wide strings) from here on out, since they aren&#39;t actually any different in this context than any other. The bug/quirk in question only manifests for &#34;normal&#34; strings that are parsed/compiled into UTF-16, so for the sake of clarity, I&#39;m going to call such strings &#34;forced-wide&#34; strings. For all other strings except &#34;forced-wide&#34; strings, integer escape sequences (e.g. <code>\x80</code> [hexadecimal] or <code>\123</code> [octal]) are handled as you might expect—the number they encode is directly emitted, so e.g. the sequence <code>\x80</code> always gets compiled into the integer value <code>0x80</code>, and then either written as a <code>u8</code> or a <code>u16</code> as seen here:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
  </span><span>&#34;\x80&#34;</span><span>,</span>    <span>────►</span>  <span title="Hexdump of the compiled result of &#34;\x80&#34;">80</span>
  <span>L</span><span>&#34;\x80&#34;</span>    <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;\x80&#34;">80 00</span>
<span>}</span>

<span>STRINGTABLE</span><span> </span><span>{</span>
  1 <span>L</span><span>&#34;\x80&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;\x80&#34;">80 00</span>
<span>}</span></code></pre>
<p>However, for &#34;forced-wide&#34; strings, this is not the case:</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span>
  1 <span>&#34;\x80&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of &#34;\x80&#34;">AC 20</span>
<span>}</span></code></pre>
<p>Why is the result <code>AC 20</code>? Well, for these &#34;forced-wide&#34; strings, the escape sequence is parsed, <em>then that value is re-interpreted using the current code page</em>, and then the <em>resulting codepoint</em> is written as UTF-16. In the above example, the current code page is <a href="https://en.wikipedia.org/wiki/Windows-1252">Windows-1252</a> (the default), so this is what&#39;s going on:</p>
<ul>
<li><code>\x80</code> parsed into an integer is <code>0x80</code></li>
<li><code>0x80</code> interpreted as Windows-1252 is <code>€</code></li>
<li><code>€</code> has the codepoint value <code>U+20AC</code></li>
<li><code>U+20AC</code> encoded as little-endian UTF-16 is <code>AC 20</code></li>
</ul>
<p>This means that if we use a different code page, then the compiled result will also be different. If we use <code>rc.exe /c65001</code> to set the code page to UTF-8, then this is what we get:</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span>
  1 <span>&#34;\x80&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of &#34;\x80&#34;">FD FF</span>
<span>}</span></code></pre>
<p><code>FD FF</code> is the little-endian UTF-16 encoding of the codepoint <a href="https://codepoints.net/U+FFFD"><code>U+FFFD</code></a> (� aka the Replacement Character). The explanation for this result is a bit more involved, so let&#39;s take a brief detour...</p>
<p>It is possible for string literals within <code>.rc</code> files to contain byte sequences that are considered invalid within their code page. The easiest way to demonstrate this is with UTF-8, where there are many ways to construct invalid sequences. One such way is just to include a byte that can never be part of a valid UTF-8 sequence, like <code><span title="0xFF is never valid in UTF-8">&lt;0xFF&gt;</span></code>. If we do so, this is the result:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
  </span><span>&#34;<span title="0xFF is never valid in UTF-8">&lt;0xFF&gt;</span>&#34;</span><span>,</span>  <span>────►</span>  <span title="Hexdump of the compiled result of &#34;&lt;0xFF&gt;&#34;">EF BF BD</span>
  <span>L</span><span>&#34;<span title="0xFF is never valid in UTF-8">&lt;0xFF&gt;</span>&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;&lt;0xFF&gt;&#34;">FD FF</span>
<span>}</span></code></pre>
<p><i>Compiled using the UTF-8 code page via <code>rc.exe /c65001</code></i></p>
<p><code>EF BF BD</code> is <a href="https://codepoints.net/U+FFFD"><code>U+FFFD</code></a> (�) encoded as UTF-8, and (as mentioned before), <code>FD FF</code> is the little-endian UTF-16 encoding of the same codepoint. So, when encountering an invalid sequence within a string literal, the Windows RC compiler converts it to the Unicode Replacement Character and then encodes that as whatever encoding should be emitted in that context.</p>

<p>Okay, so getting back to the bug/quirk at hand, we now know that invalid sequences are converted to <code>�</code>, which is encoded as <code>FD FF</code>. We also know that <code>FD FF</code> is what we get after compiling the escaped integer <code>\x80</code> within a &#34;forced-wide&#34; string when using the UTF-8 code page. Further, we know that escaped integers in &#34;forced-wide&#34; strings are re-interpreted using the current code page.</p>
<p>In UTF-8, the byte value <code>0x80</code> is a continuation byte, so it makes sense that, when re-interpreted as UTF-8, it is considered an invalid sequence. However, that&#39;s actually irrelevant; parsed integer sequences seem to be re-interpreted in isolation, so <em>any</em> value between <code>0x80</code> and <code>0xFF</code> is treated as an invalid sequence, as those values can only be valid within a multi-byte UTF-8 sequence. This can be confirmed by attempting to construct a valid multi-byte UTF-8 sequence using an integer escape as at least one of the bytes, but seeing nothing but � in the result:</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span>
  1 <span>&#34;\xE2\x82\xAC&#34;</span>      <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;\xE2\x82\xAC&#34;">FD FF FD FF FD FF</span>
  2 <span>&#34;\xE2<span title="Second byte of € encoded as UTF-8">&lt;0x82&gt;</span><span title="Third byte of € encoded as UTF-8">&lt;0xAC&gt;</span>&#34;</span>  <span>────►</span>  <span title="Hexdump of the compiled result of L&#34;\xE2&lt;0x82&gt;&lt;0xAC&gt;&#34;">FD FF FD FF FD FF</span>
<span>}</span></code></pre>
<p><i><code>E2 82 AC</code> is the UTF-8 encoding of € (<a href="https://codepoints.net/U+20AC"><code>U+20AC</code></a>)</i></p>
<p>An extra wrinkle comes when dealing with octal escapes. <code>0xFF</code> in octal is <code>0o377</code>, which means that octal escape sequences need to accept 3 digits in order to specify all possible values of a <code>u8</code>. However, this also means that octal escape sequences can encode values above the maximum <code>u8</code> value, e.g. <code>\777</code> (the maximum escaped octal integer) represents the value 511 in decimal or <code>0x1FF</code> in hexadecimal. This is handled by the Windows RC compiler by truncating the value down to a <code>u8</code>, so e.g. <code>\777</code> gets parsed into <code>0x1FF</code> but then gets truncated down to <code>0xFF</code> before then going through the steps mentioned before.</p>
<p>Here&#39;s an example where three different escaped integers end up compiling down to the same result, with the last one only being equal after truncation:</p>
<pre><code><span>STRINGTABLE</span><span> </span><span>{</span>
  1 <span>&#34;\x80&#34;</span>  <span>────►</span> <span>0x80</span> <span>─►</span> <span>€</span> <span>─►</span> <span>AC 20</span>
  2 <span>&#34;\200&#34;</span>  <span>────►</span> <span>0x80</span> <span>─►</span> <span>€</span> <span>─►</span> <span>AC 20</span>
  3 <span>&#34;\600&#34;</span>  <span>────►</span> <span>0x180</span> <span>─►</span> <span>0x80</span> <span>─►</span> <span>€</span> <span>─►</span> <span>AC 20</span>
<span>}</span></code></pre>
<p><i>Compiled using the Windows-1252 code page, so <code>0x80</code> is re-interpreted as € (<code>U+20AC</code>)</i></p>

<p>Finally, things get a little more bizarre when combined with <a href="#the-entirely-undocumented-concept-of-the-output-code-page">&#34;<em>The entirely undocumented concept of the &#39;output&#39; code page</em>&#34;</a>, as it turns out the re-interpretation of the escaped integers in &#34;forced-wide&#34; strings actually uses <em>the output code page</em>, not the input code page.</p>
<h4>Why?<a id="why" href="#why">🔗</a></h4>
<p>This one is truly baffling to me. If this behavior is intentional, I don&#39;t understand the use-case <em>at all</em>. It effectively means that it&#39;s impossible to use escaped integers to specify certain values, and it also means that which values those are depends on the current code page. For example, if the code page is Windows-1252, it&#39;s impossible to use escaped integers for the values <code>0x80</code>, <code>0x82</code>-<code>0x8C</code>, <code>0x8E</code>, <code>0x91</code>-<code>0x9C</code>, and <code>0x9E</code>-<code>0x9F</code> (each of these is mapped to a codepoint with a different value). If the code page is UTF-8, then it&#39;s impossible to use escaped integers for any of the values from <code>0x80</code>-<code>0xFF</code> (all of these are treated as part of a invalid UTF-8 sequence and converted to �). This limitation seemingly defeats the entire purpose of escaped integer sequences.</p>
<p>This leads me to believe this is a bug, and even then, it&#39;s a <em>very</em> strange bug. There is absolutely no reason I can conceive of for the <em>result of a parsed integer escape</em> to be <em>accidentally</em> re-interpreted as if it were encoded as the current code page.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-54" href="#resinator-s-behavior-54">🔗</a></h4>
<p><code>resinator</code> currently matches the behavior of the Windows RC compiler exactly for &#34;forced-wide&#34; strings. However, using an escaped integer in a &#34;forced-wide&#34; string is likely to become a warning in the future.</p>
</div>
<div>
<p><span>utterly baffling, miscompilation</span></p><h3>Codepoint misbehavior/miscompilation<a id="codepoint-misbehavior-miscompilation" href="#codepoint-misbehavior-miscompilation">🔗</a></h3>
<p>There are a few different ASCII control characters/Unicode codepoints that cause strange behavior in the Windows RC compiler if they are put certain places in a <code>.rc</code> file. Each case is sufficiently different that they might warrant their own section, but I&#39;m just going to lump them together into one section here.</p>
<h4>U+0000 Null<a id="u-0000-null" href="#u-0000-null">🔗</a></h4>
<p>The Windows RC compiler behaves very strangely when embedded <code>NUL</code> (<code>&lt;0x00&gt;</code>) characters are in a <code>.rc</code> file. Some examples with regards to string literals:</p>
<div>

<div>
<div><p>will error with <code>unexpected end of file in string literal</code></p></div></div>

<div>
<div><p>&#34;succeeds&#34; but results in an empty <code>.res</code> file (no <code>RCDATA</code> resource)</p></div></div>
</div>
<p>Even stranger is that the character count of the file seems to matter in some fashion for these examples. The first example has an odd character count, so it errors, but add one more character (or any odd number of characters; doesn&#39;t matter what/where they are, can even be whitespace) and it will not error. The second example has an even character count, so adding another character (again, anywhere) would induce the <code>unexpected end of file in string literal</code> error.</p>
<h4>U+0004 End of Transmission<a id="u-0004-end-of-transmission" href="#u-0004-end-of-transmission">🔗</a></h4>
<p>The Windows RC compiler seemingly treats &#39;End of Transmission&#39; (<code>&lt;0x04&gt;</code>) characters outside of string literals as a &#39;skip the next character&#39; instruction when parsing. This means that:</p>
<div>
<div>
<div>
  <pre><code>1 RCDATA<span title="&#39;End of Transmission&#39; control character">&lt;0x04&gt;</span>! <span>{</span> <span>&#34;foo&#34;</span> <span>}</span></code></pre>
</div>
</div>
<div>
<p>gets treated as if it were:</p>
</div>

</div>
<p>while</p>
<div>
<div>
<div>
  <pre><code>1 RCDATA<span title="&#39;End of Transmission&#39; control character">&lt;0x04&gt;</span>!?! <span>{</span> <span>&#34;foo&#34;</span> <span>}</span></code></pre>
</div>
</div>
<div>
<p>gets treated as if it were:</p>
</div>

</div>
<h4>U+007F Delete<a id="u-007f-delete" href="#u-007f-delete">🔗</a></h4>
<p>The Windows RC compiler seemingly treats &#39;Delete&#39; (<code>&lt;0x7F&gt;</code>) characters as a terminator in some capacity. A few examples:</p>
<div>

<div>
<div><p>gets parsed as <code>1 RC DATA {}</code>, leading to the compile error <code>file not found: DATA</code></p></div></div>

<div>
<div><p>&#34;succeeds&#34; but results in an empty <code>.res</code> file (no <code>RCDATA</code> resource)</p></div></div>

<div>
<div><p>fails with <code>unexpected end of file in string literal</code></p></div></div>
</div>
<h4>U+001A Substitute<a id="u-001a-substitute" href="#u-001a-substitute">🔗</a></h4>
<p>The Windows RC compiler treats &#39;Substitute&#39; (<code>&lt;0x1A&gt;</code>) characters as an &#39;end of file&#39; marker:</p>
<div>
<div>
  <pre><code>1 <span>RCDATA</span> <span>{</span><span>}</span>
<span title="&#39;Substitute&#39; control character">&lt;0x1A&gt;</span>
2 <span>RCDATA</span> <span>{</span><span>}</span></code></pre>
</div>
<div>
<div><p>Only the <code>1 RCDATA {}</code> resource makes it into the <code>.res</code>, everything after the <code>&lt;0x1A&gt;</code> is ignored</p></div></div>
</div>
<p>but use of the <code>&lt;0x1A&gt;</code> character can also lead to a (presumed) infinite loop in certain scenarios, like this one:</p>
<pre><code>1 <span>MENUEX</span> <span>FIXED</span><span title="&#39;Substitute&#39; control character">&lt;0x1A&gt;</span><span>VERSION</span></code></pre>

<h4>U+0900, U+0A00, U+0A0D, U+0D00, U+2000<a id="u-0900-u-0a00-u-0a0d-u-0d00-u-2000" href="#u-0900-u-0a00-u-0a0d-u-0d00-u-2000">🔗</a></h4>
<p>The Windows RC compiler will error and/or ignore these codepoints when used outside of string literals, but not always. When used within string literals, the Windows RC compiler will miscompile them in some very bizarre ways.</p>

<div>
  <div>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;ऀ਀਍ഀ &#34;</span><span> </span><span>}</span><span>
</span></code></pre>
  </div>
  
</div>
<p>The expected result is the resource&#39;s data to contain the UTF-8 encoding of each codepoint, one after another, but that is not at all what we get:</p>
<pre><code>Expected bytes: <span title="UTF-8 encoding of U+0900">E0 A4 80</span> <span title="UTF-8 encoding of U+0A00">E0 A8 80</span> <span title="UTF-8 encoding of U+0A0D">E0 A8 8D</span> <span title="UTF-8 encoding of U+0D00">E0 B4 80</span> <span title="UTF-8 encoding of U+2000">E2 80 80</span>

  Actual bytes: <span title="Horizontal Tab (\t)">09</span> <span title="Space">20</span> <span title="New Line (\n)">0A</span> <span title="Space">20</span> <span title="New Line (\n)">0A</span> <span title="Space">20</span></code></pre>
<p>These are effectively the transformations that are being made in this case:</p>
<pre><code><span title="Devanagari Sign Inverted Candrabindu">&lt;U+0900&gt;</span>  <span>────►</span>  <span title="Horizontal Tab (\t)">09</span>
<span title="&lt;reserved&gt;">&lt;U+0A00&gt;</span>  <span>────►</span>  <span title="Space">20</span> <span title="New Line (\n)">0A</span>
<span title="&lt;reserved&gt;">&lt;U+0A0D&gt;</span>  <span>────►</span>  <span title="Space">20</span> <span title="New Line (\n)">0A</span>
<span title="Malayalam Sign Combining Anusvara Above">&lt;U+0D00&gt;</span>  <span>────►</span>  &lt;omitted entirely&gt;
<span title="En Quad">&lt;U+2000&gt;</span>  <span>────►</span>  <span title="Space">20</span></code></pre>
<p>It turns out that all the codepoints have been turned into some combination of whitespace characters: <code>&lt;0x09&gt;</code> is <code>\t</code>, <code>&lt;0x20&gt;</code> is <code>&lt;space&gt;</code>, and <code>&lt;0x0A&gt;</code> is <code>\n</code>. My guess as to what&#39;s going on here is that there&#39;s some whitespace detection code going seriously haywire, in combination with some sort of endianness heuristic. If we run the example through the preprocessor only (<code>rc.exe /p /c65001 test.rc</code>), we can see that things have already gone wrong (note: I&#39;ve emphasized some whitespace characters):</p>
<pre><code><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;test.rc&#34;</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;</span><span title="Horizontal Tab (\t)">────</span>

<span title="Space">·</span><span>&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>There&#39;s quite few bugs/quirks interacting here, so I&#39;ll do my best to explain.</p>
<p>As detailed in <a href="#the-windows-rc-compiler-speaks-utf-16">&#34;<em>The Windows RC compiler &#39;speaks&#39; UTF-16</em>&#34;</a>, the preprocessor always outputs UTF-16, which means that the preprocessor will interpret the bytes of the file using the current code page and then write them back out as UTF-16. So, with that in mind, let&#39;s think about <code>U+0900</code>, which erroneously gets transformed to the character <code>&lt;0x09&gt;</code> (<code>\t</code>):</p>
<ul>
<li>In the <code>.rc</code> file, <code>U+0900</code> is encoded as UTF-8, meaning the bytes in the file are <code>E0 A4 80</code></li>
<li>The preprocessor will decode those bytes into the codepoint <code>0x0900</code> (since we set the code page to UTF-8)</li>
</ul>
<p>While <a href="https://en.wikipedia.org/wiki/Endianness">integer endianness</a> is irrelevant for UTF-8, it <em>is</em> relevant for UTF-16, since a code unit (<code>u16</code>) is 2 bytes wide. It seems possible that, because the Windows RC compiler is so UTF-16-centric, it has some heuristic to infer the endianness of a file, and that heuristic is being triggered for certain whitespace characters. That is, it might be that the Windows RC compiler sees the decoded <code>0x0900</code> codepoint and thinks it might be a byteswapped <code>0x0009</code>, and therefore <em>treats it as</em> <code>0x0009</code> (which is a tab character).</p>
<p>This sort of thing would explain some of the changes we see to the preprocessed file:</p>
<ul>
<li><code>U+0900</code> could be confused for a byteswapped <code>&lt;0x09&gt;</code> (<code>\t</code>)</li>
<li><code>U+0A00</code> could be confused for a byteswapped <code>&lt;0x0A&gt;</code> (<code>\n</code>)</li>
<li><code>U+2000</code> could be confused for a byteswapped <code>&lt;0x20&gt;</code> (<code>&lt;space&gt;</code>)</li>
</ul>
<p>For <code>U+0A0D</code> and <code>U+0D00</code>, we need another piece of information: carriage returns (<code>&lt;0x0D&gt;</code>, <code>\r</code>) are completely ignored by the preprocessor (i.e. <code>RC<span title="Carriage Return (\r)">&lt;0x0D&gt;</span>DATA</code> gets interpreted as <code>RCDATA</code>). With this in mind:</p>
<ul>
<li><code>U+0A0D</code>, ignoring the <code>0D</code> part, could be confused for a byteswapped <code>&lt;0x0A&gt;</code> (<code>\n</code>)</li>
<li><code>U+0D00</code> could be confused for a byteswapped <code>&lt;0x0D&gt;</code> (<code>\r</code>), and therefore is ignored</li>
</ul>

<p>Now that we have a theory about what might be going wrong in the preprocessor, we can examine the preprocessed version of the example:</p>
<pre><code><span>#line</span><span> </span><span>1</span><span> </span><span>&#34;test.rc&#34;</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;<span title="Horizontal Tab (\t)">────</span>

<span title="Space">·</span>&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>From <a href="#multiline-strings-don-t-behave-as-expected-documented">&#34;<em>Multiline strings don&#39;t behave as expected/documented</em>&#34;</a>, we know that this string literal—contrary to the documentation—is an accepted multiline string literal, and we also know that whitespace in these undocumented string literals is typically collapsed, so the two newlines and the trailing space should become one <code><span title="Space">20</span></code> <code><span title="New Line (\n)">0A</span></code> sequence. In fact, if we take the output of the preprocessor and copy it into a new file and compile <em>that</em>, we get a completely different result that&#39;s more in line with what we expect:</p>
<div>
  
  <div>
<pre><code>Compiled data: <span title="Space">20</span> <span title="Space">20</span> <span title="Space">20</span> <span title="Space">20</span> <span title="Space">20</span> <span title="New Line (\n)">0A</span></code></pre>
  </div>
</div>
<p>As detailed in <a href="#the-column-of-a-tab-character-matters">&#34;<em>The column of a tab character matters</em>&#34;</a>, an embedded tab character gets converted to a variable number of spaces depending on which column it&#39;s at in the file. It just so happens that it gets converted to 4 spaces in this case, and the remaining <code><span title="Space">20</span></code> <code><span title="New Line (\n)">0A</span></code> is the collapsed whitespace following the tab character.</p>
<p>However, what we actually see when compiling the <code>1 RCDATA { &#34;ऀ਀਍ഀ &#34; }</code> example is:</p>
<pre><code><span title="Horizontal Tab (\t)">09</span> <span title="Space">20</span> <span title="New Line (\n)">0A</span> <span title="Space">20</span> <span title="New Line (\n)">0A</span> <span title="Space">20</span></code></pre>
<p>where these transformations are occurring:</p>
<pre><code><span title="Devanagari Sign Inverted Candrabindu">&lt;U+0900&gt;</span>  <span>────►</span>  <span title="Horizontal Tab (\t)">09</span>
<span title="&lt;reserved&gt;">&lt;U+0A00&gt;</span>  <span>────►</span>  <span title="Space">20</span> <span title="New Line (\n)">0A</span>
<span title="&lt;reserved&gt;">&lt;U+0A0D&gt;</span>  <span>────►</span>  <span title="Space">20</span> <span title="New Line (\n)">0A</span>
<span title="Malayalam Sign Combining Anusvara Above">&lt;U+0D00&gt;</span>  <span>────►</span>  &lt;omitted entirely&gt;
<span title="En Quad">&lt;U+2000&gt;</span>  <span>────►</span>  <span title="Space">20</span></code></pre>
<p>So it seems that something about when this bug/quirk takes place in the compiler pipeline affects how the preprocessor/compiler treats the input/output.</p>
<ul>
<li>Normally, an embedded tab character will get converted to spaces during compilation, but even though the Windows RC compiler seems to <em>think</em> <code>&lt;U+0900&gt;</code> is an embedded tab character, it gets compiled into <code>&lt;0x09&gt;</code> rather than converted to space characters.</li>
<li>Normally, an undocumented-but-accepted multiline string literal has its whitespace collapsed, but even though the Windows RC compiler seems to <em>think</em> <code>&lt;U+0A00&gt;</code> and <code>&lt;U+0A0D&gt;</code> are new lines and <code>&lt;U+2000&gt;</code> is a space, it doesn&#39;t collapse them.</li>
</ul>
<p>So, to summarize, these codepoints likely confuse the Windows RC compiler into thinking they are whitespace, and the compiler treats them as the whitespace character in some ways, but introduces novel behavior for those characters in other ways. In any case, this is a miscompilation, because these codepoints have no <em>real</em> relationship to the whitespace characters the Windows RC compiler mistakes them for.</p>
<h4>U+FEFF Byte Order Mark<a id="u-feff-byte-order-mark" href="#u-feff-byte-order-mark">🔗</a></h4>
<p>For the most part, the Windows RC compiler skips over <code>&lt;U+FEFF&gt;</code> (<a href="https://codepoints.net/U+FEFF">byte-order mark or BOM</a>) everywhere, even within string literals, within names, etc. (e.g. <code>RC&lt;U+FEFF&gt;DATA</code> will compile as if it were <code>RCDATA</code>). However, there are edge cases where a BOM will cause cryptic and unexplained errors, like this:</p>
<div>
<div>
  <pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span>
1 <span>RCDATA</span> <span>{</span> 1<span title="&#39;Byte-Order Mark&#39; Unicode codepoint">&lt;U+FEFF&gt;</span>1 <span>}</span></code></pre>
</div>
<div>
<pre><code><span>test.rc(2) : fatal error RC1011: compiler limit : &#39;1 }
&#39;: macro definition too big
</span></code></pre>
</div>
</div>
<h4>U+E000 Private Use Character<a id="u-e000-private-use-character" href="#u-e000-private-use-character">🔗</a></h4>
<p>This behaves similarly to the byte-order mark (it gets skipped/ignored wherever it is), although <code>&lt;U+E000&gt;</code> seems to avoid causing errors like the BOM does.</p>
<h4>U+FFFE, U+FFFF Noncharacter<a id="u-fffe-u-ffff-noncharacter" href="#u-fffe-u-ffff-noncharacter">🔗</a></h4>
<p>The behavior of these codepoints on their own is strange, but it&#39;s not the most interesting part about them, so it&#39;s up to you if you want to expand this:</p>
<details>
<summary>Behavior of U+FFFE and U+FFFF on their own</summary>
<div>

<pre><code>Expected bytes: <span title="UTF-8 encoding of U+FFFE">EF BF BE</span>

  Actual bytes: <span title="UTF-8 encoding of U+FFFD Replacement Character (�)">EF BF BD</span> <span title="UTF-8 encoding of U+FFFD Replacement Character (�)">EF BF BD</span> (UTF-8 encoding of �, twice)</code></pre>
<p><code>U+FFFF</code> behaves the same way.</p>
</div>
<div>

<pre><code>Expected bytes: <span title="UTF-16 LE encoding of U+FFFE">FE FF</span>

  Actual bytes: <span title="UTF-16 LE encoding of U+FFFD Replacement Character (�)">FD FF</span> <span title="UTF-16 LE encoding of U+FFFD Replacement Character (�)">FD FF</span> (UTF-16 LE encoding of �, twice)</code></pre>
<p><code>U+FFFF</code> behaves the same way.</p>
</div>
<div>
<div>
  <div>
  <pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span>
1 <span>RCDATA</span> <span>{</span> <span>&#34;</span><span title="&#39;Noncharacter&#39; Unicode codepoint">&lt;U+FFFE&gt;</span><span>&#34;</span> <span>}</span></code></pre>
  </div>
  
</div>
<pre><code>Expected bytes: <span title="Windows-1252 encoding of &#39;?&#39;">3F</span>

  Actual bytes: <span title="Windows-1252 encoding of Latin Small Letter Y with Diaeresis (ÿ)">FE</span> <span title="Windows-1252 encoding of Latin Small Letter Thorn (þ)">FF</span></code></pre>
<p><code>U+FFFF</code> behaves the same way, but would get compiled to <code>FF FF</code>.</p>
</div>
<div>
<div>
  <div>
  <pre><code><span>#pragma</span><span> </span><span>code_page</span><span>(</span><span>65001</span><span>)</span>
1 <span>RCDATA</span> <span>{</span> <span>L&#34;</span><span title="&#39;Noncharacter&#39; Unicode codepoint">&lt;U+FFFE&gt;</span><span>&#34;</span> <span>}</span></code></pre>
  </div>
  
</div>
<pre><code>Expected bytes: <span title="UTF-16 LE encoding of U+FFFE">FE FF</span>

  Actual bytes: <span title="UTF-16 LE encoding of U+00FF Latin Small Letter Y with Diaeresis (ÿ)">FE 00</span> <span title="UTF-16 LE encoding of U+00FE Latin Small Letter Thorn (þ)">FF 00</span></code></pre>
<p><code>U+FFFF</code> behaves the same way, but would get compiled to <code>FF 00 FF 00</code>.</p>
</div>
</details>
<p>The <em>interesting</em> part about <code>U+FFFE</code> and <code>U+FFFF</code> is that their presence affects how <em>every non-ASCII codepoint in the file</em> is interpreted/compiled. That is, if either one appears anywhere in a file, it affects the interpretation of the entire file. Let&#39;s start with this example and try to understand what might be happening with the <code>䄀</code> characters in the <code>RCD䄀T䄀</code> resource type:</p>
<div>
  <div>
  <pre><code>1 RCD䄀T䄀 <span>{</span> <span>&#34;</span><span title="&#39;Noncharacter&#39; Unicode codepoint">&lt;U+FFFE&gt;</span><span>&#34;</span> <span>}</span></code></pre>
  </div>
  
</div>
<p>If we run this through the preprocessor only (<code>rc /c65001 /p test.rc</code>), then it ends up as:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;��&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>The interpretation of the <code>&lt;U+FFFE&gt;</code> codepoint itself is the same as described above, but we can also see that the following transformation is occurring for the <code>䄀</code> codepoint:</p>
<pre><code><span title="CJK Unified Ideograph-4100">&lt;U+4100&gt;</span> <span>(</span>䄀<span>)</span>  <span>────►</span>  <span title="Latin Capital Letter A">&lt;U+0041&gt;</span> <span>(</span>A<span>)</span></code></pre>
<p>And this transformation is not an illusion. If you compile this example <code>.rc</code> file, it will get compiled as the predefined <code>RCDATA</code> resource type. So, what&#39;s going on here?</p>
<p>Let&#39;s back up a bit and talk in a bit more detail about <a href="https://en.wikipedia.org/wiki/UTF-16">UTF-16</a> and <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>. Since UTF-16 uses 2 bytes per code unit, it can be encoded either as little-endian (least-significant byte first) or big-endian (most-significant byte first).</p>
<div>
  
  <div>
<pre><code><span title="Latin Capital Letter A">&lt;U+0041&gt;</span> <span title="Meetei Mayek Letter Huk">&lt;U+ABCD&gt;</span> <span title="CJK Unified Ideograph-4100">&lt;U+4100&gt;</span></code></pre>
  </div>
  
  
  
  
</div>
<p>In many cases, the endianness of the encoding can be inferred, but in order to make it unambiguous, a <a href="https://en.wikipedia.org/wiki/Byte_order_mark">byte-order mark</a> (BOM) can be included (usually at the start of a file). The codepoint of the BOM is <a href="https://codepoints.net/U+FEFF"><code>U+FEFF</code></a>, so that&#39;s either encoded as <code>FF FE</code> for little-endian or <code>FE FF</code> for big-endian.</p>

<p>With this in mind, consider how one might handle a big-endian UTF-16 byte-order mark in a file when starting with the assumption that the file is little-endian.</p>
<div>
  <div>
    <div><p>Big-endian UTF-16 encoded byte-order mark:</p></div>
  </div>
  
  <div>
    <div><p>Decoded codepoint, assuming little-endian:</p></div>
  </div>
  
</div>
<p>So, starting with the assumption that a file is little-endian, treating the decoded codepoint <code>&lt;U+FFFE&gt;</code> as a trigger for switching to interpreting the file as big-endian can make sense. However, it <em>only</em> makes sense when you are working with an encoding where endianness matters (e.g. UTF-16 or UTF-32). It appears, though, that the Windows RC compiler is using this <em>&#34;<code>&lt;U+FFFE&gt;</code>? Oh, the file is big-endian and I should byteswap every codepoint&#34;</em> heuristic even when it&#39;s dealing with UTF-8, which doesn&#39;t make any sense—endianness is irrelevant for UTF-8, since its code units are a single byte.</p>
<p>As mentioned in <a href="#u-0900-u-0a00-u-0a0d-u-0d00-u-2000"><code>U+0900</code>, <code>U+0A00</code>, etc</a>, this endianness handling is likely happening in the wrong phase of the compiler pipeline; it&#39;s acting on already-decoded codepoints rather than affecting how the bytes of the file are decoded.</p>
<p>If I had to guess as to what&#39;s going on here, it would be something like:</p>
<ul>
<li>The preprocessor decodes all codepoints, and internally assumes little-endian in some fashion</li>
<li>If the preprocessor ever encounters the decoded codepoint <code>&lt;U+FFFE&gt;</code>, it assumes it must be a byteswapped byte-order mark, indicating that the file is encoded as big-endian, and sets some internal &#39;big-endian&#39; flag</li>
<li>When writing the result after preprocessing, that &#39;big-endian&#39; flag is used to determine whether or not to byteswap every codepoint in the file before writing it (except ASCII codepoints for some reason)</li>
</ul>
<p>This would explain the behavior with <code>䄀</code> we saw earlier, where this <code>.rc</code> file:</p>
<pre><code>1 RCD䄀T䄀 <span>{</span> <span>&#34;</span><span title="&#39;Noncharacter&#39; Unicode codepoint">&lt;U+FFFE&gt;</span><span>&#34;</span> <span>}</span></code></pre>
<p>gets preprocessed into:</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span> </span><span>&#34;��&#34;</span><span> </span><span>}</span><span>
</span></code></pre>
<p>which means the following (byteswapping) transformation occurred, even to the <code>䄀</code> characters preceding the <code>&lt;U+FFFE&gt;</code>:</p>
<pre><code><span title="CJK Unified Ideograph-4100">&lt;U+4100&gt;</span> <span>(</span>䄀<span>)</span>  <span>────►</span>  <span title="Latin Capital Letter A">&lt;U+0041&gt;</span> <span>(</span>A<span>)</span></code></pre>
<h5>Wait, what about <code>U+FFFF</code>?<a id="wait-what-about-u-ffff" href="#wait-what-about-u-ffff">🔗</a></h5>
<p><code>U+FFFF</code> works the exact same way as <code>U+FFFE</code>—it, too, causes all non-ACII codepoints in the file to be byteswapped—and I have no clue as to why that would be since <code>U+FFFF</code> has no apparent relationship to a BOM. My only guess is an errant <code>&gt;= 0xFFFE</code> check on a <code>u16</code> value.</p>
<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-55" href="#resinator-s-behavior-55">🔗</a></h4>
<p>Any codepoints that cause misbehaviors are either a compile error:</p>
<pre><code><span>test.rc:1:9:</span><span> error:</span><span> character &#39;\x04&#39; is not allowed outside of string literals
</span><span>1 RCDATA�!?! { &#34;foo&#34; }
</span><span>        ^
</span><span></span></code></pre>
<pre><code><span>test.rc:1:1:</span><span> error:</span><span> character &#39;\x7F&#39; is not allowed
</span><span>�1 RCDATA {}
</span><span>^
</span><span></span></code></pre>
<p>or the miscompilation is avoided and a warning is emitted:</p>
<pre><code><span>test.rc:1:12:</span><span> warning:</span><span> codepoint U+0900 within a string literal would be miscompiled by the Win32 RC compiler (it would get treated as U+0009)
</span><span>1 RCDATA { &#34;ऀ਀਍ഀ &#34; }
</span><span>           ^~~~~~~
</span><span></span></code></pre>
<pre><code><span>test.rc:1:12:</span><span> warning:</span><span> codepoint U+FFFF within a string literal would cause the entire file to be miscompiled by the Win32 RC compiler
</span><span>1 RCDATA { &#34;￿&#34; }
</span><span>           ^~~
</span><span></span><span>test.rc:1:12:</span><span> note:</span><span> the presence of this codepoint causes all non-ASCII codepoints to be byteswapped by the Win32 RC preprocessor
</span><span></span></code></pre>
</div>
<div>
<p><span>preprocessor bug/quirk</span></p><h3>The sad state of the lonely forward slash<a id="the-sad-state-of-the-lonely-forward-slash" href="#the-sad-state-of-the-lonely-forward-slash">🔗</a></h3>
<p>If a line consists of nothing but a <code>/</code> character, then the <code>/</code> is ignored entirely (note: the line can have any amount of whitespace preceding the <code>/</code>, but nothing after the <code>/</code>). The following example compiles just fine:</p>
<pre><code><span>/</span><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>
  </span><span>/</span><span>
  </span><span>/</span><span>
</span><span>}</span><span>
</span><span>/</span><span>
</span></code></pre>
<p>and is effectively equivalent to</p>
<pre><code><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{}</span><span>
</span></code></pre>
<p>This seems to be a bug/quirk of the preprocessor of <code>rc.exe</code>; if we use <code>rc.exe /p</code> to only run the preprocessor, we see this output:</p>
<pre><code><span>
</span><span>1</span><span> </span><span>RCDATA</span><span> </span><span>{</span><span>


</span><span>}</span><span>


</span></code></pre>
<p>It is very like that this is a bug/quirk in the code responsible for parsing and removing comments. In fact, it&#39;s pretty easy to understand how such a bug could come about if we think about a state machine that parses and removes comments. In such a state machine, once you see a <code>/</code> character, there are three relevant possibilities:</p>
<ul>
<li>It is not part of a comment, in which case it should be emitted</li>
<li>It is the start of a line comment (<code>//</code>)</li>
<li>It is the start of a multiline comment (<code>/*</code>)</li>
</ul>
<p>So, for a parser that removes comments, it makes sense to hold off on emitting the <code>/</code> until we determine whether or not it&#39;s part of a comment. My guess is that the in-between state is not being handled fully correctly, and so instead of emitting the <code>/</code> when it is followed immediately by a line break, it is accidentally being treated as if it is part of a comment.</p>

<h4><code>resinator</code>&#39;s behavior<a id="resinator-s-behavior-56" href="#resinator-s-behavior-56">🔗</a></h4>
<p><code>resinator</code> does not currently attempt to emulate the behavior of the Windows RC compiler, so <code>/</code> is treated as any other character would be and the file is parsed accordingly. In the case of the above example, it ends up erroring with:</p>
<pre><code><span>test.rc:6:2:</span><span> error:</span><span> expected quoted string literal or unquoted literal; got &#39;&lt;eof&gt;&#39;
</span><span>/
</span><span> ^
</span><span></span></code></pre>
<p>What <code>resinator</code> <em>should</em> do in this instance <a href="https://github.com/squeek502/resinator/issues/14">is an open question</a>.</p>
</div>
<h2>Conclusion<a id="conclusion" href="#conclusion">🔗</a></h2>
<p>Well, that&#39;s all I&#39;ve got. There&#39;s a few things I left out due to them being too insignificant, or because I have forgotten about some weird behavior I added support for at some point, or because I&#39;m not (yet) aware of some bugs/quirks of the Windows RC compiler. If you got this far, thanks for reading. Like <a href="https://github.com/squeek502/resinator"><code>resinator</code></a> itself, this ended up taking a lot more effort than I initially anticipated.</p>
<p>If there&#39;s anything to take away from this article, I hope it&#39;d be something about the usefulness of fuzzing (or adjacent techniques) in exposing obscure bugs/behaviors. If you have written software that lends itself to fuzz testing in any way, I highly encourage you to consider trying it out. On <code>resinator</code>&#39;s end, there&#39;s still a lot left to explore in terms of fuzz testing. I&#39;m not fully happy with my current approach, and there are aspects of <code>resinator</code> that I know are not being properly fuzz tested yet.</p>
<p>I&#39;ve just <a href="https://github.com/squeek502/resinator/releases">released an initial version of <code>resinator</code> as a standalone program</a> if you&#39;d like to try it out. If you&#39;re a Zig user, see <a href="https://www.ryanliptak.com/blog/zig-is-a-windows-resource-compiler/">this post</a> for details on how to use the version of <code>resinator</code> included in the Zig compiler. My next steps will be <a href="https://github.com/squeek502/resinator/issues/7">adding support for converting <code>.res</code> files to  COFF object files</a> in order for Zig to be able to <a href="https://github.com/ziglang/zig/issues/17751">use its self-hosted linker for Windows resources</a>. As always, I&#39;m expecting this COFF object file stuff to be pretty straightforward to implement, but the precedence is definitely not in my favor for that assumption holding.</p>



</div>
		
	</div>


</div></div>
  </body>
</html>
