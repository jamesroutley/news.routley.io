<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.dolthub.com/blog/2024-04-19-golang-pgo-builds-using-github-actions/">Original</a>
    <h1>Golang PGO builds using GitHub Actions</h1>
    
    <div id="readability-page-1" class="page"><div data-cy="blog-post-text"><p>In February of this year, <a href="https://www.dolthub.com/blog/2024-02-19-dolt-pgo-builds/">I announced</a> that <a href="https://www.doltdb.com">Dolt</a> releases are now built as profile-guided optimized (pgo) binaries, levering this powerful feature of <a href="https://go.dev/doc/pgo">Golang</a> <code>1.20</code> to increase Dolt&#39;s read performance by 5.3%.</p>
<p>Prior to my announcement, Zach, one of our resident Golang experts, experimented and tested Golang&#39;s pgo feature and <a href="https://www.dolthub.com/blog/2024-02-02-profile-guided-optimization/">wrote about the performance gains</a> he observed in Dolt after building it with profiles created while running our <a href="https://www.dolthub.com/blog/2023-12-15-benchmarking-postgres-mysql-dolt/#what-is-sysbench">Sysbench benchmarking tests</a> against it first. From there, we knew we had to get those performance gains into our released binaries, so we retooled Dolt&#39;s release process to build pgo releases.</p>
<p>Today, I&#39;ll cover Dolt&#39;s general release process, which uses <a href="https://github.com/features/actions">GitHub Actions</a>, and I&#39;ll breakdown all phases of our release process. I&#39;ll also go over what we changed in our process to start releasing pgo builds. Hopefully this will allow you to glean some insights you can use for working pgo builds into your own Golang releases!</p>
<p>Let&#39;s dive right in.</p>

<p>Dolt leverages GitHub Actions to perform a number of automated tasks, one of which is creating and publishing releases.</p>
<p>GitHub Actions uses files called <a href="https://docs.github.com/en/actions/using-workflows/about-workflows">workflows</a> to define <a href="https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow">jobs</a> that it will do the work defined in the workflow file. These jobs are deployed to <a href="https://docs.github.com/en/actions/using-jobs/choosing-the-runner-for-a-job">runners</a>, or host machines, that you can either host yourself or allow GitHub to host for you.</p>
<p>Self-hosted runners are provisioned and maintained by you, external to GitHub Actions. GitHub-hosted runners, which are free for public repositories, are all hosted and maintained by GitHub, but they have specific storage, memory, and cpu limits depending on your tier of subscription. For Dolt, we use the free-tier GitHub-hosted runners.</p>
<p>At a high-level, the Dolt release process needs to accomplish a few objectives.</p>
<p>First, and most importantly, the process needs to create a tag and release for the new version of Dolt and upload precompiled binaries of Dolt to the <a href="https://docs.github.com/en/repositories/releasing-projects-on-github/about-releases">release assets</a>.</p>
<p>Second, the release process needs to run our Sysbench benchmarking tests against this new version of Dolt and email the results to our <a href="https://www.dolthub.com/team">DoltHub team</a>.</p>
<p>Third, and not super relevant to this blog, the process needs to kick off any other auxiliary tasks we need to perform during a release, like <a href="https://www.dolthub.com/blog/2021-01-22-release-note-generation-for-github/">creating Dolt&#39;s release notes that depend on pull request descriptions from multiple repositories</a>, publishing the release to various package managers so that it can be easily installed from them, pushing new <a href="https://www.dolthub.com/blog/2022-10-26-publish-releases-on-dockerhub/">Docker images to DockerHub</a>, or upgrading the Dolt dependency in various repositories we own.</p>
<p>So, with these objectives in mind, we came up with a suite of GitHub Actions workflows that leverage the <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#repository_dispatch">repository_dispatch</a> event so that we can accomplish each of these objectives. Let&#39;s look at a diagram that shows what this design looks like in principle, then we&#39;ll dive into the specifics of the workflows.</p>
<p><img src="https://www.dolthub.com/blog/2ce97e5aa1d249daaffa64b3d726d716/dolt_release_process.svg" alt="Diagram of Dolt Release Process Flow"/></p>
<p>In the above diagram you&#39;ll see two contexts, the GitHub Actions context and the <a href="https://kubernetes.io/">Kubernetes (K8s)</a> context. Let&#39;s discuss the GitHub Actions context first.</p>
<p>For Dolt&#39;s original release process, we used three workflows: the &#34;Release Dolt&#34; workflow, the &#34;Deploy K8s Sysbench benchmarking Job&#34; workflow, and the &#34;Email team&#34; workflow.</p>
<p>The &#34;Release Dolt&#34; workflow kicks off the entire Dolt release process, and is run manually by our engineering team when they&#39;re ready to release a new version of Dolt. Here is a pared-down version of the workflow that references the steps shown in the diagram above.</p>
<div data-language="yaml"><pre><code><span>name</span><span>:</span> Release Dolt

<span>on</span><span>:</span>
  <span>workflow_dispatch</span><span>:</span>
    <span>inputs</span><span>:</span>
      <span>version</span><span>:</span>
        <span>description</span><span>:</span> <span>&#39;SemVer format release tag, i.e. 0.24.5&#39;</span>
        <span>required</span><span>:</span> <span>true</span>

<span>jobs</span><span>:</span>
  <span>format-version</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>outputs</span><span>:</span>
      <span>version</span><span>:</span> $<span>{</span><span>{</span> steps.format_version.outputs.version <span>}</span><span>}</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Format Input
        <span>id</span><span>:</span> format_version
        <span>run</span><span>:</span> <span>|</span><span>
          version=&#34;${{ github.event.inputs.version }}&#34;
          if [[ $version == v* ]];
          then
            version=&#34;${version:1}&#34;
          fi
          echo &#34;version=$version&#34; &gt;&gt; $GITHUB_OUTPUT</span>

  <span>create-release</span><span>:</span>
    <span>needs</span><span>:</span> format<span>-</span>version
    <span>name</span><span>:</span> Create release
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>outputs</span><span>:</span>
      <span>release_id</span><span>:</span> $<span>{</span><span>{</span> steps.create_release.outputs.id <span>}</span><span>}</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Checkout code
        <span>uses</span><span>:</span> actions/checkout@v3
      <span>-</span> <span>name</span><span>:</span> Set up Go 1.x
        <span>uses</span><span>:</span> actions/setup<span>-</span>go@v3
        <span>with</span><span>:</span>
          <span>go-version</span><span>:</span> ^1.21
      <span>-</span> <span>name</span><span>:</span> Update dolt version command
        <span>run</span><span>:</span> sed <span>-</span>i <span>-</span>e &#39;s/	Version = &#34;.<span>*&#34;/</span>	Version = &#34;&#39;&#34;$NEW_VERSION&#34;&#39;&#34;/&#39; &#34;$FILE&#34;
        <span>env</span><span>:</span>
          <span>FILE</span><span>:</span> $<span>{</span><span>{</span> format(&#39;<span>{</span><span>0</span><span>}</span>/go/cmd/dolt/dolt.go&#39;<span>,</span> github.workspace) <span>}</span><span>}</span>
          <span>NEW_VERSION</span><span>:</span> $<span>{</span><span>{</span> needs.format<span>-</span>version.outputs.version <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> Set minver TBD to version
        <span>run</span><span>:</span> sed <span>-</span>i <span>-</span>e &#39;s/minver<span>:</span>&#34;TBD&#34;/minver<span>:</span>&#34;&#39;&#34;$NEW_VERSION&#34;&#39;&#34;/&#39; &#34;$FILE&#34;
        <span>env</span><span>:</span>
          <span>FILE</span><span>:</span> $<span>{</span><span>{</span> format(&#39;<span>{</span><span>0</span><span>}</span>/go/cmd/dolt/commands/sqlserver/yaml_config.go&#39;<span>,</span> github.workspace) <span>}</span><span>}</span>
          <span>NEW_VERSION</span><span>:</span> $<span>{</span><span>{</span> needs.format<span>-</span>version.outputs.version <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> update minver_validation.txt
        <span>working-directory</span><span>:</span> ./go
        <span>run</span><span>:</span> go run <span>-</span>mod=readonly ./utils/genminver_validation/ $FILE
        <span>env</span><span>:</span>
          <span>FILE</span><span>:</span> $<span>{</span><span>{</span> format(&#39;<span>{</span><span>0</span><span>}</span>/go/cmd/dolt/commands/sqlserver/testdata/minver_validation.txt&#39;<span>,</span> github.workspace) <span>}</span><span>}</span>
      <span>-</span> <span>uses</span><span>:</span> EndBug/add<span>-</span>and<span>-</span>commit@v9.1.1
        <span>with</span><span>:</span>
          <span>message</span><span>:</span> $<span>{</span><span>{</span> format(&#39;<span>[</span>ga<span>-</span>bump<span>-</span>release<span>]</span> Update Dolt version to <span>{</span><span>0</span><span>}</span> and release v<span>{</span><span>0</span><span>}</span>&#39;<span>,</span> needs.format<span>-</span>version.outputs.version) <span>}</span><span>}</span>
          <span>add</span><span>:</span> $<span>{</span><span>{</span> format(&#39;<span>[</span><span>&#34;{0}/go/cmd/dolt/dolt.go&#34;</span><span>,</span> <span>&#34;{0}/go/cmd/dolt/commands/sqlserver/yaml_config.go&#34;</span><span>,</span> <span>&#34;{0}/go/cmd/dolt/commands/sqlserver/testdata/minver_validation.txt&#34;</span><span>]</span>&#39;<span>,</span> github.workspace) <span>}</span><span>}</span>
          <span>cwd</span><span>:</span> <span>&#34;.&#34;</span>
          <span>pull</span><span>:</span> <span>&#34;--ff&#34;</span>
      <span>-</span> <span>name</span><span>:</span> Build Binaries
        <span>id</span><span>:</span> build_binaries
        <span>run</span><span>:</span> <span>|</span><span>
          latest=$(git rev-parse HEAD)
          echo &#34;commitish=$latest&#34; &gt;&gt; $GITHUB_OUTPUT
          GO_BUILD_VERSION=1.21 go/utils/publishrelease/buildbinaries.sh</span>
      <span>-</span> <span>name</span><span>:</span> Create Release
        <span>id</span><span>:</span> create_release
        <span>uses</span><span>:</span> dolthub/create<span>-</span>release@v1
        <span>env</span><span>:</span>
          <span>GITHUB_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.GITHUB_TOKEN <span>}</span><span>}</span>
        <span>with</span><span>:</span>
          <span>tag_name</span><span>:</span> v$<span>{</span><span>{</span> needs.format<span>-</span>version.outputs.version <span>}</span><span>}</span>
          <span>release_name</span><span>:</span> $<span>{</span><span>{</span> needs.format<span>-</span>version.outputs.version <span>}</span><span>}</span>
          <span>draft</span><span>:</span> <span>false</span>
          <span>prerelease</span><span>:</span> <span>false</span>
          <span>commitish</span><span>:</span> $<span>{</span><span>{</span> steps.build_binaries.outputs.commitish <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> Upload Linux AMD64 Distro
        <span>id</span><span>:</span> upload<span>-</span>linux<span>-</span>amd64<span>-</span>distro
        <span>uses</span><span>:</span> dolthub/upload<span>-</span>release<span>-</span>asset@v1
        <span>env</span><span>:</span>
          <span>GITHUB_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.GITHUB_TOKEN <span>}</span><span>}</span>
        <span>with</span><span>:</span>
          <span>upload_url</span><span>:</span> $<span>{</span><span>{</span> steps.create_release.outputs.upload_url <span>}</span><span>}</span>
          <span>asset_path</span><span>:</span> go/out/dolt<span>-</span>linux<span>-</span>amd64.tar.gz
          <span>asset_name</span><span>:</span> dolt<span>-</span>linux<span>-</span>amd64.tar.gz
          <span>asset_content_type</span><span>:</span> application/zip
<span>...</span>
      <span>-</span> <span>name</span><span>:</span> Upload Install Script
        <span>id</span><span>:</span> upload<span>-</span>install<span>-</span>script
        <span>uses</span><span>:</span> dolthub/upload<span>-</span>release<span>-</span>asset@v1
        <span>env</span><span>:</span>
          <span>GITHUB_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.GITHUB_TOKEN <span>}</span><span>}</span>
        <span>with</span><span>:</span>
          <span>upload_url</span><span>:</span> $<span>{</span><span>{</span> steps.create_release.outputs.upload_url <span>}</span><span>}</span>
          <span>asset_path</span><span>:</span> go/out/install.sh
          <span>asset_name</span><span>:</span> install.sh
          <span>asset_content_type</span><span>:</span> text/plain

  <span>trigger-performance-benchmark-email</span><span>:</span>
    <span>needs</span><span>:</span> <span>[</span>format<span>-</span>version<span>,</span> create<span>-</span>release<span>]</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Trigger Performance Benchmarks
        <span>uses</span><span>:</span> peter<span>-</span>evans/repository<span>-</span>dispatch@v2.0.0
        <span>with</span><span>:</span>
          <span>token</span><span>:</span> $<span>{</span><span>{</span> secrets.REPO_ACCESS_TOKEN <span>}</span><span>}</span>
          <span>event-type</span><span>:</span> release<span>-</span>dolt
          <span>client-payload</span><span>:</span> <span>&#39;{&#34;version&#34;: &#34;${{ needs.format-version.outputs.version }}&#34;, &#34;actor&#34;: &#34;${{ github.actor }}&#34;}&#39;</span></code></pre></div>
<p>This workflow is triggered manually, using the <a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch">workflow_dispatch</a> event, and requires a new version number as input. From there, it does some quick formatting of the version input, then writes and commits this new version to Dolt&#39;s <code>main</code> branch so that the released binaries will output this new number from the <a href="https://docs.dolthub.com/cli-reference/cli#dolt-version">dolt version</a> command.</p>
<p>In the &#34;Build Binaries&#34; step, the <code>create-release</code> job runs the <a href="https://github.com/dolthub/dolt/blob/main/go/utils/publishrelease/buildbinaries.sh">buildbinaries.sh</a> script, which builds Dolt from source using a Golang <a href="https://www.docker.com/">Docker</a> container that runs the <code>go build</code> command.</p>
<p>We use Docker containers to build Dolt so that the path&#39;s output by stack traces are generic Linux <code>go</code> paths and not paths that reference a <code>go</code> installation on the runner or on one of our personal computers (which has happened in early, early versions of Dolt 🤠).</p>
<p>Next, the &#34;Create Release&#34; step creates the tag and publishes the release on GitHub. It also provides an <code>upload_url</code> which is used in all subsequent steps of the <code>create-release</code> job to upload the compiled binaries to the new GitHub release.</p>
<p>The final portion of this workflow is another job that runs after all the previous jobs have completed. This job is called <code>trigger-performance-benchmark-email</code>. It uses <a href="https://github.com/marketplace/actions/repository-dispatch">a GitHub Action</a> we found on their marketplace to emit a <code>repository_dispatch</code> event which kicks off a separate Dolt workflow. One that we can see if we look back at our diagram.</p>
<p><img src="https://www.dolthub.com/blog/12661c36559d0670b5954b00ca0e43d8/dolt_release_process_release_dolt_last_step.svg" alt="Diagram of Dolt Release Process Flow Highlighting Release Dolt Workflow to Deploy K8s Sysbench Job"/></p>
<p>Our diagram shows the final step of the &#34;Release Dolt&#34; workflow pointing to another workflow called &#34;Deploy K8s Sysbench benchmarking Job&#34;. This is the workflow that is started by the <code>trigger-performance-benchmark-email</code> workflow job.</p>
<p>This workflow, and others like it, were designed to be dispatched asynchronously in part so that it wouldn&#39;t be tightly coupled with only the &#34;Release Dolt&#34; workflow.</p>
<p>In fact, various workflows will trigger this workflow using a <code>repository_dispatch</code> event, since we need to run performance benchmarks at different times, not just during a release. Interestingly, this workflow, itself, kicks off another asynchronous process, which we can see in the diagram indicated by the arrow—it deploys a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">K8s Job</a> that runs our Sysbench benchmarks.</p>
<p>As it happens, we&#39;ve written quite a bit about Dolt&#39;s use of Sysbench for benchmarking Dolt and MySQL to compare their performance, but I don&#39;t think we discussed the implementation details for how we do that specifically. This blog is a good one for me to go over that, so I will momentarily. Before I do though, let&#39;s look briefly at the &#34;Deploy K8s Sysbench benchmarking Job&#34; workflow.</p>
<div data-language="yaml"><pre><code><span>name</span><span>:</span> Benchmark Latency

<span>on</span><span>:</span>
  <span>repository_dispatch</span><span>:</span>
    <span>types</span><span>:</span> <span>[</span> benchmark<span>-</span>latency <span>]</span>

<span>jobs</span><span>:</span>
  <span>performance</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>name</span><span>:</span> Benchmark Performance
    <span>strategy</span><span>:</span>
      <span>matrix</span><span>:</span>
        <span>dolt_fmt</span><span>:</span> <span>[</span> <span>&#34;__DOLT__&#34;</span> <span>]</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v3
      <span>-</span> <span>uses</span><span>:</span> azure/setup<span>-</span>kubectl@v3.0
        <span>with</span><span>:</span>
          <span>version</span><span>:</span> <span>&#39;v1.23.6&#39;</span>
      <span>-</span> <span>name</span><span>:</span> Install aws<span>-</span>iam<span>-</span>authenticator
        <span>run</span><span>:</span> <span>|</span><span>
          curl -o aws-iam-authenticator https://amazon-eks.s3.us-west-2.amazonaws.com/1.18.8/2020-09-18/bin/linux/amd64/aws-iam-authenticator &amp;&amp; \
          chmod +x ./aws-iam-authenticator &amp;&amp; \
          sudo cp ./aws-iam-authenticator /usr/local/bin/aws-iam-authenticator
          aws-iam-authenticator version</span>
      <span>-</span> <span>name</span><span>:</span> Configure AWS Credentials
        <span>uses</span><span>:</span> aws<span>-</span>actions/configure<span>-</span>aws<span>-</span>credentials@v2.2.0
        <span>with</span><span>:</span>
          <span>aws-access-key-id</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_ACCESS_KEY_ID <span>}</span><span>}</span>
          <span>aws-secret-access-key</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_SECRET_ACCESS_KEY <span>}</span><span>}</span>
          <span>aws-region</span><span>:</span> us<span>-</span>west<span>-</span><span>2</span>
      <span>-</span> <span>name</span><span>:</span> Create and Auth kubeconfig
        <span>run</span><span>:</span> <span>|</span><span>
          echo &#34;$CONFIG&#34; &gt; kubeconfig
          KUBECONFIG=kubeconfig kubectl config set-credentials github-actions-dolt --exec-api-version=client.authentication.k8s.io/v1alpha1 --exec-command=aws-iam-authenticator --exec-arg=token --exec-arg=-i --exec-arg=eks-cluster-1
          KUBECONFIG=kubeconfig kubectl config set-context github-actions-dolt-context --cluster=eks-cluster-1 --user=github-actions-dolt --namespace=performance-benchmarking
          KUBECONFIG=kubeconfig kubectl config use-context github-actions-dolt-context</span>
        <span>env</span><span>:</span>
          <span>CONFIG</span><span>:</span> $<span>{</span><span>{</span> secrets.CORP_KUBECONFIG <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> Create Sysbench Performance Benchmarking K8s Job
        <span>run</span><span>:</span> ./.github/scripts/performance<span>-</span>benchmarking/run<span>-</span>benchmarks.sh
        <span>env</span><span>:</span>
          <span>FROM_SERVER</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.from_server <span>}</span><span>}</span>
          <span>FROM_VERSION</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.from_version <span>}</span><span>}</span>
          <span>TO_SERVER</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.to_server <span>}</span><span>}</span>
          <span>TO_VERSION</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.to_version <span>}</span><span>}</span>
          <span>MODE</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.mode <span>}</span><span>}</span>
          <span>ISSUE_NUMBER</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.issue_number <span>}</span><span>}</span>
          <span>ACTOR</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.actor <span>}</span><span>}</span>
          <span>ACTOR_EMAIL</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.actor_email <span>}</span><span>}</span>
          <span>REPO_ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.REPO_ACCESS_TOKEN <span>}</span><span>}</span>
          <span>KUBECONFIG</span><span>:</span> <span>&#34;./kubeconfig&#34;</span>
          <span>INIT_BIG_REPO</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.init_big_repo <span>}</span><span>}</span>
          <span>NOMS_BIN_FORMAT</span><span>:</span> $<span>{</span><span>{</span> matrix.dolt_fmt <span>}</span><span>}</span>
          <span>TEMPLATE_SCRIPT</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.template_script <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> Create TPCC Performance Benchmarking K8s Job
        <span>run</span><span>:</span> ./.github/scripts/performance<span>-</span>benchmarking/run<span>-</span>benchmarks.sh
        <span>env</span><span>:</span>
          <span>FROM_SERVER</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.from_server <span>}</span><span>}</span>
          <span>FROM_VERSION</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.from_version <span>}</span><span>}</span>
          <span>TO_SERVER</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.to_server <span>}</span><span>}</span>
          <span>TO_VERSION</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.to_version <span>}</span><span>}</span>
          <span>MODE</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.mode <span>}</span><span>}</span>
          <span>ISSUE_NUMBER</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.issue_number <span>}</span><span>}</span>
          <span>ACTOR</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.actor <span>}</span><span>}</span>
          <span>ACTOR_EMAIL</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.actor_email <span>}</span><span>}</span>
          <span>REPO_ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.REPO_ACCESS_TOKEN <span>}</span><span>}</span>
          <span>KUBECONFIG</span><span>:</span> <span>&#34;./kubeconfig&#34;</span>
          <span>INIT_BIG_REPO</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.init_big_repo <span>}</span><span>}</span>
          <span>NOMS_BIN_FORMAT</span><span>:</span> $<span>{</span><span>{</span> matrix.dolt_fmt <span>}</span><span>}</span>
          <span>WITH_TPCC</span><span>:</span> <span>&#34;true&#34;</span>
          <span>TEMPLATE_SCRIPT</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.template_script <span>}</span><span>}</span></code></pre></div>
<p>Short, but kinda busy, this workflow authenticates a <a href="https://kubernetes.io/docs/reference/kubectl/">kubectl</a> client against a <a href="https://kubernetes.io/docs/concepts/architecture/">K8s cluster</a> where we run our Sysbench benchmarks and supplies the required environment variables to run a script called <a href="https://github.com/dolthub/dolt/blob/main/.github/scripts/performance-benchmarking/run-benchmarks.sh">run-benchmarks.sh</a>. This script uses the values from these variables to write a <a href="https://github.com/dolthub/dolt/blob/main/.github/scripts/performance-benchmarking/get-mysql-dolt-job-json.sh">K8s Job configuration file</a> and then <a href="https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#apply">apply</a> it, which deploys the benchmarking Job in our K8s cluster.</p>
<p>At this point you might be wondering why we choose to run benchmarks for Dolt in a K8s cluster and not just use GitHub Actions and its runners to benchmark Dolt. Well there are a couple reasons for this.</p>
<p>One, GitHub-hosted runners have very specific limits, at least for the free-tier, and for benchmarking our database we do not necessarily want to be constrained to these.</p>
<p>Additionally, there&#39;s no way for us to know, or control, what other processes or software is running on the GitHub-hosted runners while we&#39;d be doing a benchmarking run, and that could negatively impact the results of the run in unpredictable ways.</p>
<p>And while it&#39;s certainly possible to use a self-hosted runner in GitHub Actions to circumvent these two problems, in which case we <em>could</em> benchmark Dolt using <em>only</em> GitHub Actions, we already have easily provision-able hosts available in our K8s cluster, so we opted to simply use those instead.</p>
<p>In fact, simply <code>applying</code> our K8s benchmarking Job will provision a new benchmarking host using the <a href="https://github.com/kubernetes/autoscaler">K8s cluster autoscaler</a>, which is pretty cool.</p>
<p>Anyway, returning to our diagram for a brief moment, we see that after authenticating the <code>kubectl</code> client the &#34;Deploy Sysbench benchmarking Job&#34; workflow deploys the K8s Job, and the process moves to the K8s context and the &#34;K8s Sysbench benchmarking job&#34; is run.</p>
<p><img src="https://www.dolthub.com/blog/2287e0e6de2131f07cc1e3c9316e2613/dolt_release_process_deploy_k8s_job_last_step.svg" alt="Diagram of Dolt Release Process Flow Highlighting Deploy K8s Sysbench Job Workflow to K8s Sysbench Job"/></p>
<p>Now technically, this part of the original Dolt release process was more of a post-release step. Running the benchmarking job was not required to create a new Dolt release on GitHub, it just provided our team with a report on the release&#39;s latency. But it&#39;s important to see this part of our original release process so that our pgo updates to the Dolt release process will make more sense, but more on that later.</p>
<p>In the K8s context of the diagram we can see that the benchmarking Job performs a few steps. It builds a Dolt binary from a supplied <a href="https://docs.github.com/en/pull-requests/committing-changes-to-your-project/creating-and-editing-commits/about-commits">commit SHA</a>. In this case it&#39;s the SHA from the <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">HEAD</a> of Dolt <code>main</code>.</p>
<p>Next, it runs the Sysbench tests against that compiled Dolt version, then uploads the results of the Sysbench run to an <a href="https://aws.amazon.com/s3/">AWS S3 bucket</a>. Finally, it triggers a different GitHub Actions workflow that lives in the Dolt repository called the &#34;Email team&#34; workflow.</p>
<p>To perform all of this benchmarking and uploading and triggering, we&#39;ve written an internal tool that can be used to benchmark a version of Dolt against a version of MySQL.</p>
<p>This tool uses some library code we maintain in the Dolt repository, but I&#39;ll provide some relevant snippets from the internal tool and the library code so you get a sense of how we&#39;ve implemented these to run our benchmarks.</p>
<p>Our internal benchmarking tool code is essentially the following <code>go</code> function:</p>
<details>
  <summary>Click to see code</summary>
<div data-language="go"><pre><code><span>func</span> <span>compare</span><span>(</span>ctx context<span>.</span>Context<span>,</span>
	fromServer<span>,</span>
	toServer runner<span>.</span>ServerType<span>,</span>
	fromVersion<span>,</span>
	toVersion<span>,</span>
	fromProfile<span>,</span>
	toProfile<span>,</span>
	dir<span>,</span>
	doltCommand<span>,</span>
	doltgresCommand<span>,</span>
	mysqlExec<span>,</span>
	mysqlProtocol<span>,</span>
	mysqlSocketPath<span>,</span>
	postgresExec<span>,</span>
	initDbExec<span>,</span>
	nomsBinFormat<span>,</span>
	resultsDir<span>,</span>
	resultsPrefix<span>,</span>
	resultsFilename<span>,</span>
	scriptDir<span>,</span>
	schema<span>,</span>
	outputFormat <span>string</span><span>,</span>
	defaultRuns <span>int</span><span>,</span>
	initBigRepo<span>,</span>
	useDoltHubLuaScriptsRepo<span>,</span>
	writeResultsToFile <span>bool</span><span>,</span>
	queries <span>[</span><span>]</span><span>string</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
	config <span>:=</span> benchmark<span>.</span><span>NewComparisonBenchmarkingConfig</span><span>(</span>
		fromServer<span>,</span>
		toServer<span>,</span>
		fromVersion<span>,</span>
		toVersion<span>,</span>
		fromProfile<span>,</span>
		toProfile<span>,</span>
		dir<span>,</span>
		doltCommand<span>,</span>
		doltgresCommand<span>,</span>
		mysqlExec<span>,</span>
		mysqlProtocol<span>,</span>
		mysqlSocketPath<span>,</span>
		postgresExec<span>,</span>
		initDbExec<span>,</span>
		nomsBinFormat<span>,</span>
		scriptDir<span>,</span>
		defaultRuns<span>,</span>
		initBigRepo<span>,</span>
		useDoltHubLuaScriptsRepo<span>)</span>

	sr <span>:=</span> benchmark<span>.</span><span>NewSysbenchComparer</span><span>(</span>config<span>)</span>

	err <span>:=</span> sr<span>.</span><span>Run</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>&#34;&#34;</span><span>,</span> err
	<span>}</span>

	fromServerConfig<span>,</span> err <span>:=</span> config<span>.</span><span>GetFromServerConfig</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>&#34;&#34;</span><span>,</span> err
	<span>}</span>

	toServerConfig<span>,</span> err <span>:=</span> config<span>.</span><span>GetToServerConfig</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>&#34;&#34;</span><span>,</span> err
	<span>}</span>

	resultsDbName <span>:=</span> fmt<span>.</span><span>Sprintf</span><span>(</span><span>&#34;sysbench-%s&#34;</span><span>,</span> benchmark<span>.</span>ComparisonDbFilename<span>)</span>

	db <span>:=</span> benchmark<span>.</span><span>NewSqlite3ResultsDb</span><span>(</span>fromServerConfig<span>,</span> toServerConfig<span>,</span> dir<span>,</span> schema<span>,</span> resultsDir<span>,</span> resultsPrefix<span>,</span> resultsFilename<span>,</span> resultsDbName<span>,</span> outputFormat<span>,</span> queries<span>,</span> writeResultsToFile<span>)</span>
	uploadDir<span>,</span> err <span>:=</span> db<span>.</span><span>QueryResults</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>&#34;&#34;</span><span>,</span> err
	<span>}</span>

	<span>return</span> uploadDir<span>,</span> <span>nil</span>
<span>}</span></code></pre></div>
</details>
<p><code>compare</code> is used to compare the Sysbench results of one version of a database to another. You can see from the function&#39;s parameters that this tool is not only used for Dolt and MySQL, but is also used for benchmarking our latest product <a href="https://www.dolthub.com/blog/2023-11-01-announcing-doltgresql/">DoltgreSQL</a>, and it&#39;s competitor <a href="https://www.postgresql.org/">PostgreSQL</a>.</p>
<p>The <code>compare</code> function refers to a <code>fromServerConfig</code>, which is the configuration for the &#34;from&#34; database server, and refers to a <code>toServerConfig</code>, which is the configuration of the &#34;to&#34; database server. Semantically, here, this tool will compare the &#34;from&#34; database to the &#34;to&#34; database side-by-side for easy analysis. During the Dolt release process, MySQL will be the &#34;from&#34; server and Dolt will be the &#34;to&#34; server.</p>
<p>You may also notice that we use <a href="https://www.sqlite.org/">sqlite3</a> in this tool, as referenced by <code>benchmark.NewSqlite3ResultsDb</code>, which is a legacy artifact from days before Dolt v1.0.0, but it still has some unique value here.</p>
<p>Under-the-hood, after the benchmarks run with <code>sr.Run()</code>, we load the results into a <code>sqlite3</code> database and run some queries against it to get the comparative results of each database server. A benefit of using <code>sqlite3</code> over Dolt for doing this, which works just as well, is that <code>sqlite3</code> returns query output in many formats with the use of simple flags, like <code>--html</code> and <code>--markdown</code>, which saves us from having to code up query result transformation logic.</p>
<p>The <code>uploadDir</code> returned from <code>db.QueryResults()</code> contains the results of the comparison queries and a copy of the <code>sqlite3</code> database to be uploaded to S3. These results will soon be downloaded by the &#34;Email team&#34; workflow, as we&#39;ll see shortly.</p>
<p>When it comes to <em>actually</em> running the Sysbench benchmarks, the <code>benchmark.NewSysbenchComparer(config)</code> is simply a wrapper <a href="https://go.dev/tour/moretypes/2">struct</a> around the <code>Run</code> function from some <a href="https://github.com/dolthub/dolt/tree/main/go/performance/utils/benchmark_runner">benchmarking library code we maintain in the Dolt repository</a>.</p>
<details>
  <summary>Click to see code</summary>
<div data-language="go"><pre><code><span>func</span> <span>Run</span><span>(</span>config <span>*</span>Config<span>)</span> <span>error</span> <span>{</span>
	err <span>:=</span> config<span>.</span><span>Validate</span><span>(</span><span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> err
	<span>}</span>

	ctx <span>:=</span> context<span>.</span><span>Background</span><span>(</span><span>)</span>

	err <span>=</span> <span>sysbenchVersion</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> err
	<span>}</span>

	cwd<span>,</span> err <span>:=</span> os<span>.</span><span>Getwd</span><span>(</span><span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> err
	<span>}</span>

	<span>for</span> <span>_</span><span>,</span> serverConfig <span>:=</span> <span>range</span> config<span>.</span>Servers <span>{</span>
		<span>var</span> results Results
		<span>var</span> b Benchmarker
		<span>switch</span> serverConfig<span>.</span>Server <span>{</span>
		<span>case</span> Dolt<span>:</span>
			fmt<span>.</span><span>Println</span><span>(</span><span>&#34;Running dolt sysbench tests&#34;</span><span>)</span>
			b <span>=</span> <span>NewDoltBenchmarker</span><span>(</span>cwd<span>,</span> config<span>,</span> serverConfig<span>)</span>
		<span>case</span> Doltgres<span>:</span>
			fmt<span>.</span><span>Println</span><span>(</span><span>&#34;Running doltgres sysbench tests&#34;</span><span>)</span>
			b <span>=</span> <span>NewDoltgresBenchmarker</span><span>(</span>cwd<span>,</span> config<span>,</span> serverConfig<span>)</span>
		<span>case</span> MySql<span>:</span>
			fmt<span>.</span><span>Println</span><span>(</span><span>&#34;Running mysql sysbench tests&#34;</span><span>)</span>
			b <span>=</span> <span>NewMysqlBenchmarker</span><span>(</span>cwd<span>,</span> config<span>,</span> serverConfig<span>)</span>
		<span>case</span> Postgres<span>:</span>
			fmt<span>.</span><span>Println</span><span>(</span><span>&#34;Running postgres sysbench tests&#34;</span><span>)</span>
			b <span>=</span> <span>NewPostgresBenchmarker</span><span>(</span>cwd<span>,</span> config<span>,</span> serverConfig<span>)</span>
		<span>default</span><span>:</span>
			<span>panic</span><span>(</span>fmt<span>.</span><span>Sprintf</span><span>(</span><span>&#34;unexpected server type: %s&#34;</span><span>,</span> serverConfig<span>.</span>Server<span>)</span><span>)</span>
		<span>}</span>

		results<span>,</span> err <span>=</span> b<span>.</span><span>Benchmark</span><span>(</span>ctx<span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>return</span> err
		<span>}</span>

		fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;Successfuly finished %s\n&#34;</span><span>,</span> serverConfig<span>.</span>Server<span>)</span>

		err <span>=</span> <span>WriteResults</span><span>(</span>serverConfig<span>,</span> results<span>)</span>
		<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
			<span>return</span> err
		<span>}</span>

		fmt<span>.</span><span>Printf</span><span>(</span><span>&#34;Successfuly wrote results for %s\n&#34;</span><span>,</span> serverConfig<span>.</span>Server<span>)</span>
	<span>}</span>
	<span>return</span> <span>nil</span>
<span>}</span></code></pre></div>
</details>
<p>This function creates a <code>Benchmarker</code> based on the type of server it sees, then calls <code>Benchmark()</code>, which runs the Sysbench tests against that server. Here&#39;s an example of what Dolt Benchmarker&#39;s <code>Benchmark()</code> <a href="https://github.com/dolthub/dolt/blob/main/go/performance/utils/benchmark_runner/dolt.go">implementation</a> looks like:</p>
<details>
  <summary>Click to see code</summary>
<div data-language="go"><pre><code><span>func</span> <span>(</span>b <span>*</span>doltBenchmarkerImpl<span>)</span> <span>Benchmark</span><span>(</span>ctx context<span>.</span>Context<span>)</span> <span>(</span>Results<span>,</span> <span>error</span><span>)</span> <span>{</span>
	err <span>:=</span> b<span>.</span><span>checkInstallation</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	err <span>=</span> b<span>.</span><span>updateGlobalConfig</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	testRepo<span>,</span> err <span>:=</span> b<span>.</span><span>initDoltRepo</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	serverParams<span>,</span> err <span>:=</span> b<span>.</span>serverConfig<span>.</span><span>GetServerArgs</span><span>(</span><span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	server <span>:=</span> <span>NewServer</span><span>(</span>ctx<span>,</span> testRepo<span>,</span> b<span>.</span>serverConfig<span>,</span> syscall<span>.</span>SIGTERM<span>,</span> serverParams<span>)</span>
	err <span>=</span> server<span>.</span><span>Start</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	tests<span>,</span> err <span>:=</span> <span>GetTests</span><span>(</span>b<span>.</span>config<span>,</span> b<span>.</span>serverConfig<span>,</span> <span>nil</span><span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	results <span>:=</span> <span>make</span><span>(</span>Results<span>,</span> <span>0</span><span>)</span>
	<span>for</span> i <span>:=</span> <span>0</span><span>;</span> i <span>&lt;</span> b<span>.</span>config<span>.</span>Runs<span>;</span> i<span>++</span> <span>{</span>
		<span>for</span> <span>_</span><span>,</span> test <span>:=</span> <span>range</span> tests <span>{</span>
			tester <span>:=</span> <span>NewSysbenchTester</span><span>(</span>b<span>.</span>config<span>,</span> b<span>.</span>serverConfig<span>,</span> test<span>,</span> stampFunc<span>)</span>
			r<span>,</span> err <span>:=</span> tester<span>.</span><span>Test</span><span>(</span>ctx<span>)</span>
			<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
				server<span>.</span><span>Stop</span><span>(</span>ctx<span>)</span>
				<span>return</span> <span>nil</span><span>,</span> err
			<span>}</span>
			results <span>=</span> <span>append</span><span>(</span>results<span>,</span> r<span>)</span>
		<span>}</span>
	<span>}</span>

	err <span>=</span> server<span>.</span><span>Stop</span><span>(</span>ctx<span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>nil</span><span>,</span> err
	<span>}</span>

	<span>return</span> results<span>,</span> os<span>.</span><span>RemoveAll</span><span>(</span>testRepo<span>)</span>
<span>}</span></code></pre></div>
</details>
<p>During the <code>Benchmark()</code> call, this implementation will check the Dolt installation, update some global Dolt configuration, get the arguments used to start the Dolt SQL server, start the server, acquire the Sysbench tests it&#39;s going to run, then run those tests by calling <code>tester.Test()</code>.</p>
<p>When it&#39;s done, it returns the <code>results</code> and cleans up what it wrote to disk.</p>
<p>And, as we&#39;ve seen in the internal tool&#39;s <code>compare</code> function, these results are loaded into <code>sqlite3</code> and uploaded to S3 so they can be emailed to the DoltHub team. But, we&#39;re still missing one step—that is, triggering the &#34;Email team&#34; workflow with a <code>repository_dispatch</code> event after the internal benchmarking tool finishes uploading the results.</p>
<p>So the final piece of our internal tool includes:</p>
<div data-language="go"><pre><code>err <span>:=</span> d<span>.</span><span>DispatchEmailReportEvent</span><span>(</span>ctx<span>,</span> <span>*</span>toVersion<span>,</span> <span>*</span>nomsBinFormat<span>,</span> <span>*</span>bucket<span>,</span> key<span>)</span>
<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		log<span>.</span><span>Fatal</span><span>(</span>err<span>)</span>
<span>}</span></code></pre></div>
<p>The <code>DispatchEmailReportEvent()</code> method is on a <code>Dispatcher</code> interface we wrote. It simply makes an HTTP request to the <a href="https://docs.github.com/en/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event">GitHub Actions Workflow REST API</a> which emits the <code>repository_dispatch</code> event, triggering the &#34;Email team&#34; workflow to run. So let&#39;s look at that next.</p>
<p><img src="https://www.dolthub.com/blog/8a866860de44dedd4043b75ba6a3daf5/dolt_release_process_k8s_job_last_step.svg" alt="Diagram of Dolt Release Process Flow Highlighting K8s Sysbench Job to Email Team Workflow"/></p>
<p>Like the &#34;Deploy K8s Sysbench benchmarking Job&#34; workflow the &#34;Email team&#34; workflow is used by multiple processes besides the just Dolt release process, so that&#39;s why we trigger it with <code>repository_dispatch</code> events. The workflow file is as follows:</p>
<div data-language="yaml"><pre><code><span>name</span><span>:</span> Email Team Members

<span>on</span><span>:</span>
  <span>repository_dispatch</span><span>:</span>
    <span>types</span><span>:</span> <span>[</span> email<span>-</span>report <span>]</span>

<span>jobs</span><span>:</span>
  <span>email-team</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>name</span><span>:</span> Email Team Members
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> actions/checkout@v3
      <span>-</span> <span>name</span><span>:</span> Configure AWS Credentials
        <span>uses</span><span>:</span> aws<span>-</span>actions/configure<span>-</span>aws<span>-</span>credentials@v2.2.0
        <span>with</span><span>:</span>
          <span>aws-access-key-id</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_ACCESS_KEY_ID <span>}</span><span>}</span>
          <span>aws-secret-access-key</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_SECRET_ACCESS_KEY <span>}</span><span>}</span>
          <span>aws-region</span><span>:</span> us<span>-</span>west<span>-</span><span>2</span>
      <span>-</span> <span>name</span><span>:</span> Get Results
        <span>id</span><span>:</span> get<span>-</span>results
        <span>run</span><span>:</span> aws s3api get<span>-</span>object <span>-</span><span>-</span>bucket=&#34;$BUCKET&#34; <span>-</span><span>-</span>key=&#34;$KEY&#34; results.log
        <span>env</span><span>:</span>
          <span>KEY</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.key <span>}</span><span>}</span>
          <span>BUCKET</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.bucket <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> Get Addresses
        <span>id</span><span>:</span> get<span>-</span>addresses
        <span>run</span><span>:</span> <span>|</span><span>
          addresses=&#34;$TEAM&#34;
          if [ ! -z &#34;$RECIPIENT&#34; ]; then
            addresses=&#34;[\&#34;$RECIPIENT\&#34;]&#34;
          fi
          echo &#34;addresses=$addresses&#34; &gt;&gt; $GITHUB_OUTPUT</span>
        <span>env</span><span>:</span>
          <span>RECIPIENT</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.email_recipient <span>}</span><span>}</span>
          <span>TEAM</span><span>:</span> <span>&#39;[&#34;${{ secrets.PERF_REPORTS_EMAIL_ADDRESS }}&#34;]&#39;</span>
      <span>-</span> <span>name</span><span>:</span> Send Email
        <span>uses</span><span>:</span> ./.github/actions/ses<span>-</span>email<span>-</span>action
        <span>with</span><span>:</span>
          <span>template</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.template <span>}</span><span>}</span>
          <span>region</span><span>:</span> us<span>-</span>west<span>-</span><span>2</span>
          <span>version</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.version <span>}</span><span>}</span>
          <span>format</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.noms_bin_format <span>}</span><span>}</span>
          <span>toAddresses</span><span>:</span> $<span>{</span><span>{</span> steps.get<span>-</span>addresses.outputs.addresses <span>}</span><span>}</span>
          <span>dataFile</span><span>:</span> $<span>{</span><span>{</span> format(&#39;<span>{</span><span>0</span><span>}</span>/results.log&#39;<span>,</span> github.workspace) <span>}</span><span>}</span></code></pre></div>
<p>As shown in the diagram, the summary of this workflow is that it downloads the Sysbench results for the Dolt release and then sends them in an email to our team; nothing crazy.</p>
<p>And that&#39;s the Dolt release process. Or that <em>was</em> the Dolt release process. Now I&#39;ll go over how we updated this process to start building pgo binaries of Dolt on release.</p>

<p>For those unfamiliar with pgo builds, they require the <code>-pgo</code> flag with the path to a <a href="https://go.dev/blog/pprof">Golang profile</a> supplied during the <code>go build</code> command. That part is actually very simple. But prior to that, you need to create the profile you want to use for your optimized build, and this required us to update some of our benchmark library code, and our internal tool code, so that they could both <em>generate</em> a profile and <em>accept</em> a profile as input. Let me explain in more detail.</p>
<p>In our benchmarking library code, we use another Dolt utility called <a href="https://github.com/dolthub/dolt/tree/main/go/performance/utils/dolt_builder">dolt_builder</a> to actually build Dolt binaries from source. To use this tool, you simply provide the commit SHA or tag you want to build Dolt from, and it will build it for you. So we use this tool in a number of places for easily building multiple versions of Dolt simultaneously.</p>
<p>So the first thing we did was update this tool to accept a Golang profile it can use to build Dolt:</p>
<details>
  <summary>Click to see code</summary>
<div data-language="go"><pre><code>
<span>func</span> <span>goBuild</span><span>(</span>ctx context<span>.</span>Context<span>,</span> source<span>,</span> dest<span>,</span> profilePath <span>string</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
	goDir <span>:=</span> filepath<span>.</span><span>Join</span><span>(</span>source<span>,</span> <span>&#34;go&#34;</span><span>)</span>
	doltFileName <span>:=</span> <span>&#34;dolt&#34;</span>
	<span>if</span> runtime<span>.</span>GOOS <span>==</span> <span>&#34;windows&#34;</span> <span>{</span>
		doltFileName <span>=</span> <span>&#34;dolt.exe&#34;</span>
	<span>}</span>

	args <span>:=</span> <span>make</span><span>(</span><span>[</span><span>]</span><span>string</span><span>,</span> <span>0</span><span>)</span>
	args <span>=</span> <span>append</span><span>(</span>args<span>,</span> <span>&#34;build&#34;</span><span>)</span>

	<span>if</span> profilePath <span>!=</span> <span>&#34;&#34;</span> <span>{</span>
		args <span>=</span> <span>append</span><span>(</span>args<span>,</span> fmt<span>.</span><span>Sprintf</span><span>(</span><span>&#34;-pgo=%s&#34;</span><span>,</span> profilePath<span>)</span><span>)</span>
	<span>}</span>

	toBuild <span>:=</span> filepath<span>.</span><span>Join</span><span>(</span>dest<span>,</span> doltFileName<span>)</span>
	args <span>=</span> <span>append</span><span>(</span>args<span>,</span> <span>&#34;-o&#34;</span><span>,</span> toBuild<span>,</span> filepath<span>.</span><span>Join</span><span>(</span>goDir<span>,</span> <span>&#34;cmd&#34;</span><span>,</span> <span>&#34;dolt&#34;</span><span>)</span><span>)</span>

	build <span>:=</span> <span>ExecCommand</span><span>(</span>ctx<span>,</span> <span>&#34;go&#34;</span><span>,</span> args<span>...</span><span>)</span>
	build<span>.</span>Dir <span>=</span> goDir
	err <span>:=</span> build<span>.</span><span>Run</span><span>(</span><span>)</span>
	<span>if</span> err <span>!=</span> <span>nil</span> <span>{</span>
		<span>return</span> <span>&#34;&#34;</span><span>,</span> err
	<span>}</span>
	<span>return</span> toBuild<span>,</span> <span>nil</span>
<span>}</span></code></pre></div>
</details>
<p>The next thing we did was update the benchmark library code to run in a &#34;profiling&#34; mode. In the default mode, as described above, this code calls <code>Benchmark()</code> and returns the results. In the new &#34;profiling&#34; mode, the code calls <code>Profile()</code> on a <code>Profiler</code> interface:</p>
<div data-language="go"><pre><code><span>...</span>
		<span>case</span> Dolt<span>:</span>
			
			sc<span>,</span> ok <span>:=</span> serverConfig<span>.</span><span>(</span>ProfilingServerConfig<span>)</span>
			<span>if</span> ok <span>{</span>
				<span>if</span> <span>string</span><span>(</span>sc<span>.</span><span>GetServerProfile</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>&#34;&#34;</span> <span>{</span>
					fmt<span>.</span><span>Println</span><span>(</span><span>&#34;Profiling dolt while running sysbench tests&#34;</span><span>)</span>
					p <span>:=</span> <span>NewDoltProfiler</span><span>(</span>cwd<span>,</span> config<span>,</span> sc<span>)</span>
					<span>return</span> p<span>.</span><span>Profile</span><span>(</span>ctx<span>)</span>
				<span>}</span>
			<span>}</span>
<span>...</span></code></pre></div>
<p><code>Profile()</code> works similarly to <code>Benchmark()</code>, but creates a golang profile taken while running the Sysbench benchmarks. This allows us to easily generate profiles for Dolt we can use in our new release process.</p>
<p>We also update this library code to <em>accept</em> a profile as an input. That way we can supply it a profile, which it in turn will supply to <code>dolt_builder</code> to create a pgo binary, and then run Sysbench and output those results.</p>
<p>To clarify, we basically updated this library code so that we can run it in one mode to generate a Golang profile, and then run it in the default mode to get our normal benchmarking results, but it will also <em>accept</em> a Golang profile as input, and use that to build Dolt with the <code>go build -pgo</code> . Hopefully that makes sense to you, since it&#39;s a bit tricky for me to describe 🤠.</p>
<p>Moving on, we then needed to update our internal tool that uses all this library code to also have a &#34;profiling&#34; mode and accept Golang profiles as input. Our plan for the new release process was to run the internal tool once, in profiling mode, to create a Golang profile. Then, run the internal tool again in default mode, but supply the Golang profile back to it, which would produce the benchmarking results against a pgo built Dolt.</p>
<p>So, like the <code>compare</code> function, we were able to add a <code>profile</code> function to the internal tool that generates a Golang cpu profile of a Dolt version.</p>
<details>
  <summary>Click to see code</summary>
<div data-language="go"><pre><code><span>func</span> <span>profile</span><span>(</span>ctx context<span>.</span>Context<span>,</span> dir<span>,</span> profileDir<span>,</span> resultsDir<span>,</span> resultsPrefix<span>,</span> version<span>,</span> profile<span>,</span> doltCommand<span>,</span> scriptsDir <span>string</span><span>,</span> useDoltHubLuaScriptsRepo <span>bool</span><span>)</span> <span>(</span><span>string</span><span>,</span> <span>error</span><span>)</span> <span>{</span>
	config <span>:=</span> benchmark<span>.</span><span>NewProfilingConfig</span><span>(</span>
		dir<span>,</span>
		profileDir<span>,</span>
		version<span>,</span>
		profile<span>,</span>
		doltCommand<span>,</span>
		scriptsDir<span>,</span>
		useDoltHubLuaScriptsRepo<span>)</span>
	toUpload <span>:=</span> filepath<span>.</span><span>Join</span><span>(</span>resultsDir<span>,</span> resultsPrefix<span>)</span>
	sr <span>:=</span> benchmark<span>.</span><span>NewSysbenchProfiler</span><span>(</span>config<span>,</span> toUpload<span>,</span> profileDir<span>)</span>
	<span>return</span> toUpload<span>,</span> sr<span>.</span><span>Run</span><span>(</span>ctx<span>)</span>
<span>}</span></code></pre></div>
</details>
<p>This function returns its <code>toUpload</code> directory like <code>compare</code> does, but this time it contains the profile to be uploaded to S3.</p>
<p>After these changes to the code, we were ready to update our GitHub Actions workflows to start creating pgo releases of Dolt. Here&#39;s a diagram showing the new Dolt release process with GitHub Actions.</p>
<p><img src="https://www.dolthub.com/blog/3043e345e3d40dfdcad185a2001ff0f0/pgo_dolt_releases_process.svg" alt="Diagram of PGO Dolt Release Process Flow"/></p>
<p>As you can see from the new release workflow diagram we&#39;ve added some new GitHub Actions workflows, but they&#39;re similar to the original ones. Let&#39;s look more closely at them.</p>
<p>For the new Dolt release process, the first workflow we run, called &#34;Release Dolt (Profile)&#34;, does <em>not</em> actually create a GitHub release or build any Dolt binaries.</p>
<p>Instead, its only function is to trigger a second workflow called &#34;Deploy K8s Sysbench Profiling Job&#34;.</p>
<div data-language="yaml"><pre><code><span>name</span><span>:</span> Release Dolt (Profile)

<span>on</span><span>:</span>
  <span>workflow_dispatch</span><span>:</span>
    <span>inputs</span><span>:</span>
      <span>version</span><span>:</span>
        <span>description</span><span>:</span> <span>&#39;SemVer format release tag, i.e. 0.24.5&#39;</span>
        <span>required</span><span>:</span> <span>true</span>

<span>jobs</span><span>:</span>
  <span>format-version</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>outputs</span><span>:</span>
      <span>version</span><span>:</span> $<span>{</span><span>{</span> steps.format_version.outputs.version <span>}</span><span>}</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Format Input
        <span>id</span><span>:</span> format_version
        <span>run</span><span>:</span> <span>|</span><span>
          version=&#34;${{ github.event.inputs.version }}&#34;
          if [[ $version == v* ]];
          then
            version=&#34;${version:1}&#34;
          fi
          echo &#34;version=$version&#34; &gt;&gt; $GITHUB_OUTPUT</span>

  <span>profile-benchmark-dolt</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>needs</span><span>:</span> format<span>-</span>version
    <span>name</span><span>:</span> Trigger Benchmark Profile K8s Workflows
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> actions/checkout@v4
        <span>with</span><span>:</span>
          <span>ref</span><span>:</span> main
      <span>-</span> <span>name</span><span>:</span> Get sha
        <span>id</span><span>:</span> get_sha
        <span>run</span><span>:</span> <span>|</span><span>
          sha=$(git rev-parse --short HEAD)
          echo &#34;sha=$sha&#34; &gt;&gt; $GITHUB_OUTPUT</span>
      <span>-</span> <span>uses</span><span>:</span> peter<span>-</span>evans/repository<span>-</span>dispatch@v3
        <span>with</span><span>:</span>
          <span>token</span><span>:</span> $<span>{</span><span>{</span> secrets.REPO_ACCESS_TOKEN <span>}</span><span>}</span>
          <span>event-type</span><span>:</span> profile<span>-</span>dolt
          <span>client-payload</span><span>:</span> <span>&#39;{&#34;from_version&#34;: &#34;${{ steps.get_sha.outputs.sha }}&#34;, &#34;future_version&#34;: &#34;${{ needs.format-version.outputs.version }}&#34;, &#34;mode&#34;: &#34;release&#34;, &#34;actor&#34;: &#34;${{ github.actor }}&#34;, &#34;actor_email&#34;: &#34;dustin@dolthub.com&#34;, &#34;template_script&#34;: &#34;./.github/scripts/performance-benchmarking/get-dolt-profile-job-json.sh&#34;}&#39;</span></code></pre></div>
<p>The &#34;Deploy K8s Sysbench Profiling Job&#34; works almost identically to the &#34;Deploy K8s Sysbench Benchmarking Job&#34;, except it deploys a benchmarking Job running in &#34;profiling&#34; mode to the K8s cluster, so that we create a Golang profile using the <code>HEAD</code> of Dolt <code>main</code>.</p>
<div data-language="yaml"><pre><code><span>name</span><span>:</span> Profile Dolt while Benchmarking

<span>on</span><span>:</span>
  <span>repository_dispatch</span><span>:</span>
    <span>types</span><span>:</span> <span>[</span> profile<span>-</span>dolt <span>]</span>

<span>jobs</span><span>:</span>
  <span>performance</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>name</span><span>:</span> Profile Dolt while Benchmarking
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v4
      <span>-</span> <span>uses</span><span>:</span> azure/setup<span>-</span>kubectl@v4
        <span>with</span><span>:</span>
          <span>version</span><span>:</span> <span>&#39;v1.23.6&#39;</span>
      <span>-</span> <span>name</span><span>:</span> Install aws<span>-</span>iam<span>-</span>authenticator
        <span>run</span><span>:</span> <span>|</span><span>
          curl -o aws-iam-authenticator https://amazon-eks.s3.us-west-2.amazonaws.com/1.18.8/2020-09-18/bin/linux/amd64/aws-iam-authenticator &amp;&amp; \
          chmod +x ./aws-iam-authenticator &amp;&amp; \
          sudo cp ./aws-iam-authenticator /usr/local/bin/aws-iam-authenticator
          aws-iam-authenticator version</span>
      <span>-</span> <span>name</span><span>:</span> Configure AWS Credentials
        <span>uses</span><span>:</span> aws<span>-</span>actions/configure<span>-</span>aws<span>-</span>credentials@v4
        <span>with</span><span>:</span>
          <span>aws-access-key-id</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_ACCESS_KEY_ID <span>}</span><span>}</span>
          <span>aws-secret-access-key</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_SECRET_ACCESS_KEY <span>}</span><span>}</span>
          <span>aws-region</span><span>:</span> us<span>-</span>west<span>-</span><span>2</span>
      <span>-</span> <span>name</span><span>:</span> Create and Auth kubeconfig
        <span>run</span><span>:</span> <span>|</span><span>
          echo &#34;$CONFIG&#34; &gt; kubeconfig
          KUBECONFIG=kubeconfig kubectl config set-credentials github-actions-dolt --exec-api-version=client.authentication.k8s.io/v1alpha1 --exec-command=aws-iam-authenticator --exec-arg=token --exec-arg=-i --exec-arg=eks-cluster-1
          KUBECONFIG=kubeconfig kubectl config set-context github-actions-dolt-context --cluster=eks-cluster-1 --user=github-actions-dolt --namespace=performance-benchmarking
          KUBECONFIG=kubeconfig kubectl config use-context github-actions-dolt-context</span>
        <span>env</span><span>:</span>
          <span>CONFIG</span><span>:</span> $<span>{</span><span>{</span> secrets.CORP_KUBECONFIG <span>}</span><span>}</span>
      <span>-</span> <span>name</span><span>:</span> Create Profile Benchmarking K8s Job
        <span>run</span><span>:</span> ./.github/scripts/performance<span>-</span>benchmarking/run<span>-</span>benchmarks.sh
        <span>env</span><span>:</span>
          <span>PROFILE</span><span>:</span> <span>&#34;true&#34;</span>
          <span>FUTURE_VERSION</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.future_version <span>}</span><span>}</span>
          <span>FROM_VERSION</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.from_version <span>}</span><span>}</span>
          <span>MODE</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.mode <span>}</span><span>}</span>
          <span>ACTOR</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.actor <span>}</span><span>}</span>
          <span>ACTOR_EMAIL</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.actor_email <span>}</span><span>}</span>
          <span>REPO_ACCESS_TOKEN</span><span>:</span> $<span>{</span><span>{</span> secrets.REPO_ACCESS_TOKEN <span>}</span><span>}</span>
          <span>KUBECONFIG</span><span>:</span> <span>&#34;./kubeconfig&#34;</span>
          <span>INIT_BIG_REPO</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.init_big_repo <span>}</span><span>}</span>
          <span>NOMS_BIN_FORMAT</span><span>:</span> <span>&#34;__DOLT__&#34;</span>
          <span>TEMPLATE_SCRIPT</span><span>:</span> $<span>{</span><span>{</span> github.event.client_payload.template_script <span>}</span><span>}</span></code></pre></div>
<p>Once the benchmarking K8s Job is running in &#34;profiling&#34; mode, we can see the steps it performs in our updated diagram. We also see that the output of this Job is a fresh Golang profile, uploaded to S3, that&#39;s ready to be used by the remaining steps of our process to create pgo builds.</p>
<p>At the end of the profiling K8s Job, after uploading the profile, it triggers the &#34;Release Dolt&#34; workflow. This workflow works basically the same as the original &#34;Release Dolt&#34; workflow, except that its first step is <em>downloading</em> the Golang Profile that the profiling Job uploaded.</p>
<div data-language="yaml"><pre><code><span>...</span>
  <span>create-pgo-release</span><span>:</span>
    <span>needs</span><span>:</span> format<span>-</span>version
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>name</span><span>:</span> Release PGO Dolt
    <span>outputs</span><span>:</span>
      <span>release_id</span><span>:</span> $<span>{</span><span>{</span> steps.create_release.outputs.id <span>}</span><span>}</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>uses</span><span>:</span> actions/checkout@v4
        <span>with</span><span>:</span>
          <span>ref</span><span>:</span> main
      <span>-</span> <span>name</span><span>:</span> Set up Go 1.x
        <span>uses</span><span>:</span> actions/setup<span>-</span>go@v5
        <span>with</span><span>:</span>
          <span>go-version-file</span><span>:</span> go/go.mod
      <span>-</span> <span>name</span><span>:</span> Configure AWS Credentials
        <span>uses</span><span>:</span> aws<span>-</span>actions/configure<span>-</span>aws<span>-</span>credentials@v4
        <span>with</span><span>:</span>
          <span>aws-access-key-id</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_ACCESS_KEY_ID <span>}</span><span>}</span>
          <span>aws-secret-access-key</span><span>:</span> $<span>{</span><span>{</span> secrets.AWS_SECRET_ACCESS_KEY <span>}</span><span>}</span>
          <span>aws-region</span><span>:</span> us<span>-</span>west<span>-</span><span>2</span>
      <span>-</span> <span>name</span><span>:</span> Get Results
        <span>id</span><span>:</span> get<span>-</span>results
        <span>run</span><span>:</span> aws s3api get<span>-</span>object <span>-</span><span>-</span>bucket=&#34;$BUCKET&#34; <span>-</span><span>-</span>key=&#34;$KEY&#34; dolt<span>-</span>cpu<span>-</span>profile.pprof
        <span>env</span><span>:</span>
          <span>KEY</span><span>:</span> $<span>{</span><span>{</span> github.event.inputs.profile_key <span>|</span><span>|</span> github.event.client_payload.profile_key <span>}</span><span>}</span>
          <span>BUCKET</span><span>:</span> $<span>{</span><span>{</span> github.event.inputs.profile_bucket <span>|</span><span>|</span> github.event.client_payload.bucket <span>}</span><span>}</span>
<span>...</span></code></pre></div>
<p>It then supplies the downloaded profile, here called <code>dolt-cpu-profile.pprof</code> to the <code>buildbinaries.sh</code> script, which runs <code>go build -pgo=./dolt-cpu-profile.pprof</code>, which compiles the new Dolt binaries. Then, like the original version of the workflow, it creates a GitHub release and uploads these binaries as release assets.</p>
<p>Before completing, one of the final jobs in this workflow kicks off another benchmarking K8s Job, only <em>this</em> time supplying the job with the S3 key to the Golang profile it used to build the Dolt binaries.</p>
<div data-language="yaml"><pre><code><span>...</span>
  <span>trigger-performance-benchmark-email</span><span>:</span>
    <span>needs</span><span>:</span> <span>[</span>format<span>-</span>version<span>,</span> create<span>-</span>pgo<span>-</span>release<span>]</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span><span>22.04</span>
    <span>steps</span><span>:</span>
      <span>-</span> <span>name</span><span>:</span> Trigger Performance Benchmarks
        <span>uses</span><span>:</span> peter<span>-</span>evans/repository<span>-</span>dispatch@v3
        <span>with</span><span>:</span>
          <span>token</span><span>:</span> $<span>{</span><span>{</span> secrets.REPO_ACCESS_TOKEN <span>}</span><span>}</span>
          <span>event-type</span><span>:</span> release<span>-</span>dolt
          <span>client-payload</span><span>:</span> <span>&#39;{&#34;version&#34;: &#34;${{ needs.format-version.outputs.version }}&#34;, &#34;actor&#34;: &#34;${{ github.actor }}&#34;, &#34;profile_key&#34;: &#34;${{ github.event.inputs.profile_key || github.event.client_payload.profile_key }}&#34;}&#39;</span></code></pre></div>
<p>This deploys a benchmarking Job to our K8s cluster once again, but now the Job will download the Golang profile from S3 and use it to construct pgo binaries of Dolt to use for benchmarking and producing results.</p>
<p>And we can see from the diagram in the K8s context, the final step of this second benchmarking Job kicks off the &#34;Email team&#34; workflow, so that our team gets the benchmarking results for the now pgo&#39;d Dolt.</p>
<p>And so we&#39;ve done it! We are now releasing pgo builds of Dolt.</p>

<p>As you can see there&#39;s a bit of complexity involved in updating a release process to produce pgo binaries, at least that was the case for us. But the effort was definitely worth the performance gains we&#39;ve seen.</p>
<p>I hope you found this helpful for your own endeavors, and we encourage you to try updating your releases as well. If you do, we&#39;d love to hear about it. Come by and share your experience on our <a href="https://discord.gg/gqr7K4VNKe">Discord</a>.</p>
<p>Also, don&#39;t forget to check out each of our different product offerings below:</p>
<ul>
<li><a href="http://www.doltdb.com">Dolt</a>—it&#39;s Git for data.</li>
<li><a href="https://www.dolthub.com">DoltHub</a>—it&#39;s GitHub for data.</li>
<li><a href="https://www.doltlab.com">DoltLab</a>—it&#39;s GitLab for data.</li>
<li><a href="https://hosted.doltdb.com/">Hosted Dolt</a>—it&#39;s RDS for Dolt databases.</li>
</ul></div></div>
  </body>
</html>
