<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.lesswrong.com/posts/vfRpzyGsikujm9ujj/a-brief-history-of-computers">Original</a>
    <h1>A brief history of computers</h1>
    
    <div id="readability-page-1" class="page"><div><div><div><p id="block0">Recently I&#39;ve been learning about the history of computers. I find it to be incredibly interesting. I&#39;d like to write a post about it to summarize and comment on what I&#39;ve learned.</p><p id="block1">I&#39;m a little hesitant though. I&#39;m no expert on this stuff. I&#39;m largely learning about it all for the first time. So then, take all of this with a grain of salt.<span role="doc-noteref" id="fnreffnnmpm5aqm7"><sup><a href="#fnfnnmpm5aqm7">[1]</a></sup></span> It&#39;s more of a conversation starter than a finished product. If you want something authoritative, I&#39;d recommend the <a href="https://plato.stanford.edu/index.html">Stanford Encyclopedia of Philosophy</a>.</p><p id="block2">Let&#39;s start with logic. Computers are largely based on boolean logic. Y&#39;know, 1s and 0s. AND, OR, NOT.</p><p id="block3">George Boole did a bunch of important work here in the mid 1800s, but let&#39;s try backing up even further. Was there anything important that came before Boolean logic?</p><p id="block4">Yeah, there was. It goes all the way back to Aristotle in ~350 BCE. Aristotle did a bunch of groundbreaking work in the field of logic.</p><p id="block5">Furthermore, after &#34;breaking the ground&#34;, there weren&#39;t any significant developments until the mid 1800s. Wow! That&#39;s a long time. An unusually long time. In other fields like mathematics, natural sciences, literature and engineering, there were significant advances. I wonder why things in the field of logic were so quiet.</p><p id="block6">Anyway, let&#39;s talk about what exactly Aristotle did. In short, he looked at arguments <i>in the abstract</i>. It&#39;s one thing to say that:</p><pre><code>All dogs have feet
Filo is a dog
Therefore, Filo has feet</code></pre><p id="block7">It&#39;s another thing to say that:</p><pre><code>All P have Q
R is a P
Therefore, R has Q</code></pre><p id="block8">The former is <i>concrete</i>. It&#39;s talking about dogs, feet and Filo. The latter is <i>abstract</i>. It&#39;s talking about P&#39;s, Q&#39;s and R&#39;s. Do you see the difference?</p><p id="block9">Before Aristotle, people never<span role="doc-noteref" id="fnref670ohjfvvuc"><sup><a href="#fn670ohjfvvuc">[2]</a></sup></span> thought about this stuff in terms of P&#39;s and Q&#39;s. They just thought about dogs and feet. Thinking about P&#39;s and Q&#39;s totally opened things up. Pretty cool. Abstraction is powerful. I think this is very much worth noting as an important milestone in the history of computers.</p><p id="block10">Ok. So once Aristotle opened the flood gates with categorical logic, over time, people kinda piggybacked off of it and extended his work. For example, the Stoics did a bunch of work with propositional logic.</p><p id="block11">Propositional logic is different from categorical logic. Categorical logic is about what categories things belong to. For example, earlier we basically said that dogs belong to the category of &#34;things with feet&#34; and that Filo belongs to the category of &#34;dogs&#34;. With those two statements, we deduced that Filo must also belong to the category of &#34;things with feet&#34;. It makes a lot of sense when you think about it visually:</p><figure><img src="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png" srcset="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_250 250w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_500 500w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_750 750w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_1000 1000w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_1250 1250w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_1500 1500w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_1750 1750w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_2000 2000w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_2250 2250w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/c57999325bc3b993c35e30d580fedceaede559951af156e1.png/w_2448 2448w"/></figure><p id="block12">On the other hand, propositional logic is about things being true or false. For example, with this:</p><pre><code>It is raining
I don&#39;t have an umbrella</code></pre><p id="block13">we can deduce things like:</p><pre><code>&#34;It is raining and I have an umbrella&#34; is false
&#34;It is raining or I have an umbrella&#34; is true</code></pre><p id="block14">Propositional logic is about truth and uses operators like AND, OR, NOT, IF-THEN, and IF-AND-ONLY-IF. Categorical logic is about categories and uses operators like ALL, NO and SOME.</p><p id="block15">After propositional logic, subsequent work was done. For example, predicate logic kinda piggybacked off of propositional logic. But in general, nothing too crazy was going on. Let&#39;s jump ahead to the mid 1800s and George Boole.</p><p id="block16">Boole introduced stuff like this: </p><pre><code>p is true
q is false
therefore
  (p and q) is false
  (p or q) is true
  (not (p and q)) is true
  ...</code></pre><p id="block17">But wait a minute. I&#39;m confused. Didn&#39;t we get that sort of thing from propositional logic all the way back in 300 BCE from the Stoics? In researching this question I&#39;m seeing things saying that it did in fact already exist, it&#39;s just that Boole made it more &#34;systematic and formalized&#34;. I don&#39;t understand though. In what way did he made it more systematic and formalized?</p><p id="block18">Oh well. Suffice it to say that boolean logic was a thing that we knew about. Let&#39;s move on.</p><p id="block19">I was going to start talking about Charles Babbage, but I started wondering whether anything came before him. Turns out that something did: the Jacquard loom.<span role="doc-noteref" id="fnrefhh6cjw29uj"><sup><a href="#fnhh6cjw29uj">[3]</a></sup></span></p><p id="block20">Let me provide some context. Weaving is a thing. Maybe that doesn&#39;t need to be said, but I at least had to look up what weaving is. Basically, if you want to produce fabric or cloth — ie. for clothing or bed sheets — you&#39;d have to interlace yarn or thread. That&#39;s called weaving.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Warp_and_weft_2.jpg/220px-Warp_and_weft_2.jpg" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Warp_and_weft_2.jpg/330px-Warp_and_weft_2.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/5/5e/Warp_and_weft_2.jpg 2x"/></figure><p id="block21">Up until the Industrial Revolution in the mid 1700s, weaving was done by hand. It was a very labor intensive process. Which means that the resulting products were somewhat expensive. The Invisible Hand doesn&#39;t like that, and so in the Industrial Revolution, people created weaving machines.</p><p id="block22">But they were kinda static. What if things were dynamic? What if you were able to program the machine to produce fabrics with different colors and patterns?</p><p id="block23">Enter: the Jacquard loom. The Jacquard loom was a weaving machine that let you do this. You&#39;d provide it with punch cards and the punch cards would determine what colors and patterns the fabric would have.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/0/09/Jacquard.loom.cards.jpg" alt="https://upload.wikimedia.org/wikipedia/commons/0/09/Jacquard.loom.cards.jpg"/><figcaption>Close-up of a <a href="https://en.wikipedia.org/wiki/Jacquard_loom">Jacquard loom</a>&#39;s chain, constructed using 8 × 26 hole punched cards</figcaption></figure><p id="block24">If you think about it, the people who operated these machines were probably the first programmers. After all, they were providing encoded instructions to a machine in order to get the machine to do something they want. Something useful. </p><p id="block25">Pretty cool, right? Charles Babbage sure thought so.</p><p id="block26">Charles Babbage — <a href="https://en.wikipedia.org/wiki/Charles_Babbage#">considered</a> by some to be the &#34;father of the computer&#34; — was inspired by the Jacquard loom. </p><p id="block27"><span>But let&#39;s back up and get some </span><a href="https://en.wikipedia.org/wiki/Charles_Babbage#Background_on_mathematical_tables"><span>context</span></a><span> first. The year was 1812, and </span><a href="https://en.wikipedia.org/wiki/Mathematical_table"><span>mathematical tables</span></a><span> were a thing.</span></p><p id="block28"><span>What are mathematical tables, you ask? Imagine that you need to do some </span><a href="https://genius.com/163612"><span>trigonometry</span></a><span>. What&#39;s </span><code><span>sin(79)</span></code><span>?</span></p><p id="block29"><span>Well, today you&#39;d just look it up online. 15 years ago you&#39;d probably grab your TI-84 calculator. But in the year 1812, you&#39;d have to consult a mathematical table. Something like this:</span></p><figure><span></span><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Abramowitz%26Stegun.page97.agr.jpg/220px-Abramowitz%26Stegun.page97.agr.jpg" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Abramowitz%26Stegun.page97.agr.jpg/330px-Abramowitz%26Stegun.page97.agr.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Abramowitz%26Stegun.page97.agr.jpg/440px-Abramowitz%26Stegun.page97.agr.jpg 2x"/><span></span></figure><p id="block30"><span>They&#39;d use </span><a href="https://en.wikipedia.org/wiki/Computer_(occupation)"><span>computers</span></a><span> to compute all the values and write them down in books. Just not the type of computers you&#39;re probably thinking of. No, they&#39;d use </span><i><span>human</span></i><span> computers.</span></p><figure><span></span><img src="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png" srcset="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_180 180w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_360 360w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_540 540w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_720 720w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_900 900w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_1080 1080w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_1260 1260w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_1440 1440w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_1620 1620w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/d92fdd559db895dde8294e9d0350c529134d8aae9f5a28d3.png/w_1746 1746w"/><span></span></figure><p id="block31">Yup, that&#39;s right. Back then, real human beings would sit in a room doing a bunch of math to come up with all of these values.<span role="doc-noteref" id="fnrefw4th04rh1w8"><sup><a href="#fnw4th04rh1w8">[4]</a></sup></span></p><p id="block32">Babbage didn&#39;t like this though. It was too error prone. Too labor intensive. He wanted to make it less error prone and less labor intensive.</p><p id="block33">His first step towards this was to make the computations simpler. That way you can employ some relatively unskilled people to do addition and subtraction for you. Traditionally you&#39;d need to employ skilled people to do more complex math. From his <a href="https://en.wikipedia.org/wiki/Charles_Babbage#Background_on_mathematical_tables">own account</a>:</p><blockquote id="block34"><p id="block35">In 1812 he was sitting in his rooms in the Analytical Society looking at a table of logarithms, which he knew to be full of mistakes, when the idea occurred to him of computing all tabular functions by machinery. The French government had produced several tables by a new method. Three or four of their mathematicians decided how to compute the tables, half a dozen more broke down the operations into simple stages, and the work itself, which was restricted to addition and subtraction, was done by eighty computers who knew only these two arithmetical processes. Here, for the first time, mass production was applied to arithmetic, and Babbage was seized by the idea that the labours of the unskilled computers [people] could be taken over completely by machinery which would be quicker and more reliable.</p></blockquote><p id="block36">Babbage <a href="https://youtu.be/YwqltwvPnkw?t=1016">came up with</a> an organizational structure that became standard for other computing groups:</p><figure><img src="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png" srcset="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_110 110w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_220 220w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_330 330w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_440 440w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_550 550w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_660 660w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_770 770w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_880 880w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_990 990w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/eb2f5ed7621c8590dcb9ee35210154cf2a869a3ca63bd666.png/w_1074 1074w"/></figure><p id="block37">First the scientist would come up with the thing they wanted to compute. Then there was a planner who would come up with a way to break the computation down into a bunch of simple parts. Finally, the planner would tell various (human) computers to work on these simple tasks. Similar to how a senior software engineer today will break a project down into various tasks and assign those tasks to some junior engineers.</p><p id="block38">Ten years later, Babbage started working on the Difference Engine. A machine that can do the necessary computations to construct mathematical tables for polynomial functions. It was the era of the Industrial Revolution, after all. Why pay for human labor when you can instead build machines?</p><p id="block39">By the way, the name &#34;Difference Engine&#34; comes from the fact that it <a href="https://en.wikipedia.org/wiki/Difference_engine#Method_of_differences">used</a> Newton&#39;s method of finite differences. With this method, the machine didn&#39;t have to do any multiplication or division, which I assume made the mechanical stuff easier.</p><p id="block40">Unfortunately, Babbage never completed the Difference Engine. He had a bunch of cool blueprints and designs, but he was never able to actually finish building it. Partly due to issues with funding.</p><p id="block41">However, using Babbage&#39;s designs, people in the 1990s constructed the Difference Engine. It is on display today at the Science Museum in London.</p><figure><div data-oembed-url="https://www.youtube.com/watch?v=be1EM3gQkAY"><p><iframe src="https://www.youtube.com/embed/be1EM3gQkAY" allow="autoplay; encrypted-media" allowfullscreen=""></iframe></p></div></figure><p id="block42">It wasn&#39;t just a lack of funds though that pulled Babbage away from the Difference Engine. No. He was also seduced by visions of the Analytical Engine.</p><p id="block43">The Difference Engine was just too narrowly scoped. It was used for polynomial functions. But what about other things that need to be computed? In particular, mathematical tables for things like trigonometry and logarithms. Wouldn&#39;t it be cool if there was a machine that was able to compute all of that stuff?</p><p id="block44">And that was the motivation behind the Analytical Engine. The desire for a general purpose computing device. There was a big demand for mathematical tables at the time, so if you had a device that was capable of computing anything you want it to compute... on demand... well, that&#39;d be pretty game changing.</p><p id="block45">But Babbage was playing the wrong game. To be fair, he wasn&#39;t alone. Everyone else&#39;s focus was also on using these sorts of machines to do math. However, Babbage was fortunate enough to recognize the genius of and collaborate with a talented young woman in her early 20s named Ada Lovelace, and Lovelace saw this machine as something that was <i>way</i> more than a mere calculator.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Ada_Lovelace_portrait.jpg/220px-Ada_Lovelace_portrait.jpg" alt="Ada King, Countess of Lovelace. Watercolour portrait circa 1840" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Ada_Lovelace_portrait.jpg/330px-Ada_Lovelace_portrait.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Ada_Lovelace_portrait.jpg/440px-Ada_Lovelace_portrait.jpg 2x"/></figure><p id="block46">She saw it as something to be used for generating music. Art. Translating languages. Science. Poetry. She even envisioned it as something that can perform automated reasoning and deduction.</p><p id="block47">Music? Art? Language?</p><p id="block48">...</p><p id="block49">...</p><p id="block50">What???? How the hell...</p><p id="block51">...</p><p id="block52">...</p><p id="block53">...</p><p id="block54">I know, I know. This is what everyone else thought at the time too. It&#39;s the intuitive thing to think. The machine does stuff with <i>numbers</i>. How can something that operates on <i>numbers</i> be used for <i>music and art</i>? Well, let me introduce you to what I&#39;m starting to suspect is <i>the</i> key idea in computer science: encoding.</p><p id="block55">Let&#39;s start with language. I think that&#39;s an easy one to understand.</p><p id="block56">Suppose that <code>00000</code> represents the letter &#34;a&#34;, <code>00001</code> represents the letter &#34;b&#34;, <code>00010</code> represents the letter &#34;c&#34;, <code>00011</code> represents the letter &#34;d&#34;, so on and so forth. Well, that implies that the word &#34;apple&#34; can be represented as <code>00000 00111 00111 00110 00101</code>.</p><pre><code>a: 00000
p: 00111
p: 00111
l: 00110
e: 00101</code></pre><p id="block57">It also implies that the word &#34;manzana&#34; can be represented as <code>01000 00000 01001 01111 00000 01001 00000</code>.</p><pre><code>m: 01000
a: 00000
n: 01001
z: 01111
a: 00000
n: 01001
a: 00000</code></pre><p id="block58">Ok. Well, with that, suppose you wanted to have the computer translate English words into Spanish for you. How would you program it to do that?</p><p id="block59">Easy. You&#39;d write instructions that basically say something along the lines of:</p><blockquote id="block60"><p id="block61">Whenever you see <code>00000 00111 00111 00110 00101</code> (&#34;apple&#34;), replace it with <code>01000 00000 01001 01111 00000 01001 00000</code> (&#34;manzana&#34;).</p></blockquote><p id="block62">Do you see? By using this 5-bit encoding system, the computer is now able to do stuff with <i>language</i>, not just with numbers.</p><p id="block63">I&#39;m telling you, encoding is a crucial idea.</p><p id="block64">Now what if we wanted the computer to make music for us? How would we get it to do that? Well... we&#39;d have to take advantage of encoding again.</p><p id="block65">How do we encode <i>music?</i> I dunno. Let&#39;s play around and try to figure it out.</p><p id="block66">Suppose there are seven notes: A through G. We&#39;ll use three bits to encode them.</p><pre><code>A: 000
B: 001
C: 010
D: 011
E: 100
F: 101
G: 110</code></pre><p id="block67">Suppose that notes can be either flat, sharp or normal. We&#39;ll use two bits to encode this.</p><pre><code>Flat: 00
Sharp: 01
Normal: 10</code></pre><p id="block68">Suppose there are, I dunno, ten possible octaves. We&#39;ll have to use four bits to encode the octave.</p><pre><code>1: 0000
2: 0001
3: 0010
4: 0011
5: 0100
6: 0101
7: 0110
8: 0111
9: 1000
10: 1001</code></pre><p id="block69">With that, a C-sharp in the third octave would be encoded as <code>010 01 0010</code>.</p><ul><li id="block70"><code>010</code> = C</li><li id="block71"><code>01</code> = Sharp</li><li id="block72"><code>0010</code> = Third octave</li><li id="block73"><code>010 01 0010</code> = C-sharp in the third octave</li></ul><p id="block74">Ok. Now how would we have the computer compose a song? Well, just move those 1s and 0s around! Something like &#34;start with a C-sharp in the third octave, then keep going up two octaves, down one, and cycle back to the lowest octave if you get too high&#34;. Boom: it&#39;s a computer generated song.</p><p id="block75">Unfortunately, nothing ever came of the Analytical Engine. The team had trouble building it. Funding was scarce. People didn&#39;t see the vision. It wouldn&#39;t have been fast enough to do useful things anyway. Etc, etc. Babbage had the designs, but they just weren&#39;t able to get it done.</p><p id="block76">Oh, it&#39;s also worth noting that the proposed architecture of the Analytical Engine really mirrored the architecture of modern day computers. Inspired by the Jacquard loom, the instructions were stored in memory so that you could program it. It had something analogous to a CPU. Control flow. I/O. Etc.</p><p id="block77">Ada Lovelace wrote a lot about the significance of general purpose computers. That they could be used for things like art and music and would transform many industries. Unfortunately, that work was never circulated or recognized during her lifetime. People weren&#39;t into these general purpose computers. They just wanted their mathematical tables.</p><p id="block78">Well, I&#39;m actually not even so sure of that. I mean, mathematical tables were really important. There was a large demand for them. Lots of people worked hard at producing many volumes of them. But it wasn&#39;t until the 1940s and the advent of the electronic computer that they actually built a machine that was used to construct mathematical tables.</p><p id="block79">I&#39;m confused though. Babbage came up with the blueprints for his Difference Engine in the 1820s. I know he never succeeded at actually building it, but he never really had a fair chance if you ask me. If he had a team of thousands of people working for him, that&#39;d be one thing, but he only ever had the budget for a few other engineers and craftsmen to help him. It was much more akin to a guy in his garage with a few buddies than an organization with a real R&amp;D budget. It seems to me like if he had, I don&#39;t know, dozens, maybe hundreds of people working for him, they would have been able to actually build the Difference Engine.</p><p id="block80">And from what ChatGPT tells me, it&#39;s likely that this would have been an investment with a positive ROI. It&#39;d make the construction of mathematical tables significantly faster and more reliable, and there was a big demand for such tables. It makes sense to me that it&#39;d be a worthwhile investment. After all, they were already employing similar numbers of people to construct the tables by hand.</p><p id="block81">Anyway, it turns out that not much was really going on. Babbage worked on his stuff and failed. A few others were also working on similar projects but overall the amount of work being done on such machines was pretty limited.</p><p id="block82">Until the very end of the century, that is. In the late 1880s, a man named Herman Hollerith invented the Hollerith Machine. I think it&#39;s best understood by talking about it&#39;s first project: the 1890 US Census.</p><p id="block83">To produce a US Census, representatives have to go door-to-door and get citizens to fill out paperwork. Stuff like how many people are in the household, how old they are, male vs female, occupation, etc.</p><p id="block84">So far so good, right? Ok. Now imagine that you wanted to use this data to answer some questions. What percentage of households make over $1,000/year? What is the average salary of a baker? Which state has the lowest average annual salary? Which county?</p><p id="block85">It&#39;d be pretty damn tedious to answer these sorts of questions, right? You&#39;d have to go through all of the paperwork. Like for the average salary of a baker, maybe you&#39;d first go through all the papers and put the papers containing people who are employed as a baker in one pile, and then go through that pile and compute the average salary. That&#39;d definitely be a pain.</p><p id="block86">Well, Hollerith had a solution to this. You still have to go door-to-door and fill out all of the paperwork. But then you employ people to take that paperwork and fill out a punch card for each citizen. The punch card would encode stuff like salary and occupation.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/Hollerith_Punched_Card.jpg" alt="undefined"/></figure><p id="block87">Then you can feed these punch cards into the Hollerith Machine and get answers to your questions. How many doctors are there in our county? How much do they make? Etc. As you might imagine, this was a pretty big breakthrough.</p><p id="block88">People started to pay attention. Businesses were like, &#34;Hey, we could use this to construct reports.&#34; Scientists were like, &#34;Hey, we could use this to process our data.&#34;</p><p id="block89">Noticing this, in 1896, Hollerith formed the Tabulating Machine Company.</p><p id="block90">Then in 1911, four large firms, including the Tabulating Machine Company, merged to form the Computing-Tabulating-Recording Company.</p><p id="block91">In 1924 the Computing-Tabulating-Recording Company changed it&#39;s name to International Business Machines Corporation, which you probably have heard referred to today as IBM.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/51/IBM_logo.svg/180px-IBM_logo.svg.png" alt="IBM logo.svg" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/5/51/IBM_logo.svg/270px-IBM_logo.svg.png 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/5/51/IBM_logo.svg/360px-IBM_logo.svg.png 2x"/></figure><p id="block92">In the 1950s, with the invention of the electronic computer, tabulating machines started to take a back seat. In the 1960s some organizations still used them but they weren&#39;t common. By the 1970s and 1980s, they were basically dead.</p><p id="block93">This whole journey started with me wanting to understand what the big ideas are in computer science and how they developed over time. If you look into this sort of question, you&#39;ll usually find that people start with Babbage, or perhaps Boole, but soon after that they move on to Turing. They really emphasize his work as being super important and foundational.</p><p id="block94">However, I&#39;m not sure how justified that really is. At least from the perspective of someone who isn&#39;t a theoretical computer science researcher and is just trying to see what the big picture looks like.</p><p id="block95">But I&#39;m getting ahead of myself here. Let&#39;s take a step back and go through this more slowly.</p><p id="block96">Turing did a lot of his work in the 1930s. But again, let&#39;s continue to back up. Before talking about that work, I think that it&#39;s important to understand a few things about the context in which he did his work. I like the way <a href="https://cs.stackexchange.com/a/91775/30105">this StackExchange answer</a> puts it:</p><blockquote id="block97"><p id="block98">...remember that Turing was working <i>before</i> computers existed. As such, he wasn&#39;t trying to codify what electronic computers do but, rather, computation in general. My parents have a dictionary from the 1930s that defines computer as &#34;someone who computes&#34; and this is basically where Turing was coming from: for him, at that time, computation was about slide rules, log tables, pencils and pieces of paper. In that mind-set, rewriting symbols on a paper tape doesn&#39;t seem like a bad abstraction.</p></blockquote><p id="block99">Piggybacking off of that, I&#39;d like to emphasize that Turing&#39;s fields of interest were mathematics and logic. That was the lens through which he peered. He wasn&#39;t looking through a computer-oriented lens.</p><p id="block100">To elaborate, in the early 20th century, there was a guy named David Hilbert who was unhappy with the state of mathematics. Mathematicians would always seem to run into these weird paradoxes and seemingly unavoidable contradictions. So then, in response to these issues, Hilbert&#39;s thought process went something like this:</p><blockquote id="block101"><p id="block102">Guys, I really want to take a step back here. Us mathematicians, we&#39;ve got our axioms. We&#39;ve got our rules of inference. With these axioms and rules of inference, we should be able to prove all possible mathematical truths. There shouldn&#39;t be any contradictions or ambiguity or uncertainty.</p><p id="block103">I&#39;m not sure if we actually have this foundation though. Maybe we&#39;re missing certain axioms. Maybe the rules of inference we&#39;re using are unjustified. I say we should pursue a rock-solid foundation.</p><p id="block104">Once we have the foundation, <i>then</i> we can continue our other work. But it seems a little premature to be pursuing this other work when we&#39;re not sure about the actual axioms and rules of inference that our other work is based off of. When you build on top of a shaky foundation, you risk everything coming crashing down.</p></blockquote><figure><img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fimages-cdn.9gag.com%2Fphoto%2FayDqMbX_700b.jpg&amp;f=1&amp;nofb=1&amp;ipt=48cb0510c0903813554bcaa92b7a6131bd0774caff484a05c531983d8b45c6a6&amp;ipo=images" alt="A jenga structure I made. It was pretty easy. - 9GAG"/></figure><p id="block105">So, yeah. Hilbert kinda went around <a href="https://plato.stanford.edu/entries/hilbert-program/">complaining out loud</a> about all of this.</p><p id="block106">And it worked. People like Kurt Godel, Alan Turing and John von Neumann not only listened, but were inspired and took action.</p><p id="block107">Godel worked with Hilbert, joining his pursuit. Unfortunately, along this pursuit, Godel discovered something a little unsettling. He discovered that they were doomed to fail.</p><p id="block108">I&#39;m not joking. I&#39;m not exaggerating. They were doomed to fail.</p><p id="block109">It&#39;s not what Godel was hoping for. Godel was hoping to add some support to that shaky Jenga piece at the bottom so that they could continue building their beautiful tower taller and taller, consisting of structures ever more elegant. Instead, he ended up proving that it was literally impossible.</p><p id="block110">Talk about the <a href="https://www.lesswrong.com/posts/7ZqGiPHTpiDMwqMN2/twelve-virtues-of-rationality">second virtue</a>.</p><p id="block111">This really shook things up for mathematicians. It was a huge — and perhaps existentially threatening — discovery.</p><p id="block112">And that&#39;s when Turing walked up to Hilbert and was like:</p><blockquote id="block113"><p id="block114"><strong>Turing:</strong> Hey buddy. You ok?</p><p id="block115"><strong>Hilbert:</strong> Yeah, I guess.</p><p id="block116"><strong>Turing:</strong> You are? Good. Because I&#39;m about to pour some salt in that wound.</p></blockquote><p id="block117">He continued:<span role="doc-noteref" id="fnrefp7yc34fwgw"><sup><a href="#fnp7yc34fwgw">[5]</a></sup></span></p><blockquote id="block118"><p id="block119"><strong>Turing:</strong> Just in case you were secretly hanging on to any threads of hope, I figured I&#39;d really make sure that they&#39;re all burnt to a crisp.</p><p id="block120">I was thinking about it some more and I emerged even more confident in how fucked we truly are.</p><p id="block121">So you know how Godel showed that there are <i>statements</i> in formal systems that can never be proven or disproven within those systems? I just realized that, on top of this, there will always be <i>problems </i>that cannot be solved.</p><p id="block122"><strong>Hilbert: </strong>I appreciate your concern, but <a href="https://en.wikipedia.org/wiki/Alonzo_Church">Alonzo</a> was actually over here about a month ago telling me the same thing.</p><p id="block123"><strong>Turing: </strong>Oh. Ok. Yeah, he and I have chatted about it periodically.</p><p id="block124"><strong>Hilbert: </strong>I like your way of expressing it though. This Turing Machine is simple and easy to understand. Very elegant. Alonzo&#39;s lambda calculus was also cool, but I like this better.</p></blockquote><p id="block125">So yeah. Turing Machines. Let&#39;s talk about them. It&#39;s basically like this:</p><ul><li id="block126">Imagine a roll of tape.</li><li id="block127">That&#39;s divided into segments.</li><li id="block128">It&#39;s infinitely long.</li><li id="block129">Each segment either has a 1 or a 0.</li><li id="block130">There&#39;s a head that goes over the roll of tape.</li><li id="block131">The head looks at one segment at a time.</li><li id="block132">It reads whether the segment has a 1 or a 0.</li><li id="block133">And it can update the segment. From a 1 to a 0, or from a 0 to a 1.</li><li id="block134">You can write down instructions for the head to follow. For example, if the current state of the tape is this, move to the left. If it&#39;s that, move to the right. If it&#39;s this, write 1 on the current segment. If it&#39;s that, write 0 on the current segment. </li></ul><p id="block135">That&#39;s pretty much it.</p><p id="block136">Seems kinda weird, right? Well, consider this: Turing showed that there is no computation that this machine can&#39;t perform, that another machine can perform. It might take the Turing machine longer to perform the computation. It might be more difficult to write the instructions for it. But in terms of actually getting the job done, there&#39;ll never be another machine more capable than the Turing machine.<span role="doc-noteref" id="fnrefutf2ac7mqy"><sup><a href="#fnutf2ac7mqy">[6]</a></sup></span></p><p id="block137">And oh by the way, that&#39;s how he poured that salt in Hilbert&#39;s wound. First he showed this stuff about the Turing machine being as capable as any. Then he showed that there are problems the Turing machine can&#39;t solve. So then, if 1) this machine is as capable as any and 2) there are problems it can&#39;t solve, well, we can deduce 3) there are <a href="https://brilliant.org/wiki/halting-problem/">problems</a> that no machine can solve. QED.</p><p id="block138">Ok, now we know a bunch of stuff about Turing and his Turing machines. Let&#39;s zoom back out.</p><p id="block139">I get the sense that at this point, most people are ready to just keep chugging forward. Maybe after getting a little starry-eyed. That gives me some serious <a href="https://www.lesswrong.com/posts/NMoLJuDJEms7Ku9XS/guessing-the-teacher-s-password">Guessing The Teacher&#39;s Password</a> vibes though, with the password being &#34;Turing&#39;s work was very cool and important&#34;. Let&#39;s ask ourselves why we should care about any of this.<span role="doc-noteref" id="fnref897chqzplao"><sup><a href="#fn897chqzplao">[7]</a></sup></span></p><ul><li id="block140"><strong>It makes you a better programmer?</strong> Nah. Doubtful. StackExchange <a href="https://cs.stackexchange.com/questions/9341/practical-importance-of-turing-machines">says so</a>, and so do various programmer friends of mine.</li><li id="block141"><strong>You do fancy programming? </strong>Maybe.<strong> </strong><a href="https://cs.stackexchange.com/a/32853/30105">This StackExchange answer</a> is intriguing. It talks about how various real life problems are actually just halting problems in disguise.</li><li id="block142"><strong>You do theoretical computer science research and need to read and write proofs? </strong>Yeah, this seems like a pretty good reason. Most existing proofs are written with Turing&#39;s model, so if you want to read research paper&#39;s, you&#39;ll need to understand it.</li><li id="block143"><strong>It&#39;s cool? </strong>Yes! I&#39;d say so. The idea that all code/instructions can basically be boiled down to such simple operations is awesome.</li><li id="block144"><strong>It gives us a formal definition of an algorithm? </strong>I dunno. I guess. This mostly piggybacks off of the last two bullet points. See <a href="https://cs.stackexchange.com/a/66754/30105">this StackExchange answer</a>.</li><li id="block145"><strong>It contributed to the development of the general purpose computer? </strong>This is something that I&#39;m not clear on. I see stuff saying that it was a major contribution, but it doesn&#39;t make sense to me.<ul><li id="block146">I don&#39;t see why computability is particularly relevant. If people didn&#39;t know as much about computability, would it really have slowed down the development of the general purpose computer all that much? I could see how computability would be helpful with things like programming language design, but that&#39;s not really what we&#39;re talking about here.</li><li id="block147">The concept of a stored program is definitely important, but that concept dates at least as far back as the Jaquard loom.</li><li id="block148">The concept of a general rather than specific purpose machine is definitely important, but that too dates back a while. At least to Babbage and Lovelace.</li></ul></li></ul><p id="block149">Anyway, after Turing was finished with all of this, he proceeded to defeat Hitler, create the entire field of artificial intelligence, and help build the first general purpose computers.</p><p id="block150">Ok fine, I&#39;m embellishing. Turing himself didn&#39;t actually defeat Hitler, but he did do super important codebreaking work throughout the war. People often credit him with reducing the duration of the war by two years, saving millions of lives. Without Turing, who knows, maybe our world today would look like <a href="https://www.imdb.com/title/tt1740299/">The Man in the High Castle</a>.</p><p id="block151">He also didn&#39;t actually create the field of artificial intelligence himself, but he is often said to be a founding father. If you credit him with being a person who <a href="https://www.lesswrong.com/tag/taking-ideas-seriously">takes ideas seriously</a>, this shouldn&#39;t be surprising.</p><p id="block152">Think about it: he realized that any computation that can be performed can be performed by a Turing machine. So if you view human thought and reasoning as a computation rather than something mystical, well, it should be something that a Turing machine is capable of. And if a Turing machine is capable of it, it&#39;s not such a stretch to think that we can build machines ourselves that are capable of it as well.<span role="doc-noteref" id="fnref37vhfkfqjvw"><sup><a href="#fn37vhfkfqjvw">[8]</a></sup></span></p><p id="block153">It&#39;s hard for me to wrap my head around the fact that early, pre-general purpose computers (~1890-1950s) weren&#39;t computers in the way that we think about computers today. I prefer to think about them as &#34;math machines&#34;.</p><p id="block154">Earlier we talked about the Hollerith Machine and how it helped with the 1890 US Census. That machine was really only capable of doing simple things like tallying and sorting. It couldn&#39;t really do math.</p><p id="block155">But subsequent machines were able to do math. From what I&#39;m seeing, it sounds like a lot of it was military use. A ton of codebreaking efforts during World War II. Also a bunch of projectile calculations for artillery fire.</p><p id="block156">Let&#39;s dive into these projectile calculations. Without computers, people previously had to do these calculations by hand.<span role="doc-noteref" id="fnrefmkynjbuxpn"><sup><a href="#fnmkynjbuxpn">[9]</a></sup></span> You might think that it&#39;d be a simple function of the launch angle like this:</p><figure><img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.mpoweruk.com%2Fimages%2Ftrajectories.gif&amp;f=1&amp;nofb=1&amp;ipt=6f121f94fa6b04cabcc75605b44934b12302132e31c89d606e74863466df9203&amp;ipo=images" alt="Simple Missile Ballistics"/></figure><p id="block157">But there are tons of other variables. What about elevation differences? Wind? Humidity? Shell weight? Powder charge? It&#39;s actually quite complicated.</p><p id="block158">And you don&#39;t want soldiers to have to do (much) math on the battlefield in the heat of the moment. So what they pursued were something called firing tables. Basically, the firing tables let you quickly look up the output given the various inputs. And it was the task of people at home to construct these firing tables.</p><p id="block159">To do this, they&#39;d break the projectile&#39;s journey into small segments. 0.1 seconds long, let&#39;s say.</p><ul><li id="block160">So given the starting point, they&#39;d calculate where the projectile will be 0.1 seconds from <code>t=0</code>, incorporating all of the things you conveniently ignored in your physics classes. Things like drag.</li><li id="block161">Then once they get the result for where they expect the projectile to be at <code>t=0.1</code>, they&#39;d move on to the calculation for <code>t=0.2</code>, using <code>t=0.1</code> as the input.</li><li id="block162">Then <code>t=0.3</code>, then <code>t=0.4</code>, so on and so forth.</li></ul><p id="block163">Still, I had the thought: is it really that hard? It&#39;s just plugging numbers into a known formula, right? If so, that&#39;s just arithmetic. Adding and subtracting. Multiplying and dividing. Exponents. Stuff like that. Maybe some logarithms and trig. But even so, it isn&#39;t obvious to me that it&#39;s too hard, nor that building a huge mechanical machine would be easier.</p><p id="block164">Well, the math looks something like this:</p><pre><code>s = s0 + v0cos(a)t + (F(v,ψ)/m - gsin(θ) - CDpAv2/2m)*t2 / 2

Where:

s = horizontal range
s0 = initial horizontal position
v0 = initial velocity
a = angle of elevation
t = time
F = propelling force function
ψ = angle of fire
m = mass
g = gravity
θ = angle of elevation

CD = drag coefficient
p = air density
A = projectile cross sectional area</code></pre><p id="block165">So yeah, it ultimately does just boil down to a bunch of arithmetic. But it&#39;s a <i>whole bunch</i> of arithmetic. And each calculation needs to be double checked to ensure accuracy. But even that doesn&#39;t ensure accuracy. Human beings get tired and make mistakes. On the other hand, math machines don&#39;t get tired, rarely make mistakes, are faster, and are cheaper. The pros of using math machines outweighed the cons. By a long shot (no pun intended).</p><p id="block166">Then in the 1940s, there was a breakthrough.<span role="doc-noteref" id="fnref1kzgq805da5"><sup><a href="#fn1kzgq805da5">[10]</a></sup></span> The vacuum tube took computers from being mechanical to being electric. In doing so, they made computers cheaper, quieter, more reliable, more energy efficient, about 10-100x smaller, and about 100x faster. They enabled computations to be done in seconds rather than hours or days. It was big.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/c/cb/GB-ENG_-_Bletchley_-_Computers_-_Buckinghamshire_-_Milton_Keynes_-_Bletchly_-_Bletchley_Park_%284890148011%29.jpg" alt="https://upload.wikimedia.org/wikipedia/commons/c/cb/GB-ENG_-_Bletchley_-_Computers_-_Buckinghamshire_-_Milton_Keynes_-_Bletchly_-_Bletchley_Park_%284890148011%29.jpg"/><figcaption>Vacuum tubes seen on end in a recreation of the World War II-era Colossus computer at Bletchley Park, England (<a href=" https://en.wikipedia.org/wiki/Vacuum_tube#/media/File:GB-ENG_-_Bletchley_-_Computers_-_Buckinghamshire_-_Milton_Keynes_-_Bletchly_-_Bletchley_Park_(4890148011).jpg">Wikipedia</a>)</figcaption></figure><p id="block167">Things continued to move fast. I wonder what it was like back then. It must have been exciting.</p><p id="block168">In 1945, the ENIAC was introduced. I actually really like <a href="https://en.wikipedia.org/wiki/ENIAC">Wikipedia&#39;s overview</a>:</p><blockquote id="block169"><p id="block170"><strong>ENIAC</strong> (<a href="https://en.wikipedia.org/wiki/Help:IPA/English">/ˈɛniæk/</a>; <strong>Electronic Numerical Integrator and Computer</strong>)<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-1"><sup>[1]</sup></a><a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-ENIACstory-2"><sup>[2]</sup></a> was the first <a href="https://en.wikipedia.org/wiki/Computer_programming">programmable</a>, <a href="https://en.wikipedia.org/wiki/Electronics">electronic</a>, general-purpose <a href="https://en.wikipedia.org/wiki/Digital_computer">digital computer</a>, completed in 1945.<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-3"><sup>[3]</sup></a><a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-:0-4"><sup>[4]</sup></a> There were other computers that had combinations of these features, but the ENIAC had all of them in one computer. It was <a href="https://en.wikipedia.org/wiki/Turing-complete">Turing-complete</a> and able to solve &#34;a large class of numerical problems&#34; through reprogramming.<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-5"><sup>[5]</sup></a><a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-6"><sup>[6]</sup></a></p><p id="block171">Although ENIAC was designed and primarily used to calculate <a href="https://en.wikipedia.org/wiki/Artillery">artillery</a> <a href="https://en.wikipedia.org/wiki/External_ballistics">firing tables</a> for the <a href="https://en.wikipedia.org/wiki/United_States_Army">United States Army</a>&#39;s <a href="https://en.wikipedia.org/wiki/Ballistic_Research_Laboratory">Ballistic Research Laboratory</a> (which later became a part of the <a href="https://en.wikipedia.org/wiki/United_States_Army_Research_Laboratory">Army Research Laboratory</a>),<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-7"><sup>[7]</sup></a><a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-FOOTNOTEGoldstine1972214-8"><sup>[8]</sup></a> its first program was a study of the feasibility of the <a href="https://en.wikipedia.org/wiki/Thermonuclear_weapon">thermonuclear weapon</a>.<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-9"><sup>[9]</sup></a><a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-10"><sup>[10]</sup></a></p><p id="block172">ENIAC was completed in 1945 and first put to work for practical purposes on December 10, 1945.<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-trial-11"><sup>[11]</sup></a></p><p id="block173">ENIAC was formally dedicated at the <a href="https://en.wikipedia.org/wiki/University_of_Pennsylvania">University of Pennsylvania</a> on February 15, 1946, having cost $487,000 (equivalent to $6,190,000 in 2021), and called a &#34;Giant Brain&#34; by the press.<sup>[</sup><a href="https://en.wikipedia.org/wiki/Wikipedia:Citation_needed"><i><sup>citation needed</sup></i></a><sup>]</sup> It had a speed on the order of one thousand times faster than that of <a href="https://en.wikipedia.org/wiki/Electro-mechanical">electro-mechanical</a> machines; this computational power, coupled with general-purpose programmability, excited scientists and industrialists alike. The combination of speed and programmability allowed for thousands more calculations for problems.<a href="https://en.wikipedia.org/wiki/ENIAC#cite_note-12"><sup>[12]</sup></a></p><p id="block174">ENIAC was formally accepted by the U.S. Army Ordnance Corps in July 1946. It was transferred to <a href="https://en.wikipedia.org/wiki/Aberdeen_Proving_Ground">Aberdeen Proving Ground</a> in <a href="https://en.wikipedia.org/wiki/Aberdeen,_Maryland">Aberdeen, Maryland</a> in 1947, where it was in continuous operation until 1955.</p></blockquote><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/6c/ENIAC_Penn1.jpg/1920px-ENIAC_Penn1.jpg" alt="undefined"/><figcaption>Two pieces of ENIAC currently on display in the Moore School of Engineering and Applied Science, in room 100 of the Moore building. Photo courtesy of the curator, released under GNU license along with 3 other images in an email to me. Copyright 2005 Paul W Shaffer, University of Pennsylvania. On the left is a function table (for reading in a table of data). There are four panels, the left-most one controls the interface to the function table. The third one is an accumulator - memory for storing a 10-digit number, which can be added into. (<a href="https://en.wikipedia.org/wiki/ENIAC#/media/File:ENIAC_Penn1.jpg">Wikipedia</a>)</figcaption></figure><p id="block175">Let&#39;s talk more about each piece:</p><ol><li id="block176">Electronic: As mentioned in the discussion of vacuum tubes, being electronic rather than mechanical had all sorts of large advantages.</li><li id="block177">Programmable: We originally saw the benefits of programmability with the Jaquard loom. In the 1930s and 40s, computers that weren&#39;t programmable had to be physically rewired if you wanted to perform a computation.<span role="doc-noteref" id="fnref59l2q9akkc4"><sup><a href="#fn59l2q9akkc4">[11]</a></sup></span> Software wasn&#39;t actually a thing!</li><li id="block178">General-purpose: From what I could tell, this isn&#39;t something that is precisely defined, but it is trying to point at being capable of doing a wide variety of tasks. Think about it like this: the Hollerith Machine mostly was just capable of counting and sorting and so is at once end of the spectrum. On the other hand, the ENIAC is literally Turing-complete and can perform any computation. You don&#39;t have to be 100% Turing-complete to be considered general-purpose, but you should be somewhat close.</li></ol><p id="block179">Anyway, all of this goodness lead to things really picking up pace. I&#39;m allowed to quote <a href="https://claude.ai/">Claude</a>, right?</p><blockquote id="block180"><p id="block181">ENIAC (the Electronic Numerical Integrator and Computer) was a pioneering early electronic general-purpose digital computer that heavily influenced later systems:</p><ul><li id="block182">After ENIAC&#39;s unveiling in 1946, there was an explosion of computer projects inspired by its electronic, programmable architecture.</li><li id="block183">Early &#34;clone&#34; computers like EDVAC and BINAC improved on ENIAC but shared its basic design principles.</li><li id="block184">Commercial computers like UNIVAC I brought the technology to businesses for data processing tasks like payroll, inventory, and accounting.</li><li id="block185">Scientific computers were adopted by research institutions for calculations like weather modeling, aerodynamics, and particle physics.</li><li id="block186">Government and military usage was also widespread for everything from cryptography to logistics.</li><li id="block187">Programming became an essential new profession dedicated to utilizing these systems productively.</li></ul><p id="block188">So ENIAC demonstrated the possibilities of electronic computing and established an influential reference architecture. This spurred rapid adoption of computers across science, government, business and academia in the 1950s-60s. Tasks that were previously manual or mechanical were transformed by the new computational capabilities. It was a pivotal transition from basic calculation into broader information processing applications.</p></blockquote><p id="block189">After vacuum tubes, the <a href="https://en.wikipedia.org/wiki/Transistor_computer">next big innovation</a> was to use transistors. They were used throughout the 1950s and 1960s. Compared to vacuum tubes, transistors were:</p><ul><li id="block190">~1000x faster. This enabled MHz clock speeds instead of kHz.</li><li id="block191">~10x smaller. Transistors were measured in millimeters<span role="doc-noteref" id="fnrefkq24pdxsznj"><sup><a href="#fnkq24pdxsznj">[12]</a></sup></span> whereas vacuum tubes were centimeters long.</li><li id="block192">~50x cheaper. Initially. Over time they quickly got even cheaper.</li><li id="block193">~100x more reliable. Vacuum tubes had mean time between failures (MTBF) measured in thousands of hours due to filament issues whereas transistors lasted for hundreds of thousands of hours and generated less heat.</li><li id="block194">Better in various others ways as well.</li></ul><p id="block195">Yeah. They were a game changer.</p><p id="block196">Well, from what I could tell, they kinda just lead to more of the same. Evolutionary, not revolutionary. Later on the invention of integrated circuits allowed computers to be cheap and small enough for personal use. That was revolutionary. But still, it&#39;s cool that early transistors allowed for fancier computations and made computers more accessible for some smaller organizations.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/JohnvonNeumann-LosAlamos.gif/220px-JohnvonNeumann-LosAlamos.gif" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/5/5e/JohnvonNeumann-LosAlamos.gif/330px-JohnvonNeumann-LosAlamos.gif 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/5/5e/JohnvonNeumann-LosAlamos.gif/440px-JohnvonNeumann-LosAlamos.gif 2x"/></figure><p id="block197">John von Neumann was a man who did a lot of important things throughout the 1930s, 40s and 50s.</p><ul><li id="block198">He invented game theory. No big deal.</li><li id="block199">He was a major contributor to the Manhattan Project.</li><li id="block200">He developed the concept of cellular automata. Y&#39;know, like <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Jon Conway&#39;s Game of Life</a>. This influenced fields like biology, nanotechnology, and chaos theory, but more relevant to our purposes here, it influenced the development of parallel computing. Think about it: each cell in Conway&#39;s Game of Life is like a processor computing it&#39;s own thing. There&#39;s many processors doing stuff at once, and sometimes they collide and interact.</li><li id="block201">Like Godel and Turing, von Neumann was inspired by Hilbert&#39;s program and did work to establish a solid foundation for mathematics and formal systems. In particular, he did pioneering work in the formalization of set theory.</li><li id="block202">One of my favorites: he <i>proved</i> that, given some extremely, extremely reasonable assumptions<span role="doc-noteref" id="fnrefrg0tbwcetu"><sup><a href="#fnrg0tbwcetu">[13]</a></sup></span>, you should <a href="https://www.lesswrong.com/tag/shut-up-and-multiply">Shut Up and Multiply</a>. Well, he didn&#39;t phrase it that way. He said &#34;maximize <a href="https://www.lesswrong.com/tag/expected-utility">expected utility</a>&#34;.</li><li id="block203">He invented the merge sort algorithm. My favorite sorting algorithm. <code>#leetcode</code></li><li id="block204">He <a href="https://en.wikipedia.org/wiki/John_von_Neumann#Technological_singularity_hypothesis">came up</a> with the idea of the singularity.</li><li id="block205">He did a bunch of other logic, math and physics things that I don&#39;t understand.</li></ul><p id="block206">However, the thing he did that is most relevant to this post on the history of computers is coming up with the <a href="https://en.wikipedia.org/wiki/Von_Neumann_architecture">von Neumann architecture</a> of computers in 1945. Let&#39;s dig into that.</p><p id="block207">The architecture works something like this:<span role="doc-noteref" id="fnrefdw8fwb9zugp"><sup><a href="#fndw8fwb9zugp">[14]</a></sup></span></p><figure><img src="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png" srcset="https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_100 100w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_200 200w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_300 300w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_400 400w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_500 500w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_600 600w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_700 700w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_800 800w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_900 900w, https://39669.cdn.cke-cs.com/rQvD3VnunXZu34m86e5f/images/4958058ca07fd819612c9fbe6691207e6dd1ed7ea0ffb39f.png/w_904 904w"/></figure><p id="block208">You might be thinking that this looks a little mundane and obvious. Like, of course this is how computer architecture works. Duh.</p><p id="block209">Well, that&#39;s because John von Neumann came up with it. Nowadays pretty much all computers use this architecture, but at the time it wasn&#39;t like this. For example, the focus was on standalone computational units like adders and multipliers. Von Neumann encapsulated all of that stuff in the CPU. Nice, right?</p><p id="block210">Here&#39;s another example. Probably a more important one. At the time, program instructions and data usually weren&#39;t stored in the same memory space. In von Neumann&#39;s architecture, they are. I&#39;m not sure if von Neumann was 100% the first person to come up with the idea, but his architecture really popularized it, and before von Neumann, early stored program computers stored the data and instructions in different spaces.<span role="doc-noteref" id="fnref4mmsjx26xe"><sup><a href="#fn4mmsjx26xe">[15]</a></sup></span></p><p id="block211">Ok, so what&#39;s the big deal? Why is it so helpful to have the data and instructions share the same memory? Well, for starters, it&#39;s simpler, cheaper, and it made execution <a href="https://en.wikipedia.org/wiki/Locality_of_reference">faster</a> because stuff is all closer together. It was also convenient to access stuff in a single address space rather than having separate schemes.</p><p id="block212">But the biggest thing is probably that it made assemblers and compilers possible. Well, I&#39;m not sure if that&#39;s strictly true. Maybe you could still have them without a shared memory architecture. But the shared memory architecture made them a whole lot easier.<span role="doc-noteref" id="fnrefej8gyg8yrws"><sup><a href="#fnej8gyg8yrws">[16]</a></sup></span></p><p id="block213">What are assemblers and compilers, you ask? Let me tell you.</p><p id="block214">On early computers, what did programming look like? Well, on (most) computers that preceded the ENIAC, there was no concept of a stored program, so &#34;programmers&#34; would have to physically set up circuits and switches.</p><p id="block215">Things were a little easier on stored program computers. For those, you could enter the program in as a series of 1s and 0s, by turning on the right vacuum tubes, for instance. The vacuum tubes you turn on were the machine code and determined what operations were carried out.</p><p id="block216">But of course, humans don&#39;t think in 1s and 0s. So early programmers had to first map out what they want to do with flow charts and stuff, and then figure out how to convert those flow charts into the corresponding 1s and 0s.</p><p id="block217">What if they didn&#39;t have to do that last part? What if they could just write out some informal instructions and have those informal instructions translated into 1s and 0s (machine code) for them? That sounds like it&#39;d really improve programmer productivity, right?</p><p id="block218">Enter: assemblers. Assemblers were able to do this. They are programs just like any other computer program that takes inputs and yields outputs. You feed it in some text that looks like this:</p><pre><code>LOAD R1, #10   ; Load register 1 with 10
LOAD R2, #6    ; Load register 2 with 6
ADD R3, R1, R2 ; Add R1 and R2, store in R3 
STORE R3, Result  ; Store sum in Result variable
JUMP START     ; Jump back to start of program

START:         ; Label for start of program  </code></pre><p id="block219">And the assembler will output the corresponding 1s and 0s.</p><p id="block220">It&#39;s code that writes code.</p><p id="block221">Think of it like this. It&#39;s translating between two languages. Assembly is one language and looks like this: <code>LOAD R1, #10</code>. Machine code is another language and looks like this: <code>10010010110101010011110101000010101000100101</code>. Just like how English and Spanish are two different languages.</p><p id="block222">Assemblers are translators. Just like how a human might translate between English and Spanish at the UN, an assembler translates between assembly and machine code. The computer only speaks machine code, whereas human programmers aren&#39;t very fluent in machine code and would prefer to speak in assembly.</p><p id="block223">But hey, why stop there? This idea of translating from one language to another is pretty powerful. Assembly is ok, but still is a little cumbersome. What if we could create a language that is even more descriptive than assembly, write code in that language, and have it translated into assembly for us?</p><p id="block224">Enter: programming languages. They let you write code like this:</p><pre><code>C Calculate average of numbers in array
   REAL A(100)
   TOTAL = 0

   DO I = 1, 100  
      TOTAL = TOTAL + A(I)
   END DO

   AVG = TOTAL / 100</code></pre><p id="block225">and run it through a compiler to get the corresponding assembly code of this:</p><pre><code>; Reserve memory for array A
  RESERVE 400 ; 100 * 4 bytes per real  

; Initialize pointer and total
  MOVE BP, 0 ; Pointer to base of A
  MOVE BX, 0 ; Total

LOOP:
  ADD BX, [BP] ; Add element to total
  ADD BP, 4 ; Increment pointer
  COMP BP, 400 ; Compare to end
  JLT LOOP ; Loop if not past end 

; Calculate average
AVG:
  MOVE AX, BX ; Move total to AX
  DIV AX, 100 ; Divide total by 100
  STORE AVG ; Store result</code></pre><p id="block226">So now we have two translation steps. It&#39;s analogous to you speaking English, having an initial translator translate that to French, and then having a second translator translate the French into Spanish.</p><p id="block227">In that example, the code is in Fortran. Fortran was developed in 1957 and was the first programming language that actually got some real adoption. Other languages were also developed around that time: Lisp in 1958, Algol in 1958, and COBOL in 1959.</p><p id="block228">Programming started to become accessible to a wider audience. Popular media hyped up these languages as allowing &#34;communication with intelligent machines&#34;. Conferences like the ACM National Conference drew huge interest around new languages. It was an exciting time.</p><p id="block229">It wasn&#39;t just programming languages that made things exciting though. Programming languages allowed humans to talk to computers, but shortly after the development of the first programming languages in the late 1950s, in the early 1960s, networking allowed <i>computers</i> to talk to computers.</p><p id="block230"><img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fclickamericana.com%2Fwp-content%2Fuploads%2FComputers-in-1966-770x667.jpg&amp;f=1&amp;nofb=1&amp;ipt=303de9e87598df4abc88e7c14a6f9cc0948444468fb8292314340ad4067f66ef&amp;ipo=images" alt="Computers in the 1960s: What they looked like &amp; how they were used ..."/></p><p id="block231">Why was this useful?</p><ul><li id="block232">Terminals. It allowed for many cheaper terminals to connect to one central mainframe computers.</li><li id="block233">Early email and messaging.</li><li id="block234">Exchanging data.</li><li id="block235">Remote login.</li><li id="block236">Some early distributed computing.</li></ul><p id="block237">Stuff like that.</p><p id="block238">Then in 1966, another huge jump was made: the integrated circuit.</p><p id="block239">Before 1966, transistors were a thing, but they weren&#39;t the transistors that we imagine today. Today we think of transistors as tiny little things on computer chips that are so small you can&#39;t even see them. But before 1966, transistors were much larger. Macroscopic. Millimeters long.</p><p id="block240">I don&#39;t really understand the scientific or engineering breakthroughs that allowed this to happen, but something called photolithography allowed them to actually manufacture the transistors directly on the computer chips. This allowed chips to contain millions or even billions of individual transistors. And the connections between components were done directly on the chip instead of using external wires.</p><p id="block241"><img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fmotionarray.imgix.net%2Fpreview-587129-3uJrqRp3TP0LFw0O-large.jpg%3Fw%3D1400%26q%3D60%26fit%3Dmax%26auto%3Dformat&amp;f=1&amp;nofb=1&amp;ipt=65eab4e09bfed670252cf2a76f35a23e7a195bdb03fd8fa901c703cfb2748a56&amp;ipo=images" alt="Integrated Circuit Board - Stock Photos | Motion Array"/></p><p id="block242">Here&#39;s a sense of how this functionally improved things:</p><ul><li id="block243">Speed: 100x improvement. Tens of megahertz rather than kHz.</li><li id="block244">Memory: 1000x or more. Memory density went from kilobits per chip to megabits.</li><li id="block245">Cost: 500x reduction. The cost per transistor fell from around $50 in the 1950s to under $0.10 with integrated circuits.</li><li id="block246">Reliability: Failures rates 100x lower.</li><li id="block247">Power: 1000x reduction. Microwatts instead of watts.</li><li id="block248">Size: Integrated circuits allowed for computers small enough to fit on desktops. Ones we&#39;d recognize today. Before that, computers were often the size of a room.</li></ul><p id="block249">In the 1960s, <a href="https://medium.com/@adamzerner/overview-of-computer-networking-70848bd62710">computer networks</a> were mostly used for military, research, academia, and some large enterprises. However, in the 70s, that started to change.</p><p id="block250">But let&#39;s start with ARPANET in 1969. ARPA stands for Advanced Research Projects Agency, which is a part of the Department of Defense. Basically, there were a bunch of universities doing research for the military. Research with computers. It&#39;d be nice if those computers could talk to one another. And so they created ARPANET. A network of ARPA-funded research groups.</p><p id="block251">But then things expanded beyond military applications. Over time, it kinda just became a way for university departments to collaborate with one another. Sharing computing resources. Datasets. Email. Email was the &#34;killer app&#34; of the time.</p><figure><img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2F3.bp.blogspot.com%2F-TNgktleXezU%2FWgjG5JEsjXI%2FAAAAAAAAAAs%2FBIsC9LcAPsw9d5I0OhrMnfVLtRYE8AhbACLcBGAs%2Fs1600%2FArpanet_1970.png&amp;f=1&amp;nofb=1&amp;ipt=f432bd981522dc0ebcd233166e6ab28d7ba099c45f4552da1a8d06c7fdb5d482&amp;ipo=images" alt="Entry 4 - Leonard Kleinrock: The ARPANET"/></figure><p id="block252">It wasn&#39;t just ARPANET though. You think ARPA and universities were the only ones who wanted in on this? Nah. There were various other networks developed for research, government and commercial purposes.</p><p id="block253">Telenet was another popular one that began in 1975 and was actually sold commercially. Ie. you&#39;d pay a monthly fee to use their so called &#34;backbone network&#34; to get connected to other computer networks.</p><figure><img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Ftse2.mm.bing.net%2Fth%3Fid%3DOIP.Ggyb7-gw5ihL8A6DMGvzEwHaHb%26pid%3DApi&amp;f=1&amp;ipt=2d001c3c01c4907a4c5425305705712196b5d535098ff1b22dbb4954c7463cc8&amp;ipo=images" alt="Broadband provider starts to show TV commercials based on viewing and ..."/></figure><p id="block254">Things were a little annoying though. Different networks had different protocols for communicating. It&#39;s as if ARPANET spoke Spanish and Telenet spoke French. They didn&#39;t really mix.</p><p id="block255">So, in the mid to late 1970s, people started trying to come up with a standard way for computers to talk to one another. &#34;Let&#39;s just all speak the same language, guys.&#34; Unlike humans, computers actually were able to all agree on one language, and that language is called TCP/IP.</p><p id="block256"><img src="https://miro.medium.com/v2/resize:fit:1400/1*p5uiclzG8aP3igXzjmt0WQ.png" alt=""/></p><p id="block257">And once they started speaking the same languages, &#34;internetworking&#34; became a thing. Networks communicating with one another. Networks becoming &#34;interconnected&#34;. Eventually, this became the <i>internet</i> we know of today.</p><figure><img src="https://miro.medium.com/v2/resize:fit:1400/1*UW_L7S-p1jHNYB3MEUKzog.png" alt=""/></figure><p id="block258">In the 1960s, there were minicomputers, and there were mainframes. You <a href="https://en.wikipedia.org/wiki/Minicomputer#cite_note-inflation-US-4">can</a> distinguish between the two by saying that minicomputers cost $25k and under ($188k in 2022) whereas mainframes are more expensive.</p><p id="block259">Then with the invention of the integrated circuit, from maybe 1970-1975, microcomputers started to become a thing. Costs were only in the hundreds of dollars. Maybe low thousands. And they could fit on a desk.</p><p id="block260">However, computing power was really low. They were only used by electronics hobbyists. All you could do with them was some basic logic and arithmetic. Programming had to be done in machine code or very primitive assembly via switches. They were sold in DIY kits. You had to solder stuff together on your own. You had to provide your own monitor and keyboard.</p><figure><img src="https://upload.wikimedia.org/wikipedia/en/thumb/c/cb/Popular_Electronics_Cover_Jan_1975.jpg/220px-Popular_Electronics_Cover_Jan_1975.jpg" srcset="//upload.wikimedia.org/wikipedia/en/c/cb/Popular_Electronics_Cover_Jan_1975.jpg 1.5x"/><figcaption>January 1975 <i>Popular Electronics</i> with the Altair 8800 computer. Published on November 29, 1974.<a href="https://en.wikipedia.org/wiki/Altair_8800#cite_note-PE-1975-01-PDF-14"><sup>[14]</sup></a></figcaption></figure><p id="block261">So yeah, this was definitely hobbyist territory. Businesses needed minicomputers or mainframes since those were the machines with the computing power and business software that they needed.</p><p id="block262">And that&#39;s when Steve Jobs changed everything. He said, &#34;<i>Fuck</i> this DIY bull shit. Computers aren&#39;t for corporations. They&#39;re for people. You should be able to just buy one, put it on your desk, and use it. And you shouldn&#39;t have to read a 200+ page instruction manual to do so. It should just be intuitive.&#34;</p><p id="block263">This triggered a remarkable change in society at large.</p><p id="block264">Thieves returned stolen purses. Soldiers on battle fields looked each other in the eyes, and put down their weapons. Fathers cried and apologized to their sons. Politicians refused campaign contributions. Teachers stopped assigning homework. Business executives started doing psychedelics and attending yoga classes. IBM apologized for being greedy, pointy-haired bastards, and begged Jobs to be their CEO.</p><p id="block265">Jobs accepted. He used IBM&#39;s vast resources to commission the development of The Perfect Circle. This circle was drawn in sand and after an initial version with molecular-level accuracy was vetoed by Jobs, a subsequent version with atomic-level accuracy was finally completed. Then, having been on a diet of just quinoa and green tea for seven months, Jobs achieved a state of heightened meditation inside The Perfect Circle. In this state, he migrated to his True Form, entered Machine City, confronted Deus Ex Machina, and negotiated a deal to release all humans from The Matrix. Eternal salvation had been achieved.</p><p id="block266">Ok, ok. I&#39;ll stop.</p><p id="block267">It was actually Steve Wozniak who had a lot of the vision.</p><p id="block268">Woz, as he&#39;s often referred to, was a nerd who bought computer kits and built microcomputers. But, as I previously explained, doing so was really annoying. Soldering? Machine code? Yuk.</p><p id="block269">And as an early member of the Homebrew Computer Club, Woz saw these pain points first hand. People would come to club meetings, hang out, and discuss the various difficulties and frustrations they faced with these DIY kits.</p><p id="block270">So then, Woz sought to build something better. Something that got rid of these frustrations and, going even further, enabled everyday users to easily get started computing rather than just electronics enthusiasts. Jobs&#39; contribution here was moreso the ambition. He wanted to make a dent in the universe and put these computers on the desks of people across the globe. An important and admirable contribution, if you ask me.</p><p id="block271">Anyway, in 1976, the Apple I was released as one of the very first pre-assembled computer motherboards. You still had to hook it up to stuff like a screen, keyboard and power supply, but at least you didn&#39;t have to arrange and solder all of the chips together yourself.</p><p id="block272"><img src="https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fgazettereview.com%2Fwp-content%2Fuploads%2F2017%2F05%2FApple-Computer.jpg&amp;f=1&amp;nofb=1&amp;ipt=de2b59f11212649408a5428a49e159de2a5f4455190300d0ea481f83df2d07a5&amp;ipo=images" alt="Rare Apple-1 Computer Sold At Auction For $130,000 - The Gazette Review"/></p><p id="block273">Soon after, in 1977, the Apple II was released. This was important because it was the first, true, personal computer. In the sense that it actually did come fully assembled. You didn&#39;t have to set up the keyboard, screen and sound. You basically just had to plug it in.</p><p id="block274">The Apple II wasn&#39;t the only one though. Along with the Apple II, the Commodore PET and TRS-80 were also really popular. Together, they formed the &#34;1977 Trinity&#34;.</p><figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Trinity77.jpg/412px-Trinity77.jpg" srcset="//upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Trinity77.jpg/618px-Trinity77.jpg 1.5x, //upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Trinity77.jpg/824px-Trinity77.jpg 2x"/><figcaption>The three personal computers referred to by Byte Magazine as the &#34;1977 Trinity&#34; of home computing: The Commodore PET, the Apple II, and the TRS-80 Model I. (<a href="https://en.wikipedia.org/wiki/Personal_computer">Wikipedia</a>)</figcaption></figure><p id="block275">This really was quite revolutionary. Personal computing had arrived and was exploding. Now individuals and small businesses were able to join the party that previously just consisted of large organizations.</p><p id="block276">In 1982, &#34;The Computer&#34; was named <i>Person of the Year</i> by Time Magazine.</p><p id="block277">Lots of crazy things were happening in the 80s:</p><ul><li id="block278">Programming languages:<ul><li id="block279">Throughout the 60s and 70s the main programming languages in use were COBOL, Fortran, ALGOL, and BASIC. Gross.</li><li id="block280">In the 80s, you had C as the dominant language for systems programming, Pascal in academia and general software development, and SQL for querying databases. In the mid 80s, C++ emerged, as did object-oriented programming.</li><li id="block281">Still, COBOL, Fortran and BASIC also remained popular, as did assembly.</li></ul></li><li id="block282">PCs continued to boom. After initially seeing them as small toys that weren&#39;t worth paying attention to, IBM entered the market with the 5150 PC in 1981.</li><li id="block283">Inspired by the Xerox Alto which was developed at Xerox PARC in 1973, we saw the GUI emerge. First with Apple&#39;s Macintosh in 1984 (remember the <a href="https://www.youtube.com/watch?v=VtvjbmoDx-I">commercial?</a>) and then Microsoft&#39;s Windows operating system. Oh, and the mouse was also introduced.</li><li id="block284">Popular uses for personal computers included word processing, accounting, desktop publishing (newsletters, flyers), programming, education, computer-aided design for engineers and architects, and gaming.</li><li id="block285">Internet use expanded.<ul><li id="block286">TCP/IP was standardized and established.</li><li id="block287">The NSCA created the first public dial-up internet access in the late 80s.</li><li id="block288">Still, home consumer use was very rare. Typical internet users were university students, faculty, or nerds. This, however, made for some wonderful email lists and discussion boards on applications like Usenet and Bitnet.</li></ul></li><li id="block289">Hardware continued to explode, following the trajectory predicted by Moore&#39;s Law. Microprocessors started to replace integrated circuits. With microprocessors, all of the components were on one chip. Prior to that, with integrated circuits (IC), CPUs were made up of many ICs connected to each other. ALU on one, control unit on another, registers on a third, etc. The progression to and advancement of microprocessors meant that, over the decade:<ul><li id="block290">Clock speeds increased from about 5 MHz to 25-33 MHz.</li><li id="block291">RAM grew from kilobytes per chip to megabytes per chip.</li><li id="block292">Storage went from floppy disks in the hundreds of kilobytes to hard disks in the tens of megabytes.</li><li id="block293">Cost per transistor continued to drop, starting at about 1 cent to less than a hundredth of a cent.</li><li id="block294">Power needs were reduced from a few watts to less than a watt.</li><li id="block295">Reliability improved a lot with chip failure rates falling.</li></ul></li><li id="block296">CD-ROMs became popular.</li><li id="block297">The first computer viruses were seen. Anti-virus software was created.</li><li id="block298">Laptops and mobile phones were introduced.</li><li id="block299">Database management systems (DBMS) became widespread.</li></ul><p id="block300">Overall, I think the theme of the decade is that computers became mainstream.</p><p id="block301">If I recall correctly, this journey of me learning about the history of computers and writing this post began with a sense of insecurity: I&#39;ve been a web developer for 10+ years and didn&#39;t know the difference between the internet and the World Wide Web, nor if there even is a difference in the first place. Seems like something I should know.</p><p id="block302">So, I researched it. I found out that the World Wide Web — aka &#34;the Web&#34; — is, in fact, a different thing. Tim Berners-Lee created the Web in the early 90s. Given that this is where I began my journey — and that I was born in 1992 and don&#39;t like the idea of &#34;history&#34; include time when I was alive — it seems fitting to make this the last section in the post.</p><p id="block303">Ok, so what is the difference between the Web and the internet? The web involves websites. Web browsers. HTML. HTTP. That sort of thing. It&#39;s the stuff you look at with Firefox, Google Chrome and Safari. So when you visit lesswrong.com, you&#39;re using the Web, but when you play WoW or use Apple Mail to send an email, you&#39;re using the internet without the web.</p><p id="block304">Let me elaborate. The Web <i>uses</i> the internet. It&#39;s like this.<span role="doc-noteref" id="fnref7m7gmw84r9u"><sup><a href="#fn7m7gmw84r9u">[17]</a></sup></span></p><figure><img src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwebstockreview.net%2Fimages%2Finternet-clipart-internet-access-1.jpg&amp;f=1&amp;nofb=1&amp;ipt=4ed9509c89efa5ddeccac223466011c357867502b110817bbdf0445692ea0ac9&amp;ipo=images" alt="Internet clipart internet access, Internet internet access Transparent ..."/></figure><p id="block305">Much like the Postal Service, the internet provides people with the service of delivering their packages from point A to point B.</p><p id="block306">With the postal services:</p><ul><li id="block307">Packages = paper in envelopes</li><li id="block308">Points A and B = mailboxes</li></ul><p id="block309">With the internet:</p><ul><li id="block310">Packages = 1s and 0s</li><li id="block311">Points A and B = computers</li></ul><p id="block312">Before the Web, people wrote messages to each other in languages like SMTP (email) and FTP (file transfer). With the Web, people wrote messages to each other, with the help of web <i>browsers</i>, in HTTP. But before diving into that too much, let&#39;s back up and look at the context in which the Web was developed.</p><p id="block313">Before the Web, accessing information online was difficult.</p><ul><li id="block314">Early online systems like Telnet, FTP, and Usenet required using command lines and remembering multiple textual commands.</li><li id="block315">Setting up internet connectivity often involved editing technical configuration files manually.</li><li id="block316">You had to know IP addresses and paths.</li><li id="block317">Content appeared in basic ASCII text.</li></ul><p id="block318">So then, nerds were the only ones technical and motivated enough to use the internet. But with the web, it was a whole lot easier.</p><ul><li id="block319">You use your mouse to open up a graphical web browser.</li><li id="block320">You type the name of a website in and hit enter. No need for IP addresses.</li><li id="block321">Navigation can be done by clicking links rather than entering in yet another IP address.</li><li id="block322">Everything <a href="https://news.ycombinator.com/item?id=36739920">was pretty</a>. Text can be formatted and mixed with things like images and tables.</li></ul><p id="block323">I can&#39;t think of an elegant way to end this post. Maybe that is a metaphor. Or maybe this is a metaphor.</p><ol role="doc-endnotes"><li role="doc-endnote" id="fnfnnmpm5aqm7"><span><sup><strong><a href="#fnreffnnmpm5aqm7">^</a></strong></sup></span><div><p id="block325">To elaborate, I&#39;m a web developer with about 10 years of experience. I didn&#39;t study computer science in college but I have spent a year self-studying it + have periodically learned things on and off over the years. I don&#39;t have the best understanding of computer science-y things, but also don&#39;t have the worst.</p><p id="block326">So it probably makes sense to take all of this with a small pinch of salt. A grain is too small. More skepticism is required than that. But I think you can put a decent amount of trust behind the content of this post too. I&#39;d bet on there being a small amount of errors and only 1-4 things that aren&#39;t directionally correct.</p><p id="block327"><a href="https://slatestarcodex.com/2017/11/02/non-expert-explanation/">Non-Expert Explanation</a> is a frame that I think is extremely appropriate to apply.</p></div></li><li role="doc-endnote" id="fn670ohjfvvuc"><span><sup><strong><a href="#fnref670ohjfvvuc">^</a></strong></sup></span><p id="block329">I&#39;m confident that this is <i>directionally</i> correct, but not sure if it is <i>literally</i> correct. It looks like maybe there were kinda sorta some type of abstract argument stuff before Aristotle. If so, it wasn&#39;t popular and well ironed out.</p></li><li role="doc-endnote" id="fnhh6cjw29uj"><span><sup><strong><a href="#fnrefhh6cjw29uj">^</a></strong></sup></span><p id="block331">There were of course also things that <a href="https://en.wikipedia.org/wiki/History_of_computing_hardware">came before</a> the Jacquard loom. In ancient and medieval times there were a few simple mechanical devices that performed some calculations. Later on in the 1600s, Blaise Pascal and Gottfried Wilhelm von Leibniz were two big names that also built mechanical calculators.</p></li><li role="doc-endnote" id="fnw4th04rh1w8"><span><sup><strong><a href="#fnrefw4th04rh1w8">^</a></strong></sup></span><p id="block333">At first I was wondering why this was so much work. Just calculate eg. <code>sin(79)</code>, <code>sin(80)</code>, <code>sin(81)</code> etc., write it all down, and call it a day. Then you never have to do that work again. But then I realized: what about <code>sin(79.1)</code>? What about <code>sin(79.74327432)</code>? Engineers and physicists needed values with that sort of precision so there were actually lots and lots of computations that needed to be done.</p></li><li role="doc-endnote" id="fnp7yc34fwgw"><span><sup><strong><a href="#fnrefp7yc34fwgw">^</a></strong></sup></span><p id="block335">While this picture is based upon a true story, some characters have been composited and a number of incidents fictionalized.</p></li><li role="doc-endnote" id="fnutf2ac7mqy"><span><sup><strong><a href="#fnrefutf2ac7mqy">^</a></strong></sup></span><p id="block337">Well... there <a href="https://cs.stackexchange.com/a/55513/30105">are</a><i> theoretical </i>machines that can compute things that a Turing machine cannot. How? By doing weird stuff with infinity. But don&#39;t go around giving hope back to Hilbert: given what we know about physics, these machines aren&#39;t actually possible to build.</p></li><li role="doc-endnote" id="fn897chqzplao"><span><sup><strong><a href="#fnref897chqzplao">^</a></strong></sup></span><p id="block339">Take this with a few more grains of salt. I&#39;m not as confident about it.</p></li><li role="doc-endnote" id="fn37vhfkfqjvw"><span><sup><strong><a href="#fnref37vhfkfqjvw">^</a></strong></sup></span><p id="block341">Turing wasn&#39;t the only one who realized these sorts of things. As I mentioned earlier, Ada Lovelace had the same visions back in the mid 1800s. David Hilbert did too. As did Nikola Tesla in 1898 and Isaac Asimov in the early 1900s.</p></li><li role="doc-endnote" id="fnmkynjbuxpn"><span><sup><strong><a href="#fnrefmkynjbuxpn">^</a></strong></sup></span><p id="block343">Or, perhaps I should say, before they had math machines, they had to use computers. Because &#34;computer&#34; used to refer to a human who performs mathematical calculations with pencil and paper. I still can&#39;t get over how weird that is.</p></li><li role="doc-endnote" id="fn1kzgq805da5"><span><sup><strong><a href="#fnref1kzgq805da5">^</a></strong></sup></span><p id="block345">Actually, before then, there was a small period of time when computers mixed electrical and mechanical components.</p></li><li role="doc-endnote" id="fn59l2q9akkc4"><span><sup><strong><a href="#fnref59l2q9akkc4">^</a></strong></sup></span><p id="block347">I guess you could say that those computers that had to be rewired were, technically, still programmable. It&#39;s just that the programming = a ton of rewiring and was a huge pain in the ass.</p></li><li role="doc-endnote" id="fnkq24pdxsznj"><span><sup><strong><a href="#fnrefkq24pdxsznj">^</a></strong></sup></span><p id="block349">I&#39;m talking about early transistors here. Over time they get smaller and smaller and smaller.</p></li><li role="doc-endnote" id="fnrg0tbwcetu"><span><sup><strong><a href="#fnrefrg0tbwcetu">^</a></strong></sup></span><p id="block351">If you&#39;re someone who prefers Alamaeda to Berkeley, Berkeley to Cupertino, and Cupertino to Alamaeda, then this doesn&#39;t apply to you. However, I would appreciate it if you would reach out to me. I have a few ideas for some mutually beneficial financial exchanges we could engage in.</p></li><li role="doc-endnote" id="fndw8fwb9zugp"><span><sup><strong><a href="#fnrefdw8fwb9zugp">^</a></strong></sup></span><p id="block353">If you want the deets, check out <a href="https://medium.com/@adamzerner/how-computers-work-e20e1fd228cf">this old post</a> I wrote.</p></li><li role="doc-endnote" id="fn4mmsjx26xe"><span><sup><strong><a href="#fnref4mmsjx26xe">^</a></strong></sup></span><p id="block355">Look back at that old picture of the ENIAC earlier in this post.</p></li><li role="doc-endnote" id="fnej8gyg8yrws"><span><sup><strong><a href="#fnrefej8gyg8yrws">^</a></strong></sup></span><p id="block357">I don&#39;t really understand the reasons for this. Sorry.</p></li><li role="doc-endnote" id="fn7m7gmw84r9u"><span><sup><strong><a href="#fnref7m7gmw84r9u">^</a></strong></sup></span></li></ol></div></div></div></div>
  </body>
</html>
