<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://github.blog/2022-04-18-highlights-from-git-2-36/">Original</a>
    <h1>Highlights from Git 2.36</h1>
    
    <div id="readability-page-1" class="page"><div><div>


<div id="post-64204">
	<p>The open source Git project just <a href="https://lore.kernel.org/git/xmqqh76qz791.fsf@gitster.g/T/#u">released Git 2.36,</a> with features and bug fixes from over 96 contributors, 26 of them new. We last caught up with you on the latest in Git back <a href="https://github.blog/2022-01-24-highlights-from-git-2-35/">when 2.35 was released</a>.</p>
<p>To celebrate this most recent release, here’s GitHub’s look at some of the most interesting features and changes introduced since last time.</p>
<h2>Review merge conflict resolution with –remerge-diff</h2>
<p>Returning readers may remember our coverage of <a href="https://github.blog/2021-08-16-highlights-from-git-2-33/">merge <code>ort</code></a>, the from-scratch rewrite of Git’s <a href="https://git-scm.com/docs/merge-strategies#Documentation/merge-strategies.txt-recursive"><code>recursive</code></a> merge engine.</p>
<p>This release brings another new feature powered by <code>ort</code>, which is the <code>--remerge-diff</code> option. To explain what <code>--remerge-diff</code> is and why you might be excited about it, let’s take a step back and talk about <code>git show</code>.</p>
<p>When given a commit <code>git show</code> will print out that commit’s log message as well as its diff. But it has slightly different behavior when given a merge commit, especially one that had merge conflicts. If you’ve ever passed a conflicted merge to <code>git show</code>, you might be familiar with this output:</p>
<p><img src="https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472" alt="" width="1024" height="472" data-recalc-dims="1" data-lazy-srcset="https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472?w=1884 1884w, https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472?w=300 300w, https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472?w=768 768w, https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472?w=1024 1024w, https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472?w=1536 1536w" data-lazy-sizes="(max-width: 1000px) 100vw, 1000px" data-lazy-src="https://github.blog/wp-content/uploads/2022/04/git-1.png?resize=1024%2C472&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></p>
<p>If you look closely, you might notice that there are actually two columns of diff markers (the <code>+</code> and <code>-</code> characters to indicate lines added and removed). These come from the output of <code>git diff-tree -cc</code>, which is showing us the diff between each parent and the post-image of the given commit simultaneously.</p>
<p>In this particular example, the conflict occurs because one side has an extra argument in the <code>dwim_ref()</code> call, and the other includes an updated comment to use reflect renaming a variable from <code>sha1</code> to <code>oid</code>. The left-most markers show the latter resolution, and the right-most markers show the former.</p>
<p>But this output can be understandably difficult to interpret. In Git 2.36, <code>--remerge-diff</code> takes a different approach. Instead of showing you the diffs between the merge resolution and each parent simultaneously, <code>--remerge-diff</code> shows you the diff between the file with merge conflicts, and the resolution.</p>
<p><img loading="lazy" src="https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472" alt="" width="1024" height="472" data-recalc-dims="1" data-lazy-srcset="https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472?w=1884 1884w, https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472?w=300 300w, https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472?w=768 768w, https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472?w=1024 1024w, https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472?w=1536 1536w" data-lazy-sizes="(max-width: 1000px) 100vw, 1000px" data-lazy-src="https://github.blog/wp-content/uploads/2022/04/git-2.png?resize=1024%2C472&amp;is-pending-load=1" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"/></p>
<p>The above shows the output of <code>git show</code> with <code>--remerge-diff</code> on the same conflicted merge commit as before. Here, we can see the <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-mergeconflictStyle"><code>diff3</code>-style</a> conflicts (shown in red, since the merge commit <em>removes</em> the conflict markers during resolution) along with the resolution. By more clearly indicating which parts of the conflict were left as-is, we can more easily see how the given commit resolved its conflicts, instead of trying to weave-together the simultaneous diff output from <code>git diff-tree -cc</code>.</p>
<p>Reconstructing these merges is made possible using <code>ort</code>. The <code>ort</code> engine is significantly faster than its predecessor, <code>recursive</code>, and can reconstruct all conflicted merge in linux.git in about 3 seconds (as compared to <code>diff-tree -cc</code>, which takes more than 30 seconds to perform the same operation</p>
<p>Give it a whirl in your Git repositories on 2.36 by running <code>git show --remerge-diff</code> on some merge conflicts in your history.</p>
<p>[<a href="https://github.com/git/git/compare/34230514b83f55ea0f4531e8486533ac5c3e2ffe...0dec322d31db3920872f43bdd2a7ddd282a5be67">source</a>]</p>
<h2>More flexible fsync configuration</h2>
<p>If you have ever looked around in your repository’s <code>.git</code> directory, you’ll notice a variety of files: objects, references, reflogs, packfiles, configuration, and the like. Git writes these objects to keep track of the state of your repository, creating new object files when you make new commits, update references, repack your repository, and so on.</p>
<p>Most likely, you haven’t had to think too hard about how these files are written and updated. If you’re curious about these details, then read on! When any application writes changes to your filesystem, those changes aren’t immediately persisted, since writing to the external storage medium is <a href="https://gist.github.com/jboner/2841832">significantly slower</a> than updating your filesystem’s in-memory caches.</p>
<p>Instead, changes are staged in <a href="https://en.wikipedia.org/wiki/Page_cache">memory</a> and periodically flushed to disk at which point the changes are (usually, though disks and controllers can have their own write caches, too) written to the physical storage medium.</p>
<p>Aside from following standard best-practices (like writing new files to a temporary location and then atomically moving them into place), Git has had a somewhat limited set of configuration available to tune how and when it calls <code>fsync</code>, mostly limited to <a href="https://git-scm.com/docs/git-config/2.36.0#Documentation/git-config.txt-corefsyncObjectFiles"><code>core.fsyncObjectFiles</code></a>, which, when set, causes Git to call <code>fsync()</code> when creating new <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-Objects">loose object files</a>. (Git has had non-configurable <code>fsync()</code> calls scattered throughout its codebase for things like writing packfiles, the commit-graph, multi-pack index, and so on).</p>
<p>Git 2.36 introduces a significantly more flexible set of configuration options to tune how and when Git will explicitly <code>fsync</code> lots of different kinds of files, not just if it <code>fsync</code>s loose objects.</p>
<p>At the heart of this new change are two new configuration variables:</p>
<p>You can also tune how Git ensures the durability of components included in your <code>core.fsync</code> configuration by setting the <code>core.fsyncMethod</code> to either <code>fsync</code> (which calls <code>fsync()</code>, or issues a special <a href="https://man7.org/linux/man-pages/man2/fcntl.2.html"><code>fcntl()</code></a> on macOS), or <code>writeout-only</code>, which schedules the written data for flushing, though does not guarantee that metadata like directory entries are updated as part of the flush operation.</p>
<p>Most users won’t need to change these defaults. But for server operators who have many Git repositories living on hardware that may suddenly lose power, having these new knobs to tune will provide new opportunities to enhance the durability of written data.</p>
<p>[<a href="https://github.com/git/git/compare/a68dfadae5e95c7f255cf38c9efdcbc2e36d1931...b9f5d0358d2e882d47f496c1a5589f6cebc25578">source</a>, <a href="https://github.com/git/git/compare/eb804cd405618ef78b772072685c39392aea4ac1...bc22d845c4328f5bd896d019b3729f776ad4be4c">source</a>, <a href="https://github.com/git/git/compare/da95e25656690e4b585b73677e9db746bd796a67...9a4987677d3f65e8cd93b9e77216f0f1026cd9b2">source</a>]</p>
<h2>Stricter repository ownership checks</h2>
<p>If you haven’t seen <a href="https://github.blog/2022-04-12-git-security-vulnerability-announced/">our blog post from last week</a> announcing the security patches for versions 2.35 and earlier, let me give you a brief recap.</p>
<p>Beginning in Git 2.35.2, Git changed its default behavior to prevent you from executing <code>git</code> commands in a repository owned by a different user than the current one. This is designed to prevent <code>git</code> invocations from unintentionally executing commands which the repository owner configured.</p>
<p>You can bypass this check by setting the new <a href="https://git-scm.com/docs/git-config/Documentation/git-config.txt-safedirectory"><code>safe.directory</code> configuration</a> to include trusted repositories owned by other users. If you can’t upgrade immediately, our <a href="https://github.blog/2022-04-12-git-security-vulnerability-announced/">blog post</a> outlines some steps you can take to mitigate your risk, though the safest thing you can do is upgrade to the latest version of Git.</p>
<p>Since publishing <a href="https://github.blog/2022-04-12-git-security-vulnerability-announced/">that blog post</a>, the <code>safe.directory</code> option now interprets the value <code>*</code> to consider all Git repositories as safe, regardless of their owner.  You can set this in your <code>--global</code> config to opt-out of the new behavior in situations where it makes sense.</p>
<p>[<a href="https://github.com/git/git/compare/ab1f2765f78e75ee51dface57e1071b3b7f42b09...53ef17d3ee0f7fcb151f428ee3bd736b8046825f">source</a>]</p>
<h2>Tidbits</h2>
<p>Now that we have looked at some of the bigger features in detail, let’s turn to a handful of smaller topics from this release.</p>
<ul>
<li>If you’ve ever spent time poking around in the internals of one of your Git repositories, you may have come across the <code>git cat-file</code> command. Reminiscent of <code>cat</code>, this command is useful for printing out the raw contents of Git objects in your repository. <code>cat-file</code> has a handful of other modes that go beyond just printing the contents of an object. Instead of printing out one object at a time, it can accept a stream of objects (via stdin) when passed the <code>--batch</code> or <code>--batch-check</code> command-line arguments. These two similarly-named options have slightly different outputs: <code>--batch</code> instructs <code>cat-file</code> to just print out each object’s contents, while <code>--batch-check</code> is used to print out information about the object itself, like its type and size<sup id="fnref-64204-1"><a href="#fn-64204-1" title="Read footnote.">1</a></sup>.
<p>But what if you want to dynamically switch between the two? Before, the only way was to run two separate copies of the <code>cat-file</code> command in the same repository, one in <code>--batch</code> mode and the other in <code>--batch-check</code> mode. In Git 2.36, you no longer need to do this.  You can instead run a single <code>git cat-file</code> command with the new <code>--batch-command</code> mode. This mode lets you ask for the type of output you want for each object. Its input looks either like <code>contents &lt;object&gt;</code>, or <code>info &lt;object&gt;</code>, which correspond to the output you’d get from <code>--batch</code>, or <code>--batch-check</code>, respectively.</p>
<p>For server operators who may have long-running <code>cat-file</code> commands intended to service multiple requests, <code>--batch-command</code> accepts a new <code>flush</code> command, which flushes the output buffer upon receipt.</p>
<p>[<a href="https://github.com/git/git/compare/47be28e51e6a3b390e694d868b7da04181e99e96...440c705ea63253642c8f4761f80eb7a97a62b614">source</a>, <a href="https://github.com/git/git/compare/07135d6be732aca61dfa77d03a3aa06120767c03...473fa2df08d9c6e2a4ff81ddc74f53f4b94a7983">source</a>]</p>
</li>
<li>
<p>Speaking of Git internals, if you’ve ever needed to script around the contents of a tree object in your repository, then there’s no doubt that <code>git ls-tree</code> has come in handy.</p>
<p>If you aren’t familiar with <code>ls-tree</code>, the gist is that it allows you to list the contents of a tree objects, optionally recursing through nested sub-trees. Its output looks something like this:</p>
<pre><code>$ git ls-tree HEAD -- builtin/
100644 blob 3ffb86a43384f21cad4fdcc0d8549e37dba12227  builtin/add.c
100644 blob 0f4111bafa0b0810ae29903509a0af74073013ff  builtin/am.c
100644 blob 58ff977a2314e2878ee0c7d3bcd9874b71bfdeef  builtin/annotate.c
100644 blob 3f099b960565ff2944209ba514ea7274dad852f5  builtin/apply.c
100644 blob 7176b041b6d85b5760c91f94fcdde551a38d147f  builtin/archive.c
[...]
</code></pre>
<p>Previously, the customizability of <code>ls-tree</code>‘s output was somewhat limited. You could restrict the output to just the filenames with <code>--name-only</code>, print absolute paths with <code>--full-name</code>, or abbreviate the object IDs with <code>--abbrev</code>, but that was about it.</p>
<p>In Git 2.36, you have a lot more control about how <code>ls-tree</code>‘s should look. There’s a new <code>--object-only</code> option to complement <code>--name-only</code>. But if yo really want to customize its output, the new <code>--format</code> option is your best bet. You can select from any combination and order of the each entry’s mode, type, name, and size.</p>
<p>Here’s a fun example of where something like this might come in handy. Let’s say you’re interested in the distribution of file-sizes of blobs in your repository. Before, to get a list of object sizes, you would have had to do either:</p>
<pre><code>$ git ls-tree ... | awk &#39;{ print $3 }&#39; | git cat-file --batch-check=&#39;%(objectsize)&#39;
</code></pre>
<p>or (ab)use the <code>--long</code> format and pull out the file sizes of blobs:</p>
<pre><code>$ git ls-tree -l | awk &#39;{ print $4 }&#39;
</code></pre>
<p>but now you can ask for just the file sizes directly, making it much more convenient to script around them:</p>
<pre><code>$ dist () {
 ruby -lne &#39;print 10 ** (Math.log10($_.to_i).ceil)&#39; | sort -n | uniq -c
}
$ git ls-tree --format=&#39;%(objectsize)&#39; HEAD:builtin/ | dist
  8 1000
 59 10000
 53 100000
  2 1000000
</code></pre>
<p>…showing us that we have 8 files that are between 1-10 KiB in size, 59 files between 10-100 KiB, 53 files between 100 KiB and 1 MiB, and 2 files larger than 1 MiB.</p>
<p>[<a href="https://github.com/git/git/compare/3ff8cbfe8a333f55931fa9b588f106e060a67079...9c4d58ff2c385f49585197c8650356955e1fa02e">source</a>, <a href="https://github.com/git/git/compare/95acb13a550cbc07a5ef38ffceb5678fac61acff...350296cc78912c245847ec65e55143053450cce1">source</a>, <a href="https://github.com/git/git/compare/07330a41d66a2c9589b585a3a24ecdcf19994f19...5e65dac9c88d02f569cc87cdf630ecb5a780c6a6">source</a>, <a href="https://github.com/git/git/compare/bf23fe5c37d62f37267d31d4afa1a1444f70cdac...acd34fd5f60ab01e871dfa3a3bb8b81828ac181d">source</a>]</p>
</li>
<li>
<p>If you’ve ever tried to track down a bug using Git, then you’re familiar with the <code>git bisect</code> command. If you haven’t, here’s a quick primer. <code>git bisect</code> takes two revisions of your repository, one corresponding to a known “good” state, and another corresponding to some broken state. The idea is then to run a <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a> between those two points in history to find the first commit which transitioned the good state to the broken state.</p>
<p>If you aren’t a frequent bisect user, you may not have heard of the <code>git bisect run</code> command. Instead of requiring you to classify whether each point along the search is good or bad, you can supply a script which Git will execute for you, using its <a href="https://en.wikipedia.org/wiki/Exit_status">exit status</a> to classify each revision for you.</p>
<p>This can be useful when trying to figure out which commit broke the build, which you can do by running:</p>
<pre><code>$ git bisect start &lt;bad&gt; &lt;good&gt;
$ git bisect run make
</code></pre>
<p>which will run <code>make</code> along the binary search between <code>&lt;bad&gt;</code> and <code>&lt;good&gt;</code>, outputting the first commit which broke compilation.</p>
<p>But what about automating more complicated tests? It can often be useful to write a one-off shell script which runs some test for you, and then hand that off to <code>git bisect</code>. Here, you might do something like:</p>
<pre><code>$ vi test.sh
# type type type
$ git bisect run test.sh
</code></pre>
<p>See the problem? We forgot to mark <code>test.sh</code> as <a href="https://en.wikipedia.org/wiki/File-system_permissions#Permissions">executable</a>! In previous versions of Git, <code>git bisect</code> would incorrectly carry on the search, classifying each revision as broken. In Git 2.36, <code>git bisect</code> will detect that you forgot to mark the script as executable, and halt the search early.</p>
<p>[<a href="https://github.com/git/git/compare/967176465a62fe3f71008e20c5959c12542ef2b0...48af1fdee374e205c9774c163fbd4683d1110d11">source</a>]</p>
</li>
<li>
<p>When you run <code>git fetch</code>, your Git client communicates with the remote to carry out a process called <a href="https://git-scm.com/docs/pack-protocol/2.2.3#_packfile_negotiation">negotiation</a> to determine which objects the server needs to send to complete your request. Roughly speaking, your client and the server mutually advertise what they have at the tips of each <a href="https://git-scm.com/book/en/v2/Git-Internals-Git-References">reference</a>, then your client lists which objects it wants, and the server sends back all objects <em>between</em> the requested objects and the ones you already have.</p>
<p>This works well because Git always expects to maintain <a href="https://en.wikipedia.org/wiki/Closure_(mathematics)">closure</a> over reachable objects<sup id="fnref-64204-2"><a href="#fn-64204-2" title="Read footnote.">2</a></sup>, meaning that if you have some reachable object in your repository, you also have all of its ancestors.</p>
<p>In other words, it’s fine for the Git server to omit objects you already have, since the combination of the objects it sends along with the ones you already have should be sufficient to assemble the branches and tags your client asked for.</p>
<p>But if your repository is corrupt, then you may need the server to send you objects which are reachable from ones you already have, in which case it isn’t good enough for the server to just send you the objects between what you have and want. In the past, getting into a situation like this may have led you to re-clone your entire repository.</p>
<p>Git 2.36 ships with a new option to <code>git fetch</code> which makes it easier to recover from certain kinds of repository corruption. By passing the new  <code>--refetch</code> option, you can instruct <code>git fetch</code> to fetch <em>all</em> objects from the remote, regardless of which objects you already have, which is useful when the contents of your <code>objects</code> directory are suspect.</p>
<p>[<a href="https://github.com/git/git/compare/1b54f5b89ac2efb5256b1870fabef28ea55e2f20...4963d3e41fa454500760fe6f8fb1bab890c1c3eb">source</a>]</p>
</li>
<li>
<p><a href="https://github.blog/2022-01-24-highlights-from-git-2-35/">Returning readers</a> may remember our earlier discussions about <a href="https://github.blog/2021-11-10-make-your-monorepo-feel-small-with-gits-sparse-index/">the sparse index</a> and <a href="https://github.blog/2020-01-17-bring-your-monorepo-down-to-size-with-sparse-checkout/">sparse checkouts</a>, which make it possible to only have part of your repository checked out at a time.</p>
<p>Over the last handful of releases, more and more commands have become compatible with the sparse index. This release is no exception, with four more Git commands joining the pack. Git 2.36 brings sparse index support to <code>git clean</code>, <code>git checkout-index</code>, <code>git update-index</code>, and <code>git read-tree</code>.</p>
<p>If you haven’t used these commands, there’s no need to worry: adding support to these <a href="https://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain">plumbing</a> commands is designed to lay the ground work for building a sparse index-aware <code>git stash</code>. In the meantime, sparse index support already exists in the commands that you are most likely already familiar with, like <code>git status</code>, <code>git commit</code>, <code>git checkout</code>, and more.</p>
<p>As an added bonus, <code>git sparse-checkout</code> (which is used to enable the sparse checkout feature and dictate which parts of your repository you want checked out) gained support for the command-line completion Git ships in its <a href="https://github.com/git/git/tree/v2.36.0/contrib"><code>contrib</code> directory</a>.</p>
<p>[<a href="https://github.com/git/git/compare/708cbef33a2c905c920e94b70d0946f9f4ff3a4e...b9ca5e26579ceb820103b49648c01187a4a0dddd">source</a>, <a href="https://github.com/git/git/compare/430883a70c79614e52279f2800a9a383ffc68fe5...f27c170f645e6b8ed642c49c503964893ee26a4f">source</a>, <a href="https://github.com/git/git/compare/b80121027d1247a0754b3cc46897fee75c050b44...48803821b1712687d6e06e9d7a0e911eabecf4d1">source</a>]</p>
</li>
<li>
<p>Returning readers may remember our <a href="https://github.blog/2020-12-21-get-up-to-speed-with-partial-clone-and-shallow-clone/">previous coverage on partial clones</a>, a relatively new feature in Git which allows you to initialize your clones by downloading just some of the objects in your repository.</p>
<p>If you used this feature in the past with <code>git clone</code>‘s <code>--recurse-submodules</code> flag, the partial clone filter was only applied to the top-level repository, cloning all of the objects in the submodules.</p>
<p>This has been fixed in the latest release, where the <code>--filter</code> specification you use in your top-level clone is applied recursively to any submodules your repository might contain, too.</p>
<p>[<a href="https://github.com/git/git/compare/d21d5ddfe675f9dbcdbb94ab01776115a2d1fdde...f05da2b48b48a46db65fc768b3ffecaf996dd655">source</a>, <a href="https://github.com/git/git/compare/77da6db57f90bb0478df4d2a111363c80f0c0748...5da9560ebc8a089807920a7548141e4e5b60a4dc">source</a>]</p>
</li>
<li>
<p>While we’re talking about partial clones, now is a good time to mention partial <em>bundles</em>, which are new in Git 2.36. You may not have heard of <a href="https://git-scm.com/book/en/v2/Git-Tools-Bundling">Git bundles</a>, which is a different way of transferring around parts of your repository.</p>
<p>Roughly speaking, a bundle combines the data in a <a href="https://git-scm.com/book/en/v2/Git-Internals-Packfiles">packfile</a>, along with a list of references that are contained in the bundle. This allows you to capture information about the state of your repository into a single file that you can share. For example, the Git project uses bundles to <a href="https://github.com/git/git/blob/v2.36.0/Documentation/howto/coordinate-embargoed-releases.txt#L59-L65">share embargoed security releases with various Linux distribution maintainers</a>. This allows us to send all of the objects which comprise a new release, along with the tags that point at them in a single file over email.</p>
<p>In previous releases of Git, it was impossible to prepare a filtered bundle which you could apply to a partial clone. In Git 2.36, you can now prepare filtered bundles, whose contents are unpacked as if they arrived during a partial clone<sup id="fnref-64204-3"><a href="#fn-64204-3" title="Read footnote.">3</a></sup>. You can’t yet initialize a new clone from a partial bundle, but you can use it to fetch objects into a bare repository:</p>
<pre><code>$ git bundle create --filter=blob:none ../partial.bundle v2.36.0
$ cd ..
$ git init --bare example.repo
$ git fetch --filter=blob:none ../partial.bundle &#39;refs/tags/*:refs/tags/*&#39;
[ ... ]
From ../example.bundle
* [new tag]             v2.36.0 -&gt; v2.36.0
</code></pre>
<p>[<a href="https://github.com/git/git/compare/b6763af74ba55570deae38ce118c1d803d7b825c...86fdd94d723b7fa1870a64e8080d3540a434f29b">source</a>, <a href="https://github.com/git/git/compare/1041d58b4d9c587b2b6c76c3dfb14fbe78ccf196...5cb28270a1ff94a0a23e67b479bbbec3bc993518">source</a>]</p>
</li>
<li>
<p>Lastly, let’s discuss a bug fix concerning Git’s <a href="https://github.blog/2021-04-29-scaling-monorepo-maintenance/">multi-pack reachability bitmaps</a>. If you have started to use this new feature, you may have noticed a handful of new files in your <code>.git/objects/pack</code> directory:</p>
<pre><code>$ ls .git/objects/pack/multi-pack-index*
.git/objects/pack/multi-pack-index
.git/objects/pack/multi-pack-index-33cd13fb5d4166389dbbd51cabdb04b9df882582.bitmap
.git/objects/pack/multi-pack-index-33cd13fb5d4166389dbbd51cabdb04b9df882582.rev
</code></pre>
<p>In order, these are: the <a href="https://git-scm.com/docs/multi-pack-index">multi-pack index</a> (MIDX) itself, the reachability bitmap data, and the reverse-index which tells Git which bits correspond to what objects in your repository.</p>
<p>These are all associated back to the MIDX via the MIDX’s <a href="https://en.wikipedia.org/wiki/Checksum">checksum</a>, which is how Git knows that the three belong together. This release fixes a bug where the <code>.rev</code> file could fall out-of-sync with the MIDX and its bitmap, leading Git to report incorrect results when using a multi-pack bitmap. This happens when changing the object order of the MIDX without changing the set of objects tracked by the MIDX.</p>
<p>If your <code>.rev</code> file has a modification time that is significantly older than the MIDX and <code>.bitmap</code>, you may have been bitten by this bug<sup id="fnref-64204-4"><a href="#fn-64204-4" title="Read footnote.">4</a></sup>. Luckily this bug can be resolved by dropping and regenerating your bitmaps<sup id="fnref-64204-5"><a href="#fn-64204-5" title="Read footnote.">5</a></sup>. To prevent a MIDX bitmap and its <code>.rev</code> file from falling out of sync again, the contents of the <code>.rev</code> are now included in the MIDX itself, forcing the MIDX’s checksum to change whenever the object order changes.</p>
<p>[<a href="https://github.com/git/git/compare/90b7153806af46ca62b85a92a2810015be2453d4...f8b60cf99b0ab10d915c7bfd4802a1af45d0d439">source</a>]</p>
</li>
</ul>
<h2>The rest of the iceberg</h2>
<p>That’s just a sample of changes from the latest release. For more, check out the <a href="https://github.com/git/git/blob/v2.36.0/Documentation/RelNotes/2.36.0.txt">release notes for 2.36</a>, or <a href="https://github.com/git/git/tree/v2.36.0/Documentation/RelNotes">any previous version</a> in the Git repository.</p>


    

</div>


</div></div></div>
  </body>
</html>
