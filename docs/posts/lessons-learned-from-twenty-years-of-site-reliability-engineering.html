<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://sre.google/resources/practices-and-processes/twenty-years-of-sre-lessons-learned/">Original</a>
    <h1>Lessons Learned from Twenty Years of Site Reliability Engineering</h1>
    
    <div id="readability-page-1" class="page"><div id="page-content">
  <section>
    <div>
      <div>
        
        <h2>Or, Eleven things we have learned  as Site Reliability Engineers at Google</h2>
        <h3>Authors</h3>
        <p>Adrienne Walcer, Kavita Guliani, Mikel Ward, Sunny Hsiao, and Vrai Stacey</p>
        <h3>Contributors</h3>
        <p>Ali Biber, Guy Nadler, Luisa Fearnside, Thomas Holdschick, and Trevor Mattson-Hamilton</p>
        <h3>Foreword</h3>
<p>A lot can happen in twenty years, especially when you&#39;re busy growing.</p>
<p>Two decades ago, Google had a pair of small datacenters, each housing a few thousand servers, connected in a ring by a pair of 2.4G network links. We ran our private cloud (though we didn&#39;t call it that at the time) using Python scripts such as &#34;Assigner&#34; and &#34;Autoreplacer&#34; and &#34;Babysitter&#34; which operated on config files full of individual server names. We had a small database of the machines (MDB) which helped keep information about individual servers organized and durable. Our small team of engineers used scripts and configs to solve some common problems automatically, and to reduce the manual labor required to manage our little fleet of servers.</p>
<p>Time passed, Google&#39;s users came for the search and stayed for the free GB of Gmail, and our fleet and network grew with it. Today, in terms of computing power, we are over 1,000 times as large as we were 20 years ago; in network, over 10,000 times as large, and we spend far less effort per server than we used to while enjoying much better reliability from our service stack. Our tools have evolved from a collection of Python scripts, to integrated ecosystems of services, to a unified platform which offers reliability by default. And our understanding of the problems and failure modes of distributed systems also evolved, as we experienced new classes of outages. We created the <a href="https://sre.google/sre-book/accelerating-sre-on-call/" title="Wheel of Misfortune">Wheel of Misfortune</a>, we wrote <a href="https://sre.google/sre-book/service-best-practices/" title="Service Best Practices guides">Service Best Practices guides</a>, we published Google&#39;s Greatest Hits, and today are delighted to present:</p>
<p>Lessons learned from two decades of Site Reliability Engineering</p>
<p>Let&#39;s start back in 2016, when YouTube was offering your favorite videos such as &#34;Carpool Karaoke with Adele&#34; and the ever-catchy &#34;Pen-Pineapple-Apple-Pen.&#34; YouTube experienced a fifteen-minute global outage, due to a bug in YouTube&#39;s distributed memory caching system, disrupting YouTube&#39;s ability to serve videos. Here are three lessons we learned from this incident.</p>
          <div>
            <h2>1</h2>
            <p>The riskiness of a mitigation should scale with the severity of the outage</p>
          </div>
          <p>There&#39;s a meme where one person posts a picture of a spider seen in their house, and the captain says, &#34;TIME 2 MOVE 2 A NEW HOUSE!&#34;. The joke is that the incident (seeing a scary spider) would be responded to with a severe mitigation (abandon your current home and move to a new one). We, here in SRE, have had some interesting experiences in choosing a mitigation with more risks than the outage it&#39;s meant to resolve. During the aforementioned YouTube outage, a risky load-shedding process didn&#39;t fix the outage... it instead created a cascading failure.</p>
<p>We learned the hard way that during an incident, we should monitor and evaluate the severity of the situation and choose a mitigation path whose riskiness is appropriate for that severity. In a best case scenario, a risky mitigation resolves an outage. In a worst case scenario, the risky mitigation misfires and the outage is prolonged by something that was intended to fix it. Additionally, if everything is broken, you can make an informed decision to bypass standard procedures.</p>
          <div>
            <h2>2</h2>
            <p>Recovery mechanisms should be fully tested before an emergency</p>
          </div>
          <p>An emergency fire evacuation in a tall city building is a terrible opportunity to use a ladder for the first time. Similarly, an outage is a terrible opportunity to try a risky load-shedding process for the first time. To keep your cool during a high-risk and high-stress situation, it&#39;s important to practice recovery mechanisms and mitigations beforehand and verify that:</p>
<ul>
<li>they&#39;ll do what you need them to do</li>
<li>you know how to do them</li>
</ul>
<p>Testing recovery mechanisms has a fun side effect of reducing the risk of performing some of these actions. Since this messy outage, we&#39;ve doubled down on testing.</p>
          
          <p>At one point, we wanted to push a caching configuration change. We were pretty sure that it would not lead to anything bad. But pretty sure is not 100% sure. Turns out, caching was a pretty critical feature for YouTube, and the config change had some unintended consequences that fully hobbled the service for 13 minutes. Had we <a href="https://sre.google/workbook/canarying-releases/" title="canaried those global changes">canaried those global changes</a> with a progressive rollout strategy, this outage could have been curbed before it had global impact. <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/24017e52c907294589604a29a86f158828eda078.pdf" rel="noopener noreferrer" target="_blank" title="Read more">Read more about the canary strategy in this paper</a>, and <a href="https://www.usenix.org/conference/srecon18europe/presentation/davidovic" rel="noopener noreferrer" target="_blank" title="learn more">learn more in this video</a>.</p>
<p>Around the same timeframe, YouTube&#39;s slightly younger sibling, Google Calendar, also experienced an outage which serves as the backdrop for the next two lessons.</p>
          <div>
            <h2>4</h2>
            <p>Have a &#34;Big Red Button&#34;</p>
          </div>
          <p>A &#34;Big Red Button&#34; is a unique but highly practical safety feature: it should kick off a simple, easy-to-trigger action that reverts whatever triggered the undesirable state to (ideally) shut down whatever&#39;s happening. &#34;Big Red Buttons&#34; come in many shapes and sizesâ€”and it&#39;s important to identify what those big red buttons might be before you submit a potentially risky action. We once narrowly missed a major outage because the engineer who submitted the would-be-triggering change unplugged their desktop computer before the change could propagate. So when planning your major rollouts, consider What is my big red button? Ensure every service dependency has a &#34;big red button&#34; to exercise in an emergency. See <a href="https://www.oreilly.com/content/generic-mitigations/" rel="noopener noreferrer" target="_blank" title="Generic Mitigations">&#34;Generic Mitigations&#34;</a> for more!</p>
          <div>
            <h2>5</h2>
            <p>Unit tests alone are not enough - integration testing is also needed</p>
          </div>
          <p>Ahh.... unit tests. They verify that an individual component can perform the way we need it to. Unit tests have intentionally limited scope, and are super helpful, but they also don&#39;t fully replicate the runtime environment and productionized demands that might exist. For this reason, we are big advocates of integration testing! We can use integration tests to verify that jobs and tasks can perform a cold start. Will things work the way we want them to? Will components work together the way we want them too? Will these components successfully create the system we want them to? This lesson was learned during a Calendar outage in which our testing didn&#39;t follow the same path as real use, resulting in plenty of testing... that didn&#39;t help us assess how a change would perform in reality.</p>
<p>Shifting to an incident that happened in February 2017, we find our next two lessons.</p>
<p>First, unavailable OAuth tokens caused millions of users to be logged out of devices and services, and 32,000 OnHub and Google WiFi devices to perform a factory reset. Manual account recovery claims jumped by 10x because of failed logins. It took Google about 12 hours to fully recover from the outage.</p>
          <div>
            <h2>6</h2>
            <p>COMMUNICATION CHANNELS! AND BACKUP CHANNELS!! AND BACKUPS FOR THOSE BACKUP CHANNELS!!!</p>
          </div>
          <p>Yes, it was a bad time. You want to know what made it worse? Teams were expecting to be able to use Google Hangouts and Google Meet to manage the incident. But when 350M users were logged out of their devices and services... relying on these Google services was, in retrospect, kind of a bad call. Ensure that you have non-dependent backup communication channels, and that you have tested them.</p>
<p>Then, the same 2017 incident led us to better understand <a href="https://sre.google/sre-book/addressing-cascading-failures/#:~:text=Graceful%20degradation%20takes%20the%20concept,decreasing%20the%20quality%20of%20responses." title="graceful degradation">graceful degradation:</a></p>
          <div>
            <h2>7</h2>
            <p>Intentionally degrade performance modes</p>
          </div>
          <p>It&#39;s easy to think of availability as either &#34;fully up&#34; or &#34;fully down&#34; ... but being able to offer a continuous minimum functionality with a degraded performance mode helps to offer a more consistent user experience. So we&#39;ve built degraded performance modes carefully and intentionallyâ€”so during rough patches, it might not even be user-visible (it might be happening right now!). Services should degrade gracefully and continue to function under exceptional circumstances.</p>
<p>This next lesson is a recommendation to ensure that your last-line-of-defense system works as expected in extreme scenarios, such as natural disasters or cyber attacks, that result in loss of productivity or service availability.</p>
          <div>
            <h2>8</h2>
            <p>Test for Disaster resilience</p>
          </div>
          <p>Besides unit testing and integration testing, there are other types of very important testing: disaster resilience and recovery testing. While resilience testing verifies that your service or system could survive in the event of faults, latency, or disruptions, recovery testing verifies that your service can transition back to homeostasis after a full shutdown. Both should be critical pieces of your business continuity strategyâ€”as described in <a href="https://queue.acm.org/detail.cfm?id=2371516" rel="noopener noreferrer" target="_blank" title="Weathering the Unexpected">&#34;Weathering the Unexpected&#34;</a>. A useful activity can also be sitting your team down and working through how some of these scenarios could theoretically play outâ€”tabletop game style. This can also be a fun opportunity to explore those terrifying &#34;What Ifs&#34;, for example, &#34;What if part of your network connectivity gets shut down unexpectedly?&#34;.</p>
          <div>
            <h2>9</h2>
            <p>Automate your mitigations</p>
          </div>
          <p>In March of 2023, a near-simultaneous failure of multiple networking devices occurred in a few datacenters, resulting in a widespread packet loss. In this 6-day outage, an estimated 70% of services experienced varied levels of impact, depending on the location, service load, and configuration at the time of network failure.</p>
<p>In such instances, you can reduce your mean time to resolution (MTTR), by automating mitigating measures done by hand. If there&#39;s a clear signal that a particular failure is occurring, then why can&#39;t that mitigation be kicked off in an automated way? Sometimes it is better to use an automated mitigation first and save the root-causing for after user impact has been avoided.</p>
          <div>
            <h2>10</h2>
            <p>Reduce the time between rollouts, to decrease the likelihood of the rollout going wrong</p>
          </div>
          <p>In March of 2022, a widespread outage in the payments system prevented customers from completing transactions, resulting in the PokÃ©mon GO community day being postponed. The cause was the removal of a single database field, which should have been safe as all uses of that field were removed from the code beforehand. Unfortunately, a slow rollout cadence of one part of the system meant that the field was still being used by the live system.</p>
<p>Having long delays between rollouts, especially in complex, multiple component systems, makes it extremely difficult to reason out the safety of a particular change. <a href="https://cloud.google.com/blog/products/devops-sre/using-the-four-keys-to-measure-your-devops-performance" rel="noopener noreferrer" target="_blank" title="Frequent rollouts">Frequent rollouts</a>â€”with the proper testing in placeâ€” lead to fewer surprises from this class of failure.</p>
          <div>
            <h2>11</h2>
            <p>A single global hardware version is a single point of failure</p>
          </div>
          <p>Having only one particular model of device to perform a critical function can make for simpler operations and maintenance. However, it means that if that model turns out to have a problem, that critical function is no longer being performed.</p>
<p>This happened in March 2020 when a networking device that had an undiscovered zero-day bug, encountered a change in traffic patterns that triggered that bug. As the same model and version of the device was being used across the network, a substantial regional outage ensued. What prevented this from being a total outage was the presence of multiple network backbones that allowed high-priority traffic to be routed via a still working alternative.</p>
<p>Latent bugs in critical infrastructure can lurk undetected until a seemingly innocuous event triggers them. Maintaining a diverse infrastructure, while incurring costs of its own, can mean the difference between a troublesome outage and a total one.</p>
        <p>So there you have it! Eleven lessons learned, from two decades of Site Reliability Engineering at Google. Why eleven? Well, you see, Google Site Reliability, with our rich history, is still in our <span>prime</span>.</p>
        
      </div>
    </div>
  </section>
    </div></div>
  </body>
</html>
