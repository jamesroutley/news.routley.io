<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://brunocalza.me/making-a-change-to-sqlite-source-code/">Original</a>
    <h1>Making a change to SQLite source code</h1>
    
    <div id="readability-page-1" class="page"><div id="site-main">
    <div>

        <article>

            


            <section>
                <div>
                    <p>The other day, I was thinking about how I could get the bytes of a <a href="https://www.sqlite.org/fileformat.html#record_format">record</a> of a recently inserted or updated row in <code>SQLite</code>. The motivation for that is that I wanted to create a hash of that row, essentially, to be able to build a <a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</a> of the corresponding table as rows get inserted or updated.</p><p>The closest API that <code>SQLite</code> offers to what I was looking for is the <a href="https://www.sqlite.org/c3ref/update_hook.html">sqlite3_update_hook</a>:</p><blockquote>The <code>sqlite3_update_hook()</code> interface registers a callback function with the database connection identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a rowid table.</blockquote><p>The issue with that API is that it only returns the <a href="https://sqlite.org/lang_createtable.html#rowid">rowid</a> of the row. That means I would have to fetch all the columns for the rows inside the column. And even with that approach, I would still not get the raw bytes of the row record. I would just get the driver&#39;s representation of that row. </p><p>There are probably plenty of approaches to how I could build such a tree, but as far as I&#39;m concerned, the <code>SQLite</code> API does not offer what I was exactly looking for. So, I decided to dig deeper into the source code to see if there could be a world where I would understand it, and not only that, I could actually make some changes to it to provide what I was hoping for. </p><p>I have always felt intimidated by reading <code>C</code> language code. So I thought it would be just one of those times of opening a <code>C</code> language file and giving up minutes later. But it turns out this time was different. </p><p>I&#39;ve cloned <code>SQLite</code> <a href="https://sqlite.org/src/doc/trunk/README.md">source code</a> using <code>fossil</code> and started navigating the files structure. </p><figure><img src="https://brunocalza.me/content/images/2022/09/Screen-Shot-2022-09-26-at-21.27.31.png" alt="" srcset="https://brunocalza.me/content/images/size/w600/2022/09/Screen-Shot-2022-09-26-at-21.27.31.png 600w, https://brunocalza.me/content/images/size/w1000/2022/09/Screen-Shot-2022-09-26-at-21.27.31.png 1000w, https://brunocalza.me/content/images/size/w1600/2022/09/Screen-Shot-2022-09-26-at-21.27.31.png 1600w, https://brunocalza.me/content/images/2022/09/Screen-Shot-2022-09-26-at-21.27.31.png 2030w" sizes="(min-width: 720px) 720px"/><figcaption>Figure 1 - SQLite src directory</figcaption></figure><p>If you&#39;re somewhat familiar with how databases work you can probably imagine what some files are responsible for. Not bad. I decided to jump straight to the <code>insert.c</code> file to see if I could find something interesting there. </p><p>If you skim through all function implementation you&#39;ll probably hit <code><a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/insert.c#L671">sqlite3Insert</a></code>. Above the function signature, we see:</p><!--kg-card-begin: markdown--><pre><code>** This routine is called to handle SQL of the following forms:
**
**    insert into TABLE (IDLIST) values(EXPRLIST),(EXPRLIST),...
**    insert into TABLE (IDLIST) select
**    insert into TABLE (IDLIST) default values
**
</code></pre>
<!--kg-card-end: markdown--><p>Maybe inside this function, there was something that I could tweak. I was able to make some guesses about what&#39;s happening in there, but what caught my eye was the number of function calls to functions of a name similar to <code>sqlite3vdbeXXX</code>.</p><p>That reminded me that <code>SQLite</code> uses a virtual machine called <a href="https://www.sqlite.org/opcode.html">vdbe</a>. That means all SQL statements are translated to the language of this virtual machine first. Then, the execution engine executes the virtual machine code. Let&#39;s look at an example of how a simpler <code>INSERT</code> is translated into bytecode:</p><!--kg-card-begin: markdown--><pre><code>sqlite&gt; create table a (a int, b text);
sqlite&gt; explain INSERT INTO a VALUES (1, &#39;Hello&#39;);
addr  opcode         p1    p2    p3    p4             p5  comment      
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     8     0                    0   Start at 8
1     OpenWrite      0     2     0     2              0   root=2 iDb=0; a
2     Integer        1     2     0                    0   r[2]=1
3     String8        0     3     0     Hello          0   r[3]=&#39;Hello&#39;
4     NewRowid       0     1     0                    0   r[1]=rowid
5     MakeRecord     2     2     4     DB             0   r[4]=mkrec(r[2..3])
6     Insert         0     4     1     a              57  intkey=r[1] data=r[4]
7     Halt           0     0     0                    0   
8     Transaction    0     1     1     0              1   usesStmtJournal=0
9     Goto           0     1     0                    0   
</code></pre>
<!--kg-card-end: markdown--><p>I concluded that all <code><a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/insert.c#L671">sqlite3Insert</a></code> is really doing is translating a parsed <code>INSERT</code> statement to a bunch of virtual machine operations, according to all rules of <code>SQLite</code> insertion.</p><p>This was not really the place I was looking for. What I really needed was the place where the record is created before insertion. That could only be the place that is executing the virtual machine code, probably the place that is executing the <code>Insert (<code>OP_INSERT</code>)</code> Â opcode, I thought. </p><p>Looking at <em>Figure 1</em>, the <code>vdbe.c</code> file felt like a reasonable place to look for that. I went straight there. </p><p>What I found there was an <strong>8000</strong> lines <a href="https://github.com/sqlite/sqlite/blob/master/src/vdbe.c#L875"><code>switch( pOp-&gt;opcode )</code></a> statement and with a simple <em>CMD+F</em> <code>OP_INSERT</code> I found the <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5393">place</a> that was handling the <code>Insert</code> operation execution.</p><p>The first line of the case I found a hint of what I was looking for:</p><pre><code> Mem *pData;       /* MEM cell holding data for the record to be inserted */</code></pre><p>So <code>pData</code> points to the record data to be inserted. And you can see at <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5402"></a><a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5402">L54</a>02, <code>pData = &amp;aMem[pOp-&gt;p2];</code>, how it is setting <code>pData</code> value to the virtual machine memory <code>aMem</code> address at the position pointed by virtual machine register <code>p2</code>. </p><p>Quick recap: at <code>insert.c</code> we&#39;ve learned that the <code>INSERT</code> statement was translated into a bunch of virtual machine code. The data from the <code>INSERT</code> went to the virtual machine through those <code>sqlite3vdbeXXX</code> calls. I assume the call that registered the <code>OP_INSERT</code> opcode and the data into the virtual machine is the one at line <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/insert.c#L2593">2593</a>:</p><pre><code>sqlite3VdbeAddOp3(v, OP_Insert, iDataCur, aRegIdx[i], regNewData);</code></pre><p>And <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/insert.c#L1560">here</a> is a nice description of <code>regNewData</code> :</p><!--kg-card-begin: markdown--><pre><code>** The regNewData parameter is the first register in a range that contains
** the data to be inserted or the data after the update.  There will be
** pTab-&gt;nCol+1 registers in this range.  The first register (the one
** that regNewData points to) will contain the new rowid, or NULL in the
** case of a WITHOUT ROWID table.  The second register in the range will
** contain the content of the first table column.  The third register will
** contain the content of the second table column.  And so forth.
**
** The regOldData parameter is similar to regNewData except that it contains
** the data prior to an UPDATE rather than afterwards.  regOldData is zero
** for an INSERT.  This routine can distinguish between UPDATE and INSERT by
** checking regOldData for zero.
</code></pre>
<!--kg-card-end: markdown--><p>So, at this point we are executing that machine code with that data. Scrolling a bit down, let&#39;s see how <code>pData</code> is used. At <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5448-L5449">L5448-L5449</a>, we see:</p><pre><code>  x.pData = pData-&gt;z;
  x.nData = pData-&gt;n;</code></pre><p>And <code>x</code> <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5400">is</a>:</p><pre><code> BtreePayload x;   /* Payload to be inserted */</code></pre><p>Awesome. Scrolling a bit more, we <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5457">see</a>:</p><pre><code>  rc = sqlite3BtreeInsert(pC-&gt;uc.pCursor, &amp;x,
      (pOp-&gt;p5 &amp; (OPFLAG_APPEND|OPFLAG_SAVEPOSITION|OPFLAG_PREFORMAT)), 
      seekResult
  );</code></pre><p>Cool, we found the place where the raw record byte is being inserted. But, how do we know that it is the record formatted as documented <a href="https://www.sqlite.org/fileformat.html#record_format">here</a>? If you look closely at the virtual machine code from our example <code>INSERT</code>, before the <code>Insert</code> opcode there is a <code>MakeRecord</code> opcode, that is responsible for building the record. </p><p>You can check the <code>OP_MakeRecord</code> implementation at <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L3153">vdbe.c</a> file and see the following comment:</p><blockquote>Convert P2 registers beginning with P1 into the [record format] use as a data record in a database table or as a key in an index.</blockquote><p>And the <a href="https://github.com/sqlite/sqlite/blob/version-3.39.4/src/vdbe.c#L5464-L5473">last lines</a> of the case statement, we find this:</p><pre><code>  /* Invoke the update-hook if required. */
  if( rc ) goto abort_due_to_error;
  if( pTab ){
    assert( db-&gt;xUpdateCallback!=0 );
    assert( pTab-&gt;aCol!=0 );
    db-&gt;xUpdateCallback(db-&gt;pUpdateArg,
           (pOp-&gt;p5 &amp; OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT,
           zDb, pTab-&gt;zName, x.nKey);
  }
  break;</code></pre><p>Yes! The update hook!</p><p>So, here I have everything I need in my hands. The update hook and the record bytes. So, I just need to update the callback to add the record, and <em>voila.</em></p><p>That&#39;s exactly what I did:</p><pre><code>db-&gt;xUpdateCallback(db-&gt;pUpdateArg,
	(pOp-&gt;p5 &amp; OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT,
	zDb, pTab-&gt;zName, x.nKey, pData-&gt;z, pData-&gt;n);</code></pre><p>Passing the payload (<code>pData-&gt;z</code>) and its size (<code>pData-&gt;n</code>).</p><p>And, of course a bunch of more changes in multiple places to account for function signature change were necessary.</p><p>Here&#39;s <code>fossil status</code> after the changes:</p><pre><code>EDITED     src/main.c
EDITED     src/sqlite.h.in
EDITED     src/sqlite3ext.h
EDITED     src/sqliteInt.h
EDITED     src/tclsqlite.c
EDITED     src/vdbe.c</code></pre><p>And the <a href="https://gist.github.com/brunocalza/7fccffae20878694cc4cf8237af61de0">diff</a> of changes in case you&#39;re following along. I&#39;ve compiled my changes following the <a href="https://sqlite.org/src/doc/trunk/README.md">instructions</a>. </p><p>All right! Now it&#39;s time to create a simple test of my change in a Go program. I&#39;m most familiar with <a href="https://github.com/mattn/go-sqlite3">mattn/go-sqlite3</a> driver for interacting with <code>SQLite</code>. This project offers <code>SQLite</code> API access through <code>Go</code> by importing the <code>SQLite</code> <a href="https://github.com/mattn/go-sqlite3/blob/master/sqlite3-binding.c">amalgamation file</a> and working through <code>C</code> bindings. </p><p>So I <a href="https://github.com/brunocalza/go-sqlite3">forked that repo</a>, and imported <a href="https://github.com/mattn/go-sqlite3/compare/master...brunocalza:go-sqlite3:bcalza/updatehook#diff-6fecad8f0a67dd53104130218011b8fcd7c1180ebd083b2e0a2840a487cb49d8">my own compiled amalgamation file</a>. And did the <a href="https://github.com/mattn/go-sqlite3/compare/master...brunocalza:go-sqlite3:bcalza/updatehook">necessary updates</a> in the <code>Go</code> API to have access to that new value. My linter messed up with the diff. But only a few changes were needed:</p><ul><li>A change at the <a href="https://github.com/mattn/go-sqlite3/compare/master...brunocalza:go-sqlite3:bcalza/updatehook#diff-6c33163da8a75fb344db8bf4261df0fe2f6fc8a8e867221fe0bb81cb8de77643R74">updateHookTrampoline</a> that now receives the record as <code>*C.char</code> and its size as <code>int</code>, and casts it to <code>[]byte</code> passing it to callback:</li></ul><pre><code>func updateHookTrampoline(handle unsafe.Pointer, op int, db *C.char, table *C.char, rowid int64, data *C.char, size int) {
	callback := lookupHandle(handle).(func(int, string, string, int64, []byte))
	callback(op, C.GoString(db), C.GoString(table), rowid, C.GoBytes(unsafe.Pointer(data), C.int(size)))
}</code></pre><ul><li>And a change to <a href="https://github.com/mattn/go-sqlite3/compare/master...brunocalza:go-sqlite3:bcalza/updatehook#diff-2b10fcf999dec2c93bce3364fdeefd688eda6ad78934ac1a2d8b359b57ee7687R575">RegisterUpdateHook</a>.</li></ul><p>So, now we have everything in place to test this out. Let&#39;s run a simple example inspired by <a href="https://fly.io/blog/sqlite-internals-btree/">SQLite Internals: Pages &amp; B-trees</a> blog post.</p><pre><code>package main

import (
	&#34;database/sql&#34;
	&#34;fmt&#34;
	&#34;log&#34;
	&#34;os&#34;

	&#34;github.com/mattn/go-sqlite3&#34;
)

func main() {
	sqlite3conn := []*sqlite3.SQLiteConn{}
	sql.Register(&#34;sqlite3_with_hook_example&#34;,
		&amp;sqlite3.SQLiteDriver{
			ConnectHook: func(conn *sqlite3.SQLiteConn) error {
				sqlite3conn = append(sqlite3conn, conn)
				conn.RegisterUpdateHook(func(op int, db string, table string, rowid int64, data []byte) {
					switch op {
					case sqlite3.SQLITE_INSERT:
						fmt.Printf(&#34;%x\n&#34;, data)
					}
				})
				return nil
			},
		})
	os.Remove(&#34;./foo.db&#34;)

	srcDb, err := sql.Open(&#34;sqlite3_with_hook_example&#34;, &#34;./foo.db&#34;)
	if err != nil {
		log.Fatal(err)
	}
	defer srcDb.Close()
	srcDb.Ping()

	_, err = srcDb.Exec(`CREATE TABLE sandwiches (
		id INTEGER PRIMARY KEY,
		name TEXT,
		length REAL,
		count INTEGER
	);`)
	if err != nil {
		log.Fatal(err)
	}
	_, err = srcDb.Exec(&#34;INSERT INTO sandwiches (name, length, count) VALUES (&#39;Italian&#39;, 7.5, 2);&#34;)
	if err != nil {
		log.Fatal(err)
	}
}
</code></pre><p>Don&#39;t forget to add <code>replace github.com/mattn/go-sqlite3 =&gt; github.com/brunocalza/go-sqlite3 v0.0.0-20220926005737-36475033d841</code> to <code>go.mod</code> .</p><p>If you run that, you&#39;ll get:</p><p><code>05001b07014974616c69616e401e00000000000002</code></p><p>Which is exactly the raw record of the row <code>(&#39;Italian&#39;, 7.5, 2)</code> as described at <a href="https://fly.io/blog/sqlite-internals-btree/#efficient-sandwich-encoding">Efficient Sandwich Encoding</a>, without the primary key and the length of the record (two first bytes).</p><p>And here I finish the journey. It was really fun to know I was able to understand some parts of <code>SQLite</code> source code, although I did not understand most of it, and make some changes and see those changes reflected through <code>Go</code>&#39;s driver. </p><p>To be honest this approach of changing the source code of a database is too risky. Keeping up-to-date with new versions (and also I&#39;d have to also keep an up-to-date fork of the <code>Go</code>&#39;s driver) is too problematic. Â </p><p>I work on a web3 protocol called <a href="https://tableland.xyz/">Tableland</a>. Problems similar to this are always frequent in our Engineering team. If you enjoy this kind of stuff, get in touch through our <a href="https://github.com/tablelandnetwork/">Github</a> or <a href="https://discord.gg/dc8EBEhGbg">Discord</a>, or <a href="https://twitter.com/brunocalza">@brunocalza</a>.</p>
                </div>
            </section>



        </article>

    </div>
</div></div>
  </body>
</html>
