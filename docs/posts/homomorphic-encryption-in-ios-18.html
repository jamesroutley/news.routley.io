<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://boehs.org/node/homomorphic-encryption">Original</a>
    <h1>Homomorphic encryption in iOS 18</h1>
    
    <div id="readability-page-1" class="page"><div><dl><dt><strong><a href="https://kracekumar.com/locations/">in</a></strong></dt><dd><a href="https://kracekumar.com/in/blog">blog</a></dd><dt><strong><a href="https://kracekumar.com/tags/">tags</a></strong></dt><dd><ul><li><a href="https://kracekumar.com/tag/apple">apple</a></li><li><a href="https://kracekumar.com/tag/security">security</a></li><li><a href="https://kracekumar.com/tag/math">math</a></li><li><a href="https://kracekumar.com/tag/ai">ai</a></li></ul></dd><dt><strong>date</strong></dt><dd><span itemprop="datePublished" content="Fri Jan 10 2025 00:00:00 GMT+0000 (Coordinated Universal Time)">1/10/2025</span></dd></dl><hr/><blockquote><p><a href="https://kracekumar.com/post/subtitle-generator-using-whisper/penpen">PenPen</a>&#39;s Note: This article is written with the intent of accessibility to non-maths folk who possess some computer knowhow. It comes in wake of the shit storm following Jeff Johnson’s recent “<a href="https://lapcatsoftware.com/articles/2024/12/3.html">Apple Photos phones home on iOS 18 and macOS 15</a>”. There’s a lot of confusion and curiosity about how this technology works, along with criticisms lobbed at Apple’s densely packed published research. The goal of this post is to distill that research into a more understandable package, so that you can make more informed decisions about your data. “<a href="https://pxlnv.com/linklog/enhanced-visual-search/">Nowhere does Apple plainly say what is going on</a>”, but maybe I can.</p></blockquote><p>You are Apple. You want to make search work like magic in the Photos app, so the user can find all their “dog” pictures with ease. You devise a way to numerically represent the <em>concepts</em> of an image, so that you can find how closely images are related in meaning. Then, you create a database of known images and <em>their</em> numerical representations (“this number means car”), and find the closest matches. To preserve privacy, you put this database on the phone.</p><p>All of this, as cool as it might sound, is a <a href="https://youtu.be/wjZofJX0v4M?t=747">solved</a> <a href="https://stackoverflow.blog/2023/11/09/an-intuitive-introduction-to-text-embeddings/">problem</a>. This “numerical representation” is called an embedding vector. A vector is a series of coordinates in a very high dimensional space. One dimension might measure how “dog-like” a thing is. Another might measure how “wild-like” a thing is. Dog-like <em>and</em> wild-like? That’s a wolf. We can compare distances using algorithms like cosine similarity. We are quite good at turning text into vectors, and only slightly worse at doing the same for images.</p><p>But then, your database grows. Your users don’t want <em>all</em> dogs, they want golden retrievers. You can no longer fit this database on a device. You’re tempted to store this database on your servers, and send the numerical representation computed on device off to them. This should be fine: vectorization is a lossy operation. But then you would know that Amy takes lots of pictures of golden retrievers, and that is a political disaster.</p><h2 id="the-promise-of-homomorphic-encryption" tabindex="-1">The promise of homomorphic encryption</h2><p>Another thing we’re pretty good at is encryption. Encryption enables us to take a series of bits and scramble them, such that an observer (someone without a key) cannot read the original value. When the correct key is applied, the original value is restored.</p><p>For encryption to work, small changes to the input must change the output in unpredictable ways. If this <em>wasn’t</em> the case, an attacker could gradually refine an input, with the goal of creating increasingly similar encrypted outputs. When the outputs match, the attacker knows the original value.</p><p>Unfortunately, encryption as we know it is of little use to us. If we encrypt our vector before we send it, Apple’s servers cannot read the value of the vector. If Apple’s servers cannot read the value of the vector, then they do not know what database entry is most closely located to our vector (if they <em>do</em> know, then our encryption failed). Servers cannot tell us things they do not know. Therefore, all this was for waste.</p><p>This conjecture sounds concrete, but one of the statements is false. What if I told you that servers <em>can</em> tell us things they do not know? Enter homomorphic encryption.</p><p>The premise is as follows: the client sends the server an encrypted value. The server cannot read the value. The server <em>can</em> modify the value, but it cannot know the new value resulting from this modification. In essence, the server is operating with a blindfold.</p><figure><p><img src="https://kracekumar.com/assets/Pasted%20image%2020250109220746.png" alt="A stock image of a woman using an old computer wearing a blindfold"/></p><figcaption>Real photo of apple server rooms</figcaption></figure><p>Take addition. You are given unknown value <code>P</code>, and you add known value <code>Q</code> to it. You can deduce that the resulting value is equal to <code>P+Q</code>, but you do not know what <code>P+Q</code> <em>is</em>, nor do you know <code>P</code>. The client decrypts the value using it’s key, and obtains the result of <code>P+Q</code>. Since the client also knows the value of <code>P</code>, it can backsolve for <code>Q</code>.</p><svg width="547" height="469" xmlns="http://www.w3.org/2000/svg"><defs id="defs_1"></defs><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" d="M 0,0 l 547,0 l 0,469 l-547 0 z" fill="transparent" stroke="none"></path><g opacity="1" transform="matrix(1,0,0,1,85.2125015258789,10)"><g opacity="1"><line opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x1="40" y1="50" x2="40" y2="388.84000000000003" stroke="var(--fg2)"></line><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" d="M 4,0 l 72,0 a 4,4,0,0,1,4,4 l 0,42 a 4,4,0,0,1,-4,4 l -72,0 a 4,4,0,0,1,-4,-4 l 0,-42 a 4,4,0,0,1,4,-4 z" fill="var(--light)" stroke="#3b4044"></path><text alignment-baseline="central" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="40" y="25" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Client</text></g><g opacity="1"><line opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x1="308.797" y1="50" x2="308.797" y2="388.84000000000003" stroke="var(--fg2)"></line><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" d="M 272.797,0 l 72,0 a 4,4,0,0,1,4,4 l 0,42 a 4,4,0,0,1,-4,4 l -72,0 a 4,4,0,0,1,-4,-4 l 0,-42 a 4,4,0,0,1,4,-4 z" fill="var(--light)" stroke="#3b4044"></path><text alignment-baseline="central" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="308.797" y="25" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Server</text></g><g opacity="1"></g><g opacity="1"><path opacity="1" stroke-width="2" stroke-opacity="1" fill-opacity="1" stroke="var(--fg2)" d="M 40,90.02000000000001 C 100,80.02000000000001 100,120.02000000000001 40,110.02000000000001" x1="40" x2="40" y2="110.02000000000001" fill="none"></path><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="31.339745962155618" y="110.02000000000001" fill="var(--fg2)" d="M 31.339745962155618 105.02000000000001L 31.339745962155618 115.02000000000001L 40 110.02000000000001Z" stroke="none" transform="matrix(-1,-1.2246467991473532e-16,1.2246467991473532e-16,-1,79.99999999999999,220.04000000000002)"></path><text alignment-baseline="before-edge" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="40" y="60" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" width="221.79899999999998" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Generate plaintext value P</text></g><g opacity="1"><path opacity="1" stroke-width="2" stroke-opacity="1" fill-opacity="1" stroke="var(--fg2)" d="M 40,153.78400000000002 C 100,143.78400000000002 100,183.78400000000002 40,173.78400000000002" x1="40" x2="40" y2="173.78400000000002" fill="none"></path><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="31.339745962155618" y="173.78400000000002" fill="var(--fg2)" d="M 31.339745962155618 168.78400000000002L 31.339745962155618 178.78400000000002L 40 173.78400000000002Z" stroke="none" transform="matrix(-1,-1.2246467991473532e-16,1.2246467991473532e-16,-1,79.99999999999997,347.56800000000004)"></path><text alignment-baseline="before-edge" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="40" y="120.02000000000001" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" width="250.42499999999998" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Encrypt P into ciphertext E(P)</text></g><g opacity="1"><line opacity="1" stroke-width="2" stroke-opacity="1" fill-opacity="1" x1="40" y1="207.54800000000003" x2="308.797" y2="207.54800000000003" stroke="var(--fg2)"></line><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="300.13674596215566" y="207.54800000000003" fill="var(--fg2)" d="M 300.13674596215566 202.54800000000003L 300.13674596215566 212.54800000000003L 308.797 207.54800000000003Z" stroke="none" transform="matrix(1,0,0,1,0,0)"></path><text alignment-baseline="before-edge" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="184.3985" y="183.78400000000002" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" width="288.797" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Send E(P)</text></g><g opacity="1"><path opacity="1" stroke-width="2" stroke-opacity="1" fill-opacity="1" stroke="var(--fg2)" d="M 308.797,251.31200000000004 C 368.797,241.31200000000004 368.797,281.312 308.797,271.312" x1="308.797" x2="308.797" y2="271.312" fill="none"></path><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="300.13674596215566" y="271.312" fill="var(--fg2)" d="M 300.13674596215566 266.312L 300.13674596215566 276.312L 308.797 271.312Z" stroke="none" transform="matrix(-1,-1.2246467991473532e-16,1.2246467991473532e-16,-1,617.594,542.624)"></path><text alignment-baseline="before-edge" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="308.797" y="217.54800000000003" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" width="305.792" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Modify E(P) blindly: E(P)+E(Q)=E(P+Q)</text></g><g opacity="1"><line opacity="1" stroke-width="2" stroke-opacity="1" fill-opacity="1" x1="308.797" y1="305.076" x2="40" y2="305.076" stroke="var(--fg2)"></line><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="31.339745962155618" y="305.076" fill="var(--fg2)" d="M 31.339745962155618 300.076L 31.339745962155618 310.076L 40 305.076Z" stroke="none" transform="matrix(-1,-1.2246467991473532e-16,1.2246467991473532e-16,-1,79.99999999999997,610.152)"></path><text alignment-baseline="before-edge" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="184.3985" y="281.312" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" width="288.797" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Send modified ciphertext E(P+Q)</text></g><g opacity="1"><path opacity="1" stroke-width="2" stroke-opacity="1" fill-opacity="1" stroke="var(--fg2)" d="M 40,348.84000000000003 C 100,338.84000000000003 100,378.84000000000003 40,368.84000000000003" x1="40" x2="40" y2="368.84000000000003" fill="none"></path><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="31.339745962155618" y="368.84000000000003" fill="var(--fg2)" d="M 31.339745962155618 363.84000000000003L 31.339745962155618 373.84000000000003L 40 368.84000000000003Z" stroke="none" transform="matrix(-1,-1.2246467991473532e-16,1.2246467991473532e-16,-1,79.99999999999996,737.6800000000001)"></path><text alignment-baseline="before-edge" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="40" y="315.076" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" width="227.402" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Decrypt to get result (P+Q)</text></g><g opacity="1"><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" d="M 4,388.84000000000003 l 72,0 a 4,4,0,0,1,4,4 l 0,42 a 4,4,0,0,1,-4,4 l -72,0 a 4,4,0,0,1,-4,-4 l 0,-42 a 4,4,0,0,1,4,-4 z" fill="var(--light)" stroke="#3b4044"></path><text alignment-baseline="central" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="40" y="413.84000000000003" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Client</text></g><g opacity="1"><path opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" d="M 272.797,388.84000000000003 l 72,0 a 4,4,0,0,1,4,4 l 0,42 a 4,4,0,0,1,-4,4 l -72,0 a 4,4,0,0,1,-4,-4 l 0,-42 a 4,4,0,0,1,4,-4 z" fill="var(--light)" stroke="#3b4044"></path><text alignment-baseline="central" text-anchor="middle" opacity="1" stroke-width="1" stroke-opacity="1" fill-opacity="1" x="308.797" y="413.84000000000003" font-size="13" font-family="&#39;Input Mono Compressed&#39;, monospace" font-style="normal" font-weight="400" font-variant="normal" fill="var(--fg2)" paint-order="stroke" style="stroke-linecap:butt; stroke-linejoin:miter;" stroke="none">Server</text></g></g></svg><p>There are two main operations that hold in a homomorphic scheme:</p><ul><li><strong>Homomorphic addition</strong>: <code>E(P) + E(Q) = E(P + Q)</code></li><li><strong>Homomorphic multiplication</strong>: <code>E(P) * E(Q) = E(P * Q)</code></li></ul><p>Operations typically reserved for plaintext can now be performed on ciphertext!</p><p>There are a number of complexities associated with homomorphic encryption, such as the accumulation of <a href="https://www.jeremykun.com/2024/05/04/fhe-overview/#basic-operations-and-dealing-with-noise">noise</a>. Supporting a truly arbitrary number of operations is quite difficult, but if you can support both gates with arbitrary depth, you have <em>fully</em> homomorphic encryption. The actual maths behind this is quite complex, and will unfortunately need to be out of scope. There’s some interest in creating compilers for homomorphic encryption, and our code samples will be Rust, loosely based on the <a href="https://docs.sunscreen.tech/fhe/intro/intro.html">Sunscreen</a> compiler for simplicity. <a href="https://docs.zama.ai/concrete">Concrete</a> is likely a much <a href="https://medium.com/optalysys/fully-homomorphic-encryption-and-the-game-of-life-d7c37d74bbaf">more robust</a> option, with a higher learning curve.</p><details><summary>Open call for cryptographers</summary><p>The world could use an explanation of the maths behind homomorphic encryption (and, by extension, post-quantum encryption!) in simple English.</p><p>I somewhat understand the shortest vector problem and the resulting insecure GGH encryption scheme.</p><p>I <em>think</em> I understand that the fundamentals of BFV is ‘Ring learning with errors’, where the client generates a number of polynomials, picks some value of <code>w</code>, and calculates the answers to each equation for its value of <code>w</code>. The public key is the system with a private value of <code>w</code>, and public solutions. The solutions have some random error. The solution to RLWE can be used to solve a shortest vector problem in a lattice. But it’s all a little fuzzy.</p><p>I’m looking for some 3blue1brown style intuitive explanation of how BFV works end to end, I haven’t really found one. Maybe it exists? If so, let me know. If it doesn’t exist, maybe you’d like to make one ;)</p></details><h3 id="what-do-homomorphic-programs-look-like%3F" tabindex="-1">What do homomorphic programs look like?</h3><p>Below is a simple homomorphic program that multiplies two encrypted values:</p><pre tabindex="0"><code><span><span>#[</span><span>fhe_program</span><span>]</span></span>
<span><span>fn</span><span> multiply</span><span>(</span><span>a</span><span>:</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;,</span><span> b</span><span>:</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;)</span><span> -&gt;</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;</span><span> {</span></span>
<span><span>    a</span><span> *</span><span> b</span></span>
<span><span>}</span></span>
<span><span>fn</span><span> main</span><span>()</span><span> {</span></span>
<span><span>    let</span><span> (</span><span>public_key</span><span>,</span><span> private_key</span><span>)</span><span> =</span><span> runtime</span><span>.</span><span>generate_keys</span><span>()</span><span>?</span><span>;</span></span>
<span><span>    // client encrypts value using its public key. This encrypted value can only be decrypted using the private key. This is called asymmetric encryption.</span></span>
<span><span>    let</span><span> client_value</span><span> =</span><span> runtime</span><span>.</span><span>encrypt</span><span>(</span><span>Signed</span><span>::</span><span>from</span><span>(</span><span>8</span><span>),</span><span> &amp;</span><span>public_key</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    // The private key isn&#39;t sent to the server, so the server cannot decrypt the &#39;8&#39;</span></span>
<span><span>    let</span><span> res</span><span> =</span><span> server</span><span>(</span><span>public_key</span><span>,</span><span> client_value</span><span>);</span></span>
<span><span>    // client uses its private key to decrypt the value. result = 24</span></span>
<span><span>    let</span><span> result</span><span> =</span><span> runtime</span><span>.</span><span>decrypt</span><span>(</span><span>res</span><span>,</span><span> &amp;</span><span>private_key</span><span>)</span><span>?</span><span>;</span></span>
<span><span>}</span></span>
<span><span>// the server does not receive the private key, and thus cannot decrypt the result nor client_value</span></span>
<span><span>fn</span><span> server</span><span>(</span><span>public_key</span><span>:</span><span> PublicKey</span><span>,</span><span> client_value</span><span>:</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;)</span><span> -&gt;</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;</span><span> {</span></span>
<span><span>	// server encrypts a new value using the user&#39;s public key</span></span>
<span><span>    let</span><span> server_value</span><span> =</span><span> runtime</span><span>.</span><span>encrypt</span><span>(</span><span>Signed</span><span>::</span><span>from</span><span>(</span><span>3</span><span>),</span><span> &amp;</span><span>public_key</span><span>)</span><span>?</span><span>;</span></span>
<span><span>    // server runs &#39;multiply&#39; using both the client_value and the server_value, and returns the response</span></span>
<span><span>    runtime</span><span>.</span><span>run</span><span>(</span><span>multiply</span><span>,</span><span> vec!</span><span>[</span><span>client_value</span><span>,</span><span> server_value</span><span>],</span><span> &amp;</span><span>public_key</span><span>)</span><span>?</span><span>;</span></span>
<span><span>}</span></span></code></pre><p>This example is quite simple. It gets much more complicated when you need to perform a number of operations, such what may be required by private information retrieval, as you need to structure the query as some primitive mathematical operations.</p><p>More specifically, HE programs tend to <em>only</em> support <code>add</code> and <code>mul</code> instructions by their nature. Comparisons and Modulus are very difficult. So you need to structure your query in very particular ways.</p><p>For instance, to retrieve a value from a database, the query can be structured a vector of length <code>n</code>, where <code>n</code> is the size of the database. The query is a vector of <code>0</code>s, with a <code>1</code> at the index of the value you want to retrieve. Then, you perform a dot product with the database, and all values except the one you want to retrieve will be zeroed out:</p><pre tabindex="0"><code><span><span>// [0, 0, 1, 0, 0] * [10, 20, 30, 40, 50] = [0, 0, 30, 0, 0]</span></span>
<span><span>#[</span><span>fhe_program</span><span>]</span></span>
<span><span>fn</span><span> lookup</span><span>(</span><span>query</span><span>:</span><span> [</span><span>Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;;</span><span> DATABASE_SIZE</span><span>],</span><span> database</span><span>:</span><span> [</span><span>Signed</span><span>;</span><span> DATABASE_SIZE</span><span>])</span><span> -&gt;</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;</span><span> {</span></span>
<span><span>    let</span><span> mut</span><span> sum</span><span> =</span><span> query</span><span>[</span><span>0</span><span>]</span><span> *</span><span> database</span><span>[</span><span>0</span><span>];</span></span>
<span><span>    for</span><span> i</span><span> in</span><span> 1</span><span>..</span><span>DATABASE_SIZE</span><span> {</span></span>
<span><span>        sum</span><span> =</span><span> sum</span><span> +</span><span> query</span><span>[</span><span>i</span><span>]</span><span> *</span><span> database</span><span>[</span><span>i</span><span>]</span></span>
<span><span>    }</span></span>
<span><span>    sum</span></span>
<span><span>}</span></span></code></pre><p>You may be thinking that this sounds computationally expensive. You would be correct. In terms of bandwidth, you can reduce the length of inputs. For instance, if you structured the database in two dimensions, the query could encode the row and the column separately, and then you have a query size of <code>2sqrt(n)</code>, without any leaks. You may, however, be paying the price in execution cost.</p><details><summary>sqrt lookup</summary><pre tabindex="0"><code><span><span>#[</span><span>fhe_program</span><span>]</span></span>
<span><span>fn</span><span> lookup</span><span>(</span></span>
<span><span>    col_query</span><span>:</span><span> [</span><span>Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;;</span><span> SQRT_DATABASE_SIZE</span><span>],</span></span>
<span><span>    row_query</span><span>:</span><span> [</span><span>Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;;</span><span> SQRT_DATABASE_SIZE</span><span>],</span></span>
<span><span>    database</span><span>:</span><span> [[</span><span>Signed</span><span>;</span><span> SQRT_DATABASE_SIZE</span><span>];</span><span> SQRT_DATABASE_SIZE</span><span>],</span></span>
<span><span>)</span><span> -&gt;</span><span> Cipher</span><span>&lt;</span><span>Signed</span><span>&gt;</span><span> {</span></span>
<span><span>    let</span><span> mut</span><span> col</span><span> =</span><span> [</span><span>col_query</span><span>[</span><span>0</span><span>];</span><span> SQRT_DATABASE_SIZE</span><span>];</span></span>
<span><span>    // extract desired column</span></span>
<span><span>    for</span><span> i</span><span> in</span><span> 0</span><span>..</span><span>SQRT_DATABASE_SIZE</span><span> {</span></span>
<span><span>        for</span><span> j</span><span> in</span><span> 0</span><span>..</span><span>SQRT_DATABASE_SIZE</span><span> {</span></span>
<span><span>            if</span><span> j</span><span> ==</span><span> 0</span><span> {</span></span>
<span><span>                col</span><span>[</span><span>i</span><span>]</span><span> =</span><span> database</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> *</span><span> col_query</span><span>[</span><span>j</span><span>];</span></span>
<span><span>            }</span><span> else</span><span> {</span></span>
<span><span>                col</span><span>[</span><span>i</span><span>]</span><span> =</span><span> col</span><span>[</span><span>i</span><span>]</span><span> +</span><span> database</span><span>[</span><span>i</span><span>][</span><span>j</span><span>]</span><span> *</span><span> col_query</span><span>[</span><span>j</span><span>];</span></span>
<span><span>            }</span></span>
<span><span>        }</span></span>
<span><span>    }</span></span>
<span><span>    let</span><span> mut</span><span> sum</span><span> =</span><span> col</span><span>[</span><span>0</span><span>]</span><span> *</span><span> row_query</span><span>[</span><span>0</span><span>];</span></span>
<span><span>    for</span><span> i</span><span> in</span><span> 1</span><span>..</span><span>SQRT_DATABASE_SIZE</span><span> {</span></span>
<span><span>        sum</span><span> =</span><span> sum</span><span> +</span><span> col</span><span>[</span><span>i</span><span>]</span><span> *</span><span> row_query</span><span>[</span><span>i</span><span>];</span></span>
<span><span>    }</span></span>
<span><span>    sum</span></span>
<span><span>}</span></span></code></pre></details><blockquote><p><a href="https://kracekumar.com/post/subtitle-generator-using-whisper/penpen">PenPen</a>&#39;s Note: With sunscreen, branching cannot depend on function parameters, and comparisons with those parameters isn’t supported. Not even <code>==</code>. This is because under the hood, everything you do is just algebra with polynomials. By hand, you <em>can</em> implement boolean logic, however. Jeremy Kun writes that “Given this power, you can encrypt your data bit by bit, express your program as a boolean circuit—an <code>XOR</code> gate is addition and an <code>AND</code> gate is multiplication—and simulate the circuit. Since <code>XOR</code> and <code>AND</code> form a universal basis for boolean logic, you can always decompose a circuit this way”. Also, with branching, you might wonder if branches can leak information. <a href="https://www.jeremykun.com/2024/05/04/fhe-overview/#the-highest-level-view">Yes</a>. They can. Hence, the worst case scenario must be executed every time. All <code>if</code> branches must be executed, and all loops must reach their upper bounds (this also means that the bounds must be statically known)</p></blockquote><p>Cosine similarity is more difficult, as it is defined with division and norm operations, but you can normalize the vectors and then do simple scalar products inside the homomorphic program. Preprocessing really is the name of the game.</p><pre tabindex="0"><code><span><span>let</span><span> norm</span><span> =</span><span> (</span><span>vector1</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>map</span><span>(</span><span>|</span><span>x</span><span>|</span><span> x</span><span> *</span><span> x</span><span>)</span><span>.</span><span>sum</span><span>::</span><span>&lt;</span><span>f64</span><span>&gt;())</span><span>.</span><span>sqrt</span><span>();</span></span>
<span><span>let</span><span> normalized_vector</span><span>:</span><span> Vec</span><span>&lt;</span><span>Signed</span><span>&gt;</span><span> =</span><span> vector1</span><span>.</span><span>iter</span><span>()</span><span>.</span><span>map</span><span>(</span><span>|</span><span>x</span><span>|</span><span> Signed</span><span>::</span><span>from</span><span>(</span><span>x</span><span> /</span><span> norm1</span><span>))</span><span>.</span><span>collect</span><span>();</span></span></code></pre><p>We have no way to simply return the best match. At best, we can return scores for each entry in the database, and the client can then decrypt the scores and find the best match:</p><blockquote><p>For each query, the server response contains all the entries in the cluster. […] In Wally, we utilize lattice-based, somewhat homomorphic encryption (SHE) to reduce the response overhead. […] The server computes the distance function between the encrypted information and the cluster entries under SHE and returns encrypted scores. This reduces the response because the size of encrypted scores is significantly smaller than the entries.</p></blockquote><h2 id="apple%E2%80%99s-implementation%3A-wally" tabindex="-1">Apple’s implementation: Wally</h2><blockquote><p><a href="https://kracekumar.com/post/subtitle-generator-using-whisper/penpen">PenPen</a>&#39;s Note: This section provides a high level overview of the <a href="https://arxiv.org/pdf/2406.06761">Scalable Private Search with Wally</a> paper.</p></blockquote><p>Unfortunately, Apple’s implementation of homomorphic encryption is not as pure as what we’ve discussed above. Apple must balance both privacy and performance, which are at odds with each other (HE programs run many orders of magnitude slower than their equivalents).</p><p>Before we get to Apple’s take on HE, let’s take a step beck. A non-private implementation of this search would look like this:</p><ol><li>At initialization, the server separates its documents into clusters of similar documents.</li><li>The client picks the cluster that best matches the query.</li><li>The client sends its vector to the server.</li><li>The server returns the similarity score for each document in the cluster.</li><li>The client picks the best entry.</li><li>The client requests the metadata for the index of the best entry.</li></ol><p>This has the following security flaws:</p><ol><li>The server can read the vector. Embeddings can be <a href="https://arxiv.org/abs/2310.06816">quite revealing</a>.</li><li>The client reveals the nearest cluster. This is a less significant issue, but it can be used to infer the query. For instance, a query with an embedding matching “dog” would likely be in the “animal” cluster.</li><li>To fetch the relevant metadata, the client sends the index of the closest entry to the server. This would also be a privacy leak!</li></ol><h3 id="hiding-the-embedding%3A-back-to-homomorphic-encryption" tabindex="-1">Hiding the embedding: back to homomorphic encryption</h3><p>The embedding vector is by far the most sensitive piece of information that is currently being leaked.</p><p>Fully homomorphic encryption is too slow to be used by Apple, so they use somewhat homomorphic encryption. SHE supports both addition and multiplication logic, but only to a certain depth. Each math operation increases depth, as it increases the amount of noise. Parameters have been chosen that balance security and noise budgets. Obviously it would be ideal not to be working under these constraints. Unfortunately, FHE just isn’t fast enough yet.</p><p>Here are the implemented operations, where <code>ct</code> means <code>E(v)</code> and <code>v</code> is a vector:</p><table><thead><tr><th>SHE operation</th><th>Result</th><th>Time (ms)</th><th>Noise (bits)</th></tr></thead><tbody><tr><td>PtCtAdd(ct, v’)</td><td>E(v + v’)</td><td></td><td></td></tr><tr><td>CtCtAdd(ct, ct’)</td><td>E(v + v’)</td><td>0.004</td><td>0.5</td></tr><tr><td>PtCtMult(ct, v’)</td><td>E(v ⊙ v’)</td><td>0.02</td><td>20</td></tr><tr><td>CtCtMult(ct, ct’)</td><td>E(v ⊙ v’)</td><td>2.5</td><td>26</td></tr><tr><td>CtRotate(ct, r) for r ∈[0, n/2)</td><td></td><td>0.5</td><td>0.5</td></tr></tbody></table><p>In the pesudocode above, the query is a vector of many individually encrypted values. In Apple’s implementation, it appears the whole vector is fit into a singular value:</p><blockquote><p>Overall, in our implementation, the client query and server response are a single RLWE ciphertext of sizes 226kB, and 53kB, respectively, (the former with evaluation keys)</p></blockquote><p>The optimizations they do to the similarity math is described later in the paper, but I’m not gonna lie — it went over my head.</p><h3 id="hiding-the-nearest-cluster" tabindex="-1">Hiding the nearest cluster</h3><p>Of the three leaks, the cluster is the least significant. If the embedding is leaked, a huge amount about the content of the photo is revealed. The breed of dog. The color of the grass. The <em>vibe</em>. If the best match is leaked, the server knows we likely have a photo of a golden retriever. If the cluster is leaked… well it’s an animal of some sort. Apple chose to make some privacy sacrifice for the sake of performance, opting for a technique called differential privacy.</p><p>Apple uses an <a href="https://www.rfc-editor.org/rfc/rfc9458">ohttp</a> anonymization network operated by a 3rd party to proxy requests to Wally. This means that it is impossible to know what device a specific request comes from — it all blends together. In addition, the following mitigations are put in place:</p><ol><li>Clients issue a number of fake queries, then discard the result.</li><li>Queries are clumped together by “epoch”. Within each epoch, a fixed number of users make queries, and their queries are processed at the end of the epoch. The queries are also sent in a random order at random times, hopefully eliminating timing side channels.</li></ol><p><a href="https://lapcatsoftware.com/articles/2025/1/1.html">Jeff Johnson</a> rightfully notes that this scheme is still somewhat flawed:</p><blockquote><p>The two hops, the two companies, are already acting in partnership, so what is there technically in the relay setup to stop the two companies from getting together—either voluntarily or at the secret command of some government—to compare notes, as it were, and connect the dots?</p></blockquote><h3 id="hiding-metadata" tabindex="-1">Hiding metadata</h3><p>Metadata is our third leak. The solution is really quite simple. Instead of querying a cluster for the metadata at one index, the cluster returns the metadata for <em>all</em> indexes stored in that cluster.</p><blockquote><p><a href="https://kracekumar.com/post/subtitle-generator-using-whisper/penpen">PenPen</a>&#39;s Note: This seems like a lot of data the client is getting anyway. I don’t blame you for questioning if the server is actually needed. The thing is, the stored vectors that are compared against are by far the biggest storage user. Each vector can easily be multiple kilobytes. The paper discusses a database of 35 million entries divided across 8500 clusters.</p></blockquote><p>If the metadata is too big, the same techniques detailed in this article can be used for private information retrieval instead of private nearest neighbor search, which is what we’ve focused on up till this point.</p><h2 id="discussion" tabindex="-1">Discussion</h2><p>Before I go any further, I want to make it clear that I am just a hobbyist, not any sort of an expert on this subject matter. I first learned of homomorphic encryption while reading Jeff Johnson’s recent “<a href="https://lapcatsoftware.com/articles/2024/12/3.html">Apple Photos phones home on iOS 18 and macOS 15</a>” and <a href="https://lapcatsoftware.com/articles/2024/12/4.html">later</a> <a href="https://lapcatsoftware.com/articles/2025/1/1.html">posts</a>, and what precedes is 10 or so hours worth of research. I do not contest anything that he wrote.</p><blockquote><p>One natural way of understanding privacy is as synonymous with secrecy. According to this interpretation, if my data is private, then nobody except me can read my data […] The right to privacy can also mean the right to private <em>ownership</em>. […] With Enhanced Visual Search, Apple appears to focus solely on the understanding of privacy as secrecy, ignoring the understanding of privacy as ownership.</p></blockquote><p>I myself, having put in the time to piece together a huge pile of scattered information, have decided I like the feature and will leave it enabled. With that being said, technical understanding is no substitute for consent, which should have been requested by Apple along with a proper explanation.</p><p><img src="https://kracekumar.com/assets/Pasted%20image%2020250109113847.png" alt="&#34;What happens on your iPhone, stays on your iPhone.&#34;"/></p><p>Apple once said that “What happens on your iPhone, stays on your iPhone.” Obviously, this is not entirely the case, and it wasn’t the case long before Apple began using homomorphic encryption.</p><details><summary>A brief tangent about Private Cloud Compute</summary><p>No doubt, they are putting in the effort. Much more than any other tech company. But they still make sacrifices, like when they decided to offload their most complex AI workloads to their servers in a programme called <a href="https://security.apple.com/blog/private-cloud-compute/">Private Cloud Compute</a>. This entails running computations in an isolated, permissionless and stateless environment, and giving security researchers permission to read the source.</p><p>All this sounds good, but how can I be sure that the servers are running the code they say they’re running? With homomorphic encryption, this trust isn’t needed because an adversarial server wouldn’t have anything to steal, but LLMs can’t run in this context. If we are expected to know that Private Cloud Compute is indeed private, we must be able to <em>know</em> through cryptographic verification that servers we do not control are running code we trust, but how can we know this when the servers can send whatever data they want over the wire? It doesn’t mean much that the server <em>says</em> it’s running commit <code>f52fbd</code>, it can say whatever it wants. This is a problem that feels impossible, and apple recognizes this problem:</p><blockquote><p>There’s no general mechanism to allow researchers to verify that those software images match what’s actually running in the production environment.</p></blockquote><p>And it appears they claim that they’ve found a solution. In the future, I plan to investigate this claim. But anyway, back to the task at hand. Is homomorphic encryption private? <em>Something</em> is leaving your device…</p></details><p>But, what information is <em>really</em> leaving your device? There is no trust me bro element. Barring some issue being found in the math or Apple’s implementation of it, for the first time the cloud is able to act as a sort of extension to your device and your data, which is an immensely exciting proposition. Apple has managed categorise photos without knowing anything about what they contain. How cool is that.</p><p>Had this project came first, before the commoditization of the smartphone and social media, I would’ve written something about a slippery slope to less and less careful use of the cloud. But we’re already living in a world where all our data is up there, not in our hands. This project represents a small step back in the right direction, and I cannot get over how cool it is. I just wish that Apple would be more upfront.</p><p>We live in amazing times.</p><p><em>P.S. If you made it this far, you clearly like math, and if you clearly like math, you’ll clearly like my app, <a href="https://apps.apple.com/us/app/maculate/id6738711535?ct=https://indiecatalog.app">Maculate</a>!</em></p><h2 id="%F0%9F%93%9D-references-%26-recommended-reading" tabindex="-1">📝 References &amp; Recommended Reading</h2><ul><li><a href="https://homomorphicencryption.org/wp-content/uploads/2018/10/CCS-HE-Tutorial-Slides.pdf">Building Applications with Homomorphic Encryption</a></li><li><a href="https://arxiv.org/pdf/2406.06761">Scalable Private Search with Wally</a></li><li><a href="https://en.wikipedia.org/wiki/Homomorphic_encryption">Homomorphic encryption</a></li><li><a href="https://www.jeremykun.com/2024/05/04/fhe-overview/">A High-Level Technical Overview of Fully Homomorphic Encryption</a></li><li><a href="https://lapcatsoftware.com/articles/2025/1/1.html">Technology is never a substitute for consent</a></li></ul><hr/><h2>👟 Footnotes</h2></div></div>
  </body>
</html>
