<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://nullprogram.com/blog/2022/08/08/">Original</a>
    <h1>A quick and practical “MSI” hash table</h1>
    
    <div id="readability-page-1" class="page"><div>
<article>
  
  <time datetime="2022-08-08">
    August 08, 2022
  </time>
  <p>
    nullprogram.com/blog/2022/08/08/
  </p>

  <p>I <a href="https://skeeto.s3.amazonaws.com/share/onward17-essays2.pdf">generally prefer C</a>, so I’m accustomed to building whatever I need
on the fly, such as heaps, linked lists, and especially hash tables. Few
programs use more than a small subset of a data structure’s features,
making their implementation smaller, simpler, and more efficient than the
general case, which must handle every edge case. A typical hash table
tutorial will describe a relatively lengthy program, but in practice,
bespoke hash tables are <a href="https://nullprogram.com/blog/2020/10/19/#hash-table-memoization">only a few lines of code</a>. Over the years
I’ve worked out some basic principles for hash table construction that aid
in quick and efficient implementation. This article covers the technique
and philosophy behind what I’ve come to call the “mask-step-index” (MSI)
hash table, which is my standard approach.</p>

<p>MSI hash tables are nothing novel, just a <a href="https://en.wikipedia.org/wiki/Double_hashing">double hashed</a>, <a href="https://en.wikipedia.org/wiki/Open_addressing">open
address</a> hash table layered generically atop an external array. It’s
best regarded as a kind of database index — <em>a lookup index over an
existing array</em>. The array exists independently, and the hash table
provides an efficient lookup into that array over some property of its
entries.</p>

<p>The core of the MSI hash table is this iterator function:</p>

<div><div><pre><code><span>// Compute the next candidate index. Initialze idx to the hash.</span>
<span>int32_t</span> <span>ht_lookup</span><span>(</span><span>uint64_t</span> <span>hash</span><span>,</span> <span>int</span> <span>exp</span><span>,</span> <span>int32_t</span> <span>idx</span><span>)</span>
<span>{</span>
    <span>uint32_t</span> <span>mask</span> <span>=</span> <span>((</span><span>uint32_t</span><span>)</span><span>1</span> <span>&lt;&lt;</span> <span>exp</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
    <span>uint32_t</span> <span>step</span> <span>=</span> <span>(</span><span>hash</span> <span>&gt;&gt;</span> <span>(</span><span>64</span> <span>-</span> <span>exp</span><span>))</span> <span>|</span> <span>1</span><span>;</span>
    <span>return</span> <span>(</span><span>idx</span> <span>+</span> <span>step</span><span>)</span> <span>&amp;</span> <span>mask</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The name should now make sense. I literally sound it out in my head when I
type it, like a mnemonic. Compute a mask, then a step size, finally an
index. The <code>exp</code> parameter is a power-of-two exponent for the hash table
size, <a href="https://nullprogram.com/blog/2022/05/14/">which may look familiar</a>. I’ve used <code>int32_t</code> for the index,
but it’s easy to substitute, say, <code>size_t</code>. I try to optimize for the
common case, where a 31-bit index is more than sufficient, and a signed
type since <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1428r0.pdf">subscripts should be signed</a>. Internally it uses unsigned
types since overflow is both expected and harmless thanks to the
power-of-two hash table size.</p>

<p>It’s the caller’s responsibility to compute the hash, and the MSI iterator
tells the caller <em>where to look next</em>. For insertion, the caller (maybe)
looks either for an existing entry to override, or an empty slot. For
lookup, the caller looks for a matching entry, giving up as soon as it
find an empty slot. An insertion loop looks like this string intern table:</p>

<div><div><pre><code><span>#define EXP 15
</span>
<span>// Initialize all slots to an &#34;empty&#34; value (null)</span>
<span>#define HT_INIT { {0}, 0 }
</span><span>struct</span> <span>ht</span> <span>{</span>
    <span>char</span> <span>*</span><span>ht</span><span>[</span><span>1</span><span>&lt;&lt;</span><span>EXP</span><span>];</span>
    <span>int32_t</span> <span>len</span><span>;</span>
<span>};</span>

<span>char</span> <span>*</span><span>intern</span><span>(</span><span>struct</span> <span>ht</span> <span>*</span><span>t</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>)</span>
<span>{</span>
    <span>uint64_t</span> <span>h</span> <span>=</span> <span>hash</span><span>(</span><span>key</span><span>,</span> <span>strlen</span><span>(</span><span>key</span><span>)</span><span>+</span><span>1</span><span>);</span>
    <span>for</span> <span>(</span><span>int32_t</span> <span>i</span> <span>=</span> <span>h</span><span>;;)</span> <span>{</span>
        <span>i</span> <span>=</span> <span>ht_lookup</span><span>(</span><span>h</span><span>,</span> <span>EXP</span><span>,</span> <span>i</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>])</span> <span>{</span>
            <span>// empty, insert here</span>
            <span>if</span> <span>((</span><span>uint32_t</span><span>)</span><span>t</span><span>-&gt;</span><span>len</span><span>+</span><span>1</span> <span>==</span> <span>(</span><span>uint32_t</span><span>)</span><span>1</span><span>&lt;&lt;</span><span>EXP</span><span>)</span> <span>{</span>
                <span>return</span> <span>0</span><span>;</span>  <span>// out of memory</span>
            <span>}</span>
            <span>t</span><span>-&gt;</span><span>len</span><span>++</span><span>;</span>
            <span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>key</span><span>;</span>
            <span>return</span> <span>key</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(</span><span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>],</span> <span>key</span><span>))</span> <span>{</span>
            <span>// found, return canonical instance</span>
            <span>return</span> <span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>];</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>The caller initializes the iterator to the hash result. This will probably
be out of range, even negative, but that doesn’t matter. The iterator
function will turn it into a valid index before use. This detail is key to
<em>double hashing</em>: The low bits of the hash tell it where to start, and the
high bits tell it how to step. The hash table size is a power of two, and
the step size is forced to an odd number (via <code>| 1</code>), so it’s guaranteed
to visit each slot in the table exactly once before restarting. It’s
important that the search halts before looping, such as by guaranteeing
the existence of an empty slot (i.e. the “out of memory” check).</p>

<p>Note: The example out of memory check pushes the hash table to the
absolute limit, and in practice you’d want to stop at a smaller load
factor — perhaps even as low as 50% since that’s simple and fast.
Otherwise it degrades into a linear search as the table approaches
capacity.</p>

<p>Even if two keys start or land at the same place, they’ll quickly diverge
due to differing steps. For awhile I used plain linear probing — i.e.
<code>step=1</code> — but double hashing came out ahead every time I benchmarked,
steering me towards this “MSI” construction. Ideally <code>ht_lookup</code> would be
placed so that it’s inlined — e.g. in the same translation unit — so that
the mask and step are not actually recomputed each iteration.</p>

<h3 id="deletion">Deletion</h3>

<p>What about deletion? First, consider how infrequently you delete entries
from a hash table. When was the last time you used <code>del</code> on a dictionary
in Python, or <code>delete</code> on a <code>map</code> in Go? This operation is rarely needed.
However, when you <em>do</em> need it, reserve a gravestone value in addition to
the empty value.</p>

<div><div><pre><code><span>char</span> <span>*</span><span>gravestone</span> <span>=</span> <span>&#34;(deleted)&#34;</span><span>;</span>

<span>char</span> <span>*</span><span>intern</span><span>(</span><span>struct</span> <span>ht</span> <span>*</span><span>t</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>)</span>
<span>{</span>
<span>`</span>   <span>// ...</span>
        <span>if</span> <span>(</span><span>!</span><span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>])</span> <span>{</span>
            <span>// ...</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>gravestone</span><span>)</span> <span>{</span>
            <span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>key</span><span>;</span>
            <span>return</span> <span>key</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(...))</span> <span>{</span>
            <span>// ...</span>
        <span>}</span>
    <span>// ...</span>
<span>}</span>

<span>char</span> <span>*</span><span>unintern</span><span>(</span><span>struct</span> <span>ht</span> <span>*</span><span>t</span><span>,</span> <span>char</span> <span>*</span><span>key</span><span>)</span>
<span>{</span>
    <span>// ...</span>
        <span>if</span> <span>(</span><span>!</span><span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>])</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>==</span> <span>gravestone</span><span>)</span> <span>{</span>
            <span>// skip over</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>strcmp</span><span>(...))</span> <span>{</span>
            <span>char</span> <span>*</span><span>old</span> <span>=</span> <span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>];</span>
            <span>t</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>gravestone</span><span>;</span>
            <span>return</span> <span>old</span><span>;</span>
        <span>}</span>
    <span>// ...</span>
<span>}</span>
</code></pre></div></div>

<p>When searching, skip over gravestones. When inserting, use the first
gravestone found.</p>

<h3 id="as-a-database-index">As a database index</h3>

<p>Iterating over the example string intern table is simple: Iterate over the
underlying array, skipping empty slots (and maybe gravestones). Entries
will be in a random order rather than, say, insertion order. This is a
useful introductory example, but this isn’t where MSI most shines. As
mentioned, it’s best when treated like a database index.</p>

<p>Let’s take a step back and consider the caller of <code>intern</code>. How does it
allocate these strings? Perhaps they’re <a href="https://nullprogram.com/blog/2022/05/22/">appended to a buffer</a>, and
<code>intern</code> indicates whether or not the string is unique so far.</p>

<div><div><pre><code><span>struct</span> <span>buf</span> <span>{</span>
    <span>// lookup table over the buffer</span>
    <span>struct</span> <span>ht</span> <span>ht</span><span>;</span>

    <span>// a collection of strings</span>
    <span>int32_t</span> <span>len</span><span>;</span>
    <span>char</span> <span>buf</span><span>[</span><span>BUFLEN</span><span>];</span>
<span>};</span>
</code></pre></div></div>

<p>Strings are only appended to the buffer when unique, and the hash table
can make that determination in constant time.</p>

<div><div><pre><code><span>char</span> <span>*</span><span>buf_push</span><span>(</span><span>struct</span> <span>buf</span> <span>*</span><span>b</span><span>,</span> <span>char</span> <span>*</span><span>s</span><span>)</span>
<span>{</span>
    <span>size_t</span> <span>len</span> <span>=</span> <span>strlen</span><span>(</span><span>s</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span><span>b</span><span>-&gt;</span><span>len</span><span>+</span><span>len</span> <span>&gt;</span> <span>sizeof</span><span>(</span><span>b</span><span>-&gt;</span><span>buf</span><span>))</span> <span>{</span>
        <span>return</span> <span>0</span><span>;</span>  <span>// out of memory</span>
    <span>}</span>

    <span>char</span> <span>*</span><span>candidate</span> <span>=</span> <span>b</span><span>-&gt;</span><span>buf</span> <span>+</span> <span>buf</span><span>-&gt;</span><span>len</span><span>;</span>
    <span>memcpy</span><span>(</span><span>candidate</span><span>,</span> <span>s</span><span>,</span> <span>len</span><span>);</span>

    <span>char</span> <span>*</span><span>result</span> <span>=</span> <span>intern</span><span>(</span><span>&amp;</span><span>b</span><span>-&gt;</span><span>ht</span><span>,</span> <span>candidate</span><span>);</span>
    <span>if</span> <span>(</span><span>result</span> <span>==</span> <span>candidate</span><span>)</span> <span>{</span>
        <span>// string is unique, keep it</span>
        <span>b</span><span>-&gt;</span><span>len</span> <span>+=</span> <span>len</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>result</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>In my first example, <code>EXP</code> was fixed. This could be converted into a
dynamic allocation and the hash table resized as needed. Here’s a new
constructor, which I’m including since I think it’s instructive:</p>

<div><div><pre><code><span>struct</span> <span>ht</span> <span>{</span>
    <span>int32_t</span> <span>len</span><span>;</span>
    <span>int</span> <span>exp</span><span>;</span>
    <span>char</span> <span>**</span><span>ht</span><span>;</span>
<span>};</span>

<span>static</span> <span>struct</span> <span>ht</span>
<span>ht_new</span><span>(</span><span>int</span> <span>exp</span><span>)</span>
<span>{</span>
    <span>struct</span> <span>ht</span> <span>ht</span> <span>=</span> <span>{</span><span>0</span><span>,</span> <span>exp</span><span>,</span> <span>0</span><span>};</span>

    <span>assert</span><span>(</span><span>exp</span> <span>&gt;=</span> <span>0</span><span>);</span>
    <span>if</span> <span>(</span><span>exp</span> <span>&gt;=</span> <span>32</span><span>)</span> <span>{</span>
        <span>return</span> <span>ht</span><span>;</span>  <span>// request too large</span>
    <span>}</span>

    <span>ht</span><span>.</span><span>ht</span> <span>=</span> <span>calloc</span><span>((</span><span>size_t</span><span>)</span><span>1</span><span>&lt;&lt;</span><span>exp</span><span>,</span> <span>sizeof</span><span>(</span><span>ht</span><span>.</span><span>ht</span><span>[</span><span>0</span><span>]));</span>
    <span>return</span> <span>ht</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>If <code>intern</code> fails, the hash table can be replaced with a new table twice
as large, and since, like a database index, its contents are entirely
redundant, <em>the hash table can be discarded and rebuilt from scratch</em>. The
new and old table don’t need to exist simultaneously. Here’s a routine to
populate an empty hash table from the buffer:</p>

<div><div><pre><code><span>void</span> <span>buf_rehash</span><span>(</span><span>struct</span> <span>buf</span> <span>*</span><span>b</span><span>)</span>
<span>{</span>
    <span>assert</span><span>(</span><span>b</span><span>-&gt;</span><span>ht</span><span>.</span><span>len</span> <span>==</span> <span>0</span><span>);</span>
    <span>for</span> <span>(</span><span>int32_t</span> <span>off</span> <span>=</span> <span>0</span><span>;</span> <span>off</span> <span>&lt;</span> <span>b</span><span>-&gt;</span><span>len</span><span>;)</span> <span>{</span>
        <span>char</span> <span>*</span><span>s</span> <span>=</span> <span>b</span><span>-&gt;</span><span>buf</span> <span>+</span> <span>off</span><span>;</span>
        <span>int32_t</span> <span>len</span> <span>=</span> <span>strlen</span><span>(</span><span>s</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
        <span>off</span> <span>+=</span> <span>len</span><span>;</span>
        <span>uint64_t</span> <span>h</span> <span>=</span> <span>hash</span><span>(</span><span>s</span><span>,</span> <span>len</span><span>);</span>
        <span>for</span> <span>(</span><span>int32_t</span> <span>i</span> <span>=</span> <span>h</span><span>;;)</span> <span>{</span>
            <span>i</span> <span>=</span> <span>ht_lookup</span><span>(</span><span>h</span><span>,</span> <span>b</span><span>-&gt;</span><span>ht</span><span>.</span><span>exp</span><span>,</span> <span>i</span><span>);</span>
            <span>if</span> <span>(</span><span>!</span><span>b</span><span>-&gt;</span><span>ht</span><span>.</span><span>ht</span><span>[</span><span>i</span><span>])</span> <span>{</span>
                <span>b</span><span>-&gt;</span><span>ht</span><span>.</span><span>len</span><span>++</span><span>;</span>
                <span>b</span><span>-&gt;</span><span>ht</span><span>.</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>s</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div></div>

<p>Note how this iterates in insertion order, which may be useful in other
cases, too. On the rehash it doesn’t need to check for existing entries,
as all entries are already known to be unique. Later when <code>intern</code> hits
its capacity:</p>

<div><div><pre><code>    <span>char</span> <span>*</span><span>result</span> <span>=</span> <span>intern</span><span>(</span><span>&amp;</span><span>b</span><span>-&gt;</span><span>ht</span><span>,</span> <span>candidate</span><span>);</span>
    <span>if</span> <span>(</span><span>!</span><span>result</span><span>)</span> <span>{</span>
        <span>free</span><span>(</span><span>b</span><span>-&gt;</span><span>ht</span><span>.</span><span>ht</span><span>);</span>
        <span>b</span><span>-&gt;</span><span>ht</span> <span>=</span> <span>ht_new</span><span>(</span><span>ht</span><span>.</span><span>exp</span><span>+</span><span>1</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>b</span><span>-&gt;</span><span>ht</span><span>)</span> <span>{</span>
            <span>return</span> <span>0</span><span>;</span>  <span>// out of memory</span>
        <span>}</span>
        <span>buf_rehash</span><span>(</span><span>b</span><span>);</span>
        <span>result</span> <span>=</span> <span>intern</span><span>(</span><span>&amp;</span><span>b</span><span>-&gt;</span><span>ht</span><span>,</span> <span>candidate</span><span>);</span>  <span>// cannot fail</span>
    <span>}</span>
</code></pre></div></div>

<p>I freed and reallocated the table, but it would be trivial to use a
<code>realloc</code> instead, unlike the case where the old table <em>isn’t</em> redundant.</p>

<h3 id="multimaps">Multimaps</h3>

<p>An MSI hash table is trivially converted into a multimap, a hash table
with multiple values per key. Callers just make one small change: <em>Don’t
stop searching until an empty slot is found</em>. Each match is an additional
multimap value. The “value array” is stored along the hash table itself,
in insertion order, without additional allocations.</p>

<p>For example, imagine the strings in the string buffer have a namespace
prefix, delimited by a colon, like <code>city:Austin</code> and <code>state:Texas</code>. We’d
like a fast lookup of all strings under a particular namespace. The
solution is to add another hash table as you would an index to a database
table.</p>

<div><div><pre><code><span>struct</span> <span>buf</span> <span>{</span>
    <span>// ..</span>
    <span>struct</span> <span>ht</span> <span>ns</span><span>;</span>
    <span>// ..</span>
<span>};</span>
</code></pre></div></div>

<p>When a unique string is appended it’s also registered in the namespace
multimap. It doesn’t check for an existing key, only for an empty slot,
since it’s a multimap:</p>

<div><div><pre><code>    <span>// Check outside the loop since it always inserts.</span>
    <span>if</span> <span>(</span><span>/* ... ns multimap lacks capacity ... */</span><span>)</span> <span>{</span>
        <span>// ... grow+rehash ns mutilmap ...</span>
    <span>}</span>

    <span>int32_t</span> <span>nslen</span> <span>=</span> <span>strcspn</span><span>(</span><span>s</span><span>,</span> <span>&#34;:&#34;</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
    <span>uint64_t</span> <span>h</span> <span>=</span> <span>hash</span><span>(</span><span>s</span><span>,</span> <span>nslen</span><span>);</span>
    <span>for</span> <span>(</span><span>int32_t</span> <span>i</span> <span>=</span> <span>h</span><span>;;)</span> <span>{</span>
        <span>i</span> <span>=</span> <span>ht_lookup</span><span>(</span><span>h</span><span>,</span> <span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>exp</span><span>,</span> <span>i</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>ht</span><span>[</span><span>i</span><span>])</span> <span>{</span>
            <span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>len</span><span>++</span><span>;</span>
            <span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>ht</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>s</span><span>;</span>
            <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre></div></div>

<p>It includes the <code>:</code> as a terminator which simplifies lookups. Here’s a
lookup loop to print all strings under a namespace (includes terminal <code>:</code>
in the key):</p>

<div><div><pre><code>    <span>char</span> <span>*</span><span>ns</span> <span>=</span> <span>&#34;city:&#34;</span><span>;</span>
    <span>int32_t</span> <span>nslen</span> <span>=</span> <span>strlen</span><span>(</span><span>ns</span><span>);</span>
    <span>// ...</span>

    <span>uint64_t</span> <span>h</span> <span>=</span> <span>hash</span><span>(</span><span>ns</span><span>,</span> <span>nslen</span><span>);</span>
    <span>for</span> <span>(</span><span>int32_t</span> <span>i</span> <span>=</span> <span>h</span><span>;;)</span> <span>{</span>
        <span>i</span> <span>=</span> <span>ht_lookup</span><span>(</span><span>h</span><span>,</span> <span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>exp</span><span>,</span> <span>i</span><span>);</span>
        <span>if</span> <span>(</span><span>!</span><span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>ht</span><span>[</span><span>i</span><span>])</span> <span>{</span>
            <span>break</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span><span>strncmp</span><span>(</span><span>b</span><span>.</span><span>ns</span><span>-&gt;</span><span>ht</span><span>[</span><span>i</span><span>],</span> <span>ns</span><span>,</span> <span>nslen</span><span>))</span> <span>{</span>
            <span>puts</span><span>(</span><span>b</span><span>-&gt;</span><span>ns</span><span>.</span><span>ht</span><span>[</span><span>i</span><span>]</span><span>+</span><span>nslen</span><span>);</span>
        <span>}</span>
    <span>}</span>
</code></pre></div></div>

<p>An alternative approach to multimaps is to additionally key over a value
subscript. For example, the first city is keyed <code>{&#34;city&#34;, 0}</code>, the next
<code>{&#34;city&#34;, 1}</code>, etc. The value subscript could be mixed into the string
hash with an <a href="https://nullprogram.com/blog/2018/07/31/">integer permutation</a> (more on this below):</p>

<div><div><pre><code><span>uint64_t</span> <span>h</span> <span>=</span> <span>hash64</span><span>(</span><span>val_idx</span> <span>^</span> <span>hash</span><span>(</span><span>s</span><span>,</span> <span>nslen</span><span>));</span>
</code></pre></div></div>

<p>The lookup loop would compare both the string and the value subscript, and
stop when it finds a match. The underlying hash table is not truly a
multimap, but rather a plain hash table with a larger key. This requires
extra bookkeeping — tracking individual subscripts and the number of
values per key — but provides constant time random access on the multimap
value array.</p>

<h3 id="hash-functions">Hash functions</h3>

<p>The MSI iterator leaves hashing up to the caller, who has better knowledge
about the input and how to hash it, though this takes a bit of knowledge
of how to build a hash function. The good news is that it’s easy, and less
is more. Better to do too little than too much, and a faster, weaker hash
function is worth a few extra collisions.</p>

<p>The first rule is to never lose sight of the goal: The purpose of the hash
function is to uniformly distribute entries over a table. The better you
know and exploit your input, the less you need to do in the hash function.
Sometimes your keys already contain random data, and so your hash function
can be the identity function! For example, if your keys are <a href="https://www.rfc-editor.org/rfc/rfc4122#section-4.4">“version 4”
UUIDs</a>, don’t waste time hashing them, just load a few bytes from the
end as an integer and you’re done.</p>

<div><div><pre><code><span>// &#34;Hash&#34; a v4 UUID</span>
<span>uint64_t</span> <span>uuid4_hash</span><span>(</span><span>unsigned</span> <span>char</span> <span>uuid</span><span>[</span><span>16</span><span>])</span>
<span>{</span>
    <span>uint64_t</span> <span>h</span><span>;</span>
    <span>memcpy</span><span>(</span><span>&amp;</span><span>h</span><span>,</span> <span>uuid</span><span>+</span><span>8</span><span>,</span> <span>8</span><span>);</span>
    <span>return</span> <span>h</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>A reasonable start for strings is <a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV-1a</a>, such as this possible
implementation for my <code>hash()</code> function above:</p>

<div><div><pre><code><span>uint64_t</span> <span>hash</span><span>(</span><span>char</span> <span>*</span><span>s</span><span>,</span> <span>int32_t</span> <span>len</span><span>)</span>
<span>{</span>
    <span>uint64_t</span> <span>h</span> <span>=</span> <span>0x100</span><span>;</span>
    <span>for</span> <span>(</span><span>int32_t</span> <span>i</span> <span>=</span> <span>0</span><span>;</span> <span>i</span> <span>&lt;</span> <span>len</span><span>;</span> <span>i</span><span>++</span><span>)</span> <span>{</span>
        <span>h</span> <span>^=</span> <span>s</span><span>[</span><span>i</span><span>]</span> <span>&amp;</span> <span>255</span><span>;</span>
        <span>h</span> <span>*=</span> <span>1111111111111111111</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>h</span> <span>^</span> <span>h</span><span>&gt;&gt;</span><span>32</span><span>;</span>
<span>}</span>
</code></pre></div></div>

<p>The hash state is initialized to a <em>basis</em>, some arbitrary value. This a
useful place to introduce a seed or hash key. It’s best that at least one
bit above the low mix-in bits is set so that it’s not trivially stuck at
zero. Above, I’ve chosen the most trivial basis with reasonable results,
though often I’ll use the digits of π.</p>

<p>Next XOR some input into the low bits. This could be a byte, a Unicode
code point, etc. More is better, since otherwise you’re stuck doing more
work per unit, the main weakness of FNV-1a. Carefully note the byte mask,
<code>&amp; 255</code>, which inhibits sign extension. <strong>Do not mix sign-extended inputs
into FNV-1a</strong> — a widespread implementation mistake.</p>

<p>Multiply by a large, odd random-ish integer. A prime is a reasonable
choice, and I usually pick my favorite prime, shown above: 19 ones in base
10.</p>

<p>Finally, my own touch, an xorshift finalizer. The high bits are much
better mixed than the low bits, so this improves the overall quality.
Though if you take time to benchmark, you might find that this finalizer
isn’t necessary. Remember, do <em>just</em> enough work to keep the number of
collisions low — not <em>lowest</em> — and no more.</p>

<p>If your input is made of integers, or is a short, fixed length, use an
<a href="https://nullprogram.com/blog/2018/07/31/">integer permutation</a>, particularly multiply-xorshift. It takes very
little to get a sufficient distribution. Sometimes one multiplication does
the trick. Fixed-sized, integer-permutation hashes tend to be the fastest,
easily beating fancier SIMD-based hashes, including AES-NI. For example:</p>

<div><div><pre><code><span>// Hash a timestamp-based, version 1 UUID</span>
<span>uint64_t</span> <span>uuid1_hash</span><span>(</span><span>unsigned</span> <span>char</span> <span>uuid</span><span>[</span><span>16</span><span>])</span>
<span>{</span>
    <span>uint64_t</span> <span>s</span><span>[</span><span>2</span><span>];</span>
    <span>memcpy</span><span>(</span><span>s</span><span>,</span> <span>uuid</span><span>,</span> <span>16</span><span>);</span>
    <span>s</span><span>[</span><span>0</span><span>]</span> <span>+=</span> <span>0x3243f6a8885a308d</span><span>;</span>  <span>// digits of pi</span>
    <span>s</span><span>[</span><span>0</span><span>]</span> <span>*=</span> <span>1111111111111111111</span><span>;</span>
    <span>s</span><span>[</span><span>0</span><span>]</span> <span>^=</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>&gt;&gt;</span> <span>33</span><span>;</span>
    <span>s</span><span>[</span><span>0</span><span>]</span> <span>+=</span> <span>s</span><span>[</span><span>1</span><span>];</span>
    <span>s</span><span>[</span><span>0</span><span>]</span> <span>*=</span> <span>1111111111111111111</span><span>;</span>
    <span>s</span><span>[</span><span>0</span><span>]</span> <span>^=</span> <span>s</span><span>[</span><span>0</span><span>]</span> <span>&gt;&gt;</span> <span>33</span><span>;</span>
    <span>return</span> <span>s</span><span>[</span><span>0</span><span>];</span>
<span>}</span>
</code></pre></div></div>

<p>If I benchmarked this in a real program, I would probably cut it down even
further, deleting hash operations one at a time and measuring the overall
hash table performance. This <code>memcpy</code> trick works well with floats, too,
especially packing two single precision floats into one 64-bit integer.</p>

<p>If you ever <a href="https://mort.coffee/home/tar/">hesitate to build a hash table</a> when the situation
calls, I hope the MSI technique will make the difference next time. I have
more hash table tricks up my sleeve, but since they’re not specific to MSI
I’ll save them for a future article.</p>



  
  <ol></ol>

  

  <nav>
  
    
  
  
  </nav>
</article>

</div></div>
  </body>
</html>
