<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.brendanlong.com/cpu-utilization-is-a-lie.html">Original</a>
    <h1>%CPU utilization is a lie</h1>
    
    <div id="readability-page-1" class="page"><section id="content"><article itemscope="" itemtype="http://schema.org/BlogPosting"><header></header><div itemprop="articleBody"><p>I deal with a lot of servers at work, and one thing everyone wants to know about their servers is how close they are to being at max utilization. It should be easy, right? Just pull up <code>top</code> or another system monitor tool, look at network, memory and CPU utilization, and whichever one is the highest tells you how close you are to the limits.</p><p><img alt="A screenshot of a system monitor app showing 24 cores, half of which are at 100% utitilization and half of which are close to 0%." src="https://www.brendanlong.com/images/cpu-utilization-lie/system-monitor-screenshot.png"/></p><p>For example, this machine is at 50% CPU utilization, so it can <a href="#matrix-math">probably do twice as much of whatever it&#39;s doing</a>.</p><p>And yet, whenever people actually try to project these numbers, they find that CPU utilization doesn&#39;t quite increase linearly. <strong>But how bad could it possibly be?</strong></p><p>To answer this question, I ran a bunch of stress tests and monitored both how much work they did and what the system-reported CPU utilization was, then graphed the results.</p><p>For my test machine, I used a desktop computer running Ubuntu with a <a href="https://www.amd.com/en/products/processors/desktops/ryzen/5000-series/amd-ryzen-9-5900x.html">Ryzen 9 5900X</a> (12 core / 24 thread) processor. I also enabled <a href="https://www.amd.com/en/resources/support-articles/faqs/CPU-PB2.html">Precision Boost Overdrive</a> (i.e. <a href="https://en.wikipedia.org/wiki/AMD_Turbo_Core">Turbo</a>).</p><p>I vibe-coded <a href="https://github.com/brendanlong/cpu-utilization-graphs">a script</a> that runs <a href="https://github.com/ColinIanKing/stress-ng">stress-ng</a> in a loop, first using 24 workers and attempting to run them each at different utilizations from 1% to 100%, then using 1 to 24 workers all at 100% utilization. It used different stress testing method and measured the number of operations that could be completed (&#34;Bogo ops<sup id="fnref:jvyu8i00sms"><a href="#fn:jvyu8i00sms">1</a></sup>&#34;).</p><p>The reason I did two different methods was that operating systems are smart about how they schedule work, and scheduling a small number of workers at 100% utilization can be done optimally (spoilers) but with 24 workers all at 50% utilization it&#39;s hard for the OS to do anything other than spreading the work evenly.</p><p>You can see <a href="https://docs.google.com/spreadsheets/d/1QKdYa3NIFGTixG_LdnsbwbeLDnE2GNVVsS9-dfkcT20/edit?usp=sharing">the raw CSV results here</a>.</p><h2 id="general-cpu"><a href="#general-cpu">General CPU</a></h2><p>The most basic test just runs all of stress-ng&#39;s CPU stress tests in a loop.</p><p><img alt="" src="https://www.brendanlong.com/images/cpu-utilization-lie/cpu_utilization_analysis_cpu.png"/></p><p>You can see that when the system is reporting 50% CPU utilization, it&#39;s actually doing 60-65% of the actual maximum work it can do.</p><h2 id="64-bit-integer-math"><a href="#64-bit-integer-math">64-bit Integer Math</a></h2><p>But maybe that one was just a fluke. What if we just run some random math on 64-bit integers?</p><p><img alt="" src="https://www.brendanlong.com/images/cpu-utilization-lie/cpu_utilization_analysis_int64.png"/></p><p>This one is even worse! At &#34;50% utilization&#34;, we&#39;re actually doing 65-85% of the max work we can get done. It can&#39;t possibly get worse than that though, right?</p><h2 id="matrix-math"><a href="#matrix-math">Matrix Math</a></h2><p><img alt="" src="https://www.brendanlong.com/images/cpu-utilization-lie/cpu_utilization_analysis_matrixprod.png"/></p><p>Something is definitely off. <strong>Doing matrix math, &#34;50% utilization&#34; is actually 80% to 100% of the max work that can be done.</strong></p><p>In case you were wondering about the system monitor screenshot from the start of the article, that was a matrix math test running with 12 workers, and you can see that it really did report 50% utilization even though additional workers do absolutely nothing (except make the utilization number go up).</p><h2 id="hyperthreading"><a href="#hyperthreading">Hyperthreading</a></h2><p>You might notice that this the graph keeps changing at 50%, and I&#39;ve helpfully added piecewise linear regressions showing the fit.</p><p>The main reason this is happening is <a href="https://en.wikipedia.org/wiki/Hyper-threading">hyperthreading</a>: Half of the &#34;cores&#34; on this machine (and most machines) are sharing resources with other cores. If I run 12 workers on this machine, they each get scheduled on their own physical core with no shared resources, but once I go over that, each additional worker is sharing resources with another. In some cases (general CPU benchmarks), this makes things slightly worse, and in some cases (<a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a>-heavy matrix math), there are no useful resources left to share.</p><h2 id="turbo"><a href="#turbo">Turbo</a></h2><p>It&#39;s harder to see, but <a href="https://en.wikipedia.org/wiki/AMD_Turbo_Core">Turbo</a> is also having an effect. This particular processor runs at 4.9 GHz at low utilization, but slowly drops to 4.3 GHz as more cores become active<sup id="fnref:yk2lmnusjj"><a href="#fn:yk2lmnusjj">2</a></sup>.</p><p><img alt="" src="https://www.brendanlong.com/images/cpu-utilization-lie/clock_speed_vs_cpu_all.png"/></p><p>Note the zoomed-in y-axis. The clock speed &#34;only&#34; drops by 15% on this processor.</p><p>Since CPU utilization is calculated as busy cycles / total cycles, this means the denominator is getting smaller as the numerator gets larger, so we get yet another reason why actual CPU utilization increases faster than linearly.</p><p><img alt="" src="https://www.brendanlong.com/images/cpu-utilization-lie/cpu_utilization_combined_adjusted.png"/></p><p>If you look at CPU utilization and assume it will increase linearly, you&#39;re going to have a rough time. If you&#39;re using the CPU efficiently (running above &#34;50%&#34; utilization), the reported utilization is an underestimate, sometimes significantly so.</p><p>And keep in mind that I&#39;ve only shown results for one processor, but hyperthreading performance and Turbo behavior can vary wildly between different processors, especially from different companies (AMD vs Intel).</p><p>The best way I know to work around this is to run benchmarks and monitor actual work done:</p><ol><li>Benchmark how much work your server can do before having errors or unacceptable latency.</li><li>Report how much work your server is currently doing.</li><li>Compare those two metrics instead of CPU utilization.</li></ol></div></article></section></div>
  </body>
</html>
