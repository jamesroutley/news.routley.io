<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://chipx86.blog/2025/06/29/tip-use-keyword-only-arguments-in-python-dataclasses/">Original</a>
    <h1>Use keyword-only arguments in Python dataclasses</h1>
    
    <div id="readability-page-1" class="page"><article id="post-1444" itemtype="https://schema.org/CreativeWork" itemscope="itemscope">

	
	
<div>

	
	
		<!-- .entry-header -->

	
	
	<div data-ast-blocks-layout="true" itemprop="text">

		
		
<p>Python <a href="https://docs.python.org/3/library/dataclasses.html">dataclasses</a> are a really nice feature for constructing classes that primarily hold or work with data. They can be a good alternative to using dictionaries, since they allow you to add methods, dynamic properties, and subclasses. They can also be a good alternative to building your own class by hand, since they don’t need a custom <code>__init__()</code> that reassigns attributes and provide methods like <code>__eq__()</code> out of the box.</p>



<p>One small tip to keeping dataclasses maintainable is to always construct them with <code>kw_only=True</code>, like so:</p>


<div><pre title="">from dataclasses import dataclass


@dataclass(kw_only=True)
class MyDataClass:
    x: int
    y: str
    z: bool = True
</pre></div>


<p>This will construct an <code>__init__()</code> that looks like this:</p>


<div><pre title="">class MyDataClass:
    def __init__(
        self,
        *,
        x: int,
        y: str,
        z: bool = True,
    ) -&gt; None:
        self.x = x
        self.y = y
        self.z = z
</pre></div>


<p>Instead of:</p>


<div><pre title="">class MyDataClass:
    def __init__(
        self,
        x: int,
        y: str,
        z: bool = True,
    ) -&gt; None:
        self.x = x
        self.y = y
        self.z = z
</pre></div>


<p>That <code>*</code> in the argument list means everything that follows must be passed as a keyword argument, instead of a positional argument.</p>



<p>There are two reasons you probably want to do this:</p>



<ol>
<li>It allows you to reorder the fields on the dataclass without breaking callers. Positional arguments means a caller can use <code>MyDataClass(1, &#39;foo&#39;, False)</code>, and if you remove/reorder any of these arguments, you’ll break those callers unexpectedly. By forcing callers to use <code>MyDataClass(x=1, y=&#39;foo&#39;, z=False)</code>, you remove this risk.</li>



<li>It allows subclasses to add required fields. Normally, any field with a default value (like <code>z</code> above) will force any fields following it to also have a default. And that includes <em>all</em> fields defined by subclasses. Using <code>kw_only=True</code> gives subclasses the flexibility to decide for themselves which fields must be provided by the caller and which have a default.</li>
</ol>



<p>These reasons are more important for library authors than anything. We spend a lot of time trying to ensure backwards-compatibility and forwards-extensibility in <a href="https://www.reviewboard.org">Review Board</a>, so this is an important topic for us. And if you’re developing something reusable with dataclasses, it might be for you, too.</p>



<p><strong>Update:</strong> One important point I left out is Python compatibility. This flag was introduced in Python 3.10, so if you’re supporting older versions, you won’t be able to use this just yet. If you want to optimistically enable this just on 3.10+, one approach would be:</p>


<div><pre title="">import sys
from dataclasses import dataclass


if sys.version_info[:2] &gt;= (3, 10):
    dataclass_kwargs = {
        &#39;kw_only&#39;: True,
    }
else:
    dataclass_kwargs = {}

...

@dataclass(**dataclass_kwargs)
class MyDataClass:
    ...
...
</pre></div>


<p>But this won’t solve the subclassing issue, so you’d still need to ensure any subclasses use default arguments if you want to support versions prior to 3.10.</p>

		
		
			</div><!-- .entry-content .clear -->
</div>

	
</article></div>
  </body>
</html>
