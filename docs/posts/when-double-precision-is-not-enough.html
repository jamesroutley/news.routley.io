<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://adambaskerville.github.io/posts/LespEigenvalues/">Original</a>
    <h1>When Double Precision Is Not Enough</h1>
    
    <div id="readability-page-1" class="page"><div><p>Click the following button to launch an ipython notebook on Google Colab which implements the code developed in this post:</p><p><a href="https://colab.research.google.com/github/adambaskerville/adambaskerville.github.io/blob/master/_posts/EigenvaluesCode/Eigenvalues.ipynb"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a></p><p>We want to solve the following standard eigenvalue problem</p><p>\[ \mathbf{A}\Psi = \lambda\Psi, \]</p><p>where \(\mathbf{A}\) is the <code>lesp</code> matrix, \(\Psi\) is the eigenvector and \(\lambda\) the eigenvalue. The <code>lesp</code> matrix is a tridiagonal matrix with real, sensitive eigenvalues, with a \(5 \times 5\) example seen in equation (1).</p><p>\[ \mathbf{M} = \begin{pmatrix} -5 &amp; 2 &amp; 0 &amp; 0 &amp; 0 \\</p><p>We are going to numerically show that the eigenvalues of a matrix \(\mathbf{A}\) are equal to the eigenvalues of its matrix transpose, \(\mathbf{A}^T\), easily proved as follows</p><p>\[\text{det}(\mathbf{A}^T - \lambda \mathbf{I}) = \text{det}((\mathbf{A} - \lambda \mathbf{I})^T) = \text{det}(\mathbf{A} - \lambda \mathbf{I}),\]</p><p>where \(\mathbf{I}\) is the identity matrix. If you do not want to write your own function to construct the <code>lesp</code> matrix then you are in luck, there is a python library, <a href="https://pypi.org/project/rogues/">rogues</a>, which has one built in.</p><p>The following python code calculates the eigenvalues of \(\mathbf{A}\) and \(\mathbf{A}^T\) and displays them using <a href="https://seaborn.pydata.org/">seaborn</a>.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td><pre><span>from</span> <span>rogues</span> <span>import</span> <span>lesp</span>
<span>from</span> <span>matplotlib</span> <span>import</span> <span>pyplot</span>
<span>import</span> <span>seaborn</span> <span>as</span> <span>sns</span> 
<span>from</span> <span>scipy.linalg</span> <span>import</span> <span>eigvals</span>

<span>sns</span><span>.</span><span>set</span><span>()</span>
<span>palette</span> <span>=</span> <span>sns</span><span>.</span><span>color_palette</span><span>(</span><span>&#34;bright&#34;</span><span>)</span>

<span># Dimension of matrix
</span><span>dim</span> <span>=</span> <span>100</span>
<span># get lesp matrix
</span><span>A</span> <span>=</span> <span>lesp</span><span>(</span><span>dim</span><span>)</span>
<span># Transpose matrix A
</span><span>AT</span> <span>=</span> <span>A</span><span>.</span><span>T</span>
<span># Calculate eigenvalues of A
</span><span>Aev</span> <span>=</span> <span>eigvals</span><span>(</span><span>A</span><span>)</span>
<span># Calculate eigenvalues of A^T
</span><span>ATev</span> <span>=</span> <span>eigvals</span><span>(</span><span>A</span><span>.</span><span>T</span><span>)</span>
<span># Extract real and imaginary parts of A
</span><span>A_X</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>real</span> <span>for</span> <span>x</span> <span>in</span> <span>Aev</span><span>]</span>
<span>A_Y</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>imag</span> <span>for</span> <span>x</span> <span>in</span> <span>Aev</span><span>]</span>
<span># Extract real and imaginary parts of A^T
</span><span>AT_X</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>real</span> <span>for</span> <span>x</span> <span>in</span> <span>ATev</span><span>]</span>
<span>AT_Y</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>imag</span> <span>for</span> <span>x</span> <span>in</span> <span>ATev</span><span>]</span>

<span># Plot
</span><span>ax</span> <span>=</span> <span>sns</span><span>.</span><span>scatterplot</span><span>(</span><span>x</span><span>=</span><span>A_X</span><span>,</span> <span>y</span><span>=</span><span>A_Y</span><span>,</span> <span>color</span> <span>=</span> <span>&#39;gray&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;o&#39;</span><span>,</span> <span>label</span><span>=</span><span>r</span><span>&#39;$\mathbf{A}$&#39;</span><span>)</span>
<span>ax</span> <span>=</span> <span>sns</span><span>.</span><span>scatterplot</span><span>(</span><span>x</span><span>=</span><span>AT_X</span><span>,</span> <span>y</span><span>=</span><span>AT_Y</span><span>,</span> <span>color</span> <span>=</span> <span>&#39;blue&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;x&#39;</span><span>,</span> <span>label</span><span>=</span><span>r</span><span>&#39;$\mathbf{A}^T$&#39;</span><span>)</span>
<span># Give axis labels
</span><span>ax</span><span>.</span><span>set</span><span>(</span><span>xlabel</span><span>=</span><span>r</span><span>&#39;real&#39;</span><span>,</span> <span>ylabel</span><span>=</span><span>r</span><span>&#39;imag&#39;</span><span>)</span>
<span># Draw legend
</span><span>ax</span><span>.</span><span>legend</span><span>()</span>

<span>pyplot</span><span>.</span><span>show</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><p>This produces the following plot of the eigenvalues for a \(100 \times 100 \) matrix.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/Lesp_scipy.png" alt="Desktop View"/></p><p>Something is wrong, most of the eigenvalues of matrix \(\mathbf{A}\) are not equal to the eigenvalues of \(\mathbf{A}^T\), even though they should be identical. Some of them also have complex components! There is no error with the program; this discrepancy is caused by a loss of <strong>numerical accuracy</strong> in the eigenvalue calculation due to the limitation of hardware double precision (16-digit).</p><p>The scipy <code>eigvals</code> function calls LAPACK routine <a href="http://www.netlib.org/lapack/lapack-3.1.1/html/dgeev.f.html"><code>_DGEEV</code></a> which first reduces the input matrix to upper Hessenberg form by means of orthogonal similarity transformations. The QR algorithm is then used to further reduce the matrix to upper quasi-triangular Schur form, \(\mathbf{T}\), with 1 by 1 and 2 by 2 blocks on the main diagonal. The eigenvalues are computed from \(\mathbf{T}\).</p><p>For most applications this will produce very accurate eigenvalues, but when a problem is ill-conditioned, or a small change to the input matrix results in a significant change to the eigenvalues; more numerically stable methods are required. Failing this, higher working precision is required such as quadruple (32-digit), octuple (64-digit) or even arbitrary precision. If you are losing precision in a calculation it is always advised to first analyse the methods and algorithms you are using to see if they can be improved. Only after doing this is it desirable to increase the working precision. Extended precision calculations take <strong>significantly</strong> longer than double precision calculations as they are run in software rather than on hardware.</p><p>Increasing precision is simple in python with the use of the <a href="http://mpmath.org/">mpmath</a> library. Note that this library is <strong>incredibly</strong> slow for large matrices, so is best avoided for most applications. The following code calculates the same eigenvalues as before, this time at quadruple, 32-digit precision.</p><div><p><code><table><tbody><tr><td><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td><pre><span>from</span> <span>rogues</span> <span>import</span> <span>lesp</span>
<span>from</span> <span>matplotlib</span> <span>import</span> <span>pyplot</span>
<span>import</span> <span>seaborn</span> <span>as</span> <span>sns</span> 
<span>from</span> <span>scipy.linalg</span> <span>import</span> <span>eigvals</span>
<span>from</span> <span>mpmath</span> <span>import</span> <span>*</span>
<span># Set precision to 32-digit
</span><span>mp</span><span>.</span><span>dps</span> <span>=</span> <span>32</span>

<span>sns</span><span>.</span><span>set</span><span>()</span>
<span>palette</span> <span>=</span> <span>sns</span><span>.</span><span>color_palette</span><span>(</span><span>&#34;bright&#34;</span><span>)</span>

<span># Dimension of matrix
</span><span>dim</span> <span>=</span> <span>100</span>
<span># Lesp matrix
</span><span>A</span> <span>=</span> <span>lesp</span><span>(</span><span>dim</span><span>)</span>
<span># Transpose matrix A
</span><span>AT</span> <span>=</span> <span>A</span><span>.</span><span>T</span>
<span># Calculate eigenvalues of A
</span><span>Aev</span><span>,</span> <span>Eeg</span> <span>=</span> <span>mp</span><span>.</span><span>eig</span><span>(</span><span>mp</span><span>.</span><span>matrix</span><span>(</span><span>A</span><span>))</span>
<span># Calculate eigenvalues of A^T
</span><span>ATev</span><span>,</span> <span>ETeg</span> <span>=</span> <span>mp</span><span>.</span><span>eig</span><span>(</span><span>mp</span><span>.</span><span>matrix</span><span>(</span><span>AT</span><span>))</span>
<span># Extract real and imaginary parts of A
</span><span>A_X</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>real</span> <span>for</span> <span>x</span> <span>in</span> <span>Aev</span><span>]</span>
<span>A_Y</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>imag</span> <span>for</span> <span>x</span> <span>in</span> <span>Aev</span><span>]</span>
<span># Extract real and imaginary parts of A^T
</span><span>AT_X</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>real</span> <span>for</span> <span>x</span> <span>in</span> <span>ATev</span><span>]</span>
<span>AT_Y</span> <span>=</span> <span>[</span><span>x</span><span>.</span><span>imag</span> <span>for</span> <span>x</span> <span>in</span> <span>ATev</span><span>]</span>

<span># Plot
</span><span>ax</span> <span>=</span> <span>sns</span><span>.</span><span>scatterplot</span><span>(</span><span>x</span><span>=</span><span>A_X</span><span>,</span> <span>y</span><span>=</span><span>A_Y</span><span>,</span> <span>color</span> <span>=</span> <span>&#39;gray&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;o&#39;</span><span>,</span> <span>label</span><span>=</span><span>r</span><span>&#39;$\mathbf{A}$&#39;</span><span>)</span>
<span>ax</span> <span>=</span> <span>sns</span><span>.</span><span>scatterplot</span><span>(</span><span>x</span><span>=</span><span>AT_X</span><span>,</span> <span>y</span><span>=</span><span>AT_Y</span><span>,</span> <span>color</span> <span>=</span> <span>&#39;blue&#39;</span><span>,</span> <span>marker</span><span>=</span><span>&#39;x&#39;</span><span>,</span> <span>label</span><span>=</span><span>r</span><span>&#39;$\mathbf{A}^T$&#39;</span><span>)</span>
<span># Give axis labels
</span><span>ax</span><span>.</span><span>set</span><span>(</span><span>xlabel</span><span>=</span><span>r</span><span>&#39;real&#39;</span><span>,</span> <span>ylabel</span><span>=</span><span>r</span><span>&#39;imag&#39;</span><span>)</span>
<span># Draw legend
</span><span>ax</span><span>.</span><span>legend</span><span>()</span>

<span>pyplot</span><span>.</span><span>show</span><span>()</span>
</pre></td></tr></tbody></table></code></p></div><p>This produces the following plot of the eigenvalues for a \(100 \times 100 \) matrix.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/Lesp_mpmath.png" alt="Desktop View"/></p><p>Success! We have shown that the eigenvalues of \(\mathbf{A}\) are equal to the eigenvalues of \(\mathbf{A}^T\), equation (1) and all eigenvalues are real. This particular example highlights a recurring theme within computational studies of quantum systems. Quantum simulations of atoms and molecules regularly involve ill-conditioned standard and generalized eigenvalue problems. Numerically stable algorithms exist for such problems, but these occasionally fail leaving us to brute force the calculation with higher precision to minimize floating point rounding errors.</p><p>The next post will discuss better ways to implement higher precision in numerical calculations.</p></div></div>
  </body>
</html>
