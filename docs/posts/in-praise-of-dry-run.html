<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://henrikwarne.com/2026/01/31/in-praise-of-dry-run/">Original</a>
    <h1>In praise of –dry-run</h1>
    
    <div id="readability-page-1" class="page"><div>
				
<p>For the last few months, I have been developing a new reporting application. Early on, I decided to add a <em>–dry-run</em> option to the run command. This turned out to be quite useful – I have used it many times a day while developing and testing the application.</p>



<figure><a href="https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg"><img data-attachment-id="2600" data-permalink="https://henrikwarne.com/2026/01/31/in-praise-of-dry-run/snow/" data-orig-file="https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg" data-orig-size="4000,1176" data-comments-opened="1" data-image-meta="{&#34;aperture&#34;:&#34;1.7&#34;,&#34;credit&#34;:&#34;&#34;,&#34;camera&#34;:&#34;Pixel 9a&#34;,&#34;caption&#34;:&#34;&#34;,&#34;created_timestamp&#34;:&#34;1768050964&#34;,&#34;copyright&#34;:&#34;&#34;,&#34;focal_length&#34;:&#34;4.53&#34;,&#34;iso&#34;:&#34;29&#34;,&#34;shutter_speed&#34;:&#34;0.000541&#34;,&#34;title&#34;:&#34;&#34;,&#34;orientation&#34;:&#34;0&#34;}" data-image-title="snow" data-image-description="" data-image-caption="" data-medium-file="https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=300" data-large-file="https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=500" width="1024" height="301" src="https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=1024" alt="" srcset="https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=1024 1024w, https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=2048 2048w, https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=150 150w, https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=300 300w, https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=768 768w, https://henrikwarne.com/wp-content/uploads/2026/01/snow.jpg?w=1440 1440w" sizes="(max-width: 1024px) 100vw, 1024px"/></a></figure>



<h2>Background</h2>



<p>The application will generate a set of reports every weekday. It has a loop that checks periodically if it is time to generate new reports. If so, it will read data from a database, apply some logic to create the reports, zip the reports, upload them to an sftp server, check for error responses on the sftp server, parse the error responses, and send out notification mails. The files (the generated reports, and the downloaded feedback files) are moved to different directories depending on the step in the process. A simple and straightforward application.</p>



<p>Early in the development process, when testing the incomplete application, I remembered that Subversion (the version control system after CVS, before Git) had a <em>–dry-run</em> option. Other linux commands have this option too. If a command is run with the argument <em>–dry-run</em>, the output will print what will happen when the command is run, but no changes will be made. This lets the user see what will happen if the command is run without the <em>–dry-run</em> argument.</p>



<p>I remembered how helpful that was, so I decided to add it to my command as well. When I run the command with <em>–dry-run</em>, it prints out the steps that will be taken in each phase: which reports that will be generated (and which will not be), which files will be zipped and moved, which files will be uploaded to the sftp server, and which files will be downloaded from it (it logs on and lists the files).</p>



<p>Looking back at the project, I realized that I ended up using the <em>–dry-run</em> option pretty much every day.</p>



<h2>Benefits</h2>



<p>I am surprised how useful I found it to be. I often used it as a check before getting started. Since I know <em>–dry-run</em> will not change anything, it is safe to run without thinking. I can immediately see that everything is accessible, that the configuration is correct, and that the state is as expected. It is a quick and easy sanity check.</p>



<p>I also used it quite a bit when testing the complete system. For example, if I changed a date in the report state file (the date for the last successful report of a given type), I could immediately see from the output whether it would now be generated or not. Without <em>–dry-run</em>, the actual report would also be generated, which takes some time. So I can test the behavior, and receive very quick feedback. </p>



<h2>Downside</h2>



<p>The downside is that the <em>dryRun</em>-flag pollutes the code a bit. In all the major phases, I need to check if the flag is set, and only print the action that will be taken, but not actually doing it. However, this doesn’t go very deep. For example, none of the code that actually generates the report needs to check it. I only need to check if that code should be invoked in the first place. </p>



<h2>Conclusion</h2>



<p>The type of application I have been writing is ideal for <em>–dry-run</em>. It is invoked by a command, and it may create some changes, for example generating new reports. More reactive applications (that wait for messages before acting) don’t seem to be a good fit.</p>



<p>I added <em>–dry-run</em> on a whim early on in the project. I was surprised at how useful I found it to be. Adding it early was also good, since I got the benefit of it while developing more functionality.</p>



<p>The <em>–dry-run</em> flag is not for every situation, but when it fits, it can be quite useful.</p>




							</div></div>
  </body>
</html>
