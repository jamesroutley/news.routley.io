<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://jakstys.lt/2022/how-uber-uses-zig/">Original</a>
    <h1>How Uber Uses Zig</h1>
    
    <div id="readability-page-1" class="page"><div>
      <p>Disclaimer: I work at Uber and am partially responsible for bringing <code>zig cc</code>
to serious internal use. Opinions are mine, this blog post is not affiliated
with Uber.</p>
<p>I talked at the <a href="https://zig.news/kristoff/zig-milan-party-2022-final-info-schedule-1jc1">Zig Milan</a> meetup about “Onboarding Zig at Uber”.
This post is a little about “how Uber uses Zig”, and more about “my experience
of bringing Zig to Uber”, from both technical and social aspects.</p>
<p><!-- raw HTML omitted -->The video is <a href="https://www.youtube.com/watch?v=SCj2J3HcEfc">here</a><!-- raw HTML omitted -->. The rest of the post is a loose
transcript, with some commentary and errata.</p>




















<figure>
    
    <picture>
      <source type="image/webp" sizes="(max-width: 600px) 350px, 350px" srcset="
          /_/2022/_hu95706ec8c8422d31b51471a0e7308677_86244_ab4b88d0abb89671c14c0c0166c104b9.webp 350w"/>
      <img sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/uber-zig-frank-tweet_hu95706ec8c8422d31b51471a0e7308677_86244_350x0_resize_q75_box.jpg 350w" src="https://avi.im/_/2022/_hu95706ec8c8422d31b51471a0e7308677_86244_ffb79179e9e5f0467fc554f37b10f6eb.jpg" alt="My talk title, picture taken by @jedisct1"/>
    </picture>
    
    
    <figcaption>
        <p>
        @mo_kelione is still my temporary twitter handle from 2009.
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>TLDR:</p>
<ul>
<li>Uber uses Zig to compile its C/C++ code. Now only in the <a href="https://eng.uber.com/go-monorepo-bazel/">Go
Monorepo</a> via <a href="https://sr.ht/~motiejus/bazel-zig-cc/">bazel-zig-cc</a>, with plans to
possibly expand use of <code>zig cc</code> to other languages that need a C/C++
toolchain.</li>
<li>Main selling points of C/C++ toolchain on top of zig-cc over the
alternatives: configurable versions of glibc and macOS cross-compilation.</li>
<li>Uber does not have any plans to use zig-the-language yet.</li>
<li>Uber signed a support agreement with Zig Software Foundation (ZSF) to
prioritize bug fixes. The contract value is disclosed in the ZSF financial
reports.</li>
<li>Thanks to my team, the Go Monorepo team, the Go Platform team, my director,
finance, legal, and of course Zig Software Foundation for making this
relationship happen. The relationship has been fruitful so far.</li>
</ul>


<h2 id="about-ubers-tech-stack">About Uber’s tech stack</h2>
<p>Uber started in 2010, has clocked over 15 billion trips, and made lots of cool
and innovative tech for it to happen. General-purpose “allowed” server-side
languages are Go and Java, with Python and Node allowed for specific use cases
(like front-end for Node and Python for data analysis/ML). C++ is used for a few
low level libraries. Use of other languages in back-end code is minimal.</p>
<p>Our Go Monorepo is larger than Linux kernel<sup id="fnref:1"><a href="#fn:1" role="doc-noteref">1</a></sup>, and worked on by a couple of
thousand engineers. In short, it’s big.</p>
<h2 id="how-does-uber-use-zig">How does Uber use Zig?</h2>




















<figure>
    
    <picture>
      <source type="image/webp" sizes="(max-width: 600px) 350px, 350px" srcset="
          /_/2022/_hubc44e19d0892953edb9771121dbf1b45_94355_a6ccdaaca10fac8cfd40082c0f49ce92.webp 350w
          , /_/2022/_hubc44e19d0892953edb9771121dbf1b45_94355_6c20941a60eea8bd6ec5b9dab5292c2c.webp 700w"/>
      <img sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/uber-zig-abg_hubc44e19d0892953edb9771121dbf1b45_94355_350x0_resize_box_3.png 350w
          , /_/2022/_hubc44e19d0892953edb9771121dbf1b45_94355_28caa931ed83ce6eeb9d060c602de07c.png 700w" src="https://avi.im/_/2022/_hubc44e19d0892953edb9771121dbf1b45_94355_28caa931ed83ce6eeb9d060c602de07c.png" alt="Abhinav Gupta: we&#39;re using Zig&#39;s C toolchain only, not the language. It&#39;s not fully rolled out yet, but among other things, it&#39;ll enable cross compilation of C based code (as well as Go code that uses CGo). It&#39;ll drop the dependency on the system&#39;s C compiler."/>
    </picture>
    
    
    <figcaption>
        <p>
        Abhinav&#39;s TLDR of the presentation.
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>I can’t say this better than my colleague <a href="https://abhinavg.net/">Abhinav Gupta</a> from the Go
Platform team (a transcript is available in the “alt” attribute):</p>
<p>At this point of the presentation, since I explained (thanks abg!) how Uber
uses Zig, I could end the talk. But you all came in for the process, so after
an uncomfortable pause, I decided to tell more about it.</p>


<h2 id="history">History</h2>
<p>Pre-2018 Uber’s Go services lived in their separate repositories. In 2018<sup id="fnref:2"><a href="#fn:2" role="doc-noteref">2</a></sup>
services started moving to Go monorepo en masse. My team was among the first
wave — I still remember the complexity.</p>
<h3 id="2019-asks-for-a-hermetic-toolchain">2019: asks for a hermetic toolchain</h3>
<p>At the time, the Go monorepo already used a hermetic Go toolchain. Therefore,
the Go compiler used to build the monorepo was unaffected by the compiler
installed on the system, if any. Therefore, on whichever environment a Go build
was running, it always used the same version of Go. Bazel docs <a href="https://bazel.build/concepts/hermeticity">explain this
better than me</a>.</p>




















<figure>
    
    <picture>
      <source type="image/webp" sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/_hu53cf51d855df74765df0df7779c8531c_63125_74249529063697eda84b5203c7f4473b.webp 350w
          , /_/2022/_hu53cf51d855df74765df0df7779c8531c_63125_b4ece40056d4f67049235a6894be3f44.webp 700w"/>
      <img sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/uber-zig-gm-221_hu53cf51d855df74765df0df7779c8531c_63125_350x0_resize_box_3.png 350w
          , /_/2022/_hu53cf51d855df74765df0df7779c8531c_63125_76b844227286e601de7d05ad2a9ccbcd.png 700w" src="https://avi.im/_/2022/_hu53cf51d855df74765df0df7779c8531c_63125_76b844227286e601de7d05ad2a9ccbcd.png" alt="A Jira task asking for a hermetic C++ toolchain."/>
    </picture>
    
    
    <figcaption>
        <p>
        This was created in 2019 and did not see much movement.
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>A C++ toolchain is a collection of programs to compile C/C++ code. It is
unavoidable for some our Go code to use <a href="https://godocs.io/cmd/cgo">CGo</a>, so it needs a C/C++
compiler. Go then links the Go and C parts to the final executable.</p>
<p>The C++ toolchain was not hermetic since the start of Go monorepo: Bazel would
use whatever it found on the system. That meant Clang on macOS, GCC (whatever
version) on Linux. Setting up a hermetic C++ toolchain in Bazel is a lot of
work (think person-months for our monorepo), there was no immediate need, and
it also was not painful <em>enough</em> to be picked up.</p>
<p>At this point it is important to understand the limitations of a non-hermetic
C++ toolchain:</p>
<ul>
<li>Cannot cross-compile. So we can’t compile Linux executables on a Mac if they
require CGo (which many of our services do). This was worked around by… not
cross-compiling.</li>
<li>CGo executables would link to a glibc version that was found on the system.
That means: when upgrading the OS (multi-month effort), the build fleet must
be upgraded last. Otherwise, if build host runs a newer glibc than a
production host, the resulting binary will link against a newer glibc
version, which is incompatible to the old one still on a production host.</li>
<li>We couldn’t use new compilers, which have better optimizations, because we
were running an older OS on the build fleet (backporting only the compiler,
but not glibc, carries it’s own risks).</li>
<li>Official binaries for newer versions of Go are built against a more recent
version of GCC than some of our build machines. We had to work around this by
compiling Go from source on these machines.</li>
</ul>
<p>All of these issues were annoying, but not enough to invest into the toolchain.</p>
<h3 id="2020-dec-need-musl">2020 Dec: need musl</h3>
<p>I was working on a non-Uber-related toy project that is built with Bazel and
uses CGo. I wanted my binary to be static, but Bazel does not make that easy. I
spent a couple of evenings creating a Bazel toolchain on top of
<a href="https://musl.cc">musl.cc</a>, but didn’t go far, because at the time I wasn’t
able to make sense out of the Bazel’s toolchain documentation, and I didn’t
find a good example to rely on.</p>
<h3 id="2021-jan-discovering-zig-cc">2021 Jan: discovering <code>zig cc</code></h3>
<p>In January of 2021 I found Andrew Kelley’s blog post <a href="https://andrewkelley.me/post/zig-cc-powerful-drop-in-replacement-gcc-clang.html"><code>zig cc</code>: a Powerful
Drop-In Replacement for GCC/Clang</a>. I recommend reading the
article; it changed how I think about compilers (and it will help you
understand the remaining article better, because I gave the talk to a Zig
audience). To sum up the Andrew’s article, <code>zig cc</code> has the following
advantages:</p>
<ul>
<li>Fully hermetic C/C++ compiler in ~40MB tarball. This is an order of magnitude
smaller than the standard Clang distributions.</li>
<li>Can link against a glibc version that was provided as a command-line argument
(e.g. <code>-target x86_64-linux-gnu.2.28</code> will compile for x86_64 Linux and link
against glibc 2.28).</li>
<li>Host and target are decoupled. The setup is the same for both <code>linux-aarch64</code>
and <code>darwin-x86_64</code> targets, regardless of the host.</li>
<li>Linking with musl is “just a different libc version”: <code>-target x86_64-linux-musl</code>.</li>
</ul>
<p>I started messing around with <code>zig cc</code>. I compiled random programs, reported
issues. I thought about making this a <a href="https://bazel.build/docs/toolchains">bazel toolchain</a>, but
there were quite a few blocking bugs or missing features. One of them was lack
of <code>zig ar</code>, which Bazel relies on.</p>
<h3 id="2021-feb-asking-for-attention">2021 Feb: asking for attention</h3>
<p>I <a href="https://github.com/ziglang/zig/issues?q=author%3Amotiejus+sort%3Acreated-asc">reported bugs</a> to Zig. Nothing happened for a
week. I donated $50/month, expecting “the Zig folks” to prioritize what I’ve
reported. A week of silence again. And then I dropped the bomb in
<code>#zig:libera.chat</code>:</p>
<pre tabindex="0"><code>&lt;motiejus&gt; What is the protocol to &#34;claim&#34; the dev hours once donated?
&lt;andrewrk&gt; ZSF only accepts no-strings-attached donations
&lt;andrewrk&gt; did you get a different impression somewhere?
</code></pre><p>Oops. At the time I hoped that whoever notice the conversation would immediately
forget it. Well, here it is again, more than a year later, over here, for your
enjoyment.</p>
<h3 id="2021-june-bazel-zig-cc-and-ubers-go-monorepo">2021 June: bazel-zig-cc and Uber’s Go monorepo</h3>
<p>In June of 2021 <a href="https://github.com/ajbouh/">Adam Bouhenguel</a> created a <a href="https://github.com/ajbouh/bazel-zig-cc/">working bazel-zig-cc
prototype</a>. The basics worked, but it still lacked some
features. Andrew later implemented <code>zig ar</code><sup id="fnref:3"><a href="#fn:3" role="doc-noteref">3</a></sup>, which was the last missing
piece to a truly workable bazel-zig-cc. I integrated <code>zig ar</code>, polished the
documentation and <a href="https://lists.sr.ht/~andrewrk/ziglang/%3C20210811104907.qahogqbdjs4trihn%40mtpad.i.jakstys.lt%3E">announced my fork of bazel-zig-cc to the Zig mailing
list</a>. At this point it was usable for my toy project. Win!</p>
<p>A few weeks after the announcement I created a “WIP DIFF” for Uber’s Go
monorepo: just used my onboarding instructions and naïvely submitted it to our
CI. It failed almost all tests.</p>




















<figure>
    
    <picture>
      <source type="image/webp" sizes="(max-width: 600px) 350px, 350px" srcset="
          /_/2022/_hu97485416e625a5cd7c054c111c1add3d_14135_6d6bba405d07f8be5bacd1a15acb5534.webp 350w"/>
      <img sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/uber-zig-zcc-gocode_hu97485416e625a5cd7c054c111c1add3d_14135_350x0_resize_box_3.png 350w" src="https://avi.im/_/2022/_hu97485416e625a5cd7c054c111c1add3d_14135_78b6f9a0a3c8e3e2cd53dadd8934193c.png" alt="A diff titled &#34;zig c++ toolchain&#34;. Started in July 1, 2021"/>
    </picture>
    
    
    <figcaption>
        <p>
        Onboarding bazel-zig-cc to Uber&#39;s Go monorepo.
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>Most of the failures were caused by dependencies on system libraries. At this
point it was clear that, to truly onboard bazel-zig-cc and compile <strong>all</strong> it’s
C/C++ code, there needs to be quite a lot of investment to remove the
dependency on system libraries and undoing of a lot of technical debt.</p>
<h3 id="2021-end-recap">2021 End: recap</h3>
<ul>
<li>Various places at Uber would benefit from a hermetic C++ cross-compiler, but
it’s not funded due to requiring a large investment and not naving enough
justification.</li>
<li>bazel-zig-cc kinda works, but both bazel-zig-cc and zig cc have known bugs.</li>
<li>I can’t realistically implement the necessary changes or bug fixes. I tried
implementing <code>zig ar</code>, a trivial front-end for LLVM’s <code>ar</code>, and failed.</li>
<li>Once an issue had been identified as a Zig issue, getting attention from Zig
developers was unpredictable. Some issues got resolved within days, some took
more than 6 months, and donations din’t change <code>zig cc</code> priorities.</li>
<li>The monorepo-onboarding diff was simmering and waiting for it’s time.</li>
</ul>
<h3 id="2021-end-uber-needs-a-cross-compiler">2021 End: Uber needs a cross-compiler</h3>
<p>I was tasked to evaluate arm64 for Uber. Evaluation details aside, I needed to
compile software for linux-arm64. Lots of it! Since most of our low-level infra
is in the Go monorepo, I needed a cross-compiler there first.</p>
<p>A business reason for a cross-compiler landed on my lap. Now now both time and
money can be invested there. Having a “WIP diff” with <code>zig cc</code> was a good
start, but was still very far from over: teams were not convinced it was the
right thing to do, the diff was too much of a prototype, and both zig-cc and
bazel-zig-cc needed lots of work before they could be used at any capacity at
Uber.</p>
<p>When onboarding such a technology in a large corporation, the most important
thing to manage is risk. As Zig is a novel technology (not even 1.0!), it was
truly unusual to suggest compiling all of our C and C++ code with it. We should
be planning to stick with it for at least a decade. Questions were raised and
evaluated with great care and scrutiny. For that I am truly grateful to the Go
Monorepo team, especially <a href="https://github.com/kmicklas">Ken Micklas</a>, for doing the work and
research on this unproven prototype.</p>
<h3 id="evaluation-of-different-compilers">Evaluation of different compilers</h3>
<p>Given that we now needed a cross-compiler, we had two candidates:</p>
<ul>
<li><a href="https://github.com/grailbio/bazel-toolchain">grailbio/bazel-toolchain</a>. Uses a vanilla Clang.
No risk. Well understood. Obviously safe and correct solution.</li>
<li><a href="https://sr.ht/~motiejus/bazel-zig-cc/">~motiejus/bazel-zig-cc</a>: uses <code>zig cc</code>. Buggy, risky, unsafe,
uncertain, used-by-nobody, but quite a tempting solution.</li>
</ul>
<p><code>zig cc</code> provides a few extra features on top of <code>bazel-toolchain</code>:</p>
<ul>
<li>configurable glibc version. With <code>grailbio</code> you would need a sysroot
(basically, a chroot with the system libraries, so the programs can be linked
against them), which would need to be maintained.</li>
<li>a working, albeit still buggy, hermetic (cross-)compiler for macOS.</li>
</ul>
<p>We would be able to handle glibc with either, however, <code>grailbio</code> is unlikely
to ever have a way to compile to macOS, let alone cross-compile. Relying on the
system compiler is undesirable on developer laptops, and the Go Platform feels
that first-hand, especially during macOS upgrades.</p>
<p>The prospect of a hermetic toolchain for macOS targets tipped the scales
towards <code>zig cc</code>, with all its warts, risks and instability.</p>
<p>There was still another problem, one of attention: if we were considering the
use of Zig in a serious capacity, we knew we will hit problems, but would be
unlikely to have the expertise to solve them. How can we, as a BigCorp, de-risk
the engagement question, making sure that bugs important to us are handled
timely? We were sure of good intentions of ZSF: it was obvious that, if we find
and report a legitimate bug, it would get fixed. But how can we put an upper
bound on latency?</p>
<h3 id="money">Money</h3>
<p>$50 donation does not help, perhaps a large service contract would? I asked
around if we could spend some money to de-risk our “cross-compiler”. Getting a
green light from the management took about 10 minutes; drafting, approving and
signing the contract took about 2 months.</p>
<p>Contract terms were roughly as follows:</p>
<ul>
<li>Uber reports issues to github.com/ziglang/zig and pings Loris.</li>
<li>Loris assigns it to someone in ZSF.</li>
<li>Hack hack hack hack hack.</li>
<li>When done, Loris enters the number of hours worked on the issue.</li>
</ul>
<p>Uber has a right to ZSF members’ <em>time</em>. We have no decision or voting power
whatsoever with regards to Zig. We have right to offer suggestions, but they
have been and will be treated just like from any other third-party bystander.
We did not ask for special rights, it’s explicit in the contract, and we don’t
want that.</p>
<p>The contract was signed, the wire transfer completed, and in 2022 January we
had:</p>
<ul>
<li>A service contract with ZSF that promised to prioritize issues that we’ve
registered.</li>
<li>A commitment from Go Platform team to make our C++ toolchain cross-compiling
and hermetic.</li>
</ul>




















<figure>
    
    <picture>
      <source type="image/webp" sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/_hue49f1a541ca279e3883ce24aab7d242f_39219_ea10450bdd94056e0a2c45f143475cd0.webp 350w
          , /_/2022/_hue49f1a541ca279e3883ce24aab7d242f_39219_e0594d65b5c157c30ca90f9111defca2.webp 700w"/>
      <img sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/uber-zig-deposit_hue49f1a541ca279e3883ce24aab7d242f_39219_350x0_resize_box_3.png 350w
          , /_/2022/_hue49f1a541ca279e3883ce24aab7d242f_39219_b9a6ebdcac5863c4728d41b966d0daad.png 700w" src="https://avi.im/_/2022/_hue49f1a541ca279e3883ce24aab7d242f_39219_b9a6ebdcac5863c4728d41b966d0daad.png" alt="Wire of $52800 from Uber to Zig Software Foundation"/>
    </picture>
    
    
    <figcaption>
        <p>
        The amount of money that changed hands is public, because ZSF is a nonprofit.
        
            
        
        </p> 
    </figcaption>
    
</figure>


<h2 id="2022-and-beyond">2022 and beyond</h2>
<p>In Feb 2022 the toolchain was gated behind a command-line flag
(<code>--config=hermetic-cc</code>). As of Feb 2022, you can invoke <code>zig cc</code> in Uber’s Go
Monorepo without requiring a custom patch.</p>




















<figure>
    
    <picture>
      <source type="image/webp" sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/_hua75be2f53ef6592733cc4689f465ce30_38960_a897cfc1ff2a41b72e95301bd14fae8c.webp 350w"/>
      <img sizes="(max-width: 600px) 350px, 700px" srcset="
          /_/2022/uber-zig-landed_hua75be2f53ef6592733cc4689f465ce30_38960_350x0_resize_box_3.png 350w" src="https://avi.im/_/2022/_hua75be2f53ef6592733cc4689f465ce30_38960_8422e411a39f8e47192bc027e55c2437.png" alt="WIP DIFF onboarding the monorepo was landed"/>
    </picture>
    
    
    <figcaption>
        <p>
        Proof of our submitqueue landed my WIP DIFF.
        
            
        
        </p> 
    </figcaption>
    
</figure>


<p>Timeline of 2022 so far:</p>
<ul>
<li>In April, around my talk in Milan, we shipped the first Debian package
compiled with zig-cc to production.</li>
<li>In May we have enabled <code>zig cc</code> for all our Debian packages.</li>
<li>In H2 we expect to compile all our cgo code with <code>zig cc</code> and make
the <code>--config=hermetic-cc</code> a default.</li>
<li>In H2 we expect to move <a href="https://sr.ht/~motiejus/bazel-zig-cc/">bazel-zig-cc</a> under github.com/uber.</li>
</ul>
<p>We have opened a number of issues to Zig, and, as of writing, all of them have
been resolved. Some were handled by ZSF alone, some were more involved and
required collaboration between ZSF, Uber and Go developers.</p>
<h2 id="summary">Summary</h2>
<p>I started preparing for the presentation hoping I can give “a runbook” how to
adopt Zig at a big company. However, there is no runbook; my effort to onboard
zig-cc could have failed due to many many reasons.</p>
<p>Looking back, I think the most important reasons for success is a killer
feature at the right time. In our case, there were two: glibc version selection
without a sysroot and cross-compiling to macOS.</p>
<h2 id="appendix">Appendix</h2>
<p>I forgot to flip to the last slide in the presentation. Here it is:</p>
<pre tabindex="0"><code>
{
 
</code></pre><p>If compilers or adopting software for other CPU architectures (and/or living in
the Eastern Europe) is your thing, my team in Vilnius is hiring. Also, my
sister teams in Seattle and Bay Area are hiring too. Ping me.</p>
<h2 id="credits">Credits</h2>
<p>Many thanks Abhinav Gupta, Loris Cro and Ken Micklas for reading drafts of
this.</p>

</div></div>
  </body>
</html>
