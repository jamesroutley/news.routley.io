<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.lucasholten.com/rust-query-announcement/">Original</a>
    <h1>Safe relational database queries using the Rust type system</h1>
    
    <div id="readability-page-1" class="page"><div>
  <article>
    
  <header>
    <p>
      <time datetime="2024-11-24">2024-11-24</time>
    
      <strong>Announcing rust-query</strong>
    </p>
      <ul role="list">
        <li role="listitem"><a href="https://blog.lucasholten.com/tags/database/">database</a></li>
      
        <li role="listitem"><a href="https://blog.lucasholten.com/tags/rust/">rust</a></li>
      </ul>
    </header>

    
  
<p>Do you want to persist your data safely without migration issues and easily write complicated queries? All of this without writing a single line of SQL? If so, then <a href="https://github.com/LHolten/rust-query">I am making <code>rust-query</code></a> for you!</p>
<blockquote>
<p>This is my first blog post about <code>rust-query</code>, a project I&#39;ve been working on for many months. I hope you like it!</p>
</blockquote>
<h3 id="rust-and-databases">Rust and Databases</h3>
<p>There is only one reason why I made this library and it is because I don&#39;t like the current options for interacting with a database from Rust. The existing libraries don&#39;t provide the compile time guarantees that I want and are verbose or awkward like SQL.</p>
<p>The reason I care so much is that databases are really cool. They solve a huge problem of making crash-resistant software with support for atomic transactions.</p>
<h2 id="structured-query-language-sql-is-a-protocol">Structured Query Language (SQL) is a protocol</h2>
<p>For those who don&#39;t know, SQL is <strong>the</strong> standard when it comes to interacting with databases. So much so that almost all databases only accept queries in some dialect of SQL.</p>
<p>My opinion is that SQL should be for computers to write. This would put it firmly in the same category as LLVM IR. The fact that it is human-readable is useful for debugging and testing, but I don&#39;t think it&#39;s how you want to write queries.</p>

<p><a href="https://crates.io/crates/rust-query"><code>rust-query</code></a> is my answer to relational database queries in Rust. It&#39;s an opinionated library that deeply integrates with Rust&#39;s type system to make database operations feel Rust-native.</p>
<h2 id="key-features-and-design-decisions">Key Features and Design Decisions</h2>
<p>I could write a blog post about each one of these, but let&#39;s keep it short for now:</p>
<ul>
<li><strong>Explicit table aliasing</strong>: Joining a table gives back a dummy representing that table <code>let user = User::join(rows);</code>.</li>
<li><strong>Null safety</strong>: Optional values in queries have <code>Option</code> type, requiring special care to handle.</li>
<li><strong>Intuitive aggregates</strong>: Our aggregates are guaranteed to give a single result for every row they&#39;re joined on. After trying it, you&#39;ll see this is much more intuitive than traditional <code>GROUP BY</code> operations.</li>
<li><strong>Type-safe foreign key navigation</strong>: Database constraints are like type signatures, so you can rely on them for your queries with easy-to-use implicit joins by foreign key (e.g., <code>track.album().artist().name()</code>).</li>
<li><strong>Type-safe unique lookups</strong>: For example, you can get an <code>Option&lt;Rating&gt;</code> dummy with <code>Rating::unique(my_user, my_story)</code>.</li>
<li><strong>Multi-versioned schema</strong>: It&#39;s declarative and you can see the differences between all past versions of the schema at once!</li>
<li><strong>Type-safe migrations</strong>: Migrations have all the power of queries and can use arbitrary Rust code to process rows. Ever had to consult something outside the database for use in a migration? Now you can!</li>
<li><strong>Type-safe unique conflicts</strong>: Inserting and updating rows in tables with unique constraints results in specialized error types.</li>
<li><strong>Row references tied to transaction lifetime</strong>: Row references can only be used while the row is guaranteed to exist.</li>
<li><strong>Encapsulated typed row IDs</strong>: The actual row numbers are never exposed from the library API. Application logic should not need to know about them.</li>
</ul>
<h2 id="let-s-see-it">Let&#39;s see it!</h2>
<p>You always start by defining a schema. With <code>rust-query</code> it&#39;s easy to migrate to a different schema later.</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>schema</span><span>]
</span><span>enum </span><span>Schema {
</span><span>    User {
</span><span>        name: </span><span>String</span><span>,
</span><span>    },
</span><span>    Story {
</span><span>        author: User,
</span><span>        title: </span><span>String</span><span>,
</span><span>        content: </span><span>String
</span><span>    },
</span><span>    #[</span><span>unique</span><span>(user, story)]
</span><span>    Rating {
</span><span>        user: User,
</span><span>        story: Story,
</span><span>        stars: </span><span>i64
</span><span>    },
</span><span>}
</span><span>use </span><span>v0::</span><span>*</span><span>;
</span></code></pre>
<p>Schema defintions in <code>rust-query</code> use enum syntax, but no actual enum is defined here.
This schema defines three tables with specified columns and relationships:</p>
<ul>
<li>Using another table name as a column type creates a foreign key constraint.</li>
<li>The <code>#[unique]</code> attribute creates named unique constraints.</li>
<li>The <code>#[schema]</code> macro parses the enum syntax and generates a module <code>v0</code> that contains the database API.</li>
</ul>
<h3 id="writing-queries">Writing Queries</h3>
<p>First, let&#39;s see how to insert some data into our schema:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>insert_data</span><span>(txn: </span><span>&amp;</span><span>mut </span><span>TransactionMut&lt;Schema&gt;) {
</span><span>    </span><span>// Insert users
</span><span>    </span><span>let</span><span> alice </span><span>=</span><span> txn.</span><span>insert</span><span>(User {
</span><span>        name: &#34;</span><span>alice</span><span>&#34;,
</span><span>    });
</span><span>    </span><span>let</span><span> bob </span><span>=</span><span> txn.</span><span>insert</span><span>(User {
</span><span>        name: &#34;</span><span>bob</span><span>&#34;,
</span><span>    });
</span><span>    
</span><span>    </span><span>// Insert a story
</span><span>    </span><span>let</span><span> dream </span><span>=</span><span> txn.</span><span>insert</span><span>(Story {
</span><span>        author: alice,
</span><span>        title: &#34;</span><span>My crazy dream</span><span>&#34;,
</span><span>        content: &#34;</span><span>A dinosaur and a bird...</span><span>&#34;,
</span><span>    });
</span><span>    
</span><span>    </span><span>// Insert a rating - note the try_insert due to the unique constraint
</span><span>    </span><span>let</span><span> rating </span><span>=</span><span> txn.</span><span>try_insert</span><span>(Rating {
</span><span>        user: bob,
</span><span>        story: dream,
</span><span>        stars: </span><span>5</span><span>,
</span><span>    }).</span><span>expect</span><span>(&#34;</span><span>no rating for this user and story exists yet</span><span>&#34;);
</span><span>}
</span></code></pre>
<p>A few important points about insertions:</p>
<ul>
<li>We need a mutable transaction (<code>TransactionMut</code>) to modify the database.</li>
<li>Insert operations return references to the newly inserted rows.</li>
<li>When inserting into tables with unique constraints, use <code>try_insert</code> to handle potential conflicts.</li>
<li>The error type of <code>try_insert</code> is based on how many unique constraints the table has.</li>
</ul>
<p>Now let&#39;s query this data:</p>
<pre data-lang="rust"><code data-lang="rust"><span>fn </span><span>query_data</span><span>(txn: </span><span>&amp;</span><span>Transaction&lt;Schema&gt;) {
</span><span>    </span><span>let</span><span> results </span><span>=</span><span> txn.</span><span>query</span><span>(|rows| {
</span><span>        </span><span>let</span><span> story </span><span>= </span><span>Story::join(rows);
</span><span>        </span><span>let</span><span> avg_rating </span><span>= aggregate</span><span>(|rows| {
</span><span>            </span><span>let</span><span> rating </span><span>= </span><span>Rating::join(rows);
</span><span>            rows.</span><span>filter_on</span><span>(rating.</span><span>story</span><span>(), </span><span>&amp;</span><span>story);
</span><span>            rows.</span><span>avg</span><span>(rating.</span><span>stars</span><span>().</span><span>as_float</span><span>())
</span><span>        });
</span><span>        rows.</span><span>into_vec</span><span>((story.</span><span>title</span><span>(), avg_rating))
</span><span>    });
</span><span>
</span><span>    </span><span>for </span><span>(title, avg_rating) </span><span>in</span><span> results {
</span><span>        println!(&#34;</span><span>story &#39;</span><span>{title}</span><span>&#39; has avg rating </span><span>{avg_rating:?}</span><span>&#34;);
</span><span>    }
</span><span>}
</span></code></pre>
<p>Key points about queries:</p>
<ul>
<li><code>rows</code> represents the current set of rows in the query.</li>
<li>Joins can add rows and filters can remove rows. <details>By joining a table like <code>Story</code>, the <code>rows</code> set is mutated to be the Cartesian product of itself and the rows from the joined table. The query above only has a single <code>join</code>, so we know it will give exactly one result for each row in the <code>Story</code> table.</details> </li>
<li>Using <code>aggregate</code> to calculate an aggregate, does not change the number of rows in the query.</li>
<li><code>rows.filter_on</code> can be used to filter rows in the aggregate to match a value from the outer scope.</li>
<li>The <code>rows.avg</code> method returns the average of the rows in the aggregate, if there are no rows then the average will evaluate to <code>None</code>.</li>
<li>Results can be collected into vectors of tuples or structs.</li>
</ul>
<h3 id="schema-evolution-and-migrations">Schema Evolution and Migrations</h3>
<p>Let&#39;s say you want to add an email address to each user. Here&#39;s how you&#39;d create the new schema version:</p>
<pre data-lang="rust"><code data-lang="rust"><span>#[</span><span>schema</span><span>]
</span><span>#[</span><span>version</span><span>(0..</span><span>=</span><span>1)]
</span><span>enum </span><span>Schema {
</span><span>    User {
</span><span>        name: </span><span>String</span><span>,
</span><span>        #[</span><span>version</span><span>(1..)]
</span><span>        email: </span><span>String</span><span>,
</span><span>    },
</span><span>    </span><span>// ... rest of schema ...
</span><span>}
</span><span>use </span><span>v1::</span><span>*</span><span>;
</span></code></pre>
<p>And here&#39;s how you&#39;d migrate the data:</p>
<pre data-lang="rust"><code data-lang="rust"><span>let</span><span> m </span><span>=</span><span> m.</span><span>migrate</span><span>(v1::update::Schema {
</span><span>    user: </span><span>Box</span><span>::new(|old_user| {
</span><span>        Alter::new(v1::update::UserMigration {
</span><span>            email: old_user
</span><span>                .</span><span>name</span><span>()
</span><span>                .</span><span>map_dummy</span><span>(|name| format!(&#34;</span><span>{name}</span><span>@example.com</span><span>&#34;)),
</span><span>        })
</span><span>    }),
</span><span>});
</span></code></pre>
<ul>
<li>The <code>v1::update</code> module contains structs defining the difference between schema <code>v0</code> and schema <code>v1</code>.</li>
<li>We use these structs to implement the migration. This way the migration is type checked against both the old and new schemas.</li>
<li>Note that inside migrations we can execute all the single-row queries we want: aggregates, unique constraint lookups etc.!</li>
<li>We can also use <code>map_dummy</code> with arbitrary Rust to process rows further.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p><code>rust-query</code> represents a fresh approach to database interactions in Rust, prioritizing:</p>
<ul>
<li>Checking everything possible at compile time.</li>
<li>Making it possible to compose queries with each other and arbitrary Rust.</li>
<li>Enabling schema evolution with type-checked migrations.</li>
</ul>
<p>While still in development, the library already allows building experimental database-backed applications in Rust. I encourage you to try it out and provide feedback through <a href="https://github.com/LHolten/rust-query">GitHub</a> issues!</p>
<blockquote>
<p>The library currently uses SQLite as its only backend, chosen for its embedded nature. This will not change anytime soon, as one backend is most practical while <code>rust-query</code> is in development.</p>
</blockquote>


    
  
  </article>
</div></div>
  </body>
</html>
