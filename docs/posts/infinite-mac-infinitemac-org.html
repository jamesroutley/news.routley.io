<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://blog.persistent.info/2023/03/infinitemac-dot-org.html">Original</a>
    <h1>Infinite Mac: Infinitemac.org</h1>
    
    <div id="readability-page-1" class="page"><article>
<p><b>tl;dr:</b> Infinite Mac has a new home at <a href="https://infinitemac.org/">infinitemac.org</a>. Using a new Emscripten port of Mini vMac, it is now able to run almost every notable version of Mac OS, from 1984’s <a href="https://infinitemac.org/1984/System%201.0">System 1.0</a> to 2000’s <a href="https://infinitemac.org/2000/Mac%20OS%209.0.4">Mac OS 9.0.4</a>. The project is also now accepting donations (via <a href="https://github.com/sponsors/mihaip">GitHub Sponsors</a> or <a href="https://www.paypal.com/donate/?hosted_button_id=394METCPT6PYN">PayPal</a>).</p>

<figure>
  <img src="https://persistent.info/images/infinite-macs.jpeg" width="800" height="627" alt="3 emulated Macs and a real one on a desk"/>
  <figcaption>Spot the odd one out.</figcaption>
</figure>

<h3>Mini vMac</h3>

<p>As I mentioned in my <a href="https://blog.persistent.info/2023/01/infinite-mac-2022-in-review.html#whats-next">last post on the project</a>, my immediate plans were to make even older versions of System Software runnable in the browser. <a href="https://github.com/adespoton">Em Adespoton</a> maintains a <a href="https://docs.google.com/spreadsheets/d/1us6SCBgVs8NqbxofJXTmHDeK3nKQJpcgya2nWC9_t2w/edit">compatibility matrix spreadsheet</a> showing which emulators can run specific OS versions, and it looked like my best bet was <a href="https://www.gryphel.com/c/minivmac/index.html">Mini vMac</a>. There is an existing <a href="https://github.com/yksoft1/minivmac-em">Emscripten port</a>, but I decided to start from scratch for two reasons:</p>

<ol>
<li>It used <a href="https://emscripten.org/docs/compiling/Building-Projects.html?highlight=sdl2#emscripten-ports">Emscripten’s SDL compatibility layer</a>, presumably to minimize the work to get something up and running. However, that’s both less efficient (as far as additional layers of abstraction to go through) and would not benefit from the JavaScript/browser API wrappers that I’d already developed for Basilisk II and SheepShaver.</li>
<li>It first ran Mini vMac’s custom build system to <a href="https://github.com/yksoft1/minivmac-em/commit/4448ccfea424d8fe684696d1b50271023693a709">generate</a> the Makefile and other configuration data for Linux/SDL, and then <a href="https://github.com/yksoft1/minivmac-em/commits/master">modified</a> the generated code to get things working. This seemed like a not very maintainable approach for the long run, since any re-runs of the generation system (e.g. to generate with <a href="https://www.gryphel.com/c/minivmac/options.html#in">different options</a>) would require the modifications to be redone.</li>
</ol>

<p>The first step in doing it myself was to get Mini vMac building. It’s an “interesting” project for a few reasons:</p>

<ul>
<li>It doesn’t use version control (source code is available as <a href="https://www.gryphel.com/d/minivmac/minivmac-37.03/minivmac-37.03.src.tgz">tarballs</a> <a href="https://www.gryphel.com/d/minivmac/minivmac-36.04/minivmac-36.04.src.tgz">for</a> <a href="https://www.gryphel.com/d/minivmac/minivmac-3.5.8/minivmac-3.5.8.src.zip">major</a> <a href="https://web.archive.org/web/20170619143145/http://www.gryphel.com/d/minivmac/minivmac-3.4.1/minivmac-3.4.1.src.zip">versions</a>).</li>
<li>Rather than a traditional autoconf + make setup, it has its own build system generator (also written in C). </li>
<li>Almost all <a href="https://www.gryphel.com/c/minivmac/options.html#in">options</a> are specified at compile time (to minimize binary size and runtime cost presumably), so there&#39;s a lot of branching that relies on the C preprocessor.</li>
<li>It can be built by <a href="https://www.gryphel.com/c/minivmac/appc/index.html#in">very old compilers</a> for a broad range of platforms (even <a href="https://github.com/minivmac/minivmac/blob/master/src/OSGLUMAC.c">classic Mac OS</a>, <a href="https://github.com/minivmac/minivmac/blob/master/src/OSGLUOSX.c">Carbon</a>, <a href="https://github.com/minivmac/minivmac/blob/master/src/OSGLUNDS.c">Nintendo DS</a>). Therefore it targets C89 and makes heavy use of macros and typedefs to make things work in such a broad range of environments.</li>
</ul>

<p><a href="https://invisibleup.com/articles/30/#:~:text=I%20could%20steal.-,Mini%20vMac,-This%20is%20the">This blog post</a> has a rather negative take on the whole setup, but I have some empathy for Paul (Mini vMac’s author). This is clearly a passion project for him (dating back to <a href="https://www.gryphel.com/c/news/nva0.html#n010228">2001</a>), and he’s set things up in a way that suits him. Incidentally, Paul himself<a href="https://www.emaculation.com/forum/viewtopic.php?t=11570"> has not been heard from</a> for a couple of years, hence Mini vMac is in a bit of a limbo state. An import of the codebase and website <a href="https://github.com/minivmac">to a GitHub org</a> was done in 2022, in case Paul’s site does eventually go down.</p>

<p>With that context out of the way, getting it to build was actually not as painful as it sounds. While the build system is custom, it’s also arbitrary C code, so it’s very easy to hack on (vs. dealign with <a href="https://en.wikipedia.org/wiki/M4_(computer_language)">m4</a> for autoconf). Since it targets some very low-end platforms it’s also very fast to build, so the iteration speed was great. The <a href="https://github.com/mihaip/minivmac/commit/2e845b62d3634b0f60f3dc3ce5f183f960ebd2d6">initial bring-up</a> involved adding an alternate Makefile generation mode that used the Emscripten toolchain and <a href="https://github.com/mihaip/minivmac/blob/2e845b62d3634b0f60f3dc3ce5f183f960ebd2d6/src/OSGLUESC.c">a glue file</a> to get configuration data in and the framebuffer out. With that scaffolding in place, adding <a href="https://github.com/mihaip/minivmac/commit/2bd517950679aaa5b4423b79deed3698208bf6d9">input</a>, <a href="https://github.com/mihaip/minivmac/commit/be99085a99a12116ea33b00bb8a2997393c902ae">disk image</a> <a href="https://github.com/mihaip/infinite-mac/commit/6cc34a97dc87a82ee2a0c39059f240530975f40c">mounting</a>, <a href="https://github.com/mihaip/minivmac/commit/8bcc54cbacad4cbebb603de260f7610bfbe34401">color</a> and <a href="https://github.com/mihaip/minivmac/commit/2fe49d588a24e635b680253f4c2144b4b6a7efcf">sound</a> was pretty straightforward.</p>

<p>Since the emulator allows the speed to be controlled, I <a href="https://github.com/mihaip/minivmac/commit/cde47f0034d04a21d5266c16223c84fc6a3fb911">exposed</a> <a href="https://github.com/mihaip/infinite-mac/commit/7476945e362710d7d84f2b96285ee84e653dced3">that</a> as well. I knew that modern machines emulate classic Mac OS significantly faster than 68K-era Macs ran it (even when targeting WebAssembly and not being able to use JIT), but it was made truly apparent when running in 1x speed mode. I was a lot more patient back in the 90s, back when you had to be <a href="http://web.archive.org/web/20040211083851/http://www.redshed.net/enbiggenEventQueue/index.html">aware of how big the event queue was</a> and make sure the computer could keep up.</p>

<p>The framebuffer updating in Mini vMac keeps track of <a href="https://wiki.c2.com/?DirtyRectangles">dirty rectangles</a> (another example of its focus on low-end host machines), and it was a nice bit of API “mechanical sympathy” to be able to <a href="https://github.com/mihaip/minivmac/commit/9742b0e19d6e9e5fe69b22f62b0009d17c3edbfe">hook that</a> <a href="https://github.com/mihaip/infinite-mac/commit/fcb93e00e9f4b41ec3c12c9950a15cdb56842fa1">up to</a> the dirty region option of <a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/putImageData">CanvasRenderingContext2D.putImageData()</a>. Though as it turns out that code path is perhaps not well-tested on some versions of Chrome — non-macOS users <a href="https://github.com/mihaip/infinite-mac/issues/95">reported glitches</a> and I had to add some <a href="https://github.com/mihaip/infinite-mac/commit/436eed6ba9efd412dbbba619c9ed8084097862b9">opt-outs</a>.</p>

<h3>System 6</h3>

<p>Once I had Mini vMac up and running in the browser, I booted a System 6.0.8 image. I only started using a Mac with System 7.1, so this was my first time spending any significant amount of time with this older version. I recall that System 7 had a reputation for being more RAM hungry and slower than its predecessor, but by modern standards they seem equally snappy and stingy with their memory use (with MultiFinder enabled System 6 uses the same amount of RAM as System 7).</p>

<p>What was more surprising was that things that I took from granted from System 7 (and assumed had been there for ages) were in fact recent additions. Two that I ran into very quickly were typing into Finder windows to select items with that prefix and being able to drag files onto application icons to open them. Around this same time <a href="https://toot.community/@justkwin/109851080677206288">Quinn had a thread</a> about how earlier versions of the Mac UI were not as refined as people remembered them, which was a nice confirmation of my experience.</p>

<p>One of the other surprises that I ran into was that the Infinite HD disk (with its 1GB of Mac software) was taking a very long time to mount. I eventually figured out that its desktop file was being rebuilt (having a visible progress bar for this is another System7 refinement). It turned out that the <a href="https://support.apple.com/kb/TA46427?locale=en_US">Desktop DB/Desktop DF files</a> that I was used to were another System 7 advance, while System 6 used a simpler (single) “Desktop” file, which causes <a href="https://68kmla.org/bb/index.php?threads/way-to-stop-6-0-8-7-1-desktop-rebuilding.40069/">problems when switching back and forth</a>. The <a href="https://github.com/mihaip/infinite-mac/commit/935ea5973a16f11dcc6f09c373368433302c7a1e">solution</a> for my situation turned out to rebuild the desktop files twice, first under System 6 and then under Mac OS 8, so that both sets would be included in the generated image.</p>

<p>Once I had it all working, it was a matter of registering <a href="https://system6.app/">system6.app</a> and configuring it.</p>

<figure>
  <img src="https://persistent.info/images/system6.png" width="680" height="510" alt="System 6 showing the “About the Finder…” window" loading="lazy"/>
  <figcaption>System 6.0.8 running on an emulated Mac Plus.</figcaption>
</figure>

<h3>RUN <u>ALL</u> THE VERSIONS!</h3>

<figure>
  <a href="https://persistent.info/images/infinite-mac-browser.png"><img src="https://persistent.info/images/infinite-mac-browser.png" width="297" height="1302" alt="System 6 showing the “About the Finder…” window" loading="lazy"/></a>
  <figcaption>The mid-90s were a tough time.</figcaption>
</figure>

<p>With Mini vMac running, running older OSes was mostly a matter of figuring out which <a href="https://www.gryphel.com/c/minivmac/options.html#option_m">machines</a> to build and tracking down install disks. <a href="https://www.marchintosh.com/">MARCHintosh</a> was coming up, and I figured it would be a worthwhile goal to get a gallery up and running in time for that.</p>

<p>But first, I needed a domain name. While <a href="https://system7.app/">system7.app</a>, <a href="https://macos8.app/">macos8.app</a>, etc. were all very catchy and memorable, <code>system2point1.app</code> was somehow less so (this was the first version to <a href="https://en.wikipedia.org/wiki/Hierarchical_File_System_(Apple)#History">add support for HFS</a>, and thus notable, even if it was a point release). I initially considered <code>system.software</code> (to further extend my use of more obscure TLDs), but it’s a premium domain name costing $2,700/year, and thus not really within my budget. <code>macos.museum</code> was a more affordable $84/year, but it was only one of the few <code>macos.&lt;TLD&gt;</code> domains that was unclaimed, leading me to conclude that Apple’s legal department may have an interest in it (“Mac OS” is also technically an anachronistic way to refer to pre-System 7.5.1 releases). In the end the “obvious” <a href="https://infinitemac.org/">infinitemac.org</a> won out, both for its affordability ($12/year) and because it matched the project name. The <code>.app</code> domains names will remain as shortcuts/redirects.</p>

<p>I used the word “gallery” above, and that was the experience I was going for. I wanted a curated experience, with pristine, period-accurate installations. I appreciate what the <a href="https://archive.org/details/softwarelibrary_mac">Internet Archive has done</a> (and will often use it as a source) but at some point the amount of choice (400+ bootable images) becomes overwhelming. I wanted to have a place where you can experience first-hand what someone means by <a href="https://arstechnica.com/gadgets/2010/09/macos-x-beta/14/#b6">“spatial Finder”</a>. Or if you <a href="https://gascoigne.social/@Charles/109684287235699788">come across some trivia</a> about option-double clicking only getting its modern behavior (close windows behind you) in System 6.0.4, you can <a href="https://infinitemac.org/1989/System%206.0.4">open it</a> and <a href="https://infinitemac.org/1989/System%206.0.3">its predecessor</a> side-by-side to see for yourself.</p>

<p>A reference point I had was Stephen Hackett’s <a href="https://512pixels.net/projects/aqua-screenshot-library/">macOS screenshot gallery</a> (or his more recent <a href="https://weblog.rogueamoeba.com/2023/03/03/come-visit-the-rogue-amoeba-historic-screenshot-archive/">Rogue Amoeba one</a>), or <a href="http://thewessens.net/collection/apple/systems/EarlyMacSystems.html">this one of early Mac systems</a>. While they were certainly curated, even a great set of screenshots can’t capture what it’s like to use one of these systems (e.g. the feeling of <a href="http://www.quinn.echidna.id.au/Quinn/WWW/HISubtleties/ZoomRects.html">zoom rects</a> going across the screen).</p>

<p>My other inspiration was <a href="https://mac.getutm.app/gallery/">UTM’s gallery</a> (which does provide one-click access, but requires native software and waiting for download and installation) and <a href="https://www.pcjs.org/">PCjs Machines</a> (which run in the browser, but being about PCs is inherently inferior in the eyes of this 90s Mac fanboy).</p>

<p>For getting pristine versions of each OS, I tried to use “primary” sources as much as possible, i.e. directly from Apple. In some cases Apple still hosts the downloads (unclear why <a href="https://support.apple.com/kb/DL1259?locale=en_US&amp;viewlocale=en_US">Mac OS 8.6</a> gets such treatment). In other cases, there were “archive” releases from the 90s that have multiple operating systems (e.g. the <a href="https://macintoshgarden.org/apps/apple-eto-essentials-tools-objects-1991">1991 E.T.O. Essentials CD</a> has System 7.0 and earlier, and the <a href="https://archive.org/details/AppleLegacyRecoveryOct1999">1999 Legacy Recovery CD</a> has some later releases).</p>

<p>The one release that was surprisingly hard to track down was <a href="https://en.wikipedia.org/wiki/System_1">System 0.97/1.0</a> that shipped with the original Macintosh 128K. I was <a href="https://www.betaarchive.com/forum/viewtopic.php?t=31561">not the first</a> to run into this, and it appears to boil down to it being a short-lived release (1.1 came out a few months later), relatively few 128K Macs being sold, and the system disk also being the primary data storage mechanism for users. <a href="https://github.com/mihaip/infinite-mac/issues/100#issuecomment-1445007822">I tracked down</a> all the disk images I could find, and put together a combined one that matched the original’s spirit.</p>

<p>The other thing that was surprisingly hard to find was a detailed changelog for each release. Perhaps there are <a href="https://groups.google.com/g/comp.sys.mac.system">comp.sys.mac.system</a> posts from the era or Apple press releases, but my archeology skills do not extend to Usenet or wire services. I mostly used <a href="http://www.toddp.com/classic/Software%20Install/Apple%20Support%20Documents/Macintosh%20Secrets/Mac%20Secrets%204th%20ed./ch06.pdf">Macworld’s Mac Secrets</a> (which being from 1996 is somewhat contemporary) and <a href="https://web.archive.org/web/20160810183725/http://www.mac512.com/macwebpages/system.htm">Mac 512’s System Showcase</a>.</p>

<p>As previously mentioned HFS was introduced with System 2.1, thus earlier versions (that only support <a href="https://en.wikipedia.org/wiki/Macintosh_File_System">MFS</a>) cannot mount the Infinite HD HFS image <a href="https://blog.persistent.info/2022/03/blog-post.html#infinite-hd">with the software library.</a> I briefly considered making an MFS generator too, but the only MFS libraries I could find were either <a href="https://github.com/zydeco/libmfs">read-only</a> or <a href="https://developer.apple.com/library/archive/samplecode/MFSLives/Introduction/Intro.html">embedded inside sample code</a> from 20 years ago, thus it seemed like a yak too far. I ended up <a href="https://github.com/mihaip/infinite-mac/commit/6ace3f333201d69d1fcf3fe56c3fcab8ddf89368">hand-creating</a> an image with some representative programs.</p>

<p><a href="https://infinitemac.org/">The final gallery</a> includes every notable system software release (I&#39;m sorry, fans of System 7.0.1). Perhaps over time I&#39;ll go back and backfill truly everything, but for now generating 36 bootable images was plenty. I tried to make the browsing experience as pleasant as possible — each release has a permalink, and you can command-click on the “Run” button to open things in new windows. Some releases only work with specific Macs, and some can run on multiple (I used the <a href="https://docs.google.com/spreadsheets/d/1wB2HnysPp63fezUzfgpk0JX_b7bXvmAg6-Dk7QDyKPY/edit#gid=840977089">Apple ROMs spreadsheet</a> and <a href="https://github.com/sentient06/MacROMan">Mac ROMan</a> to build up <a href="https://github.com/mihaip/infinite-mac/blob/930880fb8041df938caab2aae45fc6adc899a890/src/machines.ts">a library </a>of machines) — which machine is used can be chosen via the “Customize” button.</p>

<h3>Other Improvements</h3>

<p>The focus on gathering together all of the OS releases meant that I didn’t have as much time to work on the emulation aspects. The one thing I spent some time on was<a href="https://github.com/mihaip/infinite-mac/commit/5a682c7f1b18c186c018696345e61dfa918d2306"> improving the audio playback system</a>. Audio is one of the areas that I know less about, and I had kept most of the structure from <a href="https://github.com/jsdf/macemu">James Friend’s original Basilisk II port</a> in place. However, as I was bringing up the audio subsystem for Mini vMac I remembered that <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorklet">audio worklets</a> are now widely supported, and they also have an API “mechanical sympathy” with what the emulator expects. I’d also already set up a ring buffer system for the <a href="https://blog.persistent.info/2022/07/infinite-mac-networking.html">networking support</a>, and in fact the <a href="https://github.com/padenot/ringbuf.js#examples-and-use-cases">library mentioned emulation</a> as a use-case. The <a href="https://github.com/mihaip/infinite-mac/commit/5a682c7f1b18c186c018696345e61dfa918d2306">current implementation</a> is a system that is quite a bit simpler, has lower latency, and I understand better, though <a href="https://github.com/mihaip/infinite-mac/issues/123">there are still bugs</a>. Between <a href="https://github.com/mihaip/infinite-mac/blob/930880fb8041df938caab2aae45fc6adc899a890/src/emulator/emulator-audio-worklet.ts">the audio worklet</a>, <a href="https://github.com/mihaip/infinite-mac/blob/main/src/emulator/emulator-service-worker.ts">the service worker</a>, and <a href="https://github.com/mihaip/infinite-mac/blob/main/src/emulator/emulator-worker.ts">the dedicated worker</a>, I’ve managed to use most of the worker types — I now just need an excuse to use a <a href="https://developer.mozilla.org/en-US/docs/Web/API/PaintWorklet">paint worklet</a> to catch them all.</p>

<p>One small tweak that I made was related to scaling. Nearest-neighbor is nice for preserving a crisp look and feel, but it’s not appropriate when trying to fill the screen in <a href="https://github.com/mihaip/infinite-mac/commit/a417957d5734189110f3902938f720600f319000">full-screen mode</a> or when the host screen itself is <a href="https://github.com/mihaip/infinite-mac/commit/dc744f3f88557a7ba2e70f82a89ce20159b94ab5">doing non-integer scaling</a>. I can see why emulators end up with <a href="https://corteximplant.com/@scummvm/109935928397178919">configuration settings</a> to allow for more historical visual accuracy, but for now I’ve managed to stay away from too many fiddly settings.</p>

<p>I made a few improvements to the experience on mobile/touch devices — there’s now <a href="https://github.com/mihaip/infinite-mac/issues/7">a way to bring up the keyboard</a> and <a href="https://github.com/mihaip/infinite-mac/issues/79">import files</a> (without drag and drop) and <a href="https://github.com/mihaip/infinite-mac/commit/21ec859b475166d096dbb3afeed15494131a477e">controls are visible</a> even when the screen chrome is in its smallest mode. There are still fundamental limitations, these are all desktop UIs that were designed for very precise pointing devices, and they rely on actions like double-clicking that are <a href="https://github.com/mihaip/infinite-mac/issues/8">hard to do</a> precisely on mobile. PCjs appears to have <a href="https://www.pcjs.org/blog/2016/03/06/">taken a slightly different approach</a> that may be worth considering: touches appear to drive a virtual trackpad that moves the cursor and allows more complex operation (like drag-and-drop) to be accomplished.</p>

<p>I also ran into a few cases where the emulator would not load, especially in-app web views. Those turned out to be <a href="https://github.com/mihaip/infinite-mac/commit/773071876fda5a4101e2cd2a570a39b9dcec78c3">caused</a> by the service worker trying to do caching (but not being allowed to), but in general some <a href="https://github.com/mihaip/infinite-mac/commit/89cb33397881391d5ca0f31552cdd19ae97d24f8">basic error</a> <a href="https://github.com/mihaip/infinite-mac/commit/b39ff3cad6233891c035e196e8f97870282b831d">reporting</a> seemed appropriate. Perhaps setting up <a href="https://sentry.io/">Sentry</a> or the like would be appropriate, though I would like to minimize the number of other services I depend on.</p>

<p>I had <a href="https://blog.persistent.info/2023/01/infinite-mac-2022-in-review.html#donations">mentioned</a> wanting to have a way to cover the infrastructure costs of the project ($332.48 so far), and I got around to setting up <a href="https://github.com/sponsors/mihaip">GitHub Sponsors</a> and <a href="https://www.paypal.com/donate/?hosted_button_id=394METCPT6PYN">PayPal</a> donation accounts. A few people have already donated, for which I am very grateful. I will try not to blow it all on domain names.</p>

<h3>What’s Next</h3>

<p>First, a break. I’ve been working <a href="https://github.com/mihaip/infinite-mac/commits?author=mihaip&amp;since=2023-01-01&amp;until=2023-03-31">almost every day</a> on the project to hit my (self-imposed) MARCHintosh deadline of having all OS releases, and it’s gotten to be a bit of a grind. </p>

<p>Beyond that, there are <a href="https://github.com/mihaip/infinite-mac/issues?q=is%3Aissue+label%3ALibrary">a bunch of software requests</a> that I could incorporate into the Infinite HD image. Though making it even easier to load software (even if I don’t include it directly) would be even better — I recently came across <a href="http://discmaster.textfiles.com/">Discmaster</a> and something that lets you load anything from the Internet Archive with one click would be great.</p>

<p>Improving the persistence support is another area I’d like to explore — the “Saved” folder in “The Outside World” is a bit too obscure, and because it uses the <a href="https://macintoshgarden.org/apps/file-system-manager-12">File System Manager</a> some programs don’t work well with it. Ideally there should be a whole HFS volume that can be persisted. That would also integrate nicel with the browser’s <a href="https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API">file system APIs</a>.</p>

<p>Finally, though I said I would take a break from adding additional operating system images, there are <a href="https://bitbang.social/@SinclairSpeccy/109980552130864852">pre-release and obscure ones</a> that might be fun to get running. Or perhaps even <a href="https://github.com/mihaip/infinite-mac/issues/121">parallel universe alternatives</a>.</p>
</article></div>
  </body>
</html>
