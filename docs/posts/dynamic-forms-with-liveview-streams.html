<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://fly.io/phoenix-files/dynamic-forms-with-streams/">Original</a>
    <h1>Dynamic Forms with LiveView Streams</h1>
    
    <div id="readability-page-1" class="page"><article> <dl> <dt>Author</dt> <dd> <img src="https://fly.io/static/images/berenice.webp" alt="Berenice Medel" srcset=""/> <dl> <dt>Name</dt> <dd> Berenice Medel </dd> <dt>Social Media</dt> <dd> <a href="https://twitter.com/bemesa21" target="_blank" rel="noopener noreferrer"> <span aria-hidden="true">@bemesa21</span> <span>View Twitter Profile</span> </a> </dd> </dl> </dd> </dl> <section> <figure> <img src="https://fly.io/phoenix-files/2023-05-29/drag_and_drop_cover.webp" alt=""/> <figcaption> <span>Image by</span> <svg role="img" style="pointer-events: none; width: 17px; height: 17px;" viewBox="0 0 20 20" fill="currentColor" fill-rule="evenodd"> <g buffered-rendering="static"> <path fill-rule="evenodd" d="M1 8a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 018.07 3h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0016.07 6H17a2 2 0 012 2v7a2 2 0 01-2 2H3a2 2 0 01-2-2V8zm13.5 3a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM10 14a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd"></path> </g> </svg> <a href="https://annieruygtillustration.com" target="_blank"> Annie Ruygt </a> </figcaption> </figure> <p> In this post, we&#39;ll develop a dynamic list component using the new LiveView Streams and the enhanced form features introduced in LiveView 0.18/0.19. Get ready to discover how to create a responsive list component with interactive capabilities like adding, editing, and deleting items. Fly.io is a great place to run your Phoenix LiveView applications! Check out how to <a href="https:///docs/elixir/">get started</a>!</p><p>You developed a component that lets you add and remove items in a &#34;has_many&#34; relationship. Take, for example, a shopping list where it can <em>have many</em> items. You&#39;ve got a cool form that lets you send data for new items, and it works really well:</p>  <p>However, you&#39;re still not entirely happy with the result. When you make a mistake while adding an item to the list, there&#39;s no way to edit it. How can you make the list items editable right in the list component, without the need for a modal?</p> <p>Well, what if we use individual forms for each list item instead of a single form to add and associate them with the list? That&#39;s a simple task, we can render as many forms as we want. We&#39;re going to use the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#to_form/2">to_form/2</a> function to create form structs from changesets, and then we&#39;re going to use those structs to render our form components.</p> <p>And another thing: once we&#39;ve fixed up our form component, we&#39;re going to see how to use <a href="https://fly.io/phoenix-files/phoenix-dev-blog-streams/">LiveView Streams</a> to manage and manipulate our list items without the need to store them all in memory. Adding, editing, deleting, and resetting items in a collection has never been easier!</p> <h2 id="defining-our-component-s-markup"><a href="#defining-our-component-s-markup" aria-label="Anchor"></a>Defining Our Component&#39;s Markup</h2><p>Let&#39;s begin by <em>refactoring</em> <a href="https://fly.io/phoenix-files/liveview-drag-and-drop/">our component</a> and keeping only the header:</p> <div><pre><code><span>defmodule</span> <span>ComponentsExamplesWeb</span><span>.</span><span>ListComponent</span> <span>do</span>
  <span>use</span> <span>ComponentsExamplesWeb</span><span>,</span> <span>:live_component</span>

  <span>def</span> <span>render</span><span>(</span><span>assigns</span><span>)</span> <span>do</span>
    <span>~H&#34;&#34;</span><span>&#34;
    &lt;div class=&#34;</span><span>bg</span><span>-</span><span>gray</span><span>-</span><span>100</span> <span>py</span><span>-</span><span>4</span> <span>rounded</span><span>-</span><span>lg</span><span>&#34;&gt;
      &lt;div class=&#34;</span><span>space</span><span>-</span><span>y</span><span>-</span><span>5</span> <span>mx</span><span>-</span><span>auto</span> <span>max</span><span>-</span><span>w</span><span>-</span><span>7</span><span>xl</span> <span>px</span><span>-</span><span>4</span> <span>space</span><span>-</span><span>y</span><span>-</span><span>4</span><span>&#34;&gt;
        &lt;.header&gt;
          &lt;%= @list_name %&gt;
        &lt;/.header&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &#34;&#34;&#34;</span>
  <span>end</span>

  <span>def</span> <span>update</span><span>(%{</span><span>list:</span> <span>list</span><span>}</span> <span>=</span> <span>assigns</span><span>,</span> <span>socket</span><span>)</span> <span>do</span>
    <span>socket</span> <span>=</span>
      <span>socket</span>
      <span>|&gt;</span> <span>assign</span><span>(</span>
        <span>list_id:</span> <span>list</span><span>.</span><span>id</span><span>,</span>
        <span>list_name:</span> <span>list</span><span>.</span><span>title</span>
      <span>)</span>
    <span>{</span><span>:ok</span><span>,</span> <span>socket</span><span>}</span>
  <span>end</span>
<span>end</span>  
</code></pre></div><p>In the assigns, we&#39;re passing a struct <code>list</code>. It contains an id, a title, and a list of items, each of which has multiple attributes.</p> <p>To generate these structs, their corresponding changesets, and the context functions that we&#39;ll be using later, you can use the <a href="https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Context.html">phx.gen.context</a> generator:</p> <div><pre><code>mix phx.gen.context SortableList List lists title:string
mix phx.gen.context SortableList Item items name:string position:integer list_id:integer
</code></pre></div><p>Here&#39;s an example list, containing a single item:</p> <div><pre><code><span>%</span><span>ComponentsExamples</span><span>.</span><span>SortableList</span><span>.</span><span>List</span><span>{</span>
  <span>__meta__:</span> <span>#Ecto.Schema.Metadata&lt;:loaded, &#34;lists&#34;&gt;,</span>
  <span>id:</span> <span>1</span><span>,</span>
  <span>title:</span> <span>&#34;Shopping list 1&#34;</span><span>,</span>
  <span>items:</span> <span>[</span>
    <span>%</span><span>ComponentsExamples</span><span>.</span><span>SortableList</span><span>.</span><span>Item</span><span>{</span>
      <span>__meta__:</span> <span>#Ecto.Schema.Metadata&lt;:loaded, &#34;items&#34;&gt;,</span>
      <span>id:</span> <span>161</span><span>,</span>
      <span>name:</span> <span>&#34;chocolate&#34;</span><span>,</span>
      <span>position:</span> <span>0</span><span>,</span>
      <span>status:</span> <span>:started</span><span>,</span>
      <span>list_id:</span> <span>1</span><span>,</span>
      <span>list:</span> <span>#Ecto.Association.NotLoaded&lt;association :list is not loaded&gt;,</span>
      <span>inserted_at:</span> <span>~N[2023-05-16 20:29:12]</span><span>,</span>
      <span>updated_at:</span> <span>~N[2023-05-16 20:29:12]</span>
    <span>}</span>
  <span>],</span>
  <span>inserted_at:</span> <span>~N[2023-04-25 19:35:09]</span><span>,</span>
  <span>updated_at:</span> <span>~N[2023-04-25 19:35:09]</span>
<span>}</span>
</code></pre></div><p>Now, we need to iterate over the items of the list and render the forms. But before we dive into that, let&#39;s update our assigns to include a form per item:</p> <div><pre><code><span>def update(%{list: list} = assigns, socket) do
</span><span>+ item_forms = Enum.map(list.items, &amp;build_item_form(&amp;1, %{list_id: list.id}))
</span><span>
</span>  socket =
    socket
    |&gt; assign(
      list_id: list.id,
      list_name: list.title,
<span>+     items: item_forms
</span>    )
  {:ok, socket}
<span>end
</span></code></pre></div><p>Let&#39;s see the content of the <code>build_item_form/1</code> function:</p> <div><pre><code><span>defp</span> <span>build_item_form</span><span>(</span><span>item_or_changeset</span><span>,</span> <span>params</span><span>)</span> <span>do</span>
  <span>changeset</span> <span>=</span>
    <span>item_or_changeset</span>
    <span>|&gt;</span> <span>SortableList</span><span>.</span><span>change_item</span><span>(</span><span>params</span><span>)</span>

  <span>to_form</span><span>(</span><span>changeset</span><span>,</span> <span>id:</span> <span>&#34;form-</span><span>#{</span><span>changeset</span><span>.</span><span>data</span><span>.</span><span>list_id</span><span>}</span><span>-</span><span>#{</span><span>changeset</span><span>.</span><span>data</span><span>.</span><span>id</span><span>}</span><span>&#34;</span><span>)</span>
<span>end</span>
</code></pre></div><p>We receive an <code>%Item{}</code> and create a changeset from it. Then, we use the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#to_form/2">Phoenix.Component.html.to_form/2</a> function. This handy function converts a data structure into a <a href="https://hexdocs.pm/phoenix_html/3.3.0/Phoenix.HTML.Form.html">Phoenix.HTML.Form</a>, which we can use to render our <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.Component.html#form/1">form/1</a> components. Note that the <code>id</code> of the form has the <code>list_id</code> and the <code>id</code> of the item interpolated.</p> <p>As a result, we have an assign called <code>:items</code> that holds the <code>Phoenix.HTML.Form</code> structs containing our element data. We iterate through each item in our assign and render a <code>simple_form/1</code> for each of them:</p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div class=&#34;bg-gray-100 py-4 rounded-lg&#34;&gt;
    &lt;div class=&#34;space-y-5 mx-auto max-w-7xl px-4 space-y-4&#34;&gt;
      &lt;.header&gt;
        &lt;%= @list_name %&gt;
      &lt;/.header&gt;
<span>+     &lt;div id={&#34;#{@list_id}-items&#34;} class=&#34;grid grid-cols-1 gap-2&#34;&gt;
+      &lt;div :for={form &lt;- @items} id={&#34;list#{@list_id}-item#{item.id}&#34;}&gt;
+       &lt;.simple_form
+           for={form}
+           phx-change=&#34;validate&#34;
+           phx-submit=&#34;save&#34;
+           phx-target={@myself}
+           class=&#34;min-w-0 flex-1 drag-ghost:opacity-0&#34;
+           phx-value-id={form.data.id}
+         &gt;
+          &lt;div class=&#34;flex&#34;&gt;
+          &lt;/div&gt;
+         &lt;/.simple_form&gt;
</span>        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span></code></pre></div><p>We define the events triggered on change or data submission, and we pass the item ID to these events using the <code>phx-value-*</code> bindings.</p> <p>Now, let&#39;s add elements to the body of our item form. We start by adding a button to change the status of our element:</p> <p><img src="https://fly.io/phoenix-files/2023-05-29/form_1.png?card?1/3?center" alt="This is a screenshot of the shopping list component. In the screenshot, there is a button highlighted by a red square. This button can be used to toggle the status of an item in the list."/></p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div class=&#34;bg-gray-100 py-4 rounded-lg&#34;&gt;
    &lt;div class=&#34;space-y-5 mx-auto max-w-7xl px-4 space-y-4&#34;&gt;
      &lt;.header&gt;...&lt;/.header&gt;
      &lt;div id={&#34;#{@list_id}-items&#34;} class=&#34;grid grid-cols-1 gap-2&#34;&gt;
        &lt;div :for={form &lt;- @items} id={&#34;list#{@list_id}-item#{item.id}&#34;}&gt;
          &lt;.simple_form ...&gt;
            &lt;div class=&#34;flex&#34;&gt;
<span>+.            &lt;button
+               :if={form.data.id}
+               type=&#34;button&#34;
+               class=&#34;w-10&#34;
+.              phx-click={JS.push(&#34;toggle_complete&#34;, target: @myself, value: %{id: form.data.id})}
+             &gt;
+               &lt;.icon
+                 name=&#34;hero-check-circle&#34;
+                 class={[
+                   &#34;w-7 h-7&#34;,
+.                  if(form[:status].value == :completed, 
+                     do: &#34;bg-green-600&#34;, 
+                     else: &#34;bg-gray-300&#34;)
+                 ]}
+               /&gt;
+.            &lt;/button&gt;
</span>            &lt;/div&gt;
          &lt;/.simple_form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span></code></pre></div><p>This button is displayed conditionally when the list element has an <code>id</code>, indicating that it already exists in the database and its status can be edited. Additionally, we apply conditional classes to the <code>&lt;.icon&gt;</code> based on the item&#39;s status, to change its color.</p> <p>Now, let&#39;s add the most important part, the text input to to edit each list item:</p> <p><img src="https://fly.io/phoenix-files/2023-05-29/form_2.png?card?1/3?center" alt="This is a screenshot of the shopping list component. In the screenshot, there is a text input field highlighted. This text input field is used to create new items or update existing ones in the shopping list."/></p> <p>We add two text inputs to send the parameters of our item: the <code>:name</code> and the <code>:list_id</code> to which it belongs:</p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div class=&#34;bg-gray-100 py-4 rounded-lg&#34;&gt;
    &lt;div class=&#34;space-y-5 mx-auto max-w-7xl px-4 space-y-4&#34;&gt;
      &lt;.header&gt;...&lt;/.header&gt;
      &lt;div id={&#34;#{@list_id}-items&#34;} class=&#34;grid grid-cols-1 gap-2&#34;&gt;
        &lt;div :for={form &lt;- @items} id={&#34;list#{@list_id}-item#{item.id}&#34;}&gt;
          &lt;.simple_form ...&gt;
            &lt;div class=&#34;flex&#34;&gt;
              ...
<span>+             &lt;div class=&#34;flex-auto block text-sm leading-6 text-zinc-900&#34;&gt;
+               &lt;input type=&#34;hidden&#34; name={form[:list_id].name} value={form[:list_id].value} /&gt;
+               &lt;.input
+                 field={form[:name]}
+                 type=&#34;text&#34;
+                 phx-target={@myself}
+                 phx-key=&#34;escape&#34;
+                 phx-keydown={
+                   !form.data.id &amp;&amp;
+                     JS.push(&#34;discard&#34;, target: @myself, value: %{list_id: @list_id})
+                 }
+                 phx-blur={form.data.id &amp;&amp; JS.dispatch(&#34;submit&#34;, to: &#34;##{form.id}&#34;)}
+               /&gt;
+             &lt;/div&gt;
</span>            &lt;/div&gt;
          &lt;/.simple_form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span></code></pre></div><p>Let&#39;s take a closer look at the elements we added. First, we include a hidden input field to store the id of the list to which the element belongs. This allows us to send it as part of the parameters for the <code>validate</code> and <code>save</code> events by setting the <code>value={form[:list_id].value}</code> attribute.</p> <p>Next, we introduce a slightly more complex <code>&lt;.input&gt;</code> component with event options. By using the <code>phx-key</code> and <code>phx-keydown</code> attributes, we specify that pressing the escape key triggers the <code>discard</code> event sent to the server.</p> <p>We have two ways to save changes: pressing Enter to trigger the <code>submit</code> event or allowing changes to be automatically saved when the input loses focus.</p> <p>For elements that already exist in the database and are modified, the <code>phx-blur</code> binding comes into play. It automatically submits the form when the input loses focus, ensuring that changes are saved seamlessly.</p> <p>Lastly, we add a button with an icon to delete existing elements from the database:</p> <p><img src="https://fly.io/phoenix-files/2023-05-29/form_3.png?card?1/3?center" alt="This is a screenshot of the shopping list component. In the screenshot, there is a button highlighted in a red square. This button is used to delete the corresponding item from the shopping list."/></p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div class=&#34;bg-gray-100 py-4 rounded-lg&#34;&gt;
    &lt;div class=&#34;space-y-5 mx-auto max-w-7xl px-4 space-y-4&#34;&gt;
      &lt;.header&gt;...&lt;/.header&gt;
      &lt;div id={&#34;#{@list_id}-items&#34;} class=&#34;grid grid-cols-1 gap-2&#34;&gt;
        &lt;div :for={form &lt;- @items} id={&#34;list#{@list_id}-item#{item.id}&#34;}&gt;
          &lt;.simple_form ...&gt;
            &lt;div class=&#34;flex&#34;&gt;
              ...
<span>+             &lt;button
+               :if={form.data.id}
+               type=&#34;button&#34;
+               class=&#34;w-10 -mt-1 flex-none&#34;
+               phx-click={
+                 JS.push(&#34;delete&#34;, target: @myself, value: %{id: form.data.id})
+                 |&gt; hide(&#34;#list#{@list_id}-item#{form.data.id}&#34;)
+               }
+             &gt;
+               &lt;.icon name=&#34;hero-x-mark&#34; /&gt;
+             &lt;/button&gt;
</span>            &lt;/div&gt;
          &lt;/.simple_form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span></code></pre></div><p>We trigger the <code>delete</code> event while simultaneously hiding the form of the item we wish to remove.</p> <p>We now add the final section to our component. We include two buttons: one to add a new item to the list, and another to delete all items from the list.</p> <p><img src="https://fly.io/phoenix-files/2023-05-29/form_4.png?card?1/3?center" alt="This is a screenshot of the shopping list component. Below the list items, there is a highlighted section containing two buttons. The first button is used to add a new item form to the list, while the second button is used to reset the list items."/></p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div class=&#34;bg-gray-100 py-4 rounded-lg&#34;&gt;
    &lt;div class=&#34;space-y-5 mx-auto max-w-7xl px-4 space-y-4&#34;&gt;
      &lt;.header&gt;...&lt;/.header&gt;
      &lt;div id={&#34;#{@list_id}-items&#34;} class=&#34;grid grid-cols-1 gap-2&#34;&gt;
        &lt;div :for={form &lt;- @items} id={&#34;list#{@list_id}-item#{item.id}&#34;}&gt;
          ...
        &lt;/div&gt;
      &lt;/div&gt;
<span>+     &lt;.button phx-click={JS.push(&#34;new&#34;, target: @myself, value: %{list_id: @list_id})} class=&#34;mt-4&#34;&gt;
+       Add item
+     &lt;/.button&gt;
+     &lt;.button
+       phx-click={JS.push(&#34;reset&#34;, target: @myself, value: %{list_id: @list_id})}
+       class=&#34;mt-4&#34;
+     &gt;
+       Reset
+     &lt;/.button&gt;
</span>    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span></code></pre></div><p>We sent events to the server using <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.JS.html#push/1">JS.push</a>. Both the <code>reset</code> and <code>new</code> events receive the <code>list_id</code> as a parameter.</p> <p>Awesome! We&#39;ve finished the markup for our component!</p> <p>We can easily render it by passing a list struct like the one we saw above:</p> <div><pre><code><span>def</span> <span>render</span><span>(</span><span>assigns</span><span>)</span> <span>do</span>
  <span>~H&#34;&#34;</span><span>&#34;
  &lt;div id=&#34;</span><span>lists</span><span>&#34; class=&#34;</span><span>grid</span> <span>sm:</span><span>grid</span><span>-</span><span>cols</span><span>-</span><span>1</span> <span>md:</span><span>grid</span><span>-</span><span>cols</span><span>-</span><span>3</span> <span>gap</span><span>-</span><span>2</span><span>&#34;&gt;
    &lt;.live_component
      :for={list &lt;- @lists}
      module={ComponentsExamplesWeb.ListComponent}
      id={list.id}
      list={list}
    /&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;</span>
<span>end</span>
</code></pre></div><p>But before we tackle handling all the events we defined, how about we optimize memory usage by using <code>Streams</code>? With just a few tweaks, we can implement this feature and ensure we&#39;re not storing all the list elements in memory.</p> <h2 id="converting-to-streams"><a href="#converting-to-streams" aria-label="Anchor"></a>Converting to Streams</h2><p>To optimize memory usage, let&#39;s start by making a small change to our assigns. We assign the stream items using the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream/4">stream/4</a> function:</p> <div><pre><code><span>def update(%{list: list} = assigns, socket) do
</span>  item_forms = Enum.map(list.items, &amp;build_item_form(&amp;1, %{list_id: assigns.id}))
<span>
</span>  socket =
    socket
    |&gt; assign(
      list_id: list.id,
      list_name: list.title,
<span>-     items: item_forms
</span>    )
<span>+   |&gt; stream(:items, item_forms)
</span><span>
</span>  {:ok, socket}
<span>end
</span></code></pre></div><p>Next, we define the required <code>phx-update</code> DOM attribute on the parent container where the item collection is rendered. The items are now accessed via the new assign <code>@streams</code>, and we consume the stream using a comprehension:</p> <div><pre><code><span>def render(assigns) do
</span>  ~H&#34;&#34;&#34;
  &lt;div class=&#34;bg-gray-100 py-4 rounded-lg&#34;&gt;
    &lt;div class=&#34;space-y-5 mx-auto max-w-7xl px-4 space-y-4&#34;&gt;
      ...
<span>-      &lt;div id={&#34;#{@list_id}-items&#34;} class=&#34;grid grid-cols-1 gap-2&#34;&gt;
</span><span>+      &lt;div
+        id={&#34;#{@list_id}-items&#34;}
+        class=&#34;grid grid-cols-1 gap-2&#34;
+        phx-update=&#34;stream&#34;
+      &gt;
</span><span>-        &lt;div :for={form &lt;- @items} id={&#34;list#{@list_id}-item#{item.id}&#34;}&gt;
</span><span>+        &lt;div :for={{id, form} &lt;- @streams.items} id={id}&gt;         
</span>        ...
        &lt;/div&gt;
      &lt;/div&gt;
      ...
    &lt;/div&gt;
  &lt;/div&gt;
  &#34;&#34;&#34;
<span>end
</span></code></pre></div><p>Now we&#39;re all set to handle the events we defined earlier!</p> <figure> <figcaption> <p> Fly.io is a great way to run your Phoenix LiveView app close to your users. It&#39;s really easy to get started. You can be running in minutes.</p><p><a href="https://fly.io/docs/elixir/"> Deploy a Phoenix app today!  <span>→</span> </a></p> </figcaption><p><img src="https://fly.io/static/images/cta-dog.webp" srcset="/static/images/cta-dog@2x.webp 2x" alt=""/></p></figure><h2 id="add-delete-update-reset-streams"><a href="#add-delete-update-reset-streams" aria-label="Anchor"></a>Add, Delete, Update, Reset Streams</h2><p>We&#39;ll be defining five events (<a href="#new">new</a>, <a href="#validate">validate</a>, <a href="#save">save</a>, <a href="#delete">delete</a>, <a href="#reset">reset</a>). Our main focus is explain how we can use streams to reflect changes in our list. We won&#39;t be diving into functions that interact with the database.</p> <p>To get started, it will be helpful to define a helper function that creates forms already associated with the <code>list_id</code>:</p> <div><pre><code><span>defp</span> <span>build_empty_form</span><span>(</span><span>list_id</span><span>)</span> <span>do</span>
  <span>build_item_form</span><span>(%</span><span>Item</span><span>{</span><span>list_id:</span> <span>list_id</span><span>},</span> <span>%{})</span>
<span>end</span>
</code></pre></div><p>Keep in mind this function, as well as the one we defined earlier. We&#39;ll be using them in our upcoming steps!</p> <h3 id="new"><a href="#new" aria-label="Anchor"></a>New</h3> <p>To add a new element to the list, we can use the function we just defined to create an empty form. Then, we can insert this form into the stream using the <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream_insert/4">stream_insert/4</a> function:</p> <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;new&#34;</span><span>,</span> <span>%{</span><span>&#34;list_id&#34;</span> <span>=&gt;</span> <span>list_id</span><span>},</span> <span>socket</span><span>)</span> <span>do</span>
  <span>{</span><span>:noreply</span><span>,</span> <span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>build_empty_form</span><span>(</span><span>list_id</span><span>),</span> <span>at:</span> <span>-</span><span>1</span><span>)}</span>
<span>end</span>
</code></pre></div><p>To insert the new form at the end of the list, we use the <code>:at</code> option provided by the <code>stream_insert/4</code> function.</p> <h3 id="validate"><a href="#validate" aria-label="Anchor"></a>Validate</h3> <p>To display the errors of our item, we need to modify the already rendered form in the client and insert a new form that includes the errors from the changeset.</p> <p>One important detail to note is that in order for our component to recognize that it should display the changeset errors, we need to add an <code>:action</code> to it. To achieve this, we make a slight modification to the <code>build_item_form/4</code> function that we defined earlier:</p> <div><pre><code><span>-defp build_item_form(item_or_changeset, params) do
</span><span>+defp build_item_form(item_or_changeset, params, action \\ nil) do
</span>  changeset =
    item_or_changeset
    |&gt; SortableList.change_item(params)
<span>+   |&gt; Map.put(:action, action)
</span><span>
</span>  to_form(changeset, id: &#34;form-#{changeset.data.list_id}-#{changeset.data.id}&#34;)
<span>end
</span></code></pre></div><p>The action can be any random atom, but hey, let&#39;s keep things clear and name them sensibly.</p> <p>Now let&#39;s see how to handle the event and use this new <code>:action</code> parameter:</p> <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;validate&#34;</span><span>,</span> <span>%{</span><span>&#34;item&#34;</span> <span>=&gt;</span> <span>item_params</span><span>}</span> <span>=</span> <span>params</span><span>,</span> <span>socket</span><span>)</span> <span>do</span>
  <span>item</span> <span>=</span> <span>%</span><span>Item</span><span>{</span><span>id:</span> <span>params</span><span>[</span><span>&#34;id&#34;</span><span>]</span> <span>||</span> <span>nil</span><span>,</span> <span>list_id:</span> <span>item_params</span><span>[</span><span>&#34;list_id&#34;</span><span>]}</span>
  <span>item_form</span> <span>=</span> <span>build_item_form</span><span>(</span><span>item</span><span>,</span> <span>item_params</span><span>,</span> <span>:validate</span><span>))</span>
  <span>{</span><span>:noreply</span><span>,</span> <span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>item_form</span><span>}</span>
<span>end</span> 
</code></pre></div><p>First, we generate a new <code>%Item{}</code> that includes the item <code>id</code> sent from the text input and the <code>list_id</code> sent using the <code>phx-value-id={form.data.id}</code> parameter. Next, we call our <code>build_item_form/4</code> function with the <code>:validate</code> action and insert the item into the stream using <code>stream_insert/4</code>.</p> <p>Like magic, we didn&#39;t have to specify that this is an update of a form that already exists! This is because <code>to_form</code> created a DOM ID that allows to identify the elements of the stream that already exists in the client.</p> <h3 id="save"><a href="#save" aria-label="Anchor"></a>Save</h3> <p>When attempting to save a new item, we may receive one of two possible responses. First, when an item is successfully inserted, we clear the new item form and replace it with a fresh empty form. We also insert a new form containing the persisted data. Second, if an error occurs, we display the relevant errors to the user.</p> <p>Let&#39;s now delve into the implementation details of these actions.</p> <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;save&#34;</span><span>,</span> <span>%{</span><span>&#34;item&#34;</span> <span>=&gt;</span> <span>item_params</span><span>},</span> <span>socket</span><span>)</span> <span>do</span>
  <span>case</span> <span>SortableList</span><span>.</span><span>create_item</span><span>(</span><span>item_params</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>new_item</span><span>}</span> <span>-&gt;</span>
      <span>empty_form</span> <span>=</span> <span>build_empty_form</span><span>(</span><span>item_params</span><span>[</span><span>&#34;list_id&#34;</span><span>])</span>


      <span>{</span><span>:noreply</span><span>,</span>
       <span>socket</span>
       <span>|&gt;</span> <span>stream_insert</span><span>(</span><span>:items</span><span>,</span> <span>build_item_form</span><span>(</span><span>new_item</span><span>,</span> <span>%{}))</span>
       <span>|&gt;</span> <span>stream_delete</span><span>(</span><span>:items</span><span>,</span> <span>empty_form</span><span>)</span>
       <span>|&gt;</span> <span>stream_insert</span><span>(</span><span>:items</span><span>,</span> <span>empty_form</span><span>)}</span>

    <span>{</span><span>:error</span><span>,</span> <span>changeset</span><span>}</span> <span>-&gt;</span>
      <span>{</span><span>:noreply</span><span>,</span> <span>assign</span><span>(</span><span>socket</span><span>,</span> <span>:form</span><span>,</span> <span>build_item_form</span><span>(</span><span>changeset</span><span>,</span> <span>%{},</span> <span>:insert</span><span>)))}</span>
  <span>end</span>
<span>end</span>
</code></pre></div><p>Great! We can chain together the different functions of the stream using the pipeline operator.</p>  <p>On the other hand, the <code>save</code> event may be triggered by one of the forms that have already been saved in the database, indicating an update of the item. We can identify this by pattern matching, receiving a non-null <code>item_id</code>:</p> <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;save&#34;</span><span>,</span> <span>%{</span><span>&#34;id&#34;</span> <span>=&gt;</span> <span>item_id</span><span>,</span> <span>&#34;item&#34;</span> <span>=&gt;</span> <span>params</span><span>},</span> <span>socket</span><span>)</span> <span>do</span>
  <span>todo</span> <span>=</span> <span>SortableList</span><span>.</span><span>get_item!</span><span>(</span><span>item_id</span><span>)</span>

  <span>case</span> <span>SortableList</span><span>.</span><span>update_item</span><span>(</span><span>todo</span><span>,</span> <span>params</span><span>)</span> <span>do</span>
    <span>{</span><span>:ok</span><span>,</span> <span>updated_item</span><span>}</span> <span>-&gt;</span>
      <span>{</span><span>:noreply</span><span>,</span> <span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>build_item_form</span><span>(</span><span>updated_item</span><span>,</span> <span>%{}))}</span>

    <span>{</span><span>:error</span><span>,</span> <span>changeset</span><span>}</span> <span>-&gt;</span>
      <span>{</span><span>:noreply</span><span>,</span> <span>stream_insert</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>build_item_form</span><span>(</span><span>changeset</span><span>,</span> <span>%{},</span> <span>:update</span><span>))}</span>
  <span>end</span>
<span>end</span>
</code></pre></div><p>It&#39;s almost like magic, isn&#39;t it? We just need to use <code>stream_insert</code>, and the stream takes care of updating itself. And if we want to display the errors from the changeset, we simply add an <code>:action</code> to it.</p> <h3 id="delete"><a href="#delete" aria-label="Anchor"></a>Delete</h3><p>Deleting items from a stream is easy too!</p>  <p>For this we have <a href="https://hexdocs.pm/phoenix_live_view/Phoenix.LiveView.html#stream_delete/3">stream_delete/3</a> which also receives changesets as a parameter:</p> <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;delete&#34;</span><span>,</span> <span>%{</span><span>&#34;id&#34;</span> <span>=&gt;</span> <span>item_id</span><span>},</span> <span>socket</span><span>)</span> <span>do</span>
  <span>item</span> <span>=</span> <span>SortableList</span><span>.</span><span>get_item!</span><span>(</span><span>item_id</span><span>)</span>
  <span>{</span><span>:ok</span><span>,</span> <span>_</span><span>}</span> <span>=</span> <span>SortableList</span><span>.</span><span>delete_item</span><span>(</span><span>item</span><span>)</span>
  <span>{</span><span>:noreply</span><span>,</span> <span>stream_delete</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>build_item_form</span><span>(</span><span>item</span><span>,</span> <span>%{}))}</span>
<span>end</span>
</code></pre></div><p>You can also use the <code>stream_delete/3</code> function to <code>discard</code> the form of the new element when needed:</p> <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;discard&#34;</span><span>,</span> <span>params</span><span>,</span> <span>socket</span><span>)</span> <span>do</span>
  <span>{</span><span>:noreply</span><span>,</span> <span>stream_delete</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>build_empty_form</span><span>(</span><span>params</span><span>[</span><span>&#34;list_id&#34;</span><span>]))}</span>
<span>end</span>
</code></pre></div><h3 id="reset"><a href="#reset" aria-label="Anchor"></a>Reset</h3><p>We have the option to remove all items from a stream, which is perfect for our reset button:</p>  <div><pre><code><span>def</span> <span>handle_event</span><span>(</span><span>&#34;reset&#34;</span><span>,</span> <span>params</span><span>,</span> <span>socket</span><span>)</span> <span>do</span>
  <span>empty_form</span> <span>=</span> <span>build_empty_form</span><span>(</span><span>params</span><span>[</span><span>&#34;list_id&#34;</span><span>])</span>
  <span>{</span><span>:noreply</span><span>,</span> <span>stream</span><span>(</span><span>socket</span><span>,</span> <span>:items</span><span>,</span> <span>[</span><span>empty_form</span><span>],</span> <span>reset:</span> <span>true</span><span>)}</span>
<span>end</span>
</code></pre></div><p>We simply need to reconfigure our stream by passing the option <code>reset: true</code>. Additionally, we can include a list of new elements to be inserted, which in this case would be at least one empty form.</p> <p>Hooray! We&#39;ve done it! Our component is now complete and ready to shine!</p> <h2 id="closing"><a href="#closing" aria-label="Anchor"></a>Closing</h2><p>The features we explored today unlock a world of exciting new possibilities for apps development with LiveView. <code>LiveView Streams</code> revolutionize collection handling and memory optimization, simplifying tasks such as adding, editing, and deleting items. Furthermore, the optimizations brought by <code>to_form/1</code> enable efficient manipulation of individual inputs without the need for full form re-rendering. This simple yet immensely powerful function opens up new avenues for form usage, expanding the potential of your applications.</p> <p>Check out <a href="https://github.com/bemesa21/components_examples">this repo</a> to see these game-changing features in action. We used <a href="https://fly.io/phoenix-files/liveview-drag-and-drop/">our previous learnings</a> to create an even more impressive component!</p> <h2 id="credits"><a href="#credits" aria-label="Anchor"></a>Credits</h2><p>A big shoutout to Chris McCord for sharing <a href="https://github.com/chrismccord/todo_trek">the incredible example</a> that inspired these posts and for patiently answering any questions about the exciting new concepts in Phoenix and LiveView.</p>  </section> <dl> <dt> Previous post  ↓ </dt> <dd> <a href="https://fly.io/phoenix-files/taking-control-of-map-sort-order-in-elixir/"> Taking Control of Map Sort Order in Elixir </a> </dd> </dl> </article></div>
  </body>
</html>
