<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://emersion.fr/blog/2025/using-podman-compose-and-buildkit/">Original</a>
    <h1>Using Podman, Compose and BuildKit</h1>
    
    <div id="readability-page-1" class="page"><div id="main">
	<nav><a href="https://emersion.fr/">home</a> ·
	<a href="https://emersion.fr/blog">blog</a> ·
	<a rel="me" href="https://emersion.fr/about">about</a>
</nav>


	<main>


<article lang="en">
	<header>
		
		
			<time datetime="2025-02-23T00:00:00+02:00">2025-02-23</time>
		
	</header>

	<p>For my <a href="https://osrd.fr/en/">day job</a>, I need to build and run a <a href="https://docs.docker.com/compose/">Docker Compose</a> project.
However, because Docker <a href="https://github.com/moby/moby/issues/26824">doesn’t play well with nftables</a> and I
prefer a rootless + daemonless approach, I’m using <a href="https://podman.io/">Podman</a>.</p>
<p>Podman supports Docker Compose projects with two possible solutions: either by
connecting the official <a href="https://github.com/docker/compose/">Docker Compose CLI</a> to a Podman socket, either by
using <a href="https://github.com/containers/podman-compose">their own drop-in replacement</a>. They ship a
<a href="https://docs.podman.io/en/latest/markdown/podman-compose.1.html">small wrapper</a> to select one of these options. (The
wrapper has the same name as the replacement, which makes things confusing.)</p>
<p>Unfortunately, both options have downsides. When using the official Docker
Compose CLI, the classic builder is used instead of the newer <a href="https://docs.docker.com/build/buildkit/">BuildKit</a>
builder. As a result, some features such as <a href="https://docs.docker.com/reference/compose-file/build/#additional_contexts">additional contexts</a> are not
supported. When using the podman-compose replacement, some other features are
missing, such as <code>!reset</code>, <code>configs</code> and referencing another service in
additional contexts. It would be possible to add these features to
podman-compose, but that’s an endless stream of work (Docker Compose regularly
adds new features) and I don’t really see the value in re-implementing all of
this (the fact that it’s Python doesn’t help me getting motivated).</p>
<p>I’ve started looking for a way to convince the Docker Compose CLI to run under
Podman with BuildKit enabled. I’ve tried a few months ago and never got it to
work, but it seems like this recently became easier! The podman-compose wrapper
<a href="https://github.com/containers/podman/blob/1e7f810f714240f5d68f92baa1ab39ee53a249f5/cmd/podman/compose.go#L164">force-disables BuildKit</a>, so we need to use
directly the Docker Compose CLI without the wrapper. On Arch Linux, this can be
achieved by enabling the Podman socket and creating a new Docker context (same
as setting <code>DOCKER_HOST</code>, but more permanent):</p>
<pre><code>pacman -S docker-compose docker-buildx
systemctl --user start podman.socket
docker context create podman --docker host=unix://$XDG_RUNTIME_DIR/podman/podman.sock
docker context use podman
</code></pre>
<p>With that, <code>docker compose</code> just works! It turns out it automagically creates a
<code>buildx_buildkit_default</code> container under-the-hood to run the BuildKit daemon.
Since I don’t like automagical things, I immediately tried to run BuildKit
daemon myself:</p>
<pre><code>pacman -S buildkit
systemctl --user start buildkit.service
docker buildx create --name local unix://$XDG_RUNTIME_DIR/buildkit/rootless
docker buildx use local
</code></pre>
<p>Now <code>docker compose</code> uses our systemd-managed BuildKit service. But we’re not
done yet! One of the reasons I like Podman is because it’s daemonless, and
we’ve got a daemon running in the background. This isn’t the end of the world,
but it’d be nicer to be able to run the build without BuildKit.</p>
<p>Fortunately, there’s a way around this: any Compose project can be turned into
a JSON description of the build commands called <a href="https://docs.docker.com/build/bake/">Bake</a>. <code>docker buildx bake --print</code> will print that JSON file (and the Docker Compose CLI will use Bake
files if <code>COMPOSE_BAKE=true</code> is set since v2.33). Note, Bake supports way more
features (e.g. HCL files) but we don’t really need these for our purposes (and
the command above can lower fancy Bake files into dumb JSON ones).</p>
<p>The JSON file is pretty similar to the <code>podman build</code> CLI arguments. It’s not
that hard to do the translation, so I’ve written <a href="https://github.com/emersion/bakah">Bakah</a>, a small tool which
does exactly this. It uses <a href="https://buildah.io/">Buildah</a> instead of shelling out to Podman (Buildah
is the library used by Podman under-the-hood to build images). A few details
required a bit more attention, for instance dependency resolution and parallel
builds, but it’s quite simple. It can be used like so:</p>
<pre><code>docker buildx bake --print &gt;bake.json
bakah --file bake.json
</code></pre>
<p>Bakah is still missing the fancier Bake features (HCL files, inheritance,
merging/overriding files, variables, and so on), but it’s enough to build
complex Compose projects. I plan to use it for <a href="https://codeberg.org/emersion/soju-containers">soju-containers</a> in the future,
to better split my Dockerfiles (one for the backend, one for the frontend) and
remove the CI shell script (which contains a bunch of Podman CLI invocations).
I hope it can be useful to you as well!</p>


	
	
	
</article>

	</main>

	
</div></div>
  </body>
</html>
