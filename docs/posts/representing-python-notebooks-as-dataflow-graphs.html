<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://marimo.io/blog/dataflow">Original</a>
    <h1>Representing Python notebooks as dataflow graphs</h1>
    
    <div id="readability-page-1" class="page"><div><div><blockquote>
<p>This blog is adapted from our talk at PyCon 2025. marimo is free and open
source, available on <a target="_blank" href="https://github.com/marimo-team/marimo">GitHub</a>. For
a free online experience with link sharing, try <a target="_blank" href="https://molab.marimo.io/notebooks">molab</a>.</p>
</blockquote>
<p>marimo is a new kind of open-source Python notebook. While traditional
notebooks are just REPLs, marimo notebooks are Python programs represented as
dataflow graphs. This intermediate representation lets marimo
blend the best parts of interactive computing with the reproducibility and
reusability of Python software: every marimo notebook works as a reactive
notebook for Python (and SQL) that keeps code and outputs in sync (run a cell
and marimo knows which other cells to run), an executable script and a Python
module, and an interactive web app.</p>
<p>In this blog post, we motivate the need for a new kind of notebook, explain how
and why marimo represents notebooks as dataflow graphs, present design
decisions we made to help users adapt to dataflow programming, discuss
our implementation, and show several examples of how marimo uses its dataflow
graph to make data work reactive, interactive, reproducible, and reusable.</p>

<h2 id="motivating-a-new-kind-of-notebook"><a target="_blank" aria-label="Link to section" href="#motivating-a-new-kind-of-notebook"><span></span></a>Motivating a new kind of notebook</h2>
<p>AI and data work are different from software engineering.
When you work with data, it’s helpful to hold objects in memory,
iteratively transforming and visualizing them as you evaluate
datasets, models, and algorithms. Notebooks are the only programming
environment that enable this workflow — for this reason, the number of GitHub
repos with Jupyter notebooks <a target="_blank" href="https://github.blog/news-insights/octoverse/octoverse-2024/">more than doubled in
2024</a>,
alongside the rise of AI.</p>
<figure><p><img src="https://marimo.io/images/blog/31/mnist_quadratic.gif" alt="quadratic transform"/><img src="https://marimo.io/images/blog/31/mnist_centered.gif" alt="centered MNIST"/></p><figcaption><p>Interactive computing is crucial for evaluating
data and algorithms. These GIFs visualize projected LBFGS
applied to different embedding formulations on the MNIST dataset.
I made them in Jupyter notebooks during my PhD in machine learning;
I used Jupyter notebooks extensively during my PhD, but I also had
issues in reproducibility, interactivity, maintainability, and reusability,
which motivated me to start work on marimo.</p></figcaption></figure>
<p>Nonetheless, traditional notebooks such as Google Colab or Jupyter notebooks
suffer from issues in reproducibility, interactivity, maintainability, and
reusability, making them unsuited for modern AI and data work and creating
the need for a new kind of notebook.</p>
<h3 id="reproducibility"><a target="_blank" aria-label="Link to section" href="#reproducibility"><span></span></a>Reproducibility</h3>
<p>Traditional notebooks have a reproducibility crisis. In
2019, a <a target="_blank" href="https://leomurta.github.io/papers/pimentel2019a.pdf">study</a> from New
York University and Federal Fluminense University found that of the nearly
1 million Jupyter notebooks on GitHub with valid execution orders, only 24%
could be re-run, and just 4% reproduced the same results. A <a target="_blank" href="https://blog.jetbrains.com/datalore/2020/12/17/we-downloaded-10-000-000-jupyter-notebooks-from-github-this-is-what-we-learned/">similar
study</a>
from 2020 by JetBrains found that over a third of the notebooks on GitHub had
invalid execution histories.</p>
<p>Traditional notebooks accumulate hidden state: run or delete a cell,
and program memory is imperatively mutated without regard to the rest of the
code on the page. This allows code and outputs to become out of sync. While a feature of
REPLs, hidden state gets in the way when you’re trying to do work you’d like to
reproduce.</p>
<figure><img src="https://marimo.io/images/blog/31/colab-1.png"/><figcaption>Code and outputs in traditional notebooks
can become out of sync</figcaption></figure>
<p>These studies can be scrutinized and caveated, but the finding resonates with
developer sentiment at large, not to mention my own experience as a former
machine learning PhD student who used notebooks on an almost daily basis. <a target="_blank" href="https://arxiv.org/pdf/1810.08055">You
have to be very disciplined</a> to make a
Jupyter notebook that is actually reproducible. At least for the
kind of work that I do, I’d prefer a tool that was reproducible by default.</p>
<h3 id="interactivity"><a target="_blank" aria-label="Link to section" href="#interactivity"><span></span></a>Interactivity</h3>
<p>While Jupyter notebooks are interactive in that you can execute cells
iteratively, <em>data</em> in traditional notebooks is not interactive. As a
researcher, I wanted to make selections in scatter plots and get my selection
back as a dataframe automatically. These kinds of highly interactive
experiences were simply out of reach.</p>
<h3 id="maintainability"><a target="_blank" aria-label="Link to section" href="#maintainability"><span></span></a>Maintainability</h3>
<figure><img src="https://marimo.io/images/blog/31/untitled14.png"/><figcaption>Jupyter’s JSON file format and the fact that
Jupyter notebooks are not well-formed programs makes code reuse difficult.</figcaption></figure>
<p>Because traditional notebooks are not Python files but instead stored with code
and outputs serialized in what <a target="_blank" href="https://github.com/samuelcolvin/notbook">Pydantic creator Samuel Colvin calls a “horrid
blob”</a> of JSON, they are difficult to
maintain. Instead of reusing code, practitioners end up duplicating notebooks
or starting from scratch. (The file format also makes it hard to version
notebooks with Git.)</p>
<h3 id="reusability"><a target="_blank" aria-label="Link to section" href="#reusability"><span></span></a>Reusability</h3>
<p>Finally, because traditional notebooks aren’t guaranteed to be valid Python
programs, they are difficult to reuse as data pipelines, as apps, or software.
And yet people try anyway (just look at Databricks and SageMaker), because <em>AI and data
people really like interactive programming environments</em>.</p>
<h2 id="marimo-a-new-kind-of-notebook"><a target="_blank" aria-label="Link to section" href="#marimo-a-new-kind-of-notebook"><span></span></a>marimo: a new kind of notebook</h2>
<p>Toward the end of my PhD, I got to thinking: <em>what would it take to make a new
kind of notebook that blended the best parts of interactive computing
with the reproducibility, maintainability, and reusability of Python software</em>?</p>
<p>A reactive notebook that kept code and outputs in sync:</p>
<video controls="" muted="" loop="" width="700px"><source src="/images/blog/31/reactive.webm" type="video/webm"/></video>
<p>That sent scatterplot selections back to Python, automatically:</p>
<figure><img src="https://marimo.io/images/blog/31/mnist-image-preview.gif"/></figure>
<p>That could be reused as a module …</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>from</span><span> my_notebook </span><span>import</span><span> my_function</span></span></code></pre></div></figure>
<p>or a script …</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>python my_embedding_notebook.py </span><span>--</span><span>dimension </span><span>256</span></span></code></pre></div></figure>
<p>or a <a target="_blank" href="https://marimo.io/@public/reactive-plots">web app</a>?</p>
<p>It turns out that one way to create a notebook that satisfies these
properties is to represent notebooks as dataflow graphs on cells. This
is the solution that marimo adopted.</p>
<p>marimo was originally created three years ago, with feedback from <a target="_blank" href="https://marimo.io/blog/slac-marimo">Stanford
scientists</a> and AI/ML engineers. Today,
marimo is downloaded hundreds of thousands of times a month, has over 15k
GitHub stars, is built by a <a target="_blank" href="https://marimo.io/about">stellar team</a>, and is
used by large enterprises including
<a target="_blank" href="https://blog.cloudflare.com/marimo-cloudflare-notebooks/">Cloudflare</a>,
Shopify, and BlackRock, as well as cutting-edge startups and research labs.</p>
<h2 id="representation-as-a-dataflow-graph"><a target="_blank" aria-label="Link to section" href="#representation-as-a-dataflow-graph"><span></span></a>Representation as a dataflow graph</h2>
<p>A marimo notebook is modeled as a directed acyclic graph (DAG) on cells. An edge <code>(u, v)</code> means cell <code>v</code> reads a variable defined by <code>u</code>. Variable definitions and
references are statically inferred, with no runtime tracing. This means that
there’s no runtime overhead associated with our graph, and also that variable
mutations are not tracked.</p>
<p>This <em>dataflow graph</em>  specifies how variables <em>flow</em> from one cell to another.
The semantics of the graph are that if <code>u</code> is a parent of <code>v</code>, meaning that <code>v</code>
reads a variable defined by <code>u</code>, then <code>v</code> has to run after <code>u</code>.</p>
<p><strong>Example.</strong></p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span># Cell 1</span></span>
<span data-line=""><span>x </span><span>=</span><span> 0</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span># Cell 2  </span></span>
<span data-line=""><span>y </span><span>=</span><span> x </span><span>+</span><span> 1</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span># Cell 3</span></span>
<span data-line=""><span>z </span><span>=</span><span> x </span><span>+</span><span> y </span><span>+</span><span> 1</span></span></code></pre></div></figure>
<p>We build a graph that looks like this:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="console" data-theme="github-light"><code data-language="console" data-theme="github-light"><span data-line=""><span>Cell 1 --&gt; Cell 2 --&gt; Cell 3</span></span>
<span data-line=""><span>   |                    ^</span></span>
<span data-line=""><span>   |                    |</span></span>
<span data-line=""><span>   +--------------------+</span></span></code></pre></div></figure>
<h3 id="an-intermediate-representation-for-notebooks-scripts-and-apps"><a target="_blank" aria-label="Link to section" href="#an-intermediate-representation-for-notebooks-scripts-and-apps"><span></span></a>An intermediate representation for notebooks, scripts, and apps</h3>
<figure><img src="https://marimo.io/images/blog/31/compiler-v2.png"/><figcaption><p>A notebook is shown on the left, and its representation as a dataflow graph is
in the middle. On the right are three ways the graph can be executed: as a
reactive notebook, in which you can run individual cells; as a script; and as a
web app.</p></figcaption></figure>
<p>The dataflow graph is an intermediate representation for three different ways
of running your code:</p>
<p><strong>As a reactive notebook.</strong> When you run a cell, marimo uses the dataflow
graph to determine which other cells need to run to keep code and outputs
in sync. marimo can either run these cells for you automatically or mark them
as stale (your choice). This is called <strong>reactive execution</strong>. Reactivity
dramatically speeds up experimentation while also giving you guarantees on
state.</p>
<p><strong>As a Python script.</strong> Notebooks are stored as Python files in which each
cell is a function. Running <code>python notebook.py</code> runs your cells in a
topologically sorted order.</p>
<p><strong>As an interactive web app.</strong> Use <code>marimo run notebook.py</code> from the command-line
to serve your notebook as a web app, with code hidden. Interactions with
UI elements trigger reactive execution of dependent cells — no callbacks
required.</p>
<p>In all three cases, the dataflow graph determines the cell execution order,
ensuring that your program’s semantics remain the same.</p>
<h3 id="a-contract-between-marimo-and-the-developer"><a target="_blank" aria-label="Link to section" href="#a-contract-between-marimo-and-the-developer"><span></span></a>A contract between marimo and the developer</h3>
<p>marimo imposes a few constraints on your code to ensure that
your notebook is a directed acyclic graph (DAG).</p>
<ol>
<li>No cycles</li>
<li>No variable redefinitions across cells</li>
</ol>
<p>These constraints have a small <a target="_blank" href="https://docs.marimo.io/guides/coming_from/jupyter/">learning
curve</a>. But accept these
<em>simple-to-understand</em> constraints — sign this contract — and you get many
benefits:</p>
<ul>
<li><strong>batteries-included:</strong> replaces <code>jupyter</code>, <code>streamlit</code>, <code>jupytext</code>, <code>ipywidgets</code>, <code>papermill</code>, and more</li>
<li><strong>reactive</strong>: run a cell, and marimo reactively <a target="_blank" href="https://docs.marimo.io/guides/reactivity.html">runs all dependent cells</a> or <a href="#expensive-notebooks">marks them as stale</a></li>
<li><strong>interactive:</strong> <a target="_blank" href="https://docs.marimo.io/guides/interactivity.html">bind sliders, tables, plots, and more</a> to Python — no callbacks required</li>
<li><strong>git-friendly:</strong> stored as <code>.py</code> files</li>
<li><strong>designed for data</strong>: query dataframes, databases, warehouses, or lakehouses <a target="_blank" href="https://docs.marimo.io/guides/working_with_data/sql.html">with SQL</a>, filter and search <a target="_blank" href="https://docs.marimo.io/guides/working_with_data/dataframes.html">dataframes</a></li>
<li><strong>AI-native</strong>: <a target="_blank" href="https://docs.marimo.io/guides/generate_with_ai/">generate cells with AI</a> tailored for data work</li>
<li><strong>reproducible:</strong> <a target="_blank" href="https://docs.marimo.io/guides/reactivity.html#no-hidden-state">no hidden state</a>, deterministic execution, <a target="_blank" href="https://docs.marimo.io/guides/package_management/">built-in package management</a></li>
<li><strong>executable:</strong> <a target="_blank" href="https://docs.marimo.io/guides/scripts.html">execute as a Python script</a>, parameterized by CLI args</li>
<li><strong>shareable</strong>: <a target="_blank" href="https://docs.marimo.io/guides/apps.html">deploy as an interactive web app</a> or <a target="_blank" href="https://docs.marimo.io/guides/apps.html#slides-layout">slides</a>, <a target="_blank" href="https://docs.marimo.io/guides/wasm.html">run in the browser via WASM</a></li>
<li><strong>reusable:</strong> <a target="_blank" href="https://docs.marimo.io/guides/reusing_functions/">import functions and classes</a> from one notebook to another</li>
<li><strong>testable:</strong> <a target="_blank" href="https://docs.marimo.io/guides/testing/">run pytest</a> on notebooks</li>
<li><strong>a modern editor</strong>: <a target="_blank" href="https://docs.marimo.io/guides/editor_features/ai_completion.html#github-copilot">GitHub Copilot</a>, <a target="_blank" href="https://docs.marimo.io/guides/editor_features/ai_completion.html">AI assistants</a>, vim keybindings, variable explorer, and <a target="_blank" href="https://docs.marimo.io/guides/editor_features/index.html">more</a></li>
</ul>
<p>Plus, you may find that you end up writing better code.</p>
<h3 id="why-marimo-does-not-track-mutations"><a target="_blank" aria-label="Link to section" href="#why-marimo-does-not-track-mutations"><span></span></a>Why marimo does not track mutations</h3>
<p>We opted for static construction, based only on variable definitions and
references, for two reasons:</p>
<ol>
<li>it makes the dataflow structure easy for developers to
understand;</li>
<li>it’s possible for us to implement with 100% correctness.</li>
</ol>
<p>In contrast, runtime tracing of mutations (such as a list append) would cover
more control dependencies, but <em>never all</em>. It would be fundamentally incorrect,
stranding developers in an uncanny valley with steep usability cliffs in which
they wouldn’t be able to predict how and when their cells would run.</p>
<h2 id="how-marimo-uses-the-dataflow-graph"><a target="_blank" aria-label="Link to section" href="#how-marimo-uses-the-dataflow-graph"><span></span></a>How marimo uses the dataflow graph</h2>
<h3 id="reactive-execution"><a target="_blank" aria-label="Link to section" href="#reactive-execution"><span></span></a>Reactive execution</h3>
<p>Reactive execution is based on a single runtime rule:</p>
<blockquote>
<p>When a cell is run, all other cells that reference its definitions (its descendants) are also run; when a cell is deleted or modified, its definitions are removed from kernel memory and its descendants are re-run.</p>
</blockquote>
<p>This keeps code and outputs in sync and prevents bugs before they happen, while
also enabling rapid data transformations.</p>
<p>It’s also different from how regular notebooks work, and that can take getting used to.
For this reason, marimo provides the affordances that make reactive execution
more manageable. Below we list some of these affordances, as well as other ways
in which marimo’s runtime uses the graph to make developers more productive.</p>
<p><strong>Lazy execution.</strong> The reactive runtime can be configured to be <em>lazy</em>, in which
case descendants are marked as <em>stale</em> instead of automatically run. A single
click (or hotkey combination) can be used to run all stale cells.</p>
<p><strong>Control flow.</strong> Raising an exception halts execution of a cell and its descendants;
marimo provides a convenience function for this, <code>mo.stop(predicate)</code>. This allows
developers to author notebooks or workflows in which subtrees of cells are only
executed when their preconditions are met.</p>
<p><strong>Granular re-runs for imports.</strong> It is common to declare all notebooks in a
cell, incrementally adding additional imports as needed; it would be
unfortunate if adding these new imports triggered re-runs of cells depending on
the already imported modules. For such cases we statically determine the set of
modules imported by a cell; descendants of “import-only” cells are filtered
based on new imports, preventing unnecessary re-runs.</p>
<p><strong>Graceful constraint validation.</strong> As mentioned earlier, marimo notebooks have some constraints: a variable cannot be defined in multiple cells, and cycles among cells are not allowed. When a repeated definition is introduced, care is taken to not invalidate previously valid state. In particular, registration of a new cell <code>u</code> should not invalidate
an existing cell <code>v</code>, unless there is a path from <code>u</code> to <code>v</code>.</p>
<p>If you have three cells, run incrementally:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>x </span><span>=</span><span> 0</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>x</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span># </span></span></code></pre></div></figure>
<p>The third cell triggers a multiple definition error, without invalidating the
first two cells.</p>
<p><strong>Local variables.</strong>  To make it easier to adapt to marimo’s constraint, we introduce
the following rule: variables prefixed with an underscore are made local to a cell,
and so their name can be reused in multiple cells</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>for</span><span> _i </span><span>in</span><span> range</span><span>(k): </span><span>...</span></span></code></pre></div></figure>
<p>This also allows for anonymous scopes, which are a convenient way to avoid polluting
the global scope:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>def</span><span> _</span><span>():</span></span>
<span data-line=""><span>    x </span><span>=</span><span> ...</span></span></code></pre></div></figure>
<p>Local variables are implemented by name-mangling while walking the AST and forming
the graph.</p>
<p><strong>Module hot-reloading.</strong></p>
<p>marimo comes with an advanced module autoreloader that takes advantage of the
dataflow graph.</p>
<ul>
<li>On module change, the cells that use modified modules (determined statically,
by referring to the graph) are marked stale.</li>
<li>Modules that depend on these modified modules also marked stale.</li>
<li>This allows us to know exactly which cells need to be re-run (unlike IPython’s
<code>autoreload</code> extension).</li>
</ul>
<video controls="" muted="" loop="" width="700px"><source src="/images/blog/31/docs-module-reloading-lazy.mp4" type="video/mp4"/></video>
<p><strong>SQL embedding.</strong></p>
<p>SQL is also supported through an embedding in Python:</p>
<ul>
<li>We parse a dataflow graph on SQL, analogous to Python, by specializing
Python AST visitor’s analysis of <code>Call</code> nodes.</li>
<li>Python and SQL graphs are joined based on return value and referenced variables.</li>
</ul>
<p>As an example,</p>
<figure><img src="https://marimo.io/images/blog/31/sql_cell.png"/></figure>
<p>is translated to</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>mo.sql(</span></span>
<span data-line=""><span>f</span><span>&#39;&#39;&#39;</span></span>
<span data-line=""><span>SELECT * FROM df WHERE b &lt; </span><span>{{</span><span>max_b_value</span><span>}}</span></span>
<span data-line=""><span>&#39;&#39;&#39;</span></span>
<span data-line=""><span>)</span></span></code></pre></div></figure>
<p>which is subject to static analysis.</p>
<p><strong>Composition.</strong> marimo allows for composition of notebooks, implemented by
nesting graphs, each with its own runtime. <code>UIElement</code> interactions and <code>RPC</code>s
are routed through this graph stack.</p>
<p><strong>Caching.</strong> Because <code>functools.cache</code> invalidated on cell re-run, marimo comes
with its own caching utilities. <code>import marimo as mo</code> to get …</p>
<ul>
<li><code>mo.cache</code>, analogous but keyed on ancestor source and primitive reference values:</li>
</ul>
<ol>
<li>Function code hash</li>
<li>Content addressed hash (primitive references)</li>
<li>Execution path hash (ancestor source)</li>
</ol>
<ul>
<li><code>mo.persistent_cache</code> allows disk caching (local or remote)</li>
</ul>
<p><strong>Mutable state.</strong> marimo encourages functional code and discourages mutations. For advanced users, we provide React-like state setters and getters provide an escape hatch for mutable state (though we discourage this practice, and recommend implementing <a target="_blank" href="https://docs.marimo.io/api/inputs/anywidget/">custom widgets with anywidget</a> instead).</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>get_state, set_state </span><span>=</span><span> mo.state(</span><span>0</span><span>)</span></span></code></pre></div></figure>
<p>A call to <code>set_state</code> registers a pending state update with the runtime:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>set_state(</span><span>1</span><span>)</span></span></code></pre></div></figure>
<p>When cells have finished executing, any cell with a reference to a getter of
a pending state update is marked for execution:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>get_state()</span></span></code></pre></div></figure>
<h3 id="interactive-elements"><a target="_blank" aria-label="Link to section" href="#interactive-elements"><span></span></a>Interactive elements</h3>
<p>The dataflow graph makes it possible for marimo to provide a reactive experience
for working with UI elements, no callbacks required. Binding UI elements to
global variables connects them to marimo’s runtime.</p>

<p>Interacting with a UI element marks for execution all
cells that refer to its bound variable but <em>don’t define it</em>. In our implementation,
on interaction, the runtime searches <code>globals</code> for matching <code>UIElement</code> objects,
does a lookup to find the bound variables’ defining cells, then triggers reactive
execution.</p>
<h3 id="scripts"><a target="_blank" aria-label="Link to section" href="#scripts"><span></span></a>Scripts</h3>
<p><strong>Script execution.</strong> marimo stores notebooks as pure Python files, with each
cell stored as a function.</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>import</span><span> marimo</span></span>
<span data-line=""> </span>
<span data-line=""><span>app </span><span>=</span><span> marimo.App()</span></span>
<span data-line=""> </span>
<span data-line=""><span>@app.cell</span></span>
<span data-line=""><span>def</span><span> _</span><span>():</span></span>
<span data-line=""><span>    x </span><span>=</span><span> 0</span></span>
<span data-line=""><span>    return</span><span> x</span></span>
<span data-line=""> </span>
<span data-line=""><span>@app.cell</span></span>
<span data-line=""><span>def</span><span> _</span><span>(x):</span></span>
<span data-line=""><span>    y </span><span>=</span><span> x </span><span>+</span><span> 1</span></span>
<span data-line=""><span>    print</span><span>(y)</span></span>
<span data-line=""><span>    return</span></span>
<span data-line=""> </span>
<span data-line=""><span>if</span><span> __name__</span><span> ==</span><span> &#34;__main__&#34;</span><span>:</span></span>
<span data-line=""><span>    app.run()</span></span></code></pre></div></figure>
<p>Running <code>python my_notebook.py</code> registers the cells with an internal dataflow
graph and runs them in a topologically sorted order.</p>
<p><strong>Reuse as modules.</strong></p>
<p>Any cell that defines a “pure” (no variable references except for those from a
special setupcell or other pure functions) function is <a target="_blank" href="https://docs.marimo.io/guides/reusing_functions/">saved as top-level
symbols</a>. Determining which
functions are pure requires studying the graph. For example:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>import</span><span> marimo</span></span>
<span data-line=""> </span>
<span data-line=""><span>app </span><span>=</span><span> marimo.App()</span></span>
<span data-line=""> </span>
<span data-line=""><span>with</span><span> app.setup():</span></span>
<span data-line=""><span>   import</span><span> numpy </span><span>as</span><span> np</span></span>
<span data-line=""> </span>
<span data-line=""><span>@app.function</span></span>
<span data-line=""><span>def</span><span> mean</span><span>(x: np.ndarray):</span></span>
<span data-line=""><span>    return</span><span> np.mean(x)</span></span>
<span data-line=""> </span>
<span data-line=""><span>@app.cell</span></span>
<span data-line=""><span>def</span><span> _</span><span>():</span></span>
<span data-line=""><span>    print</span><span>(mean(np.random.randn(</span><span>2</span><span>,</span><span>2</span><span>)))</span></span>
<span data-line=""><span>    return</span></span>
<span data-line=""> </span>
<span data-line=""><span>if</span><span> __name__</span><span> ==</span><span> &#34;__main__&#34;</span><span>:</span></span>
<span data-line=""><span>    app.run()</span></span></code></pre></div></figure>
<p>Allowing you to write, in another Python file or notebook:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>from</span><span> my_notebook </span><span>import</span><span> mean</span></span></code></pre></div></figure>
<p><strong>Converting Jupyter notebooks to marimo notebooks.</strong> marimo has a built-in
converter from Jupyter notebooks to marimo notebooks (<code>marimo convert</code> at the
command-line), which fixes violated constraints such as multiple definitions.
We extended our AST visitor to transform multiple definitions with static
single assignment:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a </span><span>=</span><span> 0</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a </span><span>=</span><span> a </span><span>+</span><span> 1</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a</span></span></code></pre></div></figure>
<p>is remapped to</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a </span><span>=</span><span> 0</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a_1 </span><span>=</span><span> a </span><span>+</span><span> 1</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>a_1</span></span></code></pre></div></figure>
<h3 id="apps"><a target="_blank" aria-label="Link to section" href="#apps"><span></span></a>Apps</h3>
<p>marimo notebooks can be run as data apps with the command-line: <code>marimo run my_notebook.py</code>, which hides the notebook code by default. Unlike other data
app frameworks, marimo uses the DAG to ensure a minimal set of cells run on UI
element interactions.</p>
<h2 id="implementation"><a target="_blank" aria-label="Link to section" href="#implementation"><span></span></a>Implementation</h2>
<p>Representing a notebook as a dataflow graph requires parsing each cell into an abstract syntax
tree (AST), then applying semantic analysis to wire up the graph.</p>
<h3 id="parsing"><a target="_blank" aria-label="Link to section" href="#parsing"><span></span></a>Parsing</h3>
<p>Parsing means converting user code into an AST. In Python, this involves using
the builtin <code>ast</code> module. For example, the code</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>b </span><span>=</span><span> a </span><span>+</span><span> 1</span></span></code></pre></div></figure>
<p>is represented by the tree</p>
<figure><img src="https://marimo.io/images/blog/31/ast_parse.png"/></figure>
<p>In Python,</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>import</span><span> ast</span></span>
<span data-line=""> </span>
<span data-line=""><span>ast.dump(ast.parse(</span><span>&#34;b = a + 1&#34;</span><span>), </span><span>indent</span><span>=</span><span>4</span><span>)</span></span></code></pre></div></figure>
<p>yields</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="console" data-theme="github-light"><code data-language="console" data-theme="github-light"><span data-line=""><span>Module(</span></span>
<span data-line=""><span>    body=[</span></span>
<span data-line=""><span>        Assign(</span></span>
<span data-line=""><span>            targets=[</span></span>
<span data-line=""><span>                Name(id=&#39;b&#39;, ctx=Store())</span></span>
<span data-line=""><span>            ],</span></span>
<span data-line=""><span>            value=BinOp(</span></span>
<span data-line=""><span>                left=Name(id=&#39;a&#39;, ctx=Load()),</span></span>
<span data-line=""><span>                op=Add(),</span></span>
<span data-line=""><span>                right=Constant(value=1)</span></span>
<span data-line=""><span>            )</span></span>
<span data-line=""><span>        )</span></span>
<span data-line=""><span>    ]</span></span>
<span data-line=""><span>)</span></span></code></pre></div></figure>
<h3 id="semantic-analysis"><a target="_blank" aria-label="Link to section" href="#semantic-analysis"><span></span></a>Semantic analysis</h3>
<p>Semantic analysis takes the abstract syntax trees produced in parsing (one for each cell),
and makes sense of them:</p>
<ol>
<li>We walk the tree to find variables the cell defines, refers to (but doesn’t define), and deletes;</li>
<li>we construct the graph based on cells’ definitions and references;</li>
<li>we check whether graph constraints are satisfied.</li>
</ol>
<p>As an example, the sequence of cells</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>b </span><span>=</span><span> a </span><span>+</span><span> 1</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>print</span><span>(b)</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>def</span><span> f</span><span>():</span></span>
<span data-line=""><span>    b </span><span>=</span><span> ...</span></span>
<span data-line=""><span>    return</span><span> b</span></span></code></pre></div></figure>
<p>is after analysis formed into the following graph. Notice that the variable <code>b</code> in <code>f</code> is recognized
as local to the cell, since it is defined in a function’s scope.</p>
<figure><img src="https://marimo.io/images/blog/31/semantic_analysis_1.png"/></figure>
<h4 id="variable-scope-resolution"><a target="_blank" aria-label="Link to section" href="#variable-scope-resolution"><span></span></a>Variable scope resolution</h4>
<p>Determining which variables are definitions and references, and which are local to a cell,
is called variable scope resolution:</p>
<ol>
<li>Variables are visible in <strong>scopes</strong>: these are sets of names valid in a specific region.</li>
<li>Scopes can be <strong>nested</strong>; inner scopes can access parent scopes’ variables, but not vice versa.</li>
<li>A cell’s <strong>definitions</strong> are the variable declarations in global scope.</li>
<li>A cell’s <strong>references</strong> are variable load or deletes in any scope that have not been defined in a parent scope.</li>
<li>Resolving references involves maintaining <strong>symbol tables</strong> in a <strong>stack of scopes</strong>.</li>
</ol>
<p><strong>Example.</strong> Consider this code:</p>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>def</span><span> f</span><span>(d):</span></span>
<span data-line=""><span>    return</span><span> b </span><span>+</span><span> c </span><span>+</span><span> d</span></span></code></pre></div></figure>
<figure data-rehype-pretty-code-figure=""><div><pre tabindex="0" data-language="python" data-theme="github-light"><code data-language="python" data-theme="github-light"><span data-line=""><span>b </span><span>=</span><span> d</span></span></code></pre></div></figure>
<p>The cell defining <code>f</code> references <code>b</code>, <code>c</code>, but not <code>d</code>, since <code>d</code> is shadowed by the function argument.
The cell defining <code>b</code> references <code>d</code>.</p>
<h2 id="conclusion"><a target="_blank" aria-label="Link to section" href="#conclusion"><span></span></a>Conclusion</h2>
<p>marimo’s rapid adoption indicates that developers are willing to sign our
<a target="_blank" href="#a-contract-between-marimo-and-the-developer">social contract</a>. And even
though dataflow notebooks may feel new to developers at first, they quickly
become accustomed to it.</p>
<p>Statically constructing a dataflow graph gives us enough information to make
notebooks reactive, reproducible, and reusable, while still being simple enough
that you can understand what’s happening. And because it’s based on static
analysis of regular Python code, you get all the benefits of <a target="_blank" href="https://marimo.io/blog/python-not-json">working in
Python</a>: compatibility with LLMs and
Python tooling, testing, version control, everything you’d expect from a real
programming language.</p>
<p>What we ended up with is something that feels like an extremely interactive
notebook when you’re developing, works like a script when you need to run it in
production, and becomes an app when you want to share it with others.</p>
<h2>Join the marimo community</h2><p>If you&#39;re interested in helping shape marimo&#39;s future, here are some ways you can get involved:</p></div></div></div>
  </body>
</html>
