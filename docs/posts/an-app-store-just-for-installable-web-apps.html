<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://store.app">Original</a>
    <h1>Show HN: An app store just for installable web apps</h1>
    
    <div id="readability-page-1" class="page"><div><article itemscope="" itemtype="http://schema.org/Article"><header><p>October 01, 2023</p></header><section><p>
I&#39;m attending the Fall 2 batch at <a href="https://www.recurse.com/scout/click?t=4b09801ab494151291278015fdbdd197">Recurse Center</a>! Posts in this series cover things I&#39;m working on or find interesting during my time here.
</p>
<p>Last week, I wrote about what I did during my <a href="https://stace.dev/rc-01-first-week-at-recurse/">first week at Recurse</a> and set some goals for this week. One of those goals was to find out more about Unix raw sockets since the Rust <a href="https://docs.rs/pnet/latest/pnet/"><code>libpnet</code></a> crate‚Äôs <code>transport_channel</code> API uses them (<a href="https://github.com/libpnet/libpnet/blob/87f362dea40a0a58b2b1660c51038343c0731dea/pnet_transport/src/lib.rs#L94">here</a>) to send and receive <a href="https://en.wikipedia.org/wiki/Transport_layer">Layer 4</a> packets. This week‚Äôs post recounts how I ended up debugging macOS‚Äô raw sockets as I attempted to filter out TCP packets in my Rust program.</p>
<h2>The case of the missing packets</h2>
<p>To send and receive TCP packets, I modified <code>libpnet</code>‚Äôs transport layer <a href="https://github.com/libpnet/libpnet/blob/main/examples/transport_echo_server.rs">echo example</a> and set the protocol to TCP. My program (more like a hacked script at this stage) sends a TCP SYN packet to a remote server and listens for its SYN ACK packet response. I could see with <code>tcpdump</code> that the two packets were sent and received, but for some reason my Rust program never receives the SYN ACK packet. Since Unix sockets and low level network programming are both quite new to me, I was quite confused.</p>
<p>Is there a bug in my program? Did I misuse <code>libpnet</code>‚Äôs APIs? Is the program not receiving packets because I didn‚Äôt have a port attached to the receiver stream? Do I need a port? Is this because I didn‚Äôt call <code>bind</code>? How does <code>bind</code> factor into all of these anyway? This led me down a rabbit hole of reading the man page for the <code>socket</code> system call and related resources.</p>
<p>Meanwhile, I also set about looking for examples on GitHub to see how this API was being used in the wild. I found at least <a href="https://github.com/OliLay/traceroute-rust/">two</a> <a href="https://github.com/teru01/toytcp/blob/b8ae46590011d528a63325e800fce142e16139fc/src/tcp.rs#L329">other</a> projects using the same <code>transport_channel</code> API to receive TCP packets. Going through the examples, I couldn‚Äôt quite spot any significant difference in how I tried to get the packets. Although I didn‚Äôt run those programs, their READMEs seem to suggest that it did work for them. Since they seemed to be side projects and both were last updated more than two years ago, I did some additional googling. The search led me to a <a href="https://squidarth.com/networking/systems/rc/2018/05/28/using-raw-sockets.html">blog post</a> (from another Recurser!) directly using raw sockets to receive TCP packets and <a href="https://stackoverflow.com/questions/5476112/raw-socket-question-are-tcp-packets-passed-to-a-raw-socket">Stack Overflow</a> <a href="https://stackoverflow.com/questions/40795772/cant-receive-packets-to-raw-socket">answers</a> suggesting that raw sockets do get TCP and UDP packets, as long as the <code>protocol</code> arg is set to the desired protocol.</p>
<p>I was out of ideas. And then I found an open tab on <a href="https://jameshfisher.com/2018/03/04/create-udp-connection-with-netcat/"><em>Creating a UDP connection with netcat</em></a> and thought, maybe I could try receiving UDP packets in my program instead? Maybe going through the code as I made the changes for UDP, and UDP being another protocol, and a simpler one, it might reveal a bug or at least some answers. The guide also had <code>tcpdump</code> filter for both UDP and ICMP packets, since when a UDP port is unreachable, the client receives a ICMP Port Unreachable packet. Unfortunately, capturing UDP packets proved unsuccessful too. There were packets in <code>tcpdump</code>, but none in the program.</p>
<p>At this point I was ready to leave my desk for a break, but then I saw that <code>tcpdump</code> also recorded some ICMP packets, and in a last-ditch attempt, I thought perhaps I could try receiving ICMP packets instead? Alas, when I modified the program to listen to ICMP packets, it did capture the ICMP Port Unreachable packet from (I assume) the kernel‚Äôs network stack. Finally some progress! This made me curious as to what makes ICMP so special anyway. Aren‚Äôt all three protocols transport layer protocols?<sup id="fnref-1"><a href="#fn-1">1</a></sup></p>
<p>In any case, this led me to search google again, and combing through the results, I saw this interesting link from the Apple Developer forum: <a href="https://developer.apple.com/forums/thread/724580">Raw Socket recvfrom not working for TCP</a>. Clicking on it,</p>
<blockquote>
<p>This is not going to work on any¬†<em>BSD</em>¬†Sockets implementation. You can‚Äôt use raw sockets to read TCP or UDP. To quote my trusty (and dusty, literally!) copy of Stevens [1]:</p>
<blockquote>
<p>The following rules apply;</p>
<ol>
<li>Received UDP packets and received TCP packets are¬†<em>never</em>¬†[their emphasis] passed to a raw socket.</li>
</ol>
</blockquote>
<p>This is¬†<em>UNIX Network Programming, Volume 1</em>, Second Edition, section 25.4¬†<em>Raw Socket Input</em>, page 659.
‚Äî<a href="https://developer.apple.com/forums/thread/724580">Raw Socket recvfrom not working for TCP</a>.</p>
</blockquote>
<p>I was in disbelief at first, but checking my own copy of <em>UNIX Network Programming</em>, 3rd Edition, there it was on page 872, the same sentence (no pun intended). But, there was hope:</p>
<blockquote>
<p>If a process wants to read IP datagrams containing UDP or TCP packets, the packets must be read at the datalink layer, as described in Chapter 29.</p>
</blockquote>
<p>Debugging, when a bug is elusive, can oftentimes be a frustrating and (sometimes) cathartic event. Sometimes the bug is staring at me right in the face and I‚Äôm convinced that my 4 line LeetCode answer is absolutely correct and somehow, the automatic checker is wrong. At least in such moments I can identify the offending test case and print each input and variable one by one if I need to. Debugging a program using a new library in an unfamiliar language that interacts with the OS network stack though, that seems easier to end up in a depth-first search path when one should be instead doing an A* search.</p>
<p>The sane approach to debugging is to start from a known base of knowledge (for example a known working program) and change one thing at a time to establish some working facts. But sometimes though, in the haze of confusion, it‚Äôs tempting to change multiple things at once in hopes of saving time‚Ñ¢. And  although this haphazard approach does work from time to time (if only rarely), more often than not it ends up introducing much more uncertainty and moving variables, making it hard to keep track of things, ultimately wasting more time and energy. <sup id="fnref-2"><a href="#fn-2">2</a></sup></p>
<blockquote>
<p>Suppose, you wrote a sockets-based program in C. You know it is going to run on a Pentium¬Æ, so you enter all your constants in reverse and force them to the¬†<em>network byte order</em>. It works well.</p>
<p>Then, some day, your trusted old Pentium¬Æ becomes a rusty old Pentium¬Æ. You replace it with a system whose¬†<em>host order</em>¬†is the same as the¬†<em>network order</em>. You need to recompile all your software. All of your software continues to perform well, except the one program you wrote.</p>
<p>You have since forgotten that you had forced all of your constants to the opposite of the¬†<em>host order</em>. You spend some quality time tearing out your hair, calling the names of all gods you ever heard of (and some you made up), hitting your monitor with a nerf bat, and performing all the other traditional ceremonies of trying to figure out why something that has worked so well is suddenly not working at all.</p>
<p>Eventually, you figure it out, say a couple of swear words, and start rewriting our code.</p>
</blockquote>
<p>How debugging can feel like, even if the exact bug and details differ. Excerpt from <a href="https://docs.freebsd.org/en/books/developers-handbook/sockets/#sockets-essential-functions">FreeBSD Developers&#39; Handbook: Chapter 7. Sockets</a>.</p>
<p>I went back to look through the <code>libpnet</code> examples and found an example for an <a href="https://docs.rs/pnet/latest/pnet/index.html#ethernet-echo-server">ethernet echo server</a> that connects to the datalink layer. This is one layer more than what I expected to go down to but it was worth a try since the raw sockets approach didn‚Äôt work out and the textbook above suggests that this is the only way to get TCP packets on BSD systems. And this <em>did</em> work, albeit not for localhost connections since that seems to operate only on the transport layer. I could receive ethernet packets that contained TCP packets, including the anticipated SYN ACK packet from above. I just needed to parse and filter out the ethernet headers, which wasn‚Äôt too difficult with the packet manipulation functions from <code>libpnet</code>.</p>
<h2>A mystery (and problem) solved, but what‚Äôs next?</h2>
<p>Sending out a TCP SYN packet and receiving a response is just the beginning. Before I can write out the code for my TCP implementation, there are still a number of open questions:</p>
<ul>
<li>It turns out that when the OS network stack receives a SYN ACK packet to a destination connection that it did not open and so doesn‚Äôt recognise (i.e. the connection from my TCP implementation), it sends out a RST packet to the server, effectively closing the connection. So, I‚Äôd need to figure out how to prevent or circumvent this.
<ul>
<li>One approach I‚Äôve found is to disable all outgoing RST packets using <code>iptables</code>, but what are the downsides to this approach?</li>
<li>Would using a TUN/TAP device avoid this alltogether? How difficult would it be to set that up on macOS?</li>
</ul>
</li>
<li>How should I structure my TCP implementation and interface? I was initially planning to model it after Rust‚Äôs <code>TCPListener</code> and <code>TCPStream</code>, but maybe I should take a simpler approach? Perhaps I could just implement a CLI that‚Äôs similar to <code>netcat</code> with the custom TCP implementation?</li>
<li>Is it possible to use the datalink connection described above to listen to TCP packets from localhost? Considering that (I think) there‚Äôs no datalink for localhost? This is less important than the first two since I can test with a remote server instead of using localhost but I was curious since I was initially using localhost to test my implementation.
<ul>
<li>One approach I‚Äôm thinking would be to use the Rust <a href="https://docs.rs/pcap/latest/pcap/"><code>pcap</code> package</a> directly in my program to capture localhost packets, instead of going through <code>libpcap</code>, which uses <code>pcap</code> to access datalink packets, but always assumes an ethernet device.</li>
</ul>
</li>
</ul>
<h2>Other things that happened this week</h2>
<p>I didn‚Äôt just spend time on TCP and network programming (even though it sometimes felt like it). Some other highlights:</p>
<ul>
<li>Attended the <a href="https://moldabledevelopment.com">Moldable Development</a> group‚Äôs overview of the <a href="https://gtoolkit.com">Glamorous Toolkit</a> (v cool stuff).</li>
<li>Had more coffee chats with Recursers.</li>
<li>Started on the <a href="https://cryptopals.com/">cryptopals crypto challenges</a> and joined the Cryptopals Group‚Äôs first meeting. This has been an unexpected source of great fun and is probably why there wasn‚Äôt further significant progress for my TCP project during the second half of the week.</li>
</ul>
<h2>Plans for next week</h2>
<ul>
<li>Talk to some other folks working on their own TCP implementation and figure out some of the open questions above.</li>
<li>Attend RC‚Äôs weekly presentation event. (I missed this week‚Äôs presentations because I forgot to RSVP for the calendar event and didn‚Äôt see the message for it until it was over.)</li>
<li>I‚Äôve been using Rust for the TCP implementation and cryptopals challenges, but I‚Äôm still facing some Rust lifetime errors that I don‚Äôt quite fully understand. So far I‚Äôve been able to work around them, but I‚Äôd like to get a better working understanding of the errors and how to reason about references and ownership, instead of just relying on SO answers.</li>
<li>Spend more time learning cryptography basics and finishing the first set of  the cryptopals challenges.</li>
</ul>
</section><hr/><div><div data-gatsby-image-wrapper=""><p><img aria-hidden="true" data-placeholder-image="" decoding="async" src="data:image/jpeg;base64,/9j/2wBDAAIBAQEBAQIBAQECAgICAgQDAgICAgUEBAMEBgUGBgYFBgYGBwkIBgcJBwYGCAsICQoKCgoKBggLDAsKDAkKCgr/2wBDAQICAgICAgUDAwUKBwYHCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgr/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAcGCAX/xAAYAQADAQEAAAAAAAAAAAAAAAADBgcEBf/aAAwDAQACEAMQAAAB5+6bhtZ5++dPHDFPtWUJf0gnrB//xAAbEAABBQEBAAAAAAAAAAAAAAAFAgMEBgcBAP/aAAgBAQABBQIG+rssI4ajL2TqX7aEDT6g1W7j22K0xTTdoJWgqS9n8t6Ga0uK0q1//8QAIBEAAgEBCQAAAAAAAAAAAAAAAQIAAwQREhQiMUFisf/aAAgBAwEBPwF8u9Fnxal4iMxQS2Ei49h6INp//8QAHxEAAgICAQUAAAAAAAAAAAAAAQIAAwQRMRITIaGy/9oACAECAQE/AbabAmmr8MNg69xUWtemYCg42jx2z8wcT//EACcQAAIBBAIABAcAAAAAAAAAAAECAwAEBRESIRMxQVEUIzJxgZGh/9oACAEBAAY/ArySKFpG8IhY1PmTIo1/aixWTv8AEzW93CyqthMztbOB0GJ6O9EfcVEIo9CPGwJr20tXefvTEESDWo/mPy5A/SPL3pcbZ5NpZGJk004ZeK+qLoapvhmJQwIQW9equMlJIqPJcueMQ0o711+qxVzERs5JVK66IkADD87qVOwEjRVC9aGq/8QAHBABAAMAAwEBAAAAAAAAAAAAAQARITFBUWGB/9oACAEBAAE/Ic7lFV4vi0v9jZuO8KMBWUdE6wAVtqZ9gVTNi96KgaeM9hgdDfQ1MC223qes+5I9eRrkLaVu6sLwoTjlAxpQVdHNSHdQMlE//9oADAMBAAIAAwAAABDkP8D/xAAbEQEAAgIDAAAAAAAAAAAAAAABACExURFxgf/aAAgBAwEBPxBKjQdtZytJk9jA6IwTwtsEgn//xAAZEQEAAwEBAAAAAAAAAAAAAAABESExAEH/2gAIAQIBAT8Qn1WSE0FHwNHG5mOIDyubkIpc152Xf//EABwQAQEBAQADAQEAAAAAAAAAAAERIQAxQVFhkf/aAAgBAQABPxBdr3WY54olZMMnEmZi3UCBTHr2lkWxbc2Sif37vGgIWgK12KSVzHW7SDu0LINLAeDGwrXS20Nm+vt7TdjtwpQBqrKq71zp0MMqlOt8bhwbxXKwEDD+9//Z" alt=""/></p><picture><source type="image/webp" data-srcset="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/541c0/profile-pic.webp 64w,/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/57ec1/profile-pic.webp 128w" sizes="64px"/><img data-gatsby-image-ssr="" layout="fixed" data-main-image="" sizes="64px" decoding="async" loading="lazy" data-src="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/df4a6/profile-pic.jpg" data-srcset="/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/df4a6/profile-pic.jpg 64w,/static/ff7ac4e749b0b2b9c3a4ee4a4ef14508/c7570/profile-pic.jpg 128w" alt="Stacey Tay"/></picture></div><p>Hi! I‚Äôm Stacey. Welcome to my<!-- --> <a href="https://stace.dev/">blog</a>. I‚Äôm a software engineer with an interest in programming languages and web performance. I also like making üçµ, reading fiction, and discovering random<!-- --> <a href="https://www.quora.com/What-should-everybody-know-about-tea-in-terms-of-health-benefits-or-detriments-carbon-footprint-quality-and-how-my-choice-of-tea-reflects-on-me/answer/Stacey-Tay-1">word origins</a>.</p></div></article></div></div>
  </body>
</html>
