<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://bradley.chatha.dev/blog/dlang-propaganda/asn1-compiler-in-d/">Original</a>
    <h1>I spent a year of my life making an ASN.1 compiler in D</h1>
    
    <div id="readability-page-1" class="page"><div> <section>  <section> <a href="https://bradley.chatha.dev/blog/dlang-propaganda">  </a> </section>  <p>
Published: 2025/10/23
| Updated: 2025/10/23 </p> <p>… and it’s still nowhere near complete.</p>
<p>In this post I’ll just rambling about ASN.1; parts of the compiler implementation, and some of the tool’s output rather than the tool itself as its still too WIP to really advertise on its own yet.</p>
<p>This post is unstructured, so you can just pick somewhere random and start reading from there with no/minimal context lost.</p>
<p>Note: the name of the tool is <a href="https://github.com/Juptune/juptune/tree/master/tools/dasn1">dasn1</a>.</p>
<h2 id="summary">Summary</h2>
<ul>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#very-briefly---what-is-asn1"><em>Very</em> briefly - what is ASN.1?</a></li>
<li><a href="#asn1s-notation-can-be-really-complex">ASN.1’s notation can be really complex</a>
<ul>
<li><a href="#x680-woes---historical-deprecations">x.680 woes - historical deprecations</a></li>
<li><a href="#x681">x.681</a></li>
<li><a href="#x682">x.682</a></li>
<li><a href="#x683">x.683</a></li>
</ul>
</li>
<li><a href="#asn1s-notation-is-also-pretty-cool">ASN.1’s notation is also pretty cool!</a>
<ul>
<li><a href="#asn1s-constraint-system">ASN.1’s constraint system</a></li>
<li><a href="#asn1s-versioning-system">ASN.1’s versioning system</a></li>
</ul>
</li>
<li><a href="#d-is-easy-to-generate-code-for">D is easy to generate code for</a>
<ul>
<li><a href="#static-imports--fully-qualified-names">Static imports &amp; fully qualified names</a></li>
<li><a href="#module-local-lookups">Module-local lookups</a></li>
<li><a href="#typeof">typeof()</a></li>
<li><a href="#d-allows-trailing-commas-in-almost-every-context">D allows trailing commas in almost every context</a></li>
<li><a href="#utilise-metaprogramming-so-your-compiler-can-stay-dumbpoorly-made">Utilise metaprogramming so your compiler can stay dumb/poorly made</a></li>
</ul>
</li>
<li><a href="#interesting-d-specific-parts-of-the-implementation">Interesting D-specific parts of the implementation</a>
<ul>
<li><a href="#mixin-templates-for-ast-nodes">Mixin templates for AST nodes</a></li>
<li><a href="#templates-can-provide-really-natural-apis-while-still-catching-errors-at-compile-time">Templates can provide really natural APIs while still catching errors at compile time</a></li>
<li><a href="#d-snark-the-forever-experimental-allocator-package">D Snark: The forever-experimental allocator package</a></li>
<li><a href="#alias-this---a-very-occasionally-useful-feature">alias this - a very occasionally useful feature</a></li>
<li><a href="#versionunittest">version(unittest)</a></li>
<li><a href="#templates--with--terse-ish-test-harnesses">Templates + with() = terse-ish test harnesses</a></li>
</ul>
</li>
<li><a href="#pain-points">Pain points</a>
<ul>
<li><a href="#value-sequence-syntax">Value sequence syntax</a></li>
<li><a href="#its-hard-to-find-important-info-in-the-specs">It’s hard to find important info in the specs</a></li>
<li><a href="#you-need-to-implement-constraints-3-separate-times">You need to implement constraints 3 separate times</a></li>
<li><a href="#the-dream-of-immutable-ir-nodes">The dream of immutable IR nodes</a></li>
<li><a href="#asn1-has-an-all-or-nothing-level-of-complexity">ASN.1 has an all-or-nothing level of complexity</a></li>
<li><a href="#any-defined-by">ANY DEFINED BY</a></li>
<li><a href="#i-cant-retain-all-the-information-i-need-to-know">I can’t retain all the information I need to know</a></li>
</ul>
</li>
<li><a href="#writing-a-compiler-is-tedious-work">Writing a compiler is tedious work</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="motivation">Motivation</h2>
<p>I’m currently writing <a href="https://github.com/Juptune/juptune">Juptune</a> - a toy async I/O framework that attempts to implement as much of its stack as possible in pure D.</p>
<p>I’m really interested in writing an implementation of TLS, which means I need to be able to handle x.509 certificates (i.e. TLS/SSL certs), which means I need to be able to handle their underlying data encoding: ASN.1’s DER encoding.</p>
<p>So basically I just wanted to do this <em>for fun</em> at the end of the day, nothing much deeper than that. I’ve never written or worked on a proper compiler project before that wasn’t toy-sized so I saw a ton of growth potential… the main thing that’s grown however is the mental scar ASN.1’s left on me.</p>
<p>I’ve succesfully generated code that can parse a couple of x.509 certificates I’ve thrown at it, and I’ve started work on an almost-D-native (excluding crypto primitives) implementation of TLS 1.3.</p>
<p>I’m constantly amazed about how much of modern life relies on these ancient, overly complicated specs from the 90s. ASN.1 is used <em>everywhere</em> in some form or another and yet I bet you’ve never even heard of it before, just have a look on <a href="https://en.wikipedia.org/wiki/ASN.1#Applications">wikipedia</a>.</p>
<h2 id="very-briefly---what-is-asn1"><em>Very</em> briefly - what is ASN.1?</h2>
<p>ASN.1 is the result of a bunch of graybeards from the late 80s+ trying to design an overengineered data specification language. In other words, it’s protobuf on steroids.</p>
<p>There’s two parts of ASN.1: There’s the ASN.1 notation (defined by x.680, x.681, x.682, and x.683), and then there’s the various encodings (BER, CER, DER, PER, XER, JER…). In this post I’ll mainly be focusing on the notation + DER.</p>
<p>Similarly to protobuf you use the notation to define a structured way to represent data, and then use tooling that can generate encoders/decoders for a specific encoding, in a specific programming language.</p>
<p>Here’s a choice snippet of the ASN.1 notation for RFC 5280 (which defines what’s commonly known as TLS certificates):</p>
<div><figure><pre data-language="txt"><code><div><p><span>-- Modules are strongly versioned - something I&#39;ll talk about later!</span></p></div><div><p><span>PKIX1Implicit88 {</span></p></div><div><p><span><span>    </span></span><span>iso(1) identified-organization(3) dod(6) internet(1)</span></p></div><div><p><span><span>    </span></span><span>security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-implicit(19)</span></p></div><div><p><span>} DEFINITIONS IMPLICIT TAGS ::=</span></p></div><div><p><span>BEGIN</span></p></div><div></div><div><p><span>-- Aliases to &#34;built-in&#34; types.</span></p></div><div><p><span>KeyIdentifier ::= OCTET STRING</span></p></div><div></div><div><p><span>-- Compact bitflags</span></p></div><div><p><span>KeyUsage ::= BIT STRING {</span></p></div><div><p><span><span>     </span></span><span>digitalSignature        (0),</span></p></div><div><p><span><span>     </span></span><span>nonRepudiation          (1),  -- recent editions of X.509 have</span></p></div><div><p><span><span>                                </span></span><span>-- renamed this bit to contentCommitment</span></p></div><div><p><span><span>     </span></span><span>keyEncipherment         (2),</span></p></div><div><p><span><span>     </span></span><span>dataEncipherment        (3),</span></p></div><div><p><span><span>     </span></span><span>keyAgreement            (4),</span></p></div><div><p><span><span>     </span></span><span>keyCertSign             (5),</span></p></div><div><p><span><span>     </span></span><span>cRLSign                 (6),</span></p></div><div><p><span><span>     </span></span><span>encipherOnly            (7),</span></p></div><div><p><span><span>     </span></span><span>decipherOnly            (8) }</span></p></div><div></div><div><p><span>-- A struct/class equivalent</span></p></div><div><p><span>PolicyInformation ::= SEQUENCE {</span></p></div><div><p><span><span>     </span></span><span>policyIdentifier   CertPolicyId,</span></p></div><div></div><div><p><span><span>     </span></span><span>-- Types can be given constraints - something I&#39;ll also talk about later!</span></p></div><div><p><span><span>     </span></span><span>policyQualifiers   SEQUENCE (SIZE (1..MAX)) OF PolicyQualifierInfo OPTIONAL</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>-- A pretty clean way of defining unique identifiers</span></p></div><div></div><div><p><span>id-pkix  OBJECT IDENTIFIER  ::=</span></p></div><div><p><span><span>         </span></span><span>{ iso(1) identified-organization(3) dod(6) internet(1)</span></p></div><div><p><span><span>                    </span></span><span>security(5) mechanisms(5) pkix(7) }</span></p></div><div></div><div><p><span>id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }</span></p></div><div><p><span><span>        </span></span><span>-- arc for extended key purpose OIDS</span></p></div><div></div><div><p><span>id-kp-serverAuth             OBJECT IDENTIFIER ::= { id-kp 1 }</span></p></div><div><p><span>id-kp-clientAuth             OBJECT IDENTIFIER ::= { id-kp 2 }</span></p></div><div><p><span>id-kp-codeSigning            OBJECT IDENTIFIER ::= { id-kp 3 }</span></p></div><div><p><span>id-kp-emailProtection        OBJECT IDENTIFIER ::= { id-kp 4 }</span></p></div><div><p><span>id-kp-timeStamping           OBJECT IDENTIFIER ::= { id-kp 8 }</span></p></div><div><p><span>id-kp-OCSPSigning            OBJECT IDENTIFIER ::= { id-kp 9 }</span></p></div><div></div><div><p><span>END</span></p></div></code></pre></figure></div>
<p>Encoding wise here’s a quick of some of the more well known ones:</p>
<ul>
<li>BER - Basic binary encoding rules. Uses a Tag-Length-Value (TLV) format that supports functionally infinite lengths of data.</li>
<li>CER - A limited subset of BER where each value can only have one possible encoding. It uses some odd design choices (such as <em>always</em> using the infinite-length forms of encoded data), so no one really uses it.</li>
<li>DER - A limited subset of BER where each value can only have one possible encoding, but with a more sane choice of decisions made compared to CER. This is used extensively for cryptographic purposes.</li>
<li>PER - A binary encoding that uses contraint information to encode data in the absolute minimum amount of bits possible. There’s also like 4 variations of this one btw.</li>
<li>OER - Similar to PER except it keeps the bytes of values separate, whereas PER can pack the bits of different values together tightly.</li>
<li>XER - An XML based encoding. The ASN.1 notation grammar actually has XML-specific parts to it just for this encoding (because of course it does).</li>
<li>JER - A JSON based encoding.</li>
</ul>
<p>Did I ever mention that ASN.1 is complicated? On the one hand the sheer amount of possible encodings is daunting, but on the other hand it shows a certain flexbility that ASN.1 provides - you could even invent your own domain-specific encoding if needed.</p>
<h2 id="asn1s-notation-can-be-really-complex">ASN.1’s notation can be really complex</h2>
<p>Loosely speaking you can define ASN.1’s notation as being the “base” notation defined in x.680, with the sometimes-optional addon specifications defined in x.681, x.682, x.683.</p>
<p>These specifications are also written in academicese so for mere uneducated mortals such as myself, simply trying to read and understand what the specifications are saying in the first place is already a large hurdle. I <em>think</em> I’ve started to get the hang of it though.</p>
<p>Fortunately for my use case of handling x.509 certificates, there’s no hard requirement for anything beyond x.680 and so x.680 is the only spec I’ve attempted to implement so far (outside of x.690 which describes how BER/CER/DER works - which is actually a <em>joy</em> to read compared to the x.68x specs).</p>
<p>x.680 isn’t the worst thing in the world to implement, it’s just the fact that there’s a <em>lot</em> more to it than you’d think from a quick glance at a code example, as well as some relatively annoying “transformation” (semantic) rules you have to acccount for.</p>
<p>Generally though I’d say the really difficult parts seem to come from its extensions.</p>
<h3 id="x680-woes---historical-deprecations">x.680 woes - historical deprecations</h3>
<p>One of the more annoying parts of implementing a parser for ASN.1’s notation is that x.680 has been revised several times over the years, which includes the deprecation + removal of certain features.</p>
<p>And so some other specifications you read through will either:</p>
<ol>
<li>Use older forms of syntax that are no longer recommended/supported.</li>
<li>Replace the older forms of syntax with newer variants which can be <em>much</em> more complicated to implement.</li>
</ol>
<p>Meaning that if you want to write a compiler for ASN.1 for a specific use case, but want it to also be an implementation of the more modern specs… then you’ll have to partially implement/hack around some of the older stuff that’s no longer defined in the up to date spec documentation.</p>
<p>An example would be the <code>ANY DEFINED BY</code> syntax, which I have a separate section on.</p>
<h3 id="x681">x.681</h3>
<p>This is essentially the academic equivalent of an Elder Scroll - you will go insane attempting to read let alone mentally parse this damn thing.</p>
<p>x.681 describes the Information Class Object system. I’d <em>love</em> to talk to you more about it more in depth but I haven’t put in enough effort to confidently state much about how it works.</p>
<p>One of the few parts I sort of understand and can talk about is that x.681 has a really cool feature where Information Classes can be given a custom initialisation syntax:</p>
<div><figure><pre data-language="txt"><code><div><p><span>-- Given this information class</span></p></div><div><p><span>PERSON ::= CLASS {</span></p></div><div><p><span><span>    </span></span><span>&amp;name UTF8String,</span></p></div><div><p><span><span>    </span></span><span>&amp;age INTEGER DEFAULT 0</span></p></div><div><p><span>}</span></p></div><div><p><span>WITH SYNTAX {</span></p></div><div><p><span><span>    </span></span><span>CALLED &amp;name [WHO IS &amp;age YEARS OLD]</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>-- Can be initialised as either one of these</span></p></div><div><p><span>bradley1 PERSON ::= { CALLED &#34;Bradley&#34; }</span></p></div><div><p><span>bradley2 PERSON ::= { CALLED &#34;Bradley&#34; WHO IS 26 YEARS OLD }</span></p></div></code></pre></figure></div>
<p>I’d absolutely love to attempt to implement x.681 for the challenge of this feature alone, however I only have so much energy (and sanity), so it’ll likely be a while until I even properly consider it.</p>
<h3 id="x682">x.682</h3>
<p>x.682 describes the Table Constraint feature. I’m going to be honest I don’t understand a single thing about this feature - I took one look at the specification and was like “absolutely not”.</p>
<h3 id="x683">x.683</h3>
<p>x.683 describes the ability to create templated (sorry, “parameterised”) types. Similar to the other ASN.1 extensions I haven’t looked much into this feature, but it appears to be a lot simpler to implement than the others.</p>
<p>In essence, one of the things you can do is this:</p>
<div><figure><pre data-language="txt"><code><div><p><span>MyTemplatedThingy{ValueT} ::= SEQUENCE {</span></p></div><div><p><span><span>    </span></span><span>value ValueT</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>MyStringThingy ::= MyTemplatedThingy{UTF8String}</span></p></div></code></pre></figure></div>
<p>It supports values as well as types within its template parameters (similarly to D!) so there’s a few cool things you can do with it I guess.</p>
<h2 id="asn1s-notation-is-also-pretty-cool">ASN.1’s notation is also pretty cool!</h2>
<p>Despite the many, <em>many</em>, <strong>many</strong> pains of this god forsaken technology, it’s actually really interesting and powerful at the same time.</p>
<h3 id="asn1s-constraint-system">ASN.1’s constraint system</h3>
<p>ASN.1’s notation contains a pretty neat feature where you can add special constraints onto types + fields. So rather than having a stray “ProtcolPacket.field1.field2.xyz MUST be between 0 and 2” that’s super easy to miss, you can instead describe this constraint within ASN.1 itself which (good) tooling will then take into account for you.</p>
<p>Here’s some examples of the simpler constraints available:</p>
<div><figure><pre data-language="txt"><code><div><p><span>UInt8 ::= INTEGER (0..255) -- Constrain to a specific range of values</span></p></div><div></div><div><p><span>LegacyFlag ::= INTEGER (0) -- Constrain to a single value</span></p></div><div><p><span>LegacyFlags ::= INTEGER (0 | 2 | 4 | 8) -- You can combine constraints via the UNION (shorthand &#39;|&#39;) operator.</span></p></div><div><p><span>LegacyFlags2 ::= INTEGER (0 | 2 ^ 4..8) -- You can also use the INTERSECTION (shorthand &#39;^&#39;) operator to specify alternatively valid constraints.</span></p></div><div></div><div><p><span>-- You can limit the size of some types</span></p></div><div><p><span>Password ::= UTF8String (SIZE (8..32)) -- Must be between 8 and 32 chars.</span></p></div><div><p><span>NumberList ::= SET SIZE (2..MAX) OF INTEGER -- Must have at least 2 elements, but is otherwise unbounded.</span></p></div></code></pre></figure></div>
<p>There’s a few more constraints available but… they’re mostly pretty complex ones that I don’t want to have to think about.</p>
<p>It’s really cool to see that ASN.1 has a feature like this though, considering the only other langauge I’ve personally encountered that has a similar feature is Ada.</p>
<h3 id="asn1s-versioning-system">ASN.1’s versioning system</h3>
<p>ASN.1 generally uses the <code>OBJECT IDENTIFIER</code> type in order to, well, identify specific things, e.g. extensions found within x.509 certificates.</p>
<p><code>OBJECT IDENTIFIER</code>s are also used to provide versions to modules, for example:</p>
<div><figure><pre data-language="txt"><code><div><p><span>PKIX1Implicit88 {</span></p></div><div><p><span><span>    </span></span><span>iso(1) identified-organization(3) dod(6) internet(1)</span></p></div><div><p><span><span>    </span></span><span>security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-implicit(19)</span></p></div><div><p><span>} DEFINITIONS IMPLICIT TAGS ::= BEGIN -- .. -- END</span></p></div></code></pre></figure></div>
<p>Everything between the curly brackets is an OBJECT IDENTIFIER for this exact module - technically no other ASN.1 module in existance should ever use this specific OBJECT IDENTIFIER. The optional labels (e.g. <code>iso</code>) have no meaning beyond aiding human comprehension, it’s the values (e.g. <code>(0)</code>) that are actually used to create the identifier.</p>
<p>As a great example of this versioning system, it just so happens that this specific module has a more modern version that has this specific OBJECT IDENTIFIER instead:</p>
<div><figure><pre data-language="txt"><code><div><p><span>PKIX1Implicit-2009</span></p></div><div><p><span><span>    </span></span><span>{iso(1) identified-organization(3) dod(6) internet(1) security(5)</span></p></div><div><p><span><span>    </span></span><span>mechanisms(5) pkix(7) id-mod(0) id-mod-pkix1-implicit-02(59)}</span></p></div><div><p><span>DEFINITIONS IMPLICIT TAGS ::= BEGIN -- .. -- END</span></p></div></code></pre></figure></div>
<p>This updated version doesn’t change how data is encoded to/from DER but instead it simply uses more modern syntax and features.</p>
<p>This is important because older specifications will be using <code>PKIX1Implicit88</code> whereas newer ones will likely be using <code>PKIX1Implicit-2009</code> instead, and so there needs to be a more clear-cut way to distinguish between these two versions of the <code>PKIX1Implicit</code> module other than going by its name - and this is where OBJECT IDENTIFIERS come in handy.</p>
<p>When importing modules within ASN.1 notation you can (and should) specify an OBJECT IDENTIFIER as well:</p>
<div><figure><pre data-language="txt"><code><div><p><span>-- There&#39;s 0 room for ambiguity or naming clashes when OBJECT IDENTIFIERs come into play</span></p></div><div><p><span>IMPORTS</span></p></div><div><p><span><span>    </span></span><span>id-pkix FROM PKIX1Implicit88 {</span></p></div><div><p><span><span>        </span></span><span>iso(1) identified-organization(3) dod(6) internet(1)</span></p></div><div><p><span><span>        </span></span><span>security(5) mechanisms(5) pkix(7) id-mod(0) id-pkix1-implicit(19)</span></p></div><div><p><span><span>    </span></span><span>},</span></p></div><div><p><span><span>    </span></span><span>SignatureAlgs FROM PKIX1Implicit-2009 {</span></p></div><div><p><span><span>        </span></span><span>iso(1) identified-organization(3) dod(6) internet(1) security(5)</span></p></div><div><p><span><span>        </span></span><span>mechanisms(5) pkix(7) id-mod(0) id-mod-pkix1-implicit-02(59)</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>;</span></p></div></code></pre></figure></div>
<p>Maybe I’m just a nerd, but I find this to almost be a thing of beauty with how simple yet effective it is.</p>
<h2 id="d-is-easy-to-generate-code-for">D is easy to generate code for</h2>
<p>D has several quality of life features that makes it surprisingly easy to generate code for - features that would definitely make the compiler more annoying to work with when targeting other languages.</p>
<p>These features on their own aren’t exactly rare to see, but the specific combination is what makes everything work together so well.</p>
<h3 id="static-imports--fully-qualified-names">Static imports &amp; fully qualified names</h3>
<p><code>static import</code> in D means “import this module, but ONLY allow it to be used via its fully qualified name”:</p>
<div><figure><pre data-language="d"><code><div><p><span>static import</span><span> </span><mark><span>std.stdio</span></mark><span>;</span></p></div><div></div><div><p><span>// Good!</span></p></div><div><p><mark><span>std.stdio</span></mark><span>.writeln</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>);</span></p></div><div></div><div><p><span>// Bad!</span></p></div><div><p><span>writeln</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>);</span></p></div></code></pre></figure></div>
<p>You can even override the module name, as strange as that sounds!</p>
<div><figure><pre data-language="d"><code><div><p><span>static import</span><span> </span><mark><span>io</span><span> </span></mark><span>= </span><span>std.stdio</span><span>;</span></p></div><div></div><div><p><mark><span>io.</span></mark><span>writeln</span><span>(</span><span>&#34;Hello, world!&#34;</span><span>);</span></p></div></code></pre></figure></div>
<p>This feature is a godsend for preserving the original names of ASN.1 types. For example, Juptune provides an error type called <code>Result</code> which comes from the <code>juptune.core.util.result</code> module.</p>
<p>Without static imports I’d have to be careful of ASN.1 code that defines a <code>Result</code> type as it’d otherwise come into conflict with Juptune’s own <code>Result</code> type.</p>
<p>However, with static imports, I can basically just generate code that looks like this:</p>
<div><figure><pre data-language="d"><code><div><p><span>static import</span><span> </span><span>jres</span><span> = </span><span>juptune.core.util.result</span><span>;</span></p></div><div></div><div><p><span>// From ASN.1 definition: Result ::= SEQUENCE { -- yada yada -- }</span></p></div><div><p><span>struct</span><span> </span><span>Result</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><mark><span>jres.Result</span></mark><span> </span><span>set</span><span>(</span><span>/*...*/</span><span>) </span><span>@nogc</span><span> </span><span>nothrow</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>/*...*/</span></p></div><div><p><span>        </span><span>return</span><span> </span><mark><span>jres.Result</span></mark><span>.noError</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Completely removing the need of me having to worry about symbol name conflicts.</p>
<h3 id="module-local-lookups">Module-local lookups</h3>
<p>On a similar vein D allows you to specify that instead of looking up a symbol from any available symbol table (e.g. local vars; non-static imports, etc.) it should instead perform a lookup using the current module’s top-level symbols.</p>
<p>For example:</p>
<div><figure><pre data-language="d"><code><div><p><span>/* Given this ASN.1 notation:</span></p></div><div></div><div><p><span><span>    </span></span><span>Type1 ::= SEQUENCE { -- yada yada -- }</span></p></div><div><p><span><span>    </span></span><span>Type2 ::= SEQUENCE { type2 Type2 }</span></p></div><div><p><span>*/</span></p></div><div></div><div><p><span>// The following types are generated</span></p></div><div></div><div><p><span>struct</span><span> </span><span>Type1</span><span> { </span><span>/* yada yada */</span><span> }</span></p></div><div></div><div><p><span>struct</span><span> </span><span>Type2</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span><span>        </span></span><mark><span>.</span><span>Type1</span></mark><span> </span><span>_type1</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>The leading <code>.</code> in <code>.Type1</code> is what causes the module-local lookup.</p>
<p>Essentially, this feature compliments the static import feature to help make it much harder for ASN.1 types to accidentally refer to the wrong symbol when converted into D code.</p>
<h3 id="typeof">typeof()</h3>
<p>In short: this feature allowed me to be <em>really really</em> lazy with certain parts of the compiler :D</p>
<p>As the name suggests, <code>typeof()</code> allows you to retrieve the type of any particular symbol you pass into it - this is great when dealing with code generation since sometimes it can be <em>kind of annoying</em> to structure your code in a way where you can easily preserve the type name of some symbol you’re working with.</p>
<p>In other words “this let’s me write bad code and make it still work”.</p>
<p>First example is around how some getters and setters for SEQEUENCE fields are generated. Instead of doing the correct thing and preserving the type name for each field, I got lazy and just used <code>typeof(_field)</code>:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Heavily omitted example</span></p></div><div><p><span>struct</span><span> </span><span>Dss_Parms</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>asn1.Asn1Integer</span><span> </span><span>_p</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>jres.Result</span><span> </span><span>setP</span><span>(</span><mark><span>typeof(</span><span>_p</span><span>)</span></mark><span> </span><span>value</span><span>) </span><span>@nogc</span><span> </span><span>nothrow</span></p></div><div><p><span><span>    </span></span><span>{ </span><span>/* .. */</span><span> }</span></p></div><div></div><div><p><span>    </span><mark><span>typeof(</span><span>_p</span><span>)</span></mark><span> </span><span>getP</span><span>() </span><span>@nogc</span><span> </span><span>nothrow</span></p></div><div><p><span><span>    </span></span><span>{ </span><span>/* .. */</span><span> }</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>The second example is around error messages. Instead of needing to keep track of the current type’s name when generating error messages… I could just use <code>typeof(this)</code> to get the type instead:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Heavily omitted example</span></p></div><div><p><span>struct</span><span> </span><span>Dss_Parms</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>jres.Result</span><span> </span><span>fromDecoding</span><span>(</span><span>/* .. */</span><span>) </span><span>@nogc</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>/* .. */</span></p></div><div><p><span>        </span><span>result</span><span> </span><span>=</span><span> </span><span>asn1.asn1DecodeComponentHeader</span><span>!</span><span>ruleset</span><span>(</span><span>memory</span><span>,</span><span> </span><span>componentHeader</span><span>);</span></p></div><div><p><span>        </span><span>if</span><span>(</span><span>result.isError</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>return</span><span> </span><span>result.wrapError</span><span>(</span></p></div><div><p><span>                </span><span>&#34;when decoding header of field &#39;p&#39; in type &#34;</span></p></div><div><p><span>                </span><span>~__traits(</span><span>identifier</span><span>,</span><span> </span><span>typeof(this))</span></p></div><div><p><span>                </span><span>~</span><span>&#34;:&#34;</span></p></div><div><p><span><span>            </span></span><span>);</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span>        </span><span>/* .. */</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>What’s <em>even better</em> is that because the entire string is composed of compile-time constants, it doesn’t actually require an allocation + concat at runtime since the compiler will constant fold it for you. This allows <code>fromDecoding</code> to still be marked as <code>@nogc</code>!</p>
<h3 id="d-allows-trailing-commas-in-almost-every-context">D allows trailing commas in almost every context</h3>
<p>Generating a parameter list and don’t want to have to care about whether there’s an extra comma or not?</p>
<div><figure><pre data-language="d"><code><div><p><span>// Trailing commas are allowed!</span></p></div><div><p><span>void</span><span> </span><span>func</span><span>(</span><span>int</span><span> </span><span>param1</span><span>,</span><span> </span><span>int</span><span> </span><span>param</span><mark><span>2</span><span>,</span><span>)</span></mark></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>func</span><span>(</span><span>1</span><span>,</span><span> </span><mark><span>2</span><span>,</span><span>)</span></mark><span>;</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Enum options?</p>
<div><figure><pre data-language="d"><code><div><p><span>enum</span><span> </span><span>Choice</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>_FAILSAFE</span><span>,</span></p></div><div><p><span>    </span><span>specified</span><span>,</span></p></div><div><p><span>    </span><span>otherSource</span><span>,</span></p></div><div><p><span>    </span><span>stillCompile</span><mark><span>s</span><span>,</span></mark></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Array values?</p>
<div><figure><pre data-language="d"><code><div><p><span>static</span><span> </span><span>immutable</span><span> </span><span>ubyte</span><span>[] </span><span>mainValue__value</span><span> </span><span>=</span><span> [</span></p></div><div><p><span>    </span><span>14</span><span>,</span><span> </span><span>3</span><span>,</span><span> </span><span>2</span><span>,</span><span> </span><span>2</span><mark><span>6</span><span>,</span></mark></p></div><div><p><span>]</span></p></div></code></pre></figure></div>
<p>D’s got your back! (Except for specifying multiple modules in a single import statement, then for some reason you’re not allowed, but shh about that).</p>
<h3 id="utilise-metaprogramming-so-your-compiler-can-stay-dumbpoorly-made">Utilise metaprogramming so your compiler can stay dumb/poorly made</h3>
<p>For a while a lot of the types being generated (and some of the core decoding types) didn’t have a <code>toString</code> implementation. This’d normally mean that I couldn’t just use <code>.toString</code> willy-nilly but instead the compiler would need knowledge about which types had a <code>toString</code> or not.</p>
<p>However, as is the common theme now D allows us to be very lazy - instead of keeping track of this ourselves in dasn1, we can instead just generate code where it’s the D compiler’s concern instead of our’s:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Heavily omitted</span></p></div><div><p><span>struct</span><span> </span><span>Dss_Parms</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>void</span><span> </span><span>toString</span><span>(</span><span>SinkT</span><span>)(</span><span>scope</span><span> </span><span>SinkT</span><span> </span><span>sink</span><span>,</span><span> </span><span>int</span><span> </span><span>depth</span><span> </span><span>=</span><span> </span><span>0</span><span>,</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>/* .. */</span></p></div><div><p><span>        </span><span>static if(__traits(</span><span>hasMember</span><span>,</span><span> </span><span>typeof(</span><span>_p</span><span>),</span><span> </span><span>&#34;toString&#34;</span><span>))</span></p></div><div><p><span>            </span><span>_p.toString</span><span>(</span><span>sink</span><span>,</span><span> </span><span>depth</span><span>+</span><span>1</span><span>);</span></p></div><div><p><span>        </span><span>else</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>putIndent</span><span>();</span></p></div><div><p><span>            </span><span>sink</span><span>(</span><span>&#34;&lt;no toString impl&gt;</span><span>\n</span><span>&#34;</span><span>);</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span>        </span><span>/* .. */</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Job sorted (and future proofed!).</p>
<p>You could definitely utilise D’s metaprogramming for more complicated stuff, but it’s also good for silly little things like this.</p>
<h2 id="interesting-d-specific-parts-of-the-implementation">Interesting D-specific parts of the implementation</h2>
<p>Naturally I’ve tried to use whatever D features that I could in order to implement dasn1, so I thought I’d pick a few parts of the code that rely on D’s features quite heavily as a small showcase.</p>
<h3 id="mixin-templates-for-ast-nodes">Mixin templates for AST nodes</h3>
<p>Mixin templates are a fairly quirky feature of D - it allows you to define a normal template (essentially a compile-time collection of symbols) and then copy-paste them wherever you like, whether that’s inside a class, struct, the top-level module etc.</p>
<p>Since the ASN.1 grammar only had a handful of node “types”, I decided to use mixin templates to model each specific “type”:</p>
<div><figure><pre data-language="d"><code><div><p><span>// I&#39;ve included the mixin template for the `List` type in its entirety, plus a few nodes that reference other mixin templates not shown.</span></p></div><div><p><span>// This is just to give a general idea on how it all works, without diving into many details.</span></p></div><div></div><div><p><span>private</span><span> </span><span>mixin template</span><span> </span><span>List</span><span>(</span><span>Asn1NodeType</span><span> </span><span>MyType</span><span>,</span><span> </span><span>ItemT</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>juptune.core.ds</span><span> : </span><span>Array</span><span>;</span></p></div><div></div><div><p><span>    </span><span>enum</span><span> </span><span>_MustBeDtored</span><span> </span><span>=</span><span> </span><span>true</span><span>; </span><span>// A compile-time flag that some other metaprogramming in the compiler uses to handle memory management!</span></p></div><div></div><div><p><span>    </span><span>private</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>Array</span><span>!</span><span>ItemT</span><span> </span><span>_items</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>@nogc</span><span> </span><span>nothrow</span><span>:</span></p></div><div></div><div><p><span>    </span><span>this</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>super</span><span>(</span><span>MyType</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>ref</span><span> </span><span>typeof(</span><span>_items</span><span>)</span><span> </span><span>items</span><span>() </span><span>=&gt;</span><span> </span><span>this</span><span>._items</span><span>;</span></p></div><div></div><div><p><span>    </span><span>override</span><span> </span><span>void</span><span> </span><span>dispose</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>this._items.__xdtor</span><span>();</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div><div></div><div></div><div><p><span>/++</span></p></div><div><p><span><span>    </span></span><span>DefinitiveObjIdComponentList ::=</span></p></div><div><p><span><span>        </span></span><span>DefinitiveObjIdComponent</span></p></div><div><p><span><span>        </span></span><span>| DefinitiveObjIdComponent DefinitiveObjIdComponentList</span></p></div><div><p><span><span> </span></span><span>++/</span></p></div><div><p><span>final</span><span> </span><span>class</span><span> </span><span>Asn1DefinitiveObjIdComponentListNode</span><span> : </span><span>Asn1BaseNode</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>mixin</span><span> </span><span>List</span><span>!(</span><span>Asn1NodeType.DefinitiveObjIdComponentList</span><span>,</span><span> </span><span>Asn1DefinitiveObjIdComponentNode</span><span>);</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>/++</span></p></div><div><p><span><span>    </span></span><span>ModuleDefinition ::=</span></p></div><div><p><span><span>        </span></span><span>ModuleIdentifier</span></p></div><div><p><span><span>        </span></span><span>DEFINITIONS</span></p></div><div><p><span><span>        </span></span><span>TagDefault</span></p></div><div><p><span><span>        </span></span><span>ExtensionDefault</span></p></div><div><p><span><span>        </span></span><span>&#34;::=&#34;</span></p></div><div><p><span><span>        </span></span><span>BEGIN</span></p></div><div><p><span><span>        </span></span><span>ModuleBody</span></p></div><div><p><span><span>        </span></span><span>END</span></p></div><div><p><span><span> </span></span><span>++/</span></p></div><div><p><span>final</span><span> </span><span>class</span><span> </span><span>Asn1ModuleDefinitionNode</span><span> : </span><span>Asn1BaseNode</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>mixin</span><span> </span><span>Container</span><span>!(</span><span>Asn1NodeType.ModuleDefinition</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ModuleIdentifierNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1TagDefaultNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ExtensionDefaultNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ModuleBodyNode</span><span>,</span></p></div><div><p><span><span>    </span></span><span>);</span></p></div><div><p><span>}</span></p></div><div></div><div><p><span>/++</span></p></div><div><p><span><span>    </span></span><span>DefinitiveIdentifier ::=</span></p></div><div><p><span><span>        </span></span><span>&#34;{&#34; DefinitiveObjIdComponentList &#34;}&#34;</span></p></div><div><p><span><span>        </span></span><span>| empty</span></p></div><div><p><span><span> </span></span><span>++/</span></p></div><div><p><span>final</span><span> </span><span>class</span><span> </span><span>Asn1DefinitiveIdentifierNode</span><span> : </span><span>Asn1BaseNode</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>mixin</span><span> </span><span>OneOf</span><span>!(</span><span>Asn1NodeType.DefinitiveIdentifier</span><span>,</span></p></div><div><p><span>        </span><span>Asn1DefinitiveObjIdComponentListNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1EmptyNode</span><span>,</span></p></div><div><p><span><span>    </span></span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>I probably could’ve gotten away with just using templated base classes instead, but there’s a few differences that actually make that kind of annoying. Namely it’d create some bloated symbol names which would make reading compiler errors even more painful than it already ended up being.</p>
<h3 id="templates-can-provide-really-natural-apis-while-still-catching-errors-at-compile-time">Templates can provide really natural APIs while still catching errors at compile time</h3>
<p>Let’s look at one of the AST nodes again:</p>
<div><figure><pre data-language="d"><code><div><p><span>final</span><span> </span><span>class</span><span> </span><span>Asn1ModuleDefinitionNode</span><span> : </span><span>Asn1BaseNode</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>mixin</span><span> </span><span>Container</span><span>!(</span><span>Asn1NodeType.ModuleDefinition</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ModuleIdentifierNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1TagDefaultNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ExtensionDefaultNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ModuleBodyNode</span><span>,</span></p></div><div><p><span><span>    </span></span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This is a node that contains several other nodes. <code>Container</code> itself supports an unbounded amount of node types it can store, since D supports variadic template parameters. You may be asking what the API for this even looks like, and I’ll be glad to show you a quick snippet:</p>
<div><figure><pre data-language="d"><code><div><p><span>Asn1ModuleDefinitionNode</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>/* parse from somewhere */</span><span>;</span></p></div><div></div><div><p><span>// We don&#39;t have to work with named functions when we can just work with types!</span></p></div><div><p><span>auto</span><span> </span><span>tagDefault</span><span>   </span><span>=</span><span> </span><span>node.getNode</span><span>!</span><span>Asn1TagDefaultNode</span><span>;</span></p></div><div><p><span>auto</span><span> </span><span>modReference</span><span> </span><span>=</span><span> </span><span>node.getNode</span><span>!</span><span>Asn1ModuleIdentifierNode</span></p></div><div><p><span><span>                        </span></span><span>.</span><span>getNode</span><span>!</span><span>Asn1ModuleReferenceTokenNode</span><span>;</span></p></div><div></div><div><p><span>// Since each `Container` node knows what types are available, it can catch errors at compile time still.</span></p></div><div><p><span>node.getNode</span><span>!</span><span>Asn1EmptyNode</span><span>; </span><span>// Error: &#34;Invalid node type: Asn1EmptyNode&#34;</span></p></div></code></pre></figure></div>
<p>Let’s have a look at a <code>OneOf</code> node instead now:</p>
<div><figure><pre data-language="d"><code><div><p><span>/++</span></p></div><div><p><span><span>    </span></span><span>TagDefault ::=</span></p></div><div><p><span><span>        </span></span><span>EXPLICIT TAGS</span></p></div><div><p><span><span>        </span></span><span>| IMPLICIT TAGS</span></p></div><div><p><span><span>        </span></span><span>| AUTOMATIC TAGS</span></p></div><div><p><span><span>        </span></span><span>| empty</span></p></div><div><p><span><span> </span></span><span>++/</span></p></div><div><p><span>final</span><span> </span><span>class</span><span> </span><span>Asn1TagDefaultNode</span><span> : </span><span>Asn1BaseNode</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>mixin</span><span> </span><span>OneOf</span><span>!(</span><span>Asn1NodeType.TagDefault</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ExplicitTagsNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1ImplicitTagsNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1AutomaticTagsNode</span><span>,</span></p></div><div><p><span>        </span><span>Asn1EmptyNode</span><span>,</span></p></div><div><p><span><span>    </span></span><span>);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This node has a similar template-based API for most of its operations:</p>
<div><figure><pre data-language="d"><code><div><p><span>// It generates a constructor for each possible type.</span></p></div><div><p><span>// Pretend the `cast(xyz)null`s are actually constructed objects.</span></p></div><div><p><span>auto</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>new </span><span>Asn1TagDefaultNode</span><span>(</span><span>cast(</span><span>Asn1ExplicitTagsNode</span><span>)</span><span>null</span><span>); </span><span>// Node is for EXPLICIT TAGS</span></p></div><div><p><span>     </span><span>node</span><span> </span><span>=</span><span> </span><span>new </span><span>Asn1TagDefaultNode</span><span>(</span><span>cast(</span><span>Asn1ImplicitTagsNode</span><span>)</span><span>null</span><span>); </span><span>// Node is for IMPLICIT TAGS</span></p></div><div></div><div><p><span>// General getter/checker functions.</span></p></div><div><p><span>bool</span><span> </span><span>_</span><span>                 </span><span>=</span><span> </span><span>node.isNode</span><span>!</span><span>Asn1ImplicitTagsNode</span><span>;</span></p></div><div><p><span>Asn1ImplicitTagsNode</span><span> </span><span>_</span><span> </span><span>=</span><span> </span><span>node.asNode</span><span>!</span><span>Asn1ImplicitTagsNode</span><span>; </span><span>// Runtime error if the node isn&#39;t storing an `Asn1ImplicitTagsNode`</span></p></div><div><p><span>Asn1ImplicitTagsNode</span><span> </span><span>_</span><span> </span><span>=</span><span> </span><span>node.maybeNode</span><span>!</span><span>Asn1ImplicitTagsNode</span><span>; </span><span>// Null if the node isn&#39;t storing an `Asn1ImplicitTagsNode`</span></p></div></code></pre></figure></div>
<p>However the main feature of the <code>OneOf</code> node is its <code>match</code> function. This function requires the user to pass in a handler function for each possible node type that the <code>OneOf</code> can store, and this requirement is enforced at compile-time so that changes to the node type list will immediately require all appropriate <code>match</code> functions to be updated (i.e. no silent breakage).</p>
<p>This is surprisingly easy to implement with D due to its first-class metaprogramming features, I’ll try my best to be brief with how this all works:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Relatively well omitted</span></p></div><div><p><span>private</span><span> </span><span>mixin template</span><span> </span><span>OneOf</span><span>(</span></p></div><div><p><span>    </span><span>Asn1NodeType</span><span> </span><span>MyType</span><span>,</span></p></div><div><p><span>    </span><span>NodeTypes</span><span>...</span></p></div><div><p><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>private</span><span> </span><span>int</span><span> </span><span>_oneOfIndex</span><span> </span><span>=</span><span> </span><span>-</span><span>1</span><span>;</span></p></div><div></div><div><p><span>    </span><span>private</span><span> </span><span>template</span><span> </span><span>oneOfHandlerFuncTuple</span><span>()</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.meta</span><span> : </span><span>staticMap</span><span>;</span></p></div><div></div><div><p><span>        </span><span>alias</span><span> </span><span>ToFuncHandler</span><span>(</span><span>alias</span><span> </span><span>NodeT</span><span>) </span><span>=</span><span> </span><span>Result</span><span> </span><span>delegate</span><span>(</span><span>NodeT</span><span>) </span><span>@nogc</span><span> </span><span>nothrow</span><span>;</span></p></div><div><p><span>        </span><span>alias</span><span> </span><span>oneOfHandlerFuncTuple</span><span> </span><span>=</span><span> </span><span>staticMap</span><span>!(</span><span>ToFuncHandler</span><span>,</span><span> </span><span>NodeTypes</span><span>);</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>Result</span><span> </span><span>match</span><span>(</span><span>scope</span><span> </span><span>oneOfHandlerFuncTuple</span><span>!</span><span>() </span><span>handlers</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>switch</span><span>(</span><span>this</span><span>._oneOfIndex</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>static foreach</span><span>(</span><span>i</span><span>,</span><span> </span><span>NodeT</span><span>;</span><span> </span><span>NodeTypes</span><span>)</span></p></div><div><p><span><span>            </span></span><span>{</span></p></div><div><p><span>                </span><span>case</span><span> </span><span>i</span><span>:</span></p></div><div><p><span>                    </span><span>return</span><span> </span><span>handlers</span><span>[</span><span>i</span><span>](</span><span>this</span><span>.asNode</span><span>!</span><span>NodeT</span><span>);</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div></div><div><p><span>            </span><span>default</span><span>:</span></p></div><div><p><span>                </span><span>assert(</span><span>false</span><span>,</span><span> </span><span>&#34;bug: oneOfIndex isn&#39;t a valid value?&#34;</span><span>)</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>In essence:</p>
<ul>
<li><code>NodeTypes...</code> is the template parameter containing a compile-time tuple of all possible types that this <code>OneOf</code> can store.</li>
<li><code>oneOfHandlerFuncTuple</code> is a template that generates a new compile-time tuple, where each <code>NodeTypes</code> is mapped into a function pointer type.</li>
<li><code>match</code> uses the result of <code>oneOfHandlerFuncTuple</code> as its main parameter. Since this is a compile-time tuple of types it automagically gets expanded into multiple parameters under the hood.</li>
<li><code>static foreach</code> within <code>match</code>’s body allows us to iterate over a compile-time collection (in this case, <code>NodeTypes</code>) and duplicate the foreach’s body for each item. In this case, so we can make a <code>case</code> statement per item in <code>NodeTypes</code>.</li>
</ul>
<p>So:</p>
<ul>
<li>If <code>NodeTypes...</code> is <code>(Node1, Node2)</code>.</li>
<li><code>oneOfHandlerFuncTuple</code> results in <code>(Result delegate(Node1), Result delegate(Node2))</code></li>
<li>And <code>match</code>’s parameters expand into <code>match(scope delegate(Node1) handler_0, scope delegate(Node2) handler_1)</code></li>
</ul>
<p><em>Which means</em> that we could use this example match function like so:</p>
<div><figure><pre data-language="d"><code><div><p><span>ExampleOneOf</span><span> </span><span>node</span><span>;</span></p></div><div><p><span>node.match</span><span>(</span></p></div><div><p><span><span>    </span></span><span>(</span><span>Node1</span><span> </span><span>child</span><span>){ </span><span>return</span><span> </span><span>Result.noError</span><span>; }</span><span>,</span></p></div><div><p><span><span>    </span></span><span>(</span><span>Node2</span><span> </span><span>child</span><span>){ </span><span>return</span><span> </span><span>Result.noError</span><span>; }</span><span>,</span></p></div><div><p><span>);</span></p></div></code></pre></figure></div>
<p>I know that’s a lot to take in especially since I have to be briefer than usual, but TL;DR D makes the hard stuff easy while still being relatively easy on the eyes. I would make a snarky comparison with C++ but literally no one expects C++ metaprogramming to be readable at this point.</p>
<h3 id="d-snark-the-forever-experimental-allocator-package">D Snark: The forever-experimental allocator package</h3>
<p>10 years ago (October 2015) D’s standard library was given an experimental package called <code>std.experimental.allocator</code>. It has a pretty neat but kind of janky way of composing a bunch of allocation building blocks together, in order to “easily” make custom allocators.</p>
<p>I use it for the ASN.1 stuff since it makes it easy to construct and dispose classes within <code>@nogc</code> code, and it looks kind of cool to boot:</p>
<div><figure><pre data-language="d"><code><div><p><span>import</span><span> </span><span>std.experimental.allocator.mallocator</span><span>                        : </span><span>Mallocator</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.experimental.allocator.building_blocks.allocator_list</span><span>    : </span><span>AllocatorList</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.experimental.allocator.building_blocks.region</span><span>            : </span><span>Region</span><span>;</span></p></div><div><p><span>import</span><span> </span><span>std.experimental.allocator.building_blocks.stats_collector</span><span>   : </span><span>StatsCollector</span><span>,</span><span> </span><span>Stats</span><span> = </span><span>Options</span><span>;</span></p></div><div></div><div><p><span>private</span><span> </span><span>alias</span><span> </span><span>NodeAllocator</span><span> </span><span>=</span><span> </span><span>StatsCollector</span><span>!(</span></p></div><div><p><span>    </span><span>AllocatorList</span><span>!(</span></p></div><div><p><span><span>        </span></span><span>(</span><span>n</span><span>) </span><span>=&gt;</span><span> </span><span>Region</span><span>!</span><span>Mallocator</span><span>(</span><span>1024</span><span> </span><span>*</span><span> </span><span>1024</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>Mallocator</span></p></div><div><p><span><span>    </span></span><span>)</span><span>,</span></p></div><div><p><span>    </span><span>Stats.bytesAllocated</span></p></div><div><p><span>);</span></p></div></code></pre></figure></div>
<p>The issue is this package is still experimental 10 years later and I wouldn’t be surprised if it gets removed sooner or later, especially with the Phobos v2 work that’ll hopefully exist in some form before I retire (I’m 26).</p>
<p>:D The sign of someone who loves this damn language is that they can’t help but provide some level of historical snark. I have no further comments, I just miss the days I had hope for D’s future xD</p>
<h3 id="alias-this---a-very-occasionally-useful-feature">alias this - a very occasionally useful feature</h3>
<p>Situation: I need to store IR nodes using a base class rather than a specific concrete implementation class, but I’d still like to limit the potential options without having to go down the SumType route.</p>
<p>Solution: This short but sweet struct (note: this is a different <code>OneOf</code> struct for IR purposes, not AST purposes).</p>
<div><figure><pre data-language="d"><code><div><p><span>private</span><span> </span><span>struct</span><span> </span><span>OneOf</span><span>(</span><span>BaseIrT</span><span> : </span><span>Asn1BaseIr</span><span>,</span><span> </span><span>IrTypes</span><span>...) </span><span>// @suppress(dscanner.suspicious.incomplete_operator_overloading)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>import</span><span> </span><span>std.meta</span><span> : </span><span>anySatisfy</span><span>;</span></p></div><div></div><div><p><span>    </span><span>BaseIrT</span><span> </span><span>ir</span><span>;</span></p></div><div><p><span>    </span><span>alias</span><span> </span><span>ir</span><span> </span><span>this</span><span>;</span></p></div><div></div><div><p><span>    </span><span>this</span><span>(</span><span>IrT</span><span> : </span><span>BaseIrT</span><span>)(</span><span>IrT</span><span> </span><span>ir</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>enum</span><span> </span><span>ErrorMsg</span><span> </span><span>=</span><span> </span><span>&#34;Invalid IR node was passed in. Is not one of: &#34;</span><span>~</span><span>IrTypes.stringof</span><span>;</span></p></div><div><p><span>        </span><span>static if(is(</span><span>IrT</span><span> </span><span>==</span><span> </span><span>BaseIrT</span><span>))</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>static foreach</span><span>(</span><span>TargetIrT</span><span>;</span><span> </span><span>IrTypes</span><span>)</span></p></div><div><p><span><span>            </span></span><span>{</span></p></div><div><p><span>                </span><span>if</span><span>(</span><span>auto</span><span> </span><span>casted</span><span> </span><span>=</span><span> </span><span>cast(</span><span>TargetIrT</span><span>)</span><span> </span><span>ir</span><span>)</span></p></div><div><p><span><span>                </span></span><span>{</span></p></div><div><p><span>                    </span><span>this</span><span>.ir</span><span> </span><span>=</span><span> </span><span>ir</span><span>;</span></p></div><div><p><span>                    </span><span>return</span><span>;</span></p></div><div><p><span><span>                </span></span><span>}</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div><p><span>            </span><span>assert(</span><span>false</span><span>,</span><span> </span><span>ErrorMsg</span><span>)</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span>        </span><span>else</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>enum</span><span> </span><span>isInputT</span><span>(</span><span>T</span><span>) </span><span>=</span><span> </span><span>is(</span><span>T</span><span> </span><span>==</span><span> </span><span>IrT</span><span>)</span><span>;</span></p></div><div><p><span>            </span><span>static assert(</span><span>anySatisfy</span><span>!</span><span>(</span><span>isInputT</span><span>,</span><span> </span><span>IrTypes</span><span>)</span><span>,</span><span> </span><span>ErrorMsg</span><span>)</span><span>;</span></p></div><div><p><span>            </span><span>this</span><span>.ir</span><span> </span><span>=</span><span> </span><span>ir</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>We can initialise this struct like so:</p>
<div><figure><pre data-language="d"><code><div><p><span>alias</span><span> </span><span>ItemT</span><span> </span><span>=</span><span> </span><span>OneOf</span><span>!(</span><span>Asn1BaseIr</span><span>,</span><span> </span><span>Asn1ValueReferenceIr</span><span>,</span><span> </span><span>Asn1TypeReferenceIr</span><span>);</span></p></div><div></div><div><p><span>auto</span><span> </span><span>item</span><span> </span><span>=</span><span> </span><span>ItemT</span><span>(</span><span>cast(</span><span>Asn1ValueReferenceIr</span><span>)</span><span>null</span><span>); </span><span>// Fine (if we ignore it&#39;s null for this example)</span></p></div><div><p><span>auto</span><span> </span><span>item</span><span> </span><span>=</span><span> </span><span>ItemT</span><span>(</span><span>cast(</span><span>Asn1ImportsIr</span><span>)</span><span>null</span><span>); </span><span>// Not fine - compile-time error since we know the original type already</span></p></div><div></div><div><p><span>Asn1BaseIr</span><span> </span><span>ir</span><span> </span><span>=</span><span> </span><span>cast(</span><span>Asn1ValueReferenceIr</span><span>)</span><span>null</span><span>; </span><span>// Pretend its not null</span></p></div><div><p><span>auto</span><span> </span><span>item</span><span> </span><span>=</span><span> </span><span>ItemT</span><span>(</span><span>ir</span><span>); </span><span>// Fine - it looks like an Asn1BaseIr so we have to dynamically cast it at runtime to perform the type check, which passes.</span></p></div><div></div><div><p><span>Asn1BaseIr</span><span> </span><span>ir</span><span> </span><span>=</span><span> </span><span>cast(</span><span>Asn1ImportsIr</span><span>)</span><span>null</span><span>;</span></p></div><div><p><span>auto</span><span> </span><span>item</span><span> </span><span>=</span><span> </span><span>ItemT</span><span>(</span><span>ir</span><span>); </span><span>// Runtime error - dynamic casting failed.</span></p></div></code></pre></figure></div>
<p>Now the fun part comes from this weird <code>alias ir this;</code> line. Normally when working with a wrapper struct like this you’d have do something like:</p>
<div><figure><pre data-language="d"><code><div><p><span>ItemT</span><span> </span><span>item</span><span>;</span></p></div><div><p><span>if</span><span>(</span><span>Asn1ValueReferenceIr</span><span> </span><span>casted</span><span> </span><span>=</span><span> </span><span>cast(</span><span>Asn1ValueReferenceIr</span><span>)</span><span>item.getWrappedIrNode</span><span>())</span></p></div><div><p><span>{ </span><span>/* .. */</span><span> }</span></p></div></code></pre></figure></div>
<p>With <code>alias ir this;</code> anytime we try to perform an operation (e.g. casting; function calls, etc.) that the <code>OneOf</code> struct itself does not support, the compiler will instead try to use it on the <code>OneOf.ir</code> field instead:</p>
<div><figure><pre data-language="d"><code><div><p><span>alias</span><span> </span><span>ItemT</span><span> </span><span>=</span><span> </span><span>OneOf</span><span>!(</span><span>Asn1BaseIr</span><span>,</span><span> </span><span>Asn1ValueReferenceIr</span><span>,</span><span> </span><span>Asn1TypeReferenceIr</span><span>);</span></p></div><div><p><span>auto</span><span> </span><span>item</span><span> </span><span>=</span><span> </span><span>/* ... */</span><span>;</span></p></div><div></div><div><p><span>// Since `OneOf` doesn&#39;t overload the `opCast`, the following would normally fail.</span></p></div><div><p><span>cast(</span><span>Asn1ValueReferenceIr</span><span>)</span><span>item</span><span>; </span><span>// -&gt; item.opCast!Asn1ValueReferenceIr wouldn&#39;t work since its not overloaded by OneOf.</span></p></div><div></div><div><p><span>// The compiler sees the `alias ir this`, and so tries casting that instead.</span></p></div><div><p><span>cast(</span><span>Asn1ValueReferenceIr</span><span>)</span><span>item.ir</span><span>; </span><span>// This now works!</span></p></div></code></pre></figure></div>
<p>It’s a very weird, niche feature which might even get removed or at least deprecated in the future, but it allows for some mild syntax cleanup as shown above.</p>
<h3 id="versionunittest">version(unittest)</h3>
<p>Some of the IR types try to strictly limit the way that user code can query and interact with their data, mainly to help prevent potential memory corruption… at least that was my original, flawed reasoning.</p>
<p>This can be <em>awkward</em> when writing unittests, as sometimes you just need to query a very particular part of a type’s data without having to go through all of its hurdles.</p>
<p>And so by simply slapping <code>version(unittest)</code> onto a funciton definition, you now have an escape hatch that won’t make its way out into real code:</p>
<div><figure><pre data-language="d"><code><div><p><span>// Only compiles when unittests are also compiled.</span></p></div><div><p><span>version(unittest)</span><span> </span><span>IrT</span><span> </span><span>getByName</span><span>(</span><span>IrT</span><span> : </span><span>Asn1ValueIr</span><span>)(</span><span>const</span><span>(</span><span>char</span><span>)[] </span><span>name</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>return</span><span> </span><span>cast(</span><span>IrT</span><span>)</span><span>this</span><span>._namedBits</span><span>[</span><span>name</span><span>];</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<h3 id="templates--with--terse-ish-test-harnesses">Templates + with() = terse-ish test harnesses</h3>
<p>There’s a few examples of this within the codebase. Sometimes unittests are for the most part identical except:</p>
<ul>
<li>They need to tweak a few types here and there.</li>
<li>They need an “initialiser” function that returns a different type from other unittests.</li>
<li>They need to change what the function-to-be-tested is (and thus what some of the types being used are).</li>
<li>Sometimes the test case type itself needs to have a few types changed.</li>
<li>Everything else is the same though between unittests - it’s mainly just types getting in the way.</li>
</ul>
<p>It’s one of those things where you kind of just have to use it and do it before you “get it”, so I apologise for the really poor explanation, but this is essentially something you can do with templates.</p>
<p>Here’s one of the templated “test harnesses” I used - this one in particular is for testing the AST -&gt; IR converter functions.</p>
<div><figure><pre data-language="d"><code><div><p><span>private</span><span> </span><span>template</span><span> </span><span>GenericTestHarness</span><span>(</span><span>NodeToIrT</span><span>,</span><span> </span><span>ActualIrT</span><span>,</span><span> </span><span>alias</span><span> </span><span>ParseFunc</span><span>,</span><span> </span><span>alias</span><span> </span><span>Converter</span><span> </span><span>=</span><span> </span><span>asn1AstToIr</span><span>)</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>static</span><span> </span><span>struct</span><span> </span><span>T</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>string</span><span> </span><span>input</span><span>;</span></p></div><div><p><span>        </span><span>Asn1SemanticError</span><span> </span><span>expectedError</span><span>;</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div></div><div><p><span>    </span><span>void</span><span> </span><span>run</span><span>(</span><span>T</span><span>[</span><span>string</span><span>] </span><span>cases</span><span>)</span></p></div><div><p><span><span>    </span></span><span>{</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.conv</span><span>   : </span><span>to</span><span>;</span></p></div><div><p><span>        </span><span>import</span><span> </span><span>std.traits</span><span> : </span><span>EnumMembers</span><span>;</span></p></div><div><p><span>        </span><span>foreach</span><span>(</span><span>name</span><span>,</span><span> </span><span>test</span><span>;</span><span> </span><span>cases</span><span>)</span></p></div><div><p><span><span>        </span></span><span>{</span></p></div><div><p><span>            </span><span>try</span></p></div><div><p><span><span>            </span></span><span>{</span></p></div><div><p><span>                </span><span>/* .. */</span></p></div><div><p><span>                </span><span>auto</span><span> </span><span>node</span><span> </span><span>=</span><span> </span><span>ParseFunc</span><span>(</span><span>parser</span><span>);</span></p></div><div></div><div><p><span>                </span><span>NodeToIrT</span><span> </span><span>irFromNode</span><span>;</span></p></div><div><p><span>                </span><span>auto</span><span> </span><span>result</span><span> </span><span>=</span><span> </span><span>Converter</span><span>(</span><span>node</span><span>,</span><span> </span><span>irFromNode</span><span>,</span><span> </span><span>context</span><span>,</span><span> </span><span>Asn1NullErrorHandler.instance</span><span>);</span></p></div><div><p><span>                </span><span>/* .. */</span></p></div><div><p><span><span>            </span></span><span>}</span></p></div><div><p><span>            </span><span>catch</span><span>(</span><span>Throwable</span><span> </span><span>err</span><span>) </span><span>// @suppress(dscanner.suspicious.catch_em_all)</span></p></div><div><p><span>                </span><span>assert(</span><span>false</span><span>,</span><span> </span><span>&#34;</span><span>\n</span><span>[&#34;</span><span>~</span><span>name</span><span>~</span><span>&#34;]:</span><span>\n</span><span>&#34;</span><span>~</span><span>err.msg</span><span>)</span><span>;</span></p></div><div><p><span><span>        </span></span><span>}</span></p></div><div><p><span><span>    </span></span><span>}</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>It can be used like so:</p>
<div><figure><pre data-language="d"><code><div><p><span>@(</span><span>&#34;Asn1Ir - one off edge cases&#34;</span><span>)</span></p></div><div><p><span>unittest</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>alias</span><span> </span><span>Harness</span><span> </span><span>=</span><span> </span><span>GenericTestHarness</span><span>!(</span><span>Asn1ModuleIr</span><span>,</span><span> </span><span>Asn1ModuleIr</span><span>,</span><span> (</span><span>ref</span><span> </span><span>parser</span><span>){</span></p></div><div><p><span>        </span><span>Asn1ModuleDefinitionNode</span><span> </span><span>node</span><span>;</span></p></div><div><p><span>        </span><span>parser.ModuleDefinition</span><span>(</span><span>node</span><span>).</span><span>resultAssert</span><span>;</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>node</span><span>;</span></p></div><div><p><span><span>    </span></span><span>});</span></p></div><div></div><div><p><span>    </span><span>Harness.run</span><span>([</span></p></div><div><p><span>        </span><span>&#34;ensure that default values can lookup type-scoped references&#34;</span><span>: </span><span>Harness.T</span><span>(</span><span>`</span></p></div><div><p><span><span>            </span></span><span>Unittest DEFINITIONS ::= BEGIN</span></p></div><div><p><span><span>                </span></span><span>I ::= INTEGER { v1(0) }</span></p></div><div><p><span><span>                </span></span><span>S ::= SEQUENCE {</span></p></div><div><p><span><span>                    </span></span><span>i I DEFAULT v1</span></p></div><div><p><span><span>                </span></span><span>}</span></p></div><div><p><span><span>            </span></span><span>END</span></p></div><div><p><span><span>        </span></span><span>`</span><span>,</span><span> </span><span>Asn1SemanticError.none</span><span>)</span><span>,</span></p></div><div><p><span><span>    </span></span><span>]);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>One main issue, especially for the larger tests, is that specifying <code>Harness.T</code> (and more minorly <code>Harness.run</code>) can start to make the code look chunky and a bit harder to read.</p>
<p>So by using the magical <code>with()</code> statement, instead of writing <code>Harness.run</code> and <code>Harness.T</code>, we can just write <code>run</code> and <code>T</code> and the compiler will know how to lookup these otherwise missing/undefined symbols:</p>
<div><figure><pre data-language="d"><code><div><p><span>@(</span><span>&#34;Constraints - ensuring value references are handled&#34;</span><span>)</span></p></div><div><p><span>unittest</span></p></div><div><p><span>{</span></p></div><div><p><span>    </span><span>alias</span><span> </span><span>Harness</span><span> </span><span>=</span><span> </span><span>GenericTestHarness</span><span>!(</span><span>Asn1ModuleIr</span><span>,</span><span> </span><span>Asn1ModuleIr</span><span>,</span><span> (</span><span>ref</span><span> </span><span>parser</span><span>){</span></p></div><div><p><span>        </span><span>Asn1ModuleDefinitionNode</span><span> </span><span>node</span><span>;</span></p></div><div><p><span>        </span><span>parser.ModuleDefinition</span><span>(</span><span>node</span><span>).</span><span>resultAssert</span><span>;</span></p></div><div><p><span>        </span><span>return</span><span> </span><span>node</span><span>;</span></p></div><div><p><span><span>    </span></span><span>});</span></p></div><div></div><div><p><span>    </span><span>with</span><span>(</span><span>Harness</span><span>) </span><span>run</span><span>([</span></p></div><div><p><span>        </span><span>&#34;BIT STRING - SingleValue&#34;</span><span>: </span><span>T</span><span>(</span><span>`</span></p></div><div><p><span><span>            </span></span><span>Unittest DEFINITIONS ::= BEGIN</span></p></div><div><p><span><span>                </span></span><span>v BIT STRING ::= &#39;01&#39;H</span></p></div><div><p><span><span>                </span></span><span>B ::= BIT STRING (v)</span></p></div><div><p><span><span>                </span></span><span>b B ::= &#39;01&#39;H</span></p></div><div><p><span><span>            </span></span><span>END</span></p></div><div><p><span><span>        </span></span><span>`</span><span>,</span><span> </span><span>Asn1SemanticError.none</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>&#34;BIT STRING - Size - SingleValue&#34;</span><span>: </span><span>T</span><span>(</span><span>`</span></p></div><div><p><span><span>            </span></span><span>Unittest DEFINITIONS ::= BEGIN</span></p></div><div><p><span><span>                </span></span><span>a INTEGER ::= 4</span></p></div><div><p><span><span>                </span></span><span>B ::= BIT STRING (SIZE (a))</span></p></div><div><p><span><span>                </span></span><span>b B ::= &#39;0&#39;H</span></p></div><div><p><span><span>            </span></span><span>END</span></p></div><div><p><span><span>        </span></span><span>`</span><span>,</span><span> </span><span>Asn1SemanticError.none</span><span>)</span><span>,</span></p></div><div></div><div><p><span>        </span><span>&#34;BIT STRING - Size - ValueRange&#34;</span><span>: </span><span>T</span><span>(</span><span>/* .. */</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>&#34;BOOLEAN - SingleValue&#34;</span><span>: </span><span>T</span><span>(</span><span>/* .. */</span><span>)</span><span>,</span></p></div><div><p><span>        </span><span>/* .. */</span></p></div><div><p><span><span>    </span></span><span>]);</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>Again this is one of those things that on paper sounds really stupid (and impossible to easily describe), but grows on you really fast when you give it a try.</p>
<h2 id="pain-points">Pain points</h2>
<p>While ASN.1’s basic syntax looks pretty easy from an initial glance, that illusion shatters once you start getting into it more deeply.</p>
<h3 id="value-sequence-syntax">Value sequence syntax</h3>
<p>ASN.1 has various separate value forms that start with a left bracket (<code>{</code>), a lot of these forms are ambiguous due to a variety of factors and can only be distinguished with semantic context.</p>
<p>Given that dans1 has a clean split between syntax and semantic analysis, “this does not spark joy” as the kids would say.</p>
<p>I’ll let this comment from the parser code explain itself:</p>
<div><figure><pre data-language="d"><code><div><p><span>// If a left parenthesis shows up directly after any identifier, then it&#39;s an OBJECT IDENTIFIER sequence,</span></p></div><div><p><span>// as no other sequence-looking value syntax allows for NameAndNumberForm.</span></p></div><div><p><span>//      { iso-yada(123) }</span></p></div><div><p><span>//      { iso-yada-123 asn1(123) }</span></p></div><div><p><span>//</span></p></div><div><p><span>// If no commas show up and there&#39;s only 1 value, then it&#39;s ambiguous, so will default to</span></p></div><div><p><span>// a ValueList.</span></p></div><div><p><span>//      { my-integer }</span></p></div><div><p><span>//</span></p></div><div><p><span>// (Values in the form of `a { yada }` are ambiguous between a named Sequence value and a</span></p></div><div><p><span>//  parameterised value)</span></p></div><div><p><span>//</span></p></div><div><p><span>// If no commas show up and there&#39;s 1 ambiguous value, then assume it&#39;s a NamedValueList.</span></p></div><div><p><span>//      { iso-yada-123 asn1 }</span></p></div><div><p><span>//</span></p></div><div><p><span>// If a comma is found; multiple non-named values exist, and any number</span></p></div><div><p><span>// of ambiguous values exist then it&#39;s a ValueList.</span></p></div><div><p><span>//      { my, value }</span></p></div><div><p><span>//      { my, ambiguous {} }</span></p></div><div><p><span>//</span></p></div><div><p><span>// If a comma is found, and only ambiguous values exists, assume it&#39;s a NamedValueList.</span></p></div><div><p><span>//      { ambiguous {} }</span></p></div><div><p><span>//      { ambiguous {}, twobiguous {} }</span></p></div><div><p><span>//</span></p></div><div><p><span>// If a comma is found, and any amount of non-ambiguous named values exist, it&#39;s a NamedValueList.</span></p></div><div><p><span>//      { ambiguous {}, except this }</span></p></div><div><p><span>//</span></p></div><div><p><span>// DefinedValue allows for a ParameterizedValue, which uses `{}` to define parameters,</span></p></div><div><p><span>// so we need to keep track of whether we&#39;re in a parameter list or not and ignore everything inside one.</span></p></div><div><p><span>//      { some { template, params }, here }</span></p></div><div><p><span>//</span></p></div><div><p><span>// This loop also keeps track of how many identifiers show up side-by-side, but it&#39;s</span></p></div><div><p><span>// currently (and probably never) needed as a way to sort out ambiguity.</span></p></div><div><p><span>//</span></p></div><div><p><span>// Semantic Analysis will perform the rest of the validation, e.g. sometimes what looks like a</span></p></div><div><p><span>// NamedValueList is also a valid OBJECT IDENTIFIER sequence, so type information will be used to</span></p></div><div><p><span>// clear up ambiguity.</span></p></div></code></pre></figure></div>
<p>:D Fun times.</p>
<h3 id="its-hard-to-find-important-info-in-the-specs">It’s hard to find important info in the specs</h3>
<p>Example: I can’t even remember the exact conditions, but I remember having to debug some generated decoder code since it was failing to decode a specific field. It turned out that this field was under certain “exact conditions” that meant its tag was supposed to be treated as <code>EXPLICIT</code> instead of the module-default <code>IMPLICIT</code>.</p>
<p>I still have <em>no</em> idea where in the spec this behaviour gets mentioned and so I basically had to wing a fix and hope it works going forward.</p>
<p>More generally this feeling and scenario has happened quite a few times - the information is scattered (sometimes across different specs) and is hard to keep track of.</p>
<p>Another example is around module versions. The spec makes absolutely zero mention (that I can see) on how to version modules for non ISO/ITU purposes, and I would greatly appreciate if anyone could help me find this information.</p>
<p>I’d be amazed if there’s a 100% spec compliant implementation out there, even commercially.</p>
<h3 id="you-need-to-implement-constraints-3-separate-times">You need to implement constraints 3 separate times</h3>
<ol>
<li>The first implementation is to type-check constraints, e.g. <code>UTF8String (SIZE (&#34;yagababa&#34;))</code> doesn’t make sense.</li>
<li>The second implementation is to confirm that ASN.1 notation values are correct, e.g. <code>myInt INTEGER (1) ::= 2</code> needs to trigger an error.</li>
<li>The third implementation is to generate runtime checks when you generate code from the ASN.1 notation.</li>
</ol>
<p>It’s tedious and not very fun, but there’s no real way around it.</p>
<p>For a newbie to compiler programming like me I also found it really hard to deal with useful error messages. I ended up running the checks twice: one time to see if there’s even an error at all, and the second time to build up the error string. This is mainly complicated by the existance of UNION and (especially) INTERSECTION constraints.</p>
<h3 id="the-dream-of-immutable-ir-nodes">The dream of immutable IR nodes</h3>
<p>I foolishly made the mistake of believing that once I converted the generic AST nodes into the more specific IR nodes that I wouldn’t have to make any major changes to the underlying data (beyond setting up things like symbol tables).</p>
<p>:D Unfortunately that wonderfully naive thought was quickly crushed as ASN.1 requires the semantic stage to perform certain transformations, certain transformations (e.g. <code>AUTOMATIC TAGS</code>) that ended up/are going to be really annoying due to the way I’ve structured the code.</p>
<p>But that’s future Brad’s problem.</p>
<h3 id="asn1-has-an-all-or-nothing-level-of-complexity">ASN.1 has an all-or-nothing level of complexity</h3>
<p>I am <strong>extremely</strong> thankful that x.509 is an old enough specification that the ASN.1 notation only uses the older syntax of x.680.</p>
<p>The alternative is that you’d <em>need</em> an implementation of the x.681, x.682, and x.683 specs to use any of the newer stuff - this is absolutely non-trivial to implement, and I imagine this is one of the many reasons ASN.1 hasn’t ever really taken off outside of historical and commercialised spaces.</p>
<h3 id="any-defined-by">ANY DEFINED BY</h3>
<p>There is one exception to the above however and that is <code>ANY DEFINED BY</code>.</p>
<p>It’d basically be used to define a type who’s contents could be <em>any other type</em> conditioned by some other field:</p>
<div><figure><pre data-language="txt"><code><div><p><span>Extension ::= SEQUENCE {</span></p></div><div><p><span><span>    </span></span><span>extension-type OBJECT IDENTIFIER,</span></p></div><div><p><span><span>    </span></span><span>extension-value ANY DEFINED BY extension-type</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>You then have to piece together what identifier matches which type. Dasn1 doesn’t actually implement <code>ANY DEFINED BY</code> as-is since even by the 2003 revision it was deprecated.</p>
<p>Instead, for better or for worse, dasn1 has a hacked together intrinsic called <code>Dasn1-Any</code>:</p>
<div><figure><pre data-language="txt"><code><div><p><span>-- Small snippet from https://github.com/Juptune/juptune/blob/master/data/asn1/rfc5280-explicit.asn1</span></p></div><div><p><span>-- (yeah the module version is super messed up, I&#39;ll fix it eventually)</span></p></div><div><p><span>IMPORTS</span></p></div><div><p><span><span>      </span></span><span>Dasn1-Any FROM Dasn1-Intrinsics { iso(0) custom(0) dasn1(1) intrinsics(0) }</span></p></div><div><p><span>;</span></p></div><div></div><div><p><span>AttributeTypeAndValue   ::= SEQUENCE {</span></p></div><div><p><span><span>        </span></span><span>type    AttributeType,</span></p></div><div><p><span><span>        </span></span><span>value   Dasn1-Any</span></p></div><div><p><span>}</span></p></div></code></pre></figure></div>
<p>This essentially gets lowered down into the decoding code for <code>OCTET STRING</code> but without any sort of tag validation enabled. Unfortunately until/unless I want to implement Information Object Classes, I’m then stuck with having to manually call into the decoding code when I want to turn <code>Dans1-Any</code> fields into their actual types.</p>
<h3 id="i-cant-retain-all-the-information-i-need-to-know">I can’t retain all the information I need to know</h3>
<p>This is more of a personal one.</p>
<p>Between the various different aspects of the ASN.1 compiler, the x.68x specs, the x.690 spec, and all of the other projects building off of this ASN.1 work (x.509 certificate handling, TLS 1.3) I started to feel like a stranger in my own codebase, even just a week after I had last touched it.</p>
<p>It’ll definitely be interesting making future improvements/changes as my at-hand knowledge is constantly dwindling.</p>
<h2 id="writing-a-compiler-is-tedious-work">Writing a compiler is tedious work</h2>
<p>From having to write 20,000 different node visitors for various reasons; to hand-rolling a syntax parser for a boring, drawn out grammar; to needing to write code that looks 95% the same as the last but that last 5% of difference ranges from drudge to mentally taxing, repeated 9000 times.</p>
<p>I think I can finally say I have some proper compiler experience under my belt ;(</p>
<p>But lord knows that each and every milestone has been so extremely rewarding (as long as I try not to think about the fact that almost no one will be using this code).</p>
<p>p.s. Don’t try to make a template-based parser combinator for the entire grammar of a language you don’t personally control unless you want to see symbol names that are 10Mb+ long and explode the binary size by over 100Mb. Don’t ask me how I know.</p>
<p>(I even hard crashed the D compiler I use once, since I guess the error message was literally too long. That endlessly scrolling console…)</p>
<h2 id="conclusion">Conclusion</h2>
<p>A <em>probably</em> wasted year of my life later and there’s still an insane amount of work left on everything relating to this project (and Juptune) in general, but I think it’s making me a better programmer. Maybe.</p>
<p>The dream is that one day I can put “made an ASN.1 compiler + x.509 certificate handler + TLS 1.3 implementation” on my CV and still get told “sorry, you’re a good match except you don’t have 6 months of production experience in Ansible, we can’t hire you” by a recruiter. God I love this industry.</p>
<p>Don’t do ASN.1 kids, you’ll never be the same.</p> <section> <a href="https://bradley.chatha.dev/blog/dlang-propaganda">  </a> </section>  </section>  </div></div>
  </body>
</html>
