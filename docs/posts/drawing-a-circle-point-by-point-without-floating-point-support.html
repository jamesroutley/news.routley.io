<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://yurichev.com/news/20220322_circle/">Original</a>
    <h1>Drawing a circle, point-by-point, without floating point support</h1>
    
    <div id="readability-page-1" class="page">
<img src="https://x.od.ua/tracker/dot.php" referrerpolicy="unsafe-url"/>


<!-- blog post begin -->

<p>
Now we need to add a circle to <a href="https://yurichev.com/news/20220321_sin_cos_clock/">our clock</a>.
</p>

<p>
Circle is defined by Pythagorean theorem: $x^2 + y^2 = r^2$, where $x$ and $y$ -- coordinates on plain and $r$ is radius.
</p>

<h3>Naive algorithm</h3>

<p>
So let&#39;s draw it!
Enumerate all points in 0..radius range and find &#34;height&#34; for each point.
Height will be $\sqrt{r^2 - y^2}$
We will draw only a quadrant, i.e., $\frac{1}{4}$ of the circle:
</p>

<pre>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;style&gt;
      #my-canvas { border: 1px solid gray; }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id=&#34;my-canvas&#34; width=&#34;600&#34; height=&#34;600&#34;&gt;&lt;/canvas&gt;
    &lt;script&gt;

      var canvas = document.querySelector(&#39;#my-canvas&#39;);
      var context = canvas.getContext(&#39;2d&#39;);
      var half_width = canvas.width/2;
      var half_height = canvas.height/2;
      // clock is slightly smaller than canvas:
      var clock_radius = Math.min(half_width, half_height)*0.85;

      function putPixel(x, y)
      {
	  context.fillRect(x+half_width, y+half_height, 1, 1);
      };

      function circle()
      {
	  // x^2 + y^2 = radius^2
	  // x^2 = radius^2 - y^2
	  // x=sqrt(radius^2 - y^2)
	  for (x=0; x&lt;clock_radius; x++)
	  {
	      var y=Math.sqrt(clock_radius*clock_radius - x**2);
	      putPixel(x, y);
	  }
      };

      circle();

    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<img src="https://yurichev.com/news/20220322_circle/quadrant_1.png"/>

<p>
Ouch! This arc looks correct, but the points at right-bottom are &#34;dispersed&#34;.
</p>

<p>
The common way is to draw only octant ($\frac{1}{8}$) of a circle and then &#34;copy&#34; the octant 7 times more.
But to draw a 45Â° angle (or $\frac{\Pi}{4}$) you have to use some trigonometry.
</p>

<pre>      function circle()
      {
          // Pi/4 = octant. find a point on x where octant is ended:
          var octant_limit = clock_radius * Math.cos(Math.PI/4);

          for (x=0; x&lt;octant_limit; x++)
          {
              var y=Math.sqrt(clock_radius*clock_radius - x**2);
              putPixel(x, y);
          }
      };
</pre>

<p>
Looks nice:
</p>

<img src="https://yurichev.com/news/20220322_circle/octant_1.png"/>

<p>
Now copy it 7 more times:
</p>

<pre>          for (x=0; x&lt;octant_limit; x++)
          {
              var y=Math.sqrt(clock_radius*clock_radius - x**2);
              putPixel(x, y);
              // copy our octant 7 times:
              putPixel(x, -y);
              putPixel(-x, y);
              putPixel(-x, -y);

              putPixel(y, x);
              putPixel(y, -x);
              putPixel(-y, x);
              putPixel(-y, -x);
          }
</pre>

<img src="https://yurichev.com/news/20220322_circle/octant_full.png"/>

<h3>Midpoint circle algorithm</h3>

<p>
Naive algorithm is correct, but it requires at least one &#34;heavy&#34; operation -- square root.
</p>

<p>
Here I will rework my algorithm a bit:
</p>

<pre>      function circle(x0, y0, radius)
      {
          // starting point:
          var x = radius;
          var y = 0;

          while (x &gt;= y)
          {
              // main octant:
              putPixel(x0 + x, y0 + y);
              // copy octant 7 times:
              putPixel(x0 + y, y0 + x);
              putPixel(x0 - y, y0 + x);
              putPixel(x0 - x, y0 + y);
              putPixel(x0 - x, y0 - y);
              putPixel(x0 - y, y0 - x);
              putPixel(x0 + y, y0 - x);
              putPixel(x0 + x, y0 - y);

              y=y+1;
              var new_radius=Math.sqrt(x**2 + y**2).toFixed(); // also convert to int
              // we check here if the &#39;new radius&#39; becomes too big
              // if so, decrease $x$
              // we do this to maintain the equation x^2 + y^2 = r^2 (for integer arithmetic)
              if (new_radius&gt;radius)
                  x=x-1;
          }
      };
</pre>

<img src="https://yurichev.com/news/20220322_circle/midpoint_1.png"/>

<p>
We &#34;maintain&#34; the equation here.
If radius becomes too big, we get &#34;stray&#34; point back, so that it will always lay on circle&#39;s edge.
</p>

<p>
And this algorithm has also square root operation.
</p>

<p>
Please note -- we recalculate &#34;new_radius&#34; at each iteration.
Can we &#34;update&#34; that value rather than scratching from start?
&#34;Adjust&#34; it?
</p>

<p>
Yes, if we know a bits of calculus.
<a href="https://yurichev.com/news/20220322_calculus_eng/">I described it earlier</a>.
Instead of recalculating $x^2$ each time, we can add derivative to some temporary variable: $2x + 1$.
</p>

<p>
The function will be different now:
</p>

<pre>      function circle(x0, y0, radius)
      {
          // starting point:
          var x = radius;
          var y = 0;

          var current_radius_squared = radius**2;

          while (x &gt;= y)
          {
              // main octant:
              putPixel(x0 + x, y0 + y);
              // copy octant 7 times:
              putPixel(x0 + y, y0 + x);
              putPixel(x0 - y, y0 + x);
              putPixel(x0 - x, y0 + y);
              putPixel(x0 - x, y0 - y);
              putPixel(x0 - y, y0 - x);
              putPixel(x0 + y, y0 - x);
              putPixel(x0 + x, y0 - y);

              // increase $y$ and update $current_radius$
              y += 1;
              current_radius_squared += 2*y + 1;

              // if $current_radius$ is bigger than $radius$, decrease $x$ and update $current_radius$ again
              // we do this to maintain the equation x^2 + y^2 = r^2 (for integer arithmetic)
              if (current_radius_squared &gt; radius**2)
              {
                  x -= 1;
                  current_radius_squared -= 2*x + 1;
              }
          }
      };
</pre>

<p>
Please note: we don&#39;t maintain current radius anymore. We maintain it in &#34;squared&#34; form.
current_radius_squared is always equals to the $x^2 + y^2$ expression.
</p>

<p>
So if in the expression $x^2 + y^2$, $x$ is increased by 1, just add $2x + 1$ to it.
If decreased by 1, subtract.
No need to calculate power(s).
</p>

<p>
Also, since we precomputed $r^2$ value at start, we can use at as &#34;reference&#34; value.
</p>

<p>
Isn&#39;t it cool to apply some calculus to a real-life problem?
</p>

<p>
The third version is merely an optimization.
Here we don&#39;t maintain current radius, we maintain only error or difference between radius-we-have and radius-must-be.
</p>

<p>
This version is highly popular and you&#39;ll find it when googling for the midpoint circle algorithm.
</p>

<pre>      function circle(x0, y0, radius)
      {
          // starting point:
          var x = radius;
          var y = 0;

          var err = 0;

          while (x &gt;= y)
          {
              // main octant:
              putPixel(x0 + x, y0 + y);
              // copy octant 7 times:
              putPixel(x0 + y, y0 + x);
              putPixel(x0 - y, y0 + x);
              putPixel(x0 - x, y0 + y);
              putPixel(x0 - x, y0 - y);
              putPixel(x0 - y, y0 - x);
              putPixel(x0 + y, y0 - x);
              putPixel(x0 + x, y0 - y);

              // increase $y$ and update $err$
              y += 1;
              err += 2*y + 1;

              // if $err$ is bigger than zero, decrease $x$ and update $err$ again
              // we do this to maintain the equation x^2 + y^2 - r^2 = 0 (for integer arithmetic)
              if (err &gt; 0)
              {
                  x -= 1;
                  err -= 2*x + 1;
              }
          }
      };
</pre>

<p>
The final optimized version is cool. It requires only additions, subtractions and bit shifts: $2x$ is the same as x&lt;&lt;1, of course.
It also requires only integer arithmetic.
</p>

<p>
Summary: many explanations of midpoint algorithm use the final, optimized version.
But I added several unoptimized steps.
</p>

<p>
There are couple of blog posts I read to better understanding.
<a href="https://web.archive.org/web/20120422045142/https://banu.com/blog/7/drawing-circles/">Mukund Sivaraman</a>,
<a href="https://www.thecrazyprogrammer.com/2016/12/bresenhams-midpoint-circle-algorithm-c-c.html">Neeraj Mishra</a>.
</p>

<hr/>

<p>
As seen at <a href="https://lobste.rs/s/gxtcgs/drawing_circle_point_by_point_without">lobste.rs</a>,
<a href="https://news.ycombinator.com/item?id=30787020">HN</a>.
</p>

<!-- blog post end -->

<p><img src="https://yurichev.com/tmp/dot.png?body_20220322_circle"/></p>

<!-- blog footer begin -->
<hr/>
<p>
<a href="https://yurichev.com/news/">List of my other blog posts.</a>
<a href="https://torus.company/">My company.</a>
</p>





<!-- blog footer end -->




</div>
  </body>
</html>
