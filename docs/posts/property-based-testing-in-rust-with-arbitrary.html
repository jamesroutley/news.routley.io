<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>James Routley | Feed</title>
    <link
      rel="stylesheet"
      type="text/css"
      href="../styles.css"
      media="screen"
    />
  </head>
  <body>
    <a href="/index.html">Back</a>
    <a href="https://www.greyblake.com/blog/property-based-testing-in-rust-with-arbitrary/">Original</a>
    <h1>Property-Based Testing in Rust with Arbitrary</h1>
    
    <div id="readability-page-1" class="page"><article>
        
        <span> Sergey Potapov<span> </span> October 21, 2022<span> </span> #<a href="https://www.greyblake.com/tags/rust/">rust</a>  #<a href="https://www.greyblake.com/tags/testing/">testing</a>  #<a href="https://www.greyblake.com/tags/arbitrary/">arbitrary</a>  #<a href="https://www.greyblake.com/tags/fuzzing/">fuzzing</a> </span>

    <p>In my opinion, <a rel="noopener" target="_blank" href="https://crates.io/crates/arbitrary">arbitrary</a> is one of the most underrated Rust crates.
What is so special about it?
It provides the <a rel="noopener" target="_blank" href="https://crates.io/crates/arbitrary">Arbitrary</a> trait.
If a type implements <code>Arbitrary</code>, then a value of that type can be obtained from <a rel="noopener" target="_blank" href="https://docs.rs/arbitrary/latest/arbitrary/struct.Unstructured.html"><code>Unstructured</code></a>, which is essentially just a sequence of bytes.</p>
<p>This is a foundation for fuzz testing in the Rust ecosystem. Whilst fuzzing is not a common practice for every project,
<code>Arbitrary</code> can be also used for property-based testing.</p>
<h2 id="property-based-testing-vs-fuzzing">Property-based testing VS fuzzing</h2>
<p>Property-based testing and fuzzing have the same idea behind them: generate random structured input
and feed it to software aiming to make it break or behave incorrectly.
However, fuzzing is generally a <em>black-box</em> testing method and can last for very long (e.g. months), while property-based tests
rather belong to a unit test suite and may run for a fraction of second.</p>
<p>I find that property-based testing in some situations can be a very good replacement for classical unit tests,
when we need to test symmetrical data conversion, like:</p>
<ul>
<li>Serialization and deserializaiton</li>
<li>Converting between domain models and DTOs</li>
<li>Converting between domain models and persistence layer (database records).</li>
</ul>
<h2 id="introduction-to-the-problem">Introduction to the problem</h2>
<p>Let&#39;s say we have a domain model <code>Vehicle</code> defined as the following:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>Vehicle</span> </span><span><span><span>{</span>
    <span>id</span><span>:</span> VehicleId,
    <span>vehicle_type</span><span>:</span> VehicleType,
</span><span><span>}</span></span></span>

<span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>VehicleId</span></span><span><span><span>(</span><span>i32</span></span><span>)</span></span><span>;</span>

<span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>enum</span> <span>VehicleType</span> <span><span>{</span>
    Car <span><span>{</span>
        fuel<span>:</span> Fuel<span>,</span>
        max_speed_kph<span>:</span> <span><span>Option</span><span>&lt;</span><span>u32</span><span>&gt;</span></span><span>,</span>
    </span><span><span>}</span></span><span>,</span>
    Bicycle<span>,</span>
</span><span><span>}</span></span></span>

<span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>enum</span> <span>Fuel</span> <span><span>{</span>
    Electricity<span>,</span>
    Diesel<span>,</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>A vehicle can be either a car or a bicycle; a car has fuel associated with it and an optional maximum speed in kilometers per hour.</p>
<p>If we want to store a such model in a relational database like PostgreSQL, we&#39;d need to convert it into a flat structure, that resembles a record in the database:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>VehicleRecord</span> </span><span><span><span>{</span>
    <span>id</span><span>:</span> <span>i32</span>,

        <span>kind</span><span>:</span> String,

        <span>fuel</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>String</span><span>&gt;</span></span>,

            <span>max_speed_kph</span><span>:</span> <span><span>Option</span><span>&lt;</span><span>i32</span><span>&gt;</span></span>,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>And we&#39;ll need the functions for bidirectional conversion between <code>Vehicle</code> and <code>VehicleRecord</code>.</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>vehicle_to_record</span></span><span><span><span>(</span><span>vehicle</span><span>:</span> Vehicle</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> VehicleRecord</span> </span><span><span><span>{</span>
    <span>let</span> Vehicle <span><span>{</span> id <span>,</span> vehicle_type </span><span><span>}</span></span> <span>=</span> vehicle<span>;</span>
    <span>let</span> <span><span>(</span>kind<span>,</span> fuel<span>,</span> max_speed_kph</span><span><span>)</span></span> <span>=</span> <span>match</span> vehicle_type <span><span>{</span>
        <span>VehicleType<span>::</span></span>Car <span><span>{</span> fuel<span>,</span> max_speed_kph </span><span><span>}</span></span> <span>=&gt;</span> <span><span>{</span>
            <span><span>(</span>
                <span><span>&#34;</span>Car<span>&#34;</span></span><span>.</span><span>to_owned</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
                <span>Some</span><span><span>(</span><span>fuel_to_str</span><span><span>(</span>fuel</span><span><span>)</span></span><span>.</span><span>to_owned</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>,</span>
                max_speed_kph<span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>speed</span><span>|</span></span> </span><span>speed<span>.</span><span>try_into</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span> </span></span><span><span>)</span></span>
            </span><span><span>)</span></span>
        </span><span><span>}</span></span>
        Bicycle <span>=&gt;</span> <span><span>{</span>
            <span><span>(</span>
                <span><span>&#34;</span>Bicycle<span>&#34;</span></span><span>.</span><span>to_owned</span><span><span>(</span></span><span><span>)</span></span><span>,</span>
                <span>None</span><span>,</span>
                <span>None</span><span>,</span>
            </span><span><span>)</span></span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span><span>;</span>
    <span>let</span> id <span>=</span> id<span>.</span><span>0</span><span>;</span>
    VehicleRecord <span><span>{</span> id<span>,</span> kind<span>,</span> fuel<span>,</span> max_speed_kph </span><span><span>}</span></span>
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>record_to_vehicle</span></span><span><span><span>(</span><span>record</span><span>:</span> VehicleRecord</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> Vehicle</span> </span><span><span><span>{</span>
    <span>let</span> VehicleRecord <span><span>{</span> id<span>,</span> kind<span>,</span> fuel<span>,</span> max_speed_kph </span><span><span>}</span></span> <span>=</span> record<span>;</span>
    <span>let</span> id <span>=</span> VehicleId<span><span>(</span>id</span><span><span>)</span></span><span>;</span>
    <span>let</span> vehicle_type <span>=</span> <span>match</span> kind<span>.</span><span>as_str</span><span><span>(</span></span><span><span>)</span></span> <span><span>{</span>
        <span><span>&#34;</span>Car<span>&#34;</span></span> <span>=&gt;</span> <span><span>{</span>
            <span>let</span> fuel<span>:</span> <span>String</span> <span>=</span> fuel<span>.</span><span>expect</span><span><span>(</span><span><span>&#34;</span>Car must have fuel<span>&#34;</span></span></span><span><span>)</span></span><span>;</span>
            <span>VehicleType<span>::</span></span>Car <span><span>{</span>
                fuel<span>:</span> <span>fuel_from_str</span><span><span>(</span><span>&amp;</span>fuel</span><span><span>)</span></span><span>,</span>
                max_speed_kph<span>:</span> max_speed_kph<span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>speed</span><span>|</span></span> </span><span>speed<span>.</span><span>try_into</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span> </span></span><span><span>)</span></span><span>,</span>
            </span><span><span>}</span></span>
        </span><span><span>}</span></span><span>,</span>
        <span><span>&#34;</span>Bicycle<span>&#34;</span></span> <span>=&gt;</span> <span>VehicleType<span>::</span></span>Bicycle<span>,</span>
        unknown <span>=&gt;</span> <span>panic!</span><span><span>(</span><span><span>&#34;</span>Unknown vehicle type: {unknown}<span>&#34;</span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span><span>;</span>
    Vehicle <span><span>{</span> id<span>,</span> vehicle_type </span><span><span>}</span></span>
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>fuel_from_str</span></span><span><span><span>(</span><span>s</span><span>:</span> <span>&amp;</span><span>str</span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> Fuel</span> </span><span><span><span>{</span>
    <span>match</span> s <span><span>{</span>
        <span><span>&#34;</span>Electricity<span>&#34;</span></span> <span>=&gt;</span> <span>Fuel<span>::</span></span>Electricity<span>,</span>
        <span><span>&#34;</span>Diesel<span>&#34;</span></span> <span>=&gt;</span> <span>Fuel<span>::</span></span>Diesel<span>,</span>
        unknown_fuel <span>=&gt;</span> <span>panic!</span><span><span>(</span><span><span>&#34;</span>Unknown fuel: {unknown_fuel}<span>&#34;</span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span>
</span><span><span>}</span></span></span>

<span><span><span>fn</span> </span><span>fuel_to_str</span></span><span><span><span>(</span><span>fuel</span><span>:</span> Fuel</span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>&amp;</span><span>&#39;static</span> <span>str</span></span> </span><span><span><span>{</span>
    <span>match</span> fuel <span><span>{</span>
        <span>Fuel<span>::</span></span>Electricity <span>=&gt;</span> <span><span>&#34;</span>Electricity<span>&#34;</span></span><span>,</span>
        <span>Fuel<span>::</span></span>Diesel <span>=&gt;</span> <span><span>&#34;</span>Diesel<span>&#34;</span></span><span>,</span>
    </span><span><span>}</span></span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>Finally, let&#39;s implement a unit test to verify conversion from <code>Vehicle</code> to <code>VehicleRecord</code> and vice versa. If everything works correctly, we should
get the same model back:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>test</span><span>]</span></span>
<span><span><span>fn</span> </span><span>test_vehicle_record_mapping</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span>let</span> vehicle <span>=</span> Vehicle <span><span>{</span>
        id<span>:</span> VehicleId<span><span>(</span><span>123</span></span><span><span>)</span></span><span>,</span>
        vehicle_type<span>:</span> <span>VehicleType<span>::</span></span>Car <span><span>{</span>
            fuel<span>:</span> <span>Fuel<span>::</span></span>Electricity<span>,</span>
            max_speed_kph<span>:</span> <span>None</span><span>,</span>
        </span><span><span>}</span></span>
    </span><span><span>}</span></span><span>;</span>
    <span>let</span> record <span>=</span> <span>vehicle_to_record</span><span><span>(</span>vehicle<span>.</span><span>clone</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
    <span>let</span> same_vehicle <span>=</span> <span>record_to_vehicle</span><span><span>(</span>record</span><span><span>)</span></span><span>;</span>
    <span>assert_eq!</span><span><span>(</span>vehicle<span>,</span> same_vehicle</span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>Even though the test is correct, it&#39;s not exhaustive and the following cases are missing:</p>
<ul>
<li><code>fuel</code> is <code>Fuel::Diesel</code></li>
<li><code>max_speed_kph</code> is present</li>
<li><code>vehicle_type</code> is <code>Vehicle::Bicycle</code></li>
</ul>
<p>Shall we <del>copy-paste</del> write 2-3 tests more? Or just pretend it&#39;s sufficient?</p>
<h2 id="welcome-arbitrary">Welcome Arbitrary</h2>
<p>Let&#39;s introduce <a rel="noopener" target="_blank" href="https://crates.io/crates/arbitrary">arbitrary</a> to the project:</p>
<pre><code><span>cargo add arbitrary --features=derive
</span></code></pre>
<p>We also want to derive <code>Arbitrary</code> trait for our models:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>use</span> <span>arbitrary<span>::</span></span>Arbitrary<span>;</span>

<span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone<span>,</span> Arbitrary</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>struct</span> </span><span><span>Vehicle</span> </span><span><span><span>{</span>
    <span>id</span><span>:</span> VehicleId,
    <span>vehicle_type</span><span>:</span> VehicleType,
</span><span><span>}</span></span></span>
</span></code></pre>
<p>Now we can play with it a little to get a better feeling how it works:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span><span>fn</span> </span><span>main</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
        <span>let</span> bytes<span>:</span> <span><span>[</span><span>u8</span><span>;</span> <span>16</span><span>]</span></span> <span>=</span> <span><span>[</span><span>255</span><span>,</span> <span>40</span><span>,</span> <span>179</span><span>,</span> <span>24</span><span>,</span> <span>184</span><span>,</span> <span>113</span><span>,</span> <span>24</span><span>,</span> <span>73</span><span>,</span> <span>143</span><span>,</span> <span>51</span><span>,</span> <span>152</span><span>,</span> <span>121</span><span>,</span> <span>133</span><span>,</span> <span>143</span><span>,</span> <span>14</span><span>,</span> <span>59</span><span>]</span></span><span>;</span>
    <span>let</span> <span>mut</span> u <span>=</span> <span>arbitrary<span>::</span></span><span>Unstructured<span>::</span></span>new<span><span>(</span><span>&amp;</span>bytes</span><span><span>)</span></span><span>;</span>
    <span>let</span> vehicle <span>=</span> <span>Vehicle<span>::</span></span>arbitrary<span><span>(</span><span>&amp;</span><span>mut</span> u</span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span><span>;</span>
    <span>dbg!</span><span><span>(</span><span>&amp;</span>vehicle</span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>Output:</p>
<pre><code><span>&amp;vehicle = Vehicle {
    id: VehicleId(
        414394623,
    ),
    vehicle_type: Car {
        fuel: Electricity,
        max_speed_kph: Some(
            3870351,
        ),
    },
}
</span></code></pre>
<p>Is it not wonder? Out of <del>nothing</del> random bytes we have obtained a structured vehicle!
If we can keep those bytes coming, we can generate an endless amount of vehicles to feed the unit test.</p>
<h2 id="rewriting-the-test-with-arbitrary-and-arbtest">Rewriting the test with Arbitrary and arbtest</h2>
<p>If we want to use <code>Arbitrary</code> for property-based testing, a tiny library like <a rel="noopener" target="_blank" href="https://crates.io/crates/arbtest">arbtest</a> comes handy.
It&#39;s a bit raw but it gets the job done. Let&#39;s rewrite our test:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>test</span><span>]</span></span>
<span><span><span>fn</span> </span><span>test_vehicle_record_mapping</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>prop</span></span><span><span><span>(</span><span>u</span><span>:</span> <span>&amp;</span><span>mut</span> <span>arbitrary<span>::</span></span><span>Unstructured<span>&lt;</span>&#39;<span>_</span><span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>arbitrary<span>::</span></span><span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>let</span> vehicle <span>=</span> <span>Vehicle<span>::</span></span>arbitrary<span><span>(</span>u</span><span><span>)</span></span><span>?</span><span>;</span>
        <span>let</span> record <span>=</span> <span>vehicle_to_record</span><span><span>(</span>vehicle<span>.</span><span>clone</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
        <span>let</span> same_vehicle <span>=</span> <span>record_to_vehicle</span><span><span>(</span>record</span><span><span>)</span></span><span>;</span>
        <span>assert_eq!</span><span><span>(</span>vehicle<span>,</span> same_vehicle</span><span><span>)</span></span><span>;</span>
        <span>Ok</span><span><span>(</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
    <span>arbtest<span>::</span></span>builder<span><span>(</span></span><span><span>)</span></span><span>.</span><span>run</span><span><span>(</span>prop</span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>It&#39;s similar to the old test, but with a few innovations:
the assertions are now within <code>prop</code> function.
The <code>prop</code> function receives <code>Unstructured</code>, which is used to obtain an arbitrary vehicle.
The responsibility of the builder is to generate <code>Unstructured</code> and feed it to <code>prop()</code>.
In fact, <code>prop</code> is invoked multiple times within a single test and by default, the arbtest runs it for 200ms.</p>
<p>OK, let&#39;s run the tests and see if it works:</p>
<pre><code><span>failures:

---- test_vehicle_record_mapping stdout ----
thread &#39;test_vehicle_record_mapping&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: TryFromIntError(())&#39;, src/main.rs:49:60
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


arb_test failed!
    Seed: 0x25dc50a20000003e
</span></code></pre>
<p>Oh no! Our bullet-proof code panics on line 49 within <code>vehicle_to_record()</code>:</p>
<pre data-lang="rust"><code data-lang="rust"><span>max_speed_kph<span>.</span><span>map</span><span><span>(</span><span><span><span>|</span></span></span><span><span><span>speed</span><span>|</span></span> </span><span>speed<span>.</span><span>try_into</span><span><span>(</span></span><span><span>)</span></span><span>.</span><span>unwrap</span><span><span>(</span></span><span><span>)</span></span> </span></span><span><span>)</span></span>
</span></code></pre>
<p><code>arbtest</code> also printed the seed <code>0x25dc50a20000003e</code>. With this seed, we can deterministically reproduce the failure
and fix the test.</p>
<p>Let&#39;s slightly tweak our test:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>test</span><span>]</span></span>
<span><span><span>fn</span> </span><span>test_vehicle_record_mapping</span></span><span><span><span>(</span></span><span><span><span>)</span></span></span></span><span> </span><span><span><span>{</span>
    <span><span><span>fn</span> </span><span>prop</span></span><span><span><span>(</span><span>u</span><span>:</span> <span>&amp;</span><span>mut</span> <span>arbitrary<span>::</span></span><span>Unstructured<span>&lt;</span>&#39;<span>_</span><span>&gt;</span></span></span><span><span><span>)</span></span></span></span><span> <span><span>-&gt;</span> <span>arbitrary<span>::</span></span><span><span>Result</span><span>&lt;</span><span>(</span><span>)</span><span>&gt;</span></span></span> </span><span><span><span>{</span>
        <span>let</span> vehicle <span>=</span> <span>Vehicle<span>::</span></span>arbitrary<span><span>(</span>u</span><span><span>)</span></span><span>?</span><span>;</span>
        <span>dbg!</span><span><span>(</span><span>&amp;</span>vehicle</span><span><span>)</span></span><span>;</span>
        <span>let</span> record <span>=</span> <span>vehicle_to_record</span><span><span>(</span>vehicle<span>.</span><span>clone</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span><span>;</span>
        <span>let</span> same_vehicle <span>=</span> <span>record_to_vehicle</span><span><span>(</span>record</span><span><span>)</span></span><span>;</span>
        <span>assert_eq!</span><span><span>(</span>vehicle<span>,</span> same_vehicle</span><span><span>)</span></span><span>;</span>
        <span>Ok</span><span><span>(</span><span><span>(</span></span><span><span>)</span></span></span><span><span>)</span></span>
    </span><span><span>}</span></span></span>
    <span>arbtest<span>::</span></span>builder<span><span>(</span></span><span><span>)</span></span><span>.</span><span>seed</span><span><span>(</span><span>0x25dc50a20000003e</span></span><span><span>)</span></span><span>.</span><span>run</span><span><span>(</span>prop</span><span><span>)</span></span><span>;</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>We added <code>dbg!(&amp;vehicle);</code> to see which vehicle exactly causes problems and the builder is now initialized with <code>.seed(0x25dc50a20000003e)</code>, that allows us
to reproduce the same failure. When we run it again, we can also see the vehicle details:</p>
<pre><code><span>&amp;vehicle = Vehicle {
    id: VehicleId(
        1455468422,
    ),
    vehicle_type: Car {
        fuel: Diesel,
        max_speed_kph: Some(
            2207965846,
        ),
    },
}
</span></code></pre>
<p>Having all that information, the failure becomes now very plain to explain:
we use <code>u32</code> for <code>max_speed_kph</code> in the domain model, but <code>i32</code> in the DB record.
And <code>2207965846</code> is above the maximum <code>i32</code> value (2^31-1).</p>
<p>So how do we fix it? We go to the product owner and ask a weird question.</p>
<p>&#34;Hey! Do we plan to expand our system to support tracking of spaceships with speeds over 65535 km/h?&#34;</p>
<p>&#34;Oh God, no.&#34;</p>
<p>&#34;Is there any possibility that we will have to support any other vehicles with speeds over 65535 km/h?&#34; - we continue.</p>
<p>&#34;Of course not! Our business is about the city&#39;s transportation network, which implies...&#34;</p>
<p>&#34;I know, I know, thank you. I just wanted to double-check.&#34;</p>
<p>So that means we can replace <code>u32</code> with <code>u16</code> and we&#39;re fine:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span><span>#</span><span>[</span><span>derive</span><span><span><span>(</span></span></span><span><span>Debug<span>,</span> PartialEq<span>,</span> Clone<span>,</span> Arbitrary</span></span><span><span><span>)</span></span></span><span>]</span></span>
<span><span>enum</span> <span>VehicleType</span> <span><span>{</span>
    Car <span><span>{</span>
        fuel<span>:</span> Fuel<span>,</span>
        max_speed_kph<span>:</span> <span><span>Option</span><span>&lt;</span><span>u16</span><span>&gt;</span></span><span>,</span>
    </span><span><span>}</span></span><span>,</span>
    Bicycle<span>,</span>
</span><span><span>}</span></span></span>
</span></code></pre>
<p>We run the tests and they pass.
To be extra sure we can set the time budget to 1 minute and run it locally once:</p>
<pre data-lang="rust"><code data-lang="rust"><span><span>arbtest<span>::</span></span>builder<span><span>(</span></span><span><span>)</span></span><span>.</span><span>budget_ms</span><span><span>(</span><span>60_000</span></span><span><span>)</span></span><span>.</span><span>run</span><span><span>(</span>prop</span><span><span>)</span></span><span>;</span>
</span></code></pre>
<p>Still no failure, so we&#39;re good to go.</p>
<h2 id="conclusions">Conclusions</h2>
<p>As it was shown in this article, property-based testing can be very handy for testing symmetrical data conversions.
It has number of advantages over classical unit tests:</p>
<ul>
<li><strong>Much less test code needs to be written</strong>. Especially it becomes a noticeable win, when you deal with much larger data structures.</li>
<li><strong>The test inputs are not biased</strong>, what is never the case when test inputs created by a human beings (aka developers).</li>
</ul>
<h2 id="p-s">P.S.</h2>
<p>In real production application, we&#39;d rather return errors, instead of just panicking in the conversions.</p>
<p>Someone may prefer implementing <code>From</code> traits instead of <code>vehicle_to_record()</code> and <code>record_to_vehicle()</code> functions. It&#39;s rather a question taste, but there 2 main reasons I did not go with <code>From</code>:</p>
<ul>
<li>I don&#39;t want <code>From</code> to panic</li>
<li>I don&#39;t want the conversions to be exposed outside of the infrastructure layer.</li>
</ul>
<p>Instead of implementing <code>fuel_from_str</code> and <code>fuel_to_str</code>, we could derive <code>FromStr</code> and <code>Dislpay</code>, using <a rel="noopener" target="_blank" href="https://crates.io/crates/strum">strum</a> crate.</p>
<p>If you&#39;re confused about why we need both <code>Vehicle</code> and <code>VehicleRecord</code>,
I&#39;d recommend reading <a rel="noopener" target="_blank" href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">Domain Modeling Made Functional by Scott Wlaschin</a>.
This is out of scope for this article, but long story short: we want to keep the domain model <code>Vehicle</code> as expressive as possible,
so it&#39;s easy to work with it in the domain layer.
Whilst <code>VehicleRecord</code> is easy to persist in a relational database.</p>
<h2 id="links">Links</h2>
<ul>
<li><a rel="noopener" target="_blank" href="https://www.reddit.com/r/rust/comments/yi3y33/propertybased_testing_in_rust_with_arbitrary/">Discussion on Reddit</a></li>
<li><a rel="noopener" target="_blank" href="https://crates.io/crates/arbitrary">arbitrary crate</a></li>
<li><a rel="noopener" target="_blank" href="https://crates.io/crates/arbitrary">arbtest crate</a></li>
<li><a rel="noopener" target="_blank" href="https://www.tedinski.com/2018/12/11/fuzzing-and-property-testing.html">Fuzzing vs property testing by Ted Kaminski</a></li>
<li><a rel="noopener" target="_blank" href="https://pragprog.com/titles/swdddf/domain-modeling-made-functional/">Domain Modeling Made Functional by Scott Wlaschin</a></li>
</ul>

<p><b><a href="#">Back to top</a></b></p>
    </article></div>
  </body>
</html>
